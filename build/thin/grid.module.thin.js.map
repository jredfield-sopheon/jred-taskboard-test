{
  "version": 3,
  "sources": ["../../../Grid/lib/Grid/column/ActionColumn.js", "../../../Grid/lib/Grid/column/AggregateColumn.js", "../../../Grid/lib/Grid/column/PercentColumn.js", "../../../Grid/lib/Grid/column/RatingColumn.js", "../../../Grid/lib/Grid/column/TemplateColumn.js", "../../../Grid/lib/Grid/column/TimeColumn.js", "../../../Grid/lib/Grid/feature/CellCopyPaste.js", "../../../Grid/lib/Grid/feature/CellTooltip.js", "../../../Grid/lib/Grid/feature/ColumnRename.js", "../../../Grid/lib/Grid/feature/FillHandle.js", "../../../Grid/lib/Grid/feature/MergeCells.js", "../../../Grid/lib/Grid/feature/QuickFind.js", "../../../Grid/lib/Grid/feature/RowExpander.js", "../../../Grid/lib/Grid/feature/Search.js", "../../../Grid/lib/Grid/feature/StickyCells.js", "../../../Grid/lib/Grid/feature/experimental/FileDrop.js", "../../../Grid/lib/Grid/widget/GroupBar.js", "../../../Grid/lib/Grid/widget/TreeCombo.js", "../../../Grid/bundle/entry.thin.js"],
  "sourcesContent": ["import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\n/**\n * @module Grid/column/ActionColumn\n */\n/**\n * Config object for an action in an ActionColumn.\n * @typedef {Object} ActionConfig\n * @property {String} cls CSS Class for action icon\n * @property {Function|String|TooltipConfig} tooltip Tooltip text, or a config object which can reconfigure the shared\n * tooltip by setting boolean, numeric and string config values, or a function to return the tooltip text, passed the\n * row's `record`\n * @property {Function|Boolean} visible Boolean to define the action icon visibility or a callback function, passed the\n * row's `record`, to change it dynamically\n * @property {Function} onClick Callback to handle click action item event, passed the row's `record`\n * @property {Boolean} showForGroup Set to true to have action icon visible in group headers only when using the `group`\n * feature\n * @property {Function|String} renderer A render function, or the name of a function in the Grid's ownership tree used\n * to define the action element. Passed the row's `record`, expected to return an HTML string or a DOM config object.\n * **Note**: when specified, the `cls` action config is ignored. Make sure you add an action icon manually, for example:\n * ```javascript\n * {\n *      type    : 'action',\n *      text    : 'Increase amount',\n *      actions : [{\n *          cls      : 'b-fa b-fa-plus', // this line will be ignored\n *          renderer : ({ record }) => '<i class=\"b-action-item b-fa b-fa-plus\"></i> ' + record.name,\n *          onClick  : ({ record }) => {}\n *      }]\n * }\n * ```\n *\n * or\n *\n * ```javascript\n * {\n *      type    : 'action',\n *      text    : 'Increase amount',\n *      actions : [{\n *          cls      : 'b-fa b-fa-plus', // this line will be ignored\n *          renderer : 'up.renderAction' // Defined on the Grid\n *          onClick  : ({ record }) => {}\n *      }]\n * }\n * ```\n */\n/**\n * A column that displays actions as clickable icons in the cell.\n *\n * {@inlineexample Grid/column/ActionColumn.js}\n *\n * ```javascript\n * new TreeGrid({\n *     appendTo : document.body,\n *     columns  : [{\n *         type    : 'action',\n *         text    : 'Increase amount',\n *         actions : [{\n *             cls      : 'b-fa b-fa-plus',\n *             renderer : ({ action, record }) => `<i class=\"b-action-item ${action.cls} b-${record.enabled ? \"green\" : \"red\"}-class\"></i>`,\n *             visible  : ({ record }) => record.canAdd,\n *             tooltip  : ({ record }) => `<p class=\"b-nicer-than-default\">Add to ${record.name}</p>`,\n *             onClick  : ({ record }) => console.log(`Adding ${record.name}`)\n *         }, {\n *             cls     : 'b-fa b-fa-pencil',\n *             tooltip : 'Edit note',\n *             onClick : ({ record }) => console.log(`Editing ${record.name}`)\n *         }]\n *     }]\n * });\n * ```\n *\n * Actions may be placed in {@link Grid/feature/Group} headers, by setting `action.showForGroup` to `true`. Those\n * actions will not be shown on normal rows.\n *\n * @extends Grid/column/Column\n * @classtype action\n * @column\n */\nexport default class ActionColumn extends Column {\n    static type = 'action';\n    static fields = [\n        /**\n         * An array of action config objects, see {@link #typedef-ActionConfig} for details.\n         *\n         * ```javascript\n         * new Grid({\n         *     columns  : [{\n         *         type    : 'action',\n         *         text    : 'Actions',\n         *         actions : [{\n         *             cls      : 'b-fa b-fa-plus',\n         *             visible  : ({ record }) => record.canAdd,\n         *             onClick  : ({ record }) => console.log(`Adding ${record.name}`)\n         *         }, {\n         *             cls     : 'b-fa b-fa-pencil',\n         *             tooltip : 'Edit note',\n         *             onClick : ({ record }) => console.log(`Editing ${record.name}`)\n         *         }]\n         *     }]\n         * });\n         * ```\n         *\n         * @config {ActionConfig[]} actions List of action configs\n         * @category Common\n         */\n        { name : 'actions', type : 'array' },\n        /**\n         * Set true to hide disable actions in this column if the grid is {@link Core.widget.Widget#config-readOnly}\n         * @config {Boolean} disableIfGridReadOnly\n         * @default\n         * @category Common\n         */\n        { name : 'disableIfGridReadOnly', defaultValue : false }\n    ];\n    static defaults = {\n        /**\n         * Filtering by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} filterable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        filterable : false,\n        /**\n         * Grouping by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} groupable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        groupable : false,\n        /**\n         * Sorting by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} sortable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        sortable : false,\n        /**\n         * Editor for action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} editor\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        editor : false,\n        /**\n         * Searching by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} searchable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        searchable : false,\n        /**\n         * By default, for action column this flag is switched to `true`, because the content of this column is always HTML.\n         * @config {Boolean} htmlEncode\n         * @default false\n         * @category Misc\n         * @hide\n         */\n        htmlEncode : false,\n        /**\n         * Set to `true` to allow the column to being drag-resized when the ColumnResize plugin is enabled.\n         * @config {Boolean} resizable\n         * @default false\n         * @category Interaction\n         */\n        resizable : false,\n        /**\n         * Column minimal width. If value is Number then minimal width is in pixels.\n         * @config {Number|String} minWidth\n         * @default 30\n         * @category Layout\n         */\n        minWidth : 30\n    };\n    get groupHeaderReserved() {\n        return true;\n    }\n    construct(config, store) {\n        const me = this;\n        super.construct(...arguments);\n        // use auto-size only as default behaviour\n        if (!config.width && !config.flex) {\n            me.grid.ion({ paint : 'updateAutoWidth', thisObj : me });\n        }\n        if (me.disableIfGridReadOnly) {\n            me.grid.element.classList.add('b-actioncolumn-readonly');\n        }\n        // If column is cloned, renderer is already set up\n        if (me.renderer !== me.internalRenderer) {\n            me.externalRenderer = me.renderer;\n            me.renderer = me.internalRenderer;\n        }\n    }\n    /**\n     * Renderer that displays action icon(s) in the cell.\n     * @private\n     */\n    internalRenderer({ grid, column, record, callExternalRenderer = true }) {\n        const\n            inGroupTitle = record && ('groupRowFor' in record.meta),\n            { subGrid }  = column;\n        if (callExternalRenderer) {\n            this.externalRenderer?.(...arguments);\n        }\n        return {\n            className : { 'b-action-ct' : 1 },\n            children  : column.actions?.map((actionConfig, index) => {\n                if ('visible' in actionConfig) {\n                    if ((typeof actionConfig.visible === 'function') && actionConfig.visible({ record }) === false) {\n                        return '';\n                    }\n                    if (actionConfig.visible === false) {\n                        return '';\n                    }\n                }\n                // check if an action allowed to be shown in case of using grouping\n                if ((inGroupTitle && !actionConfig.showForGroup) || (!inGroupTitle && actionConfig.showForGroup)) {\n                    return '';\n                }\n                const\n                    {\n                        tooltip,\n                        renderer\n                    }    = actionConfig,\n                    btip = (typeof tooltip === 'function' || tooltip?.startsWith?.('up.')) ? subGrid.callback(tooltip, subGrid, [{ record }]) : tooltip || '';\n                // handle custom renderer if it is specified\n                if (renderer) {\n                    const customRendererData = subGrid.callback(renderer, subGrid, [{\n                        index,\n                        record,\n                        column,\n                        tooltip : btip,\n                        action  : actionConfig\n                    }]);\n                    // take of set data-index to make onClick handler work stable\n                    if (typeof customRendererData === 'string') {\n                        return {\n                            tag     : 'span',\n                            dataset : {\n                                ...Tooltip.encodeConfig(btip),\n                                index\n                            },\n                            html : customRendererData\n                        };\n                    }\n                    else {\n                        customRendererData.dataset = customRendererData.dataset || {};\n                        customRendererData.dataset.index = index;\n                        return customRendererData;\n                    }\n                }\n                else {\n                    return {\n                        tag     : 'button',\n                        dataset : {\n                            ...Tooltip.encodeConfig(btip),\n                            index\n                        },\n                        'aria-label' : btip,\n                        className    : {\n                            'b-tool'           : 1,\n                            'b-action-item'    : 1,\n                            [actionConfig.cls] : actionConfig.cls\n                        }\n                    };\n                }\n            })\n        };\n    }\n    /**\n     * Handle icon click and call action handler.\n     * @private\n     */\n    onCellClick({ column, record, target }) {\n        if (column !== this || !target.classList.contains('b-action-item')) {\n            return;\n        }\n        let actionIndex = target.dataset.index;\n        // index may be set in a parent node if user used an html string in his custom renderer\n        // and we take care to set this property to support onClick handler\n        if (!actionIndex) {\n            actionIndex = target.parentElement.dataset && target.parentElement.dataset.index;\n        }\n        const\n            action        = column.actions?.[actionIndex],\n            actionHandler = action?.onClick;\n        if (actionHandler) {\n            this.callback(actionHandler, column, [{ record, action, target }]);\n        }\n    }\n    /**\n     * Update width for actions column to fit content.\n     * @private\n     */\n    updateAutoWidth() {\n        const\n            me           = this,\n            groupActions = [],\n            {\n                actions : oldActions\n            }            = me;\n        // header may be disabled, in that case we won't be able to calculate the width properly\n        if (!me.element) {\n            return;\n        }\n        const actions = me.actions = [];\n        // collect group and non group actions to check length later\n        oldActions?.forEach(actionOriginal => {\n            const action = { ...actionOriginal };\n            // remove possible visibility condition to make sure an action will exists in test HTML\n            delete action.visible;\n            // group actions shows in different row and never together with non group\n            if (action.showForGroup) {\n                delete action.showForGroup;\n                groupActions.push(action);\n            }\n            else {\n                actions.push(action);\n            }\n        });\n        // use longest actions length to calculate column width\n        if (groupActions.length > actions.length) {\n            me._actions = groupActions;\n        }\n        const actionsHtml = DomHelper.createElement(me.internalRenderer({ column : me, callExternalRenderer : false })).outerHTML;\n        me.width = DomHelper.measureText(actionsHtml, me.element, true, me.element.parentElement);\n        me.actions = oldActions;\n    }\n}\nColumnStore.registerColumnType(ActionColumn);\nActionColumn.exposeProperties();\nActionColumn._$name = 'ActionColumn';", "import ColumnStore from '../data/ColumnStore.js';\nimport NumberColumn from './NumberColumn.js';\n/**\n * @module Grid/column/AggregateColumn\n */\n/**\n * A column, which, when used as part of a {@link Grid.view.TreeGrid}, aggregates the values of this column's descendants using\n * a configured function which defaults to `sum`. The aggregate value is re-calculated after any change to the data,\n * and if you want aggregate values to be change-tracked, please set {@link #config-includeParentInChangeSet} to true.\n *\n * Default editor depends on the data field type. If it is a number, default editor is a {@link Core/widget/NumberField}.\n * Otherwise Default editor is a {@link Core/widget/TextField}.\n *\n * ```javascript\n * const grid = new TreeGrid({\n *     // Custom aggregation handler.\n *     // For test purposes, this just does \"sum\"\n *     myAggregator(...values) {\n *         let result = 0;\n *\n *         for (let i = 0, { length } = values; i < length; i++) {\n *             result += parseInt(args[i], 10);\n *         }\n *         return result;\n *     },\n *     columns : [\n *         { field : 'name', text : 'Name' },\n *\n *         // Will sum the ages of leaf nodes. This is the default.\n *         { type : 'aggregate', field : 'age', text : 'Age', renderer : ({ value }) => `<b>${value}<b>` },\n *\n *         // Will use AggregateColumn's built-in avg of scores of leaf nodes\n *         { type : 'aggregate', field : 'score', text : 'Score', function : 'avg' },\n *\n *         // Will use the grid's myAggregator function\n *         { type : 'aggregate', field : 'revenue', text : 'Revenue', function : 'up.myAggregator' },\n *     ]\n * });\n * ```\n *\n * @extends Grid/column/NumberColumn\n * @classtype aggregate\n * @column\n */\nexport default class AggregateColumn extends NumberColumn {\n    //region Config\n    static type = 'aggregate';\n    static fields = [\n        'function',\n        'includeParentInChangeSet'\n    ];\n    static get defaults() {\n        return {\n            /**\n             * Math Function name, or function name prepended by `\"up.\"` that is resolvable in an\n             * ancestor component (such as the owning Grid, or a height Container), or a function to\n             * use to aggregate child record values for this column, or a function.\n             *\n             * This Column is provided with a `sum` and `avg` function. The default function is `sum`\n             * which is used for the aggregation.\n             *\n             * The function is passed a set of child node values, each value in a separate argument\n             * and should return a single value based upon the value set passed.\n             * @config {'sum'|'avg'|'min'|'max'|Function}\n             * @param {Core.data.Model[]} records Records for aggregation\n             * @returns {*} Aggregated value\n             * @category Common\n             */\n            function : 'sum',\n            /**\n             * Set to `true` to include changes to parent (aggregate) rows in the store's modification tracking.\n             * @config {Boolean} includeParentInChangeSet\n             * @category Common\n             */\n            includeParentInChangeSet : false\n        };\n    }\n    construct(data, columnStore) {\n        const me = this;\n        me.configuredAlign = 'align' in data;\n        me.configuredEditor = 'editor' in data;\n        super.construct(...arguments);\n        const { grid } = columnStore;\n        // 'sum' is reserved by Summary feature, so we use a different name\n        if (me.function === 'sum') {\n            me.function = 'sumChildren';\n        }\n        if (grid) {\n            me.store = grid.store;\n        }\n    }\n    set store(store) {\n        const\n            me             = this,\n            storeListeners = {\n                update  : 'onRecordUpdate',\n                thisObj : me,\n                prio    : 1000\n            },\n            oldStore = me._store;\n        if (store !== oldStore) {\n            if (oldStore) {\n                oldStore.un(storeListeners);\n            }\n            me._store = store;\n            const\n                { modelClass } = store,\n                field = modelClass.fieldMap[me.field];\n            // It's *likely*, but not certain that this will be used for a numeric field.\n            // Use numeric defaults unless configured otherwise if so.\n            if (field && field.type === 'number') {\n                if (!me.configuredAlign) {\n                    me.align = 'end';\n                }\n                if (!me.configuredEditor) {\n                    me.editor = 'number';\n                }\n            }\n            store.ion(storeListeners);\n        }\n    }\n    canEdit(record) {\n        return record.isLeaf;\n    }\n    get store() {\n        return this._store;\n    }\n    sumChildren(...args) {\n        let result = 0;\n        for (let i = 0, { length } = args; i < length; i++) {\n            result += parseFloat(args[i] || 0, 10);\n        }\n        return result;\n    }\n    avg(...args) {\n        let result = 0;\n        const { length } = args;\n        for (let i = 0; i < length; i++) {\n            result += parseFloat(args[i] || 0, 10);\n        }\n        return result / length;\n    }\n    onRecordUpdate({ record, changes }) {\n        const\n            me = this,\n            { rowManager } = me.grid;\n        if (me.field in changes) {\n            if (record.isLeaf) {\n                record.bubble(rec => {\n                    const row = rowManager.getRowFor(rec);\n                    if (row) {\n                        const cellElement = row.getCell(me.field);\n                        if (cellElement) {\n                            row.renderCell(cellElement);\n                        }\n                    }\n                }, true);\n            }\n        }\n    }\n    getRawValue(record) {\n        let value;\n        const\n            me        = this,\n            { field } = me;\n        if (record.children?.length) {\n            const\n                fn       = me.function,\n                isMathFn = typeof fn === 'string' && typeof Math[fn] === 'function',\n                {\n                    handler,\n                    thisObj\n                } = isMathFn ? {\n                    handler : Math[fn],\n                    thisObj : Math\n                } : me.resolveCallback(fn);\n            // Gather all child node values before passing them to the aggregator function.\n            value = handler.apply(thisObj, record.children.map(r => me.getRawValue(r)));\n            if (me.includeParentInChangeSet) {\n                record.set(field, value, true);\n            }\n            else {\n                record.setData(field, value);\n            }\n        }\n        else {\n            value = record.getValue(field);\n        }\n        return value;\n    }\n    canFillValue() {\n        return false;\n    }\n}\nColumnStore.registerColumnType(AggregateColumn, true);\nAggregateColumn.exposeProperties();\nAggregateColumn._$name = 'AggregateColumn';", "import NumberColumn from './NumberColumn.js';\nimport ColumnStore from '../data/ColumnStore.js';\n/**\n * @module Grid/column/PercentColumn\n */\n/**\n * A column that display a basic progress bar.\n *\n * {@inlineexample Grid/column/PercentColumn.js}\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         { type: 'percent', text: 'Progress', data: 'progress' }\n *     ]\n * });\n * ```\n *\n * Default editor is a {@link Core.widget.NumberField NumberField}.\n *\n * @extends Grid/column/NumberColumn\n * @classtype percent\n * @column\n */\nexport default class PercentColumn extends NumberColumn {\n    static type = 'percent';\n    // Type to use when auto adding field\n    static fieldType = 'number';\n    static fields = ['showValue', 'lowThreshold'];\n    static get defaults() {\n        return {\n            min : 0,\n            max : 100,\n            /**\n             * Set to `true` to render the number value inside the bar, for example `'15%'`.\n             * @config {Boolean}\n             * @default\n             * @category Rendering\n             */\n            showValue : false,\n            /**\n             * When below this percentage the bar will have `b-low` CSS class added. By default it turns the bar red.\n             * @config {Number}\n             * @default\n             * @category Rendering\n             */\n            lowThreshold : 20,\n            htmlEncode      : false,\n            searchable      : false,\n            summaryRenderer : ({ sum }) => `${sum}%`,\n            fitMode         : false\n        };\n    }\n    constructor(config, store) {\n        super(...arguments);\n        this.internalCellCls = 'b-percent-bar-cell';\n    }\n    /**\n     * Renderer that displays a progress bar in the cell. If you create a custom renderer, and want to include the\n     * default markup you can call `defaultRenderer` from it.\n     *\n     * ```javascript\n     * new Grid({\n     *     columns: [\n     *         {\n     *             type: 'percent',\n     *             text : 'Percent',\n     *             field : 'percent',\n     *             renderer({ value }) {\n     *                 const domConfig = this.defaultRenderer();\n     *\n     *                 if (value > 100) {\n     *                     domConfig.className = b-percent-bar-outer over-allocated';\n     *                 }\n     *\n     *                 return domConfig;\n     *             }\n     *         }\n     *     ]\n     * }\n     * ```\n     *\n     * @param {Object} rendererData The data object passed to the renderer\n     * @param {Number} rendererData.value The value to display\n     * @returns {DomConfig} DomConfig object representing the default markup for the cells content\n     */\n    defaultRenderer({ value }) {\n        value = value || 0;\n        return {\n            className       : 'b-percent-bar-outer',\n            role            : 'progressbar',\n            'aria-valuemin' : 0,\n            'aria-valuemax' : 100,\n            'aria-valuenow' : value,\n            'aria-label'    : value + '%',\n            tabIndex        : 0,\n            children        : [\n                {\n                    tag       : 'div',\n                    className : {\n                        'b-percent-bar' : 1,\n                        'b-zero'        : value === 0,\n                        'b-low'         : value < this.lowThreshold\n                    },\n                    style : {\n                        width : value + '%'\n                    },\n                    children : [\n                        this.showValue ? {\n                            tag  : 'span',\n                            text : value + '%'\n                        } : undefined\n                    ]\n                }\n            ]\n        };\n    }\n    // Null implementation because the column width drives the width of its content.\n    // So the concept of sizing to content is invalid here.\n    resizeToFitContent() {}\n}\nPercentColumn.sum = 'average';\nColumnStore.registerColumnType(PercentColumn, true);\nPercentColumn._$name = 'PercentColumn';", "import NumberColumn from './NumberColumn.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\n/**\n * @module Grid/column/RatingColumn\n */\n/**\n * A column that displays a star rating. Click a start to set a value, shift+click to unset a single start from the end.\n * Clicking the first and only star toggles it.\n *\n * This column uses a custom widget as its editor, and it is not intended to be changed.\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         { type: 'rating', max : 10, field: 'rating' }\n *     ]\n * });\n * ```\n *\n * {@inlineexample Grid/column/RatingColumn.js}\n *\n * @extends Grid/column/NumberColumn\n * @classtype rating\n * @column\n */\nexport default class RatingColumn extends NumberColumn {\n    static $name = 'RatingColumn';\n    static type = 'rating';\n    // Type to use when auto adding field\n    static fieldType = 'number';\n    static fields = ['emptyIcon', 'filledIcon', 'editable'];\n    static get defaults() {\n        return {\n            min : 0,\n            max : 5,\n            /**\n             * The empty rating icon to show\n             * @config {String}\n             * @category Rendering\n             */\n            emptyIcon : 'b-icon b-icon-star',\n            /**\n             * The filled rating icon to show\n             * @config {String}\n             * @category Rendering\n             */\n            filledIcon : 'b-icon b-icon-star',\n            /**\n             * Allow user to click an icon to change the value\n             * @config {Boolean}\n             * @category Interaction\n             */\n            editable : true,\n            filterType : 'number',\n            searchable : false,\n            width      : '11.2em',\n            htmlEncode : false,\n            minWidth   : '11.2em',\n            editor     : false,\n            fitMode    : 'value'\n        };\n    }\n    /**\n     * Renderer that displays a number of stars in the cell. Also adds CSS class 'b-rating-cell' to the cell.\n     * @private\n     */\n    renderer({ value }) {\n        return {\n            className : {\n                'b-rating-cell-inner' : 1,\n                'b-not-editable'      : !this.editable\n            },\n            children : ArrayHelper.populate(this.max, i => {\n                const filled = i < value;\n                return {\n                    tag       : 'i',\n                    className : {\n                        'b-rating-icon'                             : true,\n                        'b-filled'                                  : filled,\n                        'b-empty'                                   : !filled,\n                        [filled ? this.filledIcon : this.emptyIcon] : true\n                    }\n                };\n            })\n        };\n    }\n    onCellClick({ grid, column, record, target, event }) {\n        if (target.classList.contains('b-rating-icon') && !grid.readOnly && column.editable) {\n            let starIndex = [].indexOf.call(target.parentNode.childNodes, target);\n            if (target.classList.contains('b-filled') && (event.metaKey || event.shiftKey)) {\n                starIndex = starIndex - 1;\n            }\n            // Clicking first star when it is only one removes it\n            if (record.getValue(column.field) === 1 && starIndex === 0) {\n                starIndex = -1;\n            }\n            record.set(column.field, starIndex + 1);\n        }\n    }\n}\nColumnStore.registerColumnType(RatingColumn, true);\nRatingColumn.exposeProperties();\nRatingColumn._$name = 'RatingColumn';", "import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\n/**\n * @module Grid/column/TemplateColumn\n */\n/**\n * A column that uses a template for cell content. Any function can be used as template, and the function is passed { value, record, field } properties.\n * It should return a string which will be rendered in the cell.\n *\n * Default editor is a {@link Core.widget.TextField TextField}.\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         { type: 'template', field: 'age', template: ({value}) => `${value} years old` }\n *     ]\n * });\n * ```\n *\n * {@inlineexample Grid/column/TemplateColumn.js}\n *\n * @extends Grid/column/Column\n * @classtype template\n * @column\n */\nexport default class TemplateColumn extends Column {\n    static type = 'template';\n    static fields = [\n        /**\n         * Template function used to generate a value displayed in the cell. Called with arguments `{ value, record, field }`\n         *\n         * @config {Function} template\n         * @param {Object} data An object that contains data about the cell being rendered.\n         * @param {*} data.value The value (only present when you set a `field` on the column)\n         * @param {Core.data.Model} data.record The record representing the row\n         * @param {String} data.field The column field name\n         * @returns {DomConfig|String|null} String or DomConfig object representing the HTML markup\n         * @category Common\n         */\n        'template'\n    ];\n    static get defaults() {\n        return {\n            htmlEncode : false\n        };\n    }\n    constructor(config, store) {\n        super(...arguments);\n        const me = this;\n        if (!me.template) {\n            throw new Error('TemplateColumn needs a template');\n        }\n        if (typeof me.template !== 'function') {\n            throw new Error('TemplateColumn.template must be a function');\n        }\n    }\n    /**\n     * Renderer that uses a template for cell content.\n     * @private\n     */\n    renderer(renderData) {\n        // If it's a special row, such as a group row, we can't use the user's template\n        if (!renderData.record.isSpecialRow) {\n            return this.template({\n                value  : renderData.value,\n                record : renderData.record,\n                field  : this.field\n            });\n        }\n    }\n}\nColumnStore.registerColumnType(TemplateColumn, true);\nTemplateColumn.exposeProperties();\nTemplateColumn._$name = 'TemplateColumn';", "import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\n/**\n * @module Grid/column/TimeColumn\n */\n/**\n * A column that displays a time in the specified format (see {@link Core.helper.DateHelper#function-format-static} for formatting options).\n *\n * Default editor is a {@link Core.widget.TimeField TimeField}.\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *          { type: 'time', text: 'Start time', format: 'HH:mm:ss', data: 'start' }\n *     ]\n * });\n *```\n *\n * {@inlineexample Grid/column/TimeColumn.js}\n *\n * @extends Grid/column/Column\n * @classtype time\n * @column\n */\nexport default class TimeColumn extends Column {\n    //region Config\n    static type = 'time';\n    // Type to use when auto adding field\n    static fieldType = 'date';\n    static fields = ['format'];\n    static get defaults() {\n        return {\n            /**\n             * Time format\n             * @config {String}\n             * @category Common\n             * @default\n             */\n            format : 'LT',\n            minWidth : 140,\n            filterType : 'time'\n        };\n    }\n    //endregion\n    //region Display\n    /**\n     * Renderer that displays the time with the specified format. Also adds cls 'b-time-cell' to the cell.\n     * @private\n     */\n    defaultRenderer({ value }) {\n        return value ? this.formatValue(value) : '';\n    }\n    /**\n     * Group renderer that displays the time with the specified format.\n     * @private\n     */\n    groupRenderer({ cellElement, groupRowFor }) {\n        cellElement.innerHTML = this.formatValue(groupRowFor);\n    }\n    //endregion\n    //region Formatter\n    /**\n     * Used by both renderer and groupRenderer to do the actual formatting of the time\n     * @private\n     * @param value\n     * @returns {String}\n     */\n    formatValue(value) {\n        // Ideally we should be served a time, but if not make it easier for the user by parsing\n        if (typeof value === 'string') {\n            value = DateHelper.parse(value, this.format);\n        }\n        return DateHelper.format(value, this.format);\n    }\n    //endregion\n    //region Getters/Setters\n    /**\n     * Get/Set format for time displayed in cell and editor (see {@link Core.helper.DateHelper#function-format-static} for formatting options)\n     * @property {String}\n     */\n    set format(value) {\n        const { editor } = this;\n        this.set('format', value);\n        if (editor) {\n            editor.format = value;\n        }\n    }\n    get format() {\n        return  this.get('format');\n    }\n    get defaultEditor() {\n        return {\n            name   : this.field,\n            type   : 'time',\n            format : this.format\n        };\n    }\n    //endregion\n}\nColumnStore.registerColumnType(TimeColumn, true);\nTimeColumn.exposeProperties();\nTimeColumn._$name = 'TimeColumn';", "import CopyPasteBase from './base/CopyPasteBase.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nconst actions = {\n    cut   : 1,\n    copy  : 1,\n    paste : 1\n};\n/**\n * @module Grid/feature/CellCopyPaste\n */\n/**\n * Allows using `[Ctrl/CMD + C]`, `[Ctrl/CMD + X]` and `[Ctrl/CMD + V]` to cut, copy and paste cell or cell ranges. Also\n * makes cut, copy and paste actions available via the cell context menu.\n *\n * <div class=\"note\">\n * Requires {@link Grid/view/Grid#config-selectionMode selectionMode.cell} to be activated. Also, if the\n * {@link Grid/feature/CellEdit} feature is disabled, the {@link #config-copyOnly} config will default to `true` which\n * prevents cut and paste actions completely. Set {@link #config-copyOnly} to `false` to prevent this behaviour.\n * </div>\n *\n * This feature will work alongside with {@link Grid/feature/RowCopyPaste} but there is differences on functionality.\n * * When used together, context menu options will be detailed so the user will know to copy the cell or the row.\n * * They will also detect what type of selection is present at the moment. If there are only rows selected, only row\n *   alternatives are shown in the context menu and the keyboard shortcuts will be processed by RowCopyPaste.\n * * If there are only cells selected, there will be context menu options for both row and cell but keyboard shortcuts\n *   will be handled by CellCopyPaste.\n * * They do share clipboard, even if internal clipboard is used, so it is not possible to have rows and cells copied or\n *   cut at the same time.\n *\n * If the {@link https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API Clipboard API} is available, that will\n * be used. This enables copying and pasting between different Bryntum products or completely different applications.\n * Please note that only string values are supported.\n *\n * This feature is **disabled** by default\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         cellCopyPaste : true\n *     }\n * });\n * ```\n *\n * {@inlineexample Grid/feature/CellCopyPaste.js}\n *\n * ## Keyboard shortcuts\n * The feature has the following default keyboard shortcuts:\n *\n * | Keys       | Action  | Action description                                                                      |\n * |------------|---------|-----------------------------------------------------------------------------------------|\n * | `Ctrl`+`C` | *copy*  | Calls {@link #function-copy} which copies selected cell values into the clipboard.      |\n * | `Ctrl`+`X` | *cut*   | Calls {@link #function-cut} which cuts out selected cell values and saves in clipboard. |\n * | `Ctrl`+`V` | *paste* | Calls {@link #function-paste} which inserts string values from the clipboard.           |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [this guide](#Grid/guides/customization/keymap.md).\n *\n * @extends Grid/feature/base/CopyPasteBase\n * @classtype cellCopyPaste\n * @feature\n */\nexport default class CellCopyPaste extends CopyPasteBase {\n    static $name = 'CellCopyPaste';\n    static pluginConfig = {\n        chain : [\n            'populateCellMenu', 'afterSelectionModeChange'\n        ]\n    };\n    static configurable = {\n        useNativeClipboard : !VersionHelper.isTestEnv,\n        copyText  : 'L{copy}',\n        cutText   : 'L{cut}',\n        pasteText : 'L{paste}'\n    };\n    afterConstruct() {\n        super.afterConstruct();\n        this.afterSelectionModeChange();\n    }\n    afterSelectionModeChange() {\n        const me = this;\n        if (!me.client.selectionMode.cell) {\n            me.disabled = true;\n        }\n        else if (me._disabledBySelectionMode) {\n            me.disabled = false;\n            delete me._disabledBySelectionMode;\n        }\n    }\n    // Used in events to separate events from different features from each other\n    entityName = 'cell';\n    set copyOnly(value) {\n        this._copyOnly = value;\n    }\n    get copyOnly() {\n        // If celledit is disabled, cut and paste actions are disabled by default\n        if (this._copyOnly == null) {\n            return !this.client.features.cellEdit?.enabled;\n        }\n        return Boolean(this._copyOnly);\n    }\n    get canCopy() {\n        const { client } = this;\n        return Boolean(!this.disabled && client.selectedCells.length &&\n            (\n                !client._selectedRows.length ||\n                client.features.rowCopyPaste?.disabled ||\n                client.focusedCell && client.isCellSelected(client.focusedCell)\n            ));\n    }\n    get canCutPaste() {\n        return this.canCopy && !this.copyOnly && !this.client.features.cellEdit?.isEditing && !this.client.readOnly;\n    }\n    // Called from keyMap. Also used internally here\n    isActionAvailable({ actionName }) {\n        if (actions[actionName]) {\n            return this.canCopy && (actionName === 'copy' || this.canCutPaste);\n        }\n    }\n    /**\n     * Cuts selected cells to clipboard (native if accessible) to paste later\n     * @async\n     */\n    async cut() {\n        await this.copy(true);\n    }\n    /**\n     * Copies selected cells to clipboard (native if accessible) to paste later\n     * @async\n     */\n    async copy(isCut = false) {\n        if (typeof isCut != 'boolean') {\n            isCut = false; // If called by keymap, arguments[0] will be an event\n        }\n        const\n            me                = this,\n            { selectedCells } = me.client,\n            cells             = isCut ? selectedCells.filter(r => !r.record?.readOnly) : selectedCells;\n        if (cells) {\n            if ((isCut ? !me.canCutPaste : !me.canCopy)) {\n                return;\n            }\n            const copiedDataString = me.cellsToString(cells);\n            await me.writeToClipboard(copiedDataString, isCut, { cells });\n            if (isCut === true) {\n                for (const cell of cells) {\n                    if (!cell.column.readOnly) {\n                        cell.record.set(cell.column.field, null);\n                    }\n                }\n            }\n            /**\n             * Fires on the owning Grid after a copy action is performed.\n             * @event copy\n             * @on-owner\n             * @param {Grid.view.Grid} source Owner grid\n             * @param {Grid.util.Location[]} cells The cells about to be copied or cut\n             * @param {String} copiedDataString The concatenated data string that was copied or cut\n             * @param {Boolean} isCut `true` if this was a cut action\n             * @param {String} entityName 'cell' to distinguish this event from other copy events\n             */\n            me.client.trigger('copy', { cells, copiedDataString, isCut, entityName : me.entityName });\n        }\n    }\n    // Called from Clipboardable before writing to the clipboard\n    async beforeCopy({ data, isCut, cells }) {\n        /**\n         * Fires on the owning Grid before a copy action is performed, return `false` to prevent the action\n         * @event beforeCopy\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {Grid.util.Location[]} cells The cells about to be copied or cut\n         * @param {String} data The string data about to be copied or cut\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'cell' to distinguish this event from other beforeCopy events\n         */\n        return await this.client.trigger('beforeCopy', { cells, data, isCut, entityName : this.entityName });\n    }\n    /**\n     * Pastes string data into a cell or a range of cells. Either from native clipboard if that is accessible or from a\n     * fallback clipboard that is only available to the owner Grid.\n     *\n     * The string data will be split on `\\n` and `\\t` and put in different rows and columns accordingly.\n     *\n     * Note that there must be a selected cell to paste the data into.\n     * @async\n     */\n    async paste() {\n        const\n            me                     = this,\n            { client, entityName } = me,\n            targetCell             = client.selectedCells[0];\n        if (!me.canCutPaste || !targetCell) {\n            return;\n        }\n        const clipboardData = await me.readFromClipboard({}, true);\n        if (!clipboardData) {\n            return;\n        }\n        const { modifiedRecords, targetCells } = me.setFromStringData(clipboardData);\n        if (client.selectedCells.length === 1 && targetCells.length > 1) {\n            client.selectCellRange(targetCells[0], targetCells[targetCells.length - 1]);\n        }\n        /**\n         * Fires on the owning Grid after a paste action is performed.\n         * @event paste\n         * @on-owner\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {String} clipboardData The clipboardData that was pasted\n         * @param {Core.data.Model[]} modifiedRecords The records which have been modified due to the paste action\n         * @param {Grid.util.Location} targetCell The cell from which the paste will be started\n         * @param {String} entityName 'cell' to distinguish this event from other paste events\n         */\n        client.trigger('paste', { clipboardData, targetCell, modifiedRecords : [...modifiedRecords], entityName });\n    }\n    // Called from Clipboardable before finishing the clipboard read\n    async beforePaste({ data }) {\n        /**\n         * Fires on the owning Grid before a paste action is performed, return `false` to prevent the action\n         * @event beforePaste\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {String} clipboardData The clipboardData about to be pasted\n         * @param {Grid.util.Location} targetCell The cell from which the paste will be started\n         * @param {String} entityName 'cell' to distinguish this event from other beforePaste events\n         */\n        return await this.client.trigger('beforePaste', {\n            clipboardData : data, targetCell : this.client.selectedCell, entityName : this.entityName\n        });\n    }\n    populateCellMenu({ record, items }) {\n        const me = this;\n        if (me.canCopy) {\n            items.cutCell = {\n                text        : me.cutText,\n                localeClass : me,\n                icon        : 'b-icon b-icon-cut',\n                weight      : 115,\n                disabled    : record.readOnly || !me.canCutPaste,\n                onItem      : () => me.cut()\n            };\n            items.pasteCell = {\n                text        : me.pasteText,\n                localeClass : me,\n                icon        : 'b-icon b-icon-paste',\n                weight      : 120,\n                disabled    : record.readOnly || !me.canCutPaste || me.hasClipboardData() === false,\n                onItem      : () => me.paste()\n            };\n            items.copyCell = {\n                text        : me.copyText,\n                localeClass : me,\n                cls         : 'b-separator',\n                icon        : 'b-icon b-icon-copy',\n                weight      : 110,\n                onItem      : () => me.copy()\n            };\n        }\n    }\n}\nCellCopyPaste._$name = 'CellCopyPaste'; GridFeatureManager.registerFeature(CellCopyPaste);\n", "import Objects from '../../Core/helper/util/Objects.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\n/**\n * @module Grid/feature/CellTooltip\n */\n/**\n * Displays a tooltip when hovering cells.\n *\n * {@inlineexample Grid/feature/CellTooltip.js}\n *\n * To show contents when hovering a cell, you can specify a global {@link #config-tooltipRenderer} function for the\n * feature, you can also define a {@link Grid.column.Column#config-tooltipRenderer} for individual columns.\n *\n * ```javascript\n * // Column with its own tooltip renderer\n * {\n *   text            : 'Name',\n *   field           : 'name',\n *   tooltipRenderer : ({ record }) => `My name is\\xa0<b>${record.name}</b>`\n * }\n * ```\n *\n * Configuration properties passed into this feature are used to configure the {@link Core.widget.Tooltip} instance\n * used.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ## Showing async content\n * Showing remotely loaded content is super easy using the {@link #config-tooltipRenderer}:\n *\n * ```javascript\n * // Async tooltip with some custom settings\n * const grid = new Grid({\n *   features: {\n *     cellTooltip: {\n *       // Time that mouse needs to be over cell before tooltip is shown\n *       hoverDelay : 4000,\n *       // Time after mouse out to hide the tooltip, 0 = instantly\n *       hideDelay  : 0,\n *       // Async tooltip renderer, return a Promise which yields the text content\n *       tooltipRenderer({ record, tip }) {\n *         return fetch(`tip.php?id=${record.id}`).then(response => response.text())\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @extendsconfigs Core/widget/Tooltip\n * @demo Grid/celltooltip\n * @classtype cellTooltip\n * @feature\n */\nexport default class CellTooltip extends InstancePlugin {\n    //region Config\n    static $name = 'CellTooltip';\n    static configurable = {\n        /**\n         * Function called to generate the HTML content for the cell tooltip.\n         * The function should return a string (your HTML), or a Promise yielding a string (for remotely loaded\n         * content)\n         * @prp {Function}\n         * @param {Object} context\n         * @param {HTMLElement} context.cellElement The cell element\n         * @param {Core.data.Model} context.record The row record\n         * @param {Grid.column.Column} context.column The column\n         * @param {Core.widget.Tooltip} context.tip The Tooltip instance\n         * @param {Grid.feature.CellTooltip} context.cellTooltip The feature\n         * @param {Event} context.event The raw DOM event\n         * @returns {String|Promise}\n         * @typings {String|Promise<String>}\n         */\n        tooltipRenderer : null\n    };\n    //endregion\n    // region Init\n    construct(grid, config) {\n        super.construct(grid, this.processConfig(config));\n    }\n    initTip() {\n        const me = this;\n        /**\n         * Returns the tooltip instance\n         * @member {Core.widget.Tooltip} tip\n         * @readonly\n         */\n        me.tip = Tooltip.new({\n            forElement        : me.client.element,\n            forSelector       : '.b-grid-row:not(.b-group-row) .b-grid-cell, .b-grid-merged-cells',\n            hoverDelay        : 1000,\n            trackMouse        : false,\n            cls               : 'b-celltooltip-tip',\n            getHtml           : me.getTooltipContent.bind(me),\n            internalListeners : {\n                pointerOver : 'onPointerOver',\n                thisObj     : me\n            },\n            // eslint-disable-next-line bryntum/no-listeners-in-lib\n            listeners : me.configuredListeners\n        }, me.initialConfig);\n        me.relayEvents(me.tip, ['beforeShow', 'show']);\n    }\n    onPointerOver({ target }) {\n        const column = this.client.getColumnFromElement(target);\n        // Veto onPointerOver if column's tooltipRenderer is false\n        return column.tooltipRenderer !== false && Boolean(column.tooltipRenderer || this.tooltipRenderer);\n    }\n    // CellTooltip feature handles special config cases, where user can supply a function to use as tooltipRenderer\n    // instead of a normal config object\n    processConfig(config) {\n        if (typeof config === 'function') {\n            return {\n                tooltipRenderer : config\n            };\n        }\n        return config;\n    }\n    // override setConfig to process config before applying it (used mainly from ReactGrid)\n    setConfig(config) {\n        super.setConfig(this.processConfig(config));\n    }\n    doDestroy() {\n        this.tip && this.tip.destroy();\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        if (!disable) {\n            this.initTip();\n        }\n        else if (this.tip) {\n            this.tip.destroy();\n            this.tip = null;\n        }\n        super.doDisable(disable);\n    }\n    //endregion\n    //region Content\n    /**\n     * Called from Tooltip to populate it with html.\n     * @private\n     */\n    getTooltipContent({ tip, activeTarget : cellElement, event }) {\n        const\n            me     = this,\n            record = me.client.getRecordFromElement(cellElement),\n            column = me.client.getColumnFromElement(cellElement),\n            arg    = { cellElement, record, column, event, tip, cellTooltip : me };\n        let result;\n        // If we have not changed context, we should not change content, unless we have a custom target selector (element within the cell)\n        if (!me.forSelector && record === me.lastRecord && record.generation === me.lastRecordGeneration && column === me.lastColumn) {\n            return me.tip._html;\n        }\n        me.lastRecord = record;\n        me.lastRecordGeneration = record.generation;\n        me.lastColumn = column;\n        // first, use columns tooltipRenderer if any\n        if (column.tooltipRenderer) {\n            result = column.tooltipRenderer(arg);\n        }\n        // secondly, try feature's renderer (specifying column.tooltipRenderer as false prevents tooltip in that column)\n        else if (me.tooltipRenderer && column.tooltipRenderer !== false) {\n            result = me.tooltipRenderer(arg);\n        }\n        // No caching of async requests\n        if (Objects.isPromise(result)) {\n            me.lastRecord = me.lastRecordGeneration = me.lastColumn = null;\n        }\n        // Tip should hide if no content is available\n        if (!result) {\n            tip.hide();\n        }\n        return result;\n    }\n    //endregion\n}\nCellTooltip._$name = 'CellTooltip'; GridFeatureManager.registerFeature(CellTooltip);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Editor from '../../Core/widget/Editor.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\n/**\n * @module Grid/feature/ColumnRename\n */\n/**\n * Allows user to rename columns by either right-clicking column header or using keyboard shortcuts when column header\n * is focused.\n *\n * To get notified about column renaming listen to `change` event on {@link Grid.data.ColumnStore columns} store.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * {@inlineexample Grid/feature/ColumnRename.js}\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys          | Action           | Action description                        |\n * |---------------|------------------|-------------------------------------------|\n * | `F2`          | *startEdit*      | Starts editing focused column header text |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @demo Grid/columns\n * @classtype columnRename\n * @feature\n */\nexport default class ColumnRename extends InstancePlugin {\n    static $name = 'ColumnRename';\n    static configurable = {\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            F2 : 'startEdit'\n        }\n    };\n    doDestroy() {\n        this.editor?.destroy();\n        super.doDestroy();\n    }\n    static get pluginConfig() {\n        return {\n            after : ['populateHeaderMenu']\n        };\n    }\n    populateHeaderMenu({ items, column }) {\n        items.rename = {\n            weight   : 215,\n            icon     : 'b-fw-icon b-icon-edit',\n            text     : this.L('L{rename}'),\n            disabled : column.readOnly,\n            onItem   : () => this.startEdit(column)\n        };\n    }\n    startEdit(column) {\n        if (column instanceof Event) {\n            // If started editing by key\n            column = this.client.getHeaderDataFromEvent(column)?.column;\n        }\n        if (column) {\n            if (column.readOnly) {\n                // return false to let keyMap know that we didn't handle this event\n                return false;\n            }\n            const { textWrapper } = column;\n            let { editor } = this;\n            if (!editor) {\n                this.editor = editor = new Editor({\n                    owner : this.client,\n                    align : {\n                        align : 't0-t0'\n                    }\n                });\n            }\n            editor.render(textWrapper);\n            editor.startEdit({\n                target : textWrapper,\n                record : column,\n                field  : 'text'\n            });\n        }\n    }\n}\nColumnRename._$name = 'ColumnRename'; GridFeatureManager.registerFeature(ColumnRename, false);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Location from '../../Grid/util/Location.js';\nimport GlobalEvents from '../../Core/GlobalEvents.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n/**\n * @module Grid/feature/FillHandle\n */\n/**\n * This feature adds a fill handle to a Grid range selection, which when dragged, fills the cells being dragged over\n * with values based on the values in the original selected range. This is similar to functionality normally seen in\n * various spreadsheet applications.\n *\n * {@inlineexample Grid/feature/FillHandle.js}\n *\n * Requires {@link Grid/view/Grid#config-selectionMode selectionMode.cell} to be activated.\n *\n * This feature is **disabled** by default\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         fillHandle : true\n *     }\n * });\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype fillHandle\n * @feature\n */\nexport default class FillHandle extends InstancePlugin.mixin(Delayable) {\n    static $name = 'FillHandle';\n    static configurable = {\n        /**\n         * Implement this function to be able to customize the value that cells will be filled with.\n         * Return `undefined` to use default calculations.\n         *\n         * ````javascript\n         * new Grid({\n         *    features : {\n         *        fillHandle : {\n         *           calculateFillValue({cell, column, range, record}) {\n         *              if(column.field === 'number') {\n         *                 return range.reduce(\n         *                    (sum, location) => sum + location.record[location.column.field]\n         *                 );\n         *              }\n         *           }\n         *        }\n         *    }\n         * });\n         * ````\n         *\n         * @param {Object} data Object containing information about current cell and fill value\n         * @param {Grid.util.Location} data.cell Current cell data\n         * @param {Grid.column.Column} data.column Current cell column\n         * @param {Grid.util.Location[]} data.range Range from where to calculate values\n         * @param {Core.data.Model} data.record Current cell record\n         * @returns {String|Number|Date} Value to fill current cell\n         * @config {Function}\n         */\n        calculateFillValue : null,\n        /**\n         * Set to `true` to enable the fill range to crop the original selected range. This clears the cells which were\n         * a part of the original selected range, but are no longer a part of the smaller range.\n         * @config {Boolean}\n         */\n        allowCropping : false\n    };\n    // Plugin configuration. This plugin chains/overrides some functions in Grid.\n    static pluginConfig = {\n        chain    : ['afterSelectionChange', 'onContentChange', 'afterColumnsChange', 'fixElementHeights'],\n        override : ['getCellDataFromEvent']\n    };\n    afterConstruct() {\n        super.afterConstruct();\n        if (!this.client.selectionMode.cell) {\n            this.disabled = true;\n        }\n        this._fillListeners = {};\n    }\n    delayable = {\n        handleSelection : 'raf'\n    };\n    onContentChange() {\n        this.handleSelection();\n    }\n    afterColumnsChange() {\n        this.handleSelection();\n    }\n    fixElementHeights() {\n        this.handleSelection();\n    }\n    getCellDataFromEvent(event, includeSingleAxisMatch) {\n        if (includeSingleAxisMatch) {\n            includeSingleAxisMatch = !event.target.classList.contains('b-fill-handle');\n        }\n        return this.overridden.getCellDataFromEvent(event, includeSingleAxisMatch);\n    }\n    // region Pattern recognition\n    findPatternsIn2dRange(range, horizontal, negative) {\n        const values = {};\n        // Converts a cellselector range to values per column or row\n        for (const cell of range) {\n            const id = horizontal ? cell.id : cell.columnId;\n            let value = cell.record.getValue(cell.column.field);\n            // If a number string, convert to number\n            if (value && typeof value === 'string' && !isNaN(value)) {\n                value = parseFloat(value);\n            }\n            if (!values[id]) {\n                values[id] = [];\n            }\n            values[id].push(value);\n        }\n        // Find patterns for each column or row in range\n        for (const rowOrCol in values) {\n            values[rowOrCol].pattern = this.findPatternsIn1dRange(values[rowOrCol], negative);\n        }\n        return values;\n    }\n    findPatternsIn1dRange(range, negative) {\n        const\n            lastValue = range[negative ? 0 : (range.length - 1)],\n            pattern   = {\n                next : () => lastValue,\n                lastValue\n            };\n        // If all values in same column/row is either number or date\n        if (range.every(val => typeof val === 'number') || range.every(val => val instanceof Date)) {\n            const diffs = range.map((val, ix) => val - range[ix - 1]);\n            diffs.shift(); // Removes initial NaN\n            // Found a repeating pattern\n            if (new Set(diffs).size === 1) {\n                pattern.increaseBy = diffs[0] * (negative ? -1 : 1);\n                pattern.next = () => {\n                    if (pattern.lastValue instanceof Date) {\n                        pattern.lastValue = new Date(pattern.lastValue.getTime() + pattern.increaseBy);\n                    }\n                    else {\n                        pattern.lastValue += pattern.increaseBy;\n                    }\n                    return pattern.lastValue;\n                };\n            }\n        }\n        // Else it's treated as a string value\n        else if (range.length > 1) {\n            pattern.stringPattern = [...range];\n            pattern.next = () => {\n                if (pattern.currentIndex === undefined) {\n                    pattern.currentIndex = 0;\n                }\n                else {\n                    pattern.currentIndex += 1;\n                    if (pattern.currentIndex >= pattern.stringPattern.length) {\n                        pattern.currentIndex = 0;\n                    }\n                }\n                return pattern.stringPattern[pattern.currentIndex];\n            };\n        }\n        return pattern;\n    }\n    // endregion\n    afterSelectionChange() {\n        const me = this;\n        if (me.client.readOnly) {\n            me.removeElements();\n            return;\n        }\n        // If selection isn't finished, wait for mouse up and then add fill elements\n        if (GlobalEvents.isMouseDown()) {\n            me.client.delayUntilMouseUp(() => me.handleSelection(true));\n            // Remove prev elements immediately in this case\n            me.removeElements();\n        }\n        // Otherwise, add fill elements immediately\n        else {\n            me.handleSelection(true);\n        }\n    }\n    /**\n     * Checks selection and sees to it that fill handle and border is drawn.\n     * Runs on next animation frame\n     * @internal\n     */\n    handleSelection() {\n        if (!this._isExtending) {\n            const range = this.rangeSelection;\n            if (range) {\n                this.drawFillHandleAndBorder(range[0], range[range.length - 1]);\n            }\n            else {\n                this.removeElements();\n            }\n        }\n    }\n    // region Mouse events\n    // On fillHandle mouse down only\n    onMouseDown(event) {\n        const { client } = this;\n        if (!client.readOnly) {\n            this._fillListeners.mouseMoveOrUp = EventHelper.on({\n                element   : globalThis,\n                mouseover : {\n                    handler : 'onMouseOver',\n                    element : client.selectionDragMouseEventListenerElement\n                },\n                mouseup : 'onMouseUp',\n                thisObj : this\n            });\n            event.preventDefault();\n            event.stopImmediatePropagation();\n            event.handled = true;\n        }\n    }\n    // Responsible for doing the filling\n    onMouseUp() {\n        const\n            me              = this,\n            {\n                client,\n                currentRange,\n                _isCropping\n            }               = me,\n            range           = me.rangeSelection,\n            selectionChange = range && currentRange && client.internalSelectRange(currentRange.from, currentRange.to),\n            selectedCells   = selectionChange?.selectedCells || [],\n            // For extending : Only modify cells that are not a part of original range\n            // For cropping  : Only clear cells that are not a part of new selection\n            extensionCells  = _isCropping ? me.croppingCells\n                : selectedCells.filter(cell => !range.some(sel => sel.equals(cell, true)));\n        delete me._isCropping; // Removing flag in case we bail out early\n        if (me._isExtending) {\n            client.disableScrollingCloseToEdges(client.items);\n            delete me._isExtending;\n        }\n        // If no extension, do nothing\n        if (!extensionCells?.length) {\n            me.handleSelection();\n            return;\n        }\n        client.suspendRefresh();\n        // If trimming (inverted extension), clear cells that where previously selected and not a part of new selection\n        if (_isCropping) {\n            extensionCells.forEach(cell => cell.record.set(cell.column.field, null, false, false, false, true));\n        }\n        // Extending cell values depending on pattern\n        else {\n            const\n                [firstCell] = extensionCells,\n                // If extensioncells has a record that is included in original selection, then we are dragging horizontally\n                horizontal  = range.some(sel => sel.record === firstCell.record),\n                // negative in this aspect, means dragging either upwards or to the left depending on horizontal or vertical\n                negative    = horizontal\n                    ? firstCell.columnIndex < range[0].columnIndex\n                    : firstCell.rowIndex < range[0].rowIndex,\n                patterns    = me.findPatternsIn2dRange(range, horizontal, negative),\n                changeMap   = new Map();\n            if (negative) {\n                extensionCells.reverse();\n            }\n            for (const cell of extensionCells) {\n                const { column, record } = cell;\n                if (!column.readOnly && column.canFillValue({ range, record, cell })) {\n                    let value   = me.calculateFillValue?.({ range, column, record, cell }),\n                        changed = changeMap.get(record);\n                    if (!changed) {\n                        changed = {};\n                        changeMap.set(record, changed);\n                    }\n                    if (value === undefined) {\n                        const pattern = patterns[horizontal ? cell.id : cell.columnId].pattern;\n                        value = pattern.next();\n                    }\n                    changed[column.field] = column.calculateFillValue?.({ value, record, range }) || value;\n                }\n            }\n            for (const [record, changes] of changeMap) {\n                record.set(changes, null, null, null, null, true);\n            }\n        }\n        client.resumeRefresh(true);\n        // Selects the extended area\n        client.performSelection(selectionChange);\n        delete me.currentRange;\n        me.handleSelection();\n    }\n    // The fill border and handle should refresh on mouse move\n    onMouseOver(event) {\n        const\n            me           = this,\n            {\n                client,\n                rangeSelection\n            }            = me,\n            first        = rangeSelection[0],\n            last         = rangeSelection[rangeSelection.length - 1],\n            cellData     = client.getCellDataFromEvent(event, true);\n        let cellSelector = cellData && client.normalizeCellContext(cellData.cellSelector);\n        if (cellSelector?._column?.region === first._column.region) {\n            const\n                equalOrSmaller = rangeSelection.some(cs => cs.equals(cellSelector, true));\n            let negative;\n            if (!me._isExtending) {\n                client.enableScrollingCloseToEdges(client.items);\n            }\n            if (equalOrSmaller) {\n                // If were smaller, were cropping (if it's allowed)\n                me._isCropping = me.allowCropping &&\n                    (cellSelector.rowIndex < last.rowIndex || cellSelector.columnIndex < last.columnIndex);\n            }\n            else {\n                // If cellSelector is on a row in range, endSelector should be current column but end/first row\n                if (cellSelector.rowIndex >= first.rowIndex && cellSelector.rowIndex <= last.rowIndex) {\n                    negative     = first.columnIndex > cellSelector.columnIndex;\n                    cellSelector = new Location({\n                        grid   : client,\n                        record : negative ? first.record : last.record,\n                        column : cellSelector.column\n                    });\n                }\n                // Else endSelector should be current row but end/first column\n                else {\n                    negative     = first.rowIndex > cellSelector.rowIndex;\n                    cellSelector = new Location({\n                        grid   : client,\n                        record : cellSelector.record,\n                        column : negative ? first.column : last.column\n                    });\n                }\n            }\n            // negative means that current mouse over cell is above or to the left\n            const\n                // If negative, draw from calculated mouse over cell\n                // otherwise, draw from top-left selection cell\n                from = negative ? cellSelector : first,\n                // If negative or were inside selection (but not cropping), draw to bottom-right selection cell\n                // otherwise, draw to calculated mouse over cell\n                to   = negative || (equalOrSmaller && !me._isCropping) ? last : cellSelector;\n            me.currentRange = { from, to };\n            // This flag is true even if were trimming\n            me._isExtending = true;\n            me.drawFillHandleAndBorder(from, to, true);\n        }\n    }\n    // endregion\n    // region Creating, updating and removing fillhandle and fillborder\n    drawFillHandleAndBorder(from, to, keepListeners = false) {\n        const\n            me        = this,\n            {\n                client,\n                currentRange,\n                _fillListeners\n            }         = me,\n            regionEl  = client.subGrids[from.column.region].element,\n            { x }     = Rectangle.from(from.cell || from.column.element, regionEl),\n            { right } = Rectangle.from(to.cell || to.column.element, regionEl),\n            { y }     = client.getRecordCoords(from.record, true),\n            bottom    = client.getRecordCoords(to.record, true).bottom - 1;\n        let {\n            borderElement,\n            handleElement\n        }             = me;\n        me.removeElements(keepListeners);\n        if (!borderElement) {\n            me.borderElement = borderElement = DomHelper.createElement({\n                className : 'b-fill-selection-border'\n            });\n            me.handleElement = handleElement = DomHelper.createElement({\n                className : 'b-fill-handle'\n            });\n        }\n        DomHelper.setRect(borderElement, { y, x, width : (right - x), height : (bottom - y) });\n        regionEl.appendChild(borderElement);\n        // If fill handle is drawn at right edge, put it to the left instead\n        DomHelper.setTopLeft(handleElement, bottom, right >= regionEl.scrollWidth ? x : right);\n        regionEl.appendChild(handleElement);\n        // Remove all previously cropping cls\n        me.toggleCroppingCls(false);\n        delete me.croppingCells;\n        // If were cropping, we should add cls class to the cells that will be \"shrunk\"\n        if (me._isCropping && me.rangeSelection?.length) {\n            const newCells = client.getRange(currentRange.from, currentRange.to);\n            me.croppingCells = me.rangeSelection.filter(sel => !newCells.some(cell => cell.equals(sel, true)));\n            me.toggleCroppingCls();\n        }\n        if (!_fillListeners.handleClick) {\n            _fillListeners.handleClick = EventHelper.on({\n                element   : client.rootElement,\n                delegate  : '.b-fill-handle',\n                mousedown : 'onMouseDown',\n                thisObj   : me\n            });\n        }\n        me.hasFillElements = true;\n    }\n    toggleCroppingCls(add = true) {\n        this.croppingCells?.forEach(sel => this.client.getCell(sel)?.classList.toggle('b-indicate-crop', add));\n    }\n    removeElements(keepListeners = false) {\n        const me = this;\n        me.handleElement?.remove();\n        me.borderElement?.remove();\n        if (!keepListeners) {\n            me.removeListeners();\n        }\n        me.hasFillElements = false;\n    }\n    // Detach listeners\n    removeListeners() {\n        const me = this;\n        for (const listener in me._fillListeners) {\n            me._fillListeners[listener]();\n        }\n        me._fillListeners = {};\n    }\n    // endregion\n    // Gets current selection range. Only allows for single range or single cell.\n    get rangeSelection() {\n        const\n            { client }        = this,\n            { selectedCells } = client,\n            range             = client._shiftSelectRange ?? (selectedCells.length === 1 && selectedCells);\n        // We only got one selected range, nothing else selected\n        // Only allow fill handle on single region selection\n        if (!client._selectedRows.length && range?.length && range.length === selectedCells.length &&\n            range.every(c1 => selectedCells.some(c2 => c1.equals(c2, true)) &&\n                c1._column.parent && c1._column.region === range[0]._column.region && client.store.isAvailable(c1.id)\n            )\n        ) {\n            return range;\n        }\n        return null;\n    }\n}\nFillHandle._$name = 'FillHandle'; GridFeatureManager.registerFeature(FillHandle);\n", "import ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\n/**\n * @module Grid/feature/MergeCells\n */\n// Maps DOM events to relayed events that need correct casing\nconst camelCase = {\n    mousedown   : 'mouseDown',\n    mousemove   : 'mouseMove',\n    mouseup     : 'mouseUp',\n    touchdown   : 'touchDown',\n    touchmove   : 'touchMove',\n    touchup     : 'touchUp',\n    pointerover : 'mouseOver',\n    mouseout    : 'mouseOut',\n    dblclick    : 'dblClick',\n    keydown     : 'keyDown',\n    keypress    : 'keyPress',\n    keyup       : 'keyUp',\n    contextmenu : 'contextMenu'\n};\n/**\n * This feature merges cells that have the same value in sorted (or {@link #config-sortedOnly optionally} any) columns\n * configured to {@link Grid/column/Column#config-mergeCells}.\n *\n * The content of merged cells is sticky for Grids with a single subgrid section when all columns fit in view (content\n * stays in view until the cell is scrolled fully out of view).\n *\n * {@note}\n * Support for sticky content is limited because of how <code>position: sticky</code> works. Grid\n * scrolls vertically in one element, and horizontally in another (to support multiple regions in the grid), and this\n * setup is not supported by current browsers implementation of sticky positioning\n * {/@note}\n *\n * Try scrolling in the demo below. As mentioned above, cells are by default merged only in sorted columns -  try\n * sorting by the other columns (\"City\" and \"Favorite food\" are configured to merge cells):\n *\n * {@inlineexample Grid/feature/MergeCells.js}\n *\n * By configuring the feature with `sortedOnly : false`, cells can be merged in any column:\n *\n * {@inlineexample Grid/feature/MergeCellsAll.js}\n *\n * This feature is **disabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype mergeCells\n * @feature\n */\nexport default class MergeCells extends InstancePlugin {\n    //region Config\n    static $name = 'MergeCells';\n    static configurable = {\n        /**\n         * By default, merged cells allow pointer events to pass through to the underlying row/cell, to allow selecting\n         * a row and editing an individual cell even when they are merged. Configure as `false` to allow merged cells to\n         * catch and react to the pointer events instead.\n         *\n         * ```javascript\n         * const grid = new Grid({\n         *     features : {\n         *         mergeCells : {\n         *             // Let merged cells react to pointer events\n         *             passthrough : false\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         */\n        passthrough : true,\n        /**\n         * Configure as `false` to allow merging cells in columns that are not sorted.\n         *\n         * {@note}\n         * Note that this will have a slight negative impact on performance, since cells in all columns configured to\n         * merge cells have to be iterated.\n         * {/@note}\n         *\n         * @config {Boolean}\n         * @default true\n         */\n        sortedOnly : true\n    };\n    // All current ranges (once rendered)\n    mergedRanges = [];\n    // Ranges indexed by row index & column id -> Each range included multiple times, for easy lookup\n    mergedMap    = {};\n    static get pluginConfig() {\n        return {\n            chain : [\n                'beforeRenderCell',\n                'afterRenderRow',\n                'bindStore',\n                'afterColumnsChange',\n                'afterRemove',\n                'afterToggleGroup',\n                'afterToggleSubGrid',\n                'handleEvent',\n                'populateHeaderMenu',\n                // 'setHoveredRow'\n                'afterSelectionChange'\n            ],\n            // Grid must perform its update *after* we do.\n            before : [\n                'onInternalResize'\n            ],\n            override : [\n                'getColumnFromElement',\n                'getRecordFromElement'\n            ]\n        };\n    };\n    //endregion\n    //region Init\n    afterConstruct() {\n        const\n            me         = this,\n            { client } = me;\n        // Each subgrid gets a merged cells container\n        client.eachSubGrid(subGrid => me.setupSubGrid(subGrid));\n        // Merged cells are synced after rows are updated\n        client.rowManager.ion({\n            renderDone : 'onRenderDone',\n            thisObj    : me\n        });\n        me.bindStore(client.store);\n    }\n    setupSubGrid(subGrid) {\n        // Element that will contain the merged cells\n        subGrid.$mergedCellsElement = DomHelper.createElement({\n            parent    : subGrid.element,\n            className : {\n                'b-grid-merged-cells-container' : 1\n            }\n        });\n        // Catch resizing region\n        subGrid.ion({\n            beforeInternalResize : 'refreshBounds',\n            thisObj              : this\n        });\n    }\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            // Flag to allow reset to redraw even though we are already disabled at this stage\n            this.isDisabling = true;\n            this.reset();\n            this.isDisabling = false;\n        }\n        super.doDisable(disable);\n    }\n    updatePassthrough(use) {\n        // Toggle CSS class that has `pointer-events : none`\n        this.client.element.classList.toggle('b-mergecells-passthrough', use);\n    }\n    updateSortedOnly(sortedOnly) {\n        if (!this.isConfiguring) {\n            this.reset(true, sortedOnly);\n        }\n    }\n    //endregion\n    //region Grid hooks\n    bindStore(store) {\n        this.detachListeners('store');\n        store.ion({\n            name    : 'store',\n            change  : 'onStoreChange',\n            // Call our refresh logic before grids\n            refresh : {\n                prio : 1,\n                fn   : 'onStoreRefresh'\n            },\n            thisObj : this\n        });\n    }\n    // Refresh all ranges when grid is resized\n    onInternalResize() {\n        this.refreshBounds();\n    }\n    // Get / create ranges before cell contents are rendered, redirecting the contents to the range\n    beforeRenderCell(renderData) {\n        const\n            me                              = this,\n            { column, record, cellElement } = renderData,\n            subGrid                         = me.client.subGrids[column.region];\n        // Only affect sorted columns configured to merge cells\n        if (!me.disabled && column.mergeCells && (column.isSorted || !me.sortedOnly) && !record.isSpecialRow && !subGrid.collapsed) {\n            const mergedRange = me.getMergeRange(record, column);\n            if (mergedRange?.use) {\n                // Flag the unmerged cell to allow styling it\n                cellElement.classList.add('b-merged-cell');\n                // Make sure it is empty\n                cellElement.innerHTML = '';\n                // Redirect output to the merged cell\n                renderData.cellElement = mergedRange.cellElement;\n            }\n        }\n    }\n    afterRenderRow({ row, oldId, oldHeight }) {\n        // Row reused for same record changed height\n        if (oldId === row.id && oldHeight !== row.height) {\n            this.heightChanged = true;\n        }\n    }\n    // Refresh all ranges when a column is resized (since it might affect their position and size)\n    afterColumnsChange({ action, changes, column }) {\n        if (this.disabled) {\n            return;\n        }\n        if (action === 'update' && changes.mergeCells && !column.mergeCells) {\n            // Remove all ranges for the column when mergeCells is set to false\n            for (const range of this.mergedRanges.slice()) {\n                if (range.column === column) {\n                    this.removeRange(range);\n                }\n            }\n            this.syncDom();\n            return;\n        }\n        this.refreshBounds();\n    }\n    // Remove might be transitioned, wait until it finishes before resetting (in the afterRemove hook)\n    afterRemove() {\n        !this.disabled && this.reset();\n    }\n    // Group collapsed or expanded\n    afterToggleGroup() {\n        !this.disabled && this.reset();\n    }\n    // SubGrid collapsed or expanded\n    afterToggleSubGrid() {\n        !this.disabled && this.reset();\n    }\n    // setHoveredRow(row) {\n    //     this.$hovered = row && this.mergedRanges.find(r => r.fromIndex <= row.dataIndex && r.toIndex >= row.dataIndex);\n    //\n    //     this.syncDom();\n    // }\n    // Selection changed, range is considered selected when all of its rows are selected (only in passthrough mode)\n    afterSelectionChange() {\n        if (!this.passthrough) {\n            const\n                { client } = this,\n                indices    = client.selectedRecords.map(r => client.store.indexOf(r));\n            let changed    = false;\n            for (const range of this.mergedRanges) {\n                let allSelected = true;\n                // Check if all records in the range are selected\n                for (let i = range.fromIndex; i <= range.toIndex && allSelected; i++) {\n                    allSelected = indices.includes(i);\n                }\n                if (range.isSelected !== allSelected) {\n                    range.isSelected = allSelected;\n                    changed = true;\n                }\n            }\n            // Only redraw if a range selection status changed\n            changed && this.syncDom();\n        }\n    }\n    //endregion\n    //region Grid overrides\n    // Extract record from merged cells\n    getRecordFromElement(element) {\n        if (element.elementData?.range) {\n            return this.client.store.getAt(element.elementData.range.fromIndex);\n        }\n        return this.overridden.getRecordFromElement(element);\n    }\n    // Extract column from merged cells\n    getColumnFromElement(element) {\n        if (element.elementData?.range) {\n            return element.elementData.range.column;\n        }\n        return this.overridden.getColumnFromElement(element);\n    }\n    //endregion\n    //region Header menu\n    // Allow toggling merging cells from the column header menu (unless column is explicitly disallowing it)\n    populateHeaderMenu({ column, items }) {\n        if (column.mergeable !== false) {\n            items.mergeCells = {\n                text     : 'L{MergeCells.mergeCells}',\n                icon     : `b-fw-icon ${column.mergeCells ? 'b-icon-checked' : 'b-icon-unchecked'}`,\n                tooltip  : 'L{MergeCells.menuTooltip}',\n                cls      : 'b-separator',\n                weight   : 500,\n                disabled : this.disabled,\n                onItem   : () => column.mergeCells = !column.mergeCells\n            };\n        }\n    }\n    //endregion\n    //region Relaying events\n    // Relay pointer events from the merged cell on grid\n    async handleEvent(event) {\n        if (!this.passthrough) {\n            const mergedCellsElement = event.target.closest('.b-grid-merged-cells');\n            if (mergedCellsElement) {\n                const\n                    { client }   = this,\n                    { range }    = mergedCellsElement.elementData,\n                    { cellEdit } = client.features,\n                    { column }   = range,\n                    type         = StringHelper.capitalize(camelCase[event.type] ?? event.type),\n                    eventData    = {\n                        grid        : client,\n                        records     : [],\n                        column,\n                        cellElement : mergedCellsElement.firstElementChild,\n                        target      : event.target,\n                        event\n                    };\n                for (let i = range.fromIndex; i <= range.toIndex; i++) {\n                    eventData.records.push(client.store.getAt(i));\n                }\n                client.trigger(`mergedCell${type}`, eventData);\n                // Cell editing, pass through to cell underneath even when not using passthrough mode\n                if (cellEdit?.triggerEvent.toLowerCase() === `cell${type}`.toLowerCase()) {\n                    const row = client.rowManager.getRowAt(event.clientY);\n                    await cellEdit.startEditing({ id : row.id, columnId : column.id });\n                }\n                // Select ranges rows when clicking the merged cell\n                else if (event.type === 'click') {\n                    this.onRangeClick({ range });\n                }\n            }\n        }\n    }\n    //endregion\n    //region Event listeners\n    // Select ranges rows when clicking a merged cell\n    onRangeClick({ range }) {\n        const records = [];\n        for (let i = range.fromIndex; i <= range.toIndex; i++) {\n            records.push(this.client.store.getAt(i));\n        }\n        this.client.selectedRecords = records;\n    }\n    // Reset when data changes\n    onStoreChange() {\n        !this.disabled && this.reset();\n    }\n    // Reset before grids refresh listener come into play, grid will redraw\n    onStoreRefresh({ action }) {\n        // filter & dataset triggers change too, handled above\n        if (action !== 'filter' && action !== 'dataset') {\n            !this.disabled && this.reset(false);\n        }\n    }\n    //endregion\n    //region Render\n    // Element is needed early since it is passed to column renderers, and syncing for each rendered cell would give a\n    // lot of overhead. Thus creating element directly instead\n    createRangeElement(range) {\n        const\n            parent = this.client.getSubGridFromColumn(range.column).$mergedCellsElement,\n            syncId = `${range.fromIndex}-@-${range.column.id}`;\n        // If there is already an element for the range (also if previously released), we grab that one.\n        // We are bending the rules of DomSync here by spawning the element early\n        let element = parent.syncIdMap?.[syncId] ?? parent.releasedIdMap?.[syncId];\n        // No longer considered released\n        if (parent.releasedIdMap) {\n            delete parent.releasedIdMap[syncId];\n        }\n        if (!element) {\n            element = DomHelper.createElement(this.createRangeDomConfig(range));\n        }\n        // New element or reusing released one, DomSync need to be made aware\n        DomSync.addChild(parent, element, syncId);\n        range.element = element;\n        range.cellElement = element.firstElementChild;\n        return element;\n    }\n    // Create a DomConfig object for the supplied range, used initially with DomHelper and thereafter with DomSync\n    createRangeDomConfig(range) {\n        const\n            { column, fromIndex, toIndex, top, left, right, width, height } = range,\n            { type } = column,\n            record = this.client.store.getAt(fromIndex),\n            domConfig = {\n                className : {\n                    'b-grid-merged-cells' : 1,\n                    // 'b-hover'             : this.$hovered === range,\n                    'b-selected'          : range.isSelected\n                },\n                elementData : {\n                    range\n                },\n                style : {\n                    top,\n                    left,\n                    right,\n                    height,\n                    width\n                },\n                dataset : {\n                    syncId   : `${fromIndex}-@-${column.id}`,\n                    fromIndex,\n                    toIndex,\n                    column   : column.field,\n                    columnId : column.id\n                },\n                children : [\n                    // Div for an actual cell\n                    {\n                        className : new DomClassList(this.client.cellCls).assign({\n                            [`b-${type?.toLowerCase()}-cell`] : type,\n                            [column.cellCls]                  : column.cellCls,\n                            [column.internalCellCls]          : column.internalCellCls\n                        }).assign(column.autoCls),\n                        // Don't touch cell children that might have been added by renderer\n                        keepChildren : true,\n                        // Tag along the range for easy resolving later\n                        elementData  : {\n                            range\n                        },\n                        // Dataset expected on cells\n                        dataset : {\n                            column   : column.field,\n                            columnId : column.id\n                        },\n                        // Size using configured row height, to at least have a chance of lining up with surrounding cells\n                        style : {\n                            height : this.client.rowManager.rowHeight\n                        }\n                    }\n                ]\n            };\n        // Allow application code a chance to affect the merged cell (intended for styling)\n        column.mergedRenderer?.({ domConfig, value : column.getRawValue(record), record, column, fromIndex, toIndex });\n        return domConfig;\n    }\n    buildMergedCellsConfig(fromIndex, toIndex, rows) {\n        const\n            me             = this,\n            { client }     = me,\n            { rowManager } = client;\n        // When exporting content we render rows to a document fragment one by one without RowManager. In\n        // order to draw ranges correctly in this case we need provide some meta information - list of row-like\n        // objects from which we can size for merged cell element, i.e. top, bottom, height, dataIndex\n        // Match grids row buffer, drawing ranges from the topmost row to the bottommost\n        fromIndex = fromIndex ?? rowManager.topRow?.dataIndex;\n        toIndex = toIndex ?? rowManager.bottomRow?.dataIndex;\n        const\n            // { locked = [], normal = [] }\n            domConfigMap = client.regions.reduce((map, region) => {\n                map[region] = {\n                    className : {\n                        'b-grid-merged-cells-container' : 1\n                    },\n                    children : []\n                };\n                return map;\n            }, {});\n        // Determine and update visible ranges\n        for (const range of me.mergedRanges) {\n            if (range.use && range.fromIndex <= toIndex && range.toIndex >= fromIndex) {\n                // Update the range, in case more of it has been scrolled into view\n                me.updateRange(range, me.heightChanged, rows);\n                // Create a DomConfig for it\n                domConfigMap[range.column.region].children.push(me.createRangeDomConfig(range));\n            }\n        }\n        return domConfigMap;\n    }\n    syncDom(force = false) {\n        const\n            me             = this,\n            { client }     = me,\n            { rowManager } = client;\n        // Bail out if we get here too early (happens in Scheduler) or are disabled\n        if (!force && !rowManager.topRow || me.disabled && !me.isDisabling) {\n            return;\n        }\n        const domConfigMap = this.buildMergedCellsConfig();\n        // Sync per subgrid\n        client.eachSubGrid(subGrid => {\n            DomSync.sync({\n                targetElement : subGrid.$mergedCellsElement,\n                syncIdField   : 'syncId',\n                domConfig     : domConfigMap[subGrid.region]\n            });\n        });\n        me.heightChanged = false;\n    }\n    // Called after rows are updated, sync visible ranges per subgrid\n    onRenderDone() {\n        this.syncDom();\n    }\n    //endregion\n    //region Ranges\n    // Remove range from list and index/column map, leaving no trace it since we don't know if it will ever\n    // come back (element will be released by DomSync)\n    removeRange(range) {\n        ArrayHelper.remove(this.mergedRanges, range);\n        for (let index = range.fromIndex; index <= range.toIndex; index++) {\n            delete this.mergedMap[`${index}-@-${range.column.id}`];\n        }\n    }\n    // Full reset, regenerating all ranges\n    reset(redraw = true, force = false) {\n        const\n            me        = this,\n            columns   = me.client.columns.visibleColumns.filter(c => c.mergeCells && (c.isSorted || !me.sortedOnly || force), true),\n            hadRanges = me.mergedRanges.length;\n        me.mergedRanges = [];\n        me.mergedMap = {};\n        if (redraw && !me.client.refreshSuspended) {\n            for (const row of me.client.rowManager.rows) {\n                for (const column of columns) {\n                    row.renderCell(row.getCell(column.id));\n                }\n            }\n            // Redraw, forcing it if all rows are gone\n            me.syncDom(hadRanges && !me.client.rowManager.rowCount);\n        }\n    }\n    // Refreshes existing ranges coords\n    refreshBounds() {\n        const\n            { mergedRanges } = this,\n            row              = this.client.rowManager.topRow,\n            boundsMap        = new Map(),\n            isRtl            = this.client.rtl;\n        for (const range of mergedRanges.slice()) {\n            const\n                { column }  = range,\n                cellElement = row.getCell(column.id);\n            // Column shown\n            if (cellElement) {\n                let { rowWidth, bounds } = boundsMap.get(column) ?? {};\n                if (!bounds) {\n                    // Temporarily cache bounds to avoid calculating them multiple times\n                    rowWidth = cellElement.parentElement.offsetWidth;\n                    bounds = Rectangle.from(cellElement, cellElement.parentElement);\n                    boundsMap.set(column, { rowWidth, bounds });\n                }\n                if (isRtl) {\n                    range.right = rowWidth - bounds.right;\n                }\n                else {\n                    range.left = bounds.left;\n                }\n                range.width = bounds.width;\n            }\n            // Column hidden or removed\n            else {\n                this.removeRange(range);\n            }\n        }\n        this.syncDom();\n    }\n    // Updates the range as user scrolls, until its start and end coords are fully known\n    // Rows argument is required to render merged cells on export. We provide row-like objects there\n    updateRange(range, force, rows = null) {\n        const\n            { store, rowManager }           = this.client,\n            { topRendered, bottomRendered } = range,\n            { rowOffsetHeight }             = rowManager;\n        let { fromIndex, toIndex } = range,\n            topRow, bottomRow;\n        force = rows ? rows.length > 0 : force;\n        // No need to update anything if bounds are correct already\n        if (!force && topRendered && bottomRendered) {\n            return;\n        }\n        if (!topRendered || force) {\n            if (rows) {\n                const index = rows.findIndex(row => row.dataIndex >= fromIndex);\n                topRow = rows[index];\n                fromIndex = topRow.dataIndex;\n            }\n            else {\n                do {\n                    topRow = rowManager.getRowById(store.getAt(fromIndex));\n                }\n                while (!topRow && fromIndex++ < toIndex);\n            }\n            // topRow is the actual topmost row in the range\n            range.topRendered = (fromIndex === range.fromIndex);\n            const rowsAbove = fromIndex - range.fromIndex;\n            range.top = topRow.top - rowsAbove * (rows ? topRow.offsetHeight : rowOffsetHeight);\n        }\n        if (!bottomRendered || force) {\n            if (rows) {\n                // We need to find last index, so we can just pick max between -1 and whatever we find\n                const index = rows.findIndex(row => row.dataIndex === toIndex);\n                bottomRow = rows[index === -1 ? rows.length - 1 : index];\n                fromIndex = bottomRow.dataIndex;\n            }\n            else {\n                do {\n                    bottomRow = rowManager.getRowById(store.getAt(toIndex));\n                }\n                while (!bottomRow && toIndex-- > fromIndex);\n            }\n            // bottomRow is the actual bottommost row in the range\n            range.bottomRendered = (toIndex === range.toIndex);\n            const rowsBelow = range.toIndex - toIndex;\n            range.bottom = bottomRow.bottom + rowsBelow * (rows ? bottomRow.offsetHeight : rowOffsetHeight);\n        }\n        range.height = range.bottom - range.top;\n    }\n    // Retrieve a range for the specified record / column, creating a new one if none found by walking upwards and\n    // downwards until a deviating value is found\n    getMergeRange(record, column) {\n        if (record.isSpecialRow) {\n            return;\n        }\n        const\n            me            = this,\n            { mergedMap } = me,\n            { store }     = me.client,\n            row           = me.client.rowManager.topRow,\n            columnId      = column.id,\n            index         = store.indexOf(record),\n            key           = `${index}-@-${columnId}`,\n            isRtl         = this.client.rtl;\n        let range = mergedMap[key];\n        if (!range) {\n            const value = column.getRawValue(record);\n            range = mergedMap[key] = {\n                column\n            };\n            me.mergedRanges.push(range);\n            // Search up until encountering different value\n            let earlierRecord, earlierValue, earlierIndex = index;\n            do {\n                earlierRecord = store.getAt(--earlierIndex);\n                earlierValue  = earlierRecord && column.getRawValue(earlierRecord);\n                if (earlierValue === value) {\n                    mergedMap[`${earlierIndex}-@-${columnId}`] = range;\n                }\n            } while (earlierRecord && !earlierRecord.isSpecialRow && earlierValue === value);\n            // And down\n            let laterRecord, laterValue, laterIndex = index;\n            do {\n                laterRecord = store.getAt(++laterIndex);\n                laterValue  = laterRecord && column.getRawValue(laterRecord);\n                if (laterValue === value) {\n                    mergedMap[`${laterIndex}-@-${columnId}`] = range;\n                }\n            } while (laterRecord && !laterRecord.isSpecialRow && laterValue === value);\n            range.fromIndex = earlierIndex + 1;\n            range.toIndex   = laterIndex - 1;\n            // We only care about ranges longer than 1 record\n            if (range.toIndex - range.fromIndex > 0) {\n                const\n                    cellElement = row.getCell(columnId),\n                    rowWidth    = cellElement.parentElement.offsetWidth,\n                    cellBounds  = Rectangle.from(cellElement, cellElement.parentElement);\n                if (isRtl) {\n                    range.right = rowWidth - cellBounds.right;\n                }\n                else {\n                    range.left = cellBounds.left;\n                }\n                range.width = cellBounds.width;\n                range.use = true;\n            }\n        }\n        if (!range.element && range.use) {\n            me.createRangeElement(range);\n        }\n        return range;\n    }\n    //endregion\n}\nMergeCells._$name = 'MergeCells'; GridFeatureManager.registerFeature(MergeCells);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nconst actions = {\n    goToNextHit      : 1,\n    goToPrevHit      : 1,\n    showFilterEditor : 1,\n    clearSearch      : 1\n};\n/**\n * @module Grid/feature/QuickFind\n */\n/**\n * Feature that allows the user to search in a column by focusing a cell and typing. Navigate between hits using the\n * keyboard, [f3] or [ctrl]/[cmd] + [g] moves to next, also pressing [shift] moves to previous.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys                | Action             | Action description                |\n * |---------------------|--------------------|-----------------------------------|\n * | `F3`                | *goToNextHit*      | Move focus to next search hit     |\n * | `Shift`+F3`         | *goToPrevHit*      | Move focus to previous search hit |\n * | `Ctrl`+`G`          | *goToNextHit*      | Move focus to next search hit     |\n * | `Ctrl`+`Shift`+`G`  | *goToPrevHit*      | Move focus to previous search hit |\n * | `Ctrl`+`Shift`+`F3` | *showFilterEditor* | Shows the filter editor           |\n * | `Escape`            | *clearSearch*      | Removes the search completely     |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * ```javascript\n * // enable QuickFind\n * let grid = new Grid({\n *   features: {\n *     quickFind: true\n *   }\n * });\n * ```\n *\n * // navigate to next hit programmatically\n * grid.features.quickFind.gotoNextHit();\n *\n * {@inlineexample Grid/feature/QuickFind.js}\n *\n * @demo Grid/quickfind\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype quickFind\n * @feature\n */\nexport default class QuickFind extends InstancePlugin {\n    //region Config\n    static $name = 'QuickFind';\n    static configurable = {\n        mode : 'header',\n        find : '',\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            F3             : 'gotoNextHit',\n            'Shift+F3'     : 'gotoPrevHit',\n            'Ctrl+g'       : 'gotoNextHit',\n            'Ctrl+Shift+g' : 'gotoPrevHit',\n            'Ctrl+Shift+f' : 'showFilterEditor',\n            Escape         : 'clearSearch',\n            //Private\n            Backspace : 'onBackspace'\n        }\n    };\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onElementKeyPress', 'onCellNavigate']\n        };\n    }\n    //endregion\n    //region Init\n    static get properties() {\n        return {\n            hitCls          : 'b-quick-hit',\n            hitCellCls      : 'b-quick-hit-cell',\n            hitCellBadgeCls : 'b-quick-hit-cell-badge',\n            hitTextCls      : 'b-quick-hit-text'\n        };\n    }\n    construct(grid, config) {\n        super.construct(grid, config);\n        Object.assign(this, {\n            grid,\n            treeWalker : grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)\n        });\n    }\n    isActionAvailable({ actionName }) {\n        if (actions[actionName]) {\n            const { focusedCell } = this.grid;\n            return !this.disabled && focusedCell?.record && !focusedCell.isActionable && this.find.length > 0;\n        }\n    }\n    doDisable(disable) {\n        if (disable) {\n            this.clear();\n        }\n        super.doDisable(disable);\n    }\n    get store() {\n        return this.grid.store;\n    }\n    //endregion\n    //region Show/hide QuickFind\n    /**\n     * Shows a \"searchfield\" in the header. Triggered automatically when you have a cell focused and start typing.\n     * @private\n     */\n    showQuickFind() {\n        const\n            me       = this,\n            { grid } = me,\n            header   = grid.getHeaderElement(me.columnId);\n        if (header) {\n            if (!me.headerField) {\n                const [element, field, badge] = DomHelper.createElement({\n                    tag       : 'div',\n                    className : 'b-quick-hit-header',\n                    children  : [\n                        { tag : 'div', className : 'b-quick-hit-field' },\n                        { tag : 'div', className : 'b-quick-hit-badge' }\n                    ]\n                }, { returnAll : true });\n                if (me.mode === 'header') {\n                    header.appendChild(element);\n                }\n                else {\n                    element.className += ' b-quick-hit-mode-grid';\n                    grid.element.appendChild(element);\n                }\n                me.headerField = {\n                    header    : element,\n                    field,\n                    badge,\n                    colHeader : header\n                };\n            }\n            me.headerField.field.innerHTML = me.find;\n            me.headerField.badge.innerHTML = me.found.length;\n            header.classList.add('b-quick-find-header');\n        }\n        if ((header || grid.hideHeaders) && !me.renderListenerInitialized) {\n            grid.rowManager.ion({\n                rendercell : me.renderCell,\n                thisObj    : me\n            });\n            me.renderListenerInitialized = true;\n        }\n    }\n    /**\n     * Hide the \"searchfield\" and remove highlighted hits. Called automatically when pressing [esc] or backspacing away\n     * the keywords.\n     * @private\n     */\n    hideQuickFind() {\n        const\n            me                    = this,\n            { grid, headerField } = me;\n        // rerender cells to remove quick-find markup\n        for (const hit of (me.prevFound || me.found)) {\n            const row = grid.getRowById(hit.id);\n            if (row) {\n                // Need to force replace quick finds markup\n                row.forceInnerHTML = true;\n                const cellElement = row.getCell(me.columnId);\n                cellElement._content = null;\n                row.renderCell(cellElement);\n                row.forceInnerHTML = false;\n            }\n        }\n        if (headerField) {\n            headerField.header.parentNode.removeChild(headerField.header);\n            headerField.colHeader.classList.remove('b-quick-find-header');\n            me.headerField = null;\n        }\n        if (me.renderListenerInitialized) {\n            grid.rowManager.un({ rendercell : me.renderCell }, me);\n            me.renderListenerInitialized = false;\n        }\n        grid.trigger('hideQuickFind');\n    }\n    //endregion\n    //region Search\n    /**\n     * Performs a search and highlights hits. If find is empty, QuickFind is closed.\n     * @param {String} find Text to search for\n     * @param {String} columnFieldOrId Column to search\n     */\n    search(find, columnFieldOrId = this.columnId, fromSplit = false) {\n        const\n            me       = this,\n            { grid } = me,\n            column   = grid.columns.getById(columnFieldOrId) || grid.columns.get(columnFieldOrId),\n            found    = me.store.findByField(column.field, find, column.mergeCells && column.isSorted);\n        let i = 1;\n        Object.assign(me, {\n            foundMap  : {},\n            prevFound : me.found,\n            found,\n            find,\n            columnId  : column.id,\n            findRe    : new RegExp(`(\\\\s+)?(${StringHelper.escapeRegExp(String(find))})(\\\\s+)?`, 'ig')\n        });\n        if (find) {\n            me.showQuickFind();\n        }\n        else {\n            me.hideQuickFind();\n        }\n        // clear old hits\n        for (const cellElement of DomHelper.children(grid.element, `.${me.hitCls}`)) {\n            cellElement.classList.remove(me.hitCls, me.hitCellCls);\n            if (cellElement._originalContent) {\n                cellElement.innerHTML = cellElement._originalContent;\n                cellElement._originalContent = null;\n            }\n        }\n        if (!found) {\n            return;\n        }\n        if (found.length > 0 && !fromSplit) {\n            me.gotoClosestHit(grid.focusedCell, found);\n        }\n        // highlight hits for visible cells\n        for (const hit of found) {\n            me.foundMap[hit.id] = i++;\n            const row = grid.getRowById(hit.data.id);\n            row?.renderCell(row.getCell(column.id));\n            // limit highlighted hits\n            if (i > 1000) {\n                break;\n            }\n        }\n        // Relay to other grids when splitting\n        grid.syncSplits?.(other => other.features.quickFind.search(find, columnFieldOrId, true));\n        grid.trigger('quickFind', { find, found });\n    }\n    /**\n     * Clears and closes QuickFind.\n     */\n    clear() {\n        if (this.find || this.found?.length) {\n            this.search('');\n        }\n    }\n    /**\n     * Number of results found\n     * @type {Number}\n     * @readonly\n     */\n    get foundCount() {\n        return this.found?.length ?? 0;\n    }\n    /**\n     * Found results (as returned by Store#findByField), an array in format { index: x, data: record }\n     * @member {StoreSearchResult[]} found\n     * @readonly\n     */\n    //endregion\n    //region Navigation\n    /**\n     * Go to specified hit.\n     * @param {Number} index\n     */\n    gotoHit(index) {\n        const nextHit = this.found[index];\n        if (nextHit) {\n            this.grid.focusCell({\n                columnId : this.columnId,\n                id       : nextHit.id\n            }, { doSelect : true });\n        }\n        return !!nextHit;\n    }\n    gotoClosestHit(focusedCell, found) {\n        const\n            focusedIndex = focusedCell ? this.grid.store.indexOf(focusedCell.id) : 0,\n            foundSorted  = found.slice().sort(\n                (a, b) => Math.abs(a.index - focusedIndex) - Math.abs(b.index - focusedIndex)\n            );\n        this.gotoHit(found.indexOf(foundSorted[0]));\n    }\n    /**\n     * Go to the first hit.\n     */\n    gotoFirstHit() {\n        this.gotoHit(0);\n    }\n    /**\n     * Go to the last hit.\n     */\n    gotoLastHit() {\n        this.gotoHit(this.found.length - 1);\n    }\n    /**\n     * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].\n     */\n    gotoNextHit() {\n        const\n            me           = this,\n            { grid }     = me,\n            // start from focused cell, or if focus has left grid use lastFocusedCell\n            currentId    = grid._focusedCell?.id ?? grid.lastFocusedCell?.id,\n            currentIndex = grid.store.indexOf(currentId) || 0,\n            nextHit      = me.found.find(hit => hit.index > currentIndex);\n        if (nextHit) {\n            grid.focusCell({\n                columnId : me.columnId,\n                id       : nextHit.id\n            }, { doSelect : true });\n        }\n        else {\n            me.gotoFirstHit();\n        }\n    }\n    /**\n     * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].\n     */\n    gotoPrevHit() {\n        const\n            me              = this,\n            { grid, found } = me,\n            currentId       = grid._focusedCell?.id ?? grid.lastFocusedCell?.id,\n            currentIndex    = grid.store.indexOf(currentId) || 0;\n        let prevHit;\n        if (!found.length) {\n            return;\n        }\n        for (let i = found.length - 1; i--; i >= 0) {\n            if (found[i].index < currentIndex) {\n                prevHit = found[i];\n                break;\n            }\n        }\n        if (prevHit) {\n            grid.focusCell({\n                columnId : me.columnId,\n                id       : prevHit.id\n            }, { doSelect : true });\n        }\n        else {\n            me.gotoLastHit();\n        }\n    }\n    //endregion\n    //region Render\n    /**\n     * Called from SubGrid when a cell is rendered.\n     * @private\n     */\n    renderCell({ cellElement, column, record }) {\n        const\n            me           = this,\n            { classList } = cellElement,\n            {\n                treeWalker,\n                findRe,\n                hitTextCls\n            }           = me,\n            hitIndex    = me.columnId === column.id && me.foundMap?.[record.id];\n        if (hitIndex) {\n            // highlight cell\n            classList.add(me.hitCls);\n            cellElement.isQuickHit = true;\n            cellElement._originalContent = cellElement.innerHTML;\n            // if features have added other stuff to the cell, value is in div.b-grid-cell-value\n            // highlight in cell if found in innerHTML\n            const inner = treeWalker.currentNode = DomHelper.down(cellElement, '.b-grid-cell-value,.b-tree-cell-value') || cellElement;\n            for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode);) {\n                const\n                    nodeToReplace = textNode,\n                    textContent   = textNode.nodeValue,\n                    newText       = ['<span>'];\n                // Move onto next text node before we replace the node with a highlight HTML sequence\n                textNode = treeWalker.nextNode();\n                let offset = findRe.lastIndex;\n                // Convert textContent into an innerHTML string which htmlEncodes the text and embeds\n                // a highlighting span which contains the target text.\n                for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {\n                    const\n                        preamble    = textContent.substring(offset, match.index),\n                        spaceBefore = match[1] ? '\\xa0' : '',\n                        v           = match[2],\n                        spaceAfter  = match[3] ? '\\xa0' : '';\n                    newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class=\"${hitTextCls}\">${v}</span>${spaceAfter}`);\n                    offset = findRe.lastIndex;\n                }\n                newText.push(StringHelper.encodeHtml(textContent.substring(offset)), '</span>');\n                // Insert a fragment with each match wrapped with a span.\n                nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(''), {\n                    fragment : true\n                }), nodeToReplace);\n                nodeToReplace.remove();\n            }\n            DomHelper.createElement({\n                parent    : cellElement,\n                className : me.hitCellBadgeCls,\n                text      : hitIndex\n            });\n        }\n    }\n    //endregion\n    //region Events\n    onBackspace(event) {\n        const me = this;\n        if (me.find) {\n            me.find = me.find.substr(0, me.find.length - 1);\n            me.search(me.find);\n            return true;\n        }\n        return false;\n    }\n    clearSearch() {\n        if (this.find) {\n            this.find = '';\n            this.search(this.find);\n            return true;\n        }\n        return false;\n    }\n    showFilterEditor() {\n        const\n            me = this,\n            { filter } = me.client.features;\n        if (filter && me.columnId && me.foundCount) {\n            me.clear();\n            filter.showFilterEditor(me.client.columns.getById(me.columnId), me.find);\n        }\n    }\n    /**\n     * Chained function called on grids keypress event. Handles input for \"searchfield\".\n     * @private\n     * @param event\n     */\n    onElementKeyPress(event) {\n        const\n            me              = this,\n            { grid }        = me,\n            { focusedCell } = grid;\n        // Only react to keystrokes on grid cell elements\n        if (!event.handled && !me.disabled && focusedCell?.record && !focusedCell.isActionable && event.key?.length === 1) {\n            const column = grid.columns.getById(grid._focusedCell.columnId);\n            // if trying to search in invalid column, it's a hard failure\n            if (column && column.searchable !== false) {\n                me.columnId = grid._focusedCell.columnId;\n                me.find += event.key;\n                me.search(me.find);\n            }\n        }\n    }\n    onCellNavigate(grid, fromCellSelector, toCellSelector) {\n        const\n            me    = this;\n        if (me.find && (!toCellSelector || toCellSelector.columnId !== me.columnId)) {\n            me.clear();\n        }\n    }\n    //endregion\n}\nQuickFind._$name = 'QuickFind'; GridFeatureManager.registerFeature(QuickFind);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport Objects from '../../Core/helper/util/Objects.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport GlobalEvents from '../../Core/GlobalEvents.js';\nimport '../column/ActionColumn.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nconst actions = {\n    onTab      : 1,\n    onShiftTab : 1\n};\n/**\n * @module Grid/feature/RowExpander\n */\nconst storeRemoveActions = { remove : 1, filter : 1, dataset : 1, replace : 1 };\n/**\n * Enables expanding of Grid rows by either row click or double click, or by adding a separate Grid column which renders\n * a button that expands or collapses the row.\n *\n * {@inlineexample Grid/feature/RowExpander.js}\n *\n * The content of the expanded row body is rendered by providing either a {@link #config-renderer} function to the\n * rowExpander feature config:\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            renderer({record, region, expanderElement}){\n *                return htmlToBeExpanded;\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * Or a {@link #config-widget} configuration object:\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            widget : {\n *                type : 'detailGrid',\n *            },\n *            dataField : 'orderDetails'\n *        }\n *    }\n * });\n * ```\n *\n * {@inlineexample Grid/feature/RowExpanderWidget.js}\n *\n * <div class=\"note\">Note that if used in a Gantt, the Gant's `fixedRowHeight` must be set to `false`.</div>\n *\n * This feature is **disabled** by default\n *\n * ## Expand on click\n * Set {@link #config-triggerEvent} to a Grid cell event that should trigger row expanding and collapsing.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            triggerEvent: 'celldblclick',\n *            renderer...\n *        }\n *    }\n * });\n * ```\n *\n * ## Expander column position\n * The expander column can either be inserted before or after the existing Grid columns. If the Grid has multiple\n * regions the column will be added to the first region.\n *\n * Adjust expander column position to last in a specific Grid region by setting {@link #config-columnPosition}\n * to `last` and configuring the {@link #config-column} with a region name.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            column: {\n *                region: 'last'\n *            },\n *            columnPosition: 'last',\n *            renderer...\n *        }\n *    }\n * });\n * ```\n *\n * ## Record update\n * If the expander content depends on row record data, the expander can be re-rendered on record update by setting\n * {@link #config-refreshOnRecordChange} to `true`.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            refreshOnRecordChange: true,\n *            renderer...\n *        }\n *    }\n * });\n * ```\n *\n * ## Async\n * When the content of the row expander should be rendered async just see to it that you return a promise.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            async renderer({record, region, expanderElement}){\n *                return fetchFromBackendAndRenderData(record);\n *            }\n *        }\n *    }\n * });\n *```\n *\n * ## Multiple regions\n * When the Grid has more than one region, the {@link #config-renderer} function will be called once per region for each\n * expanding row.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            renderer({ record, region }) {\n *                if(region === 'locked') {\n *                    return createRowExpander(record);\n *                }\n *\n *                return null;\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * If you are using the {@link #config-widget} configuration, you can provide a widget configuration object for each\n * region like so:\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            widget : {\n *                locked : {\n *                    type : 'detailGrid',\n *                    // If your widgets uses different data sources, out the dataField\n *                    //  property in the widget configuration object\n *                    dataField : 'orderDetails'\n *                },\n *                normal : {\n *                    type : 'summaryGrid',\n *                    dataField : 'sumDetails'\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * If you want your expanded content to span over all Grid regions, set the {@link #config-spanRegions} config to\n * `true`.\n *\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype rowExpander\n * @feature\n */\nexport default class RowExpander extends InstancePlugin.mixin(Delayable) {\n    //region Config\n    static $name = 'RowExpander';\n    // Cannot use `static properties = {}`, new Map/Set would pollute the prototype\n    static get properties() {\n        return {\n            // CSS classes\n            expanderBodyClass        : 'b-rowexpander-body',\n            expandedRowClass         : 'b-rowexpander-row-expanded',\n            shadowRootContainerClass : 'b-rowexpander-shadowroot-container',\n            // Map where the keys are the expanded records and values are an object\n            // {rowHeight, cellHeight, expandedBodyElements}\n            recordStateMap           : new Map(),\n            collapsingStateMap       : new Map()\n        };\n    }\n    static configurable = {\n        /**\n         * The implementation of this function is called each time the body of an expanded row is rendered. Either\n         * return an HTML string, a {@link Core.helper.DomHelper#typedef-DomConfig} object describing the markup or any\n         * Widget configuration object, like a Grid configuration object for example.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            renderer({record, region, expanderElement}){\n         *                return htmlToBeExpanded;\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * Or return a {@link Core.helper.DomHelper#typedef-DomConfig} object.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            renderer({record, region, expanderElement}){\n         *                return {\n         *                   tag       : 'form',\n         *                   className : 'expanded-row-form',\n         *                   children  : [\n         *                       {\n         *                           tag        : 'textarea',\n         *                           name       : 'description',\n         *                           className  : 'expanded-textarea'\n         *                       },\n         *                       {\n         *                           tag        : 'button',\n         *                           text       : 'Save',\n         *                           className  : 'expanded-save-button',\n         *                       }\n         *                   ]\n         *                };\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * Or return a Widget configuration object. What differs a Widget configuration object from a DomConfig object\n         * is the presence of the `type` property and the absence of a `tag` property.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            async renderer({record, region, expanderElement}){\n         *                const myData = await fetch('myURL');\n         *                return {\n         *                   type : 'grid',\n         *                   autoHeight : true,\n         *                   columns : [\n         *                       ...\n         *                   ],\n         *                   data : myData\n         *                };\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * It is also possible to add markup directly to the expanderElement.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            renderer({record, region, expanderElement}){\n         *                new UIComponent({\n         *                    appendTo: expanderElement,\n         *                    ...\n         *                });\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         * The renderer function can also be asynchronous.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            async renderer({record, region, expanderElement}){\n         *                return await awaitAsynchronousOperation();\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} renderData Object containing renderer parameters\n         * @param {Core.data.Model} renderData.record Record for the row\n         * @param {HTMLElement} renderData.expanderElement Expander body element\n         * @param {HTMLElement} renderData.rowElement Row element\n         * @param {String} renderData.region Grid region name\n         * @param {Grid.view.Grid} renderData.grid Grid instance\n         * @returns {String|DomConfig|null} Row expander body content\n         * @async\n         *\n         * @category Rendering\n         */\n        renderer : null,\n        /**\n         * The name of the Grid event that will toggle expander. Defaults to `null` but can be set to any event such\n         * as {@link Grid.view.mixin.GridElementEvents#event-cellDblClick} or\n         * {@link Grid.view.mixin.GridElementEvents#event-cellClick}.\n         *\n         * ```javascript\n         * features : {\n         *     rowExpander : {\n         *         triggerEvent : 'cellclick'\n         *     }\n         * }\n         * ```\n         *\n         * @config {String}\n         */\n        triggerEvent : null,\n        /**\n         * Provide a column config object to display a button with expand/collapse functionality.\n         * Shown by default, set to `null` to not include.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            column: {\n         *                // Use column config options here\n         *                region: 'last'\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {ActionColumnConfig|Grid.column.ActionColumn}\n         */\n        column : {},\n        /**\n         * Makes the expand/collapse button column appear either as the first column (default or `first`) or as the\n         * last (set to `last`). Note that the column by default will be added to the first region, if the Grid\n         * has multiple regions. Use the {@link #config-column} config to change region.\n         * @config {String}\n         * @default\n         */\n        columnPosition : 'first',\n        /**\n         * If set to `true`, the RowExpander will, on record update, re-render an expanded row by calling the\n         * {@link #config-renderer} function or recreate the configured {@link #config-widget}.\n         * @config {Boolean}\n         * @default\n         */\n        refreshOnRecordChange : false,\n        /**\n         * Use this for customizing async {@link #config-renderer} loading indicator height.\n         * @config {Number}\n         * @defalt\n         */\n        loadingIndicatorHeight : 100,\n        /**\n         * Use this for customizing async {@link #config-renderer} loading indicator text.\n         * @config {String}\n         * @default Loading\n         */\n        loadingIndicatorText : 'L{loading}',\n        /**\n         * Use this to disable expand and collapse animations.\n         * @config {Boolean}\n         * @default\n         */\n        enableAnimations : true,\n        /**\n         * A widget configuration object that will be used to create a widget to render into the row expander body. Can\n         * be used instead of providing a {@link #config-renderer}.\n         *\n         * If the widget needs a store, it can be populated by use of the {@link #config-dataField} config. This will\n         * create a store from the expanded record's corresponding `dataField` value, which needs to be an array of\n         * objects or a store itself.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            widget : {\n         *                type : 'detailGrid',\n         *            },\n         *            dataField : 'orderDetails'\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * If there is multiple regions, you can configure each region like so:\n         *\n         * ```javascript\n         * new Grid({\n         *     features : {\n         *         rowExpander : {\n         *             widget : {\n         *                 // The region name is the property, and its widget config the value\n         *                 left : {\n         *                    type : 'detailGrid',\n         *                    // If your widgets uses different data sources, put the dataField\n         *                    //  property in the widget configuration object\n         *                    dataField : 'orderDetails'\n         *                },\n         *                middle : {\n         *                    type : 'summaryGrid',\n         *                    dataField : 'sumDetails\n         *                },\n         *                // No expander here\n         *                right : null\n         *             }\n         *         }\n         *     }\n         * })\n         * ```\n         *\n         * @config {ContainerItemConfig}\n         */\n        widget : null,\n        /**\n         * Used together with {@link #config-widget} to populate the widget's Store from the expanded record's\n         * corresponding `dataField` value, which needs to be an array of objects or a store itself.\n         * @config {String}\n         */\n        dataField : null,\n        keyMap : {\n            // Private\n            Tab         : { handler : 'onTab', weight : 50 },\n            'Shift+Tab' : { handler : 'onShiftTab', weight : 50 }\n        },\n        /**\n         * When expanding a row and the expanded body element is not completely in view, setting this to `true` will\n         * automatically scroll the expanded row into view.\n         * @config {Boolean}\n         * @default\n         */\n        autoScroll : false,\n        /**\n         * When the Grid has multiple regions, setting this config to `true` changes how the expanded content is created\n         * and rendered. Instead of calling {@link #config-renderer} once per region (or one {@link #config-widget}\n         * per region) it will only create one expanded element which will span the full grid width regardless of Grid\n         * regions.\n         * @config {Boolean}\n         * @default\n         */\n        spanRegions : false\n    };\n    // Plugin configuration. This plugin chains/overrides some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain    : ['afterColumnsChange', 'beforeRenderRow', 'processRowHeight', 'bindStore', 'navigateUp'],\n            override : ['onGridBodyFocusIn', 'navigateDown', 'catchFocus', 'keyMapOnKeyDown']\n        };\n    }\n    //endregion\n    //region Init\n    afterConstruct() {\n        const\n            me         = this,\n            { client } = me;\n        if (!me.renderer && !me.widget) {\n            me.disabled = true;\n            console.warn('RowExpander requires either a widget config or implementing the renderer function.');\n            return;\n        }\n        if (client.isGanttBase && client.fixedRowHeight !== false) {\n            console.warn('When using RowExpander on a Gantt, the Gantt`s fixedRowHeight config must be set to false.');\n        }\n        if (me.widget) {\n            GlobalEvents.ion({\n                theme   : me.onThemeChange,\n                thisObj : me\n            });\n        }\n        // Bind initial store\n        me.bindStore(client.store);\n        if (me.triggerEvent) {\n            client.ion({ [me.triggerEvent] : 'onTriggerEvent', thisObj : me });\n        }\n        me.addColumn();\n    }\n    bindStore(store) {\n        const me = this;\n        me.recordStateMap.clear();\n        me.collapsingStateMap.clear();\n        me.detachListeners('clientStoreChange');\n        store.ion({\n            name    : 'clientStoreChange',\n            change  : me.onStoreChange,\n            thisObj : me\n        });\n    }\n    doDisable(disable) {\n        const { client } = this;\n        if (disable) {\n            this.recordStateMap.clear();\n            this.collapsingStateMap.clear();\n        }\n        if (!client.isConfiguring) {\n            client.rowManager.renderFromRow();\n        }\n        super.doDisable(disable);\n    }\n    changeLoadingIndicatorText(text) {\n        return text ? this.L(text) : text;\n    }\n    // Overrides onGridBodyFocusIn to ignore events on row expander body.\n    onGridBodyFocusIn(event) {\n        const me = this;\n        if (me.hasWidget ? !event.target.matches(`.${me.expanderBodyClass}, .${me.shadowRootContainerClass}`)\n            : !me.client.lastMousedownEvent?.target?.closest('.' + me.expanderBodyClass)\n        ) {\n            me.overridden.onGridBodyFocusIn(event);\n        }\n    }\n    // Override keyMap key down so to not acting on keydown inside nested grid\n    keyMapOnKeyDown({ target }) {\n        if (!this.hasWidget || !target.classList?.contains(this.shadowRootContainerClass)) {\n            this.overridden.keyMapOnKeyDown(...arguments);\n        }\n    }\n    get isAnimating() {\n        return this.client.isAnimating;\n    }\n    set isAnimating(value) {\n        const\n            { client }     = this,\n            wasAnimating   = client.isAnimating;\n        client.isAnimating = value;\n        if (client.isAnimating !== wasAnimating) {\n            client.element.classList.toggle('b-rowexpander-animating');\n        }\n    }\n    changeWidget(widget) {\n        if (widget && this.isWidgetConfig(widget)) {\n            return { [this.client.regions[0]] : widget };\n        }\n        return widget;\n    }\n    //endregion\n    //region Events\n    /**\n     * This event fires before row expand is started.\n     *\n     * Returning `false` from a listener prevents the RowExpander to expand the row.\n     *\n     * Note that this event fires when the RowExpander toggles the row, not when the actual row expander body is\n     * rendered. Most of the time this is synchronous, but in the case of a row that is not yet rendered into view by\n     * scrolling, it can happen much later.\n     *\n     * @event beforeExpand\n     * @preventable\n     * @async\n     * @param {Core.data.Model} record Record\n     */\n    /**\n     * This event fires before row collapse is started.\n     *\n     * Returning `false` from a listener prevents the RowExpander to collapse the row.\n     *\n     * Note that this event fires when the RowExpander toggles the row, not when the actual row expander body is\n     * rendered. Most of the time this is synchronous, but in the case of a row that is not yet rendered into view by\n     * scrolling, it can happen much later.\n     *\n     * @event beforeCollapse\n     * @preventable\n     * @async\n     * @param {Core.data.Model} record Record\n     */\n    /**\n     * This event fires when a row expand has finished expanding.\n     *\n     * Note that this event fires when actual row expander body is rendered, and not necessarily in immediate succession\n     * of an expand action. In the case of expanding a row that is not yet rendered into view by scrolling, it can happen\n     * much later.\n     *\n     * @event expand\n     * @param {Core.data.Model} record Record\n     * @param {Object} expandedElements An object with the Grid region name as property and the expanded body\n     * element as value\n     * @param {Core.widget.Widget} widget In case of expanding a Widget, this will be a reference to the instance\n     * created by the actual expansion. If there is multiple Grid regions, use the `widgets` param instead.\n     * @param {Object} widgets In case of expanding a Widget, this will be an object with the Grid region name as\n     * property and the reference to the widget instance created by the actual expansion\n     */\n    /**\n     * This event fires when a row has finished collapsing.\n     *\n     * @event collapse\n     * @param {Core.data.Model} record Record\n     */\n    //endregion\n    //region ExpanderColumn\n    afterColumnsChange() {\n        this.addColumn();\n    }\n    changeColumn(config) {\n        if (config == null) {\n            return config;\n        }\n        return {\n            type    : 'action',\n            actions : [{\n                cls     : 'b-icon b-icon-collapse-down',\n                tooltip : ({ record }) => this.L(this.recordStateMap.has(record) ? 'L{RowExpander.collapse}' : 'L{RowExpander.expand}'),\n                onClick : ({ record }) => this.toggleExpand(record)\n            }],\n            width    : 40,\n            hideable : false,\n            align    : 'center',\n            region   : this.client.regions[0],\n            ...config,\n            field    : 'expanderActionColumn'\n        };\n    }\n    // Called in construct and if grid columns change\n    addColumn() {\n        const\n            me          = this,\n            { column }  = me,\n            { columns } = me.client;\n        if (!me._isAddingExpanderColumn && column && (!me._expander || !columns.includes(me._expander))) {\n            me._isAddingExpanderColumn = true;\n            if (me.columnPosition === 'last') {\n                [me._expander] = columns.add(column);\n            }\n            else {\n                [me._expander] = columns.insert(0, column);\n            }\n            me._isAddingExpanderColumn = false;\n        }\n    }\n    //endregion\n    //region UI events\n    onTriggerEvent({ target }) {\n        // Only grid cell event is handled. Action-cell event has its own handler.\n        if (this.disabled || target?.closest('.b-action-cell') || !target.closest('.b-grid-cell')) {\n            return;\n        }\n        this.toggleExpand(this.client.getRecordFromElement(target));\n    }\n    /**\n     * Toggles expanded state.\n     * @private\n     * @param {Core.data.Model} record The record that should be toggled\n     * @category Internal\n     */\n    toggleExpand(record) {\n        if (record) {\n            if (this.recordStateMap.has(record)) {\n                this.collapse(record);\n            }\n            else {\n                this.expand(record);\n            }\n        }\n    }\n    onExpanderBodyResize(entries) {\n        for (const entry of entries) {\n            const\n                record      = this.client.store.getById(entry.target.dataset?.id),\n                recordState = record && this.recordStateMap.get(record);\n            if (recordState && !recordState.ignoreResize && !recordState.isAnimating) {\n                const oldHeight = recordState.expanderBodyHeight;\n                recordState.expanderBodyHeight = null; // Clears saved height to recalc in processRowHeight\n                if (this.processRowHeight(record, 0) !== oldHeight) {\n                    this.renderRowsWithAnimation(record);\n                }\n            }\n        }\n    }\n    //endregion\n    //region Rendering\n    get shouldSpanRegions() {\n        return this.spanRegions && this.client.regions.length > 1;\n    }\n    /**\n     * Listens to changes in the Grid Store. Will remove expand State data on Store removal.\n     * If the refreshOnRecordChange config is `true`, it will trigger a re-render of the expander.\n     * @private\n     * @param {String} action\n     * @param {Core.data.Store} source\n     * @param {Core.data.Model[]} records\n     * @category Internal\n     */\n    onStoreChange({ action, source, records, changes }) {\n        const\n            me                                     = this,\n            { recordStateMap, collapsingStateMap } = me,\n            changedKeys                            = changes && Object.keys(changes);\n        if (changedKeys?.length === 1 && source.modelClass.fieldMap[changedKeys[0]]?.type === 'store') {\n            return;\n        }\n        if (me.disabled) {\n            return;\n        }\n        if (action === 'removeAll') {\n            recordStateMap.clear();\n            collapsingStateMap.clear();\n        }\n        else if (storeRemoveActions[action]) {\n            for (const [record, state] of recordStateMap) {\n                if (!source.includes(record)) {\n                    me.destroyWidgets(state);\n                    recordStateMap.delete(record);\n                    collapsingStateMap.delete(record);\n                }\n            }\n        }\n        else if (me.refreshOnRecordChange && records?.length) {\n            if (action === 'update') {\n                const recordState = recordStateMap.get(records[0]);\n                if (recordState?.isCreated) {\n                    recordState.isCreated = false;\n                    me.client.rowManager.renderFromRecord(records[0]);\n                }\n            }\n            else if (action === 'updatemultiple') {\n                let topRecordIndex,\n                    topRecord;\n                for (const rec of records) {\n                    const recordState = recordStateMap.get(rec);\n                    if (recordState?.isCreated) {\n                        const index           = source.records.indexOf(rec);\n                        recordState.isCreated = false;\n                        if (!topRecord || topRecordIndex > index) {\n                            topRecordIndex = index;\n                            topRecord      = rec;\n                        }\n                    }\n                }\n                if (topRecord) {\n                    me.client.rowManager.renderFromRecord(topRecord);\n                }\n            }\n        }\n    }\n    // Implements grid.processRowHeight hook\n    processRowHeight(record, height) {\n        const\n            me                    = this,\n            { shouldSpanRegions } = me;\n        let recordState           = me.recordStateMap.get(record),\n            heightChanged         = false;\n        // If we have a recordState but no expanderBodyHeight, we should recalculate height.\n        if (recordState && !recordState.expanderBodyHeight) {\n            for (const region of me.client.regions) {\n                const height = recordState.expandedBodyElements[region]?.offsetHeight;\n                if (height > recordState.expanderBodyHeight) {\n                    recordState.expanderBodyHeight = height;\n                    heightChanged = true;\n                }\n            }\n        }\n        else if (!recordState && (recordState = me.collapsingStateMap.get(record)) && recordState.expanderBodyHeight) {\n            recordState.expanderBodyHeight = 0;\n            heightChanged = true;\n        }\n        if (heightChanged && me.enableAnimations && shouldSpanRegions) {\n            me.animateSpannedExpander(recordState);\n        }\n        return (recordState?.expanderBodyHeight ?? 0) + height;\n    }\n    // If we're using spanRegions, we need to force a CSS transition on the body elements height\n    animateSpannedExpander(state) {\n        const\n            me          = this,\n            bodyElement = state.expandedBodyElements[me.client.regions[0]],\n            rowElement  = me.client.rowManager.getRowById(state.record).element;\n        state.isAnimating = me.isAnimating = true;\n        state.ignoreResize = true;\n        // The bodyElement has no height per default, need to set one to get the CSS transition working\n        bodyElement.style.height = rowElement.offsetHeight - state.cellHeight + 'px';\n        bodyElement.offsetHeight; // Force DOM render\n        bodyElement.style.height = state.expanderBodyHeight + 'px';\n        me.waitForTransition(bodyElement, () => {\n            // Re-set no height\n            bodyElement.style.height = '';\n            if (!state.expanderBodyHeight) {\n                // If we're collapse, remove element\n                bodyElement.remove();\n            }\n            state.isAnimating = me.isAnimating = false;\n        });\n    }\n    /**\n     * Hooks on before row render to render or remove row expander content depending on record state.\n     * @private\n     * @category Internal\n     */\n    beforeRenderRow({ row, record }) {\n        const\n            me           = this,\n            { regions }  = me.client,\n            {\n                expandedRowClass,\n                collapsingStateMap,\n                shouldSpanRegions\n            }            = me,\n            // The map only contains record that are expanded\n            recordState  = me.recordStateMap.get(record);\n        row.cls.toggle('b-rowexpander-disabled', me.disabled);\n        // If current row is expanded\n        if (row.cls[expandedRowClass]) {\n            let collapsingState = collapsingStateMap.get(record);\n            if (collapsingState) {\n                const clearCollapse = () => {\n                    collapsingState = collapsingStateMap.get(record);\n                    // Make sure record still should be collapsed after animation is complete\n                    if (collapsingState) {\n                        collapsingStateMap.delete(record);\n                        me.removeExpander(row);\n                        me.destroyWidgets(collapsingState);\n                    }\n                };\n                // If animating a collapse, content should not be removed until animation is complete\n                if (me.enableAnimations && me.isAnimating) {\n                    me.waitForTransition(row, clearCollapse);\n                }\n                else {\n                    clearCollapse();\n                }\n            }\n            // Row is expanded but record should not be, remove expander\n            else if (!recordState) {\n                me.removeExpander(row);\n            }\n        }\n        else {\n            // Makes sure record should collapse no longer\n            collapsingStateMap.delete(record);\n        }\n        if (!me.disabled && recordState) {\n            // Expander content is created once, then reused.\n            if (!recordState.isCreated) {\n                recordState.ignoreResize = true; // Tells the resizeObserver to ignore this element right now\n                me.renderExpander(record, row, recordState);\n            }\n            row.cls.add(expandedRowClass);\n            regions.forEach((region, i) => {\n                const rowElement = row.getElement(region);\n                // isCreated means that the content has finished its creation process, which can be async\n                // If shouldSpanRegions, then we only do this on the first region\n                if (recordState.isCreated && (!shouldSpanRegions || i === 0)) {\n                    const\n                        bodyElement = recordState.expandedBodyElements[region],\n                        target      = shouldSpanRegions ? me.client.verticalScroller : rowElement;\n                    // If the bodyElement is connected to our target, we do not need to do anything\n                    if (bodyElement.parentElement !== target) {\n                        if (!shouldSpanRegions) {\n                            // If not, remove current content\n                            DomHelper.removeEachSelector(rowElement, '.' + me.expanderBodyClass);\n                        }\n                        // And add the created element\n                        target.appendChild(bodyElement);\n                        // Observe body element to refresh grid when the body element resizes\n                        me.observeResize(bodyElement);\n                    }\n                    if (shouldSpanRegions) {\n                        // Sync row top with expanded element top\n                        bodyElement.style.top = row.top + recordState.cellHeight + 'px';\n                    }\n                    recordState.ignoreResize = false;\n                    // Resolve the expand promise on next animation frame\n                    if (recordState.renderPromiseResolver && !recordState.isRenderingAsync) {\n                        me.delay(recordState.renderPromiseResolver);\n                        recordState.renderPromiseResolver = null;\n                    }\n                }\n                me.lockCellHeight(rowElement, recordState.cellHeight, false);\n            });\n            // If expander body is rendered not fully in view, it will be scrolled into view\n            if (me._shouldScrollIntoView && me.autoScroll) {\n                me._shouldScrollIntoView = false;\n                if (!DomHelper.isInView(recordState.expandedBodyElements[regions[0]], true)) {\n                    // Wait for rendering to complete, then scroll\n                    me.client.rowManager.ion({\n                        once       : true,\n                        thisObj    : me,\n                        renderDone : () => me.scrollRowIntoView(row, record)\n                    });\n                }\n            }\n        }\n    }\n    /**\n     * Scrolls expanded row into view. This function is called after rowManager has finished rendering.\n     * @private\n     * @category Internal\n     */\n    scrollRowIntoView(row, record) {\n        // If animating expand, need to wait for the animation to end before scrolling.\n        if (this.isAnimating) {\n            this.waitForTransition(row, () => this.client.scrollRowIntoView(record));\n        }\n        else {\n            this.client.scrollRowIntoView(record);\n        }\n    }\n    /**\n     * Waits for height transition on the provided rows element. Then calls provided function.\n     * @private\n     * @category Internal\n     */\n    waitForTransition(row, fn) {\n        const element = DomHelper.isElement(row) ? row : row.element;\n        EventHelper.onTransitionEnd({\n            element,\n            property : 'height',\n            handler  : fn,\n            thisObj  : this,\n            duration : DomHelper.getPropertyTransitionDuration(element, 'height') ?? 1\n        });\n    }\n    removeExpander(row) {\n        const me = this;\n        row.cls.remove(me.expandedRowClass);\n        for (const region of me.client.regions) {\n            const rowElement = row.getElement(region);\n            for (const child of rowElement.querySelectorAll('.' + me.expanderBodyClass)) {\n                me.unobserveResize(child);\n                child.remove();\n            }\n            // If this function is called after animation finished, we need to remove class `manually`\n            rowElement.classList.remove(me.expandedRowClass);\n            me.lockCellHeight(rowElement, null, false);\n            // If spanRegions, remove that element as well\n            if (me.shouldSpanRegions) {\n                row._spannedExpandedBodyElement?.remove?.();\n                row._spannedExpandedBodyElement = null;\n            }\n        }\n    }\n    destroyWidgets(state) {\n        for (const region of this.client.regions) {\n            state.widgets?.[region]?.destroy?.();\n        }\n    }\n    // Checks if a configuration object is a widget configuration object\n    isWidgetConfig(content) {\n        return content.type && !content.tag;\n    }\n    /**\n     * Creates expander element for each grid region and calls the renderer, also for each grid region.\n     * @private\n     * @param {Core.data.Model} record\n     * @param {Grid.row.Row} row\n     * @param {Object} recordState\n     * @category Internal\n     */\n    renderExpander(record, row, recordState) {\n        const\n            me                                           = this,\n            { client : grid, widget, shouldSpanRegions } = me,\n            cellHeight                                   = row.cells[0]?.offsetHeight,\n            { expandedBodyElements = {} }                = recordState,\n            renderPromises                               = [],\n            // Will be called sync or async depending on the implementation of the renderer function.\n            continueRendering                            = (content, expanderElement, region) => {\n                if (content != null) {\n                    if (typeof content === 'string') {\n                        // In case there is nodes already there\n                        const currentChildren = [...expanderElement.childNodes].map(n => expanderElement.removeChild(n));\n                        expanderElement.innerHTML = content;\n                        currentChildren.reverse().forEach(n => expanderElement.insertBefore(n, expanderElement.firstChild));\n                    }\n                    else if (me.isWidgetConfig(content)) {\n                        createWidget(content, expanderElement, region);\n                    }\n                    // Everything else will be treated as a dom config for now\n                    else {\n                        content = DomHelper.createElement(content);\n                        expanderElement.appendChild(content);\n                    }\n                }\n            },\n            createWidget = (widgetConfig, expanderElement, region) => {\n                const\n                    themeName           = DomHelper.getThemeInfo()?.name,\n                    shadowRootContainer = DomHelper.createElement({\n                        parent    : expanderElement,\n                        className : me.shadowRootContainerClass,\n                        style     : 'flex : 1'\n                    }),\n                    shadowRoot = shadowRootContainer._shadowRoot = shadowRootContainer.attachShadow({ mode : 'closed' });\n                renderPromises.push(DomHelper.cloneStylesIntoShadowRoot(shadowRoot).then(() => {\n                    if (grid.isDestroyed) {\n                        return;\n                    }\n                    const widgetDataField = widgetConfig.dataField ?? me.dataField;\n                    if (widgetDataField) {\n                        const fieldData = record.getValue(widgetDataField);\n                        // This path is used if field is a StoreDataField\n                        if (fieldData?.isStore) {\n                            widgetConfig.store = fieldData;\n                        }\n                        else if (grid.store[`${widgetDataField}Store`]) {\n                            const relatedStore = grid.store[`${widgetDataField}Store`];\n                            widgetConfig.store = relatedStore.chain(r => record.getValue(widgetDataField).includes(r));\n                        }\n                        else {\n                            widgetConfig.data = fieldData;\n                        }\n                    }\n                    if (themeName) {\n                        const\n                            { cls }  = widgetConfig,\n                            themeCls = `b-theme-${themeName.toLowerCase()}`;\n                        widgetConfig.cls = cls ? cls + ' ' + themeCls : themeCls;\n                    }\n                    if (!recordState.widgets) {\n                        recordState.widgets = {};\n                    }\n                    recordState.widgets[region] = expanderElement.widget = Widget.create(ObjectHelper.assign({\n                        appendTo       : shadowRoot,\n                        owner          : grid,\n                        flex           : 1,\n                        minHeight      : '5em',\n                        isNested       : true,\n                        expandedRecord : record\n                    }, widgetConfig));\n                    if (widgetDataField) {\n                        // If we have created a store, refresh expanded row on store changes\n                        expanderElement.widget.store.ion({\n                            change  : () => !row.isDestroyed && row.render(),\n                            thisObj : me\n                        });\n                    }\n                }).catch((href) => {\n                    throw new Error('Could not load stylesheet ' + href);\n                }));\n            };\n        // If another rendering of the same record is made while waiting for async, we should ignore it.\n        if (recordState.isRenderingAsync) {\n            return;\n        }\n        // class needed at this point to give the expander container correct height\n        row.addCls(me.expandedRowClass);\n        Object.assign(recordState, { cellHeight, expandedBodyElements, expanderBodyHeight : 0, loadingIndicators : [] });\n        for (const [i, region] of grid.regions.entries()) {\n            // If spanRegions, we only care about the first region\n            if (shouldSpanRegions && i > 0) {\n                break;\n            }\n            const\n                rowElement          = row.getElement(region);\n            let expanderBodyElement = expandedBodyElements[region],\n                renderResponse;\n            if (expanderBodyElement) {\n                // If there is one already, it's content needs to be removed\n                me.unobserveResize(expanderBodyElement);\n                expanderBodyElement.replaceChildren();\n            }\n            else {\n                // Create expand container\n                // Expander element needs to be in the DOM for appendTo to work correctly\n                expanderBodyElement = DomHelper.createElement({\n                    parent    : shouldSpanRegions ? grid.verticalScroller : rowElement,\n                    tabIndex  : -1,\n                    className : me.expanderBodyClass,\n                    style     : {\n                        top : shouldSpanRegions ? row.top + cellHeight : cellHeight + 'px'\n                    },\n                    dataset : {\n                        id : record.id\n                    }\n                });\n            }\n            if (shouldSpanRegions) {\n                row._spannedExpandedBodyElement = expanderBodyElement;\n            }\n            me.observeResize(expanderBodyElement);\n            if (widget?.[region]) {\n                createWidget(widget[region], expanderBodyElement, region);\n            }\n            else {\n                // The renderer can be async or sync\n                renderResponse = me.renderer?.({\n                    record,\n                    expanderElement : expanderBodyElement,\n                    rowElement,\n                    region,\n                    grid\n                });\n            }\n            if (Objects.isPromise(renderResponse)) {\n                renderPromises.push(renderResponse.then(content => continueRendering(content, expanderBodyElement, region)));\n            }\n            else {\n                continueRendering(renderResponse, expanderBodyElement, region);\n            }\n            expandedBodyElements[region] = expanderBodyElement;\n        }\n        // If we have async renderer, wait for all to complete\n        if (renderPromises.length) {\n            recordState.isRenderingAsync = true;\n            // Adding loading indicators when waiting for async content\n            me.showLoadingIndicators(recordState);\n            Promise.all(renderPromises).then(() => {\n                // One of the promises (createWidget) can, while resolving, add another promise to the array\n                // That's why we need to do this twice\n                Promise.all(renderPromises).then(() => {\n                    if (grid.isDestroyed) {\n                        return;\n                    }\n                    // Remove loading indicator\n                    recordState.loadingIndicators?.forEach(li => li.remove());\n                    recordState.loadingIndicators.length = 0;\n                    recordState.ignoreResize = false;\n                    recordState.isRenderingAsync = false;\n                    // Initiate a render if all current states is finished rendering, this code should be executed once\n                    // for each state\n                    for (const [, state] of me.recordStateMap) {\n                        if (state.isRenderingAsync) {\n                            return;\n                        }\n                    }\n                    // (?. since we might have been destroyed while waiting for promises)\n                    me.renderRowsWithAnimation?.(record, true);\n                });\n            });\n        }\n        recordState.isCreated = true;\n    }\n    showLoadingIndicators(recordState) {\n        for (const region in recordState.expandedBodyElements) {\n            recordState.loadingIndicators.push(DomHelper.createElement({\n                parent    : recordState.expandedBodyElements[region],\n                className : 'b-rowexpander-loading',\n                style     : {\n                    height : this.loadingIndicatorHeight + 'px'\n                },\n                children : [\n                    {\n                        tag       : 'i',\n                        className : 'b-icon b-icon-spinner'\n                    },\n                    this.loadingIndicatorText\n                ]\n            }));\n        }\n    }\n    /**\n     * Called when grid rows needs to re-render, for example on expand or collapse.\n     * Activates animations on grid, and deactivates them when they are completed.\n     * @private\n     * @param {Core.data.Model} record Record whose row was toggled\n     * @category Internal\n     */\n    renderRowsWithAnimation(record) {\n        const me = this;\n        if (me.enableAnimations) {\n            const row = me.client.rowManager.getRowById(record);\n            if (row) {\n                me.isAnimating = true;\n                if (me.collapsingStateMap.has(record)) {\n                    row.addCls('b-row-is-collapsing');\n                }\n                me.waitForTransition(row, () => {\n                    me.isAnimating = false;\n                    if (!row.isDestroyed) {\n                        row.removeCls?.('b-row-is-collapsing');\n                    }\n                });\n            }\n        }\n        return me.bufferedRenderer(record);\n    }\n    /**\n     * Collects a rendering call for each record, saves them in array and calls the delayed (RAF) rafRenderer function\n     * @private\n     * @param {Core.data.Model} record Record whose row was toggled\n     * @category Internal\n     */\n    bufferedRenderer(record) {\n        (this._bufferedRecords ?? (this._bufferedRecords = [])).push(record);\n        if (!this._rafPromise) {\n            this._rafPromise = new Promise(resolve => {\n                requestAnimationFrame(() => {\n                    this.internalRender?.(resolve);\n                    this._rafPromise = null;\n                });\n            });\n        }\n        return this._rafPromise;\n    }\n    /**\n     * Re-renders the grid from the topmost record of those saved in bufferedRenderer\n     * @private\n     * @category Internal\n     */\n    internalRender(resolvePromise) {\n        const\n            me                   = this,\n            { _bufferedRecords } = me,\n            { store }            = me.client;\n        me.recordStateMap.forEach((state, record) => {\n            if (state.renderPromiseResolver && state.isCreated && !_bufferedRecords.includes(record)) {\n                _bufferedRecords.push(record);\n            }\n        });\n        const [top] = _bufferedRecords.sort((a, b) => store.indexOf(a) - store.indexOf(b));\n        me.client.rowManager.renderFromRecord(top);\n        _bufferedRecords.length = 0;\n        // So that rendering is completed when promises are resolved\n        me.delay(resolvePromise);\n    }\n    /**\n     * Called when row is expanded. This function locks all cell's height to current height (before expanding).\n     * @private\n     * @param {HTMLElement} rowElement\n     * @param {Number} cellHeight The height to lock\n     * @param {Boolean} unlock To remove locked cell height when the row is collapsed\n     * @category Internal\n     */\n    lockCellHeight(rowElement, cellHeight, unlock) {\n        for (let a = 0; a < rowElement.children.length; a++) {\n            const child = rowElement.children[a];\n            // Should not lock expander element\n            if (!child.classList.contains(this.expanderBodyClass)) {\n                child.style.height = unlock ? '' : cellHeight + 'px';\n            }\n        }\n    }\n    //endregion\n    //region Public\n    /**\n     * Tells the RowExpander that the provided record should be expanded. If or when the record is rendered into view,\n     * the record will be expanded.\n     *\n     * Promise will resolve when the row gets expanded. Note that this can be much later than the actual expand call,\n     * depending on response times and if current record is in view or not.\n     *\n     * @param {Core.data.Model} record Record whose row should be expanded\n     * @category Common\n     */\n    async expand(record, fromSplit = false) {\n        const me = this;\n        if (me.disabled || me.recordStateMap.has(record) || await me.trigger('beforeExpand', { record }) === false) {\n            return;\n        }\n        let recordState;\n        return new Promise((resolve) => {\n            recordState = {\n                isCreated             : false,\n                renderPromiseResolver : resolve,\n                record\n            };\n            // Tells renderer that this record should be expanded\n            me.recordStateMap.set(record, recordState);\n            // In the event that we have expanded a record which is in collapsing animation state\n            me.collapsingStateMap.delete(record);\n            me._shouldScrollIntoView = true;\n            me.renderRowsWithAnimation(record);\n            // Propagate to splits\n            if (!fromSplit) {\n                me.client.syncSplits?.(other => other.features.rowExpander.expand(record, true));\n            }\n        }).then(() => {\n            me.trigger?.('expand', {\n                record,\n                expandedElements : recordState.expandedBodyElements,\n                widget           : recordState.widgets?.[me.client.regions[0]],\n                widgets          : recordState.widgets\n            });\n        });\n    }\n    /**\n     * Tells the RowExpander that the provided record should be collapsed. If the record is in view, it will be\n     * collapsed. If the record is not in view, it will simply not be expanded when rendered into view.\n     *\n     * @param {Core.data.Model} record Record whose row should be collapsed\n     * @category Common\n     */\n    async collapse(record, fromSplit = false) {\n        const\n            me          = this,\n            recordState = me.recordStateMap.get(record);\n        if (me.disabled || await me.trigger('beforeCollapse', { record }) === false) {\n            return;\n        }\n        // Unobserve resize\n        if (recordState?.expandedBodyElements) {\n            for (const region in recordState.expandedBodyElements) {\n                me.unobserveResize(recordState.expandedBodyElements[region]);\n            }\n        }\n        me.recordStateMap.delete(record);\n        me.collapsingStateMap.set(record, recordState);\n        await me.renderRowsWithAnimation(record);\n        me.trigger('collapse', { record });\n        // Propagate to splits\n        if (!fromSplit) {\n            me.client.syncSplits?.(other => other.features.rowExpander.collapse(record, true));\n        }\n    }\n    //endregion\n    // region Nested navigation\n    get hasWidget() {\n        return Boolean(this.widget) || [...this.recordStateMap.values()].some(state => state.widgets);\n    }\n    // Overrides the original, hence the if statement\n    navigateDown() {\n        if (!this.onKeyboardIn()) {\n            return this.overridden.navigateDown(...arguments);\n        }\n    }\n    // Chains the original\n    navigateUp() {\n        this.onKeyboardIn(true);\n    }\n    // Detects if focus is being reverted here by a nested grid, and focuses either the expanded row or the row below\n    catchFocus({ navigationDirection, source, editing }) {\n        const\n            { client }               = this,\n            { focusedCell, regions } = client;\n        for (let [record, state] of this.recordStateMap.entries()) {\n            for (const region in state.expandedBodyElements) {\n                if (state.expandedBodyElements[region].widget === source) {\n                    // If we're tab-editing, we should look for a nested grid in the region next to the source's region\n                    // If there is one, we should start editing there\n                    if (editing) {\n                        const nextRegion = regions[regions.indexOf(region) + (navigationDirection === 'down' ? 1 : -1)];\n                        if (nextRegion) {\n                            return this.startEditInWidget(state.widgets?.[nextRegion], navigationDirection === 'down');\n                        }\n                    }\n                    if (navigationDirection === 'down') {\n                        record = client.store.getNext(record, undefined, true);\n                    }\n                    let column;\n                    // If a column has been navigated to earlier, focus that\n                    if (!editing && focusedCell && !focusedCell._isDefaultFocus) {\n                        column = focusedCell.column;\n                    }\n                    // Else, get best candidate\n                    else {\n                        column = this.getNavigateableColumn(client, true, editing && navigationDirection === 'up');\n                    }\n                    // In case the cell we want to revert to is the one that was focused previously\n                    client._focusedCell = null;\n                    const cellContext = client.normalizeCellContext({ record, column });\n                    client.focusCell(cellContext);\n                    if (editing) {\n                        client.startEditing(cellContext);\n                    }\n                    return true;\n                }\n            }\n        }\n    }\n    // Detects if the user keyboard navigates either from the expanded row and down, or the row below the expanded row\n    // and up. If so, and there is a Grid in the expanded body, it starts to keyboard navigate there\n    onKeyboardIn(up) {\n        const\n            { focusedCell } = this.client,\n            state           = focusedCell && this.recordStateMap.get(focusedCell.record),\n            widget          = state?.expandedBodyElements?.[focusedCell?.column?.region]?.widget;\n        if (widget?.isGrid) {\n            let column;\n            // If a column has been navigated to earlier, focus that\n            if (widget.focusedCell && !widget.focusedCell._isDefaultFocus) {\n                column = widget.focusedCell.column;\n            }\n            // Else, get the best possible candidate\n            else {\n                column = this.getNavigateableColumn(widget);\n            }\n            // In case the cell we want to revert to is the one that was focused previously\n            widget._focusedCell = null;\n            widget.focusCell(widget.normalizeCellContext({ record : widget[`${up ? 'last' : 'first'}VisibleRow`], column }));\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Get the first column that is not the `checkboxSelectionColumn` and not the expander column.\n     * @param grid\n     * @param editable Also checks that the column has an `editor`\n     * @param reverse If `true`, this functions returns the last column which meets the requirements\n     * @private\n     */\n    getNavigateableColumn(grid, editable = true, reverse = false) {\n        const columns = reverse ? [...grid.columns.visibleColumns].reverse() : grid.columns.visibleColumns;\n        return columns.find(c =>\n            c !== grid.checkboxSelectionColumn &&\n            c !== grid.features.rowExpander?._expander &&\n            (!editable || c.editor)\n        ) ?? columns[0];\n    }\n    isActionAvailable({ actionName }) {\n        if (actions[actionName]) {\n            return !this.isDisabled && this.client.features.cellEdit?.isEditing;\n        }\n    }\n    onTab(previous) {\n        const\n            { client }   = this,\n            { cellEdit } = client.features;\n        // Tab:ing while cell editing\n        if (cellEdit?.enabled) {\n            const\n                { columns, regions } = client,\n                { activeRecord }     = cellEdit,\n                next                 = previous !== true,\n                nextCell             = cellEdit.getAdjacentEditableCell(client.focusedCell, next),\n                expandedRecord       = next ? activeRecord : (nextCell ? client.store.getById(nextCell.id) : null),\n                widgets              = expandedRecord && this.recordStateMap.get(expandedRecord)?.widgets;\n            // If the cell were trying to tab into is on a new row\n            // And the current row is expanded (or the next row if we're tab:ing backwards)\n            if (widgets && activeRecord?.id !== nextCell?.id) {\n                // Get that column's region\n                let nextRegion = (nextCell ? columns.getById(nextCell.columnId) : columns.visibleColumns[0]).region;\n                while (nextRegion) {\n                    // Is there a widget in that region?\n                    const widget = widgets[nextRegion];\n                    // Try to start editing the widget. If it works, we're done\n                    if (this.startEditInWidget(widget, next)) {\n                        return true;\n                    }\n                    // Otherwise, try the next (or previous) region\n                    nextRegion = regions[regions.indexOf(nextRegion) + (next ? 1 : -1)];\n                }\n            }\n        }\n        // KeyMap continues to call action handlers for this shortcut\n        return false;\n    }\n    startEditInWidget(widget, next = true) {\n        const { cellEdit } = this.client.features;\n        if (cellEdit?.enabled && widget?.features?.cellEdit?.enabled) {\n            cellEdit.finishEditing().then(() => {\n                const\n                    record = widget[`${next ? 'first' : 'last'}VisibleRow`],\n                    column = this.getNavigateableColumn(widget, true, !next);\n                widget.startEditing(widget.normalizeCellContext({ record, column }));\n            });\n            return true;\n        }\n    }\n    onShiftTab() {\n        return this.onTab(true);\n    }\n    // endregion\n    // Resize observe in own function for overridability\n    observeResize(element) {\n        const me = this;\n        if (!me.resizeObserver) {\n            me.resizeObserver = new ResizeObserver(entries => me.onExpanderBodyResize(entries));\n        }\n        me.resizeObserver.observe(element);\n    }\n    // Unobserves an observed element\n    unobserveResize(element) {\n        this.resizeObserver?.unobserve(element);\n    }\n    doDestroy() {\n        this.resizeObserver?.disconnect();\n        delete this.resizeObserver;\n        // destroy any nested widgets\n        for (const [, state] of this.recordStateMap) {\n            this.destroyWidgets(state);\n        }\n        super.doDestroy();\n    }\n    onThemeChange({ prev, theme }) {\n        for (const [, entry] of this.recordStateMap) {\n            Object.values(entry.expandedBodyElements).forEach(bodyElement => {\n                const shadowRootContainer = bodyElement.querySelector('.' + this.shadowRootContainerClass);\n                if (shadowRootContainer?._shadowRoot) {\n                    DomHelper.cloneStylesIntoShadowRoot(shadowRootContainer?._shadowRoot, true);\n                    bodyElement.widget?.element?.classList.remove(`b-theme-${prev}`);\n                    bodyElement.widget?.element?.classList.add(`b-theme-${theme}`);\n                }\n            });\n        }\n    }\n    /**\n     * Gets the corresponding expanded record from either a nested widget or an element in the expanded body.\n     * @param {HTMLElement|Core.widget.Widget} elementOrWidget\n     * @returns {Core.data.Model}\n     */\n    getExpandedRecord(elementOrWidget) {\n        for (const [rec, { widgets, expandedBodyElements }] of this.recordStateMap.entries()) {\n            if (widgets && elementOrWidget.isWidget) {\n                for (const region in widgets) {\n                    if (widgets[region] === elementOrWidget) {\n                        return rec;\n                    }\n                }\n                // Fallback if calling this function on paint\n                if (elementOrWidget.expandedRecord?.isModel) {\n                    return elementOrWidget.expandedRecord;\n                }\n            }\n            else {\n                for (const region in expandedBodyElements) {\n                    const curEl = expandedBodyElements[region];\n                    if (curEl === elementOrWidget || curEl.contains(elementOrWidget)) {\n                        return rec;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets the expanded widget(s) for a specified record. The widget(s) will be returned as an object with region\n     * names as properties and the widgets as values.\n     * @param {Core.data.Model} record\n     * @returns {Core.widget.Widget}\n     */\n    getExpandedWidgets(record) {\n        return this.recordStateMap.get(record)?.widgets;\n    }\n}\nRowExpander._$name = 'RowExpander'; GridFeatureManager.registerFeature(RowExpander);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport DomDataStore from '../../Core/data/DomDataStore.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nconst actions = {\n    goToNextHit : 1,\n    goToPrevHit : 1\n};\n/**\n * @module Grid/feature/Search\n */\n/**\n * {@inlineexample Grid/feature/Search.js}\n *\n * Feature that allows the user to search the entire grid. Navigate between hits using the\n * keyboard, [F3] or [Ctrl/CMD + G] moves to next, also pressing [Shift] moves to previous.\n *\n * Note that this feature does not include a UI, please build your own and call appropriate methods in the feature.\n * For a demo implementation, see <a href=\"../examples/search/\" target=\"_blank\">Search example</a>.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ## Keyboard shortcuts\n *\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys               | Action        | Action description                |\n * |--------------------|---------------|-----------------------------------|\n * | `F3`               | *goToNextHit* | Move focus to next search hit     |\n * | `Shift`+`F3`       | *goToPrevHit* | Move focus to previous search hit |\n * | `Ctrl`+`G`         | *goToNextHit* | Move focus to next search hit     |\n * | `Ctrl`+`Shift`+`G` | *goToPrevHit* | Move focus to previous search hit |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * ```javascript\n * // enable Search\n * let grid = new Grid({\n *   features: {\n *     search: true\n *   }\n * });\n *\n * // perform search\n * grid.features.search.search('steve');\n * ```\n *\n * @demo Grid/search\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype search\n * @feature\n */\nexport default class Search extends Delayable(InstancePlugin) {\n    //region Init\n    static $name = 'Search';\n    static configurable = {\n        /**\n         * The maximum amount of search hits\n         * @config {Number}\n         * @default\n         */\n        limit : 1000,\n        /**\n         * Set to false to not show the search hit index numbers\n         * @config {Boolean}\n         * @default\n         */\n        showHitIndex : true,\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            F3             : 'gotoNextHit',\n            'Ctrl+g'       : 'gotoNextHit',\n            'Shift+F3'     : 'gotoPrevHit',\n            'Ctrl+Shift+g' : 'gotoPrevHit'\n        }\n    };\n    static get properties() {\n        return {\n            hitCls          : 'b-search-hit',\n            hitCellCls      : 'b-search-hit-cell',\n            hitCellBadgeCls : 'b-search-hit-cell-badge',\n            hitTextCls      : 'b-search-hit-text'\n        };\n    }\n    construct(grid, config) {\n        super.construct(grid, config);\n        Object.assign(this, {\n            grid,\n            text       : '',\n            hitEls     : [],\n            treeWalker : grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)\n        });\n        // When new nodes appear due to node expand, include them in the search\n        grid.ion({\n            expandNode : 'onTreeNodeExpand',\n            thisObj    : this\n        });\n    }\n    isActionAvailable({ actionName }) {\n        if (actions[actionName]) {\n            return Boolean(this.text);\n        }\n    }\n    onTreeNodeExpand() {\n        if (this.text) {\n            this.requestAnimationFrame(this.search, [this.text, false, true]);\n        }\n    }\n    doDestroy() {\n        this.clear(true);\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        if (disable) {\n            this.clear();\n        }\n        super.doDisable(disable);\n    }\n    get store() {\n        return this.grid.store;\n    }\n    //endregion\n    //region Plugin config\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['populateCellMenu']\n        };\n    }\n    //endregion\n    //region Search\n    /**\n     * Performs a search and highlights hits.\n     * @param {String} text Text to search for\n     * @param {Boolean} [gotoHit] Go to first hit after search\n     * @param {Boolean} [reapply] Pass true to force search\n     * @param {String[]} [fields] An array of the fields to search for the value in\n     */\n    async search(text, gotoHit = true, reapply = false, fields, fromSplit = false) {\n        const me = this;\n        // empty search considered a clear\n        if (!text) {\n            return me.clear();\n        }\n        // searching for same thing again, do nothing\n        if (!reapply && text === me.text || me.disabled) {\n            return;\n        }\n        const\n            { grid, store } = me,\n            // Only search columns in use\n            columns         = grid.columns.visibleColumns.filter(col => col.searchable !== false),\n            formatters      = [];\n        fields      = fields || columns.map(col => {\n            // For date / number columns\n            formatters.push(col.formatValue?.bind(col));\n            return col.field;\n        });\n        const found = store.search(text, fields, formatters);\n        if (store.isTree && found.length) {\n            await grid.expandTo(found.map(hit => hit.id));\n        }\n        // Only include first result for merged cells in the count\n        for (const column of columns) {\n            if (column.mergeCells && column.isSorted) {\n                let prevValue = null,\n                    belongsTo = null;\n                for (const hit of found) {\n                    if (hit.field === column.field) {\n                        const value = hit.data[hit.field];\n                        if (value === prevValue) {\n                            hit.belongsTo = belongsTo;\n                        }\n                        prevValue = value;\n                        belongsTo = `${hit.field}-${hit.id}`;\n                    }\n                }\n            }\n        }\n        let i = 1;\n        Object.assign(me, {\n            foundMap  : {},\n            prevFound : me.found,\n            found,\n            text,\n            findRe    : new RegExp(`(\\\\s+)?(${StringHelper.escapeRegExp(String(text))})(\\\\s+)?`, 'ig')\n        });\n        me.clearHits();\n        if (!found) {\n            return;\n        }\n        // highlight hits for visible cells\n        for (const hit of found) {\n            // merged cells reuse the index of the first hit in the range\n            me.foundMap[`${hit.field}-${hit.id}`] = hit.belongsTo ? me.foundMap[hit.belongsTo] : i++;\n            // limit hits\n            if (i > me.limit) {\n                break;\n            }\n        }\n        if (!me.listenersInitialized) {\n            grid.rowManager.ion({\n                name       : 'renderCell',\n                renderCell : 'renderCell',\n                thisObj    : me\n            });\n            store.ion({\n                name                                : 'storeRefresh',\n                [`refresh${grid.asyncEventSuffix}`] : 'onStoreRefresh',\n                thisObj                             : me\n            });\n            me.listenersInitialized = true;\n        }\n        grid.refreshRows();\n        grid.trigger('search', { grid, find : text, found });\n        if (gotoHit && !me.isHitFocused && !fromSplit) {\n            me.gotoNextHit(true);\n        }\n        grid.syncSplits?.(other => other.features.search.search(text, gotoHit, reapply, fields, true));\n        return found;\n    }\n    clearHits() {\n        // Clear old hits\n        for (const cellElement of DomHelper.children(this.grid.element, '.' + this.hitCls)) {\n            cellElement.classList.remove(this.hitCls, this.hitCellCls);\n            // Rerender cell to remove search-hit-text\n            const row = DomDataStore.get(cellElement).row;\n            // Merged cells have no row, but they will be cleared anyway by their own DomSync call\n            if (row) {\n                // Need to force replace the markup\n                row.forceInnerHTML = true;\n                row.renderCell(cellElement);\n                row.forceInnerHTML = false;\n            }\n        }\n    }\n    /**\n     * Clears search results.\n     */\n    clear(silent = false) {\n        const\n            me       = this,\n            { grid } = me;\n        if (me.foundMap) {\n            delete me.foundMap;\n        }\n        me.text = null;\n        me.clearHits();\n        if (me.listenersInitialized) {\n            me.detachListeners('renderCell');\n            me.detachListeners('storeRefresh');\n            me.listenersInitialized = false;\n        }\n        if (!silent) {\n            grid.trigger('clearSearch', { grid });\n            // Propagate to other grids when splitting\n            grid.syncSplits?.(other => other.features.search.clear());\n        }\n    }\n    /**\n     * Number of results found\n     * @readonly\n     * @property {Number}\n     */\n    get foundCount() {\n        return this.found?.length ?? 0;\n    }\n    //endregion\n    //region Navigation\n    /**\n     * Returns true if focused row is a hit\n     * @property {Boolean}\n     * @readonly\n     */\n    get isHitFocused() {\n        const\n            me              = this,\n            { grid }        = me,\n            { focusedCell } = grid;\n        if (focusedCell?.cell?.contains(DomHelper.getActiveElement(grid.element))) {\n            const { rowIndex, column } = focusedCell;\n            return rowIndex !== -1 && me.found.some(hit =>\n                hit.index === rowIndex && column && hit.field === column.field\n            );\n        }\n    }\n    /**\n     * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].\n     */\n    gotoNextHit(fromStart = false) {\n        const\n            me = this;\n        if (!me.found?.length) return;\n        const\n            { grid, store } = me,\n            fromCell        = grid.focusedCell || grid.lastFocusedCell,\n            currentIndex    = fromCell && fromStart !== true ? store.indexOf(fromCell.record, undefined, true) : -1,\n            nextHit         = me.found.findIndex(hit => hit.index > currentIndex);\n        if (nextHit !== -1) {\n            me.gotoHit(nextHit);\n        }\n    }\n    /**\n     * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].\n     */\n    gotoPrevHit() {\n        const\n            me        = this,\n            { store } = me;\n        if (!me.found?.length) return;\n        const\n            { grid, found } = me,\n            fromCell        = grid.focusedCell || grid.lastFocusedCell,\n            currentIndex    = fromCell ? store.indexOf(fromCell.record, undefined, true) : 0;\n        for (let i = found.length - 1; i--; i >= 0) {\n            const hit = found[i];\n            if (hit.index < currentIndex) {\n                me.gotoHit(i);\n                break;\n            }\n        }\n    }\n    /**\n     * Go to specified hit.\n     * @param {Number} index\n     */\n    gotoHit(index) {\n        const\n            { grid } = this,\n            nextHit  = this.found[index];\n        if (nextHit) {\n            grid.focusCell({\n                field : nextHit.field,\n                id    : nextHit.id\n            });\n        }\n        return Boolean(nextHit);\n    }\n    /**\n     * Go to the first hit.\n     */\n    gotoFirstHit() {\n        this.gotoHit(0);\n    }\n    /**\n     * Go to the last hit.\n     */\n    gotoLastHit() {\n        this.gotoHit(this.found.length - 1);\n    }\n    //endregion\n    //region Render\n    /**\n     * Called from SubGrid when a cell is rendered. Highlights search hits.\n     * @private\n     */\n    renderCell({ cellElement, column, record, value }) {\n        const\n            me       = this,\n            {\n                treeWalker,\n                findRe,\n                hitTextCls,\n                showHitIndex\n            }        = me,\n            hitIndex = me.foundMap?.[column.field + '-' + record.id];\n        if (hitIndex) {\n            // highlight cell\n            cellElement.classList.add(me.hitCls);\n            // Remove any previous hit badge\n            showHitIndex && cellElement.querySelector(`.${me.hitCellBadgeCls}`)?.remove();\n            // highlight in cell if found in innerHTML\n            const inner = DomHelper.down(cellElement, '.b-grid-cell-value,.b-tree-cell-value') || cellElement;\n            if (String(value).toLowerCase() === String(me.text).toLowerCase()) {\n                inner.innerHTML = `<span class=\"${me.hitTextCls}\">${inner.innerHTML}</span>${showHitIndex ? `<div class=\"${me.hitCellBadgeCls}\">${hitIndex}</div>` : ''}`;\n            }\n            // Replace every occurrence of the text in every descendant text node with a span\n            // encapsulating the matched string.\n            else {\n                treeWalker.currentNode = inner;\n                for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode);) {\n                    const\n                        nodeToReplace = textNode,\n                        textContent   = textNode.nodeValue,\n                        newText       = ['<span>'];\n                    // Move onto next text node before we replace the node with a highlihght HTML sequence\n                    textNode = treeWalker.nextNode();\n                    let offset = findRe.lastIndex;\n                    // Convert textContent into an innerHTML string which htmlEncodes the text and embeds\n                    // a highlighting span which contains the target text.\n                    for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {\n                        const\n                            preamble    = textContent.substring(offset, match.index),\n                            spaceBefore = match[1] ? '\\xa0' : '',\n                            v           = match[2],\n                            spaceAfter  = match[3] ? '\\xa0' : '';\n                        newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class=\"${hitTextCls}\">${StringHelper.encodeHtml(v)}</span>${spaceAfter}`);\n                        offset = findRe.lastIndex;\n                    }\n                    newText.push(StringHelper.encodeHtml(textContent.substring(offset)), '<span>');\n                    // Insert a fragment with each match wrapped with a span.\n                    nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(''), {\n                        fragment : true\n                    }), nodeToReplace);\n                    nodeToReplace.remove();\n                }\n                if (showHitIndex) {\n                    DomHelper.createElement({\n                        parent    : cellElement,\n                        className : me.hitCellBadgeCls,\n                        text      : hitIndex\n                    });\n                }\n            }\n            me.hitEls.push(cellElement);\n        }\n    }\n    //endregion\n    //region Context menu\n    /**\n     * Add search menu item to cell context menu.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Core.data.Model} options.record Record for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateCellMenu({ column, record, items, cellElement }) {\n        const me = this;\n        if (column.searchable) {\n            items.search = {\n                text        : 'L{searchForValue}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-search',\n                cls         : 'b-separator',\n                weight      : 200,\n                disabled    : me.disabled,\n                onItem      : () => {\n                    let sel = globalThis.getSelection().toString();\n                    if (!sel) {\n                        sel = cellElement.innerText;\n                    }\n                    me.search(sel);\n                }\n            };\n        }\n    }\n    //endregion\n    //region Events\n    onStoreRefresh() {\n        this.search(this.text, false, true);\n    }\n    //endregion\n}\nSearch.featureClass = 'b-search';\nSearch._$name = 'Search'; GridFeatureManager.registerFeature(Search);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n/**\n * @module Grid/feature/StickyCells\n */\n/**\n * A feature which pins configurable content from a grid row to the top of the grid\n * while the row scrolls off the top but is still visible.\n *\n * As soon as the row becomes too small to contain the content, it is unpinned, and\n * scrolls out naturally, and the following row's configured content becomes pinned.\n *\n * For example:\n *\n * ```javascript\n *     new Grid({\n *         features : {\n *             stickyCells : {\n *                 // Identifies elements to clone and pin to the grid top.\n *                 contentSelector : '.myClassName'\n *             }\n *         }\n *     });\n * ```\n *\n * This feature is **disabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype stickyCells\n * @feature\n */\nexport default class StickyCells extends InstancePlugin {\n    //region Config\n    static get $name() {\n        return 'StickyCells';\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * A CSS selector which must identify the content within your grid row which you\n             * require to be pinned to the grid while the row if the topmost row, and remains visible.\n             * @config {String}\n             */\n            contentSelector : null,\n            currentTopRowCls : 'b-sticky-cells-current-top-row'\n        };\n    }\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            before : ['renderRows']\n        };\n    }\n    //endregion\n    //region Init\n    construct(grid, config) {\n        super.construct(grid, config);\n        // We cannot chain our client's onGridScroll because that is now a delayable injected method.\n        grid.ion({\n            scroll  : 'onGridScroll',\n            thisObj : this\n        });\n        Object.assign(this, DomHelper.createElement({\n            reference : 'element',\n            parent    : grid.element,\n            className : 'b-grid-sticky-row',\n            children  : [{\n                reference : 'contentElement',\n                className : 'b-grid-cell'\n            }]\n        }));\n        // Clean these classes from copied cell and row classLists\n        this.removeClasses = {\n            'b-focused'             : false,\n            'b-hover'               : false,\n            'b-selected'            : false,\n            [this.currentTopRowCls] : false\n        };\n    }\n    renderRows() {\n        // Do not leave stranded sticky row visible on data change\n        this.element.classList.add('b-hide-visibility');\n    }\n    onGridScroll() {\n        const\n            me = this,\n            {\n                client : grid,\n                element,\n                contentElement\n            } = me,\n            gridViewport  = Rectangle.client(grid.bodyContainer).roundPx(),\n            currentTopRow = grid.rowManager.getRowAt(gridViewport.y),\n            topRowChanged = currentTopRow !== me.currentTopRow;\n        if (currentTopRow) {\n            if (topRowChanged) {\n                if (me.currentTopRow) {\n                    me.currentTopRow.removeCls(me.currentTopRowCls);\n                    me.currentTopRow.removeCls('b-not-enough-height');\n                }\n                me.currentTopRow = currentTopRow;\n                currentTopRow.addCls(me.currentTopRowCls);\n                contentElement.innerHTML = '';\n                contentElement.appendChild(me.updateStickyContent());\n            }\n            // If the outgoing row is not too tall, and doesn't *need* the content\n            // pinning to the top, hide the sticky row, and make the source sticky\n            // elements pin themselves to the bottom of the cell using the b-not-enough-height\n            // class to switch them to align-self: flex-end\n            const notEnoughHeight = me.currentTopRow.bottom - me.client.scrollable.y <= me.stickyContentHeight;\n            me.element.classList[notEnoughHeight ? 'add' : 'remove']('b-hide-visibility');\n            me.currentTopRow[notEnoughHeight ? 'addCls' : 'removeCls']('b-not-enough-height');\n            // Keep sticky row aligned while constrained to the viewport.\n            // This keeps it pinned to the top.\n            gridViewport.y += me.stickyContentTop;\n            DomHelper.alignTo(element, me.stickyEls[0], { align : 't0-t0', constrainTo : gridViewport }, true);\n        }\n        me.lastProcessedTopRow = currentTopRow;\n    }\n    updateStickyContent() {\n        const\n            me            = this,\n            {\n                currentTopRow,\n                removeClasses\n            }             = me,\n            rowClasses   = {\n                'b-grid-sticky-row' : 1\n            },\n            cellClasses  = {},\n            stickyContent = me.stickyContent || (me.stickyContent = document.createDocumentFragment()),\n            stickyEls     = me.stickyEls || (me.stickyEls = []);\n        // Release the sticky state on the previous row's sticky elements\n        stickyEls.forEach(e => {\n            e.classList.remove('b-sticky-content-el');\n        });\n        // Collect the elements we need to clone from the current top row\n        stickyEls.length = 0;\n        currentTopRow.eachElement(rowEl => {\n            stickyEls.push(...rowEl.querySelectorAll(me.contentSelector));\n        });\n        // Clear the documentFragment which we use to hold our clones\n        while (stickyContent.firstChild) {\n            stickyContent.remove(stickyContent.firstChild);\n        }\n        me.stickyContentHeight = 0;\n        me.stickyContentTop = 0;\n        // Clone the selected elements and measure them for alignment.\n        stickyEls.map(e => {\n            // Collect the app classes that may be necessary on the cell and row elements.\n            e.closest('.b-grid-cell').classList.forEach(cls => cellClasses[cls] = 1);\n            e.closest('.b-grid-row').classList.forEach(cls => rowClasses[cls] = 1);\n            // Clean out grid's classes from the class sets.\n            Object.assign(cellClasses, removeClasses);\n            Object.assign(rowClasses,  removeClasses);\n            const eTop = e.offsetTop;\n            me.stickyContentTop = Math.max(me.stickyContentTop, eTop);\n            // We need to know how tall the sticky content is\n            e.style.alignSelf = 'flex-end';\n            me.stickyContentHeight = Math.max(me.stickyContentHeight, me.currentTopRow.height - e.offsetTop + eTop);\n            e.style.alignSelf = '';\n            const result = e.cloneNode(true);\n            // Tag the content al *after* cloning it.\n            e.classList.add('b-sticky-content-el');\n            stickyContent.appendChild(result);\n            return result;\n        });\n        cellClasses['b-focused'] = false;\n        DomHelper.syncClassList(me.contentElement, cellClasses);\n        DomHelper.syncClassList(me.element, rowClasses);\n        return stickyContent;\n    }\n}\nStickyCells._$name = 'StickyCells'; GridFeatureManager.registerFeature(StickyCells, false);\n", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../GridFeatureManager.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\n/**\n * @module Grid/feature/experimental/FileDrop\n */\n/**\n * An experimental feature that lets users drop files on a Widget. The widget fires an event when a file is dropped onto it.\n * In the event, you get access to the raw files as strings, that were parsed by calling `readAsBinaryString`.\n *\n * This feature is **disabled** by default.\n * For info on enabling it, see {@link Grid/view/mixin/GridFeatures}.\n *\n * NOTE: Currently only supports dropping one file at a time.\n *\n * @experimental\n * @extends Core/mixin/InstancePlugin\n * @classtype fileDrop\n * @feature\n */\nexport default class FileDrop extends InstancePlugin {\n    static $name = 'FileDrop';\n    construct(client, config) {\n        const me = this;\n        super.construct(client, config);\n        // Setup event listeners for dragging files onto the grid element\n        EventHelper.on({\n            element   : client.element,\n            thisObj   : me,\n            drop      : me.onFileDrop,\n            dragover  : me.onFileDragOver,\n            dragenter : me.onFileDragEnter,\n            dragleave : me.onFileDragLeave\n        });\n    }\n    onFileLoad(domEvent) {\n        this.client.trigger('fileDrop', {\n            file : this.file, domEvent\n        });\n    }\n    onFileDragEnter() {\n        // Mouse over styling while dragging a file\n        this.client.element.classList.add('b-dragging-file');\n    }\n    onFileDragOver(event) {\n        event.preventDefault();\n    }\n    onFileDragLeave(event) {\n        const { element } = this.client;\n        if (event.relatedTarget && !element.contains(event.relatedTarget)) {\n            this.client.element.classList.remove('b-dragging-file');\n        }\n    }\n    onFileDrop(domEvent) {\n        // Prevent default behavior (prevents the file from being opened)\n        domEvent.preventDefault();\n        const file = domEvent.dataTransfer.items[0].getAsFile();\n        /**\n         * Fired when a file is dropped on the widget element\n         * @event fileDrop\n         * @param {Grid.view.Grid} source The owning Grid instance\n         * @param {DataTransferItem} file The dropped file descriptor\n         * @param {DragEvent} domEvent The native DragEvent\n         * @on-owner\n         */\n        this.client.trigger('fileDrop', { file, domEvent });\n        this.onFileDragLeave(domEvent);\n    }\n}\nFileDrop._$name = 'FileDrop'; GridFeatureManager.registerFeature(FileDrop, false, 'Grid');\n", "import ChipView from '../../Core/widget/ChipView.js';\nimport Store from '../../Core/data/Store.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n/**\n * @module Grid/widget/GroupBar\n */\n/**\n * A widget used to manage grouping of a tree with the {@link Grid.feature.TreeGroup} feature. Column headers can be\n * drag-dropped on this widget to regroup the data in the tree store. This widget only handles column-based grouping,\n * and doesn't handle custom group functions.\n *\n * ```javascript\n * const tree = new TreeGrid({\n *     appendTo : 'container',\n *     features : {\n *         treeGroup : {\n *             hideGroupedColumns : true,\n *             levels             : [\n *                 'manager',\n *                 'airline'\n *             ],\n *             parentRenderer : (field, data) => `${StringHelper.capitalize(field)}: ${data.name}`\n *         }\n *     },\n *\n *     columns : [\n *         {\n *             text  : 'Name',\n *             field : 'name',\n *             flex  : 3,\n *             type  : 'tree'\n *         },\n *         {\n *             text   : 'Airline',\n *             field  : 'airline',\n *             align  : 'center',\n *             flex   : 2,\n *         },\n *         {\n *             type  : 'check',\n *             text  : 'Domestic',\n *             field : 'domestic',\n *             align : 'left',\n *             flex  : 1\n *         },\n *         {\n *             type  : 'number',\n *             text  : 'Capacity',\n *             field : 'capacity',\n *             flex  : 1\n *         },\n *         {\n *             type  : 'number',\n *             text  : 'Crew',\n *             field : 'crew',\n *             flex  : 1\n *         }\n *     ],\n *\n *     tbar : [\n *         'Group by',\n *         {\n *             type : 'groupbar'\n *         }\n *     ]\n * ```\n * @classtype groupbar\n * @extends Core/widget/ChipView\n * @demo Grid/tree-grouping\n * @widget\n */\nexport default class GroupBar extends ChipView {\n    static type  = 'groupbar';\n    static $name = 'GroupBar';\n    static configurable = {\n        selectedCls : 'not-used',\n        itemTpl(record) {\n            return StringHelper.encodeHtml(StringHelper.capitalize(record.getValue(this.displayField)));\n        }\n    };\n    construct() {\n        super.construct(...arguments);\n        const treeGrid = this.treeGrid = this.up('gridbase', true);\n        if (!treeGrid) {\n            throw new Error('GroupBar must be used inside a Grid component');\n        }\n        treeGrid.ion({\n            paint   : this.onTreePaint,\n            once    : true,\n            thisObj : this\n        });\n    }\n    onTreePaint() {\n        const\n            me           = this,\n            { treeGrid } = me,\n            { treeGroup, columnReorder } = treeGrid.features;\n        if (!treeGroup) {\n            throw new Error('GroupBar widget requires the TreeGroup feature to be present');\n        }\n        columnReorder.usingGroupBarWidget = true;\n        me.store = new Store({\n            fields            : ['cls', 'ascending'],\n            internalListeners : {\n                add     : me.onStoreChanged,\n                remove  : me.onStoreChanged,\n                thisObj : me\n            }\n        });\n        treeGrid.ion({\n            treeGroupChange          : me.onTreeGroupChanged,\n            beforeColumnDropFinalize : me.onBeforeColumnDropFinalize,\n            columnDrag               : me.onColumnDrag,\n            columnDragStart          : me.onColumnDragStart,\n            columnDrop               : me.onColumnDrop,\n            thisObj                  : me\n        });\n        me.onTreeGroupChanged({ levels : treeGroup.levels });\n    }\n    onStoreChanged({ records }) {\n        const\n            me           = this,\n            { treeGrid } = me;\n        if (!me.treeGrid.isConstructing && records?.[0]?.cls !== 'b-drop-target') {\n            me.ignoreGroupChange               = true;\n            treeGrid.features.treeGroup.levels = me.store.map(({ field }) => field);\n            me.ignoreGroupChange               = false;\n        }\n    }\n    onTreeGroupChanged({ levels }) {\n        if (!this.ignoreGroupChange) {\n            if (levels.some(level => level instanceof Function && !level.fieldName)) {\n                throw new Error('GroupBar only supports column grouping');\n            }\n            this.store.data = (levels || []).map(level => {\n                level = level.fieldName || level;\n                return this.treeGrid.columns.get(level);\n            });\n        }\n    }\n    onColumnDragStart() {\n        this.store.add({ id : 'placeholder', cls : 'b-drop-target' }); \n    }\n    onColumnDrag({ context, column, event }) {\n        const overGroupBar = event.target.closest('.b-groupbar');\n        if (overGroupBar) {\n            context.valid = true;\n        }\n    }\n    onBeforeColumnDropFinalize({ column, event }) {\n        const droppedOnGroupBar = event.target.closest('.b-groupbar');\n        if (droppedOnGroupBar) {\n            if (!column.isTreeColumn) {\n                this.store.getById('placeholder').remove();\n                this.store.add(column);\n            }\n        }\n    }\n    onColumnDrop() {\n        this.store.getById('placeholder')?.remove();\n    }\n}\nGroupBar.initClass();\nGroupBar._$name = 'GroupBar';", "import Combo from '../../Core/widget/Combo.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport '../../Grid/view/TreeGrid.js';\n/**\n * @module Grid/widget/TreeCombo\n */\n/**\n * A powerful {@link Core/widget/Combo} box using a {@link Grid/view/TreeGrid} as its drop down widget. You can define\n * your own set of columns to display and use all the regular features of the Grid.\n *\n * {@inlineexample Grid/widget/TreeCombo.js}\n *\n * ```javascript\n * new TreeCombo({\n *     label    : 'Pick task(s)',\n *     width    : '30em',\n *     appendTo : document.body,\n *     picker   : {\n *         // Define the columns to show in the grid\n *         columns : [\n *             { type : 'tree', text : 'Tasks', field : 'name', flex : 1 },\n *             { text : 'Priority', field : 'prio' }\n *         ]\n *     },\n *     chipView : {\n *         // Render the chips in the combo field\n *         itemTpl(record) {\n *             return StringHelper.xss`${record.name}`;\n *         }\n *     },\n *     store : {\n *         fields     : [\n *             'prio'\n *         ],\n *         data : [\n *             {\n *                 name     : 'Development Tasks',\n *                 expanded : true,\n *                 children : [\n *                     { id : 1, name : 'Improve React docs', prio : 'High' },\n *                     { id : 2, name : 'Build Angular module', prio : 'Low' },\n *                     { id : 3, name : 'Creat Vue project', prio : 'Low' }\n *                 ]\n *             },\n *             { name : 'Customer meeting', prio : 'Normal' },\n *             {\n *                 name     : 'Customer Tasks',\n *                 expanded : true,\n *                 children : [\n *                     { id : 4, name : 'Intro meeting', prio : 'Normal' },\n *                     { id : 5, name : 'Build POC', prio : 'High' },\n *                     { id : 6, name : 'Documentation', prio : 'Low' }\n *                 ]\n *             }\n *         ]\n *     }\n * });\n * ```\n *\n * @extends Core/widget/Combo\n * @classtype treecombo\n * @inputfield\n */\nexport default class TreeCombo extends Combo {\n    static $name = 'TreeCombo';\n    static type = 'treecombo';\n    static configurable = {\n        multiSelect : true,\n        picker      : {\n            type                       : 'treegrid',\n            minWidth                   : '35em',\n            disableGridRowModelWarning : true,\n            selectionMode              : {\n                row                  : true,\n                rowCheckboxSelection : true\n            }\n        },\n        chipView : {\n            itemTpl(record) {\n                return StringHelper.xss`${record.name}`;\n            },\n            scrollable : {\n                overflowX : 'hidden-scroll'\n            }\n        }\n    };\n    changePicker(picker, oldPicker) {\n        picker = super.changePicker(picker, oldPicker);\n        picker?.ion({\n            selectionChange : 'onPickerSelectionChange',\n            thisObj         : this\n        });\n        return picker;\n    }\n    updateMultiSelect(multiSelect) {\n        super.updateMultiSelect(...arguments);\n        this.picker.selectionMode.multiSelect = multiSelect;\n    }\n    updateReadOnly(readOnly) {\n        super.updateReadOnly(...arguments);\n        this.picker.readOnly = readOnly;\n    }\n    get value() {\n        return super.value;\n    }\n    set value(value) {\n        // indicate we are setting the field value\n        this._settingValue = true;\n        super.value = value;\n        // select provided value enitres in the picker\n        this.picker.selectedRecords = value.map?.(val => this.store.getById(val)) || [];\n        this._settingValue = false;\n    }\n    onPickerSelectionChange({ selection }) {\n        // apply selection to value (if we aren't in the middle of value setting)\n        if (!this._settingValue) {\n            this.value = selection;\n        }\n    }\n}\nTreeCombo.initClass();\nTreeCombo._$name = 'TreeCombo';", "// column\nexport { default as ActionColumn } from '../lib/Grid/column/ActionColumn.js';\nexport { default as AggregateColumn } from '../lib/Grid/column/AggregateColumn.js';\nexport { default as CheckColumn } from '../lib/Grid/column/CheckColumn.js';\nexport { default as ColorColumn } from '../lib/Grid/column/ColorColumn.js';\nexport { default as Column } from '../lib/Grid/column/Column.js';\nexport { default as DateColumn } from '../lib/Grid/column/DateColumn.js';\nexport { default as NumberColumn } from '../lib/Grid/column/NumberColumn.js';\nexport { default as PercentColumn } from '../lib/Grid/column/PercentColumn.js';\nexport { default as RatingColumn } from '../lib/Grid/column/RatingColumn.js';\nexport { default as RowNumberColumn } from '../lib/Grid/column/RowNumberColumn.js';\nexport { default as TemplateColumn } from '../lib/Grid/column/TemplateColumn.js';\nexport { default as TimeColumn } from '../lib/Grid/column/TimeColumn.js';\nexport { default as TreeColumn } from '../lib/Grid/column/TreeColumn.js';\nexport { default as WidgetColumn } from '../lib/Grid/column/WidgetColumn.js';\n// data\nexport { default as ColumnStore } from '../lib/Grid/data/ColumnStore.js';\nexport { default as GridRowModel } from '../lib/Grid/data/GridRowModel.js';\n// feature\nexport { default as CellCopyPaste } from '../lib/Grid/feature/CellCopyPaste.js';\nexport { default as CellEdit } from '../lib/Grid/feature/CellEdit.js';\nexport { default as CellMenu } from '../lib/Grid/feature/CellMenu.js';\nexport { default as CellTooltip } from '../lib/Grid/feature/CellTooltip.js';\nexport { default as ColumnAutoWidth } from '../lib/Grid/feature/ColumnAutoWidth.js';\nexport { default as ColumnDragToolbar } from '../lib/Grid/feature/ColumnDragToolbar.js';\nexport { default as ColumnPicker } from '../lib/Grid/feature/ColumnPicker.js';\nexport { default as ColumnRename } from '../lib/Grid/feature/ColumnRename.js';\nexport { default as ColumnReorder } from '../lib/Grid/feature/ColumnReorder.js';\nexport { default as ColumnResize } from '../lib/Grid/feature/ColumnResize.js';\nexport { default as FillHandle } from '../lib/Grid/feature/FillHandle.js';\nexport { default as Filter } from '../lib/Grid/feature/Filter.js';\nexport { default as FilterBar } from '../lib/Grid/feature/FilterBar.js';\nexport { default as GridFeatureManager } from '../lib/Grid/feature/GridFeatureManager.js';\nexport { default as Group } from '../lib/Grid/feature/Group.js';\nexport { default as GroupSummary } from '../lib/Grid/feature/GroupSummary.js';\nexport { default as HeaderMenu } from '../lib/Grid/feature/HeaderMenu.js';\nexport { default as MergeCells } from '../lib/Grid/feature/MergeCells.js';\nexport { default as QuickFind } from '../lib/Grid/feature/QuickFind.js';\nexport { default as RegionResize } from '../lib/Grid/feature/RegionResize.js';\nexport { default as RowCopyPaste } from '../lib/Grid/feature/RowCopyPaste.js';\nexport { default as RowExpander } from '../lib/Grid/feature/RowExpander.js';\nexport { default as RowReorder } from '../lib/Grid/feature/RowReorder.js';\nexport { default as RowResize } from '../lib/Grid/feature/RowResize.js';\nexport { default as Search } from '../lib/Grid/feature/Search.js';\nexport { default as Sort } from '../lib/Grid/feature/Sort.js';\nexport { default as StickyCells } from '../lib/Grid/feature/StickyCells.js';\nexport { default as Stripe } from '../lib/Grid/feature/Stripe.js';\nexport { default as Split } from '../lib/Grid/feature/Split.js';\nexport { default as Summary } from '../lib/Grid/feature/Summary.js';\nexport { default as Tree } from '../lib/Grid/feature/Tree.js';\nexport { default as TreeGroup } from '../lib/Grid/feature/TreeGroup.js';\n// feature base\nexport { default as CopyPasteBase } from '../lib/Grid/feature/base/CopyPasteBase.js';\n// export feature\nexport { default as ExportDialog } from '../lib/Grid/view/export/ExportDialog.js';\nexport { default as Exporter } from '../lib/Grid/feature/export/exporter/Exporter.js';\nexport { default as ExportOrientationCombo } from '../lib/Grid/view/export/field/ExportOrientationCombo.js';\nexport { default as ExportRowsCombo } from '../lib/Grid/view/export/field/ExportRowsCombo.js';\nexport { default as MultiPageExporter } from '../lib/Grid/feature/export/exporter/MultiPageExporter.js';\nexport { default as MultiPageVerticalExporter } from '../lib/Grid/feature/export/exporter/MultiPageVerticalExporter.js';\nexport { default as PdfExport } from '../lib/Grid/feature/export/PdfExport.js';\nexport { default as Print } from '../lib/Grid/feature/export/Print.js';\nexport { default as PrintMixin } from '../lib/Grid/feature/export/mixin/PrintMixin.js';\nexport { default as SinglePageExporter } from '../lib/Grid/feature/export/exporter/SinglePageExporter.js';\nexport { FileFormat, Orientation, PaperFormat, RowsRange } from '../lib/Grid/feature/export/Utils.js';\n// feature experimental\nexport { default as ExcelExporter } from '../lib/Grid/feature/experimental/ExcelExporter.js';\nexport { default as FileDrop } from '../lib/Grid/feature/experimental/FileDrop.js';\n// row\nexport { default as Row } from '../lib/Grid/row/Row.js';\n// util\nexport { default as Location } from '../lib/Grid/util/Location.js';\nexport { default as TableExporter } from '../lib/Grid/util/TableExporter.js';\n// view\nexport { default as Bar } from '../lib/Grid/view/Bar.js';\nexport { default as Footer } from '../lib/Grid/view/Footer.js';\nexport { default as Grid } from '../lib/Grid/view/Grid.js';\nexport { default as GridBase } from '../lib/Grid/view/GridBase.js';\nexport { default as Header } from '../lib/Grid/view/Header.js';\nexport { default as RowManager } from '../lib/Grid/row/RowManager.js';\nexport { default as SubGrid } from '../lib/Grid/view/SubGrid.js';\nexport { default as TreeGrid } from '../lib/Grid/view/TreeGrid.js';\n// view mixin\nexport { default as GridElementEvents } from '../lib/Grid/view/mixin/GridElementEvents.js';\nexport { default as GridFeatures } from '../lib/Grid/view/mixin/GridFeatures.js';\nexport { default as GridResponsive } from '../lib/Grid/view/mixin/GridResponsive.js';\nexport { default as GridSelection } from '../lib/Grid/view/mixin/GridSelection.js';\nexport { default as GridState } from '../lib/Grid/view/mixin/GridState.js';\nexport { default as GridSubGrids } from '../lib/Grid/view/mixin/GridSubGrids.js';\n// widget\nexport { default as GridFieldFilterPicker } from '../lib/Grid/widget/GridFieldFilterPicker.js';\nexport { default as GridFieldFilterPickerGroup } from '../lib/Grid/widget/GridFieldFilterPickerGroup.js';\nexport { default as GroupBar } from '../lib/Grid/widget/GroupBar.js';\nexport { default as TreeCombo } from '../lib/Grid/widget/TreeCombo.js';\n\n\nimport GlobalEvents from '../lib/Core/GlobalEvents.js';\nimport BrowserHelper from '../lib/Core/helper/BrowserHelper.js';\nimport VersionHelper from '../lib/Core/helper/VersionHelper.js';\nimport Widget from '../lib/Core/widget/Widget.js';\nimport Toast from '../lib/Core/widget/Toast.js';\nimport Override from '../lib/Core/mixin/Override.js';\nimport DomHelper from '../lib/Core/helper/DomHelper.js';\nimport GridBase from '../lib/Grid/view/GridBase.js';\nimport RowManager from '../lib/Grid/row/RowManager.js';\n(() => {\n    //region Common\n    const\n        HOSTS            = [\n            'bryntum.com',\n            'cdpn.io',\n            'react-gantt.com',\n            'vue-gantt.com',\n            'vue-scheduler.com',\n            'react-scheduler.com',\n            'angular-scheduler.com',\n            'angular-calendar.com',\n            'vue-calendar.com',\n            'react-calendar.com',\n            'lmctfy.net',\n            'bryntum-dev-ed.develop.lightning.force.com'\n        ],\n        ONE_DAY          = 1000 * 60 * 60 * 24,\n        EXPIRING_CLASSES = [],\n        location = (globalThis || self).location;\n    if (!VersionHelper.isTestEnv && (HOSTS.some(host => location.host.includes(host)) || /\\/docs/.test(location.href))) {\n        return;\n    }\n    let initialized;\n    function initExpiryHelper(owner, baseClass) {\n        if (!initialized) {\n            initialized = true;\n            ExpiryHelper.construct({\n                widget : owner\n            });\n        }\n        // do not remove this line (used to distinguish trial bundles by regexp)\n        owner.__foo = 'THISISTRIAL';\n    }\n    //endregion\n    //region ExpiryHelper\n    class ExpiryHelper {\n        static construct(config) {\n            const\n                me            = this,\n                product       = 'taskboard',\n                productName   = 'TaskBoard',\n                version       = VersionHelper.getVersion(product),\n                callHomeDelay = VersionHelper.isTestEnv ? 3000 : 1000 * 60,\n                blockUrl      = BrowserHelper.queryString.blockUrl;\n            Object.assign(me, {\n                version,\n                product,\n                Product          : productName,\n                verifyUrl        : VersionHelper.isTestEnv ? blockUrl : 'https://bryntum.com/verify/',\n                blocked          : false,\n                lastVersionCheck : 0,\n                trialKey         : `b-${product}-trial-start`,\n                versionCheckKey  : `b-${product}-verify-date`\n            }, config);\n            if (!VersionHelper.isTestEnv) {\n                console.log(`Bryntum ${productName} Trial Version`);\n            }\n            me.cacheTrialStartTime();\n            if (me.isExpired) {\n                if (document.readyState === 'complete') {\n                    me.onTrialExpired();\n                }\n                else {\n                    document.addEventListener('readystatechange', () => {\n                        if (document.readyState === 'complete') {\n                            me.onTrialExpired();\n                        }\n                    });\n                }\n            }\n            // Call home to log trial usage, assuming localStorage access works reliably\n            // 1 min delay to be less easily detected\n            setTimeout(() => {\n                me.updateBlockedStatus();\n            }, callHomeDelay);\n        }\n        static cacheTrialStartTime() {\n            const\n                me         = this,\n                timeString = BrowserHelper.getLocalStorageItem(me.trialKey),\n                time       = Number(timeString);\n            if (time && !isNaN(time)) {\n                me.trialStartTime = time;\n            }\n            me.trialStartTime = me.trialStartTime || Date.now();\n            // First trial access, or no localstorage (no local storage meaning our expiration mechanism won't work. Only remote blocking will end the trial)\n            BrowserHelper.setLocalStorageItem(me.trialKey, me.trialStartTime);\n        }\n        static get isExpired() {\n            return this.blocked || (Date.now() - this.trialStartTime > ONE_DAY * 45) || window.bryntum?.[this.product]?.expired;\n        }\n        static updateBlockedStatus() {\n            const\n                me                  = this,\n                saveVersionCheckKey = () => BrowserHelper.setLocalStorageItem(me.versionCheckKey, Date.now());\n            me.lastVersionCheck = me.lastVersionCheck || BrowserHelper.getLocalStorageItem(me.versionCheckKey) || 0;\n            // Max 1 version check per session / day\n            if (me.lastVersionCheck && Date.now() - me.lastVersionCheck < ONE_DAY) {\n                return;\n            }\n            if (me.verifyUrl) {\n                const\n                    url    = encodeURIComponent(location.href),\n                    logUrl = `${me.verifyUrl}?id=${window.bryntum.license}&url=${url}`,\n                    img    = new Image();\n                img.onload = () => {\n                    // 2x2 image means trial is blocked due to violation\n                    if (img.naturalWidth === 2) {\n                        me.blockTrial();\n                    }\n                    else {\n                        // Just in case\n                        saveVersionCheckKey();\n                    }\n                };\n                img.onerror = () => {\n                    saveVersionCheckKey();\n                };\n                img.src = logUrl;\n            }\n            else {\n                saveVersionCheckKey();\n            }\n        }\n        static onTrialExpired() {\n            const rootEl = this.widget.rootElement;\n            if (!this.expirationShown) {\n                this.expirationShown = true;\n                if (!VersionHelper.isTestEnv) {\n                    console.warn(`Bryntum ${this.Product} trial version expired. Purchase a license at https://bryntum.com/store or contact us at https://bryntum.com/contact/ for licensing options.`);\n                }\n                rootEl.floatRoot && Toast.show({\n                    html        : `Psst! Your Bryntum ${this.Product} trial has expired. Please see <a href=\"https://bryntum.com/store\">our store</a> for licensing options`,\n                    timeout     : 20000,\n                    rootElement : rootEl\n                });\n            }\n            DomHelper.removeEachSelector(rootEl, '.b-sch-dependency');\n            DomHelper.forEachSelector(rootEl, '.b-container', element => {\n                const widget = Widget.fromElement(element, 'widget');\n                if (EXPIRING_CLASSES.some(cls => widget instanceof cls)) {\n                    this.maskExpiredWidget(widget);\n                }\n            });\n        }\n        static blockTrial() {\n            this.blocked = true;\n            // Get rid of version check timestamp\n            BrowserHelper.removeLocalStorageItem(this.versionCheckKey);\n            // To force expired state: Set a fake early trial timestamp\n            BrowserHelper.setLocalStorageItem(this.trialKey, 1);\n            this.onTrialExpired();\n        }\n        static maskExpiredWidget(widget) {\n            widget.mask({\n                text  : '<h3 style=\"margin:0\">Trial expired, <a href=\"https://bryntum.com/store\" style=\"margin:0 3px; color:inherit\">click here</a> to buy a license.</h3>',\n                icon  : 'b-fa b-fa-frown',\n                type  : 'trial',\n                cover : 'target'\n            });\n        }\n        static setWaterMark(element, {\n            darkColor = 'rgba(255, 255, 255, 0.03)',\n            lightColor = 'rgba(240, 240, 240, 0.54)'\n        } = {}) {\n            // Used for thumbnails\n            if (BrowserHelper.queryString.thumb != null) {\n                return;\n            }\n            const\n                color     = DomHelper.themeInfo?.name?.toLowerCase().endsWith('-dark') ? darkColor : lightColor,\n                svgString = `\n                   <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100%\" height=\"100%\" style=\"font-family:sans-serif;font-weight:900;fill:${color}\">\n                    <defs>\n                        <pattern id=\"company\" patternUnits=\"userSpaceOnUse\" width=\"400\" height=\"200\">\n                            <text y=\"30\" font-size=\"40\" id=\"name\">Bryntum</text>\n                            <text y=\"120\" x=\"200\" font-size=\"24\" id=\"trial\">Trial Version</text>\n                        </pattern>\n                        <pattern id=\"pattern\" xlink:href=\"#company\" patternTransform=\"rotate(-45)\">\n                            <use xlink:href=\"#name\" /><use xlink:href=\"#trial\" />\n                        </pattern>\n                    </defs>\n                    <rect width=\"100%\" height=\"100%\" fill=\"url(#pattern)\" />\n                </svg>`;\n            element.style.backgroundImage = `url('data:image/svg+xml;base64,${window.btoa(svgString)}')`;\n        };\n    }\n    //endregion\n    //region Common override\n    const applyBaseOverride = baseClass => {\n        EXPIRING_CLASSES.push(baseClass);\n        Override.apply(class {\n            static get target() {\n                return {\n                    class : baseClass\n                };\n            }\n            onPaintOverride() {\n                const\n                    me            = this,\n                    setWatermarks = () => {\n                        const targets = me.subGrids ? Object.values(me.subGrids) : [me];\n                        for (const target of targets) {\n                            if (target.element) {\n                                ExpiryHelper.setWaterMark(target.element);\n                            }\n                        }\n                    };\n                initExpiryHelper(me, baseClass);\n                setWatermarks();\n                // React to theme changes\n                GlobalEvents.on('theme', () => {\n                    setWatermarks();\n                });\n                if (ExpiryHelper.isExpired) {\n                    ExpiryHelper.maskExpiredWidget(me);\n                }\n            }\n        });\n    };\n    //endregion\n    if (typeof GridBase !== 'undefined') {\n        applyBaseOverride(GridBase);\n        Override.apply(class {\n            static get target() {\n                return {\n                    class : RowManager\n                };\n            }\n            matchRowCount() {\n                if (!ExpiryHelper.isExpired || this.grid?.isScheduler) {\n                    this._overridden.matchRowCount.apply(this, arguments);\n                }\n            }\n            renderRows() {\n                if (!ExpiryHelper.isExpired || this.grid?.isScheduler) {\n                    this._overridden.renderRows.apply(this, arguments);\n                }\n            }\n            renderFromRow() {\n                if (!ExpiryHelper.isExpired || this.grid?.isScheduler) {\n                    this._overridden.renderFromRow.apply(this, arguments);\n                }\n            }\n        });\n    }\n})();\n(() => {\n    // do not load analytics code for specific domains\n    const ignoreDomainRe = /(.force.com|.lightning.com|.salesforce.com|lmctfy.net|qa.bryntum.com|qa2.bryntum.com)/;\n    // document location might be null in firefox in salesforce\n    if (!document.location || ignoreDomainRe.test(document.location.href) || window.top !== window) {\n        return;\n    }\n    let id;\n    const websiteUrls = [\n        'bryntum.com',\n        'cdpn.io'\n    ];\n    const\n        products   = ['calendar', 'grid', 'gantt', 'scheduler', 'schedulerpro', 'taskboard'],\n        frameworks = ['angular', 'react', 'vue', 'ionic'];\n    websiteUrls.splice(0, 0, ...products.map(prod => frameworks.map(framework => `${framework}-${prod}`)).concat('bryntum.com').flat());\n    if (document.location.host.match(websiteUrls.join('|'))) {\n        id = 'G-1VY6776VJP';\n    }\n    else {\n        id = 'G-H465KZDH8S';\n    }\n    const newScript = document.createElement('script');\n    newScript.onload = function() {\n        window.dataLayer = window.dataLayer || [];\n        function gtag() {\n            window.dataLayer.push(arguments);\n        }\n        gtag('js', new Date());\n        gtag('config', id);\n    };\n    document.head.appendChild(newScript);\n    newScript.src = 'https://www.googletagmanager.com/gtag/js?id=' + id;\n})();\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiFA,IAAqB,eAArB,cAA0C,OAAO;AAAA,EAoG7C,IAAI,sBAAsB;AACtB,WAAO;AAAA,EACX;AAAA,EACA,UAAU,QAAQ,OAAO;AACrB,UAAM,KAAK;AACX,UAAM,UAAU,GAAG,SAAS;AAE5B,QAAI,CAAC,OAAO,SAAS,CAAC,OAAO,MAAM;AAC/B,SAAG,KAAK,IAAI,EAAE,OAAQ,mBAAmB,SAAU,GAAG,CAAC;AAAA,IAC3D;AACA,QAAI,GAAG,uBAAuB;AAC1B,SAAG,KAAK,QAAQ,UAAU,IAAI,yBAAyB;AAAA,IAC3D;AAEA,QAAI,GAAG,aAAa,GAAG,kBAAkB;AACrC,SAAG,mBAAmB,GAAG;AACzB,SAAG,WAAW,GAAG;AAAA,IACrB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAiB,EAAE,MAAM,QAAQ,QAAQ,uBAAuB,KAAK,GAAG;AA5M5E;AA6MQ,UACI,eAAe,UAAW,iBAAiB,OAAO,MAClD,EAAE,QAAQ,IAAK;AACnB,QAAI,sBAAsB;AACtB,iBAAK,qBAAL,8BAAwB,GAAG;AAAA,IAC/B;AACA,WAAO;AAAA,MACH,WAAY,EAAE,eAAgB,EAAE;AAAA,MAChC,WAAY,YAAO,YAAP,mBAAgB,IAAI,CAAC,cAAc,UAAU;AArNrE,YAAAA;AAsNgB,YAAI,aAAa,cAAc;AAC3B,cAAK,OAAO,aAAa,YAAY,cAAe,aAAa,QAAQ,EAAE,OAAO,CAAC,MAAM,OAAO;AAC5F,mBAAO;AAAA,UACX;AACA,cAAI,aAAa,YAAY,OAAO;AAChC,mBAAO;AAAA,UACX;AAAA,QACJ;AAEA,YAAK,gBAAgB,CAAC,aAAa,gBAAkB,CAAC,gBAAgB,aAAa,cAAe;AAC9F,iBAAO;AAAA,QACX;AACA,cACI;AAAA,UACI;AAAA,UACA;AAAA,QACJ,IAAO,cACP,OAAQ,OAAO,YAAY,gBAAcA,MAAA,mCAAS,eAAT,gBAAAA,IAAA,cAAsB,UAAU,QAAQ,SAAS,SAAS,SAAS,CAAC,EAAE,OAAO,CAAC,CAAC,IAAI,WAAW;AAE3I,YAAI,UAAU;AACV,gBAAM,qBAAqB,QAAQ,SAAS,UAAU,SAAS,CAAC;AAAA,YAC5D;AAAA,YACA;AAAA,YACA;AAAA,YACA,SAAU;AAAA,YACV,QAAU;AAAA,UACd,CAAC,CAAC;AAEF,cAAI,OAAO,uBAAuB,UAAU;AACxC,mBAAO;AAAA,cACH,KAAU;AAAA,cACV,SAAU;AAAA,gBACN,GAAG,QAAQ,aAAa,IAAI;AAAA,gBAC5B;AAAA,cACJ;AAAA,cACA,MAAO;AAAA,YACX;AAAA,UACJ,OACK;AACD,+BAAmB,UAAU,mBAAmB,WAAW,CAAC;AAC5D,+BAAmB,QAAQ,QAAQ;AACnC,mBAAO;AAAA,UACX;AAAA,QACJ,OACK;AACD,iBAAO;AAAA,YACH,KAAU;AAAA,YACV,SAAU;AAAA,cACN,GAAG,QAAQ,aAAa,IAAI;AAAA,cAC5B;AAAA,YACJ;AAAA,YACA,cAAe;AAAA,YACf,WAAe;AAAA,cACX,UAAqB;AAAA,cACrB,iBAAqB;AAAA,cACrB,CAAC,aAAa,GAAG,GAAI,aAAa;AAAA,YACtC;AAAA,UACJ;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,EAAE,QAAQ,QAAQ,OAAO,GAAG;AAxR5C;AAyRQ,QAAI,WAAW,QAAQ,CAAC,OAAO,UAAU,SAAS,eAAe,GAAG;AAChE;AAAA,IACJ;AACA,QAAI,cAAc,OAAO,QAAQ;AAGjC,QAAI,CAAC,aAAa;AACd,oBAAc,OAAO,cAAc,WAAW,OAAO,cAAc,QAAQ;AAAA,IAC/E;AACA,UACI,UAAgB,YAAO,YAAP,mBAAiB,cACjC,gBAAgB,iCAAQ;AAC5B,QAAI,eAAe;AACf,WAAK,SAAS,eAAe,QAAQ,CAAC,EAAE,QAAQ,QAAQ,OAAO,CAAC,CAAC;AAAA,IACrE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,kBAAkB;AACd,UACI,KAAe,MACf,eAAe,CAAC,GAChB;AAAA,MACI,SAAU;AAAA,IACd,IAAe;AAEnB,QAAI,CAAC,GAAG,SAAS;AACb;AAAA,IACJ;AACA,UAAMC,WAAU,GAAG,UAAU,CAAC;AAE9B,6CAAY,QAAQ,oBAAkB;AAClC,YAAM,SAAS,EAAE,GAAG,eAAe;AAEnC,aAAO,OAAO;AAEd,UAAI,OAAO,cAAc;AACrB,eAAO,OAAO;AACd,qBAAa,KAAK,MAAM;AAAA,MAC5B,OACK;AACD,QAAAA,SAAQ,KAAK,MAAM;AAAA,MACvB;AAAA,IACJ;AAEA,QAAI,aAAa,SAASA,SAAQ,QAAQ;AACtC,SAAG,WAAW;AAAA,IAClB;AACA,UAAM,cAAc,UAAU,cAAc,GAAG,iBAAiB,EAAE,QAAS,IAAI,sBAAuB,MAAM,CAAC,CAAC,EAAE;AAChH,OAAG,QAAQ,UAAU,YAAY,aAAa,GAAG,SAAS,MAAM,GAAG,QAAQ,aAAa;AACxF,OAAG,UAAU;AAAA,EACjB;AACJ;AA7PI,cADiB,cACV,QAAO;AACd,cAFiB,cAEV,UAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAyBZ,EAAE,MAAO,WAAW,MAAO,QAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOnC,EAAE,MAAO,yBAAyB,cAAe,MAAM;AAC3D;AACA,cApCiB,cAoCV,YAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQd,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQb,WAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQZ,UAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQX,QAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQT,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQb,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOb,WAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOZ,UAAW;AACf;AA4JJ,YAAY,mBAAmB,YAAY;AAC3C,aAAa,iBAAiB;AAC9B,aAAa,SAAS;;;ACtStB,IAAqB,kBAArB,cAA6C,aAAa;AAAA,EAOtD,WAAW,WAAW;AAClB,WAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAgBH,UAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMX,0BAA2B;AAAA,IAC/B;AAAA,EACJ;AAAA,EACA,UAAU,MAAM,aAAa;AACzB,UAAM,KAAK;AACX,OAAG,kBAAkB,WAAW;AAChC,OAAG,mBAAmB,YAAY;AAClC,UAAM,UAAU,GAAG,SAAS;AAC5B,UAAM,EAAE,KAAK,IAAI;AAEjB,QAAI,GAAG,aAAa,OAAO;AACvB,SAAG,WAAW;AAAA,IAClB;AACA,QAAI,MAAM;AACN,SAAG,QAAQ,KAAK;AAAA,IACpB;AAAA,EACJ;AAAA,EACA,IAAI,MAAM,OAAO;AACb,UACI,KAAiB,MACjB,iBAAiB;AAAA,MACb,QAAU;AAAA,MACV,SAAU;AAAA,MACV,MAAU;AAAA,IACd,GACA,WAAW,GAAG;AAClB,QAAI,UAAU,UAAU;AACpB,UAAI,UAAU;AACV,iBAAS,GAAG,cAAc;AAAA,MAC9B;AACA,SAAG,SAAS;AACZ,YACI,EAAE,WAAW,IAAI,OACjB,QAAQ,WAAW,SAAS,GAAG,KAAK;AAGxC,UAAI,SAAS,MAAM,SAAS,UAAU;AAClC,YAAI,CAAC,GAAG,iBAAiB;AACrB,aAAG,QAAQ;AAAA,QACf;AACA,YAAI,CAAC,GAAG,kBAAkB;AACtB,aAAG,SAAS;AAAA,QAChB;AAAA,MACJ;AACA,YAAM,IAAI,cAAc;AAAA,IAC5B;AAAA,EACJ;AAAA,EACA,QAAQ,QAAQ;AACZ,WAAO,OAAO;AAAA,EAClB;AAAA,EACA,IAAI,QAAQ;AACR,WAAO,KAAK;AAAA,EAChB;AAAA,EACA,eAAe,MAAM;AACjB,QAAI,SAAS;AACb,aAAS,IAAI,GAAG,EAAE,OAAO,IAAI,MAAM,IAAI,QAAQ,KAAK;AAChD,gBAAU,WAAW,KAAK,CAAC,KAAK,GAAG,EAAE;AAAA,IACzC;AACA,WAAO;AAAA,EACX;AAAA,EACA,OAAO,MAAM;AACT,QAAI,SAAS;AACb,UAAM,EAAE,OAAO,IAAI;AACnB,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAC7B,gBAAU,WAAW,KAAK,CAAC,KAAK,GAAG,EAAE;AAAA,IACzC;AACA,WAAO,SAAS;AAAA,EACpB;AAAA,EACA,eAAe,EAAE,QAAQ,QAAQ,GAAG;AAChC,UACI,KAAK,MACL,EAAE,WAAW,IAAI,GAAG;AACxB,QAAI,GAAG,SAAS,SAAS;AACrB,UAAI,OAAO,QAAQ;AACf,eAAO,OAAO,SAAO;AACjB,gBAAM,MAAM,WAAW,UAAU,GAAG;AACpC,cAAI,KAAK;AACL,kBAAM,cAAc,IAAI,QAAQ,GAAG,KAAK;AACxC,gBAAI,aAAa;AACb,kBAAI,WAAW,WAAW;AAAA,YAC9B;AAAA,UACJ;AAAA,QACJ,GAAG,IAAI;AAAA,MACX;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,YAAY,QAAQ;AAhKxB;AAiKQ,QAAI;AACJ,UACI,KAAY,MACZ,EAAE,MAAM,IAAI;AAChB,SAAI,YAAO,aAAP,mBAAiB,QAAQ;AACzB,YACI,KAAW,GAAG,UACd,WAAW,OAAO,OAAO,YAAY,OAAO,KAAK,EAAE,MAAM,YACzD;AAAA,QACI;AAAA,QACA;AAAA,MACJ,IAAI,WAAW;AAAA,QACX,SAAU,KAAK,EAAE;AAAA,QACjB,SAAU;AAAA,MACd,IAAI,GAAG,gBAAgB,EAAE;AAE7B,cAAQ,QAAQ,MAAM,SAAS,OAAO,SAAS,IAAI,OAAK,GAAG,YAAY,CAAC,CAAC,CAAC;AAC1E,UAAI,GAAG,0BAA0B;AAC7B,eAAO,IAAI,OAAO,OAAO,IAAI;AAAA,MACjC,OACK;AACD,eAAO,QAAQ,OAAO,KAAK;AAAA,MAC/B;AAAA,IACJ,OACK;AACD,cAAQ,OAAO,SAAS,KAAK;AAAA,IACjC;AACA,WAAO;AAAA,EACX;AAAA,EACA,eAAe;AACX,WAAO;AAAA,EACX;AACJ;AAAA;AAnJI,cAFiB,iBAEV,QAAO;AACd,cAHiB,iBAGV,UAAS;AAAA,EACZ;AAAA,EACA;AACJ;AAgJJ,YAAY,mBAAmB,iBAAiB,IAAI;AACpD,gBAAgB,iBAAiB;AACjC,gBAAgB,SAAS;;;AC1KzB,IAAqB,gBAArB,cAA2C,aAAa;AAAA,EAKpD,WAAW,WAAW;AAClB,WAAO;AAAA,MACH,KAAM;AAAA,MACN,KAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAON,WAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOZ,cAAe;AAAA,MACf,YAAkB;AAAA,MAClB,YAAkB;AAAA,MAClB,iBAAkB,CAAC,EAAE,IAAI,MAAM,GAAG,GAAG;AAAA,MACrC,SAAkB;AAAA,IACtB;AAAA,EACJ;AAAA,EACA,YAAY,QAAQ,OAAO;AACvB,UAAM,GAAG,SAAS;AAClB,SAAK,kBAAkB;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA8BA,gBAAgB,EAAE,MAAM,GAAG;AACvB,YAAQ,SAAS;AACjB,WAAO;AAAA,MACH,WAAkB;AAAA,MAClB,MAAkB;AAAA,MAClB,iBAAkB;AAAA,MAClB,iBAAkB;AAAA,MAClB,iBAAkB;AAAA,MAClB,cAAkB,QAAQ;AAAA,MAC1B,UAAkB;AAAA,MAClB,UAAkB;AAAA,QACd;AAAA,UACI,KAAY;AAAA,UACZ,WAAY;AAAA,YACR,iBAAkB;AAAA,YAClB,UAAkB,UAAU;AAAA,YAC5B,SAAkB,QAAQ,KAAK;AAAA,UACnC;AAAA,UACA,OAAQ;AAAA,YACJ,OAAQ,QAAQ;AAAA,UACpB;AAAA,UACA,UAAW;AAAA,YACP,KAAK,YAAY;AAAA,cACb,KAAO;AAAA,cACP,MAAO,QAAQ;AAAA,YACnB,IAAI;AAAA,UACR;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,qBAAqB;AAAA,EAAC;AAC1B;AA/FI,cADiB,eACV,QAAO;AAAA;AAEd,cAHiB,eAGV,aAAY;AACnB,cAJiB,eAIV,UAAS,CAAC,aAAa,cAAc;AA6FhD,cAAc,MAAM;AACpB,YAAY,mBAAmB,eAAe,IAAI;AAClD,cAAc,SAAS;;;ACjGvB,IAAqB,eAArB,cAA0C,aAAa;AAAA,EAMnD,WAAW,WAAW;AAClB,WAAO;AAAA,MACH,KAAM;AAAA,MACN,KAAM;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMN,WAAY;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMZ,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMb,UAAW;AAAA,MACX,YAAa;AAAA,MACb,YAAa;AAAA,MACb,OAAa;AAAA,MACb,YAAa;AAAA,MACb,UAAa;AAAA,MACb,QAAa;AAAA,MACb,SAAa;AAAA,IACjB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,EAAE,MAAM,GAAG;AAChB,WAAO;AAAA,MACH,WAAY;AAAA,QACR,uBAAwB;AAAA,QACxB,kBAAwB,CAAC,KAAK;AAAA,MAClC;AAAA,MACA,UAAW,YAAY,SAAS,KAAK,KAAK,OAAK;AAC3C,cAAM,SAAS,IAAI;AACnB,eAAO;AAAA,UACH,KAAY;AAAA,UACZ,WAAY;AAAA,YACR,iBAA8C;AAAA,YAC9C,YAA8C;AAAA,YAC9C,WAA8C,CAAC;AAAA,YAC/C,CAAC,SAAS,KAAK,aAAa,KAAK,SAAS,GAAI;AAAA,UAClD;AAAA,QACJ;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AAAA,EACA,YAAY,EAAE,MAAM,QAAQ,QAAQ,QAAQ,MAAM,GAAG;AACjD,QAAI,OAAO,UAAU,SAAS,eAAe,KAAK,CAAC,KAAK,YAAY,OAAO,UAAU;AACjF,UAAI,YAAY,CAAC,EAAE,QAAQ,KAAK,OAAO,WAAW,YAAY,MAAM;AACpE,UAAI,OAAO,UAAU,SAAS,UAAU,MAAM,MAAM,WAAW,MAAM,WAAW;AAC5E,oBAAY,YAAY;AAAA,MAC5B;AAEA,UAAI,OAAO,SAAS,OAAO,KAAK,MAAM,KAAK,cAAc,GAAG;AACxD,oBAAY;AAAA,MAChB;AACA,aAAO,IAAI,OAAO,OAAO,YAAY,CAAC;AAAA,IAC1C;AAAA,EACJ;AACJ;AAzEI,cADiB,cACV,SAAQ;AACf,cAFiB,cAEV,QAAO;AAAA;AAEd,cAJiB,cAIV,aAAY;AACnB,cALiB,cAKV,UAAS,CAAC,aAAa,cAAc,UAAU;AAsE1D,YAAY,mBAAmB,cAAc,IAAI;AACjD,aAAa,iBAAiB;AAC9B,aAAa,SAAS;;;AC9EtB,IAAqB,iBAArB,cAA4C,OAAO;AAAA,EAgB/C,WAAW,WAAW;AAClB,WAAO;AAAA,MACH,YAAa;AAAA,IACjB;AAAA,EACJ;AAAA,EACA,YAAY,QAAQ,OAAO;AACvB,UAAM,GAAG,SAAS;AAClB,UAAM,KAAK;AACX,QAAI,CAAC,GAAG,UAAU;AACd,YAAM,IAAI,MAAM,iCAAiC;AAAA,IACrD;AACA,QAAI,OAAO,GAAG,aAAa,YAAY;AACnC,YAAM,IAAI,MAAM,4CAA4C;AAAA,IAChE;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,YAAY;AAEjB,QAAI,CAAC,WAAW,OAAO,cAAc;AACjC,aAAO,KAAK,SAAS;AAAA,QACjB,OAAS,WAAW;AAAA,QACpB,QAAS,WAAW;AAAA,QACpB,OAAS,KAAK;AAAA,MAClB,CAAC;AAAA,IACL;AAAA,EACJ;AACJ;AA5CI,cADiB,gBACV,QAAO;AACd,cAFiB,gBAEV,UAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYZ;AACJ;AA+BJ,YAAY,mBAAmB,gBAAgB,IAAI;AACnD,eAAe,iBAAiB;AAChC,eAAe,SAAS;;;AChDxB,IAAqB,aAArB,cAAwC,OAAO;AAAA,EAM3C,WAAW,WAAW;AAClB,WAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOH,QAAS;AAAA,MACT,UAAW;AAAA,MACX,YAAa;AAAA,IACjB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB,EAAE,MAAM,GAAG;AACvB,WAAO,QAAQ,KAAK,YAAY,KAAK,IAAI;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc,EAAE,aAAa,YAAY,GAAG;AACxC,gBAAY,YAAY,KAAK,YAAY,WAAW;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,YAAY,OAAO;AAEf,QAAI,OAAO,UAAU,UAAU;AAC3B,cAAQ,WAAW,MAAM,OAAO,KAAK,MAAM;AAAA,IAC/C;AACA,WAAO,WAAW,OAAO,OAAO,KAAK,MAAM;AAAA,EAC/C;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,OAAO,OAAO;AACd,UAAM,EAAE,OAAO,IAAI;AACnB,SAAK,IAAI,UAAU,KAAK;AACxB,QAAI,QAAQ;AACR,aAAO,SAAS;AAAA,IACpB;AAAA,EACJ;AAAA,EACA,IAAI,SAAS;AACT,WAAQ,KAAK,IAAI,QAAQ;AAAA,EAC7B;AAAA,EACA,IAAI,gBAAgB;AAChB,WAAO;AAAA,MACH,MAAS,KAAK;AAAA,MACd,MAAS;AAAA,MACT,QAAS,KAAK;AAAA,IAClB;AAAA,EACJ;AAAA;AAEJ;AAAA;AAxEI,cAFiB,YAEV,QAAO;AAAA;AAEd,cAJiB,YAIV,aAAY;AACnB,cALiB,YAKV,UAAS,CAAC,QAAQ;AAsE7B,YAAY,mBAAmB,YAAY,IAAI;AAC/C,WAAW,iBAAiB;AAC5B,WAAW,SAAS;;;ACrGpB,IAAM,UAAU;AAAA,EACZ,KAAQ;AAAA,EACR,MAAQ;AAAA,EACR,OAAQ;AACZ;AA0DA,IAAqB,gBAArB,cAA2C,cAAc;AAAA,EAAzD;AAAA;AA4BI;AAAA,sCAAa;AAAA;AAAA,EAfb,iBAAiB;AACb,UAAM,eAAe;AACrB,SAAK,yBAAyB;AAAA,EAClC;AAAA,EACA,2BAA2B;AACvB,UAAM,KAAK;AACX,QAAI,CAAC,GAAG,OAAO,cAAc,MAAM;AAC/B,SAAG,WAAW;AAAA,IAClB,WACS,GAAG,0BAA0B;AAClC,SAAG,WAAW;AACd,aAAO,GAAG;AAAA,IACd;AAAA,EACJ;AAAA,EAGA,IAAI,SAAS,OAAO;AAChB,SAAK,YAAY;AAAA,EACrB;AAAA,EACA,IAAI,WAAW;AAjGnB;AAmGQ,QAAI,KAAK,aAAa,MAAM;AACxB,aAAO,GAAC,UAAK,OAAO,SAAS,aAArB,mBAA+B;AAAA,IAC3C;AACA,WAAO,QAAQ,KAAK,SAAS;AAAA,EACjC;AAAA,EACA,IAAI,UAAU;AAxGlB;AAyGQ,UAAM,EAAE,OAAO,IAAI;AACnB,WAAO,QAAQ,CAAC,KAAK,YAAY,OAAO,cAAc,WAE9C,CAAC,OAAO,cAAc,YACtB,YAAO,SAAS,iBAAhB,mBAA8B,aAC9B,OAAO,eAAe,OAAO,eAAe,OAAO,WAAW,EACjE;AAAA,EACT;AAAA,EACA,IAAI,cAAc;AAjHtB;AAkHQ,WAAO,KAAK,WAAW,CAAC,KAAK,YAAY,GAAC,UAAK,OAAO,SAAS,aAArB,mBAA+B,cAAa,CAAC,KAAK,OAAO;AAAA,EACvG;AAAA;AAAA,EAEA,kBAAkB,EAAE,WAAW,GAAG;AAC9B,QAAI,QAAQ,UAAU,GAAG;AACrB,aAAO,KAAK,YAAY,eAAe,UAAU,KAAK;AAAA,IAC1D;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM;AACR,UAAM,KAAK,KAAK,IAAI;AAAA,EACxB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,KAAK,QAAQ,OAAO;AACtB,QAAI,OAAO,SAAS,WAAW;AAC3B,cAAQ;AAAA,IACZ;AACA,UACI,KAAoB,MACpB,EAAE,cAAc,IAAI,GAAG,QACvB,QAAoB,QAAQ,cAAc,OAAO,OAAE;AA5I/D;AA4IkE,gBAAC,OAAE,WAAF,mBAAU;AAAA,KAAQ,IAAI;AACjF,QAAI,OAAO;AACP,UAAK,QAAQ,CAAC,GAAG,cAAc,CAAC,GAAG,SAAU;AACzC;AAAA,MACJ;AACA,YAAM,mBAAmB,GAAG,cAAc,KAAK;AAC/C,YAAM,GAAG,iBAAiB,kBAAkB,OAAO,EAAE,MAAM,CAAC;AAC5D,UAAI,UAAU,MAAM;AAChB,mBAAW,QAAQ,OAAO;AACtB,cAAI,CAAC,KAAK,OAAO,UAAU;AACvB,iBAAK,OAAO,IAAI,KAAK,OAAO,OAAO,IAAI;AAAA,UAC3C;AAAA,QACJ;AAAA,MACJ;AAWA,SAAG,OAAO,QAAQ,QAAQ,EAAE,OAAO,kBAAkB,OAAO,YAAa,GAAG,WAAW,CAAC;AAAA,IAC5F;AAAA,EACJ;AAAA;AAAA,EAEA,MAAM,WAAW,EAAE,MAAM,OAAO,MAAM,GAAG;AAarC,WAAO,MAAM,KAAK,OAAO,QAAQ,cAAc,EAAE,OAAO,MAAM,OAAO,YAAa,KAAK,WAAW,CAAC;AAAA,EACvG;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,QAAQ;AACV,UACI,KAAyB,MACzB,EAAE,QAAQ,WAAW,IAAI,IACzB,aAAyB,OAAO,cAAc,CAAC;AACnD,QAAI,CAAC,GAAG,eAAe,CAAC,YAAY;AAChC;AAAA,IACJ;AACA,UAAM,gBAAgB,MAAM,GAAG,kBAAkB,CAAC,GAAG,IAAI;AACzD,QAAI,CAAC,eAAe;AAChB;AAAA,IACJ;AACA,UAAM,EAAE,iBAAiB,YAAY,IAAI,GAAG,kBAAkB,aAAa;AAC3E,QAAI,OAAO,cAAc,WAAW,KAAK,YAAY,SAAS,GAAG;AAC7D,aAAO,gBAAgB,YAAY,CAAC,GAAG,YAAY,YAAY,SAAS,CAAC,CAAC;AAAA,IAC9E;AAWA,WAAO,QAAQ,SAAS,EAAE,eAAe,YAAY,iBAAkB,CAAC,GAAG,eAAe,GAAG,WAAW,CAAC;AAAA,EAC7G;AAAA;AAAA,EAEA,MAAM,YAAY,EAAE,KAAK,GAAG;AAYxB,WAAO,MAAM,KAAK,OAAO,QAAQ,eAAe;AAAA,MAC5C,eAAgB;AAAA,MAAM,YAAa,KAAK,OAAO;AAAA,MAAc,YAAa,KAAK;AAAA,IACnF,CAAC;AAAA,EACL;AAAA,EACA,iBAAiB,EAAE,QAAQ,MAAM,GAAG;AAChC,UAAM,KAAK;AACX,QAAI,GAAG,SAAS;AACZ,YAAM,UAAU;AAAA,QACZ,MAAc,GAAG;AAAA,QACjB,aAAc;AAAA,QACd,MAAc;AAAA,QACd,QAAc;AAAA,QACd,UAAc,OAAO,YAAY,CAAC,GAAG;AAAA,QACrC,QAAc,MAAM,GAAG,IAAI;AAAA,MAC/B;AACA,YAAM,YAAY;AAAA,QACd,MAAc,GAAG;AAAA,QACjB,aAAc;AAAA,QACd,MAAc;AAAA,QACd,QAAc;AAAA,QACd,UAAc,OAAO,YAAY,CAAC,GAAG,eAAe,GAAG,iBAAiB,MAAM;AAAA,QAC9E,QAAc,MAAM,GAAG,MAAM;AAAA,MACjC;AACA,YAAM,WAAW;AAAA,QACb,MAAc,GAAG;AAAA,QACjB,aAAc;AAAA,QACd,KAAc;AAAA,QACd,MAAc;AAAA,QACd,QAAc;AAAA,QACd,QAAc,MAAM,GAAG,KAAK;AAAA,MAChC;AAAA,IACJ;AAAA,EACJ;AACJ;AAxMI,cADiB,eACV,SAAQ;AACf,cAFiB,eAEV,gBAAe;AAAA,EAClB,OAAQ;AAAA,IACJ;AAAA,IAAoB;AAAA,EACxB;AACJ;AACA,cAPiB,eAOV,gBAAe;AAAA,EAClB,oBAAqB,CAAC,cAAc;AAAA,EACpC,UAAY;AAAA,EACZ,SAAY;AAAA,EACZ,WAAY;AAChB;AA8LJ,cAAc,SAAS;AAAiB,mBAAmB,gBAAgB,aAAa;;;ACnNxF,IAAqB,cAArB,cAAyC,eAAe;AAAA;AAAA;AAAA,EAuBpD,UAAU,MAAM,QAAQ;AACpB,UAAM,UAAU,MAAM,KAAK,cAAc,MAAM,CAAC;AAAA,EACpD;AAAA,EACA,UAAU;AACN,UAAM,KAAK;AAMX,OAAG,MAAM,QAAQ,IAAI;AAAA,MACjB,YAAoB,GAAG,OAAO;AAAA,MAC9B,aAAoB;AAAA,MACpB,YAAoB;AAAA,MACpB,YAAoB;AAAA,MACpB,KAAoB;AAAA,MACpB,SAAoB,GAAG,kBAAkB,KAAK,EAAE;AAAA,MAChD,mBAAoB;AAAA,QAChB,aAAc;AAAA,QACd,SAAc;AAAA,MAClB;AAAA;AAAA,MAEA,WAAY,GAAG;AAAA,IACnB,GAAG,GAAG,aAAa;AACnB,OAAG,YAAY,GAAG,KAAK,CAAC,cAAc,MAAM,CAAC;AAAA,EACjD;AAAA,EACA,cAAc,EAAE,OAAO,GAAG;AACtB,UAAM,SAAS,KAAK,OAAO,qBAAqB,MAAM;AAEtD,WAAO,OAAO,oBAAoB,SAAS,QAAQ,OAAO,mBAAmB,KAAK,eAAe;AAAA,EACrG;AAAA;AAAA;AAAA,EAGA,cAAc,QAAQ;AAClB,QAAI,OAAO,WAAW,YAAY;AAC9B,aAAO;AAAA,QACH,iBAAkB;AAAA,MACtB;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA,EAEA,UAAU,QAAQ;AACd,UAAM,UAAU,KAAK,cAAc,MAAM,CAAC;AAAA,EAC9C;AAAA,EACA,YAAY;AACR,SAAK,OAAO,KAAK,IAAI,QAAQ;AAC7B,UAAM,UAAU;AAAA,EACpB;AAAA,EACA,UAAU,SAAS;AACf,QAAI,CAAC,SAAS;AACV,WAAK,QAAQ;AAAA,IACjB,WACS,KAAK,KAAK;AACf,WAAK,IAAI,QAAQ;AACjB,WAAK,MAAM;AAAA,IACf;AACA,UAAM,UAAU,OAAO;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,kBAAkB,EAAE,KAAK,cAAe,aAAa,MAAM,GAAG;AAC1D,UACI,KAAS,MACT,SAAS,GAAG,OAAO,qBAAqB,WAAW,GACnD,SAAS,GAAG,OAAO,qBAAqB,WAAW,GACnD,MAAS,EAAE,aAAa,QAAQ,QAAQ,OAAO,KAAK,aAAc,GAAG;AACzE,QAAI;AAEJ,QAAI,CAAC,GAAG,eAAe,WAAW,GAAG,cAAc,OAAO,eAAe,GAAG,wBAAwB,WAAW,GAAG,YAAY;AAC1H,aAAO,GAAG,IAAI;AAAA,IAClB;AACA,OAAG,aAAa;AAChB,OAAG,uBAAuB,OAAO;AACjC,OAAG,aAAa;AAEhB,QAAI,OAAO,iBAAiB;AACxB,eAAS,OAAO,gBAAgB,GAAG;AAAA,IACvC,WAES,GAAG,mBAAmB,OAAO,oBAAoB,OAAO;AAC7D,eAAS,GAAG,gBAAgB,GAAG;AAAA,IACnC;AAEA,QAAI,QAAQ,UAAU,MAAM,GAAG;AAC3B,SAAG,aAAa,GAAG,uBAAuB,GAAG,aAAa;AAAA,IAC9D;AAEA,QAAI,CAAC,QAAQ;AACT,UAAI,KAAK;AAAA,IACb;AACA,WAAO;AAAA,EACX;AAAA;AAEJ;AAAA;AAvHI,cAFiB,aAEV,SAAQ;AACf,cAHiB,aAGV,gBAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBlB,iBAAkB;AACtB;AAsGJ,YAAY,SAAS;AAAe,mBAAmB,gBAAgB,WAAW;;;AC/IlF,IAAqB,eAArB,cAA0C,eAAe;AAAA,EAWrD,YAAY;AA9ChB;AA+CQ,eAAK,WAAL,mBAAa;AACb,UAAM,UAAU;AAAA,EACpB;AAAA,EACA,WAAW,eAAe;AACtB,WAAO;AAAA,MACH,OAAQ,CAAC,oBAAoB;AAAA,IACjC;AAAA,EACJ;AAAA,EACA,mBAAmB,EAAE,OAAO,OAAO,GAAG;AAClC,UAAM,SAAS;AAAA,MACX,QAAW;AAAA,MACX,MAAW;AAAA,MACX,MAAW,KAAK,EAAE,WAAW;AAAA,MAC7B,UAAW,OAAO;AAAA,MAClB,QAAW,MAAM,KAAK,UAAU,MAAM;AAAA,IAC1C;AAAA,EACJ;AAAA,EACA,UAAU,QAAQ;AAhEtB;AAiEQ,QAAI,kBAAkB,OAAO;AAEzB,gBAAS,UAAK,OAAO,uBAAuB,MAAM,MAAzC,mBAA4C;AAAA,IACzD;AACA,QAAI,QAAQ;AACR,UAAI,OAAO,UAAU;AAEjB,eAAO;AAAA,MACX;AACA,YAAM,EAAE,YAAY,IAAI;AACxB,UAAI,EAAE,OAAO,IAAI;AACjB,UAAI,CAAC,QAAQ;AACT,aAAK,SAAS,SAAS,IAAI,OAAO;AAAA,UAC9B,OAAQ,KAAK;AAAA,UACb,OAAQ;AAAA,YACJ,OAAQ;AAAA,UACZ;AAAA,QACJ,CAAC;AAAA,MACL;AACA,aAAO,OAAO,WAAW;AACzB,aAAO,UAAU;AAAA,QACb,QAAS;AAAA,QACT,QAAS;AAAA,QACT,OAAS;AAAA,MACb,CAAC;AAAA,IACL;AAAA,EACJ;AACJ;AAxDI,cADiB,cACV,SAAQ;AACf,cAFiB,cAEV,gBAAe;AAAA;AAAA;AAAA;AAAA;AAAA,EAKlB,QAAS;AAAA,IACL,IAAK;AAAA,EACT;AACJ;AAgDJ,aAAa,SAAS;AAAgB,mBAAmB,gBAAgB,cAAc,KAAK;;;AC3D5F,IAAqB,aAArB,cAAwC,eAAe,MAAM,iBAAS,EAAE;AAAA,EAAxE;AAAA;AAmDI,qCAAY;AAAA,MACR,iBAAkB;AAAA,IACtB;AAAA;AAAA,EATA,iBAAiB;AACb,UAAM,eAAe;AACrB,QAAI,CAAC,KAAK,OAAO,cAAc,MAAM;AACjC,WAAK,WAAW;AAAA,IACpB;AACA,SAAK,iBAAiB,CAAC;AAAA,EAC3B;AAAA,EAIA,kBAAkB;AACd,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,qBAAqB;AACjB,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,oBAAoB;AAChB,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,qBAAqB,OAAO,wBAAwB;AAChD,QAAI,wBAAwB;AACxB,+BAAyB,CAAC,MAAM,OAAO,UAAU,SAAS,eAAe;AAAA,IAC7E;AACA,WAAO,KAAK,WAAW,qBAAqB,OAAO,sBAAsB;AAAA,EAC7E;AAAA;AAAA,EAEA,sBAAsB,OAAO,YAAY,UAAU;AAC/C,UAAM,SAAS,CAAC;AAEhB,eAAW,QAAQ,OAAO;AACtB,YAAM,KAAK,aAAa,KAAK,KAAK,KAAK;AACvC,UAAI,QAAQ,KAAK,OAAO,SAAS,KAAK,OAAO,KAAK;AAElD,UAAI,SAAS,OAAO,UAAU,YAAY,CAAC,MAAM,KAAK,GAAG;AACrD,gBAAQ,WAAW,KAAK;AAAA,MAC5B;AACA,UAAI,CAAC,OAAO,EAAE,GAAG;AACb,eAAO,EAAE,IAAI,CAAC;AAAA,MAClB;AACA,aAAO,EAAE,EAAE,KAAK,KAAK;AAAA,IACzB;AAEA,eAAW,YAAY,QAAQ;AAC3B,aAAO,QAAQ,EAAE,UAAU,KAAK,sBAAsB,OAAO,QAAQ,GAAG,QAAQ;AAAA,IACpF;AACA,WAAO;AAAA,EACX;AAAA,EACA,sBAAsB,OAAO,UAAU;AACnC,UACI,YAAY,MAAM,WAAW,IAAK,MAAM,SAAS,CAAE,GACnD,UAAY;AAAA,MACR,MAAO,MAAM;AAAA,MACb;AAAA,IACJ;AAEJ,QAAI,MAAM,MAAM,SAAO,OAAO,QAAQ,QAAQ,KAAK,MAAM,MAAM,SAAO,eAAe,IAAI,GAAG;AACxF,YAAM,QAAQ,MAAM,IAAI,CAAC,KAAK,OAAO,MAAM,MAAM,KAAK,CAAC,CAAC;AACxD,YAAM,MAAM;AAEZ,UAAI,IAAI,IAAI,KAAK,EAAE,SAAS,GAAG;AAC3B,gBAAQ,aAAa,MAAM,CAAC,KAAK,WAAW,KAAK;AACjD,gBAAQ,OAAO,MAAM;AACjB,cAAI,QAAQ,qBAAqB,MAAM;AACnC,oBAAQ,YAAY,IAAI,KAAK,QAAQ,UAAU,QAAQ,IAAI,QAAQ,UAAU;AAAA,UACjF,OACK;AACD,oBAAQ,aAAa,QAAQ;AAAA,UACjC;AACA,iBAAO,QAAQ;AAAA,QACnB;AAAA,MACJ;AAAA,IACJ,WAES,MAAM,SAAS,GAAG;AACvB,cAAQ,gBAAgB,CAAC,GAAG,KAAK;AACjC,cAAQ,OAAO,MAAM;AACjB,YAAI,QAAQ,iBAAiB,QAAW;AACpC,kBAAQ,eAAe;AAAA,QAC3B,OACK;AACD,kBAAQ,gBAAgB;AACxB,cAAI,QAAQ,gBAAgB,QAAQ,cAAc,QAAQ;AACtD,oBAAQ,eAAe;AAAA,UAC3B;AAAA,QACJ;AACA,eAAO,QAAQ,cAAc,QAAQ,YAAY;AAAA,MACrD;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA,EAEA,uBAAuB;AACnB,UAAM,KAAK;AACX,QAAI,GAAG,OAAO,UAAU;AACpB,SAAG,eAAe;AAClB;AAAA,IACJ;AAEA,QAAI,qBAAa,YAAY,GAAG;AAC5B,SAAG,OAAO,kBAAkB,MAAM,GAAG,gBAAgB,IAAI,CAAC;AAE1D,SAAG,eAAe;AAAA,IACtB,OAEK;AACD,SAAG,gBAAgB,IAAI;AAAA,IAC3B;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB;AACd,QAAI,CAAC,KAAK,cAAc;AACpB,YAAM,QAAQ,KAAK;AACnB,UAAI,OAAO;AACP,aAAK,wBAAwB,MAAM,CAAC,GAAG,MAAM,MAAM,SAAS,CAAC,CAAC;AAAA,MAClE,OACK;AACD,aAAK,eAAe;AAAA,MACxB;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,YAAY,OAAO;AACf,UAAM,EAAE,OAAO,IAAI;AACnB,QAAI,CAAC,OAAO,UAAU;AAClB,WAAK,eAAe,gBAAgB,YAAY,GAAG;AAAA,QAC/C,SAAY;AAAA,QACZ,WAAY;AAAA,UACR,SAAU;AAAA,UACV,SAAU,OAAO;AAAA,QACrB;AAAA,QACA,SAAU;AAAA,QACV,SAAU;AAAA,MACd,CAAC;AACD,YAAM,eAAe;AACrB,YAAM,yBAAyB;AAC/B,YAAM,UAAU;AAAA,IACpB;AAAA,EACJ;AAAA;AAAA,EAEA,YAAY;AA9NhB;AA+NQ,UACI,KAAkB,MAClB;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,IACJ,IAAkB,IAClB,QAAkB,GAAG,gBACrB,kBAAkB,SAAS,gBAAgB,OAAO,oBAAoB,aAAa,MAAM,aAAa,EAAE,GACxG,iBAAkB,mDAAiB,kBAAiB,CAAC,GAGrD,iBAAkB,cAAc,GAAG,gBAC7B,cAAc,OAAO,UAAQ,CAAC,MAAM,KAAK,SAAO,IAAI,OAAO,MAAM,IAAI,CAAC,CAAC;AACjF,WAAO,GAAG;AACV,QAAI,GAAG,cAAc;AACjB,aAAO,6BAA6B,OAAO,KAAK;AAChD,aAAO,GAAG;AAAA,IACd;AAEA,QAAI,EAAC,iDAAgB,SAAQ;AACzB,SAAG,gBAAgB;AACnB;AAAA,IACJ;AACA,WAAO,eAAe;AAEtB,QAAI,aAAa;AACb,qBAAe,QAAQ,UAAQ,KAAK,OAAO,IAAI,KAAK,OAAO,OAAO,MAAM,OAAO,OAAO,OAAO,IAAI,CAAC;AAAA,IACtG,OAEK;AACD,YACI,CAAC,SAAS,IAAI,gBAEd,aAAc,MAAM,KAAK,SAAO,IAAI,WAAW,UAAU,MAAM,GAE/D,WAAc,aACR,UAAU,cAAc,MAAM,CAAC,EAAE,cACjC,UAAU,WAAW,MAAM,CAAC,EAAE,UACpC,WAAc,GAAG,sBAAsB,OAAO,YAAY,QAAQ,GAClE,YAAc,oBAAI,IAAI;AAC1B,UAAI,UAAU;AACV,uBAAe,QAAQ;AAAA,MAC3B;AACA,iBAAW,QAAQ,gBAAgB;AAC/B,cAAM,EAAE,QAAQ,OAAO,IAAI;AAC3B,YAAI,CAAC,OAAO,YAAY,OAAO,aAAa,EAAE,OAAO,QAAQ,KAAK,CAAC,GAAG;AAClE,cAAI,SAAU,QAAG,uBAAH,4BAAwB,EAAE,OAAO,QAAQ,QAAQ,KAAK,IAChE,UAAU,UAAU,IAAI,MAAM;AAClC,cAAI,CAAC,SAAS;AACV,sBAAU,CAAC;AACX,sBAAU,IAAI,QAAQ,OAAO;AAAA,UACjC;AACA,cAAI,UAAU,QAAW;AACrB,kBAAM,UAAU,SAAS,aAAa,KAAK,KAAK,KAAK,QAAQ,EAAE;AAC/D,oBAAQ,QAAQ,KAAK;AAAA,UACzB;AACA,kBAAQ,OAAO,KAAK,MAAI,YAAO,uBAAP,gCAA4B,EAAE,OAAO,QAAQ,MAAM,OAAM;AAAA,QACrF;AAAA,MACJ;AACA,iBAAW,CAAC,QAAQ,OAAO,KAAK,WAAW;AACvC,eAAO,IAAI,SAAS,MAAM,MAAM,MAAM,MAAM,IAAI;AAAA,MACpD;AAAA,IACJ;AACA,WAAO,cAAc,IAAI;AAEzB,WAAO,iBAAiB,eAAe;AACvC,WAAO,GAAG;AACV,OAAG,gBAAgB;AAAA,EACvB;AAAA;AAAA,EAEA,YAAY,OAAO;AAtSvB;AAuSQ,UACI,KAAe,MACf;AAAA,MACI;AAAA,MACA;AAAA,IACJ,IAAe,IACf,QAAe,eAAe,CAAC,GAC/B,OAAe,eAAe,eAAe,SAAS,CAAC,GACvD,WAAe,OAAO,qBAAqB,OAAO,IAAI;AAC1D,QAAI,eAAe,YAAY,OAAO,qBAAqB,SAAS,YAAY;AAChF,UAAI,kDAAc,YAAd,mBAAuB,YAAW,MAAM,QAAQ,QAAQ;AACxD,YACI,iBAAiB,eAAe,KAAK,QAAM,GAAG,OAAO,cAAc,IAAI,CAAC;AAC5E,UAAI;AACJ,UAAI,CAAC,GAAG,cAAc;AAClB,eAAO,4BAA4B,OAAO,KAAK;AAAA,MACnD;AACA,UAAI,gBAAgB;AAEhB,WAAG,cAAc,GAAG,kBACf,aAAa,WAAW,KAAK,YAAY,aAAa,cAAc,KAAK;AAAA,MAClF,OACK;AAED,YAAI,aAAa,YAAY,MAAM,YAAY,aAAa,YAAY,KAAK,UAAU;AACnF,qBAAe,MAAM,cAAc,aAAa;AAChD,yBAAe,IAAI,SAAS;AAAA,YACxB,MAAS;AAAA,YACT,QAAS,WAAW,MAAM,SAAS,KAAK;AAAA,YACxC,QAAS,aAAa;AAAA,UAC1B,CAAC;AAAA,QACL,OAEK;AACD,qBAAe,MAAM,WAAW,aAAa;AAC7C,yBAAe,IAAI,SAAS;AAAA,YACxB,MAAS;AAAA,YACT,QAAS,aAAa;AAAA,YACtB,QAAS,WAAW,MAAM,SAAS,KAAK;AAAA,UAC5C,CAAC;AAAA,QACL;AAAA,MACJ;AAEA,YAGI,OAAO,WAAW,eAAe,OAGjC,KAAO,YAAa,kBAAkB,CAAC,GAAG,cAAe,OAAO;AACpE,SAAG,eAAe,EAAE,MAAM,GAAG;AAE7B,SAAG,eAAe;AAClB,SAAG,wBAAwB,MAAM,IAAI,IAAI;AAAA,IAC7C;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,wBAAwB,MAAM,IAAI,gBAAgB,OAAO;AAjW7D;AAkWQ,UACI,KAAY,MACZ;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,IACJ,IAAY,IACZ,WAAY,OAAO,SAAS,KAAK,OAAO,MAAM,EAAE,SAChD,EAAE,EAAE,IAAQ,UAAU,KAAK,KAAK,QAAQ,KAAK,OAAO,SAAS,QAAQ,GACrE,EAAE,MAAM,IAAI,UAAU,KAAK,GAAG,QAAQ,GAAG,OAAO,SAAS,QAAQ,GACjE,EAAE,EAAE,IAAQ,OAAO,gBAAgB,KAAK,QAAQ,IAAI,GACpD,SAAY,OAAO,gBAAgB,GAAG,QAAQ,IAAI,EAAE,SAAS;AACjE,QAAI;AAAA,MACA;AAAA,MACA;AAAA,IACJ,IAAgB;AAChB,OAAG,eAAe,aAAa;AAC/B,QAAI,CAAC,eAAe;AAChB,SAAG,gBAAgB,gBAAgB,UAAU,cAAc;AAAA,QACvD,WAAY;AAAA,MAChB,CAAC;AACD,SAAG,gBAAgB,gBAAgB,UAAU,cAAc;AAAA,QACvD,WAAY;AAAA,MAChB,CAAC;AAAA,IACL;AACA,cAAU,QAAQ,eAAe,EAAE,GAAG,GAAG,OAAS,QAAQ,GAAI,QAAU,SAAS,EAAG,CAAC;AACrF,aAAS,YAAY,aAAa;AAElC,cAAU,WAAW,eAAe,QAAQ,SAAS,SAAS,cAAc,IAAI,KAAK;AACrF,aAAS,YAAY,aAAa;AAElC,OAAG,kBAAkB,KAAK;AAC1B,WAAO,GAAG;AAEV,QAAI,GAAG,iBAAe,QAAG,mBAAH,mBAAmB,SAAQ;AAC7C,YAAM,WAAW,OAAO,SAAS,aAAa,MAAM,aAAa,EAAE;AACnE,SAAG,gBAAgB,GAAG,eAAe,OAAO,SAAO,CAAC,SAAS,KAAK,UAAQ,KAAK,OAAO,KAAK,IAAI,CAAC,CAAC;AACjG,SAAG,kBAAkB;AAAA,IACzB;AACA,QAAI,CAAC,eAAe,aAAa;AAC7B,qBAAe,cAAc,YAAY,GAAG;AAAA,QACxC,SAAY,OAAO;AAAA,QACnB,UAAY;AAAA,QACZ,WAAY;AAAA,QACZ,SAAY;AAAA,MAChB,CAAC;AAAA,IACL;AACA,OAAG,kBAAkB;AAAA,EACzB;AAAA,EACA,kBAAkB,MAAM,MAAM;AAnZlC;AAoZQ,eAAK,kBAAL,mBAAoB,QAAQ,SAAI;AApZxC,UAAAC;AAoZ2C,cAAAA,MAAA,KAAK,OAAO,QAAQ,GAAG,MAAvB,gBAAAA,IAA0B,UAAU,OAAO,mBAAmB;AAAA;AAAA,EACrG;AAAA,EACA,eAAe,gBAAgB,OAAO;AAtZ1C;AAuZQ,UAAM,KAAK;AACX,aAAG,kBAAH,mBAAkB;AAClB,aAAG,kBAAH,mBAAkB;AAClB,QAAI,CAAC,eAAe;AAChB,SAAG,gBAAgB;AAAA,IACvB;AACA,OAAG,kBAAkB;AAAA,EACzB;AAAA;AAAA,EAEA,kBAAkB;AACd,UAAM,KAAK;AACX,eAAW,YAAY,GAAG,gBAAgB;AACtC,SAAG,eAAe,QAAQ,EAAE;AAAA,IAChC;AACA,OAAG,iBAAiB,CAAC;AAAA,EACzB;AAAA;AAAA;AAAA,EAGA,IAAI,iBAAiB;AAzazB;AA0aQ,UACI,EAAE,OAAO,IAAW,MACpB,EAAE,cAAc,IAAI,QACpB,SAAoB,YAAO,sBAAP,YAA6B,cAAc,WAAW,KAAK;AAGnF,QAAI,CAAC,OAAO,cAAc,WAAU,+BAAO,WAAU,MAAM,WAAW,cAAc,UAChF,MAAM;AAAA,MAAM,QAAM,cAAc,KAAK,QAAM,GAAG,OAAO,IAAI,IAAI,CAAC,KAC1D,GAAG,QAAQ,UAAU,GAAG,QAAQ,WAAW,MAAM,CAAC,EAAE,QAAQ,UAAU,OAAO,MAAM,YAAY,GAAG,EAAE;AAAA,IACxG,GACF;AACE,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AACJ;AAtZI,cADiB,YACV,SAAQ;AACf,cAFiB,YAEV,gBAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA6BlB,oBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMrB,eAAgB;AACpB;AAAA;AAEA,cAxCiB,YAwCV,gBAAe;AAAA,EAClB,OAAW,CAAC,wBAAwB,mBAAmB,sBAAsB,mBAAmB;AAAA,EAChG,UAAW,CAAC,sBAAsB;AACtC;AA6WJ,WAAW,SAAS;AAAc,mBAAmB,gBAAgB,UAAU;;;AC9a/E,IAAM,YAAY;AAAA,EACd,WAAc;AAAA,EACd,WAAc;AAAA,EACd,SAAc;AAAA,EACd,WAAc;AAAA,EACd,WAAc;AAAA,EACd,SAAc;AAAA,EACd,aAAc;AAAA,EACd,UAAc;AAAA,EACd,UAAc;AAAA,EACd,SAAc;AAAA,EACd,UAAc;AAAA,EACd,OAAc;AAAA,EACd,aAAc;AAClB;AA6BA,IAAqB,aAArB,cAAwC,eAAe;AAAA,EAAvD;AAAA;AAqCI;AAAA,wCAAe,CAAC;AAEhB;AAAA,qCAAe,CAAC;AAAA;AAAA,EAChB,WAAW,eAAe;AACtB,WAAO;AAAA,MACH,OAAQ;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA;AAAA,QAEA;AAAA,MACJ;AAAA;AAAA,MAEA,QAAS;AAAA,QACL;AAAA,MACJ;AAAA,MACA,UAAW;AAAA,QACP;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,iBAAiB;AACb,UACI,KAAa,MACb,EAAE,OAAO,IAAI;AAEjB,WAAO,YAAY,aAAW,GAAG,aAAa,OAAO,CAAC;AAEtD,WAAO,WAAW,IAAI;AAAA,MAClB,YAAa;AAAA,MACb,SAAa;AAAA,IACjB,CAAC;AACD,OAAG,UAAU,OAAO,KAAK;AAAA,EAC7B;AAAA,EACA,aAAa,SAAS;AAElB,YAAQ,sBAAsB,UAAU,cAAc;AAAA,MAClD,QAAY,QAAQ;AAAA,MACpB,WAAY;AAAA,QACR,iCAAkC;AAAA,MACtC;AAAA,IACJ,CAAC;AAED,YAAQ,IAAI;AAAA,MACR,sBAAuB;AAAA,MACvB,SAAuB;AAAA,IAC3B,CAAC;AAAA,EACL;AAAA,EACA,UAAU,SAAS;AACf,QAAI,CAAC,KAAK,eAAe;AAErB,WAAK,cAAc;AACnB,WAAK,MAAM;AACX,WAAK,cAAc;AAAA,IACvB;AACA,UAAM,UAAU,OAAO;AAAA,EAC3B;AAAA,EACA,kBAAkB,KAAK;AAEnB,SAAK,OAAO,QAAQ,UAAU,OAAO,4BAA4B,GAAG;AAAA,EACxE;AAAA,EACA,iBAAiB,YAAY;AACzB,QAAI,CAAC,KAAK,eAAe;AACrB,WAAK,MAAM,MAAM,UAAU;AAAA,IAC/B;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,UAAU,OAAO;AACb,SAAK,gBAAgB,OAAO;AAC5B,UAAM,IAAI;AAAA,MACN,MAAU;AAAA,MACV,QAAU;AAAA;AAAA,MAEV,SAAU;AAAA,QACN,MAAO;AAAA,QACP,IAAO;AAAA,MACX;AAAA,MACA,SAAU;AAAA,IACd,CAAC;AAAA,EACL;AAAA;AAAA,EAEA,mBAAmB;AACf,SAAK,cAAc;AAAA,EACvB;AAAA;AAAA,EAEA,iBAAiB,YAAY;AACzB,UACI,KAAkC,MAClC,EAAE,QAAQ,QAAQ,YAAY,IAAI,YAClC,UAAkC,GAAG,OAAO,SAAS,OAAO,MAAM;AAEtE,QAAI,CAAC,GAAG,YAAY,OAAO,eAAe,OAAO,YAAY,CAAC,GAAG,eAAe,CAAC,OAAO,gBAAgB,CAAC,QAAQ,WAAW;AACxH,YAAM,cAAc,GAAG,cAAc,QAAQ,MAAM;AACnD,UAAI,2CAAa,KAAK;AAElB,oBAAY,UAAU,IAAI,eAAe;AAEzC,oBAAY,YAAY;AAExB,mBAAW,cAAc,YAAY;AAAA,MACzC;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,eAAe,EAAE,KAAK,OAAO,UAAU,GAAG;AAEtC,QAAI,UAAU,IAAI,MAAM,cAAc,IAAI,QAAQ;AAC9C,WAAK,gBAAgB;AAAA,IACzB;AAAA,EACJ;AAAA;AAAA,EAEA,mBAAmB,EAAE,QAAQ,SAAS,OAAO,GAAG;AAC5C,QAAI,KAAK,UAAU;AACf;AAAA,IACJ;AACA,QAAI,WAAW,YAAY,QAAQ,cAAc,CAAC,OAAO,YAAY;AAEjE,iBAAW,SAAS,KAAK,aAAa,MAAM,GAAG;AAC3C,YAAI,MAAM,WAAW,QAAQ;AACzB,eAAK,YAAY,KAAK;AAAA,QAC1B;AAAA,MACJ;AACA,WAAK,QAAQ;AACb;AAAA,IACJ;AACA,SAAK,cAAc;AAAA,EACvB;AAAA;AAAA,EAEA,cAAc;AACV,KAAC,KAAK,YAAY,KAAK,MAAM;AAAA,EACjC;AAAA;AAAA,EAEA,mBAAmB;AACf,KAAC,KAAK,YAAY,KAAK,MAAM;AAAA,EACjC;AAAA;AAAA,EAEA,qBAAqB;AACjB,KAAC,KAAK,YAAY,KAAK,MAAM;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,uBAAuB;AACnB,QAAI,CAAC,KAAK,aAAa;AACnB,YACI,EAAE,OAAO,IAAI,MACb,UAAa,OAAO,gBAAgB,IAAI,OAAK,OAAO,MAAM,QAAQ,CAAC,CAAC;AACxE,UAAI,UAAa;AACjB,iBAAW,SAAS,KAAK,cAAc;AACnC,YAAI,cAAc;AAElB,iBAAS,IAAI,MAAM,WAAW,KAAK,MAAM,WAAW,aAAa,KAAK;AAClE,wBAAc,QAAQ,SAAS,CAAC;AAAA,QACpC;AACA,YAAI,MAAM,eAAe,aAAa;AAClC,gBAAM,aAAa;AACnB,oBAAU;AAAA,QACd;AAAA,MACJ;AAEA,iBAAW,KAAK,QAAQ;AAAA,IAC5B;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,qBAAqB,SAAS;AA9QlC;AA+QQ,SAAI,aAAQ,gBAAR,mBAAqB,OAAO;AAC5B,aAAO,KAAK,OAAO,MAAM,MAAM,QAAQ,YAAY,MAAM,SAAS;AAAA,IACtE;AACA,WAAO,KAAK,WAAW,qBAAqB,OAAO;AAAA,EACvD;AAAA;AAAA,EAEA,qBAAqB,SAAS;AArRlC;AAsRQ,SAAI,aAAQ,gBAAR,mBAAqB,OAAO;AAC5B,aAAO,QAAQ,YAAY,MAAM;AAAA,IACrC;AACA,WAAO,KAAK,WAAW,qBAAqB,OAAO;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAIA,mBAAmB,EAAE,QAAQ,MAAM,GAAG;AAClC,QAAI,OAAO,cAAc,OAAO;AAC5B,YAAM,aAAa;AAAA,QACf,MAAW;AAAA,QACX,MAAW,aAAa,OAAO,aAAa,mBAAmB,kBAAkB;AAAA,QACjF,SAAW;AAAA,QACX,KAAW;AAAA,QACX,QAAW;AAAA,QACX,UAAW,KAAK;AAAA,QAChB,QAAW,MAAM,OAAO,aAAa,CAAC,OAAO;AAAA,MACjD;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,YAAY,OAAO;AA9S7B;AA+SQ,QAAI,CAAC,KAAK,aAAa;AACnB,YAAM,qBAAqB,MAAM,OAAO,QAAQ,sBAAsB;AACtE,UAAI,oBAAoB;AACpB,cACI,EAAE,OAAO,IAAM,MACf,EAAE,MAAM,IAAO,mBAAmB,aAClC,EAAE,SAAS,IAAI,OAAO,UACtB,EAAE,OAAO,IAAM,OACf,OAAe,aAAa,YAAW,eAAU,MAAM,IAAI,MAApB,YAAyB,MAAM,IAAI,GAC1E,YAAe;AAAA,UACX,MAAc;AAAA,UACd,SAAc,CAAC;AAAA,UACf;AAAA,UACA,aAAc,mBAAmB;AAAA,UACjC,QAAc,MAAM;AAAA,UACpB;AAAA,QACJ;AACJ,iBAAS,IAAI,MAAM,WAAW,KAAK,MAAM,SAAS,KAAK;AACnD,oBAAU,QAAQ,KAAK,OAAO,MAAM,MAAM,CAAC,CAAC;AAAA,QAChD;AACA,eAAO,QAAQ,aAAa,IAAI,IAAI,SAAS;AAE7C,aAAI,qCAAU,aAAa,mBAAkB,OAAO,IAAI,GAAG,YAAY,GAAG;AACtE,gBAAM,MAAM,OAAO,WAAW,SAAS,MAAM,OAAO;AACpD,gBAAM,SAAS,aAAa,EAAE,IAAK,IAAI,IAAI,UAAW,OAAO,GAAG,CAAC;AAAA,QACrE,WAES,MAAM,SAAS,SAAS;AAC7B,eAAK,aAAa,EAAE,MAAM,CAAC;AAAA,QAC/B;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,aAAa,EAAE,MAAM,GAAG;AACpB,UAAM,UAAU,CAAC;AACjB,aAAS,IAAI,MAAM,WAAW,KAAK,MAAM,SAAS,KAAK;AACnD,cAAQ,KAAK,KAAK,OAAO,MAAM,MAAM,CAAC,CAAC;AAAA,IAC3C;AACA,SAAK,OAAO,kBAAkB;AAAA,EAClC;AAAA;AAAA,EAEA,gBAAgB;AACZ,KAAC,KAAK,YAAY,KAAK,MAAM;AAAA,EACjC;AAAA;AAAA,EAEA,eAAe,EAAE,OAAO,GAAG;AAEvB,QAAI,WAAW,YAAY,WAAW,WAAW;AAC7C,OAAC,KAAK,YAAY,KAAK,MAAM,KAAK;AAAA,IACtC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,mBAAmB,OAAO;AAzW9B;AA0WQ,UACI,SAAS,KAAK,OAAO,qBAAqB,MAAM,MAAM,EAAE,qBACxD,SAAS,GAAG,MAAM,SAAS,MAAM,MAAM,OAAO,EAAE;AAGpD,QAAI,WAAU,kBAAO,cAAP,mBAAmB,YAAnB,aAA8B,YAAO,kBAAP,mBAAuB;AAEnE,QAAI,OAAO,eAAe;AACtB,aAAO,OAAO,cAAc,MAAM;AAAA,IACtC;AACA,QAAI,CAAC,SAAS;AACV,gBAAU,UAAU,cAAc,KAAK,qBAAqB,KAAK,CAAC;AAAA,IACtE;AAEA,YAAQ,SAAS,QAAQ,SAAS,MAAM;AACxC,UAAM,UAAU;AAChB,UAAM,cAAc,QAAQ;AAC5B,WAAO;AAAA,EACX;AAAA;AAAA,EAEA,qBAAqB,OAAO;AA9XhC;AA+XQ,UACI,EAAE,QAAQ,WAAW,SAAS,KAAK,MAAM,OAAO,OAAO,OAAO,IAAI,OAClE,EAAE,KAAK,IAAI,QACX,SAAS,KAAK,OAAO,MAAM,MAAM,SAAS,GAC1C,YAAY;AAAA,MACR,WAAY;AAAA,QACR,uBAAwB;AAAA;AAAA,QAExB,cAAwB,MAAM;AAAA,MAClC;AAAA,MACA,aAAc;AAAA,QACV;AAAA,MACJ;AAAA,MACA,OAAQ;AAAA,QACJ;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,MACJ;AAAA,MACA,SAAU;AAAA,QACN,QAAW,GAAG,SAAS,MAAM,OAAO,EAAE;AAAA,QACtC;AAAA,QACA;AAAA,QACA,QAAW,OAAO;AAAA,QAClB,UAAW,OAAO;AAAA,MACtB;AAAA,MACA,UAAW;AAAA;AAAA,QAEP;AAAA,UACI,WAAY,IAAI,aAAa,KAAK,OAAO,OAAO,EAAE,OAAO;AAAA,YACrD,CAAC,KAAK,6BAAM,aAAa,OAAO,GAAI;AAAA,YACpC,CAAC,OAAO,OAAO,GAAqB,OAAO;AAAA,YAC3C,CAAC,OAAO,eAAe,GAAa,OAAO;AAAA,UAC/C,CAAC,EAAE,OAAO,OAAO,OAAO;AAAA;AAAA,UAExB,cAAe;AAAA;AAAA,UAEf,aAAe;AAAA,YACX;AAAA,UACJ;AAAA;AAAA,UAEA,SAAU;AAAA,YACN,QAAW,OAAO;AAAA,YAClB,UAAW,OAAO;AAAA,UACtB;AAAA;AAAA,UAEA,OAAQ;AAAA,YACJ,QAAS,KAAK,OAAO,WAAW;AAAA,UACpC;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AAEJ,iBAAO,mBAAP,gCAAwB,EAAE,WAAW,OAAQ,OAAO,YAAY,MAAM,GAAG,QAAQ,QAAQ,WAAW,QAAQ;AAC5G,WAAO;AAAA,EACX;AAAA,EACA,uBAAuB,WAAW,SAAS,MAAM;AAxbrD;AAybQ,UACI,KAAiB,MACjB,EAAE,OAAO,IAAQ,IACjB,EAAE,WAAW,IAAI;AAKrB,gBAAY,iCAAa,gBAAW,WAAX,mBAAmB;AAC5C,cAAU,6BAAW,gBAAW,cAAX,mBAAsB;AAC3C,UAEI,eAAe,OAAO,QAAQ,OAAO,CAAC,KAAK,WAAW;AAClD,UAAI,MAAM,IAAI;AAAA,QACV,WAAY;AAAA,UACR,iCAAkC;AAAA,QACtC;AAAA,QACA,UAAW,CAAC;AAAA,MAChB;AACA,aAAO;AAAA,IACX,GAAG,CAAC,CAAC;AAET,eAAW,SAAS,GAAG,cAAc;AACjC,UAAI,MAAM,OAAO,MAAM,aAAa,WAAW,MAAM,WAAW,WAAW;AAEvE,WAAG,YAAY,OAAO,GAAG,eAAe,IAAI;AAE5C,qBAAa,MAAM,OAAO,MAAM,EAAE,SAAS,KAAK,GAAG,qBAAqB,KAAK,CAAC;AAAA,MAClF;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,QAAQ,QAAQ,OAAO;AACnB,UACI,KAAiB,MACjB,EAAE,OAAO,IAAQ,IACjB,EAAE,WAAW,IAAI;AAErB,QAAI,CAAC,SAAS,CAAC,WAAW,UAAU,GAAG,YAAY,CAAC,GAAG,aAAa;AAChE;AAAA,IACJ;AACA,UAAM,eAAe,KAAK,uBAAuB;AAEjD,WAAO,YAAY,aAAW;AAC1B,cAAQ,KAAK;AAAA,QACT,eAAgB,QAAQ;AAAA,QACxB,aAAgB;AAAA,QAChB,WAAgB,aAAa,QAAQ,MAAM;AAAA,MAC/C,CAAC;AAAA,IACL,CAAC;AACD,OAAG,gBAAgB;AAAA,EACvB;AAAA;AAAA,EAEA,eAAe;AACX,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,OAAO;AACf,gBAAY,OAAO,KAAK,cAAc,KAAK;AAC3C,aAAS,QAAQ,MAAM,WAAW,SAAS,MAAM,SAAS,SAAS;AAC/D,aAAO,KAAK,UAAU,GAAG,KAAK,MAAM,MAAM,OAAO,EAAE,EAAE;AAAA,IACzD;AAAA,EACJ;AAAA;AAAA,EAEA,MAAM,SAAS,MAAM,QAAQ,OAAO;AAChC,UACI,KAAY,MACZ,UAAY,GAAG,OAAO,QAAQ,eAAe,OAAO,OAAK,EAAE,eAAe,EAAE,YAAY,CAAC,GAAG,cAAc,QAAQ,IAAI,GACtH,YAAY,GAAG,aAAa;AAChC,OAAG,eAAe,CAAC;AACnB,OAAG,YAAY,CAAC;AAChB,QAAI,UAAU,CAAC,GAAG,OAAO,kBAAkB;AACvC,iBAAW,OAAO,GAAG,OAAO,WAAW,MAAM;AACzC,mBAAW,UAAU,SAAS;AAC1B,cAAI,WAAW,IAAI,QAAQ,OAAO,EAAE,CAAC;AAAA,QACzC;AAAA,MACJ;AAEA,SAAG,QAAQ,aAAa,CAAC,GAAG,OAAO,WAAW,QAAQ;AAAA,IAC1D;AAAA,EACJ;AAAA;AAAA,EAEA,gBAAgB;AA9gBpB;AA+gBQ,UACI,EAAE,aAAa,IAAI,MACnB,MAAmB,KAAK,OAAO,WAAW,QAC1C,YAAmB,oBAAI,IAAI,GAC3B,QAAmB,KAAK,OAAO;AACnC,eAAW,SAAS,aAAa,MAAM,GAAG;AACtC,YACI,EAAE,OAAO,IAAK,OACd,cAAc,IAAI,QAAQ,OAAO,EAAE;AAEvC,UAAI,aAAa;AACb,YAAI,EAAE,UAAU,OAAO,KAAI,eAAU,IAAI,MAAM,MAApB,YAAyB,CAAC;AACrD,YAAI,CAAC,QAAQ;AAET,qBAAW,YAAY,cAAc;AACrC,mBAAS,UAAU,KAAK,aAAa,YAAY,aAAa;AAC9D,oBAAU,IAAI,QAAQ,EAAE,UAAU,OAAO,CAAC;AAAA,QAC9C;AACA,YAAI,OAAO;AACP,gBAAM,QAAQ,WAAW,OAAO;AAAA,QACpC,OACK;AACD,gBAAM,OAAO,OAAO;AAAA,QACxB;AACA,cAAM,QAAQ,OAAO;AAAA,MACzB,OAEK;AACD,aAAK,YAAY,KAAK;AAAA,MAC1B;AAAA,IACJ;AACA,SAAK,QAAQ;AAAA,EACjB;AAAA;AAAA;AAAA,EAGA,YAAY,OAAO,OAAO,OAAO,MAAM;AACnC,UACI,EAAE,OAAO,WAAW,IAAc,KAAK,QACvC,EAAE,aAAa,eAAe,IAAI,OAClC,EAAE,gBAAgB,IAAgB;AACtC,QAAI,EAAE,WAAW,QAAQ,IAAI,OACzB,QAAQ;AACZ,YAAQ,OAAO,KAAK,SAAS,IAAI;AAEjC,QAAI,CAAC,SAAS,eAAe,gBAAgB;AACzC;AAAA,IACJ;AACA,QAAI,CAAC,eAAe,OAAO;AACvB,UAAI,MAAM;AACN,cAAM,QAAQ,KAAK,UAAU,SAAO,IAAI,aAAa,SAAS;AAC9D,iBAAS,KAAK,KAAK;AACnB,oBAAY,OAAO;AAAA,MACvB,OACK;AACD,WAAG;AACC,mBAAS,WAAW,WAAW,MAAM,MAAM,SAAS,CAAC;AAAA,QACzD,SACO,CAAC,UAAU,cAAc;AAAA,MACpC;AAEA,YAAM,cAAe,cAAc,MAAM;AACzC,YAAM,YAAY,YAAY,MAAM;AACpC,YAAM,MAAM,OAAO,MAAM,aAAa,OAAO,OAAO,eAAe;AAAA,IACvE;AACA,QAAI,CAAC,kBAAkB,OAAO;AAC1B,UAAI,MAAM;AAEN,cAAM,QAAQ,KAAK,UAAU,SAAO,IAAI,cAAc,OAAO;AAC7D,oBAAY,KAAK,UAAU,KAAK,KAAK,SAAS,IAAI,KAAK;AACvD,oBAAY,UAAU;AAAA,MAC1B,OACK;AACD,WAAG;AACC,sBAAY,WAAW,WAAW,MAAM,MAAM,OAAO,CAAC;AAAA,QAC1D,SACO,CAAC,aAAa,YAAY;AAAA,MACrC;AAEA,YAAM,iBAAkB,YAAY,MAAM;AAC1C,YAAM,YAAY,MAAM,UAAU;AAClC,YAAM,SAAS,UAAU,SAAS,aAAa,OAAO,UAAU,eAAe;AAAA,IACnF;AACA,UAAM,SAAS,MAAM,SAAS,MAAM;AAAA,EACxC;AAAA;AAAA;AAAA,EAGA,cAAc,QAAQ,QAAQ;AAC1B,QAAI,OAAO,cAAc;AACrB;AAAA,IACJ;AACA,UACI,KAAgB,MAChB,EAAE,UAAU,IAAI,IAChB,EAAE,MAAM,IAAQ,GAAG,QACnB,MAAgB,GAAG,OAAO,WAAW,QACrC,WAAgB,OAAO,IACvB,QAAgB,MAAM,QAAQ,MAAM,GACpC,MAAgB,GAAG,KAAK,MAAM,QAAQ,IACtC,QAAgB,KAAK,OAAO;AAChC,QAAI,QAAQ,UAAU,GAAG;AACzB,QAAI,CAAC,OAAO;AACR,YAAM,QAAQ,OAAO,YAAY,MAAM;AACvC,cAAQ,UAAU,GAAG,IAAI;AAAA,QACrB;AAAA,MACJ;AACA,SAAG,aAAa,KAAK,KAAK;AAE1B,UAAI,eAAe,cAAc,eAAe;AAChD,SAAG;AACC,wBAAgB,MAAM,MAAM,EAAE,YAAY;AAC1C,uBAAgB,iBAAiB,OAAO,YAAY,aAAa;AACjE,YAAI,iBAAiB,OAAO;AACxB,oBAAU,GAAG,YAAY,MAAM,QAAQ,EAAE,IAAI;AAAA,QACjD;AAAA,MACJ,SAAS,iBAAiB,CAAC,cAAc,gBAAgB,iBAAiB;AAE1E,UAAI,aAAa,YAAY,aAAa;AAC1C,SAAG;AACC,sBAAc,MAAM,MAAM,EAAE,UAAU;AACtC,qBAAc,eAAe,OAAO,YAAY,WAAW;AAC3D,YAAI,eAAe,OAAO;AACtB,oBAAU,GAAG,UAAU,MAAM,QAAQ,EAAE,IAAI;AAAA,QAC/C;AAAA,MACJ,SAAS,eAAe,CAAC,YAAY,gBAAgB,eAAe;AACpE,YAAM,YAAY,eAAe;AACjC,YAAM,UAAY,aAAa;AAE/B,UAAI,MAAM,UAAU,MAAM,YAAY,GAAG;AACrC,cACI,cAAc,IAAI,QAAQ,QAAQ,GAClC,WAAc,YAAY,cAAc,aACxC,aAAc,UAAU,KAAK,aAAa,YAAY,aAAa;AACvE,YAAI,OAAO;AACP,gBAAM,QAAQ,WAAW,WAAW;AAAA,QACxC,OACK;AACD,gBAAM,OAAO,WAAW;AAAA,QAC5B;AACA,cAAM,QAAQ,WAAW;AACzB,cAAM,MAAM;AAAA,MAChB;AAAA,IACJ;AACA,QAAI,CAAC,MAAM,WAAW,MAAM,KAAK;AAC7B,SAAG,mBAAmB,KAAK;AAAA,IAC/B;AACA,WAAO;AAAA,EACX;AAAA;AAEJ;AAAA;AA1mBI,cAFiB,YAEV,SAAQ;AACf,cAHiB,YAGV,gBAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAmBlB,aAAc;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYd,YAAa;AACjB;AA0kBJ,WAAW,SAAS;AAAc,mBAAmB,gBAAgB,UAAU;;;AChqB/E,IAAMC,WAAU;AAAA,EACZ,aAAmB;AAAA,EACnB,aAAmB;AAAA,EACnB,kBAAmB;AAAA,EACnB,aAAmB;AACvB;AAgDA,IAAqB,YAArB,cAAuC,eAAe;AAAA;AAAA,EAsBlD,WAAW,eAAe;AACtB,WAAO;AAAA,MACH,OAAQ,CAAC,qBAAqB,gBAAgB;AAAA,IAClD;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,WAAW,aAAa;AACpB,WAAO;AAAA,MACH,QAAkB;AAAA,MAClB,YAAkB;AAAA,MAClB,iBAAkB;AAAA,MAClB,YAAkB;AAAA,IACtB;AAAA,EACJ;AAAA,EACA,UAAU,MAAM,QAAQ;AACpB,UAAM,UAAU,MAAM,MAAM;AAC5B,WAAO,OAAO,MAAM;AAAA,MAChB;AAAA,MACA,YAAa,KAAK,gBAAgB,KAAK,SAAS,UAAU,WAAW,WAAW,MAAM,UAAU,WAAW,aAAa;AAAA,IAC5H,CAAC;AAAA,EACL;AAAA,EACA,kBAAkB,EAAE,WAAW,GAAG;AAC9B,QAAIA,SAAQ,UAAU,GAAG;AACrB,YAAM,EAAE,YAAY,IAAI,KAAK;AAC7B,aAAO,CAAC,KAAK,aAAY,2CAAa,WAAU,CAAC,YAAY,gBAAgB,KAAK,KAAK,SAAS;AAAA,IACpG;AAAA,EACJ;AAAA,EACA,UAAU,SAAS;AACf,QAAI,SAAS;AACT,WAAK,MAAM;AAAA,IACf;AACA,UAAM,UAAU,OAAO;AAAA,EAC3B;AAAA,EACA,IAAI,QAAQ;AACR,WAAO,KAAK,KAAK;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,gBAAgB;AACZ,UACI,KAAW,MACX,EAAE,KAAK,IAAI,IACX,SAAW,KAAK,iBAAiB,GAAG,QAAQ;AAChD,QAAI,QAAQ;AACR,UAAI,CAAC,GAAG,aAAa;AACjB,cAAM,CAAC,SAAS,OAAO,KAAK,IAAI,UAAU,cAAc;AAAA,UACpD,KAAY;AAAA,UACZ,WAAY;AAAA,UACZ,UAAY;AAAA,YACR,EAAE,KAAM,OAAO,WAAY,oBAAoB;AAAA,YAC/C,EAAE,KAAM,OAAO,WAAY,oBAAoB;AAAA,UACnD;AAAA,QACJ,GAAG,EAAE,WAAY,KAAK,CAAC;AACvB,YAAI,GAAG,SAAS,UAAU;AACtB,iBAAO,YAAY,OAAO;AAAA,QAC9B,OACK;AACD,kBAAQ,aAAa;AACrB,eAAK,QAAQ,YAAY,OAAO;AAAA,QACpC;AACA,WAAG,cAAc;AAAA,UACb,QAAY;AAAA,UACZ;AAAA,UACA;AAAA,UACA,WAAY;AAAA,QAChB;AAAA,MACJ;AACA,SAAG,YAAY,MAAM,YAAY,GAAG;AACpC,SAAG,YAAY,MAAM,YAAY,GAAG,MAAM;AAC1C,aAAO,UAAU,IAAI,qBAAqB;AAAA,IAC9C;AACA,SAAK,UAAU,KAAK,gBAAgB,CAAC,GAAG,2BAA2B;AAC/D,WAAK,WAAW,IAAI;AAAA,QAChB,YAAa,GAAG;AAAA,QAChB,SAAa;AAAA,MACjB,CAAC;AACD,SAAG,4BAA4B;AAAA,IACnC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB;AACZ,UACI,KAAwB,MACxB,EAAE,MAAM,YAAY,IAAI;AAE5B,eAAW,OAAQ,GAAG,aAAa,GAAG,OAAQ;AAC1C,YAAM,MAAM,KAAK,WAAW,IAAI,EAAE;AAClC,UAAI,KAAK;AAEL,YAAI,iBAAiB;AACrB,cAAM,cAAc,IAAI,QAAQ,GAAG,QAAQ;AAC3C,oBAAY,WAAW;AACvB,YAAI,WAAW,WAAW;AAC1B,YAAI,iBAAiB;AAAA,MACzB;AAAA,IACJ;AACA,QAAI,aAAa;AACb,kBAAY,OAAO,WAAW,YAAY,YAAY,MAAM;AAC5D,kBAAY,UAAU,UAAU,OAAO,qBAAqB;AAC5D,SAAG,cAAc;AAAA,IACrB;AACA,QAAI,GAAG,2BAA2B;AAC9B,WAAK,WAAW,GAAG,EAAE,YAAa,GAAG,WAAW,GAAG,EAAE;AACrD,SAAG,4BAA4B;AAAA,IACnC;AACA,SAAK,QAAQ,eAAe;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,OAAO,MAAM,kBAAkB,KAAK,UAAU,YAAY,OAAO;AA1MrE;AA2MQ,UACI,KAAW,MACX,EAAE,KAAK,IAAI,IACX,SAAW,KAAK,QAAQ,QAAQ,eAAe,KAAK,KAAK,QAAQ,IAAI,eAAe,GACpF,QAAW,GAAG,MAAM,YAAY,OAAO,OAAO,MAAM,OAAO,cAAc,OAAO,QAAQ;AAC5F,QAAI,IAAI;AACR,WAAO,OAAO,IAAI;AAAA,MACd,UAAY,CAAC;AAAA,MACb,WAAY,GAAG;AAAA,MACf;AAAA,MACA;AAAA,MACA,UAAY,OAAO;AAAA,MACnB,QAAY,IAAI,OAAO,WAAW,aAAa,aAAa,OAAO,IAAI,CAAC,CAAC,YAAY,IAAI;AAAA,IAC7F,CAAC;AACD,QAAI,MAAM;AACN,SAAG,cAAc;AAAA,IACrB,OACK;AACD,SAAG,cAAc;AAAA,IACrB;AAEA,eAAW,eAAe,UAAU,SAAS,KAAK,SAAS,IAAI,GAAG,MAAM,EAAE,GAAG;AACzE,kBAAY,UAAU,OAAO,GAAG,QAAQ,GAAG,UAAU;AACrD,UAAI,YAAY,kBAAkB;AAC9B,oBAAY,YAAY,YAAY;AACpC,oBAAY,mBAAmB;AAAA,MACnC;AAAA,IACJ;AACA,QAAI,CAAC,OAAO;AACR;AAAA,IACJ;AACA,QAAI,MAAM,SAAS,KAAK,CAAC,WAAW;AAChC,SAAG,eAAe,KAAK,aAAa,KAAK;AAAA,IAC7C;AAEA,eAAW,OAAO,OAAO;AACrB,SAAG,SAAS,IAAI,EAAE,IAAI;AACtB,YAAM,MAAM,KAAK,WAAW,IAAI,KAAK,EAAE;AACvC,iCAAK,WAAW,IAAI,QAAQ,OAAO,EAAE;AAErC,UAAI,IAAI,KAAM;AACV;AAAA,MACJ;AAAA,IACJ;AAEA,eAAK,eAAL,8BAAkB,WAAS,MAAM,SAAS,UAAU,OAAO,MAAM,iBAAiB,IAAI;AACtF,SAAK,QAAQ,aAAa,EAAE,MAAM,MAAM,CAAC;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAIA,QAAQ;AA9PZ;AA+PQ,QAAI,KAAK,UAAQ,UAAK,UAAL,mBAAY,SAAQ;AACjC,WAAK,OAAO,EAAE;AAAA,IAClB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,aAAa;AAxQrB;AAyQQ,YAAO,gBAAK,UAAL,mBAAY,WAAZ,YAAsB;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAYA,QAAQ,OAAO;AACX,UAAM,UAAU,KAAK,MAAM,KAAK;AAChC,QAAI,SAAS;AACT,WAAK,KAAK,UAAU;AAAA,QAChB,UAAW,KAAK;AAAA,QAChB,IAAW,QAAQ;AAAA,MACvB,GAAG,EAAE,UAAW,KAAK,CAAC;AAAA,IAC1B;AACA,WAAO,CAAC,CAAC;AAAA,EACb;AAAA,EACA,eAAe,aAAa,OAAO;AAC/B,UACI,eAAe,cAAc,KAAK,KAAK,MAAM,QAAQ,YAAY,EAAE,IAAI,GACvE,cAAe,MAAM,MAAM,EAAE;AAAA,MACzB,CAAC,GAAG,MAAM,KAAK,IAAI,EAAE,QAAQ,YAAY,IAAI,KAAK,IAAI,EAAE,QAAQ,YAAY;AAAA,IAChF;AACJ,SAAK,QAAQ,MAAM,QAAQ,YAAY,CAAC,CAAC,CAAC;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAIA,eAAe;AACX,SAAK,QAAQ,CAAC;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc;AACV,SAAK,QAAQ,KAAK,MAAM,SAAS,CAAC;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc;AAvTlB;AAwTQ,UACI,KAAe,MACf,EAAE,KAAK,IAAQ,IAEf,aAAe,gBAAK,iBAAL,mBAAmB,OAAnB,aAAyB,UAAK,oBAAL,mBAAsB,IAC9D,eAAe,KAAK,MAAM,QAAQ,SAAS,KAAK,GAChD,UAAe,GAAG,MAAM,KAAK,SAAO,IAAI,QAAQ,YAAY;AAChE,QAAI,SAAS;AACT,WAAK,UAAU;AAAA,QACX,UAAW,GAAG;AAAA,QACd,IAAW,QAAQ;AAAA,MACvB,GAAG,EAAE,UAAW,KAAK,CAAC;AAAA,IAC1B,OACK;AACD,SAAG,aAAa;AAAA,IACpB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc;AA5UlB;AA6UQ,UACI,KAAkB,MAClB,EAAE,MAAM,MAAM,IAAI,IAClB,aAAkB,gBAAK,iBAAL,mBAAmB,OAAnB,aAAyB,UAAK,oBAAL,mBAAsB,IACjE,eAAkB,KAAK,MAAM,QAAQ,SAAS,KAAK;AACvD,QAAI;AACJ,QAAI,CAAC,MAAM,QAAQ;AACf;AAAA,IACJ;AACA,aAAS,IAAI,MAAM,SAAS,GAAG,KAAK,KAAK,GAAG;AACxC,UAAI,MAAM,CAAC,EAAE,QAAQ,cAAc;AAC/B,kBAAU,MAAM,CAAC;AACjB;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,SAAS;AACT,WAAK,UAAU;AAAA,QACX,UAAW,GAAG;AAAA,QACd,IAAW,QAAQ;AAAA,MACvB,GAAG,EAAE,UAAW,KAAK,CAAC;AAAA,IAC1B,OACK;AACD,SAAG,YAAY;AAAA,IACnB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW,EAAE,aAAa,QAAQ,OAAO,GAAG;AA5WhD;AA6WQ,UACI,KAAe,MACf,EAAE,UAAU,IAAI,aAChB;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,IACJ,IAAc,IACd,WAAc,GAAG,aAAa,OAAO,QAAM,QAAG,aAAH,mBAAc,OAAO;AACpE,QAAI,UAAU;AAEV,gBAAU,IAAI,GAAG,MAAM;AACvB,kBAAY,aAAa;AACzB,kBAAY,mBAAmB,YAAY;AAG3C,YAAM,QAAQ,WAAW,cAAc,UAAU,KAAK,aAAa,uCAAuC,KAAK;AAC/G,eAAS,WAAW,WAAW,SAAS,GAAG,YAAY,MAAM,SAAS,QAAQ,KAAI;AAC9E,cACI,gBAAgB,UAChB,cAAgB,SAAS,WACzB,UAAgB,CAAC,QAAQ;AAE7B,mBAAW,WAAW,SAAS;AAC/B,YAAI,SAAS,OAAO;AAGpB,iBAAS,QAAQ,OAAO,KAAK,WAAW,GAAG,OAAO,QAAQ,OAAO,KAAK,WAAW,GAAG;AAChF,gBACI,WAAc,YAAY,UAAU,QAAQ,MAAM,KAAK,GACvD,cAAc,MAAM,CAAC,IAAI,SAAS,IAClC,IAAc,MAAM,CAAC,GACrB,aAAc,MAAM,CAAC,IAAI,SAAS;AACtC,kBAAQ,KAAK,GAAG,aAAa,WAAW,QAAQ,CAAC,GAAG,WAAW,gBAAgB,UAAU,KAAK,CAAC,UAAU,UAAU,EAAE;AACrH,mBAAS,OAAO;AAAA,QACpB;AACA,gBAAQ,KAAK,aAAa,WAAW,YAAY,UAAU,MAAM,CAAC,GAAG,SAAS;AAE9E,sBAAc,WAAW,aAAa,UAAU,0BAA0B,QAAQ,KAAK,EAAE,GAAG;AAAA,UACxF,UAAW;AAAA,QACf,CAAC,GAAG,aAAa;AACjB,sBAAc,OAAO;AAAA,MACzB;AACA,gBAAU,cAAc;AAAA,QACpB,QAAY;AAAA,QACZ,WAAY,GAAG;AAAA,QACf,MAAY;AAAA,MAChB,CAAC;AAAA,IACL;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,YAAY,OAAO;AACf,UAAM,KAAK;AACX,QAAI,GAAG,MAAM;AACT,SAAG,OAAO,GAAG,KAAK,OAAO,GAAG,GAAG,KAAK,SAAS,CAAC;AAC9C,SAAG,OAAO,GAAG,IAAI;AACjB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA,EACA,cAAc;AACV,QAAI,KAAK,MAAM;AACX,WAAK,OAAO;AACZ,WAAK,OAAO,KAAK,IAAI;AACrB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA,EACA,mBAAmB;AACf,UACI,KAAK,MACL,EAAE,OAAO,IAAI,GAAG,OAAO;AAC3B,QAAI,UAAU,GAAG,YAAY,GAAG,YAAY;AACxC,SAAG,MAAM;AACT,aAAO,iBAAiB,GAAG,OAAO,QAAQ,QAAQ,GAAG,QAAQ,GAAG,GAAG,IAAI;AAAA,IAC3E;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB,OAAO;AAhc7B;AAicQ,UACI,KAAkB,MAClB,EAAE,KAAK,IAAW,IAClB,EAAE,YAAY,IAAI;AAEtB,QAAI,CAAC,MAAM,WAAW,CAAC,GAAG,aAAY,2CAAa,WAAU,CAAC,YAAY,kBAAgB,WAAM,QAAN,mBAAW,YAAW,GAAG;AAC/G,YAAM,SAAS,KAAK,QAAQ,QAAQ,KAAK,aAAa,QAAQ;AAE9D,UAAI,UAAU,OAAO,eAAe,OAAO;AACvC,WAAG,WAAW,KAAK,aAAa;AAChC,WAAG,QAAQ,MAAM;AACjB,WAAG,OAAO,GAAG,IAAI;AAAA,MACrB;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,eAAe,MAAM,kBAAkB,gBAAgB;AACnD,UACI,KAAQ;AACZ,QAAI,GAAG,SAAS,CAAC,kBAAkB,eAAe,aAAa,GAAG,WAAW;AACzE,SAAG,MAAM;AAAA,IACb;AAAA,EACJ;AAAA;AAEJ;AAAA;AA7ZI,cAFiB,WAEV,SAAQ;AACf,cAHiB,WAGV,gBAAe;AAAA,EAClB,MAAO;AAAA,EACP,MAAO;AAAA;AAAA;AAAA;AAAA;AAAA,EAKP,QAAS;AAAA,IACL,IAAiB;AAAA,IACjB,YAAiB;AAAA,IACjB,UAAiB;AAAA,IACjB,gBAAiB;AAAA,IACjB,gBAAiB;AAAA,IACjB,QAAiB;AAAA;AAAA,IAEjB,WAAY;AAAA,EAChB;AACJ;AA4YJ,UAAU,SAAS;AAAa,mBAAmB,gBAAgB,SAAS;;;AC/c5E,IAAMC,WAAU;AAAA,EACZ,OAAa;AAAA,EACb,YAAa;AACjB;AAIA,IAAM,qBAAqB,EAAE,QAAS,GAAG,QAAS,GAAG,SAAU,GAAG,SAAU,EAAE;AA+J9E,IAAqB,cAArB,cAAyC,eAAe,MAAM,iBAAS,EAAE;AAAA;AAAA,EAIrE,WAAW,aAAa;AACpB,WAAO;AAAA;AAAA,MAEH,mBAA2B;AAAA,MAC3B,kBAA2B;AAAA,MAC3B,0BAA2B;AAAA;AAAA;AAAA,MAG3B,gBAA2B,oBAAI,IAAI;AAAA,MACnC,oBAA2B,oBAAI,IAAI;AAAA,IACvC;AAAA,EACJ;AAAA;AAAA,EAsQA,WAAW,eAAe;AACtB,WAAO;AAAA,MACH,OAAW,CAAC,sBAAsB,mBAAmB,oBAAoB,aAAa,YAAY;AAAA,MAClG,UAAW,CAAC,qBAAqB,gBAAgB,cAAc,iBAAiB;AAAA,IACpF;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,iBAAiB;AACb,UACI,KAAa,MACb,EAAE,OAAO,IAAI;AACjB,QAAI,CAAC,GAAG,YAAY,CAAC,GAAG,QAAQ;AAC5B,SAAG,WAAW;AACd,cAAQ,KAAK,oFAAoF;AACjG;AAAA,IACJ;AACA,QAAI,OAAO,eAAe,OAAO,mBAAmB,OAAO;AACvD,cAAQ,KAAK,4FAA4F;AAAA,IAC7G;AACA,QAAI,GAAG,QAAQ;AACX,2BAAa,IAAI;AAAA,QACb,OAAU,GAAG;AAAA,QACb,SAAU;AAAA,MACd,CAAC;AAAA,IACL;AAEA,OAAG,UAAU,OAAO,KAAK;AACzB,QAAI,GAAG,cAAc;AACjB,aAAO,IAAI,EAAE,CAAC,GAAG,YAAY,GAAI,kBAAkB,SAAU,GAAG,CAAC;AAAA,IACrE;AACA,OAAG,UAAU;AAAA,EACjB;AAAA,EACA,UAAU,OAAO;AACb,UAAM,KAAK;AACX,OAAG,eAAe,MAAM;AACxB,OAAG,mBAAmB,MAAM;AAC5B,OAAG,gBAAgB,mBAAmB;AACtC,UAAM,IAAI;AAAA,MACN,MAAU;AAAA,MACV,QAAU,GAAG;AAAA,MACb,SAAU;AAAA,IACd,CAAC;AAAA,EACL;AAAA,EACA,UAAU,SAAS;AACf,UAAM,EAAE,OAAO,IAAI;AACnB,QAAI,SAAS;AACT,WAAK,eAAe,MAAM;AAC1B,WAAK,mBAAmB,MAAM;AAAA,IAClC;AACA,QAAI,CAAC,OAAO,eAAe;AACvB,aAAO,WAAW,cAAc;AAAA,IACpC;AACA,UAAM,UAAU,OAAO;AAAA,EAC3B;AAAA,EACA,2BAA2B,MAAM;AAC7B,WAAO,OAAO,KAAK,EAAE,IAAI,IAAI;AAAA,EACjC;AAAA;AAAA,EAEA,kBAAkB,OAAO;AAhgB7B;AAigBQ,UAAM,KAAK;AACX,QAAI,GAAG,YAAY,CAAC,MAAM,OAAO,QAAQ,IAAI,GAAG,iBAAiB,MAAM,GAAG,wBAAwB,EAAE,IAC9F,GAAC,cAAG,OAAO,uBAAV,mBAA8B,WAA9B,mBAAsC,QAAQ,MAAM,GAAG,qBAC5D;AACE,SAAG,WAAW,kBAAkB,KAAK;AAAA,IACzC;AAAA,EACJ;AAAA;AAAA,EAEA,gBAAgB,EAAE,OAAO,GAAG;AAzgBhC;AA0gBQ,QAAI,CAAC,KAAK,aAAa,GAAC,YAAO,cAAP,mBAAkB,SAAS,KAAK,4BAA2B;AAC/E,WAAK,WAAW,gBAAgB,GAAG,SAAS;AAAA,IAChD;AAAA,EACJ;AAAA,EACA,IAAI,cAAc;AACd,WAAO,KAAK,OAAO;AAAA,EACvB;AAAA,EACA,IAAI,YAAY,OAAO;AACnB,UACI,EAAE,OAAO,IAAQ,MACjB,eAAiB,OAAO;AAC5B,WAAO,cAAc;AACrB,QAAI,OAAO,gBAAgB,cAAc;AACrC,aAAO,QAAQ,UAAU,OAAO,yBAAyB;AAAA,IAC7D;AAAA,EACJ;AAAA,EACA,aAAa,QAAQ;AACjB,QAAI,UAAU,KAAK,eAAe,MAAM,GAAG;AACvC,aAAO,EAAE,CAAC,KAAK,OAAO,QAAQ,CAAC,CAAC,GAAI,OAAO;AAAA,IAC/C;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAuDA,qBAAqB;AACjB,SAAK,UAAU;AAAA,EACnB;AAAA,EACA,aAAa,QAAQ;AACjB,QAAI,UAAU,MAAM;AAChB,aAAO;AAAA,IACX;AACA,WAAO;AAAA,MACH,MAAU;AAAA,MACV,SAAU,CAAC;AAAA,QACP,KAAU;AAAA,QACV,SAAU,CAAC,EAAE,OAAO,MAAM,KAAK,EAAE,KAAK,eAAe,IAAI,MAAM,IAAI,4BAA4B,uBAAuB;AAAA,QACtH,SAAU,CAAC,EAAE,OAAO,MAAM,KAAK,aAAa,MAAM;AAAA,MACtD,CAAC;AAAA,MACD,OAAW;AAAA,MACX,UAAW;AAAA,MACX,OAAW;AAAA,MACX,QAAW,KAAK,OAAO,QAAQ,CAAC;AAAA,MAChC,GAAG;AAAA,MACH,OAAW;AAAA,IACf;AAAA,EACJ;AAAA;AAAA,EAEA,YAAY;AACR,UACI,KAAc,MACd,EAAE,OAAO,IAAK,IACd,EAAE,QAAQ,IAAI,GAAG;AACrB,QAAI,CAAC,GAAG,2BAA2B,WAAW,CAAC,GAAG,aAAa,CAAC,QAAQ,SAAS,GAAG,SAAS,IAAI;AAC7F,SAAG,0BAA0B;AAC7B,UAAI,GAAG,mBAAmB,QAAQ;AAC9B,SAAC,GAAG,SAAS,IAAI,QAAQ,IAAI,MAAM;AAAA,MACvC,OACK;AACD,SAAC,GAAG,SAAS,IAAI,QAAQ,OAAO,GAAG,MAAM;AAAA,MAC7C;AACA,SAAG,0BAA0B;AAAA,IACjC;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,eAAe,EAAE,OAAO,GAAG;AAEvB,QAAI,KAAK,aAAY,iCAAQ,QAAQ,sBAAqB,CAAC,OAAO,QAAQ,cAAc,GAAG;AACvF;AAAA,IACJ;AACA,SAAK,aAAa,KAAK,OAAO,qBAAqB,MAAM,CAAC;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,aAAa,QAAQ;AACjB,QAAI,QAAQ;AACR,UAAI,KAAK,eAAe,IAAI,MAAM,GAAG;AACjC,aAAK,SAAS,MAAM;AAAA,MACxB,OACK;AACD,aAAK,OAAO,MAAM;AAAA,MACtB;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,qBAAqB,SAAS;AAtpBlC;AAupBQ,eAAW,SAAS,SAAS;AACzB,YACI,SAAc,KAAK,OAAO,MAAM,SAAQ,WAAM,OAAO,YAAb,mBAAsB,EAAE,GAChE,cAAc,UAAU,KAAK,eAAe,IAAI,MAAM;AAC1D,UAAI,eAAe,CAAC,YAAY,gBAAgB,CAAC,YAAY,aAAa;AACtE,cAAM,YAAY,YAAY;AAC9B,oBAAY,qBAAqB;AACjC,YAAI,KAAK,iBAAiB,QAAQ,CAAC,MAAM,WAAW;AAChD,eAAK,wBAAwB,MAAM;AAAA,QACvC;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,IAAI,oBAAoB;AACpB,WAAO,KAAK,eAAe,KAAK,OAAO,QAAQ,SAAS;AAAA,EAC5D;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,cAAc,EAAE,QAAQ,QAAQ,SAAS,QAAQ,GAAG;AAlrBxD;AAmrBQ,UACI,KAAyC,MACzC,EAAE,gBAAgB,mBAAmB,IAAI,IACzC,cAAyC,WAAW,OAAO,KAAK,OAAO;AAC3E,SAAI,2CAAa,YAAW,OAAK,YAAO,WAAW,SAAS,YAAY,CAAC,CAAC,MAAzC,mBAA4C,UAAS,SAAS;AAC3F;AAAA,IACJ;AACA,QAAI,GAAG,UAAU;AACb;AAAA,IACJ;AACA,QAAI,WAAW,aAAa;AACxB,qBAAe,MAAM;AACrB,yBAAmB,MAAM;AAAA,IAC7B,WACS,mBAAmB,MAAM,GAAG;AACjC,iBAAW,CAAC,QAAQ,KAAK,KAAK,gBAAgB;AAC1C,YAAI,CAAC,OAAO,SAAS,MAAM,GAAG;AAC1B,aAAG,eAAe,KAAK;AACvB,yBAAe,OAAO,MAAM;AAC5B,6BAAmB,OAAO,MAAM;AAAA,QACpC;AAAA,MACJ;AAAA,IACJ,WACS,GAAG,0BAAyB,mCAAS,SAAQ;AAClD,UAAI,WAAW,UAAU;AACrB,cAAM,cAAc,eAAe,IAAI,QAAQ,CAAC,CAAC;AACjD,YAAI,2CAAa,WAAW;AACxB,sBAAY,YAAY;AACxB,aAAG,OAAO,WAAW,iBAAiB,QAAQ,CAAC,CAAC;AAAA,QACpD;AAAA,MACJ,WACS,WAAW,kBAAkB;AAClC,YAAI,gBACA;AACJ,mBAAW,OAAO,SAAS;AACvB,gBAAM,cAAc,eAAe,IAAI,GAAG;AAC1C,cAAI,2CAAa,WAAW;AACxB,kBAAM,QAAkB,OAAO,QAAQ,QAAQ,GAAG;AAClD,wBAAY,YAAY;AACxB,gBAAI,CAAC,aAAa,iBAAiB,OAAO;AACtC,+BAAiB;AACjB,0BAAiB;AAAA,YACrB;AAAA,UACJ;AAAA,QACJ;AACA,YAAI,WAAW;AACX,aAAG,OAAO,WAAW,iBAAiB,SAAS;AAAA,QACnD;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA,EAEA,iBAAiB,QAAQ,QAAQ;AAvuBrC;AAwuBQ,UACI,KAAwB,MACxB,EAAE,kBAAkB,IAAI;AAC5B,QAAI,cAAwB,GAAG,eAAe,IAAI,MAAM,GACpD,gBAAwB;AAE5B,QAAI,eAAe,CAAC,YAAY,oBAAoB;AAChD,iBAAW,UAAU,GAAG,OAAO,SAAS;AACpC,cAAMC,WAAS,iBAAY,qBAAqB,MAAM,MAAvC,mBAA0C;AACzD,YAAIA,UAAS,YAAY,oBAAoB;AACzC,sBAAY,qBAAqBA;AACjC,0BAAgB;AAAA,QACpB;AAAA,MACJ;AAAA,IACJ,WACS,CAAC,gBAAgB,cAAc,GAAG,mBAAmB,IAAI,MAAM,MAAM,YAAY,oBAAoB;AAC1G,kBAAY,qBAAqB;AACjC,sBAAgB;AAAA,IACpB;AACA,QAAI,iBAAiB,GAAG,oBAAoB,mBAAmB;AAC3D,SAAG,uBAAuB,WAAW;AAAA,IACzC;AACA,aAAQ,gDAAa,uBAAb,YAAmC,KAAK;AAAA,EACpD;AAAA;AAAA,EAEA,uBAAuB,OAAO;AAC1B,UACI,KAAc,MACd,cAAc,MAAM,qBAAqB,GAAG,OAAO,QAAQ,CAAC,CAAC,GAC7D,aAAc,GAAG,OAAO,WAAW,WAAW,MAAM,MAAM,EAAE;AAChE,UAAM,cAAc,GAAG,cAAc;AACrC,UAAM,eAAe;AAErB,gBAAY,MAAM,SAAS,WAAW,eAAe,MAAM,aAAa;AACxE,gBAAY;AACZ,gBAAY,MAAM,SAAS,MAAM,qBAAqB;AACtD,OAAG,kBAAkB,aAAa,MAAM;AAEpC,kBAAY,MAAM,SAAS;AAC3B,UAAI,CAAC,MAAM,oBAAoB;AAE3B,oBAAY,OAAO;AAAA,MACvB;AACA,YAAM,cAAc,GAAG,cAAc;AAAA,IACzC,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgB,EAAE,KAAK,OAAO,GAAG;AAC7B,UACI,KAAe,MACf,EAAE,QAAQ,IAAK,GAAG,QAClB;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,IACJ,IAAe,IAEf,cAAe,GAAG,eAAe,IAAI,MAAM;AAC/C,QAAI,IAAI,OAAO,0BAA0B,GAAG,QAAQ;AAEpD,QAAI,IAAI,IAAI,gBAAgB,GAAG;AAC3B,UAAI,kBAAkB,mBAAmB,IAAI,MAAM;AACnD,UAAI,iBAAiB;AACjB,cAAM,gBAAgB,MAAM;AACxB,4BAAkB,mBAAmB,IAAI,MAAM;AAE/C,cAAI,iBAAiB;AACjB,+BAAmB,OAAO,MAAM;AAChC,eAAG,eAAe,GAAG;AACrB,eAAG,eAAe,eAAe;AAAA,UACrC;AAAA,QACJ;AAEA,YAAI,GAAG,oBAAoB,GAAG,aAAa;AACvC,aAAG,kBAAkB,KAAK,aAAa;AAAA,QAC3C,OACK;AACD,wBAAc;AAAA,QAClB;AAAA,MACJ,WAES,CAAC,aAAa;AACnB,WAAG,eAAe,GAAG;AAAA,MACzB;AAAA,IACJ,OACK;AAED,yBAAmB,OAAO,MAAM;AAAA,IACpC;AACA,QAAI,CAAC,GAAG,YAAY,aAAa;AAE7B,UAAI,CAAC,YAAY,WAAW;AACxB,oBAAY,eAAe;AAC3B,WAAG,eAAe,QAAQ,KAAK,WAAW;AAAA,MAC9C;AACA,UAAI,IAAI,IAAI,gBAAgB;AAC5B,cAAQ,QAAQ,CAAC,QAAQ,MAAM;AAC3B,cAAM,aAAa,IAAI,WAAW,MAAM;AAGxC,YAAI,YAAY,cAAc,CAAC,qBAAqB,MAAM,IAAI;AAC1D,gBACI,cAAc,YAAY,qBAAqB,MAAM,GACrD,SAAc,oBAAoB,GAAG,OAAO,mBAAmB;AAEnE,cAAI,YAAY,kBAAkB,QAAQ;AACtC,gBAAI,CAAC,mBAAmB;AAEpB,wBAAU,mBAAmB,YAAY,MAAM,GAAG,iBAAiB;AAAA,YACvE;AAEA,mBAAO,YAAY,WAAW;AAE9B,eAAG,cAAc,WAAW;AAAA,UAChC;AACA,cAAI,mBAAmB;AAEnB,wBAAY,MAAM,MAAM,IAAI,MAAM,YAAY,aAAa;AAAA,UAC/D;AACA,sBAAY,eAAe;AAE3B,cAAI,YAAY,yBAAyB,CAAC,YAAY,kBAAkB;AACpE,eAAG,MAAM,YAAY,qBAAqB;AAC1C,wBAAY,wBAAwB;AAAA,UACxC;AAAA,QACJ;AACA,WAAG,eAAe,YAAY,YAAY,YAAY,KAAK;AAAA,MAC/D,CAAC;AAED,UAAI,GAAG,yBAAyB,GAAG,YAAY;AAC3C,WAAG,wBAAwB;AAC3B,YAAI,CAAC,UAAU,SAAS,YAAY,qBAAqB,QAAQ,CAAC,CAAC,GAAG,IAAI,GAAG;AAEzE,aAAG,OAAO,WAAW,IAAI;AAAA,YACrB,MAAa;AAAA,YACb,SAAa;AAAA,YACb,YAAa,MAAM,GAAG,kBAAkB,KAAK,MAAM;AAAA,UACvD,CAAC;AAAA,QACL;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB,KAAK,QAAQ;AAE3B,QAAI,KAAK,aAAa;AAClB,WAAK,kBAAkB,KAAK,MAAM,KAAK,OAAO,kBAAkB,MAAM,CAAC;AAAA,IAC3E,OACK;AACD,WAAK,OAAO,kBAAkB,MAAM;AAAA,IACxC;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB,KAAK,IAAI;AA74B/B;AA84BQ,UAAM,UAAU,UAAU,UAAU,GAAG,IAAI,MAAM,IAAI;AACrD,gBAAY,gBAAgB;AAAA,MACxB;AAAA,MACA,UAAW;AAAA,MACX,SAAW;AAAA,MACX,SAAW;AAAA,MACX,WAAW,eAAU,8BAA8B,SAAS,QAAQ,MAAzD,YAA8D;AAAA,IAC7E,CAAC;AAAA,EACL;AAAA,EACA,eAAe,KAAK;AAv5BxB;AAw5BQ,UAAM,KAAK;AACX,QAAI,IAAI,OAAO,GAAG,gBAAgB;AAClC,eAAW,UAAU,GAAG,OAAO,SAAS;AACpC,YAAM,aAAa,IAAI,WAAW,MAAM;AACxC,iBAAW,SAAS,WAAW,iBAAiB,MAAM,GAAG,iBAAiB,GAAG;AACzE,WAAG,gBAAgB,KAAK;AACxB,cAAM,OAAO;AAAA,MACjB;AAEA,iBAAW,UAAU,OAAO,GAAG,gBAAgB;AAC/C,SAAG,eAAe,YAAY,MAAM,KAAK;AAEzC,UAAI,GAAG,mBAAmB;AACtB,wBAAI,gCAAJ,mBAAiC,WAAjC;AACA,YAAI,8BAA8B;AAAA,MACtC;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,eAAe,OAAO;AA16B1B;AA26BQ,eAAW,UAAU,KAAK,OAAO,SAAS;AACtC,8BAAM,YAAN,mBAAgB,YAAhB,mBAAyB,YAAzB;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA,EAEA,eAAe,SAAS;AACpB,WAAO,QAAQ,QAAQ,CAAC,QAAQ;AAAA,EACpC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,eAAe,QAAQ,KAAK,aAAa;AA37B7C;AA47BQ,UACI,KAA+C,MAC/C,EAAE,QAAS,MAAM,QAAQ,kBAAkB,IAAI,IAC/C,cAA+C,SAAI,MAAM,CAAC,MAAX,mBAAc,cAC7D,EAAE,uBAAuB,CAAC,EAAE,IAAmB,aAC/C,iBAA+C,CAAC,GAEhD,oBAA+C,CAAC,SAAS,iBAAiB,WAAW;AACjF,UAAI,WAAW,MAAM;AACjB,YAAI,OAAO,YAAY,UAAU;AAE7B,gBAAM,kBAAkB,CAAC,GAAG,gBAAgB,UAAU,EAAE,IAAI,OAAK,gBAAgB,YAAY,CAAC,CAAC;AAC/F,0BAAgB,YAAY;AAC5B,0BAAgB,QAAQ,EAAE,QAAQ,OAAK,gBAAgB,aAAa,GAAG,gBAAgB,UAAU,CAAC;AAAA,QACtG,WACS,GAAG,eAAe,OAAO,GAAG;AACjC,uBAAa,SAAS,iBAAiB,MAAM;AAAA,QACjD,OAEK;AACD,oBAAU,UAAU,cAAc,OAAO;AACzC,0BAAgB,YAAY,OAAO;AAAA,QACvC;AAAA,MACJ;AAAA,IACJ,GACA,eAAe,CAAC,cAAc,iBAAiB,WAAW;AAr9BtE,UAAAC;AAs9BgB,YACI,aAAsBA,MAAA,UAAU,aAAa,MAAvB,gBAAAA,IAA0B,MAChD,sBAAsB,UAAU,cAAc;AAAA,QAC1C,QAAY;AAAA,QACZ,WAAY,GAAG;AAAA,QACf,OAAY;AAAA,MAChB,CAAC,GACD,aAAa,oBAAoB,cAAc,oBAAoB,aAAa,EAAE,MAAO,SAAS,CAAC;AACvG,qBAAe,KAAK,UAAU,0BAA0B,UAAU,EAAE,KAAK,MAAM;AA99B/F,YAAAA;AA+9BoB,YAAI,KAAK,aAAa;AAClB;AAAA,QACJ;AACA,cAAM,mBAAkBA,MAAA,aAAa,cAAb,OAAAA,MAA0B,GAAG;AACrD,YAAI,iBAAiB;AACjB,gBAAM,YAAY,OAAO,SAAS,eAAe;AAEjD,cAAI,uCAAW,SAAS;AACpB,yBAAa,QAAQ;AAAA,UACzB,WACS,KAAK,MAAM,GAAG,eAAe,OAAO,GAAG;AAC5C,kBAAM,eAAe,KAAK,MAAM,GAAG,eAAe,OAAO;AACzD,yBAAa,QAAQ,aAAa,MAAM,OAAK,OAAO,SAAS,eAAe,EAAE,SAAS,CAAC,CAAC;AAAA,UAC7F,OACK;AACD,yBAAa,OAAO;AAAA,UACxB;AAAA,QACJ;AACA,YAAI,WAAW;AACX,gBACI,EAAE,IAAI,IAAK,cACX,WAAW,WAAW,UAAU,YAAY,CAAC;AACjD,uBAAa,MAAM,MAAM,MAAM,MAAM,WAAW;AAAA,QACpD;AACA,YAAI,CAAC,YAAY,SAAS;AACtB,sBAAY,UAAU,CAAC;AAAA,QAC3B;AACA,oBAAY,QAAQ,MAAM,IAAI,gBAAgB,SAAS,OAAO,OAAO,aAAa,OAAO;AAAA,UACrF,UAAiB;AAAA,UACjB,OAAiB;AAAA,UACjB,MAAiB;AAAA,UACjB,WAAiB;AAAA,UACjB,UAAiB;AAAA,UACjB,gBAAiB;AAAA,QACrB,GAAG,YAAY,CAAC;AAChB,YAAI,iBAAiB;AAEjB,0BAAgB,OAAO,MAAM,IAAI;AAAA,YAC7B,QAAU,MAAM,CAAC,IAAI,eAAe,IAAI,OAAO;AAAA,YAC/C,SAAU;AAAA,UACd,CAAC;AAAA,QACL;AAAA,MACJ,CAAC,EAAE,MAAM,CAAC,SAAS;AACf,cAAM,IAAI,MAAM,+BAA+B,IAAI;AAAA,MACvD,CAAC,CAAC;AAAA,IACN;AAEJ,QAAI,YAAY,kBAAkB;AAC9B;AAAA,IACJ;AAEA,QAAI,OAAO,GAAG,gBAAgB;AAC9B,WAAO,OAAO,aAAa,EAAE,YAAY,sBAAsB,oBAAqB,GAAG,mBAAoB,CAAC,EAAE,CAAC;AAC/G,eAAW,CAAC,GAAG,MAAM,KAAK,KAAK,QAAQ,QAAQ,GAAG;AAE9C,UAAI,qBAAqB,IAAI,GAAG;AAC5B;AAAA,MACJ;AACA,YACI,aAAsB,IAAI,WAAW,MAAM;AAC/C,UAAI,sBAAsB,qBAAqB,MAAM,GACjD;AACJ,UAAI,qBAAqB;AAErB,WAAG,gBAAgB,mBAAmB;AACtC,4BAAoB,gBAAgB;AAAA,MACxC,OACK;AAGD,8BAAsB,UAAU,cAAc;AAAA,UAC1C,QAAY,oBAAoB,KAAK,mBAAmB;AAAA,UACxD,UAAY;AAAA,UACZ,WAAY,GAAG;AAAA,UACf,OAAY;AAAA,YACR,KAAM,oBAAoB,IAAI,MAAM,aAAa,aAAa;AAAA,UAClE;AAAA,UACA,SAAU;AAAA,YACN,IAAK,OAAO;AAAA,UAChB;AAAA,QACJ,CAAC;AAAA,MACL;AACA,UAAI,mBAAmB;AACnB,YAAI,8BAA8B;AAAA,MACtC;AACA,SAAG,cAAc,mBAAmB;AACpC,UAAI,iCAAS,SAAS;AAClB,qBAAa,OAAO,MAAM,GAAG,qBAAqB,MAAM;AAAA,MAC5D,OACK;AAED,0BAAiB,QAAG,aAAH,4BAAc;AAAA,UAC3B;AAAA,UACA,iBAAkB;AAAA,UAClB;AAAA,UACA;AAAA,UACA;AAAA,QACJ;AAAA,MACJ;AACA,UAAI,QAAQ,UAAU,cAAc,GAAG;AACnC,uBAAe,KAAK,eAAe,KAAK,aAAW,kBAAkB,SAAS,qBAAqB,MAAM,CAAC,CAAC;AAAA,MAC/G,OACK;AACD,0BAAkB,gBAAgB,qBAAqB,MAAM;AAAA,MACjE;AACA,2BAAqB,MAAM,IAAI;AAAA,IACnC;AAEA,QAAI,eAAe,QAAQ;AACvB,kBAAY,mBAAmB;AAE/B,SAAG,sBAAsB,WAAW;AACpC,cAAQ,IAAI,cAAc,EAAE,KAAK,MAAM;AAGnC,gBAAQ,IAAI,cAAc,EAAE,KAAK,MAAM;AAllCvD,cAAAA,KAAAC;AAmlCoB,cAAI,KAAK,aAAa;AAClB;AAAA,UACJ;AAEA,WAAAD,MAAA,YAAY,sBAAZ,gBAAAA,IAA+B,QAAQ,QAAM,GAAG,OAAO;AACvD,sBAAY,kBAAkB,SAAS;AACvC,sBAAY,eAAe;AAC3B,sBAAY,mBAAmB;AAG/B,qBAAW,CAAC,EAAE,KAAK,KAAK,GAAG,gBAAgB;AACvC,gBAAI,MAAM,kBAAkB;AACxB;AAAA,YACJ;AAAA,UACJ;AAEA,WAAAC,MAAA,GAAG,4BAAH,gBAAAA,IAAA,SAA6B,QAAQ;AAAA,QACzC,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AACA,gBAAY,YAAY;AAAA,EAC5B;AAAA,EACA,sBAAsB,aAAa;AAC/B,eAAW,UAAU,YAAY,sBAAsB;AACnD,kBAAY,kBAAkB,KAAK,UAAU,cAAc;AAAA,QACvD,QAAY,YAAY,qBAAqB,MAAM;AAAA,QACnD,WAAY;AAAA,QACZ,OAAY;AAAA,UACR,QAAS,KAAK,yBAAyB;AAAA,QAC3C;AAAA,QACA,UAAW;AAAA,UACP;AAAA,YACI,KAAY;AAAA,YACZ,WAAY;AAAA,UAChB;AAAA,UACA,KAAK;AAAA,QACT;AAAA,MACJ,CAAC,CAAC;AAAA,IACN;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,wBAAwB,QAAQ;AAC5B,UAAM,KAAK;AACX,QAAI,GAAG,kBAAkB;AACrB,YAAM,MAAM,GAAG,OAAO,WAAW,WAAW,MAAM;AAClD,UAAI,KAAK;AACL,WAAG,cAAc;AACjB,YAAI,GAAG,mBAAmB,IAAI,MAAM,GAAG;AACnC,cAAI,OAAO,qBAAqB;AAAA,QACpC;AACA,WAAG,kBAAkB,KAAK,MAAM;AA3oChD;AA4oCoB,aAAG,cAAc;AACjB,cAAI,CAAC,IAAI,aAAa;AAClB,sBAAI,cAAJ,6BAAgB;AAAA,UACpB;AAAA,QACJ,CAAC;AAAA,MACL;AAAA,IACJ;AACA,WAAO,GAAG,iBAAiB,MAAM;AAAA,EACrC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,iBAAiB,QAAQ;AA3pC7B;AA4pCQ,MAAC,UAAK,qBAAL,YAA0B,KAAK,mBAAmB,CAAC,GAAI,KAAK,MAAM;AACnE,QAAI,CAAC,KAAK,aAAa;AACnB,WAAK,cAAc,IAAI,QAAQ,aAAW;AACtC,8BAAsB,MAAM;AA/pC5C,cAAAD;AAgqCoB,WAAAA,MAAA,KAAK,mBAAL,gBAAAA,IAAA,WAAsB;AACtB,eAAK,cAAc;AAAA,QACvB,CAAC;AAAA,MACL,CAAC;AAAA,IACL;AACA,WAAO,KAAK;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,eAAe,gBAAgB;AAC3B,UACI,KAAuB,MACvB,EAAE,iBAAiB,IAAI,IACvB,EAAE,MAAM,IAAe,GAAG;AAC9B,OAAG,eAAe,QAAQ,CAAC,OAAO,WAAW;AACzC,UAAI,MAAM,yBAAyB,MAAM,aAAa,CAAC,iBAAiB,SAAS,MAAM,GAAG;AACtF,yBAAiB,KAAK,MAAM;AAAA,MAChC;AAAA,IACJ,CAAC;AACD,UAAM,CAAC,GAAG,IAAI,iBAAiB,KAAK,CAAC,GAAG,MAAM,MAAM,QAAQ,CAAC,IAAI,MAAM,QAAQ,CAAC,CAAC;AACjF,OAAG,OAAO,WAAW,iBAAiB,GAAG;AACzC,qBAAiB,SAAS;AAE1B,OAAG,MAAM,cAAc;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,eAAe,YAAY,YAAY,QAAQ;AAC3C,aAAS,IAAI,GAAG,IAAI,WAAW,SAAS,QAAQ,KAAK;AACjD,YAAM,QAAQ,WAAW,SAAS,CAAC;AAEnC,UAAI,CAAC,MAAM,UAAU,SAAS,KAAK,iBAAiB,GAAG;AACnD,cAAM,MAAM,SAAS,SAAS,KAAK,aAAa;AAAA,MACpD;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAaA,MAAM,OAAO,QAAQ,YAAY,OAAO;AACpC,UAAM,KAAK;AACX,QAAI,GAAG,YAAY,GAAG,eAAe,IAAI,MAAM,KAAK,MAAM,GAAG,QAAQ,gBAAgB,EAAE,OAAO,CAAC,MAAM,OAAO;AACxG;AAAA,IACJ;AACA,QAAI;AACJ,WAAO,IAAI,QAAQ,CAAC,YAAY;AA/tCxC;AAguCY,oBAAc;AAAA,QACV,WAAwB;AAAA,QACxB,uBAAwB;AAAA,QACxB;AAAA,MACJ;AAEA,SAAG,eAAe,IAAI,QAAQ,WAAW;AAEzC,SAAG,mBAAmB,OAAO,MAAM;AACnC,SAAG,wBAAwB;AAC3B,SAAG,wBAAwB,MAAM;AAEjC,UAAI,CAAC,WAAW;AACZ,uBAAG,QAAO,eAAV,4BAAuB,WAAS,MAAM,SAAS,YAAY,OAAO,QAAQ,IAAI;AAAA,MAClF;AAAA,IACJ,CAAC,EAAE,KAAK,MAAM;AA/uCtB;AAgvCY,eAAG,YAAH,4BAAa,UAAU;AAAA,QACnB;AAAA,QACA,kBAAmB,YAAY;AAAA,QAC/B,SAAmB,iBAAY,YAAZ,mBAAsB,GAAG,OAAO,QAAQ,CAAC;AAAA,QAC5D,SAAmB,YAAY;AAAA,MACnC;AAAA,IACJ,CAAC;AAAA,EACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,MAAM,SAAS,QAAQ,YAAY,OAAO;AA/vC9C;AAgwCQ,UACI,KAAc,MACd,cAAc,GAAG,eAAe,IAAI,MAAM;AAC9C,QAAI,GAAG,YAAY,MAAM,GAAG,QAAQ,kBAAkB,EAAE,OAAO,CAAC,MAAM,OAAO;AACzE;AAAA,IACJ;AAEA,QAAI,2CAAa,sBAAsB;AACnC,iBAAW,UAAU,YAAY,sBAAsB;AACnD,WAAG,gBAAgB,YAAY,qBAAqB,MAAM,CAAC;AAAA,MAC/D;AAAA,IACJ;AACA,OAAG,eAAe,OAAO,MAAM;AAC/B,OAAG,mBAAmB,IAAI,QAAQ,WAAW;AAC7C,UAAM,GAAG,wBAAwB,MAAM;AACvC,OAAG,QAAQ,YAAY,EAAE,OAAO,CAAC;AAEjC,QAAI,CAAC,WAAW;AACZ,qBAAG,QAAO,eAAV,4BAAuB,WAAS,MAAM,SAAS,YAAY,SAAS,QAAQ,IAAI;AAAA,IACpF;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,IAAI,YAAY;AACZ,WAAO,QAAQ,KAAK,MAAM,KAAK,CAAC,GAAG,KAAK,eAAe,OAAO,CAAC,EAAE,KAAK,WAAS,MAAM,OAAO;AAAA,EAChG;AAAA;AAAA,EAEA,eAAe;AACX,QAAI,CAAC,KAAK,aAAa,GAAG;AACtB,aAAO,KAAK,WAAW,aAAa,GAAG,SAAS;AAAA,IACpD;AAAA,EACJ;AAAA;AAAA,EAEA,aAAa;AACT,SAAK,aAAa,IAAI;AAAA,EAC1B;AAAA;AAAA,EAEA,WAAW,EAAE,qBAAqB,QAAQ,QAAQ,GAAG;AAryCzD;AAsyCQ,UACI,EAAE,OAAO,IAAkB,MAC3B,EAAE,aAAa,QAAQ,IAAI;AAC/B,aAAS,CAAC,QAAQ,KAAK,KAAK,KAAK,eAAe,QAAQ,GAAG;AACvD,iBAAW,UAAU,MAAM,sBAAsB;AAC7C,YAAI,MAAM,qBAAqB,MAAM,EAAE,WAAW,QAAQ;AAGtD,cAAI,SAAS;AACT,kBAAM,aAAa,QAAQ,QAAQ,QAAQ,MAAM,KAAK,wBAAwB,SAAS,IAAI,GAAG;AAC9F,gBAAI,YAAY;AACZ,qBAAO,KAAK,mBAAkB,WAAM,YAAN,mBAAgB,aAAa,wBAAwB,MAAM;AAAA,YAC7F;AAAA,UACJ;AACA,cAAI,wBAAwB,QAAQ;AAChC,qBAAS,OAAO,MAAM,QAAQ,QAAQ,QAAW,IAAI;AAAA,UACzD;AACA,cAAI;AAEJ,cAAI,CAAC,WAAW,eAAe,CAAC,YAAY,iBAAiB;AACzD,qBAAS,YAAY;AAAA,UACzB,OAEK;AACD,qBAAS,KAAK,sBAAsB,QAAQ,MAAM,WAAW,wBAAwB,IAAI;AAAA,UAC7F;AAEA,iBAAO,eAAe;AACtB,gBAAM,cAAc,OAAO,qBAAqB,EAAE,QAAQ,OAAO,CAAC;AAClE,iBAAO,UAAU,WAAW;AAC5B,cAAI,SAAS;AACT,mBAAO,aAAa,WAAW;AAAA,UACnC;AACA,iBAAO;AAAA,QACX;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,aAAa,IAAI;AA90CrB;AA+0CQ,UACI,EAAE,YAAY,IAAI,KAAK,QACvB,QAAkB,eAAe,KAAK,eAAe,IAAI,YAAY,MAAM,GAC3E,UAAkB,0CAAO,yBAAP,oBAA8B,gDAAa,WAAb,mBAAqB,YAAnD,mBAA4D;AAClF,QAAI,iCAAQ,QAAQ;AAChB,UAAI;AAEJ,UAAI,OAAO,eAAe,CAAC,OAAO,YAAY,iBAAiB;AAC3D,iBAAS,OAAO,YAAY;AAAA,MAChC,OAEK;AACD,iBAAS,KAAK,sBAAsB,MAAM;AAAA,MAC9C;AAEA,aAAO,eAAe;AACtB,aAAO,UAAU,OAAO,qBAAqB,EAAE,QAAS,OAAO,GAAG,KAAK,SAAS,OAAO,YAAY,GAAG,OAAO,CAAC,CAAC;AAC/G,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,sBAAsB,MAAM,WAAW,MAAM,UAAU,OAAO;AA32ClE;AA42CQ,UAAM,UAAU,UAAU,CAAC,GAAG,KAAK,QAAQ,cAAc,EAAE,QAAQ,IAAI,KAAK,QAAQ;AACpF,YAAO,aAAQ;AAAA,MAAK,OAAE;AA72C9B,YAAAA;AA82CY,qBAAM,KAAK,2BACX,QAAMA,MAAA,KAAK,SAAS,gBAAd,gBAAAA,IAA2B,eAChC,CAAC,YAAY,EAAE;AAAA;AAAA,IACpB,MAJO,YAIF,QAAQ,CAAC;AAAA,EAClB;AAAA,EACA,kBAAkB,EAAE,WAAW,GAAG;AAn3CtC;AAo3CQ,QAAIF,SAAQ,UAAU,GAAG;AACrB,aAAO,CAAC,KAAK,gBAAc,UAAK,OAAO,SAAS,aAArB,mBAA+B;AAAA,IAC9D;AAAA,EACJ;AAAA,EACA,MAAM,UAAU;AAx3CpB;AAy3CQ,UACI,EAAE,OAAO,IAAM,MACf,EAAE,SAAS,IAAI,OAAO;AAE1B,QAAI,qCAAU,SAAS;AACnB,YACI,EAAE,SAAS,QAAQ,IAAI,QACvB,EAAE,aAAa,IAAQ,UACvB,OAAuB,aAAa,MACpC,WAAuB,SAAS,wBAAwB,OAAO,aAAa,IAAI,GAChF,iBAAuB,OAAO,eAAgB,WAAW,OAAO,MAAM,QAAQ,SAAS,EAAE,IAAI,MAC7F,UAAuB,oBAAkB,UAAK,eAAe,IAAI,cAAc,MAAtC,mBAAyC;AAGtF,UAAI,YAAW,6CAAc,SAAO,qCAAU,KAAI;AAE9C,YAAI,cAAc,WAAW,QAAQ,QAAQ,SAAS,QAAQ,IAAI,QAAQ,eAAe,CAAC,GAAG;AAC7F,eAAO,YAAY;AAEf,gBAAM,SAAS,QAAQ,UAAU;AAEjC,cAAI,KAAK,kBAAkB,QAAQ,IAAI,GAAG;AACtC,mBAAO;AAAA,UACX;AAEA,uBAAa,QAAQ,QAAQ,QAAQ,UAAU,KAAK,OAAO,IAAI,GAAG;AAAA,QACtE;AAAA,MACJ;AAAA,IACJ;AAEA,WAAO;AAAA,EACX;AAAA,EACA,kBAAkB,QAAQ,OAAO,MAAM;AAz5C3C;AA05CQ,UAAM,EAAE,SAAS,IAAI,KAAK,OAAO;AACjC,SAAI,qCAAU,cAAW,4CAAQ,aAAR,mBAAkB,aAAlB,mBAA4B,UAAS;AAC1D,eAAS,cAAc,EAAE,KAAK,MAAM;AAChC,cACI,SAAS,OAAO,GAAG,OAAO,UAAU,MAAM,YAAY,GACtD,SAAS,KAAK,sBAAsB,QAAQ,MAAM,CAAC,IAAI;AAC3D,eAAO,aAAa,OAAO,qBAAqB,EAAE,QAAQ,OAAO,CAAC,CAAC;AAAA,MACvE,CAAC;AACD,aAAO;AAAA,IACX;AAAA,EACJ;AAAA,EACA,aAAa;AACT,WAAO,KAAK,MAAM,IAAI;AAAA,EAC1B;AAAA;AAAA;AAAA,EAGA,cAAc,SAAS;AACnB,UAAM,KAAK;AACX,QAAI,CAAC,GAAG,gBAAgB;AACpB,SAAG,iBAAiB,IAAI,eAAe,aAAW,GAAG,qBAAqB,OAAO,CAAC;AAAA,IACtF;AACA,OAAG,eAAe,QAAQ,OAAO;AAAA,EACrC;AAAA;AAAA,EAEA,gBAAgB,SAAS;AAl7C7B;AAm7CQ,eAAK,mBAAL,mBAAqB,UAAU;AAAA,EACnC;AAAA,EACA,YAAY;AAr7ChB;AAs7CQ,eAAK,mBAAL,mBAAqB;AACrB,WAAO,KAAK;AAEZ,eAAW,CAAC,EAAE,KAAK,KAAK,KAAK,gBAAgB;AACzC,WAAK,eAAe,KAAK;AAAA,IAC7B;AACA,UAAM,UAAU;AAAA,EACpB;AAAA,EACA,cAAc,EAAE,MAAM,MAAM,GAAG;AAC3B,eAAW,CAAC,EAAE,KAAK,KAAK,KAAK,gBAAgB;AACzC,aAAO,OAAO,MAAM,oBAAoB,EAAE,QAAQ,iBAAe;AAh8C7E;AAi8CgB,cAAM,sBAAsB,YAAY,cAAc,MAAM,KAAK,wBAAwB;AACzF,YAAI,2DAAqB,aAAa;AAClC,oBAAU,0BAA0B,2DAAqB,aAAa,IAAI;AAC1E,kCAAY,WAAZ,mBAAoB,YAApB,mBAA6B,UAAU,OAAO,WAAW,IAAI;AAC7D,kCAAY,WAAZ,mBAAoB,YAApB,mBAA6B,UAAU,IAAI,WAAW,KAAK;AAAA,QAC/D;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,kBAAkB,iBAAiB;AA/8CvC;AAg9CQ,eAAW,CAAC,KAAK,EAAE,SAAS,qBAAqB,CAAC,KAAK,KAAK,eAAe,QAAQ,GAAG;AAClF,UAAI,WAAW,gBAAgB,UAAU;AACrC,mBAAW,UAAU,SAAS;AAC1B,cAAI,QAAQ,MAAM,MAAM,iBAAiB;AACrC,mBAAO;AAAA,UACX;AAAA,QACJ;AAEA,aAAI,qBAAgB,mBAAhB,mBAAgC,SAAS;AACzC,iBAAO,gBAAgB;AAAA,QAC3B;AAAA,MACJ,OACK;AACD,mBAAW,UAAU,sBAAsB;AACvC,gBAAM,QAAQ,qBAAqB,MAAM;AACzC,cAAI,UAAU,mBAAmB,MAAM,SAAS,eAAe,GAAG;AAC9D,mBAAO;AAAA,UACX;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,mBAAmB,QAAQ;AA7+C/B;AA8+CQ,YAAO,UAAK,eAAe,IAAI,MAAM,MAA9B,mBAAiC;AAAA,EAC5C;AACJ;AAAA;AA9zCI,cAFiB,aAEV,SAAQ;AAcf,cAhBiB,aAgBV,gBAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgHlB,UAAW;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAgBX,cAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAoBf,QAAS,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQV,gBAAiB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOjB,uBAAwB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMxB,wBAAyB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMzB,sBAAuB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMvB,kBAAmB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAkDnB,QAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMT,WAAY;AAAA,EACZ,QAAS;AAAA;AAAA,IAEL,KAAc,EAAE,SAAU,SAAS,QAAS,GAAG;AAAA,IAC/C,aAAc,EAAE,SAAU,cAAc,QAAS,GAAG;AAAA,EACxD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASb,aAAc;AAClB;AA8iCJ,YAAY,SAAS;AAAe,mBAAmB,gBAAgB,WAAW;;;AC3+ClF,IAAMI,WAAU;AAAA,EACZ,aAAc;AAAA,EACd,aAAc;AAClB;AAkDA,IAAqB,SAArB,cAAoC,kBAAU,cAAc,EAAE;AAAA,EA2B1D,WAAW,aAAa;AACpB,WAAO;AAAA,MACH,QAAkB;AAAA,MAClB,YAAkB;AAAA,MAClB,iBAAkB;AAAA,MAClB,YAAkB;AAAA,IACtB;AAAA,EACJ;AAAA,EACA,UAAU,MAAM,QAAQ;AACpB,UAAM,UAAU,MAAM,MAAM;AAC5B,WAAO,OAAO,MAAM;AAAA,MAChB;AAAA,MACA,MAAa;AAAA,MACb,QAAa,CAAC;AAAA,MACd,YAAa,KAAK,gBAAgB,KAAK,SAAS,UAAU,WAAW,WAAW,MAAM,UAAU,WAAW,aAAa;AAAA,IAC5H,CAAC;AAED,SAAK,IAAI;AAAA,MACL,YAAa;AAAA,MACb,SAAa;AAAA,IACjB,CAAC;AAAA,EACL;AAAA,EACA,kBAAkB,EAAE,WAAW,GAAG;AAC9B,QAAIA,SAAQ,UAAU,GAAG;AACrB,aAAO,QAAQ,KAAK,IAAI;AAAA,IAC5B;AAAA,EACJ;AAAA,EACA,mBAAmB;AACf,QAAI,KAAK,MAAM;AACX,WAAK,sBAAsB,KAAK,QAAQ,CAAC,KAAK,MAAM,OAAO,IAAI,CAAC;AAAA,IACpE;AAAA,EACJ;AAAA,EACA,YAAY;AACR,SAAK,MAAM,IAAI;AACf,UAAM,UAAU;AAAA,EACpB;AAAA,EACA,UAAU,SAAS;AACf,QAAI,SAAS;AACT,WAAK,MAAM;AAAA,IACf;AACA,UAAM,UAAU,OAAO;AAAA,EAC3B;AAAA,EACA,IAAI,QAAQ;AACR,WAAO,KAAK,KAAK;AAAA,EACrB;AAAA;AAAA;AAAA;AAAA,EAIA,WAAW,eAAe;AACtB,WAAO;AAAA,MACH,OAAQ,CAAC,kBAAkB;AAAA,IAC/B;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,MAAM,OAAO,MAAM,UAAU,MAAM,UAAU,OAAO,QAAQ,YAAY,OAAO;AApJnF;AAqJQ,UAAM,KAAK;AAEX,QAAI,CAAC,MAAM;AACP,aAAO,GAAG,MAAM;AAAA,IACpB;AAEA,QAAI,CAAC,WAAW,SAAS,GAAG,QAAQ,GAAG,UAAU;AAC7C;AAAA,IACJ;AACA,UACI,EAAE,MAAM,MAAM,IAAI,IAElB,UAAkB,KAAK,QAAQ,eAAe,OAAO,SAAO,IAAI,eAAe,KAAK,GACpF,aAAkB,CAAC;AACvB,aAAc,UAAU,QAAQ,IAAI,SAAO;AAnKnD,UAAAC;AAqKY,iBAAW,MAAKA,MAAA,IAAI,gBAAJ,gBAAAA,IAAiB,KAAK,IAAI;AAC1C,aAAO,IAAI;AAAA,IACf,CAAC;AACD,UAAM,QAAQ,MAAM,OAAO,MAAM,QAAQ,UAAU;AACnD,QAAI,MAAM,UAAU,MAAM,QAAQ;AAC9B,YAAM,KAAK,SAAS,MAAM,IAAI,SAAO,IAAI,EAAE,CAAC;AAAA,IAChD;AAEA,eAAW,UAAU,SAAS;AAC1B,UAAI,OAAO,cAAc,OAAO,UAAU;AACtC,YAAI,YAAY,MACZ,YAAY;AAChB,mBAAW,OAAO,OAAO;AACrB,cAAI,IAAI,UAAU,OAAO,OAAO;AAC5B,kBAAM,QAAQ,IAAI,KAAK,IAAI,KAAK;AAChC,gBAAI,UAAU,WAAW;AACrB,kBAAI,YAAY;AAAA,YACpB;AACA,wBAAY;AACZ,wBAAY,GAAG,IAAI,KAAK,IAAI,IAAI,EAAE;AAAA,UACtC;AAAA,QACJ;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,IAAI;AACR,WAAO,OAAO,IAAI;AAAA,MACd,UAAY,CAAC;AAAA,MACb,WAAY,GAAG;AAAA,MACf;AAAA,MACA;AAAA,MACA,QAAY,IAAI,OAAO,WAAW,aAAa,aAAa,OAAO,IAAI,CAAC,CAAC,YAAY,IAAI;AAAA,IAC7F,CAAC;AACD,OAAG,UAAU;AACb,QAAI,CAAC,OAAO;AACR;AAAA,IACJ;AAEA,eAAW,OAAO,OAAO;AAErB,SAAG,SAAS,GAAG,IAAI,KAAK,IAAI,IAAI,EAAE,EAAE,IAAI,IAAI,YAAY,GAAG,SAAS,IAAI,SAAS,IAAI;AAErF,UAAI,IAAI,GAAG,OAAO;AACd;AAAA,MACJ;AAAA,IACJ;AACA,QAAI,CAAC,GAAG,sBAAsB;AAC1B,WAAK,WAAW,IAAI;AAAA,QAChB,MAAa;AAAA,QACb,YAAa;AAAA,QACb,SAAa;AAAA,MACjB,CAAC;AACD,YAAM,IAAI;AAAA,QACN,MAAsC;AAAA,QACtC,CAAC,UAAU,KAAK,gBAAgB,EAAE,GAAI;AAAA,QACtC,SAAsC;AAAA,MAC1C,CAAC;AACD,SAAG,uBAAuB;AAAA,IAC9B;AACA,SAAK,YAAY;AACjB,SAAK,QAAQ,UAAU,EAAE,MAAM,MAAO,MAAM,MAAM,CAAC;AACnD,QAAI,WAAW,CAAC,GAAG,gBAAgB,CAAC,WAAW;AAC3C,SAAG,YAAY,IAAI;AAAA,IACvB;AACA,eAAK,eAAL,8BAAkB,WAAS,MAAM,SAAS,OAAO,OAAO,MAAM,SAAS,SAAS,QAAQ,IAAI;AAC5F,WAAO;AAAA,EACX;AAAA,EACA,YAAY;AAER,eAAW,eAAe,UAAU,SAAS,KAAK,KAAK,SAAS,MAAM,KAAK,MAAM,GAAG;AAChF,kBAAY,UAAU,OAAO,KAAK,QAAQ,KAAK,UAAU;AAEzD,YAAM,MAAM,aAAa,IAAI,WAAW,EAAE;AAE1C,UAAI,KAAK;AAEL,YAAI,iBAAiB;AACrB,YAAI,WAAW,WAAW;AAC1B,YAAI,iBAAiB;AAAA,MACzB;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,MAAM,SAAS,OAAO;AAzP1B;AA0PQ,UACI,KAAW,MACX,EAAE,KAAK,IAAI;AACf,QAAI,GAAG,UAAU;AACb,aAAO,GAAG;AAAA,IACd;AACA,OAAG,OAAO;AACV,OAAG,UAAU;AACb,QAAI,GAAG,sBAAsB;AACzB,SAAG,gBAAgB,YAAY;AAC/B,SAAG,gBAAgB,cAAc;AACjC,SAAG,uBAAuB;AAAA,IAC9B;AACA,QAAI,CAAC,QAAQ;AACT,WAAK,QAAQ,eAAe,EAAE,KAAK,CAAC;AAEpC,iBAAK,eAAL,8BAAkB,WAAS,MAAM,SAAS,OAAO,MAAM;AAAA,IAC3D;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,IAAI,aAAa;AAlRrB;AAmRQ,YAAO,gBAAK,UAAL,mBAAY,WAAZ,YAAsB;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,IAAI,eAAe;AA5RvB;AA6RQ,UACI,KAAkB,MAClB,EAAE,KAAK,IAAW,IAClB,EAAE,YAAY,IAAI;AACtB,SAAI,gDAAa,SAAb,mBAAmB,SAAS,UAAU,iBAAiB,KAAK,OAAO,IAAI;AACvE,YAAM,EAAE,UAAU,OAAO,IAAI;AAC7B,aAAO,aAAa,MAAM,GAAG,MAAM;AAAA,QAAK,SACpC,IAAI,UAAU,YAAY,UAAU,IAAI,UAAU,OAAO;AAAA,MAC7D;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,YAAY,YAAY,OAAO;AA3SnC;AA4SQ,UACI,KAAK;AACT,QAAI,GAAC,QAAG,UAAH,mBAAU;AAAQ;AACvB,UACI,EAAE,MAAM,MAAM,IAAI,IAClB,WAAkB,KAAK,eAAe,KAAK,iBAC3C,eAAkB,YAAY,cAAc,OAAO,MAAM,QAAQ,SAAS,QAAQ,QAAW,IAAI,IAAI,IACrG,UAAkB,GAAG,MAAM,UAAU,SAAO,IAAI,QAAQ,YAAY;AACxE,QAAI,YAAY,IAAI;AAChB,SAAG,QAAQ,OAAO;AAAA,IACtB;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc;AA3TlB;AA4TQ,UACI,KAAY,MACZ,EAAE,MAAM,IAAI;AAChB,QAAI,GAAC,QAAG,UAAH,mBAAU;AAAQ;AACvB,UACI,EAAE,MAAM,MAAM,IAAI,IAClB,WAAkB,KAAK,eAAe,KAAK,iBAC3C,eAAkB,WAAW,MAAM,QAAQ,SAAS,QAAQ,QAAW,IAAI,IAAI;AACnF,aAAS,IAAI,MAAM,SAAS,GAAG,KAAK,KAAK,GAAG;AACxC,YAAM,MAAM,MAAM,CAAC;AACnB,UAAI,IAAI,QAAQ,cAAc;AAC1B,WAAG,QAAQ,CAAC;AACZ;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA,EAKA,QAAQ,OAAO;AACX,UACI,EAAE,KAAK,IAAI,MACX,UAAW,KAAK,MAAM,KAAK;AAC/B,QAAI,SAAS;AACT,WAAK,UAAU;AAAA,QACX,OAAQ,QAAQ;AAAA,QAChB,IAAQ,QAAQ;AAAA,MACpB,CAAC;AAAA,IACL;AACA,WAAO,QAAQ,OAAO;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAIA,eAAe;AACX,SAAK,QAAQ,CAAC;AAAA,EAClB;AAAA;AAAA;AAAA;AAAA,EAIA,cAAc;AACV,SAAK,QAAQ,KAAK,MAAM,SAAS,CAAC;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,WAAW,EAAE,aAAa,QAAQ,QAAQ,MAAM,GAAG;AA9WvD;AA+WQ,UACI,KAAW,MACX;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ,IAAW,IACX,YAAW,QAAG,aAAH,mBAAc,OAAO,QAAQ,MAAM,OAAO;AACzD,QAAI,UAAU;AAEV,kBAAY,UAAU,IAAI,GAAG,MAAM;AAEnC,wBAAgB,iBAAY,cAAc,IAAI,GAAG,eAAe,EAAE,MAAlD,mBAAqD;AAErE,YAAM,QAAQ,UAAU,KAAK,aAAa,uCAAuC,KAAK;AACtF,UAAI,OAAO,KAAK,EAAE,YAAY,MAAM,OAAO,GAAG,IAAI,EAAE,YAAY,GAAG;AAC/D,cAAM,YAAY,gBAAgB,GAAG,UAAU,KAAK,MAAM,SAAS,UAAU,eAAe,eAAe,GAAG,eAAe,KAAK,QAAQ,WAAW,EAAE;AAAA,MAC3J,OAGK;AACD,mBAAW,cAAc;AACzB,iBAAS,WAAW,WAAW,SAAS,GAAG,YAAY,MAAM,SAAS,QAAQ,KAAI;AAC9E,gBACI,gBAAgB,UAChB,cAAgB,SAAS,WACzB,UAAgB,CAAC,QAAQ;AAE7B,qBAAW,WAAW,SAAS;AAC/B,cAAI,SAAS,OAAO;AAGpB,mBAAS,QAAQ,OAAO,KAAK,WAAW,GAAG,OAAO,QAAQ,OAAO,KAAK,WAAW,GAAG;AAChF,kBACI,WAAc,YAAY,UAAU,QAAQ,MAAM,KAAK,GACvD,cAAc,MAAM,CAAC,IAAI,SAAS,IAClC,IAAc,MAAM,CAAC,GACrB,aAAc,MAAM,CAAC,IAAI,SAAS;AACtC,oBAAQ,KAAK,GAAG,aAAa,WAAW,QAAQ,CAAC,GAAG,WAAW,gBAAgB,UAAU,KAAK,aAAa,WAAW,CAAC,CAAC,UAAU,UAAU,EAAE;AAC9I,qBAAS,OAAO;AAAA,UACpB;AACA,kBAAQ,KAAK,aAAa,WAAW,YAAY,UAAU,MAAM,CAAC,GAAG,QAAQ;AAE7E,wBAAc,WAAW,aAAa,UAAU,0BAA0B,QAAQ,KAAK,EAAE,GAAG;AAAA,YACxF,UAAW;AAAA,UACf,CAAC,GAAG,aAAa;AACjB,wBAAc,OAAO;AAAA,QACzB;AACA,YAAI,cAAc;AACd,oBAAU,cAAc;AAAA,YACpB,QAAY;AAAA,YACZ,WAAY,GAAG;AAAA,YACf,MAAY;AAAA,UAChB,CAAC;AAAA,QACL;AAAA,MACJ;AACA,SAAG,OAAO,KAAK,WAAW;AAAA,IAC9B;AAAA,EACJ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAWA,iBAAiB,EAAE,QAAQ,QAAQ,OAAO,YAAY,GAAG;AACrD,UAAM,KAAK;AACX,QAAI,OAAO,YAAY;AACnB,YAAM,SAAS;AAAA,QACX,MAAc;AAAA,QACd,aAAc;AAAA,QACd,MAAc;AAAA,QACd,KAAc;AAAA,QACd,QAAc;AAAA,QACd,UAAc,GAAG;AAAA,QACjB,QAAc,MAAM;AAChB,cAAI,MAAM,WAAW,aAAa,EAAE,SAAS;AAC7C,cAAI,CAAC,KAAK;AACN,kBAAM,YAAY;AAAA,UACtB;AACA,aAAG,OAAO,GAAG;AAAA,QACjB;AAAA,MACJ;AAAA,IACJ;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,iBAAiB;AACb,SAAK,OAAO,KAAK,MAAM,OAAO,IAAI;AAAA,EACtC;AAAA;AAEJ;AAAA;AAlZI,cAFiB,QAEV,SAAQ;AACf,cAHiB,QAGV,gBAAe;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMlB,OAAQ;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMR,cAAe;AAAA;AAAA;AAAA;AAAA;AAAA,EAKf,QAAS;AAAA,IACL,IAAiB;AAAA,IACjB,UAAiB;AAAA,IACjB,YAAiB;AAAA,IACjB,gBAAiB;AAAA,EACrB;AACJ;AA2XJ,OAAO,eAAe;AACtB,OAAO,SAAS;AAAU,mBAAmB,gBAAgB,MAAM;;;AChbnE,IAAqB,cAArB,cAAyC,eAAe;AAAA;AAAA,EAEpD,WAAW,QAAQ;AACf,WAAO;AAAA,EACX;AAAA,EACA,WAAW,gBAAgB;AACvB,WAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMH,iBAAkB;AAAA,MAClB,kBAAmB;AAAA,IACvB;AAAA,EACJ;AAAA;AAAA,EAEA,WAAW,eAAe;AACtB,WAAO;AAAA,MACH,QAAS,CAAC,YAAY;AAAA,IAC1B;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,UAAU,MAAM,QAAQ;AACpB,UAAM,UAAU,MAAM,MAAM;AAE5B,SAAK,IAAI;AAAA,MACL,QAAU;AAAA,MACV,SAAU;AAAA,IACd,CAAC;AACD,WAAO,OAAO,MAAM,UAAU,cAAc;AAAA,MACxC,WAAY;AAAA,MACZ,QAAY,KAAK;AAAA,MACjB,WAAY;AAAA,MACZ,UAAY,CAAC;AAAA,QACT,WAAY;AAAA,QACZ,WAAY;AAAA,MAChB,CAAC;AAAA,IACL,CAAC,CAAC;AAEF,SAAK,gBAAgB;AAAA,MACjB,aAA0B;AAAA,MAC1B,WAA0B;AAAA,MAC1B,cAA0B;AAAA,MAC1B,CAAC,KAAK,gBAAgB,GAAI;AAAA,IAC9B;AAAA,EACJ;AAAA,EACA,aAAa;AAET,SAAK,QAAQ,UAAU,IAAI,mBAAmB;AAAA,EAClD;AAAA,EACA,eAAe;AACX,UACI,KAAK,MACL;AAAA,MACI,QAAS;AAAA,MACT;AAAA,MACA;AAAA,IACJ,IAAI,IACJ,eAAgB,UAAU,OAAO,KAAK,aAAa,EAAE,QAAQ,GAC7D,gBAAgB,KAAK,WAAW,SAAS,aAAa,CAAC,GACvD,gBAAgB,kBAAkB,GAAG;AACzC,QAAI,eAAe;AACf,UAAI,eAAe;AACf,YAAI,GAAG,eAAe;AAClB,aAAG,cAAc,UAAU,GAAG,gBAAgB;AAC9C,aAAG,cAAc,UAAU,qBAAqB;AAAA,QACpD;AACA,WAAG,gBAAgB;AACnB,sBAAc,OAAO,GAAG,gBAAgB;AACxC,uBAAe,YAAY;AAC3B,uBAAe,YAAY,GAAG,oBAAoB,CAAC;AAAA,MACvD;AAKA,YAAM,kBAAkB,GAAG,cAAc,SAAS,GAAG,OAAO,WAAW,KAAK,GAAG;AAC/E,SAAG,QAAQ,UAAU,kBAAkB,QAAQ,QAAQ,EAAE,mBAAmB;AAC5E,SAAG,cAAc,kBAAkB,WAAW,WAAW,EAAE,qBAAqB;AAGhF,mBAAa,KAAK,GAAG;AACrB,gBAAU,QAAQ,SAAS,GAAG,UAAU,CAAC,GAAG,EAAE,OAAQ,SAAS,aAAc,aAAa,GAAG,IAAI;AAAA,IACrG;AACA,OAAG,sBAAsB;AAAA,EAC7B;AAAA,EACA,sBAAsB;AAClB,UACI,KAAgB,MAChB;AAAA,MACI;AAAA,MACA;AAAA,IACJ,IAAgB,IAChB,aAAe;AAAA,MACX,qBAAsB;AAAA,IAC1B,GACA,cAAe,CAAC,GAChB,gBAAgB,GAAG,kBAAkB,GAAG,gBAAgB,SAAS,uBAAuB,IACxF,YAAgB,GAAG,cAAc,GAAG,YAAY,CAAC;AAErD,cAAU,QAAQ,OAAK;AACnB,QAAE,UAAU,OAAO,qBAAqB;AAAA,IAC5C,CAAC;AAED,cAAU,SAAS;AACnB,kBAAc,YAAY,WAAS;AAC/B,gBAAU,KAAK,GAAG,MAAM,iBAAiB,GAAG,eAAe,CAAC;AAAA,IAChE,CAAC;AAED,WAAO,cAAc,YAAY;AAC7B,oBAAc,OAAO,cAAc,UAAU;AAAA,IACjD;AACA,OAAG,sBAAsB;AACzB,OAAG,mBAAmB;AAEtB,cAAU,IAAI,OAAK;AAEf,QAAE,QAAQ,cAAc,EAAE,UAAU,QAAQ,SAAO,YAAY,GAAG,IAAI,CAAC;AACvE,QAAE,QAAQ,aAAa,EAAE,UAAU,QAAQ,SAAO,WAAW,GAAG,IAAI,CAAC;AAErE,aAAO,OAAO,aAAa,aAAa;AACxC,aAAO,OAAO,YAAa,aAAa;AACxC,YAAM,OAAO,EAAE;AACf,SAAG,mBAAmB,KAAK,IAAI,GAAG,kBAAkB,IAAI;AAExD,QAAE,MAAM,YAAY;AACpB,SAAG,sBAAsB,KAAK,IAAI,GAAG,qBAAqB,GAAG,cAAc,SAAS,EAAE,YAAY,IAAI;AACtG,QAAE,MAAM,YAAY;AACpB,YAAM,SAAS,EAAE,UAAU,IAAI;AAE/B,QAAE,UAAU,IAAI,qBAAqB;AACrC,oBAAc,YAAY,MAAM;AAChC,aAAO;AAAA,IACX,CAAC;AACD,gBAAY,WAAW,IAAI;AAC3B,cAAU,cAAc,GAAG,gBAAgB,WAAW;AACtD,cAAU,cAAc,GAAG,SAAS,UAAU;AAC9C,WAAO;AAAA,EACX;AACJ;AACA,YAAY,SAAS;AAAe,mBAAmB,gBAAgB,aAAa,KAAK;;;AC3JzF,IAAqB,WAArB,cAAsC,eAAe;AAAA,EAEjD,UAAU,QAAQ,QAAQ;AACtB,UAAM,KAAK;AACX,UAAM,UAAU,QAAQ,MAAM;AAE9B,gBAAY,GAAG;AAAA,MACX,SAAY,OAAO;AAAA,MACnB,SAAY;AAAA,MACZ,MAAY,GAAG;AAAA,MACf,UAAY,GAAG;AAAA,MACf,WAAY,GAAG;AAAA,MACf,WAAY,GAAG;AAAA,IACnB,CAAC;AAAA,EACL;AAAA,EACA,WAAW,UAAU;AACjB,SAAK,OAAO,QAAQ,YAAY;AAAA,MAC5B,MAAO,KAAK;AAAA,MAAM;AAAA,IACtB,CAAC;AAAA,EACL;AAAA,EACA,kBAAkB;AAEd,SAAK,OAAO,QAAQ,UAAU,IAAI,iBAAiB;AAAA,EACvD;AAAA,EACA,eAAe,OAAO;AAClB,UAAM,eAAe;AAAA,EACzB;AAAA,EACA,gBAAgB,OAAO;AACnB,UAAM,EAAE,QAAQ,IAAI,KAAK;AACzB,QAAI,MAAM,iBAAiB,CAAC,QAAQ,SAAS,MAAM,aAAa,GAAG;AAC/D,WAAK,OAAO,QAAQ,UAAU,OAAO,iBAAiB;AAAA,IAC1D;AAAA,EACJ;AAAA,EACA,WAAW,UAAU;AAEjB,aAAS,eAAe;AACxB,UAAM,OAAO,SAAS,aAAa,MAAM,CAAC,EAAE,UAAU;AAStD,SAAK,OAAO,QAAQ,YAAY,EAAE,MAAM,SAAS,CAAC;AAClD,SAAK,gBAAgB,QAAQ;AAAA,EACjC;AACJ;AA/CI,cADiB,UACV,SAAQ;AAgDnB,SAAS,SAAS;AAAY,mBAAmB,gBAAgB,UAAU,OAAO,MAAM;;;ACExF,IAAqB,WAArB,cAAsC,SAAS;AAAA,EAS3C,YAAY;AACR,UAAM,UAAU,GAAG,SAAS;AAC5B,UAAM,WAAW,KAAK,WAAW,KAAK,GAAG,YAAY,IAAI;AACzD,QAAI,CAAC,UAAU;AACX,YAAM,IAAI,MAAM,+CAA+C;AAAA,IACnE;AACA,aAAS,IAAI;AAAA,MACT,OAAU,KAAK;AAAA,MACf,MAAU;AAAA,MACV,SAAU;AAAA,IACd,CAAC;AAAA,EACL;AAAA,EACA,cAAc;AACV,UACI,KAAe,MACf,EAAE,SAAS,IAAI,IACf,EAAE,WAAW,cAAc,IAAI,SAAS;AAC5C,QAAI,CAAC,WAAW;AACZ,YAAM,IAAI,MAAM,8DAA8D;AAAA,IAClF;AACA,kBAAc,sBAAsB;AACpC,OAAG,QAAQ,IAAI,MAAM;AAAA,MACjB,QAAoB,CAAC,OAAO,WAAW;AAAA,MACvC,mBAAoB;AAAA,QAChB,KAAU,GAAG;AAAA,QACb,QAAU,GAAG;AAAA,QACb,SAAU;AAAA,MACd;AAAA,IACJ,CAAC;AACD,aAAS,IAAI;AAAA,MACT,iBAA2B,GAAG;AAAA,MAC9B,0BAA2B,GAAG;AAAA,MAC9B,YAA2B,GAAG;AAAA,MAC9B,iBAA2B,GAAG;AAAA,MAC9B,YAA2B,GAAG;AAAA,MAC9B,SAA2B;AAAA,IAC/B,CAAC;AACD,OAAG,mBAAmB,EAAE,QAAS,UAAU,OAAO,CAAC;AAAA,EACvD;AAAA,EACA,eAAe,EAAE,QAAQ,GAAG;AAvHhC;AAwHQ,UACI,KAAe,MACf,EAAE,SAAS,IAAI;AACnB,QAAI,CAAC,GAAG,SAAS,oBAAkB,wCAAU,OAAV,mBAAc,SAAQ,iBAAiB;AACtE,SAAG,oBAAkC;AACrC,eAAS,SAAS,UAAU,SAAS,GAAG,MAAM,IAAI,CAAC,EAAE,MAAM,MAAM,KAAK;AACtE,SAAG,oBAAkC;AAAA,IACzC;AAAA,EACJ;AAAA,EACA,mBAAmB,EAAE,OAAO,GAAG;AAC3B,QAAI,CAAC,KAAK,mBAAmB;AACzB,UAAI,OAAO,KAAK,WAAS,iBAAiB,YAAY,CAAC,MAAM,SAAS,GAAG;AACrE,cAAM,IAAI,MAAM,wCAAwC;AAAA,MAC5D;AACA,WAAK,MAAM,QAAQ,UAAU,CAAC,GAAG,IAAI,WAAS;AAC1C,gBAAQ,MAAM,aAAa;AAC3B,eAAO,KAAK,SAAS,QAAQ,IAAI,KAAK;AAAA,MAC1C,CAAC;AAAA,IACL;AAAA,EACJ;AAAA,EACA,oBAAoB;AAChB,SAAK,MAAM,IAAI,EAAE,IAAK,eAAe,KAAM,gBAAgB,CAAC;AAAA,EAChE;AAAA,EACA,aAAa,EAAE,SAAS,QAAQ,MAAM,GAAG;AACrC,UAAM,eAAe,MAAM,OAAO,QAAQ,aAAa;AACvD,QAAI,cAAc;AACd,cAAQ,QAAQ;AAAA,IACpB;AAAA,EACJ;AAAA,EACA,2BAA2B,EAAE,QAAQ,MAAM,GAAG;AAC1C,UAAM,oBAAoB,MAAM,OAAO,QAAQ,aAAa;AAC5D,QAAI,mBAAmB;AACnB,UAAI,CAAC,OAAO,cAAc;AACtB,aAAK,MAAM,QAAQ,aAAa,EAAE,OAAO;AACzC,aAAK,MAAM,IAAI,MAAM;AAAA,MACzB;AAAA,IACJ;AAAA,EACJ;AAAA,EACA,eAAe;AA9JnB;AA+JQ,eAAK,MAAM,QAAQ,aAAa,MAAhC,mBAAmC;AAAA,EACvC;AACJ;AAzFI,cADiB,UACV,QAAQ;AACf,cAFiB,UAEV,SAAQ;AACf,cAHiB,UAGV,gBAAe;AAAA,EAClB,aAAc;AAAA,EACd,QAAQ,QAAQ;AACZ,WAAO,aAAa,WAAW,aAAa,WAAW,OAAO,SAAS,KAAK,YAAY,CAAC,CAAC;AAAA,EAC9F;AACJ;AAmFJ,SAAS,UAAU;AACnB,SAAS,SAAS;;;ACpGlB,IAAqB,YAArB,cAAuC,MAAM;AAAA,EAuBzC,aAAa,QAAQ,WAAW;AAC5B,aAAS,MAAM,aAAa,QAAQ,SAAS;AAC7C,qCAAQ,IAAI;AAAA,MACR,iBAAkB;AAAA,MAClB,SAAkB;AAAA,IACtB;AACA,WAAO;AAAA,EACX;AAAA,EACA,kBAAkB,aAAa;AAC3B,UAAM,kBAAkB,GAAG,SAAS;AACpC,SAAK,OAAO,cAAc,cAAc;AAAA,EAC5C;AAAA,EACA,eAAe,UAAU;AACrB,UAAM,eAAe,GAAG,SAAS;AACjC,SAAK,OAAO,WAAW;AAAA,EAC3B;AAAA,EACA,IAAI,QAAQ;AACR,WAAO,MAAM;AAAA,EACjB;AAAA,EACA,IAAI,MAAM,OAAO;AAzGrB;AA2GQ,SAAK,gBAAgB;AACrB,UAAM,QAAQ;AAEd,SAAK,OAAO,oBAAkB,WAAM,QAAN,+BAAY,SAAO,KAAK,MAAM,QAAQ,GAAG,OAAM,CAAC;AAC9E,SAAK,gBAAgB;AAAA,EACzB;AAAA,EACA,wBAAwB,EAAE,UAAU,GAAG;AAEnC,QAAI,CAAC,KAAK,eAAe;AACrB,WAAK,QAAQ;AAAA,IACjB;AAAA,EACJ;AACJ;AAvDI,cADiB,WACV,SAAQ;AACf,cAFiB,WAEV,QAAO;AACd,cAHiB,WAGV,gBAAe;AAAA,EAClB,aAAc;AAAA,EACd,QAAc;AAAA,IACV,MAA6B;AAAA,IAC7B,UAA6B;AAAA,IAC7B,4BAA6B;AAAA,IAC7B,eAA6B;AAAA,MACzB,KAAuB;AAAA,MACvB,sBAAuB;AAAA,IAC3B;AAAA,EACJ;AAAA,EACA,UAAW;AAAA,IACP,QAAQ,QAAQ;AACZ,aAAO,aAAa,MAAM,OAAO,IAAI;AAAA,IACzC;AAAA,IACA,YAAa;AAAA,MACT,WAAY;AAAA,IAChB;AAAA,EACJ;AACJ;AAmCJ,UAAU,UAAU;AACpB,UAAU,SAAS;;;CChBlB,MAAM;AAEH,QACI,QAAmB;AAAA,IACf;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ,GACA,UAAmB,MAAO,KAAK,KAAK,IACpC,mBAAmB,CAAC,GACpB,YAAY,cAAc,MAAM;AACpC,MAAI,CAAC,cAAc,cAAc,MAAM,KAAK,UAAQ,SAAS,KAAK,SAAS,IAAI,CAAC,KAAK,SAAS,KAAK,SAAS,IAAI,IAAI;AAChH;AAAA,EACJ;AACA,MAAI;AACJ,WAAS,iBAAiB,OAAO,WAAW;AACxC,QAAI,CAAC,aAAa;AACd,oBAAc;AACd,mBAAa,UAAU;AAAA,QACnB,QAAS;AAAA,MACb,CAAC;AAAA,IACL;AAEA,UAAM,QAAQ;AAAA,EAClB;AAAA,EAGA,MAAM,aAAa;AAAA,IACf,OAAO,UAAU,QAAQ;AACrB,YACI,KAAgB,MAChB,UAAgB,aAChB,cAAgB,aAChB,UAAgB,cAAc,WAAW,OAAO,GAChD,gBAAgB,cAAc,YAAY,MAAO,MAAO,IACxD,WAAgB,cAAc,YAAY;AAC9C,aAAO,OAAO,IAAI;AAAA,QACd;AAAA,QACA;AAAA,QACA,SAAmB;AAAA,QACnB,WAAmB,cAAc,YAAY,WAAW;AAAA,QACxD,SAAmB;AAAA,QACnB,kBAAmB;AAAA,QACnB,UAAmB,KAAK,OAAO;AAAA,QAC/B,iBAAmB,KAAK,OAAO;AAAA,MACnC,GAAG,MAAM;AACT,UAAI,CAAC,cAAc,WAAW;AAC1B,gBAAQ,IAAI,WAAW,WAAW,gBAAgB;AAAA,MACtD;AACA,SAAG,oBAAoB;AACvB,UAAI,GAAG,WAAW;AACd,YAAI,SAAS,eAAe,YAAY;AACpC,aAAG,eAAe;AAAA,QACtB,OACK;AACD,mBAAS,iBAAiB,oBAAoB,MAAM;AAChD,gBAAI,SAAS,eAAe,YAAY;AACpC,iBAAG,eAAe;AAAA,YACtB;AAAA,UACJ,CAAC;AAAA,QACL;AAAA,MACJ;AAGA,iBAAW,MAAM;AACb,WAAG,oBAAoB;AAAA,MAC3B,GAAG,aAAa;AAAA,IACpB;AAAA,IACA,OAAO,sBAAsB;AACzB,YACI,KAAa,MACb,aAAa,cAAc,oBAAoB,GAAG,QAAQ,GAC1D,OAAa,OAAO,UAAU;AAClC,UAAI,QAAQ,CAAC,MAAM,IAAI,GAAG;AACtB,WAAG,iBAAiB;AAAA,MACxB;AACA,SAAG,iBAAiB,GAAG,kBAAkB,KAAK,IAAI;AAElD,oBAAc,oBAAoB,GAAG,UAAU,GAAG,cAAc;AAAA,IACpE;AAAA,IACA,WAAW,YAAY;AAlM/B;AAmMY,aAAO,KAAK,WAAY,KAAK,IAAI,IAAI,KAAK,iBAAiB,UAAU,QAAO,kBAAO,YAAP,mBAAiB,KAAK,aAAtB,mBAAgC;AAAA,IAChH;AAAA,IACA,OAAO,sBAAsB;AACzB,YACI,KAAsB,MACtB,sBAAsB,MAAM,cAAc,oBAAoB,GAAG,iBAAiB,KAAK,IAAI,CAAC;AAChG,SAAG,mBAAmB,GAAG,oBAAoB,cAAc,oBAAoB,GAAG,eAAe,KAAK;AAEtG,UAAI,GAAG,oBAAoB,KAAK,IAAI,IAAI,GAAG,mBAAmB,SAAS;AACnE;AAAA,MACJ;AACA,UAAI,GAAG,WAAW;AACd,cACI,MAAS,mBAAmB,SAAS,IAAI,GACzC,SAAS,GAAG,GAAG,SAAS,OAAO,OAAO,QAAQ,OAAO,QAAQ,GAAG,IAChE,MAAS,IAAI,MAAM;AACvB,YAAI,SAAS,MAAM;AAEf,cAAI,IAAI,iBAAiB,GAAG;AACxB,eAAG,WAAW;AAAA,UAClB,OACK;AAED,gCAAoB;AAAA,UACxB;AAAA,QACJ;AACA,YAAI,UAAU,MAAM;AAChB,8BAAoB;AAAA,QACxB;AACA,YAAI,MAAM;AAAA,MACd,OACK;AACD,4BAAoB;AAAA,MACxB;AAAA,IACJ;AAAA,IACA,OAAO,iBAAiB;AACpB,YAAM,SAAS,KAAK,OAAO;AAC3B,UAAI,CAAC,KAAK,iBAAiB;AACvB,aAAK,kBAAkB;AACvB,YAAI,CAAC,cAAc,WAAW;AAC1B,kBAAQ,KAAK,WAAW,KAAK,OAAO,8IAA8I;AAAA,QACtL;AACA,eAAO,aAAa,MAAM,KAAK;AAAA,UAC3B,MAAc,sBAAsB,KAAK,OAAO;AAAA,UAChD,SAAc;AAAA,UACd,aAAc;AAAA,QAClB,CAAC;AAAA,MACL;AACA,gBAAU,mBAAmB,QAAQ,mBAAmB;AACxD,gBAAU,gBAAgB,QAAQ,gBAAgB,aAAW;AACzD,cAAM,SAAS,OAAO,YAAY,SAAS,QAAQ;AACnD,YAAI,iBAAiB,KAAK,SAAO,kBAAkB,GAAG,GAAG;AACrD,eAAK,kBAAkB,MAAM;AAAA,QACjC;AAAA,MACJ,CAAC;AAAA,IACL;AAAA,IACA,OAAO,aAAa;AAChB,WAAK,UAAU;AAEf,oBAAc,uBAAuB,KAAK,eAAe;AAEzD,oBAAc,oBAAoB,KAAK,UAAU,CAAC;AAClD,WAAK,eAAe;AAAA,IACxB;AAAA,IACA,OAAO,kBAAkB,QAAQ;AAC7B,aAAO,KAAK;AAAA,QACR,MAAQ;AAAA,QACR,MAAQ;AAAA,QACR,MAAQ;AAAA,QACR,OAAQ;AAAA,MACZ,CAAC;AAAA,IACL;AAAA,IACA,OAAO,aAAa,SAAS;AAAA,MACzB,YAAY;AAAA,MACZ,aAAa;AAAA,IACjB,IAAI,CAAC,GAAG;AA9QhB;AAgRY,UAAI,cAAc,YAAY,SAAS,MAAM;AACzC;AAAA,MACJ;AACA,YACI,UAAY,qBAAU,cAAV,mBAAqB,SAArB,mBAA2B,cAAc,SAAS,YAAW,YAAY,YACrF,YAAY;AAAA,sLAC0J,KAAK;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAY/K,cAAQ,MAAM,kBAAkB,kCAAkC,OAAO,KAAK,SAAS,CAAC;AAAA,IAC5F;AAAA,EACJ;AAGA,QAAM,oBAAoB,eAAa;AACnC,qBAAiB,KAAK,SAAS;AAC/B,aAAS,MAAM,MAAM;AAAA,MACjB,WAAW,SAAS;AAChB,eAAO;AAAA,UACH,OAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA,kBAAkB;AACd,cACI,KAAgB,MAChB,gBAAgB,MAAM;AAClB,gBAAM,UAAU,GAAG,WAAW,OAAO,OAAO,GAAG,QAAQ,IAAI,CAAC,EAAE;AAC9D,qBAAW,UAAU,SAAS;AAC1B,gBAAI,OAAO,SAAS;AAChB,2BAAa,aAAa,OAAO,OAAO;AAAA,YAC5C;AAAA,UACJ;AAAA,QACJ;AACJ,yBAAiB,IAAI,SAAS;AAC9B,sBAAc;AAEd,6BAAa,GAAG,SAAS,MAAM;AAC3B,wBAAc;AAAA,QAClB,CAAC;AACD,YAAI,aAAa,WAAW;AACxB,uBAAa,kBAAkB,EAAE;AAAA,QACrC;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AAEA,MAAI,OAAO,aAAa,aAAa;AACjC,sBAAkB,QAAQ;AAC1B,aAAS,MAAM,MAAM;AAAA,MACjB,WAAW,SAAS;AAChB,eAAO;AAAA,UACH,OAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA,gBAAgB;AA/U5B;AAgVgB,YAAI,CAAC,aAAa,eAAa,UAAK,SAAL,mBAAW,cAAa;AACnD,eAAK,YAAY,cAAc,MAAM,MAAM,SAAS;AAAA,QACxD;AAAA,MACJ;AAAA,MACA,aAAa;AApVzB;AAqVgB,YAAI,CAAC,aAAa,eAAa,UAAK,SAAL,mBAAW,cAAa;AACnD,eAAK,YAAY,WAAW,MAAM,MAAM,SAAS;AAAA,QACrD;AAAA,MACJ;AAAA,MACA,gBAAgB;AAzV5B;AA0VgB,YAAI,CAAC,aAAa,eAAa,UAAK,SAAL,mBAAW,cAAa;AACnD,eAAK,YAAY,cAAc,MAAM,MAAM,SAAS;AAAA,QACxD;AAAA,MACJ;AAAA,IACJ,CAAC;AAAA,EACL;AACJ,GAAG;AAAA,CACF,MAAM;AAEH,QAAM,iBAAiB;AAEvB,MAAI,CAAC,SAAS,YAAY,eAAe,KAAK,SAAS,SAAS,IAAI,KAAK,OAAO,QAAQ,QAAQ;AAC5F;AAAA,EACJ;AACA,MAAI;AACJ,QAAM,cAAc;AAAA,IAChB;AAAA,IACA;AAAA,EACJ;AACA,QACI,WAAa,CAAC,YAAY,QAAQ,SAAS,aAAa,gBAAgB,WAAW,GACnF,aAAa,CAAC,WAAW,SAAS,OAAO,OAAO;AACpD,cAAY,OAAO,GAAG,GAAG,GAAG,SAAS,IAAI,UAAQ,WAAW,IAAI,eAAa,GAAG,SAAS,IAAI,IAAI,EAAE,CAAC,EAAE,OAAO,aAAa,EAAE,KAAK,CAAC;AAClI,MAAI,SAAS,SAAS,KAAK,MAAM,YAAY,KAAK,GAAG,CAAC,GAAG;AACrD,SAAK;AAAA,EACT,OACK;AACD,SAAK;AAAA,EACT;AACA,QAAM,YAAY,SAAS,cAAc,QAAQ;AACjD,YAAU,SAAS,WAAW;AAC1B,WAAO,YAAY,OAAO,aAAa,CAAC;AACxC,aAAS,OAAO;AACZ,aAAO,UAAU,KAAK,SAAS;AAAA,IACnC;AACA,SAAK,MAAM,oBAAI,KAAK,CAAC;AACrB,SAAK,UAAU,EAAE;AAAA,EACrB;AACA,WAAS,KAAK,YAAY,SAAS;AACnC,YAAU,MAAM,iDAAiD;AACrE,GAAG;",
  "names": ["_a", "actions", "_a", "actions", "actions", "height", "_a", "_b", "actions", "_a"]
}
