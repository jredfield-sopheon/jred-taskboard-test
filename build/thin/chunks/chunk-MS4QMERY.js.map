{
  "version": 3,
  "sources": ["../../../../Scheduler/lib/Scheduler/preset/ViewPreset.js", "../../../../Scheduler/lib/Scheduler/localization/En.js", "../../../../Scheduler/lib/Scheduler/preset/PresetStore.js", "../../../../Scheduler/lib/Scheduler/preset/PresetManager.js", "../../../../Scheduler/lib/Scheduler/data/TimeAxis.js", "../../../../Scheduler/lib/Scheduler/view/model/TimeAxisViewModel.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineDateMapper.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineDomEvents.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineViewPresets.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineZoomable.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/RecurrenceConfirmationPopup.js", "../../../../Scheduler/lib/Scheduler/view/mixin/RecurringEvents.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineEventRendering.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineScroll.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineState.js", "../../../../Scheduler/lib/Scheduler/view/Header.js", "../../../../Scheduler/lib/Scheduler/view/TimeAxisSubGrid.js", "../../../../Scheduler/lib/Scheduler/view/TimelineBase.js", "../../../../Scheduler/lib/Scheduler/view/mixin/Describable.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerDom.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerDomEvents.js", "../../../../Scheduler/lib/Scheduler/eventlayout/HorizontalLayout.js", "../../../../Scheduler/lib/Scheduler/eventlayout/HorizontalLayoutStack.js", "../../../../Scheduler/lib/Scheduler/eventlayout/PackMixin.js", "../../../../Scheduler/lib/Scheduler/eventlayout/HorizontalLayoutPack.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerResourceRendering.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerEventRendering.js", "../../../../Scheduler/lib/Scheduler/data/mixin/ProjectConsumer.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerStores.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerScroll.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerRegions.js", "../../../../Scheduler/lib/Scheduler/view/mixin/SchedulerState.js", "../../../../Scheduler/lib/Scheduler/view/mixin/EventSelection.js", "../../../../Scheduler/lib/Scheduler/view/mixin/EventNavigation.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TransactionalFeatureMixin.js", "../../../../Scheduler/lib/Scheduler/data/mixin/AttachToProjectMixin.js", "../../../../Scheduler/lib/Scheduler/view/orientation/HorizontalRendering.js", "../../../../Scheduler/lib/Scheduler/eventlayout/VerticalLayout.js", "../../../../Scheduler/lib/Scheduler/view/orientation/VerticalRendering.js", "../../../../Scheduler/lib/Scheduler/view/TimeAxisBase.js", "../../../../Scheduler/lib/Scheduler/view/HorizontalTimeAxis.js", "../../../../Scheduler/lib/Scheduler/view/ResourceHeader.js", "../../../../Scheduler/lib/Scheduler/column/TimeAxisColumn.js", "../../../../Scheduler/lib/Scheduler/view/VerticalTimeAxis.js", "../../../../Scheduler/lib/Scheduler/column/VerticalTimeAxisColumn.js", "../../../../Scheduler/lib/Scheduler/view/mixin/CurrentConfig.js", "../../../../Scheduler/lib/Scheduler/view/SchedulerBase.js", "../../../../Scheduler/lib/Scheduler/widget/EventColorPicker.js", "../../../../Scheduler/lib/Scheduler/tooltip/ClockTemplate.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/TaskEditStm.js", "../../../../Scheduler/lib/Scheduler/feature/base/TimeSpanMenuBase.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceFrequencyCombo.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceDaysCombo.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceDaysButtonGroup.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceMonthDaysButtonGroup.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceMonthsButtonGroup.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceStopConditionCombo.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrencePositionsCombo.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/RecurrenceEditorPanel.js", "../../../../Scheduler/lib/Scheduler/widget/EventColorField.js", "../../../../Scheduler/lib/Scheduler/feature/EventMenu.js", "../../../../Scheduler/lib/Scheduler/feature/ScheduleMenu.js"],
  "sourcesContent": ["import Model from '../../Core/data/Model.js';\nimport IdHelper from '../../Core/helper/IdHelper.js';\nimport DH from '../../Core/helper/DateHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n/**\n * @module Scheduler/preset/ViewPreset\n */\n/**\n * An object containing a unit identifier and an increment variable, used to define the `timeResolution` of a\n * `ViewPreset`.\n * @typedef {Object} ViewPresetTimeResolution\n * @property {String} unit The unit of the resolution, e.g. 'minute'\n * @property {Number} increment The increment of the resolution, e.g. 15\n */\n/**\n * Defines a header level for a ViewPreset.\n *\n * A sample header configuration can look like below\n * ```javascript\n * headers    : {\n *     {\n *         unit        : \"month\",\n *         renderer : function(start, end, headerConfig, index) {\n *             var month = start.getMonth();\n *             // Simple alternating month in bold\n *             if (start.getMonth() % 2) {\n *                 return '<strong>' + month + '</strong>';\n *             }\n *             return month;\n *         },\n *         align       : 'start' // `start` or `end`, omit to center content (default)\n *     },\n *     {\n *         unit        : \"week\",\n *         increment   : 1,\n *         renderer    : function(start, end, headerConfig, index) {\n *             return 'foo';\n *         }\n *     },\n * }\n * ```\n *\n * @typedef {Object} ViewPresetHeaderRow\n * @property {'start'|'center'|'end'} align The text alignment for the cell. Valid values are `start` or `end`, omit\n * this to center text content (default). Can also be added programmatically in `the renderer`.\n * @property {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} unit The unit of time\n * represented by each cell in this header row. See also increment property. Valid values are \"millisecond\", \"second\",\n * \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n * @property {String} headerCellCls A CSS class to add to the cells in the time axis header row. Can also be added\n * programmatically in the `renderer`.\n * @property {Number} increment The number of units each header cell will represent (e.g. 30 together with unit:\n * \"minute\" for 30 minute cells)\n * @property {String} dateFormat Defines how the cell date will be formatted\n * @property {Function} renderer A custom renderer function used to render the cell content. It should return text/HTML\n * to put in the header cell.\n *\n * ```javascript\n * function (startDate, endDate, headerConfig, i) {\n *   // applies special CSS class to align header left\n *   headerConfig.align = \"start\";\n *   // will be added as a CSS class of the header cell DOM element\n *   headerConfig.headerCellCls = \"myClass\";\n *\n *   return DateHelper.format(startDate, 'YYYY-MM-DD');\n * }\n * ```\n *\n * The render function is called with the following parameters:\n *\n * @property {Date} renderer.startDate The start date of the cell.\n * @property {Date} renderer.endDate The end date of the cell.\n * @property {Object} renderer.headerConfig An object containing the header config.\n * @property {'start'|'center'|'end'} [renderer.headerConfig.align] The text alignment for the cell. See `align` above.\n * @property {String} [renderer.headerConfig.headerCellCls] A CSS class to add to the cells in the time axis header row.\n * See `headerCellCls` above.\n * @property {Number} renderer.index The index of the cell in the row.\n * @property {Object} thisObj `this` reference for the renderer function\n * @property {Function} cellGenerator A function that should return an array of objects containing 'start', 'end' and\n * 'header' properties. Use this if you want full control over how the header rows are generated.\n *\n * **Note:** `cellGenerator` cannot be used for the bottom level of your headers.\n *\n * Example :\n * ```javascript\n * viewPreset : {\n *     displayDateFormat : 'H:mm',\n *     shiftIncrement    : 1,\n *     shiftUnit         : 'WEEK',\n *     timeResolution    : {\n *         unit      : 'MINUTE',\n *         increment : 10\n *     },\n *     headers           : [\n *         {\n *             unit          : 'year',\n *             // Simplified scenario, assuming view will always just show one US fiscal year\n *             cellGenerator : (viewStart, viewEnd) => [{\n *                 start  : viewStart,\n *                 end    : viewEnd,\n *                 header : `Fiscal Year ${viewStart.getFullYear() + 1}`\n *             }]\n *         },\n *         {\n *             unit : 'quarter',\n *             renderer(start, end, cfg) {\n *                 const\n *                     quarter       = Math.floor(start.getMonth() / 3) + 1,\n *                     fiscalQuarter = quarter === 4 ? 1 : (quarter + 1);\n *\n *                 return `FQ${fiscalQuarter} ${start.getFullYear() + (fiscalQuarter === 1 ? 1 : 0)}`;\n *             }\n *         },\n *         {\n *             unit       : 'month',\n *             dateFormat : 'MMM Y'\n *         }\n *     ]\n *  },\n * ```\n */\n/**\n * A ViewPreset is a record of {@link Scheduler.preset.PresetStore PresetStore} which describes the granularity\n * of the timeline view of a {@link Scheduler.view.Scheduler Scheduler} and the layout and subdivisions of the timeline header.\n *\n * You can create a new instance by specifying all fields:\n *\n * ```javascript\n * const myViewPreset = new ViewPreset({\n *     id   : 'myPreset',              // Unique id value provided to recognize your view preset. Not required, but having it you can simply set new view preset by id: scheduler.viewPreset = 'myPreset'\n *\n *     name : 'My view preset',        // A human-readable name provided to be used in GUI, e.i. preset picker, etc.\n *\n *     tickWidth  : 24,                // Time column width in horizontal mode\n *     tickHeight : 50,                // Time column height in vertical mode\n *     displayDateFormat : 'HH:mm',    // Controls how dates will be displayed in tooltips etc\n *\n *     shiftIncrement : 1,             // Controls how much time to skip when calling shiftNext and shiftPrevious.\n *     shiftUnit      : 'day',         // Valid values are 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'.\n *     defaultSpan    : 12,            // By default, if no end date is supplied to a view it will show 12 hours\n *\n *     timeResolution : {              // Dates will be snapped to this resolution\n *         unit      : 'minute',       // Valid values are 'millisecond', 'second', 'minute', 'hour', 'day', 'week', 'month', 'quarter', 'year'.\n *         increment : 15\n *     },\n *\n *     headers : [                     // This defines your header rows from top to bottom\n *         {                           // For each row you can define 'unit', 'increment', 'dateFormat', 'renderer', 'align', and 'thisObj'\n *             unit       : 'day',\n *             dateFormat : 'ddd DD/MM'\n *         },\n *         {\n *             unit       : 'hour',\n *             dateFormat : 'HH:mm'\n *         }\n *     ],\n *\n *     columnLinesFor : 1              // Defines header level column lines will be drawn for. Defaults to the last level.\n * });\n * ```\n *\n * Or you can extend one of view presets registered in {@link Scheduler.preset.PresetManager PresetManager}:\n *\n * ```javascript\n * const myViewPreset2 = new ViewPreset({\n *     id   : 'myPreset',                  // Unique id value provided to recognize your view preset. Not required, but having it you can simply set new view preset by id: scheduler.viewPreset = 'myPreset'\n *     name : 'My view preset',            // A human-readable name provided to be used in GUI, e.i. preset picker, etc.\n *     base : 'hourAndDay',                // Extends 'hourAndDay' view preset provided by PresetManager. You can pick out any of PresetManager's view presets: PresetManager.records\n *\n *     timeResolution : {                  // Override time resolution\n *         unit      : 'minute',\n *         increment : 15                  // Make it increment every 15 mins\n *     },\n *\n *     headers : [                         // Override headers\n *         {\n *             unit       : 'day',\n *             dateFormat : 'DD.MM.YYYY'   // Use different date format for top header 01.10.2020\n *         },\n *         {\n *             unit       : 'hour',\n *             dateFormat : 'LT'\n *         }\n *     ]\n * });\n * ```\n *\n * See {@link Scheduler.preset.PresetManager PresetManager} for the list of base presets. You may add your own\n * presets to this global list:\n *\n * ```javascript\n * PresetManager.add(myViewPreset);     // Adds new preset to the global scope. All newly created scheduler instances will have it too.\n *\n * const scheduler = new Scheduler({\n *     viewPreset : 'myPreset'\n *     // other configs...\n * });\n * ```\n *\n * Or add them on an individual basis to Scheduler instances:\n *\n * ```javascript\n * const scheduler = new Scheduler({...});\n *\n * scheduler.presets.add(myViewPreset); // Adds new preset to the scheduler instance only. All newly created scheduler instances will **not** have it.\n *\n * scheduler.viewPreset = 'myPreset';\n * ```\n *\n * ## Defining custom header rows\n *\n * You can have any number of header rows by specifying {@link #field-headers}, see {@link #typedef-ViewPresetHeaderRow}\n * for the config object format and {@link Core.helper.DateHelper} for the supported date formats, or use to render\n * custom contents into the row cells.\n *\n * ```javascript\n *  headers : [\n *      {\n *          unit       : 'month',\n *          dateFormat : 'MM.YYYY'\n *      },\n *      {\n *          unit       : 'week',\n *          renderer   : ({ startDate }) => `Week ${DateHelper.format(startDate, 'WW')}`\n *      }\n *  ]\n * ```\n *\n * {@inlineexample Scheduler/preset/CustomHeader.js}\n *\n * This live demo shows a custom ViewPreset with AM/PM time format:\n * {@inlineexample Scheduler/preset/amPmPreset.js}\n *\n * @extends Core/data/Model\n */\nexport default class ViewPreset extends Model {\n    static $name = 'ViewPreset';\n    static get fields() {\n        return [\n            /**\n             * The name of an existing view preset to extend\n             * @field {String} base\n             */\n            { name : 'base', type : 'string' },\n            /**\n             * The name of the view preset\n             * @field {String} name\n             */\n            { name : 'name', type : 'string' },\n            /**\n             * The height of the row in horizontal orientation\n             * @field {Number} rowHeight\n             * @default\n             */\n            {\n                name         : 'rowHeight',\n                defaultValue : 24\n            },\n            /**\n             * The width of the time tick column in horizontal orientation\n             * @field {Number} tickWidth\n             * @default\n             */\n            {\n                name         : 'tickWidth',\n                defaultValue : 50\n            },\n            /**\n             * The height of the time tick column in vertical orientation\n             * @field {Number} tickHeight\n             * @default\n             */\n            {\n                name         : 'tickHeight',\n                defaultValue : 50\n            },\n            /**\n             * Defines how dates will be formatted in tooltips etc\n             * @field {String} displayDateFormat\n             * @default\n             */\n            {\n                name         : 'displayDateFormat',\n                defaultValue : 'HH:mm'\n            },\n            /**\n             * The unit to shift when calling shiftNext/shiftPrevious to navigate in the chart.\n             * Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n             * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} shiftUnit\n             * @default\n             */\n            {\n                name         : 'shiftUnit',\n                defaultValue : 'hour'\n            },\n            /**\n             * The amount to shift (in shiftUnits)\n             * @field {Number} shiftIncrement\n             * @default\n             */\n            {\n                name         : 'shiftIncrement',\n                defaultValue : 1\n            },\n            /**\n             * The amount of time to show by default in a view (in the unit defined by {@link #field-mainUnit})\n             * @field {Number} defaultSpan\n             * @default\n             */\n            {\n                name         : 'defaultSpan',\n                defaultValue : 12\n            },\n            /**\n             * Initially set to a unit. Defaults to the unit defined by the middle header.\n             * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} mainUnit\n             */\n            {\n                name : 'mainUnit'\n            },\n            /**\n             * Note: Currently, this field only applies when changing viewPreset with the {@link Scheduler.widget.ViewPresetCombo}.\n             *\n             * Set to a number and that amount of {@link #field-mainUnit} will be added to the startDate. For example: A\n             * start value of `5` together with the mainUnit `hours` will add 5 hours to the startDate. This can achieve\n             * a \"day view\" that starts 5 AM.\n             *\n             * Set to a string unit (for example week, day, month) and the startDate will be the start of that unit\n             * calculated from current startDate. A start value of `week` will result in a startDate in the first day of\n             * the week.\n             *\n             * If set to a number or not set at all, the startDate will be calculated at the beginning of current\n             * mainUnit.\n             * @field {Number|String} start\n             */\n            {\n                name : 'start'\n            },\n            /**\n             * An object containing a unit identifier and an increment variable. This value means minimal task duration\n             * you can create using UI. For example when you drag create a task or drag & drop a task, if increment is 5\n             * and unit is 'minute' that means that you can create a 5-minute-long task, or move it 5 min\n             * forward/backward. This config maps to scheduler's\n             * {@link Scheduler.view.mixin.TimelineDateMapper#property-timeResolution} config.\n             *\n             * ```javascript\n             * timeResolution : {\n             *   unit      : 'minute',  //Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n             *   increment : 5\n             * }\n             * ```\n             *\n             * @field {ViewPresetTimeResolution} timeResolution\n             */\n            'timeResolution',\n            /**\n             * An array containing one or more {@link #typedef-ViewPresetHeaderRow} config objects, each of\n             * which defines a level of headers for the scheduler.\n             * The `main` unit will be the last header's unit, but this can be changed using the\n             * {@link #field-mainHeaderLevel} field.\n             * @field {ViewPresetHeaderRow[]} headers\n             */\n            'headers',\n            /**\n             * Index of the {@link #field-headers} array to define which header level is the `main` header.\n             * Defaults to the bottom header.\n             * @field {Number} mainHeaderLevel\n             */\n            'mainHeaderLevel',\n            /**\n             * Index of a header level in the {@link #field-headers} array for which column lines are drawn. See\n             * {@link Scheduler.feature.ColumnLines}.\n             * Defaults to the bottom header.\n             * @field {Number} columnLinesFor\n             */\n            'columnLinesFor'\n        ];\n    }\n    construct() {\n        super.construct(...arguments);\n        this.normalizeUnits();\n    }\n    generateId(owner) {\n        const\n            me    = this,\n            {\n                headers\n            }     = me,\n            parts = [];\n        // If we were subclassed from a base, use that id as the basis of our.\n        let result = Object.getPrototypeOf(me.data).id;\n        if (!result) {\n            for (let { length } = headers, i = length - 1; i >= 0; i--) {\n                const\n                    { unit, increment } = headers[i],\n                    multiple            = increment > 1;\n                parts.push(`${multiple ? increment : ''}${i ? unit : StringHelper.capitalize(unit)}${multiple ? 's' : ''}`);\n            }\n            // Use upwards header units so eg \"monthAndYear\"\n            result = parts.join('And');\n        }\n        // If duplicate, decorate the generated by adding details.\n        // For example make it \"hourAndDay-50by80\"\n        // Only interrogate the store if it is loaded. If consulted during\n        // a load, the idMap will be created empty\n        if (owner.count && owner.includes(result)) {\n            result += `-${me.tickWidth}by${me.tickHeight || me.tickWidth}`;\n            // If still duplicate use increment\n            if (owner.includes(result)) {\n                result += `-${me.bottomHeader.increment}`;\n                // And if STILL duplicate, make it unique with a suffix\n                if (owner.includes(result)) {\n                    result = IdHelper.generateId(`${result}-`);\n                }\n            }\n        }\n        return result;\n    }\n    normalizeUnits() {\n        const\n            me                                     = this,\n            { timeResolution, headers, shiftUnit } = me;\n        if (headers) {\n            // Make sure date \"unit\" constant specified in the preset are resolved\n            for (let i = 0, { length } = headers; i < length; i++) {\n                const header = headers[i];\n                header.unit = DH.normalizeUnit(header.unit);\n                if (header.splitUnit) {\n                    header.splitUnit = DH.normalizeUnit(header.splitUnit);\n                }\n                if (!('increment' in header)) {\n                    headers[i] = Object.assign({\n                        increment : 1\n                    }, header);\n                }\n            }\n        }\n        if (timeResolution) {\n            timeResolution.unit = DH.normalizeUnit(timeResolution.unit);\n        }\n        if (shiftUnit) {\n            me.shiftUnit = DH.normalizeUnit(shiftUnit);\n        }\n    }\n    // Process legacy columnLines config into a headers array.\n    static normalizeHeaderConfig(data) {\n        const\n            { headerConfig, columnLinesFor, mainHeaderLevel } = data,\n            headers                                           = data.headers = [];\n        if (headerConfig.top) {\n            if (columnLinesFor === 'top') {\n                data.columnLinesFor = 0;\n            }\n            if (mainHeaderLevel === 'top') {\n                data.mainHeaderLevel = 0;\n            }\n            headers[0] = headerConfig.top;\n        }\n        if (headerConfig.middle) {\n            if (columnLinesFor === 'middle') {\n                data.columnLinesFor = headers.length;\n            }\n            if (mainHeaderLevel === 'middle') {\n                data.mainHeaderLevel = headers.length;\n            }\n            headers.push(headerConfig.middle);\n        }\n        else {\n            throw new Error('ViewPreset.headerConfig must be configured with a middle');\n        }\n        if (headerConfig.bottom) {\n            // Main level is middle when using headerConfig object.\n            data.mainHeaderLevel = headers.length - 1;\n            // There *must* be a middle above this bottom header\n            // so that is the columnLines one by default.\n            if (columnLinesFor == null) {\n                data.columnLinesFor = headers.length - 1;\n            }\n            else if (columnLinesFor === 'bottom') {\n                data.columnLinesFor = headers.length;\n            }\n            // There *must* be a middle above this bottom header\n            // so that is the main one by default.\n            if (mainHeaderLevel == null) {\n                data.mainHeaderLevel = headers.length - 1;\n            }\n            if (mainHeaderLevel === 'bottom') {\n                data.mainHeaderLevel = headers.length;\n            }\n            headers.push(headerConfig.bottom);\n        }\n    }\n    // These are read-only once configured.\n    set() {}\n    inSet() {}\n    get columnLinesFor() {\n        return ('columnLinesFor' in this.data) ? this.data.columnLinesFor : this.headers.length - 1;\n    }\n    get tickSize() {\n        return this._tickSize || this.tickWidth;\n    }\n    get tickWidth() {\n        return ('tickWidth' in this.data) ? this.data.tickWidth : 50;\n    }\n    get tickHeight() {\n        return ('tickHeight' in this.data) ? this.data.tickHeight : 50;\n    }\n    get headerConfig() {\n        // Configured in the legacy manner, just return the configured value.\n        if (this.data.headerConfig) {\n            return this.data.headerConfig;\n        }\n        // Rebuild the object based upon the configured headers array.\n        const\n            result      = {},\n            { headers } = this,\n            { length }  = headers;\n        switch (length) {\n            case 1 :\n                result.middle = headers[0];\n                break;\n            case 2:\n                if (this.mainHeaderLevel === 0) {\n                    result.middle = headers[0];\n                    result.bottom = headers[1];\n                }\n                else {\n                    result.top    = headers[0];\n                    result.middle = headers[1];\n                }\n                break;\n            case 3:\n                result.top    = headers[0];\n                result.middle = headers[1];\n                result.bottom = headers[2];\n                break;\n            default:\n                throw new Error('headerConfig object not supported for >3 header levels');\n        }\n        return result;\n    }\n    set mainHeaderLevel(mainHeaderLevel) {\n        this.data.mainHeaderLevel = mainHeaderLevel;\n    }\n    get mainHeaderLevel() {\n        if ('mainHeaderLevel' in this.data) {\n            return this.data.mainHeaderLevel;\n        }\n        // 3 headers, then it's the middle\n        if (this.data.headers.length === 3) {\n            return 1;\n        }\n        // Assume it goes top, middle.\n        // If it's middle, top, use mainHeaderLevel : 0\n        return this.headers.length - 1;\n    }\n    get mainHeader() {\n        return this.headers[this.mainHeaderLevel];\n    }\n    get topHeader() {\n        return this.headers[0];\n    }\n    get topUnit() {\n        return this.topHeader.unit;\n    }\n    get topIncrement() {\n        return this.topHeader.increment;\n    }\n    get bottomHeader() {\n        return this.headers[this.headers.length - 1];\n    }\n    get leafUnit() {\n        return this.bottomHeader.unit;\n    }\n    get leafIncrement() {\n        return this.bottomHeader.increment;\n    }\n    get mainUnit() {\n        if ('mainUnit' in this.data) {\n            return this.data.mainUnit;\n        }\n        return this.mainHeader.unit;\n    }\n    get msPerPixel() {\n        const { bottomHeader } = this;\n        return Math.round(DH.asMilliseconds(bottomHeader.increment || 1, bottomHeader.unit) / this.tickWidth);\n    }\n    get isValid() {\n        const me = this;\n        let valid = true;\n        // Make sure all date \"unit\" constants are valid\n        for (const header of me.headers) {\n            valid = valid && Boolean(DH.normalizeUnit(header.unit));\n        }\n        if (me.timeResolution) {\n            valid = valid && DH.normalizeUnit(me.timeResolution.unit);\n        }\n        if (me.shiftUnit) {\n            valid = valid && DH.normalizeUnit(me.shiftUnit);\n        }\n        return valid;\n    }\n}\nViewPreset._$name = 'ViewPreset';", "import LocaleHelper from '../../Core/localization/LocaleHelper.js';\nimport '../../Grid/localization/En.js';\nconst locale = {\n    localeName : 'En',\n    localeDesc : 'English (US)',\n    localeCode : 'en-US',\n    Object : {\n        newEvent : 'New event'\n    },\n    ResourceInfoColumn : {\n        eventCountText : data => data + ' event' + (data !== 1 ? 's' : '')\n    },\n    Dependencies : {\n        from    : 'From',\n        to      : 'To',\n        valid   : 'Valid',\n        invalid : 'Invalid'\n    },\n    DependencyType : {\n        SS           : 'SS',\n        SF           : 'SF',\n        FS           : 'FS',\n        FF           : 'FF',\n        StartToStart : 'Start-to-Start',\n        StartToEnd   : 'Start-to-Finish',\n        EndToStart   : 'Finish-to-Start',\n        EndToEnd     : 'Finish-to-Finish',\n        short        : [\n            'SS',\n            'SF',\n            'FS',\n            'FF'\n        ],\n        long : [\n            'Start-to-Start',\n            'Start-to-Finish',\n            'Finish-to-Start',\n            'Finish-to-Finish'\n        ]\n    },\n    DependencyEdit : {\n        From              : 'From',\n        To                : 'To',\n        Type              : 'Type',\n        Lag               : 'Lag',\n        'Edit dependency' : 'Edit dependency',\n        Save              : 'Save',\n        Delete            : 'Delete',\n        Cancel            : 'Cancel',\n        StartToStart      : 'Start to Start',\n        StartToEnd        : 'Start to End',\n        EndToStart        : 'End to Start',\n        EndToEnd          : 'End to End'\n    },\n    EventEdit : {\n        Name         : 'Name',\n        Resource     : 'Resource',\n        Start        : 'Start',\n        End          : 'End',\n        Save         : 'Save',\n        Delete       : 'Delete',\n        Cancel       : 'Cancel',\n        'Edit event' : 'Edit event',\n        Repeat       : 'Repeat'\n    },\n    EventDrag : {\n        eventOverlapsExisting : 'Event overlaps existing event for this resource',\n        noDropOutsideTimeline : 'Event may not be dropped completely outside the timeline'\n    },\n    SchedulerBase : {\n        'Add event'      : 'Add event',\n        'Delete event'   : 'Delete event',\n        'Unassign event' : 'Unassign event',\n        color            : 'Color'\n    },\n    TimeAxisHeaderMenu : {\n        pickZoomLevel   : 'Zoom',\n        activeDateRange : 'Date range',\n        startText       : 'Start date',\n        endText         : 'End date',\n        todayText       : 'Today'\n    },\n    EventCopyPaste : {\n        copyEvent  : 'Copy event',\n        cutEvent   : 'Cut event',\n        pasteEvent : 'Paste event'\n    },\n    EventFilter : {\n        filterEvents : 'Filter tasks',\n        byName       : 'By name'\n    },\n    TimeRanges : {\n        showCurrentTimeLine : 'Show current timeline'\n    },\n    PresetManager : {\n        secondAndMinute : {\n            displayDateFormat : 'll LTS',\n            name              : 'Seconds'\n        },\n        minuteAndHour : {\n            topDateFormat     : 'ddd MM/DD, hA',\n            displayDateFormat : 'll LST'\n        },\n        hourAndDay : {\n            topDateFormat     : 'ddd MM/DD',\n            middleDateFormat  : 'LST',\n            displayDateFormat : 'll LST',\n            name              : 'Day'\n        },\n        day : {\n            name : 'Day/hours'\n        },\n        week : {\n            name : 'Week/hours'\n        },\n        dayAndWeek : {\n            displayDateFormat : 'll LST',\n            name              : 'Week/days'\n        },\n        dayAndMonth : {\n            name : 'Month'\n        },\n        weekAndDay : {\n            displayDateFormat : 'll LST',\n            name              : 'Week'\n        },\n        weekAndMonth : {\n            name : 'Weeks'\n        },\n        weekAndDayLetter : {\n            name : 'Weeks/weekdays'\n        },\n        weekDateAndMonth : {\n            name : 'Months/weeks'\n        },\n        monthAndYear : {\n            name : 'Months'\n        },\n        year : {\n            name : 'Years'\n        },\n        manyYears : {\n            name : 'Multiple years'\n        }\n    },\n    RecurrenceConfirmationPopup : {\n        'delete-title'              : 'You are deleting an event',\n        'delete-all-message'        : 'Do you want to delete all occurrences of this event?',\n        'delete-further-message'    : 'Do you want to delete this and all future occurrences of this event, or only the selected occurrence?',\n        'delete-further-btn-text'   : 'Delete All Future Events',\n        'delete-only-this-btn-text' : 'Delete Only This Event',\n        'update-title'              : 'You are changing a repeating event',\n        'update-all-message'        : 'Do you want to change all occurrences of this event?',\n        'update-further-message'    : 'Do you want to change only this occurrence of the event, or this and all future occurrences?',\n        'update-further-btn-text'   : 'All Future Events',\n        'update-only-this-btn-text' : 'Only This Event',\n        Yes                         : 'Yes',\n        Cancel                      : 'Cancel',\n        width                       : 600\n    },\n    RecurrenceLegend : {\n        ' and '                         : ' and ',\n        Daily                           : 'Daily',\n        'Weekly on {1}'                 : ({ days }) => `Weekly on ${days}`,\n        'Monthly on {1}'                : ({ days }) => `Monthly on ${days}`,\n        'Yearly on {1} of {2}'          : ({ days, months }) => `Yearly on ${days} of ${months}`,\n        'Every {0} days'                : ({ interval }) => `Every ${interval} days`,\n        'Every {0} weeks on {1}'        : ({ interval, days }) => `Every ${interval} weeks on ${days}`,\n        'Every {0} months on {1}'       : ({ interval, days }) => `Every ${interval} months on ${days}`,\n        'Every {0} years on {1} of {2}' : ({ interval, days, months }) => `Every ${interval} years on ${days} of ${months}`,\n        position1                       : 'the first',\n        position2                       : 'the second',\n        position3                       : 'the third',\n        position4                       : 'the fourth',\n        position5                       : 'the fifth',\n        'position-1'                    : 'the last',\n        day                             : 'day',\n        weekday                         : 'weekday',\n        'weekend day'                   : 'weekend day',\n        daysFormat                      : ({ position, days }) => `${position} ${days}`\n    },\n    RecurrenceEditor : {\n        'Repeat event'      : 'Repeat event',\n        Cancel              : 'Cancel',\n        Save                : 'Save',\n        Frequency           : 'Frequency',\n        Every               : 'Every',\n        DAILYintervalUnit   : 'day(s)',\n        WEEKLYintervalUnit  : 'week(s)',\n        MONTHLYintervalUnit : 'month(s)',\n        YEARLYintervalUnit  : 'year(s)',\n        Each                : 'Each',\n        'On the'            : 'On the',\n        'End repeat'        : 'End repeat',\n        'time(s)'           : 'time(s)'\n    },\n    RecurrenceDaysCombo : {\n        day           : 'day',\n        weekday       : 'weekday',\n        'weekend day' : 'weekend day'\n    },\n    RecurrencePositionsCombo : {\n        position1    : 'first',\n        position2    : 'second',\n        position3    : 'third',\n        position4    : 'fourth',\n        position5    : 'fifth',\n        'position-1' : 'last'\n    },\n    RecurrenceStopConditionCombo : {\n        Never     : 'Never',\n        After     : 'After',\n        'On date' : 'On date'\n    },\n    RecurrenceFrequencyCombo : {\n        None    : 'No repeat',\n        Daily   : 'Daily',\n        Weekly  : 'Weekly',\n        Monthly : 'Monthly',\n        Yearly  : 'Yearly'\n    },\n    RecurrenceCombo : {\n        None   : 'None',\n        Custom : 'Custom...'\n    },\n    Summary : {\n        'Summary for' : date => `Summary for ${date}`\n    },\n    ScheduleRangeCombo : {\n        completeview : 'Complete schedule',\n        currentview  : 'Visible schedule',\n        daterange    : 'Date range',\n        completedata : 'Complete schedule (for all events)'\n    },\n    SchedulerExportDialog : {\n        'Schedule range' : 'Schedule range',\n        'Export from'    : 'From',\n        'Export to'      : 'To'\n    },\n    ExcelExporter : {\n        'No resource assigned' : 'No resource assigned'\n    },\n    CrudManagerView : {\n        serverResponseLabel : 'Server response:'\n    },\n    DurationColumn : {\n        Duration : 'Duration'\n    }\n};\nexport default LocaleHelper.publishLocale(locale);\n", "import { unitMagnitudes } from '../../Core/helper/DateHelper.js';\nimport ViewPreset from './ViewPreset.js';\nimport Localizable from '../../Core/localization/Localizable.js';\nimport '../../Scheduler/localization/En.js';\nimport Store from '../../Core/data/Store.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/preset/PresetStore\n */\n/**\n * A special Store subclass which holds {@link Scheduler.preset.ViewPreset ViewPresets}.\n * Each ViewPreset in this store represents a zoom level. The store data is sorted in special\n * zoom order. That is zoomed out to zoomed in. The first Preset will produce the narrowest event bars\n * the last one will produce the widest event bars.\n *\n * To specify view presets (zoom levels) please provide set of view presets to the scheduler:\n *\n * ```javascript\n * const myScheduler = new Scheduler({\n *     presets : [\n *         {\n *             base : 'hourAndDay',\n *             id   : 'MyHourAndDay',\n *             // other preset configs....\n *         },\n *         {\n *             base : 'weekAndMonth',\n *             id   : 'MyWeekAndMonth',\n *             // other preset configs....\n *         }\n *     ],\n *     viewPreset : 'MyHourAndDay',\n *     // other scheduler configs....\n *     });\n * ```\n *\n * @extends Core/data/Store\n */\nexport default class PresetStore extends Localizable(Store) {\n    static get $name() {\n        return 'PresetStore';\n    }\n    static get defaultConfig() {\n        return {\n            useRawData : true,\n            modelClass : ViewPreset,\n            /**\n             * Specifies the sort order of the presets in the store.\n             * By default they are in zoomed out to zoomed in order. That is\n             * presets which will create widest event bars to presets\n             * which will produce narrowest event bars.\n             *\n             * Configure this as `-1` to reverse this order.\n             * @config {Number}\n             * @default\n             */\n            zoomOrder : 1\n        };\n    }\n    set storage(storage) {\n        super.storage = storage;\n        // Maintained in order automatically while adding.\n        this.storage.addSorter((lhs, rhs) => {\n            const\n                leftBottomHeader  = lhs.bottomHeader,\n                rightBottomHeader = rhs.bottomHeader;\n            // Sort order:\n            //  Milliseconds per pixel.\n            //  Tick size.\n            //  Unit magnitude.\n            //  Increment size.\n            const\n                order = rhs.msPerPixel - lhs.msPerPixel ||\n                unitMagnitudes[leftBottomHeader.unit] - unitMagnitudes[rightBottomHeader.unit] ||\n                leftBottomHeader.increment - rightBottomHeader.increment;\n            return order * this.zoomOrder;\n        });\n    }\n    get storage() {\n        return super.storage;\n    }\n    getById(id) {\n        // If we do not know about the id, inherit it from the PresetManager singleton\n        return super.getById(id) || !this.isPresetManager && globalThis.bryntum.PresetManager.getById(id);\n    }\n    createRecord(data, ...args) {\n        let result;\n        if (data.isViewPreset) {\n            return data;\n        }\n        if (typeof data === 'string') {\n            result = this.getById(data);\n        }\n        else if (typeof data === 'number') {\n            result = this.getAt(data);\n        }\n        // Its a ViewPreset data object\n        else {\n            // If it's extending an existing ViewPreset, inherit then override\n            // the data from the base.\n            if (data.base) {\n                data = this.copyBaseValues(data);\n            }\n            // Model constructor will call generateId if no id is provided\n            return super.createRecord(data, ...args);\n        }\n        if (!result) {\n            throw new Error(`ViewPreset ${data} does not exist`);\n        }\n        return result;\n    }\n    updateLocalization() {\n        super.updateLocalization();\n        const me = this;\n        // Collect presets from store...\n        let presets = me.allRecords;\n        // and basePresets if we are the PresetManager\n        if (me.isPresetManager) {\n            presets = new Set(presets.concat(Object.values(me.basePresets)));\n        }\n        presets.forEach(preset => {\n            let localePreset = me.optionalL(`L{PresetManager.${preset.id}}`, null, true);\n            // Default presets generated from base presets use localization of base if they have no own\n            if (typeof localePreset === 'string' && preset.baseId) {\n                localePreset = me.optionalL(`L{PresetManager.${preset.baseId}}`, null, true);\n            }\n            // Apply any custom format defined in locale, or the original format if none exists\n            if (localePreset && typeof localePreset === 'object') {\n                if (!preset.originalDisplayDateFormat) {\n                    preset.originalDisplayDateFormat = preset.displayDateFormat;\n                }\n                // it there is a topDateFormat but preset.mainHeaderLevel is 0, means the middle header is the top header actually,\n                // so convert property to middle (if middle doesn't exists) to localization understand (topDateFormat for weekAndDay for example)\n                // topDateFormat doesn't work when mainHeaderLevel is 0 because it doesn't have top config\n                // but has top header visually (Check on get headerConfig method in ViewPreset class)\n                if (preset.mainHeaderLevel === 0 && localePreset.topDateFormat) {\n                    localePreset.middleDateFormat = localePreset.middleDateFormat || localePreset.topDateFormat;\n                }\n                preset.setData('displayDateFormat', localePreset.displayDateFormat || preset.originalDisplayDateFormat);\n                ['top', 'middle', 'bottom'].forEach(level => {\n                    const\n                        levelConfig           = preset.headerConfig[level],\n                        localeLevelDateFormat = localePreset[level + 'DateFormat'];\n                    if (levelConfig) {\n                        if (!levelConfig.originalDateFormat) {\n                            levelConfig.originalDateFormat = levelConfig.dateFormat;\n                        }\n                        // if there was defined topDateFormat on locale file for example, use it instead of renderer from basePresets (https://github.com/bryntum/support/issues/1307)\n                        if (localeLevelDateFormat && levelConfig.renderer) {\n                            levelConfig.renderer = null;\n                        }\n                        levelConfig.dateFormat = localeLevelDateFormat || levelConfig.originalDateFormat;\n                    }\n                });\n                // The preset names are used in ViewPresetCombo and are localized by default\n                if (localePreset.name) {\n                    if (!preset.unlocalizedName) {\n                        preset.unlocalizedName = preset.name;\n                    }\n                    preset.setData('name', localePreset.name);\n                }\n                else if (preset.unlocalizedName && preset.unlocalizedName !== preset.name) {\n                    preset.name = preset.unlocalizedName;\n                    preset.unlocalizedName = null;\n                }\n            }\n        });\n    }\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // Preset config on Scheduler/Gantt expects array of presets and not store config\n    getCurrentConfig(options) {\n        return super.getCurrentConfig(options).data;\n    }\n    copyBaseValues(presetData) {\n        let base = this.getById(presetData.base);\n        if (!base) {\n            throw new Error(`ViewPreset base '${presetData.base}' does not exist.`);\n        }\n        base = ObjectHelper.clone(base.data);\n        delete base.id;\n        if (presetData.name) {\n            delete base.name;\n        }\n        // Merge supplied data into a clone of the base ViewPreset's data\n        // so that the new one overrides the base.\n        return ObjectHelper.merge(base, presetData);\n    }\n    add(preset) {\n        preset = Array.isArray(preset) ? preset : [preset];\n        preset.forEach(preset => {\n            // If a ViewPreset instance that extends another preset was added\n            // Only in add we can apply the base data\n            if (preset.isViewPreset && preset.base) {\n                preset.data = this.copyBaseValues(preset.originalData);\n            }\n        });\n        return super.add(...arguments);\n    }\n}\nPresetStore._$name = 'PresetStore';", "import DateHelper from '../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport ViewPreset from './ViewPreset.js';\nimport PresetStore from './PresetStore.js';\n// No module tag here. That stops the singleton from being included by the docs.\n/**\n * ## Intro\n * This is a global Store of {@link Scheduler.preset.ViewPreset ViewPresets}, required to supply initial data to\n * Scheduler's {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}.\n *\n * You can provide new view presets globally or for a specific scheduler.\n *\n * **NOTE:** You **cannot** modify existing records in the PresetManager store. You can either remove\n * preset records from the store or add new records to the store.\n * Also please keep in mind, all changes provided to the PresetManager store are not reflected to the\n * {@link Scheduler.view.mixin.TimelineViewPresets#config-presets} of schedulers that already exist!\n *\n * If you want to have just a few presets (also known as zoom levels) in your Scheduler, you can slice corresponding records\n * from the `PresetManager` and apply them to the Scheduler `presets` config.\n * ```javascript\n * const newPresets = PresetManager.records.slice(10, 12);\n *\n * const scheduler = new Scheduler({\n *     presets    : newPresets, // Only 2 zoom levels are available\n *     viewPreset : newPresets[0].id\n * });\n * ```\n *\n * If you want to adjust all default presets and assign to a specific scheduler you are going to create,\n * you can extend them and pass as an array to the Scheduler `presets` config.\n * Here is an example of how to set the same `timeResolution` to all `ViewPresets`.\n * ```javascript\n * const newPresets = PresetManager.map(preset => {\n *     return {\n *         id             : 'my_' + preset.id,\n *         base           : preset.id, // Based on an existing preset\n *         timeResolution : {\n *             unit      : 'day',\n *             increment : 1\n *         }\n *     };\n * });\n *\n * const scheduler = new Scheduler({\n *     presets     : newPresets,\n *     viewPreset : 'my_hourAndDay'\n * });\n * ```\n *\n * If you want to do the same for **all** schedulers which will be created next, you can register new presets in a loop.\n * ```javascript\n * PresetManager.records.forEach(preset => {\n *     // Pass the same ID, so when a new preset is added to the store,\n *     // it will replace the current one.\n *     PresetManager.registerPreset(preset.id, {\n *        id             : preset.id,\n *        base           : preset.id,\n *        timeResolution : {\n *            unit      : 'day',\n *            increment : 1\n *        }\n *    });\n * });\n * ```\n *\n * Here is an example of how to add a new `ViewPreset` to the global `PresetManager` store and to the already created\n * scheduler `presets`.\n * ```javascript\n * const scheduler = new Scheduler({...});\n *\n * const newGlobalPresets = PresetManager.add({\n *     id              : 'myNewPreset',\n *     base            : 'hourAndDay', // Based on an existing preset\n *     columnLinesFor  : 0,\n *     // Override headers\n *     headers : [\n *         {\n *             unit       : 'day',\n *             // Use different date format for top header 01.10.2020\n *             dateFormat : 'DD.MM.YYYY'\n *         },\n *         {\n *             unit       : 'hour',\n *             dateFormat : 'LT'\n *         }\n *     ]\n * });\n *\n * // Add new presets to the scheduler that has been created before changes\n * // to PresetManager are applied\n * scheduler.presets.add(newGlobalPresets);\n * ```\n *\n * ## Predefined presets\n *\n * Predefined presets are:\n *\n * - `secondAndMinute` - creates a 2 level header - minutes and seconds:\n * {@inlineexample Scheduler/preset/secondAndMinute.js}\n * - `minuteAndHour` - creates a 2 level header - hours and minutes:\n * {@inlineexample Scheduler/preset/minuteAndHour.js}\n * - `hourAndDay` - creates a 2 level header - days and hours:\n * {@inlineexample Scheduler/preset/hourAndDay.js}\n * - `dayAndWeek` - creates a 2 level header - weeks and days:\n * {@inlineexample Scheduler/preset/dayAndWeek.js}\n * - `dayAndMonth` - creates a 2 level header - months and days:\n * {@inlineexample Scheduler/preset/dayAndMonth.js}\n * - `weekAndDay` - just like `dayAndWeek` but with different formatting:\n * {@inlineexample Scheduler/preset/weekAndDay.js}\n * - `weekAndDayLetter` - creates a 2 level header - weeks and day letters:\n * {@inlineexample Scheduler/preset/weekAndDayLetter.js}\n * - `weekAndMonth` - creates a 2 level header - months and weeks:\n * {@inlineexample Scheduler/preset/weekAndMonth.js}\n * - `weekDateAndMonth` - creates a 2 level header - months and weeks (weeks shown by first day only):\n * {@inlineexample Scheduler/preset/weekDateAndMonth.js}\n * - `monthAndYear` - creates a 2 level header - years and months:\n * {@inlineexample Scheduler/preset/monthAndYear.js}\n * - `year` - creates a 2 level header - years and quarters:\n * {@inlineexample Scheduler/preset/year.js}\n * - `manyYears` - creates a 2 level header - 5-years and years:\n * {@inlineexample Scheduler/preset/manyYears.js}\n *\n * See the {@link Scheduler.preset.ViewPreset} and {@link Scheduler.preset.ViewPresetHeaderRow} classes for a\n * description of the view preset properties.\n *\n * ## Localizing View Presets\n * Bryntum Scheduler uses locales for translations including date formats for view presets.\n *\n * To translate date format for view presets just define the date format for the specified region\n * for your locale file, like this:\n * ```javascript\n * const locale = {\n *\n *     localeName : 'En',\n *\n *     // ... Other translations here ...\n *\n *     PresetManager : {\n *         // Translation for the \"weekAndDay\" ViewPreset\n *         weekAndDay : {\n *             // Change the date format for the top and middle levels\n *             topDateFormat    : 'MMM',\n *             middleDateFormat : 'D'\n *         },\n *         // Translation for the \"dayAndWeek\" ViewPreset\n *         dayAndWeek : {\n *             // Change the date format for the top level\n *             topDateFormat : 'MMMM YYYY'\n *         }\n *     }\n * }\n *\n * LocaleManager.applyLocale(locale);\n * ```\n *\n * Check the <a target=\"_blank\" href=\"../examples/localization/\">localization demo</a> and [this guide](#Scheduler/guides/customization/localization.md) for more details.\n *\n * @singleton\n * @extends Scheduler/preset/PresetStore\n */\nclass PresetManager extends PresetStore {\n    static get $name() {\n        return 'PresetManager';\n    }\n    static get defaultConfig() {\n        return {\n            // To not break CSP demo\n            preventSubClassingModel : true,\n            basePresets : {\n                secondAndMinute : {\n                    name              : 'Seconds',\n                    tickWidth         : 30,   // Time column width\n                    tickHeight        : 40,\n                    displayDateFormat : 'll LTS', // Controls how dates will be displayed in tooltips etc\n                    shiftIncrement    : 10,     // Controls how much time to skip when calling shiftNext and shiftPrevious.\n                    shiftUnit         : 'minute', // Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n                    defaultSpan       : 24,    // By default, if no end date is supplied to a view it will show 24 hours\n                    timeResolution    : {      // Dates will be snapped to this resolution\n                        unit      : 'second',  // Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n                        increment : 5\n                    },\n                    // This defines your header rows.\n                    // For each row you can define \"unit\", \"increment\", \"dateFormat\", \"renderer\", \"align\", and \"thisObj\"\n                    headers : [\n                        {\n                            unit       : 'minute',\n                            dateFormat : 'lll'\n                        },\n                        {\n                            unit       : 'second',\n                            increment  : 10,\n                            dateFormat : 'ss'\n                        }\n                    ]\n                },\n                minuteAndHour : {\n                    name              : 'Minutes',\n                    tickWidth         : 60,    // Time column width\n                    tickHeight        : 60,\n                    displayDateFormat : 'll LT', // Controls how dates will be displayed in tooltips etc\n                    shiftIncrement    : 1,     // Controls how much time to skip when calling shiftNext and shiftPrevious.\n                    shiftUnit         : 'hour', // Valid values are \"MILLI\", \"SECOND\", \"minute\", \"HOUR\", \"DAY\", \"WEEK\", \"MONTH\", \"QUARTER\", \"YEAR\".\n                    defaultSpan       : 24,    // By default, if no end date is supplied to a view it will show 24 hours\n                    timeResolution    : {      // Dates will be snapped to this resolution\n                        unit      : 'minute',  // Valid values are \"MILLI\", \"SECOND\", \"minute\", \"HOUR\", \"DAY\", \"WEEK\", \"MONTH\", \"QUARTER\", \"YEAR\".\n                        increment : 15\n                    },\n                    headers : [\n                        {\n                            unit       : 'hour',\n                            dateFormat : 'ddd MM/DD, hA'\n                        },\n                        {\n                            unit       : 'minute',\n                            increment  : 30,\n                            dateFormat : 'mm'\n                        }\n                    ]\n                },\n                hourAndDay : {\n                    name              : 'Day',\n                    tickWidth         : 70,\n                    tickHeight        : 40,\n                    displayDateFormat : 'll LT',\n                    shiftIncrement    : 1,\n                    shiftUnit         : 'day',\n                    defaultSpan       : 24,\n                    timeResolution    : {\n                        unit      : 'minute',\n                        increment : 30\n                    },\n                    headers : [\n                        {\n                            unit       : 'day',\n                            dateFormat : 'ddd DD/MM' //Mon 01/10\n                        },\n                        {\n                            unit       : 'hour',\n                            dateFormat : 'LT'\n                        }\n                    ]\n                },\n                day : {\n                    name              : 'Day/hours',\n                    displayDateFormat : 'LT',\n                    shiftIncrement    : 1,\n                    shiftUnit         : 'day',\n                    defaultSpan       : 1,\n                    timeResolution    : {\n                        unit      : 'minute',\n                        increment : 30\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit       : 'day',\n                            dateFormat : 'ddd DD/MM', // Mon 01/02\n                            splitUnit  : 'day'\n                        },\n                        {\n                            unit : 'hour',\n                            renderer(value) {\n                                return `\n                                    <div class=\"b-sch-calendarcolumn-ct\"><span class=\"b-sch-calendarcolumn-hours\">${DateHelper.format(value, 'HH')}</span>\n                                    <span class=\"b-sch-calendarcolumn-minutes\">${DateHelper.format(value, 'mm')}</span></div>\n                                `;\n                            }\n                        }\n                    ]\n                },\n                week : {\n                    name              : 'Week/hours',\n                    displayDateFormat : 'LT',\n                    shiftIncrement    : 1,\n                    shiftUnit         : 'week',\n                    defaultSpan       : 24,\n                    timeResolution    : {\n                        unit      : 'minute',\n                        increment : 30\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit       : 'week',\n                            dateFormat : 'D d',\n                            splitUnit  : 'day'\n                        },\n                        {\n                            unit       : 'hour',\n                            dateFormat : 'LT',    // will be overridden by renderer\n                            renderer(value) {\n                                return `\n                                    <div class=\"sch-calendarcolumn-ct\">\n                                    <span class=\"sch-calendarcolumn-hours\">${DateHelper.format(value, 'HH')}</span>\n                                    <span class=\"sch-calendarcolumn-minutes\">${DateHelper.format(value, 'mm')}</span>\n                                    </div>\n                                `;\n                            }\n                        }\n                    ]\n                },\n                dayAndWeek : {\n                    name              : 'Days & Weeks',\n                    tickWidth         : 100,\n                    tickHeight        : 80,\n                    displayDateFormat : 'll LT',\n                    shiftUnit         : 'day',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 5,\n                    timeResolution    : {\n                        unit      : 'hour',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit : 'week',\n                            renderer(start) {\n                                return DateHelper.getShortNameOfUnit('week') + '.' + DateHelper.format(start, 'WW MMM YYYY');\n                            }\n                        },\n                        {\n                            unit       : 'day',\n                            dateFormat : 'dd DD'\n                        }\n                    ]\n                },\n                // dayAndMonth : {\n                //     name              : 'Days & Months',\n                //     tickWidth         : 100,\n                //     tickHeight        : 80,\n                //     displayDateFormat : 'll LT',\n                //     shiftUnit         : 'day',\n                //     shiftIncrement    : 1,\n                //     defaultSpan       : 5,\n                //     timeResolution    : {\n                //         unit      : 'hour',\n                //         increment : 1\n                //     },\n                //     headers : [\n                //         {\n                //             unit       : 'month',\n                //             dateFormat : 'MMMM YYYY',\n                //             align      : 'start'\n                //         },\n                //         {\n                //             unit       : 'day',\n                //             dateFormat : 'dd DD'\n                //         }\n                //     ]\n                // },\n                dayAndMonth : {\n                    name              : 'Month',\n                    tickWidth         : 100,\n                    tickHeight        : 80,\n                    displayDateFormat : 'll LT',\n                    shiftUnit         : 'month',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 1,\n                    mainUnit          : 'month',\n                    timeResolution    : {\n                        unit      : 'hour',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'month',\n                            dateFormat : 'MMMM YYYY'\n                        },\n                        {\n                            unit       : 'day',\n                            dateFormat : 'DD'\n                        }\n                    ]\n                },\n                weekAndDay : {\n                    name              : 'Week',\n                    tickWidth         : 100,\n                    tickHeight        : 80,\n                    displayDateFormat : 'll hh:mm A',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 1,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit       : 'week',\n                            dateFormat : 'YYYY MMMM DD' // 2017 January 01\n                        },\n                        {\n                            unit       : 'day',\n                            increment  : 1,\n                            dateFormat : 'DD MMM'\n                        }\n                    ]\n                },\n                weekAndMonth : {\n                    name              : 'Weeks',\n                    tickWidth         : 100,\n                    tickHeight        : 105,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 5,\n                    defaultSpan       : 6,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'month',\n                            dateFormat : 'MMM YYYY' //Jan 2017\n                        },\n                        {\n                            unit       : 'week',\n                            dateFormat : 'DD MMM'\n                        }\n                    ]\n                },\n                weekAndDayLetter : {\n                    name              : 'Weeks/weekdays',\n                    tickWidth         : 20,\n                    tickHeight        : 50,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 10,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit                : 'week',\n                            dateFormat          : 'ddd DD MMM YYYY',\n                            verticalColumnWidth : 115\n                        },\n                        {\n                            unit                : 'day',\n                            dateFormat          : 'd1',\n                            verticalColumnWidth : 25\n                        }\n                    ]\n                },\n                weekDateAndMonth : {\n                    name              : 'Months/weeks',\n                    tickWidth         : 30,\n                    tickHeight        : 40,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'week',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 10,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'month',\n                            dateFormat : 'YYYY MMMM'\n                        },\n                        {\n                            unit       : 'week',\n                            dateFormat : 'DD'\n                        }\n                    ]\n                },\n                monthAndYear : {\n                    name              : 'Months',\n                    tickWidth         : 110,\n                    tickHeight        : 110,\n                    displayDateFormat : 'll',\n                    shiftIncrement    : 3,\n                    shiftUnit         : 'month',\n                    defaultSpan       : 12,\n                    timeResolution    : {\n                        unit      : 'day',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'year',\n                            dateFormat : 'YYYY' //2017\n                        },\n                        {\n                            unit       : 'month',\n                            dateFormat : 'MMM YYYY' //Jan 2017\n                        }\n                    ]\n                },\n                year : {\n                    name                : 'Years',\n                    tickWidth           : 100,\n                    tickHeight          : 100,\n                    resourceColumnWidth : 100,\n                    displayDateFormat   : 'll',\n                    shiftUnit           : 'year',\n                    shiftIncrement      : 1,\n                    defaultSpan         : 1,\n                    mainHeaderLevel     : 0,\n                    timeResolution      : {\n                        unit      : 'month',\n                        increment : 1\n                    },\n                    headers : [\n                        {\n                            unit       : 'year',\n                            dateFormat : 'YYYY'\n                        },\n                        {\n                            unit : 'quarter',\n                            renderer(start, end, cfg) {\n                                return DateHelper.getShortNameOfUnit('quarter').toUpperCase() + (Math.floor(start.getMonth() / 3) + 1);\n                            }\n                        }\n                    ]\n                },\n                manyYears : {\n                    name              : 'Multiple years',\n                    tickWidth         : 40,\n                    tickHeight        : 50,\n                    displayDateFormat : 'll',\n                    shiftUnit         : 'year',\n                    shiftIncrement    : 1,\n                    defaultSpan       : 10,\n                    timeResolution    : {\n                        unit      : 'year',\n                        increment : 1\n                    },\n                    mainHeaderLevel : 0,\n                    headers         : [\n                        {\n                            unit      : 'year',\n                            increment : 5,\n                            renderer  : (start, end) => start.getFullYear() + ' - ' + end.getFullYear()\n                        },\n                        {\n                            unit       : 'year',\n                            dateFormat : 'YY',\n                            increment  : 1\n                        }\n                    ]\n                }\n            },\n            // This is a list of bryntum-supplied preset adjustments used to create the Scheduler's\n            // default initial set of ViewPresets.\n            defaultPresets : [\n                // Years over years\n                'manyYears',\n                { width : 80, increment : 1, resolution : 1, base : 'manyYears', resolutionUnit : 'YEAR' },\n                // Years over quarters\n                'year',\n                { width : 30,  increment : 1, resolution : 1, base : 'year', resolutionUnit : 'MONTH' },\n                { width : 50,  increment : 1, resolution : 1, base : 'year', resolutionUnit : 'MONTH' },\n                { width : 200, increment : 1, resolution : 1, base : 'year', resolutionUnit : 'MONTH' },\n                // Years over months\n                'monthAndYear',\n                // Months over weeks\n                'weekDateAndMonth',\n                // Months over weeks\n                'weekAndMonth',\n                // Months over weeks\n                'weekAndDayLetter',\n                // Months over days\n                'dayAndMonth',\n                // Weeks over days\n                'weekAndDay',\n                { width : 54, increment : 1, resolution : 1, base : 'weekAndDay', resolutionUnit : 'HOUR' },\n                // Days over hours\n                'hourAndDay',\n                { width : 64,  increment : 6, resolution : 30, base : 'hourAndDay', resolutionUnit : 'MINUTE' },\n                { width : 100, increment : 6, resolution : 30, base : 'hourAndDay', resolutionUnit : 'MINUTE' },\n                { width : 64,  increment : 2, resolution : 30, base : 'hourAndDay', resolutionUnit : 'MINUTE' },\n                // Hours over minutes\n                'minuteAndHour',\n                { width : 60,  increment : 15, resolution : 5, base : 'minuteAndHour' },\n                { width : 130, increment : 15, resolution : 5, base : 'minuteAndHour' },\n                { width : 60,  increment : 5,  resolution : 5, base : 'minuteAndHour' },\n                { width : 100, increment : 5,  resolution : 5, base : 'minuteAndHour' },\n                // Minutes over seconds\n                'secondAndMinute',\n                { width : 60,  increment : 10, resolution : 5, base : 'secondAndMinute' },\n                { width : 130, increment : 5,  resolution : 5, base : 'secondAndMinute' }\n            ],\n            internalListeners : {\n                locale : 'updateLocalization'\n            }\n        };\n    }\n    set basePresets(basePresets) {\n        const presetCache = this._basePresets = {};\n        for (const id in basePresets) {\n            basePresets[id].id = id;\n            presetCache[id] = this.createRecord(basePresets[id]);\n        }\n    }\n    get basePresets() {\n        return this._basePresets;\n    }\n    set defaultPresets(defaultPresets) {\n        for (let i = 0, { length } = defaultPresets; i < length; i++) {\n            const\n                presetAdjustment   = defaultPresets[i],\n                isBase             = typeof presetAdjustment === 'string',\n                baseType           = isBase ? presetAdjustment : presetAdjustment.base;\n            let preset;\n            // The default was just a string, so it's an unmodified instance of a base type.\n            if (isBase) {\n                preset = this.basePresets[baseType];\n            }\n            // If it's an object, it's an adjustment to a base type\n            else {\n                const\n                    config             = Object.setPrototypeOf(ObjectHelper.clone(this.basePresets[baseType].data), { id : baseType }),\n                    { timeResolution } = config,\n                    bottomHeader       = config.headers[config.headers.length - 1];\n                config.id = undefined;\n                if ('width' in presetAdjustment) {\n                    config.tickWidth = presetAdjustment.width;\n                }\n                if ('height' in presetAdjustment) {\n                    config.tickHeight = presetAdjustment.height;\n                }\n                if ('increment' in presetAdjustment) {\n                    bottomHeader.increment = presetAdjustment.increment;\n                }\n                if ('resolution' in presetAdjustment) {\n                    timeResolution.increment = presetAdjustment.resolution;\n                }\n                if ('resolutionUnit' in presetAdjustment) {\n                    timeResolution.unit = DateHelper.getUnitByName(presetAdjustment.resolutionUnit);\n                }\n                preset = this.createRecord(config);\n                // Keep id of original preset around, used with localization in PresetStore\n                preset.baseId = baseType;\n            }\n            this.add(preset);\n        }\n    }\n    getById(id) {\n        // Look first in the default set, and if it's one of the base types that is not imported into the\n        // default set, then look at the bases.\n        return super.getById(id) || this.basePresets[id];\n    }\n    /**\n     * Registers a new view preset base to be used by any scheduler grid or tree on the page.\n     * @param {String} id The unique identifier for this preset\n     * @param {ViewPresetConfig} config The configuration properties of the view preset (see\n     * {@link Scheduler.preset.ViewPreset} for more information)\n     * @returns {Scheduler.preset.ViewPreset} A new ViewPreset based upon the passed configuration.\n     */\n    registerPreset(id, config) {\n        const\n            preset = this.createRecord(Object.assign({\n                id\n            }, config)),\n            existingDuplicate = this.find(p => p.equals(preset));\n        if (existingDuplicate) {\n            return existingDuplicate;\n        }\n        if (preset.isValid) {\n            this.add(preset);\n        }\n        else {\n            throw new Error('Invalid preset, please check your configuration');\n        }\n        return preset;\n    }\n    getPreset(preset) {\n        if (typeof preset === 'number') {\n            preset = this.getAt(preset);\n        }\n        if (typeof preset === 'string') {\n            preset = this.getById(preset);\n        }\n        else if (!(preset instanceof ViewPreset)) {\n            preset = this.createRecord(preset);\n        }\n        return preset;\n    }\n    /**\n     * Applies preset customizations or fetches a preset view preset using its name.\n     * @param {String|ViewPresetConfig} presetOrId Id of a predefined preset or a preset config object\n     * @returns {Scheduler.preset.ViewPreset} Resulting ViewPreset instance\n     */\n    normalizePreset(preset) {\n        const me = this;\n        if (!(preset instanceof ViewPreset)) {\n            if (typeof preset === 'string') {\n                preset = me.getPreset(preset);\n                if (!preset) {\n                    throw new Error('You must define a valid view preset. See PresetManager for reference');\n                }\n            }\n            else if (typeof preset === 'object') {\n                // Look up any existing ViewPreset that it is based upon.\n                if (preset.base) {\n                    const base = this.getById(preset.base);\n                    if (!base) {\n                        throw new Error(`ViewPreset base '${preset.base}' does not exist`);\n                    }\n                    // The config is based upon the base's data with the new config object merged in.\n                    preset = ObjectHelper.merge(ObjectHelper.clone(base.data), preset);\n                }\n                // Ensure the new ViewPreset has a legible, logical id which does not already\n                // exist in our store.\n                if (preset.id) {\n                    preset = me.createRecord(preset);\n                }\n                else {\n                    preset = me.createRecord(ObjectHelper.assign({}, preset));\n                    preset.id = preset.generateId(preset);\n                }\n            }\n        }\n        return preset;\n    }\n    /**\n     * Deletes a view preset\n     * @param {String} id The id of the preset, or the preset instance.\n     */\n    deletePreset(presetOrId) {\n        if (typeof presetOrId === 'string') {\n            presetOrId = this.getById(presetOrId);\n        }\n        else if (typeof presetOrId === 'number') {\n            presetOrId = this.getAt(presetOrId);\n        }\n        if (presetOrId) {\n            this.remove(presetOrId);\n            // ALso remove it from our base list\n            delete this.basePresets[presetOrId.id];\n        }\n    }\n}\nconst pm = new PresetManager();\nglobalThis.bryntum.PresetManager = pm;\nexport { pm as default };\n", "import Store from '../../Core/data/Store.js';\nimport DH from '../../Core/helper/DateHelper.js';\nimport TimeSpan from '../model/TimeSpan.js';\nimport PresetManager from '../preset/PresetManager.js';\n/**\n * @module Scheduler/data/TimeAxis\n */\n// Micro-optimized version of TimeSpan for faster reading. Hit a lot and since it is internal fields are guaranteed to\n// not be remapped and changes won't be batches, so we can always return raw value from data avoiding all additional\n// checks and logic\nclass Tick extends TimeSpan {\n    // Only getters on purpose, we do not support manipulating ticks\n    get startDate() {\n        return this.data.startDate;\n    }\n    get endDate() {\n        return this.data.endDate;\n    }\n}\n/**\n * A class representing the time axis of the scheduler. The scheduler timescale is based on the ticks generated by this\n * class. This is a pure \"data\" (model) representation of the time axis and has no UI elements.\n *\n * The time axis can be {@link #config-continuous} or not. In continuous mode, each timespan starts where the previous\n * ended, and in non-continuous mode there can be gaps between the ticks.\n * A non-continuous time axis can be used when want to filter out certain periods of time (like weekends) from the time\n * axis.\n *\n * To create a non-continuous time axis you have 2 options. First, you can create a time axis containing only the time\n * spans of interest. To do that, subclass this class and override the {@link #property-generateTicks} method.\n *\n * The other alternative is to call the {@link #function-filterBy} method, passing a function to it which should return\n * `false` if the time tick should be filtered out. Calling {@link Core.data.mixin.StoreFilter#function-clearFilters}\n * will return you to a full time axis.\n *\n * @extends Core/data/Store\n */\nexport default class TimeAxis extends Store {\n    //region Events\n    /**\n     * Fires before the timeaxis is about to be reconfigured (e.g. new start/end date or unit/increment). Return `false`\n     * to abort the operation.\n     * @event beforeReconfigure\n     * @param {Scheduler.data.TimeAxis} source The time axis instance\n     * @param {Date} startDate The new time axis start date\n     * @param {Date} endDate The new time axis end date\n     */\n    /**\n     * Event that is triggered when we end reconfiguring and everything UI-related should be done\n     * @event endReconfigure\n     * @private\n     */\n    /**\n     * Fires when the timeaxis has been reconfigured (e.g. new start/end date or unit/increment)\n     * @event reconfigure\n     * @param {Scheduler.data.TimeAxis} source The time axis instance\n     */\n    /**\n     * Fires if all the ticks in the timeaxis are filtered out. After firing the filter is temporarily disabled to\n     * return the time axis to a valid state. A disabled filter will be re-enabled the next time ticks are regenerated\n     * @event invalidFilter\n     * @param {Scheduler.data.TimeAxis} source The time axis instance\n     */\n    //endregion\n    //region Default config\n    static get defaultConfig() {\n        return {\n            modelClass : Tick,\n            /**\n             * Set to false if the timeline is not continuous, e.g. the next timespan does not start where the previous ended (for example skipping weekends etc).\n             * @config {Boolean}\n             * @default\n             */\n            continuous : true,\n            originalContinuous : null,\n            /**\n             * Include only certain hours or days in the time axis (makes it `continuous : false`). Accepts and object\n             * with `day` and `hour` properties:\n             * ```\n             * const scheduler = new Scheduler({\n             *     timeAxis : {\n             *         include : {\n             *              // Do not display hours after 17 or before 9 (only display 9 - 17). The `to\u00B4 value is not\n             *              // included in the time axis\n             *              hour : {\n             *                  from : 9,\n             *                  to   : 17\n             *              },\n             *              // Do not display sunday or saturday\n             *              day : [0, 6]\n             *         }\n             *     }\n             * }\n             * ```\n             * In most cases we recommend that you use Scheduler's workingTime config instead. It is easier to use and\n             * makes sure all parts of the Scheduler gets updated.\n             * @config {Object}\n             */\n            include : null,\n            /**\n             * Automatically adjust the timespan when generating ticks with {@link #property-generateTicks} according to\n             * the `viewPreset` configuration. Setting this to false may lead to shifting time/date of ticks.\n             * @config {Boolean}\n             * @default\n             */\n            autoAdjust : true,\n            //isConfigured : false,\n            // in case of `autoAdjust : false`, the 1st and last ticks can be truncated, containing only part of the normal tick\n            // these dates will contain adjusted start/end (like if the tick has not been truncated)\n            adjustedStart    : null,\n            adjustedEnd      : null,\n            // the visible position in the first tick, can actually be > 1 because the adjustment is done by the `mainUnit`\n            visibleTickStart : null,\n            // the visible position in the first tick, is always ticks count - 1 < value <= ticks count, in case of autoAdjust, always = ticks count\n            visibleTickEnd   : null,\n            tickCache : {},\n            viewPreset       : null,\n            maxTraverseTries : 100,\n            useRawData       : {\n                disableDuplicateIdCheck : true,\n                disableDefaultValue     : true,\n                disableTypeConversion   : true\n            }\n        };\n    }\n    static get configurable() {\n        return {\n            /**\n             * Method generating the ticks for this time axis. Should return a **non-empty** array of ticks. Each tick\n             * is an object of the following structure:\n             * ```\n             * {\n             *    startDate : ..., // start date\n             *    endDate   : ...  // end date\n             * }\n             * ```\n             * To see it in action please check out our [TimeAxis](https://bryntum.com/products/scheduler/examples/timeaxis/)\n             * example and navigate to \"Compressed non-working time\" tab.\n             *\n             * @param {Date} axisStartDate The start date of the interval\n             * @param {Date} axisEndDate The end date of the interval\n             * @param {String} unit The unit of the time axis\n             * @param {Number} increment The increment for the unit specified.\n             * @returns {TimeSpanConfig[]} ticks The ticks representing the time axis\n             * @config {Function}\n             */\n            generateTicks : null,\n            unit                : null,\n            increment           : null,\n            resolutionUnit      : null,\n            resolutionIncrement : null,\n            mainUnit            : null,\n            shiftUnit           : null,\n            shiftIncrement      : 1,\n            defaultSpan         : 1,\n            weekStartDay : null,\n            // Used to force resolution to match whole ticks, to snap accordingly when using fillTicks in the UI\n            forceFullTicks : null\n        };\n    }\n    //endregion\n    //region Init\n    // private\n    construct(config) {\n        const me = this;\n        super.construct(config);\n        me.originalContinuous = me.continuous;\n        me.ion({\n            change : ({ action }) => {\n                // If the change was due to filtering, there will be a refresh event\n                // arriving next, so do not reconfigure\n                if (action !== 'filter') {\n                    me.trigger('reconfigure', { supressRefresh : false });\n                }\n            },\n            refresh        : () => me.trigger('reconfigure', { supressRefresh : false }),\n            endreconfigure : event => me.trigger('reconfigure', event)\n        });\n        if (me.startDate) {\n            me.internalOnReconfigure();\n            me.trigger('reconfigure');\n        }\n        else if (me.viewPreset) {\n            const range  = me.getAdjustedDates(new Date());\n            me.startDate = range.startDate;\n            me.endDate   = range.endDate;\n        }\n    }\n    get isTimeAxis() {\n        return true;\n    }\n    //endregion\n    //region Configuration (reconfigure & consumePreset)\n    /**\n     * Reconfigures the time axis based on the config object supplied and generates the new 'ticks'.\n     * @param {Object} config\n     * @param {Boolean} [suppressRefresh]\n     * @private\n     */\n    reconfigure(config, suppressRefresh = false, preventThrow = false) {\n        const\n            me         = this,\n            normalized = me.getAdjustedDates(config.startDate, config.endDate),\n            oldConfig  = {};\n        if (me.trigger('beforeReconfigure', { startDate : normalized.startDate, endDate : normalized.endDate, config }) !== false) {\n            me.trigger('beginReconfigure');\n            me._configuredStartDate = config.startDate;\n            me._configuredEndDate   = config.endDate;\n            // Collect old values for end event\n            for (const propName in config) {\n                oldConfig[propName] = me[propName];\n            }\n            const viewPresetChanged = config.viewPreset && config.viewPreset !== me.viewPreset;\n            // If changing viewPreset, try to gracefully recover if an applied filter results in an empty view\n            if (viewPresetChanged) {\n                preventThrow = me.isFiltered;\n                me.filters.forEach(f => f.disabled = false);\n            }\n            Object.assign(me, config);\n            if (me.internalOnReconfigure(preventThrow, viewPresetChanged) === false) {\n                return false;\n            }\n            me.trigger('endReconfigure', { suppressRefresh, config, oldConfig });\n        }\n    }\n    internalOnReconfigure(preventThrow = false, viewPresetChanged) {\n        const me = this;\n        me.isConfigured = true;\n        const\n            adjusted   = me.getAdjustedDates(me.startDate, me.endDate, true),\n            normalized = me.getAdjustedDates(me.startDate, me.endDate),\n            start      = normalized.startDate,\n            end        = normalized.endDate;\n        if (start >= end) {\n            throw new Error(`Invalid start/end dates. Start date must be less than end date. Start date: ${start}. End date: ${end}.`);\n        }\n        const\n            { unit, increment = 1 } = me,\n            ticks                   = me.generateTicks(start, end, unit, increment) ||\n                                      // Offer a fallback in case user did not generate any ticks at all.\n                                      me.constructor.prototype.generateTicks.call(me, start, end, unit, increment);\n        // Suspending to be able to detect an invalid filter\n        me.suspendEvents();\n        me.maintainFilter = preventThrow;\n        me.data           = ticks;\n        me.maintainFilter = false;\n        const { count } = me;\n        if (count === 0) {\n            if (preventThrow) {\n                if (viewPresetChanged) {\n                    me.disableFilters();\n                }\n                me.resumeEvents();\n                return false;\n            }\n            throw new Error('Invalid time axis configuration or filter, please check your input data.');\n        }\n        // start date is cached, update it to fill after generated ticks\n        me.startDate = me.first.startDate;\n        me.endDate   = me.last.endDate;\n        me.resumeEvents();\n        if (me.isContinuous) {\n            me.adjustedStart = adjusted.startDate;\n            me.adjustedEnd   = DH.getNext(count > 1 ? ticks[count - 1].startDate : adjusted.startDate, unit, increment, me.weekStartDay);\n        }\n        else {\n            me.adjustedStart = me.startDate;\n            me.adjustedEnd   = me.endDate;\n        }\n        me.updateVisibleTickBoundaries();\n        me.updateTickCache(true);\n    }\n    updateVisibleTickBoundaries() {\n        const\n            me = this,\n            {\n                count,\n                unit,\n                startDate,\n                endDate,\n                weekStartDay,\n                increment = 1\n            }  = me;\n        // Denominator is amount of milliseconds in a full tick (unit * increment). Normally we use 30 days in a month\n        // and 365 days in a year. But if month is 31 day long or year is a leap one standard formula might calculate\n        // wrong value. e.g. if we're rendering 1 day from August, formula goes like (2021-08-31 - 2021-08-02) / 30 = 1\n        // and renders full tick which is incorrect. For such cases we need to adjust denominator to a correct one.\n        // Thankfully there are only a few of them - month, year and day with DST transition.\n        const\n            startDenominator = DH.getNormalizedUnitDuration(startDate, unit) * increment,\n            endDenominator   = DH.getNormalizedUnitDuration(endDate, unit) * increment;\n        // if visibleTickStart > 1 this means some tick is fully outside of the view - we are not interested in it and want to\n        // drop it and adjust \"adjustedStart\" accordingly\n        do {\n            me.visibleTickStart = (startDate - me.adjustedStart) / startDenominator;\n            if (me.autoAdjust) me.visibleTickStart = Math.floor(me.visibleTickStart);\n            if (me.visibleTickStart >= 1) me.adjustedStart = DH.getNext(me.adjustedStart, unit, increment, weekStartDay);\n        } while (me.visibleTickStart >= 1);\n        do {\n            me.visibleTickEnd = count - (me.adjustedEnd - endDate) / endDenominator;\n            if (count - me.visibleTickEnd >= 1) me.adjustedEnd = DH.getNext(me.adjustedEnd, unit, -1, weekStartDay);\n        } while (count - me.visibleTickEnd >= 1);\n        // This flag indicates that the time axis starts exactly on a tick boundary and finishes on a tick boundary\n        // This is used as an optimization flag by TimeAxisViewModel.createHeaderRow\n        me.fullTicks = !me.visibleTickStart && me.visibleTickEnd === count;\n    }\n    /**\n     * Get the currently used time unit for the ticks\n     * @readonly\n     * @member {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} unit\n     */\n    /**\n     * Get/set currently used preset\n     * @property {Scheduler.preset.ViewPreset}\n     */\n    get viewPreset() {\n        return this._viewPreset;\n    }\n    set viewPreset(preset) {\n        const me = this;\n        preset = PresetManager.getPreset(preset);\n        if (!preset.isViewPreset) {\n            throw new Error('TimeAxis must be configured with the ViewPreset instance that the Scheduler is using');\n        }\n        me._viewPreset = preset;\n        Object.assign(me, {\n            unit      : preset.bottomHeader.unit,\n            increment : preset.bottomHeader.increment || 1,\n            resolutionUnit      : preset.timeResolution.unit,\n            resolutionIncrement : preset.timeResolution.increment,\n            mainUnit       : preset.mainHeader.unit,\n            shiftUnit      : preset.shiftUnit || preset.mainHeader.unit,\n            shiftIncrement : preset.shiftIncrement || 1,\n            defaultSpan : preset.defaultSpan || 1,\n            presetName  : preset.id,\n            // Weekview columns are updated upon 'datachanged' event on this object.\n            // We have to pass headers in order to render them correctly (timeAxisViewModel is incorrect in required time)\n            headers : preset.headers\n        });\n    }\n    //endregion\n    //region Getters & setters\n    get weekStartDay() {\n        return this._weekStartDay ?? DH.weekStartDay;\n    }\n    // private\n    get resolution() {\n        return {\n            unit      : this.resolutionUnit,\n            increment : this.resolutionIncrement\n        };\n    }\n    // private\n    set resolution(resolution) {\n        this.resolutionUnit      = resolution.unit;\n        this.resolutionIncrement = resolution.increment;\n    }\n    get resolutionUnit() {\n        return this.forceFullTicks ? this.unit : this._resolutionUnit;\n    }\n    get resolutionIncrement() {\n        return this.forceFullTicks ? this.increment : this._resolutionIncrement;\n    }\n    //endregion\n    //region Timespan & resolution\n    /**\n     * Changes the time axis timespan to the supplied start and end dates.\n     *\n     * **Note** This does **not** preserve the temporal scroll position. You may use\n     * {@link Scheduler.view.Scheduler#function-setTimeSpan} to set the time axis and\n     * maintain temporal scroll position (if possible).\n     * @param {Date} newStartDate The new start date\n     * @param {Date} [newEndDate] The new end date\n     */\n    setTimeSpan(newStartDate, newEndDate, preventThrow = false) {\n        // If providing a 0 span range, add default range\n        if (newEndDate && newStartDate - newEndDate === 0) {\n            newEndDate = null;\n        }\n        const\n            me                     = this,\n            { startDate, endDate } = me.getAdjustedDates(newStartDate, newEndDate);\n        if (me.startDate - startDate !== 0 || me.endDate - endDate !== 0) {\n            return me.reconfigure({\n                startDate,\n                endDate\n            }, false, preventThrow);\n        }\n    }\n    /**\n     * Moves the time axis by the passed amount and unit.\n     *\n     * NOTE: When using a filtered TimeAxis the result of `shift()` cannot be guaranteed, it might shift into a\n     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.\n     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly\n     * instead.\n     *\n     * @param {Number} amount The number of units to jump\n     * @param {String} [unit] The unit (Day, Week etc)\n     */\n    shift(amount, unit = this.shiftUnit) {\n        const me = this;\n        let { startDate, endDate } = me;\n        // Use unfiltered start and end dates when shifting a filtered time axis, to lessen risk of messing it up.\n        // Still not guaranteed to work though\n        if (me.isFiltered) {\n            startDate = me.allRecords[0].startDate;\n            endDate   = me.allRecords[me.allCount - 1].endDate;\n        }\n        // Hack for filtered time axis, for example if weekend is filtered out and you shiftPrev() day from monday\n        let tries = 0;\n        do {\n            startDate = DH.add(startDate, amount, unit);\n            endDate   = DH.add(endDate, amount, unit);\n        } while (tries++ < me.maxTraverseTries && me.setTimeSpan(startDate, endDate, {\n            preventThrow : true\n        }) === false);\n    }\n    /**\n     * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement`\n     * config of the current view preset.\n     *\n     * NOTE: When using a filtered TimeAxis the result of `shiftNext()` cannot be guaranteed, it might shift into a\n     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.\n     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly\n     * instead.\n     *\n     * @param {Number} [amount] The number of units to jump forward\n     */\n    shiftNext(amount = this.shiftIncrement) {\n        this.shift(amount);\n    }\n    /**\n     * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount specified by the `shiftIncrement` config of the current view preset.\n     *\n     * NOTE: When using a filtered TimeAxis the result of `shiftPrev()` cannot be guaranteed, it might shift into a\n     * filtered out span. It tries to be smart about it by shifting from unfiltered start and end dates.\n     * If that solution does not work for your filtering setup, please call {@link #function-setTimeSpan} directly\n     * instead.\n     *\n     * @param {Number} [amount] The number of units to jump backward\n     */\n    shiftPrevious(amount = this.shiftIncrement) {\n        this.shift(-amount);\n    }\n    //endregion\n    //region Filter & continuous\n    /**\n     * Filter the time axis by a function (and clears any existing filters first). The passed function will be called with each tick in time axis.\n     * If the function returns `true`, the 'tick' is included otherwise it is filtered. If all ticks are filtered out\n     * the time axis is considered invalid, triggering `invalidFilter` and then removing the filter.\n     * @param {Function} fn The function to be called, it will receive an object with `startDate`/`endDate` properties, and `index` of the tick.\n     * @param {Object} [thisObj] `this` reference for the function\n     * @typings {Promise<any|null>}\n     */\n    filterBy(fn, thisObj = this) {\n        const me = this;\n        me.filters.clear();\n        super.filterBy((tick, index) => fn.call(thisObj, tick.data, index));\n    }\n    filter() {\n        const\n            me     = this,\n            retVal = super.filter(...arguments);\n        if (!me.maintainFilter && me.count === 0) {\n            me.resumeEvents();\n            me.trigger('invalidFilter');\n            me.disableFilters();\n        }\n        return retVal;\n    }\n    disableFilters() {\n        this.filters.forEach(f => f.disabled = true);\n        this.filter();\n    }\n    triggerFilterEvent(event) {\n        const me = this;\n        if (!event.filters.count) {\n            me.continuous = me.originalContinuous;\n        }\n        else {\n            me.continuous = false;\n        }\n        // Filters has been applied (or cleared) but listeners are not informed yet, update tick cache to have start and\n        // end dates correct when later redrawing events & header\n        me.updateTickCache();\n        super.triggerFilterEvent(event);\n    }\n    /**\n     * Returns `true` if the time axis is continuous (will return `false` when filtered)\n     * @property {Boolean}\n     */\n    get isContinuous() {\n        return this.continuous !== false && !this.isFiltered;\n    }\n    //endregion\n    //region Dates\n    getAdjustedDates(startDate, endDate, forceAdjust = false) {\n        const me = this;\n        // If providing a 0 span range, add default range\n        if (endDate && startDate - endDate === 0) {\n            endDate = null;\n        }\n        startDate = startDate || me.startDate;\n        endDate   = endDate || DH.add(startDate, me.defaultSpan, me.mainUnit);\n        return me.autoAdjust || forceAdjust ? {\n            startDate : me.floorDate(startDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1),\n            endDate   : me.ceilDate(endDate, false, me.autoAdjust ? me.mainUnit : me.unit, 1)\n        } : {\n            startDate,\n            endDate\n        };\n    }\n    /**\n     * Method to get the current start date of the time axis.\n     * @property {Date}\n     */\n    get startDate() {\n        return this._start || (this.first ? new Date(this.first.startDate) : null);\n    }\n    set startDate(start) {\n        this._start = DH.parse(start);\n    }\n    /**\n     * Method to get a the current end date of the time axis\n     * @property {Date}\n     */\n    get endDate() {\n        return this._end || (this.last ? new Date(this.last.endDate) : null);\n    }\n    set endDate(end) {\n        if (end) this._end = DH.parse(end);\n    }\n    // used in performance critical code for comparisons\n    get startMS() {\n        return this._startMS;\n    }\n    // used in performance critical code for comparisons\n    get endMS() {\n        return this._endMS;\n    }\n    // Floors a date and optionally snaps it to one of the following resolutions:\n    // 1. 'resolutionUnit'. If param 'resolutionUnit' is passed, the date will simply be floored to this unit.\n    // 2. If resolutionUnit is not passed: If date should be snapped relative to the timeaxis start date,\n    // the resolutionUnit of the timeAxis will be used, or the timeAxis 'mainUnit' will be used to snap the date\n    //\n    // returns a copy of the original date\n    // private\n    floorDate(date, relativeToStart, resolutionUnit, incr) {\n        relativeToStart = relativeToStart !== false;\n        const\n            me         = this,\n            relativeTo = relativeToStart ? DH.clone(me.startDate) : null,\n            increment  = incr || me.resolutionIncrement,\n            unit       = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit),\n            snap       = (value, increment) => Math.floor(value / increment) * increment;\n        if (relativeToStart) {\n            return DH.floor(date, { unit, magnitude : increment }, relativeTo);\n        }\n        const dt = DH.clone(date);\n        if (unit === 'week') {\n            const\n                day      = dt.getDay() || 7,\n                startDay = me.weekStartDay || 7;\n            DH.add(DH.startOf(dt, 'day', false), day >= startDay ? startDay - day : -(7 - startDay + day), 'day', false);\n            // Watch out for Brazil DST craziness (see test 028_timeaxis_dst.t.js)\n            if (dt.getDay() !== startDay && dt.getHours() === 23) {\n                DH.add(dt, 1, 'hour', false);\n            }\n        }\n        else {\n            // removes \"smaller\" units from date (for example minutes; removes seconds and milliseconds)\n            DH.startOf(dt, unit, false);\n            // day and year are 1-based so need to make additional adjustments\n            const\n                modifier     = ['day', 'year'].includes(unit) ? 1 : 0,\n                useUnit      = unit === 'day' ? 'date' : unit,\n                snappedValue = snap(DH.get(dt, useUnit) - modifier, increment) + modifier;\n            DH.set(dt, useUnit, snappedValue);\n        }\n        return dt;\n    }\n    /**\n     * Rounds the date to nearest unit increment\n     * @private\n     */\n    roundDate(date, relativeTo, resolutionUnit = this.resolutionUnit, increment = this.resolutionIncrement || 1) {\n        const\n            me = this,\n            dt = DH.clone(date);\n        relativeTo = DH.clone(relativeTo || me.startDate);\n        switch (resolutionUnit) {\n            case 'week': {\n                DH.startOf(dt, 'day', false);\n                let distanceToWeekStartDay = dt.getDay() - me.weekStartDay,\n                    toAdd;\n                if (distanceToWeekStartDay < 0) {\n                    distanceToWeekStartDay = 7 + distanceToWeekStartDay;\n                }\n                if (Math.round(distanceToWeekStartDay / 7) === 1) {\n                    toAdd = 7 - distanceToWeekStartDay;\n                }\n                else {\n                    toAdd = -distanceToWeekStartDay;\n                }\n                return DH.add(dt, toAdd, 'day', false);\n            }\n            case 'month': {\n                const\n                    nbrMonths     = DH.diff(relativeTo, dt, 'month') + DH.as('month', dt.getDay() / DH.daysInMonth(dt)), //*/DH.as('month', DH.diff(relativeTo, dt)) + (dt.getDay() / DH.daysInMonth(dt)),\n                    snappedMonths = Math.round(nbrMonths / increment) * increment;\n                return DH.add(relativeTo, snappedMonths, 'month', false);\n            }\n            case 'quarter':\n                DH.startOf(dt, 'month', false);\n                return DH.add(dt, 3 - (dt.getMonth() % 3), 'month', false);\n            default: {\n                const\n                    duration        = DH.as(resolutionUnit, DH.diff(relativeTo, dt)),\n                    // Need to find the difference of timezone offsets between relativeTo and original dates. 0 if timezone offsets are the same.\n                    offset          = resolutionUnit === 'year' ? 0 : DH.as(resolutionUnit, relativeTo.getTimezoneOffset() - dt.getTimezoneOffset(), 'minute'),\n                    // Need to add the offset to the whole duration, so the divided value will take DST into account\n                    snappedDuration = Math.round((duration + offset) / increment) * increment;\n                // Now when the round is done, we need to subtract the offset, so the result also will take DST into account\n                return DH.add(relativeTo, snappedDuration - offset, resolutionUnit, false);\n            }\n        }\n    }\n    // private\n    ceilDate(date, relativeToStart, resolutionUnit, increment) {\n        const me = this;\n        relativeToStart = relativeToStart !== false;\n        increment       = increment || (relativeToStart ? me.resolutionIncrement : 1);\n        const\n            unit = resolutionUnit || (relativeToStart ? me.resolutionUnit : me.mainUnit),\n            dt   = DH.clone(date);\n        let doCall = false;\n        switch (unit) {\n            case 'minute':\n                doCall = !DH.isStartOf(dt, 'minute');\n                break;\n            case 'hour':\n                doCall = !DH.isStartOf(dt, 'hour');\n                break;\n            case 'day':\n            case 'date':\n                doCall = !DH.isStartOf(dt, 'day');\n                break;\n            case 'week':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getDay() !== me.weekStartDay || !DH.isEqual(dt, date));\n                break;\n            case 'month':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getDate() !== 1 || !DH.isEqual(dt, date));\n                break;\n            case 'quarter':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getMonth() % 3 !== 0 || dt.getDate() !== 1 || !DH.isEqual(dt, date));\n                break;\n            case 'year':\n                DH.startOf(dt, 'day', false);\n                doCall = (dt.getMonth() !== 0 || dt.getDate() !== 1 || !DH.isEqual(dt, date));\n                break;\n        }\n        if (doCall) {\n            return DH.getNext(dt, unit, increment, me.weekStartDay);\n        }\n        return dt;\n    }\n    //endregion\n    //region Ticks\n    get include() {\n        return this._include;\n    }\n    set include(include) {\n        const me = this;\n        me._include   = include;\n        me.continuous = !include;\n        if (!me.isConfiguring) {\n            me.startDate = me._configuredStartDate;\n            me.endDate   = me._configuredEndDate;\n            me.internalOnReconfigure();\n            me.trigger('includeChange');\n        }\n    }\n    // Check if a certain date is included based on timeAxis.include rules\n    processExclusion(startDate, endDate, unit) {\n        const { include } = this;\n        if (include) {\n            return Object.entries(include).some(([includeUnit, rule]) => {\n                if (!rule) {\n                    return false;\n                }\n                const { from, to } = rule;\n                // Including the closest smaller unit with a { from, to} rule should affect start & end of the\n                // generated tick. Currently only works for days or smaller.\n                if (DH.compareUnits('day', unit) >= 0 && DH.getLargerUnit(includeUnit) === unit) {\n                    if (from) {\n                        DH.set(startDate, includeUnit, from);\n                    }\n                    if (to) {\n                        let stepUnit = unit;\n                        // Stepping back base on date, not day\n                        if (unit === 'day') {\n                            stepUnit = 'date';\n                        }\n                        // Since endDate is not inclusive it points to the next day etc.\n                        // Turns for example 2019-01-10T00:00 -> 2019-01-09T18:00\n                        DH.set(endDate, {\n                            [stepUnit]    : DH.get(endDate, stepUnit) - 1,\n                            [includeUnit] : to\n                        });\n                    }\n                }\n                // \"Greater\" unit being included? Then we need to care about it\n                // (for example excluding day will also affect hour, minute etc)\n                if (DH.compareUnits(includeUnit, unit) >= 0) {\n                    const datePart = (includeUnit === 'day' ? startDate.getDay() : DH.get(startDate, includeUnit));\n                    if ((from && datePart < from) || (to && datePart >= to)) {\n                        return true;\n                    }\n                }\n            });\n        }\n        return false;\n    }\n    // Calculate constants used for exclusion when scaling within larger ticks\n    initExclusion() {\n        Object.entries(this.include).forEach(([unit, rule]) => {\n            if (rule) {\n                const { from, to } = rule;\n                // For example for hour:\n                // 1. Get the next bigger unit -> day, get ratio -> 24\n                // 2. to 20 - from 8 = 12 hours visible each day. lengthFactor 24 / 12 = 2 means that each hour used\n                // needs to represent 2 hours when drawn (to stretch)\n                // |    \u2588\u2588\u2588\u2588    | -> |  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  |\n                rule.lengthFactor = DH.getUnitToBaseUnitRatio(unit, DH.getLargerUnit(unit)) / (to - from);\n                rule.lengthFactorExcl = DH.getUnitToBaseUnitRatio(unit, DH.getLargerUnit(unit)) / (to - from - 1);\n                // Calculate weighted center to stretch around |   \u2588\u2588x\u2588 |\n                rule.center = from + from / (rule.lengthFactor - 1);\n            }\n        });\n    }\n    /**\n     * Method generating the ticks for this time axis. Should return an array of ticks . Each tick is an object of the following structure:\n     * ```\n     * {\n     *    startDate : ..., // start date\n     *    endDate   : ...  // end date\n     * }\n     * ```\n     * Take notice, that this function either has to be called with `start`/`end` parameters, or create those variables.\n     *\n     * To see it in action please check out our [TimeAxis](https://bryntum.com/products/scheduler/examples/timeaxis/) example and navigate to \"Compressed non-working time\" tab.\n     *\n     * @member {Function} generateTicks\n     * @param {Date} axisStartDate The start date of the interval\n     * @param {Date} axisEndDate The end date of the interval\n     * @param {String} unit The unit of the time axis\n     * @param {Number} increment The increment for the unit specified.\n     * @returns {Array|undefined} ticks The ticks representing the time axis, or no return value to use the default tick generation\n     */\n    updateGenerateTicks() {\n        if (!this.isConfiguring) {\n            this.reconfigure(this);\n        }\n    }\n    _generateTicks(axisStartDate, axisEndDate, unit = this.unit, increment = this.increment) {\n        const\n            me            = this,\n            ticks         = [],\n            usesExclusion = Boolean(me.include);\n        let intervalEnd,\n            tickEnd,\n            isExcluded,\n            dstDiff                = 0,\n            { startDate, endDate } = me.getAdjustedDates(axisStartDate, axisEndDate);\n        me.tickCache = {};\n        if (usesExclusion) {\n            me.initExclusion();\n        }\n        while (startDate < endDate) {\n            intervalEnd = DH.getNext(startDate, unit, increment, me.weekStartDay);\n            if (!me.autoAdjust && intervalEnd > endDate) {\n                intervalEnd = endDate;\n            }\n            // Handle hourly increments crossing DST boundaries to keep the timescale looking correct\n            // Only do this for HOUR resolution currently, and only handle it once per tick generation.\n            if (unit === 'hour' && increment > 1 && ticks.length > 0 && dstDiff === 0) {\n                const prev = ticks[ticks.length - 1];\n                dstDiff = ((prev.startDate.getHours() + increment) % 24) - prev.endDate.getHours();\n                if (dstDiff !== 0) {\n                    // A DST boundary was crossed in previous tick, adjust this tick to keep timeaxis \"symmetric\".\n                    intervalEnd = DH.add(intervalEnd, dstDiff, 'hour');\n                }\n            }\n            isExcluded = false;\n            if (usesExclusion) {\n                tickEnd    = new Date(intervalEnd.getTime());\n                isExcluded = me.processExclusion(startDate, intervalEnd, unit);\n            }\n            else {\n                tickEnd = intervalEnd;\n            }\n            if (!isExcluded) {\n                ticks.push({\n                    id      : (ticks.length + 1),\n                    startDate,\n                    endDate : intervalEnd\n                });\n                me.tickCache[startDate.getTime()] = ticks.length - 1;\n            }\n            startDate = tickEnd;\n        }\n        return ticks;\n    }\n    /**\n     * How many ticks are visible across the TimeAxis.\n     *\n     * Usually, this is an integer because {@link #config-autoAdjust} means that the start and end\n     * dates are adjusted to be on tick boundaries.\n     * @property {Number}\n     * @internal\n     */\n    get visibleTickTimeSpan() {\n        const me = this;\n        return me.isContinuous ? me.visibleTickEnd - me.visibleTickStart : me.count;\n    }\n    /**\n     * Gets a tick \"coordinate\" representing the date position on the time scale. Returns -1 if the date is not part of the time axis.\n     * @param {Date} date the date\n     * @returns {Number} the tick position on the scale or -1 if the date is not part of the time axis\n     */\n    getTickFromDate(date) {\n        const\n            me     = this,\n            ticks  = me.records,\n            dateMS = date.getTime?.() ?? date;\n        let begin = 0,\n            end   = ticks.length - 1,\n            middle, tick, tickStart, tickEnd;\n        // Quickly eliminate out of range dates or if we have not been set up with a time range yet\n        if (!ticks.length || dateMS < ticks[0].startDateMS || dateMS > ticks[end].endDateMS) {\n            return -1;\n        }\n        if (me.isContinuous) {\n            // Chop tick cache in half until we find a match\n            while (begin < end) {\n                middle = (begin + end + 1) >> 1;\n                if (dateMS > ticks[middle].endDateMS) {\n                    begin = middle + 1;\n                }\n                else if (dateMS < ticks[middle].startDateMS) {\n                    end = middle - 1;\n                }\n                else {\n                    begin = middle;\n                }\n            }\n            tick      = ticks[begin];\n            tickStart = tick.startDateMS;\n            // Part way though, calculate the fraction\n            if (dateMS > tickStart) {\n                tickEnd = tick.endDateMS;\n                begin += (dateMS - tickStart) / (tickEnd - tickStart);\n            }\n            return Math.min(Math.max(begin, me.visibleTickStart), me.visibleTickEnd);\n        }\n        else {\n            for (let i = 0; i <= end; i++) {\n                tickEnd = ticks[i].endDateMS;\n                if (dateMS <= tickEnd) {\n                    tickStart = ticks[i].startDateMS;\n                    // date < tickStart can occur in filtered case\n                    tick = i + (dateMS > tickStart ? (dateMS - tickStart) / (tickEnd - tickStart) : 0);\n                    return tick;\n                }\n            }\n        }\n    }\n    getSnappedTickFromDate(date) {\n        const\n            startTickIdx = Math.floor(this.getTickFromDate(date));\n        return this.getAt(startTickIdx);\n    }\n    /**\n     * Gets the time represented by a tick \"coordinate\".\n     * @param {Number} tick the tick \"coordinate\"\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @returns {Date} The date to represented by the tick \"coordinate\", or null if invalid.\n     */\n    getDateFromTick(tick, roundingMethod) {\n        const me = this;\n        if (tick === me.visibleTickEnd) {\n            return me.endDate;\n        }\n        const\n            wholeTick = Math.floor(tick),\n            fraction  = tick - wholeTick,\n            t         = me.getAt(wholeTick);\n        if (!t) {\n            return null;\n        }\n        const\n            // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedStart property and should use tick start\n            start = wholeTick === 0 && me.isContinuous ? me.adjustedStart : t.startDate,\n            // if we've filtered timeaxis using filterBy, then we cannot trust to adjustedEnd property and should use tick end\n            end   = (wholeTick === me.count - 1) && me.isContinuous ? me.adjustedEnd : t.endDate;\n        let date = DH.add(start, fraction * (end - start), 'millisecond');\n        if (roundingMethod) {\n            date = me[roundingMethod + 'Date'](date);\n        }\n        return date;\n    }\n    /**\n     * Returns the ticks of the timeaxis in an array of objects with a \"startDate\" and \"endDate\".\n     * @property {Scheduler.model.TimeSpan[]}\n     */\n    get ticks() {\n        return this.records;\n    }\n    /**\n     * Caches ticks and start/end dates for faster processing during rendering of events.\n     * @private\n     */\n    updateTickCache(onlyStartEnd = false) {\n        const me = this;\n        if (me.count) {\n            me._start   = me.first.startDate;\n            me._end     = me.last.endDate;\n            me._startMS = me.startDate.getTime();\n            me._endMS   = me.endDate.getTime();\n        }\n        else {\n            me._start = me._end = me._startMs = me._endMS = null;\n        }\n        // onlyStartEnd is true prior to clearing filters, to get start and end dates correctly during that process.\n        // No point in filling tickCache yet in that case, it will be done after the filters are cleared\n        if (!onlyStartEnd) {\n            me.tickCache = {};\n            me.forEach((tick, i) => me.tickCache[tick.startDate.getTime()] = i);\n        }\n    }\n    //endregion\n    //region Axis\n    /**\n     * Returns true if the passed date is inside the span of the current time axis.\n     * @param {Date} date The date to query for\n     * @returns {Boolean} true if the date is part of the time axis\n     */\n    dateInAxis(date, inclusiveEnd = false) {\n        const\n            me        = this,\n            axisStart = me.startDate,\n            axisEnd   = me.endDate;\n        // Date is between axis start/end and axis is not continuous - need to perform better lookup\n        if (me.isContinuous) {\n            return inclusiveEnd ? DH.betweenLesserEqual(date, axisStart, axisEnd) : DH.betweenLesser(date, axisStart, axisEnd);\n        }\n        else {\n            const length = me.getCount();\n            let tickStart, tickEnd, tick;\n            for (let i = 0; i < length; i++) {\n                tick      = me.getAt(i);\n                tickStart = tick.startDate;\n                tickEnd   = tick.endDate;\n                if ((inclusiveEnd && date <= tickEnd) || (!inclusiveEnd && date < tickEnd)) {\n                    return date >= tickStart;\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Returns true if the passed timespan is part of the current time axis (in whole or partially).\n     * @param {Date} start The start date\n     * @param {Date} end The end date\n     * @returns {Boolean} true if the timespan is part of the timeaxis\n     */\n    timeSpanInAxis(start, end) {\n        const me = this;\n        if (!end || end.getTime() === start.getTime()) {\n            return this.dateInAxis(start, true);\n        }\n        if (me.isContinuous) {\n            return DH.intersectSpans(start, end, me.startDate, me.endDate);\n        }\n        return (start < me.startDate && end > me.endDate) || me.getTickFromDate(start) !== me.getTickFromDate(end);\n    }\n    // Accepts a TimeSpan model (uses its cached MS values to be a bit faster during rendering)\n    isTimeSpanInAxis(timeSpan) {\n        const\n            me                         = this,\n            { startMS, endMS }         = me,\n            { startDateMS }            = timeSpan,\n            endDateMS                  = timeSpan.endDateMS ?? timeSpan.meta.endDateCached;\n        // only consider fully scheduled ranges\n        if (!startDateMS || !endDateMS) {\n            return false;\n        }\n        if (endDateMS === startDateMS) {\n            return me.dateInAxis(timeSpan.startDate, true);\n        }\n        if (me.isContinuous) {\n            return endDateMS > startMS && startDateMS < endMS;\n        }\n        const\n            startTick = me.getTickFromDate(timeSpan.startDate),\n            endTick   = me.getTickFromDate(timeSpan.endDate);\n        // endDate is not inclusive\n        if (\n            (startTick === me.count && DH.isEqual(timeSpan.startDate, me.last.endDate)) ||\n            (endTick === 0 && DH.isEqual(timeSpan.endDate, me.first.startDate))\n        ) {\n            return false;\n        }\n        return (\n            // Spanning entire axis\n            (startDateMS < startMS && endDateMS > endMS) ||\n            // Unintentionally 0 wide (ticks excluded or outside)\n            startTick !== endTick\n        );\n    }\n    //endregion\n    //region Iteration\n    /**\n     * Calls the supplied iterator function once per interval. The function will be called with four parameters, startDate endDate, index, isLastIteration.\n     * @internal\n     * @param {String} unit The unit to use when iterating over the timespan\n     * @param {Number} increment The increment to use when iterating over the timespan\n     * @param {Function} iteratorFn The function to call\n     * @param {Object} [thisObj] `this` reference for the function\n     */\n    forEachAuxInterval(unit, increment = 1, iteratorFn, thisObj = this) {\n        const end = this.endDate;\n        let dt = this.startDate,\n            i  = 0,\n            intervalEnd;\n        if (dt > end) throw new Error('Invalid time axis configuration');\n        while (dt < end) {\n            intervalEnd = DH.min(DH.getNext(dt, unit, increment, this.weekStartDay), end);\n            iteratorFn.call(thisObj, dt, intervalEnd, i, intervalEnd >= end);\n            dt = intervalEnd;\n            i++;\n        }\n    }\n    //endregion\n}\nTimeAxis._$name = 'TimeAxis';", "import DH from '../../../Core/helper/DateHelper.js';\nimport Events from '../../../Core/mixin/Events.js';\nimport PresetManager from '../../preset/PresetManager.js';\nimport ViewPreset from '../../preset/ViewPreset.js';\nimport '../../data/TimeAxis.js';\n/**\n * @module Scheduler/view/model/TimeAxisViewModel\n */\n/**\n * This class is an internal view model class, describing the visual representation of a {@link Scheduler.data.TimeAxis}.\n * The config for the header rows is described in the {@link Scheduler.preset.ViewPreset#field-headers headers}.\n * To calculate the size of each cell in the time axis, this class requires:\n *\n * - availableSpace  - The total width or height available for the rendering\n * - tickSize       - The fixed width or height of each cell in the lowest header row. This value is normally read from the\n * {@link Scheduler.preset.ViewPreset viewPreset} but this can also be updated programmatically using the {@link #property-tickSize} setter\n *\n * Normally you should not interact with this class directly.\n *\n * @extends Core/mixin/Events\n */\nexport default class TimeAxisViewModel extends Events() {\n    //region Default config\n    static get defaultConfig() {\n        return {\n            /**\n             * The time axis providing the underlying data to be visualized\n             * @config {Scheduler.data.TimeAxis}\n             * @internal\n             */\n            timeAxis : null,\n            /**\n             * The available width/height, this is normally not known by the consuming UI component using this model\n             * class until it has been fully rendered. The consumer of this model should set\n             * {@link #property-availableSpace} when its width has changed.\n             * @config {Number}\n             * @internal\n             */\n            availableSpace : null,\n            /**\n             * The \"tick width\" for horizontal mode or \"tick height\" for vertical mode, to use for the cells in the\n             * bottom most header row.\n             * This value is normally read from the {@link Scheduler.preset.ViewPreset viewPreset}\n             * @config {Number}\n             * @default\n             * @internal\n             */\n            tickSize : 100,\n            /**\n             * true if there is a requirement to be able to snap events to a certain view resolution.\n             * This has implications of the {@link #config-tickSize} that can be used, since all widths must be in even pixels.\n             * @config {Boolean}\n             * @default\n             * @internal\n             */\n            snap : false,\n            /**\n             * true if cells in the bottom-most row should be fitted to the {@link #property-availableSpace available space}.\n             * @config {Boolean}\n             * @default\n             * @internal\n             */\n            forceFit : false,\n            headers : null,\n            mode : 'horizontal', // or 'vertical'\n            //used for Exporting. Make sure the tick columns are not recalculated when resizing.\n            suppressFit : false,\n            // cache of the config currently used.\n            columnConfig : [],\n            // the view preset name to apply initially\n            viewPreset : null,\n            // The default header level to draw column lines for\n            columnLinesFor : null,\n            originalTickSize : null,\n            headersDatesCache : []\n        };\n    }\n    //endregion\n    //region Init & destroy\n    construct(config) {\n        const me = this;\n        // getSingleUnitInPixels results are memoized because of frequent calls during rendering.\n        me.unitToPixelsCache = {};\n        super.construct(config);\n        const viewPreset = me.timeAxis.viewPreset || me.viewPreset;\n        if (viewPreset) {\n            if (viewPreset instanceof ViewPreset) {\n                me.consumeViewPreset(viewPreset);\n            }\n            else {\n                const preset = PresetManager.getPreset(viewPreset);\n                preset && me.consumeViewPreset(preset);\n            }\n        }\n        // When time axis is changed, reconfigure the model\n        me.timeAxis.ion({ reconfigure : 'onTimeAxisReconfigure', thisObj : me });\n        me.configured = true;\n    }\n    doDestroy() {\n        this.timeAxis.un('reconfigure', this.onTimeAxisReconfigure, this);\n        super.doDestroy();\n    }\n    /**\n     * Returns an array representing the headers of the current timeAxis. Each element is an array representing the cells for that level in the header.\n     * @returns {Object[]} An array of headers, each element being an array representing each cell (with start date and end date) in the timeline representation.\n     * @internal\n     */\n    get columnConfig() {\n        return this._columnConfig;\n    }\n    set columnConfig(config) {\n        this._columnConfig = config;\n    }\n    get headers() {\n        return this._headers;\n    }\n    set headers(headers) {\n        if (headers && headers.length && headers[headers.length - 1].cellGenerator) {\n            throw new Error('`cellGenerator` cannot be used for the bottom level of your headers. Use TimeAxis#generateTicks() instead.');\n        }\n        this._headers = headers;\n    }\n    get isTimeAxisViewModel() {\n        return true;\n    }\n    //endregion\n    //region Events\n    /**\n     * Fires after the model has been updated.\n     * @event update\n     * @param {Scheduler.view.model.TimeAxisViewModel} source The model instance\n     */\n    /**\n     * Fires after the model has been reconfigured.\n     * @event reconfigure\n     * @param {Scheduler.view.model.TimeAxisViewModel} source The model instance\n     */\n    //endregion\n    //region Mode\n    /**\n     * Using horizontal mode?\n     * @returns {Boolean}\n     * @readonly\n     * @internal\n     */\n    get isHorizontal() {\n        return this.mode !== 'vertical';\n    }\n    /**\n     * Using vertical mode?\n     * @returns {Boolean}\n     * @readonly\n     * @internal\n     */\n    get isVertical() {\n        return this.mode === 'vertical';\n    }\n    /**\n     * Gets/sets the forceFit value for the model. Setting it will cause it to update its contents and fire the\n     * {@link #event-update} event.\n     * @property {Boolean}\n     * @internal\n     */\n    set forceFit(value) {\n        if (value !== this._forceFit) {\n            this._forceFit = value;\n            this.update();\n        }\n    }\n    //endregion\n    //region Reconfigure & update\n    reconfigure(config) {\n        // clear the cached headers\n        this.headers = null;\n        // Ensure correct ordering\n        this.setConfig(config);\n        this.trigger('reconfigure');\n    }\n    onTimeAxisReconfigure({ source : timeAxis, suppressRefresh }) {\n        if (this.viewPreset !== timeAxis.viewPreset) {\n            this.consumeViewPreset(timeAxis.viewPreset);\n        }\n        if (!suppressRefresh && timeAxis.count > 0) {\n            this.update();\n        }\n    }\n    /**\n     * Updates the view model current timeAxis configuration and available space.\n     * @param {Number} [availableSpace] The available space for the rendering of the axis (used in forceFit mode)\n     * @param {Boolean} [silent] Pass `true` to suppress the firing of the `update` event.\n     * @param {Boolean} [forceUpdate] Pass `true` to fire the `update` event even if the size has not changed.\n     * @internal\n     */\n    update(availableSpace, silent = false, forceUpdate = false) {\n        const\n            me                    = this,\n            { timeAxis, headers } = me,\n            spaceAvailable        = availableSpace !== 0;\n        // We're in configuration, or no change, quit\n        if (me.isConfiguring || (spaceAvailable && me._availableSpace === availableSpace)) {\n            if (forceUpdate) {\n                me.trigger('update');\n            }\n            return;\n        }\n        me._availableSpace = Math.max(availableSpace || me.availableSpace || 0, 0);\n        if (typeof me.availableSpace !== 'number') {\n            throw new Error('Invalid available space provided to TimeAxisModel');\n        }\n        me.columnConfig = [];\n        // The \"column width\" is considered to be the width of each tick in the lowest header row and this width\n        // has to be same for all cells in the lowest row.\n        const tickSize = me._tickSize = me.calculateTickSize(me.originalTickSize);\n        if (typeof tickSize !== 'number' || tickSize <= 0) {\n            throw new Error('Invalid timeAxis tick size');\n        }\n        // getSingleUnitInPixels results are memoized because of frequent calls during rendering.\n        me.unitToPixelsCache = {};\n        // totalSize is cached because of frequent calls which calculate it.\n        me._totalSize = null;\n        // Generate the underlying date ranges for each header row, which will provide input to the cell rendering\n        for (let pos = 0, { length } = headers; pos < length; pos++) {\n            const header = headers[pos];\n            if (header.cellGenerator) {\n                const headerCells = header.cellGenerator.call(me, timeAxis.startDate, timeAxis.endDate);\n                me.columnConfig[pos] = me.createHeaderRow(pos, header, headerCells);\n            }\n            else {\n                me.columnConfig[pos] = me.createHeaderRow(pos, header);\n            }\n        }\n        if (!silent) {\n            me.trigger('update');\n        }\n    }\n    //endregion\n    //region Date / position mapping\n    /**\n     * Returns the distance in pixels for a timespan with the given start and end date.\n     * @param {Date} start start date\n     * @param {Date} end end date\n     * @returns {Number} The length of the time span\n     * @category Date mapping\n     */\n    getDistanceBetweenDates(start, end) {\n        return this.getPositionFromDate(end) - this.getPositionFromDate(start);\n    }\n    /**\n     * Returns the distance in pixels for a time span\n     * @param {Number} durationMS Time span duration in ms\n     * @returns {Number} The length of the time span\n     * @category Date mapping\n     */\n    getDistanceForDuration(durationMs) {\n        return this.getSingleUnitInPixels('millisecond') * durationMs;\n    }\n    /**\n     * Gets the position of a date on the projected time axis or -1 if the date is not in the timeAxis.\n     * @param {Date} date the date to query for.\n     * @returns {Number} the coordinate representing the date\n     * @category Date mapping\n     */\n    getPositionFromDate(date, options = {}) {\n        const tick = this.getScaledTick(date, options);\n        if (tick === -1) {\n            return -1;\n        }\n        return this.tickSize * (tick - this.timeAxis.visibleTickStart);\n    }\n    // Translates a tick along the time axis to facilitate scaling events when excluding certain days or hours\n    getScaledTick(date, { respectExclusion, snapToNextIncluded, isEnd, min, max }) {\n        const\n            { timeAxis }      = this,\n            { include, unit } = timeAxis;\n        let tick = timeAxis.getTickFromDate(date);\n        if (tick !== -1 && respectExclusion && include) {\n            let tickChanged = false;\n            // Stretch if we are using a larger unit than 'hour', except if it is 'day'. If so, it is already handled\n            // by a cheaper reconfiguration of the ticks in `generateTicks`\n            if (include.hour && DH.compareUnits(unit, 'hour') > 0 && unit !== 'day') {\n                const\n                    { from, to, lengthFactor, center } = include.hour,\n                    // Original hours\n                    originalHours                      = date.getHours(),\n                    // Crop to included hours\n                    croppedHours                       = Math.min(Math.max(originalHours, from), to);\n                // If we are not asked to snap (when other part of span is not included) any cropped away hour\n                // should be considered excluded\n                if (!snapToNextIncluded && croppedHours !== originalHours) {\n                    return -1;\n                }\n                const\n                    // Should scale hour and smaller units (seconds will hardly affect visible result...)\n                    fractionalHours = croppedHours + date.getMinutes() / 60,\n                    // Number of hours from the center    |xxxx|123c----|xxx|\n                    hoursFromCenter = center - fractionalHours,\n                    // Step from center to stretch event  |x|112233c----|xxx|\n                    newHours        = center - hoursFromCenter * lengthFactor;\n                // Adding instead of setting to get a clone of the date, to not affect the original\n                date = DH.add(date, newHours - originalHours, 'h');\n                tickChanged = true;\n            }\n            if (include.day && DH.compareUnits(unit, 'day') > 0) {\n                const { from, to, lengthFactor, center } = include.day;\n                //region Crop\n                let checkDay = date.getDay();\n                // End date is exclusive, check the day before if at 00:00\n                if (isEnd && date.getHours() === 0 && date.getMinutes() === 0 && date.getSeconds() === 0 && date.getMilliseconds() === 0) {\n                    if (--checkDay < 0) {\n                        checkDay = 6;\n                    }\n                }\n                let addDays = 0;\n                if (checkDay < from || checkDay >= to) {\n                    // If end date is in view but start date is excluded, snap to next included day\n                    if (snapToNextIncluded) {\n                        // Step back to \"to-1\" (not inclusive) for end date\n                        if (isEnd) {\n                            addDays = (to - checkDay - 8) % 7;\n                        }\n                        // Step forward to \"from\" for start date\n                        else {\n                            addDays = (from - checkDay + 7) % 7;\n                        }\n                        date = DH.add(date, addDays, 'd');\n                        date = DH.startOf(date, 'd', false);\n                        // Keep end after start and vice versa\n                        if (\n                            (max && date.getTime() >= max) ||\n                            (min && date.getTime() <= min)\n                        ) {\n                            return -1;\n                        }\n                    }\n                    else {\n                        // day excluded at not snapping to next\n                        return -1;\n                    }\n                }\n                //endregion\n                const\n                    { weekStartDay } = timeAxis,\n                    // Center to stretch around, for some reason pre-calculated cannot be used for sundays :)\n                    fixedCenter      = date.getDay() === 0 ? 0 : center,\n                    // Should scale day and smaller units (minutes will hardly affect visible result...)\n                    fractionalDay    = date.getDay() + date.getHours() / 24, //+ dateClone.getMinutes() / (24 * 1440),\n                    // Number of days from the calculated center\n                    daysFromCenter   = fixedCenter - fractionalDay,\n                    // Step from center to stretch event\n                    newDay           = fixedCenter - daysFromCenter * lengthFactor;\n                // Adding instead of setting to get a clone of the date, to not affect the original\n                date = DH.add(date, newDay - fractionalDay + weekStartDay, 'd');\n                tickChanged = true;\n            }\n            // Now the date might start somewhere else (fraction of ticks)\n            if (tickChanged) {\n                // When stretching date might end up outside of time axis, making it invalid to use. Clip it to time axis\n                // to circumvent this\n                date = DH.constrain(date, timeAxis.startDate, timeAxis.endDate);\n                // Get a new tick based on the \"scaled\" date\n                tick = timeAxis.getTickFromDate(date);\n            }\n        }\n        return tick;\n    }\n    /**\n     * Gets the date for a position on the time axis\n     * @param {Number} position The page X or Y coordinate\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [allowOutOfRange=false] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} the Date corresponding to the xy coordinate\n     * @category Date mapping\n     */\n    getDateFromPosition(position, roundingMethod, allowOutOfRange = false) {\n        const\n            me           = this,\n            { timeAxis } = me,\n            tick         = me.getScaledPosition(position) / me.tickSize + timeAxis.visibleTickStart;\n        if (tick < 0 || tick > timeAxis.count) {\n            if (allowOutOfRange) {\n                let result;\n                // Subtract the correct number of tick units from the start date\n                if (tick < 0) {\n                    result = DH.add(timeAxis.startDate, tick, timeAxis.unit);\n                }\n                else {\n                    // Add the correct number of tick units to the end date\n                    result = DH.add(timeAxis.endDate, tick - timeAxis.count, timeAxis.unit);\n                }\n                // Honour the rounding requested\n                if (roundingMethod) {\n                    result = timeAxis[roundingMethod + 'Date'](result);\n                }\n                return result;\n            }\n            return null;\n        }\n        return timeAxis.getDateFromTick(tick, roundingMethod);\n    }\n    // Translates a position along the time axis to facilitate scaling events when excluding certain days or hours\n    getScaledPosition(position) {\n        const { include, unit, weekStartDay } = this.timeAxis;\n        // Calculations are\n        if (include) {\n            const dayWidth = this.getSingleUnitInPixels('day');\n            // Have to calculate day before hour to get end result correct\n            if (include.day && DH.compareUnits(unit, 'day') > 0) {\n                const { from, lengthFactor } = include.day,\n                    // Scaling happens within a week, determine position within it\n                    positionInWeek         = position % (dayWidth * 7),\n                    // Store were the week starts to be able to re-add it after scale\n                    weekStartPosition      = position - positionInWeek;\n                // Scale position using calculated length per day factor, adding the width of excluded days\n                position                     = positionInWeek / lengthFactor + (from - weekStartDay) * dayWidth + weekStartPosition;\n            }\n            // Hours are not taken into account when viewing days, since the day ticks are reconfigured in\n            // `generateTicks` instead\n            if (include.hour && DH.compareUnits(unit, 'hour') > 0 && unit !== 'day') {\n                const { from, lengthFactorExcl } = include.hour,\n                    hourWidth                  = this.getSingleUnitInPixels('hour'),\n                    // Scaling happens within a day, determine position within it\n                    positionInDay              = position % dayWidth,\n                    // Store were the day starts to be able to re-add it after scale\n                    dayStartPosition           = position - positionInDay;\n                // Scale position using calculated length per day factor, adding the width of excluded hours\n                position                         = positionInDay / lengthFactorExcl + from * hourWidth + dayStartPosition;\n            }\n        }\n        return position;\n    }\n    /**\n     * Returns the amount of pixels for a single unit\n     * @internal\n     * @returns {Number} The unit in pixel\n     */\n    getSingleUnitInPixels(unit) {\n        const me = this;\n        return me.unitToPixelsCache[unit] || (me.unitToPixelsCache[unit] = DH.getUnitToBaseUnitRatio(me.timeAxis.unit, unit, true) * me.tickSize / me.timeAxis.increment);\n    }\n    /**\n     * Returns the pixel increment for the current view resolution.\n     * @internal\n     * @returns {Number} The increment\n     */\n    get snapPixelAmount() {\n        if (this.snap) {\n            const { resolution } = this.timeAxis;\n            return (resolution.increment || 1) * this.getSingleUnitInPixels(resolution.unit);\n        }\n        return 1;\n    }\n    //endregion\n    //region Sizes\n    /**\n     * Get/set the current time column size (the width or height of a cell in the bottom-most time axis header row,\n     * depending on mode)\n     * @internal\n     * @property {Number}\n     */\n    get tickSize() {\n        return this._tickSize;\n    }\n    set tickSize(size) {\n        this.setTickSize(size, false);\n    }\n    setTickSize(size, suppressEvent) {\n        this._tickSize = this.originalTickSize = size;\n        this.update(undefined, suppressEvent);\n    }\n    get timeResolution() {\n        return this.timeAxis.resolution;\n    }\n    // Calculates the time column width/height based on the value defined viewPreset \"tickWidth/tickHeight\". It also\n    // checks for the forceFit view option and the snap, both of which impose constraints on the time column width\n    // configuration.\n    calculateTickSize(proposedSize) {\n        const\n            me                                  = this,\n            { forceFit, timeAxis, suppressFit } = me,\n            timelineUnit                        = timeAxis.unit;\n        let size  = 0,\n            ratio = 1; //Number.MAX_VALUE;\n        if (me.snap) {\n            const resolution = timeAxis.resolution;\n            ratio            = DH.getUnitToBaseUnitRatio(timelineUnit, resolution.unit) * resolution.increment;\n        }\n        if (!suppressFit) {\n            const fittingSize = me.availableSpace / timeAxis.visibleTickTimeSpan;\n            size = (forceFit || proposedSize < fittingSize) ? fittingSize : proposedSize;\n            if (ratio > 0 && (!forceFit || ratio < 1)) {\n                size = Math.max(1, ratio * size) / ratio;\n            }\n        }\n        else {\n            size = proposedSize;\n        }\n        return size;\n    }\n    /**\n     * Returns the total width/height of the time axis representation, depending on mode.\n     * @returns {Number} The width or height\n     * @internal\n     * @readonly\n     */\n    get totalSize() {\n        // Floor the space to prevent spurious overflow\n        return this._totalSize || (this._totalSize = Math.floor(this.tickSize * this.timeAxis.visibleTickTimeSpan));\n    }\n    /**\n     * Get/set the available space for the time axis representation. If size changes it will cause it to update its\n     * contents and fire the {@link #event-update} event.\n     * @internal\n     * @property {Number}\n     */\n    get availableSpace() {\n        return this._availableSpace;\n    }\n    set availableSpace(space) {\n        const me = this;\n        // We should only need to repaint fully if the tick width has changed (which will happen if forceFit is set, or if the full size of the time axis doesn't\n        // occupy the available space - and gets stretched\n        me._availableSpace = Math.max(0, space);\n        if (me._availableSpace > 0) {\n            const newTickSize = me.calculateTickSize(me.originalTickSize);\n            if (newTickSize > 0 && newTickSize !== me.tickSize) {\n                me.update();\n            }\n        }\n    }\n    //endregion\n    //region Fitting & snapping\n    /**\n     * Returns start dates for ticks at the specified level in format { date, isMajor }.\n     * @param {Number} level Level in headers array, `0` meaning the topmost...\n     * @param {Boolean} useLowestHeader Use lowest level\n     * @param getEnd\n     * @returns {Array}\n     * @internal\n     */\n    getDates(level = this.columnLinesFor, useLowestHeader = false, getEnd = false) {\n        const\n            me            = this,\n            ticks         = [],\n            linesForLevel = useLowestHeader ? me.lowestHeader : level,\n            majorLevel    = me.majorHeaderLevel,\n            levelUnit     = me.headers && me.headers[level].unit,\n            majorUnit     = majorLevel != null && me.headers && me.headers[majorLevel].unit,\n            validMajor    = majorLevel != null && DH.doesUnitsAlign(majorUnit, levelUnit),\n            hasGenerator  = !!(me.headers && me.headers[linesForLevel].cellGenerator);\n        if (hasGenerator) {\n            const cells = me.columnConfig[linesForLevel];\n            for (let i = 1, l = cells.length; i < l; i++) {\n                ticks.push({ date : cells[i].startDate });\n            }\n        }\n        else {\n            me.forEachInterval(linesForLevel, (start, end) => {\n                ticks.push({\n                    date    : getEnd ? end : start,\n                    // do not want to consider tick to be major tick, hence the check for majorHeaderLevel\n                    isMajor : majorLevel !== level && validMajor && me.isMajorTick(getEnd ? end : start)\n                });\n            });\n        }\n        return ticks;\n    }\n    get forceFit() {\n        return this._forceFit;\n    }\n    /**\n     * This function fits the time columns into the available space in the time axis column.\n     * @param {Boolean} suppressEvent `true` to skip firing the 'update' event.\n     * @internal\n     */\n    fitToAvailableSpace(suppressEvent) {\n        const proposedSize = Math.floor(this.availableSpace / this.timeAxis.visibleTickTimeSpan);\n        this.setTickSize(proposedSize, suppressEvent);\n    }\n    get snap() {\n        return this._snap;\n    }\n    /**\n     * Gets/sets the snap value for the model. Setting it will cause it to update its contents and fire the\n     * {@link #event-update} event.\n     * @property {Boolean}\n     * @internal\n     */\n    set snap(value) {\n        if (value !== this._snap) {\n            this._snap = value;\n            if (this.configured) {\n                this.update();\n            }\n        }\n    }\n    //endregion\n    //region Headers\n    // private\n    createHeaderRow(position, headerRowConfig, headerCells) {\n        const\n            me                            = this,\n            cells                         = [],\n            { align, headerCellCls = '' } = headerRowConfig,\n            today                         = DH.clearTime(new Date()),\n            { timeAxis }                  = me,\n            tickLevel                     = me.headers.length - 1,\n            createCellContext             = (start, end, i, isLast, data) => {\n                let value = DH.format(start, headerRowConfig.dateFormat);\n                const\n                    // So that we can use shortcut tickSize as the tickLevel cell width.\n                    // We can do this if the TimeAxis is aligned to start and end on tick boundaries\n                    // or if it's not the first or last tick.\n                    // getDistanceBetweenDates is an expensive operation.\n                    isInteriorTick = i > 0 && !isLast,\n                    cellData       = {\n                        align,\n                        start,\n                        end,\n                        value : data ? data.header : value,\n                        headerCellCls,\n                        width : tickLevel === position && me.owner && (timeAxis.fullTicks || isInteriorTick) ? me.owner.tickSize : me.getDistanceBetweenDates(start, end),\n                        index : i\n                    };\n                if (cellData.width === 0) {\n                    return;\n                }\n                // Vertical mode uses absolute positioning for header cells\n                cellData.coord = size - 1;\n                size += cellData.width;\n                me.headersDatesCache[position][start.getTime()] = 1;\n                if (headerRowConfig.renderer) {\n                    value = headerRowConfig.renderer.call(headerRowConfig.thisObj || me, start, end, cellData, i);\n                    cellData.value = value == null ? '' : value;\n                }\n                // To be able to style individual day cells, weekends or other important days\n                if (headerRowConfig.unit === 'day' && (!headerRowConfig.increment || headerRowConfig.increment === 1)) {\n                    cellData.headerCellCls += ' b-sch-dayheadercell-' + start.getDay();\n                    if (DH.clearTime(start, true) - today === 0) {\n                        cellData.headerCellCls += ' b-sch-dayheadercell-today';\n                    }\n                }\n                cells.push(cellData);\n            };\n        let size = 0;\n        me.headersDatesCache[position] = {};\n        if (headerCells) {\n            headerCells.forEach((cellData, i) => createCellContext(cellData.start, cellData.end, i, i === headerCells.length - 1, cellData));\n        }\n        else {\n            me.forEachInterval(position, createCellContext);\n        }\n        return cells;\n    }\n    get mainHeader() {\n        return ('mainHeaderLevel' in this) ? this.headers[this.mainHeaderLevel] : this.bottomHeader;\n    }\n    get bottomHeader() {\n        return this.headers[this.headers.length - 1];\n    }\n    get lowestHeader() {\n        return this.headers.length - 1;\n    }\n    /**\n     * This method is meant to return the level of the header which 2nd lowest.\n     * It is used for {@link #function-isMajorTick} method\n     * @returns {String}\n     * @private\n     */\n    get majorHeaderLevel() {\n        const { headers } = this;\n        if (headers) {\n            return Math.max(headers.length - 2, 0);\n        }\n        return null;\n    }\n    //endregion\n    //region Ticks\n    /**\n     * For vertical view (and column lines plugin) we sometimes want to know if current tick starts along with the\n     * upper header level.\n     * @param {Date} date\n     * @returns {Boolean}\n     * @private\n     */\n    isMajorTick(date) {\n        const nextLevel = this.majorHeaderLevel;\n        // if forceFit is used headersDatesCache won\u00B4t have been generated yet on the first call here,\n        // since no size is set yet\n        return nextLevel != null && this.headersDatesCache[nextLevel] && this.headersDatesCache[nextLevel][date.getTime()] || false;\n    }\n    /**\n     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.\n     * Return false to break the iteration.\n     * @param {Number} position The index of the header in the headers array.\n     * @param {Function} iteratorFn The function to call, will be called with start date, end date and \"tick index\"\n     * @param {Object} [thisObj] `this` reference for the function\n     * @internal\n     */\n    forEachInterval(position, iteratorFn, thisObj = this) {\n        const { headers, timeAxis } = this;\n        if (headers) {\n            // This is the lowest header row, which should be fed the data in the tickStore (or a row above using same unit)\n            if (position === headers.length - 1) {\n                timeAxis.forEach((r, index) =>\n                    iteratorFn.call(thisObj, r.startDate, r.endDate, index, index === timeAxis.count - 1)\n                );\n            }\n            // All other rows\n            else {\n                const header = headers[position];\n                timeAxis.forEachAuxInterval(header.unit, header.increment, iteratorFn, thisObj);\n            }\n        }\n    }\n    /**\n     * Calls the supplied iterator function once per interval. The function will be called with three parameters, start date and end date and an index.\n     * Return false to break the iteration.\n     * @internal\n     * @param {Function} iteratorFn The function to call\n     * @param {Object} [thisObj] `this` reference for the function\n     */\n    forEachMainInterval(iteratorFn, thisObj) {\n        this.forEachInterval(this.mainHeaderLevel, iteratorFn, thisObj);\n    }\n    //endregion\n    //region ViewPreset\n    consumeViewPreset(preset) {\n        const me = this;\n        // clear the cached headers\n        me.headers = null;\n        me.getConfig('tickSize');\n        // Since we are bypassing the tickSize setter below, ensure that\n        // the config initial setter has been removed by referencing the property.\n        // We only do this to avoid multiple updates from this.\n        me.viewPreset = preset;\n        Object.assign(me, {\n            headers         : preset.headers,\n            columnLinesFor  : preset.columnLinesFor,\n            mainHeaderLevel : preset.mainHeaderLevel,\n            _tickSize       : me.isHorizontal ? preset.tickWidth : preset.tickHeight\n        });\n        me.originalTickSize = me.tickSize;\n    }\n    //endregion\n}\nTimeAxisViewModel._$name = 'TimeAxisViewModel';", "import Base from '../../../Core/Base.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\n// Used to avoid having to create huge amounts of Date objects\nconst tempDate = new Date();\n/**\n * @module Scheduler/view/mixin/TimelineDateMapper\n */\n/**\n * Mixin that contains functionality to convert between coordinates and dates etc.\n *\n * @mixin\n */\nexport default Target => class TimelineDateMapper extends (Target || Base) {\n    static $name = 'TimelineDateMapper';\n    static configurable = {\n        /**\n         * Set to `true` to snap to the current time resolution increment while interacting with scheduled events.\n         *\n         * The time resolution increment is either determined by the currently applied view preset, or it can be\n         * overridden using {@link #property-timeResolution}.\n         *\n         * <div class=\"note\">When the {@link Scheduler/view/mixin/TimelineEventRendering#config-fillTicks} option is\n         * enabled, snapping will align to full ticks, regardless of the time resolution.</div>\n         *\n         * @prp {Boolean}\n         * @default\n         * @category Scheduled events\n         */\n        snap : false\n    };\n    //region Coordinate <-> Date\n    getRtlX(x) {\n        if (this.rtl && this.isHorizontal) {\n            x = this.timeAxisViewModel.totalSize - x;\n        }\n        return x;\n    }\n    /**\n     * Gets the date for an X or Y coordinate, either local to the view element or the page based on the 3rd argument.\n     * If the coordinate is not in the currently rendered view, null will be returned unless the `allowOutOfRange`\n     * parameter is passed a `true`.\n     * @param {Number} coordinate The X or Y coordinate\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [local] true if the coordinate is local to the scheduler view element\n     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} The Date corresponding to the X or Y coordinate\n     * @category Dates\n     */\n    getDateFromCoordinate(coordinate, roundingMethod, local = true, allowOutOfRange = false, ignoreRTL = false) {\n        if (!local) {\n            coordinate = this.currentOrientation.translateToScheduleCoordinate(coordinate);\n        }\n        // Time axis is flipped for RTL\n        if (!ignoreRTL) {\n            coordinate = this.getRtlX(coordinate);\n        }\n        return this.timeAxisViewModel.getDateFromPosition(coordinate, roundingMethod, allowOutOfRange);\n    }\n    getDateFromCoord(options) {\n        return this.getDateFromCoordinate(options.coord, options.roundingMethod, options.local, options.allowOutOfRange, options.ignoreRTL);\n    }\n    /**\n     * Gets the date for an XY coordinate regardless of the orientation of the time axis.\n     * @param {Array} xy The page X and Y coordinates\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [local] true if the coordinate is local to the scheduler element\n     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} the Date corresponding to the xy coordinate\n     * @category Dates\n     */\n    getDateFromXY(xy, roundingMethod, local = true, allowOutOfRange = false) {\n        return this.currentOrientation.getDateFromXY(xy, roundingMethod, local, allowOutOfRange);\n    }\n    /**\n     * Gets the time for a DOM event such as 'mousemove' or 'click' regardless of the orientation of the time axis.\n     * @param {Event} e the Event instance\n     * @param {'floor'|'round'|'ceil'} [roundingMethod] Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Boolean} [allowOutOfRange] By default, this returns `null` if the position is outside\n     * of the time axis. Pass `true` to attempt to calculate a date outside of the time axis.\n     * @returns {Date} The date corresponding to the EventObject's position along the orientation of the time axis.\n     * @category Dates\n     */\n    getDateFromDomEvent(e, roundingMethod, allowOutOfRange = false) {\n        return this.getDateFromXY([e.pageX, e.pageY], roundingMethod, false, allowOutOfRange);\n    }\n    /**\n     * Gets the start and end dates for an element Region\n     * @param {Core.helper.util.Rectangle} rect The rectangle to map to start and end dates\n     * @param {'floor'|'round'|'ceil'} roundingMethod Rounding method to use. 'floor' to take the tick (lowest header\n     * in a time axis) start date, 'round' to round the value to nearest increment or 'ceil' to take the tick end date\n     * @param {Number} duration The duration in MS of the underlying event\n     * @returns {Object} an object containing start/end properties\n     */\n    getStartEndDatesFromRectangle(rect, roundingMethod, duration, allowOutOfRange = false) {\n        const\n            me               = this,\n            { isHorizontal } = me,\n            startPos         = isHorizontal ? rect.x : rect.top,\n            endPos           = isHorizontal ? rect.right : rect.bottom;\n        let start, end;\n        // Element within bounds\n        if (startPos >= 0 && endPos < me.timeAxisViewModel.totalSize) {\n            start = me.getDateFromCoordinate(startPos, roundingMethod, true);\n            end = me.getDateFromCoordinate(endPos, roundingMethod, true);\n        }\n        // Starts before, start is worked backwards from end\n        else if (startPos < 0) {\n            end = me.getDateFromCoordinate(endPos, roundingMethod, true, allowOutOfRange);\n            start = end && DateHelper.add(end, -duration, 'ms');\n        }\n        // Ends after, end is calculated from the start\n        else {\n            start = me.getDateFromCoordinate(startPos, roundingMethod, true, allowOutOfRange);\n            end = start && DateHelper.add(start, duration, 'ms');\n        }\n        return {\n            start, end\n        };\n    }\n    //endregion\n    //region Date display\n    /**\n     * Method to get a displayed end date value, see {@link #function-getFormattedEndDate} for more info.\n     * @private\n     * @param {Date} endDate The date to format\n     * @param {Date} startDate The start date\n     * @returns {Date} The date value to display\n     */\n    getDisplayEndDate(endDate, startDate) {\n        if (\n            // If time is midnight,\n            endDate.getHours() === 0 && endDate.getMinutes() === 0 &&\n            // and end date is greater then start date\n            (!startDate || !(endDate.getYear() === startDate.getYear() && endDate.getMonth() === startDate.getMonth() && endDate.getDate() === startDate.getDate())) &&\n            // and UI display format doesn't contain hour info (in this case we'll just display the exact date)\n            !DateHelper.formatContainsHourInfo(this.displayDateFormat)\n        ) {\n            // format the date inclusively as 'the whole previous day'.\n            endDate = DateHelper.add(endDate, -1, 'day');\n        }\n        return endDate;\n    }\n    /**\n     * Method to get a formatted end date for a scheduled event, the grid uses the \"displayDateFormat\" property defined in the current view preset.\n     * End dates are formatted as 'inclusive', meaning when an end date falls on midnight and the date format doesn't involve any hour/minute information,\n     * 1ms will be subtracted (e.g. 2010-01-08T00:00:00 will first be modified to 2010-01-07 before being formatted).\n     * @private\n     * @param {Date} endDate The date to format\n     * @param {Date} startDate The start date\n     * @returns {String} The formatted date\n     */\n    getFormattedEndDate(endDate, startDate) {\n        return this.getFormattedDate(this.getDisplayEndDate(endDate, startDate));\n    }\n    //endregion\n    //region Other date functions\n    /**\n     * Gets the x or y coordinate relative to the scheduler element, or page coordinate (based on the 'local' flag)\n     * If the coordinate is not in the currently rendered view, -1 will be returned.\n     * @param {Date|Number} date the date to query for (or a date as ms)\n     * @param {Boolean|Object} options true to return a coordinate local to the scheduler view element (defaults to true),\n     * also accepts a config object like { local : true }.\n     * @returns {Number} the x or y position representing the date on the time axis\n     * @category Dates\n     */\n    getCoordinateFromDate(date, options = true) {\n        const\n            me                    = this,\n            { timeAxisViewModel } = me,\n            {\n                isContinuous,\n                startMS,\n                endMS,\n                startDate,\n                endDate,\n                unit\n            }                     = me.timeAxis,\n            dateMS                = date.valueOf();\n        // Avoiding to break the API while allowing passing options through to getPositionFromDate()\n        if (options === true) {\n            options = {\n                local : true\n            };\n        }\n        else if (!options) {\n            options = {\n                local : false\n            };\n        }\n        else if (!('local' in options)) {\n            options.local = true;\n        }\n        let pos;\n        if (!(date instanceof Date)) {\n            tempDate.setTime(date);\n            date = tempDate;\n        }\n        // Shortcut for continuous time axis that is using a unit that can be reliably translated to days (or smaller)\n        if (isContinuous &&\n            date.getTimezoneOffset() === startDate.getTimezoneOffset() &&\n            startDate.getTimezoneOffset() === endDate.getTimezoneOffset() &&\n            DateHelper.getUnitToBaseUnitRatio(unit, 'day') !== -1\n        ) {\n            if (dateMS < startMS || dateMS > endMS) {\n                return -1;\n            }\n            pos = (dateMS - startMS) / (endMS - startMS) * timeAxisViewModel.totalSize;\n        }\n        // Non-continuous or using for example months (vary in length)\n        else {\n            pos = timeAxisViewModel.getPositionFromDate(date, options);\n        }\n        // RTL coords from the end of the time axis\n        if (me.rtl && me.isHorizontal && !options?.ignoreRTL) {\n            pos = timeAxisViewModel.totalSize - pos;\n        }\n        if (!options.local) {\n            pos = me.currentOrientation.translateToPageCoordinate(pos);\n        }\n        return pos;\n    }\n    /**\n     * Returns the distance in pixels for the time span in the view.\n     * @param {Date} startDate The start date of the span\n     * @param {Date} endDate The end date of the span\n     * @returns {Number} The distance in pixels\n     * @category Dates\n     */\n    getTimeSpanDistance(startDate, endDate) {\n        return this.timeAxisViewModel.getDistanceBetweenDates(startDate, endDate);\n    }\n    /**\n     * Returns the center date of the currently visible timespan of scheduler.\n     *\n     * @property {Date}\n     * @readonly\n     * @category Dates\n     */\n    get viewportCenterDate() {\n        const { timeAxis, timelineScroller } = this;\n        // Take the easy way if the axis is continuous.\n        // We can just work out how far along the time axis the viewport center is.\n        if (timeAxis.isContinuous) {\n            // The offset from the start of the whole time axis\n            const timeAxisOffset = (timelineScroller.position + timelineScroller.clientSize / 2) / timelineScroller.scrollSize;\n            return new Date(timeAxis.startMS + (timeAxis.endMS - timeAxis.startMS) * timeAxisOffset);\n        }\n        return this.getDateFromCoordinate(timelineScroller.position + timelineScroller.clientSize / 2);\n    }\n    get viewportCenterDateCached() {\n        return this.cachedCenterDate || (this.cachedCenterDate = this.viewportCenterDate);\n    }\n    //endregion\n    //region TimeAxis getters/setters\n    /**\n     * Gets/sets the current time resolution object, which contains a unit identifier and an increment count\n     * `{ unit, increment }`. This value means minimal task duration you can create using UI.\n     *\n     * For example when you drag create a task or drag & drop a task, if increment is 5 and unit is 'minute'\n     * that means that you can create tasks in 5 minute increments, or move it in 5 minute steps.\n     *\n     * This value is taken from viewPreset {@link Scheduler.preset.ViewPreset#field-timeResolution timeResolution}\n     * config by default. When supplying a `Number` to the setter only the `increment` is changed and the `unit` value\n     * remains untouched.\n     *\n     * ```javascript\n     * timeResolution : {\n     *   unit      : 'minute',  //Valid values are \"millisecond\", \"second\", \"minute\", \"hour\", \"day\", \"week\", \"month\", \"quarter\", \"year\".\n     *   increment : 5\n     * }\n     * ```\n     *\n     * <div class=\"note\">When the {@link Scheduler/view/mixin/TimelineEventRendering#config-fillTicks} option is\n     * enabled, the resolution will be in full ticks regardless of configured value.</div>\n     *\n     * @property {Object|Number}\n     * @category Dates\n     */\n    get timeResolution() {\n        return this.timeAxis.resolution;\n    }\n    set timeResolution(resolution) {\n        this.timeAxis.resolution = (typeof resolution === 'number') ? {\n            increment : resolution,\n            unit      : this.timeAxis.resolution.unit\n        } : resolution;\n    }\n    //endregion\n    //region Snap\n    get snap() {\n        return this._timeAxisViewModel?.snap ?? this._snap;\n    }\n    updateSnap(snap) {\n        if (!this.isConfiguring) {\n            this.timeAxisViewModel.snap = snap;\n            this.timeAxis.forceFullTicks = snap && this.fillTicks;\n        }\n    }\n    //endregion\n    onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX, scrollingToCenter) {\n        // Invalidate cached center date unless we are scrolling to center on it.\n        if (!scrollingToCenter) {\n            this.cachedCenterDate = null;\n        }\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport DomDataStore from '../../../Core/data/DomDataStore.js';\nimport GlobalEvents from '../../../Core/GlobalEvents.js';\n/**\n * @module Scheduler/view/mixin/TimelineDomEvents\n */\nconst { eventNameMap } = EventHelper;\n/**\n * An object which encapsulates a schedule timeline tick context based on a DOM event. This will include\n * the row and resource information and the tick and time information for a DOM pointer event detected\n * in the timeline.\n * @typedef {Object} TimelineContext\n * @property {Event} domEvent The DOM event which triggered the context change.\n * @property {HTMLElement} eventElement If the `domEvent` was on an event bar, this will be the event bar element.\n * @property {HTMLElement} cellElement The cell element under the `domEvent`\n * @property {Date} date The date corresponding to the `domEvent` position in the timeline\n * @property {Scheduler.model.TimeSpan} tick A {@link Scheduler.model.TimeSpan} record which encapsulates the contextual tick\n * @property {Number} tickIndex The contextual tick index. This may be fractional.\n * @property {Number} tickParentIndex The integer contextual tick index.\n * @property {Date} tickStartDate The start date of the contextual tick.\n * @property {Date} tickEndDate The end date of the contextual tick.\n * @property {Grid.row.Row} row The contextual {@link Grid.row.Row}\n * @property {Number} index The contextual row index\n * @property {Scheduler.model.EventModel} [eventRecord] The contextual event record (if any) if the event source is a `Scheduler`\n * @property {Scheduler.model.AssignmentModel} [assignmentRecord] The contextual assignment record (if any) if the event source is a `Scheduler`\n * @property {Scheduler.model.ResourceModel} [resourceRecord] The contextual resource record(if any)  if the event source is a `Scheduler`\n */\n/**\n * Mixin that handles dom events (click etc) for scheduler and rendered events.\n *\n * @mixin\n */\nexport default Target => class TimelineDomEvents extends (Target || Base) {\n    /**\n     * Fires after a click on a time axis cell\n     * @event timeAxisHeaderClick\n     * @param {Scheduler.column.TimeAxisColumn|Scheduler.column.VerticalTimeAxisColumn} source The column object\n     * @param {Date} startDate The start date of the header cell\n     * @param {Date} endDate The end date of the header cell\n     * @param {Event} event The event object\n     */\n    /**\n     * Fires after a double click on a time axis cell\n     * @event timeAxisHeaderDblClick\n     * @param {Scheduler.column.TimeAxisColumn|Scheduler.column.VerticalTimeAxisColumn} source The column object\n     * @param {Date} startDate The start date of the header cell\n     * @param {Date} endDate The end date of the header cell\n     * @param {Event} event The event object\n     */\n    /**\n     * Fires after a right click on a time axis cell\n     * @event timeAxisHeaderContextMenu\n     * @param {Scheduler.column.TimeAxisColumn|Scheduler.column.VerticalTimeAxisColumn} source The column object\n     * @param {Date} startDate The start date of the header cell\n     * @param {Date} endDate The end date of the header cell\n     * @param {Event} event The event object\n     */\n    static $name = 'TimelineDomEvents';\n    //region Default config\n    static configurable = {\n        /**\n         * The currently hovered timeline context. This is updated as the mouse or pointer moves over the timeline.\n         * @member {TimelineContext} timelineContext\n         * @readonly\n         * @category Dates\n         */\n        timelineContext : {\n            $config : {\n                // Reject non-changes so that when set from scheduleMouseMove and EventMouseMove,\n                // we only update the context and fire events when it changes.\n                equal(c1, c2) {\n                    // index is the resource index, tickParentIndex is the\n                    // tick's index in the TimeAxis.\n                    return c1?.index === c2?.index &&\n                        c1?.tickParentIndex === c2?.tickParentIndex &&\n                        !((c1?.tickStartDate || 0) - (c2?.tickStartDate || 0));\n                }\n            }\n        },\n        updateTimelineContextOnScroll : false,\n        /**\n         * Set to `true` to ignore reacting to DOM events (mouseover/mouseout etc) while scrolling. Useful if you\n         * want to maximize scroll performance.\n         * @config {Boolean}\n         * @default false\n         */\n        ignoreDomEventsWhileScrolling : null\n    };\n    static properties = {\n        schedulerEvents : {\n            pointermove : 'handleScheduleEvent',\n            mouseover   : 'handleScheduleEvent',\n            mousedown   : 'handleScheduleEvent',\n            mouseup     : 'handleScheduleEvent',\n            click       : 'handleScheduleEvent',\n            dblclick    : 'handleScheduleEvent',\n            contextmenu : 'handleScheduleEvent',\n            mousemove   : 'handleScheduleEvent',\n            mouseout    : 'handleScheduleEvent'\n        }\n    };\n    static delayable = {\n        // Allow the scroll event to complete in its thread, and dispatch the mousemove event next AF\n        onScheduleScroll : 'raf'\n    };\n    // Currently hovered events (can be parent + child)\n    hoveredEvents = new Set();\n    //endregion\n    //region Init\n    /**\n     * Adds listeners for DOM events for the scheduler and its events.\n     * Which events is specified in Scheduler#schedulerEvents.\n     * @private\n     */\n    initDomEvents() {\n        const\n            me = this,\n            { schedulerEvents }  = me;\n        // Set thisObj and element of the configured listener specs.\n        schedulerEvents.element = me.timeAxisSubGridElement;\n        schedulerEvents.thisObj = me;\n        EventHelper.on(schedulerEvents);\n        EventHelper.on({\n            element    : me.timeAxisSubGridElement,\n            mouseleave : 'handleScheduleLeaveEvent',\n            capture    : true,\n            thisObj    : me\n        });\n        // This is to handle scroll events while the mouse is over the schedule.\n        // For example magic mouse or touchpad scrolls, or scrolls caused by keyboard\n        // navigation while the mouse happens to be over the schedule.\n        // The context must update. We must consider any scroll because the document\n        // or some other wrapping element could be scrolling the Scheduler under the mouse.\n        if (me.updateTimelineContextOnScroll && BrowserHelper.supportsPointerEventConstructor) {\n            EventHelper.on({\n                element : document,\n                scroll  : 'onScheduleScroll',\n                capture : true,\n                thisObj : me\n            });\n        }\n    };\n    //endregion\n    //region Event handling\n    getTimeSpanMouseEventParams(eventElement, event) {\n        throw new Error('Implement in subclass');\n    }\n    getScheduleMouseEventParams(cellData, event) {\n        throw new Error('Implement in subclass');\n    }\n    /**\n     * Wraps dom Events for the scheduler and event bars and fires as our events.\n     * For example click -> scheduleClick or eventClick\n     * @private\n     * @param event\n     */\n    handleScheduleEvent(event) {\n        const me = this;\n        if (me.ignoreDomEventsWhileScrolling && (me.scrolling || me.timeAxisSubGrid.scrolling)) {\n            return;\n        }\n        const timelineContext = me.getTimelineEventContext(event);\n        // Cache the last pointer event so that  when scrolling below the mouse\n        // we can inject mousemove events at that point.\n        me.lastPointerEvent = event;\n        // We are over the schedule region\n        if (timelineContext) {\n            // Only fire a scheduleXXXX event if we are *not* over an event.\n            // If over an event fire (event|task)XXXX.\n            me.trigger(`${timelineContext.eventElement ? me.scheduledEventName : 'schedule'}${eventNameMap[event.type] || StringHelper.capitalize(event.type)}`, timelineContext);\n        }\n        // If the context has changed, updateTimelineContext will fire events\n        me.timelineContext = timelineContext;\n    }\n    handleScheduleLeaveEvent(event) {\n        if (event.target === this.timeAxisSubGridElement) {\n            this.handleScheduleEvent(event);\n        }\n    }\n    /**\n     * This handles the scheduler being scrolled below the mouse by trackpad or keyboard events.\n     * The context, if present needs to be recalculated.\n     * @private\n     */\n    onScheduleScroll({ target }) {\n        const me = this;\n        // If the latest mouse event resulted in setting a context, we need to reproduce that event at the same clientX,\n        // clientY in order to keep the context up to date while scrolling.\n        // If the scroll is because of a pan feature drag (on us or a partner), we must not do this.\n        // Target might be removed in salesforce by Locker Service if scroll event occurs on body\n        if (\n            target && me.updateTimelineContextOnScroll && !me.features.pan?.isActive &&\n            !me.partners.some(p => p.features.pan?.isActive) &&\n            (target.contains(me.element) || me.bodyElement.contains(target))\n        ) {\n            const { timelineContext, lastPointerEvent } = me;\n            if (timelineContext) {\n                const\n                    targetElement = DomHelper.elementFromPoint(timelineContext.domEvent.clientX, timelineContext.domEvent.clientY),\n                    pointerEvent  = new BrowserHelper.PointerEventConstructor('pointermove', lastPointerEvent),\n                    mouseEvent    = new MouseEvent('mousemove', lastPointerEvent);\n                // See https://github.com/bryntum/support/issues/6274\n                // The pointerId does not propagate correctly on the synthetic PointerEvent, but also is readonly, so\n                // redefine the property. This is required by Ext JS gesture publisher which tracks pointer movements\n                // while a pointer is down. Without the correct pointerId, Ext JS would see this move as a \"missed\"\n                // pointerdown and forever await its pointerup (i.e., it would get stuck in the activeTouches). This\n                // would cause all future events to be perceived as part of or the end of a drag and would never again\n                // dispatch pointer events correctly. Finally, lastPointerEvent.pointerId is often incorrect (undefined\n                // in fact), so check the most recent pointerdown/touchstart event and default to 1\n                Object.defineProperty(pointerEvent, 'pointerId', {\n                    value : GlobalEvents.currentPointerDown?.pointerId ?? GlobalEvents.currentTouch?.identifier ?? 1\n                });\n                // Drag code should ignore these synthetic events\n                pointerEvent.scrollInitiated = mouseEvent.scrollInitiated = true;\n                // Emulate the correct browser sequence for mouse move events\n                targetElement?.dispatchEvent(pointerEvent);\n                targetElement?.dispatchEvent(mouseEvent);\n            }\n        }\n    }\n    updateTimelineContext(context, oldContext) {\n        /**\n         * Fired when the pointer-activated {@link #property-timelineContext} has changed.\n         * @event timelineContextChange\n         * @param {TimelineContext} oldContext The tick/resource context being deactivated.\n         * @param {TimelineContext} context The tick/resource context being activated.\n         */\n        this.trigger('timelineContextChange', { oldContext, context });\n        if (context && !oldContext) {\n            this.trigger('scheduleMouseEnter', context);\n        }\n        else if (!context) {\n            this.trigger('scheduleMouseLeave', { event : oldContext.event });\n        }\n    }\n    /**\n     * Gathers contextual information about the schedule contextual position of the passed event.\n     *\n     * Used by schedule mouse event handlers, but also by the scheduleContext feature.\n     * @param {Event} domEvent The DOM event to gather context for.\n     * @returns {TimelineContext} the schedule DOM event context\n     * @internal\n     */\n    getTimelineEventContext(domEvent) {\n        const\n            me           = this,\n            eventElement = domEvent.target.closest(me.eventInnerSelector),\n            cellElement  = me.getCellElementFromDomEvent(domEvent);\n        if (cellElement) {\n            const date = me.getDateFromDomEvent(domEvent, 'floor');\n            if (!date) {\n                return;\n            }\n            const\n                cellData    = DomDataStore.get(cellElement),\n                mouseParams = eventElement ? me.getTimeSpanMouseEventParams(eventElement, domEvent) : me.getScheduleMouseEventParams(cellData, domEvent);\n            if (!mouseParams) {\n                return;\n            }\n            const\n                index     = me.isVertical ? me.resourceStore.indexOf(mouseParams.resourceRecord) : cellData.row.dataIndex,\n                tickIndex = me.timeAxis.getTickFromDate(date),\n                tick      = me.timeAxis.getAt(Math.floor(tickIndex));\n            if (tick) {\n                return {\n                    isTimelineContext : true,\n                    domEvent,\n                    eventElement,\n                    cellElement,\n                    index,\n                    tick,\n                    tickIndex,\n                    date,\n                    tickStartDate     : tick.startDate,\n                    tickEndDate       : tick.endDate,\n                    tickParentIndex   : tick.parentIndex,\n                    row               : cellData.row,\n                    event             : domEvent,\n                    ...mouseParams\n                };\n            }\n        }\n    }\n    getCellElementFromDomEvent({ target, clientY, type }) {\n        const\n            me           = this,\n            {\n                isVertical,\n                foregroundCanvas\n            }            = me,\n            eventElement = target.closest(me.eventSelector);\n        // If event was on an event bar, calculate the cell.\n        if (eventElement) {\n            const record = !isVertical && (me.resolveRowRecord(eventElement) || me.store.getAt(me.rowManager.getRowAt(clientY, false).dataIndex));\n            return me.getCell({\n                [isVertical ? 'row' : 'record'] : isVertical ? 0 : record,\n                column                          : me.timeAxisColumn\n            });\n        }\n        // If event was triggered by an element in the foreground canvas, but not an event element\n        // we need to ascertain the cell \"behind\" that element to be able to create the context.\n        else if (foregroundCanvas.contains(target)) {\n            // Only trigger a Scheduler event if the event was on the background itself.\n            // Otherwise, we will trigger unexpected events on things like dependency lines which historically\n            // have never triggered scheduleXXXX events. The exception to this is the mousemove event which\n            // needs to always fire so that timelineContext and scheduleTooltip correctly track the mouse\n            if (target === foregroundCanvas || type === 'mousemove') {\n                return me.rowManager.getRowAt(clientY, false)?.getCell(me.timeAxisColumn.id);\n            }\n        }\n        else {\n            // Event was inside a row, or on a row border.\n            return target.matches('.b-grid-row') ? target.firstElementChild : target.closest(me.timeCellSelector);\n        }\n    }\n    // Overridden by ResourceTimeRanges to \"pass events through\" to the schedule\n    matchScheduleCell(element) {\n        return element.closest(this.timeCellSelector);\n    }\n    onElementMouseButtonEvent(event) {\n        const targetCell = event.target.closest('.b-sch-header-timeaxis-cell');\n        if (targetCell) {\n            const\n                me           = this,\n                position     = targetCell.parentElement.dataset.headerPosition,\n                headerCells  = me.timeAxisViewModel.columnConfig[position],\n                index        = me.timeAxis.isFiltered ? headerCells.findIndex(cell => cell.index == targetCell.dataset.tickIndex) : targetCell.dataset.tickIndex,\n                cellConfig   = headerCells[index],\n                contextMenu  = me.features.contextMenu;\n            // Skip same events with Grid context menu triggerEvent\n            if (!contextMenu || event.type !== contextMenu.triggerEvent) {\n                this.trigger(`timeAxisHeader${StringHelper.capitalize(event.type)}`, {\n                    startDate : cellConfig.start,\n                    endDate   : cellConfig.end,\n                    event\n                });\n            }\n        }\n    }\n    onElementMouseDown(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementMouseDown(event);\n    }\n    onElementClick(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementClick(event);\n    }\n    onElementDblClick(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementDblClick(event);\n    }\n    onElementContextMenu(event) {\n        this.onElementMouseButtonEvent(event);\n        super.onElementContextMenu(event);\n    }\n    /**\n     * Relays mouseover events as eventmouseenter if over rendered event.\n     * Also adds Scheduler#overScheduledEventClass to the hovered element.\n     * @private\n     */\n    onElementMouseOver(event) {\n        const\n            me                = this;\n        if (me.ignoreDomEventsWhileScrolling && (me.scrolling || me.timeAxisSubGrid.scrolling)) {\n            return;\n        }\n        super.onElementMouseOver(event);\n        const\n            { target }        = event,\n            { hoveredEvents } = me;\n        // We must be over the event or dependency terminal hover area\n        if ((target.closest(me.eventInnerSelector) || target.matches('.b-sch-terminal-hover-area')) && !me.features.eventDrag?.isDragging) {\n            const eventElement = target.closest(me.eventSelector);\n            if (!hoveredEvents.has(eventElement) && !me.preventOverCls) {\n                hoveredEvents.add(eventElement);\n                eventElement.classList.add(me.overScheduledEventClass);\n                const params = me.getTimeSpanMouseEventParams(eventElement, event);\n                if (params) {\n                    // do not fire this event if model cannot be found\n                    // this can be the case for \"b-sch-dragcreator-proxy\" elements for example\n                    me.trigger(`${me.scheduledEventName}MouseEnter`, params);\n                }\n            }\n        }\n        else if (hoveredEvents.size) {\n            me.unhoverAll(event);\n        }\n    }\n    /**\n     * Relays mouseout events as eventmouseleave if out from rendered event.\n     * Also removes Scheduler#overScheduledEventClass from the hovered element.\n     * @private\n     */\n    onElementMouseOut(event) {\n        const\n            me                        = this,\n            { features }              = me,\n            { target, relatedTarget } = event;\n        // If it's not a mouseout into an event (or anything inside one of the schedule's\n        // extra drawing canvases), continue up to the Grid base.\n        // A mouseout cell->(event|dep-line|timeRange) should *not* trigger a mouseout of the cell\n        // or row even though the event element is in fact outside. To a user, the event is in the cell.\n        if (!relatedTarget?.closest('.b-sch-canvas *')) {\n            super.onElementMouseOut(event);\n        }\n        const\n            eventWrap      = target.closest(me.eventSelector),\n            eventInner     = eventWrap?.querySelector(me.eventInnerSelector),\n            timeSpanRecord = eventWrap && me.resolveTimeSpanRecord(eventWrap);\n        // We must be over the event bar\n        if (eventInner && timeSpanRecord && me.hoveredEvents.has(eventWrap) && !features.eventDrag?.isDragging) {\n            // out to child or terminal hover area shouldn't count...\n            if (relatedTarget && (DomHelper.isDescendant(eventInner, relatedTarget) || relatedTarget.matches('.b-sch-terminal-hover-area'))) {\n                return;\n            }\n        }\n        if (eventWrap) {\n            me.unhover(eventWrap, event);\n        }\n    }\n    unhover(element, event) {\n        const me = this;\n        element.classList.remove(me.overScheduledEventClass);\n        me.trigger(`${me.scheduledEventName}MouseLeave`, me.getTimeSpanMouseEventParams(element, event));\n        me.hoveredEvents.delete(element);\n    }\n    unhoverAll(event) {\n        for (const element of this.hoveredEvents) {\n            !element.isReleased && !element.classList.contains('b-released') && this.unhover(element, event);\n        }\n        // Might not be empty because of conditional unhover above\n        this.hoveredEvents.clear();\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport PresetManager from '../../preset/PresetManager.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport PresetStore from '../../preset/PresetStore.js';\nimport DateHelper, { unitMagnitudes } from '../../../Core/helper/DateHelper.js';\n/**\n * @module Scheduler/view/mixin/TimelineViewPresets\n */\n/**\n * View preset handling.\n *\n * A Scheduler's {@link #config-presets} are loaded with a default set of {@link Scheduler.preset.ViewPreset ViewPresets}\n * which are defined by the system in the {@link Scheduler.preset.PresetManager PresetManager}.\n *\n * The zooming feature works by reconfiguring the Scheduler with a new {@link Scheduler.preset.ViewPreset ViewPreset} selected\n * from the {@link #config-presets} store.\n *\n * {@link Scheduler.preset.ViewPreset ViewPresets} can be added and removed from the store to change the amount of available steps.\n * Range of zooming in/out can be also modified with {@link Scheduler.view.mixin.TimelineZoomable#config-maxZoomLevel} / {@link Scheduler.view.mixin.TimelineZoomable#config-minZoomLevel} properties.\n *\n * This mixin adds additional methods to the column : {@link Scheduler.view.mixin.TimelineZoomable#property-maxZoomLevel}, {@link Scheduler.view.mixin.TimelineZoomable#property-minZoomLevel}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomToLevel}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomIn},\n * {@link Scheduler.view.mixin.TimelineZoomable#function-zoomOut}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomInFull}, {@link Scheduler.view.mixin.TimelineZoomable#function-zoomOutFull}.\n *\n * **Notice**: Zooming is not supported when `forceFit` option is set to true for the Scheduler or for filtered timeaxis.\n *\n * @mixin\n */\nexport default Target => class TimelineViewPresets extends (Target || Base) {\n    static get $name() {\n        return 'TimelineViewPresets';\n    }\n    //region Default config\n    static get configurable() {\n        return {\n            /**\n             * A string key used to lookup a predefined {@link Scheduler.preset.ViewPreset} (e.g. 'weekAndDay', 'hourAndDay'),\n             * managed by {@link Scheduler.preset.PresetManager}. See {@link Scheduler.preset.PresetManager} for more information.\n             * Or a config object for a viewPreset.\n             *\n             * Options:\n             * - 'secondAndMinute'\n             * - 'minuteAndHour'\n             * - 'hourAndDay'\n             * - 'dayAndWeek'\n             * - 'dayAndMonth'\n             * - 'weekAndDay'\n             * - 'weekAndMonth',\n             * - 'monthAndYear'\n             * - 'year'\n             * - 'manyYears'\n             * - 'weekAndDayLetter'\n             * - 'weekDateAndMonth'\n             * - 'day'\n             * - 'week'\n             *\n             * If passed as a config object, the settings from the viewPreset with the provided `base` property will be used along\n             * with any overridden values in your object.\n             *\n             * To override:\n             * ```javascript\n             * viewPreset : {\n             *   base    : 'hourAndDay',\n             *   id      : 'myHourAndDayPreset',\n             *   headers : [\n             *       {\n             *           unit      : \"hour\",\n             *           increment : 12,\n             *           renderer  : (startDate, endDate, headerConfig, cellIdx) => {\n             *               return \"\";\n             *           }\n             *       }\n             *   ]\n             * }\n             * ```\n             * or set a new valid preset config if the preset is not registered in the {@link Scheduler.preset.PresetManager}.\n             *\n             * When you use scheduler in weekview mode, this config is used to pick view preset. If passed view preset is not\n             * supported by weekview (only 2 supported by default - 'day' and 'week') default preset will be used - 'week'.\n             * @config {String|ViewPresetConfig}\n             * @default\n             * @category Common\n             */\n            viewPreset : 'weekAndDayLetter',\n            /**\n             * Get the {@link Scheduler.preset.PresetStore} created for the Scheduler,\n             * or set an array of {@link Scheduler.preset.ViewPreset} config objects.\n             * @member {Scheduler.preset.PresetStore|ViewPresetConfig[]} presets\n             * @category Common\n             */\n            /**\n             * An array of {@link Scheduler.preset.ViewPreset} config objects\n             * which describes the available timeline layouts for this scheduler.\n             *\n             * By default, a predefined set is loaded from the {@link Scheduler.preset.PresetManager}.\n             *\n             * A {@link Scheduler.preset.ViewPreset} describes the granularity of the\n             * timeline view and the layout and subdivisions of the timeline header.\n             * @config {ViewPresetConfig[]} presets\n             *\n             * @category Common\n             */\n            presets : true,\n            /**\n             * Defines how dates will be formatted in tooltips etc. This config has priority over similar config on the\n             * view preset. For allowed values see {@link Core.helper.DateHelper#function-format-static}.\n             *\n             * By default, this is ingested from {@link Scheduler.preset.ViewPreset} upon change of\n             * {@link Scheduler.preset.ViewPreset} (Such as when zooming in or out). But Setting this\n             * to your own value, overrides that behaviour.\n             * @prp {String}\n             * @category Scheduled events\n             */\n            displayDateFormat : null\n        };\n    }\n    //endregion\n    /**\n     * Get/set the current view preset\n     * @member {Scheduler.preset.ViewPreset|ViewPresetConfig|String} viewPreset\n     * @param [viewPreset.options]\n     * @param {Date} [viewPreset.options.startDate] A new start date for the time axis\n     * @param {Date} [viewPreset.options.endDate] A new end date for the time axis\n     * @param {Date} [viewPreset.options.centerDate] Where to center the new time axis\n     * @param {Number} [viewPreset.options.scrollPosition] The scroll position to scroll\n     * the new time axis to. This takes precedence over any date-scrolling.\n     * It is used when partnering two timelines which must be scroll-synced.\n     * @category Common\n    */\n    //region Get/set\n    changePresets(presets) {\n        const config = {\n            owner : this\n        };\n        let data = [];\n        // By default includes all presets\n        if (presets === true) {\n            data = PresetManager.allRecords;\n        }\n        // Accepts an array of presets\n        else if (Array.isArray(presets)) {\n            for (const preset of presets) {\n                // If we got a presetId\n                if (typeof preset === 'string') {\n                    const presetRecord = PresetManager.getById(preset);\n                    if (presetRecord) {\n                        data.push(presetRecord);\n                    }\n                }\n                else {\n                    data.push(preset);\n                }\n            }\n        }\n        // Or a store config object\n        else {\n            ObjectHelper.assign(config, presets);\n        }\n        // Creates store first and then adds data, because data config does not support a mix of raw objects and records.\n        const presetStore = new PresetStore(config);\n        presetStore.add(data);\n        return presetStore;\n    }\n    changeViewPreset(viewPreset, oldViewPreset) {\n        const\n            me           = this,\n            { presets } = me;\n        if (viewPreset) {\n            viewPreset = presets.createRecord(viewPreset);\n            // If an existing ViewPreset id is used, this will replace it.\n            if (!presets.includes(viewPreset)) {\n                presets.add(viewPreset);\n            }\n        }\n        else {\n            viewPreset = presets.first;\n        }\n        const\n            lastOpts = me.lastViewPresetOptions || {},\n            options  = viewPreset.options || (viewPreset.options = {}),\n            event    = {\n                ...options,\n                from   : oldViewPreset,\n                to     : viewPreset,\n                preset : viewPreset\n            },\n            presetChanged  = !me._viewPreset || !me._viewPreset.equals(viewPreset);\n        delete lastOpts.event;\n        // Only return the value for onward processing if there's a change\n        if (presetChanged || !ObjectHelper.isEqual(options, lastOpts)) {\n            // Assign event after comparison, to not have it get super expensive\n            options.event = event;\n            // Bypass the no-change check if the viewPreset is the same and we only got in here\n            // because different options were asked for.\n            if (!presetChanged) {\n                me._viewPreset = null;\n            }\n            /**\n             * Fired before the {@link #config-viewPreset} is changed.\n             * @event beforePresetChange\n             * @param {Scheduler.view.Scheduler} source This Scheduler instance.\n             * @param {Date} startDate The new start date of the timeline.\n             * @param {Date} endDate The new end date of the timeline.\n             * @param {Scheduler.preset.ViewPreset} from The outgoing ViewPreset.\n             * @param {Scheduler.preset.ViewPreset} to The ViewPreset being switched to.\n             * @preventable\n             */\n            // Do not trigger events for the initial preset\n            if (me.isConfiguring || me.trigger('beforePresetChange', event) !== false) {\n                return viewPreset;\n            }\n        }\n    }\n    get displayDateFormat() {\n        return this._displayDateFormat || this.viewPreset.displayDateFormat;\n    }\n    updateDisplayDateFormat(format) {\n        // Start/EndDateColumn listens for this to change their format to match\n        this.trigger('displayDateFormatChange', { format });\n    }\n    /**\n     * Method to get a formatted display date\n     * @private\n     * @param {Date} date The date\n     * @returns {String} The formatted date\n     */\n    getFormattedDate(date) {\n        return DateHelper.format(date, this.displayDateFormat);\n    }\n    updateViewPreset(preset) {\n        const\n            me          = this,\n            { options } = preset,\n            {\n                event,\n                startDate,\n                endDate\n            }           = options,\n            {\n                isHorizontal,\n                _timeAxis : timeAxis,    // Do not tickle the getter, we are just peeking to see if it's there yet.\n                _timeAxisViewModel : timeAxisViewModel // Ditto\n            } = me,\n            rtl = isHorizontal && me.rtl;\n        let\n            {\n                centerDate,\n                zoomDate,\n                zoomPosition\n            }           = options,\n            forceUpdate = false;\n        me.syncSplits?.(split => split.viewPreset = preset);\n        // Options must not be reused when this preset is used again.\n        delete preset.options;\n        // Raise flag to prevent partner from changing view preset if one is in progress\n        me._viewPresetChanging = true;\n        if (timeAxis && !me.isConfiguring) {\n            const { timelineScroller } = me;\n            // Cache options only when they are applied so that non-change vetoing in changeViewPreset is accurate\n            me.lastViewPresetOptions = options;\n            // Timeaxis may already be configured (in case of sharing with the timeline partner), no need to reconfigure it\n            if (timeAxis.isConfigured) {\n                // None of this reconfiguring should cause a refresh\n                me.suspendRefresh();\n                // Set up these configs only if we actually have them.\n                const timeAxisCfg = ObjectHelper.copyProperties({}, me, [\n                    'weekStartDay',\n                    'startTime',\n                    'endTime'\n                ]);\n                if (me.infiniteScroll) {\n                    Object.assign(timeAxisCfg, me.calculateInfiniteScrollingDateRange(\n                        centerDate || (startDate && endDate ? new Date((startDate.getTime() + endDate.getTime()) / 2) : me.viewportCenterDateCached),\n                        true,\n                        preset\n                    ));\n                }\n                // if startDate is provided we use it and the provided endDate\n                else if (startDate) {\n                    timeAxisCfg.startDate = startDate;\n                    timeAxisCfg.endDate = endDate;\n                    // if both dates are provided we can calculate centerDate for the viewport\n                    if (!centerDate && endDate) {\n                        centerDate = new Date((startDate.getTime() + endDate.getTime()) / 2);\n                    }\n                    // when no start/end dates are provided we use the current timespan\n                }\n                else {\n                    timeAxisCfg.startDate = timeAxis.startDate;\n                    timeAxisCfg.endDate = endDate || timeAxis.endDate;\n                    if (!centerDate) {\n                        centerDate = me.viewportCenterDate;\n                    }\n                }\n                timeAxis.isConfigured = false;\n                timeAxisCfg.viewPreset = preset;\n                timeAxis.reconfigure(timeAxisCfg, true);\n                timeAxisViewModel.reconfigure({\n                    viewPreset : preset,\n                    headers    : preset.headers,\n                    // This was hardcoded to 'middle' prior to the Preset refactor.\n                    // In the old code, the default headers were 'top' and 'middle', which\n                    // meant that 'middle' meant the lowest header.\n                    // So this is now length - 1.\n                    columnLinesFor : preset.columnLinesFor != null ? preset.columnLinesFor : preset.headers.length - 1,\n                    tickSize : options.tickSize || (isHorizontal ? preset.tickWidth : preset.tickHeight || preset.tickWidth || 60)\n                });\n                // A ViewPreset is extremely opinionated about its tickSize and imposes it upon the Scheduler.\n                // Allow the caller to correct the tick size after the reconfigure using the options block.\n                if (options.tickSize) {\n                    me.tickSize = options.tickSize;\n                }\n                // Allow refresh to run after the reconfiguring, without refreshing since we will do that below anyway\n                me.resumeRefresh(false);\n            }\n            me.refresh();\n            // if view is rendered and scroll is not disabled by \"notScroll\" option\n            if (!options.notScroll && me.isPainted) {\n                if ('scrollPosition' in options) {\n                    // If we are not going to end up scrolling, we need to force an update\n                    forceUpdate = timelineScroller.position === options.scrollPosition;\n                    timelineScroller.scrollTo(options.scrollPosition);\n                }\n                else if (options.visibleDate) {\n                    me.visibleDate = options.visibleDate;\n                }\n                // If a zoom at a certain date position is being requested, scroll the zoomDate\n                // to the required zoomPosition so that the zoom happens centered where the\n                // pointer events that are driving it targeted.\n                else if (zoomDate && zoomPosition) {\n                    const\n                        unitMagnitude = unitMagnitudes[timeAxis.resolutionUnit],\n                        unit          = unitMagnitude > 3 ? 'hour' : 'minute',\n                        milliseconds  = DateHelper.asMilliseconds((unit === 'minute' ? 15 : 1), unit),\n                        // Round the date to either 15 minutes for fine levels or 1 hour for coarse levels\n                        targetDate    = new Date(Math.round(zoomDate / milliseconds) * milliseconds);\n                    // setViewPreset method on partner panels should be executed with same arguments.\n                    // if one partner was provided with zoom info, other one has to be too to generate exact\n                    // header and set same scroll\n                    event.zoomDate = zoomDate;\n                    event.zoomPosition = zoomPosition;\n                    event.zoomLevel = options.zoomLevel;\n                    // Move the targetDate back under the mouse position as indicated by zoomPosition.\n                    // That is the offset into the TimeAxisSubGridElement.\n                    if (rtl) {\n                        timelineScroller.position = timelineScroller.scrollWidth - (me.getCoordinateFromDate(targetDate) + zoomPosition);\n                    }\n                    else {\n                        timelineScroller.position = me.getCoordinateFromDate(targetDate) - zoomPosition;\n                    }\n                }\n                // and we have centerDate to scroll to\n                else if (centerDate) {\n                    // remember the central date we scroll to (it gets reset after user scroll)\n                    me.cachedCenterDate = centerDate;\n                    // setViewPreset method on partner panels should be executed with same arguments.\n                    // if one partner was provided with a centerDate, other one has to be too to generate exact\n                    // header and set same scroll\n                    event.centerDate = centerDate;\n                    const\n                        viewportSize = me.timelineScroller.clientSize,\n                        centerCoord  = rtl ? me.timeAxisViewModel.totalSize - me.getCoordinateFromDate(centerDate, true)\n                            : me.getCoordinateFromDate(centerDate, true),\n                        coord        = Math.max(centerCoord - viewportSize / 2, 0);\n                    // If preset change does not lead to a scroll we have to \"refresh\" manually at the end\n                    if (coord === (me.isHorizontal ? me.scrollLeft : me.scrollTop)) {\n                        forceUpdate = true;\n                    }\n                    else if (me.isHorizontal) {\n                        me.scrollHorizontallyTo(coord, { scrollingToCenter : true });\n                    }\n                    else {\n                        me.scrollVerticallyTo(coord, { scrollingToCenter : true });\n                    }\n                }\n                else {\n                    // If preset change does not lead to a scroll we have to \"refresh\" manually at the end\n                    if ((me.isHorizontal ? me.scrollLeft : me.scrollTop) === 0) {\n                        forceUpdate = true;\n                    }\n                    // If we don't have a center date to scroll to, we reset scroll (this is bw compatible behavior)\n                    else {\n                        me.timelineScroller.scrollTo(0);\n                    }\n                }\n            }\n        }\n        // Update Scheduler element showing what preset is applied\n        me.dataset.presetId = preset.id;\n        /**\n         * Fired after the {@link #config-viewPreset} has changed.\n         * @event presetChange\n         * @param {Scheduler.view.Scheduler} source This Scheduler instance.\n         * @param {Date} startDate The new start date of the timeline.\n         * @param {Date} centerDate The new center date of the timeline.\n         * @param {Date} endDate The new end date of the timeline.\n         * @param {Scheduler.preset.ViewPreset} from The outgoing ViewPreset.\n         * @param {Scheduler.preset.ViewPreset} to The ViewPreset being switched to.\n         * @preventable\n         */\n        me.trigger('presetChange', event);\n        me._viewPresetChanging = false;\n        if (forceUpdate) {\n            if (me.isHorizontal) {\n                me.currentOrientation.updateFromHorizontalScroll(me.scrollLeft, true);\n            }\n            else {\n                me.currentOrientation.updateFromVerticalScroll(me.scrollTop);\n            }\n        }\n    }\n    //endregion\n    doDestroy() {\n        if (this._presets.owner === this) {\n            this._presets.destroy();\n        }\n        super.doDestroy();\n    }\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n        // Cannot store name, will not be allowed when reapplying\n        if (result.viewPreset && result.viewPreset.name && !result.viewPreset.base) {\n            delete result.viewPreset.name;\n        }\n        return result;\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\n/**\n * @module Scheduler/view/mixin/TimelineZoomable\n */\n/**\n * Options which may be used when changing the {@link Scheduler.view.Scheduler#property-viewPreset} property.\n *\n * @typedef {Object} ChangePresetOptions\n * @property {VisibleDate} [visibleDate] A `visibleDate` specification to bring into view after the new\n * `ViewPreset` is applied.\n * @property {Date} [startDate] New time frame start. If provided along with end, view will be centered in this\n * time interval, ignoring centerDate config. __Ignored if {@link Scheduler.view.Scheduler#config-infiniteScroll} is used.__\n * @property {Date} [endDate] New time frame end. __Ignored if {@link Scheduler.view.Scheduler#config-infiniteScroll} is used.__\n * @property {Date} [centerDate] Date to keep in center. Is ignored when start and end are provided.\n * @property {Date} [zoomDate] The date that should be positioned at the passed `datePosition` client offset.\n * @property {Number} [zoomPosition] The client offset at which the passed `zoomDate` should be positioned.\n * @property {Number} [width] Lowest tick width. Might be increased automatically\n */\n/**\n * Mixin providing \"zooming\" functionality.\n *\n * The zoom levels are stored as instances of {@link Scheduler.preset.ViewPreset}s, and are\n * cached centrally in the {@link Scheduler.preset.PresetManager}.\n *\n * The default presets are loaded into the {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}\n * store upon Scheduler instantiation. Preset selection is covered in the\n * {@link Scheduler.view.mixin.TimelineViewPresets} mixin.\n *\n * To specify custom zoom levels please provide a set of view presets to the global PresetManager store **before**\n * scheduler creation, or provide a set of view presets to a specific scheduler only:\n *\n * ```javascript\n * const myScheduler = new Scheduler({\n *     presets : [\n *         {\n *             base : 'hourAndDay',\n *             id   : 'MyHourAndDay',\n *             // other preset configs....\n *         },\n *         {\n *             base : 'weekAndMonth',\n *             id   : 'MyWeekAndMonth',\n *             // other preset configs....\n *         }\n *     ],\n *     viewPreset : 'MyHourAndDay',\n *     // other scheduler configs....\n *     });\n * ```\n *\n * @mixin\n */\nexport default Target => class TimelineZoomable extends (Target || Base) {\n    static $name = 'TimelineZoomable';\n    static defaultConfig = {\n        /**\n         * If true, you can zoom in and out on the time axis using CTRL-key + mouse wheel.\n         * @config {Boolean}\n         * @default\n         * @category Zoom\n         */\n        zoomOnMouseWheel : true,\n        /**\n         * True to zoom to time span when double-clicking a time axis cell.\n         * @config {Boolean}\n         * @default\n         * @category Zoom\n         */\n        zoomOnTimeAxisDoubleClick : true,\n        /**\n         * The minimum zoom level to which {@link #function-zoomOut} will work. Defaults to 0 (year ticks)\n         * @config {Number}\n         * @category Zoom\n         * @default\n         */\n        minZoomLevel : 0,\n        /**\n         * The maximum zoom level to which {@link #function-zoomIn} will work. Defaults to the number of\n         * {@link Scheduler.preset.ViewPreset ViewPresets} available, see {@link Scheduler/view/mixin/TimelineViewPresets#property-presets}\n         * for information. Unless you have modified the collection of available presets, the max zoom level is\n         * milliseconds.\n         * @config {Number}\n         * @category Zoom\n         * @default 23\n         */\n        maxZoomLevel : null,\n        /**\n         * Integer number indicating the size of timespan during zooming. When zooming, the timespan is adjusted to make\n         * the scrolling area `visibleZoomFactor` times wider than the timeline area itself. Used in\n         * {@link #function-zoomToSpan} and {@link #function-zoomToLevel} functions.\n         * @config {Number}\n         * @default\n         * @category Zoom\n         */\n        visibleZoomFactor : 5,\n        /**\n         * Whether the originally rendered timespan should be preserved while zooming. By default, it is set to `false`,\n         * meaning the timeline panel will adjust the currently rendered timespan to limit the amount of HTML content to\n         * render. When setting this option to `true`, be careful not to allow to zoom a big timespan in seconds\n         * resolution for example. That will cause **a lot** of HTML content to be rendered and affect performance. You\n         * can use {@link #config-minZoomLevel} and {@link #config-maxZoomLevel} config options for that.\n         * @config {Boolean}\n         * @default\n         * @category Zoom\n         */\n        zoomKeepsOriginalTimespan : null\n    };\n    // We cache the last mousewheel position, so that during zooming we can\n    // maintain a stable zoom point even if the mouse moves a little.\n    lastWheelTime = -1;\n    lastZoomPosition = -1;\n    construct(config) {\n        const me = this;\n        super.construct(config);\n        if (me.zoomOnMouseWheel) {\n            EventHelper.on({\n                element   : me.timeAxisSubGridElement,\n                wheel     : 'onWheel',\n                // Throttle zooming with the wheel a bit to have greater control of it\n                throttled : {\n                    buffer : 100,\n                    // Prevent events from slipping through the throttle, causing scroll\n                    alt    : e => e.ctrlKey && e.preventDefault()\n                },\n                thisObj : me,\n                capture : true,\n                passive : false\n            });\n        }\n        if (me.zoomOnTimeAxisDoubleClick) {\n            me.ion({\n                timeaxisheaderdblclick : ({ startDate, endDate }) => {\n                    if (!me.forceFit) {\n                        me.zoomToSpan({\n                            startDate,\n                            endDate\n                        });\n                    }\n                }\n            });\n        }\n    }\n    get maxZoomLevel() {\n        return this._maxZoomLevel || (this.presets.count - 1);\n    }\n    /**\n     * Get/set the {@link #config-maxZoomLevel} value\n     * @property {Number}\n     * @category Zoom\n     */\n    set maxZoomLevel(level) {\n        if (typeof level !== 'number') {\n            level = this.presets.count - 1;\n        }\n        if (level < 0 || level >= this.presets.count) {\n            throw new Error('Invalid range for `maxZoomLevel`');\n        }\n        this._maxZoomLevel = level;\n    }\n    get minZoomLevel() {\n        return this._minZoomLevel;\n    }\n    /**\n     * Sets the {@link #config-minZoomLevel} value\n     * @property {Number}\n     * @category Zoom\n     */\n    set minZoomLevel(level) {\n        if (typeof level !== 'number') {\n            level = 0;\n        }\n        if (level < 0 || level >= this.presets.count) {\n            throw new Error('Invalid range for `minZoomLevel`');\n        }\n        this._minZoomLevel = level;\n    }\n    /**\n     * Current zoom level, which is equal to the {@link Scheduler.preset.ViewPreset ViewPreset} index\n     * in the provided array of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets zoom levels}.\n     * @property {Number}\n     * @category Zoom\n     */\n    get zoomLevel() {\n        return this.presets.indexOf(this.viewPreset);\n    }\n    // noinspection JSAnnotator\n    set zoomLevel(level) {\n        this.zoomToLevel(level);\n    }\n    /**\n     * Returns number of milliseconds per pixel.\n     * @param {Object} level Element from array of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets}.\n     * @param {Boolean} ignoreActualWidth If true, then density will be calculated using default zoom level settings.\n     * Otherwise, density will be calculated for actual tick width.\n     * @returns {Number} Return number of milliseconds per pixel.\n     * @private\n     */\n    getMilliSecondsPerPixelForZoomLevel(preset, ignoreActualWidth) {\n        const\n            { bottomHeader } = preset,\n            // Scheduler uses direction independent tickSize, but presets are allowed to define different sizes for\n            // vertical and horizontal -> cant use preset.tickSize here\n            width            = this.isHorizontal ? preset.tickWidth : preset.tickHeight;\n        // trying to convert the unit + increment to a number of milliseconds\n        // this number is not fixed (month can be 28, 30 or 31 day), but at least this conversion\n        // will be consistent (should be no DST changes at year 1)\n        return Math.round(\n            (DateHelper.add(new Date(1, 0, 1), bottomHeader.increment || 1, bottomHeader.unit) - new Date(1, 0, 1)) /\n            // `actualWidth` is a column width after view adjustments applied to it (see `calculateTickWidth`)\n            // we use it if available to return the precise index value from `getCurrentZoomLevelIndex`\n            (ignoreActualWidth ? width : preset.actualWidth || width)\n        );\n    }\n    /**\n     * Zooms to passed view preset, saving center date. Method accepts config object as a first argument, which can be\n     * reduced to primitive type (string,number) when no additional options required. e.g.:\n     * ```javascript\n     * // zooming to preset\n     * scheduler.zoomTo({ preset : 'hourAndDay' })\n     * // shorthand\n     * scheduler.zoomTo('hourAndDay')\n     *\n     * // zooming to level\n     * scheduler.zoomTo({ level : 0 })\n     * // shorthand\n     * scheduler.zoomTo(0)\n     * ```\n     *\n     * It is also possible to zoom to a time span by omitting `preset` and `level` configs, in which case scheduler sets\n     * the time frame to a specified range and applies zoom level which allows to fit all columns to this range. The\n     * given time span will be centered in the scheduling view (unless `centerDate` config provided). In the same time,\n     * the start/end date of the whole time axis will be extended to allow scrolling for user.\n     * ```javascript\n     * // zooming to time span\n     * scheduler.zoomTo({\n     *     startDate : new Date(..),\n     *     endDate : new Date(...)\n     * });\n     * ```\n     *\n     * @param {ViewPresetConfig|Object|String|Number} config Config object, preset name or zoom level index.\n     * @param {String} [config.preset] Preset name to zoom to. Ignores level config in this case\n     * @param {Number} [config.level] Zoom level to zoom to. Is ignored, if preset config is provided\n     * @param {VisibleDate} [config.visibleDate] A `visibleDate` specification to bring into view after the zoom.\n     * @param {Date} [config.startDate] New time frame start. If provided along with end, view will be centered in this\n     * time interval (unless `centerDate` is present)\n     * @param {Date} [config.endDate] New time frame end\n     * @param {Date} [config.centerDate] Date that should be kept in the center. Has priority over start and end params\n     * @param {Date} [config.zoomDate] The date that should be positioned at the passed `datePosition` client offset.\n     * @param {Number} [config.zoomPosition] The client offset at which the passed `date` should be positioned.\n     * @param {Number} [config.width] Lowest tick width. Might be increased automatically\n     * @param {Number} [config.leftMargin] Amount of pixels to extend span start on (used, when zooming to span)\n     * @param {Number} [config.rightMargin] Amount of pixels to extend span end on (used, when zooming to span)\n     * @param {Number} [config.adjustStart] Amount of units to extend span start on (used, when zooming to span)\n     * @param {Number} [config.adjustEnd] Amount of units to extend span end on (used, when zooming to span)\n     * @category Zoom\n     */\n    zoomTo(config) {\n        const me = this;\n        if (typeof config === 'object') {\n            if (config.preset) {\n                me.zoomToLevel(config.preset, config);\n            }\n            else if (config.level != null) {\n                me.zoomToLevel(config.level, config);\n            }\n            else {\n                me.zoomToSpan(config);\n            }\n        }\n        else {\n            me.zoomToLevel(config);\n        }\n    }\n    /**\n     * Allows zooming to certain level of {@link Scheduler.view.mixin.TimelineViewPresets#config-presets} array.\n     * Automatically limits zooming between {@link #config-maxZoomLevel} and {@link #config-minZoomLevel}. Can also set\n     * time axis timespan to the supplied start and end dates.\n     *\n     * @param {Number} preset Level to zoom to.\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} level Current zoom level or null if it hasn't changed.\n     * @category Zoom\n     */\n    zoomToLevel(preset, options = {}) {\n        if (this.forceFit) {\n            console.warn('Warning: The forceFit setting and zooming cannot be combined');\n            return;\n        }\n        // Sanitize numeric zooming.\n        if (typeof preset === 'number') {\n            preset = Math.min(Math.max(preset, this.minZoomLevel), this.maxZoomLevel);\n        }\n        const\n            me                 = this,\n            { presets }       = me,\n            tickSizeProp       = me.isVertical ? 'tickHeight' : 'tickWidth',\n            newPreset          = presets.createRecord(preset),\n            configuredTickSize = newPreset[tickSizeProp],\n            startDate          = options.startDate ? new Date(options.startDate) : null,\n            endDate            = options.endDate ? new Date(options.endDate) : null;\n        // If an existing ViewPreset id is used, this will replace it.\n        presets.add(newPreset);\n        let span = startDate && endDate ? { startDate, endDate } : null;\n        const\n            centerDate             = options.centerDate ? new Date(options.centerDate) : (span ? new Date((startDate.getTime() + endDate.getTime()) / 2) : me.viewportCenterDateCached);\n        let scrollableViewportSize = me.isVertical ? me.scrollable.clientHeight : me.timeAxisSubGrid.width;\n        if (scrollableViewportSize === 0) {\n            const\n                { _beforeCollapseState } = me.timeAxisSubGrid;\n            if (me.isHorizontal && me.timeAxisSubGrid.collapsed && _beforeCollapseState?.width) {\n                scrollableViewportSize = _beforeCollapseState.width;\n            }\n            else {\n                return null;\n            }\n        }\n        // Always calculate an optimal date range for the new zoom level\n        if (!span) {\n            span = me.calculateOptimalDateRange(centerDate, scrollableViewportSize, newPreset);\n        }\n        // Temporarily override tick size while reconfiguring the TimeAxisViewModel\n        if ('width' in options) {\n            newPreset.setData(tickSizeProp, options.width);\n        }\n        me.isZooming = true;\n        // Passed through to the viewPreset changing method\n        newPreset.options = {\n            ...options,\n            startDate : span.startDate || me.startDate,\n            endDate   : span.endDate || me.endDate,\n            centerDate\n        };\n        me.viewPreset = newPreset;\n        // after switching the view preset the `width` config of the zoom level may change, because of adjustments\n        // we will save the real value in the `actualWidth` property, so that `getCurrentZoomLevelIndex` method\n        // will return the exact level index after zooming\n        newPreset.actualWidth = me.timeAxisViewModel.tickSize;\n        me.isZooming = false;\n        // Restore the tick size because the default presets are shared.\n        newPreset.setData(tickSizeProp, configuredTickSize);\n        return me.zoomLevel;\n    }\n    /**\n     * Changes the range of the scheduling chart to fit all the events in its event store.\n     * @param {Object} [options] Options object for the zooming operation.\n     * @param {Number} [options.leftMargin] Defines margin in pixel between the first event start date and first visible\n     * date\n     * @param {Number} [options.rightMargin] Defines margin in pixel between the last event end date and last visible\n     * date\n     */\n    zoomToFit(options) {\n        const eventStore = this.eventStore,\n            span       = eventStore.getTotalTimeSpan();\n        options = {\n            leftMargin  : 0,\n            rightMargin : 0,\n            ...options,\n            ...span\n        };\n        // Make sure we received a time span, event store might be empty\n        if (options.startDate && options.endDate) {\n            if (options.endDate > options.startDate) {\n                this.zoomToSpan(options);\n            }\n            else {\n                // If we only had a zero time span, just scroll it into view\n                this.scrollToDate(options.startDate);\n            }\n        }\n    }\n    /**\n     * Sets time frame to specified range and applies zoom level which allows to fit all columns to this range.\n     *\n     * The given time span will be centered in the scheduling view, in the same time, the start/end date of the whole\n     * time axis will be extended in the same way as {@link #function-zoomToLevel} method does, to allow scrolling for\n     * user.\n     *\n     * @param {Object} config The time frame.\n     * @param {Date} config.startDate The time frame start.\n     * @param {Date} config.endDate The time frame end.\n     * @param {Date} [config.centerDate] Date that should be kept in the center. Has priority over start and end params\n     * @param {Number} [config.leftMargin] Amount of pixels to extend span start on\n     * @param {Number} [config.rightMargin] Amount of pixels to extend span end on\n     * @param {Number} [config.adjustStart] Amount of units to extend span start on\n     * @param {Number} [config.adjustEnd] Amount of units to extend span end on\n     *\n     * @returns {Number|null} level Current zoom level or null if it hasn't changed.\n     * @category Zoom\n     */\n    zoomToSpan(config = {}) {\n        if (config.leftMargin || config.rightMargin) {\n            config.adjustStart = 0;\n            config.adjustEnd = 0;\n        }\n        if (!config.leftMargin) config.leftMargin = 0;\n        if (!config.rightMargin) config.rightMargin = 0;\n        if (!config.startDate || !config.endDate) throw new Error('zoomToSpan: must provide startDate + endDate dates');\n        const\n            me           = this,\n            { timeAxis } = me,\n            // this config enables old zoomToSpan behavior which we want to use for zoomToFit in Gantt\n            needToAdjust = config.adjustStart >= 0 || config.adjustEnd >= 0;\n        let {\n            startDate,\n            endDate\n        } = config;\n        if (needToAdjust) {\n            startDate = DateHelper.add(startDate, -config.adjustStart, timeAxis.mainUnit);\n            endDate   = DateHelper.add(endDate, config.adjustEnd, timeAxis.mainUnit);\n        }\n        if (startDate <= endDate) {\n            // get scheduling view width\n            const\n                { availableSpace } = me.timeAxisViewModel,\n                presets = me.presets.allRecords,\n                diffMS  = endDate - startDate || 1;\n            // if potential width of col is less than col width provided by zoom level\n            //   - we'll zoom out panel until col width fit into width from zoom level\n            // and if width of column is more than width from zoom level\n            //   - we'll zoom in until col width fit won't fit into width from zoom level\n            let currLevel = me.zoomLevel,\n                inc, range;\n            // if we zoomed out even more than the highest zoom level - limit it to the highest zoom level\n            if (currLevel === -1) currLevel = 0;\n            let msPerPixel             = me.getMilliSecondsPerPixelForZoomLevel(presets[currLevel], true),\n                // increment to get next zoom level:\n                // -1 means that given timespan won't fit the available width in the current zoom level, we need to zoom out,\n                // so that more content will \"fit\" into 1 px\n                //\n                // +1 mean that given timespan will already fit into available width in the current zoom level, but,\n                // perhaps if we'll zoom in a bit more, the fitting will be better\n                candidateLevel         = currLevel + (inc = diffMS / msPerPixel + config.leftMargin + config.rightMargin > availableSpace ? -1 : 1),\n                zoomLevel, levelToZoom = null;\n            // loop over zoom levels\n            while (candidateLevel >= 0 && candidateLevel <= presets.length - 1) {\n                // get zoom level\n                zoomLevel = presets[candidateLevel];\n                msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);\n                const spanWidth = diffMS / msPerPixel + config.leftMargin + config.rightMargin;\n                // if zooming out\n                if (inc === -1) {\n                    // if columns fit into available space, then all is fine, we've found appropriate zoom level\n                    if (spanWidth <= availableSpace) {\n                        levelToZoom = candidateLevel;\n                        // stop searching\n                        break;\n                    }\n                    // if zooming in\n                }\n                else {\n                    // if columns still fits into available space, we need to remember the candidate zoom level as a potential\n                    // resulting zoom level, the indication that we've found correct zoom level will be that timespan won't fit\n                    // into available view\n                    if (spanWidth <= availableSpace) {\n                        // if it's not currently active level\n                        if (currLevel !== candidateLevel - inc) {\n                            // remember this level as applicable\n                            levelToZoom = candidateLevel;\n                        }\n                    }\n                    else {\n                        // Sanity check to find the following case:\n                        // If we're already zoomed in at the appropriate level, but the current zoomLevel is \"too small\" to fit and had to be expanded,\n                        // there is an edge case where we should actually just stop and use the currently selected zoomLevel\n                        break;\n                    }\n                }\n                candidateLevel += inc;\n            }\n            // If we didn't find a large/small enough zoom level, use the lowest/highest level\n            levelToZoom = levelToZoom != null ? levelToZoom : candidateLevel - inc;\n            // presets is the array of all ViewPresets this Scheduler is using\n            zoomLevel = presets[levelToZoom];\n            const unitToZoom = zoomLevel.bottomHeader.unit;\n            // Extract the correct msPerPixel value for the new zoom level\n            msPerPixel = me.getMilliSecondsPerPixelForZoomLevel(zoomLevel, true);\n            if (config.leftMargin || config.rightMargin) {\n                // time axis doesn't yet know about new view preset (zoom level) so it cannot round/ceil date correctly\n                startDate = new Date(startDate.getTime() - msPerPixel * config.leftMargin);\n                endDate   = new Date(endDate.getTime() + msPerPixel * config.rightMargin);\n            }\n            const tickCount = DateHelper.getDurationInUnit(startDate, endDate, unitToZoom, true) / zoomLevel.bottomHeader.increment;\n            if (tickCount === 0) {\n                return null;\n            }\n            const\n                customWidth = Math.floor(availableSpace / tickCount),\n                centerDate  = config.centerDate || new Date((startDate.getTime() + endDate.getTime()) / 2);\n            if (needToAdjust) {\n                range = {\n                    startDate,\n                    endDate\n                };\n            }\n            else {\n                range = me.calculateOptimalDateRange(centerDate, availableSpace, zoomLevel);\n            }\n            let result = me.zoomLevel;\n            // No change of zoom level needed, just move to the date range\n            if (me.zoomLevel === levelToZoom) {\n                timeAxis.reconfigure(range);\n            }\n            else {\n                result = me.zoomToLevel(levelToZoom,\n                    Object.assign(range, {\n                        width : customWidth,\n                        centerDate\n                    })\n                );\n            }\n            this.trigger('zoomToSpan', { zoomLevel : levelToZoom, startDate, endDate, centerDate });\n            return result;\n        }\n        return null;\n    }\n    /**\n     * Zooms in the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view\n     * will zoom in by this value. Otherwise, a value of `1` will be used.\n     *\n     * @param {Number} [levels] (optional) amount of levels to zoom in\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomIn(levels = 1, options) {\n        // Allow zoomIn({ visibleDate : ... })\n        if (typeof levels === 'object') {\n            options = levels;\n            levels = 1;\n        }\n        const currentZoomLevelIndex = this.zoomLevel;\n        if (currentZoomLevelIndex >= this.maxZoomLevel) {\n            return null;\n        }\n        return this.zoomToLevel(currentZoomLevelIndex + levels, options);\n    }\n    /**\n     * Zooms out the timeline according to the array of zoom levels. If the amount of levels to zoom is given, the view\n     * will zoom out by this value. Otherwise, a value of `1` will be used.\n     *\n     * @param {Number} levels (optional) amount of levels to zoom out\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomOut(levels = 1, options) {\n        // Allow zoomOut({ visibleDate : ... })\n        if (typeof levels === 'object') {\n            options = levels;\n            levels = 1;\n        }\n        const currentZoomLevelIndex = this.zoomLevel;\n        if (currentZoomLevelIndex <= this.minZoomLevel) {\n            return null;\n        }\n        return this.zoomToLevel(currentZoomLevelIndex - levels, options);\n    }\n    /**\n     * Zooms in the timeline to the {@link #config-maxZoomLevel} according to the array of zoom levels.\n     *\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomInFull(options) {\n        return this.zoomToLevel(this.maxZoomLevel, options);\n    }\n    /**\n     * Zooms out the timeline to the {@link #config-minZoomLevel} according to the array of zoom levels.\n     *\n     * @param {ChangePresetOptions} [options] Object containing options which affect how the new preset is applied.\n     * @returns {Number|null} currentLevel New zoom level of the panel or null if level hasn't changed.\n     * @category Zoom\n     */\n    zoomOutFull(options) {\n        return this.zoomToLevel(this.minZoomLevel, options);\n    }\n    /*\n     * Adjusts the timespan of the panel to the new zoom level. Used for performance reasons,\n     * as rendering too many columns takes noticeable amount of time so their number is limited.\n     * @category Zoom\n     * @private\n     */\n    calculateOptimalDateRange(centerDate, viewportSize, viewPreset) {\n        const\n            me               = this,\n            { timeAxis }     = me,\n            { bottomHeader } = viewPreset,\n            tickWidth        = me.isHorizontal ? viewPreset.tickWidth : viewPreset.tickHeight;\n        if (me.zoomKeepsOriginalTimespan) {\n            return {\n                startDate : timeAxis.startDate,\n                endDate   : timeAxis.endDate\n            };\n        }\n        const\n            unit       = bottomHeader.unit,\n            difference = Math.ceil(viewportSize / tickWidth * bottomHeader.increment * me.visibleZoomFactor / 2),\n            startDate  = DateHelper.add(centerDate, -difference, unit),\n            endDate    = DateHelper.add(centerDate, difference, unit);\n        return {\n            startDate : timeAxis.floorDate(startDate, false, unit, bottomHeader.increment),\n            endDate   : timeAxis.ceilDate(endDate, false, unit, bottomHeader.increment)\n        };\n    }\n    onElementMouseMove(event) {\n        const\n            {\n                isHorizontal,\n                zoomContext\n            } = this;\n        super.onElementMouseMove(event);\n        if (event.isTrusted && zoomContext) {\n            // Invalidate the zoomContext if mouse has strayed away from it\n            if (Math.abs(event[`client${isHorizontal ? 'X' : 'Y'}`] - zoomContext.coordinate) > 10) {\n                this.zoomContext = null;\n            }\n        }\n    }\n    async onWheel(event) {\n        if (event.ctrlKey && !this.forceFit) {\n            event.preventDefault();\n            const\n                me           = this,\n                {\n                    zoomContext,\n                    isHorizontal,\n                    timelineScroller,\n                    zoomLevel\n                }            = me,\n                now          = performance.now(),\n                coordinate   = event[`client${isHorizontal ? 'X' : 'Y'}`];\n            let zoomPosition = coordinate - timelineScroller.viewport[`${isHorizontal ? 'x' : 'y'}`];\n            // zoomPosition is the offset into the TimeAxisSubGridElement.\n            if (isHorizontal && me.rtl) {\n                zoomPosition = timelineScroller.viewport.width + timelineScroller.viewport.x - coordinate;\n            }\n            // If we are in a fast-arriving stream of wheel events, we use the same zoomDate as last time.\n            // If it's a new zoom gesture or the pointer has strayed away from the context then ascertain\n            // the gesture's center date\n            if (now - me.lastWheelTime > 200 || !zoomContext || Math.abs(coordinate - me.zoomContext.coordinate) > 20) {\n                // We're creating a zoom gesture which lasts as long as the\n                // wheel events keep arriving at the same timeline position\n                me.zoomContext = {\n                    // So we can track if we're going in (to finer resolutions)\n                    zoomLevel,\n                    // Pointer client(X|Y)\n                    coordinate,\n                    // Full TimeAxis offset position at which to place the date\n                    zoomPosition,\n                    // The date to place at the position\n                    zoomDate : me.getDateFromDomEvent(event)\n                };\n            }\n            // Use the current zoomContext's zoomDate, but at each level, the relative position of that date\n            // in the TimeAxis has to be corrected as the TimeAxis grows and scrolls to keep the zoomPosition\n            // stable.\n            else {\n                // If we zoom in to a finer resolution, get a more accurate centering date.\n                // If gesture was started at a years/months level, the date will be inaccurate.\n                if (zoomLevel > zoomContext.zoomLevel) {\n                    zoomContext.zoomDate = me.getDateFromDomEvent(event);\n                    zoomContext.zoomLevel = zoomLevel;\n                }\n                zoomContext.zoomPosition = zoomPosition;\n            }\n            me.lastWheelTime = now;\n            me[`zoom${event.deltaY > 0 ? 'Out' : 'In'}`](undefined, me.zoomContext);\n        }\n    }\n    /**\n     * Changes the time axis timespan to the supplied start and end dates.\n     * @param {Date} newStartDate The new start date\n     * @param {Date} [newEndDate] The new end date. If omitted or equal to startDate, the\n     * {@link Scheduler.preset.ViewPreset#field-defaultSpan} property of the current view preset will be used to calculate the new end date.\n     * @param {Object} [options] An object containing modifiers for the time span change operation.\n     * @param {Boolean} [options.maintainVisibleStart] Specify as `true` to keep the visible start date stable.\n     * @param {Date} [options.visibleDate] The date inside the range to scroll into view\n     * @async\n     */\n    setTimeSpan(newStartDate, newEndDate, options) {\n        this.timeAxis.setTimeSpan(newStartDate, newEndDate, options);\n    }\n    /**\n     * Moves the time axis by the passed amount and unit.\n     *\n     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shift} for more information.\n     *\n     * @param {Number} amount The number of units to jump\n     * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} [unit] The unit (Day, Week etc)\n     */\n    shift(amount, unit) {\n        this.timeAxis.shift(amount, unit);\n    }\n    /**\n     * Moves the time axis forward in time in units specified by the view preset `shiftUnit`, and by the amount\n     * specified by the `shiftIncrement` config of the current view preset.\n     *\n     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shiftNext} for more information.\n     *\n     * @param {Number} [amount] The number of units to jump forward\n     */\n    shiftNext(amount) {\n        this.timeAxis.shiftNext(amount);\n    }\n    /**\n     * Moves the time axis backward in time in units specified by the view preset `shiftUnit`, and by the amount\n     * specified by the `shiftIncrement` config of the current view preset.\n     *\n     * NOTE: If using a filtered time axis, see {@link Scheduler.data.TimeAxis#function-shiftPrevious} for more\n     * information.\n     *\n     * @param {Number} [amount] The number of units to jump backward\n     */\n    shiftPrevious(amount) {\n        this.timeAxis.shiftPrevious(amount);\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Popup from '../../../Core/widget/Popup.js';\n/**\n * @module Scheduler/view/recurrence/RecurrenceConfirmationPopup\n */\n/**\n * A confirmation dialog shown when modifying a recurring event or some of its occurrences.\n * For recurring events, the dialog informs the user that the change will be applied to all occurrences.\n *\n * For occurrences, the dialog lets the user choose if the change should affect all future occurrences,\n * or this occurrence only.\n *\n * Usage example:\n *\n * ```javascript\n * const confirmation = new RecurrenceConfirmationPopup();\n *\n * confirmation.confirm({\n *     eventRecord : recurringEvent,\n *     actionType  : \"delete\",\n *     changerFn   : () => recurringEvent.remove(event)\n * });\n * ```\n *\n * @classtype recurrenceconfirmation\n * @extends Core/widget/Popup\n */\nexport default class RecurrenceConfirmationPopup extends Popup {\n    static get $name() {\n        return 'RecurrenceConfirmationPopup';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrenceconfirmation';\n    }\n    static get defaultConfig() {\n        return {\n            localizableProperties : [],\n            align                 : 'b-t',\n            autoShow              : false,\n            autoClose             : false,\n            closeAction           : 'onRecurrenceClose',\n            modal                 : true,\n            centered              : true,\n            scrollAction          : 'realign',\n            constrainTo           : globalThis,\n            draggable             : true,\n            closable              : true,\n            floating              : true,\n            eventRecord           : null,\n            cls                   : 'b-sch-recurrenceconfirmation',\n            bbar                  : {\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    changeSingleButton : {\n                        weight  : 100,\n                        cls     : 'b-raised',\n                        color   : 'b-blue',\n                        text    : 'L{update-only-this-btn-text}',\n                        onClick : 'up.onChangeSingleButtonClick'\n                    },\n                    changeMultipleButton : {\n                        weight  : 200,\n                        color   : 'b-green',\n                        text    : 'L{Object.Yes}',\n                        onClick : 'up.onChangeMultipleButtonClick'\n                    },\n                    cancelButton : {\n                        weight  : 300,\n                        color   : 'b-gray',\n                        text    : 'L{Object.Cancel}',\n                        onClick : 'up.onCancelButtonClick'\n                    }\n                }\n            }\n        };\n    }\n    /**\n     * Reference to the \"Apply changes to multiple occurrences\" button, if used\n     * @property {Core.widget.Button}\n     * @readonly\n     */\n    get changeMultipleButton() {\n        return this.widgetMap.changeMultipleButton;\n    }\n    /**\n     * Reference to the button that causes changing of the event itself only, if used\n     * @property {Core.widget.Button}\n     * @readonly\n     */\n    get changeSingleButton() {\n        return this.widgetMap.changeSingleButton;\n    }\n    /**\n     * Reference to the cancel button, if used\n     * @property {Core.widget.Button}\n     * @readonly\n     */\n    get cancelButton() {\n        return this.widgetMap.cancelButton;\n    }\n    /**\n     * Handler for \"Apply changes to multiple occurrences\" {@link #property-changeMultipleButton button}.\n     * It calls {@link #function-processMultipleRecords} and then hides the dialog.\n     */\n    onChangeMultipleButtonClick() {\n        this.processMultipleRecords();\n        this.hide();\n    }\n    /**\n     * Handler for the {@link #property-changeSingleButton button} that causes changing of the event itself only.\n     * It calls {@link #function-processSingleRecord} and then hides the dialog.\n     */\n    onChangeSingleButtonClick() {\n        this.processSingleRecord();\n        this.hide();\n    }\n    /**\n     * Handler for {@link #property-cancelButton cancel button}.\n     * It calls `cancelFn` provided to {@link #function-confirm} call and then hides the dialog.\n     */\n    onCancelButtonClick() {\n        this.cancelFn && this.cancelFn.call(this.thisObj);\n        this.hide();\n    }\n    onRecurrenceClose() {\n        if (this.cancelFn) {\n            this.cancelFn.call(this.thisObj);\n        }\n        this.hide();\n    }\n    /**\n     * Displays the confirmation.\n     * Usage example:\n     *\n     * ```javascript\n     * const popup = new RecurrenceConfirmationPopup();\n     *\n     * popup.confirm({\n     *     eventRecord,\n     *     actionType : \"delete\",\n     *     changerFn  : () => eventStore.remove(record)\n     * });\n     * ```\n     *\n     * @param {Object} config The following config options are supported:\n     * @param {Scheduler.model.EventModel} config.eventRecord   Event being modified.\n     * @param {'update'|'delete'} config.actionType Type of modification to be applied to the event. Can be\n     * either \"update\" or \"delete\".\n     * @param {Function} config.changerFn A function that should be called to apply the change to the event upon user\n     * choice.\n     * @param {Function} [config.thisObj] `changerFn` and `cancelFn` functions scope.\n     * @param {Function} [config.cancelFn] Function called on `Cancel` button click.\n     */\n    confirm(config = {}) {\n        const me = this;\n        [\n            'actionType',\n            'eventRecord',\n            'title',\n            'html',\n            'changerFn',\n            'cancelFn',\n            'finalizerFn',\n            'thisObj'\n        ].forEach(prop => {\n            if (prop in config) me[prop] = config[prop];\n        });\n        me.updatePopupContent();\n        return super.show(config);\n    }\n    updatePopupContent() {\n        const\n            me                                                         = this,\n            { changeMultipleButton, changeSingleButton, cancelButton } = me.widgetMap,\n            { eventRecord, actionType = 'update' }                     = me,\n            isMaster                                                   = eventRecord?.isRecurring;\n        if (isMaster) {\n            changeMultipleButton.text = me.L('L{Object.Yes}');\n            me.html = me.L(`${actionType}-all-message`);\n        }\n        else {\n            changeMultipleButton.text = me.L(`${actionType}-further-btn-text`);\n            me.html = me.L(`${actionType}-further-message`);\n        }\n        changeSingleButton.text = me.L(`${actionType}-only-this-btn-text`);\n        cancelButton.text = me.L('L{Object.Cancel}');\n        me.width = me.L('L{width}');\n        me.title = me.L(`${actionType}-title`);\n    }\n    /**\n     * Applies changes to multiple occurrences as reaction on \"Apply changes to multiple occurrences\"\n     * {@link #property-changeMultipleButton button} click.\n     */\n    processMultipleRecords() {\n        const { eventRecord, changerFn, thisObj, finalizerFn } = this;\n        eventRecord.beginBatch();\n        // Apply changes to the occurrence.\n        // It is not joined to any stores, so this has no consequence.\n        changerFn && this.callback(changerFn, thisObj, [eventRecord]);\n        // afterChange will promote it to being an new recurring base because there's still recurrence\n        eventRecord.endBatch();\n        finalizerFn && this.callback(finalizerFn, thisObj, [eventRecord]);\n    }\n    /**\n     * Applies changes to a single record by making it a \"real\" event and adding an exception to the recurrence.\n     * The method is called as reaction on clicking the {@link #property-changeSingleButton button} that causes changing of the event itself only.\n     */\n    processSingleRecord() {\n        const { eventRecord, changerFn, thisObj, finalizerFn } = this;\n        eventRecord.beginBatch();\n        let firstOccurrence;\n        // If that's a master event get its very first occurrence\n        if (eventRecord?.isRecurring) {\n            eventRecord.recurrence.forEachOccurrence(eventRecord.startDate, null, (occurrence, isFirst, index) => {\n                // index 1 is used by to the event itself, > 1 since there might be exceptions\n                if (index > 1) {\n                    firstOccurrence = occurrence;\n                    return false;\n                }\n            });\n        }\n        // turn the 1st occurrence into a new \"master\" event\n        firstOccurrence?.convertToRealEvent();\n        // When the changes apply, because there's no recurrence, it will become an exception\n        eventRecord.recurrence = null;\n        // Apply changes to the occurrence.\n        // It is not joined to any stores, so this has no consequence.\n        changerFn && this.callback(changerFn, thisObj, [eventRecord]);\n        // Must also change after the callback in case the callback sets the rule.\n        // This will update the batch update data block to prevent it being set back to recurring.\n        eventRecord.recurrenceRule = null;\n        // afterChange will promote it to being an exception because there's no recurrence\n        eventRecord.endBatch();\n        finalizerFn && this.callback(finalizerFn, thisObj, [eventRecord]);\n    }\n    updateLocalization() {\n        this.updatePopupContent();\n        super.updateLocalization();\n    }\n};\n// Register this widget type with its Factory\nRecurrenceConfirmationPopup.initClass();\nRecurrenceConfirmationPopup._$name = 'RecurrenceConfirmationPopup';", "import Base from '../../../Core/Base.js';\nimport '../recurrence/RecurrenceConfirmationPopup.js';\n/**\n * @module Scheduler/view/mixin/RecurringEvents\n */\n/**\n * A mixin that adds recurring events functionality to the Scheduler.\n *\n * The main purpose of the code in here is displaying a {@link Scheduler.view.recurrence.RecurrenceConfirmationPopup special confirmation}\n * on user mouse dragging/resizing/deleting recurring events and their occurrences.\n *\n * @mixin\n */\nexport default Target => class RecurringEvents extends (Target || Base) {\n    static $name = 'RecurringEvents';\n    static configurable = {\n        /**\n         * Enables showing occurrences of recurring events across the scheduler's time axis.\n         *\n         * Enables extra recurrence UI fields in the system-provided event editor (not in Scheduler Pro's task editor).\n         * @config {Boolean}\n         * @default\n         * @category Scheduled events\n         */\n        enableRecurringEvents : false,\n        recurrenceConfirmationPopup : {\n            $config : ['lazy'],\n            value   : {\n                type : 'recurrenceconfirmation'\n            }\n        }\n    };\n    construct(config) {\n        super.construct(config);\n        this.ion({\n            beforeEventDropFinalize   : 'onRecurrableBeforeEventDropFinalize',\n            beforeEventResizeFinalize : 'onRecurrableBeforeEventResizeFinalize',\n            beforeAssignmentDelete    : 'onRecurrableAssignmentBeforeDelete'\n        });\n    }\n    changeRecurrenceConfirmationPopup(recurrenceConfirmationPopup, oldRecurrenceConfirmationPopup) {\n        // Widget.reconfigure reither reconfigures an existing instance, or creates a new one, or,\n        // if the configuration is null, destroys the existing instance.\n        const result = this.constructor.reconfigure(oldRecurrenceConfirmationPopup, recurrenceConfirmationPopup, 'recurrenceconfirmation');\n        result.owner = this;\n        return result;\n    }\n    findRecurringEventToConfirmDelete(eventRecords) {\n        // show confirmation if we deal with at least one recurring event (or its occurrence)\n        // and if the record is not being edited by event editor (since event editor has its own confirmation)\n        return eventRecords.find(eventRecord => eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence));\n    }\n    onRecurrableAssignmentBeforeDelete({ assignmentRecords, context }) {\n        const\n            eventRecords = assignmentRecords.map(as => as.event),\n            eventRecord  = this.findRecurringEventToConfirmDelete(eventRecords);\n        if (this.enableRecurringEvents && eventRecord) {\n            this.recurrenceConfirmationPopup.confirm({\n                actionType : 'delete',\n                eventRecord,\n                changerFn() {\n                    context.finalize(true);\n                },\n                cancelFn() {\n                    context.finalize(false);\n                }\n            });\n            return false;\n        }\n    }\n    onRecurrableBeforeEventDropFinalize({ context }) {\n        if (this.enableRecurringEvents) {\n            const\n                { eventRecords } = context,\n                recurringEvents = eventRecords.filter(eventRecord => eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence));\n            if (recurringEvents.length) {\n                context.async = true;\n                this.recurrenceConfirmationPopup.confirm({\n                    actionType  : 'update',\n                    eventRecord : recurringEvents[0],\n                    changerFn() {\n                        context.finalize(true);\n                    },\n                    cancelFn() {\n                        context.finalize(false);\n                    }\n                });\n            }\n        }\n    }\n    onRecurrableBeforeEventResizeFinalize({ context }) {\n        if (this.enableRecurringEvents) {\n            const\n                { eventRecord } = context,\n                isRecurring     = eventRecord.supportsRecurring && (eventRecord.isRecurring || eventRecord.isOccurrence);\n            if (isRecurring) {\n                context.async = true;\n                this.recurrenceConfirmationPopup.confirm({\n                    actionType : 'update',\n                    eventRecord,\n                    changerFn() {\n                        context.finalize(true);\n                    },\n                    cancelFn() {\n                        context.finalize(false);\n                    }\n                });\n            }\n        }\n    }\n    // Make sure occurrence cache is up-to-date when reassigning events\n    onAssignmentChange({ action, records : assignments, changes }) {\n        // Ignore changes coming from engine normalizing the eventId/resourceId => event/resource\n        if (action === 'update' && changes.event && changes.resource && Object.keys(changes).length === 2) {\n            return;\n        }\n        if (action !== 'dataset' && Array.isArray(assignments)) {\n            for (const assignment of assignments) {\n                if (assignment.event?.isRecurring && !assignment.event.isBatchUpdating) {\n                    assignment.event.removeOccurrences(this.eventStore);\n                }\n            }\n        }\n    }\n    /**\n     * Returns occurrences of the provided recurring event across the date range of this Scheduler.\n     * @param  {Scheduler.model.TimeSpan} recurringEvent Recurring event for which occurrences should be retrieved.\n     * @returns {Scheduler.model.TimeSpan[]} Array of the provided timespans occurrences.\n     *\n     * __Empty if the passed event is not recurring, or has no occurrences in the date range.__\n     *\n     * __If the date range encompasses the start point, the recurring event itself will be the first entry.__\n     * @category Data\n     */\n    getOccurrencesFor(recurringEvent) {\n        return this.eventStore.getOccurrencesForTimeSpan(recurringEvent, this.timeAxis.startDate, this.timeAxis.endDate);\n    }\n    /**\n     * Internal utility function to remove events. Used when pressing [DELETE] or [BACKSPACE] or when clicking the\n     * delete button in the event editor. Triggers a preventable `beforeEventDelete` or `beforeAssignmentDelete` event.\n     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} eventRecords Records to remove\n     * @param {Function} [callback] Optional callback executed after triggering the event but before deletion\n     * @returns {Boolean} Returns `false` if the operation was prevented, otherwise `true`\n     * @internal\n     * @fires beforeEventDelete\n     * @fires beforeAssignmentDelete\n     */\n    async removeEvents(eventRecords, callback = null, popupOwner = this) {\n        const me = this;\n        if (!me.readOnly && eventRecords.length) {\n            const context = {\n                finalize(removeRecord = true) {\n                    if (callback) {\n                        callback(removeRecord);\n                    }\n                    if (removeRecord !== false) {\n                        if (eventRecords.some(record => record.isOccurrence || record.event?.isOccurrence)) {\n                            eventRecords.forEach(record => record.isOccurrenceAssignment ? record.event.remove() : record.remove());\n                        }\n                        else {\n                            const store = eventRecords[0].isAssignment ? me.assignmentStore : me.eventStore;\n                            store.remove(eventRecords);\n                        }\n                    }\n                }\n            };\n            let shouldFinalize;\n            if (eventRecords[0].isAssignment) {\n                /**\n                 * Fires before an assignment is removed. Can be triggered by user pressing [DELETE] or [BACKSPACE] or\n                 * by the event editor. Can for example be used to display a custom dialog to confirm deletion, in which\n                 * case records should be \"manually\" removed after confirmation:\n                 *\n                 * ```javascript\n                 * scheduler.on({\n                 *    beforeAssignmentDelete({ assignmentRecords, context }) {\n                 *        // Show custom confirmation dialog (pseudo code)\n                 *        confirm.show({\n                 *            listeners : {\n                 *                onOk() {\n                 *                    // Remove the assignments on confirmation\n                 *                    context.finalize(true);\n                 *                },\n                 *                onCancel() {\n                 *                    // do not remove the assignments if \"Cancel\" clicked\n                 *                    context.finalize(false);\n                 *                }\n                 *            }\n                 *        });\n                 *\n                 *        // Prevent default behaviour\n                 *        return false;\n                 *    }\n                 * });\n                 * ```\n                 *\n                 * @event beforeAssignmentDelete\n                 * @param {Scheduler.view.Scheduler} source  The Scheduler instance\n                 * @param {Scheduler.model.EventModel[]} eventRecords  The records about to be deleted\n                 * @param {Object} context  Additional removal context:\n                 * @param {Function} context.finalize  Function to call to finalize the removal.\n                 *      Used to asynchronously decide to remove the records or not. Provide `false` to the function to\n                 *      prevent the removal.\n                 * @param {Boolean} [context.finalize.removeRecords = true]   Provide `false` to the function to prevent\n                 *      the removal.\n                 * @preventable\n                 */\n                shouldFinalize = me.trigger('beforeAssignmentDelete', { assignmentRecords : eventRecords, context });\n            }\n            else {\n                /**\n                 * Fires before an event is removed. Can be triggered by user pressing [DELETE] or [BACKSPACE] or by the\n                 * event editor. Return `false` to immediately veto the removal (or a `Promise` yielding `true` or `false`\n                 * for async vetoing).\n                 *\n                 * Can for example be used to display a custom dialog to confirm deletion, in which case\n                 * records should be \"manually\" removed after confirmation:\n                 *\n                 * ```javascript\n                 * scheduler.on({\n                 *    beforeEventDelete({ eventRecords, context }) {\n                 *        // Show custom confirmation dialog (pseudo code)\n                 *        confirm.show({\n                 *            listeners : {\n                 *                onOk() {\n                 *                    // Remove the events on confirmation\n                 *                    context.finalize(true);\n                 *                },\n                 *                onCancel() {\n                 *                    // do not remove the events if \"Cancel\" clicked\n                 *                    context.finalize(false);\n                 *                }\n                 *            }\n                 *        });\n                 *\n                 *        // Prevent default behaviour\n                 *        return false;\n                 *    }\n                 * });\n                 * ```\n                 *\n                 * @event beforeEventDelete\n                 * @param {Scheduler.view.Scheduler} source The Scheduler instance\n                 * @typings source -> {Scheduler.view.Scheduler||any}\n                 * @param {Scheduler.model.EventModel[]} eventRecords  The records about to be deleted\n                 * @param {Object} context  Additional removal context:\n                 * @param {Function} context.finalize  Function to call to finalize the removal.\n                 *      Used to asynchronously decide to remove the records or not. Provide `false` to the function to\n                 *      prevent the removal.\n                 * @param {Boolean} [context.finalize.removeRecords = true]  Provide `false` to the function to prevent\n                 *      the removal.\n                 * @preventable\n                 * @async\n                 */\n                shouldFinalize = await me.trigger('beforeEventDelete', { eventRecords, context });\n            }\n            if (shouldFinalize !== false) {\n                const recurringEventRecord = eventRecords.find(eventRecord => eventRecord.isRecurring || eventRecord.isOccurrence);\n                if (recurringEventRecord) {\n                    me.recurrenceConfirmationPopup.owner = popupOwner;\n                    me.recurrenceConfirmationPopup.confirm({\n                        actionType  : 'delete',\n                        eventRecord : recurringEventRecord,\n                        changerFn() {\n                            context.finalize(true);\n                        },\n                        cancelFn() {\n                            context.finalize(false);\n                        }\n                    });\n                }\n                else {\n                    context.finalize(true);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/view/mixin/TimelineEventRendering\n */\n/**\n * Functions to handle event rendering (EventModel -> dom elements).\n *\n * @mixin\n */\nexport default Target => class TimelineEventRendering extends (Target || Base) {\n    static get $name() {\n        return 'TimelineEventRendering';\n    }\n    //region Default config\n    static get defaultConfig() {\n        return {\n            /**\n             * When `true`, events are sized and positioned based on rowHeight, resourceMargin and barMargin settings.\n             * Set this to `false` if you want to control height and vertical position using CSS instead.\n             *\n             * Note that events always get an absolute top position, but when this setting is enabled that position\n             * will match row's top. To offset within the row using CSS, use `transform : translateY(y)`.\n             *\n             * @config {Boolean}\n             * @default\n             * @category Scheduled events\n             */\n            managedEventSizing : true,\n            /**\n             * The CSS class added to an event/assignment when it is newly created\n             * in the UI and unsynced with the server.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            generatedIdCls : 'b-sch-dirty-new',\n            /**\n             * The CSS class added to an event when it has unsaved modifications\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            dirtyCls : 'b-sch-dirty',\n            /**\n             * The CSS class added to an event when it is currently committing changes\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            committingCls : 'b-sch-committing',\n            /**\n             * The CSS class added to an event/assignment when it ends outside of the visible time range.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            endsOutsideViewCls : 'b-sch-event-endsoutside',\n            /**\n             * The CSS class added to an event/assignment when it starts outside of the visible time range.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            startsOutsideViewCls : 'b-sch-event-startsoutside',\n            /**\n             * The CSS class added to an event/assignment when it is not draggable.\n             * @config {String}\n             * @default\n             * @private\n             * @category CSS\n             */\n            fixedEventCls : 'b-sch-event-fixed'\n        };\n    }\n    static configurable = {\n        /**\n         * Controls how much space to leave between stacked event bars in px.\n         *\n         * Value will be constrained by half the row height in horizontal mode.\n         *\n         * @prp {Number}\n         * @default\n         * @category Scheduled events\n         */\n        barMargin : 10,\n        /**\n         * Specify `true` to force rendered events/tasks to fill entire ticks. This only affects rendering, start\n         * and end dates retain their value on the data level.\n         *\n         * When enabling `fillTicks` you should consider either disabling EventDrag/TaskDrag and EventResize/TaskResize,\n         * or enabling {@link Scheduler/view/mixin/TimelineDateMapper#config-snap}. Otherwise their behaviour might not\n         * be what a user expects.\n         *\n         * @prp {Boolean}\n         * @default\n         * @category Scheduled events\n         */\n        fillTicks : false,\n        resourceMargin : null,\n        /**\n         * Event color used by default. Events and resources can specify their own color, with priority order being:\n         * Event -> Resource -> Scheduler default.\n         *\n         * Specify `null` to not apply a default color and take control using custom CSS (an easily overridden color\n         * will be used to make sure events are still visible).\n         *\n         * For available standard colors, see {@link Scheduler.model.mixin.EventModelMixin#typedef-EventColor}.\n         *\n         * @prp {EventColor} eventColor\n         * @category Scheduled events\n         */\n        eventColor : 'green',\n        /**\n         * Event style used by default. Events and resources can specify their own style, with priority order being:\n         * Event -> Resource -> Scheduler default. Determines the appearance of the event by assigning a CSS class\n         * to it. Available styles are:\n         *\n         * * `'plain'` (default) - flat look\n         * * `'border'` - has border in darker shade of events color\n         * * `'colored'` - has colored text and wide left border in same color\n         * * `'hollow'` - only border + text until hovered\n         * * `'line'` - as a line with the text below it\n         * * `'dashed'` - as a dashed line with the text below it\n         * * `'minimal'` - as a thin line with small text above it\n         * * `'rounded'` - minimalistic style with rounded corners\n         * * `null` - do not apply a default style and take control using custom CSS (easily overridden basic styling will be used).\n         *\n         * In addition, there are two styles intended to be used when integrating with Bryntum Calendar. To match\n         * the look of Calendar events, you can use:\n         *\n         * * `'calendar'` - a variation of the \"colored\" style matching the default style used by Calendar\n         * * `'interday'` - a variation of the \"plain\" style, for interday events\n         *\n         * @prp {'plain'|'border'|'colored'|'hollow'|'line'|'dashed'|'minimal'|'rounded'|'calendar'|'interday'|null}\n         * @default\n         * @category Scheduled events\n         */\n        eventStyle : 'plain',\n        /**\n         * The width/height (depending on vertical / horizontal mode) of all the time columns.\n         *\n         * There is a limit for the tick size value. Its minimal allowed value is calculated so ticks would fit the\n         * available space. Only applicable when {@link Scheduler.view.TimelineBase#config-forceFit} is set to\n         * `false`. To set `tickSize` freely skipping that limitation please set\n         * {@link Scheduler.view.TimelineBase#config-suppressFit} to `true`.\n         *\n         * @prp {Number}\n         * @category Scheduled events\n         */\n        tickSize : null\n    };\n    //endregion\n    //region Settings\n    updateFillTicks(fillTicks) {\n        if (!this.isConfiguring) {\n            this.timeAxis.forceFullTicks = fillTicks && this.snap;\n            this.refreshWithTransition();\n            this.trigger('stateChange');\n        }\n    }\n    changeBarMargin(margin) {\n        ObjectHelper.assertNumber(margin, 'barMargin');\n        // Run changeResourceMargin if its default value is null, to make sure resourceMarginObject is available\n        if (this._resourceMargin == null) {\n            this.changeResourceMargin(margin);\n        }\n        // bar margin should not exceed half of the row height\n        if (this.isHorizontal && this.rowHeight) {\n            return Math.min(Math.ceil(this.rowHeight / 2), margin);\n        }\n        return margin;\n    }\n    updateBarMargin() {\n        if (this.rendered) {\n            this.currentOrientation.onBeforeRowHeightChange();\n            this.refreshWithTransition();\n            this.trigger('stateChange');\n        }\n    }\n    // Documented in SchedulerEventRendering to not show up in Gantt docs\n    get resourceMargin() {\n        return this._resourceMargin == null ? this.barMargin : this._resourceMargin;\n    }\n    changeResourceMargin(margin) {\n        const me = this;\n        if (typeof margin === 'number') {\n            // resource margin should not exceed half of the row height\n            if (me.isHorizontal && me.rowHeight) {\n                margin = Math.min(Math.ceil(me.rowHeight / 2), margin);\n            }\n            me.resourceMarginObject = {\n                start : margin,\n                end   : margin,\n                total : margin * 2\n            };\n            return margin;\n        }\n        if (!margin?.start) {\n            margin.start = 0;\n        }\n        if (!margin?.end) {\n            margin.end = 0;\n        }\n        // resource margin should not exceed half of the row height\n        if (me.isHorizontal && me.rowHeight) {\n            margin.start = me.rowHeight < margin.start + margin.end ? Math.ceil(me.rowHeight / 2) : margin.start;\n            margin.end = me.rowHeight < margin.start + margin.end ? Math.ceil(me.rowHeight / 2) : margin.end;\n        }\n        me.resourceMarginObject = ObjectHelper.assign({\n            total : margin.start + margin.end\n        }, margin);\n        return margin;\n    }\n    updateResourceMargin() {\n        const me = this;\n        if (me.rendered) {\n            me.currentOrientation.onBeforeRowHeightChange();\n            me.refreshWithTransition();\n        }\n    }\n    changeTickSize(width) {\n        ObjectHelper.assertNumber(width, 'tickSize');\n        return width;\n    }\n    updateTickSize(width) {\n        this.timeAxisViewModel.tickSize = width;\n    }\n    get tickSize() {\n        return this.timeAxisViewModel.tickSize;\n    }\n    /**\n     * Predefined event colors, useful in combos etc.\n     * @type {String[]}\n     * @category Scheduled events\n     */\n    static get eventColors() {\n        // These are the colors available by default for Scheduler and Gantt\n        // They classes are located in eventstyles.scss\n        return ['red', 'pink', 'purple', 'magenta', 'violet', 'indigo', 'blue', 'cyan', 'teal', 'green', 'gantt-green', 'lime', 'yellow', 'orange', 'deep-orange', 'gray', 'light-gray'];\n    }\n    /**\n     * Predefined event styles , useful in combos etc.\n     * @type {String[]}\n     * @category Scheduled events\n     */\n    static get eventStyles() {\n        return ['plain', 'border', 'hollow', 'colored', 'line', 'dashed', 'minimal', 'rounded'];\n    }\n    updateEventStyle(style) {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n            this.trigger('stateChange');\n        }\n    }\n    updateEventColor(color) {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n            this.trigger('stateChange');\n        }\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport Scroller from '../../../Core/helper/util/Scroller.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport TimelineZoomable from './TimelineZoomable.js';\n/**\n * @module Scheduler/view/mixin/TimelineScroll\n */\nconst\n    maintainVisibleStart = {\n        maintainVisibleStart : true\n    },\n    defaultScrollOptions = {\n        block : 'nearest'\n    };\n/**\n * Functions for scrolling to events, dates etc.\n *\n * Note: the mixin applies {@link Scheduler/view/mixin/TimelineZoomable} mixin if it's not applied yet.\n *\n * @mixin\n */\nexport default Target => class TimelineScroll extends (Target || Base).mixin(\n    // the mixin overrides TimelineZoomable method so should be applied after it\n    TimelineZoomable\n) {\n    static $name = 'TimelineScroll';\n    static configurable = {\n        /**\n         * This config defines the size of the start and end invisible parts of the timespan when {@link #config-infiniteScroll} set to `true`.\n         *\n         * It should be provided as a coefficient, which will be multiplied by the size of the scheduling area.\n         *\n         * For example, if `bufferCoef` is `5` and the panel view width is 200px then the timespan will be calculated to\n         * have approximately 1000px (`5 * 200`) to the left and 1000px to the right of the visible area, resulting\n         * in 2200px of totally rendered content.\n         *\n         * @config {Number}\n         * @category Infinite scroll\n         * @default\n         */\n        bufferCoef : 5,\n        /**\n         * This config defines the scroll limit, which, when exceeded will cause a timespan shift.\n         * The limit is calculated as the `panelWidth * {@link #config-bufferCoef} * bufferThreshold`. During scrolling, if the left or right side\n         * has less than that of the rendered content - a shift is triggered.\n         *\n         * For example if `bufferCoef` is `5` and the panel view width is 200px and `bufferThreshold` is 0.2, then the timespan\n         * will be shifted when the left or right side has less than 200px (5 * 200 * 0.2) of content.\n         * @config {Number}\n         * @category Infinite scroll\n         * @default\n         */\n        bufferThreshold : 0.2,\n        /**\n         * Configure as `true` to automatically adjust the panel timespan during scrolling in the time dimension,\n         * when the scroller comes close to the start/end edges.\n         *\n         * The actually rendered timespan in this mode (and thus the amount of HTML in the DOM) is calculated based\n         * on the {@link #config-bufferCoef} option, and is thus not controlled by the {@link Scheduler/view/TimelineBase#config-startDate}\n         * and {@link Scheduler/view/TimelineBase#config-endDate} configs. The moment when the timespan shift\n         * happens is determined by the {@link #config-bufferThreshold} value.\n         *\n         * To specify initial point in time to view, supply the\n         * {@link Scheduler/view/TimelineBase#config-visibleDate} config.\n         *\n         * @config {Boolean} infiniteScroll\n         * @category Infinite scroll\n         * @default\n         */\n        infiniteScroll : false\n    };\n    //region TimelineZoomable injections\n    onZoomToSpan({ startDate }) {\n        if (this.infiniteScroll) {\n            this.scrollToDate(startDate, { block : 'start' });\n        }\n    }\n    calculateOptimalDateRange(centerDate, viewportSize, viewPreset) {\n        if (this.infiniteScroll) {\n            if (this.zoomKeepsOriginalTimespan) {\n                const { startDate, endDate } = this.timeAxis;\n                return { startDate, endDate };\n            }\n            return this.calculateInfiniteScrollingDateRange(centerDate, true);\n        }\n        return super.calculateOptimalDateRange(...arguments);\n    }\n    //endregion TimelineZoomable injections\n    initScroll() {\n        const\n            me = this,\n            {\n                isHorizontal,\n                visibleDate\n            }  = me;\n        super.initScroll();\n        const { scrollable } = isHorizontal ? me.timeAxisSubGrid : me;\n        scrollable.ion({\n            scroll  : 'onTimelineScroll',\n            thisObj : me\n        });\n        // Ensure the TimeAxis starts life at the correct size with buffer zones\n        // outside the visible window.\n        if (me.infiniteScroll) {\n            // If we have infiniteScroll-partners we don't reconfigure the timeAxis for each view\n            // So we need to trigger timeAxisViewModel.update manually to refresh the view\n            if (me.partneredWith?.values.some(partner => partner.infiniteScroll)) {\n                // Use exact subpixel available space so that tick size calculation is correct.\n                const availableSpace = scrollable.element.getBoundingClientRect()[me.isHorizontal ? 'width' : 'height'];\n                me.timeAxisViewModel.update(availableSpace, false, true);\n            }\n            // no infiniteScroll partners involved - calculate & set timespan\n            else {\n                const\n                    setTimeSpanOptions     = visibleDate ? { ...visibleDate, visibleDate : visibleDate.date } : { visibleDate : me.viewportCenterDate, block : 'center' },\n                    { startDate, endDate } = me.calculateInfiniteScrollingDateRange(setTimeSpanOptions.visibleDate, setTimeSpanOptions.block === 'center');\n                // Don't ask to maintain visible start - we're initializing - there's no visible start yet.\n                // If there's a visibleDate set, it will execute its scroll on paint.\n                me.setTimeSpan(\n                    startDate,\n                    endDate,\n                    setTimeSpanOptions\n                );\n            }\n        }\n    }\n    /**\n     * A {@link Core.helper.util.Scroller} which scrolls the time axis in whatever {@link Scheduler.view.Scheduler#config-mode} the\n     * Scheduler is configured, either `horizontal` or `vertical`.\n     *\n     * The width and height dimensions are replaced by `size`. So this will expose the following properties:\n     *\n     *    - `clientSize` The size of the time axis viewport.\n     *    - `scrollSize` The full scroll size of the time axis viewport\n     *    - `position` The position scrolled to along the time axis viewport\n     *\n     * @property {Core.helper.util.Scroller}\n     * @readonly\n     * @category Scrolling\n     */\n    get timelineScroller() {\n        const me = this;\n        if (!me.scrollInitialized) {\n            me.initScroll();\n        }\n        return me._timelineScroller || (me._timelineScroller = new TimelineScroller({\n            widget       : me,\n            scrollable   : me.isHorizontal ? me.timeAxisSubGrid.scrollable : me.scrollable,\n            isHorizontal : me.isHorizontal\n        }));\n    }\n    /**\n     * Used to calculate the range to extend the TimeAxis to during infinite scroll.\n     * @param {Date} date\n     * @param {Boolean} centered\n     * @param {Scheduler.preset.ViewPreset} [preset] Optional, the preset for which to calculate the range.\n     * defaults to the currently active ViewPreset\n     * @returns {Object} `{ startDate, endDate }`\n     * @internal\n     */\n    calculateInfiniteScrollingDateRange(date, centered, preset = this.timeAxisViewModel.viewPreset) {\n        const\n            {\n                timeAxis,\n                availableSpace\n            } = this.timeAxisViewModel,\n            {\n                bufferCoef\n            } = this,\n            {\n                leafUnit,\n                leafIncrement,\n                topUnit,\n                topIncrement,\n                tickSize\n            } = preset,\n            // If the units are the same and the increments are integer, snap to the top header's unit & increment\n            useTop    = leafUnit === topUnit && Math.round(topIncrement) === topIncrement && Math.round(leafIncrement) === leafIncrement,\n            snapSize  = useTop ? topIncrement : leafIncrement,\n            snapUnit  = useTop ? topUnit      : leafUnit;\n        // if provided date is the central point on the timespan\n        if (centered) {\n            const halfSpan = Math.ceil((availableSpace * bufferCoef + (availableSpace / 2)) / tickSize);\n            return {\n                startDate : timeAxis.floorDate(DateHelper.add(date, -halfSpan * leafIncrement, leafUnit), false, snapUnit, snapSize),\n                endDate   : timeAxis.ceilDate(DateHelper.add(date, halfSpan * leafIncrement, leafUnit), false, snapUnit, snapSize)\n            };\n        }\n        // if provided date is the left coordinate of the visible timespan area\n        else {\n            const bufferedTicks = Math.ceil(availableSpace * bufferCoef / tickSize);\n            return {\n                startDate : timeAxis.floorDate(DateHelper.add(date, -bufferedTicks * leafIncrement, leafUnit), false, snapUnit, snapSize),\n                endDate   : timeAxis.ceilDate(DateHelper.add(date, Math.ceil((availableSpace / tickSize + bufferedTicks) * leafIncrement), leafUnit), false, snapUnit, snapSize)\n            };\n        }\n    }\n    doDestroy() {\n        this._timelineScroller?.destroy();\n        super.doDestroy();\n    }\n    onTimelineScroll({ source }) {\n        // On scroll, check if we are nearing the end to see if the sliding window needs moving.\n        // onSchedulerHorizontalScroll is delayed to animationFrame\n        if (this.infiniteScroll) {\n            this.checkTimeAxisScroll(source[this.isHorizontal ? 'x' : 'y']);\n        }\n    }\n    checkTimeAxisScroll(scrollPos) {\n        const\n            me             = this,\n            scrollable     = me.timelineScroller,\n            { clientSize } = scrollable,\n            requiredSize   = clientSize * me.bufferCoef,\n            limit          = requiredSize * me.bufferThreshold,\n            maxScroll      = scrollable.maxPosition,\n            { style }      = me.timeAxisSubGrid.virtualScrollerElement;\n        // if scroll violates limits let's shift timespan\n        if ((maxScroll - scrollPos < limit) || scrollPos < limit) {\n            // If they were dragging the thumb, this must be a one-time thing. They *must* lose contact\n            // with the thumb when the window shift occurs and the thumb zooms back to the center.\n            // Changing for a short time to overflow:hidden terminates the thumb drag.\n            // They can start again from the center, the reset happens very quickly.\n            style.overflow = 'hidden';\n            style.pointerEvents = 'none';\n            // Avoid content height changing when scrollbar disappears\n            style.paddingBottom = `${DomHelper.scrollBarWidth}px`;\n            me.setTimeout(() => {\n                style.overflow = '';\n                style.paddingBottom = '';\n                style.pointerEvents = '';\n            }, 100);\n            me.shiftToDate(me.getDateFromCoordinate(scrollPos, null, true, false, true));\n        }\n    }\n    shiftToDate(date, centered) {\n        const newRange = this.calculateInfiniteScrollingDateRange(date, centered);\n        // this will trigger a refresh (`refreshKeepingScroll`) which will perform `restoreScrollState` and sync the scrolling position\n        this.setTimeSpan(newRange.startDate, newRange.endDate, maintainVisibleStart);\n    }\n    // If we change to infinite scrolling dynamically, it should create the buffer zones.\n    updateInfiniteScroll(infiniteScroll) {\n        // At construction time, this is handled in initScroll.\n        // This is just here to handle dynamic updates.\n        if (!this.isConfiguring && infiniteScroll) {\n            this.checkTimeAxisScroll(this.timelineScroller.position);\n        }\n    }\n    //region Scroll to date\n    /**\n     * Scrolls the timeline \"tick\" encapsulating the passed `Date` into view according to the passed options.\n     * @param {Date} date The date to which to scroll the timeline\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     */\n    async scrollToDate(date, options = {}) {\n        const\n            me               = this,\n            {\n                timeAxis,\n                visibleDateRange,\n                infiniteScroll\n            }              = me,\n            {\n                unit,\n                increment\n            }              = timeAxis,\n            edgeOffset     = options.edgeOffset || 0,\n            visibleWidth   = DateHelper.ceil(visibleDateRange.endDate, increment + ' ' + unit) - DateHelper.floor(visibleDateRange.startDate, increment + ' ' + unit),\n            direction      = date > me.viewportCenterDate ? 1 : -1,\n            extraScroll    = (infiniteScroll ? visibleWidth * me.bufferCoef * me.bufferThreshold : (options.block === 'center' ? visibleWidth / 2 : (edgeOffset ? me.getMilliSecondsPerPixelForZoomLevel(me.viewPreset) * edgeOffset : 0))) * direction,\n            visibleDate    = new Date(date.getTime() + extraScroll),\n            shiftDirection = visibleDate > timeAxis.endDate ? 1 : visibleDate < timeAxis.startDate ? -1 : 0;\n        // Required visible date outside TimeAxis and infinite scrolling, that has opinions about how\n        // much scroll range has to be created after the target date.\n        if (shiftDirection && me.infiniteScroll) {\n            me.shiftToDate(new Date(date - extraScroll), null, true);\n            // shift to date could trigger a native browser async scroll out of our control. If a scroll\n            // happens during scrollToCoordinate, the scrolling is cancelled so we wait a bit here\n            await me.nextAnimationFrame();\n        }\n        const\n            scrollerViewport = me.timelineScroller.viewport,\n            localCoordinate  = me.getCoordinateFromDate(date, true),\n            // Available space can be less than tick size (Export.t.js in Gantt)\n            width            = Math.min(me.timeAxisViewModel.tickSize, me.timeAxisViewModel.availableSpace),\n            target           = me.isHorizontal\n                // In RTL coordinate is for the right edge of the tick, so we need to subtract width\n                ? new Rectangle(me.getCoordinateFromDate(date, false) - (me.rtl ? width : 0), scrollerViewport.y, width, scrollerViewport.height)\n                : new Rectangle(scrollerViewport.x, me.getCoordinateFromDate(date, false), scrollerViewport.width, me.timeAxisViewModel.tickSize);\n        await me.scrollToCoordinate(localCoordinate, target, date, options);\n    }\n    /**\n     * Scrolls to current time.\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     */\n    scrollToNow(options = {}) {\n        return this.scrollToDate(new Date(), options);\n    }\n    /**\n     * Used by {@link #function-scrollToDate} to scroll to correct coordinate.\n     * @param {Number} localCoordinate Coordinate to scroll to\n     * @param {Element|Core.helper.util.Rectangle} target The target\n     * @param {Date} date Date to scroll to, used for reconfiguring the time axis\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @private\n     * @category Scrolling\n     */\n    async scrollToCoordinate(localCoordinate, target, date, options = {}) {\n        const me = this;\n        // Not currently have this date in a timeaxis. Ignore negative scroll in weekview, it can be just 'filtered' with\n        // startTime/endTime config\n        if (localCoordinate < 0) {\n            // adjust the timeaxis first\n            const\n                visibleSpan         = me.endDate - me.startDate,\n                { unit, increment } = me.timeAxis,\n                newStartDate        = DateHelper.floor(new Date(date.getTime() - (visibleSpan / 2)), increment + ' ' + unit),\n                newEndDate          = DateHelper.add(newStartDate, visibleSpan);\n            // We're trying to reconfigure time span to current dates, which means we are as close to center as it\n            // could be. Do nothing then.\n            // covered by 1102_panel_api\n            if (newStartDate - me.startDate !== 0 && newEndDate - me.endDate !== 0) {\n                await me.setTimeSpan(newStartDate, newEndDate);\n                return me.scrollToDate(date, options);\n            }\n            return;\n        }\n        await me.timelineScroller.scrollIntoView(target, options);\n        // Horizontal scroll is triggered on next frame in SubGrid.js, view is not up to date yet. Resolve on next frame\n        return !me.isDestroyed && me.nextAnimationFrame();\n    }\n    //endregion\n    //region Relative scrolling\n    // These methods are important to users because although they are mixed into the top level Grid/Scheduler,\n    // for X scrolling the explicitly target the SubGrid that holds the scheduler.\n    /**\n     * Get/set the `scrollLeft` value of the SubGrid that holds the scheduler.\n     *\n     * This may be __negative__ when the writing direction is right-to-left.\n     * @property {Number}\n     * @category Scrolling\n     */\n    set scrollLeft(left) {\n        this.timeAxisSubGrid.scrollable.element.scrollLeft = left;\n    }\n    get scrollLeft() {\n        return this.timeAxisSubGrid.scrollable.element.scrollLeft;\n    }\n    /**\n     * Get/set the writing direction agnostic horizontal scroll position.\n     *\n     * This is always the __positive__ offset from the scroll origin whatever the writing\n     * direction in use.\n     *\n     * Applies to the SubGrid that holds the scheduler\n     * @property {Number}\n     * @category Scrolling\n     */\n    set scrollX(x) {\n        this.timeAxisSubGrid.scrollable.x = x;\n    }\n    get scrollX() {\n        return this.timeAxisSubGrid.scrollable.x;\n    }\n    /**\n     * Get/set vertical scroll\n     * @property {Number}\n     * @category Scrolling\n     */\n    set scrollTop(top) {\n        this.scrollable.y = top;\n    }\n    get scrollTop() {\n        return this.scrollable.y;\n    }\n    /**\n     * Horizontal scrolling. Applies to the SubGrid that holds the scheduler\n     * @param {Number} x\n     * @param {BryntumScrollOptions|Boolean} [options] How to scroll. May be passed as `true` to animate.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollHorizontallyTo(coordinate, options = true) {\n        return this.timeAxisSubGrid.scrollable.scrollTo(coordinate, null, options);\n    }\n    /**\n     * Vertical scrolling\n     * @param {Number} y\n     * @param {BryntumScrollOptions|Boolean} [options] How to scroll. May be passed as `true` to animate.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollVerticallyTo(y, options = true) {\n        return this.scrollable.scrollTo(null, y, options);\n    }\n    /**\n     * Scrolls the subgrid that contains the scheduler\n     * @param {Number} x\n     * @param {BryntumScrollOptions|Boolean} [options] How to scroll. May be passed as `true` to animate.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollTo(x, options = true) {\n        return this.timeAxisSubGrid.scrollable.scrollTo(x, null, options);\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n// Internal class used to interrogate and manipulate the timeline scroll position.\n// This delegates all operations to the appropriate Scroller, horizontal or vertical.\nclass TimelineScroller extends Scroller {\n    static get configurable() {\n        return {\n            position : null,\n            x        : null,\n            y        : null\n        };\n    }\n    // This class is passive about configuring the element.\n    // It has no opinions about *how* the overflow is handled.\n    updateOverflowX() {}\n    updateOverflowY() {}\n    onScroll(e) {\n        super.onScroll(e);\n        this._position = null;\n    }\n    syncPartners(force) {\n        this.scrollable.syncPartners(force);\n    }\n    updatePosition(position) {\n        this.scrollable[this.isHorizontal ? 'x' : 'y'] = position;\n    }\n    get viewport() {\n        return this.scrollable.viewport;\n    }\n    get position() {\n        return this._position = this.scrollable[this.isHorizontal ? 'x' : 'y'];\n    }\n    get clientSize() {\n        return this.scrollable[`client${this.isHorizontal ? 'Width' : 'Height'}`];\n    }\n    get scrollSize() {\n        return this.scrollable[`scroll${this.isHorizontal ? 'Width' : 'Height'}`];\n    }\n    get maxPosition() {\n        return this.scrollable[`max${this.isHorizontal ? 'X' : 'Y'}`];\n    }\n    scrollTo(position, options) {\n        return this.isHorizontal ? this.scrollable.scrollTo(position, null, options) : this.scrollable.scrollTo(null, position, options);\n    }\n    scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions) {\n        // Use the correct delta by default, but if it's zero, accommodate axis error.\n        return this.isHorizontal ? this.scrollable.scrollBy(xDelta || yDelta, 0, options) : this.scrollable.scrollBy(0, yDelta || xDelta, options);\n    }\n    scrollIntoView() {\n        return this.scrollable.scrollIntoView(...arguments);\n    }\n    // We accommodate mistakes. Setting X and Y sets the appropriate scroll axis position\n    changeX(x) {\n        this.position = x;\n    }\n    changeY(y) {\n        this.position = y;\n    }\n    get x() {\n        return this.position;\n    }\n    set x(x) {\n        this.scrollable[this.isHorizontal ? 'x' : 'y'] = x;\n    }\n    get y() {\n        return this.position;\n    }\n    set y(y) {\n        this.scroller[this.isHorizontal ? 'x' : 'y'] = y;\n    }\n    get clientWidth() {\n        return this.clientSize;\n    }\n    get clientHeight() {\n        return this.clientSize;\n    }\n    get scrollWidth() {\n        return this.scrollSize;\n    }\n    get scrollHeight() {\n        return this.scrollSize;\n    }\n    get maxX() {\n        return this.maxPosition;\n    }\n    get maxY() {\n        return this.maxPosition;\n    }\n}\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/view/mixin/TimelineState\n */\nconst copyProperties = [\n    'barMargin'\n];\n/**\n * Mixin for Timeline base that handles state. It serializes the following timeline properties:\n *\n * * barMargin\n * * zoomLevel\n *\n * See {@link Grid.view.mixin.GridState} and {@link Core.mixin.State} for more information on state.\n *\n * @mixin\n */\nexport default Target => class TimelineState extends (Target || Base) {\n    static get $name() {\n        return 'TimelineState';\n    }\n    /**\n     * Gets or sets timeline's state. Check out {@link Scheduler.view.mixin.TimelineState} mixin for details.\n     * @member {Object} state\n     * @property {Object[]} state.columns\n     * @property {Number} state.rowHeight\n     * @property {Object} state.scroll\n     * @property {Number} state.scroll.scrollLeft\n     * @property {Number} state.scroll.scrollTop\n     * @property {Array} state.selectedRecords\n     * @property {String} state.style\n     * @property {String} state.selectedCell\n     * @property {Object} state.store\n     * @property {Object} state.store.sorters\n     * @property {Object} state.store.groupers\n     * @property {Object} state.store.filters\n     * @property {Object} state.subGrids\n     * @property {Number} state.barMargin\n     * @property {Number} state.zoomLevel\n     * @category State\n     */\n    /**\n     * Get timeline's current state for serialization. State includes rowHeight, headerHeight, readOnly, selectedCell,\n     * selectedRecordId, column states and store state etc.\n     * @returns {Object} State object to be serialized\n     * @private\n     */\n    getState() {\n        const\n            me    = this,\n            state = ObjectHelper.copyProperties(super.getState(), me, copyProperties);\n        state.zoomLevel = me.zoomLevel;\n        state.zoomLevelOptions = {\n            startDate  : me.startDate,\n            endDate    : me.endDate,\n            // With infinite scroll reading viewportCenterDate too early will lead to exception\n            centerDate : !me.infiniteScroll || me.timeAxisViewModel.availableSpace ? me.viewportCenterDate : undefined,\n            width      : me.tickSize\n        };\n        return state;\n    }\n    /**\n     * Apply previously stored state.\n     * @param {Object} state\n     * @private\n     */\n    applyState(state) {\n        const me = this;\n        me.suspendRefresh();\n        ObjectHelper.copyProperties(me, state, copyProperties);\n        super.applyState(state);\n        if (state.zoomLevel != null) {\n            // Do not restore left scroll, infinite scroll should do all the work\n            if (me.infiniteScroll) {\n                if (state?.scroll?.scrollLeft) {\n                    state.scroll.scrollLeft = {};\n                }\n            }\n            if (me.isPainted) {\n                me.zoomToLevel(state.zoomLevel, state.zoomLevelOptions);\n            }\n            else {\n                me._zoomAfterPaint = { zoomLevel : state.zoomLevel, zoomLevelOptions : state.zoomLevelOptions };\n            }\n        }\n        me.resumeRefresh(true);\n    }\n    onInternalPaint(...args) {\n        super.onInternalPaint(...args);\n        if (this._zoomAfterPaint) {\n            const { zoomLevel, zoomLevelOptions } = this._zoomAfterPaint;\n            this.zoomToLevel(zoomLevel, zoomLevelOptions);\n            delete this._zoomAfterPaint;\n        }\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import GridHeader from '../../Grid/view/Header.js';\n/**\n * @module Scheduler/view/Header\n */\n/**\n * Custom header subclass which handles the existence of the special TimeAxisColumn\n *\n * @extends Grid/view/Header\n * @private\n */\nexport default class Header extends GridHeader {\n    static get $name() {\n        return 'SchedulerHeader';\n    }\n    refreshContent() {\n        // Only render contents into the header once as it contains the special rendering of the TimeAxisColumn\n        // In case ResizeObserver polyfill is used headers element will have resize monitors inserted and we should\n        // take that into account\n        // https://github.com/bryntum/support/issues/3444\n        if (!this.headersElement?.querySelector('.b-sch-timeaxiscolumn')) {\n            super.refreshContent();\n        }\n    }\n}\nHeader._$name = 'Header';", "import SubGrid from '../../Grid/view/SubGrid.js';\nimport Header from './Header.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n/**\n * @module Scheduler/view/TimeAxisSubGrid\n */\n/**\n * Widget that encapsulates the SubGrid part of the scheduler which houses the timeline view.\n * @extends Grid/view/SubGrid\n * @private\n */\nexport default class TimeAxisSubGrid extends SubGrid {\n    static get $name() {\n        return 'TimeAxisSubGrid';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'timeaxissubgrid';\n    }\n    static get configurable() {\n        return {\n            // A Scheduler's SubGrid doesn't accept external columns moving in\n            sealedColumns : true,\n            // Use Scheduler's Header class\n            headerClass : Header\n        };\n    }\n    startConfigure(config) {\n        const { grid : scheduler } = config;\n        // Scheduler references its TimeAxisSubGrid instance through this property.\n        scheduler.timeAxisSubGrid = this;\n        super.startConfigure(config);\n        if (scheduler.isHorizontal) {\n            config.header = {\n                cls : {\n                    'b-sticky-headers' : scheduler.stickyHeaders\n                }\n            };\n            // We don't use what the GridSubGrids mixin tells us to.\n            // We use the Scheduler's Header class.\n            delete config.headerClass;\n        }\n        // If user have not specified a width or flex for scheduler region, default to flex=1\n        if (!('flex' in config || 'width' in config)) {\n            config.flex = 1;\n        }\n    }\n    changeScrollable() {\n        const\n            me         = this,\n            scrollable = super.changeScrollable(...arguments);\n        // TimeAxisSubGrid's X axis is stretched by its canvas.\n        // We don't need the Scroller's default stretching implementation.\n        if (scrollable) {\n            Object.defineProperty(scrollable, 'scrollWidth', {\n                get() {\n                    return this.element?.scrollWidth ?? 0;\n                },\n                set() {\n                    // Setting the scroll width to be wide just updates the canvas side in Scheduler.\n                    // We do not need the Scroller's default stretcher element to be added.\n                    // Note that \"me\" here is the TimeAxisSubGrid, so we are calling Scheduler.\n                    me.grid.updateCanvasSize();\n                }\n            });\n        }\n        return scrollable;\n    }\n    handleHorizontalScroll(addCls = true) {\n        // Swallow scroll syncing calls that happen during view preset changes, that process triggers multiple when\n        // it first changes tickWidth, then scrolls to center and then an additional sync on scroll end\n        if (!this.grid._viewPresetChanging) {\n            super.handleHorizontalScroll(addCls);\n        }\n    }\n    /**\n     * This is an event handler triggered when the TimeAxisSubGrid changes size.\n     * Its height changes when content height changes, and that is not what we are\n     * interested in here. If the *width* changes, that means the visible viewport\n     * has changed size.\n     * @param {HTMLElement} element\n     * @param {Number} width\n     * @param {Number} height\n     * @param {Number} oldWidth\n     * @param {Number} oldHeight\n     * @private\n     */\n    onInternalResize(element, width, height, oldWidth, oldHeight) {\n        const me = this;\n        // Call super first, to clear cached width / height\n        super.onInternalResize(...arguments);\n        // We, as the TimeAxisSubGrid dictate the scheduler viewport width\n        if (me.isPainted && width !== oldWidth) {\n            const\n                scheduler     = me.grid,\n                bodyHeight    = scheduler._bodyRectangle.height,\n                // Avoid ResizeObserver errors when this operation may create a scrollbar\n                shouldSuspend = me.monitorResize && DomHelper.scrollBarWidth && width < oldWidth;\n            if (shouldSuspend) {\n                me.monitorResize = false;\n            }\n            scheduler.onSchedulerViewportResize(width, bodyHeight, oldWidth, bodyHeight);\n            // Revert to monitoring on the next animation frame.\n            // Changed to revert earlier because of issues when changing width programmatically\n            // This is to avoid \"ResizeObserver loop completed with undelivered notifications.\"\n            if (shouldSuspend) {\n                queueMicrotask(() => me.monitorResize = true);\n            }\n        }\n    }\n    get headerScrollWidth() {\n        return this.grid.isVertical ? super.headerScrollWidth : this.grid.timeAxisViewModel.totalSize;\n    }\n    // When restoring state we need to update time axis size immediately, resize event is not triggered fast enough to\n    // restore center date consistently\n    clearWidthCache() {\n        super.clearWidthCache();\n        // Check if we are in horizontal mode\n        if (this.owner.isHorizontal) {\n            this.owner.updateViewModelAvailableSpace(this.width);\n        }\n    }\n    async expand() {\n        const { owner } = this;\n        await super.expand();\n        if (owner.isPainted) {\n            owner.timeAxisViewModel.update(this.width, false, true);\n        }\n    }\n}\n// Register this widget type with its Factory\nTimeAxisSubGrid.initClass();\nTimeAxisSubGrid._$name = 'TimeAxisSubGrid';", "import GlobalEvents from '../../Core/GlobalEvents.js';\nimport GridBase from '../../Grid/view/GridBase.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport FunctionHelper from '../../Core/helper/FunctionHelper.js';\nimport ResizeMonitor from '../../Core/helper/ResizeMonitor.js';\nimport Collection from '../../Core/util/Collection.js';\nimport IdHelper from '../../Core/helper/IdHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport TimeAxis from '../data/TimeAxis.js';\nimport TimeAxisViewModel from './model/TimeAxisViewModel.js';\nimport TimelineDateMapper from './mixin/TimelineDateMapper.js';\nimport TimelineDomEvents from './mixin/TimelineDomEvents.js';\nimport TimelineViewPresets from './mixin/TimelineViewPresets.js';\nimport TimelineZoomable from './mixin/TimelineZoomable.js';\nimport RecurringEvents from './mixin/RecurringEvents.js';\nimport TimelineEventRendering from './mixin/TimelineEventRendering.js';\nimport TimelineScroll from './mixin/TimelineScroll.js';\nimport TimelineState from './mixin/TimelineState.js';\nimport './TimeAxisSubGrid.js';\nimport '../../Grid/feature/RegionResize.js';\nconst\n    exitTransition = {\n        fn                : 'exitTransition',\n        delay             : 0,\n        cancelOutstanding : true\n    },\n    inRange = (v, r0, r1) => (r0 == null)\n        ? (r1 == null || v < r1)\n        : (r1 == null)\n            ? v >= r0\n            : (r0 < r1)\n                ? (r0 <= v && v < r1)       // 5 in [1, 10]  (after 1 and before 10)\n                : (v < r1 || r0 <= v),      // 5 in [10, 1]  (after 10 or before 1)\n    isWorkingTime = (d, wt) => inRange(d.getDay(), wt.fromDay, wt.toDay) && inRange(d.getHours(), wt.fromHour, wt.toHour),\n    emptyObject   = {};\n/**\n * @module Scheduler/view/TimelineBase\n */\n/**\n * Options accepted by the Scheduler's {@link Scheduler.view.Scheduler#config-visibleDate} property.\n *\n * @typedef {Object} VisibleDate\n * @property {Date} date The date to bring into view.\n * @property {'start'|'end'|'center'|'nearest'} [block] How far to scroll the date.\n * @property {Number} [edgeOffset] edgeOffset A margin around the date to bring into view.\n * @property {AnimateScrollOptions|Boolean|Number} [animate] Set to `true` to animate the scroll by 300ms,\n * or the number of milliseconds to animate over, or an animation config object.\n */\n/**\n * Abstract base class used by timeline based components such as Scheduler and Gantt. Based on Grid, supplies a \"locked\"\n * region for columns and a \"normal\" for rendering of events etc.\n * @abstract\n *\n * @mixes Scheduler/view/mixin/TimelineDateMapper\n * @mixes Scheduler/view/mixin/TimelineDomEvents\n * @mixes Scheduler/view/mixin/TimelineEventRendering\n * @mixes Scheduler/view/mixin/TimelineZoomable\n * @mixes Scheduler/view/mixin/TimelineScroll\n * @mixes Scheduler/view/mixin/TimelineState\n * @mixes Scheduler/view/mixin/TimelineViewPresets\n * @mixes Scheduler/view/mixin/RecurringEvents\n *\n * @extends Grid/view/Grid\n */\nexport default class TimelineBase extends GridBase.mixin(\n    TimelineDateMapper,\n    TimelineDomEvents,\n    TimelineEventRendering,\n    TimelineZoomable,\n    TimelineScroll,\n    TimelineState,\n    TimelineViewPresets,\n    RecurringEvents\n) {\n    //region Config\n    /**\n     * @prp animateTreeNodeToggle\n     * @hide\n     */\n    static $name = 'TimelineBase';\n    // Factoryable type name\n    static type = 'timelinebase';\n    static configurable = {\n        // Not yet supported\n        animateTreeNodeToggle : false,\n        partnerSharedConfigs : {\n            value : ['timeAxisViewModel', 'timeAxis', 'viewPreset', 'infiniteScroll'],\n            $config : {\n                merge : 'distinct'\n            }\n        },\n        /**\n         * Get/set startDate. Defaults to current date if none specified.\n         *\n         * When using {@link #config-infiniteScroll}, use {@link #config-visibleDate} to control initially visible date\n         * instead.\n         *\n         * **Note:** If you need to set start and end date at the same time, use {@link #function-setTimeSpan} method.\n         * @member {Date} startDate\n         * @category Common\n         */\n        /**\n         * The start date of the timeline (if not configure with {@link #config-infiniteScroll}).\n         *\n         * If omitted, and a TimeAxis has been set, the start date of the provided {@link Scheduler.data.TimeAxis} will\n         * be used. If no TimeAxis has been configured, it'll use the start/end dates of the loaded event dataset. If no\n         * date information exists in the event data set, it defaults to the current date and time.\n         *\n         * If a string is supplied, it will be parsed using\n         * {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat}.\n         *\n         * When using {@link #config-infiniteScroll}, use {@link #config-visibleDate} to control initially visible date\n         * instead.\n         *\n         * **Note:** If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n         * @config {Date|String}\n         * @category Common\n         */\n        startDate : {\n            $config : {\n                equal : 'date'\n            },\n            value : null\n        },\n        /**\n         * Get/set endDate. Defaults to startDate + default span of the used ViewPreset.\n         *\n         * **Note:** If you need to set start and end date at the same time, use {@link #function-setTimeSpan} method.\n         * @member {Date} endDate\n         * @category Common\n         */\n        /**\n         * The end date of the timeline (if not configure with {@link #config-infiniteScroll}).\n         *\n         * If omitted, it will be calculated based on the {@link #config-startDate} setting and the 'defaultSpan'\n         * property of the current {@link #config-viewPreset}.\n         *\n         * If a string is supplied, it will be parsed using\n         * {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat}.\n         *\n         * **Note:** If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n         * @config {Date|String}\n         * @category Common\n         */\n        endDate : {\n            $config : {\n                equal : 'date'\n            },\n            value : null\n        },\n        /**\n         * Partners this Timeline panel with another Timeline in order to sync their region sizes (sub-grids like locked, normal will get the same width),\n         * start and end dates, view preset, zoom level and scrolling position. All these values will be synced with the timeline defined as the `partner`.\n         *\n         * - To add a new partner dynamically see {@link #function-addPartner} method.\n         * - To remove existing partner see {@link #function-removePartner} method.\n         * - To check if timelines are partners see {@link #function-isPartneredWith} method.\n         *\n         * Column widths and hide/show state are synced between partnered schedulers when the column set is identical.\n         * @config {Scheduler.view.TimelineBase}\n         * @category Time axis\n         */\n        partner : null,\n        /**\n         * When set, the text in the major time axis header sticks in the scrolling viewport as long as possible.\n         * @config {Boolean}\n         * @default\n         * @category Time axis\n         */\n        stickyHeaders : true,\n        /**\n         * A scrolling `options` object describing the scroll action, including a `date` option\n         * which references a `Date`. See {@link #function-scrollToDate} for details about scrolling options.\n         *\n         * ```javascript\n         *     // The date we want in the center of the Scheduler viewport\n         *     myScheduler.visibleDate = {\n         *         date    : new Date(2023, 5, 17, 12),\n         *         block   : 'center',\n         *         animate : true\n         *     };\n         * ```\n         * @member {Object} visibleDate\n         * @category Common\n         */\n        /**\n         * A date to bring into view initially on the scrollable timeline.\n         *\n         * This may be configured as either a `Date` or a scrolling `options` object describing\n         * the scroll action, including a `date` option which references a `Date`.\n         *\n         * See {@link #function-scrollToDate} for details about scrolling options.\n         *\n         * Note that if a naked `Date` is passed, it will be stored internally as a scrolling options object\n         * using the following defaults:\n         *\n         * ```javascript\n         * {\n         *     date  : <The Date object>,\n         *     block : 'nearest'\n         * }\n         * ```\n         *\n         * This moves the date into view by the shortest scroll, so that it just appears at an edge.\n         *\n         * To bring your date of interest to the center of the viewport, configure your\n         * Scheduler thus:\n         *\n         * ```javascript\n         *     visibleDate : {\n         *         date  : new Date(2023, 5, 17, 12),\n         *         block : 'center'\n         *     }\n         * ```\n         * @config {Date|VisibleDate}\n         * @category Common\n         */\n        visibleDate : null,\n        /**\n         * CSS class to add to rendered events\n         * @config {String}\n         * @category CSS\n         * @private\n         */\n        eventCls : null,\n        /**\n         * Set to `true` to force the time columns to fit to the available space (horizontal or vertical depends on mode).\n         * Note that setting {@link #config-suppressFit} to `true`, will disable `forceFit` functionality. Zooming\n         * cannot be used when `forceFit` is set.\n         * @prp {Boolean}\n         * @default\n         * @category Time axis\n         */\n        forceFit : false,\n        /**\n         * Set to a time zone or a UTC offset. This will set the projects\n         * {@link Scheduler.model.ProjectModel#config-timeZone} config accordingly. As this config is only a referer,\n         * please se project's config {@link Scheduler.model.ProjectModel#config-timeZone documentation} for more\n         * information.\n         *\n         * ```javascript\n         * new Calendar(){\n         *   timeZone : 'America/Chicago'\n         * }\n         * ```\n         * @prp {String|Number} timeZone\n         * @category Misc\n         */\n        timeZone : null,\n        /**\n         * By default the row hover effect is not visible in the Scheduler part of the grid.\n         *\n         * Set this to `false` to show the hover effect in Scheduler rows.\n         * @prp {Boolean} hideRowHover\n         * @default true\n         * @category Misc\n         */\n        hideRowHover : {\n            $config : 'lazy',\n            value   : true\n        }\n    };\n    static get defaultConfig() {\n        return {\n            /**\n             * A valid JS day index between 0-6 (0: Sunday, 1: Monday etc.) to be considered the start day of the week.\n             * When omitted, the week start day is retrieved from the active locale class.\n             * @config {Number} weekStartDay\n             * @category Time axis\n             */\n            /**\n             * An object with format `{ fromDay, toDay, fromHour, toHour }` that describes the working days and hours.\n             * This object will be used to populate TimeAxis {@link Scheduler.data.TimeAxis#config-include} property.\n             *\n             * Using it results in a non-continuous time axis. Any ticks not covered by the working days and hours will\n             * be excluded. Events within larger ticks (for example if using week as the unit for ticks) will be\n             * stretched to fill the gap otherwise left by the non working hours.\n             *\n             * As with end dates, `toDay` and `toHour` are exclusive. Thus `toDay : 6` means that day 6 (saturday) will\n             * not be included.\n             *\n             *\n             * **NOTE:** When this feature is enabled {@link Scheduler.view.mixin.TimelineZoomable Zooming feature} is\n             * not supported. It's recommended to disable zooming controls:\n             *\n             * ```javascript\n             * new Scheduler({\n             *     zoomOnMouseWheel          : false,\n             *     zoomOnTimeAxisDoubleClick : false,\n             *     ...\n             * });\n             * ```\n             *\n             * @config {Object}\n             * @category Time axis\n             */\n            workingTime : null,\n            /**\n             * A backing data store of 'ticks' providing the input date data for the time axis of timeline panel.\n             * @member {Scheduler.data.TimeAxis} timeAxis\n             * @readonly\n             * @category Time axis\n             */\n            /**\n             * A {@link Scheduler.data.TimeAxis} config object or instance, used to create a backing data store of\n             * 'ticks' providing the input date data for the time axis of timeline panel. Created automatically if none\n             * supplied.\n             * @config {TimeAxisConfig|Scheduler.data.TimeAxis}\n             * @category Time axis\n             */\n            timeAxis : null,\n            /**\n             * The backing view model for the visual representation of the time axis.\n             * Either a real instance or a simple config object.\n             * @private\n             * @config {Scheduler.view.model.TimeAxisViewModel|TimeAxisViewModelConfig}\n             * @category Time axis\n             */\n            timeAxisViewModel : null,\n            /**\n             * You can set this option to `false` to make the timeline panel start and end on the exact provided\n             * {@link #config-startDate}/{@link #config-endDate} w/o adjusting them.\n             * @config {Boolean}\n             * @default\n             * @category Time axis\n             */\n            autoAdjustTimeAxis : true,\n            /**\n             * Affects drag drop and resizing of events when {@link Scheduler/view/mixin/TimelineDateMapper#config-snap}\n             * is enabled.\n             *\n             * If set to `true`, dates will be snapped relative to event start. e.g. for a zoom level with\n             * `timeResolution = { unit: \"s\", increment: \"20\" }`, an event that starts at 10:00:03 and is dragged would\n             * snap its start date to 10:00:23, 10:00:43 etc.\n             *\n             * When set to `false`, dates will be snapped relative to the timeAxis startDate (tick start)\n             * - 10:00:03 -> 10:00:20, 10:00:40 etc.\n             *\n             * @config {Boolean}\n             * @default\n             * @category Scheduled events\n             */\n            snapRelativeToEventStartDate : false,\n            /**\n             * Set to `true` to prevent auto calculating of a minimal {@link Scheduler.view.mixin.TimelineEventRendering#property-tickSize}\n             * to always fit the content to the screen size. Setting this property on `true` will disable {@link #config-forceFit} behaviour.\n             * @config {Boolean}\n             * @default false\n             * @category Time axis\n             */\n            suppressFit : false,\n            /**\n             * CSS class to add to cells in the timeaxis column\n             * @config {String}\n             * @category CSS\n             * @private\n             */\n            timeCellCls : null,\n            scheduledEventName : null,\n            //dblClickTime : 200,\n            /**\n             * A CSS class to apply to each event in the view on mouseover.\n             * @config {String}\n             * @category CSS\n             * @private\n             */\n            overScheduledEventClass : null,\n            // allow the panel to prevent adding the hover CSS class in some cases - during drag drop operations\n            preventOverCls : false,\n            /**\n             * Set to `false` if you don't want event bar DOM updates to animate.\n             * @prp {Boolean}\n             * @default true\n             * @category Scheduled events\n             */\n            enableEventAnimations : true,\n            disableGridRowModelWarning : true,\n            // does not look good with locked columns and also interferes with event animations\n            animateRemovingRows : false,\n            schedulerRegion : 'normal',\n            transitionDuration : 200,\n            // internal timer id reference\n            animationTimeout   : null,\n            /**\n             * Region to which columns are added when they have none specified\n             * @config {String}\n             * @default\n             * @category Misc\n             */\n            defaultRegion : 'locked',\n            /**\n             * Decimal precision used when displaying durations, used by tooltips and DurationColumn.\n             * Specify `false` to use raw value\n             * @config {Number|Boolean}\n             * @default\n             * @category Common\n             */\n            durationDisplayPrecision : 1,\n            asyncEventSuffix : 'PreCommit'\n        };\n    }\n    timeCellSelector = null;\n    updateTimeZone(timeZone) {\n        if (this.project) {\n            if (this.isConfiguring) {\n                this.project._isConfiguringTimeZone = true;\n            }\n            this.project.timeZone = timeZone;\n        }\n    }\n    get timeZone() {\n        return this.project?.timeZone;\n    }\n    //endregion\n    //region Feature hooks\n    /**\n     * Populates the event context menu. Chained in features to add menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown.\n     * @param {Scheduler.model.EventModel} options.eventRecord The context event.\n     * @param {Scheduler.model.ResourceModel} options.resourceRecord The context resource.\n     * @param {Scheduler.model.AssignmentModel} options.assignmentRecord The context assignment if any.\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items.\n     * @internal\n     */\n    populateEventMenu() {}\n    /**\n     * Populates the time axis context menu. Chained in features to add menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown.\n     * @param {Scheduler.model.ResourceModel} options.resourceRecord The context resource.\n     * @param {Date} options.date The Date corresponding to the mouse position in the time axis.\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items.\n     * @internal\n     */\n    populateScheduleMenu() {}\n    // Called when visible date range potentially changes such as when scrolling in\n    // the time axis.\n    internalOnVisibleDateRangeChange(range) {\n        if (!this.handlingVisibleDateRangeChange) {\n            const\n                me                    = this,\n                { _visibleDateRange } = me,\n                dateRangeChange       = !_visibleDateRange || (_visibleDateRange.startDate - range.startDate || _visibleDateRange.endDate - range.endDate);\n            if (dateRangeChange) {\n                me.timeView.range                 = range;\n                me.handlingVisibleDateRangeChange = true;\n                /**\n                 * Fired when the range of dates visible within the viewport changes. This will be when\n                 * scrolling along a time axis.\n                 *\n                 * __Note__ that this event will fire frequently during scrolling, so any listener\n                 * should probably be added with the `buffer` option to slow down the calls to your\n                 * handler function :\n                 *\n                 * ```javascript\n                 * listeners : {\n                 *     visibleDateRangeChange({ old, new }) {\n                 *         this.updateRangeRequired(old, new);\n                 *     },\n                 *     // Only call once. 300 ms after the last event was detected\n                 *     buffer : 300\n                 * }\n                 * ```\n                 * @event visibleDateRangeChange\n                 * @param {Scheduler.view.Scheduler} source This Scheduler instance.\n                 * @param {Object} old The old date range\n                 * @param {Date} old.startDate the old start date.\n                 * @param {Date} old.endDate the old end date.\n                 * @param {Object} new The new date range\n                 * @param {Date} new.startDate the new start date.\n                 * @param {Date} new.endDate the new end date.\n                 */\n                me.trigger('visibleDateRangeChange', {\n                    old : _visibleDateRange,\n                    new : range\n                });\n                me.handlingVisibleDateRangeChange = false;\n                me._visibleDateRange              = range;\n            }\n        }\n    }\n    // Called when visible resource range changes in vertical mode\n    onVisibleResourceRangeChange() {}\n    //endregion\n    //region Init\n    construct(config = {}) {\n        const me = this;\n        super.construct(config);\n        me.$firstVerticalOverflow = true;\n        me.initDomEvents();\n        me.currentOrientation.init();\n        me.rowManager.ion({\n            refresh : () => {\n                me.forceLayout = false;\n            }\n        });\n    }\n    // Override from Grid.view.GridSubGrids\n    createSubGrid(region, config = {}) {\n        const\n            me                = this,\n            { stickyHeaders } = me;\n        // We are creating the TimeAxisSubGrid\n        if (region === (me.schedulerRegion || 'normal')) {\n            config.type = 'timeaxissubgrid';\n        }\n        // The assumption is that if we are in vertical mode, the locked SubGrid\n        // is used to house the verticalTimeAxis, and so it must all be overflow:visible\n        else if (region === 'locked' && stickyHeaders && me.isVertical) {\n            config.scrollable = {\n                overflowX : 'visible',\n                overflowY : 'visible'\n            };\n            // It's the child of the overflowElement\n            me.bodyContainer.classList.add('b-sticky-headers');\n        }\n        return super.createSubGrid(region, config);\n    }\n    doDestroy() {\n        const\n            me                                    = this,\n            { partneredWith, currentOrientation } = me;\n        currentOrientation?.destroy();\n        // Break links between this TimeLine and any partners.\n        if (partneredWith) {\n            partneredWith.forEach(p => {\n                me.removePartner(p);\n            });\n            partneredWith.destroy();\n        }\n        else {\n            me.timeAxisViewModel.destroy();\n            me.timeAxis.destroy();\n        }\n        super.doDestroy();\n    }\n    startConfigure(config) {\n        super.startConfigure(config);\n        // When the body height changes, we must update the SchedulerViewport's height\n        ResizeMonitor.addResizeListener(this.bodyContainer, this.onBodyResize.bind(this));\n        // partner needs to be initialized first so that the various shared\n        // configs are assigned first before we default them in.\n        this.getConfig('partner');\n    }\n    changeStartDate(startDate) {\n        if (typeof startDate === 'string') {\n            startDate = DateHelper.parse(startDate);\n        }\n        return startDate;\n    }\n    onInternalPaint({ firstPaint }) {\n        // Upon first paint we need to pass the forceUpdate flag in case we are sharing the TimAxisViewModel\n        // with another Timeline which will already have done this.\n        if (firstPaint) {\n            // Take height from container element\n            const\n                me             = this,\n                scrollable     = me.isHorizontal ? me.timeAxisSubGrid.scrollable : me.scrollable,\n                // Use exact subpixel available space so that tick size calculation is correct.\n                availableSpace = scrollable.element.getBoundingClientRect()[me.isHorizontal ? 'width' : 'height'];\n            // silent = true if infiniteScroll. If that is set, TimelineScroll.initScroll which is\n            // called by the base class's onInternalPaint reconfigures the TAVM when it initializes.\n            me.timeAxisViewModel.update(availableSpace, me.infiniteScroll, true);\n            // If infiniteScroll caused the TAVM update to be silent, force the rendering to\n            // get hold of the scroll state and visible range\n            if (me.infiniteScroll) {\n                me.currentOrientation.doUpdateTimeView?.();\n            }\n            // Lazy config needs to be ingested only when the TimeAxisSubGrid exists\n            me.getConfig('hideRowHover');\n        }\n        super.onInternalPaint(...arguments);\n    }\n    onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX, scrollingToCenter) {\n        // rerender cells in scheduler column on horizontal scroll to display events in view\n        this.currentOrientation.updateFromHorizontalScroll(scrollX);\n        super.onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX, scrollingToCenter);\n    }\n    /**\n     * Overrides initScroll from Grid, listens for horizontal scroll to do virtual event rendering\n     * @private\n     */\n    initScroll() {\n        const me = this;\n        let frameCount = 0;\n        super.initScroll();\n        me.ion({\n            horizontalScroll : ({ subGrid, scrollLeft, scrollX, scrollingToCenter }) => {\n                if (me.isPainted && subGrid === me.timeAxisSubGrid && !me.isDestroying && !me.refreshSuspended) {\n                    me.onSchedulerHorizontalScroll(subGrid, scrollLeft, scrollX, scrollingToCenter);\n                }\n                frameCount++;\n            }\n        });\n        if (me.testPerformance === 'horizontal') {\n            me.setTimeout(() => {\n                const start     = performance.now();\n                let scrollSpeed = 5,\n                    direction   = 1;\n                const scrollInterval = me.setInterval(() => {\n                    scrollSpeed = scrollSpeed + 5;\n                    me.scrollX += (10 + Math.floor(scrollSpeed)) * direction;\n                    if (direction === 1 && me.scrollX > 5500) {\n                        direction   = -1;\n                        scrollSpeed = 5;\n                    }\n                    if (direction === -1 && me.scrollX <= 0) {\n                        const\n                            done    = performance.now(), // eslint-disable-line no-undef\n                            elapsed = done - start;\n                        const\n                            timePerFrame = elapsed / frameCount,\n                            fps          = Math.round((1000 / timePerFrame) * 10) / 10;\n                        clearInterval(scrollInterval);\n                        console.log(me.eventPositionMode, me.eventScrollMode, fps + 'fps');\n                    }\n                }, 0);\n            }, 500);\n        }\n    }\n    //endregion\n    /**\n     * Calls the specified function (returning its return value) and preserves the timeline center\n     * point. This is a useful way of retaining the user's visual context while making updates\n     * and changes to the view which require major changes or a full refresh.\n     * @param {Function} fn The function to call.\n     * @param {Object} thisObj The `this` context for the function.\n     * @param {...*} args Parameters to the function.\n     */\n    preserveViewCenter(fn, thisObj = this, ...args) {\n        const\n            me             = this,\n            centerDate     = me.viewportCenterDate,\n            result         = fn.apply(thisObj, args),\n            scroller       = me.timelineScroller,\n            { clientSize } = scroller,\n            scrollStart    = Math.max(Math.floor(me.getCoordinateFromDate(centerDate, true) - clientSize / 2), 0);\n        scroller.scrollTo(scrollStart, { scrollingToCenter : true });\n        return result;\n    }\n    /**\n     * Changes this Scheduler's time axis timespan to the supplied start and end dates.\n     *\n     * @async\n     * @param {Date} newStartDate The new start date\n     * @param {Date} newEndDate The new end date\n     * @param {Object} [options] An object containing modifiers for the time span change operation.\n     * @param {Boolean} [options.maintainVisibleStart] Specify as `true` to keep the visible start date stable.\n     * @param {Date} [options.visibleDate] The date inside the range to scroll into view\n     */\n    setTimeSpan(newStartDate, newEndDate, options = emptyObject) {\n        const\n            me           = this,\n            { timeAxis } = me,\n            {\n                preventThrow = false, // Private, only used by the shift method.\n                maintainVisibleStart = false,\n                visibleDate\n            }            = options,\n            {\n                startDate,\n                endDate\n            }            = timeAxis.getAdjustedDates(newStartDate, newEndDate),\n            startChanged = timeAxis.startDate - startDate !== 0,\n            endChanged   = timeAxis.endDate - endDate !== 0;\n        if (startChanged || endChanged) {\n            if (maintainVisibleStart) {\n                const\n                    {\n                        timeAxisViewModel\n                    }             = me,\n                    { totalSize } = timeAxisViewModel,\n                    oldTickSize   = timeAxisViewModel.tickSize,\n                    scrollable    = me.timelineScroller,\n                    currentScroll = scrollable.position,\n                    visibleStart  = timeAxisViewModel.getDateFromPosition(currentScroll);\n                // If the current visibleStart is in the new range, maintain it\n                // So that there is no visual jump.\n                if (visibleStart >= startDate && visibleStart < endDate) {\n                    // We need to correct the scroll position as soon as the TimeAxisViewModel\n                    // has updated itself and before any other UI updates which that may trigger.\n                    timeAxisViewModel.ion({\n                        update() {\n                            const tickSizeChanged = timeAxisViewModel.tickSize !== oldTickSize;\n                            // Ensure the canvas element matches the TimeAxisViewModel's new totalSize.\n                            // This creates the required scroll range to be able to have the scroll\n                            // position correct before any further UI updates.\n                            me.updateCanvasSize();\n                            // If *only* the start moved, we can keep scroll position the same\n                            // by adjusting it by the amount the start moved.\n                            if (startChanged && !endChanged && !tickSizeChanged) {\n                                scrollable.position += (timeAxisViewModel.totalSize - totalSize);\n                            }\n                            // If only the end has changed, and tick size is same, we can maintain\n                            // the same scroll position.\n                            else if (!startChanged && !tickSizeChanged) {\n                                scrollable.position = currentScroll;\n                            }\n                            // Fall back to restoring the position by restoring the visible start time\n                            else {\n                                scrollable.position = timeAxisViewModel.getPositionFromDate(visibleStart);\n                            }\n                            // Force partners to sync with what we've just done to reset the scroll.\n                            // We are now in control.\n                            scrollable.syncPartners(true);\n                        },\n                        prio : 10000,\n                        once : true\n                    });\n                }\n            }\n            const returnValue = timeAxis.reconfigure({\n                startDate,\n                endDate\n            }, false, preventThrow);\n            if (visibleDate) {\n                return me.scrollToDate(visibleDate, options).then(() => returnValue);\n            }\n            return returnValue;\n        }\n    }\n    //region Config getters/setters\n    /**\n     * Returns `true` if any of the events/tasks or feature injected elements (such as ResourceTimeRanges) are within\n     * the {@link #config-timeAxis}\n     * @property {Boolean}\n     * @readonly\n     * @category Scheduled events\n     */\n    get hasVisibleEvents() {\n        return !this.noFeatureElementsInAxis() || this.eventStore.storage.values.some(t => this.timeAxis.isTimeSpanInAxis(t));\n    }\n    // Template function to be chained in features to determine if any elements are in time axis (needed since we cannot\n    // currently chain getters). Negated to not break chain. First feature that has elements visible returns false,\n    // which prevents other features from being queried.\n    noFeatureElementsInAxis() { }\n    // Private getter used to piece together event names such as beforeEventDrag / beforeTaskDrag. Could also be used\n    // in templates.\n    get capitalizedEventName() {\n        if (!this._capitalizedEventName) {\n            this._capitalizedEventName = StringHelper.capitalize(this.scheduledEventName);\n        }\n        return this._capitalizedEventName;\n    }\n    updatePartner(partner) {\n        if (partner) {\n            this.addPartner(partner);\n        }\n    }\n    /**\n     * Partners this Timeline with the passed Timeline in order to sync the horizontal scrolling position and zoom level.\n     *\n     * - To remove existing partner see {@link #function-removePartner} method.\n     * - To get the list of partners see {@link #property-partners} getter.\n     *\n     * The following properties are imported into this component from the added partner and shared:\n     *\n     * - {@link #property-timeAxisViewModel}\n     * - {@link #property-timeAxis}\n     * - {@link #property-viewPreset}\n     *\n     * In a set of partnered Timelines, there will only be a single instance of the above properties.\n     * The time range and scroll position in that time range are always the same among all\n     * partnered timelines.\n     *\n     * @param {Scheduler.view.TimelineBase} otherTimeline The timeline to partner with\n     */\n    addPartner(partner) {\n        const me = this;\n        if (!me.isPartneredWith(partner)) {\n            if (me._partner == null) {\n                me._partner = partner;\n            }\n            const partneredWith = me.partneredWith || (me.partneredWith = new Collection());\n            // Each must know about the other so that they can sync others upon region resize\n            partneredWith.add(partner);\n            (partner.partneredWith || (partner.partneredWith = new Collection())).add(me);\n            // Flush through viewPreset initGetter so that the setup in setConfig doesn't\n            // take them to be the class's defined getters.\n            me.getConfig('viewPreset');\n            me.getConfig('infiniteScroll');\n            partner.ion({\n                presetchange : 'onPartnerPresetChange',\n                thisObj      : me\n            });\n            partner.scrollable.ion({\n                overflowChange : 'onPartnerOverflowChange',\n                thisObj        : me\n            });\n            // collect configs that are meant to be shared between partners\n            const partnerSharedConfig = me.partnerSharedConfigs.reduce((config, configName) => {\n                config[configName] = partner[configName];\n                return config;\n            }, {});\n            // We have to use the same tick size as the partner,\n            // and we have to sync to its scroll position\n            partnerSharedConfig.viewPreset.options = {\n                scrollPosition : partner.timelineScroller.position,\n                tickSize       : partner.tickSize\n            };\n            me.setConfig(partnerSharedConfig);\n            me.ion({\n                presetchange : 'onPartnerPresetChange',\n                thisObj      : partner\n            });\n            me.scrollable.ion({\n                overflowChange : 'onPartnerOverflowChange',\n                thisObj        : partner\n            });\n            if (me.isPainted) {\n                partner.scrollable.addPartner(me.scrollable, me.isHorizontal ? 'x' : 'y');\n                partner.syncPartnerSubGrids();\n            }\n            else {\n                // When initScroll comes round, make sure it syncs with the partner\n                me.initScroll = FunctionHelper.createSequence(me.initScroll, () => {\n                    partner.scrollable.addPartner(me.scrollable, me.isHorizontal ? 'x' : 'y');\n                    partner.syncPartnerSubGrids();\n                }, me);\n            }\n        }\n    }\n    /**\n     * Breaks the link between current Timeline and the passed Timeline\n     *\n     * - To add a new partner see {@link #function-addPartner} method.\n     * - To get the list of partners see {@link #property-partners} getter.\n     *\n     * @param {Scheduler.view.TimelineBase} otherTimeline The timeline to unlink from\n     */\n    removePartner(partner) {\n        const\n            me                = this,\n            { partneredWith } = me;\n        if (me.isPartneredWith(partner)) {\n            if (me._partner === partner) {\n                me._partner = null;\n            }\n            partneredWith.remove(partner);\n            me.scrollable.removePartner(partner.scrollable);\n            me.un({\n                presetchange : 'onPartnerPresetChange',\n                thisObj      : partner\n            });\n            me.scrollable.un({\n                overflowChange : 'onPartnerOverflowChange',\n                thisObj        : partner\n            });\n            partner.removePartner(me);\n        }\n    }\n    /**\n     * Checks whether the passed timeline is partnered with the current timeline.\n     * @param {Scheduler.view.TimelineBase} partner The timeline to check the partnering with\n     * @returns {Boolean} Returns `true` if the timelines are partnered\n     */\n    isPartneredWith(partner) {\n        return Boolean(this.partneredWith?.includes(partner));\n    }\n    /**\n     * Called when a partner scheduler changes its overflowing state. The scrollable\n     * of a Grid/Scheduler only handles overflowY, so this will mean the addition\n     * or removal of a vertical scrollbar.\n     *\n     * All partners must stay in sync. If another parter has a vertical scrollbar\n     * and we do not, we must set our overflowY to 'scroll' so that we show an empty\n     * scrollbar to keep widths synchronized.\n     * @param {Object} event A {@link Core.helper.util.Scroller#event-overflowChange} event\n     * @internal\n     */\n    onPartnerOverflowChange({ source : otherScrollable, y }) {\n        const\n            { scrollable } = this,\n            ourY           = scrollable.hasOverflow('y') || scrollable.overflowY === 'scroll';\n        // If we disagree with our partner, the partner which doesn't have\n        // overflow, has to become overflowY : scroll\n        if (ourY !== y) {\n            // If we had forced scroller to be shown, we can return it to auto\n            if (scrollable.overflowY === 'scroll') {\n                scrollable.overflowY = true;\n                this.refreshVirtualScrollbars();\n            }\n            else if (ourY) {\n                otherScrollable.overflowY = 'scroll';\n            }\n            else {\n                otherScrollable.overflowY = true;\n                scrollable.overflowY      = 'scroll';\n                this.refreshVirtualScrollbars();\n            }\n        }\n        // If we agree with our partner, we can reset ourselves to overflowY : auto\n        else {\n            scrollable.overflowY = true;\n        }\n    }\n    onPartnerPresetChange({ preset, startDate, endDate, centerDate, zoomDate, zoomPosition, zoomLevel }) {\n        if (!this._viewPresetChanging && this.viewPreset !== preset) {\n            // Passed through to the viewPreset changing method\n            preset.options  = {\n                startDate,\n                endDate,\n                centerDate,\n                zoomDate,\n                zoomPosition,\n                zoomLevel\n            };\n            this.viewPreset = preset;\n        }\n    }\n    /**\n     * Returns the partnered timelines.\n     *\n     * - To add a new partner see {@link #function-addPartner} method.\n     * - To remove existing partner see {@link #function-removePartner} method.\n     *\n     * @readonly\n     * @member {Scheduler.view.TimelineBase[]} partners\n     * @category Time axis\n     */\n    get partners() {\n        const partners = this.partner ? [this.partner] : [];\n        if (this.partneredWith) {\n            partners.push.apply(partners, this.partneredWith.allValues);\n        }\n        return [...new Set(partners)];\n    }\n    get timeAxisColumn() {\n        return this.columns && this._timeAxisColumn;\n    }\n    changeColumns(columns, currentStore) {\n        const me = this;\n        let timeAxisColumnIndex, timeAxisColumnConfig;\n        // No columns means destroy\n        if (columns) {\n            const isArray = Array.isArray(columns);\n            let cols = columns;\n            if (!isArray) {\n                cols = columns.data;\n            }\n            timeAxisColumnIndex = cols && cols.length;\n            cols.some((col, index) => {\n                if (col.type === 'timeAxis') {\n                    timeAxisColumnIndex  = index;\n                    timeAxisColumnConfig = ObjectHelper.assign(col, me.timeAxisColumn);\n                    return true;\n                }\n                return false;\n            });\n            if (me.isVertical) {\n                cols = [\n                    ObjectHelper.assign({\n                        type : 'verticalTimeAxis'\n                    }, me.verticalTimeAxisColumn),\n                    // Make space for a regular TimeAxisColumn after the VerticalTimeAxisColumn\n                    cols[timeAxisColumnIndex]\n                ];\n                timeAxisColumnIndex = 1;\n            }\n            else {\n                // We're going to mutate this array which we do not own, so copy it first.\n                cols = cols.slice();\n            }\n            // Fix up the timeAxisColumn config in place\n            cols[timeAxisColumnIndex] = this._timeAxisColumn || {\n                type    : 'timeAxis',\n                cellCls : me.timeCellCls,\n                mode    : me.mode,\n                ...timeAxisColumnConfig\n            };\n            // If we are passed a raw array, or the Store we are passed is owned by another\n            // Scheduler, pass the raw column data ro the Grid's changeColumns\n            if (isArray || (columns.isStore && columns.owner !== this)) {\n                columns = cols;\n            }\n            else {\n                columns.data = cols;\n            }\n        }\n        return super.changeColumns(columns, currentStore);\n    }\n    updateColumns(columns, was) {\n        super.updateColumns(columns, was);\n        // Extract the known columns by type. Sorting will have placed them into visual order.\n        if (columns) {\n            const\n                me             = this,\n                timeAxisColumn = me._timeAxisColumn = me.columns.find(c => c.isTimeAxisColumn);\n            if (me.isVertical) {\n                me.verticalTimeAxisColumn = me.columns.find(c => c.isVerticalTimeAxisColumn);\n                me.verticalTimeAxisColumn.relayAll(me);\n            }\n            // Set up event relaying early\n            timeAxisColumn.relayAll(me);\n        }\n    }\n    onColumnsChanged({ action, changes, record : column, records }) {\n        const { timeAxisColumn, columns } = this;\n        // If someone replaces the column set (syncing leads to batch), ensure time axis is always added\n        if ((action === 'dataset' || action === 'batch') && !columns.includes(timeAxisColumn)) {\n            columns.add(timeAxisColumn, true);\n        }\n        else if (column === timeAxisColumn && 'width' in changes) {\n            this.updateCanvasSize();\n        }\n        column && this.partneredWith?.forEach(partner => {\n            const partnerColumn = partner.columns.getAt(column.allIndex);\n            if (partnerColumn?.shouldSync(column)) {\n                const partnerChanges = {};\n                for (const k in changes) {\n                    partnerChanges[k] = changes[k].value;\n                }\n                partnerColumn.set(partnerChanges);\n            }\n        });\n        super.onColumnsChanged(...arguments);\n    }\n    get timeView() {\n        const me = this;\n        // Maintainer, we need to ensure that the columns property is initialized\n        // if this getter is called at configuration time before columns have been ingested.\n        return me.columns && me.isVertical\n            ? me.verticalTimeAxisColumn?.view\n            : me.timeAxisColumn?.timeAxisView;\n    }\n    updateEventCls(eventCls) {\n        const me = this;\n        if (!me.eventSelector) {\n            // No difference with new rendering, released have 'b-released' only\n            me.unreleasedEventSelector = me.eventSelector = `.${eventCls}-wrap`;\n        }\n        if (!me.eventInnerSelector) {\n            me.eventInnerSelector = `.${eventCls}`;\n        }\n    }\n    set timeAxisViewModel(timeAxisViewModel) {\n        const\n            me            = this,\n            currentModel  = me._timeAxisViewModel,\n            tavmListeners = {\n                name    : 'timeAxisViewModel',\n                update  : 'onTimeAxisViewModelUpdate',\n                prio    : 100,\n                thisObj : me\n            };\n        if ((me.partner && !timeAxisViewModel) || (currentModel && currentModel === timeAxisViewModel)) {\n            return;\n        }\n        if (currentModel?.owner === me) {\n            // We created this model, destroy it\n            currentModel.destroy();\n        }\n        me.detachListeners('timeAxisViewModel');\n        // Getting rid of instanceof check to allow using code from different bundles\n        if (timeAxisViewModel?.isTimeAxisViewModel) {\n            timeAxisViewModel.ion(tavmListeners);\n        }\n        else {\n            timeAxisViewModel = TimeAxisViewModel.new({\n                mode              : me._mode,\n                snap              : me.snap,\n                forceFit          : me.forceFit,\n                timeAxis          : me.timeAxis,\n                suppressFit       : me.suppressFit,\n                internalListeners : tavmListeners,\n                owner             : me\n            }, timeAxisViewModel);\n        }\n        // Replace in dependent classes relying on the model\n        if (!me.isConfiguring) {\n            if (me.isHorizontal) {\n                me.timeAxisColumn.timeAxisViewModel = timeAxisViewModel;\n            }\n            else {\n                me.verticalTimeAxisColumn.view.model = timeAxisViewModel;\n            }\n        }\n        me._timeAxisViewModel = timeAxisViewModel;\n        me.relayEvents(timeAxisViewModel, ['update'], 'timeAxisViewModel');\n        if (currentModel && timeAxisViewModel) {\n            me.trigger('timeAxisViewModelChange', { timeAxisViewModel });\n        }\n    }\n    /**\n     * The internal view model, describing the visual representation of the time axis.\n     * @property {Scheduler.view.model.TimeAxisViewModel}\n     * @readonly\n     * @category Time axis\n     */\n    get timeAxisViewModel() {\n        if (!this._timeAxisViewModel) {\n            this.timeAxisViewModel = null;\n        }\n        return this._timeAxisViewModel;\n    }\n    get suppressFit() {\n        return this._timeAxisViewModel?.suppressFit ?? this._suppressFit;\n    }\n    set suppressFit(value) {\n        if (this._timeAxisViewModel) {\n            this.timeAxisViewModel.suppressFit = value;\n        }\n        else {\n            this._suppressFit = value;\n        }\n    }\n    set timeAxis(timeAxis) {\n        const\n            me                = this,\n            currentTimeAxis   = me._timeAxis,\n            timeAxisListeners = {\n                name        : 'timeAxis',\n                reconfigure : 'onTimeAxisReconfigure',\n                thisObj     : me\n            };\n        if (me.partner && !timeAxis || (currentTimeAxis && currentTimeAxis === timeAxis)) {\n            return;\n        }\n        if (currentTimeAxis) {\n            if (currentTimeAxis.owner === me) {\n                // We created this model, destroy it\n                currentTimeAxis.destroy();\n            }\n        }\n        me.detachListeners('timeAxis');\n        // Getting rid of instanceof check to allow using code from different bundles\n        if (!timeAxis?.isTimeAxis) {\n            timeAxis = ObjectHelper.assign({\n                owner          : me,\n                viewPreset     : me.viewPreset,\n                autoAdjust     : me.autoAdjustTimeAxis,\n                weekStartDay   : me.weekStartDay,\n                forceFullTicks : me.fillTicks && me.snap\n            }, timeAxis);\n            if (me.startDate) {\n                timeAxis.startDate = me.startDate;\n            }\n            if (me.endDate) {\n                timeAxis.endDate = me.endDate;\n            }\n            if (me.workingTime) {\n                me.applyWorkingTime(timeAxis);\n            }\n            timeAxis = new TimeAxis(timeAxis);\n        }\n        // Inform about reconfiguring the timeaxis, to allow users to react to start & end date changes\n        timeAxis.ion(timeAxisListeners);\n        me._timeAxis = timeAxis;\n    }\n    onTimeAxisReconfigure({ config, oldConfig }) {\n        if (config) {\n            const dateRangeChange = !oldConfig || (oldConfig.startDate - config.startDate || oldConfig.endDate - config.endDate);\n            if (dateRangeChange) {\n                /**\n                 * Fired when the range of dates encapsulated by the UI changes. This will be when\n                 * moving a view in time by reconfiguring its {@link #config-timeAxis}. This will happen\n                 * when zooming, or changing {@link #config-viewPreset}.\n                 *\n                 * Contrast this with the {@link #event-visibleDateRangeChange} event which fires much\n                 * more frequently, during scrolling along the time axis and changing the __visible__\n                 * date range.\n                 * @event dateRangeChange\n                 * @param {Scheduler.view.TimelineBase} source This Scheduler/Gantt instance.\n                 * @param {Object} old The old date range\n                 * @param {Date} old.startDate the old start date.\n                 * @param {Date} old.endDate the old end date.\n                 * @param {Object} new The new date range\n                 * @param {Date} new.startDate the new start date.\n                 * @param {Date} new.endDate the new end date.\n                 */\n                this.trigger('dateRangeChange', {\n                    old : {\n                        startDate : oldConfig.startDate,\n                        endDate   : oldConfig.endDate\n                    },\n                    new : {\n                        startDate : config.startDate,\n                        endDate   : config.endDate\n                    }\n                });\n            }\n        }\n        /**\n         * Fired when the timeaxis has changed, for example by zooming or configuring a new time span.\n         * @event timeAxisChange\n         * @param {Scheduler.view.Scheduler} source - This Scheduler\n         * @param {Object} config Config object used to reconfigure the time axis.\n         * @param {Date} config.startDate New start date (if supplied)\n         * @param {Date} config.endDate New end date (if supplied)\n         */\n        this.trigger('timeAxisChange', { config });\n    }\n    get timeAxis() {\n        if (!this._timeAxis) {\n            this.timeAxis = null;\n        }\n        return this._timeAxis;\n    }\n    updateForceFit(value) {\n        if (this._timeAxisViewModel) {\n            this._timeAxisViewModel.forceFit = value;\n        }\n    }\n    /**\n     * Get/set working time. Assign `null` to stop using working time. See {@link #config-workingTime} config for details.\n     * @property {Object}\n     * @category Scheduled events\n     */\n    set workingTime(config) {\n        this._workingTime = config;\n        if (!this.isConfiguring) {\n            this.applyWorkingTime(this.timeAxis);\n        }\n    }\n    get workingTime() {\n        return this._workingTime;\n    }\n    // Translates the workingTime configs into TimeAxis#include rules, applies them and then refreshes the header and\n    // redraws the events\n    applyWorkingTime(timeAxis) {\n        const me     = this,\n            config = me._workingTime;\n        if (config) {\n            let hour = null;\n            // Only use valid values\n            if (config.fromHour >= 0 && config.fromHour < 24 && config.toHour > config.fromHour && config.toHour <= 24 && config.toHour - config.fromHour < 24) {\n                hour = { from : config.fromHour, to : config.toHour };\n            }\n            let day = null;\n            // Only use valid values\n            if (config.fromDay >= 0 && config.fromDay < 7 && config.toDay > config.fromDay && config.toDay <= 7 && config.toDay - config.fromDay < 7) {\n                day = { from : config.fromDay, to : config.toDay };\n            }\n            if (hour || day) {\n                timeAxis.include = {\n                    hour,\n                    day\n                };\n            }\n            else {\n                // No valid rules, restore timeAxis\n                timeAxis.include = null;\n            }\n        }\n        else {\n            // No rules, restore timeAxis\n            timeAxis.include = null;\n        }\n        if (me.isPainted) {\n            // Refreshing header, which also recalculate tickSize and header data\n            me.timeAxisColumn.refreshHeader();\n            // Update column lines\n            me.features.columnLines?.refresh();\n            // Animate event changes\n            me.refreshWithTransition();\n        }\n    }\n    updateStartDate(date) {\n        this.setStartDate(date);\n    }\n    /**\n     * Sets the timeline start date.\n     *\n     * **Note:**\n     * - If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n     * - If keepDuration is false and new start date is greater than end date, it will throw an exception.\n     *\n     * @param {Date} date The new start date\n     * @param {Boolean} keepDuration Pass `true` to keep the duration of the timeline (\"move\" the timeline),\n     * `false` to change the duration (\"resize\" the timeline). Defaults to `true`.\n     */\n    setStartDate(date, keepDuration = true) {\n        const\n            me = this,\n            ta = me._timeAxis,\n            {\n                startDate,\n                endDate,\n                mainUnit\n            }  = ta || emptyObject;\n        if (typeof date === 'string') {\n            date = DateHelper.parse(date);\n        }\n        if (ta && endDate) {\n            if (date) {\n                let calcEndDate = endDate;\n                if (keepDuration && startDate) {\n                    const diff  = DateHelper.diff(startDate, endDate, mainUnit, true);\n                    calcEndDate = DateHelper.add(date, diff, mainUnit);\n                }\n                me.setTimeSpan(date, calcEndDate);\n            }\n        }\n        else {\n            me._tempStartDate = date;\n        }\n    }\n    get startDate() {\n        let ret = this._timeAxis?.startDate || this._tempStartDate;\n        if (!ret) {\n            ret = new Date();\n            const { workingTime } = this;\n            if (workingTime) {\n                while (!isWorkingTime(ret, workingTime)) {\n                    ret.setHours(ret.getHours() + 1);\n                }\n            }\n            this._tempStartDate = ret;\n        }\n        return ret;\n    }\n    changeEndDate(date) {\n        if (typeof date === 'string') {\n            date = DateHelper.parse(date);\n        }\n        this.setEndDate(date);\n    }\n    /**\n     * Sets the timeline end date\n     *\n     * **Note:**\n     * - If you need to set start and end date at the same time, use the {@link #function-setTimeSpan} method.\n     * - If keepDuration is false and new end date is less than start date, it will throw an exception.\n     *\n     * @param {Date} date The new end date\n     * @param {Boolean} keepDuration Pass `true` to keep the duration of the timeline (\"move\" the timeline),\n     * `false` to change the duration (\"resize\" the timeline). Defaults to `false`.\n     */\n    setEndDate(date, keepDuration = false) {\n        const\n            me = this,\n            ta = me._timeAxis,\n            {\n                startDate,\n                endDate,\n                mainUnit\n            }  = ta || emptyObject;\n        if (typeof date === 'string') {\n            date = DateHelper.parse(date);\n        }\n        if (ta && startDate) {\n            if (date) {\n                let calcStartDate = startDate;\n                if (keepDuration && endDate) {\n                    const diff    = DateHelper.diff(startDate, endDate, mainUnit, true);\n                    calcStartDate = DateHelper.add(date, -diff, mainUnit);\n                }\n                me.setTimeSpan(calcStartDate, date);\n            }\n        }\n        else {\n            me._tempEndDate = date;\n        }\n    }\n    get endDate() {\n        const me = this;\n        if (me._timeAxis) {\n            return me._timeAxis.endDate;\n        }\n        return me._tempEndDate || DateHelper.add(me.startDate, me.viewPreset.defaultSpan, me.viewPreset.mainHeader.unit);\n    }\n    changeVisibleDate(options) {\n        if (options instanceof Date) {\n            return { date : options, block : this.isConfiguring ? 'start' : 'nearest' };\n        }\n        if (options instanceof Object) {\n            return {\n                date  : options.date,\n                block : options.block || this.isConfiguring ? 'start' : 'nearest',\n                ...options\n            };\n        }\n    }\n    updateVisibleDate(options) {\n        const me = this;\n        // Infinite scroll initialization takes care of its visibleDate after\n        // calculating the optimum scroll range in TimelineScroll#initScroll\n        if (!(me.infiniteScroll && me.isConfiguring)) {\n            if (me.isPainted) {\n                me.scrollToDate(options.date, options);\n            }\n            else {\n                me.ion({\n                    paint : () => me.scrollToDate(options.date, options),\n                    once  : true\n                });\n            }\n        }\n    }\n    get features() {\n        return super.features;\n    }\n    // add region resize by default\n    set features(features) {\n        features = features === true ? {} : features;\n        if (!('regionResize' in features)) {\n            features.regionResize = true;\n        }\n        super.features = features;\n    }\n    //endregion\n    //region Event handlers\n    onLocaleChange() {\n        super.onLocaleChange();\n        const oldAutoAdjust = this.timeAxis.autoAdjust;\n        // Time axis should rebuild as weekStartDay may have changed\n        this.timeAxis.reconfigure({\n            autoAdjust : false\n        });\n        // Silently set it back to what the user had for next view refresh\n        this.timeAxis.autoAdjust = oldAutoAdjust;\n    }\n    /**\n     * Called when the element which encapsulates the Scheduler's visible height changes size.\n     * We only respond to *height* changes here. The TimeAxisSubGrid monitors its own width.\n     * @param {HTMLElement} element\n     * @param {DOMRect} oldRect\n     * @param {DOMRect} newRect\n     * @private\n     */\n    onBodyResize(element, oldRect, { width, height }) {\n        // Uncache old value upon element resize, not upon initial sizing\n        if (this.isVertical && oldRect && width !== oldRect.width) {\n            delete this.timeAxisSubGrid._width;\n        }\n        const newWidth = this.timeAxisSubGrid.element.offsetWidth;\n        // The Scheduler (The Grid) dictates the viewport height.\n        // Don't react on first invocation which will be initial size.\n        if (this._bodyRectangle && oldRect && (height !== oldRect.height)) {\n            this.onSchedulerViewportResize(newWidth, height, newWidth, oldRect.height);\n        }\n    }\n    onSchedulerViewportResize(width, height, oldWidth, oldHeight) {\n        if (this.isPainted) {\n            const\n                me = this,\n                {\n                    isHorizontal,\n                    partneredWith\n                }  = me;\n            me.currentOrientation.onViewportResize(width, height, oldWidth, oldHeight);\n            // Raw width is always correct for horizontal layout because the TimeAxisSubGrid\n            // never shows a scrollbar. It's always contained by an owning Grid which shows\n            // the vertical scrollbar.\n            me.updateViewModelAvailableSpace(isHorizontal ? width : Math.floor(height));\n            if (partneredWith && !me.isSyncingFromPartner) {\n                me.syncPartnerSubGrids();\n            }\n            /**\n             * Fired when the *scheduler* viewport (not the overall Scheduler element) changes size.\n             * This happens when the grid changes height, or when the subgrid which encapsulates the\n             * scheduler column changes width.\n             * @event timelineViewportResize\n             * @param {Core.widget.Widget} source - This Scheduler\n             * @param {Number} width The new width\n             * @param {Number} height The new height\n             * @param {Number} oldWidth The old width\n             * @param {Number} oldHeight The old height\n             */\n            me.trigger('timelineViewportResize', { width, height, oldWidth, oldHeight });\n        }\n    }\n    updateViewModelAvailableSpace(space) {\n        this.timeAxisViewModel.availableSpace = space;\n    }\n    onTimeAxisViewModelUpdate() {\n        if (!this._viewPresetChanging && !this.timeAxisSubGrid.collapsed) {\n            this.updateCanvasSize();\n            this.currentOrientation.onTimeAxisViewModelUpdate();\n        }\n    }\n    syncPartnerSubGrids() {\n        this.partneredWith.forEach(partner => {\n            if (!partner.isSyncingFromPartner) {\n                partner.isSyncingFromPartner = true;\n                this.eachSubGrid(subGrid => {\n                    const partnerSubGrid = partner.subGrids[subGrid.region];\n                    // If there is a difference, sync the partner SubGrid state\n                    if (partnerSubGrid.width !== subGrid.width) {\n                        if (subGrid.collapsed) {\n                            partnerSubGrid.collapse();\n                        }\n                        else {\n                            if (partnerSubGrid.collapsed) {\n                                partnerSubGrid.expand();\n                            }\n                            // When using flexed subgrid, make sure flex values has prio over width\n                            if (subGrid.flex) {\n                                // If flex values match, resize should be fine without changing anything\n                                if (subGrid.flex !== partnerSubGrid.flex) {\n                                    partnerSubGrid.flex = subGrid.flex;\n                                }\n                            }\n                            else {\n                                partnerSubGrid.width = subGrid.width;\n                            }\n                        }\n                    }\n                });\n                partner.isSyncingFromPartner = false;\n            }\n        });\n    }\n    //endregion\n    //region Mode\n    get currentOrientation() {\n        throw new Error('Implement in subclass');\n    }\n    // Horizontal is the default, overridden in scheduler\n    get isHorizontal() {\n        return true;\n    }\n    //endregion\n    //region Canvases and elements\n    get foregroundCanvas() {\n        return this._foregroundCanvas;\n    }\n    get svgCanvas() {\n        const me = this;\n        if (!me._svgCanvas) {\n            const svg = me._svgCanvas = document.createElementNS('http://www.w3.org/2000/svg', 'svg');\n            svg.setAttribute('id', IdHelper.generateId('svg'));\n            svg.classList.add('b-sch-canvas', 'b-sch-dependencies-canvas');\n            // To not be recycled by DomSync\n            svg.retainElement = true;\n            me.timeAxisSubGridElement.appendChild(svg);\n            me.trigger('svgCanvasCreated', { svg });\n        }\n        return me._svgCanvas;\n    }\n    /**\n     * Returns the subGrid containing the time axis\n     * @member {Grid.view.SubGrid} timeAxisSubGrid\n     * @readonly\n     * @category Time axis\n     */\n    /**\n     * Returns the html element for the subGrid containing the time axis\n     * @property {HTMLElement}\n     * @readonly\n     * @category Time axis\n     */\n    get timeAxisSubGridElement() {\n        // Hit a lot, caching the element (it will never change)\n        if (!this._timeAxisSubGridElement) {\n            // We need the TimeAxisSubGrid to exist, so regions must be initialized\n            this.getConfig('regions');\n            this._timeAxisSubGridElement = this.timeAxisColumn?.subGridElement;\n        }\n        return this._timeAxisSubGridElement;\n    }\n    updateCanvasSize() {\n        const me = this;\n        let result = false;\n        if (me.isVertical) {\n            const { totalSize } = me.timeAxisViewModel;\n            // Ensure vertical scroll range accommodates the TimeAxis\n            if (me.isPainted) {\n                // We used to have a bug here from not including the row border in the total height. Border is now\n                // removed, but leaving code here just in case some client is using border\n                me.refreshTotalHeight(totalSize + me._rowBorderHeight, true);\n            }\n            // Canvas might need a height in vertical mode, if ticks does not fill height (suppressFit : true)\n            if (me.suppressFit) {\n                DomHelper.setLength(me.foregroundCanvas, 'height', totalSize);\n            }\n            result = true;\n        }\n        return result;\n    }\n    /**\n     * A chainable function which Features may hook to add their own content to the timeaxis header.\n     * @param {Array} configs An array of domConfigs, append to it to have the config applied to the header\n     */\n    getHeaderDomConfigs(configs) {}\n    /**\n     * A chainable function which Features may hook to add their own content to the foreground canvas\n     * @param {Array} configs An array of domConfigs, append to it to have the config applied to the foreground canvas\n     */\n    getForegroundDomConfigs(configs) {}\n    //endregion\n    //region Grid overrides\n    async onStoreDataChange({ action }) {\n        const me = this;\n        // Only update the UI immediately if we are visible\n        if (me.isVisible) {\n            // When repopulating stores (pro and up on data reload), the engine is not in a valid state until committed.\n            // Don't want to commit here, since it might be repopulating multiple stores.\n            // Instead delay grids refresh until project is ready\n            if (action === 'dataset' && me.project?.isRepopulatingStores) {\n                await me.project.await('refresh', false);\n            }\n            super.onStoreDataChange(...arguments);\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            me.whenVisible('refresh', me, [true]);\n        }\n    }\n    refresh(forceLayout = true) {\n        const me = this;\n        if (me.isPainted && !me.refreshSuspended) {\n            // We need to refresh if there are Features laying claim to the visible time axis.\n            // Or there are events which fall inside the time axis.\n            // Or (if no events fall inside the time axis) there are event elements to remove.\n            if (me.isVertical || me.hasVisibleEvents || me.timeAxisSubGridElement.querySelector(me.eventSelector)) {\n                if (!me.project || me.isEngineReady) {\n                    me.refreshRows(false, forceLayout);\n                }\n                else {\n                    me.refreshAfterProjectRefresh             = true;\n                    me.currentOrientation.refreshAllWhenReady = true;\n                }\n            }\n            // Even if there are no events in our timeline, Features\n            // assume there will be a refresh event from the RowManager\n            // after a refresh request so fire it here.\n            else {\n                me.rowManager.trigger('refresh');\n            }\n        }\n    }\n    render() {\n        const\n            me          = this,\n            { total }   = me.resourceMarginObject,\n            schedulerEl = me.timeAxisSubGridElement;\n        // The font-size trick is no longer used by scheduler, since it allows per resource margins\n        const\n            fgCanvas = me._foregroundCanvas = DomHelper.createElement({\n                className : 'b-sch-canvas b-sch-foreground-canvas',\n                style     : `font-size:${(me.rowHeight - total)}px`,\n                parent    : schedulerEl\n            });\n        me.timeAxisSubGrid.insertRowsBefore = fgCanvas;\n        // Size correctly in case ticks does not fill height\n        if (me.isVertical && me.suppressFit) {\n            me.updateCanvasSize();\n        }\n        super.render(...arguments);\n    }\n    refreshRows(returnToTop = false, reLayoutEvents = true) {\n        const me = this;\n        if (me.isConfiguring) {\n            return;\n        }\n        me.currentOrientation.refreshRows(reLayoutEvents);\n        super.refreshRows(returnToTop);\n    }\n    updateHideHeaders(hide) {\n        const\n            me         = this,\n            scrollLeft = me.isPainted ? me.scrollLeft : 0;\n        super.updateHideHeaders(hide);\n        if (me.isPainted) {\n            if (!hide) {\n                me.timeAxisColumn.refreshHeader(null, true);\n            }\n            me.nextAnimationFrame().then(() => me.scrollLeft = scrollLeft);\n        }\n    }\n    updateHideRowHover(hideRowHover) {\n        this.timeAxisSubGridElement.classList.toggle('b-hide-row-hover', hideRowHover);\n    }\n    getCellDataFromEvent(event, includeSingleAxisMatch) {\n        if (includeSingleAxisMatch) {\n            includeSingleAxisMatch = !Boolean(event.target.closest('.b-sch-foreground-canvas'));\n        }\n        return super.getCellDataFromEvent(event, includeSingleAxisMatch);\n    }\n    // This GridSelection override disables drag-selection in timeaxis column for scheduler and gantt\n    onCellNavigate(me, from, to) {\n        const toTarget = to.target;\n        if (to.cell?.classList.contains('b-timeaxis-cell') && !GlobalEvents.currentMouseDown?.target.classList.contains('b-grid-cell')) {\n            this.preventDragSelect = true;\n        }\n        if ((!toTarget?.matches(this.eventSelector) || this.selectResourceOnEventNavigate !== false) &&\n        (!toTarget?.matches('.b-timeaxis-cell') || this.selectResourceOnScheduleClick !== false)) {\n            super.onCellNavigate(...arguments);\n        }\n    }\n    //endregion\n    //region Other\n    /**\n     * Runs a function with transitions enabled (row height, event size etc.). Useful if you want to alter the UI\n     * state with a transition.\n     *\n     * @param {Function} fn The function to run\n     */\n    runWithTransition(fn, duration = this.transitionDuration /* duration = false prevents transition */) {\n        const me = this;\n        // Do not attempt to enter animating state if we are not visible\n        if (me.isVisible && me._animationSuspendedCounter === 0) {\n            // Allow calling with true/false to keep code simpler in other places\n            if (duration == null || duration === true) {\n                duration = me.transitionDuration;\n            }\n            // Ask Grid superclass to enter the animated state if requested and enabled.\n            if (duration && me.enableEventAnimations) {\n                if (!me.hasTimeout('exitTransition')) {\n                    me.isAnimating = true;\n                }\n                // Exit animating state in duration milliseconds with a little buffer to not interrupt.\n                exitTransition.delay = duration + 50;\n                me.setTimeout(exitTransition);\n            }\n        }\n        fn();\n    }\n    _animationSuspendedCounter = 0;\n    /**\n     * Suspends CSS transitions after a row / event has been updated\n     *\n     * Multiple calls to `suspendAnimations` stack up, and will require an equal number of `resumeAnimations` calls to\n     * actually resume animations.\n     */\n    suspendAnimations() {\n        this._animationSuspendedCounter++;\n    }\n    /**\n     * Resumes CSS transitions after a row / event has been updated\n     */\n    resumeAnimations() {\n        this._animationSuspendedCounter--;\n    }\n    exitTransition() {\n        this.isAnimating = false;\n        this.trigger('transitionend');\n    }\n    // Awaited by CellEdit to make sure that the editor is not moved until row heights have transitioned, to avoid it\n    // ending up misaligned\n    async waitForAnimations() {\n        // If project is calculating, we should await that too. It might lead to transitions\n        if (!this.isEngineReady && this.project) {\n            await this.project.await('dataReady', false);\n        }\n        await super.waitForAnimations();\n    }\n    /**\n     * Refreshes the grid with transitions enabled.\n     */\n    refreshWithTransition(forceLayout, duration) {\n        const me = this;\n        // No point in starting a transition if we cant refresh anyway\n        if (!me.refreshSuspended && me.isPainted) {\n            // Since we suspend refresh when loading with CrudManager, rows might not have been initialized yet\n            if (!me.rowManager.topRow) {\n                me.rowManager.reinitialize();\n            }\n            else {\n                me.runWithTransition(() => me.refresh(forceLayout), duration);\n            }\n        }\n    }\n    /**\n     * Returns an object representing the visible date range\n     * @property {Object}\n     * @property {Date} visibleDateRange.startDate\n     * @property {Date} visibleDateRange.endDate\n     * @readonly\n     * @category Dates\n     */\n    get visibleDateRange() {\n        return this.currentOrientation.visibleDateRange;\n    }\n    // This override will force row selection on timeaxis column selection, effectively disabling cell selection there\n    isRowNumberSelecting(...selectors) {\n        return super.isRowNumberSelecting(...selectors) ||\n            selectors.some(cs => cs.column ? cs.column.isTimeAxisColumn : cs.cell?.closest('.b-timeaxis-cell'));\n    }\n    //endregion\n    /**\n     * Returns a rounded duration value to be displayed in UI (tooltips, labels etc)\n     * @param {Number} duration The raw duration value\n     * @param {Number} [nbrDecimals] The number of decimals, defaults to {@link #config-durationDisplayPrecision}\n     * @returns {Number} The rounded duration\n     */\n    formatDuration(duration, nbrDecimals = this.durationDisplayPrecision) {\n        const multiplier = Math.pow(10, nbrDecimals);\n        return Math.round(duration * multiplier) / multiplier;\n    }\n    beginListeningForBatchedUpdates() {\n        this.listenToBatchedUpdates = (this.listenToBatchedUpdates || 0) + 1;\n        // Allow live resizing (etc) in all splits\n        this.syncSplits?.(other => other.beginListeningForBatchedUpdates());\n    }\n    endListeningForBatchedUpdates() {\n        if (this.listenToBatchedUpdates) {\n            this.listenToBatchedUpdates -= 1;\n        }\n        this.syncSplits?.(other => other.endListeningForBatchedUpdates());\n    }\n    onConnectedCallback(connected, initialConnect) {\n        if (connected && !initialConnect) {\n            this.timeAxisSubGrid.scrollable.x += 0.5;\n        }\n    }\n    updateRtl(rtl) {\n        const\n            me                = this,\n            { isConfiguring } = me;\n        let visibleDateRange;\n        if (!isConfiguring) {\n            visibleDateRange = me.visibleDateRange;\n        }\n        super.updateRtl(rtl);\n        if (!isConfiguring) {\n            me.currentOrientation.clearAll();\n            if (me.infiniteScroll) {\n                me.shiftToDate(visibleDateRange.startDate);\n                me.scrollToDate(visibleDateRange.startDate, { block : 'start' });\n            }\n            else {\n                me.timelineScroller.position += 0.5;\n            }\n        }\n    }\n    /**\n     * Applies the start and end date to each event store request (formatted in the same way as the start date field,\n     * defined in the EventStore Model class).\n     * @category Data\n     * @private\n     */\n    applyStartEndParameters(params) {\n        const\n            me    = this,\n            field = me.eventStore.modelClass.fieldMap.startDate;\n        if (me.passStartEndParameters) {\n            params[me.startParamName] = field.print(me.startDate);\n            params[me.endParamName] = field.print(me.endDate);\n        }\n    }\n}\n// Register this widget type with its Factory\nTimelineBase.initClass();\n// Has to be here because Gantt extends TimelineBase\nVersionHelper.setVersion('scheduler', '5.6.2');\nTimelineBase._$name = 'TimelineBase';", "import Base from '../../../Core/Base.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\n/**\n * @module Scheduler/view/mixin/Describable\n */\nconst\n    arrayify = format => (!format || Array.isArray(format)) ? format : [format],\n    pickFormat = (formats, index, defaultFormat) => (formats && formats[index] !== true) ? formats[index] : defaultFormat;\n/**\n * Mixin that provides a consistent method for describing the ranges of time presented by a view. This is currently\n * consumed only by the Calendar widget for describing its child views. This mixin is defined here to facilitate using\n * a Scheduler as a child view of a Calendar.\n *\n * @mixin\n */\nexport default Target => class Describable extends (Target || Base) {\n    static $name = 'Describable';\n    static configurable = {\n        /**\n         * A {@link Core.helper.DateHelper} format string to use to create date output for view descriptions.\n         * @prp {String}\n         * @default\n         */\n        dateFormat : 'MMMM d, YYYY',\n        /**\n         * A string used to separate start and end dates in the {@link #config-descriptionFormat}.\n         * @prp {String}\n         * @default\n         */\n        dateSeparator : ' - ',\n        /**\n         * The date format used by the default {@link #config-descriptionRenderer} for rendering the view's description.\n         * If this value is `null`, the {@link #config-dateFormat} (and potentially {@link #config-dateSeparator}) will\n         * be used.\n         *\n         * For views that can span a range of dates, this can be a 2-item array with the following interpretation:\n         *\n         * - `descriptionFormat[0]` is either a date format string or `true` (to use {@link #config-dateFormat}). The\n         *   result of formatting the `startDate` with this format specification is used when the formatting both the\n         *   `startDate` and `endDate` with this specification produces the same result. For example, a week view\n         *   displays only the month and year components of the date, so this will be used unless the end of the week\n         *   crosses into the next month.\n         *\n         * - `descriptionFormat[1]` is used with {@link Core.helper.DateHelper#function-formatRange-static} when the\n         *  `startDate` and `endDate` format differently using `descriptionFormat[0]` (as described above). This one\n         *  format string produces a result for both dates. If this value is `true`, the {@link #config-dateFormat} and\n         *  {@link #config-dateSeparator} are combined to produce the range format.\n         *\n         * @prp {String|String[]|Boolean[]}\n         * @default\n         */\n        descriptionFormat : null,\n        /**\n         * A function that provides the textual description for this view. If provided, this function overrides the\n         * {@link #config-descriptionFormat}.\n         *\n         * ```javascript\n         *  descriptionRenderer() {\n         *      const\n         *          eventsInView = this.eventStore.records.filter(\n         *              eventRec => DateHelper.intersectSpans(\n         *                  this.startDate, this.endDate,\n         *                  eventRec.startDate, eventRec.endDate)).length,\n         *          sd = DateHelper.format(this.startDate, 'DD/MM/YYY'),\n         *          ed = DateHelper.format(this.endDate, 'DD/MM/YYY');\n         *\n         *     return `${sd} - ${ed}, ${eventsInView} event${eventsInView === 1 ? '' : 's'}`;\n         * }\n         * ```\n         * @config {Function} descriptionRenderer\n         * @param {Core.widget.Widget} view The active view in case the function is in another scope.\n         * @returns {String} Description string\n         */\n        descriptionRenderer : null\n    };\n    /**\n     * Returns the date or ranges of included dates as an array. If there is only one significant date, the array will\n     * have only one element. Otherwise, a range of dates is returned as a two-element array with `[0]` being the\n     * `startDate` and `[1]` the `lastDate`.\n     * @member {Date[]}\n     * @internal\n     */\n    get dateBounds() {\n        return [this.date];\n    }\n    /**\n     * The textual description generated by the {@link #config-descriptionRenderer} if present, or by the\n     * view's date (or date *range* if it has a range) and the {@link #config-descriptionFormat}.\n     * @property {String}\n     * @readonly\n     */\n    get description() {\n        const\n            me = this,\n            { descriptionRenderer } = me;\n        return descriptionRenderer ? me.callback(descriptionRenderer, me, [me]) : me.formattedDescription;\n    }\n    get formattedDescription() {\n        const\n            me = this,\n            { dateBounds, dateFormat } = me,\n            descriptionFormat = me.descriptionFormat ?? arrayify(me.defaultDescriptionFormat),\n            format0 = pickFormat(descriptionFormat, 0, dateFormat),\n            end = dateBounds.length > 1 && descriptionFormat?.length > 1 && (\n                DateHelper.format(dateBounds[0], format0) !== DateHelper.format(dateBounds[1], format0)\n            );\n        // Format the startDate and endDate using the first format\n        let ret = DateHelper.format(dateBounds[0], format0);\n        if (end) {\n            // The endDate renders a different description, and we have a range format.\n            ret = DateHelper.formatRange(dateBounds,\n                pickFormat(descriptionFormat, 1, `S${dateFormat}${me.dateSeparator}E${dateFormat}`));\n        }\n        return ret;\n    }\n    changeDescriptionFormat(format) {\n        return arrayify(format);\n    }\n    get widgetClass() {}  // no b-describable class\n};\n", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/view/mixin/SchedulerDom\n */\n/**\n * Mixin with EventModel and ResourceModel <-> HTMLElement mapping functions\n *\n * @mixin\n */\nexport default Target => class SchedulerDom extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerDom';\n    }\n    //region Get\n    /**\n     * Returns a single HTMLElement representing an event record assigned to a specific resource.\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord An assignment record\n     * @returns {HTMLElement} The element representing the event record\n     * @category DOM\n     */\n    getElementFromAssignmentRecord(assignmentRecord, returnWrapper = false, checkReleased = false) {\n        if (this.isPainted && assignmentRecord) {\n            let wrapper = this.foregroundCanvas.syncIdMap?.[assignmentRecord.id];\n            // When using links, the original might not be rendered but a link might\n            if (!wrapper && assignmentRecord.resource?.hasLinks) {\n                for (const link of assignmentRecord.resource.$links) {\n                    wrapper = this.foregroundCanvas.syncIdMap?.[`${assignmentRecord.id}_${link.id}`];\n                    if (!wrapper) {\n                        if (checkReleased) {\n                            // When event is released, it needs to retrieve it from releasedIdMap\n                            wrapper = this.foregroundCanvas.releasedIdMap?.[`${assignmentRecord.id}_${link.id}`];\n                            if (wrapper) {\n                                break;\n                            }\n                        }\n                    }\n                    else {\n                        break;\n                    }\n                }\n            }\n            // When event is released, it needs to retrieve it from releasedIdMap\n            if (!wrapper && checkReleased) {\n                wrapper = this.foregroundCanvas.releasedIdMap?.[assignmentRecord.id];\n            }\n            // Wrapper won't have syncIdMap when saving dragcreated event from editor\n            return returnWrapper ? wrapper : wrapper?.syncIdMap?.event;\n        }\n        return null;\n    }\n    /**\n     * Returns a single HTMLElement representing an event record assigned to a specific resource.\n     * @param {Scheduler.model.EventModel} eventRecord An event record\n     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record\n     * @returns {HTMLElement} The element representing the event record\n     * @category DOM\n     */\n    getElementFromEventRecord(eventRecord, resourceRecord = eventRecord.resources?.[0], returnWrapper = false, checkReleased = false) {\n        if (eventRecord.isResourceTimeRange) {\n            const wrapper = this.foregroundCanvas.syncIdMap?.[eventRecord.domId];\n            return returnWrapper ? wrapper : wrapper?.syncIdMap.event;\n        }\n        const assignmentRecord = this.assignmentStore.getAssignmentForEventAndResource(eventRecord, resourceRecord);\n        return this.getElementFromAssignmentRecord(assignmentRecord, returnWrapper, checkReleased);\n    }\n    /**\n     * Returns all the HTMLElements representing an event record.\n     *\n     * @param {Scheduler.model.EventModel} eventRecord An event record\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] A resource record\n     *\n     * @returns {HTMLElement[]} The element(s) representing the event record\n     * @category DOM\n     */\n    getElementsFromEventRecord(eventRecord, resourceRecord, returnWrapper = false, checkReleased = false) {\n        // Single event instance, as array\n        if (resourceRecord) {\n            return [this.getElementFromEventRecord(eventRecord, resourceRecord, returnWrapper, checkReleased)];\n        }\n        // All instances\n        else {\n            return eventRecord.resources.reduce((result, resourceRecord) => {\n                const el = this.getElementFromEventRecord(eventRecord, resourceRecord, returnWrapper, checkReleased);\n                el && result.push(el);\n                return result;\n            }, []);\n        }\n    }\n    //endregion\n    //region Resolve\n    /**\n     * Resolves the resource based on a dom element or event. In vertical mode, if resolving from an element higher up in\n     * the hierarchy than event elements, then it is required to supply an coordinates since resources are virtual\n     * columns.\n     * @param {HTMLElement|Event} elementOrEvent The HTML element or DOM event to resolve a resource from\n     * @param {Number[]} [xy] X and Y coordinates, required in some cases in vertical mode, disregarded in horizontal\n     * @returns {Scheduler.model.ResourceModel} The resource corresponding to the element, or null if not found.\n     * @category DOM\n     */\n    resolveResourceRecord(elementOrEvent, xy) {\n        return this.currentOrientation.resolveRowRecord(elementOrEvent, xy);\n    }\n    /**\n     * Product agnostic method which yields the {@link Scheduler.model.ResourceModel} record which underpins the row which\n     * encapsulates the passed element. The element can be a grid cell, or an event element, and the result\n     * will be a {@link Scheduler.model.ResourceModel}\n     * @param {HTMLElement|Event} elementOrEvent The HTML element or DOM event to resolve a record from\n     * @returns {Scheduler.model.ResourceModel} The resource corresponding to the element, or null if not found.\n     * @category DOM\n     */\n    resolveRowRecord(elementOrEvent) {\n        return this.resolveResourceRecord(elementOrEvent);\n    }\n    /**\n     * Returns the event record for a DOM element\n     * @param {HTMLElement|Event} elementOrEvent The DOM node to lookup\n     * @returns {Scheduler.model.EventModel} The event record\n     * @category DOM\n     */\n    resolveEventRecord(elementOrEvent) {\n        if (elementOrEvent instanceof Event) {\n            elementOrEvent = elementOrEvent.target;\n        }\n        const element = elementOrEvent?.closest(this.eventSelector);\n        if (element) {\n            if (element.dataset.eventId) {\n                return this.eventStore.getById(element.dataset.eventId);\n            }\n            if (element.dataset.assignmentId) {\n                return this.assignmentStore.getById(element.dataset.assignmentId).event;\n            }\n        }\n        return null;\n    }\n    // Used by shared features to resolve an event or task\n    resolveTimeSpanRecord(element) {\n        return this.resolveEventRecord(element);\n    }\n    /**\n     * Returns an assignment record for a DOM element\n     * @param {HTMLElement} element The DOM node to lookup\n     * @privateparam {Boolean} allowReleased Whether to allow resolving from a released event\n     * @returns {Scheduler.model.AssignmentModel} The assignment record\n     * @category DOM\n     */\n    resolveAssignmentRecord(element, allowReleased = false) {\n        const\n            eventElement     = element.closest(allowReleased ? '[data-assignment-id][data-event-id]' : this.eventSelector),\n            assignmentRecord = eventElement && this.assignmentStore.getById(eventElement.dataset.assignmentId),\n            eventRecord      = eventElement && this.eventStore.getById(eventElement.dataset.eventId);\n        // When resolving a recurring event, we might be resolving an occurrence\n        return this.assignmentStore.getOccurrence(assignmentRecord, eventRecord);\n    }\n    //endregion\n    // Decide if a record is inside a collapsed tree node, or inside a collapsed group (using grouping feature)\n    isRowVisible(resourceRecord) {\n        // records in collapsed groups/branches etc. are removed from processedRecords\n        return this.store.indexOf(resourceRecord) >= 0;\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/view/mixin/SchedulerDomEvents\n */\n/**\n * Mixin that handles dom events (click etc) for scheduler and rendered events.\n *\n * @mixin\n */\nexport default Target => class SchedulerDomEvents extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerDomEvents';\n    }\n    //region Events\n    /**\n     * Triggered when user mousedowns over an empty area in the schedule.\n     * @event scheduleMouseDown\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when mouse enters an empty area in the schedule.\n     * @event scheduleMouseEnter\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when mouse leaves an empty area in the schedule.\n     * @event scheduleMouseLeave\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when user mouseups over an empty area in the schedule.\n     * @event scheduleMouseUp\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when user moves mouse over an empty area in the schedule.\n     * @event scheduleMouseMove\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when user clicks an empty area in the schedule.\n     * @event scheduleClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when user double-clicks an empty area in the schedule.\n     * @event scheduleDblClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Index of double-clicked resource\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when user right-clicks an empty area in the schedule.\n     * @event scheduleContextMenu\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Date} date Date at mouse position\n     * @param {Scheduler.model.TimeSpan} tick A record which encapsulates the time axis tick clicked on.\n     * @param {Number} tickIndex The index of the time axis tick clicked on.\n     * @param {Date} tickStartDate The start date of the current time axis tick\n     * @param {Date} tickEndDate The end date of the current time axis tick\n     * @param {Grid.row.Row} row Row under the mouse (in horizontal mode only)\n     * @param {Number} index Resource index\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for mouse down on an event.\n     * @event eventMouseDown\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for mouse up on an event.\n     * @event eventMouseUp\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for click on an event.\n     * @event eventClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for double-click on an event.\n     * @event eventDblClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for right-click on an event.\n     * @event eventContextMenu\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when the mouse enters an event bar.\n     * @event eventMouseEnter\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when the mouse leaves an event bar.\n     * @event eventMouseLeave\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for mouse over events when moving into and within an event bar.\n     *\n     * Note that `mouseover` events bubble, therefore this event will fire while moving from\n     * element to element *within* an event bar.\n     *\n     * _If only an event when moving into the event bar is required, use the {@link #event-eventMouseEnter} event._\n     * @event eventMouseOver\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered for mouse out events within and when moving out of an event bar.\n     *\n     * Note that `mouseout` events bubble, therefore this event will fire while moving from\n     * element to element *within* an event bar.\n     *\n     * _If only an event when moving out of the event bar is required, use the {@link #event-eventMouseLeave} event._\n     * @event eventMouseOut\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord Event record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record\n     * @param {MouseEvent} event Browser event\n     */\n    //endregion\n    //region Event handling\n    getTimeSpanMouseEventParams(eventElement, event) {\n        // May have hovered a record being removed / faded out\n        const eventRecord = this.resolveEventRecord(eventElement);\n        return eventRecord && {\n            eventRecord,\n            resourceRecord   : this.resolveResourceRecord(eventElement),\n            assignmentRecord : this.resolveAssignmentRecord(eventElement),\n            eventElement,\n            event\n        };\n    }\n    getScheduleMouseEventParams(cellData, event) {\n        const resourceRecord = this.isVertical ? this.resolveResourceRecord(event) : this.store.getById(cellData.id);\n        return { resourceRecord };\n    }\n    /**\n     * Relays keydown events as eventkeydown if we have a selected task.\n     * @private\n     */\n    onElementKeyDown(event) {\n        const\n            result = super.onElementKeyDown(event),\n            me     = this;\n        if (me.selectedEvents.length) {\n            me.trigger(me.scheduledEventName + 'KeyDown', {\n                eventRecords      : me.selectedEvents,\n                assignmentRecords : me.selectedAssignments,\n                event,\n                eventRecord       : me.selectedEvents,\n                assignmentRecord  : me.selectedAssignments\n            });\n        }\n        return result;\n    }\n    /**\n     * Relays keyup events as eventkeyup if we have a selected task.\n     * @private\n     */\n    onElementKeyUp(event) {\n        super.onElementKeyUp(event);\n        const me = this;\n        if (me.selectedEvents.length) {\n            me.trigger(me.scheduledEventName + 'KeyUp', {\n                eventRecords      : me.selectedEvents,\n                assignmentRecords : me.selectedAssignments,\n                event,\n                eventRecord      : me.selectedEvents,\n                assignmentRecord : me.selectedAssignments\n            });\n        }\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../Core/Base.js';\n/**\n * @module Scheduler/eventlayout/HorizontalLayout\n */\n/**\n * Base class for horizontal layouts (HorizontalLayoutPack and HorizontalLayoutStack). Should not be used directly,\n * instead specify {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventLayout} in Scheduler config (stack,\n * pack or none):\n *\n * ```javascript\n * let scheduler = new Scheduler({\n *   eventLayout: 'stack'\n * });\n * ```\n *\n * @abstract\n * @private\n */\nexport default class HorizontalLayout extends Base {\n    static get defaultConfig() {\n        return {\n            nbrOfBandsByResource        : {},\n            bandIndexToPxConvertFn      : null,\n            bandIndexToPxConvertThisObj : null\n        };\n    }\n    clearCache(resource) {\n        if (resource) {\n            delete this.nbrOfBandsByResource[resource.id];\n        }\n        else {\n            this.nbrOfBandsByResource = {};\n        }\n    }\n    /**\n     * This method performs layout on an array of event render data and returns amount of _bands_. Band is a multiplier of a\n     * configured {@link Scheduler.view.Scheduler#config-rowHeight} to calculate total row height required to fit all\n     * events.\n     * This method should not be used directly, it is called by the Scheduler during the row rendering process.\n     * @param {EventRenderData[]} events Unordered array of event render data, sorting may be required\n     * @param {Scheduler.model.ResourceModel} resource The resource for which the events are being laid out.\n     * @returns {Number}\n     */\n    applyLayout(events, resource) {\n        // Return number of bands required\n        return this.nbrOfBandsByResource[resource.id] = this.layoutEventsInBands(events, resource);\n    }\n    /**\n     * This method iterates over events and calculates top position for each of them. Default layouts calculate\n     * positions to avoid events overlapping horizontally (except for the 'none' layout). Pack layout will squeeze events to a single\n     * row by reducing their height, Stack layout will increase the row height and keep event height intact.\n     * This method should not be used directly, it is called by the Scheduler during the row rendering process.\n     * @param {EventRenderData[]} events Unordered array of event render data, sorting may be required\n     * @param {Scheduler.model.ResourceModel} resource The resource for which the events are being laid out.\n     */\n    layoutEventsInBands(events, resource) {\n        throw new Error('Implement in subclass');\n    }\n}\nHorizontalLayout._$name = 'HorizontalLayout';", "import HorizontalLayout from './HorizontalLayout.js';\n/**\n * @module Scheduler/eventlayout/HorizontalLayoutStack\n */\n/**\n * Handles layout of events within a row (resource) in horizontal mode. Stacks events, increasing row height when to fit\n * all overlapping events.\n *\n * This layout is used by default in horizontal mode.\n *\n * @extends Scheduler/eventlayout/HorizontalLayout\n * @private\n */\nexport default class HorizontalLayoutStack extends HorizontalLayout {\n    static get $name() {\n        return 'HorizontalLayoutStack';\n    }\n    static get configurable() {\n        return {\n            type : 'stack'\n        };\n    }\n    // Input: Array of event layout data\n    // heightRun is used when pre-calculating row heights, taking a cheaper path\n    layoutEventsInBands(events, resource, heightRun = false) {\n        let verticalPosition = 0;\n        do {\n            let eventIndex = 0,\n                event      = events[0];\n            while (event) {\n                if (!heightRun) {\n                    // Apply band height to the event cfg\n                    event.top = this.bandIndexToPxConvertFn.call(\n                        this.bandIndexToPxConvertThisObj || this,\n                        verticalPosition,\n                        event.eventRecord,\n                        event.resourceRecord\n                    );\n                }\n                // Remove it from the array and continue searching\n                events.splice(eventIndex, 1);\n                eventIndex = this.findClosestSuccessor(event, events);\n                event = events[eventIndex];\n            }\n            verticalPosition++;\n        } while (events.length > 0);\n        // Done!\n        return verticalPosition;\n    }\n    findClosestSuccessor(eventRenderData, events) {\n        const\n            { endMS, group } = eventRenderData,\n            isMilestone      = eventRenderData.eventRecord?.duration === 0;\n        let minGap      = Infinity,\n            closest,\n            gap,\n            event,\n            eventIsMilestone;\n        for (let i = 0, l = events.length; i < l; i++) {\n            event = events[i];\n            gap = event.startMS - endMS;\n            eventIsMilestone = event.endMS - event.startMS === 0 && !event.eventRecord?.meta.isDragCreating;\n            if (\n                gap >= 0 && gap < minGap &&\n                // Two milestones should not overlap\n                (gap > 0 || !eventIsMilestone || !isMilestone) &&\n                // Milestone at events endDate goes on next band\n                !(gap === 0 && eventIsMilestone && !isMilestone)\n            ) {\n                // Events are sorted by group, so when we find first event with a different group, we can stop iteration\n                if (this.grouped && group !== event.group) {\n                    break;\n                }\n                closest = i;\n                minGap  = gap;\n            }\n        }\n        return closest;\n    }\n}\nHorizontalLayoutStack._$name = 'HorizontalLayoutStack';", "import Base from '../../Core/Base.js';\n/**\n * @module Scheduler/eventlayout/PackMixin\n */\nconst rangesIntersect = (range1Start, range1End, range2Start, range2End) => {\n    return (range2Start <= range1Start && range1Start < range2End) ||\n    (range1Start <= range2Start && range2Start < range1End);\n};\n/**\n * Mixin holding functionality shared between HorizontalLayoutPack and VerticalLayout.\n *\n * @mixin\n * @private\n */\nexport default Target => class PackMixin extends (Target || Base) {\n    static get $name() {\n        return 'PackMixin';\n    }\n    static get defaultConfig() {\n        return {\n            coordProp       : 'top',\n            sizeProp        : 'height',\n            inBandCoordProp : 'inBandTop',\n            inBandSizeProp  : 'inBandHeight'\n        };\n    }\n    isSameGroup(a, b) {\n        return this.grouped ? a.group === b.group : true;\n    }\n    // Packs the events to consume as little space as possible\n    packEventsInBands(events, applyClusterFn) {\n        const\n            me                      = this,\n            { coordProp, sizeProp } = me;\n        let slot,\n            firstInCluster,\n            cluster,\n            j;\n        for (let i = 0, l = events.length; i < l; i++) {\n            firstInCluster = events[i];\n            slot = me.findStartSlot(events, firstInCluster);\n            cluster = me.getCluster(events, i);\n            if (cluster.length > 1) {\n                firstInCluster[coordProp] = slot.start;\n                firstInCluster[sizeProp]  = slot.end - slot.start;\n                // If there are multiple slots, and events in the cluster have multiple start dates, group all same-start events into first slot\n                j = 1;\n                while (j < (cluster.length - 1) && cluster[j + 1].start - firstInCluster.start === 0) {\n                    j++;\n                }\n                // See if there's more than 1 slot available for this cluster, if so - first group in cluster consumes the entire first slot\n                const nextSlot = me.findStartSlot(events, cluster[j]);\n                if (nextSlot && nextSlot.start < 0.8) {\n                    cluster.length = j;\n                }\n            }\n            const\n                clusterSize = cluster.length,\n                slotSize    = (slot.end - slot.start) / clusterSize;\n            // Apply fraction values\n            for (j = 0; j < clusterSize; j++) {\n                applyClusterFn(cluster[j], j, slot, slotSize);\n            }\n            i += clusterSize - 1;\n        }\n        return 1;\n    }\n    findStartSlot(events, event) {\n        const\n            {\n                inBandSizeProp,\n                inBandCoordProp,\n                coordProp,\n                sizeProp\n            }                = this,\n            priorOverlappers = this.getPriorOverlappingEvents(events, event);\n        let i;\n        if (priorOverlappers.length === 0) {\n            return {\n                start : 0,\n                end   : 1\n            };\n        }\n        for (i = 0; i < priorOverlappers.length; i++) {\n            const\n                item       = priorOverlappers[i],\n                COORD_PROP = inBandCoordProp in item ? inBandCoordProp : coordProp,\n                SIZE_PROP  = inBandSizeProp in item ? inBandSizeProp : sizeProp;\n            if (i === 0 && item[COORD_PROP] > 0) {\n                return {\n                    start : 0,\n                    end   : item[COORD_PROP]\n                };\n            }\n            else {\n                if (item[COORD_PROP] + item[SIZE_PROP] < (i < priorOverlappers.length - 1 ? priorOverlappers[i + 1][COORD_PROP] : 1)) {\n                    return {\n                        start : item[COORD_PROP] + item[SIZE_PROP],\n                        end   : i < priorOverlappers.length - 1 ? priorOverlappers[i + 1][COORD_PROP] : 1\n                    };\n                }\n            }\n        }\n        return false;\n    }\n    getPriorOverlappingEvents(events, event) {\n        const\n            { startMS, endMS }       = event,\n            overlappers = [];\n        for (let i = 0, l = events.indexOf(event); i < l; i++) {\n            const item = events[i];\n            if (this.isSameGroup(item, event) && rangesIntersect(startMS, endMS, item.startMS, item.endMS)) {\n                overlappers.push(item);\n            }\n        }\n        overlappers.sort(this.sortOverlappers.bind(this));\n        return overlappers;\n    }\n    sortOverlappers(e1, e2) {\n        const { coordProp } = this;\n        return e1[coordProp] - e2[coordProp];\n    }\n    getCluster(events, startIndex) {\n        const\n            startEvent = events[startIndex],\n            result     = [startEvent];\n        if (startIndex >= events.length - 1) {\n            return result;\n        }\n        let { startMS, endMS } = startEvent;\n        for (let i = startIndex + 1, l = events.length; i < l; i++) {\n            const item = events[i];\n            if (!this.isSameGroup(item, startEvent) || !rangesIntersect(startMS, endMS, item.startMS, item.endMS)) {\n                break;\n            }\n            result.push(item);\n            startMS = Math.max(startMS, item.startMS);\n            endMS   = Math.min(item.endMS, endMS);\n        }\n        return result;\n    }\n};\n", "import HorizontalLayout from './HorizontalLayout.js';\nimport PackMixin from './PackMixin.js';\n/**\n * @module Scheduler/eventlayout/HorizontalLayoutPack\n */\n/**\n * Handles layout of events within a row (resource) in horizontal mode. Packs events (adjusts their height) to fit\n * available row height\n *\n * @extends Scheduler/eventlayout/HorizontalLayout\n * @mixes Scheduler/eventlayout/PackMixin\n * @private\n */\nexport default class HorizontalLayoutPack extends HorizontalLayout.mixin(PackMixin) {\n    static get $name() {\n        return 'HorizontalLayoutPack';\n    }\n    static get configurable() {\n        return {\n            type : 'pack'\n        };\n    }\n    // Packs the events to consume as little space as possible\n    layoutEventsInBands(events) {\n        const result = this.packEventsInBands(events, (event, j, slot, slotSize) => {\n            event.height = slotSize;\n            event.top    = slot.start + (j * slotSize);\n        });\n        events.forEach(event => {\n            Object.assign(\n                event,\n                this.bandIndexToPxConvertFn.call(\n                    this.bandIndexToPxConvertThisObj || this,\n                    event.top,\n                    event.height,\n                    event.eventRecord,\n                    event.resourceRecord\n                )\n            );\n        });\n        return result;\n    }\n}\nHorizontalLayoutPack._$name = 'HorizontalLayoutPack';", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/view/mixin/SchedulerResourceRendering\n */\n/**\n * Configs and functions used for resource rendering\n * and by the {@link Scheduler/column/ResourceInfoColumn} class.\n *\n * @mixin\n */\nexport default Target => class SchedulerResourceRendering extends (Target || Base) {\n    static $name = 'SchedulerResourceRendering';\n    //region Default config\n    static configurable = {\n        /**\n         * Control how much space to leave between the first event/last event and the resources edge (top/bottom\n         * margin within the resource row in horizontal mode, left/right margin within the resource column in\n         * vertical mode), in px. Defaults to the value of {@link Scheduler.view.Scheduler#config-barMargin}.\n         *\n         * Can be configured per resource by setting {@link Scheduler.model.ResourceModel#field-resourceMargin\n         * resource.resourceMargin}.\n         *\n         * It's also possible to set different values for top/left and bottom/right\n         * by assigning  an object to `resourceMargin` with `start` (margin top in horizontal mode,\n         * margin left in vertical mode) and `end` (margin bottom / margin right) properties:\n         * ```javascript\n         * scheduler = new Scheduler({\n         *     resourceMargin : {\n         *         start : 15,\n         *         end   : 1\n         *     }\n         * });\n         * ```\n         *\n         * @prp {Number|ResourceMarginConfig}\n         * @category Scheduled events\n         */\n        resourceMargin : null,\n        /**\n         * A config object used to configure the resource columns in vertical mode.\n         * See {@link Scheduler.view.ResourceHeader} for more details on available properties.\n         *\n         * ```javascript\n         * new Scheduler({\n         *     resourceColumns : {\n         *         columnWidth    : 100,\n         *         headerRenderer : ({ resourceRecord }) => `${resourceRecord.id} - ${resourceRecord.name}`\n         *     }\n         * })\n         * ```\n         * @config {ResourceHeaderConfig}\n         * @category Resources\n         */\n        resourceColumns : null,\n        /**\n         * Path to load resource images from. Used by the resource header in vertical mode and the\n         * {@link Scheduler.column.ResourceInfoColumn} in horizontal mode. Set this to display miniature\n         * images for each resource using their `image` or `imageUrl` fields.\n         *\n         * * `image` represents image name inside the specified `resourceImagePath`,\n         * * `imageUrl` represents fully qualified image URL.\n         *\n         *  If set and a resource has no `imageUrl` or `image` specified it will try show miniature using\n         *  the resource's name with {@link #config-resourceImageExtension} appended.\n         *\n         * **NOTE**: The path should end with a `/`:\n         *\n         * ```\n         * new Scheduler({\n         *   resourceImagePath : 'images/resources/'\n         * });\n         * ```\n         * @config {String}\n         * @category Resources\n         */\n        resourceImagePath : null,\n        /**\n         * Generic resource image, used when provided `imageUrl` or `image` fields or path calculated from resource\n         * name are all invalid. If left blank, resource name initials will be shown when no image can be loaded.\n         * @default\n         * @config {String}\n         * @category Resources\n         */\n        defaultResourceImageName : null,\n        /**\n         * Resource image extension, used when creating image path from resource name.\n         * @default\n         * @config {String}\n         * @category Resources\n         */\n        resourceImageExtension : '.jpg'\n    };\n    //endregion\n    //region Resource header/columns\n    // NOTE: The configs below are initially applied to the resource header in `TimeAxisColumn#set mode`\n    /**\n     * Use it to manipulate resource column properties at runtime.\n     * @property {Scheduler.view.ResourceHeader}\n     * @readonly\n     */\n    get resourceColumns() {\n        return this.timeAxisColumn?.resourceColumns || this._resourceColumns;\n    }\n    /**\n     * Get resource column width. Only applies to vertical mode. To set it, assign to\n     * `scheduler.resourceColumns.columnWidth`.\n     * @property {Number}\n     * @readonly\n     */\n    get resourceColumnWidth() {\n        return this.resourceColumns?.columnWidth || null;\n    }\n    //endregion\n    //region Event rendering\n    // Returns a resource specific resourceMargin, falling back to Schedulers setting\n    // This fn could be made public to allow hooking it as an alternative to only setting this in data\n    getResourceMarginObject(resourceRecord) {\n        if (resourceRecord?.resourceMargin) {\n            const margin = resourceRecord?.resourceMargin ?? this.resourceMargin;\n            if (typeof margin === 'number') {\n                return {\n                    start : margin,\n                    end   : margin,\n                    total : margin * 2\n                };\n            }\n            else {\n                margin.total = margin.start + margin.end;\n                return margin;\n            }\n        }\n        else {\n            return this.resourceMarginObject;\n        }\n    }\n    // Returns a resource specific barMargin, falling back to Schedulers setting\n    // This fn could be made public to allow hooking it as an alternative to only setting this in data\n    getBarMargin(resourceRecord) {\n        return resourceRecord?.barMargin ?? this.barMargin;\n    }\n    // Returns a resource specific rowHeight, falling back to Schedulers setting\n    // Prio order: Height from record, configured height\n    // This fn could be made public to allow hooking it as an alternative to only setting this in data\n    getResourceHeight(resourceRecord) {\n        return resourceRecord.rowHeight ?? (this.isHorizontal ? this.rowHeight : this.getResourceWidth(resourceRecord));\n    }\n    getResourceWidth(resourceRecord) {\n        return resourceRecord.columnWidth ?? this.resourceColumnWidth;\n    }\n    // Similar to getResourceHeight(), but for usage later in the process to take height set by renderers into account.\n    // Cant be used earlier in the process because then the row will grow\n    // Prio order: Height requested by renderer, height from record, configured height\n    getAppliedResourceHeight(resourceRecord) {\n        const row = this.getRowById(resourceRecord);\n        return row?.maxRequestedHeight ?? this.getResourceHeight(resourceRecord);\n    }\n    // Combined convenience getter for destructuring on calling side\n    // Second arg only passed for nested events, handled by NestedEvent feature\n    getResourceLayoutSettings(resourceRecord, parentEventRecord = null) {\n        const\n            resourceMarginObject = this.getResourceMarginObject(resourceRecord, parentEventRecord),\n            rowHeight = this.getAppliedResourceHeight(resourceRecord, parentEventRecord);\n        return {\n            barMargin     : this.getBarMargin(resourceRecord, parentEventRecord),\n            contentHeight : Math.max(rowHeight - resourceMarginObject.total, 1),\n            rowHeight,\n            resourceMarginObject\n        };\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport DomClassList from '../../../Core/helper/util/DomClassList.js';\nimport HorizontalLayoutStack from '../../eventlayout/HorizontalLayoutStack.js';\nimport HorizontalLayoutPack from '../../eventlayout/HorizontalLayoutPack.js';\nimport BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport SchedulerResourceRendering from './SchedulerResourceRendering.js';\n/**\n * @module Scheduler/view/mixin/SchedulerEventRendering\n */\n/**\n * Layout data object used to lay out an event record.\n * @typedef {Object} EventRenderData\n * @property {Scheduler.model.EventModel} eventRecord Event instance\n * @property {Scheduler.model.ResourceModel} resourceRecord Assigned resource\n * @property {Scheduler.model.AssignmentModel} assignmentRecord Assignment instance\n * @property {Number} startMS Event start date time in milliseconds\n * @property {Number} endMS Event end date in milliseconds\n * @property {Number} height Calculated event element height\n * @property {Number} width Calculated event element width\n * @property {Number} top Calculated event element top position in the row (or column)\n * @property {Number} left Calculated event element left position in the row (or column)\n */\n/**\n * Functions to handle event rendering (EventModel -> dom elements).\n *\n * @mixes Scheduler/view/mixin/SchedulerResourceRendering\n * @mixin\n */\nexport default Target => class SchedulerEventRendering extends SchedulerResourceRendering(Target || Base) {\n    static get $name() {\n        return 'SchedulerEventRendering';\n    }\n    //region Default config\n    static get configurable() {\n        return {\n            /**\n             * Position of the milestone text:\n             * * 'inside' - for short 1-char text displayed inside the diamond, not applicable when using\n             *   {@link #config-milestoneLayoutMode})\n             * * 'outside' - for longer text displayed outside the diamond, but inside it when using\n             *   {@link #config-milestoneLayoutMode}\n             * * 'always-outside' - outside even when combined with {@link #config-milestoneLayoutMode}\n             *\n             * @prp {'inside'|'outside'|'always-outside'}\n             * @default\n             * @category Milestones\n             */\n            milestoneTextPosition : 'outside',\n            /**\n             * How to align milestones in relation to their startDate. Only applies when using a `milestoneLayoutMode`\n             * other than `default`. Valid values are:\n             * * start\n             * * center (default)\n             * * end\n             * @prp {'start'|'center'|'end'}\n             * @default\n             * @category Milestones\n             */\n            milestoneAlign : 'center',\n            /**\n             * Factor representing the average char width in pixels used to determine milestone width when configured\n             * with `milestoneLayoutMode: 'estimate'`.\n             * @prp {Number}\n             * @default\n             * @category Milestones\n             */\n            milestoneCharWidth : 10,\n            /**\n             * How to handle milestones during event layout. How the milestones are displayed when part of the layout\n             * are controlled using {@link #config-milestoneTextPosition}.\n             *\n             * Options are:\n             * * default - Milestones do not affect event layout\n             * * estimate - Milestone width is estimated by multiplying text length with Scheduler#milestoneCharWidth\n             * * data - Milestone width is determined by checking EventModel#milestoneWidth\n             * * measure - Milestone width is determined by measuring label width\n             * Please note that currently text width is always determined using EventModel#name.\n             * Also note that only 'default' is supported by eventStyles line, dashed and minimal.\n             * @prp {'default'|'estimate'|'data'|'measure'}\n             * @default\n             * @category Milestones\n             */\n            milestoneLayoutMode : 'default',\n            /**\n             * Defines how to handle overlapping events. Valid values are:\n             * - `stack`, adjusts row height (only horizontal)\n             * - `pack`, adjusts event height\n             * - `mixed`, allows two events to overlap, more packs (only vertical)\n             * - `none`, allows events to overlap\n             *\n             * This config can also accept an object:\n             *\n             * ```javascript\n             * new Scheduler({\n             *     eventLayout : { type : 'stack' }\n             * })\n             * ```\n             *\n             * @prp {'stack'|'pack'|'mixed'|'none'|Object}\n             * @default\n             * @category Scheduled events\n             */\n            eventLayout : 'stack',\n            /**\n             * Override this method to provide a custom sort function to sort any overlapping events. See {@link\n             * #config-overlappingEventSorter} for more details.\n             *\n             * @param  {Scheduler.model.EventModel} a First event\n             * @param  {Scheduler.model.EventModel} b Second event\n             * @returns {Number} Return -1 to display `a` above `b`, 1 for `b` above `a`\n             * @member {Function} overlappingEventSorter\n             * @category Misc\n             */\n            /**\n             * Override this method to provide a custom sort function to sort any overlapping events. This only applies\n             * to the horizontal mode, where the order the events are sorted in determines their vertical placement\n             * within a resource.\n             *\n             * By default, overlapping events are laid out based on the start date. If the start date is equal, events\n             * with earlier end date go first. And lastly the name of events is taken into account.\n             *\n             * Here's a sample sort function, sorting on start- and end date. If this function returns -1, then event\n             * `a` is placed above event `b`:\n             *\n             * ```javascript\n             * overlappingEventSorter(a, b) {\n             *\n             *   const startA = a.startDate, endA = a.endDate;\n             *   const startB = b.startDate, endB = b.endDate;\n             *\n             *   const sameStart = (startA - startB === 0);\n             *\n             *   if (sameStart) {\n             *     return endA > endB ? -1 : 1;\n             *   } else {\n             *     return (startA < startB) ? -1 : 1;\n             *   }\n             * }\n             * ```\n             *\n             * NOTE: The algorithms (stack, pack) that lay the events out expects them to be served in chronological\n             * order, be sure to first sort by `startDate` to get predictable results.\n             *\n             * @param  {Scheduler.model.EventModel} a First event\n             * @param  {Scheduler.model.EventModel} b Second event\n             * @returns {Number} Return -1 to display `a` above `b`, 1 for `b` above `a`\n             * @config {Function}\n             * @category Misc\n             */\n            overlappingEventSorter : null,\n            /**\n             * Deprecated, to be removed in version 6.0. Replaced by {@link #config-overlappingEventSorter}.\n             * @deprecated Since 5.0. Use {@link #config-overlappingEventSorter} instead.\n             * @config {Function}\n             * @category Misc\n             */\n            horizontalEventSorterFn : null,\n            /**\n             * By default, scheduler fade events in on load. Specify `false` to prevent this animation or specify one\n             * of the available animation types to use it (`true` equals `'fade-in'`):\n             * * fade-in (default)\n             * * slide-from-left\n             * * slide-from-top\n             * ```\n             * // Slide events in from the left on load\n             * scheduler = new Scheduler({\n             *     useInitialAnimation : 'slide-from-left'\n             * });\n             * ```\n             * @prp {Boolean|'fade-in'|'slide-from-left'|'slide-from-top'|String}\n             * @default\n             * @category Misc\n             */\n            useInitialAnimation : true,\n            /**\n             * An empty function by default, but provided so that you can override it. This function is called each time\n             * an event is rendered into the schedule to render the contents of the event. It's called with the event,\n             * its resource and a `renderData` object which allows you to populate data placeholders inside the event\n             * template. **IMPORTANT** You should never modify any data on the EventModel inside this method.\n             *\n             * By default, the DOM markup of an event bar includes placeholders for 'cls' and 'style'. The cls property\n             * is a {@link Core.helper.util.DomClassList} which will be added to the event element. The style property\n             * is an inline style declaration for the event element.\n             *\n             * IMPORTANT: When returning content, be sure to consider how that content should be encoded to avoid XSS\n             * (Cross-Site Scripting) attacks. This is especially important when including user-controlled data such as\n             * the event's `name`. The function {@link Core.helper.StringHelper#function-encodeHtml-static} as well as\n             * {@link Core.helper.StringHelper#function-xss-static} can be helpful in these cases.\n             *\n             * ```javascript\n             *  eventRenderer({ eventRecord, resourceRecord, renderData }) {\n             *      renderData.style = 'color:white';                 // You can use inline styles too.\n             *\n             *      // Property names with truthy values are added to the resulting elements CSS class.\n             *      renderData.cls.isImportant = this.isImportant(eventRecord);\n             *      renderData.cls.isModified = eventRecord.isModified;\n             *\n             *      // Remove a class name by setting the property to false\n             *      renderData.cls[scheduler.generatedIdCls] = false;\n             *\n             *      // Or, you can treat it as a string, but this is less efficient, especially\n             *      // if your renderer wants to *remove* classes that may be there.\n             *      renderData.cls += ' extra-class';\n             *\n             *      return StringHelper.xss`${DateHelper.format(eventRecord.startDate, 'YYYY-MM-DD')}: ${eventRecord.name}`;\n             *  }\n             * ```\n             *\n             * @param {Object} detail An object containing the information needed to render an Event.\n             * @param {Scheduler.model.EventModel} detail.eventRecord The event record.\n             * @param {Scheduler.model.ResourceModel} detail.resourceRecord The resource record.\n             * @param {Scheduler.model.AssignmentModel} detail.assignmentRecord The assignment record.\n             * @param {Object} detail.renderData An object containing details about the event rendering.\n             * @param {Scheduler.model.EventModel} detail.renderData.event The event record.\n             * @param {Core.helper.util.DomClassList|String} detail.renderData.cls An object whose property names\n             * represent the CSS class names to be added to the event bar element. Set a property's value to truthy or\n             * falsy to add or remove the class name based on the property name. Using this technique, you do not have\n             * to know whether the class is already there, or deal with concatenation.\n             * @param {Core.helper.util.DomClassList|String} detail.renderData.wrapperCls An object whose property names\n             * represent the CSS class names to be added to the event wrapper element. Set a property's value to truthy\n             * or falsy to add or remove the class name based on the property name. Using this technique, you do not\n             * have to know whether the class is already there, or deal with concatenation.\n             * @param {Core.helper.util.DomClassList|String} detail.renderData.iconCls An object whose property names\n             * represent the CSS class names to be added to an event icon element.\n             *\n             * Note that an element carrying this icon class is injected into the event element *after*\n             * the renderer completes, *before* the renderer's created content.\n             *\n             * To disable this if the renderer takes full control and creates content using the iconCls,\n             * you can set `renderData.iconCls = null`.\n             * @param {Number} detail.renderData.left Vertical offset position (in pixels) on the time axis.\n             * @param {Number} detail.renderData.width Width in pixels of the event element.\n             * @param {Number} detail.renderData.height Height in pixels of the event element.\n             * @param {String|Object<String,String>} detail.renderData.style Inline styles for the event bar DOM element.\n             * Use either 'border: 1px solid black' or `{ border: '1px solid black' }`\n             * @param {String|Object<String,String>} detail.renderData.wrapperStyle Inline styles for wrapper of the\n             * event bar DOM element. Use either 'border: 1px solid green' or `{ border: '1px solid green' }`\n             * @param {String} detail.renderData.eventStyle The `eventStyle` of the event. Use this to apply custom\n             * styles to the event DOM element\n             * @param {String} detail.renderData.eventColor The `eventColor` of the event. Use this to set a custom\n             * color for the rendered event\n             * @param {DomConfig[]} detail.renderData.children An array of DOM configs used as children to the\n             * `b-sch-event` element. Can be populated with additional DOM configs to have more control over contents.\n             * @returns {String|Object|DomConfig|DomConfig[]} A simple string, or a custom object which will be applied to the\n             * {@link #config-eventBodyTemplate}, creating the actual HTML\n             * @config {Function}\n             * @category Scheduled events\n             */\n            eventRenderer : null,\n            /**\n             * `this` reference for the {@link #config-eventRenderer} function\n             * @config {Object}\n             * @category Scheduled events\n             */\n            eventRendererThisObj : null,\n            /**\n             * Field from EventModel displayed as text in the bar when rendering\n             * @config {String}\n             * @default\n             * @category Scheduled events\n             */\n            eventBarTextField : 'name',\n            /**\n             * The template used to generate the markup of your events in the scheduler. To 'populate' the\n             * eventBodyTemplate with data, use the {@link #config-eventRenderer} method.\n             * @config {Function}\n             * @param {*} data Data passed from {@link #config-eventRenderer} method.\n             * @returns {DomConfig|String|null}\n             * @deprecated Since 5.6.2. Return markup/DomConfigs from {@link #config-eventRenderer} instead, will be\n             * removed in 6.0.0\n             * @category Scheduled events\n             */\n            eventBodyTemplate : null,\n            /**\n             * The class responsible for the packing horizontal event layout process.\n             * Override this to take control over the layout process.\n             * @config {Scheduler.eventlayout.HorizontalLayout}\n             * @typings {typeof HorizontalLayout}\n             * @default\n             * @private\n             * @category Misc\n             */\n            horizontalLayoutPackClass : HorizontalLayoutPack,\n            /**\n             * The class name responsible for the stacking horizontal event layout process.\n             * Override this to take control over the layout process.\n             * @config {Scheduler.eventlayout.HorizontalLayout}\n             * @typings {typeof HorizontalLayout}\n             * @default\n             * @private\n             * @category Misc\n             */\n            horizontalLayoutStackClass : HorizontalLayoutStack,\n            /**\n             * Controls how much space to leave between stacked event bars in px.\n             *\n             * Can be configured per resource by setting {@link Scheduler.model.ResourceModel#field-barMargin\n             * resource.barMargin}.\n             *\n             * @config {Number} barMargin\n             * @default\n             * @category Scheduled events\n             */\n            // Used to animate events on first render\n            isFirstRender : true,\n            initialAnimationDuration : 2000,\n            /**\n             * When an event bar has a width less than this value, it gets the CSS class `b-sch-event-narrow`\n             * added. You may apply custom CSS rules using this class.\n             *\n             * In vertical mode, this class causes the text to be rotated so that it runs vertically.\n             * @default\n             * @config {Number}\n             * @category Scheduled events\n             */\n            narrowEventWidth : 10,\n            internalEventLayout : null,\n            eventPositionMode   : 'translate',\n            eventScrollMode     : 'move'\n        };\n    }\n    //endregion\n    //region Settings\n    changeEventLayout(eventLayout) {\n        // Pass layout config to internal config to normalize its form\n        this.internalEventLayout = eventLayout;\n        // Return normalized string type\n        return this.internalEventLayout.type;\n    }\n    changeInternalEventLayout(eventLayout) {\n        return this.getEventLayout(eventLayout);\n    }\n    updateInternalEventLayout(eventLayout, oldEventLayout) {\n        const me = this;\n        if (oldEventLayout) {\n            me.element.classList.remove(`b-eventlayout-${oldEventLayout.type}`);\n        }\n        me.element.classList.add(`b-eventlayout-${eventLayout.type}`);\n        if (!me.isConfiguring) {\n            me.refreshWithTransition();\n            me.trigger('stateChange');\n        }\n    }\n    changeHorizontalEventSorterFn(fn) {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Replaced by overlappingEventSorter()');\n        this.overlappingEventSorter = fn;\n    }\n    updateOverlappingEventSorter(fn) {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n        }\n    }\n    updateEventBodyTemplate() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Return markup/DomConfigs from eventRenderer() instead');\n    }\n    //endregion\n    //region Layout helpers\n    // Wraps string config to object with type\n    getEventLayout(value) {\n        if (value?.isModel) {\n            value = value.eventLayout || this.internalEventLayout;\n        }\n        if (typeof value === 'string') {\n            value = { type : value };\n        }\n        return value;\n    }\n    /**\n     * Get event layout handler. The handler decides the vertical placement of events within a resource.\n     * Returns null if no eventLayout is used (if {@link #config-eventLayout} is set to \"none\")\n     * @internal\n     * @returns {Scheduler.eventlayout.HorizontalLayout}\n     * @readonly\n     * @category Scheduled events\n     */\n    getEventLayoutHandler(eventLayout) {\n        const me = this;\n        if (!me.isHorizontal) {\n            return null;\n        }\n        const\n            { timeAxisViewModel, horizontal } = me,\n            { type }                          = eventLayout;\n        if (!me.layouts) {\n            me.layouts = {};\n        }\n        switch (type) {\n            // stack, adjust row height to fit all events\n            case 'stack': {\n                if (!me.layouts.horizontalStack) {\n                    me.layouts.horizontalStack = new me.horizontalLayoutStackClass(ObjectHelper.assign({\n                        scheduler                   : me,\n                        timeAxisViewModel,\n                        bandIndexToPxConvertFn      : horizontal.layoutEventVerticallyStack,\n                        bandIndexToPxConvertThisObj : horizontal\n                    }, eventLayout));\n                }\n                return me.layouts.horizontalStack;\n            }\n            // pack, fit all events in available height by adjusting their height\n            case 'pack': {\n                if (!me.layouts.horizontalPack) {\n                    me.layouts.horizontalPack = new me.horizontalLayoutPackClass(ObjectHelper.assign({\n                        scheduler                   : me,\n                        timeAxisViewModel,\n                        bandIndexToPxConvertFn      : horizontal.layoutEventVerticallyPack,\n                        bandIndexToPxConvertThisObj : horizontal\n                    }, eventLayout));\n                }\n                return me.layouts.horizontalPack;\n            }\n            default:\n                return null;\n        }\n    }\n    //endregion\n    //region Event rendering\n    // Chainable function called with the events to render for a specific resource. Allows features to add/remove.\n    // Chained by ResourceTimeRanges\n    getEventsToRender(resource, events) {\n        return events;\n    }\n    /**\n     * Rerenders events for specified resource (by rerendering the entire row).\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @category Rendering\n     */\n    repaintEventsForResource(resourceRecord) {\n        this.currentOrientation.repaintEventsForResource(resourceRecord);\n    }\n    /**\n     * Rerenders the events for all resources connected to the specified event\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @private\n     */\n    repaintEvent(eventRecord) {\n        const resources = this.eventStore.getResourcesForEvent(eventRecord);\n        resources.forEach(resourceRecord => this.repaintEventsForResource(resourceRecord));\n    }\n    getEventStyle(eventRecord, resourceRecord) {\n        return eventRecord.eventStyle || resourceRecord.eventStyle || this.eventStyle;\n    }\n    getEventColor(eventRecord, resourceRecord) {\n        return eventRecord.eventColor || eventRecord.event?.eventColor || eventRecord.parent?.eventColor || resourceRecord.eventColor || this.eventColor;\n    }\n    //endregion\n    //region Template\n    /**\n     * Generates data used in the template when rendering an event. For example which css classes to use. Also applies\n     * #eventBodyTemplate and calls the {@link #config-eventRenderer}.\n     * @private\n     * @param {Scheduler.model.EventModel} eventRecord Event to generate data for\n     * @param {Scheduler.model.ResourceModel} resourceRecord Events resource\n     * @param {Boolean|Object} includeOutside Specify true to get boxes for timespans outside the rendered zone in both\n     * dimensions. This option is used when calculating dependency lines, and we need to include routes from timespans\n     * which may be outside the rendered zone.\n     * @param {Boolean} includeOutside.timeAxis Pass as `true` to include timespans outside the TimeAxis's bounds\n     * @param {Boolean} includeOutside.viewport Pass as `true` to include timespans outside the vertical timespan viewport's bounds.\n     * @returns {Object} Data to use in event template, or `undefined` if the event is outside the rendered zone.\n     */\n    generateRenderData(eventRecord, resourceRecord, includeOutside = { viewport : true }) {\n        const\n            me               = this,\n            // generateRenderData calculates layout for events which are outside the vertical viewport\n            // because the RowManager needs to know a row height.\n            renderData       = me.currentOrientation.getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside),\n            { isEvent }      = eventRecord,\n            { eventResize }  = me.features,\n            // Don't want events drag created to zero duration to render as milestones\n            isMilestone      = !eventRecord.meta.isDragCreating && eventRecord.isMilestone,\n            // $originalId allows lookup to yield same result for original resources and linked resources\n            assignmentRecord = isEvent && eventRecord.assignments.find(a => a.resourceId === resourceRecord.$originalId),\n            // Events inner element, will be populated by renderer and/or eventBodyTemplate\n            eventContent     = {\n                className : 'b-sch-event-content',\n                role      : 'presentation',\n                dataset   : {\n                    taskBarFeature : 'content'\n                }\n            };\n        // Events excluded by time axis filtering get no renderData\n        if (renderData) {\n            renderData.tabIndex = '0';\n            let resizable = eventRecord.isResizable;\n            if (eventResize && resizable) {\n                if (renderData.startsOutsideView) {\n                    if (resizable === true) {\n                        resizable = 'end';\n                    }\n                    else if (resizable === 'start') {\n                        resizable = false;\n                    }\n                }\n                if (renderData.endsOutsideView) {\n                    if (resizable === true) {\n                        resizable = 'start';\n                    }\n                    else if (resizable === 'end') {\n                        resizable = false;\n                    }\n                }\n                // Let the feature veto start/end handles\n                if (resizable) {\n                    if (me.isHorizontal) {\n                        if ((!me.rtl && !eventResize.leftHandle) || (me.rtl && !eventResize.rightHandle)) {\n                            resizable = resizable === 'start' ? false : 'end';\n                        }\n                        else if ((!me.rtl && !eventResize.rightHandle) || (me.rtl && !eventResize.leftHandle)) {\n                            resizable = resizable === 'end' ? false : 'start';\n                        }\n                    }\n                    else {\n                        if (!eventResize.topHandle) {\n                            resizable = resizable === 'start' ? false : 'end';\n                        }\n                        else if (!eventResize.bottomHandle) {\n                            resizable = resizable === 'end' ? false : 'start';\n                        }\n                    }\n                }\n            }\n            // Event record cls properties are now DomClassList instances, so clone them\n            // so that they can be manipulated here and by renderers.\n            // Truthy value means the key will be added as a class name.\n            // ResourceTimeRanges applies custom cls to wrapper.\n            const\n                // Boolean needed here, otherwise DomSync will dig into comparing the modifications\n                isDirty           = Boolean(\n                    eventRecord.hasPersistableChanges || assignmentRecord?.hasPersistableChanges\n                ),\n                clsListObj        = {\n                    [resourceRecord.cls]      : resourceRecord.cls,\n                    [me.generatedIdCls]       : !eventRecord.isOccurrence && eventRecord.hasGeneratedId,\n                    [me.dirtyCls]             : isDirty,\n                    [me.committingCls]        : eventRecord.isCommitting,\n                    [me.endsOutsideViewCls]   : renderData.endsOutsideView,\n                    [me.startsOutsideViewCls] : renderData.startsOutsideView,\n                    'b-clipped-start'         : renderData.clippedStart,\n                    'b-clipped-end'           : renderData.clippedEnd,\n                    'b-iscreating'            : eventRecord.isCreating,\n                    'b-rtl'                   : me.rtl\n                },\n                wrapperClsListObj = {\n                    [`${me.eventCls}-parent`] : resourceRecord.isParent,\n                    'b-readonly'              : eventRecord.readOnly || assignmentRecord?.readOnly,\n                    'b-linked-resource'       : resourceRecord.isLinked,\n                    'b-original-resource'     : resourceRecord.hasLinks\n                },\n                clsList           = eventRecord.isResourceTimeRange ? new DomClassList() : eventRecord.internalCls.clone(),\n                wrapperClsList    = eventRecord.isResourceTimeRange ? eventRecord.internalCls.clone() : new DomClassList();\n            renderData.wrapperStyle = '';\n            // mark as wrapper to make sure fire render events for this level only\n            renderData.isWrap = true;\n            // Event specifics, things that do not apply to ResourceTimeRanges\n            if (isEvent) {\n                const selected = assignmentRecord && me.isAssignmentSelected(assignmentRecord);\n                ObjectHelper.assign(clsListObj, {\n                    [me.eventCls]                          : 1,\n                    'b-milestone'                          : isMilestone,\n                    'b-sch-event-narrow'                   : !isMilestone && renderData.width < me.narrowEventWidth,\n                    [me.fixedEventCls]                     : eventRecord.isDraggable === false,\n                    [`b-sch-event-resizable-${resizable}`] : Boolean(eventResize && !eventRecord.readOnly),\n                    [me.eventSelectedCls]                  : selected,\n                    [me.eventAssignHighlightCls]           : me.eventAssignHighlightCls && !selected && me.isEventSelected(eventRecord),\n                    'b-recurring'                          : eventRecord.isRecurring,\n                    'b-occurrence'                         : eventRecord.isOccurrence,\n                    'b-inactive'                           : eventRecord.inactive\n                });\n                renderData.eventId  = eventRecord.id;\n                const\n                    eventStyle   = me.getEventStyle(eventRecord, resourceRecord),\n                    eventColor   = me.getEventColor(eventRecord, resourceRecord),\n                    hasAnimation = me.isFirstRender && me.useInitialAnimation && globalThis.bryntum.noAnimations !== true;\n                ObjectHelper.assign(wrapperClsListObj, {\n                    [`${me.eventCls}-wrap`] : 1,\n                    'b-milestone-wrap'      : isMilestone,\n                    [me.navigator.focusCls] : eventRecord.assignments.some(a => a === me.activeAssignment)\n                });\n                if (hasAnimation) {\n                    const\n                        index   = renderData.row ? renderData.row.index : (renderData.top - me.scrollTop) / me.tickSize,\n                        delayMS = index / 20 * 1000;\n                    renderData.wrapperStyle = `animation-delay: ${delayMS}ms;`;\n                    me.maxDelay = Math.max(me.maxDelay || 0, delayMS);\n                    // Add an extra delay to wait for the most delayed animation to finish\n                    // before we call stopInitialAnimation. In this way, we allow them all to finish\n                    // before we remove the b-initial-${me._useInitialAnimation} class.\n                    if (!me.initialAnimationDetacher) {\n                        me.initialAnimationDetacher = EventHelper.on({\n                            element  : me.foregroundCanvas,\n                            delegate : me.eventSelector,\n                            // Just listen for the first animation end fired by our event els\n                            once         : true,\n                            animationend : () => me.setTimeout({\n                                fn                : 'stopInitialAnimation',\n                                delay             : me.maxDelay,\n                                cancelOutstanding : true\n                            }),\n                            // Fallback in case animation is interrupted\n                            expires : {\n                                alt   : 'stopInitialAnimation',\n                                delay : me.initialAnimationDuration + me.maxDelay\n                            },\n                            thisObj : me\n                        });\n                    }\n                }\n                renderData.eventColor = eventColor;\n                renderData.eventStyle = eventStyle;\n                renderData.assignmentRecord = renderData.assignment = assignmentRecord;\n            }\n            // If not using a wrapping div, this cls will be added to event div for correct rendering\n            renderData.wrapperCls = ObjectHelper.assign(wrapperClsList, wrapperClsListObj);\n            renderData.cls = ObjectHelper.assign(clsList, clsListObj);\n            renderData.iconCls = new DomClassList(eventRecord.getValue(me.eventBarIconClsField) || eventRecord.iconCls);\n            // ResourceTimeRanges applies custom style to the wrapper\n            if (eventRecord.isResourceTimeRange) {\n                renderData.style = '';\n                renderData.wrapperStyle += eventRecord.style || '';\n            }\n            // Others to inner\n            else {\n                renderData.style = eventRecord.style || '';\n            }\n            renderData.resource = renderData.resourceRecord = resourceRecord;\n            renderData.resourceId = renderData.rowId;\n            if (isEvent) {\n                let childContent = null,\n                    milestoneLabelConfig = null,\n                    value;\n                if (me.eventRenderer) {\n                    // User has specified a renderer fn, either to return a simple string, or an object intended for the eventBodyTemplate\n                    const\n                        rendererValue = me.eventRenderer.call(me.eventRendererThisObj || me, {\n                            eventRecord,\n                            resourceRecord,\n                            assignmentRecord : renderData.assignmentRecord,\n                            renderData\n                        });\n                    // If the user's renderer coerced it into a string, recreate a DomClassList.\n                    if (typeof renderData.cls === 'string') {\n                        renderData.cls = new DomClassList(renderData.cls);\n                    }\n                    if (typeof renderData.wrapperCls === 'string') {\n                        renderData.wrapperCls = new DomClassList(renderData.wrapperCls);\n                    }\n                    // Same goes for iconCls\n                    if (typeof renderData.iconCls === 'string') {\n                        renderData.iconCls = new DomClassList(renderData.iconCls);\n                    }\n                    if (me.eventBodyTemplate) {\n                        value = me.eventBodyTemplate(rendererValue);\n                    }\n                    else {\n                        value = rendererValue;\n                    }\n                }\n                else if (me.eventBodyTemplate) {\n                    // User has specified an eventBodyTemplate, but no renderer - just apply the entire event record data.\n                    value = me.eventBodyTemplate(eventRecord);\n                }\n                else if (me.eventBarTextField) {\n                    // User has specified a field in the data model to read from\n                    value = StringHelper.encodeHtml(eventRecord.getValue(me.eventBarTextField) || '');\n                }\n                if (!me.eventBodyTemplate || Array.isArray(value)) {\n                    eventContent.children = [];\n                    // Give milestone a dedicated label element so we can use padding\n                    if (isMilestone && (me.milestoneLayoutMode === 'default' || me.milestoneTextPosition === 'always-outside') && value != null && value !== '') {\n                        eventContent.children.unshift(milestoneLabelConfig = {\n                            tag      : 'label',\n                            children : []\n                        });\n                    }\n                    if (renderData.iconCls?.length) {\n                        eventContent.children.unshift({\n                            tag       : 'i',\n                            className : renderData.iconCls\n                        });\n                    }\n                    // Array, assumed to contain DOM configs for eventContent children (or milestone label)\n                    if (Array.isArray(value)) {\n                        (milestoneLabelConfig || eventContent).children.push(...value);\n                    }\n                    // Likely HTML content\n                    else if (StringHelper.isHtml(value)) {\n                        if (eventContent.children.length) {\n                            childContent = {\n                                tag   : 'span',\n                                class : 'b-event-text-wrap',\n                                html  : value\n                            };\n                        }\n                        else {\n                            eventContent.children = null;\n                            eventContent.html = value;\n                        }\n                    }\n                    // DOM config or plain string can be used as is\n                    else if (typeof value === 'string' || typeof value === 'object') {\n                        childContent = value;\n                    }\n                    // Other, use string\n                    else if (value != null) {\n                        childContent = String(value);\n                    }\n                    // Must allow empty string as valid content\n                    if (childContent != null) {\n                        // Milestones have content in their label, other events in their \"body\"\n                        (milestoneLabelConfig || eventContent).children.push(childContent);\n                        renderData.cls.add('b-has-content');\n                    }\n                    if (eventContent.html != null || eventContent.children.length) {\n                        renderData.children.push(eventContent);\n                    }\n                }\n                else {\n                    eventContent.html = value;\n                    renderData.children.push(eventContent);\n                }\n            }\n            const { eventStyle, eventColor, wrapperCls } = renderData;\n            // Renderers have last say on style & color\n            wrapperCls[`b-sch-style-${eventStyle || 'none'}`] = 1;\n            // Named colors are applied as a class to the wrapper\n            if (DomHelper.isNamedColor(eventColor)) {\n                wrapperCls[`b-sch-color-${eventColor}`] = eventColor;\n            }\n            else if (eventColor) {\n                const\n                    colorProp = eventStyle ? 'color' : 'background-color',\n                    style     = `${colorProp}:${eventColor};`;\n                renderData.style = style + renderData.style;\n                wrapperCls['b-sch-custom-color'] = 1;\n                renderData._customColorStyle = style; // Saves the styling string to be able to remove it if needed\n            }\n            else {\n                wrapperCls[`b-sch-color-none`] = 1;\n            }\n            // Milestones has to apply styling to b-sch-event-content\n            if (renderData.style && isMilestone && eventContent) {\n                eventContent.style = renderData.style;\n                delete renderData.style;\n            }\n            // If there are any iconCls entries...\n            renderData.cls['b-sch-event-withicon'] = renderData.iconCls?.length;\n            // For comparison in sync, cheaper than comparing DocumentFragments\n            renderData.eventContent = eventContent;\n            renderData.wrapperChildren = [];\n            // Method which features may chain in to\n            me.onEventDataGenerated(renderData);\n        }\n        return renderData;\n    }\n    /**\n     * A method which may be chained by features. It is called when an event's render\n     * data is calculated so that features may update the style, class list or body.\n     * @param {Object} eventData\n     * @internal\n     */\n    onEventDataGenerated(eventData) {}\n    //endregion\n    //region Initial animation\n    changeUseInitialAnimation(name) {\n        return name === true ? 'fade-in' : name;\n    }\n    updateUseInitialAnimation(name, old) {\n        const { classList } = this.element;\n        if (old) {\n            classList.remove(`b-initial-${old}`);\n        }\n        if (name) {\n            classList.add(`b-initial-${name}`);\n            // Transition block for FF, to not interfere with animations\n            if (BrowserHelper.isFirefox) {\n                classList.add('b-prevent-event-transitions');\n            }\n        }\n    }\n    /**\n     * Restarts initial events animation with new value {@link #config-useInitialAnimation}.\n     * @param {Boolean|String} initialAnimation new initial animation value\n     * @category Misc\n     */\n    restartInitialAnimation(initialAnimation) {\n        const me = this;\n        me.initialAnimationDetacher?.();\n        me.initialAnimationDetacher = null;\n        me.useInitialAnimation = initialAnimation;\n        me.isFirstRender = true;\n        me.refresh();\n    }\n    stopInitialAnimation() {\n        const me = this;\n        me.initialAnimationDetacher();\n        me.isFirstRender = false;\n        // Prevent any further initial animations\n        me.useInitialAnimation = false;\n        // Remove transition block for FF a bit later, to not interfere with animations\n        if (BrowserHelper.isFirefox) {\n            me.setTimeout(() => me.element.classList.remove('b-prevent-event-transitions'), 100);\n        }\n    }\n    //endregion\n    //region Milestones\n    /**\n     * Determines width of a milestones label. How width is determined is decided by configuring\n     * {@link #config-milestoneLayoutMode}. Please note that text width is always determined using the events\n     * {@link Scheduler/model/EventModel#field-name}.\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @returns {Number}\n     * @category Milestones\n     */\n    getMilestoneLabelWidth(eventRecord, resourceRecord) {\n        const\n            me   = this,\n            mode = me.milestoneLayoutMode,\n            size = me.getResourceLayoutSettings(resourceRecord).contentHeight;\n        if (mode === 'measure') {\n            const\n                html    = StringHelper.encodeHtml(eventRecord.name),\n                color   = me.getEventColor(eventRecord, resourceRecord),\n                style   = me.getEventStyle(eventRecord, resourceRecord),\n                element = me.milestoneMeasureElement || (me.milestoneMeasureElement = DomHelper.createElement({\n                    className : {\n                        'b-sch-event-wrap'       : 1,\n                        'b-milestone-wrap'       : 1,\n                        'b-measure'              : 1,\n                        [`b-sch-color-${color}`] : color,\n                        [`b-sch-style-${style}`] : style\n                    },\n                    children : [\n                        {\n                            className : 'b-sch-event b-milestone',\n                            children  : [\n                                {\n                                    className : 'b-sch-event-content',\n                                    children  : [\n                                        { tag : 'label' }\n                                    ]\n                                }\n                            ]\n                        }\n                    ],\n                    parent : me.foregroundCanvas\n                }));\n            // DomSync should not touch\n            element.retainElement = true;\n            element.style.fontSize = `${size}px`;\n            if (me.milestoneTextPosition === 'always-outside') {\n                const label = element.firstElementChild.firstElementChild.firstElementChild;\n                label.innerHTML = html;\n                const bounds = Rectangle.from(label, label.parentElement);\n                // +2 for a little margin\n                return bounds.left + bounds.width + 2;\n            }\n            else {\n                // b-sch-event-content\n                element.firstElementChild.firstElementChild.innerHTML = `<label></label>${html}`;\n                return element.firstElementChild.offsetWidth;\n            }\n        }\n        if (mode === 'estimate') {\n            return eventRecord.name.length * me.milestoneCharWidth + (me.milestoneTextPosition === 'always-outside' ? size : 0);\n        }\n        if (mode === 'data') {\n            return eventRecord.milestoneWidth;\n        }\n        return 0;\n    }\n    updateMilestoneLayoutMode(mode) {\n        const\n            me            = this,\n            alwaysOutside = me.milestoneTextPosition === 'always-outside';\n        me.element.classList.toggle('b-sch-layout-milestones', mode !== 'default' && !alwaysOutside);\n        me.element.classList.toggle('b-sch-layout-milestone-labels', mode !== 'default' && alwaysOutside);\n        if (!me.isConfiguring) {\n            me.refreshWithTransition();\n        }\n    }\n    updateMilestoneTextPosition(position) {\n        this.element.classList.toggle('b-sch-layout-milestone-text-position-inside', position === 'inside');\n        this.updateMilestoneLayoutMode(this.milestoneLayoutMode);\n    }\n    updateMilestoneAlign() {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n        }\n    }\n    updateMilestoneCharWidth() {\n        if (!this.isConfiguring) {\n            this.refreshWithTransition();\n        }\n    }\n    // endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport ProjectModel from '../../model/ProjectModel.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport TimeZoneHelper from '../../../Core/helper/TimeZoneHelper.js';\n/**\n * @module Scheduler/data/mixin/ProjectConsumer\n */\nconst engineStoreNames = [\n    'assignmentStore',\n    'dependencyStore',\n    'eventStore',\n    'resourceStore'\n];\n/**\n * Creates a Project using any configured stores, and sets the stores configured into the project into\n * the host object.\n *\n * @mixin\n */\nexport default Target => class ProjectConsumer extends (Target || Base) {\n    static get $name() {\n        return 'ProjectConsumer';\n    }\n    //region Default config\n    static get declarable() {\n        return ['projectStores'];\n    }\n    static get configurable() {\n        return {\n            projectModelClass : ProjectModel,\n            /**\n             * A {@link Scheduler.model.ProjectModel} instance or a config object. The project holds all Scheduler data.\n             * Can be omitted in favor of individual store configs or {@link Scheduler.view.mixin.SchedulerStores#config-crudManager} config.\n             *\n             * **Note:** In SchedulerPro the project is instance of SchedulerPro.model.ProjectModel class.\n             * @prp {Scheduler.model.ProjectModel|ProjectModelConfig} project\n             * @typings {ProjectModel|ProjectModelConfig}\n             * @category Data\n             */\n            project : {},\n            /**\n             * Configure as `true` to destroy the Project and stores when `this` is destroyed.\n             * @config {Boolean}\n             * @category Data\n             */\n            destroyStores : null,\n            // Will be populated by AttachToProjectMixin which features mix in\n            projectSubscribers : []\n        };\n    }\n    #suspendedByRestore;\n    //endregion\n    startConfigure(config) {\n        // process the project first which ingests any configured data sources,\n        this.getConfig('project');\n        super.startConfigure(config);\n    }\n    //region Project\n    // This is where all the ingestion happens.\n    // At config time, the changers inject incoming values into the project config object\n    // that we are building. At the end we instantiate the project with all incoming\n    // config values filled in.\n    changeProject(project, oldProject) {\n        const\n            me = this,\n            {\n                projectStoreNames,\n                projectDataNames\n            }  = me.constructor;\n        me.projectCallbacks = new Set();\n        if (project) {\n            // Flag for changes to know what stage we are at\n            me.buildingProjectConfig = true;\n            if (!project.isModel) {\n                // When configuring, prio order:\n                // 1. If using an already existing CrudManager, it is assumed to already have the stores we should use,\n                //    adopt them as ours.\n                // 2. If a supplied store already has a project, it is assumed to be shared with another scheduler and\n                //    that project is adopted as ours. Unless we are given some store not part of that project,\n                //    in which case we create a new project.\n                // 3. Use stores from a supplied project config.\n                // 4. Use stores configured on scheduler.\n                // + Pass on inline data (events, resources, dependencies, assignments -> xxData on the project config)\n                //\n                // What happens during project initialization is this:\n                // this._project is the project *config* object.\n                // changeXxxx methods put incoming values directly into it through this.project\n                // to be used as its configuration.\n                // So when it is instantiated, it has had all configs injected.\n                if (me.isConfiguring) {\n                    // Set property for changers to put incoming values into\n                    me._project = project;\n                    // crudManager will be a clone of the raw config if it is a raw config.\n                    const { crudManager } = me;\n                    // Pull in stores from the crudManager config first\n                    if (crudManager) {\n                        const { isCrudManager } = crudManager;\n                        for (const storeName of projectStoreNames) {\n                            if (crudManager[storeName]) {\n                                // We configure the project with the stores, and *not* the CrudManager.\n                                // The CrudManager ends up having its project set and thereby adopting ours.\n                                me[storeName] = crudManager[storeName];\n                                // If it's just a config, take the stores out.\n                                // We will *configure* it with this project and it will ingest\n                                // its stores from there.\n                                if (!isCrudManager) {\n                                    delete crudManager[storeName];\n                                }\n                            }\n                        }\n                    }\n                    // Pull in all our configured stores into the project config object.\n                    // That also extracts any project into this.sharedProject\n                    me.getConfig('projectStores');\n                    // Referencing these data configs causes them to be pulled into\n                    // the _project.xxxData config property if they are present.\n                    for (const dataName of projectDataNames) {\n                        me.getConfig(dataName);\n                    }\n                }\n                const { eventStore } = project;\n                let { sharedProject : sharedProject } = me;\n                // Delay autoLoading until listeners are set up, to be able to inject params\n                if (eventStore && !eventStore.isEventStoreMixin && eventStore.autoLoad && !eventStore.count) {\n                    eventStore.autoLoad = false;\n                    me.delayAutoLoad = true;\n                }\n                // We should not adopt a project from a store if we are given any store not part of that project\n                if (sharedProject && engineStoreNames.some(store => project[store] && project[store] !== sharedProject[store])) {\n                    // We have to chain any store used by the other project, they can only belong to one\n                    for (const store of engineStoreNames) {\n                        if (project[store] && project[store] === sharedProject[store]) {\n                            project[store] = project[store].chain();\n                        }\n                    }\n                    sharedProject = null;\n                }\n                // Use sharedProject if found, else instantiate our config.\n                project = sharedProject || new me.projectModelClass(project);\n                // Clear the property so that the updater is called.\n                delete me._project;\n            }\n            // In the updater, configs are live\n            me.buildingProjectConfig = false;\n        }\n        return project;\n    }\n    /**\n     * Implement in subclass to take action when project is replaced.\n     *\n     * __`super.updateProject(...arguments)` must be called first.__\n     *\n     * @param {Scheduler.model.ProjectModel} project\n     * @category Data\n     */\n    updateProject(project, oldProject) {\n        const\n            me = this,\n            {\n                projectListeners,\n                crudManager\n            }  = me;\n        me.detachListeners('projectConsumer');\n        // When we set the crudManager now, it will go through to the CrudManagerVIew\n        delete me._crudManager;\n        if (project) {\n            projectListeners.thisObj = me;\n            project.ion(projectListeners);\n            // If the project is a CrudManager, use it as such.\n            if (project.isCrudManager) {\n                me.crudManager = project;\n            }\n            // Apply the project to CrudManager, making sure the same stores are used there and here\n            else if (crudManager) {\n                crudManager.project = project;\n                // CrudManager goes through the changer as usual and is initialized\n                // from the Project, not any stores it was originally configured with.\n                me.crudManager = crudManager;\n            }\n            // Notifies classes that mix AttachToProjectMixin that we have a new project\n            me.projectSubscribers.forEach(subscriber => {\n                subscriber.detachFromProject(oldProject);\n                subscriber.attachToProject(project);\n            });\n            // Sets the project's stores into the host object\n            for (const storeName of me.constructor.projectStoreNames) {\n                me[storeName] = project[storeName];\n            }\n            // Listeners are set up, if EventStore was configured with autoLoad now is the time to load\n            if (me.delayAutoLoad) {\n                // Restore the flag, not needed but to look good on inspection\n                project.eventStore.autoLoad = true;\n                project.eventStore.load();\n            }\n            project.stm?.ion({\n                name           : 'projectConsumer',\n                restoringStart : 'onProjectRestoringStart',\n                restoringStop  : 'onProjectRestoringStop',\n                thisObj        : me\n            });\n        }\n        me.trigger('projectChange', { project });\n    }\n    // Implementation here because we need to get first look at it to adopt its stores\n    changeCrudManager(crudManager) {\n        // Set the property to be scanned for incoming stores.\n        // If it's a config, it will be stripped of those stores prior to construction.\n        if (this.buildingProjectConfig) {\n            this._crudManager = crudManager.isCrudManager ? crudManager : Object.assign({}, crudManager);\n        }\n        else {\n            return super.changeCrudManager(crudManager);\n        }\n    }\n    // Called when project changes are committed, after data is written back to records\n    onProjectDataReady() {\n        const me = this;\n        // Only update the UI when we are visible\n        me.whenVisible(() => {\n            if (me.projectCallbacks.size) {\n                me.projectCallbacks.forEach(callback => callback());\n                me.projectCallbacks.clear();\n            }\n        }, null, null, 'onProjectDataReady');\n    }\n    onProjectRestoringStart({ stm }) {\n        const { rawQueue } = stm;\n        // Suspend refresh if undo/redo potentially leads to multiple refreshes\n        if (rawQueue.length && rawQueue[rawQueue.length - 1].length > 1) {\n            this.#suspendedByRestore = true;\n            this.suspendRefresh();\n        }\n    }\n    onProjectRestoringStop() {\n        if (this.#suspendedByRestore) {\n            this.#suspendedByRestore = false;\n            this.resumeRefresh(true);\n        }\n    }\n    // Overridden in CalendarStores.js\n    onBeforeTimeZoneChange() {}\n    // When project changes time zone, change start and end dates\n    onTimeZoneChange({ timeZone, oldTimeZone }) {\n        const me = this;\n        // The timeAxis timeZone could be equal to timeZone if we are a partnered scheduler\n        if (me.startDate && me.timeAxis.timeZone !== timeZone) {\n            const startDate = oldTimeZone != null ? TimeZoneHelper.fromTimeZone(me.startDate, oldTimeZone) : me.startDate;\n            me.startDate = timeZone != null ? TimeZoneHelper.toTimeZone(startDate, timeZone) : startDate;\n            // Saves the timeZone on the timeAxis as it is shared between partnered schedulers\n            me.timeAxis.timeZone = timeZone;\n        }\n    }\n    onStartApplyChangeset() {\n        this.suspendRefresh();\n    }\n    onEndApplyChangeset() {\n        this.resumeRefresh(true);\n    }\n    /**\n     * Accepts a callback that will be called when the underlying project is ready (no commit pending and current commit\n     * finalized)\n     * @param {Function} callback\n     * @category Data\n     */\n    whenProjectReady(callback) {\n        // Might already be ready, call directly\n        if (this.isEngineReady) {\n            callback();\n        }\n        else {\n            this.projectCallbacks.add(callback);\n        }\n    }\n    /**\n     * Returns `true` if engine is in a stable calculated state, `false` otherwise.\n     * @property {Boolean}\n     * @category Misc\n     */\n    get isEngineReady() {\n        // NonWorkingTime calls this during destruction, hence the ?.\n        return Boolean(this.project.isEngineReady?.());\n    }\n    //endregion\n    //region Destroy\n    // Cleanup, destroys stores if this.destroyStores is true.\n    doDestroy() {\n        super.doDestroy();\n        if (this.destroyStores) {\n            // Shared project might already be destroyed\n            !this.project.isDestroyed && this.project.destroy();\n        }\n    }\n    //endregion\n    get projectStores() {\n        const { projectStoreNames } = this.constructor;\n        return projectStoreNames.map(storeName => this[storeName]);\n    }\n    static get projectStoreNames() {\n        return Object.keys(this.projectStores);\n    }\n    static get projectDataNames() {\n        return this.projectStoreNames.reduce((result, storeName) => {\n            const { dataName } = this.projectStores[storeName];\n            if (dataName) {\n                result.push(dataName);\n            }\n            return result;\n        }, []);\n    }\n    static setupProjectStores(cls, meta) {\n        const { projectStores } = cls;\n        if (projectStores) {\n            const\n                projectListeners  = {\n                    name                 : 'projectConsumer',\n                    dataReady            : 'onProjectDataReady',\n                    change               : 'relayProjectDataChange',\n                    beforeTimeZoneChange : 'onBeforeTimeZoneChange',\n                    timeZoneChange       : 'onTimeZoneChange',\n                    startApplyChangeset  : 'onStartApplyChangeset',\n                    endApplyChangeset    : 'onEndApplyChangeset'\n                },\n                storeConfigs      = {\n                    projectListeners\n                };\n            let previousDataName;\n            // Create a property and updater for each dataName and a changer for each store\n            for (const storeName in projectStores) {\n                const { dataName } = projectStores[storeName];\n                // Define \"eventStore\" and \"events\" configs\n                storeConfigs[storeName] = storeConfigs[dataName] = null;\n                // Define up the \"events\" property\n                if (dataName) {\n                    // Getter to return store data\n                    Object.defineProperty(meta.class.prototype, dataName, {\n                        configurable : true, // So that Config can add its setter.\n                        get() {\n                            // get events() { return this.project.eventStore.records; }\n                            return this.project[storeName]?.records;\n                        }\n                    });\n                    // Create an updater for the data name;\n                    this.createDataUpdater(storeName, dataName, previousDataName, meta);\n                }\n                this.createStoreDescriptor(meta, storeName, projectStores[storeName], projectListeners);\n                // The next data updater must reference this data name\n                previousDataName = dataName;\n            }\n            // Create the projectListeners config.\n            this.setupConfigs(meta, storeConfigs);\n        }\n    }\n    static createDataUpdater(storeName, dataName, previousDataName, meta) {\n        // Create eg \"updateEvents(data)\".\n        // We need it to call this.getConfig('resources') so that ordering of\n        // data ingestion is corrected.\n        meta.class.prototype[`update${StringHelper.capitalize(dataName)}`] = function(data) {\n            const { project } = this;\n            // Ensure a dataName that we depend on is called in.\n            // For example dependencies must load in order after the events.\n            previousDataName && this.getConfig(previousDataName);\n            if (this.buildingProjectConfig) {\n                // Set the property in the project config object.\n                // eg project.eventsData = [...]\n                project[`${dataName}Data`] = data;\n            }\n            else {\n                // Live update the project when in use.\n                project[storeName].data = data;\n            }\n        };\n    }\n    // eslint-disable-next-line bryntum/no-listeners-in-lib\n    static createStoreDescriptor(meta, storeName, { listeners }, projectListeners) {\n        const\n            { prototype : clsProto } = meta.class,\n            storeNameCap             = StringHelper.capitalize(storeName);\n        // Set up onProjectEventStoreChange to set this.eventStore\n        projectListeners[`${storeName}Change`] = function({ store }) {\n            this[storeName] = store;\n        };\n        // create changeEventStore\n        clsProto[`change${storeNameCap}`] = function(store, oldStore) {\n            const\n                me           = this,\n                { project }  = me,\n                storeProject = store?.project;\n            if (me.buildingProjectConfig) {\n                // Capture any project found at project config time\n                // to use as our shared project\n                if (storeProject?.isProjectModel) {\n                    me.sharedProject = storeProject;\n                }\n                // Set the property in the project config object.\n                // Must not go through the updater. It's too early to\n                // inform host of store change.\n                project[storeName] = store;\n                return;\n            }\n            // Live update the project when in use.\n            if (!me.initializingProject) {\n                if (project[storeName] !== store) {\n                    project[`set${storeNameCap}`](store);\n                    store = project[storeName];\n                }\n            }\n            // Implement processing here instead of creating a separate updater.\n            // Subclasses can implement updaters.\n            if (store !== oldStore) {\n                if (listeners) {\n                    listeners.thisObj = me;\n                    listeners.name = `${storeName}Listeners`;\n                    // Ensure we don't trigger one refresh per record during data loading\n                    listeners.startApplyChangeset = 'onProjectStoreStartApplyChangeset';\n                    listeners.endApplyChangeset = 'onProjectStoreEndApplyChangeset';\n                    me.detachListeners(listeners.name);\n                    store.ion(listeners);\n                }\n                // Set backing var temporarily, so it can be accessed from AttachToProjectMixin subscribers\n                me[`_${storeName}`] = store;\n                // Notifies classes that mix AttachToProjectMixin that we have a new XxxxxStore\n                me.projectSubscribers.forEach(subscriber => {\n                    subscriber[`attachTo${storeNameCap}`]?.(store);\n                });\n                me[`_${storeName}`] = null;\n            }\n            return store;\n        };\n    }\n    onProjectStoreStartApplyChangeset() {\n        this.suspendRefresh();\n    }\n    onProjectStoreEndApplyChangeset() {\n        this.resumeRefresh(true);\n    }\n    relayProjectDataChange(event) {\n        // Don't trigger change event for tree node collapse/expand\n        if ((event.isExpand || event.isCollapse) && !event.records[0].fieldMap.expanded.persist) {\n            return;\n        }\n        /**\n         * Fired when data in any of the projects stores changes.\n         *\n         * Basically a relayed version of each store's own change event, decorated with which store it originates from.\n         * See the {@link Core.data.Store#event-change store change event} documentation for more information.\n         *\n         * @event dataChange\n         * @param {Scheduler.data.mixin.ProjectConsumer} source Owning component\n         * @typings source -> {typeof Scheduler.data.mixin.ProjectConsumer||any}\n         * @param {Scheduler.model.mixin.ProjectModelMixin} project Project model\n         * @typings project -> {typeof Scheduler.model.mixin.ProjectModelMixin||any}\n         * @param {Core.data.Store} store Affected store\n         * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action\n         * Name of action which triggered the change. May be one of:\n         * * `'remove'`\n         * * `'removeAll'`\n         * * `'add'`\n         * * `'updatemultiple'`\n         * * `'clearchanges'`\n         * * `'filter'`\n         * * `'update'`\n         * * `'dataset'`\n         * * `'replace'`\n         * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)\n         * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`\n         * @param {Object} changes Passed for the `'update'` action, info on which record fields changed\n         */\n        return this.trigger('dataChange', { project : event.source, ...event, source : this });\n    }\n    //region WidgetClass\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport Store from '../../../Core/data/Store.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\nimport ProjectConsumer from '../../data/mixin/ProjectConsumer.js';\n/**\n * @module Scheduler/view/mixin/SchedulerStores\n */\n/**\n * Functions for store assignment and store event listeners.\n *\n * @mixin\n * @extends Scheduler/data/mixin/ProjectConsumer\n */\nexport default Target => class SchedulerStores extends ProjectConsumer(Target || Base) {\n    static get $name() {\n        return 'SchedulerStores';\n    }\n    //region Default config\n    // This is the static definition of the Stores we consume from the project, and\n    // which we must provide *TO* the project if we or our CrudManager is configured\n    // with them.\n    // The property name is the store name, and within that there is the dataName which\n    // is the property which provides static data definition. And there is a listeners\n    // definition which specifies the listeners *on this object* for each store.\n    //\n    // To process incoming stores, implement an updateXxxxxStore method such\n    // as `updateEventStore(eventStore)`.\n    //\n    // To process an incoming Project implement `updateProject`. __Note that\n    // `super.updateProject(...arguments)` must be called first.__\n    static get projectStores() {\n        return {\n            resourceStore : {\n                dataName : 'resources'\n            },\n            eventStore : {\n                dataName  : 'events',\n                // eslint-disable-next-line bryntum/no-listeners-in-lib\n                listeners : {\n                    batchedUpdate   : 'onEventStoreBatchedUpdate',\n                    changePreCommit : 'onInternalEventStoreChange',\n                    commitStart     : 'onEventCommitStart',\n                    commit          : 'onEventCommit',\n                    exception       : 'onEventException',\n                    idchange        : 'onEventIdChange',\n                    beforeLoad      : 'onBeforeLoad'\n                }\n            },\n            assignmentStore : {\n                dataName  : 'assignments',\n                // eslint-disable-next-line bryntum/no-listeners-in-lib\n                listeners : {\n                    changePreCommit : 'onAssignmentChange', // In EventSelection.js\n                    commitStart     : 'onAssignmentCommitStart',\n                    commit          : 'onAssignmentCommit',\n                    exception       : 'onAssignmentException',\n                    beforeRemove    : {\n                        fn   : 'onAssignmentBeforeRemove',\n                        // We must go last in case an app vetoes a remove\n                        // by returning false from a handler.\n                        prio : -1000\n                    }\n                }\n            },\n            dependencyStore : {\n                dataName : 'dependencies'\n            },\n            calendarManagerStore   : {},\n            timeRangeStore         : {},\n            resourceTimeRangeStore : {}\n        };\n    }\n    static get configurable() {\n        return {\n            /**\n             * Overridden to *not* auto create a store at the Scheduler level.\n             * The store is the {@link Scheduler.data.ResourceStore} of the backing project\n             * @config {Core.data.Store}\n             * @private\n             */\n            store : null,\n            /**\n             * The name of the start date parameter that will be passed to in every `eventStore` load request.\n             * @config {String}\n             * @category Data\n             */\n            startParamName : 'startDate',\n            /**\n             * The name of the end date parameter that will be passed to in every `eventStore` load request.\n             * @config {String}\n             * @category Data\n             */\n            endParamName : 'endDate',\n            /**\n             * Set to true to include `startDate` and `endDate` params indicating the currently viewed date range.\n             * Dates are formatted using the same format as the `startDate` field on the EventModel\n             * (e.g. 2023-03-08T00:00:00+01:00).\n             *\n             * Enabled by default in version 6.0 and above.\n             *\n             * @config {Boolean}\n             */\n            passStartEndParameters : VersionHelper.checkVersion('core', '6.0', '>='),\n            /**\n             * Class that should be used to instantiate a CrudManager in case it's provided as a simple object to\n             * {@link #config-crudManager} config.\n             * @config {Scheduler.data.CrudManager}\n             * @typings {typeof CrudManager}\n             * @category Data\n             */\n            crudManagerClass : null,\n            /**\n             * Get/set the CrudManager instance\n             * @member {Scheduler.data.CrudManager} crudManager\n             * @category Data\n             */\n            /**\n             * Supply a {@link Scheduler.data.CrudManager} instance or a config object if you want to use\n             * CrudManager for handling data.\n             * @config {CrudManagerConfig|Scheduler.data.CrudManager}\n             * @category Data\n             */\n            crudManager : null\n        };\n    }\n    //endregion\n    //region Project\n    updateProject(project, oldProject) {\n        super.updateProject(project, oldProject);\n        this.detachListeners('schedulerStores');\n        project.ion({\n            name    : 'schedulerStores',\n            refresh : 'onProjectRefresh',\n            thisObj : this\n        });\n    }\n    // Called when project changes are committed, before data is written back to records (but still ready to render\n    // since data is fetched from engine)\n    onProjectRefresh({ isInitialCommit }) {\n        const me = this;\n        // Only update the UI immediately if we are visible\n        if (me.isVisible) {\n            if (isInitialCommit) {\n                if (me.isVertical) {\n                    me.refreshAfterProjectRefresh = false;\n                    me.refreshWithTransition();\n                }\n            }\n            if (me.refreshAfterProjectRefresh) {\n                me.refreshWithTransition(false, !isInitialCommit);\n                me.refreshAfterProjectRefresh = false;\n            }\n            if (me.navigateToAfterRefresh) {\n                me.navigateTo(me.navigateToAfterRefresh, {\n                    scrollIntoView : false\n                });\n                me.navigateToAfterRefresh = null;\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            me.whenVisible('refresh', me, [true]);\n        }\n    }\n    //endregion\n    //region CrudManager\n    changeCrudManager(crudManager) {\n        const me = this;\n        if (crudManager && !crudManager.isCrudManager) {\n            // CrudManager injects itself into is Scheduler's _crudManager property\n            // because code it triggers needs to access it through its getter.\n            crudManager = me.crudManagerClass.new({\n                scheduler : me\n            }, crudManager);\n        }\n        // config setter will veto because of above described behaviour\n        // of setting the property early on creation\n        me._crudManager = crudManager;\n        me.bindCrudManager(crudManager);\n    }\n    //endregion\n    //region Row store\n    get store() {\n        // Vertical uses a dummy store\n        if (!this._store && this.isVertical) {\n            this._store = new Store({\n                data : [\n                    {\n                        id  : 'verticalTimeAxisRow', \n                        cls : 'b-verticaltimeaxis-row'\n                    }\n                ]\n            });\n        }\n        return super.store;\n    }\n    set store(store) {\n        super.store = store;\n    }\n    // Wrap w/ transition refreshFromRowOnStoreAdd() inherited from Grid\n    refreshFromRowOnStoreAdd(row, { isExpand, records }) {\n        const args = arguments;\n        this.runWithTransition(() => {\n            // Postpone drawing of events for a new resource until the following project refresh. Previously the draw\n            // would not happen because engine was not ready, but now when we allow commits and can read values during\n            // commit that block is no longer there\n            this.currentOrientation.suspended = !isExpand && !records.some(r => r.isLinked);\n            super.refreshFromRowOnStoreAdd(row, ...args);\n            this.currentOrientation.suspended = false;\n        }, !isExpand);\n    }\n    onStoreAdd(event) {\n        super.onStoreAdd(event);\n        if (this.isPainted) {\n            this.calculateRowHeights(event.records);\n        }\n    }\n    onStoreUpdateRecord({ source : store, record, changes }) {\n        // Ignore engine changes that do not affect row rendering\n        let ignoreCount = 0;\n        if ('assigned' in changes) {\n            ignoreCount++;\n        }\n        if ('calendar' in changes) {\n            ignoreCount++;\n        }\n        if (ignoreCount !== Object.keys(changes).length) {\n            super.onStoreUpdateRecord(...arguments);\n        }\n    }\n    //endregion\n    //region ResourceStore\n    updateResourceStore(resourceStore) {\n        // Reconfigure grid if resourceStore is backing the rows\n        if (resourceStore && this.isHorizontal) {\n            resourceStore.metaMapId = this.id;\n            this.store = resourceStore;\n        }\n    }\n    get usesDisplayStore() {\n        return this.store !== this.resourceStore;\n    }\n    //endregion\n    //region Events\n    onEventIdChange(params) {\n        this.currentOrientation.onEventStoreIdChange && this.currentOrientation.onEventStoreIdChange(params);\n    }\n    /**\n     * Listener to the batchedUpdate event which fires when a field is changed on a record which\n     * is batch updating. Occasionally UIs must keep in sync with batched changes.\n     * For example, the EventResize feature performs batched updating of the startDate/endDate\n     * and it tells its client to listen to batchedUpdate.\n     * @private\n     */\n    onEventStoreBatchedUpdate(event) {\n        if (this.listenToBatchedUpdates) {\n            return this.onInternalEventStoreChange(event);\n        }\n    }\n    /**\n     * Calls appropriate functions for current event layout when the event store is modified.\n     * @private\n     */\n    // Named as Internal to avoid naming collision with wrappers that relay events\n    onInternalEventStoreChange(params) {\n        // Too early, bail out\n        // Also bail out if this is a reassign using resourceId, any updates will be handled by AssignmentStore instead\n        if (!this.isPainted || !this._mode || params.isAssign || this.assignmentStore.isRemovingAssignment) {\n            return;\n        }\n        // Only respond if we are visible. If not, defer until we are shown\n        if (this.isVisible) {\n            this.currentOrientation.onEventStoreChange(params);\n        }\n        else {\n            this.whenVisible(this.onInternalEventStoreChange, this, [params]);\n        }\n    }\n    /**\n     * Refreshes committed events, to remove dirty/committing flag.\n     * CSS is added\n     * @private\n     */\n    onEventCommit({ changes }) {\n        let resourcesToRepaint = [...changes.added, ...changes.modified].map(\n            eventRecord => this.eventStore.getResourcesForEvent(eventRecord)\n        );\n        // getResourcesForEvent returns an array, so need to flatten resourcesToRepaint\n        resourcesToRepaint = Array.prototype.concat.apply([], resourcesToRepaint);\n        // repaint relevant resource rows\n        new Set(resourcesToRepaint).forEach(\n            resourceRecord => this.repaintEventsForResource(resourceRecord)\n        );\n    }\n    /**\n     * Adds the committing flag to changed events before commit.\n     * @private\n     */\n    onEventCommitStart({ changes }) {\n        const { currentOrientation, committingCls } = this;\n        // Committing sets a flag in meta that during event rendering applies a CSS class. But to not mess up drag and\n        // drop between resources no redraw is performed before committing, so class is never applied to the element(s).\n        // Applying here instead\n        [...changes.added, ...changes.modified].forEach(eventRecord =>\n            eventRecord.assignments.forEach(\n                assignmentRecord => currentOrientation.toggleCls(assignmentRecord, committingCls, true)\n            )\n        );\n    }\n    // Clear committing flag\n    onEventException({ action }) {\n        if (action === 'commit') {\n            const { changes } = this.eventStore;\n            [...changes.added, ...changes.modified, ...changes.removed].forEach(eventRecord =>\n                this.repaintEvent(eventRecord)\n            );\n        }\n    }\n    onAssignmentCommit({ changes }) {\n        this.repaintEventsForAssignmentChanges(changes);\n    }\n    onAssignmentCommitStart({ changes }) {\n        const { currentOrientation, committingCls } = this;\n        [...changes.added, ...changes.modified].forEach(assignmentRecord => {\n            currentOrientation.toggleCls(assignmentRecord, committingCls, true);\n        });\n    }\n    // Clear committing flag\n    onAssignmentException({ action }) {\n        if (action === 'commit') {\n            this.repaintEventsForAssignmentChanges(this.assignmentStore.changes);\n        }\n    }\n    repaintEventsForAssignmentChanges(changes) {\n        const resourcesToRepaint = [...changes.added, ...changes.modified, ...changes.removed].map(\n            assignmentRecord => assignmentRecord.getResource()\n        );\n        // repaint relevant resource rows\n        new Set(resourcesToRepaint).forEach(\n            resourceRecord => this.repaintEventsForResource(resourceRecord)\n        );\n    }\n    onAssignmentBeforeRemove({ records, removingAll }) {\n        if (removingAll) {\n            return;\n        }\n        const\n            me                       = this,\n            { activeAssignment }     = me,\n            deletingActiveAssignment = records.includes(activeAssignment);\n        let moveTo;\n        // Deassigning the active assignment\n        if (!me.isConfiguring &&\n            // If we have current active assignment or we scheduled navigating to an assignment, we should check\n            // if we're removing that assignment in order to avoid navigating to it\n            (me.navigateToAfterRefresh || activeAssignment && deletingActiveAssignment)\n        ) {\n            // If next navigation target is removed, clean up the flag\n            if (records.includes(me.navigateToAfterRefresh)) {\n                me.navigateToAfterRefresh = null;\n            }\n            const fromEl = me.getElementFromAssignmentRecord(activeAssignment, true);\n            // When deleting active assignment, if still part of this scheduler (when dragging to another, it might not\n            // be in Safari where focus out happens later), look for a close target until we find an existing record,\n            // not scheduled for removal and in view. Otherwise, push focus to the Scheduler.\n            if (deletingActiveAssignment && fromEl) {\n                const\n                    viewport     = me.timeAxisSubGrid.rectangle().intersect(me._bodyRectangle),\n                    fromRect     = Rectangle.from(fromEl),\n                    fromCenter   = fromRect.center,\n                    resourceDim  = me.isHorizontal ? 'y' : 'x',\n                    distanceSort = ({ element : e1, distance : d1, center : c1, edgeDistance : ed1 }, { element : e2, distance : d2, center : c2, edgeDistance : ed2 }) => {\n                        // Sort blocks which are closer in the Y axis to earlier\n                        // Unless we're in the same row, in which case use only distance.\n                        if (e1.dataset.resourceId !== e2.dataset.resourceId) {\n                            if (Math.abs(c1[resourceDim] - fromCenter[resourceDim]) < Math.abs(c2[resourceDim] - fromCenter[resourceDim])) {\n                                return -1;\n                            }\n                            if (Math.abs(c1[resourceDim] - fromCenter[resourceDim]) > Math.abs(c2[resourceDim] - fromCenter[resourceDim])) {\n                                return 1;\n                            }\n                        }\n                        return Math.min(ed1, d1) - Math.min(ed2, d2) || c2[resourceDim] - c1[resourceDim];\n                    },\n                    to = Array.from(me.foregroundCanvas.querySelectorAll(me.navigator.itemSelector)).reduce((result, element) => {\n                        // Don't consider the from element\n                        if (element !== fromEl) {\n                            const\n                                rectangle  = Rectangle.from(element).intersect(viewport),\n                                assignment = rectangle && me.resolveAssignmentRecord(element);\n                            // If there's an intersection with the viewport, add to candidate array\n                            if (assignment) {\n                                const\n                                    { center } = rectangle,\n                                    d          = fromCenter.getDelta(center),\n                                    vertGap    = center.y < fromCenter.y ? fromRect.y - rectangle.bottom : center.y > fromCenter.y ? rectangle.y - fromRect.bottom : 0,\n                                    horizGap   = center.x < fromCenter.x ? fromRect.x - rectangle.right  : center.x > fromCenter.x ? rectangle.x - fromRect.right  : 0;\n                                result.push({\n                                    element,\n                                    assignment,\n                                    center,\n                                    distance     : Math.sqrt(d[0] ** 2 + d[1] ** 2),\n                                    edgeDistance : Math.max(\n                                        vertGap, horizGap\n                                    )\n                                });\n                            }\n                        }\n                        return result;\n                    }, []).sort(distanceSort)[0];\n                if (to) {\n                    moveTo  = to.assignment;\n                }\n            }\n            // Move focus away from the element which will soon have no backing data.\n            // Only if a UI element for it is in view.\n            if (moveTo) {\n                // Although removing records from assignment store will trigger project commit and consequently\n                // `refresh` event on the project which will use this record to navigate to, some tests expect\n                // immediate navigation\n                me.navigateTo(moveTo, {\n                    scrollIntoView : false\n                });\n                me.navigateToAfterRefresh = moveTo;\n            }\n            // Focus must exit the Scheduler's subgrid, otherwise, if a navigation\n            // key gesture is delivered before the outgoing event's element has faded\n            // out and been removed, navigation will be attempted from a deleted\n            // event. Animated hiding is problematic.\n            //\n            // We cannot just revertFocus() because that might move focus back to an\n            // element in a floating EventEditor which is not yet faded out and\n            // been removed. Animated hiding is problematic.\n            //\n            // We cannot focus scheduler.timeAxisColumn.element because the browser\n            // would scroll it in some way if we have horizontal overflow.\n            //\n            // The only thing we can know about to focus here is the Scheduler itself.\n            else {\n                DomHelper.focusWithoutScrolling(me.focusElement);\n            }\n        }\n    }\n    //endregion\n    //region TimeRangeStore & TimeRanges\n    /**\n     * Inline time ranges, will be loaded into an internally created store if {@link Scheduler.feature.TimeRanges}\n     * is enabled.\n     * @config {Scheduler.model.TimeSpan[]|TimeSpanConfig[]} timeRanges\n     * @category Data\n     */\n    /**\n     * Get/set time ranges, applies to the backing project's TimeRangeStore.\n     * @member {Scheduler.model.TimeSpan[]} timeRanges\n     * @accepts {Scheduler.model.TimeSpan[]|TimeSpanConfig[]}\n     * @category Data\n     */\n    /**\n     * Get/set the time ranges store instance or config object for {@link Scheduler.feature.TimeRanges} feature.\n     * @member {Core.data.Store} timeRangeStore\n     * @accepts {Core.data.Store|StoreConfig}\n     * @category Data\n     */\n    /**\n     * The time ranges store instance for {@link Scheduler.feature.TimeRanges} feature.\n     * @config {Core.data.Store|StoreConfig} timeRangeStore\n     * @category Data\n     */\n    set timeRanges(timeRanges) {\n        this.project.timeRanges = timeRanges;\n    }\n    get timeRanges() {\n        return this.project.timeRanges;\n    }\n    //endregion\n    //region ResourceTimeRangeStore\n    /**\n     * Inline resource time ranges, will be loaded into an internally created store if\n     * {@link Scheduler.feature.ResourceTimeRanges} is enabled.\n     * @prp {Scheduler.model.ResourceTimeRangeModel[]} resourceTimeRanges\n     * @accepts {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]}\n     * @category Data\n     */\n    /**\n     * Get/set the resource time ranges store instance for {@link Scheduler.feature.ResourceTimeRanges} feature.\n     * @member {Scheduler.data.ResourceTimeRangeStore} resourceTimeRangeStore\n     * @accepts {Scheduler.data.ResourceTimeRangeStore|ResourceTimeRangeStoreConfig}\n     * @category Data\n     */\n    /**\n     * Resource time ranges store instance or config object for {@link Scheduler.feature.ResourceTimeRanges} feature.\n     * @config {Scheduler.data.ResourceTimeRangeStore|ResourceTimeRangeStoreConfig} resourceTimeRangeStore\n     * @category Data\n     */\n    set resourceTimeRanges(resourceTimeRanges) {\n        this.project.resourceTimeRanges = resourceTimeRanges;\n    }\n    get resourceTimeRanges() {\n        return this.project.resourceTimeRanges;\n    }\n    //endregion\n    //region Other functions\n    onBeforeLoad({ params }) {\n        this.applyStartEndParameters(params);\n    }\n    /**\n     * Get events grouped by timeAxis ticks from resources array\n     * @category Data\n     * @param {Scheduler.model.ResourceModel[]} resources An array of resources to process. If not passed, all resources\n     * will be used.\n     * @param {Function} filterFn filter function to filter events if required. Optional.\n     * @private\n     */\n    getResourcesEventsPerTick(resources, filterFn) {\n        const\n            { timeAxis, resourceStore } = this,\n            eventsByTick                = [];\n        resources = resources || resourceStore.records;\n        resources.forEach(resource => {\n            resource.events.forEach(event => {\n                if (!timeAxis.isTimeSpanInAxis(event) || (filterFn && !filterFn.call(this, { resource, event }))) {\n                    return;\n                }\n                // getTickFromDate may return float if event starts/ends in a middle of a tick\n                let startTick = Math.floor(timeAxis.getTickFromDate(event.startDate)),\n                    endTick = Math.ceil(timeAxis.getTickFromDate(event.endDate));\n                // if startDate/endDate of the event is out of timeAxis' bounds, use first/last tick id instead\n                if (startTick == -1) {\n                    startTick = 0;\n                }\n                if (endTick === -1) {\n                    endTick = timeAxis.ticks.length;\n                }\n                do {\n                    if (!eventsByTick[startTick]) {\n                        eventsByTick[startTick] = [event];\n                    }\n                    else {\n                        eventsByTick[startTick].push(event);\n                    }\n                } while (++startTick < endTick);\n            });\n        });\n        return eventsByTick;\n    }\n    //endregion\n    //region WidgetClass\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport AsyncHelper from '../../../Core/helper/AsyncHelper.js';\n/**\n * @module Scheduler/view/mixin/SchedulerScroll\n */\nconst\n    defaultScrollOptions = {\n        block      : 'nearest',\n        edgeOffset : 20\n    };\n/**\n * Functions for scrolling to events, dates etc.\n *\n * @mixin\n */\nexport default Target => class SchedulerScroll extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerScroll';\n    }\n    //region Scroll to event\n    /**\n     * Scrolls an event record into the viewport.\n     * If the resource store is a tree store, this method will also expand all relevant parent nodes to locate the event.\n     *\n     * This function is not applicable for events with multiple assignments, please use #scrollResourceEventIntoView instead.\n     *\n     * @param {Scheduler.model.EventModel} eventRecord the event record to scroll into view\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @async\n     * @category Scrolling\n     */\n    async scrollEventIntoView(eventRecord, options = defaultScrollOptions) {\n        const\n            me        = this,\n            resources = eventRecord.resources || [eventRecord];\n        if (resources.length > 1) {\n            throw new Error('scrollEventIntoView() is not applicable for events with multiple assignments, please use scrollResourceEventIntoView() instead.');\n        }\n        if (!resources.length) {\n            console.warn('You have asked to scroll to an event which is not assigned to a resource');\n        }\n        await me.scrollResourceEventIntoView(resources[0], eventRecord, options);\n    }\n    /**\n     * Scrolls an assignment record into the viewport.\n     *\n     * If the resource store is a tree store, this method will also expand all relevant parent nodes\n     * to locate the event.\n     *\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord A resource record an event record is assigned to\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     */\n    scrollAssignmentIntoView(assignmentRecord, ...args) {\n        return this.scrollResourceEventIntoView(assignmentRecord.resource, assignmentRecord.event, ...args);\n    }\n    /**\n     * Scrolls a resource event record into the viewport.\n     *\n     * If the resource store is a tree store, this method will also expand all relevant parent nodes\n     * to locate the event.\n     *\n     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record an event record is assigned to\n     * @param {Scheduler.model.EventModel} eventRecord An event record to scroll into view\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A Promise which resolves when the scrolling is complete.\n     * @category Scrolling\n     * @async\n     */\n    async scrollResourceEventIntoView(resourceRecord, eventRecord, options = defaultScrollOptions) {\n        const\n            me             = this,\n            eventStart     = eventRecord.startDate,\n            eventEnd       = eventRecord.endDate,\n            eventIsOutside = eventRecord.isScheduled && eventStart < me.timeAxis.startDate | ((eventEnd > me.timeAxis.endDate) << 1);\n        if (arguments.length > 3) {\n            options = arguments[3];\n        }\n        let el;\n        if (options.edgeOffset == null) {\n            options.edgeOffset = 20;\n        }\n        // Make sure event is within TimeAxis time span unless extendTimeAxis passed as false.\n        // The EventEdit feature passes false because it must not mutate the TimeAxis.\n        // Bitwise flag:\n        //  1 === start is before TimeAxis start.\n        //  2 === end is after TimeAxis end.\n        if (eventIsOutside && options.extendTimeAxis !== false) {\n            const currentTimeSpanRange = me.timeAxis.endDate - me.timeAxis.startDate;\n            // Event is too wide, expand the range to encompass it.\n            if (eventIsOutside === 3) {\n                await me.setTimeSpan(\n                    new Date(eventStart.getTime() - currentTimeSpanRange / 2),\n                    new Date(eventEnd.getTime()  + currentTimeSpanRange / 2)\n                );\n            }\n            else if (me.infiniteScroll) {\n                const\n                    { visibleDateRange } = me,\n                    visibleMS = visibleDateRange.endMS - visibleDateRange.startMS,\n                    // If event starts before time axis, scroll to a date one full viewport after target date\n                    // (reverse for an event starting after time axis), to allow a scroll animation\n                    sign = eventIsOutside & 1 ? 1 : -1;\n                await me.setTimeSpan(\n                    new Date(eventStart.getTime()  - currentTimeSpanRange / 2),\n                    new Date(eventStart.getTime() + currentTimeSpanRange / 2),\n                    {\n                        visibleDate : new Date(eventEnd.getTime() + (sign * visibleMS))\n                    }\n                );\n            }\n            // Event is partially or wholly outside but will fit.\n            // Move the TimeAxis to include it. That will maintain visual position.\n            else {\n                // Event starts before\n                if (eventIsOutside & 1) {\n                    await me.setTimeSpan(\n                        new Date(eventStart),\n                        new Date(eventStart.getTime() + currentTimeSpanRange)\n                    );\n                }\n                // Event ends after\n                else {\n                    await me.setTimeSpan(\n                        new Date(eventEnd.getTime() - currentTimeSpanRange),\n                        new Date(eventEnd)\n                    );\n                }\n            }\n        }\n        if (me.isDestroyed) {\n            return;\n        }\n        if (me.store.tree) {\n            // If we're a tree, ensure parents are expanded first\n            await me.expandTo?.(resourceRecord);\n        }\n        // Handle nested events too\n        if (me.features.nestedEvents?.enabled && eventRecord.parent && !eventRecord.parent.isRoot) {\n            await me.scrollEventIntoView(eventRecord.parent);\n        }\n        // Establishing element to scroll to\n        el = me.getElementFromEventRecord(eventRecord, resourceRecord);\n        if (el) {\n            // It's usually the event wrapper that holds focus\n            if (!DomHelper.isFocusable(el)) {\n                el = el.parentNode;\n            }\n            const scroller = me.timeAxisSubGrid.scrollable;\n            // Scroll into view with animation and highlighting if needed.\n            await scroller.scrollIntoView(el, options);\n            if (me.isDestroyed) {\n                return;\n            }\n            let element;\n            do {\n                element = me.getElementFromEventRecord(eventRecord, resourceRecord);\n                // need to await a frame for event to be rendered again\n                // (it seems it can be un-rendered during the scroll somehow)\n                if (!element) {\n                    await AsyncHelper.animationFrame();\n                }\n                if (me.isDestroyed) {\n                    return;\n                }\n            } while (!element);\n        }\n        // If event is fully outside the range, and we are not allowed to extend\n        // the range, then we cannot perform the operation.\n        else if (eventIsOutside === 3 && options.extendTimeAxis === false) {\n            console.warn('You have asked to scroll to an event which is outside the current view and extending timeaxis is disabled');\n        }\n        else if (!eventRecord.isOccurrence && !me.eventStore.isAvailable(eventRecord)) {\n            console.warn('You have asked to scroll to an event which is not available');\n        }\n        else if (eventRecord.isScheduled) {\n            // Event scheduled but not rendered, scroll to calculated location\n            await me.scrollUnrenderedEventIntoView(resourceRecord, eventRecord, options);\n        }\n        else {\n            // Event not scheduled, just scroll resource row into view\n            await me.scrollResourceIntoView(resourceRecord, options);\n        }\n    }\n    /**\n     * Scrolls an unrendered event into view. Internal function used from #scrollResourceEventIntoView.\n     * @private\n     * @category Scrolling\n     */\n    scrollUnrenderedEventIntoView(resourceRec, eventRec, options = defaultScrollOptions) {\n        // We must only resolve when the event's element has been painted\n        // *and* the scroll has fully completed.\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise(async resolve => {\n            const\n                me               = this,\n                scroller         = me.timeAxisSubGrid.scrollable,\n                scrollerViewport = scroller.viewport,\n                { rowManager }   = me,\n                initialY         = scroller.y;\n            // Event may fall on a time not included by workingTime settings\n            if (!scrollerViewport) {\n                resolve();\n                return;\n            }\n            let eventElement, delta, counter = 0;\n            do {\n                // don't risk with the infinite loop, better to throw\n                if (++counter >= 50) {\n                    throw new Error(`Too many preparational scrolls during 'scrollIntoView' for event id = ${ eventRec.id }`);\n                }\n                // note, that this box is only a rough estimation of the event position\n                // it will be precise only in trivial cases\n                // in general case, it indicates the direction in which we should scroll\n                // and our best guess on the distance\n                // this is because we don't know the row heights (even if `preCalculateHeightLimit` is used)\n                // row height might change because of:\n                // - horizontal scroll (predictable with certain effort)\n                // - row height set in some column renderer (completely unpredictable)\n                // so we scroll several times, until we have the event's element (meaning the event is rendered)\n                const box = me.getResourceEventBox(eventRec, resourceRec);\n                // Event may fall on a time not included by workingTime settings\n                if (!box) {\n                    resolve();\n                    return;\n                }\n                // In case of subPixel position, scroll the whole pixel into view\n                box.x = Math.ceil(box.x);\n                box.y = Math.ceil(box.y);\n                if (me.rtl) {\n                    // RTL scrolls in negative direction but coordinates are still LTR\n                    box.translate(-me.timeAxisViewModel.totalSize + scrollerViewport.width, 0);\n                }\n                // Note use of scroller.scrollLeft here. We need the natural DOM scrollLeft value\n                // not the +ve X position along the scrolling axis.\n                box.translate(scrollerViewport.x - scroller.scrollLeft, scrollerViewport.y - scroller.y);\n                const instantScrollOptions = Object.assign({}, defaultScrollOptions);\n                // only interested in the direction of initial jump\n                if (delta === undefined) {\n                    delta = scroller.getDeltaTo(box, instantScrollOptions);\n                }\n                const scrollPromise = scroller.scrollIntoView(box, instantScrollOptions);\n                await scrollPromise;\n                if (scrollPromise.cancelled || me.isDestroyed) {\n                    resolve();\n                    return true;\n                }\n                await AsyncHelper.animationFrame();\n                if (me.isDestroyed) {\n                    resolve();\n                    return true;\n                }\n                eventElement = me.getElementFromEventRecord(eventRec, resourceRec);\n            } while (!eventElement);\n            // now we have arrived to the local area of the event\n            // probably we don't need to suspend/resume events on scroller, since DOM `scroll` event is fired\n            // asynchronously, and we resume the events right away in the synchronous flow below\n            scroller.suspendEvents();\n            // position the scroller above/below of all rows, but not exceeding the initial Y position\n            if (delta.yDelta >= 0) {\n                scroller.y = Math.max(rowManager.topRow.top - scroller.viewport.height, initialY);\n            }\n            else {\n                scroller.y = Math.min(rowManager.bottomRow.bottom, initialY);\n            }\n            // this is a quite important call, which fixes the internal scroller state after the scrolls above\n            me.fixElementHeights();\n            scroller.resumeEvents();\n            // now make a final animated scroll, pretending we arrived there from the very 1st jump\n            const scrollPromise2 = scroller.scrollIntoView(\n                eventElement,\n                Object.assign({}, options, { elementAfterScroll : () => me.getElementFromEventRecord(eventRec, resourceRec) })\n            );\n            await scrollPromise2;\n            if (scrollPromise2.canceled || me.isDestroyed) {\n                resolve();\n                return true;\n            }\n            // final await for animation frame for the event element rendering to complete\n            await AsyncHelper.animationFrame();\n            resolve();\n        });\n    }\n    /**\n     * Scrolls the specified resource into view, works for both horizontal and vertical modes.\n     * @param {Scheduler.model.ResourceModel} resourceRecord A resource record an event record is assigned to\n     * @param {BryntumScrollOptions} [options] How to scroll.\n     * @returns {Promise} A promise which is resolved when the scrolling has finished.\n     * @category Scrolling\n     */\n    scrollResourceIntoView(resourceRecord, options = defaultScrollOptions) {\n        if (this.isVertical) {\n            return this.currentOrientation.scrollResourceIntoView(resourceRecord, options);\n        }\n        return this.scrollRowIntoView(resourceRecord, options);\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/view/mixin/SchedulerRegions\n */\n/**\n * Functions to get regions (bounding boxes) for scheduler, events etc.\n *\n * @mixin\n */\nexport default Target => class SchedulerRegions extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerRegions';\n    }\n    //region Orientation dependent regions\n    /**\n     * Gets the region represented by the schedule and optionally only for a single resource. The view will ask the\n     * scheduler for the resource availability by calling getResourceAvailability. By overriding that method you can\n     * constrain events differently for different resources.\n     * @param {Scheduler.model.ResourceModel} resourceRecord (optional) The resource record\n     * @param {Scheduler.model.EventModel} eventRecord (optional) The event record\n     * @returns {Core.helper.util.Rectangle} The region of the schedule\n     */\n    getScheduleRegion(resourceRecord, eventRecord, local = true, dateConstraints) {\n        return this.currentOrientation.getScheduleRegion(...arguments);\n    }\n    /**\n     * Gets the region, relative to the timeline view element, representing the passed resource and optionally just for a certain date interval.\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Date} startDate A start date constraining the region\n     * @param {Date} endDate An end date constraining the region\n     * @returns {Core.helper.util.Rectangle} A Rectangle which encapsulates the resource time span\n     */\n    getResourceRegion(resourceRecord, startDate, endDate) {\n        return this.currentOrientation.getRowRegion(...arguments);\n    }\n    //endregion\n    //region ResourceEventBox\n    getAssignmentEventBox(assignmentRecord, includesOutside) {\n        return this.getResourceEventBox(assignmentRecord.event, assignmentRecord.resource, includesOutside);\n    }\n    /**\n     * Get the region for a specified resources specified event.\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Boolean} includeOutside Specify true to get boxes for events outside of the rendered zone in both\n     *   dimensions. This option is used when calculating dependency lines, and we need to include routes from events\n     *   which may be outside the rendered zone.\n     * @returns {Core.helper.util.Rectangle}\n     */\n    getResourceEventBox(eventRecord, resourceRecord, includeOutside = false, roughly = false) {\n        return this.currentOrientation.getResourceEventBox(...arguments);\n    }\n    //endregion\n    //region Item box\n    /**\n     * Gets box for displayed item designated by the record. If several boxes are displayed for the given item\n     * then the method returns all of them. Box coordinates are in view coordinate system.\n     *\n     * Boxes outside scheduling view timeaxis timespan and inside collapsed rows (if row defining store is a tree store)\n     * will not be returned. Boxes outside scheduling view vertical visible area (i.e. boxes above currently visible\n     * top row or below currently visible bottom row) will be calculated approximately.\n     *\n     * @param {Scheduler.model.EventModel} event\n     * @returns {Object|Object[]}\n     * @returns {Boolean} return.isPainted Whether the box was calculated for the rendered scheduled record or was\n     *    approximately calculated for the scheduled record outside of the current vertical view area.\n     * @returns {Number} return.top\n     * @returns {Number} return.bottom\n     * @returns {Number} return.start\n     * @returns {Number} return.end\n     * @returns {'before'|'after'} return.relPos if the item is not rendered then provides a view relative\n     * position one of 'before', 'after'\n     * @internal\n     */\n    getItemBox(event, includeOutside = false) {\n        return event.resources.map(resource => this.getResourceEventBox(event, resource, includeOutside));\n    }\n    //endregion\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/view/mixin/SchedulerState\n */\nconst copyProperties = [\n    'eventLayout',\n    'mode',\n    'eventColor',\n    'eventStyle',\n    'tickSize',\n    'fillTicks'\n];\n/**\n * A Mixin for Scheduler that handles state. It serializes the following scheduler properties, in addition to what\n * is already stored by its superclass {@link Grid/view/mixin/GridState}:\n *\n * * eventLayout\n * * barMargin\n * * mode\n * * tickSize\n * * zoomLevel\n * * eventColor\n * * eventStyle\n *\n * See {@link Grid.view.mixin.GridState} and {@link Core.mixin.State} for more information on state.\n *\n * @mixin\n */\nexport default Target => class SchedulerState extends (Target || Base) {\n    static get $name() {\n        return 'SchedulerState';\n    }\n    /**\n     * Gets or sets scheduler's state. Check out {@link Scheduler.view.mixin.SchedulerState} mixin\n     * and {@link Grid.view.mixin.GridState} for more details.\n     * @member {Object} state\n     * @property {String} state.eventLayout\n     * @property {String} state.eventStyle\n     * @property {String} state.eventColor\n     * @property {Number} state.barMargin\n     * @property {Number} state.tickSize\n     * @property {Boolean} state.fillTicks\n     * @property {Number} state.zoomLevel\n     * @property {'horizontal'|'vertical'} state.mode\n     * @property {Object[]} state.columns\n     * @property {Boolean} state.readOnly\n     * @property {Number} state.rowHeight\n     * @property {Object} state.scroll\n     * @property {Number} state.scroll.scrollLeft\n     * @property {Number} state.scroll.scrollTop\n     * @property {Array} state.selectedRecords\n     * @property {String} state.selectedCell\n     * @property {String} state.style\n     * @property {Object} state.subGrids\n     * @property {Object} state.store\n     * @property {Object} state.store.sorters\n     * @property {Object} state.store.groupers\n     * @property {Object} state.store.filters\n     * @category State\n     */\n    /**\n     * Get scheduler's current state for serialization. State includes rowHeight, headerHeight, readOnly, selectedCell,\n     * selectedRecordId, column states and store state etc.\n     * @returns {Object} State object to be serialized\n     * @private\n     */\n    getState() {\n        return ObjectHelper.copyProperties(super.getState(), this, copyProperties);\n    }\n    /**\n     * Apply previously stored state.\n     * @param {Object} state\n     * @private\n     */\n    applyState(state) {\n        this.suspendRefresh();\n        let propsToCopy = copyProperties.slice();\n        if (state?.eventLayout === 'layoutFn') {\n            delete state.eventLayout;\n            propsToCopy.splice(propsToCopy.indexOf('eventLayout'), 1);\n        }\n        // Zoom level will set tick size, no need to update model additionally\n        if (state?.zoomLevelOptions?.width) {\n            propsToCopy = propsToCopy.filter(p => p !== 'tickSize');\n        }\n        ObjectHelper.copyProperties(this, state, propsToCopy);\n        super.applyState(state);\n        this.resumeRefresh(true, false);\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import Base from '../../../Core/Base.js';\nimport Collection from '../../../Core/util/Collection.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\n/**\n * @module Scheduler/view/mixin/EventSelection\n */\n/**\n * Mixin that tracks event or assignment selection by clicking on one or more events in the scheduler.\n * @mixin\n */\nexport default Target => class EventSelection extends (Target || Base) {\n    static get $name() {\n        return 'EventSelection';\n    }\n    //region Default config\n    static get configurable() {\n        return {\n            /**\n             * Configure as `true`, or set property to `true` to highlight dependent events as well when selecting an event.\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            highlightPredecessors : false,\n            /**\n             * Configure as `true`, or set property to `true` to highlight dependent events as well when selecting an event.\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            highlightSuccessors : false,\n            /**\n             * Configure as `true` to deselect a selected event upon click.\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            deselectOnClick : false,\n            /**\n             * Configure as `false` to preserve selection when clicking the empty schedule area.\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            deselectAllOnScheduleClick : true,\n            /**\n             * Set to `false` to not select the resource of the event when clicking an event bar.\n             * @prp {Boolean}\n             * @default\n             * @category Selection\n             */\n            selectResourceOnEventNavigate : true,\n            /**\n             * Set to `false` to not select the row/resource when clicking the empty area in a time axis cell.\n             * @prp {Boolean}\n             * @default\n             * @category Selection\n             */\n            selectResourceOnScheduleClick : true,\n            /**\n             * Collection to store selection.\n             * @config {Core.util.Collection}\n             * @private\n             */\n            selectedCollection : {}\n        };\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * Configure as `true` to allow `CTRL+click` to select multiple events in the scheduler.\n             * @config {Boolean}\n             * @category Selection\n             */\n            multiEventSelect : false,\n            /**\n             * Configure as `true`, or set property to `true` to disable event selection.\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            eventSelectionDisabled : false,\n            /**\n             * CSS class to add to selected events.\n             * @config {String}\n             * @default\n             * @category CSS\n             * @private\n             */\n            eventSelectedCls : 'b-sch-event-selected',\n            /**\n             * Configure as `true` to trigger `selectionChange` when removing a selected event/assignment.\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            triggerSelectionChangeOnRemove : false,\n            /**\n             * This flag controls whether Scheduler should preserve its selection of events when loading a new dataset\n             * (if selected event ids are included in the newly loaded dataset).\n             * @config {Boolean}\n             * @default\n             * @category Selection\n             */\n            maintainSelectionOnDatasetChange : true,\n            /**\n             * CSS class to add to other instances of a selected event, to highlight them.\n             * @config {String}\n             * @default\n             * @category CSS\n             * @private\n             */\n            eventAssignHighlightCls : 'b-sch-event-assign-selected'\n        };\n    }\n    //endregion\n    //region Events\n    /**\n     * Fired any time there is a change to the events selected in the Scheduler.\n     * @event eventSelectionChange\n     * @param {'select'|'deselect'|'update'|'clear'} action One of the actions 'select', 'deselect', 'update',\n     * 'clear'\n     * @param {Scheduler.model.EventModel[]} selected An array of the Events added to the selection.\n     * @param {Scheduler.model.EventModel[]} deselected An array of the Event removed from the selection.\n     * @param {Scheduler.model.EventModel[]} selection The new selection.\n     */\n    /**\n     * Fired any time there is going to be a change to the events selected in the Scheduler.\n     * Returning `false` prevents the change\n     * @event beforeEventSelectionChange\n     * @preventable\n     * @param {String} action One of the actions 'select', 'deselect', 'update', 'clear'\n     * @param {Scheduler.model.EventModel[]} selected An array of events that will be added to the selection.\n     * @param {Scheduler.model.EventModel[]} deselected An array of events that will be removed from the selection.\n     * @param {Scheduler.model.EventModel[]} selection The currently selected events, before applying `selected` and `deselected`.\n     */\n    /**\n     * Fired any time there is a change to the assignments selected in the Scheduler.\n     * @event assignmentSelectionChange\n     * @param {'select'|'deselect'|'update'|'clear'} action One of the actions 'select', 'deselect', 'update',\n     * 'clear'\n     * @param {Scheduler.model.AssignmentModel[]} selected An array of the Assignments added to the selection.\n     * @param {Scheduler.model.AssignmentModel[]} deselected An array of the Assignments removed from the selection.\n     * @param {Scheduler.model.AssignmentModel[]} selection The new selection.\n     */\n    /**\n     * Fired any time there is going to be a change to the assignments selected in the Scheduler.\n     * Returning `false` prevents the change\n     * @event beforeAssignmentSelectionChange\n     * @preventable\n     * @param {String} action One of the actions 'select', 'deselect', 'update', 'clear'\n     * @param {Scheduler.model.EventModel[]} selected An array of assignments that will be added to the selection.\n     * @param {Scheduler.model.EventModel[]} deselected An array of assignments that will be removed from the selection.\n     * @param {Scheduler.model.EventModel[]} selection The currently selected assignments, before applying `selected` and `deselected`.\n     */\n    //endregion\n    //region Init\n    afterConstruct() {\n        super.afterConstruct();\n        this.navigator?.ion({\n            navigate : 'onEventNavigate',\n            thisObj  : this\n        });\n    }\n    //endregion\n    //region Selected Collection\n    changeSelectedCollection(selectedCollection) {\n        if (!selectedCollection.isCollection) {\n            selectedCollection = new Collection(selectedCollection);\n        }\n        return selectedCollection;\n    }\n    updateSelectedCollection(selectedCollection) {\n        const me = this;\n        // When sharing collection, only the owner should destroy it\n        if (!selectedCollection.owner) {\n            selectedCollection.owner = me;\n        }\n        // Fire row change events from onSelectedCollectionChange\n        selectedCollection.ion({\n            change : (...args) => me.project.deferUntilRepopulationIfNeeded(\n                'onSelectedCollectionChange',\n                (...args) => !me.isDestroying && me.onSelectedCollectionChange(...args),\n                args\n            ),\n            // deferring this handler breaks the UI\n            beforeSplice : 'onBeforeSelectedCollectionSplice',\n            thisObj      : me\n        });\n    }\n    get selectedCollection() {\n        return this._selectedCollection;\n    }\n    getActionType(selection, selected, deselected, before) {\n        if ((before && selection.length > 0 && deselected.length === selection.length && selected.length === 0) ||\n            (!before && selection.length === 0 && deselected.length > 0)) {\n            return 'clear';\n        }\n        return (selected.length > 0 && deselected.length > 0) ? 'update' : (selected.length > 0\n            ? 'select'  : 'deselect');\n    }\n    //endregion\n    //region Modify selection\n    getEventsFromAssignments(assignments) {\n        return ArrayHelper.unique(assignments.map(assignment => assignment.event));\n    }\n    /**\n     * The {@link Scheduler.model.EventModel events} which are selected.\n     * @property {Scheduler.model.EventModel[]}\n     * @category Selection\n     */\n    get selectedEvents() {\n        return this.getEventsFromAssignments(this.selectedCollection.values);\n    }\n    set selectedEvents(events) {\n        // Select all assignments\n        const assignments = [];\n        events = ArrayHelper.asArray(events);\n        events?.forEach(event => {\n            if (this.isEventSelectable(event) !== false) {\n                if (event.isOccurrence) {\n                    event.assignments.forEach(as => {\n                        assignments.push(this.assignmentStore.getOccurrence(as, event));\n                    });\n                }\n                else {\n                    assignments.push(...event.assignments);\n                }\n            }\n        });\n        // Replace the entire selected collection with the new record set\n        this.selectedCollection.splice(0, this.selectedCollection.count, assignments);\n    }\n    /**\n     * The {@link Scheduler.model.AssignmentModel events} which are selected.\n     * @property {Scheduler.model.AssignmentModel[]}\n     * @category Selection\n     */\n    get selectedAssignments() {\n        return this.selectedCollection.values;\n    }\n    set selectedAssignments(assignments) {\n        // Replace the entire selected collection with the new record set\n        this.selectedCollection.splice(0, this.selectedCollection.count, assignments || []);\n    }\n    /**\n     * Returns `true` if the {@link Scheduler.model.EventModel event} is selected.\n     * @param {Scheduler.model.EventModel} event The event\n     * @returns {Boolean} Returns `true` if the event is selected\n     * @category Selection\n     */\n    isEventSelected(event) {\n        const { selectedCollection } = this;\n        return Boolean(selectedCollection.count && selectedCollection.includes(event.assignments));\n    }\n    /**\n     * A template method (empty by default) allowing you to control if an event can be selected or not.\n     *\n     * ```javascript\n     * new Scheduler({\n     *     isEventSelectable(event) {\n     *         return event.startDate >= Date.now();\n     *     }\n     * })\n     * ```\n     *\n     * This selection process is applicable to calendar too:\n     *\n     * ```javascript\n     * new Calendar({\n     *     isEventSelectable(event) {\n     *         return event.startDate >= Date.now();\n     *     }\n     * })\n     * ```\n     *\n     * @param {Scheduler.model.EventModel} event The event record\n     * @returns {Boolean} true if event can be selected, otherwise false\n     * @prp {Function}\n     * @category Selection\n     */\n    isEventSelectable(event) {}\n    /**\n     * Returns `true` if the {@link Scheduler.model.AssignmentModel assignment} is selected.\n     * @param {Scheduler.model.AssignmentModel} assignment The assignment\n     * @returns {Boolean} Returns `true` if the assignment is selected\n     * @category Selection\n     */\n    isAssignmentSelected(assignment) {\n        return this.selectedCollection.includes(assignment);\n    }\n    /**\n     * Selects the passed {@link Scheduler.model.EventModel event} or {@link Scheduler.model.AssignmentModel assignment}\n     * *if it is not selected*. Selecting events results in all their assignments being selected.\n     * @param {Scheduler.model.EventModel|Scheduler.model.AssignmentModel} eventOrAssignment The event or assignment to select\n     * @param {Boolean} [preserveSelection] Pass `true` to preserve any other selected events or assignments\n     * @category Selection\n     */\n    select(eventOrAssignment, preserveSelection = false) {\n        if (eventOrAssignment.isAssignment) {\n            this.selectAssignment(eventOrAssignment, preserveSelection);\n        }\n        else {\n            this.selectEvent(eventOrAssignment, preserveSelection);\n        }\n    }\n    /**\n     * Selects the passed {@link Scheduler.model.EventModel event} *if it is not selected*. Selecting an event will\n     * select all its assignments.\n     * @param {Scheduler.model.EventModel} event The event to select\n     * @param {Boolean} [preserveSelection] Pass `true` to preserve any other selected events\n     * @category Selection\n     */\n    selectEvent(event, preserveSelection = false) {\n        // If the event is already selected, this is a no-op.\n        // In this case, selection must not be cleared even in the absence of preserveSelection\n        if (!this.isEventSelected(event)) {\n            this.selectEvents([event], preserveSelection);\n        }\n    }\n    /**\n     * Selects the passed {@link Scheduler.model.AssignmentModel assignment} *if it is not selected*.\n     * @param {Scheduler.model.AssignmentModel} assignment The assignment to select\n     * @param {Boolean} [preserveSelection] Pass `true` to preserve any other selected assignments\n     * @param {Event} [event] If this method was invoked as a result of a user action, this is the DOM event that triggered it\n     * @category Selection\n     */\n    selectAssignment(assignment, preserveSelection = false, event) {\n        // If the event is already selected, this is a no-op.\n        // In this case, selection must not be cleared even in the absence of preserveSelection\n        if (!this.isAssignmentSelected(assignment)) {\n            preserveSelection ? this.selectedCollection.add(assignment) : this.selectedAssignments = assignment;\n        }\n    }\n    /**\n     * Deselects the passed {@link Scheduler.model.EventModel event} or {@link Scheduler.model.AssignmentModel assignment}\n     * *if it is selected*.\n     * @param {Scheduler.model.EventModel|Scheduler.model.AssignmentModel} eventOrAssignment The event or assignment to deselect.\n     * @category Selection\n     */\n    deselect(eventOrAssignment) {\n        if (eventOrAssignment.isAssignment) {\n            this.deselectAssignment(eventOrAssignment);\n        }\n        else {\n            this.deselectEvent(eventOrAssignment);\n        }\n    }\n    /**\n     * Deselects the passed {@link Scheduler.model.EventModel event} *if it is selected*.\n     * @param {Scheduler.model.EventModel} event The event to deselect.\n     * @category Selection\n     */\n    deselectEvent(event) {\n        if (this.isEventSelected(event)) {\n            this.selectedCollection.remove(...event.assignments);\n        }\n    }\n    /**\n     * Deselects the passed {@link Scheduler.model.AssignmentModel assignment} *if it is selected*.\n     * @param {Scheduler.model.AssignmentModel} assignment The assignment to deselect\n     * @param {Event} [event] If this method was invoked as a result of a user action, this is the DOM event that triggered it\n     * @category Selection\n     */\n    deselectAssignment(assignment) {\n        if (this.isAssignmentSelected(assignment)) {\n            this.selectedCollection.remove(assignment);\n        }\n    }\n    /**\n     * Adds {@link Scheduler.model.EventModel events} to the selection.\n     * @param {Scheduler.model.EventModel[]} events Events to be selected\n     * @param {Boolean} [preserveSelection] Pass `true` to preserve any other selected events\n     * @category Selection\n     */\n    selectEvents(events, preserveSelection = false) {\n        if (preserveSelection) {\n            const assignments = (events.reduce((assignments, event) => {\n                if (this.isEventSelectable(event) !== false) {\n                    assignments.push(...event.assignments);\n                }\n                return assignments;\n            }, []));\n            this.selectedCollection.add(assignments);\n        }\n        else {\n            this.selectedEvents = events;\n        }\n    }\n    /**\n     * Removes {@link Scheduler.model.EventModel events} from the selection.\n     * @param {Scheduler.model.EventModel[]} events Events or assignments  to be deselected\n     * @category Selection\n     */\n    deselectEvents(events) {\n        this.selectedCollection.remove(events.reduce((assignments, event) => {\n            assignments.push(...event.assignments);\n            return assignments;\n        }, []));\n    }\n    /**\n     * Adds {@link Scheduler.model.AssignmentModel assignments} to the selection.\n     * @param {Scheduler.model.AssignmentModel[]} assignments Assignments to be selected\n     * @category Selection\n     */\n    selectAssignments(assignments) {\n        this.selectedCollection.add(assignments);\n    }\n    /**\n     * Removes {@link Scheduler.model.AssignmentModel assignments} from the selection.\n     * @param {Scheduler.model.AssignmentModel[]} assignments Assignments  to be deselected\n     * @category Selection\n     */\n    deselectAssignments(assignments) {\n        this.selectedCollection.remove(assignments);\n    }\n    /**\n     * Deselects all {@link Scheduler.model.EventModel events} and {@link Scheduler.model.AssignmentModel assignments}.\n     * @category Selection\n     */\n    clearEventSelection() {\n        this.selectedAssignments = [];\n    }\n    //endregion\n    //region Events\n    /**\n     * Responds to mutations of the underlying selection Collection.\n     * Keeps the UI synced, eventSelectionChange and assignmentSelectionChange event is fired when `me.silent` is falsy.\n     * @private\n     */\n    onBeforeSelectedCollectionSplice({ toAdd, toRemove, index }) {\n        const\n            me         = this,\n            selection  = me._selectedCollection.values,\n            selected   = toAdd,\n            deselected = toRemove > 0 ? selection.slice(index, toRemove + index) : [],\n            action     = me.getActionType(selection, selected, deselected, true);\n        if (toAdd.length === 0 && toRemove === 0) {\n            return;\n        }\n        if (me.trigger('beforeEventSelectionChange', {\n            action,\n            selection  : me.getEventsFromAssignments(selection) || [],\n            selected   : me.getEventsFromAssignments(selected) || [],\n            deselected : me.getEventsFromAssignments(deselected) || []\n        }) === false) {\n            return false;\n        }\n        if (me.trigger('beforeAssignmentSelectionChange', {\n            action,\n            selection,\n            selected,\n            deselected\n        }) === false) {\n            return false;\n        }\n    }\n    onSelectedCollectionChange({ added, removed }) {\n        const\n            me         = this,\n            selection  = me.selectedAssignments,\n            selected   = added || [],\n            deselected = removed || [];\n        function updateSelection(assignmentRecord, select) {\n            const eventRecord    = assignmentRecord.event;\n            if (eventRecord) {\n                const\n                    returnWrapper               = false,\n                    checkReleased               = true,\n                    { eventAssignHighlightCls } = me,\n                    element                     = me.getElementFromAssignmentRecord(assignmentRecord, returnWrapper, checkReleased);\n                me.currentOrientation.toggleCls(assignmentRecord, me.eventSelectedCls, select, returnWrapper, checkReleased);\n                eventAssignHighlightCls && me.getElementsFromEventRecord(eventRecord, null, returnWrapper, checkReleased).forEach(el => {\n                    if (el !== element) {\n                        const otherAssignmentRecord = me.resolveAssignmentRecord(el, checkReleased);\n                        me.currentOrientation.toggleCls(otherAssignmentRecord, eventAssignHighlightCls, select, returnWrapper, checkReleased);\n                        // When selection changes, we toggle classes also for released events above, to make sure the\n                        // element & lastDomConfig matches (to not get incorrect state later). But we do not want to\n                        // animate that (cant be seen anyway)\n                        if (select && !el.parentElement.isReleased) {\n                            // Need to force a reflow to get the highlightning animation triggered\n                            el.style.animation = 'none';\n                            el.offsetHeight;\n                            el.style.animation = '';\n                        }\n                        el.classList.toggle(eventAssignHighlightCls, select);\n                    }\n                });\n            }\n        }\n        deselected.forEach(record => updateSelection(record, false));\n        selected.forEach(record => updateSelection(record, true));\n        if (me.highlightSuccessors || me.highlightPredecessors) {\n            me.highlightLinkedEvents(me.selectedEvents);\n        }\n        // To be able to restore selection after reloading resources (which might lead to regenerated assignments in\n        // the single assignment scenario, so cannot rely on records or ids)\n        me.$selectedAssignments = selection.map(assignment => ({\n            eventId    : assignment.eventId,\n            resourceId : assignment.resourceId\n        }));\n        if (!me.silent) {\n            const action = this.getActionType(selection, selected, deselected);\n            me.trigger('assignmentSelectionChange', {\n                action,\n                selection,\n                selected,\n                deselected\n            });\n            me.trigger('eventSelectionChange', {\n                action,\n                selection  : me.selectedEvents,\n                selected   : me.getEventsFromAssignments(selected),\n                deselected : me.getEventsFromAssignments(deselected)\n            });\n        }\n    }\n    /**\n     * Assignment change listener to remove events from selection which are no longer in the assignments.\n     * @private\n     */\n    onAssignmentChange(event) {\n        super.onAssignmentChange(event);\n        const\n            me = this,\n            { action, records : assignments } = event;\n        me.silent = !me.triggerSelectionChangeOnRemove;\n        if (action === 'remove') {\n            me.deselectAssignments(assignments);\n        }\n        else if (action === 'removeall' && !me.eventStore.isSettingData) {\n            me.clearEventSelection();\n        }\n        else if (action === 'dataset' && me.$selectedAssignments) {\n            if (!me.maintainSelectionOnDatasetChange) {\n                me.clearEventSelection();\n            }\n            else {\n                const newAssignments = me.$selectedAssignments.map(selector =>\n                    assignments.find(a =>\n                        a.eventId === selector.eventId &&\n                        a.resourceId === selector.resourceId\n                    )\n                );\n                me.selectedAssignments = ArrayHelper.clean(newAssignments);\n            }\n        }\n        me.silent = false;\n    }\n    onInternalEventStoreChange({ source, action, records }) {\n        // Setting empty event dataset cannot be handled in onAssignmentChange above, no assignments might be affected\n        if (!source.isResourceTimeRangeStore && action === 'dataset' && !records.length) {\n            this.clearEventSelection();\n        }\n        super.onInternalEventStoreChange(...arguments);\n    }\n    /**\n     * Mouse listener to update selection.\n     * @private\n     */\n    onAssignmentSelectionClick(event, clickedRecord) {\n        const me = this;\n        // Multi selection: CTRL means preserve selection, just add or remove the event.\n        // Single selection: CTRL deselects already selected event\n        if (me.isAssignmentSelected(clickedRecord)) {\n            if (me.deselectOnClick || event.ctrlKey) {\n                me.deselectAssignment(clickedRecord, me.multiEventSelect, event);\n            }\n        }\n        else if (this.isEventSelectable(clickedRecord.event) !== false) {\n            me.selectAssignment(clickedRecord, event.ctrlKey && me.multiEventSelect, event);\n        }\n    }\n    /**\n     * Navigation listener to update selection.\n     * @private\n     */\n    onEventNavigate({ event, item }) {\n        if (!this.eventSelectionDisabled) {\n            const assignment = item && (item.nodeType === Element.ELEMENT_NODE ? this.resolveAssignmentRecord(item) : item);\n            if (assignment) {\n                this.onAssignmentSelectionClick(event, assignment);\n            }\n            // The click was not an event or assignment\n            else if (this.deselectAllOnScheduleClick) {\n                this.clearEventSelection();\n            }\n        }\n    }\n    changeHighlightSuccessors(value) {\n        return this.changeLinkedEvents(value);\n    }\n    changeHighlightPredecessors(value) {\n        return this.changeLinkedEvents(value);\n    }\n    changeLinkedEvents(value) {\n        const me = this;\n        if (value) {\n            me.highlighted = me.highlighted || new Set();\n            me.highlightLinkedEvents(me.selectedEvents);\n        }\n        else if (me.highlighted) {\n            me.highlightLinkedEvents();\n        }\n        return value;\n    }\n    // Function that highlights/unhighlights events in a dependency chain\n    highlightLinkedEvents(eventRecords = []) {\n        const\n            me                  = this,\n            {\n                highlighted,\n                eventStore\n            }                   = me,\n            dependenciesFeature = me.features.dependencies;\n        // Unhighlight previously highlighted records\n        highlighted.forEach(eventRecord => {\n            if (!eventRecords.includes(eventRecord)) {\n                eventRecord.meta.highlight = false;\n                highlighted.delete(eventRecord);\n                if (eventStore.includes(eventRecord)) {\n                    eventRecord.dependencies.forEach(dep => dependenciesFeature.unhighlight(dep, 'b-highlight'));\n                }\n            }\n        });\n        eventRecords.forEach(eventRecord => {\n            const toWalk = [eventRecord];\n            // Collect all events along the dependency chain\n            while (toWalk.length) {\n                const record = toWalk.pop();\n                highlighted.add(record);\n                if (me.highlightSuccessors) {\n                    record.outgoingDeps.forEach(outgoing => {\n                        dependenciesFeature.highlight(outgoing, 'b-highlight');\n                        !highlighted.has(outgoing.toEvent) && toWalk.push(outgoing.toEvent);\n                    });\n                }\n                if (me.highlightPredecessors) {\n                    record.incomingDeps.forEach(incoming => {\n                        dependenciesFeature.highlight(incoming, 'b-highlight');\n                        !highlighted.has(incoming.fromEvent) && toWalk.push(incoming.fromEvent);\n                    });\n                }\n            }\n            // Highlight them\n            highlighted.forEach(record => record.meta.highlight = true);\n        });\n        // Toggle flag on schedulers element, to fade others in or out\n        me.element.classList.toggle('b-highlighting', eventRecords.length > 0);\n        me.refreshWithTransition();\n    }\n    onEventDataGenerated(renderData) {\n        if (this.highlightSuccessors || this.highlightPredecessors) {\n            renderData.cls['b-highlight'] = renderData.eventRecord.meta.highlight;\n        }\n        super.onEventDataGenerated(renderData);\n    }\n    updateProject(project, old) {\n        this.clearEventSelection();\n        super.updateProject(project, old);\n    }\n    //endregion\n    doDestroy() {\n        this._selectedCollection?.owner === this && this._selectedCollection.destroy();\n        super.doDestroy();\n    }\n    //region Getters/Setters\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport Navigator from '../../../Core/helper/util/Navigator.js';\nimport Delayable from '../../../Core/mixin/Delayable.js';\nimport Location from '../../../Grid/util/Location.js';\n/**\n * @module Scheduler/view/mixin/EventNavigation\n */\nconst\n    preventDefault  = e => e.preventDefault(),\n    isArrowKey = {\n        ArrowRight : 1,\n        ArrowLeft  : 1,\n        ArrowUp    : 1,\n        ArrowDown  : 1\n    },\n    animate100 = {\n        animate : 100\n    },\n    emptyObject = Object.freeze({});\n/**\n * Mixin that tracks event or assignment selection by clicking on one or more events in the scheduler.\n * @mixin\n */\nexport default Target => class EventNavigation extends Delayable(Target || Base) {\n    static get $name() {\n        return 'EventNavigation';\n    }\n    //region Default config\n    static get configurable() {\n        return {\n            /**\n             * A config object to use when creating the {@link Core.helper.util.Navigator}\n             * to use to perform keyboard navigation in the timeline.\n             * @config {NavigatorConfig}\n             * @default\n             * @category Misc\n             * @internal\n             */\n            navigator : {\n                allowCtrlKey   : true,\n                scrollSilently : true,\n                keys           : {\n                    Space     : 'onEventSpaceKey',\n                    Enter     : 'onEventEnterKey',\n                    Delete    : 'onDeleteKey',\n                    Backspace : 'onDeleteKey',\n                    ArrowUp   : 'onArrowUpKey',\n                    ArrowDown : 'onArrowDownKey',\n                    Escape    : 'onEscapeKey',\n                    // These are processed by GridNavigation's handlers\n                    Tab         : 'onTab',\n                    'SHIFT+Tab' : 'onShiftTab'\n                }\n            },\n            isNavigationKey : {\n                ArrowDown  : 1,\n                ArrowUp    : 1,\n                ArrowLeft  : 1,\n                ArrowRight : 1\n            }\n        };\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * A CSS class name to add to focused events.\n             * @config {String}\n             * @default\n             * @category CSS\n             * @private\n             */\n            focusCls : 'b-active',\n            /**\n             * Allow using [Delete] and [Backspace] to remove events/assignments\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            enableDeleteKey : true,\n            // Number in milliseconds to buffer handlers execution. See `Delayable.throttle` function docs.\n            onDeleteKeyBuffer      : 500,\n            navigatePreviousBuffer : 200,\n            navigateNextBuffer     : 200,\n            testConfig : {\n                onDeleteKeyBuffer : 1\n            }\n        };\n    }\n    //endregion\n    //region Events\n    /**\n     * Fired when a user gesture causes the active item to change.\n     * @event navigate\n     * @param {Event} event The browser event which instigated navigation. May be a click or key or focus event.\n     * @param {HTMLElement|null} item The newly active item, or `null` if focus moved out.\n     * @param {HTMLElement|null} oldItem The previously active item, or `null` if focus is moving in.\n     */\n    //endregion\n    construct(config) {\n        const me = this;\n        me.isInTimeAxis = me.isInTimeAxis.bind(me);\n        me.onDeleteKey = me.throttle(me.onDeleteKey, me.onDeleteKeyBuffer, me);\n        super.construct(config);\n    }\n    changeNavigator(navigator) {\n        const me = this;\n        me.getConfig('subGridConfigs');\n        return new Navigator(me.constructor.mergeConfigs({\n            ownerCmp         : me,\n            target           : me.timeAxisSubGridElement,\n            processEvent     : me.processEvent,\n            itemSelector     : `.${me.eventCls}-wrap`,\n            focusCls         : me.focusCls,\n            navigatePrevious : me.throttle(me.navigatePrevious, { delay : me.navigatePreviousBuffer, throttled : preventDefault }),\n            navigateNext     : me.throttle(me.navigateNext, { delay : me.navigateNextBuffer, throttled : preventDefault })\n        }, navigator));\n    }\n    doDestroy() {\n        this.navigator.destroy();\n        super.doDestroy();\n    }\n    isInTimeAxis(record) {\n        // If event is hidden by workingTime configs, horizontal mapper would raise a flag on instance meta\n        // We still need to check if time span is included in axis\n        return !record.instanceMeta(this).excluded && this.timeAxis.isTimeSpanInAxis(record);\n    }\n    onElementKeyDown(keyEvent) {\n        const\n            me              = this,\n            { navigator }   = me;\n        // If we're focused in the time axis, and *not* on an event, then ENTER means\n        // jump down into the first visible assignment in the cell.\n        if (me.focusedCell?.rowIndex !== -1 && me.focusedCell?.column === me.timeAxisColumn && !keyEvent.target.closest(navigator.itemSelector) && keyEvent.key === 'Enter') {\n            const firstAssignment = me.getFirstVisibleAssignment();\n            if (firstAssignment) {\n                me.navigateTo(firstAssignment, {\n                    uiEvent : keyEvent\n                });\n                return false;\n            }\n        }\n        else {\n            super.onElementKeyDown?.(keyEvent);\n        }\n    }\n    getFirstVisibleAssignment(location = this.focusedCell) {\n        const\n            me = this,\n            {\n                currentOrientation,\n                rowManager,\n                eventStore\n            } = me;\n        if (me.isHorizontal) {\n            let renderedEvents = currentOrientation.rowMap.get(rowManager.getRow(location.rowIndex));\n            if (renderedEvents?.length) {\n                return renderedEvents[0]?.elementData.assignmentRecord;\n            }\n            else {\n                renderedEvents = currentOrientation.resourceMap.get(location.id)?.eventsData;\n                if (renderedEvents?.length) {\n                    // When events are gathered from resource, we need to check they're available\n                    return renderedEvents.filter(e => eventStore.isAvailable(e.eventRecord))[0]?.assignmentRecord;\n                }\n            }\n        }\n        else {\n            const\n                firstResource = [...currentOrientation.resourceMap.values()][0],\n                renderedEvents = firstResource && Object.values(firstResource);\n            if (renderedEvents?.length) {\n                return renderedEvents.filter(e => eventStore.isAvailable(e.renderData.eventRecord))[0].renderData.assignmentRecord;\n            }\n        }\n    }\n    onGridBodyFocusIn(focusEvent) {\n        const isGridCellFocus = focusEvent.target.closest(this.focusableSelector);\n        // Event navigation only has a say when navigation is inside the TimeAxisSubGrid\n        if (this.timeAxisSubGridElement.contains(focusEvent.target)) {\n            const\n                me                  = this,\n                { navigationEvent } = me,\n                { target }          = focusEvent,\n                eventFocus          = target.closest(me.navigator.itemSelector),\n                destinationCell     = eventFocus ? me.normalizeCellContext({\n                    rowIndex : me.isVertical ? 0\n                        : me.resourceStore.indexOf(me.resolveResourceRecord(target)),\n                    column : me.timeAxisColumn,\n                    target\n                }) : new Location(target);\n            // Don't take over what the event navigator does if it's doing event navigation.\n            // Just silently cache our actionable location.\n            if (eventFocus) {\n                const { _focusedCell } = me;\n                me._focusedCell = destinationCell;\n                me.onCellNavigate?.(me, _focusedCell, destinationCell, navigationEvent, true);\n                return;\n            }\n            // Depending on how we got here, try to focus the first event in the cell *if we're in a cell*.\n            if (isGridCellFocus && (!navigationEvent || isArrowKey[navigationEvent.key])) {\n                const firstAssignment = me.getFirstVisibleAssignment(destinationCell);\n                if (firstAssignment) {\n                    me.navigateTo(firstAssignment, {\n                        // Only change scroll if focus came from key press\n                        scrollIntoView : Boolean(navigationEvent && navigationEvent.type !== 'mousedown'),\n                        uiEvent        : navigationEvent || focusEvent\n                    });\n                    return;\n                }\n            }\n        }\n        // Grid-level focus movement, let superclass handle it.\n        if (isGridCellFocus) {\n            super.onGridBodyFocusIn(focusEvent);\n        }\n    }\n    /*\n     * Override of GridNavigation#focusCell method to handle the TimeAxisColumn.\n     * Not needed until we implement full keyboard accessibility.\n     */\n    accessibleFocusCell(cellSelector, options) {\n        const me                     = this;\n        cellSelector = me.normalizeCellContext(cellSelector);\n        if (cellSelector.columnId === me.timeAxisColumn.id) {\n        }\n        else {\n            return super.focusCell(cellSelector, options);\n        }\n    }\n    // Interface method to extract the navigated to record from a populated 'navigate' event.\n    // Gantt, Scheduler and Calendar handle event differently, adding different properties to it.\n    // This method is meant to be overridden to return correct target from event\n    normalizeTarget(event) {\n        return event.assignmentRecord;\n    }\n    getPrevious(assignmentRecord, isDelete) {\n        const\n            me                     = this,\n            { resourceStore }      = me,\n            { eventSorter }        = me.currentOrientation,\n            // start/end dates are required to limit time span to look at in case recurrence feature is enabled\n            { startDate, endDate } = me.timeAxis,\n            eventRecord            = assignmentRecord.event,\n            resourceEvents         = me.eventStore\n                .getEvents({\n                    resourceRecord : assignmentRecord.resource,\n                    startDate,\n                    endDate\n                })\n                .filter(this.isInTimeAxis)\n                .sort(eventSorter);\n        let resourceRecord = assignmentRecord.resource,\n            previousEvent  = resourceEvents[resourceEvents.indexOf(eventRecord) - 1];\n        // At first event for resource, traverse up the resource store.\n        if (!previousEvent) {\n            // If we are deleting an event, skip other instances of the event which we may encounter\n            // due to multi-assignment.\n            for (\n                let rowIdx = resourceStore.indexOf(resourceRecord) - 1;\n                (!previousEvent || (isDelete && previousEvent === eventRecord)) && rowIdx >= 0;\n                rowIdx--\n            ) {\n                resourceRecord = resourceStore.getAt(rowIdx);\n                const events = me.eventStore\n                    .getEvents({\n                        resourceRecord,\n                        startDate,\n                        endDate\n                    })\n                    .filter(me.isInTimeAxis)\n                    .sort(eventSorter);\n                previousEvent = events.length && events[events.length - 1];\n            }\n        }\n        return me.assignmentStore.getAssignmentForEventAndResource(previousEvent, resourceRecord);\n    }\n    navigatePrevious(keyEvent) {\n        const\n            me                 = this,\n            previousAssignment = me.getPrevious(me.normalizeTarget(keyEvent));\n        keyEvent.preventDefault();\n        if (previousAssignment) {\n            if (!keyEvent.ctrlKey) {\n                me.clearEventSelection();\n            }\n            return me.navigateTo(previousAssignment, {\n                uiEvent : keyEvent\n            });\n        }\n        // No previous event/task, fall back to Grid's handling of this gesture\n        return me.doGridNavigation(keyEvent);\n    }\n    getNext(assignmentRecord, isDelete) {\n        const\n            me                     = this,\n            { resourceStore }      = me,\n            { eventSorter }        = me.currentOrientation,\n            // start/end dates are required to limit time span to look at in case recurrence feature is enabled\n            { startDate, endDate } = me.timeAxis,\n            eventRecord            = assignmentRecord.event,\n            resourceEvents         = me.eventStore\n                .getEvents({\n                    resourceRecord : assignmentRecord.resource,\n                    // start/end are required to limit time\n                    startDate,\n                    endDate\n                })\n                .filter(this.isInTimeAxis)\n                .sort(eventSorter);\n        let resourceRecord = assignmentRecord.resource,\n            nextEvent      = resourceEvents[resourceEvents.indexOf(eventRecord) + 1];\n        // At last event for resource, traverse down the resource store\n        if (!nextEvent) {\n            // If we are deleting an event, skip other instances of the event which we may encounter\n            // due to multi-assignment.\n            for (let rowIdx = resourceStore.indexOf(resourceRecord) + 1; (!nextEvent || (isDelete && nextEvent === eventRecord)) && rowIdx < resourceStore.count; rowIdx++) {\n                resourceRecord = resourceStore.getAt(rowIdx);\n                const events = me.eventStore\n                    .getEvents({\n                        resourceRecord,\n                        startDate,\n                        endDate\n                    })\n                    .filter(me.isInTimeAxis)\n                    .sort(eventSorter);\n                nextEvent = events[0];\n            }\n        }\n        return me.assignmentStore.getAssignmentForEventAndResource(nextEvent, resourceRecord);\n    }\n    navigateNext(keyEvent) {\n        const\n            me             = this,\n            nextAssignment = me.getNext(me.normalizeTarget(keyEvent));\n        keyEvent.preventDefault();\n        if (nextAssignment) {\n            if (!keyEvent.ctrlKey) {\n                me.clearEventSelection();\n            }\n            return me.navigateTo(nextAssignment, {\n                uiEvent : keyEvent\n            });\n        }\n        // No next event/task, fall back to Grid's handling of this gesture\n        return me.doGridNavigation(keyEvent);\n    }\n    doGridNavigation(keyEvent) {\n        if (!keyEvent.handled && keyEvent.key.indexOf('Arrow') === 0) {\n            this[`navigate${keyEvent.key.substring(5)}ByKey`](keyEvent);\n        }\n    }\n    async navigateTo(targetAssignment, {\n        scrollIntoView = true,\n        uiEvent        = {}\n    } = emptyObject) {\n        const\n            me                      = this,\n            { navigator }           = me,\n            { skipScrollIntoView }  = navigator;\n        if (targetAssignment) {\n            if (scrollIntoView) {\n                // No key processing during scroll\n                navigator.disabled = true;\n                await me.scrollAssignmentIntoView(targetAssignment, animate100);\n                navigator.disabled = false;\n            }\n            else {\n                navigator.skipScrollIntoView = true;\n            }\n            // Panel can be destroyed before promise is resolved\n            // Perform a sanity check to make sure element is still in the DOM (syncIdMap actually).\n            if (!me.isDestroyed && this.getElementFromAssignmentRecord(targetAssignment)) {\n                me.activeAssignment = targetAssignment;\n                navigator.skipScrollIntoView = skipScrollIntoView;\n                navigator.trigger('navigate', {\n                    event : uiEvent,\n                    item  : me.getElementFromAssignmentRecord(targetAssignment).closest(navigator.itemSelector)\n                });\n            }\n        }\n    }\n    set activeAssignment(assignmentRecord) {\n        const assignmentEl = this.getElementFromAssignmentRecord(assignmentRecord, true);\n        if (assignmentEl) {\n            this.navigator.activeItem = assignmentEl;\n        }\n    }\n    get activeAssignment() {\n        const { activeItem } = this.navigator;\n        if (activeItem) {\n            return this.resolveAssignmentRecord(activeItem);\n        }\n    }\n    get previousActiveEvent() {\n        const { previousActiveItem } = this.navigator;\n        if (previousActiveItem) {\n            return this.resolveEventRecord(previousActiveItem);\n        }\n    }\n    processEvent(keyEvent) {\n        const\n            me           = this,\n            eventElement = keyEvent.target.closest(me.eventSelector);\n        if (!me.navigator.disabled && eventElement) {\n            keyEvent.assignmentRecord = me.resolveAssignmentRecord(eventElement);\n            keyEvent.eventRecord = me.resolveEventRecord(eventElement);\n            keyEvent.resourceRecord = me.resolveResourceRecord(eventElement);\n        }\n        return keyEvent;\n    }\n    onDeleteKey(keyEvent) {\n        const me = this;\n        if (!me.readOnly && me.enableDeleteKey) {\n            const records = me.eventStore.usesSingleAssignment ? me.selectedEvents : me.selectedAssignments;\n            me.removeEvents(records.filter(r => !r.readOnly));\n        }\n    }\n    onArrowUpKey(keyEvent) {\n        this.focusCell({\n            rowIndex : this.focusedCell.rowIndex - 1,\n            column   : this.timeAxisColumn\n        });\n        keyEvent.handled = true;\n    }\n    onArrowDownKey(keyEvent) {\n        if (this.focusedCell.rowIndex < this.resourceStore.count - 1) {\n            this.focusCell({\n                rowIndex : this.focusedCell.rowIndex + 1,\n                column   : this.timeAxisColumn\n            });\n            keyEvent.handled = true;\n        }\n    }\n    onEscapeKey(keyEvent) {\n        if (!keyEvent.target.closest('.b-dragging')) {\n            this.focusCell({\n                rowIndex : this.focusedCell.rowIndex,\n                column   : this.timeAxisColumn\n            });\n            keyEvent.handled = true;\n        }\n    }\n    onEventSpaceKey(keyEvent) {\n        // Empty, to be chained by features\n    }\n    onEventEnterKey(keyEvent) {\n        // Empty, to be chained by features\n    }\n    get isActionableLocation() {\n        // Override from grid if the Navigator's location is an event (or task if we're in Gantt)\n        // Being focused on a task/event means that it's *not* actionable. It's not valid to report\n        // that we're \"inside\" the cell in a TimeLine, so ESC must not attempt to focus the cell.\n        if (!this.navigator.activeItem) {\n            return super.isActionableLocation;\n        }\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "/**\n * @module Scheduler/view/mixin/TransactionalFeatureMixin\n */\n/**\n * This mixin declares a common config to disable feature transactions in components which support scheduling engine:\n * SchedulerPro and Gantt.\n * @mixin\n */\nexport default Target => class TransactionalFeatureMixin extends Target {\n    static get $name() {\n        return 'TransactionalFeatureMixin';\n    }\n    static configurable = {\n        /**\n         * When true, some features will start a project transaction, blocking the project queue, suspending\n         * store events and preventing UI from updates. It behaves similar to\n         * {@link Grid.column.Column#config-instantUpdate} set to `false`.\n         * Set `false` to not use project queue.\n         * @config {Boolean}\n         * @internal\n         * @default\n         */\n        enableTransactionalFeatures : false,\n        testConfig : {\n            enableTransactionalFeatures : false\n        }\n    };\n    get widgetClass() {}\n    /**\n     * Returns `true` if queue is supported and enabled\n     * @member {Boolean}\n     * @internal\n     * @readonly\n     */\n    get transactionalFeaturesEnabled() {\n        return this.enableTransactionalFeatures && this.project?.queue;\n    }\n};\n", "/**\n * @module Scheduler/data/mixin/AttachToProjectMixin\n */\n/**\n * Mixin that calls the target class `attachToProject()` function when a new project is assigned to Scheduler/Gantt.\n *\n * @mixin\n */\nexport default Target => class AttachToProjectMixin extends Target {\n    static get $name() {\n        return 'AttachToProjectMixin';\n    }\n    async afterConstruct() {\n        super.afterConstruct();\n        const\n            me            = this,\n            projectHolder = (me.client || me.grid),\n            { project }   = projectHolder;\n        projectHolder.projectSubscribers?.push(me);\n        // Attach to already existing stores\n        if (project) {\n            me.attachToProject(project);\n            me.attachToResourceStore(project.resourceStore);\n            me.attachToEventStore(project.eventStore);\n            me.attachToAssignmentStore(project.assignmentStore);\n            me.attachToDependencyStore(project.dependencyStore);\n            me.attachToCalendarManagerStore(project.calendarManagerStore);\n        }\n    }\n    /**\n     * Override to take action when the project instance is replaced.\n     *\n     * @param {Scheduler.model.ProjectModel} project\n     */\n    attachToProject(project) {\n        this.detachListeners('project');\n        this._project = project;\n        super.attachToProject?.(project);\n    }\n    detachFromProject(project) {\n        super.detachFromProject?.(project);\n    }\n    /**\n     * Override to take action when the EventStore instance is replaced, either from being replaced on the project or\n     * from assigning a new project.\n     *\n     * @param {Scheduler.data.EventStore} store\n     */\n    attachToEventStore(store) {\n        this.detachListeners('eventStore');\n        super.attachToEventStore?.(store);\n    }\n    /**\n     * Override to take action when the ResourceStore instance is replaced, either from being replaced on the project\n     * or from assigning a new project.\n     *\n     * @param {Scheduler.data.ResourceStore} store\n     */\n    attachToResourceStore(store) {\n        this.detachListeners('resourceStore');\n        super.attachToResourceStore?.(store);\n    }\n    /**\n     * Override to take action when the AssignmentStore instance is replaced, either from being replaced on the project\n     * or from assigning a new project.\n     *\n     * @param {Scheduler.data.AssignmentStore} store\n     */\n    attachToAssignmentStore(store) {\n        this.detachListeners('assignmentStore');\n        super.attachToAssignmentStore?.(store);\n    }\n    /**\n     * Override to take action when the DependencyStore instance is replaced, either from being replaced on the project\n     * or from assigning a new project.\n     *\n     * @param {Scheduler.data.DependencyStore} store\n     */\n    attachToDependencyStore(store) {\n        this.detachListeners('dependencyStore');\n        super.attachToDependencyStore?.(store);\n    }\n    /**\n     * Override to take action when the CalendarManagerStore instance is replaced, either from being replaced on the\n     * project or from assigning a new project.\n     *\n     * @param {Core.data.Store} store\n     */\n    attachToCalendarManagerStore(store) {\n        this.detachListeners('calendarManagerStore');\n        super.attachToCalendarManagerStore?.(store);\n    }\n    get project() {\n        return this._project;\n    }\n    get calendarManagerStore() {\n        return this.project.calendarManagerStore;\n    }\n    get assignmentStore() {\n        return this.project.assignmentStore;\n    }\n    get resourceStore() {\n        return this.project.resourceStore;\n    }\n    get eventStore() {\n        return this.project.eventStore;\n    }\n    get dependencyStore() {\n        return this.project.dependencyStore;\n    }\n};\n", "import BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\nimport Base from '../../../Core/Base.js';\nimport Model from '../../../Core/data/Model.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\n/**\n * @module Scheduler/view/orientation/HorizontalRendering\n */\n/**\n * @typedef HorizontalRenderData\n * @property {Scheduler.model.EventModel} eventRecord\n * @property {Date} start Span start\n * @property {Date} end Span end\n * @property {String} rowId Id of the resource row\n * @property {DomConfig[]} children Child elements\n * @property {Number} startMS Wrap element start in milliseconds\n * @property {Number} endMS Span Wrap element end in milliseconds\n * @property {Number} durationMS Wrap duration in milliseconds (not just a difference between start and end)\n * @property {Number} innerStartMS Actual event start in milliseconds\n * @property {Number} innerEndMS Actual event end in milliseconds\n * @property {Number} innerDurationMS Actual event duration in milliseconds\n * @property {Boolean} startsOutsideView True if span starts before time axis start\n * @property {Boolean} endsOutsideView True if span ends after time axis end\n * @property {Number} left Absolute left coordinate of the wrap element\n * @property {Number} width\n * @property {Number} top Absolute top coordinate of the wrap element (can be changed by layout)\n * @property {Number} height\n * @property {Boolean} clippedStart True if start is clipped\n * @property {Boolean} clippedEnd True if end is clipped\n * @private\n */\nconst\n    releaseEventActions = {\n        releaseElement : 1, // Not used at all at the moment\n        reuseElement   : 1  // Used by some other element\n    },\n    renderEventActions  = {\n        newElement      : 1,\n        reuseOwnElement : 1,\n        reuseElement    : 1\n    },\n    MAX_WIDTH           = 9999999,\n    heightEventSorter   = ({ startDateMS : lhs }, { startDateMS : rhs }) => lhs - rhs,\n    chronoFields        = {\n        startDate : 1,\n        endDate   : 1,\n        duration  : 1\n    };\nfunction getStartEnd(scheduler, eventRecord, useEnd, fieldName, useEventBuffer) {\n    // Must use Model.get in order to get latest values in case we are inside a batch.\n    // EventResize changes the endDate using batching to enable a tentative change\n    // via the batchedUpdate event which is triggered when changing a field in a batch.\n    // Fall back to accessor if propagation has not populated date fields.\n    const\n        { timeAxis }     = scheduler,\n        date             = eventRecord.isBatchUpdating && !useEventBuffer ? eventRecord.get(fieldName) : eventRecord[fieldName],\n        hasBatchedChange = eventRecord.hasBatchedChange?.(fieldName),\n        // fillTicks shouldn't be used during resizing for changing date for smooth animation.\n        // correct date will be applied after resize, when `isResizing` will be falsy\n        useTickDates     = scheduler.fillTicks && (!eventRecord.meta?.isResizing || !hasBatchedChange);\n    if (useTickDates) {\n        let tick = timeAxis.getTickFromDate(date);\n        if (tick >= 0) {\n            // If date matches a tick start/end, use the earlier tick\n            if (useEnd && tick === Math.round(tick) && tick > 0) {\n                tick--;\n            }\n            const\n                tickIndex  = Math.floor(tick),\n                tickRecord = timeAxis.getAt(tickIndex);\n            return tickRecord[fieldName].getTime();\n        }\n    }\n    return date?.getTime();\n}\n/**\n * Handles event rendering in Schedulers horizontal mode. Reacts to project/store changes to keep the UI up to date.\n *\n * @internal\n */\nexport default class HorizontalRendering extends Base.mixin(AttachToProjectMixin) {\n    //region Config & Init\n    static $name = 'HorizontalRendering';\n    static get configurable() {\n        return {\n            /**\n             * Amount of pixels to extend the current visible range at both ends with when deciding which events to\n             * render. Only applies when using labels or for milestones\n             * @config {Number}\n             * @default\n             */\n            bufferSize : 150,\n            verticalBufferSize : 150\n        };\n    }\n    static get properties() {\n        return {\n            // Map with event DOM configs, keyed by resource id\n            resourceMap            : new Map(),\n            // Map with visible events DOM configs, keyed by row instance\n            rowMap                 : new Map(),\n            eventConfigs           : [],\n            // Flag to avoid transitioning on first refresh\n            isFirstRefresh         : true,\n            toDrawOnProjectRefresh : new Set(),\n            toDrawOnDataReady      : new Set()\n        };\n    }\n    construct(scheduler) {\n        const me = this;\n        me.client = me.scheduler = scheduler;\n        me.eventSorter = me.eventSorter.bind(scheduler);\n        me.scrollBuffer = scheduler.scrollBuffer;\n        // Catch scroll before renderers are called\n        scheduler.scrollable.ion({\n            scroll  : 'onEarlyScroll',\n            prio    : 1,\n            thisObj : me\n        });\n        scheduler.rowManager.ion({\n            name            : 'rowManager',\n            renderDone      : 'onRenderDone',\n            removeRows      : 'onRemoveRows',\n            translateRow    : 'onTranslateRow',\n            offsetRows      : 'onOffsetRows',\n            beforeRowHeight : 'onBeforeRowHeightChange',\n            thisObj         : me\n        });\n        super.construct({});\n    }\n    init() {}\n    updateVerticalBufferSize() {\n        const { rowManager } = this.scheduler;\n        if (this.scheduler.isPainted) {\n            // Refresh rows when vertical buffer size changes to trigger event repaint. Required for the export feature.\n            rowManager.renderRows(rowManager.rows);\n        }\n    }\n    //endregion\n    //region Region, dates & coordinates\n    get visibleDateRange() {\n        return this._visibleDateRange;\n    }\n    getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {\n        const { scheduler } = this;\n        let coord = xy[0];\n        if (!local) {\n            coord = this.translateToScheduleCoordinate(coord);\n        }\n        coord = scheduler.getRtlX(coord);\n        return scheduler.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);\n    }\n    translateToScheduleCoordinate(x) {\n        const\n            { scheduler }  = this,\n            { scrollable } = scheduler.timeAxisSubGrid;\n        let result = x - scheduler.timeAxisSubGridElement.getBoundingClientRect().left - globalThis.scrollX;\n        // Because we use getBoundingClientRect's left, we have to adjust for page scroll.\n        // The vertical counterpart uses the _bodyRectangle which was created with that adjustment.\n        if (scheduler.rtl) {\n            result += scrollable.maxX - Math.abs(scheduler.scrollLeft);\n        }\n        else {\n            result += scheduler.scrollLeft;\n        }\n        return result;\n    }\n    translateToPageCoordinate(x) {\n        const\n            { scheduler }  = this,\n            { scrollable } = scheduler.timeAxisSubGrid;\n        let result = x + scheduler.timeAxisSubGridElement.getBoundingClientRect().left;\n        if (scheduler.rtl) {\n            result -= scrollable.maxX - Math.abs(scheduler.scrollLeft);\n        }\n        else {\n            result -= scheduler.scrollLeft;\n        }\n        return result;\n    }\n    /**\n     * Gets the region, relative to the page, represented by the schedule and optionally only for a single resource.\n     * This method will call getDateConstraints to allow for additional resource/event based constraints. By overriding\n     * that method you can constrain events differently for different resources.\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] (optional) The row record\n     * @param {Scheduler.model.EventModel} [eventRecord] (optional) The event record\n     * @returns {Core.helper.util.Rectangle} The region of the schedule\n     */\n    getScheduleRegion(resourceRecord, eventRecord, local = true, dateConstraints, stretch = false) {\n        const\n            me                                   = this,\n            { scheduler }                        = me,\n            { timeAxisSubGridElement, timeAxis } = scheduler,\n            { start, end }                       = (!stretch || resourceRecord) && scheduler.getResourceMarginObject(resourceRecord) || { start : 0, end : 0 };\n        let region;\n        if (resourceRecord) {\n            const\n                row          = scheduler.getRowById(resourceRecord.id),\n                eventElement = eventRecord && scheduler.getElementsFromEventRecord(eventRecord, resourceRecord)[0];\n            // If the row is in rendered space, use its rectangle.\n            // If not, use the calculated rectangle. This will be adjusted as we respond\n            // to change events\n            region = row ? Rectangle.from(row.getElement('normal'), timeAxisSubGridElement) : scheduler.getRecordCoords(resourceRecord, true);\n            if (eventElement) {\n                const eventRegion = Rectangle.from(eventElement, timeAxisSubGridElement);\n                region.y      = eventRegion.y;\n                region.bottom = eventRegion.bottom;\n            }\n            else {\n                region.y      = region.y + start;\n                region.bottom = region.bottom - end;\n            }\n        }\n        else {\n            // The coordinate space needs to be sorted out here!\n            region       = Rectangle.from(timeAxisSubGridElement).moveTo(null, 0);\n            region.width = timeAxisSubGridElement.scrollWidth;\n            region.y      = region.y + start;\n            region.bottom = region.bottom - end;\n        }\n        const\n            taStart = timeAxis.startDate,\n            taEnd   = timeAxis.endDate;\n        dateConstraints = (dateConstraints?.start && dateConstraints) || scheduler.getDateConstraints?.(resourceRecord, eventRecord) || {\n            start : taStart,\n            end   : taEnd\n        };\n        let startX = scheduler.getCoordinateFromDate(dateConstraints.start ? DateHelper.max(taStart, dateConstraints.start) : taStart),\n            endX   = scheduler.getCoordinateFromDate(dateConstraints.end ? DateHelper.min(taEnd, dateConstraints.end) : taEnd);\n        if (!local) {\n            startX = me.translateToPageCoordinate(startX);\n            endX   = me.translateToPageCoordinate(endX);\n        }\n        region.left  = Math.min(startX, endX);\n        region.right = Math.max(startX, endX);\n        return region;\n    }\n    /**\n     * Gets the Region, relative to the timeline view element, representing the passed row and optionally just for a\n     * certain date interval.\n     * @param {Core.data.Model} rowRecord The row record\n     * @param {Date} startDate A start date constraining the region\n     * @param {Date} endDate An end date constraining the region\n     * @returns {Core.helper.util.Rectangle} The Rectangle which encapsulates the row\n     */\n    getRowRegion(rowRecord, startDate, endDate) {\n        const\n            { scheduler } = this,\n            { timeAxis }  = scheduler,\n            row           = scheduler.getRowById(rowRecord.id);\n        // might not be rendered\n        if (!row) {\n            return null;\n        }\n        const\n            taStart = timeAxis.startDate,\n            taEnd   = timeAxis.endDate,\n            start   = startDate ? DateHelper.max(taStart, startDate) : taStart,\n            end     = endDate ? DateHelper.min(taEnd, endDate) : taEnd,\n            startX  = scheduler.getCoordinateFromDate(start),\n            endX    = scheduler.getCoordinateFromDate(end, true, true),\n            y       = row.top,\n            x       = Math.min(startX, endX),\n            bottom  = y + row.offsetHeight;\n        return new Rectangle(x, y, Math.max(startX, endX) - x, bottom - y);\n    }\n    getResourceEventBox(eventRecord, resourceRecord, includeOutside, roughly = false) {\n        const\n            { scheduler } = this,\n            resourceData  = this.resourceMap.get(resourceRecord.id);\n        let eventLayout = null,\n            approx      = false;\n        if (resourceData) {\n            eventLayout = resourceData.eventsData.find(d => d.eventRecord === eventRecord);\n        }\n        // Outside of view, layout now if supposed to be included\n        if (!eventLayout) {\n            eventLayout = this.getTimeSpanRenderData(\n                eventRecord,\n                resourceRecord,\n                { viewport : true, timeAxis : includeOutside }\n            );\n            approx = true;\n        }\n        if (eventLayout) {\n            // Event layout is relative to row, need to make to absolute before returning\n            const\n                // Event might be outside visible area, estimate the height (for managedEventSizing = false case)\n                boxHeight   = eventLayout.height ?? scheduler.getResourceLayoutSettings(resourceRecord).contentHeight,\n                rowBox      = scheduler.rowManager.getRecordCoords(resourceRecord, true, roughly),\n                absoluteTop = eventLayout.top + rowBox.top,\n                box         = new Rectangle(eventLayout.left, absoluteTop, eventLayout.width, boxHeight);\n            // Flag informing other parts of the code that this box is approximated\n            box.layout    = !approx;\n            box.rowTop    = rowBox.top;\n            box.rowBottom = rowBox.bottom;\n            box.resourceId = resourceRecord.id;\n            return box;\n        }\n        return null;\n    }\n    //endregion\n    //region Element <-> Record mapping\n    resolveRowRecord(elementOrEvent) {\n        const\n            me            = this,\n            { scheduler } = me,\n            element       = elementOrEvent.nodeType ? elementOrEvent : elementOrEvent.target,\n            // Fix for FF on Linux having text nodes as event.target\n            el            = element.nodeType === Element.TEXT_NODE ? element.parentElement : element,\n            eventNode     = el.closest(scheduler.eventSelector);\n        if (eventNode) {\n            return me.resourceStore.getById(eventNode.dataset.resourceId);\n        }\n        // When resourceNonWorkingTime.enableMouseEvents is set to true, and the current element is a resource non working time range,\n        // in order to get the corresponding resource row, we need to read from data-resource-id attribute.\n        // That's because element has not a .b-grid-row as parent when enableMouseEvents is set to true.\n        if (!el.closest('.b-grid-row') && el.dataset.resourceId) {\n            return me.resourceStore.getById(el.dataset.resourceId);\n        }\n        return scheduler.getRecordFromElement(el);\n    }\n    //endregion\n    //region Project\n    attachToProject(project) {\n        super.attachToProject(project);\n        this.refreshAllWhenReady = true;\n        // Perform a full clear when replacing the project, to not leave any references to old project in DOM\n        if (!this.scheduler.isConfiguring) {\n            this.clearAll({ clearDom : true });\n        }\n        project?.ion({\n            name            : 'project',\n            refresh         : 'onProjectRefresh',\n            commitFinalized : 'onProjectCommitFinalized',\n            thisObj         : this\n        });\n    }\n    onProjectCommitFinalized() {\n        const { scheduler, toDrawOnDataReady, project } = this;\n        // Only update the UI immediately if we are visible\n        if (scheduler.isVisible) {\n            if (scheduler.isPainted && !scheduler.refreshSuspended) {\n                // If this is a timezone commit, we got here from a store dataset\n                // We need to do a full refresh\n                if (!toDrawOnDataReady.size && project.timeZone != null && project.ignoreRecordChanges) {\n                    project.resourceStore.forEach(r => toDrawOnDataReady.add(r.id));\n                }\n                if (toDrawOnDataReady.size) {\n                    this.clearResources(toDrawOnDataReady);\n                    this.refreshResources(toDrawOnDataReady);\n                }\n                toDrawOnDataReady.clear();\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            scheduler.whenVisible('refreshRows');\n        }\n    }\n    onProjectRefresh({ isCalculated, isInitialCommit }) {\n        const\n            me                                    = this,\n            { scheduler, toDrawOnProjectRefresh } = me;\n        // Only update the UI immediately if we are visible\n        if (scheduler.isVisible) {\n            if (scheduler.isPainted && !scheduler.isConfiguring && !scheduler.refreshSuspended) {\n                // Either refresh all rows (on for example dataset or when delayed calculations are finished)\n                if (me.refreshAllWhenReady || (isInitialCommit && isCalculated)) {\n                    scheduler.calculateAllRowHeights(true);\n                    const { rowManager } = scheduler;\n                    // Rows rendered? Refresh\n                    if (rowManager.topRow) {\n                        me.clearAll();\n                        // Refresh only if it won't be refreshed elsewhere (SchedulerStore#onProjectRefresh())\n                        if (!scheduler.refreshAfterProjectRefresh) {\n                            // If refresh was suspended when replacing the dataset in a scrolled view we might end up with a\n                            // topRow outside of available range -> reset it. Call renderRows() to mimic what normally happens\n                            // when refresh is not suspended\n                            if (rowManager.topRow.dataIndex >= scheduler.store.count) {\n                                scheduler.renderRows(false);\n                            }\n                            else {\n                                // Don't transition first refresh / early render\n                                scheduler.refreshWithTransition(false, !me.isFirstRefresh && isCalculated && !isInitialCommit);\n                            }\n                        }\n                        me.isFirstRefresh = false;\n                    }\n                    // No rows yet, reinitialize (happens if initial project empty and then non empty project assigned)\n                    else {\n                        rowManager.reinitialize();\n                    }\n                    me.refreshAllWhenReady = false;\n                }\n                // Or only affected rows (if any)\n                else if (toDrawOnProjectRefresh.size) {\n                    me.refreshResources(toDrawOnProjectRefresh);\n                }\n                toDrawOnProjectRefresh.clear();\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            scheduler.whenVisible('refresh', scheduler, [true]);\n        }\n    }\n    //endregion\n    //region AssignmentStore\n    attachToAssignmentStore(assignmentStore) {\n        this.refreshAllWhenReady = true;\n        super.attachToAssignmentStore(assignmentStore);\n        if (assignmentStore) {\n            assignmentStore.ion({\n                name             : 'assignmentStore',\n                changePreCommit  : 'onAssignmentStoreChange',\n                refreshPreCommit : 'onAssignmentStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n    onAssignmentStoreChange({ source, action, records : assignmentRecords = [], replaced, changes }) {\n        const\n            me            = this,\n            { scheduler } = me,\n            resourceIds   = new Set(assignmentRecords.flatMap(assignmentRecord => ([\n                assignmentRecord.resourceId,\n                // Also include any linked resources (?. twice since resource might not be resolved and point to id)\n                ...assignmentRecord.resource?.$links?.map(link => link.id) ?? []\n            ])));\n        // Ignore assignment changes caused by removing resources, the remove will redraw things anyway\n        // Also ignore case when resource id is changed. In this case row will be refreshed by the grid\n        if (me.resourceStore.isRemoving || me.resourceStore.isChangingId) {\n            return;\n        }\n        switch (action) {\n            // These operations will invalidate the graph, need to draw later\n            case 'dataset': {\n                // Ignore dataset when using single assignment mode\n                if (!me.eventStore.usesSingleAssignment) {\n                    if (resourceIds.size) {\n                        me.refreshResourcesWhenReady(resourceIds);\n                    }\n                    else {\n                        me.clearAll();\n                        scheduler.refreshWithTransition();\n                    }\n                }\n                return;\n            }\n            case 'add':\n            case 'remove':\n            case 'updateMultiple':\n                me.refreshResourcesWhenReady(resourceIds);\n                return;\n            case 'removeall':\n                me.refreshAllWhenReady = true;\n                return;\n            case 'replace':\n                // Gather resources from both the old record and the new one\n                replaced.forEach(([oldAssignment, newAssignment]) => {\n                    resourceIds.add(oldAssignment.resourceId);\n                    resourceIds.add(newAssignment.resourceId);\n                });\n                // And refresh them\n                me.refreshResourcesWhenReady(resourceIds);\n                return;\n            // These operations won't invalidate the graph, redraw now\n            case 'filter':\n                me.clearAll();\n                scheduler.calculateAllRowHeights(true);\n                scheduler.refreshWithTransition();\n                return;\n            case 'update': {\n                if ('eventId' in changes || 'resourceId' in changes || 'id' in changes) {\n                    // When reassigning, clear old resource also\n                    if ('resourceId' in changes) {\n                        resourceIds.add(changes.resourceId.oldValue);\n                    }\n                    // When chaining stores in single assignment mode, we might not be the project store\n                    if (source === scheduler.project.assignmentStore) {\n                        me.refreshResourcesOnDataReady(resourceIds);\n                    }\n                    // Refresh directly when we are not\n                    else {\n                        me.refreshResources(resourceIds);\n                    }\n                }\n                break;\n            }\n            case 'clearchanges': {\n                const { added, modified, removed } = changes;\n                // If modified records appear in the clearchanges action we need to refresh entire view\n                // because we have not enough information about previously assigned resource\n                if (modified.length) {\n                    scheduler.refreshWithTransition();\n                }\n                else {\n                    added.forEach(r => resourceIds.add(r.resourceId));\n                    removed.forEach(r => resourceIds.add(r.resourceId));\n                    me.refreshResourcesOnDataReady(resourceIds);\n                }\n            }\n        }\n    }\n    onAssignmentStoreRefresh({ action, records }) {\n        if (action === 'batch') {\n            this.clearAll();\n            this.scheduler.refreshWithTransition();\n        }\n    }\n    //endregion\n    //region EventStore\n    attachToEventStore(eventStore) {\n        this.refreshAllWhenReady = true;\n        super.attachToEventStore(eventStore);\n        if (eventStore) {\n            eventStore.ion({\n                name             : 'eventStore',\n                addConfirmed     : 'onEventStoreAddConfirmed',\n                refreshPreCommit : 'onEventStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n    onEventStoreAddConfirmed({ record }) {\n        for (const element of this.client.getElementsFromEventRecord(record)) {\n            element.classList.remove('b-iscreating');\n        }\n    }\n    onEventStoreRefresh({ action }) {\n        if (action === 'batch') {\n            const { scheduler } = this;\n            if (scheduler.isEngineReady && scheduler.isPainted) {\n                this.clearAll();\n                scheduler.refreshWithTransition();\n            }\n        }\n    }\n    onEventStoreChange({ action, records : eventRecords = [], record, replaced, changes, source }) {\n        const\n            me                  = this,\n            { scheduler }       = me,\n            isResourceTimeRange = source.isResourceTimeRangeStore,\n            resourceIds         = new Set();\n        if (!scheduler.isPainted) {\n            return;\n        }\n        eventRecords.forEach(eventRecord => {\n            // Update all resource rows to which this event is assigned *if* the resourceStore\n            // contains that resource (We could have filtered the resourceStore)\n            const renderedEventResources = eventRecord.$linkedResources?.filter(r => me.resourceStore.includes(r));\n            // When rendering a Gantt project, the project model also passes through here -> no `resources`\n            renderedEventResources?.forEach(resourceRecord => resourceIds.add(resourceRecord.id));\n        });\n        if (isResourceTimeRange) {\n            switch (action) {\n                // - dataset cant pass through same path as events, which relies on project being invalidated. and\n                // resource time ranges does not pass through engine\n                // - removeall also needs special path, since no resources to redraw will be collected\n                case 'removeall':\n                case 'dataset':\n                    me.clearAll();\n                    scheduler.refreshWithTransition();\n                    return;\n            }\n            me.refreshResources(resourceIds);\n        }\n        else {\n            switch (action) {\n                // No-ops\n                case 'batch': // Handled elsewhere, don't want it to clear again\n                case 'sort':  // Order in EventStore does not matter, so these actions are no-ops\n                case 'group':\n                case 'move':\n                    return;\n                case 'remove':\n                    // Remove is a no-op since assignment will also be removed\n                    return;\n                case 'clearchanges':\n                    me.clearAll();\n                    scheduler.refreshWithTransition();\n                    return;\n                case 'dataset': {\n                    me.clearAll();\n                    // This is mainly for chained stores, where data is set from main store without project being\n                    // invalidated. Nothing to wait for, refresh now\n                    if (scheduler.isEngineReady) {\n                        scheduler.refreshWithTransition();\n                    }\n                    else {\n                        me.refreshAllWhenReady = true;\n                    }\n                    return;\n                }\n                case 'add':\n                case 'updateMultiple':\n                    // Just refresh below\n                    break;\n                case 'replace':\n                    // Gather resources from both the old record and the new one\n                    replaced.forEach(([, newEvent]) => {\n                        // Old cleared by changed assignment\n                        newEvent.resources.map(resourceRecord => resourceIds.add(resourceRecord.id));\n                    });\n                    break;\n                case 'removeall':\n                case 'filter':\n                    // Filter might be caused by add retriggering filters, in which case we need to refresh later\n                    if (!scheduler.isEngineReady) {\n                        me.refreshAllWhenReady = true;\n                        return;\n                    }\n                    // Clear all when filtering for simplicity. If that turns out to give bad performance, one would need to\n                    // figure out which events was filtered out and only clear their resources.\n                    me.clearAll();\n                    scheduler.calculateAllRowHeights(true);\n                    scheduler.refreshWithTransition();\n                    return;\n                case 'update': {\n                    // Check if changes are graph related or not\n                    const allChrono = record.$entity\n                        ? !Object.keys(changes).some(name => !record.$entity.getField(name))\n                        : !Object.keys(changes).some(name => !chronoFields[name]);\n                    let dateChanges = 0;\n                    'startDate' in changes && dateChanges++;\n                    'endDate' in changes && dateChanges++;\n                    'duration' in changes && dateChanges++;\n                    if ('resourceId' in changes) {\n                        resourceIds.add(changes.resourceId.oldValue);\n                    }\n                    // If we have a set of resources to update, refresh them.\n                    // Always redraw non chrono changes (name etc) and chrono changes that can affect appearance\n                    if (\n                        resourceIds.size && (\n                            !allChrono ||\n                            // Skip case when changed \"duration\" only (w/o start/end affected)\n                            dateChanges && !('duration' in changes && dateChanges === 1) ||\n                            'percentDone' in changes ||\n                            'inactive' in changes ||\n                            'constraintDate' in changes ||\n                            'constraintType' in changes ||\n                            'segments' in changes\n                        )\n                    ) {\n                        const { eventResize, eventDragCreate } = scheduler.features;\n                        // Cheaper updates when resizing/drag creating using lockLayout\n                        if (record.isBatchUpdating && ((eventResize?.isResizing && eventResize.lockLayout) || (eventDragCreate?.isResizing && eventDragCreate.lockLayout))) {\n                            for (const id of resourceIds) {\n                                me.refreshEventsForResource(scheduler.resourceStore.getById(id), undefined, false);\n                            }\n                            me.onRenderDone();\n                        }\n                        // If we are finalizing data loading let's delay the resources refresh till all the\n                        // propagation results get into stores\n                        else if (me.project?.propagatingLoadChanges || me.project?.isWritingData) {\n                            me.refreshResourcesOnDataReady(resourceIds);\n                        }\n                        else {\n                            me.refreshResources(resourceIds);\n                        }\n                    }\n                    return;\n                }\n            }\n            me.refreshResourcesWhenReady(resourceIds);\n        }\n    }\n    //endregion\n    //region ResourceStore\n    attachToResourceStore(resourceStore) {\n        this.refreshAllWhenReady = true;\n        super.attachToResourceStore(resourceStore);\n        if (resourceStore) {\n            this.clearAll({ clearLayoutCache : true });\n            resourceStore.ion({\n                name            : 'resourceStore',\n                changePreCommit : 'onResourceStoreChange',\n                thisObj         : this\n            });\n        }\n    }\n    get resourceStore() {\n        return this.client.store;\n    }\n    onResourceStoreChange({ action, isExpand, records, changes }) {\n        const\n            me          = this,\n            // Update link + original when asked for link\n            resourceIds = records?.flatMap(r => r.isLinked ? [r.id, r.$originalId] : [r.id]);\n        if (!me.scheduler.isPainted) {\n            return;\n        }\n        switch (action) {\n            case 'add':\n                // #635 Events disappear when toggling other node\n                // If we are expanding project won't fire refresh event\n                if (!isExpand) {\n                    // Links won't cause calculations, refresh now\n                    if (records.every(r => r.isLinked)) {\n                        me.refreshResources(resourceIds);\n                    }\n                    // Otherwise refresh when project is ready\n                    else {\n                        me.refreshResourcesWhenReady(resourceIds);\n                    }\n                }\n                return;\n            case 'update': {\n                // Ignore changes from project commit, if they affect events they will be redrawn anyway\n                // Also ignore explicit transformation of leaf <-> parent\n                if (!me.project.isChangeTrackingSuspended && !changes.isLeaf) {\n                    // Resource changes might affect events, refresh\n                    me.refreshResources(resourceIds);\n                }\n                return;\n            }\n            case 'filter':\n                // Bail out on filter action. Map was already updated on `refresh` event triggered before this `change`\n                // one. And extra records are removed from rowMap by `onRemoveRows`\n                return;\n            case 'removeall':\n                me.clearAll({ clearLayoutCache : true });\n                return;\n            // We must not clear all resources when whole dataset changes\n            // https://github.com/bryntum/support/issues/3292\n            case 'dataset':\n                return;\n        }\n        resourceIds && me.clearResources(resourceIds);\n    }\n    //endregion\n    //region RowManager\n    onTranslateRow({ row }) {\n        // Newly added rows are translated prior to having an id, rule those out since they will be rendered later\n        if (row.id != null) {\n            // Event layouts are stored relative to the resource, only need to rerender the row to have its absolute\n            // position updated to match new translation\n            this.refreshEventsForResource(row, false);\n        }\n    }\n    // RowManager error correction, cached layouts will no longer match.\n    // Redraw to have events correctly positioned for dependency feature to draw to their elements\n    onOffsetRows() {\n        this.clearAll();\n        this.doUpdateTimeView();\n    }\n    // Used to pre-calculate row heights\n    calculateRowHeight(resourceRecord) {\n        const\n            { scheduler } = this,\n            rowHeight     = scheduler.getResourceHeight(resourceRecord),\n            eventLayout   = scheduler.getEventLayout(resourceRecord),\n            layoutType    = eventLayout.type,\n            lockLayout    = scheduler.features.eventResize?.lockLayout;\n        if (\n            layoutType === 'stack' &&\n            scheduler.isEngineReady &&\n            !resourceRecord.isSpecialRow &&\n            // Generated parents when TreeGrouping do not have assigned bucket\n            resourceRecord.assigned?.size > 1\n        ) {\n            const\n                {\n                    assignmentStore,\n                    eventStore,\n                    timeAxis\n                }                  = scheduler,\n                {\n                    barMargin,\n                    resourceMarginObject : { total },\n                    contentHeight\n                }                  = scheduler.getResourceLayoutSettings(resourceRecord),\n                // When using an AssignmentStore we will get all events for the resource even if the EventStore is\n                // filtered\n                eventFilter        = (eventStore.isFiltered || assignmentStore.isFiltered) && (eventRecord =>\n                    eventRecord.assignments.some(a => a.resource === resourceRecord.$original && assignmentStore.includes(a))),\n                events             = eventStore\n                    .getEvents({\n                        resourceRecord,\n                        includeOccurrences : scheduler.enableRecurringEvents,\n                        startDate          : timeAxis.startDate,\n                        endDate            : timeAxis.endDate,\n                        filter             : eventFilter\n                    })\n                    .sort(heightEventSorter)\n                    .map(eventRecord => {\n                        const\n                            useCurrent = eventRecord.isBatchUpdating && !(lockLayout && eventRecord.meta?.isResizing),\n                            // Must use Model.get in order to get latest values in case we are inside a batch.\n                            // EventResize changes the endDate using batching to enable a tentative change\n                            // via the batchedUpdate event which is triggered when changing a field in a batch.\n                            // Fall back to accessor if propagation has not populated date fields.\n                            startDate  = useCurrent ? eventRecord.get('startDate') : eventRecord.startDate,\n                            endDate    = useCurrent ? eventRecord.get('endDate') : eventRecord.endDate || startDate;\n                        return {\n                            eventRecord,\n                            resourceRecord,\n                            startMS : startDate.getTime(),\n                            endMS   : endDate.getTime()\n                        };\n                    }),\n                layoutHandler      = scheduler.getEventLayoutHandler(eventLayout),\n                nbrOfBandsRequired = layoutHandler.layoutEventsInBands(events, resourceRecord, true);\n            if (layoutHandler.type === 'layoutFn') {\n                return nbrOfBandsRequired;\n            }\n            return (nbrOfBandsRequired * contentHeight) + ((nbrOfBandsRequired - 1) * barMargin) + total;\n        }\n        return rowHeight;\n    }\n    //endregion\n    //region TimeAxis\n    doUpdateTimeView() {\n        const { scrollable } = this.scheduler.timeAxisSubGrid;\n        // scrollLeft is the DOM's concept which is -ve in RTL mode.\n        // scrollX is always the +ve scroll offset from the origin.\n        // Both may be needed for different calculations.\n        this.updateFromHorizontalScroll(scrollable.x, true);\n    }\n    onTimeAxisViewModelUpdate() {\n        const\n            me            = this,\n            { scheduler } = me;\n        me.clearAll();\n        // If refresh is suspended, update timeView as soon as refresh gets unsuspended\n        if (scheduler.refreshSuspended) {\n            me.detachListeners('renderingSuspend');\n            scheduler.ion({\n                name : 'renderingSuspend',\n                resumeRefresh({ trigger }) {\n                    // This code will try to refresh rows, but resumeRefresh event doesn't guarantee rowManager rows are\n                    // in actual state. e.g. if resources were removed during a suspended refresh rowManager won't get a\n                    // chance to update them until `refresh` event from the project. We can safely update the view only\n                    // if engine in ready (not committing), otherwise we leave refresh a liability of normal project refresh\n                    // logic. Covered by SchedulerRendering.t.js\n                    // https://github.com/bryntum/support/issues/1462\n                    if (scheduler.isEngineReady && trigger) {\n                        me.doUpdateTimeView();\n                    }\n                },\n                thisObj : me,\n                once    : true\n            });\n        }\n        // Call update anyway. If refresh is suspended this call will only update visible date range and will not redraw rows\n        me.doUpdateTimeView();\n    }\n    //endregion\n    //region Dependency connectors\n    /**\n     * Gets displaying item start side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'start'|'end'|'top'|'bottom'} 'start' / 'end' / 'top' / 'bottom'\n     */\n    getConnectorStartSide(eventRecord) {\n        return 'start';\n    }\n    /**\n     * Gets displaying item end side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'start'|'end'|'top'|'bottom'} 'start' / 'end' / 'top' / 'bottom'\n     */\n    getConnectorEndSide(eventRecord) {\n        return 'end';\n    }\n    //endregion\n    //region Scheduler hooks\n    refreshRows(reLayoutEvents) {\n        if (reLayoutEvents) {\n            this.clearAll();\n        }\n    }\n    // Clear events in case they use date as part of displayed info\n    onLocaleChange() {\n        this.clearAll();\n    }\n    // Called when viewport size changes\n    onViewportResize(width, height, oldWidth, oldHeight) {\n        // We don't draw events for all rendered rows, \"refresh\" when height changes to make sure events in previously\n        // invisible rows gets displayed\n        if (height > oldHeight) {\n            this.onRenderDone();\n        }\n    }\n    // Called from EventDrag\n    onDragAbort({ context, dragData }) {\n        // Aborted a drag in a scrolled scheduler, with origin now out of view. Element is no longer needed\n        if (this.resourceStore.indexOf(dragData.record.resource) < this.scheduler.topRow.dataIndex) {\n            context.element.remove();\n        }\n    }\n    // Called from EventSelection\n    toggleCls(assignmentRecord, cls, add = true, useWrapper = false, checkReleased = false) {\n        const\n            element      = this.client.getElementFromAssignmentRecord(assignmentRecord, useWrapper, checkReleased),\n            resourceData = this.resourceMap.get(assignmentRecord.isModel ? assignmentRecord.get('resourceId') : assignmentRecord.resourceId),\n            eventData    = resourceData?.eventsData.find(d => d.eventId === assignmentRecord.eventId);\n        // Update cached config\n        if (eventData) {\n            eventData[useWrapper ? 'wrapperCls' : 'cls'][cls] = add;\n        }\n        // Live update element\n        if (element) {\n            // Update element\n            element.classList.toggle(cls, add);\n            // And its DOM config\n            element.lastDomConfig.className[cls] = add;\n        }\n    }\n    // React to rows being removed, refreshes view without any relayouting needed since layout is cached relative to row\n    onRemoveRows({ rows }) {\n        rows.forEach(row => this.rowMap.delete(row));\n        this.onRenderDone();\n    }\n    // Reset renderer flag before any renderers are called\n    onEarlyScroll() {\n        this.rendererCalled = false;\n    }\n    // If vertical scroll did not cause a renderer to be called we still want to update since we only draw events in\n    // view, \"independent\" from their rows\n    updateFromVerticalScroll() {\n        this.fromScroll = true;\n        if (!this.rendererCalled) {\n            this.onRenderDone();\n        }\n    }\n    // Update header range on horizontal scroll. No need to draw any tasks, Gantt only cares about vertical scroll\n    updateFromHorizontalScroll(scrollX, force) {\n        const\n            me            = this,\n            {\n                scheduler,\n                scrollBuffer\n            }             = me,\n            renderAll     = scrollBuffer === -1,\n            {\n                timeAxisSubGrid,\n                timeAxis,\n                rtl\n            }             = scheduler,\n            { width }     = timeAxisSubGrid,\n            { totalSize } = scheduler.timeAxisViewModel,\n            start         = scrollX,\n            // If there are few pixels left from the right most position then just render all remaining ticks,\n            // there wouldn't be many. It makes end date reachable with more page zoom levels while not having any poor\n            // implications.\n            // 5px to make TimeViewRangePageZoom test stable in puppeteer.\n            returnEnd     = timeAxisSubGrid.scrollable.maxX !== 0 && Math.abs(timeAxisSubGrid.scrollable.maxX) <= Math.round(start) + 5,\n            startDate     = renderAll ? timeAxis.startDate : scheduler.getDateFromCoord({ coord : Math.max(0, start - scrollBuffer), ignoreRTL : true }),\n            endDate       = returnEnd || renderAll ? timeAxis.endDate : (scheduler.getDateFromCoord({ coord : start + width + scrollBuffer, ignoreRTL : true }) || timeAxis.endDate);\n        if (\n            startDate && !scheduler._viewPresetChanging &&\n            // If rendering all, no action needed if scrolling horizontally unless start/end/tick size etc changes\n            (!renderAll || force || (startDate - (me._visibleDateRange?.startDate || 0)) || (endDate - (me._visibleDateRange?.endDate || 0)))\n        ) {\n            me._visibleDateRange = { startDate, endDate, startMS : startDate.getTime(), endMS : endDate.getTime() };\n            me.viewportCoords    = renderAll ? { left : 0, right : totalSize } : rtl\n                // RTL starts all the way to the right (and goes in opposite direction)\n                ? { left : totalSize - scrollX - width + scrollBuffer, right : totalSize - scrollX - scrollBuffer }\n                // LTR all the way to the left\n                : { left : scrollX - scrollBuffer, right : scrollX + width + scrollBuffer };\n            // Update timeaxis header making it display the new dates\n            const range = scheduler.timeView.range = { startDate, endDate };\n            scheduler.internalOnVisibleDateRangeChange(range);\n            // If refresh is suspended, someone else is responsible for updating the UI later\n            if (!scheduler.refreshSuspended && scheduler.rowManager.rows.length) {\n                // Gets here too early in Safari for ResourceHistogram. ResizeObserver triggers a scroll before rows are\n                // rendered first time. Could not track down why, bailing out\n                if (scheduler.rowManager.rows[0].id === null) {\n                    return;\n                }\n                me.fromScroll = true;\n                scheduler.rowManager.rows.forEach(row => me.refreshEventsForResource(row, false, false));\n                me.onRenderDone();\n            }\n        }\n    }\n    // Called from SchedulerEventRendering\n    repaintEventsForResource(resourceRecord) {\n        this.refreshResources([resourceRecord.id]);\n    }\n    onBeforeRowHeightChange() {\n        // Row height is cached per resource, all have to be re-laid out\n        this.clearAll();\n    }\n    //endregion\n    //region Refresh resources\n    refreshResourcesOnDataReady(resourceIds) {\n        resourceIds.forEach(id => this.toDrawOnDataReady.add(id));\n    }\n    /**\n     * Clears resources directly and redraws them on next project refresh\n     * @param {Number[]|String[]} resourceIds\n     * @private\n     */\n    refreshResourcesWhenReady(resourceIds) {\n        this.clearResources(resourceIds);\n        resourceIds.forEach(id => this.toDrawOnProjectRefresh.add(id));\n    }\n    /**\n     * Clears and redraws resources directly. Respects schedulers refresh suspension\n     * @param {Number[]|String[]} ids Resource ids\n     * @param {Boolean} [transition] Use transition or not\n     * @private\n     */\n    refreshResources(ids, transition = true) {\n        const\n            me            = this,\n            { scheduler } = me;\n        me.clearResources(ids);\n        if (!scheduler.refreshSuspended) {\n            const\n                rows   = [],\n                noRows = [];\n            ids.forEach(id => {\n                const row = scheduler.getRowById(id);\n                if (row) {\n                    rows.push(row);\n                }\n                else {\n                    noRows.push(row);\n                }\n            });\n            scheduler.runWithTransition(() => {\n                // Rendering rows populates row heights, but not all resources might have a row in view\n                scheduler.calculateRowHeights(noRows.map(id => this.resourceStore.getById(id)), true);\n                // Render those that do\n                scheduler.rowManager.renderRows(rows);\n            }, transition);\n        }\n    }\n    //endregion\n    //region Stack & pack\n    layoutEventVerticallyStack(bandIndex, eventRecord, resourceRecord) {\n        const\n            {\n                barMargin,\n                resourceMarginObject : { start },\n                contentHeight\n            } = this.scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent);\n        return bandIndex === 0\n            ? start\n            : start + bandIndex * contentHeight + bandIndex * barMargin;\n    }\n    layoutEventVerticallyPack(topFraction, heightFraction, eventRecord, resourceRecord) {\n        const\n            {\n                barMargin,\n                resourceMarginObject : { start },\n                contentHeight\n            }         = this.scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent),\n            count     = 1 / heightFraction,\n            bandIndex = topFraction * count, // \"y\" within row\n            height    = (contentHeight - ((count - 1) * barMargin)) * heightFraction,\n            top       = start + bandIndex * height + bandIndex * barMargin;\n        return {\n            top, height\n        };\n    }\n    //endregion\n    //region Render\n    /**\n     * Used by event drag features to bring into existence event elements that are outside of the rendered block.\n     * @param {Scheduler.model.TimeSpan} eventRecord The event to render\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] The event to render\n     * @private\n     */\n    addTemporaryDragElement(eventRecord, resourceRecord = eventRecord.resource) {\n        const\n            { scheduler } = this,\n            renderData    = scheduler.generateRenderData(eventRecord, resourceRecord, {\n                timeAxis : true,\n                viewport : true\n            });\n        renderData.absoluteTop = renderData.row\n            ? (renderData.top + renderData.row.top)\n            : scheduler.getResourceEventBox(eventRecord, resourceRecord, true).top;\n        const\n            domConfig   = this.renderEvent(renderData),\n            { dataset } = domConfig;\n        delete domConfig.tabIndex;\n        delete dataset.eventId;\n        delete dataset.resourceId;\n        delete dataset.assignmentId;\n        delete dataset.syncId;\n        dataset.transient = true;\n        domConfig.parent  = this.scheduler.foregroundCanvas;\n        // So that the regular DomSyncing which may happen during scroll does not\n        // sweep up and reuse the temporary element.\n        domConfig.retainElement = true;\n        const result = DomHelper.createElement(domConfig);\n        result.innerElement = result.firstChild;\n        eventRecord.instanceMeta(scheduler).hasTemporaryDragElement = true;\n        return result;\n    }\n    // Earlier start dates are above later tasks\n    // If same start date, longer tasks float to top\n    // If same start + duration, sort by name\n    // Fn can be called with layout date or event records (from EventNavigation)\n    eventSorter(a, b) {\n        if (this.overlappingEventSorter) {\n            return this.overlappingEventSorter(a.eventRecord || a, b.eventRecord || b);\n        }\n        const\n            startA = a.isModel ? a.startDateMS : a.dataStartMS || a.startMS, // dataXX are used if configured with fillTicks\n            endA   = a.isModel ? a.endDateMS : a.dataEndMS || a.endMS,\n            startB = b.isModel ? b.startDateMS : b.dataStartMS || b.startMS,\n            endB   = b.isModel ? b.endDateMS : b.dataEndMS || b.endMS,\n            nameA  = a.isModel ? a.name : a.eventRecord.name,\n            nameB  = b.isModel ? b.name : b.eventRecord.name;\n        return startA - startB || endB - endA || (nameA < nameB ? -1 : nameA == nameB ? 0 : 1);\n    }\n    /**\n     * Converts a start/endDate into a MS value used when rendering the event. If scheduler is configured with\n     * `fillTicks: true` the value returned will be snapped to tick start/end.\n     * @private\n     * @param {Scheduler.model.TimeSpan} eventRecord\n     * @param {String} startDateField\n     * @param {String} endDateField\n     * @param {Boolean} useEventBuffer\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @returns {Object} Object of format { startMS, endMS, durationMS }\n     */\n    calculateMS(eventRecord, startDateField, endDateField, useEventBuffer, resourceRecord) {\n        const\n            me                    = this,\n            { scheduler }         = me,\n            { timeAxisViewModel } = scheduler;\n        let startMS    = getStartEnd(scheduler, eventRecord, false, startDateField, useEventBuffer),\n            endMS      = getStartEnd(scheduler, eventRecord, true, endDateField, useEventBuffer),\n            durationMS = endMS - startMS;\n        if (scheduler.milestoneLayoutMode !== 'default' && durationMS === 0) {\n            const\n                pxPerMinute = timeAxisViewModel.getSingleUnitInPixels('minute'),\n                lengthInPx  = scheduler.getMilestoneLabelWidth(eventRecord, resourceRecord),\n                duration    = lengthInPx * (1 / pxPerMinute);\n            durationMS = duration * 60 * 1000;\n            if (scheduler.milestoneTextPosition === 'always-outside') {\n                // Milestone is offset half a diamond to the left (compensated in CSS with padding) for the layout pass,\n                // to take diamond corner into account\n                const\n                    diamondSize = scheduler.getResourceLayoutSettings(resourceRecord, eventRecord.parent).contentHeight,\n                    diamondMS   = diamondSize * (1 / pxPerMinute) * 60 * 1000;\n                startMS -= diamondMS / 2;\n                endMS           = startMS + durationMS;\n            }\n            else {\n                switch (scheduler.milestoneAlign) {\n                    case 'start':\n                    case 'left':\n                        endMS = startMS + durationMS;\n                        break;\n                    case 'end':\n                    case 'right':\n                        endMS   = startMS;\n                        startMS = endMS - durationMS;\n                        break;\n                    default: // using center as default\n                        endMS   = startMS + durationMS / 2;\n                        startMS = endMS - durationMS;\n                        break;\n                }\n            }\n        }\n        // Normally the event bar element and the event layout use the same timestamps for sizing,\n        // but during resize if we have locked the layout we need them to differ\n        const\n            elementStartMS    = startMS,\n            elementEndMS      = endMS,\n            elementDurationMS = durationMS;\n        // Use initial values for the layout during resize\n        if (eventRecord.meta?.isResizing && scheduler.features.eventResize?.lockLayout) {\n            startMS    = eventRecord.startDate.getTime();\n            endMS      = eventRecord.endDate.getTime();\n            durationMS = elementEndMS - elementStartMS;\n        }\n        return {\n            startMS,\n            endMS,\n            durationMS,\n            elementStartMS,\n            elementEndMS,\n            elementDurationMS\n        };\n    }\n    /**\n     * Returns event render data except actual position information.\n     * @param timeSpan\n     * @param rowRecord\n     * @returns {HorizontalRenderData}\n     * @private\n     */\n    setupRenderData(timeSpan, rowRecord) {\n        const\n            me                  = this,\n            { scheduler }       = me,\n            {\n                timeAxis,\n                timeAxisViewModel\n            }                   = scheduler,\n            {\n                preamble,\n                postamble\n            }                   = timeSpan,\n            useEventBuffer      = me.isProHorizontalRendering && scheduler.features.eventBuffer?.enabled &&\n                (preamble || postamble) && !timeSpan.isMilestone,\n            pxPerMinute         = timeAxisViewModel.getSingleUnitInPixels('minute'),\n            { isBatchUpdating } = timeSpan,\n            startDateField      = useEventBuffer ? 'wrapStartDate' : 'startDate',\n            endDateField        = useEventBuffer ? 'wrapEndDate' : 'endDate',\n            // Must use Model.get in order to get latest values in case we are inside a batch.\n            // EventResize changes the endDate using batching to enable a tentative change\n            // via the batchedUpdate event which is triggered when changing a field in a batch.\n            // Fall back to accessor if propagation has not populated date fields.\n            // Use endDate accessor if duration has not been propagated to create endDate\n            timespanStart       = isBatchUpdating && !useEventBuffer ? timeSpan.get(startDateField) : timeSpan[startDateField],\n            // Allow timespans to be rendered even when they are missing an end date\n            timespanEnd         = isBatchUpdating && !useEventBuffer ? timeSpan.get(endDateField) : timeSpan[endDateField] || timespanStart,\n            viewStartMS         = timeAxis.startMS,\n            viewEndMS           = timeAxis.endMS,\n            // Convert start/end dates to milliseconds, taking fillTicks, lockLayout etc. into account\n            msValues            = me.calculateMS(timeSpan, startDateField, endDateField, useEventBuffer, rowRecord),\n            {\n                startMS,\n                endMS,\n                durationMS\n            }                   = msValues,\n            // These flags have two components because includeOutsideViewport\n            // means that we can be calculating data for events either side of\n            // the TimeAxis.\n            // The start is outside of the view if it's before *or after* the TimeAxis range.\n            // 1 set means the start is before the TimeAxis\n            // 2 set means the start is after the TimeAxis\n            // Either way, a truthy value means that the start is outside of the TimeAxis.\n            startsOutsideView   = startMS < viewStartMS | ((startMS > viewEndMS) << 1),\n            // The end is outside of the view if it's before *or after* the TimeAxis range.\n            // 1 set means the end is after the TimeAxis\n            // 2 set means the end is before the TimeAxis\n            // Either way, a truthy value means that the end is outside the TimeAxis.\n            endsOutsideView     = endMS > viewEndMS | ((endMS <= viewStartMS) << 1),\n            durationMinutes     = durationMS / (1000 * 60),\n            width               = endsOutsideView ? pxPerMinute * durationMinutes : null,\n            row                 = scheduler.getRowById(rowRecord);\n        return {\n            eventRecord : timeSpan,\n            taskRecord  : timeSpan, // Helps with using Gantt projects in Scheduler Pro\n            start       : timespanStart,\n            end         : timespanEnd,\n            rowId       : rowRecord.id,\n            children    : [],\n            startsOutsideView,\n            endsOutsideView,\n            width,\n            row,\n            useEventBuffer,\n            ...msValues\n        };\n    }\n    /**\n     * Populates render data with information about width and horizontal position of the wrap.\n     * @param {HorizontalRenderData} renderData\n     * @returns {Boolean}\n     * @private\n     */\n    fillTimeSpanHorizontalPosition(renderData) {\n        const\n            { elementStartMS : startMS, elementEndMS : endMS, elementDurationMS : durationMS } = renderData,\n            // With delayed calculation there is no guarantee data is normalized, might be missing a crucial component\n            result = startMS != null && endMS != null && this.calculateHorizontalPosition(renderData, startMS, endMS, durationMS);\n        if (result) {\n            Object.assign(renderData, result);\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Fills render data with `left` and `width` properties\n     * @param {HorizontalRenderData} renderData\n     * @param {Number} startMS\n     * @param {Number} endMS\n     * @param {Number} durationMS\n     * @returns {{left: number, width: number, clippedStart: boolean, clippedEnd: boolean}|null}\n     * @private\n     */\n    calculateHorizontalPosition(renderData, startMS, endMS, durationMS) {\n        const\n            { scheduler } = this,\n            {\n                timeAxis,\n                timeAxisViewModel\n            }             = scheduler,\n            {\n                startsOutsideView,\n                endsOutsideView,\n                eventRecord\n            }             = renderData,\n            viewStartMS   = timeAxis.startMS,\n            pxPerMinute   = timeAxisViewModel.getSingleUnitInPixels('minute');\n        let\n            width                                        = null,\n            endX                                         = scheduler.getCoordinateFromDate(endMS, {\n                local            : true,\n                respectExclusion : true,\n                isEnd            : true\n            }), startX, clippedStart = false, clippedEnd = false;\n        // If event starts outside of view, estimate where.\n        if (startsOutsideView) {\n            startX = (startMS - viewStartMS) / (1000 * 60) * pxPerMinute;\n            // Flip -ve startX to being to the right of the viewport end\n            if (scheduler.rtl) {\n                startX = timeAxisViewModel.totalSize - startX;\n            }\n        }\n        // Starts in view, calculate exactly\n        else {\n            // If end date is included in time axis but start date is not (when using time axis exclusions), snap start date to next included data\n            startX = scheduler.getCoordinateFromDate(startMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : false,\n                snapToNextIncluded : endX !== -1\n            });\n            clippedStart = startX === -1;\n        }\n        if (endsOutsideView) {\n            // Estimate where the end is, based on where time axis ends + how much the event overflows\n            const\n                distanceToTimeAxisEnd   = timeAxisViewModel.totalSize - startX,\n                overflowDurationMS      = endMS - timeAxis.endMS,\n                overflowDurationMinutes = overflowDurationMS / (1000 * 60);\n            width = scheduler.rtl\n                ? pxPerMinute * durationMS / (1000 * 60)\n                : distanceToTimeAxisEnd + pxPerMinute * overflowDurationMinutes;\n            // Have to clip the events in Safari when using stickyEvents, it does not support `overflow: clip`\n            if (BrowserHelper.isSafari && scheduler.features.stickyEvents && timeAxis.endMS) {\n                endX = scheduler.getCoordinateFromDate(timeAxis.endMS);\n            }\n            else {\n                // Parentheses needed\n                endX = startX + width * (scheduler.rtl ? -1 : 1);\n            }\n        }\n        else {\n            clippedEnd = endX === -1;\n        }\n        if (clippedEnd && !clippedStart) {\n            // We know where to start but not where to end, snap it (the opposite is already handled by the\n            // snapToNextIncluded flag when calculating startX above)\n            endX = scheduler.getCoordinateFromDate(endMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : true,\n                snapToNextIncluded : true\n            });\n        }\n        // If the element is very wide there's no point in displaying it all.\n        // Indeed the element may not be displayable at extremely large widths.\n        if (width > MAX_WIDTH) {\n            // The start is before the TimeAxis start\n            if (startsOutsideView === 1) {\n                // Both ends outside - spans TimeAxis\n                if (endsOutsideView === 1) {\n                    startX = -100;\n                    endX   = scheduler.timeAxisColumn.width + 100;\n                }\n                // End is in view\n                else {\n                    startX = endX - MAX_WIDTH;\n                }\n            }\n            // The end is after, but the start is in view\n            else if (endsOutsideView === 1) {\n                endX = startX + MAX_WIDTH;\n            }\n        }\n        if (clippedStart && clippedEnd) {\n            // Both ends excluded, but there might be some part in between that should be displayed...\n            startX = scheduler.getCoordinateFromDate(startMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : false,\n                snapToNextIncluded : true,\n                max                : endMS\n            });\n            endX = scheduler.getCoordinateFromDate(endMS, {\n                local              : true,\n                respectExclusion   : true,\n                isEnd              : true,\n                snapToNextIncluded : true,\n                min                : startMS\n            });\n            if (startX === endX) {\n                // Raise flag on instance meta to avoid duplicating this logic\n                eventRecord.instanceMeta(scheduler).excluded = true;\n                // Excluded by time axis exclusion rules, render nothing\n                return null;\n            }\n        }\n        return {\n            left  : Math.min(startX, endX),\n            // Use min width 5 for normal events, 0 for milestones (won't have width specified at all in the\n            // end). During drag create a normal event can get 0 duration, in this case we still want it to\n            // get a min width of 5 (6px for wrapper, -1 px for event element\n            width : Math.abs(endX - startX) || (eventRecord.isMilestone && !eventRecord.meta.isDragCreating ? 0 : 6),\n            clippedStart,\n            clippedEnd\n        };\n    }\n    fillTimeSpanVerticalPosition(renderData, rowRecord) {\n        const\n            { scheduler }  = this,\n            { start, end } = renderData,\n            {\n                resourceMarginObject : { start : resourceMarginStart },\n                contentHeight\n            }              = scheduler.getResourceLayoutSettings(rowRecord);\n        // If filling ticks we need to also keep data's MS values, since they are used for sorting timespans\n        if (scheduler.fillTicks) {\n            renderData.dataStartMS = start.getTime();\n            renderData.dataEndMS   = end.getTime();\n        }\n        renderData.top = Math.max(0, resourceMarginStart);\n        if (scheduler.managedEventSizing) {\n            // Timespan height should be at least 1px\n            renderData.height = contentHeight;\n        }\n    }\n    /**\n     * Gets timespan coordinates etc. Relative to containing row. If the timespan is outside of the zone in\n     * which timespans are rendered, that is outside of the TimeAxis, or outside of the vertical zone in which timespans\n     * are rendered, then `undefined` is returned.\n     * @private\n     * @param {Scheduler.model.TimeSpan} timeSpan TimeSpan record\n     * @param {Core.data.Model} rowRecord Row record\n     * @param {Boolean|Object} includeOutside Specify true to get boxes for timespans outside of the rendered zone in both\n     * dimensions. This option is used when calculating dependency lines, and we need to include routes from timespans\n     * which may be outside the rendered zone.\n     * @param {Boolean} includeOutside.timeAxis Pass as `true` to include timespans outside of the TimeAxis's bounds\n     * @param {Boolean} includeOutside.viewport Pass as `true` to include timespans outside of the vertical timespan viewport's bounds.\n     * @returns {{event/task: *, left: number, width: number, start: (Date), end: (Date), startMS: number, endMS: number, startsOutsideView: boolean, endsOutsideView: boolean}}\n     */\n    getTimeSpanRenderData(timeSpan, rowRecord, includeOutside = false) {\n        const data = this.setupRenderData(timeSpan, rowRecord);\n        if (!this.fillTimeSpanHorizontalPosition(data)) {\n            return null;\n        }\n        this.fillTimeSpanVerticalPosition(data, rowRecord);\n        return data;\n    }\n    // Layout a set of events, code shared by normal event render path and nested events\n    layoutEvents(resourceRecord, allEvents, includeOutside = false, parentEventRecord, eventSorter) {\n        const\n            me            = this,\n            { scheduler } = me,\n            { timeAxis }  = scheduler,\n            // Generate layout data\n            eventsData    = allEvents.reduce((result, eventRecord) => {\n                // Only those in time axis (by default)\n                if ((includeOutside || timeAxis.isTimeSpanInAxis(eventRecord))) {\n                    const eventBox = scheduler.generateRenderData(eventRecord, resourceRecord, includeOutside);\n                    // Collect layouts of visible events\n                    if (eventBox) {\n                        result.push(eventBox);\n                    }\n                }\n                return result;\n            }, []);\n        // Ensure the events are rendered in natural order so that navigation works.\n        eventsData.sort(eventSorter ?? me.eventSorter);\n        let rowHeight = scheduler.getAppliedResourceHeight(resourceRecord, parentEventRecord);\n        const\n            // Only events and tasks should be considered during layout (not resource time ranges if any, or events\n            // being drag created when configured with lockLayout)\n            layoutEventData = eventsData.filter(({ eventRecord }) => eventRecord.isEvent && !eventRecord.meta.excludeFromLayout),\n            eventLayout     = scheduler.getEventLayout(resourceRecord, parentEventRecord),\n            layoutHandler   = scheduler.getEventLayoutHandler(eventLayout);\n        if (layoutHandler) {\n            const\n                {\n                    barMargin,\n                    resourceMarginObject : { total },\n                    contentHeight\n                }             = scheduler.getResourceLayoutSettings(resourceRecord, parentEventRecord),\n                bandsRequired = layoutHandler.applyLayout(layoutEventData, resourceRecord) || 1;\n            if (layoutHandler.type === 'layoutFn') {\n                rowHeight = bandsRequired;\n            }\n            else {\n                rowHeight = (bandsRequired * contentHeight) + ((bandsRequired - 1) * barMargin) + total;\n            }\n        }\n        // Apply z-index when event elements might overlap, to keep \"overlap order\" consistent\n        else if (layoutEventData.length > 0) {\n            for (let i = 0; i < layoutEventData.length; i++) {\n                const data = layoutEventData[i];\n                // $event-zindex scss var is 5\n                data.wrapperStyle += `;z-index:${i + 5}`;\n            }\n        }\n        return { rowHeight, eventsData };\n    }\n    // Lay out events within a resource, relative to the resource\n    layoutResourceEvents(resourceRecord, includeOutside = false) {\n        const\n            me             = this,\n            { scheduler }  = me,\n            {\n                eventStore,\n                assignmentStore,\n                timeAxis\n            }              = scheduler,\n            // Events for this resource\n            resourceEvents = eventStore.getEvents({\n                includeOccurrences : scheduler.enableRecurringEvents,\n                resourceRecord,\n                startDate          : timeAxis.startDate,\n                endDate            : timeAxis.endDate,\n                filter             : (assignmentStore.isFiltered || eventStore.isFiltered) && (eventRecord =>\n                    eventRecord.assignments.some(a => a.resource === resourceRecord.$original && assignmentStore.includes(a)))\n            }),\n            // Call a chainable template function on scheduler to allow features to add additional \"events\" to render\n            // Currently used by ResourceTimeRanges, CalendarHighlight & NestedEvents\n            allEvents      = scheduler.getEventsToRender(resourceRecord, resourceEvents) || [];\n        return me.layoutEvents(resourceRecord, allEvents, includeOutside);\n    }\n    // Generates a DOMConfig for an EventRecord\n    renderEvent(data, rowHeight) {\n        const\n            { scheduler }                                     = this,\n            { resourceRecord, assignmentRecord, eventRecord } = data,\n            // Sync using assignment id for events and event id for ResourceTimeRanges. Add eventId for occurrences to make them unique\n            syncId                                            = assignmentRecord\n                // Assignment, might be an occurrence\n                ? this.assignmentStore.getOccurrence(assignmentRecord, eventRecord).id\n                // Something else, probably a ResourceTimeRange\n                : data.eventId,\n            eventElementConfig                                = {\n                className : data.cls,\n                style     : data.style || '',\n                children  : data.children,\n                role      : 'presentation',\n                dataset   : {\n                    // Each feature putting contents in the event wrap should have this to simplify syncing and\n                    // element retrieval after sync\n                    taskFeature : 'event'\n                },\n                syncOptions : {\n                    syncIdField : 'taskBarFeature'\n                }\n            },\n            // Event element config, applied to existing element or used to create a new one below\n            elementConfig                                     = {\n                className : data.wrapperCls,\n                tabIndex  : ('tabIndex' in data) ? data.tabIndex : -1,\n                children  : [\n                    eventElementConfig,\n                    ...data.wrapperChildren\n                ],\n                style : {\n                    top      : data.absoluteTop,\n                    left     : data.left,\n                    // ResourceTimeRanges fill row height, cannot be done earlier than this since row height is not\n                    // known initially\n                    height   : data.fillSize ? rowHeight : data.height,\n                    // DomHelper appends px to dimensions when using numbers.\n                    width    : data.width,\n                    style    : data.wrapperStyle,\n                    fontSize : data.height + 'px'\n                },\n                dataset : {\n                    // assignmentId is set in this function conditionally\n                    resourceId : resourceRecord.id,\n                    eventId    : data.eventId, // Not using eventRecord.id to distinguish between Event and ResourceTimeRange\n                    syncId     : resourceRecord.isLinked ? `${syncId}_${resourceRecord.id}` : syncId\n                },\n                // Will not be part of DOM, but attached to the element\n                elementData   : data,\n                // Dragging etc. flags element as retained, to not reuse/release it during that operation. Events\n                // always use assignments, but ResourceTimeRanges does not\n                retainElement : assignmentRecord?.instanceMeta(scheduler).retainElement || eventRecord.instanceMeta(scheduler).retainElement,\n                // Options for this level of sync, lower levels can have their own\n                syncOptions   : {\n                    syncIdField      : 'taskFeature',\n                    // Remove instead of release when a feature is disabled\n                    releaseThreshold : 0\n                }\n            };\n        // Write back the correct height for elements filling the row, to not derender them later based on wrong height\n        if (data.fillSize) {\n            data.height = rowHeight;\n        }\n        // Some browsers throw warnings on zIndex = ''\n        if (data.zIndex) {\n            elementConfig.zIndex = data.zIndex;\n        }\n        // Do not want to spam dataset with empty prop when not using assignments (ResourceTimeRanges)\n        if (assignmentRecord) {\n            elementConfig.dataset.assignmentId = assignmentRecord.id;\n        }\n        data.elementConfig = elementConfig;\n        scheduler.afterRenderEvent({ renderData : data, rowHeight, domConfig : elementConfig });\n        return elementConfig;\n    }\n    /**\n     * Refresh events for resource record (or Row), clearing its cache and forcing DOM refresh.\n     * @param {Scheduler.model.ResourceModel} recordOrRow Record or row to refresh\n     * @param {Boolean} [force] Specify `false` to prevent clearing cache and forcing DOM refresh\n     * @internal\n     */\n    refreshEventsForResource(recordOrRow, force = true, draw = true) {\n        const\n            me     = this,\n            record = me.scheduler.store.getById(recordOrRow.isRow ? recordOrRow.id : recordOrRow),\n            row    = me.scheduler.rowManager.getRowFor(record);\n        if (force) {\n            me.clearResources([record]);\n        }\n        if (row && record) {\n            me.renderer({ row, record });\n            if (force && draw) {\n                me.onRenderDone();\n            }\n        }\n    }\n    // Returns layout for the current resource. Used by the renderer and exporter\n    getResourceLayout(resourceRecord) {\n        const me = this;\n        // Use cached layout if available\n        let resourceLayout = me.resourceMap.get(resourceRecord.id);\n        if (!resourceLayout || resourceLayout.invalid) {\n            // Previously we would bail out here if engine wasn't ready. Now we instead allow drawing in most cases,\n            // since data can be read and written during commit (previously it could not)\n            if (me.suspended) {\n                return;\n            }\n            resourceLayout = me.layoutResourceEvents(resourceRecord, false);\n            me.resourceMap.set(resourceRecord.id, resourceLayout);\n        }\n        return resourceLayout;\n    }\n    getEventDOMConfigForCurrentView(resourceLayout, row, left, right) {\n        const\n            me                        = this,\n            { bufferSize, scheduler } = me,\n            { labels, eventBuffer }   = scheduler.features,\n            // Left/right labels and event buffer elements require using a buffer to not derender too early\n            usesLabels                = eventBuffer?.enabled || (labels?.enabled && (labels.left || labels.right || labels.before || labels.after)),\n            { eventsData }            = resourceLayout,\n            // When scrolling, layout will be reused and any events that are still in view can reuse their DOM configs\n            reusableDOMConfigs        = me.fromScroll ? me.rowMap.get(row) : null,\n            eventDOMConfigs           = [];\n        let useLeft, useRight;\n        // Only collect configs for those actually in view\n        for (let i = 0; i < eventsData.length; i++) {\n            const layout = eventsData[i];\n            useLeft  = left;\n            useRight = right;\n            // Labels/milestones requires keeping events rendered longer\n            if (usesLabels || layout.width === 0) {\n                useLeft -= bufferSize;\n                useRight += bufferSize;\n            }\n            if ((layout.left + layout.width) >= useLeft && layout.left <= useRight) {\n                layout.absoluteTop = layout.top + row.top;\n                const prevDomConfig = reusableDOMConfigs?.find(config => config.elementData.eventId === layout.eventId &&\n                    config.elementData.resourceId === layout.resourceId);\n                eventDOMConfigs.push(prevDomConfig ?? me.renderEvent(layout, resourceLayout.rowHeight));\n            }\n        }\n        return eventDOMConfigs;\n    }\n    // Called per row in \"view\", collect configs\n    renderer({ row, record : resourceRecord, size = {} }) {\n        const me = this;\n        // Bail out for group headers/footers\n        if (resourceRecord.isSpecialRow) {\n            // Clear any cached layout for row retooled to special row, and bail out\n            me.rowMap.delete(row);\n            return;\n        }\n        const\n            { left, right } = me.viewportCoords,\n            resourceLayout  = me.getResourceLayout(resourceRecord);\n        // Layout is suspended\n        if (!resourceLayout) {\n            return;\n        }\n        // Size row to fit events\n        size.height    = resourceLayout.rowHeight;\n        // Avoid storing our calculated height as the rows max height, to not affect next round of calculations\n        size.transient = true;\n        const eventDOMConfigs = me.getEventDOMConfigForCurrentView(resourceLayout, row, left, right);\n        me.rowMap.set(row, eventDOMConfigs);\n        // Keep track if we need to draw on vertical scroll or not, to not get multiple onRenderDone() calls\n        me.rendererCalled = true;\n    }\n    // Called when the current row rendering \"pass\" is complete, sync collected configs to DOM\n    onRenderDone() {\n        const\n            { scheduler, rowMap, verticalBufferSize } = this,\n            visibleEventDOMConfigs                    = [],\n            bodyTop                                   = scheduler._scrollTop ?? 0,\n            viewTop                                   = bodyTop - verticalBufferSize,\n            viewBottom                                = bodyTop + scheduler._bodyRectangle.height + verticalBufferSize,\n            unbuffered                                = verticalBufferSize < 0,\n            unmanagedSize                             = !scheduler.managedEventSizing;\n        // Event configs are collected when rows are rendered, but we do not want to waste resources on rendering\n        // events far out of view. Especially with many events per row giving large row heights, rows in the RowManagers\n        // buffer might far away -> collect events for rows within viewport + small vertical buffer\n        rowMap.forEach((eventDOMConfigs, row) => {\n            // Render events \"in view\". Export specifies a negative verticalBufferSize to disable it\n            if (unbuffered || (row.bottom > viewTop && row.top < viewBottom)) {\n                for (let i = 0; i < eventDOMConfigs.length; i++) {\n                    const\n                        config = eventDOMConfigs[i],\n                        data   = config.elementData,\n                        {\n                            absoluteTop,\n                            eventRecord\n                        }      = data;\n                    // Conditions under which event bars are included in the DOM:\n                    //   If bufferSize is -ve, meaning render all events.\n                    //   scheduler.managedEventSizing is false.\n                    //   The event is being drag-created or drag-resized\n                    //   The event is within the bounds of the rendered region.\n                    if (unbuffered || unmanagedSize || eventRecord.meta.isDragCreating || eventRecord.meta.isResizing || (absoluteTop + data.height > viewTop && absoluteTop < viewBottom)) {\n                        visibleEventDOMConfigs.push(config);\n                    }\n                }\n            }\n            // We are using cached DomConfigs. When DomSync releases an element, it also flags the config as released.\n            // Next time we pass it that very same config, it says it is released and nothing shows up.\n            //\n            // We are breaching the DomSync contract a bit with the cached approach. DomSync expects new configs on each\n            // call, so to facilitate that we clone the configs shallowly (nothing deep is affected by sync releasing).\n            // That way we can always pass it fresh unreleased configs.\n            for (let i = 0; i < eventDOMConfigs.length; i++) {\n                eventDOMConfigs[i] = { ...eventDOMConfigs[i] };\n            }\n        });\n        this.fromScroll             = false;\n        this.visibleEventDOMConfigs = visibleEventDOMConfigs;\n        DomSync.sync({\n            domConfig : {\n                onlyChildren : true,\n                children     : visibleEventDOMConfigs\n            },\n            targetElement : scheduler.foregroundCanvas,\n            syncIdField   : 'syncId',\n            // Called by DomSync when it creates, releases or reuses elements\n            callback({ action, domConfig, lastDomConfig, targetElement, jsx }) {\n                const\n                    { reactComponent } = scheduler,\n                    // Some actions are considered first a release and then a render (reusing another element).\n                    // This gives clients code a chance to clean up before reusing an element\n                    isRelease          = releaseEventActions[action],\n                    isRender           = renderEventActions[action];\n                !isRelease && scheduler.processEventContent?.({\n                    jsx,\n                    action,\n                    domConfig,\n                    targetElement,\n                    isRelease,\n                    reactComponent\n                });\n                if (action === 'none' || !domConfig?.elementData?.isWrap) {\n                    return;\n                }\n                // Trigger release for events (it might be a proxy element, skip those)\n                if (isRelease && lastDomConfig?.elementData) {\n                    const\n                        { eventRecord, resourceRecord, assignmentRecord } = lastDomConfig.elementData,\n                        event                                             = {\n                            renderData : lastDomConfig.elementData,\n                            element    : targetElement,\n                            eventRecord,\n                            resourceRecord,\n                            assignmentRecord\n                        };\n                    // Process event necessary in the case of release\n                    scheduler.processEventContent?.({\n                        isRelease,\n                        targetElement,\n                        reactComponent,\n                        assignmentRecord\n                    });\n                    // Some browsers do not blur on set to display:none, so releasing the active element\n                    // must *explicitly* move focus outwards to the view.\n                    if (targetElement === DomHelper.getActiveElement(targetElement)) {\n                        scheduler.focusElement.focus();\n                    }\n                    // This event is documented on Scheduler\n                    scheduler.trigger('releaseEvent', event);\n                }\n                if (isRender) {\n                    const\n                        { eventRecord, resourceRecord, assignmentRecord } = domConfig.elementData,\n                        event                                             = {\n                            renderData       : domConfig.elementData,\n                            element          : targetElement,\n                            isReusingElement : action === 'reuseElement',\n                            isRepaint        : action === 'reuseOwnElement',\n                            eventRecord,\n                            resourceRecord,\n                            assignmentRecord\n                        };\n                    // Prevent transitions when reusing some other events element\n                    if (action === 'reuseElement' && scheduler.isAnimating) {\n                        // No assignments for ResourceTimeRanges\n                        DomHelper.addTemporaryClass(targetElement, 'b-reusing-own', 50, scheduler, `b-reusing-own-${(assignmentRecord || eventRecord).id}`);\n                    }\n                    // This event is documented on Scheduler\n                    scheduler.trigger('renderEvent', event);\n                }\n            }\n        });\n    }\n    //endregion\n    //region Cache\n    // Clears cached resource layout\n    clearResources(recordsOrIds) {\n        recordsOrIds = ArrayHelper.asArray(recordsOrIds);\n        const resourceIds = recordsOrIds.map(Model.asId);\n        resourceIds.forEach(resourceId => {\n            // Invalidate resourceLayout, keeping it around in case we need it before next refresh\n            const cached = this.resourceMap.get(resourceId);\n            if (cached) {\n                cached.invalid = true;\n            }\n            const row = this.scheduler.getRowById(resourceId);\n            row && this.rowMap.delete(row);\n        });\n    }\n    clearAll({ clearDom = false, clearLayoutCache = false } = {}) {\n        const\n            me                            = this,\n            { layouts, foregroundCanvas } = me.scheduler;\n        if (clearLayoutCache && layouts) {\n            for (const layout in layouts) {\n                layouts[layout].clearCache();\n            }\n        }\n        // it seems `foregroundCanvas` can be missing at this point\n        // for example if scheduler instance is created w/o of `appendTo` config\n        if (foregroundCanvas && clearDom) {\n            // Start from scratch when replacing the project, to not retain anything in maps or released elements\n            foregroundCanvas.syncIdMap = foregroundCanvas.lastDomConfig = foregroundCanvas.releasedIdMap = null;\n            for (const child of foregroundCanvas.children) {\n                child.lastDomConfig = child.elementData = null;\n            }\n        }\n        me.resourceMap.clear();\n        me.rowMap.clear();\n    }\n    //endregion\n}\nHorizontalRendering._$name = 'HorizontalRendering';", "import PackMixin from './PackMixin.js';\n/**\n * @module Scheduler/eventlayout/VerticalLayout\n */\n/**\n * Assists with event layout in vertical mode, handles `eventLayout: none|pack|mixed`\n * @private\n * @mixes Scheduler/eventlayout/PackMixin\n */\nexport default class VerticalLayout extends PackMixin() {\n    static get defaultConfig() {\n        return {\n            coordProp : 'leftFactor',\n            sizeProp  : 'widthFactor'\n        };\n    }\n    // Try to pack the events to consume as little space as possible\n    applyLayout(events, columnWidth, resourceMarginStart, resourceMarginTotal, barMargin, columnIndex, eventLayout) {\n        const\n            me         = this,\n            layoutType = eventLayout.type;\n        return me.packEventsInBands(events, (tplData, clusterIndex, slot, slotSize) => {\n            // Stretch events to fill available width\n            if (layoutType === 'none') {\n                tplData.width = columnWidth - resourceMarginTotal;\n                tplData.left += resourceMarginStart;\n            }\n            else {\n                // Fractions of resource column\n                tplData.widthFactor = slotSize;\n                const\n                    leftFactor      = tplData.leftFactor = slot.start + (clusterIndex * slotSize),\n                    // Number of \"columns\" in the current slot\n                    packColumnCount = Math.round(1 / slotSize),\n                    // Index among those columns for current event\n                    packColumnIndex = leftFactor / slotSize,\n                    // Width with all bar margins subtracted\n                    availableWidth  = columnWidth - resourceMarginTotal - barMargin * (packColumnCount - 1);\n                // Allowing two events to overlap? Slightly offset the second\n                if (layoutType === 'mixed' && packColumnCount === 2) {\n                    tplData.left += leftFactor * columnWidth / 5 + barMargin;\n                    tplData.width = columnWidth - leftFactor * columnWidth / 5 - barMargin * 2;\n                    tplData.zIndex = 5 + packColumnIndex;\n                }\n                // Pack by default\n                else {\n                    // Fractional width\n                    tplData.width = slotSize * availableWidth;\n                    // Translate to absolute position\n                    tplData.left += leftFactor * availableWidth + resourceMarginStart + barMargin * packColumnIndex;\n                }\n            }\n            tplData.cls['b-sch-event-narrow'] = tplData.width < me.scheduler.narrowEventWidth;\n        });\n    }\n}\nVerticalLayout._$name = 'VerticalLayout';", "import Base from '../../../Core/Base.js';\nimport Delayable from '../../../Core/mixin/Delayable.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport VerticalLayout from '../../eventlayout/VerticalLayout.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\n/**\n * @module Scheduler/view/orientation/VerticalRendering\n */\nconst\n    releaseEventActions = {\n        releaseElement : 1, // Not used at all at the moment\n        reuseElement   : 1  // Used by some other element\n    },\n    renderEventActions  = {\n        newElement      : 1,\n        reuseOwnElement : 1,\n        reuseElement    : 1\n    },\n    chronoFields        = {\n        startDate : 1,\n        endDate   : 1,\n        duration  : 1\n    },\n    emptyObject        = Object.freeze({});\n/**\n * Handles event rendering in Schedulers vertical mode. Reacts to project/store changes to keep the UI up to date.\n *\n * @internal\n */\nexport default class VerticalRendering extends Base.mixin(Delayable, AttachToProjectMixin) {\n    //region Config & Init\n    static get properties() {\n        return {\n            eventMap               : new Map(),\n            resourceMap            : new Map(),\n            releasedElements       : {},\n            toDrawOnProjectRefresh : new Set(),\n            resourceBufferSize     : 1\n        };\n    }\n    construct(scheduler) {\n        this.client         = this.scheduler = scheduler;\n        this.verticalLayout = new VerticalLayout({ scheduler });\n        super.construct({});\n    }\n    init() {\n        const\n            me                             = this,\n            { scheduler, resourceColumns } = me;\n        // Resource header/columns\n        resourceColumns.resourceStore = me.resourceStore;\n        resourceColumns.ion({\n            name              : 'resourceColumns',\n            columnWidthChange : 'onResourceColumnWidthChange',\n            thisObj           : me\n        });\n        me.initialized = true;\n        if (scheduler.isPainted) {\n            me.renderer();\n        }\n        resourceColumns.availableWidth = scheduler.timeAxisSubGridElement.offsetWidth;\n    }\n    //endregion\n    //region Elements <-> Records\n    resolveRowRecord(elementOrEvent, xy) {\n        const\n            me            = this,\n            { scheduler } = me,\n            event         = elementOrEvent.nodeType ? null : elementOrEvent,\n            element       = event ? event.target : elementOrEvent,\n            coords        = event ? [event.borderOffsetX, event.borderOffsetY] : xy,\n            // Fix for FF on Linux having text nodes as event.target\n            el            = element.nodeType === Element.TEXT_NODE ? element.parentElement : element,\n            eventElement  = el.closest(scheduler.eventSelector);\n        if (eventElement) {\n            return scheduler.resourceStore.getById(eventElement.dataset.resourceId);\n        }\n        // Need to be inside schedule at least\n        if (!element.closest('.b-sch-timeaxis-cell')) {\n            return null;\n        }\n        if (!coords) {\n            throw new Error(`Vertical mode needs coordinates to resolve this element. Can also be called with a browser\n                event instead of element to extract element and coordinates from`);\n        }\n        if (scheduler.variableColumnWidths || scheduler.resourceStore.isGrouped) {\n            let totalWidth = 0;\n            for (const col of me.resourceStore) {\n                if (!col.isSpecialRow) {\n                    totalWidth += col.columnWidth || me.resourceColumns.columnWidth;\n                }\n                if (totalWidth >= coords[0]) {\n                    return col;\n                }\n            }\n            return null;\n        }\n        const index = Math.floor(coords[0] / me.resourceColumns.columnWidth);\n        return me.allResourceRecords[index];\n    }\n    toggleCls(assignmentRecord, cls, add = true, useWrapper = false) {\n        const eventData = this.eventMap.get(assignmentRecord.eventId)?.[assignmentRecord.resourceId];\n        if (eventData) {\n            eventData.renderData[useWrapper ? 'wrapperCls' : 'cls'][cls] = add;\n            // Element from the map cannot be trusted, might be reused in which case map is not updated to reflect that.\n            // To be safe, retrieve using `getElementFromAssignmentRecord`\n            const element = this.client.getElementFromAssignmentRecord(assignmentRecord, useWrapper);\n            if (element) {\n                element.classList[add ? 'add' : 'remove'](cls);\n            }\n        }\n    }\n    //endregion\n    //region Coordinate <-> Date\n    getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {\n        let coord = xy[1];\n        if (!local) {\n            coord = this.translateToScheduleCoordinate(coord);\n        }\n        return this.scheduler.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);\n    }\n    translateToScheduleCoordinate(y) {\n        return y - this.scheduler.timeAxisSubGridElement.getBoundingClientRect().top - globalThis.scrollY;\n    }\n    translateToPageCoordinate(y) {\n        return y + this.scheduler.timeAxisSubGridElement.getBoundingClientRect().top + globalThis.scrollY;\n    }\n    //endregion\n    //region Regions\n    getResourceEventBox(event, resource) {\n        const\n            eventId    = event.id,\n            resourceId = resource.id;\n        let { renderData } = this.eventMap.get(eventId)?.[resourceId] || emptyObject;\n        if (!renderData) {\n            // Never been in view, lay it out\n            this.layoutResourceEvents(this.scheduler.resourceStore.getById(resourceId));\n            // Have another go at getting the layout data\n            renderData = this.eventMap.get(eventId)?.[resourceId]?.renderData;\n        }\n        return renderData\n            ? new Rectangle(renderData.left, renderData.top, renderData.width, renderData.bottom - renderData.top)\n            : null;\n    }\n    getScheduleRegion(resourceRecord, eventRecord, local) {\n        const\n            me            = this,\n            { scheduler } = me,\n            // Only interested in width / height (in \"local\" coordinates)\n            region        = Rectangle.from(scheduler.timeAxisSubGridElement, scheduler.timeAxisSubGridElement);\n        if (resourceRecord) {\n            region.left  = me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth;\n            region.right = region.left + scheduler.resourceColumnWidth;\n        }\n        const\n            start           = scheduler.timeAxis.startDate,\n            end             = scheduler.timeAxis.endDate,\n            dateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord) || {\n                start,\n                end\n            },\n            startY          = scheduler.getCoordinateFromDate(DateHelper.max(start, dateConstraints.start)),\n            endY            = scheduler.getCoordinateFromDate(DateHelper.min(end, dateConstraints.end));\n        if (!local) {\n            region.top    = me.translateToPageCoordinate(startY);\n            region.bottom = me.translateToPageCoordinate(endY);\n        }\n        else {\n            region.top    = startY;\n            region.bottom = endY;\n        }\n        return region;\n    }\n    getRowRegion(resourceRecord, startDate, endDate) {\n        const\n            me            = this,\n            { scheduler } = me,\n            x             = me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth,\n            taStart       = scheduler.timeAxis.startDate,\n            taEnd         = scheduler.timeAxis.endDate,\n            start         = startDate ? DateHelper.max(taStart, startDate) : taStart,\n            end           = endDate ? DateHelper.min(taEnd, endDate) : taEnd,\n            startY        = scheduler.getCoordinateFromDate(start),\n            endY          = scheduler.getCoordinateFromDate(end, true, true),\n            y             = Math.min(startY, endY),\n            height        = Math.abs(startY - endY);\n        return new Rectangle(x, y, scheduler.resourceColumnWidth, height);\n    }\n    get visibleDateRange() {\n        const\n            scheduler = this.scheduler,\n            scrollPos = scheduler.scrollable.y,\n            height    = scheduler.scrollable.clientHeight,\n            startDate = scheduler.getDateFromCoordinate(scrollPos) || scheduler.timeAxis.startDate,\n            endDate   = scheduler.getDateFromCoordinate(scrollPos + height) || scheduler.timeAxis.endDate;\n        return {\n            startDate,\n            endDate,\n            startMS : startDate.getTime(),\n            endMS   : endDate.getTime()\n        };\n    }\n    //endregion\n    //region Events\n    // Column width changed, rerender fully\n    onResourceColumnWidthChange({ width, oldWidth }) {\n        const\n            me            = this,\n            { scheduler } = me;\n        // Fix width of column & header\n        me.resourceColumns.width = scheduler.timeAxisColumn.width = me.allResourceRecords.length * width;\n        me.clearAll();\n        // Only transition large changes, otherwise it is janky when dragging slider in demo\n        me.refresh(Math.abs(width - oldWidth) > 30);\n        // Not detected by resizeobserver? Need to call this for virtual scrolling to react to update\n        //        scheduler.callEachSubGrid('refreshFakeScroll');\n        //        scheduler.refreshVirtualScrollbars();\n    }\n    //endregion\n    //region Project\n    attachToProject(project) {\n        super.attachToProject(project);\n        if (project) {\n            project.ion({\n                name    : 'project',\n                refresh : 'onProjectRefresh',\n                thisObj : this\n            });\n        }\n    }\n    onProjectRefresh() {\n        const\n            me                                    = this,\n            { scheduler, toDrawOnProjectRefresh } = me;\n        // Only update the UI immediately if we are visible\n        if (scheduler.isVisible) {\n            if (scheduler.rendered && !scheduler.refreshSuspended) {\n                // Either refresh all rows (on for example dataset)\n                if (me.refreshAllWhenReady) {\n                    me.clearAll();\n                    //scheduler.refreshWithTransition();\n                    me.refresh();\n                    me.refreshAllWhenReady = false;\n                }\n                // Or only affected rows (if any)\n                else if (toDrawOnProjectRefresh.size) {\n                    me.refresh();\n                }\n                toDrawOnProjectRefresh.clear();\n            }\n        }\n        // Otherwise wait till next time we get painted (shown, or a hidden ancestor shown)\n        else {\n            scheduler.whenVisible('refresh', scheduler, [true]);\n        }\n    }\n    //endregion\n    //region EventStore\n    attachToEventStore(eventStore) {\n        super.attachToEventStore(eventStore);\n        this.refreshAllWhenReady = true;\n        if (eventStore) {\n            eventStore.ion({\n                name             : 'eventStore',\n                addConfirmed     : 'onEventStoreAddConfirmed',\n                refreshPreCommit : 'onEventStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n    onEventStoreAddConfirmed({ record }) {\n        for (const element of this.client.getElementsFromEventRecord(record)) {\n            element.classList.remove('b-iscreating');\n        }\n    }\n    onEventStoreRefresh({ action }) {\n        if (action === 'batch') {\n            this.refreshAllWhenReady = true;\n        }\n    }\n    onEventStoreChange({ action, records : eventRecords = [], record, replaced, changes, isAssign }) {\n        const\n            me          = this,\n            resourceIds = new Set();\n        eventRecords.forEach(eventRecord => {\n            // Update all resource rows to which this event is assigned *if* the resourceStore\n            // contains that resource (We could have filtered the resourceStore)\n            const renderedEventResources = eventRecord.$linkedResources?.filter(r => me.resourceStore.includes(r));\n            renderedEventResources?.forEach(resourceRecord => resourceIds.add(resourceRecord.id));\n        });\n        switch (action) {\n            // No-ops\n            case 'sort':  // Order in EventStore does not matter, so these actions are no-ops\n            case 'group':\n            case 'move':\n            case 'remove': // Remove is a no-op since assignment will also be removed\n            case 'batch':\n                return;\n            case 'dataset':\n                me.refreshAllResourcesWhenReady();\n                return;\n            case 'add':\n            case 'updateMultiple':\n                // Just refresh below\n                break;\n            case 'replace':\n                // Gather resources from both the old record and the new one\n                replaced.forEach(([, newEvent]) => {\n                    // Old cleared by changed assignment\n                    newEvent.resources.map(resourceRecord => resourceIds.add(resourceRecord.id));\n                });\n                // And clear them\n                me.clearResources(resourceIds);\n                break;\n            case 'removeall':\n            case 'filter':\n                // Clear all when filtering for simplicity. If that turns out to give bad performance, one would need to\n                // figure out which events was filtered out and only clear their resources.\n                me.clearAll();\n                me.refresh();\n                return;\n            case 'update': {\n                // Check if changes are graph related or not\n                const allChrono = record.$entity\n                    ? !Object.keys(changes).some(name => !record.$entity.getField(name))\n                    : !Object.keys(changes).some(name => !chronoFields[name]);\n                // If any one of these in changes, it will affect visuals\n                let changeCount = 0;\n                if ('startDate' in changes) changeCount++;\n                if ('endDate' in changes) changeCount++;\n                if ('duration' in changes) changeCount++;\n                // Always redraw non chrono changes (name etc)\n                if (!allChrono || changeCount || 'percentDone' in changes || 'inactive' in changes || 'segments' in changes) {\n                    if (me.shouldWaitForInitializeAndEngineReady) {\n                        me.refreshResourcesWhenReady(resourceIds);\n                    }\n                    else {\n                        me.clearResources(resourceIds);\n                        me.refresh();\n                    }\n                }\n                return;\n            }\n        }\n        me.refreshResourcesWhenReady(resourceIds);\n    }\n    //endregion\n    //region ResourceStore\n    attachToResourceStore(resourceStore) {\n        const me = this;\n        super.attachToResourceStore(resourceStore);\n        me.refreshAllWhenReady = true;\n        if (me.resourceColumns) {\n            me.resourceColumns.resourceStore = resourceStore;\n        }\n        resourceStore.ion({\n            name             : 'resourceStore',\n            changePreCommit  : 'onResourceStoreChange',\n            refreshPreCommit : 'onResourceStoreRefresh',\n            // In vertical, resource store is not the row store but should toggle the load mask\n            load             : () => me.scheduler.unmaskBody(),\n            thisObj          : me,\n            prio             : 1 // Call before others to clear cache before redraw\n        });\n        if (me.initialized && me.scheduler.isPainted) {\n            // Invalidate resource range and events\n            me.firstResource = me.lastResource = null;\n            me.clearAll();\n            me.renderer();\n        }\n    }\n    onResourceStoreChange({ source : resourceStore, action, records = [], record, replaced, changes }) {\n        const\n            me              = this,\n            // records for add, record for update, replaced [[old, new]] for replace\n            resourceRecords = replaced ? replaced.map(r => r[1]) : records,\n            resourceIds     = new Set(resourceRecords.map(resourceRecord => resourceRecord.id));\n        // Invalidate resource range\n        me.firstResource                  = me.lastResource = null;\n        resourceStore._allResourceRecords = null;\n        const { allResourceRecords } = resourceStore;\n        // Operation that did not invalidate engine, refresh directly\n        if (me.scheduler.isEngineReady) {\n            switch (action) {\n                case 'update':\n                    if (changes?.id) {\n                        me.clearResources([changes.id.oldValue, changes.id.value]);\n                    }\n                    else {\n                        me.clearResources([record.id]);\n                    }\n                    // Only the invalidation above needed\n                    break;\n                case 'filter':\n                    // All filtered out resources needs clearing and so does those not filtered out since they might have\n                    // moved horizontally when others hide\n                    me.clearAll();\n                    break;\n            }\n            // Changing a column width means columns after that will have to be recalculated\n            // so clear all cached layouts.\n            if (changes && ('columnWidth' in changes)) {\n                me.clearAll();\n            }\n            me.refresh(true);\n        }\n        // Operation that did invalidate project, update on project refresh\n        else {\n            switch (action) {\n                case 'dataset':\n                case 'remove': // Cannot tell from which index it was removed\n                case 'removeall':\n                    me.refreshAllResourcesWhenReady();\n                    return;\n                case 'replace':\n                case 'add': {\n                    if (!resourceStore.isGrouped) {\n                        // Make sure all existing events following added resources are offset correctly\n                        const\n                            firstIndex = resourceRecords.reduce(\n                                (index, record) => Math.min(index, allResourceRecords.indexOf(record)),\n                                allResourceRecords.length\n                            );\n                        for (let i = firstIndex; i < allResourceRecords.length; i++) {\n                            resourceIds.add(allResourceRecords[i].id);\n                        }\n                    }\n                }\n            }\n            me.refreshResourcesWhenReady(resourceIds);\n        }\n    }\n    onResourceStoreRefresh({ action }) {\n        const me = this;\n        if (action === 'sort' || action === 'group') {\n            // Invalidate resource range & cache\n            me.firstResource = me.lastResource = me.resourceStore._allResourceRecords = null;\n            me.clearAll();\n            me.refresh();\n        }\n    }\n    //endregion\n    //region AssignmentStore\n    attachToAssignmentStore(assignmentStore) {\n        super.attachToAssignmentStore(assignmentStore);\n        this.refreshAllWhenReady = true;\n        if (assignmentStore) {\n            assignmentStore.ion({\n                name             : 'assignmentStore',\n                changePreCommit  : 'onAssignmentStoreChange',\n                refreshPreCommit : 'onAssignmentStoreRefresh',\n                thisObj          : this\n            });\n        }\n    }\n    onAssignmentStoreChange({ action, records : assignmentRecords = [], replaced, changes }) {\n        const\n            me          = this,\n            resourceIds = new Set(assignmentRecords.map(assignmentRecord => assignmentRecord.resourceId));\n        // Operation that did not invalidate engine, refresh directly\n        if (me.scheduler.isEngineReady) {\n            switch (action) {\n                case 'remove':\n                    me.clearResources(resourceIds);\n                    break;\n                case 'filter':\n                    me.clearAll();\n                    break;\n                case 'update': {\n                    // When reassigning, clear old resource also\n                    if ('resourceId' in changes) {\n                        resourceIds.add(changes.resourceId.oldValue);\n                    }\n                    // Ignore engine resolving resourceId -> resource, eventId -> event\n                    if (!Object.keys(changes).filter(field => field !== 'resource' && field !== 'event').length) {\n                        return;\n                    }\n                    me.clearResources(resourceIds);\n                }\n            }\n            me.refresh(true);\n        }\n        // Operation that did invalidate project, update on project refresh\n        else {\n            if (changes && 'resourceId' in changes) {\n                resourceIds.add(changes.resourceId.oldValue);\n            }\n            switch (action) {\n                case 'removeall':\n                    me.refreshAllResourcesWhenReady();\n                    return;\n                case 'replace':\n                    // Gather resources from both the old record and the new one\n                    replaced.forEach(([oldAssignment, newAssignment]) => {\n                        resourceIds.add(oldAssignment.resourceId);\n                        resourceIds.add(newAssignment.resourceId);\n                    });\n            }\n            me.refreshResourcesWhenReady(resourceIds);\n        }\n    }\n    onAssignmentStoreRefresh({ action, records }) {\n        if (action === 'batch') {\n            this.clearAll();\n            this.refreshAllResourcesWhenReady();\n        }\n    }\n    //endregion\n    //region View hooks\n    refreshRows(reLayoutEvents) {\n        if (reLayoutEvents) {\n            this.clearAll();\n            this.scheduler.refreshFromRerender = false;\n        }\n    }\n    // Called from SchedulerEventRendering\n    repaintEventsForResource(resourceRecord) {\n        this.renderResource(resourceRecord);\n    }\n    updateFromHorizontalScroll(scrollX) {\n        if (scrollX !== this.prevScrollX) {\n            this.renderer();\n            this.prevScrollX = scrollX;\n        }\n    }\n    updateFromVerticalScroll() {\n        this.renderer();\n    }\n    scrollResourceIntoView(resourceRecord, options) {\n        const\n            { scheduler } = this,\n            x             = this.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth;\n        return scheduler.scrollHorizontallyTo(x, options);\n    }\n    get allResourceRecords() {\n        return this.scheduler.resourceStore.allResourceRecords;\n    }\n    // Called when viewport size changes\n    onViewportResize(width) {\n        this.resourceColumns.availableWidth = width;\n        this.renderer();\n    }\n    get resourceColumns() {\n        return this.scheduler.timeAxisColumn?.resourceColumns;\n    }\n    // Clear events in case they use date as part of displayed info\n    onLocaleChange() {\n        this.clearAll();\n    }\n    // No need to do anything special\n    onDragAbort() {}\n    onBeforeRowHeightChange() {}\n    onTimeAxisViewModelUpdate() {}\n    updateElementId() {}\n    releaseTimeSpanDiv() {}\n    //endregion\n    //region Dependency connectors\n    /**\n     * Gets displaying item start side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'top'|'left'|'bottom'|'right'} 'left' / 'right' / 'top' / 'bottom'\n     */\n    getConnectorStartSide(eventRecord) {\n        return 'top';\n    }\n    /**\n     * Gets displaying item end side\n     *\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @returns {'top'|'left'|'bottom'|'right'} 'left' / 'right' / 'top' / 'bottom'\n     */\n    getConnectorEndSide(eventRecord) {\n        return 'bottom';\n    }\n    //endregion\n    //region Refresh resources\n    /**\n     * Clears resources directly and redraws them on next project refresh\n     * @param {Number[]|String[]} resourceIds\n     * @private\n     */\n    refreshResourcesWhenReady(resourceIds) {\n        this.clearResources(resourceIds);\n        resourceIds.forEach(id => this.toDrawOnProjectRefresh.add(id));\n    }\n    /**\n     * Clears all resources directly and redraws them on next project refresh\n     * @private\n     */\n    refreshAllResourcesWhenReady() {\n        this.clearAll();\n        this.refreshAllWhenReady = true;\n    }\n    //region Rendering\n    // Resources in view + buffer\n    get resourceRange() {\n        return this.getResourceRange(true);\n    }\n    // Resources strictly in view\n    get visibleResources() {\n        const { first, last } = this.getResourceRange();\n        return {\n            first : this.allResourceRecords[first],\n            last  : this.allResourceRecords[last]\n        };\n    }\n    getResourceRange(withBuffer) {\n        const\n            {\n                scheduler,\n                resourceStore\n            }                  = this,\n            {\n                resourceColumnWidth,\n                scrollX\n            }                  = scheduler,\n            {\n                scrollWidth\n            }                  = scheduler.timeAxisSubGrid.scrollable,\n            resourceBufferSize = withBuffer ? this.resourceBufferSize : 0,\n            viewportStart      = scrollX - resourceBufferSize,\n            viewportEnd        = scrollX + scrollWidth + resourceBufferSize;\n        if (!resourceStore?.count) {\n            return { first : -1, last : -1 };\n        }\n        // Some resources define their own width\n        if (scheduler.variableColumnWidths) {\n            let first, last = 0, start, end = 0;\n            this.allResourceRecords.forEach((resource, i) => {\n                resource.instanceMeta(scheduler).insetStart = start = end;\n                end                                         = start + resource.columnWidth;\n                if (start > viewportEnd) {\n                    return false;\n                }\n                if (end > viewportStart && first == null) {\n                    first = i;\n                }\n                else if (start < viewportEnd) {\n                    last = i;\n                }\n            });\n            return { first, last };\n        }\n        // We are using fixed column widths\n        else {\n            return {\n                first : Math.max(Math.floor(scrollX / resourceColumnWidth) - resourceBufferSize, 0),\n                last  : Math.min(\n                    Math.floor((scrollX + scheduler.timeAxisSubGrid.width) / resourceColumnWidth) + resourceBufferSize,\n                    this.allResourceRecords.length - 1\n                )\n            };\n        }\n    }\n    // Dates in view + buffer\n    get dateRange() {\n        const\n            { scheduler } = this;\n        let bottomDate = scheduler.getDateFromCoordinate(Math.min(\n            scheduler.scrollTop + scheduler.bodyHeight + scheduler.tickSize - 1,\n            (scheduler.virtualScrollHeight || scheduler.scrollable.scrollHeight) - 1)\n        );\n        // Might end up below time axis (out of ticks)\n        if (!bottomDate) {\n            bottomDate = scheduler.timeAxis.last.endDate;\n        }\n        let topDate = scheduler.getDateFromCoordinate(Math.max(scheduler.scrollTop - scheduler.tickSize, 0));\n        // Might end up above time axis when reconfiguring (since this happens as part of rendering)\n        if (!topDate) {\n            topDate    = scheduler.timeAxis.first.startDate;\n            bottomDate = scheduler.getDateFromCoordinate(scheduler.bodyHeight + scheduler.tickSize - 1);\n        }\n        return {\n            topDate,\n            bottomDate\n        };\n    }\n    getTimeSpanRenderData(eventRecord, resourceRecord, includeOutside = false) {\n        const\n            me             = this,\n            {\n                scheduler\n            }              = me,\n            {\n                preamble,\n                postamble\n            }              = eventRecord,\n            {\n                variableColumnWidths\n            }              = scheduler,\n            useEventBuffer = scheduler.features.eventBuffer?.enabled && me.isProVerticalRendering &&\n                (preamble || postamble) && !eventRecord.isMilestone,\n            startDateField = useEventBuffer ? 'wrapStartDate' : 'startDate',\n            endDateField   = useEventBuffer ? 'wrapEndDate' : 'endDate',\n            // Must use Model.get in order to get latest values in case we are inside a batch.\n            // EventResize changes the endDate using batching to enable a tentative change\n            // via the batchedUpdate event which is triggered when changing a field in a batch.\n            // Fall back to accessor if propagation has not populated date fields.\n            startDate      = eventRecord.isBatchUpdating && eventRecord.hasBatchedChange(startDateField) && !useEventBuffer\n                ? eventRecord.get(startDateField) : eventRecord[startDateField],\n            endDate        = eventRecord.isBatchUpdating && eventRecord.hasBatchedChange(endDateField) && !useEventBuffer\n                ? eventRecord.get(endDateField) : eventRecord[endDateField],\n            {\n                resourceMarginObject : { total }\n            }              = scheduler.getResourceLayoutSettings(resourceRecord),\n            top            = scheduler.getCoordinateFromDate(startDate),\n            instanceMeta   = resourceRecord.instanceMeta(scheduler),\n            // Preliminary values for left & width, used for proxy. Will be changed on layout.\n            // The property \"left\" is utilized based on Scheduler's rtl setting.\n            // If RTL, then it's used as the \"right\" style position.\n            left           = variableColumnWidths ? instanceMeta.insetStart : me.allResourceRecords.indexOf(resourceRecord) * scheduler.resourceColumnWidth,\n            resourceWidth  = scheduler.getResourceWidth(resourceRecord),\n            width          = resourceWidth - total,\n            startDateMS    = startDate.getTime(),\n            endDateMS      = endDate.getTime();\n        let bottom = scheduler.getCoordinateFromDate(endDate),\n            height = bottom - top;\n        // Below, estimate height\n        if (bottom === -1) {\n            height = Math.round((endDateMS - startDateMS) * scheduler.timeAxisViewModel.getSingleUnitInPixels('millisecond'));\n            bottom = top + height;\n        }\n        return {\n            eventRecord,\n            resourceRecord,\n            left,\n            top,\n            bottom,\n            resourceWidth,\n            width,\n            height,\n            startDate,\n            endDate,\n            startDateMS,\n            endDateMS,\n            useEventBuffer,\n            children : [],\n            start   : startDate,\n            end     : endDate,\n            startMS : startDateMS,\n            endMS   : endDateMS\n        };\n    }\n    // Earlier start dates are above later tasks\n    // If same start date, longer tasks float to top\n    // If same start + duration, sort by name\n    eventSorter(a, b) {\n        const\n            startA = a.dataStartMs || a.startDateMS, // dataXX are used if configured with fillTicks\n            endA   = a.dataEndMs || a.endDateMS,\n            startB = b.dataStartMs || b.startDateMS,\n            endB   = b.dataEndMs || b.endDateMS,\n            nameA  = a.isModel ? a.name : a.eventRecord.name,\n            nameB  = b.isModel ? b.name : b.eventRecord.name;\n        return startA - startB || endB - endA || (nameA < nameB ? -1 : nameA == nameB ? 0 : 1);\n    }\n    layoutEvents(resourceRecord, allEvents, includeOutside = false, parentEventRecord, eventSorter) {\n        const\n            me                        = this,\n            { scheduler }             = me,\n            {\n                variableColumnWidths\n            }                         = scheduler,\n            { id : resourceId }       = resourceRecord,\n            instanceMeta              = resourceRecord.instanceMeta(scheduler),\n            cacheKey                  = parentEventRecord ? `${resourceId}-${parentEventRecord.id}` : resourceId,\n            // Cache per resource\n            cache                     = me.resourceMap.set(cacheKey, {}).get(cacheKey),\n            // Resource \"column\"\n            resourceIndex             = me.allResourceRecords.indexOf(resourceRecord),\n            {\n                barMargin,\n                resourceMarginObject : { start, total }\n            }                         = scheduler.getResourceLayoutSettings(resourceRecord, parentEventRecord);\n        const layoutData = allEvents.reduce((toLayout, eventRecord) => {\n            if (eventRecord.isScheduled) {\n                const\n                    renderData     = scheduler.generateRenderData(eventRecord, resourceRecord, false),\n                    // Elements will be appended to eventData during syncing\n                    eventData      = { renderData },\n                    eventResources = ObjectHelper.getMapPath(me.eventMap, renderData.eventId, {});\n                // Cache per event, { e1 : { r1 : { xxx }, r2 : ... }, e2 : ... }\n                // Uses renderData.eventId in favor of eventRecord.id to work with ResourceTimeRanges\n                eventResources[resourceId] = eventData;\n                // Cache per resource\n                cache[renderData.eventId] = eventData;\n                // Position ResourceTimeRanges directly, they do not affect the layout of others\n                if (renderData.fillSize) {\n                    // The property \"left\" is utilized based on Scheduler's rtl setting.\n                    // If RTL, then it's used as the \"right\" style position.\n                    renderData.left = variableColumnWidths ? instanceMeta.insetStart : resourceIndex * scheduler.resourceColumnWidth;\n                    renderData.width = scheduler.getResourceWidth(resourceRecord);\n                }\n                // Anything not flagged with `fillSize` should take part in layout\n                else {\n                    toLayout.push(renderData);\n                }\n            }\n            return toLayout;\n        }, []);\n        // Ensure the events are rendered in natural order so that navigation works.\n        layoutData.sort(eventSorter ?? me.eventSorter);\n        // Apply per resource event layout (pack, overlap or mixed)\n        me.verticalLayout.applyLayout(\n            layoutData,\n            scheduler.getResourceWidth(resourceRecord, parentEventRecord),\n            start,\n            total,\n            barMargin,\n            resourceIndex,\n            scheduler.getEventLayout(resourceRecord, parentEventRecord)\n        );\n        return cache;\n    }\n    // Calculate the layout for all events assigned to a resource. Since we are never stacking, the layout of one\n    // resource will never affect the others\n    layoutResourceEvents(resourceRecord) {\n        const\n            me                  = this,\n            { scheduler }       = me,\n            // Used in loop, reduce access time a wee bit\n            {\n                assignmentStore,\n                eventStore,\n                timeAxis\n            }                   = scheduler;\n        // Events for the resource, minus those that are filtered out by filtering assignments and events\n        let events = eventStore.getEvents({\n            includeOccurrences : scheduler.enableRecurringEvents,\n            resourceRecord,\n            startDate          : timeAxis.startDate,\n            endDate            : timeAxis.endDate,\n            filter             : (assignmentStore.isFiltered || eventStore.isFiltered) && (eventRecord =>\n                eventRecord.assignments.some(a => a.resource === resourceRecord && assignmentStore.includes(a)))\n        });\n        // Hook for features to inject additional timespans to render\n        events = scheduler.getEventsToRender(resourceRecord, events);\n        return me.layoutEvents(resourceRecord, events);\n    }\n    /**\n     * Used by event drag features to bring into existence event elements that are outside of the rendered block.\n     * @param {Scheduler.model.TimeSpan} eventRecord The event to render\n     * @private\n     */\n    addTemporaryDragElement(eventRecord) {\n        const\n            { scheduler } = this,\n            renderData    = scheduler.generateRenderData(\n                eventRecord,\n                eventRecord.resource,\n                { timeAxis : true, viewport : true }\n            );\n        renderData.top = renderData.row\n            ? (renderData.top + renderData.row.top)\n            : scheduler.getResourceEventBox(eventRecord, eventRecord.resource, true).top;\n        const\n            domConfig   = this.renderEvent({ renderData }),\n            { dataset } = domConfig;\n        delete domConfig.tabIndex;\n        delete dataset.eventId;\n        delete dataset.resourceId;\n        delete dataset.assignmentId;\n        delete dataset.syncId;\n        dataset.transient = true;\n        domConfig.parent  = this.scheduler.foregroundCanvas;\n        // So that the regular DomSyncing which may happen during scroll does not\n        // sweep up and reuse the temporary element.\n        domConfig.retainElement = true;\n        const result = DomHelper.createElement(domConfig);\n        result.innerElement = result.firstChild;\n        eventRecord.instanceMeta(scheduler).hasTemporaryDragElement = true;\n        return result;\n    }\n    // To update an event, first release its element and then render it again.\n    // The element will be reused and updated. Keeps code simpler\n    renderEvent(eventData) {\n        // No point in rendering event that already has an element\n        const\n            { scheduler } = this,\n            data          = eventData.renderData,\n            {\n                resourceRecord,\n                assignmentRecord,\n                eventRecord\n            }             = data,\n            // Event element config, applied to existing element or used to create a new one below\n            elementConfig = {\n                className : data.wrapperCls,\n                tabIndex  : -1,\n                children  : [\n                    {\n                        role      : 'presentation',\n                        className : data.cls,\n                        style     : (data.internalStyle || '') + (data.style || ''),\n                        children  : data.children,\n                        dataset   : {\n                            // Each feature putting contents in the event wrap should have this to simplify syncing and\n                            // element retrieval after sync\n                            taskFeature : 'event'\n                        },\n                        syncOptions : {\n                            syncIdField : 'taskBarFeature'\n                        }\n                    },\n                    ...data.wrapperChildren\n                ],\n                style : {\n                    top                                : data.top,\n                    [scheduler.rtl ? 'right' : 'left'] : data.left,\n                    // DomHelper appends px to dimensions when using numbers\n                    height                             : eventRecord.isMilestone ? '1em' : data.height,\n                    width                              : data.width,\n                    style                              : data.wrapperStyle || '',\n                    fontSize                           : eventRecord.isMilestone ? Math.min(data.width, 40) : null\n                },\n                dataset : {\n                    // assignmentId is set in this function conditionally\n                    resourceId : resourceRecord.id,\n                    eventId    : data.eventId, // Not using eventRecord.id to distinguish between Event and ResourceTimeRange\n                    // Sync using assignment id for events and event id for ResourceTimeRanges\n                    syncId     : assignmentRecord ? this.assignmentStore.getOccurrence(assignmentRecord, eventRecord).id : data.eventId\n                },\n                // Will not be part of DOM, but attached to the element\n                elementData   : eventData,\n                // Dragging etc. flags element as retained, to not reuse/release it during that operation. Events\n                // always use assignments, but ResourceTimeRanges does not\n                retainElement : (assignmentRecord || eventRecord).instanceMeta(this.scheduler).retainElement,\n                // Options for this level of sync, lower levels can have their own\n                syncOptions   : {\n                    syncIdField      : 'taskFeature',\n                    // Remove instead of release when a feature is disabled\n                    releaseThreshold : 0\n                }\n            };\n        elementConfig.className['b-sch-vertical'] = 1;\n        // Some browsers throw warnings on zIndex = ''\n        if (data.zIndex) {\n            elementConfig.zIndex = data.zIndex;\n        }\n        // Do not want to spam dataset with empty prop when not using assignments (ResourceTimeRanges)\n        if (assignmentRecord) {\n            elementConfig.dataset.assignmentId = assignmentRecord.id;\n        }\n        // Allows access to the used config later, for example to retrieve element\n        data.elementConfig = eventData.elementConfig = elementConfig;\n        scheduler.afterRenderEvent({ renderData : data, domConfig : elementConfig });\n        return elementConfig;\n    }\n    renderResource(resourceRecord) {\n        const\n            me                          = this,\n            // Date at top and bottom for determining which events to include\n            { topDateMS, bottomDateMS } = me,\n            // Will hold element configs\n            eventDOMConfigs             = [];\n        let resourceEntry = me.resourceMap.get(resourceRecord.id);\n        // Layout all events for the resource unless already done\n        if (!resourceEntry) {\n            resourceEntry = me.layoutResourceEvents(resourceRecord);\n        }\n        // Iterate over all events for the resource\n        for (const eventId in resourceEntry) {\n            const\n                eventData                               = resourceEntry[eventId],\n                { endDateMS, startDateMS, eventRecord } = eventData.renderData;\n            if (\n                // Only collect configs for those actually in view\n                endDateMS >= topDateMS && startDateMS <= bottomDateMS &&\n                // And not being dragged, those have a temporary element already\n                !eventRecord.instanceMeta(me.scheduler).hasTemporaryDragElement\n            ) {\n                // Reuse DomConfig if available, otherwise render event to create one\n                const domConfig = eventData.elementConfig?.className !== 'b-released' && eventData.elementConfig || me.renderEvent(eventData);\n                eventDOMConfigs.push(domConfig);\n            }\n        }\n        return eventDOMConfigs;\n    }\n    isEventElement(domConfig) {\n        const className = domConfig && domConfig.className;\n        return className && className[this.scheduler.eventCls + '-wrap'];\n    }\n    get shouldWaitForInitializeAndEngineReady() {\n        return !this.initialized || (!this.scheduler.isEngineReady && !this.scheduler.isCreating);\n    }\n    // Single cell so only one call to this renderer, determine which events are in view and draw them.\n    // Drawing on scroll is triggered by `updateFromVerticalScroll()` and `updateFromHorizontalScroll()`\n    renderer() {\n        const\n            me                                           = this,\n            { scheduler }                                = me,\n            // Determine resource range to draw events for\n            { first : firstResource, last : lastResource } = me.resourceRange,\n            // Date at top and bottom for determining which events to include\n            { topDate, bottomDate }                        = me.dateRange,\n            syncConfigs                                    = [],\n            featureDomConfigs                              = [];\n        // If scheduler is creating a new event, the render needs to be synchronous, so\n        // we cannot wait for the engine to normalize - the new event will have correct data set.\n        if (me.shouldWaitForInitializeAndEngineReady) {\n            return;\n        }\n        // Update current time range, reflecting the change on the vertical time axis header\n        if (!DateHelper.isEqual(topDate, me.topDate) || !DateHelper.isEqual(bottomDate, me.bottomDate)) {\n            // Calculated values used by `renderResource()`\n            me.topDate      = topDate;\n            me.bottomDate   = bottomDate;\n            me.topDateMS    = topDate.getTime();\n            me.bottomDateMS = bottomDate.getTime();\n            const range = me.timeView.range = { startDate : topDate, endDate : bottomDate };\n            scheduler.internalOnVisibleDateRangeChange(range);\n        }\n        if (firstResource !== -1 && lastResource !== -1) {\n            // Collect all events for resources in view\n            for (let i = firstResource; i <= lastResource; i++) {\n                syncConfigs.push.apply(syncConfigs, me.renderResource(me.allResourceRecords[i]));\n            }\n        }\n        scheduler.getForegroundDomConfigs(featureDomConfigs);\n        syncConfigs.push.apply(syncConfigs, featureDomConfigs);\n        DomSync.sync({\n            domConfig : {\n                onlyChildren : true,\n                children     : syncConfigs\n            },\n            targetElement : scheduler.foregroundCanvas,\n            syncIdField   : 'syncId',\n            // Called by DomHelper when it creates, releases or reuses elements\n            callback({ action, domConfig, lastDomConfig, targetElement, jsx }) {\n                const { reactComponent } = scheduler;\n                // If element is an event wrap, trigger appropriate events\n                if (me.isEventElement(domConfig) || jsx || domConfig?.elementData?.jsx) {\n                    const\n                        // Some actions are considered first a release and then a render (reusing another element).\n                        // This gives clients code a chance to clean up before reusing an element\n                        isRelease = releaseEventActions[action],\n                        isRender  = renderEventActions[action];\n                    if (scheduler.processEventContent?.({\n                        action,\n                        domConfig,\n                        isRelease : false,\n                        targetElement,\n                        reactComponent,\n                        jsx\n                    })) return;\n                    // If we are reusing an element that was previously released we should not trigger again\n                    if (isRelease && me.isEventElement(lastDomConfig) && !lastDomConfig.isReleased) {\n                        const\n                            data  = lastDomConfig.elementData.renderData,\n                            event = {\n                                renderData       : data,\n                                assignmentRecord : data.assignmentRecord,\n                                eventRecord      : data.eventRecord,\n                                resourceRecord   : data.resourceRecord,\n                                element          : targetElement\n                            };\n                        // Release any portal in React event content\n                        scheduler.processEventContent?.({\n                            isRelease,\n                            targetElement,\n                            reactComponent,\n                            assignmentRecord : data.assignmentRecord\n                        });\n                        // Some browsers do not blur on set to display:none, so releasing the active element\n                        // must *explicitly* move focus outwards to the view.\n                        if (targetElement === DomHelper.getActiveElement(targetElement)) {\n                            scheduler.focusElement.focus();\n                        }\n                        // This event is documented on Scheduler\n                        scheduler.trigger('releaseEvent', event);\n                    }\n                    if (isRender) {\n                        const\n                            data  = domConfig.elementData.renderData,\n                            event = {\n                                renderData       : data,\n                                assignmentRecord : data.assignmentRecord,\n                                eventRecord      : data.eventRecord,\n                                resourceRecord   : data.resourceRecord,\n                                element          : targetElement,\n                                isReusingElement : action === 'reuseElement',\n                                isRepaint        : action === 'reuseOwnElement'\n                            };\n                        event.reusingElement = action === 'reuseElement';\n                        // This event is documented on Scheduler\n                        scheduler.trigger('renderEvent', event);\n                    }\n                }\n            }\n        });\n        // Change in displayed resources?\n        if (me.firstResource !== firstResource || me.lastResource !== lastResource) {\n            // Update header to match\n            const range = me.resourceColumns.visibleResources = { firstResource, lastResource };\n            // Store which resources are currently in view\n            me.firstResource = firstResource;\n            me.lastResource  = lastResource;\n            scheduler.onVisibleResourceRangeChange(range);\n            scheduler.trigger('resourceRangeChange', range);\n        }\n    }\n    refresh(transition) {\n        this.scheduler.runWithTransition(() => this.renderer(), transition);\n    }\n    // To match horizontals API, used from EventDrag\n    refreshResources(resourceIds) {\n        this.clearResources(resourceIds);\n        this.refresh();\n    }\n    // To match horizontals API, used from EventDrag\n    refreshEventsForResource(recordOrRow, force = true, draw = true) {\n        this.refreshResources([recordOrRow.id]);\n    }\n    onRenderDone() {\n    }\n    //endregion\n    //region Other\n    get timeView() {\n        return this.scheduler.timeView;\n    }\n    //endregion\n    //region Cache\n    // Clears cached resource layout\n    clearResources(resourceIds) {\n        const { resourceMap, eventMap } = this;\n        resourceIds.forEach(resourceId => {\n            if (resourceMap.has(resourceId)) {\n                // The *keys* of an Object are strings, so we must iterate the values\n                // and use the original eventId to look up in the Map which preserves key type.\n                Object.values(resourceMap.get(resourceId)).forEach(({ renderData : { eventId } }) => {\n                    delete eventMap.get(eventId)[resourceId];\n                });\n                resourceMap.delete(resourceId);\n            }\n        });\n    }\n    clearAll() {\n        this.resourceMap.clear();\n        this.eventMap.clear();\n    }\n    //endregion\n}\nVerticalRendering._$name = 'VerticalRendering';", "import Widget from '../../Core/widget/Widget.js';\nimport DomSync from '../../Core/helper/DomSync.js';\n/**\n * @module Scheduler/view/TimeAxisBase\n */\nfunction isLastLevel(level, levels) {\n    return level === levels.length - 1;\n}\nfunction isLastCell(level, cell) {\n    return cell === level.cells[level.cells.length - 1];\n}\n/**\n * Base class for HorizontalTimeAxis and VerticalTimeAxis. Contains shared functionality to only render ticks in view,\n * should not be used directly.\n *\n * @extends Core/widget/Widget\n * @private\n * @abstract\n */\nexport default class TimeAxisBase extends Widget {\n    static $name = 'TimeAxisBase';\n    //region Config\n    static configurable = {\n        /**\n         * The minimum width for a bottom row header cell to be considered 'compact', which adds a special CSS class\n         * to the row (for special styling). Copied from Scheduler/Gantt.\n         * @config {Number}\n         * @default\n         */\n        compactCellWidthThreshold : 15,\n        // TimeAxisViewModel\n        model : null,\n        cls : null,\n        /**\n         * Style property to use as cell size. Either width or height depending on orientation\n         * @config {'width'|'height'}\n         * @private\n         */\n        sizeProperty : null,\n        /**\n         * Style property to use as cells position. Either left or top depending on orientation\n         * @config {'left'|'top'}\n         * @private\n         */\n        positionProperty : null\n    };\n    startDate = null;\n    endDate   = null;\n    levels    = [];\n    size      = null;\n    // Set visible date range\n    set range({ startDate, endDate }) {\n        const me = this;\n        // Only process a change\n        if (me.startDate - startDate || me.endDate - endDate) {\n            const { client } = me;\n            me.startDate = startDate;\n            me.endDate = endDate;\n            // Avoid refreshing if time axis view is not visible\n            if ((me.sizeProperty === 'width' && client?.hideHeaders) ||\n                (me.sizeProperty === 'height' && client?.verticalTimeAxisColumn?.hidden)) {\n                return;\n            }\n            me.refresh();\n        }\n    }\n    //endregion\n    //region Html & rendering\n    // Generates element configs for all levels defined by the current ViewPreset\n    buildCells(start = this.startDate, end = this.endDate) {\n        const\n            me                   = this,\n            { sizeProperty }     = me,\n            {\n                stickyHeaders,\n                isVertical\n            }                    = me.client || {},\n            featureHeaderConfigs = [],\n            { length }           = me.levels;\n        const cellConfigs = me.levels.map((level, i) => {\n            const stickyHeader = stickyHeaders && (isVertical || i < length - 1);\n            return {\n                className : {\n                    'b-sch-header-row'                     : 1,\n                    [`b-sch-header-row-${level.position}`] : 1,\n                    'b-sch-header-row-main'                : i === me.model.viewPreset.mainHeaderLevel,\n                    'b-lowest'                             : isLastLevel(i, me.levels),\n                    'b-sticky-header'                      : stickyHeader\n                },\n                syncOptions : {\n                    // Keep a maximum of 5 released cells. Might be fine with fewer since ticks are fixed width.\n                    // Prevents an unnecessary amount of cells from sticking around when switching from narrow to\n                    // wide tickSizes\n                    releaseThreshold : 5,\n                    syncIdField      : 'tickIndex'\n                },\n                dataset : {\n                    headerFeature  : `headerRow${i}`,\n                    headerPosition : level.position\n                },\n                // Only include cells in view\n                children : level.cells?.filter(cell => cell.start < end && cell.end > start).map((cell, j) => ({\n                    role      : 'presentation',\n                    className : {\n                        'b-sch-header-timeaxis-cell' : 1,\n                        [cell.headerCellCls]         : cell.headerCellCls,\n                        [`b-align-${cell.align}`]    : cell.align,\n                        'b-last'                     : isLastCell(level, cell)\n                    },\n                    dataset : {\n                        tickIndex : cell.index,\n                        // Used in export tests to resolve dates from tick elements\n                        ...globalThis.DEBUG && { date : cell.start.getTime() }\n                    },\n                    style : {\n                        // DomHelper appends px to numeric dimensions\n                        [me.positionProperty]   : cell.coord,\n                        [sizeProperty]          : cell.width,\n                        [`min-${sizeProperty}`] : cell.width\n                    },\n                    children : [\n                        {\n                            tag       : 'span',\n                            role      : 'presentation',\n                            className : {\n                                'b-sch-header-text' : 1,\n                                'b-sticky-header'   : stickyHeader\n                            },\n                            html : cell.value\n                        }\n                    ]\n                }))\n            };\n        });\n        // When tested in isolation there is no client\n        me.client?.getHeaderDomConfigs(featureHeaderConfigs);\n        cellConfigs.push(...featureHeaderConfigs);\n        // noinspection JSSuspiciousNameCombination\n        return {\n            onlyChildren : true,\n            syncOptions  : {\n                // Do not keep entire levels no longer used, for example after switching view preset\n                releaseThreshold : 0\n            },\n            children : cellConfigs\n        };\n    }\n    render(targetElement) {\n        super.render(targetElement);\n        this.refresh(true);\n    }\n    /**\n     * Refresh the UI\n     * @param {Boolean} [rebuild] Specify `true` to force a rebuild of the underlying header level definitions\n     */\n    refresh(rebuild = !this.levels.length) {\n        const\n            me               = this,\n            { columnConfig } = me.model,\n            { levels }       = me,\n            oldLevelsCount   = levels.length;\n        if (rebuild) {\n            levels.length = 0;\n            columnConfig.forEach((cells, position) => levels[position] = {\n                position,\n                cells\n            });\n            me.size = levels[0].cells.reduce((sum, cell) => sum + cell.width, 0);\n            const { parentElement } = me.element;\n            // Don't mutate a classList unless necessary. Browsers invalidate the style.\n            if (parentElement && (levels.length !== oldLevelsCount || rebuild)) {\n                parentElement.classList.remove(`b-sch-timeaxiscolumn-levels-${oldLevelsCount}`);\n                parentElement.classList.add(`b-sch-timeaxiscolumn-levels-${levels.length}`);\n            }\n        }\n        if (!me.startDate || !me.endDate) {\n            return;\n        }\n        // Boil down levels to only show what is in view\n        DomSync.sync({\n            domConfig     : me.buildCells(),\n            targetElement : me.element,\n            syncIdField   : 'headerFeature'\n        });\n        me.trigger('refresh');\n    }\n    //endregion\n    // Our widget class doesn't include \"base\".\n    get widgetClass() {\n        return 'b-timeaxis';\n    }\n}\nTimeAxisBase._$name = 'TimeAxisBase';", "import TimeAxisBase from './TimeAxisBase.js';\n/**\n * @module Scheduler/view/HorizontalTimeAxis\n */\n/**\n * A visual horizontal representation of the time axis described in the\n * {@link Scheduler.preset.ViewPreset#field-headers} field.\n * Normally you should not interact with this class directly.\n *\n * @extends Scheduler/view/TimeAxisBase\n * @private\n */\nexport default class HorizontalTimeAxis extends TimeAxisBase {\n    //region Config\n    static $name = 'HorizontalTimeAxis';\n    static type = 'horizontaltimeaxis';\n    static configurable = {\n        model        : null,\n        sizeProperty : 'width'\n    };\n    //endregion\n    get positionProperty() {\n        return this.owner?.rtl ? 'right' : 'left';\n    }\n    get width() {\n        return this.size;\n    }\n    onModelUpdate() {\n        // Force rebuild when availableSpace has changed, to recalculate width and maybe apply compact styling\n        if (!this.owner?.hideHeaders && this.model.availableSpace > 0 && this.model.availableSpace !== this.width) {\n            this.refresh(true);\n        }\n    }\n    updateModel(timeAxisViewModel) {\n        this.detachListeners('tavm');\n        timeAxisViewModel?.ion({\n            name    : 'tavm',\n            update  : 'onModelUpdate',\n            thisObj : this\n        });\n    }\n}\nHorizontalTimeAxis._$name = 'HorizontalTimeAxis';", "import Widget from '../../Core/widget/Widget.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport AvatarRendering from '../../Core/widget/util/AvatarRendering.js';\n/**\n * @module Scheduler/view/ResourceHeader\n */\n/**\n * Header widget that renders resource column headers and acts as the interaction point for resource columns in vertical\n * mode. Note that it uses virtual rendering and element reusage to gain performance, only headers in view are available\n * in DOM. Because of this you should avoid direct element manipulation, any such changes can be discarded at any time.\n *\n * By default, it displays resources `name` and also applies its `iconCls` if any, like this:\n *\n * ```html\n * <i class=\"iconCls\">name</i>\n * ```\n *\n * If Scheduler is configured with a {@link Scheduler.view.Scheduler#config-resourceImagePath} the\n * header will render miniatures for the resources, using {@link Scheduler.model.ResourceModel#field-imageUrl}\n * or {@link Scheduler.model.ResourceModel#field-image} with fallback to\n * {@link Scheduler.model.ResourceModel#field-name} + {@link Scheduler.view.Scheduler#config-resourceImageExtension}\n * for unset values.\n *\n * The contents and styling of the resource cells in the header can be customized using {@link #config-headerRenderer}:\n *\n * ```javascript\n * new Scheduler({\n *     mode            : 'vertical',\n *     resourceColumns : {\n *         headerRenderer : ({ resourceRecord }) => `Hello ${resourceRecord.name}`\n *     }\n * }\n *```\n *\n * The width of the resource columns is determined by the {@link #config-columnWidth} config.\n *\n * @extends Core/widget/Widget\n */\nexport default class ResourceHeader extends Widget {\n    //region Config\n    static $name = 'ResourceHeader';\n    static type = 'resourceheader';\n    static configurable = {\n        /**\n         * Resource store used to render resource headers. Assigned from Scheduler.\n         * @config {Scheduler.data.ResourceStore}\n         * @private\n         */\n        resourceStore : null,\n        /**\n         * Custom header renderer function. Can be used to manipulate the element config used to create the element\n         * for the header:\n         *\n         * ```javascript\n         * new Scheduler({\n         *   resourceColumns : {\n         *     headerRenderer({ elementConfig, resourceRecord }) {\n         *       elementConfig.dataset.myExtraData = 'extra';\n         *       elementConfig.style.fontWeight = 'bold';\n         *     }\n         *   }\n         * });\n         * ```\n         *\n         * See {@link DomConfig} for more information.\n         * Please take care to not break the default configs :)\n         *\n         * Or as a template by returning HTML from the function:\n         *\n         * ```javascript\n         * new Scheduler({\n         *   resourceColumns : {\n         *     headerRenderer : ({ resourceRecord }) => `\n         *       <div class=\"my-custom-template\">\n         *       ${resourceRecord.firstName} {resourceRecord.surname}\n         *       </div>\n         *     `\n         *   }\n         * });\n         * ```\n         *\n         * NOTE: When using `headerRenderer` no default internal markup is applied to the resource header cell,\n         * `iconCls` and {@link Scheduler.model.ResourceModel#field-imageUrl} or {@link Scheduler.model.ResourceModel#field-image}\n         * will have no effect unless you supply custom markup for them.\n         *\n         * @config {Function}\n         * @param {Object} params Object containing the params below\n         * @param {Scheduler.model.ResourceModel} params.resourceRecord Resource whose header is being rendered\n         * @param {DomConfig} params.elementConfig A config object used to create the element for the resource\n         * @returns {void}\n         */\n        headerRenderer : null,\n        /**\n         * Set to `false` to render just the resource name, `true` to render an avatar (or initials if no image exists)\n         * @config {Boolean}\n         * @default true\n         */\n        showAvatars : {\n            value : true,\n            $config : 'nullify'\n        },\n        /**\n         * Assign to toggle resource columns **fill* mode. `true` means they will stretch (grow) to fill viewport, `false`\n         * that they will respect their configured `columnWidth`.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @member {Boolean} fillWidth\n         */\n        /**\n         * Automatically resize resource columns to **fill** available width. Set to `false` to always respect the\n         * configured `columnWidth`.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @config {Boolean}\n         * @default\n         */\n        fillWidth : true,\n        /**\n         * Assign to toggle resource columns **fit* mode. `true` means they will grow or shrink to always fit viewport,\n         * `false` that they will respect their configured `columnWidth`.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @member {Boolean} fitWidth\n         */\n        /**\n         * Automatically resize resource columns to always **fit** available width.\n         *\n         * This is ignored if *any* resources are loaded with {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @config {Boolean}\n         * @default\n         */\n        fitWidth : false,\n        /**\n         * Width for each resource column.\n         *\n         * This is used for resources which are not are loaded with a {@link Scheduler.model.ResourceModel#field-columnWidth}.\n         * @config {Number}\n         */\n        columnWidth : 150,\n        // Copied from Scheduler#resourceImagePath on creation in TimeAxisColumn.js\n        imagePath : null,\n        // Copied from Scheduler#resourceImageExtension on creation in TimeAxisColumn.js\n        imageExtension : null,\n        // Copied from Scheduler#defaultResourceImageName on creation in TimeAxisColumn.js\n        defaultImageName : null,\n        availableWidth : null\n    };\n    /**\n     * An index of the first visible resource in vertical mode\n     * @property {Number}\n     * @readonly\n     * @private\n     */\n    firstResource = -1;\n    /**\n     * An index of the last visible resource in vertical mode\n     * @property {Number}\n     * @readonly\n     * @private\n     */\n    lastResource  = -1;\n    //endregion\n    //region Init\n    construct(config) {\n        const me = this;\n        // Inject this into owning Scheduler early because code further down\n        // can call code which uses scheduler.resourceColumns.\n        config.scheduler._resourceColumns = me;\n        super.construct(config);\n        if (me.imagePath != null) {\n            // Need to increase height a bit when displaying images\n            me.element.classList.add('b-has-images');\n        }\n        EventHelper.on({\n            element     : me.element,\n            delegate    : '.b-resourceheader-cell',\n            capture     : true,\n            click       : 'onResourceMouseEvent',\n            dblclick    : 'onResourceMouseEvent',\n            contextmenu : 'onResourceMouseEvent',\n            thisObj     : me\n        });\n    }\n    changeShowAvatars(show) {\n        this.avatarRendering?.destroy();\n        if (show) {\n            this.avatarRendering = new AvatarRendering({\n                element : this.element\n            });\n        }\n        return show;\n    }\n    updateShowAvatars() {\n        if (!this.isConfiguring) {\n            this.refresh();\n        }\n    }\n    //endregion\n    //region ResourceStore\n    updateResourceStore(store) {\n        const me = this;\n        me.detachListeners('resourceStore');\n        if (store) {\n            store.ion({\n                name            : 'resourceStore',\n                changePreCommit : 'onResourceStoreDataChange',\n                thisObj         : me\n            });\n            // Already have data? Update width etc\n            if (store.count) {\n                me.onResourceStoreDataChange({});\n            }\n        }\n    }\n    // Redraw resource headers on any data change\n    onResourceStoreDataChange({ action }) {\n        const me    = this;\n        // These must be ingested before we assess the source of column widths\n        // so that they can be cleared *after* their values have been cached.\n        me.getConfig('fillWidth');\n        me.getConfig('fitWidth');\n        me.updateWidthCache();\n        const\n            {\n                element\n            }     = me,\n            width = me.totalWidth;\n        // If we have some defined columnWidths in the resourceStore\n        // we must then bypass configured fitWidth and fillWidth behaviour.\n        if (me.scheduler.variableColumnWidths) {\n            me._fillWidth = me._fitWidth = false;\n        }\n        else {\n            me._fillWidth = me.configuredFillWidth;\n            me._fitWidth = me.configuredFitWidth;\n        }\n        if (width !== me.width) {\n            DomHelper.setLength(element, 'width', width);\n            // During setup, silently set the width. It will then render correctly. After setup, let the world know...\n            me.column.set('width', width, me.column.grid.isConfiguring);\n        }\n        if (action === 'removeall') {\n            // Keep nothing\n            element.innerHTML = '';\n        }\n        if (action === 'remove' || action === 'add' || action === 'filter' || me.fitWidth || me.fillWidth) {\n            me.refreshWidths();\n        }\n        me.column.grid.toggleEmptyText();\n    }\n    get totalWidth() {\n        return this.updateWidthCache();\n    }\n    updateWidthCache() {\n        let result          = 0;\n        const { scheduler } = this;\n        // Flag so that VerticalRendering#getResourceRange knows\n        // whether to use fast or slow mode to ascertain visible columns.\n        scheduler.variableColumnWidths = false;\n        scheduler.resourceStore.forEach(resource => {\n            // Set the start position for each resource with respect to the widths\n            resource.instanceMeta(scheduler).insetStart = result;\n            resource.instanceMeta(scheduler).insetEnd   = result + (resource.columnWidth || scheduler.resourceColumnWidth);\n            if (resource.columnWidth == null) {\n                result += scheduler.resourceColumnWidth;\n            }\n            else {\n                result += resource.columnWidth;\n                scheduler.variableColumnWidths = true;\n            }\n        });\n        return result;\n    }\n    //endregion\n    //region Properties\n    changeColumnWidth(columnWidth) {\n        // Cache configured value, because if *all* resources have their own columnWidths\n        // the property will be nulled, but if we ever recieve a new resource with no\n        // columnWidth, or a columnWidth is nulled, we then have to fall back to using this.\n        if (!this.refreshingWidths) {\n            this.configuredColumnWidth = columnWidth;\n        }\n        return columnWidth;\n    }\n    updateColumnWidth(width, oldWidth) {\n        const me = this;\n        // Flag set in refreshWidths, do not want to create a loop\n        if (!me.refreshingWidths) {\n            me.refreshWidths();\n        }\n        if (!me.isConfiguring) {\n            // If resources are grouped, I need to refresh manually the cached width of resource header columns\n            if (me.resourceStore.isGrouped) {\n                me.updateWidthCache();\n            }\n            me.refresh();\n            // Cannot trigger with requested width, might have changed because of fit/fill\n            me.trigger('columnWidthChange', { width, oldWidth });\n        }\n    }\n    changeFillWidth(fillWidth) {\n        return this.configuredFillWidth = fillWidth;\n    }\n    updateFillWidth() {\n        if (!this.isConfiguring) {\n            this.refreshWidths();\n        }\n    }\n    changeFitWidth(fitWidth) {\n        return this.configuredFitWidth = fitWidth;\n    }\n    updateFitWidth() {\n        if (!this.isConfiguring) {\n            this.refreshWidths();\n        }\n    }\n    getImageURL(imageName) {\n        return StringHelper.joinPaths([this.imagePath || '', imageName || '']);\n    }\n    updateImagePath() {\n        if (!this.isConfiguring) {\n            this.refresh();\n        }\n    }\n    //endregion\n    //region Fit to width\n    updateAvailableWidth(width) {\n        this.refreshWidths();\n    }\n    // Updates the column widths according to fill and fit settings\n    refreshWidths() {\n        const\n            me    = this,\n            {\n                availableWidth,\n                configuredColumnWidth\n            }     = me,\n            count = me.resourceStore?.count;\n        // Bail out if availableWidth not yet set or resource store not assigned/loaded\n        // or column widths are defined in the resources.\n        if (!availableWidth || !count || me.scheduler.variableColumnWidths) {\n            return;\n        }\n        me.refreshingWidths = true;\n        const\n            // Fit width if configured to do so or if configured to fill and used width is less than available width\n            fit           = me.fitWidth || me.fillWidth && configuredColumnWidth * count < availableWidth,\n            useWidth      = fit ? Math.floor(availableWidth / count) : configuredColumnWidth,\n            shouldAnimate = me.column.grid.enableEventAnimations && Math.abs(me._columnWidth - useWidth) > 30;\n        DomHelper.addTemporaryClass(me.element, 'b-animating', shouldAnimate ? 300 : 0, me);\n        me.columnWidth = useWidth;\n        me.refreshingWidths = false;\n    }\n    //endregion\n    //region Rendering\n    // Visual resource range, set by VerticalRendering + its buffer\n    set visibleResources({ firstResource, lastResource }) {\n        this.firstResource = firstResource;\n        this.lastResource = lastResource;\n        this.updateWidthCache();\n        this.refresh();\n    }\n    /**\n     * Refreshes the visible headers\n     */\n    refresh() {\n        const\n            me         = this,\n            {\n                firstResource,\n                scheduler,\n                resourceStore,\n                lastResource\n            }          = me,\n            {\n                variableColumnWidths\n            }          = scheduler,\n            groupField = resourceStore.isGrouped && resourceStore.groupers[0].field,\n            configs    = [];\n        me.element.classList.toggle('b-grouped', Boolean(groupField));\n        if (!me.column.grid.isConfiguring && firstResource > -1 && lastResource > -1 && lastResource < resourceStore.count) {\n            let currentGroup;\n            // Gather element configs for resource headers in view\n            for (let i = firstResource; i <= lastResource; i++) {\n                const\n                    resourceRecord = resourceStore.allResourceRecords[i],\n                    groupRecord    = resourceRecord.groupParent?.get(resourceStore.id),\n                    groupChildren  = groupRecord?.groupChildren;\n                if (groupField && groupRecord.id !== currentGroup?.dataset.resourceId) {\n                    const\n                        groupLeft  = groupChildren[0].instanceMeta(scheduler).insetStart,\n                        groupWidth = groupChildren[groupChildren.length - 1].instanceMeta(scheduler).insetEnd - groupLeft;\n                    currentGroup = {\n                        className : 'b-resourceheader-group-cell',\n                        dataset   : {\n                            resourceId : groupRecord.id\n                        },\n                        style : {\n                            left  : groupLeft,\n                            width : groupWidth\n                        },\n                        children : [\n                            {\n                                tag  : 'span',\n                                html : StringHelper.encodeHtml(groupChildren[0][groupField])\n                            },\n                            {\n                                className : 'b-resourceheader-group-children',\n                                children  : []\n                            }\n                        ]\n                    };\n                    configs.push(currentGroup);\n                }\n                const\n                    instanceMeta  = resourceRecord.instanceMeta(scheduler),\n                    // Possible variable column width taken from the resources, fallback to scheduler's default\n                    width         = resourceRecord.columnWidth || me.columnWidth,\n                    position      = groupField ? instanceMeta.insetStart - currentGroup.style.left //groupChildren[0].instanceMeta(scheduler).insetStart\n                        : variableColumnWidths ? instanceMeta.insetStart : i * me.columnWidth,\n                    elementConfig = {\n                        // Might look like overkill to use DomClassList here, but can be used in headerRenderer\n                        className : new DomClassList({\n                            'b-resourceheader-cell' : 1\n                        }),\n                        dataset : {\n                            resourceId : resourceRecord.id\n                        },\n                        style : {\n                            [scheduler.rtl ? 'right' : 'left'] : position,\n                            width\n                        },\n                        children : []\n                    };\n                // Let a configured headerRenderer have a go at it before applying\n                if (me.headerRenderer) {\n                    const value = me.headerRenderer({ elementConfig, resourceRecord });\n                    if (value) {\n                        if (typeof value === 'string') {\n                            elementConfig.html = value;\n                        }\n                        else if (typeof value === 'object') {\n                            elementConfig.children = [value];\n                        }\n                    }\n                }\n                // No headerRenderer, apply default markup\n                else {\n                    let imageUrl;\n                    if (resourceRecord.imageUrl) {\n                        imageUrl = resourceRecord.imageUrl;\n                    }\n                    else {\n                        if (me.imagePath != null) {\n                            if (resourceRecord.image !== false) {\n                                const imageName = resourceRecord.image ||\n                                    resourceRecord.name?.toLowerCase() + me.imageExtension;\n                                imageUrl = me.getImageURL(imageName);\n                            }\n                        }\n                    }\n                    // By default showing resource name and optionally avatar\n                    elementConfig.children.push(\n                        me.showAvatars && me.avatarRendering.getResourceAvatar({\n                            resourceRecord,\n                            initials        : resourceRecord.initials,\n                            color           : resourceRecord.eventColor,\n                            iconCls         : resourceRecord.iconCls,\n                            defaultImageUrl : me.defaultImageName && me.getImageURL(me.defaultImageName),\n                            imageUrl\n                        }),\n                        {\n                            tag       : 'span',\n                            className : 'b-resource-name',\n                            html      : StringHelper.encodeHtml(resourceRecord.name)\n                        }\n                    );\n                }\n                if (groupField) {\n                    currentGroup.children[1].children.push(elementConfig);\n                }\n                else {\n                    configs.push(elementConfig);\n                }\n            }\n        }\n        // Sync changes to the header\n        DomSync.sync({\n            domConfig : {\n                onlyChildren : true,\n                children     : configs\n            },\n            targetElement : me.element,\n            syncIdField   : 'resourceId',\n            callback : ({ jsx, targetElement, domConfig }) => {\n                // Handle the React (JSX) returned from the headerRenderer\n                scheduler.processResourceHeader?.({ jsx, targetElement, domConfig });\n            }\n        });\n    }\n    //endregion\n    onResourceMouseEvent(event) {\n        const\n            resourceCell   = event.target.closest('.b-resourceheader-cell'),\n            resourceRecord = this.resourceStore.getById(resourceCell.dataset.resourceId);\n        this.trigger('resourceHeader' + StringHelper.capitalize(event.type), {\n            resourceRecord,\n            event\n        });\n    }\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs for the header, removing irrelevant ones\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n        // Assigned from Scheduler\n        delete result.resourceStore;\n        delete result.column;\n        delete result.type;\n        return result;\n    }\n}\nResourceHeader._$name = 'ResourceHeader';", "import WidgetColumn from '../../Grid/column/WidgetColumn.js';\nimport ColumnStore from '../../Grid/data/ColumnStore.js';\nimport Events from '../../Core/mixin/Events.js';\nimport HorizontalTimeAxis from '../view/HorizontalTimeAxis.js';\nimport ResourceHeader from '../view/ResourceHeader.js';\n/**\n * @module Scheduler/column/TimeAxisColumn\n */\n/**\n * A column containing the timeline \"viewport\", in which events, dependencies etc. are drawn.\n * Normally you do not need to interact with or create this column, it is handled by Scheduler.\n *\n * If you wish to output custom contents inside the time axis row cells, you can provide your custom column configuration\n * using the {@link #config-renderer} like so:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *    appendTo         : document.body\n *    columns          : [\n *       { text : 'Name', field : 'name', width : 130 },\n *       {\n *           type : 'timeAxis',\n *           renderer({ record, cellElement }) {\n *               return '<div class=\"cool-chart\"></div>';\n *           }\n *       }\n *    ]\n * });\n * ```\n *\n * @extends Grid/column/WidgetColumn\n * @column\n */\nexport default class TimeAxisColumn extends Events(WidgetColumn) {\n    //region Config\n    headerHoverable = false;\n    static $name = 'TimeAxisColumn';\n    static get fields() {\n        return [\n            // Exclude some irrelevant fields from getCurrentConfig()\n            { name : 'locked', persist : false },\n            { name : 'flex', persist : false },\n            { name : 'width', persist : false },\n            { name : 'cellCls', persist : false },\n            { name : 'field', persist : false },\n            'mode'\n        ];\n    }\n    static get defaults() {\n        return {\n            /**\n             * Set to false to prevent this column header from being dragged.\n             * @config {Boolean} draggable\n             * @category Interaction\n             * @default false\n             */\n            draggable : false,\n            /**\n             * Set to false to prevent grouping by this column.\n             * @config {Boolean} groupable\n             * @category Interaction\n             * @default false\n             */\n            groupable : false,\n            /**\n             * Allow column visibility to be toggled through UI.\n             * @config {Boolean} hideable\n             * @default false\n             * @category Interaction\n             */\n            hideable : false,\n            /**\n             * Show column picker for the column.\n             * @config {Boolean} showColumnPicker\n             * @default false\n             * @category Menu\n             */\n            showColumnPicker : false,\n            /**\n             * Allow filtering data in the column (if Filter feature is enabled)\n             * @config {Boolean} filterable\n             * @default false\n             * @category Interaction\n             */\n            filterable : false,\n            /**\n             * Allow sorting of data in the column\n             * @config {Boolean} sortable\n             * @category Interaction\n             * @default false\n             */\n            sortable : false,\n            /**\n             * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.\n             * @config {Boolean} resizable\n             * @default false\n             * @category Interaction\n             */\n            resizable : false,\n            /**\n             * Allow searching in the column (respected by QuickFind and Search features)\n             * @config {Boolean} searchable\n             * @default false\n             * @category Interaction\n             */\n            searchable : false,\n            /**\n             * @config {String} editor\n             * @hide\n             */\n            editor : false,\n            /**\n             * Set to `true` to show a context menu on the cell elements in this column\n             * @config {Boolean} enableCellContextMenu\n             * @default false\n             * @category Menu\n             */\n            enableCellContextMenu : false,\n            /**\n             * @config {Function|Boolean} tooltipRenderer\n             * @hide\n             */\n            tooltipRenderer : false,\n            /**\n             * CSS class added to the header of this column\n             * @config {String} cls\n             * @category Rendering\n             * @default 'b-sch-timeaxiscolumn'\n             */\n            cls : 'b-sch-timeaxiscolumn',\n            // needs to have width specified, flex-basis messes measurements up\n            needWidth : true,\n            mode       : null,\n            region     : 'normal',\n            exportable : false,\n            htmlEncode : false\n        };\n    }\n    static get type() {\n        return 'timeAxis';\n    }\n    //region Init\n    construct(config) {\n        const me = this;\n        super.construct(...arguments);\n        me.thisObj = me;\n        // Inject the reference to this column as early as possible\n        me.grid._timeAxisColumn = me;\n        me.timeAxisViewModel = me.grid.timeAxisViewModel;\n        // A bit hacky, because mode is a field and not a config\n        // eslint-disable-next-line no-self-assign\n        me.mode = me.mode;\n        me.grid.ion({\n            paint   : 'onTimelinePaint',\n            thisObj : me,\n            once    : true\n        });\n    }\n    static get autoExposeFields() {\n        return true;\n    }\n    // endregion\n    doDestroy() {\n        this.resourceColumns?.destroy();\n        this.timeAxisView?.destroy();\n        super.doDestroy();\n    }\n    set mode(mode) {\n        const\n            me       = this,\n            { grid } = me;\n        me.set('mode', mode);\n        // In horizontal mode this column has a time axis header on top, with timeline ticks\n        if (mode === 'horizontal') {\n            me.timeAxisView = new HorizontalTimeAxis({\n                model                     : me.timeAxisViewModel,\n                compactCellWidthThreshold : me.compactCellWidthThreshold,\n                owner                     : grid,\n                client                    : grid\n            });\n        }\n        // In vertical mode, it instead displays resources at top\n        else if (mode === 'vertical') {\n            me.resourceColumns = ResourceHeader.new({\n                column           : me,\n                scheduler        : grid,\n                resourceStore    : grid.resourceStore,\n                imagePath        : grid.resourceImagePath,\n                imageExtension   : grid.resourceImageExtension,\n                defaultImageName : grid.defaultResourceImageName\n            }, grid.resourceColumns || {});\n            me.relayEvents(me.resourceColumns, [\n                'resourceheaderclick',\n                'resourceheaderdblclick',\n                'resourceheadercontextmenu'\n            ]);\n        }\n    }\n    get mode() {\n        return this.get('mode');\n    }\n    //region Events\n    onViewModelUpdate({ source : viewModel }) {\n        const me = this;\n        if (me.grid.timeAxisSubGrid.collapsed) {\n            return;\n        }\n        if (me.mode === 'horizontal') {\n            // render the time axis view into the column header element\n            me.refreshHeader(true);\n            me.width = viewModel.totalSize;\n            me.grid.refresh();\n            // When width is set above, that ends up on a columnsResized listener, but the refreshing of the fake\n            // scrollers to accommodate the new width is not done in this timeframe, so the upcoming centering related\n            // to preset change cannot work. So we have to refresh the fake scrollers now\n            me.subGrid.refreshFakeScroll();\n        }\n        else if (me.mode === 'vertical') {\n            // Refresh to rerender cells, in the process updating the vertical timeaxis to reflect view model changes\n            me.grid.refreshRows();\n        }\n    }\n    // Called on paint. SubGrid has its width so this is the earliest time to configure the TimeAxisViewModel with\n    // correct width\n    onTimelinePaint({ firstPaint }) {\n        const me = this;\n        if (!me.subGrid.insertRowsBefore) {\n            return;\n        }\n        if (firstPaint) {\n            me.subGridElement.classList.add('b-timeline-subgrid');\n            if (me.mode === 'vertical') {\n                me.refreshHeader();\n                // The above operation can cause height change.\n                me.grid?.onHeightChange();\n            }\n        }\n    }\n    //endregion\n    //region Rendering\n    /**\n     * Refreshes the columns header contents (which is either a HorizontalTimeAxis or a ResourceHeader). Useful if you\n     * have rendered some extra meta data that depends on external data such as the EventStore or ResourceStore.\n     */\n    refreshHeader(internal) {\n        const\n            me          = this,\n            { element } = me;\n        if (element) {\n            if (me.mode === 'horizontal') {\n                // Force timeAxisViewModel to regenerate its column config, which calls header renderers etc.\n                !internal && me.timeAxisViewModel.update(undefined, undefined, true);\n                if (!me.timeAxisView.rendered) {\n                    // Do not need the normal header markup\n                    element.innerHTML = '';\n                    me.timeAxisView.render(element);\n                }\n                else {\n                    // Force rebuild of cells in case external data has changed (cheap since it still syncs to DOM)\n                    me.timeAxisView.refresh(true);\n                }\n            }\n            else if (me.mode === 'vertical') {\n                if (!me.resourceColumns.currentElement) {\n                    // Do not need the normal header markup\n                    element.innerHTML = '';\n                    me.resourceColumns.render(element);\n                }\n                else {\n                    me.resourceColumns.refresh();\n                }\n                // Vertical's resourceColumns is redrawn with the events, no need here\n            }\n        }\n    }\n    internalRenderer(renderData) {\n        const { grid } = this;\n        // No drawing of events before engines initial commit\n        if (grid.project.isInitialCommitPerformed || grid.project.isDelayingCalculation) {\n            grid.currentOrientation.renderer(renderData);\n            return super.internalRenderer(renderData);\n        }\n        return '';\n    }\n    //endregion\n    get timeAxisViewModel() {\n        return this._timeAxisViewModel;\n    }\n    set timeAxisViewModel(timeAxisViewModel) {\n        const me = this;\n        me.detachListeners('tavm');\n        timeAxisViewModel?.ion({\n            name    : 'tavm',\n            update  : 'onViewModelUpdate',\n            prio    : -10000,\n            thisObj : me\n        });\n        me._timeAxisViewModel = timeAxisViewModel;\n        if (me.timeAxisView) {\n            me.timeAxisView.model = timeAxisViewModel;\n        }\n    }\n    // Width of the time axis column is solely determined by the zoom level. We should not keep it part of the state\n    // otherwise restoring the state might break the normal zooming process.\n    // Covered by SchedulerState.t\n    // https://github.com/bryntum/support/issues/5545\n    getState() {\n        const state = super.getState();\n        delete state.width;\n        delete state.flex;\n        return state;\n    }\n}\nColumnStore.registerColumnType(TimeAxisColumn);\nTimeAxisColumn._$name = 'TimeAxisColumn';", "import TimeAxisBase from './TimeAxisBase.js';\n/**\n * @module Scheduler/view/VerticalTimeAxis\n */\n/**\n * Widget that renders a vertical time axis. Only renders ticks in view. Used in vertical mode.\n * @extends Core/widget/Widget\n * @private\n */\nexport default class VerticalTimeAxis extends TimeAxisBase {\n    static get $name() {\n        return 'VerticalTimeAxis';\n    }\n    static get configurable() {\n        return {\n            cls : 'b-verticaltimeaxis',\n            sizeProperty : 'height',\n            positionProperty : 'top',\n            wrapText : true\n        };\n    }\n    // All cells overlayed in the same space.\n    // For future use.\n    buildHorizontalCells() {\n        const\n            me                   = this,\n            { client }           = me,\n            stickyHeaders        = client?.stickyHeaders,\n            featureHeaderConfigs = [],\n            cellConfigs          = me.levels.reduce((result, level, i) => {\n                if (level.cells) {\n                    result.push(...level.cells?.filter(cell => cell.start < me.endDate && cell.end > me.startDate).map((cell, j, cells) => ({\n                        role      : 'presentation',\n                        className : {\n                            'b-sch-header-timeaxis-cell' : 1,\n                            [cell.headerCellCls]         : cell.headerCellCls,\n                            [`b-align-${cell.align}`]    : cell.align,\n                            'b-last'                     : j === cells.length - 1,\n                            'b-lowest'                   : i === me.levels.length - 1\n                        },\n                        dataset : {\n                            tickIndex      : cell.index,\n                            cellId         : `${i}-${cell.index}`,\n                            headerPosition : i,\n                            // Used in export tests to resolve dates from tick elements\n                            ...globalThis.DEBUG && { date : cell.start.getTime() }\n                        },\n                        style : {\n                            // DomHelper appends px to numeric dimensions\n                            top       : cell.coord,\n                            height    : cell.width,\n                            minHeight : cell.width\n                        },\n                        children : [\n                            {\n                                role      : 'presentation',\n                                className : {\n                                    'b-sch-header-text' : 1,\n                                    'b-sticky-header'   : stickyHeaders\n                                },\n                                html : cell.value\n                            }\n                        ]\n                    })));\n                }\n                return result;\n            }, []);\n        // When tested in isolation there is no client\n        client?.getHeaderDomConfigs(featureHeaderConfigs);\n        cellConfigs.push(...featureHeaderConfigs);\n        // noinspection JSSuspiciousNameCombination\n        return {\n            className : me.widgetClassList,\n            dataset   : {\n                headerFeature  : `headerRow0`,\n                headerPosition : 0\n            },\n            syncOptions : {\n                // Keep a maximum of 5 released cells. Might be fine with fewer since ticks are fixed width.\n                // Prevents an unnecessary amount of cells from sticking around when switching from narrow to\n                // wide tickSizes\n                releaseThreshold : 5,\n                syncIdField      : 'cellId'\n            },\n            children : cellConfigs\n        };\n    }\n    get height() {\n        return this.size;\n    }\n}\nVerticalTimeAxis._$name = 'VerticalTimeAxis';", "import Column from '../../Grid/column/Column.js';\nimport ColumnStore from '../../Grid/data/ColumnStore.js';\nimport VerticalTimeAxis from '../view/VerticalTimeAxis.js';\n/**\n * @module Scheduler/column/VerticalTimeAxisColumn\n */\n/**\n * A special column containing the time axis labels when the Scheduler is used in vertical mode. You can configure,\n * it using the {@link Scheduler.view.Scheduler#config-verticalTimeAxisColumn} config object.\n *\n * **Note**: this column is sized by flexing to consume full width of its containing {@link Grid.view.SubGrid}. To\n * change width of this column, instead size the subgrid like so:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     mode           : 'vertical',\n *     subGridConfigs : {\n *         locked : {\n *             width : 300\n *         }\n *     }\n * });\n * ```\n *\n * @extends Grid/column/Column\n */\nexport default class VerticalTimeAxisColumn extends Column {\n    static $name = 'VerticalTimeAxisColumn';\n    static get type() {\n        return 'verticalTimeAxis';\n    }\n    static get defaults() {\n        return {\n            /**\n             * @hideconfigs autoWidth, autoHeight\n             */\n            /**\n             * Set to false to prevent this column header from being dragged.\n             * @config {Boolean} draggable\n             * @category Interaction\n             * @default false\n             * @hide\n             */\n            draggable : false,\n            /**\n             * Set to false to prevent grouping by this column.\n             * @config {Boolean} groupable\n             * @category Interaction\n             * @default false\n             * @hide\n             */\n            groupable : false,\n            /**\n             * Allow column visibility to be toggled through UI.\n             * @config {Boolean} hideable\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            hideable : false,\n            /**\n             * Show column picker for the column.\n             * @config {Boolean} showColumnPicker\n             * @default false\n             * @category Menu\n             * @hide\n             */\n            showColumnPicker : false,\n            /**\n             * Allow filtering data in the column (if Filter feature is enabled)\n             * @config {Boolean} filterable\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            filterable : false,\n            /**\n             * Allow sorting of data in the column\n             * @config {Boolean} sortable\n             * @category Interaction\n             * @default false\n             * @hide\n             */\n            sortable : false,\n            // /**\n            //  * Set to `false` to prevent the column from being drag-resized when the ColumnResize plugin is enabled.\n            //  * @config {Boolean} resizable\n            //  * @default false\n            //  * @category Interaction\n            //  * @hide\n            //  */\n            // resizable : false,\n            /**\n             * Allow searching in the column (respected by QuickFind and Search features)\n             * @config {Boolean} searchable\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            searchable : false,\n            /**\n             * Specifies if this column should be editable, and define which editor to use for editing cells in the column (if CellEdit feature is enabled)\n             * @config {String} editor\n             * @default false\n             * @category Interaction\n             * @hide\n             */\n            editor : false,\n            /**\n             * Set to `true` to show a context menu on the cell elements in this column\n             * @config {Boolean} enableCellContextMenu\n             * @default false\n             * @category Menu\n             * @hide\n             */\n            enableCellContextMenu : false,\n            /**\n             * @config {Function|Boolean} tooltipRenderer\n             * @hide\n             */\n            tooltipRenderer : false,\n            /**\n             * Column minimal width. If value is Number then minimal width is in pixels\n             * @config {Number|String} minWidth\n             * @default 0\n             * @category Layout\n             */\n            minWidth : 0,\n            resizable : false,\n            cellCls : 'b-verticaltimeaxiscolumn',\n            locked  : true,\n            flex : 1,\n            alwaysClearCell : false\n        };\n    }\n    get isFocusable() {\n        return false;\n    }\n    construct(data) {\n        super.construct(...arguments);\n        this.view = new VerticalTimeAxis({\n            model  : this.grid.timeAxisViewModel,\n            client : this.grid\n        });\n    }\n    renderer({ cellElement, size }) {\n        this.view.render(cellElement);\n        size.height = this.view.height;\n    }\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs (fields) for the column, removing irrelevant ones\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n        // Remove irrelevant configs\n        delete result.id;\n        delete result.region;\n        delete result.type;\n        delete result.field;\n        delete result.ariaLabel;\n        delete result.cellAriaLabel;\n        return result;\n    }\n}\nColumnStore.registerColumnType(VerticalTimeAxisColumn);\nVerticalTimeAxisColumn._$name = 'VerticalTimeAxisColumn';", "/**\n * @module Scheduler/view/mixin/CurrentConfig\n */\nconst\n    stores = [\n        'eventStore',\n        'taskStore',\n        'assignmentStore',\n        'resourceStore',\n        'dependencyStore',\n        'timeRangeStore',\n        'resourceTimeRangeStore'\n    ],\n    inlineProperties = [\n        'events',\n        'tasks',\n        'resources',\n        'assignments',\n        'dependencies',\n        'timeRanges',\n        'resourceTimeRanges'\n    ];\n/**\n * Mixin that makes sure inline data & crud manager data are removed from current config for products using a project.\n * The data is instead inlined in the project (by ProjectModel.js)\n *\n * @mixin\n * @private\n */\nexport default Target => class CurrentConfig extends Target {\n    static get $name() {\n        return 'CurrentConfig';\n    }\n    preProcessCurrentConfigs(configs) {\n        // Remove inline data on the component\n        for (const prop of inlineProperties) {\n            delete configs[prop];\n        }\n        super.preProcessCurrentConfigs(configs);\n    }\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    getCurrentConfig(options) {\n        const\n            project = this.project.getCurrentConfig(options),\n            result = super.getCurrentConfig(options);\n        // Force project with inline data\n        if (project) {\n            result.project = project;\n            const { crudManager } = result;\n            // Transfer crud store configs to project (mainly fields)\n            if (crudManager) {\n                for (const store of stores) {\n                    if (crudManager[store]) {\n                        project[store] = crudManager[store];\n                    }\n                }\n            }\n            if (Object.keys(project).length === 0) {\n                delete result.project;\n            }\n        }\n        // Store (resource store) data is included in project\n        delete result.data;\n        // Remove CrudManager, since data will be placed inline\n        delete result.crudManager;\n        return result;\n    }\n    get widgetClass() {}\n};\n", "import TimelineBase from './TimelineBase.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport CrudManager from '../data/CrudManager.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport '../localization/En.js';\nimport CurrentConfig from './mixin/CurrentConfig.js';\nimport Describable from './mixin/Describable.js';\nimport SchedulerDom from './mixin/SchedulerDom.js';\nimport SchedulerDomEvents from './mixin/SchedulerDomEvents.js';\nimport SchedulerEventRendering from './mixin/SchedulerEventRendering.js';\nimport SchedulerStores from './mixin/SchedulerStores.js';\nimport SchedulerScroll from './mixin/SchedulerScroll.js';\nimport SchedulerRegions from './mixin/SchedulerRegions.js';\nimport SchedulerState from './mixin/SchedulerState.js';\nimport EventSelection from './mixin/EventSelection.js';\nimport EventNavigation from './mixin/EventNavigation.js';\nimport TransactionalFeatureMixin from './mixin/TransactionalFeatureMixin.js';\nimport CrudManagerView from '../crud/mixin/CrudManagerView.js';\nimport HorizontalRendering from './orientation/HorizontalRendering.js';\nimport VerticalRendering from './orientation/VerticalRendering.js';\nimport '../column/TimeAxisColumn.js';\nimport '../column/VerticalTimeAxisColumn.js';\n// Should always be present in Scheduler\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\n/**\n * @module Scheduler/view/SchedulerBase\n */\nconst\n    descriptionFormats = {\n        month : 'MMMM, YYYY',\n        week  : ['MMMM YYYY (Wp)', 'S{MMM} - E{MMM YYYY} (S{Wp})'],\n        day   : 'MMMM D, YYYY'\n    };\n/**\n * A thin base class for {@link Scheduler.view.Scheduler}. Does not include any features by default, allowing smaller\n * custom-built bundles if used in place of {@link Scheduler.view.Scheduler}.\n *\n * **NOTE:** In most scenarios you do probably want to use Scheduler instead of SchedulerBase.\n *\n * @mixes Scheduler/view/mixin/Describable\n * @mixes Scheduler/view/mixin/EventNavigation\n * @mixes Scheduler/view/mixin/EventSelection\n * @mixes Scheduler/view/mixin/SchedulerDom\n * @mixes Scheduler/view/mixin/SchedulerDomEvents\n * @mixes Scheduler/view/mixin/SchedulerEventRendering\n * @mixes Scheduler/view/mixin/SchedulerRegions\n * @mixes Scheduler/view/mixin/SchedulerScroll\n * @mixes Scheduler/view/mixin/SchedulerState\n * @mixes Scheduler/view/mixin/SchedulerStores\n * @mixes Scheduler/view/mixin/TimelineDateMapper\n * @mixes Scheduler/view/mixin/TimelineDomEvents\n * @mixes Scheduler/view/mixin/TimelineEventRendering\n * @mixes Scheduler/view/mixin/TimelineScroll\n * @mixes Scheduler/view/mixin/TimelineViewPresets\n * @mixes Scheduler/view/mixin/TimelineZoomable\n * @mixes Scheduler/view/mixin/TransactionalFeatureMixin\n * @mixes Scheduler/crud/mixin/CrudManagerView\n * @mixes Scheduler/data/mixin/ProjectConsumer\n *\n * @features Scheduler/feature/ColumnLines\n * @features Scheduler/feature/Dependencies\n * @features Scheduler/feature/DependencyEdit\n * @features Scheduler/feature/EventCopyPaste\n * @features Scheduler/feature/EventDrag\n * @features Scheduler/feature/EventDragCreate\n * @features Scheduler/feature/EventDragSelect\n * @features Scheduler/feature/EventEdit\n * @features Scheduler/feature/EventFilter\n * @features Scheduler/feature/EventMenu\n * @features Scheduler/feature/EventNonWorkingTime\n * @features Scheduler/feature/EventResize\n * @features Scheduler/feature/EventTooltip\n * @features Scheduler/feature/GroupSummary\n * @features Scheduler/feature/HeaderZoom\n * @features Scheduler/feature/Labels\n * @features Scheduler/feature/NonWorkingTime\n * @features Scheduler/feature/Pan\n * @features Scheduler/feature/ResourceMenu\n * @features Scheduler/feature/ResourceTimeRanges\n * @features Scheduler/feature/RowReorder\n * @features Scheduler/feature/RowResize\n * @features Scheduler/feature/ScheduleContext\n * @features Scheduler/feature/ScheduleMenu\n * @features Scheduler/feature/ScheduleTooltip\n * @features Scheduler/feature/SimpleEventEdit\n * @features Scheduler/feature/Split\n * @features Scheduler/feature/StickyEvents\n * @features Scheduler/feature/Summary\n * @features Scheduler/feature/TimeAxisHeaderMenu\n * @features Scheduler/feature/TimeRanges\n * @features Scheduler/feature/TimeSelection\n *\n * @features Scheduler/feature/experimental/ExcelExporter\n *\n * @features Scheduler/feature/export/PdfExport\n * @features Scheduler/feature/export/Print\n *\n * @extends Scheduler/view/TimelineBase\n * @widget\n */\nexport default class SchedulerBase extends TimelineBase.mixin(\n    CrudManagerView,\n    Describable,\n    SchedulerDom,\n    SchedulerDomEvents,\n    SchedulerStores,\n    SchedulerScroll,\n    SchedulerState,\n    SchedulerEventRendering,\n    SchedulerRegions,\n    EventSelection,\n    EventNavigation,\n    CurrentConfig,\n    TransactionalFeatureMixin\n) {\n    //region Config\n    static $name = 'SchedulerBase';\n    // Factoryable type name\n    static type = 'schedulerbase';\n    static configurable = {\n        /**\n         * Get/set the scheduler's read-only state. When set to `true`, any UIs for modifying data are disabled.\n         * @member {Boolean} readOnly\n         * @category Misc\n         */\n        /**\n         * Configure as `true` to make the scheduler read-only, by disabling any UIs for modifying data.\n         *\n         * __Note that checks MUST always also be applied at the server side.__\n         * @config {Boolean} readOnly\n         * @default false\n         * @category Misc\n         */\n        /**\n         * The date to display when used as a component of a Calendar.\n         *\n         * This is required by the Calendar Mode Interface.\n         *\n         * @config {Date}\n         * @category Calendar integration\n         */\n        date : {\n            value : null,\n            $config : {\n                equal : 'date'\n            }\n        },\n        /**\n         * Unit used to control how large steps to take when clicking the previous and next buttons in the Calendar\n         * UI. Only applies when used as a component of a Calendar.\n         *\n         * Suitable units depend on configured {@link #config-range}, a smaller or equal unit is recommended.\n         *\n         * @config {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}\n         * @default\n         * @category Calendar integration\n         */\n        stepUnit : 'week',\n        /**\n         * Unit used to set the length of the time axis when used as a component of a Calendar. Suitable units are\n         * `'month'`, `'week'` and `'day'`.\n         *\n         * @config {'day'|'week'|'month'}\n         * @category Calendar integration\n         * @default\n         */\n        range : 'week',\n        /**\n         * When the scheduler is used in a Calendar, this function provides the textual description for the\n         * Calendar's toolbar.\n         *\n         * ```javascript\n         *  descriptionRenderer : scheduler => {\n         *      const\n         *          count = scheduler.eventStore.records.filter(\n         *              eventRec => DateHelper.intersectSpans(\n         *                  scheduler.startDate, scheduler.endDate,\n         *                  eventRec.startDate, eventRec.endDate)).length,\n         *          startDate = DateHelper.format(scheduler.startDate, 'DD/MM/YYY'),\n         *          endData = DateHelper.format(scheduler.endDate, 'DD/MM/YYY');\n         *\n         *      return `${startDate} - ${endData}, ${count} event${count === 1 ? '' : 's'}`;\n         *  }\n         * ```\n         * @config {Function}\n         * @param {Scheduler.view.SchedulerBase} view The active view.\n         * @returns {String}\n         * @category Calendar integration\n         */\n        /**\n         * A method allowing you to define date boundaries that will constrain resize, create and drag drop\n         * operations. The method will be called with the Resource record, and the Event record.\n         *\n         * ```javascript\n         *  new Scheduler({\n         *      getDateConstraints(resourceRecord, eventRecord) {\n         *          // Assuming you have added these extra fields to your own EventModel subclass\n         *          const { minStartDate, maxEndDate } = eventRecord;\n         *\n         *          return {\n         *              start : minStartDate,\n         *              end   : maxEndDate\n         *          };\n         *      }\n         *  });\n         * ```\n         * @param {Scheduler.model.ResourceModel} [resourceRecord] The resource record\n         * @param {Scheduler.model.EventModel} [eventRecord] The event record\n         * @returns {Object} Constraining object containing `start` and `end` constraints. Omitting either\n         * will mean that end is not constrained. So you can prevent a resize or move from moving *before*\n         * a certain time while not constraining the end date.\n         * @returns {Date} [return.start] Start date\n         * @returns {Date} [return.end] End date\n         * @config {Function}\n         * @category Scheduled events\n         */\n        getDateConstraints : null,\n        /**\n         * The time axis column config for vertical {@link Scheduler.view.SchedulerBase#config-mode}.\n         *\n         * Object with {@link Scheduler.column.VerticalTimeAxisColumn} configuration.\n         *\n         * This object will be used to configure the vertical time axis column instance.\n         *\n         * The config allows configuring the `VerticalTimeAxisColumn` instance used in vertical mode with any Column options that apply to it.\n         *\n         * Example:\n         *\n         * ```javascript\n         * new Scheduler({\n         *     mode     : 'vertical',\n         *     features : {\n         *         filterBar : true\n         *     },\n         *     verticalTimeAxisColumn : {\n         *         text  : 'Filter by event name',\n         *         width : 180,\n         *         filterable : {\n         *             // add a filter field to the vertical column access header\n         *             filterField : {\n         *                 type        : 'text',\n         *                 placeholder : 'Type to search',\n         *                 onChange    : ({ value }) => {\n         *                     // filter event by name converting to lowerCase to be equal comparison\n         *                     scheduler.eventStore.filter({\n         *                         filters : event => event.name.toLowerCase().includes(value.toLowerCase()),\n         *                         replace : true\n         *                     });\n         *                 }\n         *             }\n         *         }\n         *     },\n         *     ...\n         * });\n         * ```\n         *\n         * @config {VerticalTimeAxisColumnConfig}\n         * @category Time axis\n         */\n        verticalTimeAxisColumn : {},\n        /**\n         * See {@link Scheduler.view.Scheduler#keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>} keyMap\n         * @category Common\n         */\n        /**\n         * If true, a new event will be created when user double-clicks on a time axis cell (if scheduler is not in\n         * read only mode).\n         *\n         * The duration / durationUnit of the new event will be 1 time axis tick (default), or it can be read from\n         * the {@link Scheduler.model.EventModel#field-duration} and\n         * {@link Scheduler.model.EventModel#field-durationUnit} fields.\n         *\n         * Set to `false` to not create events on double click.\n         * @config {Boolean|Object} createEventOnDblClick\n         * @param {Boolean} [createEventOnDblClick.useEventModelDefaults] set to `true` to set default duration\n         * based on the defaults specified by the {@link Scheduler.model.EventModel#field-duration} and\n         * {@link Scheduler.model.EventModel#field-durationUnit} fields.\n         * @default\n         * @category Scheduled events\n         */\n        createEventOnDblClick : true,\n        /**\n             * Number of pixels to horizontally extend the visible render zone by, controlling the events that will be\n             * rendered. You can use this to increase or reduce the amount of event rendering happening when scrolling\n             * along a horizontal time axis. This can be useful if you render huge amount of events.\n             *\n             * To force the scheduler to render all events within the TimeAxis start & end dates, set this to -1.\n             * The initial render will take slightly longer but no extra event rendering will take place when scrolling.\n             *\n             * NOTE: This is an experimental API which might change in future releases.\n             * @config {Number}\n             * @default\n             * @internal\n             * @category Experimental\n             */\n        scrollBuffer : 0,\n        // A CSS class identifying areas where events can be scheduled using drag-create, double click etc.\n        schedulableAreaSelector : '.b-sch-timeaxis-cell',\n        scheduledEventName      : 'event',\n        sortFeatureStore        : 'resourceStore',\n        /**\n         * If set to `true` this will show a color field in the {@link Scheduler.feature.EventEdit} editor and also a\n         * picker in the {@link Scheduler.feature.EventMenu}. Both enables the user to choose a color which will be\n         * applied to the event bar's background. See EventModel's\n         * {@link Scheduler.model.mixin.EventModelMixin#field-eventColor} config.\n         * config.\n         * @config {Boolean}\n         * @default false\n         * @category Misc\n         */\n        showEventColorPickers : null,\n        /**\n         * By default, scrolling the schedule will update the {@link #property-timelineContext} to reflect the new\n         * currently hovered context. When displaying a large number of events on screen at the same time, this will\n         * have a slight impact on scrolling performance. In such scenarios, opt out of this behavior by setting\n         * this config to `false`.\n         * @default\n         * @prp {Boolean}\n         * @category Misc\n         */\n        updateTimelineContextOnScroll : true\n    };\n    static get defaultConfig() {\n        return {\n            /**\n             * Scheduler mode. Supported values: horizontal, vertical\n             * @config {'horizontal'|'vertical'} mode\n             * @default\n             * @category Common\n             */\n            mode : 'horizontal',\n            /**\n             * CSS class to add to rendered events\n             * @config {String}\n             * @category CSS\n             * @private\n             * @default\n             */\n            eventCls : 'b-sch-event',\n            /**\n             * CSS class to add to cells in the timeaxis column\n             * @config {String}\n             * @category CSS\n             * @private\n             * @default\n             */\n            timeCellCls : 'b-sch-timeaxis-cell',\n            /**\n             * A CSS class to apply to each event in the view on mouseover (defaults to 'b-sch-event-hover').\n             * @config {String}\n             * @default\n             * @category CSS\n             * @private\n             */\n            overScheduledEventClass : 'b-sch-event-hover',\n            /**\n             * Set to `false` if you don't want to allow events overlapping times for any one resource (defaults to `true`).\n             * <div class=\"note\">Note that toggling this at runtime won't affect already overlapping events.</div>\n             *\n             * @prp {Boolean}\n             * @default\n             * @category Scheduled events\n             */\n            allowOverlap : true,\n            /**\n             * The height in pixels of Scheduler rows.\n             * @config {Number}\n             * @default\n             * @category Common\n             */\n            rowHeight : 60,\n            /**\n             * Scheduler overrides Grids default implementation of {@link Grid.view.GridBase#config-getRowHeight} to\n             * pre-calculate row heights based on events in the rows.\n             *\n             * The amount of rows that are pre-calculated is limited for performance reasons. The limit is configurable\n             * by specifying the {@link Scheduler.view.SchedulerBase#config-preCalculateHeightLimit} config.\n             *\n             * The results of the calculation are cached internally.\n             *\n             * @config {Function} getRowHeight\n             * @param {Scheduler.model.ResourceModel} getRowHeight.record Resource record to determine row height for\n             * @returns {Number} Desired row height\n             * @category Layout\n             */\n            /**\n             * Maximum number of resources for which height is pre-calculated. If you have many events per\n             * resource you might want to lower this number to gain some initial rendering performance.\n             *\n             * Specify a falsy value to opt out of row height pre-calculation.\n             *\n             * @config {Number}\n             * @default\n             * @category Layout\n             */\n            preCalculateHeightLimit : 10000,\n            crudManagerClass : CrudManager,\n            testConfig : {\n                loadMaskError : {\n                    autoClose : 10,\n                    showDelay : 0\n                }\n            }\n        };\n    }\n    timeCellSelector          = '.b-sch-timeaxis-cell';\n    resourceTimeRangeSelector = '.b-sch-resourcetimerange';\n    //endregion\n    //region Store & model docs\n    // Documented here instead of in SchedulerStores since SchedulerPro uses different types\n    // Configs\n    /**\n     * Inline events, will be loaded into an internally created EventStore.\n     * @config {Scheduler.model.EventModel[]|Scheduler.model.EventModelConfig[]} events\n     * @category Data\n     */\n    /**\n     * The {@link Scheduler.data.EventStore} holding the events to be rendered into the scheduler (required).\n     * @config {Scheduler.data.EventStore|Scheduler.data.EventStoreConfig} eventStore\n     * @category Data\n     */\n    /**\n     * Inline resources, will be loaded into an internally created ResourceStore.\n     * @config {Scheduler.model.ResourceModel[]|Scheduler.model.ResourceModelConfig[]} resources\n     * @category Data\n     */\n    /**\n     * The {@link Scheduler.data.ResourceStore} holding the resources to be rendered into the scheduler (required).\n     * @config {Scheduler.data.ResourceStore|Scheduler.data.ResourceStoreConfig} resourceStore\n     * @category Data\n     */\n    /**\n     * Inline assignments, will be loaded into an internally created AssignmentStore.\n     * @config {Scheduler.model.AssignmentModel[]|Object[]} assignments\n     * @category Data\n     */\n    /**\n     * The optional {@link Scheduler.data.AssignmentStore}, holding assignments between resources and events.\n     * Required for multi assignments.\n     * @config {Scheduler.data.AssignmentStore|Scheduler.data.AssignmentStoreConfig} assignmentStore\n     * @category Data\n     */\n    /**\n     * Inline dependencies, will be loaded into an internally created DependencyStore.\n     * @config {Scheduler.model.DependencyModel[]|Scheduler.model.DependencyModelConfig[]} dependencies\n     * @category Data\n     */\n    /**\n     * The optional {@link Scheduler.data.DependencyStore}.\n     * @config {Scheduler.data.DependencyStore|Scheduler.model.DependencyStoreConfig} dependencyStore\n     * @category Data\n     */\n    // Properties\n    /**\n     * Get/set events, applies to the backing project's EventStore.\n     * @member {Scheduler.model.EventModel[]} events\n     * @accepts {Scheduler.model.EventModel[]|Scheduler.model.EventModelConfig[]}\n     * @category Data\n     */\n    /**\n     * Get/set the event store instance of the backing project.\n     * @member {Scheduler.data.EventStore} eventStore\n     * @category Data\n     */\n    /**\n     * Get/set resources, applies to the backing project's ResourceStore.\n     * @member {Scheduler.model.ResourceModel[]} resources\n     * @accepts {Scheduler.model.ResourceModel[]|Scheduler.model.ResourceModelConfig[]}\n     * @category Data\n     */\n    /**\n     * Get/set the resource store instance of the backing project\n     * @member {Scheduler.data.ResourceStore} resourceStore\n     * @category Data\n     */\n    /**\n     * Get/set assignments, applies to the backing project's AssignmentStore.\n     * @member {Scheduler.model.AssignmentModel[]} assignments\n     * @accepts {Scheduler.model.AssignmentModel[]|Object[]}\n     * @category Data\n     */\n    /**\n     * Get/set the event store instance of the backing project.\n     * @member {Scheduler.data.AssignmentStore} assignmentStore\n     * @category Data\n     */\n    /**\n     * Get/set dependencies, applies to the backing projects DependencyStore.\n     * @member {Scheduler.model.DependencyModel[]} dependencies\n     * @accepts {Scheduler.model.DependencyModel[]|Scheduler.model.DependencyModelConfig[]}\n     * @category Data\n     */\n    /**\n     * Get/set the dependencies store instance of the backing project.\n     * @member {Scheduler.data.DependencyStore} dependencyStore\n     * @category Data\n     */\n    //endregion\n    //region Events\n    /**\n     * Fired after rendering an event, when its element is available in DOM.\n     * @event renderEvent\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord The event record\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment record\n     * @param {Object} renderData An object containing details about the event rendering, see\n     *   {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventRenderer} for details\n     * @param {Boolean} isRepaint `true` if this render is a repaint of the event, updating its existing element\n     * @param {Boolean} isReusingElement `true` if this render lead to the event reusing a released events element\n     * @param {HTMLElement} element The event bar element\n     */\n    /**\n     * Fired after releasing an event, useful to cleanup of custom content added on `renderEvent` or in `eventRenderer`.\n     * @event releaseEvent\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel} eventRecord The event record\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment record\n     * @param {Object} renderData An object containing details about the event rendering\n     * @param {HTMLElement} element The event bar element\n     */\n    /**\n     * Fired when clicking a resource header cell\n     * @event resourceHeaderClick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Event} event The event\n     */\n    /**\n     * Fired when double clicking a resource header cell\n     * @event resourceHeaderDblclick\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Event} event The event\n     */\n    /**\n     * Fired when activating context menu on a resource header cell\n     * @event resourceHeaderContextmenu\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {Event} event The event\n     */\n    /**\n     * Triggered when a keydown event is observed if there are selected events.\n     * @event eventKeyDown\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel[]} eventRecords The selected event records\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The selected assignment records\n     * @param {KeyboardEvent} event Browser event\n     */\n    /**\n     * Triggered when a keyup event is observed if there are selected events.\n     * @event eventKeyUp\n     * @param {Scheduler.view.Scheduler} source This Scheduler\n     * @param {Scheduler.model.EventModel[]} eventRecords The selected event records\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The selected assignment records\n     * @param {KeyboardEvent} event Browser event\n     */\n    //endregion\n    //region Functions injected by features\n    // For documentation & typings purposes\n    /**\n     * Opens an editor UI to edit the passed event.\n     *\n     * *NOTE: Only available when the {@link Scheduler/feature/EventEdit EventEdit} feature is enabled.*\n     *\n     * @function editEvent\n     * @param {Scheduler.model.EventModel} eventRecord Event to edit\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] The Resource record for the event.\n     * This parameter is needed if the event is newly created for a resource and has not been assigned, or when using\n     * multi assignment.\n     * @param {HTMLElement} [element] Element to anchor editor to (defaults to events element)\n     * @category Feature shortcuts\n     */\n    /**\n     * Returns the dependency record for a DOM element\n     *\n     * *NOTE: Only available when the {@link Scheduler/feature/Dependencies Dependencies} feature is enabled.*\n     *\n     * @function resolveDependencyRecord\n     * @param {HTMLElement} element The dependency line element\n     * @returns {Scheduler.model.DependencyModel} The dependency record\n     * @category Feature shortcuts\n     */\n    //endregion\n    //region Init\n    afterConstruct() {\n        const me = this;\n        super.afterConstruct();\n        me.ion({ scroll : 'onVerticalScroll', thisObj : me });\n        if (me.createEventOnDblClick) {\n            me.ion({ scheduledblclick : me.onTimeAxisCellDblClick });\n        }\n    }\n    //endregion\n    //region Overrides\n    onPaintOverride() {\n        // Internal procedure used for paint method overrides\n        // Not used in onInternalPaint() because it may be chained on instance and Override won't be applied\n    }\n    //endregion\n    //region Config getters/setters\n    // Placeholder getter/setter for mixins, please make any changes needed to SchedulerStores#store instead\n    get store() {\n        return super.store;\n    }\n    set store(store) {\n        super.store = store;\n    }\n    /**\n     * Returns an object defining the range of visible resources\n     * @property {Object}\n     * @property {Scheduler.model.ResourceModel} visibleResources.first First visible resource\n     * @property {Scheduler.model.ResourceModel} visibleResources.last Last visible resource\n     * @readonly\n     * @category Resources\n     */\n    get visibleResources() {\n        const me = this;\n        if (me.isVertical) {\n            return me.currentOrientation.visibleResources;\n        }\n        return {\n            first : me.store.getById(me.firstVisibleRow?.id),\n            last  : me.store.getById(me.lastVisibleRow?.id)\n        };\n    }\n    //endregion\n    //region Event handlers\n    onLocaleChange() {\n        this.currentOrientation.onLocaleChange();\n        super.onLocaleChange();\n    }\n    onTimeAxisCellDblClick({ date : startDate, resourceRecord, row }) {\n        this.createEvent(startDate, resourceRecord, row);\n    }\n    onVerticalScroll({ scrollTop }) {\n        this.currentOrientation.updateFromVerticalScroll(scrollTop);\n    }\n    /**\n     * Called when new event is created.\n     * \u0421an be overridden to supply default record values etc.\n     * @param {Scheduler.model.EventModel} eventRecord Newly created event\n     * @category Scheduled events\n     */\n    onEventCreated(eventRecord) {}\n    //endregion\n    //region Mode\n    /**\n     * Checks if scheduler is in horizontal mode\n     * @returns {Boolean}\n     * @readonly\n     * @category Common\n     * @private\n     */\n    get isHorizontal() {\n        return this.mode === 'horizontal';\n    }\n    /**\n     * Checks if scheduler is in vertical mode\n     * @returns {Boolean}\n     * @readonly\n     * @category Common\n     * @private\n     */\n    get isVertical() {\n        return this.mode === 'vertical';\n    }\n    /**\n     * Get mode (horizontal/vertical)\n     * @property {'horizontal'|'vertical'}\n     * @readonly\n     * @category Common\n     */\n    get mode() {\n        return this._mode;\n    }\n    set mode(mode) {\n        const me = this;\n        me._mode = mode;\n        if (!me[mode]) {\n            me.element.classList.add(`b-sch-${mode}`);\n            if (mode === 'horizontal') {\n                me.horizontal = new HorizontalRendering(me);\n                if (me.isPainted) {\n                    me.horizontal.init();\n                }\n            }\n            else if (mode === 'vertical') {\n                me.vertical = new VerticalRendering(me);\n                if (me.rendered) {\n                    me.vertical.init();\n                }\n            }\n        }\n    }\n    get currentOrientation() {\n        return this[this.mode];\n    }\n    //endregion\n    //region Dom event dummies\n    // this is ugly, but needed since super cannot be called from SchedulerDomEvents mixin...\n    onElementKeyDown(event) {\n        return super.onElementKeyDown(event);\n    }\n    onElementKeyUp(event) {\n        return super.onElementKeyUp(event);\n    }\n    onElementMouseOver(event) {\n        return super.onElementMouseOver(event);\n    }\n    onElementMouseOut(event) {\n        return super.onElementMouseOut(event);\n    }\n    //endregion\n    //region Feature hooks\n    // Called for each event during drop\n    processEventDrop() {}\n    processCrossSchedulerEventDrop() {}\n    // Called before event drag starts\n    beforeEventDragStart() {}\n    // Called after event drag starts\n    afterEventDragStart() {}\n    // Called after aborting a drag\n    afterEventDragAbortFinalized() {}\n    // Called during event drag validation\n    checkEventDragValidity() {}\n    // Called after event resizing starts\n    afterEventResizeStart() {}\n    // Called after generating a DomConfig for an event\n    afterRenderEvent() {}\n    //endregion\n    //region Scheduler specific date mapping functions\n    get hasEventEditor() {\n        return Boolean(this.eventEditingFeature);\n    }\n    get eventEditingFeature() {\n        const {\n            eventEdit,\n            taskEdit,\n            simpleEventEdit\n        } = this.features;\n        return eventEdit?.enabled\n            ? eventEdit\n            : taskEdit?.enabled\n                ? taskEdit\n                : simpleEventEdit?.enabled ? simpleEventEdit : null;\n    }\n    // Method is chained by event editing features. Ensure that the event is in the store.\n    editEvent(eventRecord, resourceRecord, element) {\n        const\n            me = this,\n            {\n                eventStore,\n                assignmentStore\n            } = me;\n        // Abort the chain if no event editing features available\n        if (!me.hasEventEditor) {\n            return false;\n        }\n        if (eventRecord.eventStore !== eventStore) {\n            const\n                { enableEventAnimations } = me,\n                resourceRecords           = [];\n            // It's only a provisional event because we are going to edit it which will\n            // allow an opportunity to cancel the add (by removing it).\n            eventRecord.isCreating = true;\n            let assignmentRecords = [];\n            if (resourceRecord) {\n                resourceRecords.push(resourceRecord);\n                assignmentRecords = assignmentStore.assignEventToResource(eventRecord, resourceRecord);\n            }\n            // Vetoable beforeEventAdd allows cancel of this operation\n            if (me.trigger('beforeEventAdd', { eventRecord, resourceRecords, assignmentRecords }) === false) {\n                // Remove any assignment created above, to leave store as it was\n                assignmentStore?.remove(assignmentRecords);\n                return false;\n            }\n            me.enableEventAnimations = false;\n            eventStore.add(eventRecord);\n            me.project.commitAsync().then(() => me.enableEventAnimations = enableEventAnimations);\n            // Element must be created synchronously, not after the project's normalizing delays.\n            me.refreshRows();\n        }\n    }\n    /**\n     * Creates an event on the specified date (and scrolls it into view), for the specified resource which conforms to\n     * this scheduler's {@link #config-createEventOnDblClick} setting.\n     *\n     * NOTE: If the scheduler is readonly, or resource type is invalid (group header), or if `allowOverlap` is `false`\n     * and slot is already occupied - no event is created.\n     *\n     * This method may be called programmatically by application code if the `createEventOnDblClick` setting\n     * is `false`, in which case the default values for `createEventOnDblClick` will be used.\n     *\n     * If the {@link Scheduler.feature.EventEdit} feature is active, the new event\n     * will be displayed in the event editor.\n     * @param {Date} date The date to add the event at.\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource to create the event for.\n     * @category Scheduled events\n     */\n    async createEvent(startDate, resourceRecord) {\n        const\n            me                    = this,\n            {\n                enableEventAnimations,\n                eventStore,\n                assignmentStore,\n                hasEventEditor\n            }                     = me,\n            resourceRecords       = [resourceRecord],\n            useEventModelDefaults = me.createEventOnDblClick.useEventModelDefaults,\n            defaultDuration       = useEventModelDefaults ? eventStore.modelClass.defaultValues.duration : 1,\n            defaultDurationUnit   = useEventModelDefaults ? eventStore.modelClass.defaultValues.durationUnit : me.timeAxis.unit,\n            eventRecord           = eventStore.createRecord({\n                startDate,\n                endDate      : DateHelper.add(startDate, defaultDuration, defaultDurationUnit),\n                duration     : defaultDuration,\n                durationUnit : defaultDurationUnit,\n                name         : me.L('L{Object.newEvent}')\n            });\n        if (me.readOnly || resourceRecord.isSpecialRow || resourceRecord.readOnly || (!me.allowOverlap && !me.isDateRangeAvailable(\n            eventRecord.startDate,\n            eventRecord.endDate,\n            null,\n            resourceRecord\n        ))) {\n            return;\n        }\n        me.eventEditingFeature?.captureStm(true);\n        // It's only a provisional event if there is an event edit feature available to\n        // cancel the add (by removing it). Otherwise it's a definite event creation.\n        eventRecord.isCreating = hasEventEditor;\n        me.onEventCreated(eventRecord);\n        const assignmentRecords = assignmentStore?.assignEventToResource(eventRecord, resourceRecord);\n        /**\n         * Fires before an event is added. Can be triggered by schedule double click or drag create action.\n         * @event beforeEventAdd\n         * @param {Scheduler.view.Scheduler} source The Scheduler instance\n         * @param {Scheduler.model.EventModel} eventRecord The record about to be added\n         * @param {Scheduler.model.ResourceModel[]} resourceRecords Resources that the record is assigned to\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records\n         * @preventable\n         */\n        if (me.trigger('beforeEventAdd', { eventRecord, resourceRecords, assignmentRecords }) === false) {\n            // Remove any assignment created above, to leave store as it was\n            assignmentStore?.remove(assignmentRecords);\n            me.eventEditingFeature?.freeStm(false);\n            return;\n        }\n        me.enableEventAnimations = false;\n        eventStore.add(eventRecord);\n        me.project.commitAsync().then(() => me.enableEventAnimations = enableEventAnimations);\n        // Element must be created synchronously, not after the project's normalizing delays.\n        // Overrides the check for isEngineReady in VerticalRendering so that the newly added record\n        // will be rendered when we call refreshRows.\n        me.isCreating = true;\n        me.refreshRows();\n        me.isCreating = false;\n        await me.scrollEventIntoView(eventRecord);\n        /**\n         * Fired when a double click or drag gesture has created a new event and added it to the event store.\n         * @event eventAutoCreated\n         * @param {Scheduler.view.Scheduler} source This Scheduler.\n         * @param {Scheduler.model.EventModel} eventRecord The new event record.\n         * @param {Scheduler.model.ResourceModel} resourceRecord The resource assigned to the new event.\n         */\n        me.trigger('eventAutoCreated', {\n            eventRecord,\n            resourceRecord\n        });\n        if (hasEventEditor) {\n            me.editEvent(eventRecord, resourceRecord, me.getEventElement(eventRecord));\n        }\n    }\n    /**\n     * Checks if a date range is allocated or not for a given resource.\n     * @param {Date} start The start date\n     * @param {Date} end The end date\n     * @param {Scheduler.model.EventModel|null} excludeEvent An event to exclude from the check (or null)\n     * @param {Scheduler.model.ResourceModel} resource The resource\n     * @returns {Boolean} True if the timespan is available for the resource\n     * @category Dates\n     */\n    isDateRangeAvailable(start, end, excludeEvent, resource) {\n        return this.eventStore.isDateRangeAvailable(start, end, excludeEvent, resource);\n    }\n    //endregion\n    /**\n     * Suspends UI refresh on store operations.\n     *\n     * Multiple calls to `suspendRefresh` stack up, and will require an equal number of `resumeRefresh` calls to\n     * actually resume UI refresh.\n     *\n     * @function suspendRefresh\n     * @category Rendering\n     */\n    /**\n     * Resumes UI refresh on store operations.\n     *\n     * Multiple calls to `suspendRefresh` stack up, and will require an equal number of `resumeRefresh` calls to\n     * actually resume UI refresh.\n     *\n     * Specify `true` as the first param to trigger a refresh if this call unblocked the refresh suspension.\n     * If the underlying project is calculating changes, the refresh will be postponed until it is done.\n     *\n     * @param {Boolean} [trigger] `true` to trigger a refresh, if this resume unblocks suspension\n     * @privateparam {Boolean} [useTransitions] `false` to block transitions\n     * @category Rendering\n     */\n    async resumeRefresh(trigger = VersionHelper.checkVersion('core', '6.0', '>='), useTransitions = true) {\n        super.resumeRefresh(false);\n        const me = this;\n        if (!me.refreshSuspended && trigger) {\n            // Do not refresh until project is in a valid state\n            if (!me.isEngineReady) {\n                // Refresh will happen because of the commit, bail out of this one after forcing rendering to consider\n                // next one a full refresh\n                me.currentOrientation.refreshAllWhenReady = true;\n                return me.project.commitAsync();\n            }\n            // View could've been destroyed while we waited for engine\n            if (!me.isDestroyed) {\n                // If it already is, refresh now\n                if (useTransitions) {\n                    me.refreshWithTransition();\n                }\n                else {\n                    me.refresh();\n                }\n            }\n        }\n    }\n    //region Appearance\n    // Overrides grid to take crudManager loading into account\n    toggleEmptyText() {\n        const\n            me = this;\n        if (me.bodyContainer) {\n            DomHelper.toggleClasses(me.bodyContainer, 'b-grid-empty', !(me.resourceStore.count > 0 || me.crudManager?.isLoading));\n        }\n    }\n    // Overrides Grids base implementation to return a correctly calculated height for the row. Also stores it in\n    // RowManagers height map, which is used to calculate total height etc.\n    getRowHeight(resourceRecord) {\n        if (this.isHorizontal) {\n            const height = this.currentOrientation.calculateRowHeight(resourceRecord);\n            this.rowManager.storeKnownHeight(resourceRecord.id, height);\n            return height;\n        }\n    }\n    // Calculates the height for specified rows. Call when changes potentially makes its height invalid\n    calculateRowHeights(resourceRecords, silent = false) {\n        const { store } = this;\n        for (const resourceRecord of resourceRecords) {\n            // Array allowed to have nulls in it for easier code when calling this fn\n            // Also ignore records not in the flat part of the store (collapsed away resources)\n            if (resourceRecord && store.isAvailable(resourceRecord)) {\n                this.getRowHeight(resourceRecord);\n            }\n        }\n        if (!silent) {\n            this.rowManager.estimateTotalHeight(true);\n        }\n    }\n    // Calculate heights for all rows (up to the preCalculateHeightLimit)\n    calculateAllRowHeights(silent = false) {\n        const\n            { store, rowManager } = this,\n            count                 = Math.min(store.count, this.preCalculateHeightLimit);\n        // Allow opt out by specifying falsy value.\n        if (count) {\n            rowManager.clearKnownHeights();\n            for (let i = 0; i < count; i++) {\n                // This will both calculate and store the height\n                this.getRowHeight(store.getAt(i));\n            }\n            // Make sure height is reflected on scroller etc.\n            if (!silent) {\n                rowManager.estimateTotalHeight(true);\n            }\n        }\n    }\n    //endregion\n    //region Calendar Mode Interface\n    // These are all internal and match up w/CalendarMixin\n    /**\n     * Returns the date or ranges of included dates as an array. If only the {@link #config-startDate} is significant,\n     * the array will have that date as its only element. Otherwise, a range of dates is returned as a two-element\n     * array with `[0]` is the {@link #config-startDate} and `[1]` is the {@link #property-lastDate}.\n     * @member {Date[]}\n     * @internal\n     */\n    get dateBounds() {\n        const\n            me  = this,\n            ret = [me.startDate];\n        if (me.range === 'week') {\n            ret.push(me.lastDate);\n        }\n        return ret;\n    }\n    get defaultDescriptionFormat() {\n        return descriptionFormats[this.range];\n    }\n    /**\n     * The last day that is included in the date range. This is different than {@link #config-endDate} since that date\n     * is not inclusive. For example, an `endDate` of 2022-07-21 00:00:00 indicates that the time range ends at that\n     * time, and so 2022-07-21 is _not_ in the range. In this example, `lastDate` would be 2022-07-20 since that is the\n     * last day included in the range.\n     * @member {Date}\n     * @internal\n     */\n    get lastDate() {\n        const lastDate = this.endDate;\n        // endDate is \"exclusive\" because it means 00:00:00 of that day, so subtract 1\n        // to keep description consistent with human expectations.\n        return lastDate && DateHelper.add(lastDate, -1, 'day');\n    }\n    getEventRecord(target) {\n        target = DomHelper.getEventElement(target);\n        return this.resolveEventRecord(target);\n    }\n    getResourceRecord(domEvent) {\n        return this.resolveResourceRecord(domEvent);\n    }\n    getEventElement(eventRecord) {\n        return this.getElementFromEventRecord(eventRecord);\n    }\n    changeRange(unit) {\n        return DateHelper.normalizeUnit(unit);\n    }\n    updateRange(unit) {\n        if (!this.isConfiguring) {\n            const\n                currentDate = this.date,\n                newDate     = this.date = DateHelper.startOf(currentDate, unit);\n            // Force a span update if changing the range did not change the date\n            if (currentDate.getTime() === newDate.getTime()) {\n                this.updateDate(newDate);\n            }\n        }\n    }\n    changeStepUnit(unit) {\n        return DateHelper.normalizeUnit(unit);\n    }\n    updateDate(newDate) {\n        const\n            me    = this,\n            start = DateHelper.startOf(newDate, me.range);\n        me.setTimeSpan(start, DateHelper.add(start, 1, me.range));\n        // Cant always use newDate here in case timeAxis is filtered\n        me.visibleDate = {\n            date    : DateHelper.max(newDate, me.timeAxis.startDate),\n            block   : 'start',\n            animate : true\n        };\n        me.trigger('descriptionChange');\n    }\n    updateScrollBuffer(value) {\n        if (!this.isConfiguring) {\n            this.currentOrientation.scrollBuffer = value;\n        }\n    }\n    previous() {\n        this.date = DateHelper.add(this.date, -1, this.stepUnit);\n    }\n    next() {\n        this.date = DateHelper.add(this.date, 1, this.stepUnit);\n    }\n    //endregion\n    /**\n     * Assigns and schedules an unassigned event record (+ adds it to this Scheduler's event store unless already in it).\n     * @param {Object} config The config containing data about the event record to schedule\n     * @param {Date} config.startDate The start date\n     * @param {Scheduler.model.EventModel|EventModelConfig} config.eventRecord Event (or data for it) to assign and schedule\n     * @param {Scheduler.model.EventModel} [config.parentEventRecord] Parent event to add the event to (to nest it),\n     * only applies when using the NestedEvents feature\n     * @param {Scheduler.model.ResourceModel} config.resourceRecord Resource to assign the event to\n     * @param {HTMLElement} [config.element] The element if you are dragging an element from outside the scheduler\n     * @category Scheduled events\n     */\n    async scheduleEvent({ startDate, eventRecord, resourceRecord, element }) {\n        const me = this;\n        // NestedEvents has an override for this function to handle parentEventRecord\n        if (!me.eventStore.includes(eventRecord)) {\n            [eventRecord] = me.eventStore.add(eventRecord);\n        }\n        eventRecord.startDate = startDate;\n        eventRecord.assign(resourceRecord);\n        if (element) {\n            const eventRect = Rectangle.from(element, me.foregroundCanvas);\n            // Clear translate styles used by DragHelper\n            DomHelper.setTranslateXY(element, 0, 0);\n            DomHelper.setTopLeft(element, eventRect.y, eventRect.x);\n            DomSync.addChild(me.foregroundCanvas, element, eventRecord.assignments[0].id);\n        }\n        await me.project.commitAsync();\n    }\n}\n// Register this widget type with its Factory\nSchedulerBase.initClass();\n// Scheduler version is specified in TimelineBase because Gantt extends it\nSchedulerBase._$name = 'SchedulerBase';", "import ColorPicker from '../../Core/widget/ColorPicker.js';\nimport SchedulerBase from '../view/SchedulerBase.js';\n/**\n * @module Scheduler/widget/EventColorPicker\n */\n/**\n * A color picker that displays a list of available event colors which the user can select by using mouse or keyboard.\n * See Schedulers {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor eventColor config} for default\n * available colors.\n *\n * {@inlineexample Scheduler/widget/EventColorPicker.js}\n *\n * ```javascript\n * new EventColorPicker({\n *    appendTo : 'container',\n *    width    : '10em',\n *    onColorSelected() {\n *        console.log(...arguments);\n *    }\n * });\n * ```\n *\n * @classtype colorpicker\n * @extends Core/widget/ColorPicker\n */\nexport default class EventColorPicker extends ColorPicker {\n    static $name = 'EventColorPicker';\n    static type = 'eventcolorpicker';\n    static configurable = {\n        colorClasses : SchedulerBase.eventColors,\n        colorClassPrefix : 'b-sch-',\n        /**\n         * @hideconfigs colors\n         */\n        colors : null,\n        /**\n         * Provide a {@link Scheduler.model.EventModel} instance to update it's\n         * {@link Scheduler.model.mixin.EventModelMixin#field-eventColor} field\n         * @config {Scheduler.model.EventModel}\n         */\n        record : null\n    };\n    colorSelected({ color }) {\n        if (this.record) {\n            this.record.eventColor = color;\n        }\n    }\n}\nEventColorPicker.initClass();\nEventColorPicker._$name = 'EventColorPicker';", "import Base from '../../Core/Base.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\n/**\n * @module Scheduler/tooltip/ClockTemplate\n */\n/**\n * A template showing a clock, it consumes an object containing a date and a text\n * @private\n */\nexport default class ClockTemplate extends Base {\n    static get defaultConfig() {\n        return {\n            minuteHeight : 8,\n            minuteTop    : 2,\n            hourHeight   : 8,\n            hourTop      : 2,\n            handLeft     : 10,\n            div          : document.createElement('div'),\n            scheduler    : null, // may be passed to the constructor if needed\n            // `b-sch-clock-day` for calendar icon\n            // `b-sch-clock-hour` for clock icon\n            template(data) {\n                return `<div class=\"b-sch-clockwrap b-sch-clock-${data.mode || this.mode} ${data.cls || ''}\">\n                    <div class=\"b-sch-clock\">\n                        <div class=\"b-sch-hour-indicator\">${DateHelper.format(data.date, 'MMM')}</div>\n                        <div class=\"b-sch-minute-indicator\">${DateHelper.format(data.date, 'D')}</div>\n                        <div class=\"b-sch-clock-dot\"></div>\n                    </div>\n                    <span class=\"b-sch-clock-text\">${StringHelper.encodeHtml(data.text)}</span>\n                </div>`;\n            }\n        };\n    }\n    generateContent(data) {\n        return this.div.innerHTML = this.template(data);\n    }\n    updateDateIndicator(el, date) {\n        const\n            hourIndicatorEl   = el?.querySelector('.b-sch-hour-indicator'),\n            minuteIndicatorEl = el?.querySelector('.b-sch-minute-indicator');\n        if (date && hourIndicatorEl && minuteIndicatorEl && BrowserHelper.isBrowserEnv) {\n            if (this.mode === 'hour') {\n                hourIndicatorEl.style.transform   = `rotate(${(date.getHours() % 12) * 30}deg)`;\n                minuteIndicatorEl.style.transform = `rotate(${date.getMinutes() * 6}deg)`;\n            }\n            else {\n                hourIndicatorEl.style.transform   = 'none';\n                minuteIndicatorEl.style.transform = 'none';\n            }\n        }\n    }\n    set mode(mode) {\n        this._mode = mode;\n    }\n    // `day` mode for calendar icon\n    // `hour` mode for clock icon\n    get mode() {\n        if (this._mode) {\n            return this._mode;\n        }\n        const\n            unitLessThanDay        = DateHelper.compareUnits(this.scheduler.timeAxisViewModel.timeResolution.unit, 'day') < 0,\n            formatContainsHourInfo = DateHelper.formatContainsHourInfo(this.scheduler.displayDateFormat);\n        return unitLessThanDay && formatContainsHourInfo ? 'hour' : 'day';\n    }\n    set template(template) {\n        this._template = template;\n    }\n    /**\n     * Get the clock template, which accepts an object of format { date, text }\n     * @property {Function}\n     * @param {*} Format object\n     * @returns {String}\n     */\n    get template() {\n        return this._template;\n    }\n}\nClockTemplate._$name = 'ClockTemplate';", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/feature/mixin/TaskEditStm\n */\n/**\n * Mixin adding STM transactable behavior to TaskEdit feature.\n *\n * @mixin\n */\nexport default Target => class TaskEditStm extends (Target || Base) {\n    static get $name() {\n        return 'TaskEditStm';\n    }\n    getStmCapture() {\n        return {\n            stmInitiallyAutoRecord : this.stmInitiallyAutoRecord,\n            stmInitiallyDisabled   : this.stmInitiallyDisabled,\n            // this flag indicates whether the STM capture has been transferred to\n            // another feature, which will be responsible for finalizing the STM transaction\n            // (otherwise we'll do it ourselves)\n            transferred            : false\n        };\n    }\n    applyStmCapture(stmCapture) {\n        this.stmInitiallyAutoRecord = stmCapture.stmInitiallyAutoRecord;\n        this.stmInitiallyDisabled = stmCapture.stmInitiallyDisabled;\n    }\n    captureStm(startTransaction = false) {\n        const\n            me      = this,\n            project = me.project,\n            stm     = project.getStm();\n        if (me.hasStmCapture) {\n            return;\n        }\n        me.hasStmCapture = true;\n        me.stmInitiallyDisabled = stm.disabled;\n        me.stmInitiallyAutoRecord = stm.autoRecord;\n        if (me.stmInitiallyDisabled) {\n            stm.enable();\n            // it seems this branch has never been exercised by tests\n            // but the intention is to stop the auto-recording while\n            // task editor is active (all editing is one manual transaction)\n            stm.autoRecord = false;\n        }\n        else {\n            if (me.stmInitiallyAutoRecord) {\n                stm.autoRecord = false;\n            }\n            if (stm.isRecording) {\n                stm.stopTransaction();\n            }\n        }\n        if (startTransaction) {\n            this.startStmTransaction();\n        }\n    }\n    startStmTransaction() {\n        this.project.getStm().startTransaction();\n    }\n    commitStmTransaction() {\n        const\n            me  = this,\n            stm = me.project.getStm();\n        if (!me.hasStmCapture) {\n            throw new Error('Does not have STM capture, no transaction to commit');\n        }\n        if (stm.enabled) {\n            stm.stopTransaction();\n            if (me.stmInitiallyDisabled) {\n                stm.resetQueue();\n            }\n        }\n    }\n    async rejectStmTransaction() {\n        const\n            stm        = this.project.getStm(),\n            { client } = this;\n        if (!this.hasStmCapture) {\n            throw new Error('Does not have STM capture, no transaction to reject');\n        }\n        if (stm.enabled) {\n            if (stm.transaction?.length) {\n                client.suspendRefresh();\n                stm.rejectTransaction();\n                await client.resumeRefresh(true);\n            }\n            else {\n                stm.stopTransaction();\n            }\n        }\n    }\n    enableStm() {\n        this.project.getStm().enable();\n    }\n    disableStm() {\n        this.project.getStm().disable();\n    }\n    async freeStm(commitOrReject = null) {\n        const\n            me  = this,\n            stm = me.project.getStm(),\n            {\n                stmInitiallyDisabled,\n                stmInitiallyAutoRecord\n            } = me;\n        if (!me.hasStmCapture) {\n            return;\n        }\n        let promise;\n        me.rejectingStmTransaction = true;\n        if (commitOrReject === true) {\n            promise = me.commitStmTransaction();\n        }\n        else if (commitOrReject === false) {\n            // Note - we don't wait for async to complete here\n            promise = me.rejectStmTransaction();\n        }\n        await promise;\n        if (!stm.isDestroying) {\n            stm.disabled = stmInitiallyDisabled;\n            stm.autoRecord = stmInitiallyAutoRecord;\n        }\n        if (!me.isDestroying) {\n            me.rejectingStmTransaction = true;\n            me.hasStmCapture = false;\n        }\n    };\n};\n", "import ContextMenuBase from '../../../Core/feature/base/ContextMenuBase.js';\n/**\n * @module Scheduler/feature/base/TimeSpanMenuBase\n */\n/**\n * Abstract base class used by other context menu features which show the context menu for TimeAxis.\n * Using this class you can make sure the menu expects the target to disappear,\n * since it can be scroll out of the scheduling zone.\n *\n * Features that extend this class are:\n *  * {@link Scheduler/feature/EventMenu};\n *  * {@link Scheduler/feature/ScheduleMenu};\n *  * {@link Scheduler/feature/TimeAxisHeaderMenu};\n *\n * @extends Core/feature/base/ContextMenuBase\n * @abstract\n */\nexport default class TimeSpanMenuBase extends ContextMenuBase {\n}\nTimeSpanMenuBase._$name = 'TimeSpanMenuBase';", "import Combo from '../../../../Core/widget/Combo.js';\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceFrequencyCombo\n */\n/**\n * A combobox field allowing to pick frequency in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/Combo\n * @classtype recurrencefrequencycombo\n */\nexport default class RecurrenceFrequencyCombo extends Combo {\n    static $name = 'RecurrenceFrequencyCombo';\n    // Factoryable type name\n    static type = 'recurrencefrequencycombo';\n    static configurable = {\n        editable              : false,\n        displayField          : 'text',\n        valueField            : 'value',\n        localizeDisplayFields : true,\n        addNone               : false\n    };\n    buildItems() {\n        return [\n            ...(this.addNone ? [{ text : 'L{None}', value : 'NONE' }] : []),\n            { value : 'DAILY',   text : 'L{Daily}' },\n            { value : 'WEEKLY',  text : 'L{Weekly}' },\n            { value : 'MONTHLY', text : 'L{Monthly}' },\n            { value : 'YEARLY',  text : 'L{Yearly}' }\n        ];\n    }\n};\n// Register this widget type with its Factory\nRecurrenceFrequencyCombo.initClass();\nRecurrenceFrequencyCombo._$name = 'RecurrenceFrequencyCombo';", "import DateHelper from '../../../../Core/helper/DateHelper.js';\nimport Combo from '../../../../Core/widget/Combo.js';\nimport RecurrenceDayRuleEncoder from '../../../data/util/recurrence/RecurrenceDayRuleEncoder.js';\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceDaysCombo\n */\n/**\n * A combobox field allowing to pick days for the `Monthly` and `Yearly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/Combo\n * @classtype recurrencedayscombo\n */\nexport default class RecurrenceDaysCombo extends Combo {\n    static get $name() {\n        return 'RecurrenceDaysCombo';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencedayscombo';\n    }\n    static get defaultConfig() {\n        const\n            allDaysValueAsArray = ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'],\n            allDaysValue        = allDaysValueAsArray.join(',');\n        return {\n            allDaysValue,\n            editable            : false,\n            defaultValue        : allDaysValue,\n            workingDaysValue    : allDaysValueAsArray.filter((day, index) => !DateHelper.nonWorkingDays[index]).join(','),\n            nonWorkingDaysValue : allDaysValueAsArray.filter((day, index) => DateHelper.nonWorkingDays[index]).join(','),\n            splitCls            : 'b-recurrencedays-split',\n            displayField        : 'text',\n            valueField          : 'value'\n        };\n    }\n    buildItems() {\n        const me = this;\n        me._weekDays = null;\n        return me.weekDays.concat([\n            { value : me.allDaysValue,        text : me.L('L{day}'), cls : me.splitCls },\n            { value : me.workingDaysValue,    text : me.L('L{weekday}') },\n            { value : me.nonWorkingDaysValue, text : me.L('L{weekend day}') }\n        ]);\n    }\n    get weekDays() {\n        const me = this;\n        if (!me._weekDays) {\n            const weekStartDay = DateHelper.weekStartDay;\n            const dayNames = DateHelper.getDayNames().map((text, index) => ({ text, value : RecurrenceDayRuleEncoder.encodeDay(index) }));\n            // we should start week w/ weekStartDay\n            me._weekDays = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));\n        }\n        return me._weekDays;\n    }\n    set value(value) {\n        const me = this;\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n        // if the value has no matching option in the store we need to use default value\n        if (!value || !me.store.findRecord('value', value)) {\n            value = me.defaultValue;\n        }\n        super.value = value;\n    }\n    get value() {\n        let value = super.value;\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n        return value;\n    }\n}\n// Register this widget type with its Factory\nRecurrenceDaysCombo.initClass();\nRecurrenceDaysCombo._$name = 'RecurrenceDaysCombo';", "import DateHelper from '../../../../Core/helper/DateHelper.js';\nimport ButtonGroup from '../../../../Core/widget/ButtonGroup.js';\nimport RecurrenceDayRuleEncoder from '../../../data/util/recurrence/RecurrenceDayRuleEncoder.js';\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceDaysButtonGroup\n */\n/**\n * A segmented button field allowing to pick days for the \"Weekly\" mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * {@inlineexample Scheduler/view/RecurrenceDaysButtonGroup.js}\n *\n * @extends Core/widget/ButtonGroup\n */\nexport default class RecurrenceDaysButtonGroup extends ButtonGroup {\n    static get $name() {\n        return 'RecurrenceDaysButtonGroup';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencedaysbuttongroup';\n    }\n    static get defaultConfig() {\n        return {\n            defaults : {\n                cls        : 'b-raised',\n                toggleable : true\n            }\n        };\n    }\n    construct(config = {}) {\n        const me = this;\n        config.columns = 7;\n        config.items   = me.buildItems();\n        super.construct(config);\n    }\n    updateItemText(item) {\n        const day = RecurrenceDayRuleEncoder.decodeDay(item.value)[0];\n        item.text = DateHelper.getDayName(day).substring(0, 3);\n    }\n    buildItems() {\n        const me = this;\n        if (!me.__items) {\n            const weekStartDay = DateHelper.weekStartDay;\n            const dayNames = DateHelper.getDayNames().map((text, index) => ({\n                text  : text.substring(0, 3),\n                value : RecurrenceDayRuleEncoder.encodeDay(index)\n            }));\n            // we should start week w/ weekStartDay\n            me.__items = dayNames.slice(weekStartDay).concat(dayNames.slice(0, weekStartDay));\n        }\n        return me.__items;\n    }\n    set value(value) {\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n        super.value = value;\n    }\n    get value() {\n        let value = super.value;\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n        return value;\n    }\n    onLocaleChange() {\n        // update button texts on locale switch\n        this.items.forEach(this.updateItemText, this);\n    }\n    updateLocalization() {\n        this.onLocaleChange();\n        super.updateLocalization();\n    }\n    get widgetClassList() {\n        const classList = super.widgetClassList;\n        // to look more like a real field\n        classList.push('b-field');\n        return classList;\n    }\n};\n// Register this widget type with its Factory\nRecurrenceDaysButtonGroup.initClass();\nRecurrenceDaysButtonGroup._$name = 'RecurrenceDaysButtonGroup';", "import ButtonGroup from '../../../../Core/widget/ButtonGroup.js';\n/**\n * A segmented button field allowing to pick month days for the `Monthly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/ButtonGroup\n */\nexport default class RecurrenceMonthDaysButtonGroup extends ButtonGroup {\n    static get $name() {\n        return 'RecurrenceMonthDaysButtonGroup';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencemonthdaysbuttongroup';\n    }\n    static get defaultConfig() {\n        return {\n            defaults : {\n                toggleable : true,\n                cls        : 'b-raised'\n            }\n        };\n    }\n    get minValue() {\n        return 1;\n    }\n    get maxValue() {\n        return 31;\n    }\n    construct(config = {}) {\n        const me = this;\n        config.columns = 7;\n        config.items   = me.buildItems();\n        super.construct(config);\n    }\n    buildItems() {\n        const\n            me    = this,\n            items = [];\n        for (let value = me.minValue; value <= me.maxValue; value++) {\n            // button config\n            items.push({\n                text : value + '',\n                value\n            });\n        }\n        return items;\n    }\n    get widgetClassList() {\n        const classList = super.widgetClassList;\n        // to look more like a real field\n        classList.push('b-field');\n        return classList;\n    }\n};\n// Register this widget type with its Factory\nRecurrenceMonthDaysButtonGroup.initClass();\nRecurrenceMonthDaysButtonGroup._$name = 'RecurrenceMonthDaysButtonGroup';", "import DateHelper from '../../../../Core/helper/DateHelper.js';\nimport ButtonGroup from '../../../../Core/widget/ButtonGroup.js';\n/**\n * A segmented button field allowing to pick months for the `Yearly` mode in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/ButtonGroup\n */\nexport default class RecurrenceMonthsButtonGroup extends ButtonGroup {\n    static get $name() {\n        return 'RecurrenceMonthsButtonGroup';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencemonthsbuttongroup';\n    }\n    static get defaultConfig() {\n        return {\n            defaults : {\n                toggleable : true,\n                cls        : 'b-raised'\n            }\n        };\n    }\n    construct(config = {}) {\n        const me = this;\n        config.columns = 4;\n        config.items   = me.buildItems();\n        super.construct(config);\n    }\n    buildItems() {\n        return DateHelper.getMonthNames().map((item, index) => ({\n            text  : item.substring(0, 3),\n            value : index + 1 // 1-based\n        }));\n    }\n    updateItemText(item) {\n        item.text = DateHelper.getMonthName(item.value - 1).substring(0, 3);\n    }\n    onLocaleChange() {\n        // update button texts on locale switch\n        this.items.forEach(this.updateItemText, this);\n    }\n    updateLocalization() {\n        this.onLocaleChange();\n        super.updateLocalization();\n    }\n    get widgetClassList() {\n        const classList = super.widgetClassList;\n        // to look more like a real field\n        classList.push('b-field');\n        return classList;\n    }\n};\n// Register this widget type with its Factory\nRecurrenceMonthsButtonGroup.initClass();\nRecurrenceMonthsButtonGroup._$name = 'RecurrenceMonthsButtonGroup';", "import Combo from '../../../../Core/widget/Combo.js';\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceStopConditionCombo\n */\n/**\n * A combobox field allowing to choose stop condition for the recurrence in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence dialog}.\n *\n * @extends Core/widget/Combo\n * @classtype recurrencestopconditioncombo\n */\nexport default class RecurrenceStopConditionCombo extends Combo {\n    static get $name() {\n        return 'RecurrenceStopConditionCombo';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencestopconditioncombo';\n    }\n    static get defaultConfig() {\n        return {\n            editable     : false,\n            placeholder  : 'Never',\n            displayField : 'text',\n            valueField   : 'value'\n        };\n    }\n    buildItems() {\n        return [\n            { value : 'never', text : this.L('L{Never}') },\n            { value : 'count', text : this.L('L{After}') },\n            { value : 'date',  text : this.L('L{On date}') }\n        ];\n    }\n    set value(value) {\n        // Use 'never' instead of falsy value\n        value = value || 'never';\n        super.value = value;\n    }\n    get value() {\n        return super.value;\n    }\n    get recurrence() {\n        return this._recurrence;\n    }\n    set recurrence(recurrence) {\n        let value = null;\n        if (recurrence.endDate) {\n            value = 'date';\n        }\n        else if (recurrence.count) {\n            value = 'count';\n        }\n        this._recurrence = recurrence;\n        this.value = value;\n    }\n};\n// Register this widget type with its Factory\nRecurrenceStopConditionCombo.initClass();\nRecurrenceStopConditionCombo._$name = 'RecurrenceStopConditionCombo';", "import ArrayHelper from '../../../../Core/helper/ArrayHelper.js';\nimport Combo from '../../../../Core/widget/Combo.js';\n/**\n * @module Scheduler/view/recurrence/field/RecurrencePositionsCombo\n */\n/**\n * A combobox field allowing to specify day positions in the {@link Scheduler.view.recurrence.RecurrenceEditor recurrence editor}.\n *\n * @extends Core/widget/Combo\n * @classtype recurrencepositionscombo\n */\nexport default class RecurrencePositionsCombo extends Combo {\n    static get $name() {\n        return 'RecurrencePositionsCombo';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencepositionscombo';\n    }\n    static get defaultConfig() {\n        return {\n            editable     : false,\n            splitCls     : 'b-sch-recurrencepositions-split',\n            displayField : 'text',\n            valueField   : 'value',\n            defaultValue : 1,\n            maxPosition  : 5\n        };\n    }\n    buildItems() {\n        return this.buildDayNumbers().concat([\n            { value : '-1', text : this.L('L{position-1}'), cls : this.splitCls }\n        ]);\n    }\n    buildDayNumbers() {\n        return ArrayHelper.populate(this.maxPosition, i => (\n            { value : i + 1, text : this.L(`position${i + 1}`) }\n        ));\n    }\n    set value(value) {\n        const me = this;\n        if (value && Array.isArray(value)) {\n            value = value.join(',');\n        }\n        // if the value has no matching option in the store we need to use default value\n        if (!value || !me.store.findRecord('value', value)) {\n            value = me.defaultValue;\n        }\n        super.value = value;\n    }\n    get value() {\n        const value = super.value;\n        return value ? `${value}`.split(',').map(item => parseInt(item, 10)) : [];\n    }\n};\n// Register this widget type with its Factory\nRecurrencePositionsCombo.initClass();\nRecurrencePositionsCombo._$name = 'RecurrencePositionsCombo';", "import RecurrenceDayRuleEncoder from '../../data/util/recurrence/RecurrenceDayRuleEncoder.js';\nimport Panel from '../../../Core/widget/Panel.js';\nimport '../../../Core/widget/Widget.js';\nimport '../../../Core/widget/Button.js';\nimport '../../../Core/widget/Checkbox.js';\nimport '../../../Core/widget/SlideToggle.js';\nimport '../../../Core/widget/DateField.js';\nimport '../../../Core/widget/NumberField.js';\nimport './field/RecurrenceFrequencyCombo.js';\nimport './field/RecurrenceDaysCombo.js';\nimport './field/RecurrenceDaysButtonGroup.js';\nimport './field/RecurrenceMonthDaysButtonGroup.js';\nimport './field/RecurrenceMonthsButtonGroup.js';\nimport './field/RecurrenceStopConditionCombo.js';\nimport './field/RecurrencePositionsCombo.js';\nimport BrowserHelper from '../../../Core/helper/BrowserHelper.js';\n/**\n * @module Scheduler/view/recurrence/RecurrenceEditorPanel\n */\n/**\n * Panel containing fields used to edit a {@link Scheduler.model.RecurrenceModel recurrence model}. Used by\n * {@link Scheduler/view/recurrence/RecurrenceEditor}, and by the recurrence tab in Scheduler Pro's event editor.\n *\n * Not intended to be used separately.\n *\n * @extends Core/widget/Panel\n * @classtype recurrenceeditorpanel\n * @private\n */\nexport default class RecurrenceEditorPanel extends Panel {\n    static $name = 'RecurrenceEditorPanel';\n    static type = 'recurrenceeditorpanel';\n    static configurable = {\n        cls     : 'b-recurrenceeditor',\n        record  : false,\n        addNone : false,\n        items   : {\n            frequencyField : {\n                type     : 'recurrencefrequencycombo',\n                name     : 'frequency',\n                label    : 'L{RecurrenceEditor.Frequency}',\n                weight   : 10,\n                onChange : 'up.onFrequencyFieldChange',\n                addNone  : 'up.addNone'\n            },\n            intervalField : {\n                type     : 'numberfield',\n                weight   : 15,\n                name     : 'interval',\n                label    : 'L{RecurrenceEditor.Every}',\n                min      : 1,\n                required : true\n            },\n            daysButtonField : {\n                type         : 'recurrencedaysbuttongroup',\n                weight       : 20,\n                name         : 'days',\n                forFrequency : 'WEEKLY'\n            },\n            // the radio button enabling \"monthDaysButtonField\" in MONTHLY mode\n            monthDaysRadioField : {\n                type         : 'checkbox',\n                weight       : 30,\n                toggleGroup  : 'radio',\n                forFrequency : 'MONTHLY',\n                label        : 'L{RecurrenceEditor.Each}',\n                checked      : true,\n                onChange     : 'up.onMonthDaysRadioFieldChange'\n            },\n            monthDaysButtonField : {\n                type         : 'recurrencemonthdaysbuttongroup',\n                weight       : 40,\n                name         : 'monthDays',\n                forFrequency : 'MONTHLY'\n            },\n            monthsButtonField : {\n                type         : 'recurrencemonthsbuttongroup',\n                weight       : 50,\n                name         : 'months',\n                forFrequency : 'YEARLY'\n            },\n            // the radio button enabling positions & days combos in MONTHLY & YEARLY modes\n            positionAndDayRadioField : {\n                type         : 'checkbox',\n                weight       : 60,\n                toggleGroup  : 'radio',\n                forFrequency : 'MONTHLY|YEARLY',\n                label        : 'L{RecurrenceEditor.On the}',\n                onChange     : 'up.onPositionAndDayRadioFieldChange'\n            },\n            positionsCombo : {\n                type         : 'recurrencepositionscombo',\n                weight       : 80,\n                name         : 'positions',\n                forFrequency : 'MONTHLY|YEARLY'\n            },\n            daysCombo : {\n                type         : 'recurrencedayscombo',\n                weight       : 90,\n                name         : 'days',\n                forFrequency : 'MONTHLY|YEARLY',\n                flex         : 1\n            },\n            stopRecurrenceField : {\n                type     : 'recurrencestopconditioncombo',\n                weight   : 100,\n                label    : 'L{RecurrenceEditor.End repeat}',\n                onChange : 'up.onStopRecurrenceFieldChange'\n            },\n            countField : {\n                type     : 'numberfield',\n                weight   : 110,\n                name     : 'count',\n                min      : 2,\n                required : true,\n                disabled : true,\n                label    : ' '\n            },\n            endDateField : {\n                type     : 'datefield',\n                weight   : 120,\n                name     : 'endDate',\n                hidden   : true,\n                disabled : true,\n                label    : ' ',\n                required : true\n            }\n        }\n    };\n    setupWidgetConfig(widgetConfig) {\n        // All our inputs must be mutated using triggers and touch gestures on mobile\n        if (BrowserHelper.isMobile && !('editable' in widgetConfig)) {\n            widgetConfig.editable = false;\n        }\n        return super.setupWidgetConfig(...arguments);\n    }\n    updateRecord(record) {\n        super.updateRecord(record);\n        const\n            me = this,\n            {\n                frequencyField,\n                daysButtonField,\n                monthDaysButtonField,\n                monthsButtonField,\n                monthDaysRadioField,\n                positionAndDayRadioField,\n                stopRecurrenceField\n            }  = me.widgetMap;\n        if (record) {\n            const\n                event     = record.timeSpan,\n                startDate = event?.startDate;\n            // some fields default values are calculated based on event \"startDate\" value\n            if (startDate) {\n                // if no \"days\" value provided\n                if (!record.days || !record.days.length) {\n                    daysButtonField.value = [RecurrenceDayRuleEncoder.encodeDay(startDate.getDay())];\n                }\n                // if no \"monthDays\" value provided\n                if (!record.monthDays || !record.monthDays.length) {\n                    monthDaysButtonField.value = startDate.getDate();\n                }\n                // if no \"months\" value provided\n                if (!record.months || !record.months.length) {\n                    monthsButtonField.value = startDate.getMonth() + 1;\n                }\n            }\n            // if the record has both \"days\" & \"positions\" fields set check \"On the\" checkbox\n            if (record.days && record.positions) {\n                positionAndDayRadioField.check();\n                if (!me.isPainted) {\n                    monthDaysRadioField.uncheck();\n                }\n            }\n            else {\n                monthDaysRadioField.check();\n                if (!me.isPainted) {\n                    positionAndDayRadioField.uncheck();\n                }\n            }\n            stopRecurrenceField.recurrence = record;\n        }\n        else {\n            frequencyField.value = 'NONE';\n        }\n    }\n    /**\n     * Updates the provided recurrence model with the contained form data.\n     * If recurrence model is not provided updates the last loaded recurrence model.\n     * @internal\n     */\n    syncEventRecord(recurrence) {\n        // get values relevant to the RecurrenceModel (from enabled fields only)\n        const values = this.getValues((w) => w.name in recurrence && !w.disabled);\n        // Disabled field does not contribute to values, clear manually\n        if (!('endDate' in values)) {\n            values.endDate = null;\n        }\n        if (!('count' in values)) {\n            values.count = null;\n        }\n        recurrence.set(values);\n    }\n    toggleStopFields() {\n        const\n            me                           = this,\n            { countField, endDateField } = me.widgetMap;\n        switch (me.widgetMap.stopRecurrenceField.value) {\n            case 'count' :\n                countField.show();\n                countField.enable();\n                endDateField.hide();\n                endDateField.disable();\n                break;\n            case 'date' :\n                countField.hide();\n                countField.disable();\n                endDateField.show();\n                endDateField.enable();\n                break;\n            default :\n                countField.hide();\n                endDateField.hide();\n                countField.disable();\n                endDateField.disable();\n        }\n    }\n    onMonthDaysRadioFieldChange({ checked }) {\n        const { monthDaysButtonField } = this.widgetMap;\n        monthDaysButtonField.disabled = !checked || !this.isWidgetAvailableForFrequency(monthDaysButtonField);\n    }\n    onPositionAndDayRadioFieldChange({ checked }) {\n        const { daysCombo, positionsCombo } = this.widgetMap;\n        // toggle day & positions combos\n        daysCombo.disabled = positionsCombo.disabled = !checked || !this.isWidgetAvailableForFrequency(daysCombo);\n    }\n    onStopRecurrenceFieldChange() {\n        this.toggleStopFields();\n    }\n    isWidgetAvailableForFrequency(widget, frequency = this.widgetMap.frequencyField.value) {\n        return !widget.forFrequency || widget.forFrequency.includes(frequency);\n    }\n    onFrequencyFieldChange({ value, oldValue, valid }) {\n        const\n            me    = this,\n            items = me.queryAll(w => 'forFrequency' in w),\n            {\n                intervalField,\n                stopRecurrenceField\n            }     = me.widgetMap;\n        if (valid && value) {\n            for (let i = 0; i < items.length; i++) {\n                const item = items[i];\n                if (me.isWidgetAvailableForFrequency(item, value)) {\n                    item.show();\n                    item.enable();\n                }\n                else {\n                    item.hide();\n                    item.disable();\n                }\n            }\n            // Special handling of NONE\n            intervalField.hidden = stopRecurrenceField.hidden = value === 'NONE';\n            if (value !== 'NONE') {\n                intervalField.hint = me.L(`L{RecurrenceEditor.${value}intervalUnit}`);\n            }\n            // When a non-recurring record is loaded, intervalField is set to empty. We want it to default to 1 here\n            // to not look weird (defaults to 1 on the data layer)\n            if (oldValue === 'NONE' && intervalField.value == null) {\n                intervalField.value = 1;\n            }\n            me.toggleFieldsState();\n        }\n    }\n    toggleFieldsState() {\n        const\n            me            = this,\n            { widgetMap } = me;\n        me.onMonthDaysRadioFieldChange({ checked : widgetMap.monthDaysRadioField.checked });\n        me.onPositionAndDayRadioFieldChange({ checked : widgetMap.positionAndDayRadioField.checked });\n        me.onStopRecurrenceFieldChange();\n    }\n    updateLocalization() {\n        // do extra labels translation (not auto-translated yet)\n        const { countField, intervalField, frequencyField } = this.widgetMap;\n        countField.hint = this.L('L{RecurrenceEditor.time(s)}');\n        if (frequencyField.value && frequencyField.value !== 'NONE') {\n            intervalField.hint = this.L(`L{RecurrenceEditor.${frequencyField.value}intervalUnit}`);\n        }\n        super.updateLocalization();\n    }\n}\n// Register this widget type with its Factory\nRecurrenceEditorPanel.initClass();\nRecurrenceEditorPanel._$name = 'RecurrenceEditorPanel';", "import ColorField from '../../Core/widget/ColorField.js';\nimport './EventColorPicker.js';\n/**\n * @module Scheduler/widget/EventColorField\n */\n/**\n * Color field widget for editing the EventModel's {@link Scheduler.model.mixin.EventModelMixin#field-eventColor} field.\n * See Schedulers {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor eventColor config} for default\n * available colors.\n *\n * What differs this widget from {@link Core.widget.ColorField} is that this uses the\n * {@link Scheduler.widget.EventColorPicker} as its picker. And also that the {@link #config-name} config is set to\n * `eventColor` per default.\n *\n * {@inlineexample Scheduler/widget/EventColorField.js}\n *\n * This widget may be operated using the keyboard. `ArrowDown` opens the color picker, which itself is keyboard\n * navigable.\n *\n * ```javascript\n * let eventColorField = new EventColorField();\n * ```\n *\n * @extends Core/widget/ColorField\n * @classtype eventcolorfield\n * @inputfield\n */\nexport default class EventColorField extends ColorField {\n    static $name = 'EventColorField';\n    static type = 'eventcolorfield';\n    static configurable = {\n        picker : {\n            type : 'eventcolorpicker'\n        },\n        name : 'eventColor'\n    };\n}\nEventColorField.initClass();\nEventColorField._$name = 'EventColorField';", "import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport TimeSpanMenuBase from './base/TimeSpanMenuBase.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Objects from '../../Core/helper/util/Objects.js';\nimport '../widget/EventColorPicker.js';\n/**\n * @module Scheduler/feature/EventMenu\n */\n/**\n * Displays a context menu for events. Items are populated by other features and/or application code.\n *\n * {@inlineexample Scheduler/feature/EventMenu.js}\n *\n * ### Default event menu items\n *\n * Here is the list of menu items provided by the feature and populated by the other features:\n *\n * | Reference       | Text           | Weight | Feature                                  | Description                                                       |\n * |-----------------|----------------|--------|------------------------------------------|-------------------------------------------------------------------|\n * | `editEvent`     | Edit event     | 100    | {@link Scheduler/feature/EventEdit}      | Edit in the event editor. Hidden when read-only                   |\n * | `copyEvent`     | Copy event     | 110    | {@link Scheduler/feature/EventCopyPaste} | Copy event or assignment. Hidden when read-only                   |\n * | `cutEvent `     | Cut event      | 120    | {@link Scheduler/feature/EventCopyPaste} | Cut event or assignment. Hidden when read-only                    |\n * | `deleteEvent`   | Delete event   | 200    | *This feature*                           | Remove event. Hidden when read-only                               |\n * | `unassignEvent` | Unassign event | 300    | *This feature*                           | Unassign event. Hidden when read-only, shown for multi-assignment |\n * | `splitEvent`    | Split event    | 650    | *Scheduler Pro only*                     | Split an event into two segments at the mouse position            |\n * | `renameSegment` | Rename segment | 660    | *Scheduler Pro only*                     | Show an inline editor to rename the segment                       |\n * | `eventColor` \u00B9  | Color          | 400    | *This feature*                           | Choose background color for the event bar                         |\n *\n * **\u00B9** Set {@link Scheduler.view.SchedulerBase#config-showEventColorPickers} to `true` to enable this item\n *\n * ### Customizing the menu items\n *\n * The menu items in the Event menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * Add extra items for all events:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 extraItem : {\n *                     text : 'Extra',\n *                     icon : 'b-fa b-fa-fw b-fa-flag',\n *                     onItem({eventRecord}) {\n *                         eventRecord.flagged = true;\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Remove existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 deleteEvent   : false,\n *                 unassignEvent : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 deleteEvent : {\n *                     text : 'Delete booking'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Manipulate existing items for all events or specific events:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             // Process items before menu is shown\n *             processItems({eventRecord, items}) {\n *                  // Push an extra item for conferences\n *                  if (eventRecord.type === 'conference') {\n *                      items.showSessionItem = {\n *                          text : 'Show sessions',\n *                          onItem({eventRecord}) {\n *                              // ...\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show menu for secret events\n *                  if (eventRecord.type === 'secret') {\n *                      return false;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">The `processItems` implementation my be an `async` function which `awaits` a result to\n * mutate the `items` object.</div>\n *\n * Note that the {@link #property-menuContext} is applied to the Menu's `item` event, so your `onItem`\n * handler's single event parameter also contains the following properties:\n *\n * - **source** The {@link Scheduler.view.Scheduler} who's UI was right clicked.\n * - **targetElement** The element right clicked on.\n * - **eventRecord** The {@link Scheduler.model.EventModel event record} clicked on.\n * - **resourceRecord** The {@link Scheduler.model.ResourceModel resource record} clicked on.\n * - **assignmentRecord** The {@link Scheduler.model.AssignmentModel assignment record} clicked on.\n *\n * ## Video guides\n * {@frameworktabs}\n * {@react}\n * [@youtube](https://www.youtube.com/embed/ghWLmifpO_4)\n * {@endreact}\n * {@vue}\n * [@youtube](https://www.youtube.com/embed/HAq12QUBMx8)\n * {@endvue}\n * {@angular}\n * **Coming soon!**\n * {@endangular}\n * {@endframeworktabs}\n *\n * Full information of the menu customization can be found in the \"Customizing the Event menu, the Schedule menu, and the TimeAxisHeader menu\" guide.\n *\n * This feature is **enabled** by default\n *\n * @extends Scheduler/feature/base/TimeSpanMenuBase\n * @demo Scheduler/eventmenu\n * @classtype eventMenu\n * @feature\n */\nexport default class EventMenu extends TimeSpanMenuBase {\n    //region Config\n    static get $name() {\n        return 'EventMenu';\n    }\n    /**\n     * @member {Object} menuContext\n     * An informational object containing contextual information about the last activation\n     * of the context menu. The base properties are listed below.\n     * @property {Event} menuContext.domEvent The initiating event.\n     * @property {Event} menuContext.event DEPRECATED: The initiating event.\n     * @property {Number[]} menuContext.point The client `X` and `Y` position of the initiating event.\n     * @property {HTMLElement} menuContext.targetElement The target to which the menu is being applied.\n     * @property {Object<String,MenuItemConfig>} menuContext.items The context menu **configuration** items.\n     * @property {Core.data.Model[]} menuContext.selection The record selection in the client (Grid, Scheduler, Gantt or Calendar).\n     * @property {Scheduler.model.EventModel} menuContext.eventRecord The event record clicked on.\n     * @property {Scheduler.model.ResourceModel} menuContext.resourceRecord The resource record clicked on.\n     * @property {Scheduler.model.AssignmentModel} menuContext.assignmentRecord The assignment record clicked on.\n     * @readonly\n     */\n    static get configurable() {\n        return {\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             * features         : {\n             *    eventMenu : {\n             *         processItems({ items, eventRecord, assignmentRecord, resourceRecord }) {\n             *             // Add or hide existing items here as needed\n             *             items.myAction = {\n             *                 text   : 'Cool action',\n             *                 icon   : 'b-fa b-fa-fw b-fa-ban',\n             *                 onItem : () => console.log(`Clicked ${eventRecord.name}`),\n             *                 weight : 1000 // Move to end\n             *             };\n             *\n             *            if (!eventRecord.allowDelete) {\n             *                 items.deleteEvent.hidden = true;\n             *             }\n             *         }\n             *     }\n             * },\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Scheduler.model.EventModel} context.eventRecord The record representing the current event\n             * @param {Scheduler.model.ResourceModel} context.resourceRecord The record representing the current resource\n             * @param {Scheduler.model.AssignmentModel} context.assignmentRecord The assignment record\n             * @param {Object<String,MenuItemConfig|Boolean>} context.items An object containing the\n             *   {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n             * @preventable\n             */\n            processItems : null,\n            type : 'event'\n            /**\n             * This is a preconfigured set of items used to create the default context menu. The default options are\n             * listed at the top of the page.\n             *\n             * To remove existing items, set corresponding keys `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventMenu : {\n             *             items : {\n             *                 deleteEvent   : null,\n             *                 unassignEvent : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * See the feature config in the above example for details.\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n        };\n    }\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n        config.chain.push('populateEventMenu');\n        return config;\n    }\n    //endregion\n    //region Events\n    /**\n     * This event fires on the owning Scheduler before the context menu is shown for an event. Allows manipulation of the items\n     * to show in the same way as in `processItems`. Returning `false` from a listener prevents the menu from\n     * being shown.\n     * @event eventMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     * @param {MouseEvent} [event] Pointer event which triggered the context menu (if any)\n     */\n    /**\n     * This event fires on the owning Scheduler when an item is selected in the context menu.\n     * @event eventMenuItem\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.MenuItem} item\n     * @param {Scheduler.model.EventModel} eventRecord\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n    /**\n     * This event fires on the owning Scheduler after showing the context menu for an event\n     * @event eventMenuShow\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n    //endregion\n    get resourceStore() {\n        // In horizontal mode, we use store (might be a display store), in vertical & calendar we use resourceStore\n        return this.client.isHorizontal ? this.client.store : this.client.resourceStore;\n    }\n    getDataFromEvent(event) {\n        const\n            data             = super.getDataFromEvent(event),\n            eventElement     = data.targetElement,\n            { client }       = this,\n            eventRecord      = client.resolveEventRecord(eventElement),\n            // For vertical mode the resource must be resolved from the event\n            resourceRecord   = eventRecord && (client.resolveResourceRecord(eventElement) || this.resourceStore.last)?.$original,\n            assignmentRecord = eventRecord && client.resolveAssignmentRecord(eventElement);\n        return Object.assign(data, {\n            date : client.getDateFromXY([event.pageX, event.pageY], null, false),\n            eventElement,\n            eventRecord,\n            resourceRecord,\n            assignmentRecord\n        });\n    }\n    getTargetElementFromEvent({ target }) {\n        return target.closest(this.client.eventSelector) || target;\n    }\n    shouldShowMenu(eventParams) {\n        return eventParams.eventRecord;\n    }\n    /**\n     * Shows context menu for the provided event. If record is not rendered (outside of time span/filtered)\n     * menu won't appear.\n     * @param {Scheduler.model.EventModel} eventRecord Event record to show menu for.\n     * @param {Object} [options]\n     * @param {HTMLElement} options.targetElement Element to align context menu to.\n     * @param {MouseEvent} options.event Browser event.\n     * If provided menu will be aligned according to clientX/clientY coordinates.\n     * If omitted, context menu will be centered to event element.\n     */\n    showContextMenuFor(eventRecord, { targetElement, event } = {}) {\n        if (this.disabled) {\n            return;\n        }\n        if (!targetElement) {\n            targetElement = this.getElementFromRecord(eventRecord);\n            // If record is not rendered, do nothing\n            if (!targetElement) {\n                return;\n            }\n        }\n        DomHelper.triggerMouseEvent(targetElement, this.triggerEvent);\n    }\n    getElementFromRecord(record) {\n        return this.client.getElementsFromEventRecord(record)[0];\n    }\n    populateEventMenu({ items, eventRecord, assignmentRecord }) {\n        const { client } = this;\n        items.deleteEvent = {\n            disabled : eventRecord.readOnly || assignmentRecord?.readOnly,\n            hidden   : client.readOnly\n        };\n        items.unassignEvent = {\n            disabled : eventRecord.readOnly || assignmentRecord?.readOnly,\n            hidden   : client.readOnly || client.eventStore.usesSingleAssignment\n        };\n        if (client.showEventColorPickers || client.showTaskColorPickers) {\n            items.eventColor = {\n                disabled : eventRecord.readOnly,\n                hidden   : client.readOnly\n            };\n        }\n        else {\n            items.eventColor = {\n                hidden : true\n            };\n        }\n    }\n    populateItemsWithData({ items, eventRecord }) {\n        super.populateItemsWithData(...arguments);\n        const { client } = this;\n        if ((client.showEventColorPickers || (client.isSchedulerPro && client.showTaskColorPickers)) &&\n            items.eventColor?.menu\n        ) {\n            Objects.merge(items.eventColor.menu.colorMenu, {\n                value  : eventRecord.eventColor,\n                record : eventRecord\n            });\n        }\n    }\n    // This generates the fixed, unchanging part of the items and is only called once\n    // to generate the baseItems of the feature.\n    // The dynamic parts which are set by populateEventMenu have this merged into them.\n    changeItems(items) {\n        const { client } = this;\n        return Objects.merge({\n            deleteEvent : {\n                text   : 'L{SchedulerBase.Delete event}',\n                icon   : 'b-icon b-icon-trash',\n                weight : 200,\n                onItem({ menu, eventRecord }) {\n                    // We must synchronously push focus back into the menu's triggering\n                    // event so that our beforeRemove handlers can move focus onwards\n                    // to the closest remaining event.\n                    // Otherwise, the menu's default hide processing on hide will attempt\n                    // to move focus back to the menu's triggering event which will\n                    // by then have been deleted.\n                    const revertTarget = menu.focusInEvent?.relatedTarget;\n                    if (revertTarget) {\n                        revertTarget.focus();\n                        client.navigator.activeItem = revertTarget;\n                    }\n                    client.removeEvents(client.isEventSelected(eventRecord) ? client.selectedEvents : [eventRecord]);\n                }\n            },\n            unassignEvent : {\n                text   : 'L{SchedulerBase.Unassign event}',\n                icon   : 'b-icon b-icon-unassign',\n                weight : 300,\n                onItem({ menu, eventRecord, resourceRecord }) {\n                    // We must synchronously push focus back into the menu's triggering\n                    // event so that our beforeRemove handlers can move focus onwards\n                    // to the closest remaining event.\n                    // Otherwise, the menu's default hide processing on hide will attempt\n                    // to move focus back to the menu's triggering event which will\n                    // by then have been deleted.\n                    const revertTarget = menu.focusInEvent?.relatedTarget;\n                    if (revertTarget) {\n                        revertTarget.focus();\n                        client.navigator.activeItem = revertTarget;\n                    }\n                    if (client.isEventSelected(eventRecord)) {\n                        client.assignmentStore.remove(client.selectedAssignments);\n                    }\n                    else {\n                        eventRecord.unassign(resourceRecord);\n                    }\n                }\n            },\n            eventColor : {\n                text      : 'L{SchedulerBase.color}',\n                icon      : 'b-icon b-icon-palette',\n                separator : true,\n                menu      : {\n                    colorMenu : {\n                        type : 'eventcolorpicker'\n                    }\n                }\n            }\n        }, items);\n    }\n}\nEventMenu.featureClass = '';\nEventMenu._$name = 'EventMenu'; GridFeatureManager.registerFeature(EventMenu, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventMenu, false, 'ResourceHistogram');\n", "import TimeSpanMenuBase from '../../Scheduler/feature/base/TimeSpanMenuBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n/**\n * @module Scheduler/feature/ScheduleMenu\n */\n/**\n * Displays a context menu for empty parts of the schedule. Items are populated in the first place\n * by configurations of this Feature, then by other features and/or application code.\n *\n * ### Default scheduler zone menu items\n *\n * The Scheduler menu feature provides only one item:\n *\n * | Reference              | Text         | Weight | Feature                                  | Description                                                           |\n * |------------------------|--------------|--------|------------------------------------------|-----------------------------------------------------------------------|\n * | `addEvent`             | Add event    | 100    | *This feature*                           | Add new event at the target time and resource. Hidden when read-only  |\n * | `pasteEvent`           | Paste event  | 110    | {@link Scheduler/feature/EventCopyPaste} | Paste event at the target time and resource. Hidden when is read-only |\n * | `splitSchedule`        | Split        | 200    | {@link Scheduler/feature/Split}          | Shows the \"Split schedule\" sub-menu                                   |\n * | \\> `splitHorizontally` | Horizontally | 100    | {@link Scheduler/feature/Split}          | Split horizontally                                                    |\n * | \\> `splitVertically `  | Vertically   | 200    | {@link Scheduler/feature/Split}          | Split vertically                                                      |\n * | \\> `splitBoth`         | Both         | 300    | {@link Scheduler/feature/Split}          | Split both ways                                                       |\n * | `unsplitSchedule`      | Split        | 210    | {@link Scheduler/feature/Split}          | Unsplit a previously split schedule                                   |\n *\n * ### Customizing the menu items\n *\n * The menu items in the Scheduler menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * Add extra item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             items : {\n *                 extraItem : {\n *                     text : 'Extra',\n *                     icon : 'b-fa b-fa-fw b-fa-flag',\n *                     onItem({date, resourceRecord, items}) {\n *                         // Custom date based action\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Remove existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             items : {\n *                 addEvent : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             items : {\n *                 addEvent : {\n *                     text : 'Create new booking'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Manipulate existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleMenu : {\n *             // Process items before menu is shown\n *             processItems({date, resourceRecord, items}) {\n *                  // Add an extra item for ancient times\n *                  if (date < new Date(2018, 11, 17)) {\n *                      items.modernize = {\n *                          text : 'Modernize',\n *                          ontItem({date}) {\n *                              // Custom date based action\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show menu for Sundays\n *                  if (date.getDay() === 0) {\n *                      return false;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">The `processItems` implementation my be an `async` function which `awaits` a result to\n * mutate the `items` object.</div>\n *\n * ## Video guides\n * {@frameworktabs}\n * {@react}\n * [@youtube](https://www.youtube.com/embed/ghWLmifpO_4)\n * {@endreact}\n * {@vue}\n * [@youtube](https://www.youtube.com/embed/HAq12QUBMx8)\n * {@endvue}\n * {@angular}\n * **Coming soon!**\n * {@endangular}\n * {@endframeworktabs}\n *\n * Full information of the menu customization can be found in the \"Customizing the Event menu, the Schedule menu, and the TimeAxisHeader menu\" guide.\n *\n * This feature is **enabled** by default\n *\n * @demo Scheduler/basic\n * @extends Scheduler/feature/base/TimeSpanMenuBase\n * @classtype scheduleMenu\n * @feature\n */\nexport default class ScheduleMenu extends TimeSpanMenuBase {\n    //region Config\n    static get $name() {\n        return 'ScheduleMenu';\n    }\n    static get defaultConfig() {\n        return {\n            type : 'schedule',\n            /**\n             * This is a preconfigured set of items used to create the default context menu.\n             *\n             * The `items` provided by this feature are listed below. These are the predefined property names which you may\n             * configure:\n             *\n             * - `addEvent` Add an event for at the resource and time indicated by the `contextmenu` event.\n             *\n             * To remove existing items, set corresponding keys `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         scheduleMenu : {\n             *             items : {\n             *                 addEvent : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n            items : null,\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             * features         : {\n             *    scheduleMenu : {\n             *         processItems({ items, date, resourceRecord }) {\n             *            // Add or hide existing items here as needed\n             *            items.myAction = {\n             *                text   : 'Cool action',\n             *                icon   : 'b-fa b-fa-cat',\n             *                onItem : () => console.log(`Clicked on ${resourceRecord.name} at ${date}`),\n             *                weight : 1000 // Move to end\n             *            };\n             *\n             *            if (!resourceRecord.allowAdd) {\n             *                items.addEvent.hidden = true;\n             *            }\n             *        }\n             *    }\n             * },\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Scheduler.model.ResourceModel} context.resourceRecord The record representing the current resource\n             * @param {Date} context.date The clicked date\n             * @param {Object<String,MenuItemConfig|Boolean>} context.items An object containing the\n             *   {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n             * @preventable\n             */\n            processItems : null\n        };\n    }\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n        config.chain.push('populateScheduleMenu');\n        return config;\n    }\n    //endregion\n    //region Events\n    /**\n     * This event fires on the owning Scheduler or Gantt widget before the context menu is shown for the schedule. Allows manipulation of the items\n     * to show in the same way as in `processItems`. Returning `false` from a listener prevents the menu from\n     * being shown.\n     * @event scheduleMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Scheduler.model.EventModel} eventRecord Event record for which the menu was triggered\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record\n     * @param {Date} date Clicked date, rounded according to viewPreset's settings\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord Assignment record, if assignments are used\n     * @param {HTMLElement} eventElement\n     */\n    /**\n     * This event fires on the owning Scheduler or Gantt widget when an item is selected in the context menu.\n     * @event scheduleMenuItem\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Core.widget.MenuItem} item\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Date} date Clicked date, rounded according to viewPreset's settings\n     * @param {HTMLElement} element\n     */\n    /**\n     * This event fires on the owning Scheduler or Gantt widget after showing the context menu for the schedule.\n     * @event scheduleMenuShow\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Date} date Clicked date, rounded according to viewPreset's settings\n     * @param {HTMLElement} targetElement\n     */\n    //endregion\n    shouldShowMenu(eventParams) {\n        const\n            { client } = this,\n            {\n                targetElement,\n                resourceRecord\n            } = eventParams,\n            isTimeAxisColumn = client.timeAxisSubGridElement.contains(targetElement);\n        return !targetElement.closest(client.eventSelector) && isTimeAxisColumn && !(resourceRecord && resourceRecord.isSpecialRow);\n    }\n    getDataFromEvent(event) {\n        // Process event if it wasn't yet processed\n        if (DomHelper.isDOMEvent(event)) {\n            const\n                { client }     = this,\n                cellData       = client.getCellDataFromEvent?.(event),\n                date           = client.getDateFromDomEvent?.(event, 'floor'),\n                // For vertical mode the resource must be resolved from the event\n                resourceRecord = client.resolveResourceRecord(event) || client.isVertical && client.resourceStore.last;\n            return ObjectHelper.assign(super.getDataFromEvent(event), cellData, { date, resourceRecord });\n        }\n        return event;\n    }\n    populateScheduleMenu({ items, resourceRecord, date }) {\n        const { client } = this;\n        // Menu can work for ResourceHistogram which doesn't have event store\n        if (!client.readOnly && client.eventStore) {\n            items.addEvent = {\n                text     : 'L{SchedulerBase.Add event}',\n                icon     : 'b-icon b-icon-add',\n                disabled : !resourceRecord || resourceRecord.readOnly || !resourceRecord.isWorkingTime(date),\n                weight   : 100,\n                onItem() {\n                    client.createEvent(date, resourceRecord, client.getRowFor(resourceRecord));\n                }\n            };\n        }\n    }\n}\nScheduleMenu.featureClass = '';\nScheduleMenu._$name = 'ScheduleMenu'; GridFeatureManager.registerFeature(ScheduleMenu, true, 'Scheduler');\n"],
  "mappings": "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",
  "names": ["preset", "increment", "_a", "_a", "_a", "_a", "Header", "Header", "maintainVisibleStart", "_a", "_a", "resourceRecord", "_a", "eventStyle", "eventColor", "_a", "defaultScrollOptions", "copyProperties", "args", "assignments", "emptyObject", "_a", "_a", "releaseEventActions", "renderEventActions", "chronoFields", "emptyObject", "record", "_a", "_a"]
}
