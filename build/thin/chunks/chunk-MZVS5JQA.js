/*!
 *
 * Bryntum TaskBoard 5.6.2
 *
 * Copyright(c) 2023 Bryntum AB
 * https://bryntum.com/contact
 * https://bryntum.com/license
 *
 */
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// ../Core/lib/Core/helper/BrowserHelper.js
var _a;
var BrowserHelper = class {
  static cacheFlags(platform = navigator.platform, userAgent = navigator.userAgent) {
    const me = this;
    me._isLinux = Boolean(platform.match(/Linux/));
    me._isMac = Boolean(platform.match(/Mac/));
    me._isWindows = Boolean(platform.match(/Win32/));
    me._isMobile = Boolean(userAgent.match(/Mobile|Opera Mini|Opera Mobi|Puffin/) || typeof globalThis.orientation === "number");
    me._isWebkit = Boolean(userAgent.match(/WebKit/) && !userAgent.match(/Edg/));
    me._firefoxVersion = me.getVersion(userAgent, /Firefox\/(\d+)\./);
    me._isFirefox = me._firefoxVersion > 0;
    me._chromeVersion = me.getVersion(userAgent, /Chrom(?:e|ium)\/(\d+)\./);
    me._isChrome = me._chromeVersion > 0;
    me._isSafari = Boolean(userAgent.match(/Safari/)) && !me._isChrome;
    me._isMobileSafari = Boolean(userAgent.match(/Mobile.*Safari/));
    me._safariVersion = me.getVersion(userAgent, /Version\/(.*).Safari/);
    me._isAndroid = Boolean(userAgent.match(/Android/g));
  }
  //endregion
  //region Device
  /**
   * Yields `true` if the current browser supports CSS style `overflow:clip`.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get supportsOverflowClip() {
    if (this._supportsOverflowClip == null) {
      const div = document.createElement("div");
      div.style.overflow = "clip";
      div.style.display = "none";
      document.documentElement.appendChild(div);
      this._supportsOverflowClip = div.ownerDocument.defaultView.getComputedStyle(div).getPropertyValue("overflow") === "clip";
      div.remove();
    }
    return this._supportsOverflowClip;
  }
  /**
   * Yields `true` if the current browser supports CSS style `position:sticky`.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get supportsSticky() {
    return true;
  }
  /**
   * Returns matched version for userAgent.
   * @param {String} versionRe version match regular expression
   * @returns {Number} matched version
   * @readonly
   * @internal
   */
  static getVersion(userAgent, versionRe) {
    const match = userAgent.match(versionRe);
    return match ? parseFloat(match[1]) : 0;
  }
  /**
   * Determines if the user is using a touch device.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get isTouchDevice() {
    if (this._isTouchDevice === void 0) {
      this._isTouchDevice = globalThis.matchMedia("(pointer:coarse)").matches;
    }
    return this._isTouchDevice;
  }
  // Reports true by default for our tests
  static get isHoverableDevice() {
    if (this._isHoverableDevice === void 0) {
      this._isHoverableDevice = globalThis.matchMedia("(any-hover: hover)").matches;
    }
    return this._isHoverableDevice;
  }
  //endregion
  //region Platform
  static get isBrowserEnv() {
    return typeof window !== "undefined";
  }
  /**
   * Checks if platform is Mac.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isMac() {
    return this._isMac;
  }
  /**
   * Checks if platform is Windows.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isWindows() {
    return this._isWindows;
  }
  /**
   * Checks if platform is Linux.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isLinux() {
    return this._isLinux;
  }
  /**
   * Checks if platform is Android.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isAndroid() {
    return this._isAndroid;
  }
  //endregion
  //region Browser
  /**
   * Checks if browser is Webkit.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isWebkit() {
    return this._isWebkit;
  }
  /**
   * Checks if browser is Chrome or Chromium based browser.
   * Returns truthy value for Edge Chromium.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isChrome() {
    return this._isChrome;
  }
  /**
   * Returns the major Chrome version or 0 for other browsers.
   * @property {Number}
   * @readonly
   * @category Browser
   */
  static get chromeVersion() {
    return this._chromeVersion;
  }
  /**
   * Checks if browser is Firefox.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isFirefox() {
    return this._isFirefox;
  }
  /**
   * Returns the major Firefox version or 0 for other browsers.
   * @property {Number}
   * @readonly
   * @category Browser
   */
  static get firefoxVersion() {
    return this._firefoxVersion;
  }
  /**
   * Checks if browser is Safari.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isSafari() {
    return this._isSafari;
  }
  static get safariVersion() {
    return this._safariVersion;
  }
  /**
   * Checks if browser is mobile Safari
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isMobileSafari() {
    return this._isMobileSafari;
  }
  /**
   * Checks if the active device is a mobile device
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isMobile() {
    return this._isMobile;
  }
  static get platform() {
    const me = this;
    return me._isLinux ? "linux" : me._isMac ? "mac" : me._isWindows ? "windows" : me._isAndroid ? "android" : me._isMobileSafari ? "ios" : null;
  }
  /**
   * Returns `true` if the browser supports passive event listeners.
   * @property {Boolean}
   * @internal
   * @deprecated Since 5.0. All modern browsers now support passive event listeners.
   * @category Browser
   */
  static get supportsPassive() {
    return true;
  }
  // Only works in secure contexts
  static get supportsRandomUUID() {
    if (this._supportsRandomUUID === void 0) {
      try {
        this._supportsRandomUUID = Boolean(globalThis.crypto.randomUUID().length > 0);
      } catch (e) {
        this._supportsRandomUUID = false;
      }
    }
    return this._supportsRandomUUID;
  }
  //endregion
  //region Storage
  // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API
  static get storageAvailable() {
    let storage, x;
    try {
      storage = localStorage;
      x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && // everything except Firefox
      (e.code === 22 || // Firefox
      e.code === 1014 || // test name field too, because code might not be present
      // everything except Firefox
      e.name === "QuotaExceededError" || // Firefox
      e.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
      storage.length !== 0;
    }
  }
  static setLocalStorageItem(key, value) {
    this.storageAvailable && localStorage.setItem(key, value);
  }
  static getLocalStorageItem(key) {
    return this.storageAvailable && localStorage.getItem(key);
  }
  static removeLocalStorageItem(key) {
    this.storageAvailable && localStorage.removeItem(key);
  }
  //endregion
  //region Helpers
  /**
   * Returns parameter value from search string by parameter name.
   * @param {String} paramName search parameter name
   * @param {String} [defaultValue] default value if parameter not found
   * @param {String} [search] search string. Defaults to `document.location.search`
   * @returns {String} search parameter string value
   * @category Helper
   */
  static searchParam(paramName, defaultValue2 = null, search = document.location.search) {
    const re = new RegExp(`[?&]${paramName}=?([^&]*)`), match = search.match(re);
    return match && match[1] || defaultValue2;
  }
  /**
   * Returns cookie by name.
   * @param {String} name cookie name
   * @returns {String} cookie string value
   * @category Helper
   */
  static getCookie(name) {
    const nameEq = encodeURIComponent(name) + "=", cookieItems = document.cookie.split(";");
    for (let i = 0; i < cookieItems.length; i++) {
      let c = cookieItems[i];
      while (c.charAt(0) === " ") {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEq) === 0) {
        return decodeURIComponent(c.substring(nameEq.length, c.length));
      }
    }
    return "";
  }
  /**
   * Triggers a download of a file with the specified name / URL.
   * @param {String} filename The filename of the file to be downloaded
   * @param {String} [url] The URL where the file is to be downloaded from
   * @internal
   * @category Download
   */
  static download(filename, url) {
    const a = document.createElement("a");
    a.download = filename;
    a.href = url || filename;
    a.style.cssText = "display:none";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }
  /**
   * Triggers a download of a Blob with the specified name.
   * @param {Blob} blob The Blob to be downloaded
   * @param {String} filename The filename of the file to be downloaded
   * @internal
   * @category Download
   */
  static downloadBlob(blob, filename) {
    const url = globalThis.URL.createObjectURL(blob);
    this.download(filename, url);
    globalThis.URL.revokeObjectURL(url);
  }
  static get queryString() {
    var _a2;
    const params = new URL(globalThis.location.href).searchParams;
    return (_a2 = Object.fromEntries) == null ? void 0 : _a2.call(Object, params.entries());
  }
  // Used by docs fiddle
  static copyToClipboard(code) {
    let success = true;
    const textArea = document.createElement("textarea");
    textArea.value = code;
    textArea.style.height = textArea.style.width = 0;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand("copy");
    } catch (e) {
      success = false;
    }
    textArea.remove();
    return success;
  }
  static isBryntumOnline(searchStrings) {
    searchStrings = Array.isArray(searchStrings) ? searchStrings : [searchStrings];
    return Boolean(/^(www\.)?bryntum\.com/.test(globalThis.location.host) || (searchStrings == null ? void 0 : searchStrings.some((str) => this.queryString[str] != null)));
  }
  /**
   * Returns truthy value if page contains Content Security Policy meta tag or globalThis.bryntum.CSP is truthy value
   * @returns {Boolean}
   * @internal
   **/
  static get isCSP() {
    const { bryntum, document: document2 } = globalThis;
    if (bryntum.CSP == null) {
      bryntum.CSP = Boolean(document2.querySelector('meta[http-equiv="Content-Security-Policy"]'));
    }
    return bryntum.CSP;
  }
  //endregion
};
__publicField(BrowserHelper, "supportsPointerEvents", Boolean(globalThis.PointerEvent || globalThis.MSPointerEvent));
// Locker Service does not allow to instantiate PointerEvents. LWS apparently does, however.
// https://github.com/bryntum/support/issues/5578
__publicField(BrowserHelper, "supportsPointerEventConstructor", typeof PointerEvent !== "undefined");
__publicField(BrowserHelper, "PointerEventConstructor", globalThis.PointerEvent || globalThis.CustomEvent);
//region Init
/**
 * Yields `true` if the platform running is a phone (screen width or height <= 414 CSS pixels)
 * @property {Boolean}
 * @readonly
 * @static
 * @category Platform
 */
__publicField(BrowserHelper, "isPhone", (_a = globalThis.matchMedia) == null ? void 0 : _a.call(globalThis, "(max-height:414px) or (max-width:414px)").matches);
if (BrowserHelper.isBrowserEnv) {
  BrowserHelper.cacheFlags();
}
BrowserHelper._$name = "BrowserHelper";

// ../Core/lib/Core/helper/util/Objects.js
var { hasOwnProperty: hasOwnProperty2, toString } = Object.prototype;
var { isFrozen } = Object;
var afterRe = /\s*<\s*/;
var beforeRe = /\s*>\s*/;
var blendOptions = {};
var typeCache = {};
var emptyObject = Object.freeze({});
var Objects = class _Objects {
  static assign(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          dest[key] = source[key];
        }
      }
    }
    return dest;
  }
  static assignIf(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          if (!(key in dest) || dest[key] === void 0) {
            dest[key] = source[key];
          }
        }
      }
    }
    return dest;
  }
  static blend(dest, source, options) {
    options = options || blendOptions;
    dest = dest || {};
    const { clone = _Objects.clone, merge = _Objects.blend } = options;
    if (Array.isArray(source)) {
      if (source.length > 1) {
        source.forEach((s) => {
          dest = _Objects.blend(dest, s, options);
        });
        return dest;
      }
      source = source[0];
    }
    if (source) {
      let destValue, key, value;
      for (key in source) {
        value = source[key];
        if (value && _Objects.isObject(value)) {
          destValue = dest[key];
          options.key = key;
          if (destValue && _Objects.isObject(destValue)) {
            if (isFrozen(destValue)) {
              dest[key] = destValue = clone(destValue, options);
            }
            value = merge(destValue, value, options);
          } else {
            value = isFrozen(value) ? value : clone(value, options);
          }
        }
        dest[key] = value;
      }
    }
    return dest;
  }
  static clone(value, handler) {
    let cloned = value, key;
    if (value && typeof value === "object") {
      const options = handler && typeof handler === "object" && handler;
      if (options) {
        handler = null;
      }
      if (_Objects.isObject(value)) {
        if (value.skipClone) {
          cloned = value;
        } else {
          cloned = {};
          for (key in value) {
            cloned[key] = _Objects.clone(value[key]);
          }
        }
      } else if (Array.isArray(value)) {
        cloned = [];
        for (key = value.length; key-- > 0; ) {
          cloned[key] = _Objects.clone(value[key]);
        }
      } else if (_Objects.isDate(value)) {
        cloned = new Date(value.getTime());
      } else if (handler) {
        cloned = handler(value);
      }
    }
    return cloned;
  }
  static createTruthyKeys(source) {
    const keys = StringHelper.split(source), result = keys && {};
    if (keys) {
      for (const key of keys) {
        if (key) {
          result[key] = true;
        }
      }
    }
    return result;
  }
  /**
   * Returns value for a given path in the object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {*} Value associated with passed key
   */
  static getPath(object, path) {
    return path.split(".").reduce((result, key) => {
      return (result || emptyObject)[key];
    }, object);
  }
  /**
   * Returns value for a given path in the object, placing a passed default value in at the
   * leaf property and filling in undefined properties all the way down.
   * @param {Object} object Object to get path value for.
   * @param {String|Number|String[]|Number[]} path Dot-separated path, e.g. 'firstChild.childObject.someKey',
   * or the key path as an array, e.g. ['firstChild', 'childObject', 'someKey'].
   * @param {*} [defaultValue] Optionally the value to put in as the `someKey` property.
   * @returns {*} Value at the leaf position of the path.
   */
  static getPathDefault(object, path, defaultValue2) {
    const keys = Array.isArray(path) ? path : typeof path === "string" ? path.split(".") : [path], length = keys.length - 1;
    return keys.reduce((result, key, index) => {
      if (defaultValue2 && !(key in result)) {
        result[key] = index === length ? defaultValue2 : {};
      }
      return (result || emptyObject)[key];
    }, object);
  }
  /**
   * Determines if the specified path exists
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {Boolean}
   */
  static hasPath(object, path) {
    return path.split(".").every((key) => {
      if (object && key in object) {
        object = object[key];
        return true;
      }
      return false;
    });
  }
  static getTruthyKeys(source) {
    const keys = [];
    for (const key in source) {
      if (source[key]) {
        keys.push(key);
      }
    }
    return keys;
  }
  static getTruthyValues(source) {
    const values = [];
    for (const key in source) {
      if (source[key]) {
        values.push(source[key]);
      }
    }
    return values;
  }
  static isClass(object) {
    var _a2;
    if (typeof object === "function" && ((_a2 = object.prototype) == null ? void 0 : _a2.constructor) === object) {
      return true;
    }
    return false;
  }
  static isDate(object) {
    return Boolean(object == null ? void 0 : object.getUTCDate) && _Objects.typeOf(object) === "date";
  }
  /**
   * Check if passed object is a Promise or contains `then` method.
   * Used to fix problems with detecting promises in code with `instance of Promise` when
   * Promise class is replaced with any other implementation like `ZoneAwarePromise` in Angular.
   * Related to these issues:
   * https://github.com/bryntum/support/issues/791
   * https://github.com/bryntum/support/issues/2990
   *
   * @param {Object} object object to check
   * @returns {Boolean} truthy value if object is a Promise
   * @internal
   */
  static isPromise(object) {
    if (Promise && Promise.resolve) {
      return Promise.resolve(object) === object || typeof (object == null ? void 0 : object.then) === "function";
    }
    throw new Error("Promise not supported in your environment");
  }
  static isEmpty(object) {
    if (object && typeof object === "object") {
      for (const p in object) {
        return false;
      }
    }
    return true;
  }
  static isObject(value) {
    const C = value == null ? void 0 : value.constructor;
    return Boolean(
      C ? (
        // An in-frame instance of Object
        C === Object || // Detect cross-frame objects, but exclude instance of custom classes named Object. typeOf(value) is
        // "object" even for instances of a class and typeOf(C) is "function" for all constructors. We'll have
        // to settle for relying on the fact that getPrototypeOf(Object.prototype) === null.
        // NOTE: this issue does come up in Scheduler unit tests at least.
        C.getPrototypeOf && C.prototype && !Object.getPrototypeOf(C.prototype)
      ) : value && typeof value === "object"
    );
  }
  static isInstantiated(object) {
    return object ? typeof object === "object" && !_Objects.isObject(object) : false;
  }
  static merge(dest, ...sources) {
    return _Objects.blend(dest, sources);
  }
  /**
   * Merges two "items" objects. An items object is a simple object whose keys act as identifiers and whose values
   * are "item" objects. An item can be any object type. This method is used to merge such objects while maintaining
   * their property order. Special key syntax is used to allow a source object to insert a key before or after a key
   * in the `dest` object.
   *
   * For example:
   * ```javascript
   *  let dest = {
   *      foo : {},
   *      bar : {},
   *      fiz : {}
   *  }
   *
   *  console.log(Object.keys(dest));
   *  > ["foo", "bar", "fiz"]
   *
   *  dest = mergeItems(dest, {
   *      'zip > bar' : {}    // insert "zip" before "bar"
   *      'bar < zap' : {}    // insert "zap" after "bar"
   *  });
   *
   *  console.log(Object.keys(dest));
   *  > ["foo", "zip", "bar", "zap", "fiz"]
   * ```
   *
   * @param {Object} dest The destination object.
   * @param {Object|Object[]} src The source object or array of source objects to merge into `dest`.
   * @param {Object} [options] The function to use to merge items.
   * @param {Function} [options.merge] The function to use to merge items.
   * @returns {Object} The merged object. This will be the `dest` object.
   * @internal
   */
  static mergeItems(dest, src, options) {
    options = options || blendOptions;
    let anchor, delta, index, indexMap, key, shuffle, srcVal;
    const { merge = _Objects.blend } = options;
    dest = dest || {};
    if (Array.isArray(src)) {
      src.forEach((s) => {
        dest = _Objects.mergeItems(dest, s, options);
      });
    } else if (src) {
      for (key in src) {
        srcVal = src[key];
        anchor = null;
        if (key.includes(">")) {
          [key, anchor] = key.split(beforeRe);
          delta = 0;
        } else if (key.includes("<")) {
          [anchor, key] = key.split(afterRe);
          delta = 1;
        }
        if (key in dest) {
          if (srcVal && dest[key] && merge) {
            options.key = key;
            srcVal = merge(dest[key], srcVal, options);
          }
          dest[key] = srcVal;
        } else if (!anchor) {
          dest[key] = srcVal;
          indexMap == null ? void 0 : indexMap.set(key, indexMap.size);
        } else {
          if (!indexMap) {
            indexMap = /* @__PURE__ */ new Map();
            index = 0;
            for (const k in dest) {
              indexMap.set(k, index++);
            }
          }
          index = indexMap.get(anchor);
          dest[key] = srcVal;
          if (index == null && delta) {
            index = indexMap.size;
          } else {
            shuffle = shuffle || [];
            index = (index || 0) + delta;
            for (const item of indexMap) {
              const [k, v] = item;
              if (index <= v) {
                shuffle && (shuffle[indexMap.size - v - 1] = k);
                indexMap.set(k, v + 1);
              }
            }
            if (shuffle) {
              while (shuffle.length) {
                const k = shuffle.pop(), v = dest[k];
                delete dest[k];
                dest[k] = v;
              }
            }
          }
          indexMap.set(key, index);
        }
      }
    }
    return dest;
  }
  /**
   * Sets value for a given path in the object
   * @param {Object} object Target object
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @param {*} value Value for a given path
   * @returns {Object} Returns passed object
   */
  static setPath(object, path, value) {
    path.split(".").reduce((result, key, index, array) => {
      const isLast = index === array.length - 1;
      if (isLast) {
        return result[key] = value;
      } else if (!(result[key] instanceof Object)) {
        result[key] = {};
      }
      return result[key];
    }, object);
    return object;
  }
  static typeOf(value) {
    let trueType, type;
    if (value === null) {
      type = "null";
    } else if (value !== value) {
      type = "nan";
    } else {
      type = typeof value;
      if (type === "object") {
        if (value.isBase) {
          type = "instance";
        } else if (Array.isArray(value)) {
          type = "array";
        } else if (!(type = typeCache[trueType = toString.call(value)])) {
          typeCache[trueType] = type = trueType.slice(8, -1).toLowerCase();
        }
      } else if (type === "function" && value.isBase) {
        type = "class";
      }
    }
    return type;
  }
};
Object.defineProperty(Objects, "hasOwn", {
  // When available, this avoids an extra layer of function call around it:
  value: Object.hasOwn || ((object, property) => hasOwnProperty2.call(object, property))
});
Objects._$name = "Objects";

// ../Core/lib/Core/helper/StringHelper.js
var charsToEncode;
var entitiesToDecode;
var htmlEncodeRe;
var htmlDecodeRe;
var camelLettersRe = /([a-z])([A-Z])/g;
var crlfRe = /[\n\r]/g;
var escapeRegExpRe = /[.*+?^${}()|[\]\\]/g;
var htmlRe = /[&<]/;
var idRe = /(^[^a-z]+[^\w]+)/gi;
var whiteSpaceRe = /\s+/;
var domIdRe = /^[^a-z]+|[^\w:.-]+/gi;
var htmlDecoder = (m, captured) => entitiesToDecode[captured.toLowerCase()] || String.fromCharCode(parseInt(captured.substr(2), 10));
var htmlEncoder = (m, captured) => charsToEncode[captured];
var hyphenateCamelLetters = (all, g1, g2) => {
  return `${g1}-${g2.toLowerCase()}`;
};
var separateCamelLetters = (all, g1, g2) => {
  return `${g1} ${g2.toLowerCase()}`;
};
var replaceNonIdChar = (c) => {
  if (c) {
    return `_x${[...c].map((ch) => ch.charCodeAt(0).toString(16)).join("")}`;
  }
  return "__blank__";
};
var hyphenateCache = {};
var separatedCache = {};
var ancestors = [];
var circularReplacer = function(key, value) {
  if (value && typeof value === "object") {
    while (ancestors.length && ancestors[ancestors.length - 1] !== this) {
      ancestors.pop();
    }
    if (ancestors.includes(value)) {
      return "[Circular]";
    }
    ancestors.push(value);
  }
  return value;
};
var _StringHelper = class _StringHelper {
  //region Transform
  /**
   * Capitalizes the first letter of a string, "myString" -> "MyString".
   * @param {String} string The string to capitalize
   * @returns {String} The capitalized string or the value of `string` if falsy.
   * @category String formatting
   */
  static capitalize(string) {
    return string && string[0].toUpperCase() + string.substr(1);
  }
  /**
   * Makes the first letter of a string lowercase, "MyString" -> "myString".
   * @param {String} string The string to un-capitalize.
   * @returns {String} The un-capitalized string or the value of `string` if falsy.
   * @category String formatting
   */
  static uncapitalize(string) {
    return string && string[0].toLowerCase() + string.substr(1);
  }
  /**
   * Converts the passed camelCased string to a hyphen-separated string. eg "minWidth" -> "min-width"
   * @param {String} string The string to convert.
   * @returns {String} The string with adjoining lower and upper case letters
   * separated by hyphens and converted to lower case.
   * @category String formatting
   * @internal
   */
  static hyphenate(string) {
    const cached = hyphenateCache[string];
    if (cached) {
      return cached;
    }
    return hyphenateCache[string] = string.replace(camelLettersRe, hyphenateCamelLetters);
  }
  /**
   * Converts the passed camelCased string to a capitalized, space-separated string. eg "startDate" -> "Start date".
   * @param {String} string The string to convert.
   * @returns {String} The string with spaces separating words.
   * @category String formatting
   * @internal
   */
  static separate(string) {
    const cached = separatedCache[string];
    if (cached) {
      return cached;
    }
    return separatedCache[string] = this.capitalize(string.replace(camelLettersRe, separateCamelLetters));
  }
  /**
   * Creates an alphanumeric identifier from any passed string. Encodes spaces and non-alpha characters.
   * @param {String} inString The string from which to strip non-identifier characters.
   * @returns {String}
   * @category Misc
   * @internal
   */
  static createId(inString) {
    return String(inString).replace(idRe, replaceNonIdChar);
  }
  static makeValidDomId(id, replaceValue = "") {
    if (id == null) {
      return null;
    }
    return String(id).replace(domIdRe, replaceValue);
  }
  //endregion
  //region Html
  /**
   * Escapes special RegExp characters.
   * @param {String} string String to escape
   * @privateparam {String} [flags] Optional flags
   * @returns {String} Escaped string
   */
  static escapeRegExp(string, flags) {
    let ret = string.replace(escapeRegExpRe, "\\$&");
    if (flags !== void 0) {
      ret = new RegExp(ret, flags);
    }
    return ret;
  }
  /**
   * This method decodes HTML entities and returns the original HTML.
   *
   * See also {@link #function-encodeHtml-static}.
   * @param {String} str
   * @returns {String}
   * @category HTML
   */
  static decodeHtml(str) {
    return str && String(str).replace(htmlDecodeRe, htmlDecoder);
  }
  /**
   * This method encodes HTML entities and returns a string that can be placed in the document and produce the
   * original text rather than be interpreted as HTML. Using this method with user-entered values prevents those
   * values from executing as HTML (i.e., a cross-site scripting or "XSS" security issue).
   *
   * See also {@link #function-decodeHtml-static}.
   * @param {String|Number} str
   * @returns {String}
   * @category HTML
   */
  static encodeHtml(str = "") {
    return str && String(str).replace(htmlEncodeRe, htmlEncoder);
  }
  /**
   * This method is similar to {@link #function-encodeHtml-static} except that `\n` and `\r` characters in the
   * given `str` are replaced by `<br>` tags _after_ first being encoded by {@link #function-encodeHtml-static}.
   * @param {String} str
   * @returns {String}
   * @category HTML
   * @internal
   */
  static encodeHtmlBR(str) {
    var _a2;
    return (_a2 = _StringHelper.encodeHtml(str)) == null ? void 0 : _a2.replace(crlfRe, "<br>");
  }
  /**
   * Returns `true` if the provided `text` contains special HTML characters.
   * @param {String} text
   * @returns {Boolean}
   * @category HTML
   * @internal
   */
  static isHtml(text) {
    return typeof text === "string" && htmlRe.test(text || "");
  }
  /**
   * Initializes HTML entities used by {@link #function-encodeHtml-static} and {@link #function-decodeHtml-static}.
   * @param {Object} [mappings] An object whose keys are characters that should be encoded and values are the HTML
   * entity for the character.
   * @private
   */
  static initHtmlEntities(mappings) {
    mappings = mappings || {
      "&": "&amp;",
      ">": "&gt;",
      "<": "&lt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    const chars = Object.keys(mappings);
    charsToEncode = mappings;
    entitiesToDecode = chars.reduce((prev, val) => {
      prev[mappings[val]] = val;
      return prev;
    }, {});
    htmlEncodeRe = new RegExp(`([${chars.map((c) => "[-]".includes(c) ? "\\" + c : c).join("")}])`, "g");
    htmlDecodeRe = new RegExp(`(${Object.values(mappings).join("|")}|&#[0-9]+;)`, "ig");
  }
  //endregion
  //region JSON
  /**
   * Parses JSON inside a try-catch block. Returns null if the string could not be parsed.
   *
   * @param {String} string String to parse
   * @returns {Object} Resulting object or `null` if parse failed
   * @category JSON
   */
  static safeJsonParse(string) {
    let parsed = null;
    try {
      parsed = JSON.parse(string);
    } catch (e) {
    }
    return parsed;
  }
  /**
   * Stringifies an object inside a try-catch block. Returns null if an exception is encountered.
   *
   * See [JSON.stringify on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)
   * for more information on the arguments.
   *
   * @param {Object} object The object to stringify
   * @param {Function|'circular'|String[]|Number[]} [replacer] A function or array of string/number used to determine
   * properties to include in the JSON string. Also accepts the string 'circular' to use a built-in replacer handling
   * circular references, by replacing them with `'[Circular]'`.
   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value) for more
   * information.
   * @param {String|Number} [space] Number of spaces to indent or string used as whitespace
   * @returns {String} Resulting object or null if stringify failed
   * @category JSON
   */
  static safeJsonStringify(object, replacer = null, space = null) {
    let result = null;
    try {
      if (replacer === "circular") {
        ancestors.length = 0;
        replacer = circularReplacer;
      }
      result = JSON.stringify(object, replacer, space);
    } catch (e) {
    }
    return result;
  }
  //endregion
  //region Split & join
  /**
   * Joins all given paths together using the separator as a delimiter and normalizes the resulting path.
   * @param paths {Array} array of paths to join
   * @param pathSeparator [{String}] path separator. Default value is '/'
   * @returns {String}
   * @category Misc
   * @internal
   */
  static joinPaths(paths, pathSeparator = "/") {
    return paths.join(pathSeparator).replace(new RegExp("\\" + pathSeparator + "+", "g"), pathSeparator);
  }
  /**
   * Returns the provided string split on whitespace. If the string is empty or consists of only whitespace, the
   * returned array will be empty. If `str` is not a string, it is simply returned. This allows `null` or already
   * split strings (arrays) to be passed through.
   *
   * For example:
   * ```
   *  console.log(StringHelper.split(' abc def xyz   '));
   *  > ['abc', 'def', 'xyz']
   *  console.log(StringHelper.split(''));
   *  > []
   * ```
   * Compare to the standard `split()` method:
   * ```
   *  console.log(' abc def xyz   '.split(/\s+/));
   *  > ['', 'abc', 'def', 'xyz', '']
   *  console.log(''.split(/\s+/));
   *  > ['']
   * ```
   * @param {String} str
   * @param {String|RegExp} delimiter
   * @returns {String[]}
   * @category Misc
   * @internal
   */
  static split(str, delimiter = whiteSpaceRe) {
    let ret = str;
    if (typeof ret === "string") {
      ret = str.trim();
      ret = ret ? ret.split(delimiter) : [];
    }
    return ret;
  }
  //endregion
  //region XSS
  /**
   * This is a tagged template function that performs HTML encoding on replacement values to avoid XSS (Cross-Site
   * Scripting) attacks.
   *
   * For example:
   *
   * ```javascript
   *  eventRenderer(eventRecord) {
   *      return StringHelper.xss`<span class="${eventRecord.attrib}">${eventRecord.name}</span>`;
   *  }
   * ```
   *
   * @param {TemplateStringsArray} strings The template string array
   * @param {...any} values The interpolated values in the template string
   * @returns {String} The encoded string
   * See {@link Core.helper.StringHelper#function-encodeHtml-static}.
   */
  static xss(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + _StringHelper.encodeHtml(values[i]);
    }
    return buf.join("");
  }
  /**
   * This is a tagged template function that performs HTML encoding on replacement values to avoid XSS (Cross-Site
   * Scripting) attacks. Unlike {@link Core.helper.StringHelper#function-xss-static}, this method converts `\n` and
   * `\r` characters into `<br>` tags.
   *
   * For example:
   *
   * ```javascript
   *  eventRenderer(eventRecord) {
   *      return StringHelper.xssBR`<span class="${eventRecord.attrib}">${eventRecord.name}</span>`;
   *  }
   * ```
   *
   * See {@link Core.helper.StringHelper#function-encodeHtmlBR-static}.
   * @internal
   */
  static xssBR(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + _StringHelper.encodeHtmlBR(values[i]);
    }
    return buf.join("");
  }
  //endregion
  //region JavaScript string
  /**
   * Converts a value to a JavaScript string (not JSON).
   *
   * For example a date to `"new Date(y, m, d)"`, an array to `"[...]"` etc.
   *
   * @param {*} value
   * @param {Object} [options]
   * @returns {String}
   * @internal
   */
  static toJavaScriptValue(value, options) {
    const type = Objects.typeOf(value);
    if (type === "boolean" || type === "string" || type === "number" || value === null) {
      return _StringHelper.safeJsonStringify(value);
    }
    if (value === globalThis) {
      return "window";
    }
    if (type === "date") {
      return `new Date(${value.getFullYear()}, ${value.getMonth()}, ${value.getDate()}, ${value.getHours()}, ${value.getMinutes()}, ${value.getSeconds()}, ${value.getMilliseconds()})`;
    }
    if (type === "array") {
      return `[${value.map((v) => _StringHelper.toJavaScriptValue(v, options))}]`;
    }
    if (type === "object" || type === "instance") {
      return this.toJavaScriptString(value, options);
    }
    if (type === "function") {
      let contents = value.toString();
      if (contents.match(/^async (\w+?)\(/)) {
        contents = contents.replace(/^async (\w+?)\(/, "async function(");
      } else if (!contents.startsWith("async(") && contents.match(/^(\w+?)\(/)) {
        contents = contents.replace(/^(\w+?)\(/, "function(");
      }
      return contents;
    }
    if (type === "class") {
      if (value.toJavaScriptValue) {
        return value.toJavaScriptValue(options);
      }
      return Object.prototype.hasOwnProperty.call(value, "$name") ? value.$name : value.name;
    }
  }
  /**
   * Converts an object into a JavaScript string (not JSON).
   *
   * For example `{ a: 1, b: [2, 3] }` -> `"'{ a: 1, b: [2, 3] }'"`
   *
   * @param {Object} obj
   * @param {Object} [options]
   * @returns {String}
   * @internal
   */
  static toJavaScriptString(obj, options = {}) {
    var _a2;
    const level = (_a2 = options.level) != null ? _a2 : 0, intendSize = 2;
    return "{\n" + Object.keys(obj).map(
      (key) => (
        // All properties in an object are indented one step further than the object itself
        " ".repeat((level + 1) * intendSize) + (key.match(/[- *]/) ? `"${key}"` : key) + `: ${_StringHelper.toJavaScriptValue(obj[key], { ...options, level: level + 1 })}`
      )
    ).join(",\n") + // Closing brace is indented to same level as the object
    "\n" + " ".repeat(level * intendSize) + "}";
  }
  /**
   * Escapes " and \ in CSS attribute selectors, e.g. [data-id="somevalue"]
   *
   * Usage:
   * ```javascript
   * document.querySelector(StringHelper.cssAttributeQuery('data-id', 'id with & \\ chars'))
   * ```
   *
   * @param {String} attr
   * @param {String|Number} value
   * @returns {String}
   */
  static encodeAttributeSelector(attr, value) {
    return `[${attr}="${String(value).replace(/["\\]/g, "\\$&")}"]`;
  }
  /**
   * Generates a UUID. Uses `Crypto.randomUUID()` if available, otherwise generates a random UUID using
   * `Crypto.getRandomValues()`.
   *
   * @returns {String}
   */
  static generateUUID() {
    var _a2;
    if (BrowserHelper.supportsRandomUUID) {
      return globalThis.crypto.randomUUID();
    }
    if ((_a2 = globalThis.crypto) == null ? void 0 : _a2.getRandomValues) {
      return ("10000000-1000-4000-8000" + -1e11).replace(
        /[018]/g,
        (c) => (c ^ globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
      );
    }
    return `${Date.now()}-${++_StringHelper.fakeNodeUUIDIndex}`;
  }
  //endregion
};
//endregion
//region UUID
__publicField(_StringHelper, "fakeNodeUUIDIndex", 0);
var StringHelper = _StringHelper;
StringHelper.initHtmlEntities();
StringHelper._$name = "StringHelper";

// ../Core/lib/Core/helper/VersionHelper.js
var VersionHelper = class _VersionHelper {
  /**
   * Set version for specified product
   * @private
   * @param {String} product
   * @param {String} version
   */
  static setVersion(product, version) {
    product = product.toLowerCase();
    VH[product] = {
      version,
      isNewerThan(otherVersion) {
        return _VersionHelper.semanticCompareVersion(otherVersion, version, "<");
      },
      isOlderThan(otherVersion) {
        return _VersionHelper.semanticCompareVersion(otherVersion, version, ">");
      }
    };
    let bundleFor = "";
    if (typeof productName !== "undefined") {
      bundleFor = productName;
    }
    const globalKey = `${bundleFor}.${product}${version.replace(/\./g, "-")}`;
    if (BrowserHelper.isBrowserEnv && !globalThis.bryntum.silenceBundleException) {
      if (globalThis.bryntum[globalKey] === true) {
        if (this.isTestEnv) {
          globalThis.BUNDLE_EXCEPTION = true;
        } else {
          let errorProduct = bundleFor || product;
          if (errorProduct === "core") {
            errorProduct = "grid";
          }
          let capitalized = StringHelper.capitalize(errorProduct);
          if (errorProduct === "schedulerpro") {
            capitalized = "SchedulerPro";
          }
          throw new Error(
            `The Bryntum ${capitalized} bundle was loaded multiple times by the application.

Common reasons you are getting this error includes:

* Imports point to different types of the bundle (e.g. *.module.js and *.umd.js)
* Imports point to both sources and bundle
* Imports do not use the shortest relative path, JS treats them as different files
* Cache busters differ between imports, JS treats ${errorProduct}.module.js?1 and ${errorProduct}.module.js?2 as different files
* Imports missing file type, verify they all end in .js

See https://bryntum.com/products/${errorProduct}/docs/guide/${capitalized}/gettingstarted/es6bundle#troubleshooting for more information

`
          );
        }
      } else {
        globalThis.bryntum[globalKey] = true;
      }
    }
  }
  /**
   * Get (previously set) version for specified product
   * @private
   * @param {String} product
   */
  static getVersion(product) {
    product = product.toLowerCase();
    if (!VH[product]) {
      throw new Error("No version specified! Please check that you import VersionHelper correctly into the class from where you call `deprecate` function.");
    }
    return VH[product].version;
  }
  /**
   * Checks the version1 against the passed version2 using the comparison operator.
   * Supports `rc`, `beta`, `alpha` release states. Eg. `1.2.3-alpha-1`.
   * State which is not listed above means some version below `alpha`.
   * @param {String} version1 The version to test against
   * @param {String} version2 The version to test against
   * @param {String} [comparison] The comparison operator, `<=`, `<`, `=`, `>` or `>=`.
   * @returns {Boolean} `true` if the test passes.
   * @internal
   */
  static semanticCompareVersion(version1, version2, comparison = "=") {
    version1 = version1 || "";
    version2 = version2 || "";
    const version1Arr = version1.split(/[-.]/), version2Arr = version2.split(/[-.]/), isLower = comparison.includes("<"), normalizeArr = (arr, maxLength) => {
      const states = ["rc", "beta", "alpha"], result = arr.map((v) => {
        if (states.includes(v)) {
          return -states.indexOf(v) - 2;
        }
        const res = Number.parseInt(v);
        return Number.isNaN(res) ? -states.length : res;
      });
      while (result.length < maxLength) {
        result.push(-1);
      }
      return result;
    }, compareArr = () => {
      const maxLength = Math.max(version1Arr.length, version2Arr.length), arr1 = normalizeArr(version1Arr, maxLength), arr2 = normalizeArr(version2Arr, maxLength);
      for (let i = 0; i < maxLength; i++) {
        if (arr1[i] !== arr2[i]) {
          return isLower ? arr1[i] < arr2[i] : arr1[i] > arr2[i];
        }
      }
      return true;
    };
    switch (comparison) {
      case "=":
        return version1 === version2;
      case "<=":
      case ">=":
        return version1 === version2 || compareArr();
      case "<":
      case ">":
        return version1 !== version2 && compareArr();
    }
    return false;
  }
  /**
   * Checks the passed product against the passed version using the passed test.
   * @param {String} product The name of the product to test the version of
   * @param {String} version The version to test against
   * @param {String} operator The test operator, `<=`, `<`, `=`, `>` or `>=`.
   * @returns {Boolean} `true` if the test passes.
   * @internal
   */
  static checkVersion(product, version, operator) {
    return _VersionHelper.semanticCompareVersion(VH.getVersion(product), version, operator);
  }
  /**
   * Based on a comparison of current product version and the passed version this method either outputs a console.warn
   * or throws an error.
   * @param {String} product The name of the product
   * @param {String} invalidAsOfVersion The version where the offending code is invalid (when any compatibility layer
   * is actually removed).
   * @param {String} message Required! A helpful warning message to show to the developer using a deprecated API.
   * @internal
   */
  static deprecate(product, invalidAsOfVersion, message) {
    const justWarn = VH.checkVersion(product, invalidAsOfVersion, "<");
    if (justWarn) {
      console.warn(`Deprecation warning: You are using a deprecated API which will change in v${invalidAsOfVersion}. ${message}`);
    } else {
      throw new Error(`Deprecated API use. ${message}`);
    }
  }
  /**
   * Returns truthy value if environment is in testing mode
   * @returns {Boolean}
   * @internal
   **/
  static get isTestEnv() {
    var _a2, _b, _c;
    const isTestEnv = Boolean((_a2 = globalThis.bryntum) == null ? void 0 : _a2.isTestEnv);
    try {
      return isTestEnv || Boolean((_c = (_b = globalThis.parent) == null ? void 0 : _b.bryntum) == null ? void 0 : _c.isTestEnv);
    } catch (e) {
      return isTestEnv;
    }
  }
  static get isDebug() {
    let result = false;
    return result;
  }
};
var VH = VersionHelper;
if (BrowserHelper.isBrowserEnv) {
  if (VH.isTestEnv) {
    BrowserHelper._isHoverableDevice = true;
  }
  globalThis.bryntum = Object.assign(globalThis.bryntum || {}, {
    getVersion: VH.getVersion.bind(VH),
    checkVersion: VH.checkVersion.bind(VH),
    deprecate: VH.deprecate.bind(VH),
    license: "%LICENSE%"
  });
}
VersionHelper._$name = "VersionHelper";

// ../Core/lib/Core/Config.js
var { defineProperty, getOwnPropertyDescriptor } = Reflect;
var { hasOwnProperty: hasOwnProperty3, toString: toString2 } = Object.prototype;
var instancePropertiesSymbol = Symbol("instanceProperties");
var configuringSymbol = Symbol("configuring");
var lazyConfigValues = Symbol("lazyConfigValues");
var DATE_TYPE = toString2.call(/* @__PURE__ */ new Date());
var whitespace = /\s+/;
var createClsProps = (result, cls) => {
  result[cls] = 1;
  return result;
};
var Config = class _Config {
  /**
   * Returns the `Config` instance for the given `name` and `options`.
   * @param {String} name The name of the config (e.g., 'text' for the text config).
   * @param {Object} [options] Config behavior options.
   * @returns {Core.Config}
   * @internal
   */
  static get(name, options) {
    const { cache } = this, baseCfg = cache[name] || (cache[name] = new _Config(name));
    let cfg = baseCfg, key;
    if (options) {
      key = _Config.makeCacheKey(name, options);
      if (!(cfg = key && cache[key])) {
        cfg = baseCfg.extend(options);
        if (key) {
          cache[key] = cfg;
        }
      }
    }
    return cfg;
  }
  constructor(name) {
    const me = this, cap = name[0].toUpperCase() + name.substr(1);
    me.base = me;
    me.name = name;
    me.field = "_" + name;
    me.capName = cap;
    me.changer = "change" + cap;
    me.initializing = "initializing" + cap;
    me.updater = "update" + cap;
  }
  /**
   * The descriptor to use with `Reflect.defineProperty()` for defining this config's getter and setter.
   * @property {Object}
   * @private
   */
  get descriptor() {
    let descriptor = this._descriptor;
    if (!descriptor || !hasOwnProperty3.call(this, "_descriptor")) {
      this._descriptor = descriptor = this.makeDescriptor();
    }
    return descriptor;
  }
  /**
   * The descriptor to use with `Reflect.defineProperty()` for defining this config's initter.
   * @property {Object}
   * @private
   */
  get initDescriptor() {
    let descriptor = this._initDescriptor;
    if (!descriptor || !hasOwnProperty3.call(this, "_initDescriptor")) {
      this._initDescriptor = descriptor = this.makeInitter();
    }
    return descriptor;
  }
  /**
   * This method compares two values for semantic equality. By default, this is based on the `===` operator. This
   * is often overridden for configs that accept `Date` or array values.
   * @param {*} value1
   * @param {*} value2
   * @returns {Boolean}
   * @internal
   */
  equal(value1, value2) {
    return value1 === value2;
  }
  /**
   * Extends this config with a given additional set of options. These objects are just prototype extensions of this
   * instance.
   * @param {Object} options
   * @returns {Core.Config}
   * @internal
   */
  extend(options) {
    const cfg = Object.assign(Object.create(this), options), { equal: equal2, merge } = options, { equalityMethods } = _Config;
    if (typeof equal2 === "string") {
      if (equal2.endsWith("[]")) {
        cfg.equal = _Config.makeArrayEquals(equalityMethods[equal2.substr(0, equal2.length - 2)]);
      } else {
        cfg.equal = equalityMethods[equal2];
      }
    }
    if (typeof merge === "string") {
      cfg.merge = _Config.mergeMethods[merge];
    }
    return cfg;
  }
  /**
   * Defines the property on a given target object via `Reflect.defineProperty()`. If the object has its own getter,
   * it will be preserved. It is invalid to define a setter.
   * @param {Object} target
   * @internal
   */
  define(target) {
    const existing = getOwnPropertyDescriptor(target, this.name);
    let descriptor = this.descriptor;
    if (existing && existing.get) {
      descriptor = Object.assign({}, descriptor);
      descriptor.get = existing.get;
    }
    defineProperty(target, this.name, descriptor);
  }
  /**
   * Defines the property initter on the `target`. This is a property getter/setter that propagates the configured
   * value when the property is read.
   * @param {Object} target
   * @param {*} value
   * @internal
   */
  defineInitter(target, value) {
    const { name } = this, properties = target[instancePropertiesSymbol];
    let lazyValues, prop;
    if (!properties[name] && /* assign */
    (prop = getOwnPropertyDescriptor(target, name)) && !("value" in prop)) {
      properties[name] = prop;
    }
    defineProperty(target, name, this.initDescriptor);
    if (this.lazy) {
      lazyValues = target[lazyConfigValues] || (target[lazyConfigValues] = /* @__PURE__ */ new Map());
      lazyValues.set(name, value);
    }
  }
  /**
   * Returns an equality function for arrays of a base type, for example `'date'`.
   * @param {Function} [fn] The function to use to compare array elements. By default, operator `===` is used.
   * @returns {Function}
   * @private
   */
  static makeArrayEquals(fn) {
    return (value1, value2) => {
      let i, equal2 = value1 && value2 && value1.length === (i = value2.length);
      if (equal2 && Array.isArray(value1) && Array.isArray(value2)) {
        if (fn) {
          while (equal2 && i-- > 0) {
            equal2 = fn(value1[i], value2[i]);
          }
        } else {
          while (equal2 && i-- > 0) {
            equal2 = value1[i] === value2[i];
          }
        }
      } else {
        equal2 = fn ? fn(value1, value2) : value1 === value2;
      }
      return equal2;
    };
  }
  /**
   * Returns the key to use in the Config `cache`.
   * @param {String} name The name of the config property.
   * @param {Object} options The config property options.
   * @returns {String}
   * @private
   */
  static makeCacheKey(name, options) {
    const keys = Object.keys(options).sort();
    for (let key, type, value, i = keys.length; i-- > 0; ) {
      value = options[key = keys[i]];
      if (value == null && value === false) {
        keys.splice(i, 1);
      } else {
        type = typeof value;
        if (type === "function") {
          return null;
        }
        if (type === "string") {
          keys[i] = `${key}:"${value}"`;
        } else if (type === "number") {
          keys[i] = `${key}:${value}`;
        }
      }
    }
    return keys.length ? `${name}>${keys.join("|")}` : name;
  }
  /**
   * Creates and returns a property descriptor for this config suitable to be passed to `Reflect.defineProperty()`.
   * @returns {Object}
   * @private
   */
  makeDescriptor() {
    const config = this, { base, field, changer, updater, name } = config;
    if (base !== config && base.equal === config.equal) {
      return base.descriptor;
    }
    return {
      get() {
        var _a2;
        (_a2 = this.configObserver) == null ? void 0 : _a2.get(name, this);
        return this[field];
      },
      set(value) {
        var _a2, _b;
        const me = this;
        let was = me[field], applied, newValue;
        if (typeof value === "string") {
          let resolvedValue = value;
          if (value.startsWith("up.")) {
            resolvedValue = (_a2 = me.owner) == null ? void 0 : _a2.resolveProperty(value.substr(3));
          } else if (value.startsWith("this.")) {
            resolvedValue = me.resolveProperty(value.substr(5));
          }
          if (resolvedValue !== void 0 && typeof resolvedValue !== "function") {
            value = resolvedValue;
          }
        }
        if (me[changer]) {
          applied = (newValue = me[changer](value, was)) === void 0;
          if (!applied) {
            value = newValue;
            was = me[field];
          }
        }
        if (!applied && !(config.equal === equal ? was === value : config.equal(was, value))) {
          me[field] = value;
          applied = true;
          (_b = me[updater]) == null ? void 0 : _b.call(me, value, was);
        }
        if (applied && !me.isDestroyed && !me.onConfigChange.$nullFn) {
          me.onConfigChange({ name, value, was, config });
        }
      }
    };
  }
  /**
   * Creates and returns a property descriptor for this config's initter suitable to pass to
   * `Reflect.defineProperty()`.
   * @returns {Object}
   * @private
   */
  makeInitter() {
    const config = this;
    if (config !== config.base) {
      if (config.lazy) {
        return config.makeLazyInitter();
      }
      return config.base.initDescriptor;
    }
    return config.makeBasicInitter();
  }
  makeBasicInitter() {
    const config = this, { initializing, name } = config;
    return {
      configurable: true,
      get() {
        const me = this;
        config.removeInitter(me);
        me[initializing] = true;
        me[name] = me[configuringSymbol][name];
        me[initializing] = false;
        me.configDone[name] = true;
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        this.configDone[name] = true;
        this[name] = value;
      }
    };
  }
  makeLazyInitter() {
    const config = this, { initializing, name } = config;
    return {
      configurable: true,
      get() {
        const me = this, value = me[lazyConfigValues].get(name);
        config.removeInitter(me);
        if (!me.isDestroying) {
          me[initializing] = true;
          me[name] = value;
          me[initializing] = false;
        }
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        this[name] = value;
      }
    };
  }
  /**
   * Removes the property initter and restores the instance to its original form.
   * @param {Object} instance
   * @private
   */
  removeInitter(instance) {
    const { name } = this, instanceProperty = instance[instancePropertiesSymbol][name], lazyValues = instance[lazyConfigValues];
    if (instanceProperty) {
      defineProperty(instance, name, instanceProperty);
    } else {
      delete instance[name];
    }
    if ((lazyValues == null ? void 0 : lazyValues.delete(name)) && !lazyValues.size) {
      delete instance[lazyConfigValues];
    }
  }
  setDefault(cls, value) {
    defineProperty(cls.prototype, this.field, {
      configurable: true,
      writable: true,
      // or else "this._value = x" will fail
      value
    });
  }
  /**
   * This method combines (merges) two config values. This is called in two cases:
   *
   *  - When a derived class specifies the value of a config defined in a super class.
   *  - When a value is specified in the instance config object.
   *
   * @param {*} newValue In the case of derived classes, this is the config value of the derived class. In the case
   * of the instance config, this is the instance config value.
   * @param {*} currentValue In the case of derived classes, this is the config value of the super class. In the case
   * of the instance config, this is the class config value.
   * @param {Object} metaNew The class meta object from which the `newValue` is coming. This parameter is `null` if
   * the `newValue` is from an instance configuration.
   * @param {Object} metaCurrent The class meta object from which the `currentValue` is coming. This parameter is
   * `null` if the `currentValue` is not from a class configuration.
   * @returns {*}
   * @internal
   */
  merge(newValue, currentValue) {
    if (currentValue && newValue && Objects.isObject(newValue)) {
      if (currentValue.isBase) {
        return currentValue.setConfig(newValue);
      }
      if (Objects.isObject(currentValue)) {
        newValue = Objects.merge(Objects.clone(currentValue), newValue);
      }
    }
    return newValue;
  }
};
var { prototype } = Config;
var { equal } = prototype;
Config.symbols = {
  configuring: configuringSymbol,
  instanceProperties: instancePropertiesSymbol,
  lazyConfigs: lazyConfigValues
};
Config.cache = /* @__PURE__ */ Object.create(null);
Config.equalityMethods = {
  array: Config.makeArrayEquals(),
  date(value1, value2) {
    if (value1 === value2) {
      return true;
    }
    if (value1 && value2 && toString2.call(value1) === DATE_TYPE && toString2.call(value2) === DATE_TYPE) {
      return value1.getTime() === value2.getTime();
    }
    return false;
  },
  strict: Config.equal = equal
};
Config.mergeMethods = {
  distinct(newValue, oldValue) {
    let ret = oldValue ? oldValue.slice() : [];
    if (newValue != null) {
      if (Objects.isObject(newValue)) {
        if (oldValue === void 0) {
          ret = newValue;
        } else {
          let key, index;
          for (key in newValue) {
            index = ret.indexOf(key);
            if (newValue[key]) {
              if (index < 0) {
                ret.push(key);
              }
            } else if (index > -1) {
              ret.splice(index, 1);
            }
          }
        }
      } else if (Array.isArray(newValue)) {
        newValue.forEach((v) => !ret.includes(v) && ret.push(v));
      } else if (!ret.includes(newValue)) {
        ret.push(newValue);
      }
    }
    return ret;
  },
  merge: Config.merge = prototype.merge,
  classList(newValue, oldValue) {
    if (typeof newValue === "string") {
      if (!newValue.length) {
        return oldValue;
      }
      newValue = newValue.split(whitespace);
    }
    if (Array.isArray(newValue)) {
      newValue = newValue.reduce(createClsProps, {});
    }
    return Config.merge(newValue, oldValue);
  },
  objects(newValue, oldValue) {
    return newValue === true ? oldValue || {} : Config.merge(newValue, oldValue);
  },
  replace(newValue) {
    return newValue;
  },
  items(newValue, oldValue, metaNew, metaCurrent) {
    if (metaCurrent) {
      return Objects.mergeItems(oldValue, newValue, {
        merge: (oldValue2, newValue2) => prototype.merge(newValue2, oldValue2)
      });
    }
    return prototype.merge(newValue, oldValue);
  }
};
Object.assign(prototype, {
  _descriptor: null,
  _initDescriptor: null,
  /**
   * A function that compares values for equality. This test is used to determine if the `update` method should be
   * called when the setter is invoked.
   *
   * To handle `Date` values:
   * ```
   *  class Foo extends Base {
   *      static get configurable() {
   *          return {
   *              date : {
   *                  $config : {
   *                      equal : 'date'
   *                  },
   *
   *                  value : null
   *              }
   *          }
   *      }
   *
   *      updateDate(date) {
   *          // date has changed
   *      }
   *  }
   * ```
   *
   * Also useful for some configs:
   * ```
   *  class Foo extends Base {
   *      static get configurable() {
   *          return {
   *              bar : {
   *                  $config : {
   *                      equal : ObjectHelper.isEqual
   *                  },
   *
   *                  value : null
   *              }
   *          }
   *      }
   *
   *      updateBar(value) {
   *          // value has changed
   *      }
   *  }
   * ```
   * @config {Function} equal
   * @internal
   */
  /**
   * Indicates that this config property should not automatically initialize during construction. When this property
   * is set to `true`, initialization is triggered by the first use of the config property's getter.
   *
   * This property can alternatively be set to a string, in which case it can be initialized as a group using the
   * {@link Core.Base#function-triggerConfigs} method which will initialize all lazy configs with the same value for
   * this property. Note: the config will still initialize on first use if that occurs prior to the call to
   * `triggerConfigs`.
   * @config {Boolean|String}
   * @default
   * @internal
   */
  lazy: false,
  /**
   * Indicates that this config property should automatically be set to `null` on destroy.
   * @config {Boolean}
   * @default
   * @internal
   */
  nullify: false,
  /**
   * Indicates that this config participates in rendering. This has does not affect the behavior of the property
   * directly, but allows classes that perform rendering to detect which config changes will affect the rendered
   * result.
   * @config {Boolean}
   * @default
   * @internal
   */
  render: false
});
Config._$name = "Config";

// ../Core/lib/Core/Base.js
var MetaClass = class {
  constructor(options) {
    options && Object.assign(this, options);
  }
  getInherited(name, create = true) {
    var _a2;
    let ret = this[name];
    if (!(name in this)) {
      ret = (_a2 = this.super) == null ? void 0 : _a2.getInherited(name, create);
      if (ret || create) {
        this[name] = ret = Object.create(ret || null);
      }
    }
    return ret;
  }
};
var { getPrototypeOf } = Object;
var { hasOwn } = Objects;
var { defineProperty: defineProperty2 } = Reflect;
var metaSymbol = Symbol("classMetaData");
var mixinTagSymbol = Symbol("mixinTag");
var originalConfigSymbol = Symbol("originalConfig");
var createdAtSymbol = Symbol("createdAt");
var configuringSymbol2 = Config.symbols.configuring;
var instancePropertiesSymbol2 = Config.symbols.instanceProperties;
var lazyConfigsSymbol = Config.symbols.lazyConfigs;
var defaultConfigOptions = { merge: "replace", simple: true };
var emptyFn = () => {
};
var newMeta = (o) => new MetaClass(o);
var setupNames = {
  /* foo : 'setupFoo' */
};
var emptyObject2 = Object.freeze({});
var emptyArray = Object.freeze([]);
var Base = class _Base {
  static get isBase() {
    return true;
  }
  get isBase() {
    return true;
  }
  // defaultConfig & properties made private to not spam all other classes
  /**
   * A class property getter to add additional, special class properties.
   *
   * For example, a class adds a `declarable` class property like so:
   * ```
   *  class Something extends Base {
   *      static get declarable() {
   *          return ['extra'];
   *      }
   *
   *      static setupExtra(cls, meta) {
   *          // use cls.extra
   *      }
   *  }
   * ```
   * A derived class can then specify this property like so:
   * ```
   *  class Derived extends Something {
   *      static get extra() {
   *          // return extra information
   *      }
   *  }
   * ```
   * When the `Derived` class is initialized, the `setupExtra()` method is called and `Derived` is passed as the
   * argument. It is also the `this` pointer, but the parameter is minifiable. The second argument passed is the
   * `$meta` object for the class.
   *
   * Classes are initialized at the first occurrence of the following:
   *
   * - An instance is created
   * - The class `$meta` property is accessed
   *
   * @member {String[]} declarable
   * @static
   * @category Configuration
   * @internal
   */
  static get declarable() {
    return [
      "declarable",
      /**
       * A class property getter for the configuration properties of the class, which can be overridden by
       * configurations passed at construction time.
       *
       * Unlike a normal `static` property, this property is only ever used for the class that defines it (as in,
       * `hasOwnProperty`). It is retrieved for all classes in a class hierarchy, to gather their configs
       * individually and then combine them with those of derived classes.
       *
       * For example, a `Label` might declare a `text` config like so:
       * ```javascript
       *  class Label extends Base {
       *      static get configurable() {
       *          return {
       *              text : null
       *          };
       *      }
       *  }
       * ```
       * The `text` config is automatically inherited by classes derived from Label. By implementing
       * `get configurable()`, derived classes can change the default value of inherited configs, or define new
       * configs, or both.
       *
       * When a config property is declared in this way, the class author can also implement either of two
       * special methods that will be called when the config property is assigned a new value:
       *
       *  - `changeText()`
       *  - `updateText()`
       *
       * In the example above, the `Label` class could implement a `changeText()` method, an `updateText()`
       * method, or both. The generated property setter ensures these methods will be called when the `text`
       * property is assigned.
       *
       * The generated setter (for `text` in this example) performs the following steps:
       *
       *  - If the class defines a `changeText()` method, call it passing the new value and the current value:
       *    `changeText(newText, oldText)`.<br>
       *    Then:
       *    * If `changeText()` exits without returning a value (i.e., `undefined`), exit and do nothing
       *      further. The assumption is that the changer method has done all that is required.
       *    * Otherwise, the return value of `changeText()` replaces the incoming value passed to the setter.
       *  - If the new value (or the value returned by `changeText()`) is `!==` to the current value:
       *    * Update the stored config value in `this._text`.
       *    * If the class defines an `updateText()` method, call it passing the new value and the previous value.
       *      `updateText(newText, oldText)`
       *
       * #### Resolving a value from an owner
       * By specifying a value starting with `'up.'` for a config, the config system will resolve that value by
       * examining the ownership hierarchy. It will walk up the hierarchy looking for a property matching the name
       * (or dot separated path) after 'up.'. If one is found, the value will be read and used as the initial
       * value.
       *
       * ```javascript
       * class Parent extends Base {
       *     static get configurable() {
       *         return [
       *           'importantValue'
       *         ]
       *     }
       * }
       *
       * class Child extends Base {
       *     static get configurable() {
       *         return [
       *           'value'
       *         ]
       *     }
       * }
       *
       * const parent = new Parent({
       *     importantValue : 123
       * });
       *
       * const child = new Child({
       *     owner : parent,
       *     // Will be resolved from the owner
       *     value : 'up.importantValue'
       * });
       *
       * console.log(child.value); // logs 123
       * ```
       * Please note that this is for now a one way one time binding, the value will only be read initially and
       * not kept up to date on later changes.
       *
       * #### Value Merging
       * When a config property value is an object, the value declared by the base class is merged with values
       * declared by derived classes and the value passed to the constructor.
       * ```javascript
       *  class Example extends Base {
       *      static get configurable() {
       *          return {
       *              config : {
       *                  foo : 1,
       *                  bar : 2
       *              }
       *          };
       *      }
       *  }
       *
       *  class Example2 extends Example {
       *      static get configurable() {
       *          return {
       *              config : {
       *                  bar : 42,
       *                  zip : 'abc'
       *              }
       *          };
       *      }
       *  }
       *
       *  let ex = new Example2({
       *      config : {
       *          zip : 'xyz'
       *      }
       *  });
       * ```
       * The result of the merge would set `config` to:
       * ```javascript
       *  ex.foo = {
       *      foo : 1,    // from Example
       *      bar : 42,   // from Example2
       *      zip : 'xyz' // from constructor
       *  }
       * ```
       *
       * #### Config Options
       * Some config properties require additional options such as declarative information about the config that
       * may be useful to automate some operation. Consider a `Button`. It could declare that its `text` config
       * affects the rendered HTML by applying a `render` property to the config definition. Its base class could
       * then examine the config definition to find this property.
       *
       * To support this, config options ca be declared like so:
       * ```javascript
       *  class Button extends Widget {
       *      static get configurable() {
       *          return {
       *              text : {
       *                  value   : null,
       *                  $config : {
       *                      render : true
       *                  }
       *              }
       *          };
       *      }
       *  }
       * ```
       * The `$config` property can alternatively be just the names of the options that should be enabled (set
       * to `true`).
       *
       * For example, the following is equivalent to the above:
       * ```javascript
       *  class Button extends Widget {
       *      static get configurable() {
       *          return {
       *              text : {
       *                  value   : null,
       *                  $config : 'render'
       *              }
       *          };
       *  }
       * ```
       *
       * #### Default Value
       * It is common to set a config to a `null` value to take advantage of internal optimizations for `null`
       * values. In most cases the fact that this produces `undefined` as the actual initial value of the config
       * is acceptable. When this is not acceptable, a config can be declared like so:
       * ```javascript
       *  class Widget {
       *      static get configurable() {
       *          return {
       *              disabled : {
       *                  $config : null,
       *                  value   : null,
       *                  default : false
       *              }
       *          };
       *  }
       * ```
       * The `default` property above determines the value of the config while still gaining the benefits of
       * minimal processing due to the `null` value of the `value` property.
       * @member {Object} configurable
       * @static
       * @category Configuration
       * @internal
       */
      "configurable",
      /**
       * A class property getter for the default configuration of the class, which can be overridden by
       * configurations passed at construction time.
       *
       * Unlike a normal `static` property, this property is only ever used for the class that defines it (as in,
       * `hasOwnProperty`). It is retrieved for all classes in a class hierarchy, to gather their configs
       * individually and then combine them with those of derived classes.
       *
       * For example, a `Store` might declare its `url` config like so:
       * ```
       *  class Store extends Base {
       *      static get defaultConfig() {
       *          return {
       *              url : null
       *          };
       *      }
       *  }
       * ```
       * The `url` config is automatically inherited by classes derived from Store. By implementing
       * `get defaultConfig()`, derived classes can change the default value of inherited configs, or define new
       * configs, or both. When defining new configs, however, `configurable` is preferred.
       *
       * Config properties introduced to a class by this declaration do not participate in value merging and do
       * not get a generated setter. Config properties introduced by a base class using `configurable` can be
       * set to a different value using `defaultConfig` and in doing so, the values will be merged as appropriate
       * for `configurable`.
       *
       * @member {Object} defaultConfig
       * @static
       * @category Configuration
       * @internal
       */
      "defaultConfig",
      /**
       * A class property getter for the default values of internal properties for this class.
       * @member {Object} properties
       * @static
       * @category Configuration
       * @internal
       */
      "properties",
      /**
       * A class property getter for properties that will be applied to the class prototype.
       * @member {Object} prototypeProperties
       * @static
       * @category Configuration
       * @internal
       */
      "prototypeProperties"
    ];
  }
  /**
   * Base constructor, passes arguments to {@link #function-construct}.
   * @param {...Object} [args] Usually called with a config object, but accepts any params
   * @function constructor
   * @category Lifecycle
   * @advanced
   */
  constructor(...args) {
    const me = this, C = me.constructor;
    if (me.$meta.class !== C) {
      emptyFn(C.$meta);
    }
    me.construct(...args);
    me.afterConstruct();
    me.isConstructing = false;
  }
  /**
   * Factory version of the Base constructor. Merges all arguments to create a config object that is passed along to
   * the constructor.
   * @param {...Object} [configs] Allows passing multiple config objects
   * @returns {Core.Base} New instance
   * @private
   */
  static new(...configs) {
    configs = configs.filter((c) => c);
    return new this(configs.length > 1 ? this.mergeConfigs(...configs) : configs[0]);
  }
  /**
   * Base implementation applies configuration.
   *
   * Subclasses need only implement this if they have to initialize instance specific
   * properties required by the class. Often a `construct` method is
   * unnecessary. All initialization of incoming configuration properties can be
   * done in a `set propName` implementation.
   * @param {...Object} [args] Usually called with a config object, but accepts any params
   * @category Lifecycle
   * @advanced
   */
  construct(...args) {
    if (args[0] !== null) {
      this.configure(...args);
    }
    this.afterConfigure();
  }
  /**
   * Destroys the provided objects by calling their {@link #function-destroy} method.
   * Skips empty values or objects that are already destroyed.
   *
   * ```javascript
   * Base.destroy(myButton, toolbar1, helloWorldMessageBox);
   * ```
   * @param {...Object} [args] Objects to be destroyed
   * @category Lifecycle
   * @advanced
   */
  static destroy(...args) {
    const shredder = (object) => {
      if (object == null ? void 0 : object.destroy) {
        object.destroy();
      } else if (Array.isArray(object)) {
        object.forEach(shredder);
      }
    };
    shredder(args);
  }
  /**
   * Destroys this object.
   *
   * {@advanced}
   * This is primarily accomplished by calling {@link #function-doDestroy}, however, prior to
   * calling `doDestroy`, {@link #property-isDestroying} is set to `true`. After {@link #function-doDestroy} returns,
   * {@link #property-isDestroyed} is set to `true`.
   *
   * Do not override this method in subclasses. To provide class-specific cleanup, implement {@link #function-doDestroy}
   * instead.
   * {/@advanced}
   *
   * @category Lifecycle
   */
  destroy() {
    const me = this, { id } = me;
    me.isDestroying = true;
    me.destroy = emptyFn;
    me.doDestroy();
    Object.setPrototypeOf(me, null);
    for (const key in me) {
      if (key !== "destroy" && key !== "isDestroying") {
        delete me[key];
      }
    }
    delete me[originalConfigSymbol];
    me.isDestroyed = true;
    me.id = id;
  }
  /**
   * This method is required to help `unused` getters to survive production build process. Some tools, like angular,
   * will remove `unused` code in production build, making our side-effected getters behind, breaking code heavily.
   * @internal
   * @param getter Getter to evaluate
   */
  _thisIsAUsedExpression(getter) {
  }
  static get $$name() {
    return hasOwn(this, "$name") && this.$name || // _$name is filled by webpack for every class (cls._$name = '...')
    hasOwn(this, "_$name") && this._$name || this.name;
  }
  get $$name() {
    return this.constructor.$$name;
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call super.startConfigure.
   *
   * This is called by the Base class before setting configuration properties, but after
   * the active initial getters have been set, so all configurations are available.
   *
   * This method allows all classes in the hierarchy to force some configs to be evaluated before others.
   * @internal
   * @category Lifecycle
   * @params {Object} config The configuration object use to set the initial state.
   */
  startConfigure(config) {
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call super.finishConfigure.
   *
   * This is called by the Base class before exiting the {@link #function-configure} method.
   *
   * At this point, all configs have been applied, but the `isConfiguring` property is still set.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * into the config phase.
   * @internal
   * @category Lifecycle
   * @params {Object} config The configuration object use to set the initial state.
   */
  finishConfigure(config) {
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call `super.afterConfigure`. This is called by the Base class after the {@link #function-configure} method has been
   * called. At this point, all configs have been applied.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * either before or after the super.afterConstruct();
   * @internal
   * @category Lifecycle
   */
  afterConfigure() {
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call super.afterConstruct.
   *
   * This is called by the Base class after the {@link #function-construct} method has been
   * called.
   *
   * At this point, all configs have been applied.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * either before or after the super.afterConstruct();
   * @internal
   * @function afterConstructor
   * @category Lifecycle
   */
  afterConstruct() {
  }
  /**
   * Provides a way of calling callbacks which may have been specified as the _name_ of a function
   * and optionally adds scope resolution.
   *
   * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`
   * then the function is resolved in this object. This is useful when configuring listeners
   * at the class level.
   *
   * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried
   * using the `owner` property until an object with the named function is present, then the
   * named function is called upon that object.
   *
   * If a named function is not found, an error is thrown. If the function should be only called when present,
   * and may not be present, add a `?` as a suffix.
   *
   * @param {String|Function} fn The function to call, or the name of the function to call.
   * @param {Object} thisObject The `this` object of the function.
   * @param {Object[]} args The argument list to pass.
   * @category Misc
   * @advanced
   */
  callback(fn, thisObject, args = emptyArray) {
    const { handler, thisObj } = this.resolveCallback(fn, thisObject === "this" ? this : thisObject) || emptyObject2;
    return handler == null ? void 0 : handler.apply(thisObj, args);
  }
  resolveProperty(propertyPath) {
    let thisObj = this;
    while (thisObj) {
      if (Objects.hasPath(thisObj, propertyPath)) {
        return Objects.getPath(thisObj, propertyPath);
      }
      thisObj = thisObj.owner;
    }
    return void 0;
  }
  /**
   * Provides a way of locating callbacks which may have been specified as the _name_ of a function
   * and optionally adds scope resolution.
   *
   * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`
   * then the function is resolved in this object. This is useful when configuring listeners
   * at the class level.
   *
   * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried
   * using the `owner` property until an object with the named function is present, then the
   * named function is called upon that object.
   * @param {String|Function} handler The function to call, or the name of the function to call.
   * @param {Object} thisObj The `this` object of the function.
   * @param {Boolean} [enforceCallability = true] Pass `false` if the function may not exist, and a null return value is acceptable.
   * @returns {Object} `{ handler, thisObj }`
   * @category Misc
   * @advanced
   */
  resolveCallback(handler, thisObj = this, enforceCallability = true) {
    if (handler == null ? void 0 : handler.substring) {
      if (handler.endsWith("?")) {
        enforceCallability = false;
        handler = handler.substring(0, handler.length - 1);
      }
      if (handler.startsWith("up.")) {
        handler = handler.substring(3);
        for (thisObj = this.owner; thisObj && !thisObj[handler]; thisObj = thisObj.owner)
          ;
        if (!thisObj) {
          return;
        }
      } else if (handler.startsWith("this.")) {
        handler = handler.substring(5);
        thisObj = this;
      }
      if (!thisObj || !(thisObj instanceof Object)) {
        return;
      }
      handler = thisObj[handler];
    }
    if (typeof handler === "function") {
      return { handler, thisObj };
    }
    if (enforceCallability) {
      throw new Error(`No method named ${handler} on ${thisObj.$$name || "thisObj object"}`);
    }
  }
  bindCallback(inHandler, inThisObj = this) {
    if (inHandler) {
      const { handler, thisObj } = this.resolveCallback(inHandler, inThisObj);
      if (handler) {
        return handler.bind(thisObj);
      }
    }
  }
  /**
   * Delays the execution of the passed function by the passed time quantum, or if the time is omitted
   * or not a number, delays until the next animation frame. Note that this will use
   * {@link Core.mixin.Delayable#function-setTimeout} || {@link Core.mixin.Delayable#function-requestAnimationFrame}
   * if this class mixes in `Delayable`, otherwise it uses the global methods. The function will
   * be called using `this` object as its execution scope.
   * @param {Function} fn The function to call on a delay.
   * @param {Number} [delay] The number of milliseconds to delay.
   * @param {String} [name] The name of delay
   * @returns {Number} The created timeout id.
   * @private
   */
  delay(fn, delay, name = fn.name || fn) {
    fn = this.setTimeout ? fn : fn.bind(this);
    const invoker = this.setTimeout ? this : globalThis;
    return invoker[typeof delay === "number" ? "setTimeout" : "requestAnimationFrame"](fn, delay, name);
  }
  /**
   * Classes implement this method to provide custom cleanup logic before calling `super.doDestroy()`. The general
   * pattern is as follows:
   *
   * ```javascript
   *  class Foo extends Base {
   *      doDestroy() {
   *          // perform custom cleanup
   *
   *          super.doDestroy();
   *      }
   *  }
   * ```
   *
   * This method is called by {@link #function-destroy} which also prevents multiple calls from reaching `doDestroy`.
   * Prior to calling `doDestroy`, {@link #property-isDestroying} is set to `true`. Upon return, the object is fully
   * destructed and {@link #property-isDestroyed} is set to `true`.
   *
   * Do not call this method directly. Instead call {@link #function-destroy}.
   * @category Lifecycle
   * @advanced
   */
  doDestroy() {
    const me = this, { nullify } = me.$meta;
    if (nullify) {
      for (let i = 0; i < nullify.length; ++i) {
        if (me[nullify[i].field] != null) {
          me[nullify[i].name] = null;
        }
      }
    }
  }
  /**
   * Destroys the named properties if they have been initialized, and if they have a `destroy` method.
   * Deletes the property from this object. For example:
   *
   *      this.destroyProperties('store', 'resourceStore', 'eventStore', 'dependencyStore', 'assignmentStore');
   *
   * @param {String} properties The names of the properties to destroy.
   * @internal
   * @category Lifecycle
   */
  destroyProperties(...properties) {
    var _a2, _b;
    const me = this;
    let key;
    for (key of properties) {
      if (key in me && (!me[configuringSymbol2] || !me[configuringSymbol2][key])) {
        (_b = (_a2 = me[key]) == null ? void 0 : _a2.destroy) == null ? void 0 : _b.call(_a2);
        delete me[key];
      }
    }
  }
  /**
   * Called by the Base constructor to apply configs to this instance. This must not be called.
   * @param {Object} config The configuration object from which instance properties are initialized.
   * @private
   * @category Lifecycle
   */
  configure(config = {}) {
    const me = this, meta = me.$meta, { beforeConfigure } = config, configs = meta.configs, fullConfig = me.getDefaultConfiguration();
    let cfg, key, value;
    me.initialConfig = config;
    me.isConfiguring = true;
    Object.assign(me, me.getProperties());
    for (key in config) {
      value = config[key];
      cfg = configs[key];
      fullConfig[key] = cfg ? cfg.merge(value, fullConfig[key], null, meta) : value;
    }
    if (beforeConfigure) {
      delete fullConfig.beforeConfigure;
      beforeConfigure(me, fullConfig);
    }
    me.setConfig(me[originalConfigSymbol] = fullConfig, true);
    me.isConfiguring = false;
  }
  /**
   * Returns the value of the specified config property. This is a method to allow
   * property getters to be explicitly called in a way that does not get optimized out.
   *
   * The following triggers the getter call, but optimizers will remove it:
   *
   *      inst.foo;   // also raises "expression has no side-effects" warning
   *
   * Instead, do the following to trigger a getter:
   *
   *      inst.getConfig('foo');
   *
   * @param {String} name
   * @internal
   * @category Configuration
   */
  getConfig(name) {
    return this[name];
  }
  /**
   * Sets configuration options this object with all the properties passed in the parameter object.
   * Timing is taken care of. If the setter of one config is called first, and references
   * the value of another config which has not yet been set, that config will be set just
   * in time, and the *new* value will be used.
   * @param {Object} config An object containing configurations to change.
   * @category Lifecycle
   * @advanced
   */
  setConfig(config, isConstructing) {
    var _a2;
    const me = this, wasConfiguring = me[configuringSymbol2], configDone = wasConfiguring ? me.configDone : me.configDone = {}, configs = me.$meta.configs, pendingLazy = me[lazyConfigsSymbol];
    let cfg, key;
    me[instancePropertiesSymbol2] = {};
    me[configuringSymbol2] = wasConfiguring ? Object.setPrototypeOf(Object.assign({}, config), wasConfiguring) : config;
    for (key in config) {
      if (config[key] != null || hasOwn(config, key)) {
        cfg = configs[key] || Config.get(key);
        if (!(pendingLazy == null ? void 0 : pendingLazy.has(key))) {
          cfg.defineInitter(me, config[key]);
        }
        if (!isConstructing) {
          configDone[key] = false;
        }
      } else {
        configDone[key] = true;
      }
    }
    if (isConstructing) {
      me.startConfigure(config);
    }
    for (key in config) {
      if (!configDone[key] && !(isConstructing && ((_a2 = configs[key]) == null ? void 0 : _a2.lazy))) {
        me[key] = config[key];
      }
    }
    if (wasConfiguring) {
      me[configuringSymbol2] = wasConfiguring;
    } else {
      delete me[configuringSymbol2];
    }
    if (isConstructing) {
      me.finishConfigure(config);
    }
    return me;
  }
  /**
   * Returns `true` if this instance has a non-null value for the specified config. This will not activate a lazy
   * config.
   *
   * @param {String} name The name of the config property.
   * @returns {Boolean}
   * @internal
   */
  hasConfig(name) {
    var _a2;
    const me = this, config = me[configuringSymbol2];
    return Boolean(
      me["_" + name] != null || // value has been assigned to backing property
      ((_a2 = me[lazyConfigsSymbol]) == null ? void 0 : _a2.get(name)) != null || // a lazy value is pending
      // config value has not been assigned but will be
      !me.configDone[name] && config && (config[name] != null || hasOwn(config, name))
    );
  }
  /**
   * Returns the value of an uningested config *without* ingesting the config or transforming
   * it from its raw value using its `changeXxxxx` method.
   *
   * @param {String} name The name of the config property.
   * @returns {*} The raw incoming config value.
   * @internal
   */
  peekConfig(name) {
    const me = this, lazyConfig = me[lazyConfigsSymbol], config = me[configuringSymbol2];
    if (lazyConfig == null ? void 0 : lazyConfig.has(name)) {
      return lazyConfig.get(name);
    }
    if (config && name in config) {
      if (me.configDone[name]) {
        return me[name];
      }
      if (config[name] != null || hasOwn(config, name)) {
        return config[name];
      }
    }
  }
  /**
   * Ensures that the specified config is initialized if it is needed. If there is a config value specified, and it
   * was initialized by this call, this method returns `true`. If there was a config value specified, and it was
   * already initialized, this method returns `false`. If there was no value specified for the given config, this
   * method returns `null`.
   *
   * This is not the same as just reading the property, because some property getters exist that do not actually just
   * read the config value back, but instead produce some result. Reading such properties to incidentally trigger a
   * possible config initializer can lead to incorrect results. For example, the Combo items config.
   *
   * @param {String} name The name of the config property.
   * @returns {Boolean}
   * @internal
   */
  triggerConfig(name) {
    const me = this, { configDone } = me, lazyConfig = me[lazyConfigsSymbol], config = me[configuringSymbol2], triggered = (lazyConfig == null ? void 0 : lazyConfig.has(name)) || config && (config[name] != null || hasOwn(config, name)) ? !configDone[name] : null;
    if (triggered) {
      me.getConfig(name);
    }
    return triggered;
  }
  /**
   * This call will activate any pending {@link Core.Config#config-lazy} configs that were assigned a string value
   * equal to the `group` parameter.
   *
   * @param {String} group The config property group as defined by a matching {@link Core.Config#config-lazy} value.
   * @returns {String[]} The names of any configs triggered by this call or `null` if no configs were triggered.
   * @internal
   */
  triggerConfigs(group) {
    const me = this, configs = me.$meta.configs, lazyConfigs = me[lazyConfigsSymbol], triggered = lazyConfigs ? [...lazyConfigs.keys()].filter((k) => configs[k].lazy === group) : emptyArray;
    for (const key of triggered) {
      me.triggerConfig(key);
    }
    return triggered.length ? triggered : null;
  }
  onConfigChange() {
  }
  // declared above because lint/IDE get angry about not declaring the args...
  /**
   * This method is called when any config changes.
   * @param {Object} info Object containing information regarding the config change.
   * @param {String} info.name The name of the config that changed.
   * @param {*} info.value The new value of the config.
   * @param {*} info.was The previous value of the config.
   * @param {Core.Config} info.config The `Config` object for the changed config property.
   * @method onConfigChange
   * @internal
   * @category Configuration
   */
  /**
   * Returns a *copy* of the full configuration which was used to configure this object.
   * @property {Object}
   * @category Lifecycle
   * @readonly
   * @advanced
   */
  get config() {
    const result = {}, myConfig = this[originalConfigSymbol];
    for (const key in myConfig) {
      result[key] = myConfig[key];
    }
    return result;
  }
  // region Extract config
  static processConfigValue(currentValue, options) {
    if (currentValue === globalThis) {
      return globalThis;
    } else if (Array.isArray(currentValue)) {
      return currentValue.map((v) => _Base.processConfigValue(v, options));
    } else if (currentValue instanceof _Base) {
      if (options.visited.has(currentValue)) {
        return;
      }
      return currentValue.getCurrentConfig(options);
    } else if (currentValue instanceof HTMLElement || currentValue instanceof DocumentFragment) {
      return null;
    } else if (Objects.isObject(currentValue)) {
      const result = {};
      for (const key in currentValue) {
        if (key !== "owner") {
          result[key] = _Base.processConfigValue(currentValue[key], options);
        }
      }
      return result;
    }
    return currentValue;
  }
  // Recursively get the value of a config. Only intended to be called by getCurrentConfig()
  getConfigValue(name, options) {
    var _a2;
    const me = this, lazyConfigs = me[lazyConfigsSymbol];
    if (!((_a2 = me.$meta.configs[name]) == null ? void 0 : _a2.lazy)) {
      return _Base.processConfigValue(me[name], options);
    }
    if (lazyConfigs == null ? void 0 : lazyConfigs.has(name)) {
      return _Base.processConfigValue(lazyConfigs.get(name), options);
    }
  }
  // Allows removing / adding configs before values are extracted
  preProcessCurrentConfigs() {
  }
  // Extract the current values for all initially used configs, in a format that can be used to create a new instance.
  // Not intended to be called by any other code than getConfigString()
  getCurrentConfig(options = {}) {
    const me = this, configs = options.configs === "all" ? me.config : Objects.clone(me.initialConfig), visited = options.visited || (options.visited = /* @__PURE__ */ new Set()), depth = options.depth || (options.depth = 0), result = {};
    if (visited.has(me)) {
      return void 0;
    }
    visited.add(me);
    this.preProcessCurrentConfigs(configs);
    for (const name in configs) {
      const value = me.getConfigValue(name, { ...options, depth: depth + 1 });
      if (value !== void 0) {
        result[name] = value;
      }
    }
    return result;
  }
  // Extract the current values for all initially used configs and convert them to a JavaScript string
  getConfigString(options = {}) {
    return StringHelper.toJavaScriptString(this.getCurrentConfig(options));
  }
  // Experimental helper function, extracts the currently used configs and wraps them as an app, returning code as a
  // string.
  //
  // This function is intended to simplify creating test cases for issue reporting on Bryntum's support forum.
  //
  getTestCase(options = {}) {
    const Product = this.isGantt ? "Gantt" : this.isSchedulerPro ? "SchedulerPro" : this.isCalendar ? "Calendar" : this.isScheduler ? "Scheduler" : this.isGrid ? "Grid" : this.isTaskBoard ? "TaskBoard" : null;
    if (Product) {
      const product = Product.toLowerCase(), bundlePath = `../../build/${product}.module.js`;
      let preamble, postamble;
      if (options.import === "static") {
        preamble = `import * as module from "${bundlePath}";Object.assign(window, module);`;
        postamble = "";
      } else {
        preamble = `import("${bundlePath}").then(module => { Object.assign(window, module);
`;
        postamble = "});";
      }
      const version = VersionHelper.getVersion(product);
      if (version) {
        preamble += `
console.log('${Product} ${version}');
`;
      }
      return `${preamble}      
const ${product} = new ${Product}(${this.getConfigString(options)});
${postamble}`;
    }
  }
  /**
   * Experimental helper function, extracts the currently used configs and wraps them as an app, downloading the
   * resulting JS file.
   *
   * This function is intended to simplify creating test cases for issue reporting on Bryntum's support forum.
   * @category Misc
   */
  downloadTestCase(options = {}) {
    options.output = "return";
    const app = this.getTestCase(options);
    BrowserHelper.download(`app.js`, "data:application/javascript;charset=utf-8," + escape(app));
  }
  //endregion
  /**
   * Registers this class type with its Factory
   * @category Misc
   * @advanced
   */
  static initClass() {
    return this.$meta.class;
  }
  /**
   * The class's {@link #property-$meta-static meta} object.
   * @member {Object} $meta
   * @internal
   * @category Misc
   */
  /**
   * An object owned by this class that does not share properties with its super class.
   *
   * This object may contain other properties which are added as needed and are not documented here.
   *
   * @property {Object} $meta The class meta object.
   * @property {Function} $meta.class The class constructor that owns the meta object.
   * @property {Object} $meta.super The `$meta` object for the super class. This is `null` for `Base`.
   * @property {Object} $meta.config The object holding the default configuration values for this class.
   * @property {Object} $meta.configs An object keyed by config name that holds the defined configs for the class.
   * The value of each property is a {@link Core/Config} instance.
   * @property {Boolean} $meta.forkConfigs This will be `true` if the default configuration values for this class
   * (in the `config` property of the meta object) must be forked to avoid object sharing, or if the object can be
   * passed to `Object.create()` for efficiency.
   * @property {Function[]} $meta.hierarchy The array of classes in the ancestry of this class. This will start with
   * `Base` at index 0 and ends with this class.
   * @property {Function[]} $meta.properties The array of classes that define a "static get properties()" getter.
   * @internal
   * @static
   * @category Misc
   */
  static get $meta() {
    const me = this;
    let meta = me[metaSymbol];
    if (!hasOwn(me, metaSymbol)) {
      me[metaSymbol] = meta = newMeta();
      meta.class = me;
      me.setupClass(meta);
    }
    return meta;
  }
  /**
   * This optional class method is called when a class is mixed in using the {@link #function-mixin-static mixin()}
   * method.
   * @internal
   */
  static onClassMixedIn() {
  }
  /**
   * Returns the merge of the `baseConfig` and `config` config objects based on the configs defined by this class.
   * @param {Object} baseConfig The base config or defaults.
   * @param {...Object} configs One or more config objects that takes priority over `baseConfig`.
   * @returns {Object}
   * @internal
   */
  static mergeConfigs(baseConfig, ...configs) {
    const classConfigs = this.$meta.configs, result = Objects.clone(baseConfig) || {};
    let config, i, key, value;
    for (i = 0; i < configs.length; ++i) {
      config = configs[i];
      if (config) {
        for (key in config) {
          value = config[key];
          if (classConfigs[key]) {
            value = classConfigs[key].merge(value, result[key]);
          } else if (result[key] && value) {
            value = Config.merge(value, result[key]);
          }
          result[key] = value;
        }
      }
    }
    return result;
  }
  /**
   * Applies one or more `mixins` to this class and returns the produced class constructor.
   *
   * For example, instead of writing this:
   * ```
   *  class A extends Delayable(Events(Localizable(Base))) {
   *      // ...
   *  }
   * ```
   *
   * Using this method, one would write this:
   * ```
   *  class A extends Base.mixin(Localizable, Events, Delayable) {
   *      // ...
   *  }
   * ```
   * If one of the mixins specified has already been mixed into the class, it will be ignored and not mixed in a
   * second time.
   * @param {...Function} mixins
   * @returns {Function}
   * @category Misc
   * @advanced
   */
  static mixin(...mixins) {
    let C = this, i;
    for (i = 0; i < mixins.length; ++i) {
      const mixin = mixins[i], tag = mixin[mixinTagSymbol] || (mixin[mixinTagSymbol] = Symbol("mixinTag"));
      if (C[tag]) {
        continue;
      }
      C = mixin(C);
      C[tag] = true;
      if (hasOwn(C, "onClassMixedIn")) {
        C.onClassMixedIn();
      }
    }
    return C;
  }
  /**
   * This method is called only once for any class. This can occur when the first instance is created or when the
   * `$meta` object is first requested.
   * @param {Object} meta The `$meta` object for the class.
   * @internal
   * @category Misc
   */
  static setupClass(meta) {
    var _a2;
    const cls = meta.class, base = getPrototypeOf(cls).$meta, name = cls.$$name, names = base.names, proto3 = cls.prototype;
    defineProperty2(proto3, "$meta", {
      value: meta
    });
    Object.assign(meta, {
      super: base,
      config: Object.create(base.config),
      configs: Object.create(base.configs),
      declarables: base.declarables,
      forkConfigs: base.forkConfigs,
      hierarchy: Object.freeze([...base.hierarchy, cls]),
      names: names.includes(name) ? names : Object.freeze([...names, name]),
      properties: base.properties,
      nullify: (_a2 = base.nullify) == null ? void 0 : _a2.slice()
    });
    if (names !== meta.names) {
      const isName = `is${name}`, defineIsProperty = (obj) => {
        if (!hasOwn(obj, isName)) {
          defineProperty2(obj, isName, {
            get() {
              return true;
            }
          });
        }
      };
      defineIsProperty(proto3);
      defineIsProperty(cls);
    }
    for (let decl, setupName, i = 0; i < meta.declarables.length; ++i) {
      decl = meta.declarables[i];
      if (hasOwn(cls, decl)) {
        setupName = setupNames[decl] || (setupNames[decl] = `setup${StringHelper.capitalize(decl)}`);
        cls[setupName](cls, meta);
      }
    }
  }
  /**
   * This method is called as part of `setupClass()`. It will process the `configurable()` return object and the
   * `defaultConfig` return object.
   * @param {Object} meta The `meta` object for this class.
   * @param {Object} configs The config definition object.
   * @param {Boolean} simple `true` when processing `defaultConfig` and `false` when processing `configurable`.
   * @private
   * @category Configuration
   */
  static setupConfigs(meta, configs, simple) {
    const classConfigValues = meta.config, classConfigs = meta.configs, cls = meta.class, superMeta = meta.super;
    let { nullify } = meta, cfg, defaultValue2, options, setDefault, value, wasNullify;
    for (const name in configs) {
      value = configs[name];
      if (simple) {
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, defaultConfigOptions);
        } else {
          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
      } else {
        defaultValue2 = options = setDefault = void 0;
        if (value && typeof value === "object" && "$config" in value) {
          options = value.$config;
          if (options && !Objects.isObject(options)) {
            options = Objects.createTruthyKeys(options);
          }
          setDefault = "default" in value;
          defaultValue2 = setDefault ? value.default : defaultValue2;
          value = value.value;
        }
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, options);
          cfg.define(cls.prototype);
          setDefault = !(cfg.field in cls.prototype);
          wasNullify = false;
        } else {
          wasNullify = cfg.nullify;
          if (options) {
            cfg = cfg.extend(options);
          }
          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
        if (setDefault) {
          cfg.setDefault(cls, defaultValue2);
        }
        if (cfg.nullify && !wasNullify) {
          (nullify || (nullify = meta.nullify || (meta.nullify = []))).push(cfg);
        }
      }
      if (value && (Objects.isObject(value) || Array.isArray(value)) && !Object.isFrozen(value)) {
        meta.forkConfigs = true;
      }
      classConfigs[name] = cfg;
      classConfigValues[name] = value;
    }
  }
  static setupConfigurable(cls, meta) {
    cls.setupConfigs(meta, cls.configurable, false);
  }
  static setupDefaultConfig(cls, meta) {
    cls.setupConfigs(meta, cls.defaultConfig, true);
  }
  static setupDeclarable(cls, meta) {
    const declarable = cls.declarable;
    let all = meta.declarables, forked, i;
    for (i = 0; i < declarable.length; ++i) {
      if (!all.includes(declarable[i])) {
        if (!forked) {
          meta.declarables = forked = all = all.slice();
        }
        all.push(declarable[i]);
      }
    }
  }
  static setupProperties(cls, meta) {
    meta.properties = meta.super.properties.slice();
    meta.properties.push(cls);
    Object.freeze(meta.properties);
  }
  static setupPrototypeProperties(cls) {
    Object.assign(cls.prototype, cls.prototypeProperties);
  }
  /**
   * Gets the full {@link #property-defaultConfig-static} block for this object's entire inheritance chain
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  getDefaultConfiguration() {
    return this.constructor.getDefaultConfiguration();
  }
  /**
   * Gets the full {@link #property-defaultConfig-static} block for the entire inheritance chain for this class
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  static getDefaultConfiguration() {
    const meta = this.$meta, config = meta.forkConfigs ? _Base.fork(meta.config) : Object.create(meta.config);
    if (VersionHelper.isTestEnv && BrowserHelper.isBrowserEnv && config.testConfig && globalThis.__applyTestConfigs) {
      for (const o in config.testConfig) {
        config[o] = config.testConfig[o];
      }
    }
    return config;
  }
  static fork(obj) {
    let ret = obj, key, value;
    if (obj && Objects.isObject(obj) && !Object.isFrozen(obj)) {
      ret = Object.create(obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (Objects.isObject(value)) {
            ret[key] = _Base.fork(value);
          } else if (Array.isArray(value)) {
            ret[key] = value.slice();
          }
        }
      }
    }
    return ret;
  }
  /**
   * Gets the full {@link #property-properties-static} block for this class's entire inheritance chain
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  getProperties() {
    const hierarchy = this.$meta.properties, result = {};
    for (let i = 0; i < hierarchy.length; i++) {
      Object.assign(result, hierarchy[i].properties);
    }
    return result;
  }
  static get superclass() {
    return getPrototypeOf(this);
  }
  /**
   * Used by the Widget and GridFeatureManager class internally. Returns the class hierarchy of this object
   * starting from the `topClass` class (which defaults to `Base`).
   *
   * For example `classHierarchy(Widget)` on a Combo would yield `[Widget, Field, TextField, PickerField, Combo]`
   * @param {Function} [topClass] The topmost class constructor to start from.
   * @returns {Function[]} The class hierarchy of this instance.
   * @private
   * @category Configuration
   */
  classHierarchy(topClass) {
    const hierarchy = this.$meta.hierarchy, index = topClass ? hierarchy.indexOf(topClass) : 0;
    return index > 0 ? hierarchy.slice(index) : hierarchy;
  }
  /**
   * Checks if an obj is of type using object's $$name property and doing string comparison of the property with the
   * type parameter.
   *
   * @param {String} type
   * @returns {Boolean}
   * @category Misc
   * @advanced
   */
  static isOfTypeName(type) {
    return this.$meta.names.includes(type);
  }
  /**
   * Removes all event listeners that were registered with the given `name`.
   * @param {String|Symbol} name The name of the event listeners to be removed.
   * @category Events
   * @advanced
   */
  detachListeners(name) {
    let detachers = this.$detachers;
    detachers = detachers == null ? void 0 : detachers[name];
    if (detachers) {
      while (detachers.length) {
        detachers.pop()();
      }
    }
  }
  /**
   * Tracks a detacher function for the specified listener name.
   * @param {String} name The name assigned to the associated listeners.
   * @param {Function} detacher The detacher function.
   * @private
   */
  trackDetacher(name, detacher2) {
    const detachers = this.$detachers || (this.$detachers = {}), bucket = detachers[name] || (detachers[name] = []);
    bucket.push(detacher2);
  }
  /**
   * Removes all detacher functions for the specified `Events` object. This is called
   * by the `removeAllListeners` method on that object which is typically called by its
   * `destroy` invocation.
   * @param {Core.mixin.Events} eventer The `Events` instance to untrack.
   * @private
   */
  untrackDetachers(eventer) {
    const detachers = this.$detachers;
    if (detachers) {
      for (const name in detachers) {
        const bucket = detachers[name];
        for (let i = bucket.length; i-- > 0; ) {
          if (bucket[i].eventer === eventer) {
            bucket.splice(i, 1);
          }
        }
      }
    }
  }
};
var proto = Base.prototype;
proto.onConfigChange.$nullFn = emptyFn.$nullFn = true;
Base[metaSymbol] = proto.$meta = newMeta({
  class: Base,
  config: Object.freeze({}),
  configs: /* @__PURE__ */ Object.create(null),
  declarables: Base.declarable,
  forkConfigs: false,
  hierarchy: Object.freeze([Base]),
  names: Object.freeze(["Base"]),
  nullify: null,
  properties: Object.freeze([]),
  super: null
});
Object.assign(proto, {
  $detachers: null,
  configObserver: null,
  /**
   * This property is set to `true` before the `constructor` returns.
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   * @advanced
   */
  isConstructing: true,
  /**
   * This property is set to `true` by {@link #function-destroy} after destruction.
   *
   * It is also one of the few properties that remains on the object after returning from `destroy()`. This property
   * is often checked in code paths that may encounter a destroyed object (like some event handlers) or in the
   * destruction path during cleanup.
   *
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   */
  isDestroyed: false,
  /**
   * This property is set to `true` on entry to the {@link #function-destroy} method. It remains on the objects after
   * returning from `destroy()`. If {@link #property-isDestroyed} is `true`, this property will also be `true`, so
   * there is no need to test for both (for example, `comp.isDestroying || comp.isDestroyed`).
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   * @advanced
   */
  isDestroying: false
});
Base.emptyFn = emptyFn;
VersionHelper.setVersion("core", "5.6.2");
Base._$name = "Base";

// ../Core/lib/Core/helper/ArrayHelper.js
var ArrayHelper = class _ArrayHelper {
  static clean(array) {
    return array.reduce((res, item) => {
      if (item !== null && item !== void 0 && !(Array.isArray(item) && item.length === 0) && item !== "")
        res.push(item);
      return res;
    }, []);
  }
  /**
   * Similar to [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)
   * this method creates an array from an `iterable` object. Where `Array.from()` accepts a mapper function as the
   * second argument, this method accepts a `filter` function as its second argument. If a mapper function is also
   * needed, it can be passed as the third argument. Unlike `Array.from()`, if this method is passed `null`, it will
   * return an empty array.
   * @param {Array} iterable The iterable object to convert (must support `for-of` loop iteration).
   * @param {Function} [filter] A function to apply to each item of the `iterable` which must return a truthy value
   * to include that item in the resulting array.
   * @param {Function} [map] A function to apply to each item of the `iterable` that returns the actual value to put
   * into the returned array. If a `filter` is also supplied, this method is only called for those items that pass
   * the filter test.
   * @returns {Array}
   */
  static from(iterable, filter, map) {
    const array = [];
    if (iterable) {
      for (const it of iterable) {
        if (!filter || filter(it)) {
          array.push(map ? map(it) : it);
        }
      }
    }
    return array;
  }
  /**
   * Remove one or more items from an array
   * @param {Array} array Array to remove from
   * @param {Object[]|Set} items One or more items to remove, or one Set containing items to remove
   * @returns {Boolean} Returns true if any item was removed
   */
  static remove(array, ...items) {
    let index, item, removed = false;
    items = items[0] instanceof Set ? [...items[0]] : items;
    for (let i = 0; i < items.length; i++) {
      item = items[i];
      if ((index = array.indexOf(item)) !== -1) {
        array.splice(index, 1);
        removed = true;
      }
    }
    return removed;
  }
  /**
   * Calculates the insertion index of a passed object into the passed Array according
   * to the passed comparator function. Note that the passed Array *MUST* already be ordered.
   * @param {Object} item The item to calculate the insertion index for.
   * @param {Array} array The array into which the item is to be inserted.
   * @param {Function} comparatorFn The comparison function. Must return -1 or 0 or 1.
   * @param {Object} comparatorFn.lhs The left object to compare.
   * @param {Object} comparatorFn.rhs The right object to compare.
   * @param {Number} index The possible correct index to try first before a binary
   * search is instigated.
   * @internal
   */
  static findInsertionIndex(item, array, comparatorFn = this.lexicalCompare, index) {
    const len = array.length;
    let beforeCheck, afterCheck;
    if (index < len) {
      beforeCheck = index > 0 ? comparatorFn(array[index - 1], item) : 0;
      afterCheck = index < len - 1 ? comparatorFn(item, array[index]) : 0;
      if (beforeCheck < 1 && afterCheck < 1) {
        return index;
      }
    }
    return this.binarySearch(array, item, comparatorFn);
  }
  /**
   * Similar to the native `Array.find()` call, but this finds the *last* element in the array for which
   * the passed function returns a truthy value.
   * @param {Object[]} array The array to find in.
   * @param {Function} fn The testing function.
   * @param {Object} [thisObj] The scope (`this` reference) in which to call the function.
   */
  static findLast(array, fn, thisObj) {
    for (let { length } = array, i = length - 1; i >= 0; i--) {
      if (fn.call(thisObj, array[i], i, array)) {
        return array[i];
      }
    }
  }
  /**
   * This method returns the index that a given item would be inserted into the
   * given (sorted) `array`. Note that the given `item` may or may not be in the
   * array. This method will return the index of where the item *should* be.
   *
   * For example:
   *
   *      var array = [ 'A', 'D', 'G', 'K', 'O', 'R', 'X' ];
   *      var index = ArrayHelper.binarySearch(array, 'E');
   *
   *      console.log('index: ' + index);
   *      // logs "index: 2"
   *
   *      array.splice(index, 0, 'E');
   *
   *      console.log('array : ' + array.join(''));
   *      // logs "array: ADEGKORX"
   *
   * @param {Object[]} array The array to search.
   * @param {Object} item The item that you want to insert into the `array`.
   * @param {Number} [begin=0] The first index in the `array` to consider.
   * @param {Number} [end=array.length] The index that marks the end of the range
   * to consider. The item at this index is *not* considered.
   * @param {Function} [compareFn] The comparison function that matches the sort
   * order of the `array`. The default `compareFn` compares items using less-than
   * and greater-than operators.
   * @returns {Number} The index for the given item in the given array based on
   * the passed `compareFn`.
   */
  static binarySearch(array, item, begin = 0, end = array.length, compareFn = this.lexicalCompare) {
    const length = array.length;
    let middle, comparison;
    if (begin instanceof Function) {
      compareFn = begin;
      begin = 0;
    } else if (end instanceof Function) {
      compareFn = end;
      end = length;
    }
    --end;
    while (begin <= end) {
      middle = begin + end >> 1;
      comparison = compareFn(item, array[middle]);
      if (comparison >= 0) {
        begin = middle + 1;
      } else if (comparison < 0) {
        end = middle - 1;
      }
    }
    return begin;
  }
  magnitudeCompare(lhs, rhs) {
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  lexicalCompare(lhs, rhs) {
    lhs = String(lhs);
    rhs = String(rhs);
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  /**
   * Similar to Array.prototype.fill(), but constructs a new array with the specified item count and fills it with
   * clones of the supplied item.
   * @param {Number} count Number of entries to create
   * @param {Object|Array} itemOrArray Item or array of items to clone (uses object spread to create shallow clone)
   * @param {Function} [fn] An optional function that is called for each item added, to allow processing
   * @returns {Array} A new populated array
   */
  static fill(count, itemOrArray = {}, fn = null) {
    const result = [], items = Array.isArray(itemOrArray) ? itemOrArray : [itemOrArray];
    for (let i = 0; i < count; i++) {
      for (const item of items) {
        const processedItem = Object.assign({}, item);
        if (fn) {
          fn(processedItem, i);
        }
        result.push(processedItem);
      }
    }
    return result;
  }
  /**
   * Populates an array with the return value from `fn`.
   * @param {Number} count Number of entries to create
   * @param {Function} fn A function that is called `count` times, return value is added to array
   * @param {Number} fn.index Current index in the array
   * @privateparam {Boolean} [oneBased] Add 1 to the index before calling the fn (making it 1 based)
   * @returns {Array} A new populated array
   */
  static populate(count, fn, oneBased = false) {
    const items = [];
    for (let i = 0; i < count; i++) {
      items.push(fn(i + (oneBased ? 1 : 0)));
    }
    return items;
  }
  /**
   * Pushes `item` on to the `array` if not already included
   * @param {Array}  array Array to push to
   * @param {...Object} items Item(s) to push if not already included
   */
  static include(array, ...items) {
    for (const item of items) {
      if (!array.includes(item)) {
        array.push(item);
      }
    }
  }
  /**
   * Returns a new array with the unique items from the supplied array.
   * @param {Array} array Input array
   * @returns {Array} New array with unique items
   */
  static unique(array) {
    return [...new Set(array)];
  }
  // Kept for future reference : Wanted to create an indexer on Stores.
  static allowNegative(array) {
    return new Proxy(array, {
      get(target, name, receiver) {
        if (typeof name !== "string") {
          return Reflect.get(target, name, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.get(target, name, receiver);
        }
        return target[index < 0 ? target.length + index : index];
      },
      set(target, name, value, receiver) {
        if (typeof name !== "string") {
          return Reflect.set(target, name, value, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.set(target, name, value, receiver);
        }
        target[index < 0 ? target.length + index : index] = value;
        return true;
      }
    });
  }
  static delta(a, b, useRelativeNaming = false) {
    if (!b) {
      return useRelativeNaming ? { toAdd: a, toRemove: [], toKeep: [] } : { onlyInA: a, onlyInB: [], inBoth: [] };
    }
    const onlyInA = [], onlyInB = [], inBoth = /* @__PURE__ */ new Set(), bSet = new Set(b);
    for (let i = 0; i < a.length; i++) {
      const item = a[i];
      if (bSet.has(item)) {
        inBoth.add(item);
      } else {
        onlyInA.push(item);
      }
    }
    for (let i = 0; i < b.length; i++) {
      const item = b[i];
      if (!inBoth.has(item)) {
        onlyInB.push(item);
      }
    }
    if (useRelativeNaming) {
      return { toAdd: onlyInA, toRemove: onlyInB, toKeep: inBoth };
    }
    return { onlyInA, onlyInB, inBoth: [...inBoth] };
  }
  /**
   * Returns the passed object wrapped in an array. Special handling of the following cases:
   * * Passing an array returns it as is
   * * Passing a `Set` returns it converted to an Array
   * * Passing `null`/`undefined` returns the passed value
   *
   * ```javascript
   * const records = ArrayHelper.asArray(record);
   *
   * // { id : 1 } -> [{ id : 1 }]
   * // [{ id : 1 }] -> [{ id : 1 }]
   * ```
   *
   * @param {*} arrayOrObject
   * @returns {Array|null}
   * @internal
   */
  static asArray(arrayOrObject) {
    if (arrayOrObject == null) {
      return arrayOrObject;
    }
    if (arrayOrObject instanceof Set) {
      return Array.from(arrayOrObject);
    }
    return Array.isArray(arrayOrObject) ? arrayOrObject : [arrayOrObject];
  }
  /**
   * Identity function that returns its input.
   * @param {*} Any value
   * @returns {*} The input value
   * @internal
   */
  static identity(x) {
    return x;
  }
  /**
   * Transform an array into a key:value dictionary using the specified
   * key and value getters. Does not group values, so only one result will
   * appear in the output for a given key.
   *
   * ```javascript
   * const input = [{
   *     id: '1',
   *     other: 'one'
   * },{
   *     id: '2',
   *     other: 'two'
   * }];
   *
   * keyBy(input, rec => rec.id)
   *
   * // {
   * //    '1': { id: '1', other: 'one' },
   * //    '2': { id: '2', other: 'two' }
   * // }
   * ```
   *
   * @param {Array} array Array from which to build dictionary
   * @param {Function|String} getKey Function to produce the key for a given array entry, or a string property name to read
   * @param {Function} getValue Optional function to transform array elements. Defaults to returning the element itself
   * @returns {Object} A key->value dictionary with keys as returned by `getKey` and values returned by `getValue`
   * @internal
   */
  static keyBy(array, keyGetter, valueGetter = _ArrayHelper.identity) {
    const getKey = typeof keyGetter === "string" ? (o) => o == null ? void 0 : o[keyGetter] : keyGetter, getValue = typeof valueGetter === "string" ? (o) => o == null ? void 0 : o[valueGetter] : valueGetter;
    return array.reduce((dict, next) => {
      dict[getKey(next)] = getValue(next);
      return dict;
    }, {});
  }
  /**
   * Combines provided arrays of by aggregating their element values.
   * For example the below code sums up numeric elements of the arrays:
   *
   * ```javascript
   * ArrayHelper.aggregate(
   *     [
   *         [0,   1,  2, 33]
   *         [10,  1, -1],
   *         [100, 1, -1]
   *     ],
   *     entry => entry || 0, // "|| 0" here to make it work for different array sizes
   *     (aggregated, entry) => aggregated + entry, // aggregate by summing up
   *     () => 0 //initial value is zero
   * );
   *
   * // returns [111, 3, 0, 33] array
   * ```
   *
   * @param {Array[]} arrays Array to combine
   * @param {Function} getEntryValueFn Function that extracts an array entry for aggregating.
   * @param {Function} aggregatorFn A function to execute for each element in the arrays. It's purpose is to
   * aggregate the element value to the corresponding entry of the resulting array.
   * The function's return value becomes the value of the `aggregated` parameter on the next invocation of
   * `aggregatorFn`.
   * The function is called with the following arguments:
   *
   * @param {Object} aggregatorFn.aggregated Resulting array entry value. On the first call
   * `getInitialValueFn` result.
   * @param {Object} aggregatorFn.entry Current entry to aggregate into `aggregated`.
   * @param {Number} aggregatorFn.arrayIndex Index of current array (in the provided `arrays`).
   * @param {Object[]} aggregatorFn.entryIndex Index of the current entry.
   * @param {Object} aggregationContext A shared object providing extra aggregation call context.
   * @param {Function} getInitialValueFn Function that returns an initial value for the combined array entries.
   * @param {Object} [aggregationContext] Optional object that is passed to all of the above functions that can
   * be used for keeping some additional parameters used when aggregating.
   * Out of the box the object will contain `arrays` and `targetArray` properties containing
   * input and resulting arrays respectively.
   */
  static aggregate(arrays, getEntryValueFn, aggregatorFn, getInitialValueFn, aggregationContext = {}) {
    const rowLength = arrays.length, columnLength = arrays[0].length, result = [];
    aggregationContext.targetArray = result;
    aggregationContext.arrays = arrays;
    for (let colIndex = 0; colIndex < columnLength; colIndex++) {
      aggregationContext.entryIndex = colIndex;
      result.push(getInitialValueFn(colIndex, aggregationContext));
    }
    for (let rowIndex = 0; rowIndex < rowLength; rowIndex++) {
      const row = arrays[rowIndex];
      aggregationContext.rowIndex = rowIndex;
      for (let colIndex = 0; colIndex < columnLength; colIndex++) {
        aggregationContext.entryIndex = colIndex;
        const entryValue = getEntryValueFn(row[colIndex], aggregationContext);
        result[colIndex] = aggregatorFn(result[colIndex], entryValue, rowIndex, colIndex, aggregationContext);
      }
    }
    return result;
  }
  /**
   * Group an array by keys (either the values in a specified property name, or the results of a string-generating function accepting
   * an array entry as input), returning an Object with those keys, whose values are arrays containing the array entries that
   * produced that key.
   *
   * ```javascript
   * const input = [{
   *     id: 1,
   *     color: 'red'
   * },{
   *     id: 2,
   *     color: 'green'
   * },{
   *     id: 3,
   *     color: 'green'
   * }];
   *
   * groupBy(input, 'color')
   *
   * // {
   * //    'red': [ { id: '1', color: 'red' } ],
   * //    'green': [ { id: '2', color: 'green' }, { id: '3', color: 'green' } ]
   * // }
   *
   * groupBy(input, rec => rec.color?.substr(0, 1))
   *
   * // {
   * //    'r': [ { id: '1', color: 'red' } ],
   * //    'g': [ { id: '2', color: 'green' }, { id: '3', color: 'green' } ]
   * // }
   * ```
   *
   * @param {Object} array Array from which to build dictionary
   * @param {Function|String} getGroupKey Function to produce the key for a given array entry, or a string property name to read
   * @returns {Object} A key->value[] dictionary with keys as returned by `getKey` and arrays of matching items in original order as values
   * @internal
   */
  static groupBy(array, groupKeyGetter) {
    const getKey = typeof groupKeyGetter === "string" ? (o) => o == null ? void 0 : o[groupKeyGetter] : groupKeyGetter;
    return array.reduce((grouped, value) => {
      const key = getKey(value);
      (grouped[key] = grouped[key] || []).push(value);
      return grouped;
    }, {});
  }
};
ArrayHelper._$name = "ArrayHelper";

// ../Core/lib/Core/helper/FunctionHelper.js
var commaSepRe = /,\s*/;
var decompiledSym = Symbol("decompiled");
var fnRe1 = /^\s*(async\s+)?([a-z_]\w*)\s*=>([\s\S]+)$/i;
var fnRe2 = /^\s*(async\s*)?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)\s+=>([\s\S]+)$/i;
var fnRe3 = /^(\s*async)?(?:\s*function)?(?:\s*([a-z_]\w*))?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)([\s\S]+)$/i;
var { hasOwnProperty: hasOwnProperty4 } = Object.prototype;
var FunctionHelper = class _FunctionHelper {
  /**
   * Inserts a function after the specified `method` is called on an `object`. To remove this hook, invoke the
   * function returned by this method.
   * ```
   *  class A {
   *      method() {
   *          console.log('method');
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.after(instance, 'method', () => { console.log('after') });
   *
   *  instance.method();
   *  > method
   *  > after
   *
   *  detach();
   *  instance.method();
   *  > method
   * ```
   * The value returned by the original method is passed as the first argument to `fn` followed by all the arguments
   * passed by the caller.
   *
   * If `fn` returns a value (not `undefined`), that value is returned from the method call instead of the value
   * returned by the original method.
   * ```
   *  class A {
   *      method(x) {
   *          console.log('method', x);
   *          return x * 2
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.after(instance, 'method', (ret, x) => {
   *      console.log('after', ret, x);
   *      return x / 2;
   *  });
   *
   *  console.log(instance.method(50));
   *  > method 50
   *  > after 100 50
   *  > 25
   *
   *  detach();
   *  console.log(instance.method(50));
   *  > method 50
   *  > 100
   * ```
   *
   * @param {Object} object The object to hook.
   * @param {String} method The name of the method on `object` to hook.
   * @param {Function|String} fn The function or method name (on `thisObj`) to call after `method`.
   * @param {Object} [thisObj] The `this` pointer value for calling `fn`.
   * @param {Object} [options] Additional options
   * @param {Boolean} [options.return=true] Specify `false` to not include the return value of the hooked method as
   * the first argument to `fn`.
   * @returns {Function} The function to call to remove the hook.
   */
  static after(object, method, fn, thisObj, options) {
    const named = typeof fn === "string", withReturn = (options == null ? void 0 : options.return) !== false, hook = (...args) => {
      const origResult = hook.$nextHook.call(object, ...args), hookResult = (thisObj == null ? void 0 : thisObj.isDestroyed) ? void 0 : withReturn ? named ? thisObj[fn](origResult, ...args) : fn.call(thisObj, origResult, ...args) : named ? thisObj[fn](...args) : fn.call(thisObj, ...args);
      return hookResult === void 0 ? origResult : hookResult;
    };
    return _FunctionHelper.hookMethod(object, method, hook);
  }
  /**
   * Inserts a function before the specified `method` is called on an `object`. To remove this hook, invoke the
   * function returned by this method.
   * ```
   *  class A {
   *      method() {
   *          console.log('method');
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.before(instance, 'method', () => { console.log('before') });
   *
   *  instance.method();
   *  > before
   *  > method
   *
   *  detach();
   *  instance.method();
   *  > method
   * ```
   * If `fn` returns `false`, the original method is not invoked and `false` is returned to the caller.
   * ```
   *  class A {
   *      method(x) {
   *          console.log('method', x);
   *          return x * 2;
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.before(instance, 'method', x => {
   *      console.log('before', x);
   *      return false;
   *  });
   *
   *  console.log(instance.method(50));
   *  > before 50
   *  > false
   *
   *  detach();
   *  console.log(instance.method(50));
   *  > method 50
   *  > 100
   * ```
   *
   * @param {Object} object The object to hook.
   * @param {String} method The name of the method on `object` to hook.
   * @param {Function|String} fn The function or method name (on `thisObj`) to call before `method`.
   * @param {Object} [thisObj] The `this` pointer value for calling `fn`.
   * @returns {Function} The function to call to remove the hook.
   */
  static before(object, method, fn, thisObj) {
    const named = typeof fn === "string", hook = (...args) => {
      const ret = (thisObj == null ? void 0 : thisObj.isDestroyed) ? 0 : named ? thisObj[fn](...args) : fn.call(thisObj, ...args);
      return ret === false ? ret : hook.$nextHook.call(object, ...args);
    };
    return _FunctionHelper.hookMethod(object, method, hook);
  }
  static curry(func) {
    return function curried(...args) {
      if (args.length >= func.length) {
        return func.apply(this, args);
      } else {
        return function(...args2) {
          return curried.apply(this, args.concat(args2));
        };
      }
    };
  }
  static bindAll(obj) {
    for (const key in obj) {
      if (typeof obj[key] === "function") {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
  /**
   * Returns a function which calls the passed `interceptor` function first, and the passed `original` after
   * as long as the `interceptor` does not return `false`.
   * @param {Function} original The function to call second.
   * @param {Function} interceptor The function to call first.
   * @param {Object} [thisObj] The `this` reference when the functions are called.
   * @returns {Function} A function which yields the return value from the `original` function **if it was called**, else `false`.
   */
  static createInterceptor(original, interceptor, thisObj) {
    return function(...args) {
      const theThis = thisObj || this;
      if (interceptor.call(theThis, ...args) !== false) {
        return original.call(theThis, ...args);
      }
      return false;
    };
  }
  /**
   * Returns a function which calls the passed `sequence` function after calling
   * the passed `original`.
   * @param {Function} original The function to call first.
   * @param {Function} sequence The function to call second.
   * @param {Object} [thisObj] The `this` reference when the functions are called.
   * @returns {Function} A function which yields the value returned from the sequence if it returned a value, else the return
   * value from the original function.
   */
  static createSequence(original, sequence, thisObj) {
    return (...args) => {
      const origResult = original.call(thisObj, ...args), sequenceResult = sequence.call(thisObj, ...args);
      return sequenceResult === void 0 ? origResult : sequenceResult;
    };
  }
  /**
   * Create a "debounced" function which will call on the "leading edge" of a timer period.
   * When first invoked will call immediately, but invocations after that inside its buffer
   * period will be rejected, and *one* invocation will be made after the buffer period has expired.
   *
   * This is useful for responding immediately to a first mousemove, but from then on, only
   * calling the action function on a regular timer while the mouse continues to move.
   *
   * @param {Function} fn The function to call.
   * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Array} [extraArgs] The argument list to append to those passed to the function.
   * @param {Function} [alt] A function to call when the invocation is rejected due to buffer time not having expired.
   * @returns {Function} A function which calls the passed `fn` only if at least the passed `buffer`
   * milliseconds has elapsed since its last invocation.
   */
  static createThrottled(fn, buffer, thisObj, extraArgs, alt) {
    let lastCallTime = -Number.MAX_VALUE, callArgs, timerId;
    const invoke = () => {
      timerId = 0;
      lastCallTime = performance.now();
      callArgs.push.apply(callArgs, extraArgs);
      fn.apply(thisObj, callArgs);
    }, result = function(...args) {
      const elapsed = performance.now() - lastCallTime;
      callArgs = args;
      if (elapsed >= buffer) {
        clearTimeout(timerId);
        invoke();
      } else {
        if (!timerId) {
          timerId = setTimeout(invoke, buffer - elapsed);
        }
        if (alt) {
          callArgs.push.apply(callArgs, extraArgs);
          alt.apply(thisObj, callArgs);
        }
      }
    };
    result.cancel = () => clearTimeout(timerId);
    return result;
  }
  /**
   * Create a "debounced" function which will call on the "trailing edge" of a timer period.
   * When first invoked will wait until the buffer period has expired to call the function, and
   * more calls within that time will restart the timer.
   *
   * This is useful for responding to keystrokes, but deferring action until the user pauses typing.
   *
   * @param {Function} fn The function to call.
   * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Array} [args] The argument list to append to those passed to the function.
   * @returns {Function} A function which calls the passed `fn` when at least the passed `buffer`
   * milliseconds has elapsed since its last invocation.
   */
  static createBuffered(fn, buffer, thisObj, args) {
    let callArgs, timerId;
    const invoke = () => {
      timerId = 0;
      result.isPending = false;
      callArgs.push.apply(callArgs, args);
      fn.apply(thisObj, callArgs);
    }, result = function(...args2) {
      callArgs = args2;
      if (timerId) {
        clearTimeout(timerId);
      }
      result.isPending = true;
      timerId = setTimeout(invoke, buffer);
    };
    result.cancel = () => {
      result.isPending = false;
      clearTimeout(timerId);
    };
    return result;
  }
  static decompile(fn) {
    if (!(decompiledSym in fn)) {
      const code = fn.toString();
      let m = fnRe1.exec(code), args, body, name, decompiled, t;
      if (m) {
        args = [m[2]];
        body = m[3];
      } else if (m = fnRe2.exec(code)) {
        t = m[2].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[3];
      } else if (m = fnRe3.exec(code)) {
        name = m[2];
        t = m[3].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[4];
      }
      body = body == null ? void 0 : body.trim();
      fn[decompiledSym] = decompiled = m && {
        args,
        async: Boolean(m[1]),
        body: (body == null ? void 0 : body.startsWith("{")) ? body.substring(1, body.length - 1).trim() : body
      };
      if (name) {
        decompiled.name = name;
      }
    }
    return fn[decompiledSym];
  }
  static hookMethod(object, method, hook) {
    hook.$nextHook = object[method];
    object[method] = hook;
    return () => {
      var _a2;
      if (hasOwnProperty4.call(object, method)) {
        let f = object[method], next;
        if (f === hook) {
          if (((_a2 = Object.getPrototypeOf(object)) == null ? void 0 : _a2[method]) === hook.$nextHook) {
            delete object[method];
          } else {
            object[method] = hook.$nextHook;
          }
        } else {
          for (; next = f == null ? void 0 : f.$nextHook; f = next) {
            if (next === hook) {
              f.$nextHook = hook.$nextHook;
              break;
            }
          }
        }
      }
    };
  }
  /**
   * Protects the specified `method` on a given `object` such that calling it will not throw exceptions.
   * @param {Object} object The object whose method is to be protected.
   * @param {String} method The name of the method to protect.
   * @param {Function} [handler] An optional function to call for any thrown exceptions.
   * @internal
   */
  static noThrow(object, method, handler) {
    const fn = object[method];
    object[method] = (...args) => {
      try {
        return fn.apply(object, args);
      } catch (e) {
        return handler == null ? void 0 : handler(e);
      }
    };
  }
  static returnTrue() {
    return true;
  }
  static animate(duration, fn, thisObj, easing = "linear") {
    let cancel = false;
    const result = new Promise((resolve) => {
      const start = performance.now(), iterate = () => {
        const progress = Math.min((performance.now() - start) / duration, 1), delayable = thisObj && thisObj.setTimeout ? thisObj : globalThis;
        if (!cancel) {
          if (fn.call(thisObj, this.easingFunctions[easing](progress)) === false) {
            resolve();
          }
        }
        if (cancel || progress === 1) {
          delayable.requestAnimationFrame(() => resolve());
        } else {
          delayable.requestAnimationFrame(iterate);
        }
      };
      iterate();
    });
    result.cancel = () => {
      cancel = true;
      result.cancelled = true;
      return false;
    };
    return result;
  }
};
var half = 0.5;
var e1 = 1.70158;
var e2 = 7.5625;
var e3 = 1.525;
var e4 = 2 / 2.75;
var e5 = 2.25 / 2.75;
var e6 = 1 / 2.75;
var e7 = 1.5 / 2.75;
var e8 = 2.5 / 2.75;
var e9 = 2.625 / 2.75;
var e10 = 0.75;
var e11 = 0.9375;
var e12 = 0.984375;
var s1 = 1.70158;
var s2 = 1.70158;
FunctionHelper.easingFunctions = {
  linear: (t) => t,
  easeInQuad: (t) => Math.pow(t, 2),
  easeOutQuad: (t) => -(Math.pow(t - 1, 2) - 1),
  easeInOutQuad: (t) => (t /= half) < 1 ? half * Math.pow(t, 2) : -half * ((t -= 2) * t - 2),
  easeInCubic: (t) => Math.pow(t, 3),
  easeOutCubic: (t) => Math.pow(t - 1, 3) + 1,
  easeInOutCubic: (t) => (t /= half) < 1 ? half * Math.pow(t, 3) : half * (Math.pow(t - 2, 3) + 2),
  easeInQuart: (t) => Math.pow(t, 4),
  easeOutQuart: (t) => -(Math.pow(t - 1, 4) - 1),
  easeInOutQuart: (t) => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeInQuint: (t) => Math.pow(t, 5),
  easeOutQuint: (t) => Math.pow(t - 1, 5) + 1,
  easeInOutQuint: (t) => (t /= half) < 1 ? half * Math.pow(t, 5) : half * (Math.pow(t - 2, 5) + 2),
  easeInSine: (t) => -Math.cos(t * (Math.PI / 2)) + 1,
  easeOutSine: (t) => Math.sin(t * (Math.PI / 2)),
  easeInOutSine: (t) => -half * (Math.cos(Math.PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => t === 0 ? 0 : t === 1 ? 1 : (t /= half) < 1 ? half * Math.pow(2, 10 * (t - 1)) : half * (-Math.pow(2, -10 * --t) + 2),
  easeInCirc: (t) => -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => (t /= half) < 1 ? -half * (Math.sqrt(1 - t * t) - 1) : half * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeOutBounce: (t) => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  easeInBack: (t) => t * t * ((e1 + 1) * t - e1),
  easeOutBack: (t) => (t = t - 1) * t * ((e1 + 1) * t + e1) + 1,
  easeInOutBack: (t) => {
    let v1 = s1;
    return (t /= half) < 1 ? half * (t * t * (((v1 *= e3) + 1) * t - v1)) : half * ((t -= 2) * t * (((v1 *= e3) + 1) * t + v1) + 2);
  },
  elastic: (t) => -1 * Math.pow(4, -8 * t) * Math.sin((t * 6 - 1) * (2 * Math.PI) / 2) + 1,
  swingFromTo: (t) => {
    let v2 = s2;
    return (t /= half) < 1 ? half * (t * t * (((v2 *= e3) + 1) * t - v2)) : half * ((t -= 2) * t * (((v2 *= e3) + 1) * t + v2) + 2);
  },
  swingFrom: (t) => t * t * ((e1 + 1) * t - e1),
  swingTo: (t) => (t -= 1) * t * ((e1 + 1) * t + e1) + 1,
  bounce: (t) => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  bouncePast: (t) => t < e6 ? e2 * t * t : t < e4 ? 2 - (e2 * (t -= e7) * t + e10) : t < e8 ? 2 - (e2 * (t -= e5) * t + e11) : 2 - (e2 * (t -= e9) * t + e12),
  easeFromTo: (t) => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeFrom: (t) => Math.pow(t, 4),
  easeTo: (t) => Math.pow(t, 0.25)
};
FunctionHelper._$name = "FunctionHelper";

// ../Core/lib/Core/mixin/Events.js
var { isArray } = Array;
var { hasOwnProperty: hasOwnProperty5 } = Object.prototype;
var specialProperties = {
  thisObj: 1,
  detachable: 1,
  once: 1,
  detacher: 1,
  prio: 1,
  args: 1,
  expires: 1,
  buffer: 1,
  throttle: 1,
  name: 1,
  $internal: 1
};
var priorityComparator = (a, b) => b.prio - a.prio;
var Events_default = (Target) => class Events extends (Target || Base) {
  constructor() {
    super(...arguments);
    __publicField(this, "eventsSuspended", null);
  }
  static get $name() {
    return "Events";
  }
  //region Events
  /**
   * Fires before an object is destroyed.
   * @event beforeDestroy
   * @param {Core.Base} source The Object that is being destroyed.
   */
  /**
   * Fires when an object is destroyed.
   * @event destroy
   * @param {Core.Base} source The Object that is being destroyed.
   */
  /**
   * Fires when any other event is fired from the object.
   *
   * **Note**: `catchAll` is fired for both public and private events. Please rely on the public events only.
   * @event catchAll
   * @param {Object} event The Object that contains event details
   * @param {String} event.type The type of the event which is caught by the listener
   * @typings event -> {{[key: string]: any, type: string}}
   */
  //endregion
  static get declarable() {
    return [
      /**
       * The list of deprecated events as an object, where `key` is an event name which is deprecated and
       * `value` is an object which contains values for
       * {@link Core.helper.VersionHelper#function-deprecate-static VersionHelper}:
       * - product {String} The name of the product;
       * - invalidAsOfVersion {String} The version where the offending code is invalid (when any compatibility
       *   layer is actually removed);
       * - message {String} Warning message to show to the developer using a deprecated API;
       *
       * For example:
       *
       * ```javascript
       * return {
       *     click : {
       *         product            : 'Grid',
       *         invalidAsOfVersion : '1.0.0',
       *         message            : 'click is deprecated!'
       *     }
       * }
       * ```
       *
       * @name deprecatedEvents
       * @returns {Object}
       * @static
       * @internal
       */
      "deprecatedEvents"
    ];
  }
  static setupDeprecatedEvents(cls, meta) {
    const all = meta.getInherited("deprecatedEvents"), add = cls.deprecatedEvents;
    for (const eventName in add) {
      all[eventName.toLowerCase()] = all[eventName] = add[eventName];
    }
  }
  //region Config
  static get configurable() {
    return {
      /**
       * Set to true to call onXXX method names (e.g. `onShow`, `onClick`), as an easy way to listen for events.
       *
       * ```javascript
       * const container = new Container({
       *     callOnFunctions : true
       *
       *     onHide() {
       *          // Do something when the 'hide' event is fired
       *     }
       * });
       * ```
       *
       * @config {Boolean} callOnFunctions
       * @category Misc
       * @default false
       */
      /**
       * The listener set for this object.
       *
       * An object whose property names are the names of events to handle, or options which modifiy
       * __how__ the handlers are called.
       *
       * See {@link #function-addListener} for details about the options.
       *
       * Listeners can be specified in target class config and they will be merged with any listeners specified in
       * the instantiation config. Class listeners will be fired first:
       *
       * ```javascript
       * class MyStore extends Store({
       *     static get configurable() {
       *         return {
       *             listeners : {
       *                 myCustomEvent() {
       *                 },
       *                 load : {
       *                     prio : 10000,
       *                     fn() { // this load listener handles things first }
       *                 }
       *             }
       *         }
       *     }
       * });
       *
       * let store = new MyStore({
       *   listeners: {
       *     load: () => { // This load listener runs after the class's },
       *     ...
       *   }
       * });
       * ```
       *
       * ### Handlers as function name
       *
       * Object event handlers may be specified as a function __name__. If a string is specified, it is the name
       * of the function in the `thisObj` object.
       *
       * If the string begins with `up.`, this object's ownership hierarchy
       * (if present) is scanned for an object which implements that function name:
       *
       * ```javascript
       * new Popup({
       *     tbar : {
       *         items : {
       *             myCombo : {
       *                 type      : 'combo',
       *                 editable  : false,
       *                 label     : 'Type',
       *                 listeners : {
       *                     // Look in owner chain for this function name
       *                     change : 'up.onFilterChange'
       *                 },
       *                 items     : [
       *                     'Event',
       *                     'Task',
       *                     'Appointment'
       *                 ]
       *             }
       *         }
       *     },
       *     items : {
       *         ...
       *     },
       *     onFilterChange({ value }) {
       *         // Handle event type selection here
       *     }
       * });
       *```
       *
       * @config {Object}
       * @category Common
       */
      listeners: {
        value: null,
        $config: {
          merge(newValue, currentValue) {
            if (newValue !== null) {
              if (!newValue) {
                return currentValue;
              }
              if (currentValue) {
                newValue = newValue ? [newValue] : [];
                newValue.push[isArray(currentValue) ? "apply" : "call"](newValue, currentValue);
              }
            }
            return newValue;
          }
        }
      },
      /**
       * Internal listeners, that cannot be removed by the user.
       * @config {Object}
       * @internal
       */
      internalListeners: null,
      /**
       * An object where property names with a truthy value indicate which events should bubble up the ownership
       * hierarchy when triggered.
       *
       * ```javascript
       * const container = new Container({
       *     items : [
       *        { type : 'text', bubbleEvents : { change : true }}
       *     ],
       *
       *     listeners : {
       *         change() {
       *             // Will catch change event from the text field
       *         }
       *     }
       * });
       * ```
       *
       * @config {Object}
       * @category Misc
       */
      bubbleEvents: null
    };
  }
  destroy() {
    this.trigger("beforeDestroy");
    super.destroy();
  }
  //endregion
  //region Init
  construct(config, ...args) {
    if (this.configuredListeners = config == null ? void 0 : config.listeners) {
      config = Objects.assign({}, config);
      delete config.listeners;
    }
    super.construct(config, ...args);
    this.processConfiguredListeners();
  }
  processConfiguredListeners() {
    if (this.configuredListeners) {
      const me = this, { isConfiguring } = me;
      me.isConfiguring = false;
      me.listeners = me.configuredListeners;
      me.configuredListeners = null;
      me.isConfiguring = isConfiguring;
    }
  }
  /**
   * Auto detaches listeners registered from start, if set as detachable
   * @internal
   */
  doDestroy() {
    this.trigger("destroy");
    this.removeAllListeners(false);
    super.doDestroy();
  }
  static setupClass(meta) {
    super.setupClass(meta);
    Events.prototype.onListen.$nullFn = true;
    Events.prototype.onUnlisten.$nullFn = true;
  }
  //endregion
  //region Listeners
  /**
   * Adds an event listener. This method accepts parameters in the following format:
   *
   * ```javascript
   *  myObject.addListener({
   *      thisObj    : this,          // The this reference for the handlers
   *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,
   *      otherevent : {
   *          fn      : 'handlerFnName',
   *          once    : true          // Just this handler is auto-removed on fire
   *      },
   *      yetanother  : {
   *          fn      : 'yetAnotherHandler',
   *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler
   *      },
   *      prio        : 100           // Higher prio listeners are called before lower
   *  });
   * ```
   *
   * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.
   * When it is destroyed, those listeners are removed.
   *
   * The `config` parameter allows supplying options for the listener(s), for available options see {@link #typedef-BryntumListenerConfig}.
   *
   * A simpler signature may be used when only adding a listener for one event and no extra options
   * (such as `once` or `delay`) are required:
   *
   * ```javascript
   * myObject.addListener('click', myController.handleClicks, myController);
   * ```
   *
   * The args in this simple case are `eventName`, `handler` and `thisObj`
   *
   * @param {BryntumListenerConfig|String} config An object containing listener definitions, or the event name to listen for
   * @param {Object|Function} [thisObj] Default `this` reference for all listeners in the config object, or the handler
   * function to call if providing a string as the first arg.
   * @param {Object} [oldThisObj] The `this` reference if the old signature starting with a string event name is used..
   * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners
   */
  addListener(config, thisObj, oldThisObj) {
    var _a2;
    if (isArray(config)) {
      for (let i = 0, { length } = config; i < length; i++) {
        this.addListener(config[i], thisObj);
      }
      return;
    }
    const me = this, deprecatedEvents = me.$meta.getInherited("deprecatedEvents");
    if (typeof config === "string") {
      return me.addListener({
        [config]: thisObj,
        detachable: thisObj.detachable !== false,
        thisObj: oldThisObj
      });
    } else {
      thisObj = config.thisObj = config.thisObj !== void 0 ? config.thisObj : thisObj;
      for (const key in config) {
        if (!specialProperties[key] && config[key] != null) {
          const eventName = key.toLowerCase(), deprecatedEvent = deprecatedEvents == null ? void 0 : deprecatedEvents[eventName], events = me.eventListeners || (me.eventListeners = {}), specs = ArrayHelper.asArray(config[key]);
          if (deprecatedEvent) {
            const { product, invalidAsOfVersion, message } = deprecatedEvent;
            VersionHelper.deprecate(product, invalidAsOfVersion, message);
          }
          for (const listenerSpec of specs) {
            const expires = listenerSpec.expires || config.expires, listener = {
              fn: typeof listenerSpec === "object" ? listenerSpec.fn : listenerSpec,
              thisObj: listenerSpec.thisObj !== void 0 ? listenerSpec.thisObj : thisObj,
              args: listenerSpec.args || config.args,
              prio: listenerSpec.prio !== void 0 ? listenerSpec.prio : config.prio !== void 0 ? config.prio : 0,
              once: listenerSpec.once !== void 0 ? listenerSpec.once : config.once !== void 0 ? config.once : false,
              buffer: listenerSpec.buffer || config.buffer,
              throttle: listenerSpec.throttle || config.throttle,
              $internal: config.$internal,
              catchAll: key === "catchAll"
            };
            if (expires) {
              const { alt } = expires, delay = alt ? expires.delay : expires, name2 = config.name || key, fn = () => {
                me.un(eventName, listener);
                if (alt && !listener.called) {
                  me.callback(alt, thisObj);
                }
              };
              if (me.isDelayable) {
                me.setTimeout({
                  fn,
                  name: name2,
                  cancelOutstanding: true,
                  delay
                });
              } else {
                globalThis.setTimeout(fn, delay);
              }
            }
            let listeners = events[eventName] || (events[eventName] = []);
            if (listeners.$firing) {
              events[eventName] = listeners = listeners.slice();
            }
            listeners.splice(
              ArrayHelper.findInsertionIndex(listener, listeners, priorityComparator, listeners.length),
              0,
              listener
            );
            if (!me.onListen.$nullFn && listeners.length < 2) {
              me.onListen(eventName);
            }
            (_a2 = me.afterAddListener) == null ? void 0 : _a2.call(me, eventName, listener);
          }
        }
      }
      if (config.relayAll) {
        me.relayAll(config.relayAll);
      }
      if (thisObj && thisObj !== me) {
        me.attachAutoDetacher(config, thisObj);
      }
      const detachable = config.detachable !== false, name = config.name, destroy = config.expires || detachable || name ? () => {
        if (!me.isDestroyed) {
          me.removeListener(config, thisObj);
        }
      } : null;
      if (destroy) {
        destroy.eventer = me;
        destroy.listenerName = name;
        if (name && (thisObj == null ? void 0 : thisObj.trackDetacher)) {
          thisObj.trackDetacher(name, destroy);
        }
        if (config.expires) {
          me.delay(destroy, isNaN(config.expires) ? config.expires.delay : config.expires, name);
        }
        if (detachable) {
          return destroy;
        }
      }
    }
  }
  /**
   * Alias for {@link #function-addListener}. Adds an event listener. This method accepts parameters in the following format:
   *
   * ```javascript
   *  myObject.on({
   *      thisObj    : this,          // The this reference for the handlers
   *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,
   *      otherevent : {
   *          fn      : 'handlerFnName',
   *          once    : true          // Just this handler is auto-removed on fire
   *      },
   *      yetanother  : {
   *          fn      : 'yetAnotherHandler',
   *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler
   *      },
   *      prio        : 100           // Higher prio listeners are called before lower
   *  });
   * ```
   *
   * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.
   * When it is destroyed, those listeners are removed.
   *
   * The `config` parameter allows supplying options for the listener(s), for available options see {@link #typedef-BryntumListenerConfig}.
   *
   * A simpler signature may be used when only adding a listener for one event and no extra options
   * (such as `once` or `delay`) are required:
   *
   * ```javascript
   * myObject.on('click', myController.handleClicks, myController);
   * ```
   *
   * The args in this simple case are `eventName`, `handler` and `thisObj`
   *
   * @param {BryntumListenerConfig|String} config An object containing listener definitions, or the event name to listen for
   * @param {Object|Function} [thisObj] Default `this` reference for all listeners in the config object, or the handler
   * function to call if providing a string as the first arg.
   * @param {Object} [oldThisObj] The `this` reference if the old signature starting with a string event name is used..
   * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners
   */
  on(config, thisObj, oldThisObj) {
    return this.addListener(config, thisObj, oldThisObj);
  }
  /**
   * Internal convenience method for adding an internal listener, that cannot be removed by the user.
   *
   * Alias for `on({ $internal : true, ... })`. Only supports single argument form.
   *
   * @internal
   */
  ion(config) {
    config.$internal = true;
    return this.on(config);
  }
  /**
   * Shorthand for {@link #function-removeListener}
   * @param {Object|String} config A config object or the event name
   * @param {Object|Function} [thisObj] `this` reference for all listeners, or the listener function
   * @param {Object} [oldThisObj] `this` The `this` object for the legacy way of adding listeners
   */
  un(...args) {
    this.removeListener(...args);
  }
  updateInternalListeners(internalListeners, oldInternalListeners) {
    oldInternalListeners == null ? void 0 : oldInternalListeners.detach();
    if (internalListeners) {
      internalListeners.detach = this.ion(internalListeners);
    }
  }
  get listeners() {
    return this.eventListeners;
  }
  changeListeners(listeners) {
    if (this.isConfiguring) {
      this.getConfig("internalListeners");
      if (listeners) {
        this.on(listeners, this);
      }
    } else {
      if (Array.isArray(listeners)) {
        for (let i = 0, l = listeners[0], { length } = listeners; i < length; l = listeners[++i]) {
          if (!("thisObj" in l)) {
            listeners[i] = Objects.assign({ thisObj: this }, l);
          }
        }
      } else if (listeners && !("thisObj" in listeners)) {
        listeners = Objects.assign({ thisObj: this }, listeners);
      }
      return listeners;
    }
  }
  updateListeners(listeners, oldListeners) {
    oldListeners && this.un(oldListeners);
    listeners && this.on(listeners);
  }
  /**
   * Removes an event listener. Same API signature as {@link #function-addListener}
   * @param {Object|String} config A config object or the event name
   * @param {Object|Function} thisObj `this` reference for all listeners, or the listener function
   * @param {Object} oldThisObj `this` The `this` object for the legacy way of adding listeners
   */
  removeListener(config, thisObj = config.thisObj, oldThisObj) {
    const me = this;
    if (typeof config === "string") {
      return me.removeListener({ [config]: thisObj }, oldThisObj);
    }
    Object.entries(config).forEach(([eventName, listenerToRemove]) => {
      var _a2;
      if (!specialProperties[eventName] && listenerToRemove != null) {
        eventName = eventName.toLowerCase();
        const { eventListeners } = me, index = me.findListener(eventName, listenerToRemove, thisObj);
        if (index >= 0) {
          let listeners = eventListeners[eventName];
          (_a2 = me.afterRemoveListener) == null ? void 0 : _a2.call(me, eventName, listeners[index]);
          if (listeners.length > 1) {
            if (listeners.$firing) {
              eventListeners[eventName] = listeners = listeners.slice();
            }
            listeners.splice(index, 1);
          } else {
            delete eventListeners[eventName];
            if (!me.onUnlisten.$nullFn) {
              me.onUnlisten(eventName);
            }
          }
        }
      }
    });
    if (config.thisObj && !config.thisObj.isDestroyed) {
      me.detachAutoDetacher(config);
    }
  }
  /**
   * Finds the index of a particular listener to the named event. Returns `-1` if the passed
   * function/thisObj listener is not present.
   * @param {String} eventName The name of an event to find a listener for.
   * @param {String|Function} listenerToFind The handler function to find.
   * @param {Object} defaultThisObj The `thisObj` for the required listener.
   * @internal
   */
  findListener(eventName, listenerToFind, defaultThisObj) {
    var _a2;
    const eventListeners = (_a2 = this.eventListeners) == null ? void 0 : _a2[eventName], fn = listenerToFind.fn || listenerToFind, thisObj = listenerToFind.thisObj || defaultThisObj;
    if (eventListeners) {
      for (let listenerEntry, i = 0, { length } = eventListeners; i < length; i++) {
        listenerEntry = eventListeners[i];
        if (listenerEntry.fn === fn && listenerEntry.thisObj === thisObj) {
          return i;
        }
      }
    }
    return -1;
  }
  /**
   * Check if any listener is registered for the specified eventName
   * @param {String} eventName
   * @returns {Boolean} `true` if listener is registered, otherwise `false`
   * @advanced
   */
  hasListener(eventName) {
    var _a2;
    return Boolean((_a2 = this.eventListeners) == null ? void 0 : _a2[eventName == null ? void 0 : eventName.toLowerCase()]);
  }
  /**
   * Relays all events through another object that also implements Events mixin. Adds a prefix to the event name
   * before relaying, for example add -> storeAdd
   * ```
   * // Relay all events from store through grid, will make it possible to listen for store events prefixed on grid:
   * 'storeLoad', 'storeChange', 'storeRemoveAll' etc.
   * store.relayAll(grid, 'store');
   *
   * grid.on('storeLoad', () => console.log('Store loaded');
   * ```
   * @param {Core.mixin.Events} through Object to relay the events through, needs to mix Events mixin in
   * @param {String} prefix Prefix to add to event name
   * @param {Boolean} [transformCase] Specify false to prevent making first letter of event name uppercase
   * @advanced
   */
  relayAll(through, prefix, transformCase = true) {
    if (!this.relayAllTargets) {
      this.relayAllTargets = [];
    }
    const { relayAllTargets } = this;
    through.ion({
      beforeDestroy: ({ source }) => {
        if (source === through) {
          const configs = relayAllTargets.filter((r) => r.through === through);
          configs.forEach((config) => ArrayHelper.remove(relayAllTargets, config));
        }
      }
    });
    relayAllTargets.push({ through, prefix, transformCase });
  }
  /**
   * Removes all listeners registered to this object by the application.
   */
  removeAllListeners(preserveInternal = true) {
    var _a2;
    const listeners = this.eventListeners;
    let i, thisObj;
    for (const event in listeners) {
      const bucket = listeners[event];
      for (i = bucket.length; i-- > 0; ) {
        const cfg = bucket[i];
        if (!cfg.$internal || !preserveInternal) {
          this.removeListener(event, cfg);
          thisObj = cfg.thisObj;
          (_a2 = thisObj == null ? void 0 : thisObj.untrackDetachers) == null ? void 0 : _a2.call(thisObj, this);
        }
      }
    }
  }
  relayEvents(source, eventNames, prefix = "") {
    const listenerConfig = { detachable: true, thisObj: this };
    eventNames.forEach((eventName) => {
      listenerConfig[eventName] = (event, ...params) => {
        return this.trigger(prefix + eventName, event, ...params);
      };
    });
    return source.on(listenerConfig);
  }
  /**
   * This method is called when the first listener for an event is added.
   * @param {String} eventName
   * @internal
   */
  onListen() {
  }
  /**
   * This method is called when the last listener for an event is removed.
   * @param {String} eventName
   * @internal
   */
  onUnlisten() {
  }
  destructorInterceptor() {
    const { autoDetachers, target, oldDestructor } = this;
    for (let i = 0; i < autoDetachers.length; i++) {
      const { dispatcher, config } = autoDetachers[i];
      if (!dispatcher.isDestroyed) {
        dispatcher.removeListener(config, target);
      }
    }
    oldDestructor.call(target);
  }
  /**
   * Internal function used to hook destroy() calls when using thisObj
   * @private
   */
  attachAutoDetacher(config, thisObj) {
    const target = config.thisObj || thisObj, destructorName = "doDestroy" in target ? "doDestroy" : "destroy";
    if (destructorName in target) {
      let { $autoDetachers } = target;
      if (!$autoDetachers) {
        target.$autoDetachers = $autoDetachers = [];
      }
      if (!target.$oldDestructor) {
        target.$oldDestructor = target[destructorName];
        target[destructorName] = this.destructorInterceptor.bind({
          autoDetachers: $autoDetachers,
          oldDestructor: target.$oldDestructor,
          target
        });
      }
      $autoDetachers.push({ config, dispatcher: this });
    } else {
      target[destructorName] = () => {
        this.removeListener(config);
      };
    }
  }
  /**
   * Internal function used restore hooked destroy() calls when using thisObj
   * @private
   */
  detachAutoDetacher(config) {
    const target = config.thisObj;
    if (target.$oldDestructor && !target.isDestroying) {
      ArrayHelper.remove(
        target.$autoDetachers,
        target.$autoDetachers.find((detacher2) => detacher2.config === config && detacher2.dispatcher === this)
      );
      if (!target.$autoDetachers.length) {
        target["doDestroy" in target ? "doDestroy" : "destroy"] = target.$oldDestructor;
        target.$oldDestructor = null;
      }
    }
  }
  /**
   * Internal function used to run a callback function after an event is triggered
   * @private
   */
  once(eventName, callback) {
    return this.on({
      [eventName]: () => this.callback(callback),
      once: true
    });
  }
  //endregion
  //region Promise based workflow
  // experimental, used in tests to support async/await workflow
  await(eventName, options = { checkLog: true, resetLog: true, args: null }) {
    const me = this;
    if (options === false) {
      options = { checkLog: false };
    }
    const { args } = options;
    return new Promise((resolve) => {
      var _a2;
      if (options.checkLog && ((_a2 = me._triggered) == null ? void 0 : _a2[eventName])) {
        resolve();
        if (options.resetLog) {
          me.clearLog(eventName);
        }
      }
      if (args) {
        const detacher2 = me.on({
          [eventName]: (...params) => {
            const argsOk = typeof args === "function" ? args(...params) : Object.keys(args).every((key) => {
              return key in params[0] && params[0][key] === args[key];
            });
            if (argsOk) {
              resolve(...params);
              if (options.resetLog) {
                me.clearLog(eventName);
              }
              detacher2();
            }
          },
          prio: -1e4
          // Let others do their stuff first
        });
      } else {
        me.on({
          [eventName]: (...params) => {
            resolve(...params);
            if (options.resetLog) {
              me.clearLog(eventName);
            }
          },
          prio: -1e4,
          // Let others do their stuff first
          once: true
          // promises can only be resolved once anyway
        });
      }
    });
  }
  clearLog(eventName) {
    if (this._triggered) {
      if (eventName) {
        delete this._triggered[eventName];
      } else {
        this._triggered = {};
      }
    }
  }
  //endregion
  //region Trigger
  /**
   * Triggers an event, calling all registered listeners with the supplied arguments. Returning false from any listener
   * makes function return false.
   * @param {String} eventName Event name for which to trigger listeners
   * @param {Object} [param] Single parameter passed on to listeners, source property will be added to it (this)
   * @param {Boolean} [param.bubbles] Pass as `true` to indicate that the event will bubble up the widget
   * ownership hierarchy. For example up a `Menu`->`parent` Menu tree, or a `Field`->`Container` tree.
   * @typings param -> {{bubbles?: boolean, [key: string]: any}}
   * @returns {Boolean|Promise} Returns false if any listener returned `false`, or a `Promise` yielding
   * `true` / `false` based on what is returned from the async listener functions, otherwise `true`
   * @async
   * @advanced
   */
  trigger(eventName, param) {
    var _a2, _b, _c, _d;
    const me = this, name = eventName.toLowerCase(), {
      eventsSuspended,
      relayAllTargets,
      callOnFunctions
    } = me;
    let listeners = (_a2 = me.eventListeners) == null ? void 0 : _a2[name], handlerPromises;
    if (!me._triggered) {
      me._triggered = {};
    }
    me._triggered[eventName] = true;
    if (eventsSuspended) {
      if (eventsSuspended.shouldQueue) {
        eventsSuspended.queue.push(arguments);
      }
      return true;
    }
    if ((_b = me.eventListeners) == null ? void 0 : _b.catchall) {
      (listeners = listeners ? listeners.slice() : []).push(...me.eventListeners.catchall);
      listeners.sort(priorityComparator);
    }
    if (!listeners && !relayAllTargets && !callOnFunctions) {
      return true;
    }
    if (param) {
      if (!("source" in param)) {
        if (Object.isExtensible(param)) {
          param.source = me;
        } else {
          param = Object.setPrototypeOf({
            source: me
          }, param);
        }
      }
    } else {
      param = {
        source: me
      };
    }
    if (param.type !== name) {
      if (param.constructor !== Object) {
        Reflect.defineProperty(param, "type", { get: () => name });
      } else {
        param.type = name;
      }
    }
    param.eventName = eventName;
    if (!("bubbles" in param) && ((_c = me.bubbleEvents) == null ? void 0 : _c[eventName])) {
      param.bubbles = me.bubbleEvents[eventName];
    }
    if (callOnFunctions) {
      const fnName = "on" + StringHelper.capitalize(eventName);
      if (fnName in me) {
        const result = me[fnName] ? me.callback(me[fnName], me, [param]) : true;
        let inhibit;
        if (Objects.isPromise(result)) {
          (handlerPromises || (handlerPromises = [])).push(result);
        } else {
          inhibit = result === false || inhibit;
        }
        if (!me.isDestroyed && hasOwnProperty5.call(me, fnName) && !((_d = me.pluginFunctionChain) == null ? void 0 : _d[fnName])) {
          const myProto = Object.getPrototypeOf(me);
          if (fnName in myProto) {
            const result2 = myProto[fnName].call(me, param);
            if (Objects.isPromise(result2)) {
              (handlerPromises || (handlerPromises = [])).push(result2);
            } else {
              inhibit = result2 === false || inhibit;
            }
            if (me.isDestroyed) {
              return;
            }
          }
        }
        if (inhibit) {
          return false;
        }
      }
    }
    let ret;
    if (listeners) {
      let i = 0, internalAbort = false;
      listeners.$firing = true;
      for (i; i < listeners.length && !me.isDestroyed && !internalAbort; i++) {
        const listener = listeners[i];
        if (ret === false && !listener.$internal) {
          continue;
        }
        let handler, thisObj = listener.thisObj;
        if (!thisObj || !thisObj.isDestroyed) {
          listener.called = true;
          if (listener.once) {
            me.removeListener(name, listener);
          }
          if (typeof listener.fn === "string") {
            if (thisObj) {
              handler = thisObj[listener.fn];
            }
            if (!handler) {
              const result2 = me.resolveCallback(listener.fn);
              handler = result2.handler;
              thisObj = result2.thisObj;
            }
          } else {
            handler = listener.fn;
          }
          if (listener.buffer) {
            if (!listener.bufferFn) {
              const buffer = Number(listener.buffer);
              if (typeof buffer !== "number" || isNaN(buffer)) {
                throw new Error(`Incorrect type for buffer, got "${buffer}" (expected a Number)`);
              }
              listener.bufferFn = FunctionHelper.createBuffered(handler, buffer, thisObj, listener.args);
            }
            handler = listener.bufferFn;
          }
          if (listener.throttle) {
            const throttle = Number(listener.throttle);
            if (typeof throttle !== "number" || isNaN(throttle)) {
              throw new Error(`Incorrect type for throttle, got "${throttle}" (expected a Number)`);
            }
            if (!listener.throttledFn) {
              listener.throttledFn = FunctionHelper.createThrottled(handler, throttle, thisObj, listener.args);
            }
            handler = listener.throttledFn;
          }
          const result = handler.call(thisObj || me, ...listener.args || [], param);
          if (ret !== false) {
            ret = result;
          }
          if (listener.$internal && result === false) {
            internalAbort = true;
          }
          if (Objects.isPromise(result)) {
            result.$internal = listener.$internal;
            (handlerPromises || (handlerPromises = [])).push(result);
          }
        }
      }
      listeners.$firing = false;
      if (internalAbort) {
        return false;
      }
    }
    relayAllTargets == null ? void 0 : relayAllTargets.forEach((config) => {
      let name2 = eventName;
      if (config.transformCase) {
        name2 = StringHelper.capitalize(name2);
      }
      if (config.prefix) {
        name2 = config.prefix + name2;
      }
      if (config.through.trigger(name2, param) === false) {
        return false;
      }
    });
    if (param.bubbles && me.owner && !me.owner.isDestroyed) {
      return me.owner.trigger(eventName, param);
    }
    handlerPromises = handlerPromises == null ? void 0 : handlerPromises.filter((p) => ret !== false || p.$internal);
    if (handlerPromises == null ? void 0 : handlerPromises.length) {
      return new Promise((resolve) => {
        Promise.all(handlerPromises).then((promiseResults) => {
          const finalResult = !promiseResults.some((result) => result === false);
          resolve(finalResult);
        });
      });
    }
    return ret !== false;
  }
  /**
   * Prevents events from being triggered until {@link #function-resumeEvents()} is called. Optionally queues events that are triggered while
   * suspended. Multiple calls stack to require matching calls to `resumeEvents()` before actually resuming.
   * @param {Boolean} queue Specify true to queue events triggered while suspended
   * @advanced
   */
  suspendEvents(queue = false) {
    const eventsSuspended = this.eventsSuspended || (this.eventsSuspended = { shouldQueue: queue, queue: [], count: 0 });
    eventsSuspended.count++;
  }
  /**
   * Resume event triggering after a call to {@link #function-suspendEvents()}. If any triggered events were queued they will be triggered.
   * @returns {Boolean} `true` if events have been resumed (multiple calls to suspend require an equal number of resume calls to resume).
   * @advanced
   */
  resumeEvents() {
    const suspended = this.eventsSuspended;
    if (suspended) {
      if (--suspended.count === 0) {
        this.eventsSuspended = null;
        if (suspended.shouldQueue) {
          for (const queued of suspended.queue) {
            this.trigger(...queued);
          }
        }
      }
    }
    return !Boolean(this.eventsSuspended);
  }
  //endregion
};

// ../Core/lib/Core/helper/AsyncHelper.js
var AsyncHelper = class {
  /**
   * Returns a promise that resolves on next animation frame.
   * ```
   *  async method() {
   *      // do work
   *      await AsyncHelper.animationFrame();
   *      // do more work
   *  }
   * ```
   * @async
   */
  static animationFrame() {
    return new Promise((resolve) => {
      requestAnimationFrame(resolve);
    });
  }
  /**
   * Returns a promise that resolves after a specified number of milliseconds.
   * ```
   *  async method() {
   *      await AsyncHelper.sleep(10);
   *      // ...
   *  }
   * ```
   * @param {Number} millis The number of milliseconds to sleep.
   * @async
   */
  static sleep(millis) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, millis);
    });
  }
  /**
   * Returns a promise that resolves as soon as possible, allowing the browser to minimally process other messages.
   * This is the shortest possible delay the browser offers, so be aware that it does not necessarily allow the
   * browser to paint or reflow if used in a long loop. It does, however, allow other async methods to execute.
   * ```
   *  async method() {
   *      await AsyncHelper.yield();
   *      // ...
   *  }
   * ```
   * @async
   */
  static yield() {
    return Promise.resolve();
  }
};
AsyncHelper._$name = "AsyncHelper";

// ../Core/lib/Core/helper/AjaxHelper.js
var paramValueRegExp = /^(\w+)=(.*)$/;
var parseParams = function(paramString) {
  const result = {}, params = paramString.split("&");
  for (const nameValuePair of params) {
    const [match, name, value] = paramValueRegExp.exec(nameValuePair), decodedName = decodeURIComponent(name), decodedValue = decodeURIComponent(value);
    if (match) {
      let paramValue = result[decodedName];
      if (paramValue) {
        if (!Array.isArray(paramValue)) {
          paramValue = result[decodedName] = [paramValue];
        }
        paramValue.push(decodedValue);
      } else {
        result[decodedName] = decodedValue;
      }
    }
  }
  return result;
};
var _AjaxHelper = class _AjaxHelper {
  /**
   * Make a request (using GET) to the specified url.
   * @param {String} url URL to `GET` from
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static get(url, options) {
    return this.fetch(url, options);
  }
  /**
   * POST data to the specified URL.
   * @param {String} url URL to `POST` to
   * @param {String|Object|FormData} payload The data to post. If an object is supplied, it will be stringified
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static post(url, payload, options = {}) {
    if (!(payload instanceof FormData) && !(typeof payload === "string")) {
      payload = JSON.stringify(payload);
      options.headers = options.headers || {};
      options.headers["Content-Type"] = options.headers["Content-Type"] || "application/json";
    }
    return this.fetch(url, Object.assign({
      method: "POST",
      body: payload
    }, options));
  }
  /**
   * Fetch the specified resource using the `fetch` API.
   * @param {String} url URL to fetch from
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static fetch(url, options) {
    let controller;
    options = Objects.merge({}, _AjaxHelper.DEFAULT_FETCH_OPTIONS, options);
    if (typeof AbortController !== "undefined") {
      controller = options.abortController = new AbortController();
      options.signal = controller.signal;
    }
    if (!("credentials" in options)) {
      options.credentials = "include";
    }
    if (options.queryParams) {
      const params = Object.entries(options.queryParams);
      if (params.length) {
        let paramsAdded = false;
        if (options.headers && options.addQueryParamsToBody === true) {
          const contentType = new Headers(options.headers).get("Content-Type");
          let bodyClass;
          switch (contentType) {
            case "application/x-www-form-urlencoded":
              bodyClass = URLSearchParams;
              break;
            case "multipart/form-data":
              bodyClass = FormData;
              break;
          }
          if (bodyClass) {
            const body = options.body || (options.body = new bodyClass());
            if (body instanceof bodyClass) {
              params.forEach(([key, value]) => body.set(key, value));
              paramsAdded = true;
            }
          }
        }
        if (!paramsAdded) {
          url += (url.includes("?") ? "&" : "?") + params.map(
            ([param, value]) => `${param}=${encodeURIComponent(value)}`
          ).join("&");
        }
      }
    }
    const promise = new Promise((resolve, reject) => {
      fetch(url, options).then(
        (response) => {
          if (options.parseJson) {
            response.json().then((json) => {
              response.parsedJson = json;
              resolve(response);
            }).catch((error) => {
              response.parsedJson = null;
              response.error = error;
              reject(response);
            });
          } else {
            resolve(response);
          }
        }
      ).catch((error) => {
        error.stack = promise.stack;
        reject(error);
      });
    });
    promise.stack = new Error().stack;
    promise.abort = function() {
      controller == null ? void 0 : controller.abort();
    };
    return promise;
  }
  /**
   * Registers the passed URL to return the passed mocked up Fetch Response object to the
   * AjaxHelper's promise resolve function.
   * @param {String} url The url to return mock data for
   * @param {Object|Function} response A mocked up Fetch Response object which must contain
   * at least a `responseText` property, or a function to which the `url` and a `params` object
   * and the `Fetch` `options` object is passed which returns that.
   * @param {String} response.responseText The data to return.
   * @param {Boolean} [response.synchronous] resolve the Promise immediately
   * @param {Number} [response.delay=100] resolve the Promise after this number of milliseconds.
   */
  static mockUrl(url, response) {
    const me = this;
    (me.mockAjaxMap || (me.mockAjaxMap = {}))[url] = response;
    if (!_AjaxHelper.originalFetch) {
      _AjaxHelper.originalFetch = _AjaxHelper.fetch;
      _AjaxHelper.fetch = me.mockAjaxFetch.bind(me);
    }
  }
  static async mockAjaxFetch(url, options) {
    const urlAndParams = url.split("?");
    let result = this.mockAjaxMap[urlAndParams[0]], parsedJson = null;
    if (result) {
      if (typeof result === "function") {
        result = await result(urlAndParams[0], urlAndParams[1] && parseParams(urlAndParams[1]), options);
      }
      try {
        parsedJson = (options == null ? void 0 : options.parseJson) && JSON.parse(result.responseText);
      } catch (error) {
        parsedJson = null;
        result.error = error;
      }
      result = Object.assign({
        status: 200,
        ok: true,
        headers: new Headers(),
        statusText: "OK",
        url,
        parsedJson,
        text: () => new Promise((resolve) => {
          resolve(result.responseText);
        }),
        json: () => new Promise((resolve) => {
          resolve(parsedJson);
        })
      }, result);
      return new Promise(function(resolve, reject) {
        if (result.synchronous) {
          resolve(result);
        } else {
          setTimeout(function() {
            resolve(result);
          }, "delay" in result ? result.delay : 100);
        }
      });
    } else {
      return _AjaxHelper.originalFetch(url, options);
    }
  }
};
/**
 * Sets default options for {@link #function-fetch-static AjaxHelper#fetch()} calls. Please see
 * {@link #typedef-FetchOptions} and
 * [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) for details.
 *
 * ```javascript
 * // default content-type for all requests will be "application/json"
 * AjaxHelper.DEFAULT_FETCH_OPTIONS = {
 *     headers : {
 *         'content-type' : 'application/json'
 *     }
 * };
 * ```
 * @member {FetchOptions} DEFAULT_FETCH_OPTIONS
 * @static
 */
__publicField(_AjaxHelper, "DEFAULT_FETCH_OPTIONS", {});
var AjaxHelper = _AjaxHelper;
AjaxHelper._$name = "AjaxHelper";

// ../Core/lib/Core/localization/LocaleHelper.js
var global = typeof self !== "undefined" ? self : typeof globalThis !== "undefined" ? globalThis : null;
var _LocaleHelper = class _LocaleHelper {
  /**
   * Merges all properties of provided locale objects into new locale object.
   * Locales are merged in order they provided and locales which go later replace
   * same properties of previous locales.
   * @param {...Object} locales Locales to merge
   * @returns {Object} Merged locale
   */
  static mergeLocales(...locales) {
    const result = {};
    locales.forEach((locale3) => {
      Object.keys(locale3).forEach((key) => {
        if (typeof locale3[key] === "object") {
          result[key] = { ...result[key], ...locale3[key] };
        } else {
          result[key] = locale3[key];
        }
      });
    });
    return result;
  }
  /**
   * Removes all properties from `locale` that are present in the provided `toTrim`.
   * @param {Object} locale Locale to process
   * @param {Object} toTrim Object enumerating properties that should be removed.
   * When `false` throws exceptions in such cases.
   */
  static trimLocale(locale3, toTrim) {
    const remove = (key, subKey) => {
      if (locale3[key]) {
        if (subKey) {
          if (locale3[key][subKey]) {
            delete locale3[key][subKey];
          }
        } else {
          delete locale3[key];
        }
      }
    };
    Object.keys(toTrim).forEach((key) => {
      if (Object.keys(toTrim[key]).length > 0) {
        Object.keys(toTrim[key]).forEach((subKey) => remove(key, subKey));
      } else {
        remove(key);
      }
    });
  }
  /**
   * Normalizes locale object to {@link Locale} type.
   *
   * Supported configs:
   *
   * ```javascript
   * LocaleHelper.normalizeLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * });
   * ```
   *
   * and for backward compatibility
   *
   * ```javascript
   * LocaleHelper.normalizeLocale('En', {
   *     name : 'En',
   *     desc : 'English (US)',
   *     code : 'en-US',
   *     locale : {
   *         ... (localization key:value pairs)
   *     }
   * });
   * ```
   * @param {String|Object} nameOrConfig String name of locale or locale object
   * @param {Object} [config] Locale object
   * @returns {Locale} Locale object
   * @internal
   */
  static normalizeLocale(nameOrConfig, config) {
    if (!nameOrConfig) {
      throw new Error(`"nameOrConfig" parameter can not be empty`);
    }
    if (typeof nameOrConfig === "string") {
      if (!config) {
        throw new Error(`"config" parameter can not be empty`);
      }
      if (config.locale) {
        config.name = nameOrConfig || config.name;
      } else {
        config.localeName = nameOrConfig;
      }
    } else {
      config = nameOrConfig;
    }
    let locale3 = {};
    if (config.name || config.locale) {
      locale3 = Object.assign({
        localeName: config.name
      }, config.locale);
      config.desc && (locale3.localeDesc = config.desc);
      config.code && (locale3.localeCode = config.code);
      config.path && (locale3.localePath = config.path);
    } else {
      if (!config.localeName) {
        throw new Error(`"config" parameter doesn't have "localeName" property`);
      }
      locale3 = Object.assign({}, config);
    }
    for (const key of ["name", "desc", "code", "path"]) {
      if (locale3[key]) {
        delete locale3[key];
      }
    }
    if (!locale3.localeName) {
      throw new Error(`Locale name can not be empty`);
    }
    return locale3;
  }
  /**
   * Get/set currently published locales.
   * Returns an object with locales.
   *
   * Example:
   *
   * ```javascript
   * const englishLocale = LocaleHelper.locales.En;
   * ```
   *
   * `englishLocale` contains {@link Locale} object.
   *
   * @readonly
   * @member {Locales} locales
   * @static
   */
  static get locales() {
    return global.bryntum.locales || {};
  }
  static set locales(locales) {
    global.bryntum.locales = locales;
  }
  /**
   * Get/set current locale name. Defaults to "En"
   * @member {String} localeName
   * @static
   */
  static get localeName() {
    return global.bryntum.locale || "En";
  }
  static set localeName(localeName) {
    global.bryntum.locale = localeName || _LocaleHelper.localeName;
  }
  /**
   * Get current locale config specified by {@link ##property-localeName-static}.
   * If no current locale specified, returns default `En` locale or first published locale
   * or empty locale object if no published locales found.
   * @readonly
   * @member {Locales} locale
   * @static
   */
  static get locale() {
    return _LocaleHelper.localeName && this.locales[_LocaleHelper.localeName] || this.locales.En || Object.values(this.locales)[0] || { localeName: "", localeDesc: "", localeCoode: "" };
  }
  /**
   * Publishes a locale to make it available for applying.
   * Published locales are available in {@link ##property-locales-static}.
   *
   * Recommended usage:
   *
   * ```javascript
   * LocaleHelper.publishLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * });
   * ```
   *
   * for backward compatibility (prior to `5.3.0` version):
   *
   * ```javascript
   * LocaleHelper.publishLocale('En', {
   *     name : 'En',
   *     desc : 'English (US)',
   *     code : 'en-US',
   *     locale : {
   *         ... (localization key:value pairs)
   *     }
   * });
   * ```
   *
   * Publishing a locale will automatically merge it's localization keys with existing locale matching by locale name,
   * replacing existing one with new. To replace existing locale entirely pass `true` to optional `config` parameter.
   *
   * Example:
   *
   * ```javascript
   * LocaleHelper.publishLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * }, true);
   * ```
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object
   * @param {Locale|Boolean} [config] Locale object.
   * Not used if locale object is passed as first method parameter.
   * Path `true` value and locale object as first method parameter to publish locale without merging with existing one.
   * @returns {Locale} Locale object
   */
  static publishLocale(nameOrConfig, config) {
    const { locales } = global.bryntum, locale3 = _LocaleHelper.normalizeLocale(nameOrConfig, config), { localeName } = locale3;
    if (!locales[localeName] || config === true) {
      locales[localeName] = locale3;
    } else {
      locales[localeName] = this.mergeLocales(locales[localeName] || {}, locale3 || {});
    }
    return locales[localeName];
  }
};
__publicField(_LocaleHelper, "skipLocaleIntegrityCheck", false);
var LocaleHelper = _LocaleHelper;
global.bryntum = global.bryntum || {};
global.bryntum.locales = global.bryntum.locales || {};
LocaleHelper._$name = "LocaleHelper";

// ../Core/lib/Core/localization/LocaleManager.js
var LocaleManager = class extends Events_default(Base) {
  static get defaultConfig() {
    return {
      // Enable strict locale checking by default for tests
      throwOnMissingLocale: VersionHelper.isTestEnv
    };
  }
  construct(...args) {
    var _a2;
    const me = this;
    super.construct(...args);
    if (BrowserHelper.isBrowserEnv) {
      const scriptTag = document.querySelector("script[data-default-locale]");
      if (scriptTag) {
        me.applyLocale(scriptTag.dataset.defaultLocale);
      } else if ((_a2 = me.locale) == null ? void 0 : _a2.localeName) {
        me.applyLocale(me.locale.localeName);
      }
    }
  }
  /**
   * Get/set currently registered locales.
   * Alias for {@link Core.localization.LocaleHelper#property-locales-static LocaleHelper.locales}.
   * @readonly
   * @member {Locales} locales
   */
  get locales() {
    return LocaleHelper.locales;
  }
  set locales(locales) {
    LocaleHelper.locales = locales;
  }
  /**
   * Get/set currently used locale.
   * Setter calls {@link #function-applyLocale}.
   * @member {Locales} locale
   * @accepts {String|Locale}
   */
  set locale(nameOrConfig) {
    this.applyLocale(nameOrConfig);
  }
  get locale() {
    return LocaleHelper.locale;
  }
  /**
   * Publishes a locale to make it available for applying.
   * @deprecated Since 5.3.0. Use {@link Core.localization.LocaleHelper#function-publishLocale-static LocaleHelper.publishLocale} instead.
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object.
   * @param {Locale} [config] Locale object. Not used if object is passed as first method parameter
   * @returns {Locale} published locale object is passed as first method parameter
   * @function registerLocale
   */
  registerLocale(nameOrConfig, config) {
    VersionHelper.deprecate("Core", "6.0.0", "LocaleManager.registerLocale deprecated, use LocaleHelper.publishLocale instead");
    LocaleHelper.publishLocale(nameOrConfig, config);
  }
  /**
   * Extends locale specified by name to add additional translations and applies it.
   * @deprecated Since 5.3.0. Use {@link ##function-applyLocale} instead.
   *
   * @param {String} name Name of locale (for example `En` or `SvSE`).
   * @param {Locale} config Locale object
   * @returns {Locale|Promise} locale object or Promise which resolves with locale object after it was loaded
   * @function extendLocale
   */
  extendLocale(name, config) {
    VersionHelper.deprecate("Core", "6.0.0", "LocaleManager.extendLocale deprecated, use LocaleManager.applyLocale instead");
    const locale3 = LocaleHelper.publishLocale(name, config);
    return this.applyLocale(locale3, true);
  }
  /**
   * Applies a locale by string name or publishes new locale configuration with
   * {@link Core.localization.LocaleHelper#function-publishLocale-static} and applies it.
   * If locale is specified by string name, like 'En', it must be published before applying it.
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object
   * @param {Locale|Boolean} [config] Locale object. Pass `true` to reapply locale which is passed as first method parameter.
   * @returns {Locale|Promise} locale object or Promise which resolves with locale object after it was loaded
   * @fires locale
   * @async
   * @function applyLocale
   */
  applyLocale(nameOrConfig, config, ignoreError = false) {
    const me = this;
    let localeConfig;
    if (typeof nameOrConfig === "string") {
      if (typeof config !== "object") {
        localeConfig = me.locales[nameOrConfig];
        if (!localeConfig) {
          if (ignoreError) {
            return true;
          }
          throw new Error(`Locale "${nameOrConfig}" is not published. Publish with LocaleHelper.publishLocale() before applying.`);
        }
      } else {
        localeConfig = LocaleHelper.publishLocale(nameOrConfig, config);
      }
    } else {
      localeConfig = LocaleHelper.publishLocale(nameOrConfig);
    }
    if (me.locale.localeName && me.locale.localeName === localeConfig.localeName && config !== true) {
      return me.locale;
    }
    LocaleHelper.localeName = localeConfig.localeName;
    const triggerLocaleEvent = () => {
      me.trigger("locale", localeConfig);
    };
    if (localeConfig.localePath) {
      return new Promise((resolve, reject) => {
        me.loadLocale(localeConfig.localePath).then((response) => {
          response.text().then((text) => {
            const parseLocale = new Function(text);
            parseLocale();
            if (BrowserHelper.isBrowserEnv) {
              localeConfig = me.locales[localeConfig.localeName];
              if (localeConfig) {
                delete localeConfig.localePath;
              }
            }
            triggerLocaleEvent();
            resolve(localeConfig);
          });
        }).catch((response) => reject(response));
      });
    }
    triggerLocaleEvent();
    return localeConfig;
  }
  /**
   * Loads a locale using AjaxHelper {@link Core.helper.AjaxHelper#function-get-static} request.
   * @private
   * @param {String} path Path to locale file
   * @async
   */
  loadLocale(path) {
    return AjaxHelper.get(path);
  }
  /**
   * Specifies if {@link Core.localization.Localizable#function-L-static Localizable.L()} function would throw error if no localization found at runtime.
   *
   * @member {Boolean} throwOnMissingLocale
   * @default false
   */
  set throwOnMissingLocale(value) {
    this._throwOnMissingLocale = value;
  }
  get throwOnMissingLocale() {
    return this._throwOnMissingLocale;
  }
};
var LocaleManagerSingleton = new LocaleManager();
var LocaleManager_default = LocaleManagerSingleton;

// ../Core/lib/Core/localization/Localizable.js
var ObjectProto = Object.getPrototypeOf(Object);
var localeRe = /L{.*?}/g;
var capturelocaleRe = /L{(.*?)}/g;
var classMatchRe = /((.*?)\.)?(.+)/g;
var escape2 = (txt) => txt.replace(/{(\d+)}/gm, "[[$1]]");
var unescape = (txt) => txt.replace(/\[\[(\d+)]]/gm, "{$1}");
var emptyObject3 = Object.freeze(/* @__PURE__ */ Object.create(null));
var Localizable_default = (Target) => class Localizable extends (Target || Base) {
  static get $name() {
    return "Localizable";
  }
  static get configurable() {
    return {
      /**
       * A class translations of which are used for translating this entity.
       * This is often used when translations of an item are defined on its container class.
       * For example:
       *
       * ```js
       * // Toolbar class that has some predefined items
       * class MyToolbar extends Toolbar {
       *
       *     static get $name() {
       *         return 'MyToolbar';
       *     }
       *
       *     static get defaultConfig() {
       *         return {
       *             // this specifies default configs for the items
       *             defaults : {
       *                 // will tell items to use the toolbar locale
       *                 localeClass : this
       *             },
       *
       *             items : [
       *                 // The toolbar has 2 buttons and translation for their texts will be searched in
       *                 // the toolbar locales
       *                 { text : 'Agree' },
       *                 { text : 'Disagree' }
       *             ]
       *         };
       *     }
       *
       *    ...
       * }
       * ```
       * So if one makes a locale for the `MyToolbar` class that will include `Agree` and `Disagree` string translations:
       * ```js
       *     ...
       *     MyToolbar : {
       *         Agree    : 'Yes, I agree',
       *         Disagree : 'No, I do not agree'
       *     }
       * ```
       * They will be used for the toolbar buttons and the button captions will say `Yes, I agree` and `No, I do not agree`.
       *
       * @config {Core.Base}
       * @typings {typeof Base}
       * @category Misc
       * @advanced
       */
      localeClass: null,
      /**
       * Set to `false` to disable localization of this object.
       * @config {Boolean}
       * @default true
       * @category Misc
       * @advanced
       */
      localizable: null,
      /**
       * List of properties which values should be translated automatically upon a locale applying.
       * In case there is a need to localize not typical value (not a String value or a field with re-defined setter/getter),
       * you could use 'localeKey' meta configuration.
       * Example:
       * ```js
       *  static get configurable() {
       *     return {
       *          localizableProperties : ['width'],
       *
       *          width : {
       *              value   : '54em', // default value here
       *              $config : {
       *                  localeKey : 'L{editorWidth}' // name of the property that will be used in localization file
       *              }
       *          }
       *      };
       *  }
       * ```
       * @config {String[]}
       * @category Misc
       * @advanced
       */
      localizableProperties: {
        value: [],
        $config: {
          merge: "distinct"
        }
      }
    };
  }
  static clsName(cls) {
    var _a2, _b;
    return typeof cls === "string" ? cls : cls === ObjectProto ? "Object" : cls.$$name || cls.name || ((_a2 = cls.prototype) == null ? void 0 : _a2.$$name) || ((_b = cls.prototype) == null ? void 0 : _b.name);
  }
  static parseLocaleString(text) {
    const matches = [];
    let m;
    if (text == null ? void 0 : text.includes("L{")) {
      text = escape2(text);
      capturelocaleRe.lastIndex = 0;
      while ((m = capturelocaleRe.exec(text)) != null) {
        classMatchRe.lastIndex = 0;
        const classMatch = classMatchRe.exec(m[1]);
        matches.push({
          match: unescape(m[0]),
          localeKey: unescape(classMatch[3]),
          localeClass: classMatch[2]
        });
      }
    }
    return matches.length > 0 ? matches : [{
      match: text,
      localeKey: text,
      localeClass: void 0
    }];
  }
  construct(config = {}, ...args) {
    super.construct(config, ...args);
    LocaleManager_default.ion({ locale: "updateLocalization", thisObj: this });
    this.updateLocalization();
  }
  get localeClass() {
    return this._localeClass || null;
  }
  localizeProperty(property) {
    var _a2, _b, _c;
    const me = this, currentValue = Objects.getPath(me, property), localeKey = ((_a2 = me.$meta.configs[property]) == null ? void 0 : _a2.localeKey) || ((_c = (_b = me.fieldMap) == null ? void 0 : _b[property]) == null ? void 0 : _c.defaultValue);
    let localizedValue;
    if (localeKey) {
      localizedValue = Localizable.localize(localeKey, me, me.localeClass || me);
      if (localizedValue && !(property in (me.initialConfig || emptyObject3))) {
        Objects.setPath(me.isColumn ? me.data : me, property, localizedValue);
      }
    } else if (typeof currentValue === "string") {
      me.originalLocales = me.originalLocales || {};
      localizedValue = Objects.getPath(me.originalLocales, property);
      if (localizedValue === void 0) {
        Objects.setPath(me.originalLocales, property, currentValue);
        localizedValue = currentValue;
      }
      if (localizedValue) {
        Objects.setPath(me, property, localizedValue = me.optionalL(localizedValue, me));
      }
    }
    return localizedValue || currentValue;
  }
  /**
   * Method that is triggered when applying a locale to the instance
   * (happens on the instance construction steps and when switching to another locale).
   *
   * The method can be overridden to dynamically translate the instance when locale is switched.
   * When overriding the method please make sure you call `super.updateLocalization()`.
   * @category Misc
   * @advanced
   */
  updateLocalization() {
    var _a2, _b;
    if (this.localizable !== false) {
      (_a2 = this.localizableProperties) == null ? void 0 : _a2.forEach(this.localizeProperty, this);
      (_b = this.trigger) == null ? void 0 : _b.call(this, "localized");
    }
  }
  static getTranslation(text, templateData, localeCls) {
    const locale3 = LocaleManager_default.locale;
    let result = null, clsName, cls;
    if (locale3) {
      for (const { match, localeKey, localeClass } of this.parseLocaleString(text)) {
        const translate = (clsName2) => {
          var _a2;
          const translation = (_a2 = locale3[clsName2]) == null ? void 0 : _a2[localeKey];
          if (translation) {
            if (typeof translation === "function") {
              result = templateData != null ? translation(templateData) : translation;
            } else if (typeof translation === "object" || text === match) {
              result = translation;
            } else {
              result = (result || text).replace(match, translation);
            }
            if (typeof translation === "string" && translation.includes("L{")) {
              result = this.getTranslation(translation, templateData, localeCls);
            }
          }
          return translation;
        };
        let success = false;
        for (cls = localeCls; cls && (clsName = Localizable.clsName(cls)); cls = Object.getPrototypeOf(cls)) {
          if (success = translate(clsName)) {
            break;
          } else if (typeof cls === "string") {
            break;
          }
        }
        if (!success && localeClass) {
          translate(localeClass);
        }
      }
    }
    return result;
  }
  /**
   * Get localized string, returns `null` if no localized string found.
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @internal
   */
  static localize(text, templateData = void 0, ...localeClasses) {
    if ((localeClasses == null ? void 0 : localeClasses.length) === 0) {
      localeClasses = [this];
    }
    let translation = null;
    localeClasses.some((cls) => {
      translation = Localizable.getTranslation(text, templateData, cls);
      return translation != null;
    });
    return translation;
  }
  /**
   * Get localized string, returns value of `text` if no localized string found.
   *
   * If {@link Core.localization.LocaleManager#property-throwOnMissingLocale LocaleManager.throwOnMissingLocale}
   * is `true` then calls to `L()` will throw `Localization is not found for 'text' in 'ClassName'` exception when no
   * localization is found.
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @static
   * @returns {String}
   * @advanced
   */
  static L(text, templateData = void 0, ...localeClasses) {
    if ((localeClasses == null ? void 0 : localeClasses.length) === 0) {
      localeClasses = [this];
    }
    const translation = this.localize(text, templateData, ...localeClasses);
    if (translation == null && LocaleManager_default.throwOnMissingLocale && text.includes("L{")) {
      throw new Error(`Localization is not found for '${text}' in '${localeClasses.map((cls) => Localizable.clsName(cls)).join(", ")}'. ${LocaleManager_default.locale.localeName ? `Locale : ${LocaleManager_default.locale.localeName}` : ""}`);
    }
    return translation != null ? translation : text;
  }
  /**
   * Convenience function that can be called directly on the class that mixes Localizable in
   *
   * ```javascript
   * button.text = grid.L('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @category Misc
   * @advanced
   */
  L(text, templateData) {
    const { localeClass, constructor } = this;
    if (localeClass && Localizable.clsName(localeClass) !== Localizable.clsName(constructor)) {
      return Localizable.L(text, templateData, localeClass, constructor);
    } else {
      return Localizable.L(text, templateData, constructor);
    }
  }
  /**
   * Convenience function to get an optional translation. The difference compared to `L()` is that it won't throw
   * an error when the translation is missing even if configured with `throwOnMissingLocale`
   *
   * ```javascript
   * button.text = grid.optionalL('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @static
   * @category Misc
   * @advanced
   */
  static optionalL(text, templateData = void 0, ...localeClasses) {
    const shouldThrow = LocaleManager_default.throwOnMissingLocale;
    LocaleManager_default.throwOnMissingLocale = shouldThrow && localeRe.test(text);
    if ((localeClasses == null ? void 0 : localeClasses.length) === 0) {
      localeClasses = [this];
    }
    const result = Localizable.L(text, templateData, ...localeClasses);
    LocaleManager_default.throwOnMissingLocale = shouldThrow;
    return result;
  }
  /**
   * Convenience function to get an optional translation. The difference compared to `L()` is that it won't throw
   * an error when the translation is missing even if configured with `throwOnMissingLocale`
   *
   * ```javascript
   * button.text = grid.optionalL('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @param {Boolean} [preventThrow] Prevent throwing error even if localized text matches `L{foo}`
   * @returns {String}
   * @category Misc
   * @internal
   */
  optionalL(text, templateData = this, preventThrow = false) {
    const shouldThrow = LocaleManager_default.throwOnMissingLocale;
    LocaleManager_default.throwOnMissingLocale = shouldThrow && localeRe.test(text) && !preventThrow;
    const result = this.L(text, templateData);
    LocaleManager_default.throwOnMissingLocale = shouldThrow;
    return result;
  }
  /**
   * Get the global LocaleManager
   * @property {Core.localization.LocaleManager}
   * @typings {typeof LocaleManager}
   * @category Misc
   * @readonly
   * @advanced
   */
  get localeManager() {
    return LocaleManager_default;
  }
  /**
   * Get the global LocaleHelper
   * @property {Core.localization.LocaleHelper}
   * @typings {typeof LocaleHelper}
   * @category Misc
   * @readonly
   * @advanced
   */
  get localeHelper() {
    return LocaleHelper;
  }
};

// ../Core/lib/Core/localization/En.js
var locale = {
  localeName: "En",
  localeDesc: "English (US)",
  localeCode: "en-US",
  Object: {
    Yes: "Yes",
    No: "No",
    Cancel: "Cancel",
    Ok: "OK",
    Week: "Week",
    None: "None"
  },
  ColorPicker: {
    noColor: "No color"
  },
  Combo: {
    noResults: "No results",
    recordNotCommitted: "Record could not be added",
    addNewValue: (value) => `Add ${value}`
  },
  FilePicker: {
    file: "File"
  },
  Field: {
    badInput: "Invalid field value",
    patternMismatch: "Value should match a specific pattern",
    rangeOverflow: (value) => `Value must be less than or equal to ${value.max}`,
    rangeUnderflow: (value) => `Value must be greater than or equal to ${value.min}`,
    stepMismatch: "Value should fit the step",
    tooLong: "Value should be shorter",
    tooShort: "Value should be longer",
    typeMismatch: "Value is required to be in a special format",
    valueMissing: "This field is required",
    invalidValue: "Invalid field value",
    minimumValueViolation: "Minimum value violation",
    maximumValueViolation: "Maximum value violation",
    fieldRequired: "This field is required",
    validateFilter: "Value must be selected from the list"
  },
  DateField: {
    invalidDate: "Invalid date input"
  },
  DatePicker: {
    gotoPrevYear: "Go to previous year",
    gotoPrevMonth: "Go to previous month",
    gotoNextMonth: "Go to next month",
    gotoNextYear: "Go to next year"
  },
  NumberFormat: {
    locale: "en-US",
    currency: "USD"
  },
  DurationField: {
    invalidUnit: "Invalid unit"
  },
  TimeField: {
    invalidTime: "Invalid time input"
  },
  TimePicker: {
    hour: "Hour",
    minute: "Minute",
    second: "Second"
  },
  List: {
    loading: "Loading...",
    selectAll: "Select All"
  },
  GridBase: {
    loadMask: "Loading...",
    syncMask: "Saving changes, please wait..."
  },
  PagingToolbar: {
    firstPage: "Go to first page",
    prevPage: "Go to previous page",
    page: "Page",
    nextPage: "Go to next page",
    lastPage: "Go to last page",
    reload: "Reload current page",
    noRecords: "No records to display",
    pageCountTemplate: (data) => `of ${data.lastPage}`,
    summaryTemplate: (data) => `Displaying records ${data.start} - ${data.end} of ${data.allCount}`
  },
  PanelCollapser: {
    Collapse: "Collapse",
    Expand: "Expand"
  },
  Popup: {
    close: "Close"
  },
  UndoRedo: {
    Undo: "Undo",
    Redo: "Redo",
    UndoLastAction: "Undo last action",
    RedoLastAction: "Redo last undone action",
    NoActions: "No items in the undo queue"
  },
  FieldFilterPicker: {
    equals: "equals",
    doesNotEqual: "does not equal",
    isEmpty: "empty",
    isNotEmpty: "not empty",
    contains: "contains",
    doesNotContain: "does not contain",
    startsWith: "starts with",
    endsWith: "ends with",
    isOneOf: "one of",
    isNotOneOf: "not one of",
    isGreaterThan: "greater than",
    isLessThan: "less than",
    isGreaterThanOrEqualTo: "greater or equals",
    isLessThanOrEqualTo: "less or equals",
    isBetween: "between",
    isNotBetween: "not between",
    isBefore: "before",
    isAfter: "after",
    isToday: "today",
    isTomorrow: "tomorrow",
    isYesterday: "yesterday",
    isThisWeek: "this week",
    isNextWeek: "next week",
    isLastWeek: "last week",
    isThisMonth: "this month",
    isNextMonth: "next month",
    isLastMonth: "last month",
    isThisYear: "this year",
    isNextYear: "next year",
    isLastYear: "last year",
    isYearToDate: "year to date",
    isTrue: "true",
    isFalse: "false",
    selectAProperty: "Select property",
    selectAnOperator: "Select operator",
    caseSensitive: "Case-sensitive",
    and: "and",
    dateFormat: "D/M/YY",
    selectValue: "Select value",
    selectOneOrMoreValues: "Select value(s)",
    enterAValue: "Enter value",
    enterANumber: "Enter number",
    selectADate: "Select date",
    selectATime: "Select time"
  },
  FieldFilterPickerGroup: {
    addFilter: "Add filter"
  },
  DateHelper: {
    locale: "en-US",
    weekStartDay: 0,
    nonWorkingDays: {
      0: true,
      6: true
    },
    weekends: {
      0: true,
      6: true
    },
    unitNames: [
      { single: "millisecond", plural: "ms", abbrev: "ms" },
      { single: "second", plural: "seconds", abbrev: "s" },
      { single: "minute", plural: "minutes", abbrev: "min" },
      { single: "hour", plural: "hours", abbrev: "h" },
      { single: "day", plural: "days", abbrev: "d" },
      { single: "week", plural: "weeks", abbrev: "w" },
      { single: "month", plural: "months", abbrev: "mon" },
      { single: "quarter", plural: "quarters", abbrev: "q" },
      { single: "year", plural: "years", abbrev: "yr" },
      { single: "decade", plural: "decades", abbrev: "dec" }
    ],
    unitAbbreviations: [
      ["mil"],
      ["s", "sec"],
      ["m", "min"],
      ["h", "hr"],
      ["d"],
      ["w", "wk"],
      ["mo", "mon", "mnt"],
      ["q", "quar", "qrt"],
      ["y", "yr"],
      ["dec"]
    ],
    parsers: {
      L: "MM/DD/YYYY",
      LT: "HH:mm A",
      LTS: "HH:mm:ss A"
    },
    ordinalSuffix: (number) => {
      const hasSpecialCase = ["11", "12", "13"].find((n) => number.endsWith(n));
      let suffix = "th";
      if (!hasSpecialCase) {
        const lastDigit = number[number.length - 1];
        suffix = { 1: "st", 2: "nd", 3: "rd" }[lastDigit] || "th";
      }
      return number + suffix;
    }
  }
};
var En_default = LocaleHelper.publishLocale(locale);

// ../Core/lib/Core/helper/DateHelper.js
var { toString: toString3 } = Object.prototype;
var DATE_TYPE2 = toString3.call(/* @__PURE__ */ new Date());
var tempDate = /* @__PURE__ */ new Date();
var MS_PER_HOUR = 1e3 * 60 * 60;
var defaultValue = (value, defValue) => isNaN(value) || value == null ? defValue : value;
var rangeFormatPartRe = /([ES]){([^}]+)}/g;
var enOrdinalSuffix = (number) => {
  const hasSpecialCase = ["11", "12", "13"].find((n) => number.endsWith(n));
  let suffix = "th";
  if (!hasSpecialCase) {
    const lastDigit = number[number.length - 1];
    suffix = { 1: "st", 2: "nd", 3: "rd" }[lastDigit] || "th";
  }
  return number + suffix;
};
var useIntlFormat = (name, options, date) => {
  const formatter = intlFormatterCache[name] || (intlFormatterCache[name] = new Intl.DateTimeFormat(locale2, options));
  return formatter.format(date);
};
var formatTime = (name, options, date, isShort = false) => {
  let strTime = useIntlFormat(name, options, date);
  if (/am|pm/i.test(strTime)) {
    strTime = strTime.replace(/^0/, "");
    if (isShort) {
      strTime = strTime.replace(/:00/, "");
    }
  }
  return strTime;
};
var getDayDiff = (end, start) => Math.floor((end.getTime() - start.getTime() - (end.getTimezoneOffset() - start.getTimezoneOffset()) * validConversions.minute.millisecond) / validConversions.day.millisecond) + 1;
var normalizeDay = (day2) => day2 >= 0 ? day2 : day2 + 7;
var msRegExp = /([^\w])(S+)/gm;
var msReplacer = (match, g1) => g1 + "SSS";
var splitRegExp = /[:.\-/\s]/;
var locale2 = "en-US";
var ordinalSuffix = enOrdinalSuffix;
var formatCache = {};
var formatRedirects = {};
var intlFormatterCache = {};
var parserCache = {};
var redirectFormat = (format) => {
  const intlConfig = intlFormatConfigs[format];
  if (!intlConfig) {
    throw new Error("Only international formats should be used here");
  }
  if (formatRedirects[format] !== void 0) {
    return formatRedirects[format];
  }
  const intl = new Intl.DateTimeFormat(locale2, intlConfig), fmt = intl.formatToParts(new Date(2001, 1, 2, 3, 4, 5, 6)).map((part) => {
    const type = part.type, intlCfg = intlConfig[type];
    if (type === "literal") {
      return part.value.replace(/,/g, "");
    } else if (type === "day") {
      return intlCfg === "numeric" ? "D" : "DD";
    } else if (type === "month") {
      return intlCfg === "short" ? "MMM" : intlCfg === "long" ? "MMMM" : intlCfg === "numeric" ? "M" : "MM";
    } else if (type === "year") {
      return intlCfg === "numeric" ? "YYYY" : "YY";
    }
  }).join("");
  return formatRedirects[format] = fmt;
};
var DEFAULT_YEAR = 2020;
var DEFAULT_MONTH = 0;
var DEFAULT_DAY = 1;
var intlFormatConfigs = {
  l: { year: "numeric", month: "numeric", day: "numeric" },
  ll: { year: "numeric", month: "short", day: "numeric" }
};
var formats = {
  // 1, 2, ... 11, 12
  M: (date) => date.getMonth() + 1,
  //date.toLocaleDateString(locale, { month : 'numeric' }),
  // 1st, 2nd, 3rd, 4th, ... 11th, 12th
  Mo: (date) => ordinalSuffix(formats.M(date).toString()),
  // 01, 02, ...
  MM: (date) => (date.getMonth() + 1).toString().padStart(2, "0"),
  //date.toLocaleDateString(locale, { month : '2-digit' }),
  // Jan, Feb, ...
  MMM: (date) => useIntlFormat("MMM", { month: "short" }, date),
  // January, February, ...
  MMMM: (date) => useIntlFormat("MMMM", { month: "long" }, date),
  // 1, 2, ...
  Q: (date) => Math.ceil((date.getMonth() + 1) / 3),
  // 1st, 2nd, ...
  Qo: (date) => ordinalSuffix(formats.Q(date).toString()),
  // 1, 2, ...
  D: (date) => date.getDate(),
  //date.toLocaleDateString(locale, { day : 'numeric' }),
  // 1st, 2nd, ...
  Do: (date) => ordinalSuffix(formats.D(date).toString()),
  // 01, 02, ...
  DD: (date) => date.getDate().toString().padStart(2, "0"),
  //date.toLocaleDateString(locale, { day : '2-digit' }),
  // 1, 2, ..., 365, 365
  DDD: (date) => Math.ceil(
    (new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0) - new Date(date.getFullYear(), 0, 0, 12, 0, 0)) / validConversions.day.millisecond
  ),
  // 1st, 2nd, ...
  DDDo: (date) => ordinalSuffix(formats.DDD(date).toString()),
  // 001, 002, ...
  DDDD: (date) => formats.DDD(date).toString().padStart(3, "0"),
  // 0, 1, ..., 6
  d: (date) => date.getDay(),
  // 0th, 1st, ...
  do: (date) => ordinalSuffix(date.getDay().toString()),
  // S, M, ...
  d1: (date) => useIntlFormat("d1", { weekday: "narrow" }, date).substr(0, 1),
  // Su, Mo, ...
  dd: (date) => formats.ddd(date).substring(0, 2),
  // Sun, Mon, ...
  ddd: (date) => useIntlFormat("ddd", { weekday: "short" }, date),
  // Sunday, Monday, ...
  dddd: (date) => useIntlFormat("dddd", { weekday: "long" }, date),
  u: (date) => {
    const formatter = intlFormatterCache.u || (intlFormatterCache.u = new Intl.DateTimeFormat("en-GB", {
      timeZone: "UTC",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    })), parts = formatter.formatToParts(date);
    return `${parts[4].value}${parts[2].value}${parts[0].value}Z`;
  },
  uu: (date) => {
    const formatter = intlFormatterCache.uu || (intlFormatterCache.uu = new Intl.DateTimeFormat("en-GB", {
      timeZone: "UTC",
      hour12: false,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    })), parts = formatter.formatToParts(date);
    return `${parts[4].value}${parts[2].value}${parts[0].value}T${parts[6].value}${parts[8].value}${parts[10].value}Z`;
  },
  e: (date) => date.getDay(),
  E: (date) => date.getDay() + 1,
  // ISO week, 1, 2, ...
  W: (date) => DateHelper.getWeekNumber(date)[1],
  Wo: (date) => ordinalSuffix(formats.W(date).toString()),
  WW: (date) => formats.W(date).toString().padStart(2, "0"),
  // ISO week, 1, 2, ... with localized 'Week ' prefix
  Wp: (date) => `${DateHelper.localize("L{Week}")} ${formats.W(date)}`,
  WWp: (date) => `${DateHelper.localize("L{Week}")} ${formats.WW(date)}`,
  Wp0: (date) => `${DateHelper.localize("L{Week}")[0]}${formats.W(date)}`,
  WWp0: (date) => `${DateHelper.localize("L{Week}")[0]}${formats.WW(date)}`,
  // 1979, 2018
  Y: (date) => date.getFullYear(),
  //date.toLocaleDateString(locale, { year : 'numeric' }),
  // 79, 18
  YY: (date) => (date.getFullYear() % 100).toString().padStart(2, "0"),
  //date.toLocaleDateString(locale, { year : '2-digit' }),
  // 1979, 2018
  YYYY: (date) => date.getFullYear(),
  //date.toLocaleDateString(locale, { year : 'numeric' }),
  // AM, PM
  A: (date) => date.getHours() < 12 ? "AM" : "PM",
  a: (date) => date.getHours() < 12 ? "am" : "pm",
  // 0, 1, ... 23
  H: (date) => date.getHours(),
  // 00, 01, ...
  HH: (date) => date.getHours().toString().padStart(2, "0"),
  // 1, 2, ... 12
  h: (date) => date.getHours() % 12 || 12,
  // 01, 02, ...
  hh: (date) => formats.h(date).toString().padStart(2, "0"),
  // 1, 2, ... 24
  k: (date) => date.getHours() || 24,
  // 01, 02, ...
  kk: (date) => formats.k(date).toString().padStart(2, "0"),
  // Locale specific (0 -> 24 or 1 AM -> 12 PM)
  K: (date) => formatTime("K", { hour: "numeric" }, date),
  // Locale specific (00 -> 24 or 1 AM -> 12 PM)
  KK: (date) => formatTime("KK", { hour: "2-digit" }, date),
  // 0, 1, ... 59
  m: (date) => date.getMinutes(),
  //date.toLocaleTimeString(locale, { minute : 'numeric' }),
  // 00, 01, ...
  mm: (date) => formats.m(date).toString().padStart(2, "0"),
  // 0, 1, ... 59
  s: (date) => date.getSeconds(),
  //date.toLocaleTimeString(locale, { second : 'numeric' }),
  // 00, 01, ...
  ss: (date) => formats.s(date).toString().padStart(2, "0"),
  // 0, 1, ... 9 which are 000, 100, 200 ... 900 in milliseconds
  S: (date) => Math.floor(date.getMilliseconds() / 100).toString(),
  // 00, 01, ... 99 which are 000, 010, 020 ... 990 in milliseconds
  SS: (date) => Math.floor(date.getMilliseconds() / 10).toString().padStart(2, "0"),
  // 000, 001, ... 999 in milliseconds
  SSS: (date) => date.getMilliseconds().toString().padStart(3, "0"),
  z: (date) => useIntlFormat("z", { timeZoneName: "short" }, date),
  zz: (date) => useIntlFormat("zz", { timeZoneName: "long" }, date),
  Z: (date) => DH.getGMTOffset(date),
  LT: (date) => formatTime("LT", { hour: "2-digit", minute: "2-digit" }, date),
  // if minutes is 0, doesn't show it
  LST: (date) => formatTime("LST", { hour: "numeric", minute: "2-digit" }, date, true),
  LTS: (date) => formatTime("LTS", { hour: "2-digit", minute: "2-digit", second: "2-digit" }, date),
  L: (date) => useIntlFormat("L", { year: "numeric", month: "2-digit", day: "2-digit" }, date),
  l: (date) => useIntlFormat("l", intlFormatConfigs.l, date),
  LL: (date) => useIntlFormat("LL", { year: "numeric", month: "long", day: "numeric" }, date),
  ll: (date) => useIntlFormat("ll", intlFormatConfigs.ll, date),
  LLL: (date) => useIntlFormat("LLL", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  }, date),
  lll: (date) => useIntlFormat("lll", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  }, date),
  LLLL: (date) => useIntlFormat("LLLL", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    weekday: "long"
  }, date),
  llll: (date) => useIntlFormat("llll", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    weekday: "short"
  }, date)
};
var formatKeys = Object.keys(formats).sort((a, b) => b.length - a.length);
var formatRegexp = `^(?:${formatKeys.join("|")})`;
var emptyFn2 = () => ({});
var isNumber = (str) => numberRegex.test(str);
var parseMilliseconds = (str) => isNumber(str) && { milliseconds: parseInt(str.padEnd(3, "0").substring(0, 3)) };
var parsers = {
  YYYY: (str) => {
    const year = parseInt(str);
    return { year: year >= 1e3 && year <= 9999 ? year : NaN };
  },
  Y: (str) => ({ year: parseInt(str) }),
  YY: (str) => {
    const year = parseInt(str);
    return { year: year + (year > 1968 ? 1900 : 2e3) };
  },
  M: (str) => ({ month: parseInt(str) - 1 }),
  MM: (str) => ({ month: parseInt(str) - 1 }),
  Mo: (str) => ({ month: parseInt(str) - 1 }),
  MMM: (str) => {
    const month2 = (str || "").toLowerCase();
    for (const [name, entry] of Object.entries(DateHelper._monthShortNamesIndex)) {
      if (month2.startsWith(name)) {
        return { month: entry.value };
      }
    }
  },
  MMMM: (str) => {
    const month2 = (str || "").toLowerCase();
    for (const [name, entry] of Object.entries(DateHelper._monthNamesIndex)) {
      if (month2.startsWith(name)) {
        return { month: entry.value };
      }
    }
  },
  DD: (str) => ({ date: parseInt(str) }),
  D: (str) => ({ date: parseInt(str) }),
  Do: (str) => ({ date: parseInt(str) }),
  DDD: emptyFn2,
  DDDo: emptyFn2,
  DDDD: emptyFn2,
  d: emptyFn2,
  do: emptyFn2,
  d1: emptyFn2,
  dd: emptyFn2,
  ddd: emptyFn2,
  dddd: emptyFn2,
  Q: emptyFn2,
  Qo: emptyFn2,
  W: emptyFn2,
  Wo: emptyFn2,
  WW: emptyFn2,
  e: emptyFn2,
  E: emptyFn2,
  HH: (str) => ({ hours: parseInt(str) }),
  hh: (str) => ({ hours: parseInt(str) }),
  mm: (str) => ({ minutes: parseInt(str) }),
  H: (str) => ({ hours: parseInt(str) }),
  m: (str) => ({ minutes: parseInt(str) }),
  ss: (str) => ({ seconds: parseInt(str) }),
  s: (str) => ({ seconds: parseInt(str) }),
  S: parseMilliseconds,
  SS: parseMilliseconds,
  SSS: parseMilliseconds,
  A: (str) => ({ amPm: str.toLowerCase() }),
  a: (str) => ({ amPm: str.toLowerCase() }),
  L: "MM/DD/YYYY",
  LT: "HH:mm A",
  LTS: "HH:mm:ss A",
  l: { type: "dynamic", parser: () => redirectFormat("l") },
  ll: { type: "dynamic", parser: () => redirectFormat("ll") },
  // Can either be Z (=UTC, 0) or +-HH:MM
  Z: (str) => {
    if (!str || !timeZoneRegEx.test(str) && str !== "Z") {
      return null;
    }
    let timeZone = 0;
    if (str !== "Z") {
      const matches = timeZoneRegEx.exec(str);
      if (matches) {
        const sign = matches[1] === "+" ? 1 : -1, hours = parseInt(matches[2]) || 0, minutes = parseInt(matches[3]) || 0;
        timeZone = sign * (hours * 60 + minutes);
      } else {
        timeZone = -1 * (/* @__PURE__ */ new Date()).getTimezoneOffset();
      }
    }
    return { timeZone };
  }
};
var parserKeys = Object.keys(parsers).sort((a, b) => b.length - a.length);
var parserRegexp = new RegExp(`(${parserKeys.join("|")})`);
var localeStrRegExp = new RegExp("^(LL|LLL|lll|LLLL|llll)$");
var validConversions = {
  // The units below assume:
  // 30 days in a month, 91 days for a quarter and 365 for a year
  // 52 weeks per year, 4 per month, 13 per quarter
  // 3652 days per decade (assuming two of the years will be leap with 366 days)
  decade: {
    decade: 1,
    year: 10,
    quarter: 40,
    month: 120,
    week: 520,
    day: 3652,
    hour: 24 * 3652,
    minute: 1440 * 3652,
    second: 86400 * 3652,
    millisecond: 864e5 * 3652
  },
  year: {
    decade: 0.1,
    year: 1,
    quarter: 4,
    month: 12,
    week: 52,
    day: 365,
    hour: 24 * 365,
    minute: 1440 * 365,
    second: 86400 * 365,
    millisecond: 864e5 * 365
  },
  quarter: {
    decade: 1 / 40,
    year: 1 / 4,
    quarter: 1,
    month: 3,
    week: 4,
    day: 91,
    hour: 24 * 91,
    minute: 1440 * 91,
    second: 86400 * 91,
    millisecond: 864e5 * 91
  },
  month: {
    decade: 1 / 120,
    year: 1 / 12,
    quarter: 1 / 3,
    month: 1,
    week: 4,
    day: -30,
    hour: -24 * 30,
    minute: -1440 * 30,
    second: -86400 * 30,
    millisecond: -864e5 * 30
  },
  week: {
    decade: -1 / 520,
    year: -1 / 52,
    quarter: -1 / 13,
    month: -1 / 4,
    day: 7,
    hour: 168,
    minute: 10080,
    second: 604800,
    millisecond: 6048e5
  },
  day: {
    decade: -1 / 3652,
    year: -1 / 365,
    quarter: -1 / 91,
    month: -1 / 30,
    week: 1 / 7,
    hour: 24,
    minute: 1440,
    second: 86400,
    millisecond: 864e5
  },
  hour: {
    decade: -1 / (3652 * 24),
    year: -1 / (365 * 24),
    quarter: -1 / (91 * 24),
    month: -1 / (30 * 24),
    week: 1 / 168,
    day: 1 / 24,
    minute: 60,
    second: 3600,
    millisecond: 36e5
  },
  minute: {
    decade: -1 / (3652 * 1440),
    year: -1 / (365 * 1440),
    quarter: -1 / (91 * 1440),
    month: -1 / (30 * 1440),
    week: 1 / 10080,
    day: 1 / 1440,
    hour: 1 / 60,
    second: 60,
    millisecond: 6e4
  },
  second: {
    decade: -1 / (3652 * 86400),
    year: -1 / (365 * 86400),
    quarter: -1 / (91 * 86400),
    month: -1 / (30 * 86400),
    week: 1 / 604800,
    day: 1 / 86400,
    hour: 1 / 3600,
    minute: 1 / 60,
    millisecond: 1e3
  },
  millisecond: {
    decade: -1 / (3652 * 864e5),
    year: -1 / (365 * 864e5),
    quarter: -1 / (91 * 864e5),
    month: -1 / (30 * 864e5),
    week: 1 / 6048e5,
    day: 1 / 864e5,
    hour: 1 / 36e5,
    minute: 1 / 6e4,
    second: 1 / 1e3
  }
};
var normalizedUnits = {
  ms: "millisecond",
  milliseconds: "millisecond",
  s: "second",
  seconds: "second",
  m: "minute",
  mi: "minute",
  min: "minute",
  minutes: "minute",
  h: "hour",
  hours: "hour",
  d: "day",
  days: "day",
  w: "week",
  weeks: "week",
  M: "month",
  mo: "month",
  mon: "month",
  months: "month",
  q: "quarter",
  quarters: "quarter",
  y: "year",
  years: "year",
  dec: "decade",
  decades: "decade"
};
var withDecimalsDurationRegex = /^\s*([-+]?\d+(?:[.,]\d*)?|[-+]?(?:[.,]\d+))\s*([^\s]+)?/i;
var noDecimalsDurationRegex = /^\s*([-+]?\d+)(?![.,])\s*([^\s]+)?/i;
var canonicalUnitNames = [
  "millisecond",
  "second",
  "minute",
  "hour",
  "day",
  "week",
  "month",
  "quarter",
  "year",
  "decade"
];
var canonicalUnitAbbreviations = [
  ["mil"],
  ["s", "sec"],
  ["m", "min"],
  ["h", "hr"],
  ["d"],
  ["w", "wk"],
  ["mo", "mon", "mnt"],
  ["q", "quar", "qrt"],
  ["y", "yr"],
  ["dec"]
];
var deltaUnits = [
  "decade",
  "year",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var dateProperties = [
  "milliseconds",
  "seconds",
  "minutes",
  "hours",
  "date",
  "month",
  "year"
];
var parseNumber = (n) => {
  const result = parseFloat(n);
  return isNaN(result) ? null : result;
};
var numberRegex = /^[0-9]+$/;
var timeZoneRegEx = /([+-])(\d\d):*(\d\d)*$/;
var unitMagnitudes = {
  millisecond: 0,
  second: 1,
  minute: 2,
  hour: 3,
  day: 4,
  week: 5,
  month: 6,
  quarter: 7,
  year: 8,
  decade: 9
};
var snapFns = {
  round(number, step = 1) {
    return Math.round(number / step) * step;
  },
  floor(number, step = 1) {
    return Math.floor(number / step) * step;
  },
  ceil(number, step = 1) {
    return Math.ceil(number / step) * step;
  }
};
var keyCache = {};
var _DateHelper = class _DateHelper extends Localizable_default() {
  static get $name() {
    return "DateHelper";
  }
  //region Parse & format
  /**
   * Get/set the default format used by `format()` and `parse()`. Defaults to `'YYYY-MM-DDTHH:mm:ssZ'`
   * (~ISO 8601 Date and time, `'1962-06-17T09:21:34Z'`).
   * @member {String}
   */
  static set defaultFormat(format) {
    DH._defaultFormat = format;
  }
  static get defaultFormat() {
    return DH._defaultFormat || "YYYY-MM-DDTHH:mm:ssZ";
  }
  /**
   * Get/set the default format used by `parse()`. Defaults to `'YYYY-MM-DDTHH:mm:ss.SSSZ'` or {@link #property-defaultFormat-static}
   * (~ISO 8601 Date and time, `'1962-06-17T09:21:34.123Z'`).
   * @member {String}
   */
  static set defaultParseFormat(parseFormat) {
    this._defaultParseFormat = parseFormat;
  }
  static get defaultParseFormat() {
    return this._defaultParseFormat || this._defaultFormat || "YYYY-MM-DDTHH:mm:ss.SSSZ";
  }
  static buildParser(format) {
    const parts = format.split(parserRegexp), parser = [];
    if (parts.length === 1 || localeStrRegExp.test(format)) {
      return [];
    } else {
      parts.reduce((prev, curr, index, array) => {
        if (index !== 0 || curr !== "") {
          if (parserRegexp.test(curr)) {
            const localeParsers = this.localize("L{parsers}") || {}, fn = localeParsers[curr] || parsers[curr];
            if (curr === "Z" && index < array.length - 2) {
              throw new Error(`Invalid format ${format} TimeZone (Z) must be last token`);
            }
            const parserObj = typeof fn === "function" || typeof fn === "string" ? fn : fn.parser();
            if (typeof parserObj === "string") {
              const nestedParsers = DH.buildParser(parserObj), lastItem = nestedParsers.pop();
              delete lastItem.last;
              parser.push(...nestedParsers);
              prev = lastItem;
            } else {
              prev.pattern = curr;
              prev.fn = parserObj;
            }
          } else {
            prev.splitter = curr;
            parser.push(prev);
            prev = {};
          }
        } else if (Object.prototype.hasOwnProperty.call(prev, "pattern")) {
          parser.push(prev);
        }
        return prev;
      }, {});
    }
    parser[parser.length - 1].last = true;
    return parser;
  }
  /**
   * A utility function to create a sortable string key for the passed date or ms timestamp using the `'YYYY-MM-DD'`
   * format.
   * @param {Number|Date} ms The Date instance or ms timestamp to generate a key for
   * @returns {String} Date/timestamp as a string with `'YYYY-M-D'` format
   * @internal
   */
  static makeKey(ms) {
    if (ms.length === 10) {
      return ms;
    }
    if (ms.getTime) {
      ms = ms.getTime();
    }
    const cached = keyCache[Math.trunc(ms / MS_PER_HOUR)];
    if (cached) {
      return cached;
    }
    tempDate.setTime(ms);
    const month2 = tempDate.getMonth() + 1, date = tempDate.getDate();
    return keyCache[Math.trunc(ms / MS_PER_HOUR)] = `${tempDate.getFullYear()}-${month2 < 10 ? "0" + month2 : month2}-${date < 10 ? "0" + date : date}`;
  }
  /**
   * A utility function to parse a sortable string to a date using the `'YYYY-MM-DD'` format.
   * @param {String} key The string to return a date for
   * @returns {Date} new Date instance
   * @internal
   */
  static parseKey(key) {
    return DH.parse(key, "YYYY-MM-DD");
  }
  /**
   * Returns a date created from the supplied string using the specified format. Will try to create even if format
   * is left out, by first using the default format (see {@link #property-defaultFormat-static}, by default
   * `YYYY-MM-DDTHH:mm:ssZ`) and then using `new Date(dateString)`.
   * Supported tokens:
   *
   * | Unit        | Token | Description                       |
   * |-------------|-------|-----------------------------------|
   * | Year        | YYYY  | 2018                              |
   * |             | YY    | < 68 -> 2000, > 68 -> 1900        |
   * | Month       | MM    | 01 - 12                           |
   * | Date        | DD    | 01 - 31                           |
   * | Hour        | HH    | 00 - 23 or 1 - 12                 |
   * | Minute      | mm    | 00 - 59                           |
   * | Second      | ss    | 00 - 59                           |
   * | Millisecond | S     | 0 - 9 [000, 100, 200 .. 900 ]     |
   * |             | SS    | 00 - 99 [000, 010, 020 .. 990 ]   |
   * |             | SSS   | 000 - 999 [000, 001, 002 .. 999 ] |
   * | AM/PM       | A     | AM or PM                          |
   * |             | a     | am or pm                          |
   * | TimeZone    | Z     | Z for UTC or +-HH:mm              |
   * | Predefined  | L     | Long date, MM/DD/YYYY             |
   * |             | LT    | Long time, HH:mm A                |
   *
   * Predefined formats and functions used to parse tokens can be localized, see for example the swedish locale SvSE.js
   *
   * NOTE: If no date parameters are provided then `Jan 01 2020` is used as a default date
   *
   * @param {String} dateString Date string
   * @param {String} [format] Date format (or {@link #property-defaultParseFormat-static} if left out)
   * @returns {Date} new Date instance parsed from the string
   * @category Parse & format
   */
  static parse(dateString, format = DH.defaultParseFormat, strict = false) {
    if (dateString instanceof Date) {
      return dateString;
    }
    if (typeof dateString !== "string" || !dateString) {
      return null;
    }
    const config = {
      year: null,
      month: null,
      date: null,
      hours: null,
      minutes: null,
      seconds: null,
      milliseconds: null
    };
    format = format.replace(msRegExp, msReplacer);
    let parser = parserCache[format], result;
    if (!parser) {
      parser = parserCache[format] = DH.buildParser(format);
    }
    if (dateString.includes("\u202F")) {
      dateString = dateString.replace(/\s/g, " ");
    }
    parser.reduce((dateString2, parser2) => {
      var _a2;
      if (parser2.last) {
        Object.assign(config, parser2.fn(dateString2));
      } else {
        let splitAt;
        if (parser2.splitter === "T" && dateString2.indexOf("T") === -1) {
          splitAt = dateString2.indexOf(" ");
        } else {
          const timeZoneIndex = dateString2.indexOf("+");
          let { splitter } = parser2;
          if (!strict && splitRegExp.test(splitter)) {
            splitter = splitRegExp;
          }
          splitAt = parser2.splitter !== "" ? dateString2.search(typeof splitter === "string" ? StringHelper.escapeRegExp(splitter) : splitter) : ((_a2 = parser2.pattern) == null ? void 0 : _a2.length) || -1;
          if (timeZoneIndex > -1 && splitAt > timeZoneIndex) {
            splitAt = -1;
          }
        }
        let part, rest;
        if (splitAt === -1 || parser2.pattern === "SSS" && dateString2.match(/^\d+Z$/)) {
          const chunks = dateString2.split(/([Z\-+])/);
          if (chunks.length === 1) {
            part = dateString2;
            rest = "";
          } else {
            part = chunks[0];
            rest = `${chunks[1]}${chunks[2]}`;
          }
        } else {
          part = dateString2.substring(0, splitAt) || dateString2;
          rest = dateString2.substring(splitAt + parser2.splitter.length);
        }
        if (parser2.fn) {
          const res = parser2.fn(part);
          if (res) {
            Object.assign(config, res);
          } else {
            rest = part + rest;
          }
        }
        return rest;
      }
    }, dateString);
    if (config.year && !config.date) {
      config.date = 1;
    }
    if (config.date > 31 || config.month > 12) {
      return null;
    }
    const date = DH.create(config, strict);
    if (date) {
      result = date;
    } else if (!strict) {
      result = new Date(dateString);
    }
    return result;
  }
  /**
   * Creates a date from a date definition object. The object can have the following properties:
   * - year
   * - month
   * - date (day in month)
   * - hours
   * - minutes
   * - seconds
   * - milliseconds
   * - amPm : 'am' or 'pm', implies 12-hour clock
   * - timeZone : offset from UTC in minutes
   * @param {Object} definition
   * @param {Number} definition.year
   * @param {Number} [definition.month]
   * @param {Number} [definition.date]
   * @param {Number} [definition.hours]
   * @param {Number} [definition.minutes]
   * @param {Number} [definition.seconds]
   * @param {Number} [definition.milliseconds]
   * @param {Number} [definition.amPm]
   * @param {Number} [definition.timeZone]
   * @returns {Date} new Date instance
   * @category Parse & format
   */
  static create(definition, strict = false) {
    const def = { ...definition };
    let invalid = isNaN(def.year) || strict && (isNaN(def.month) || isNaN(def.date)), useUTC = false;
    if (!invalid) {
      let allNull = true;
      dateProperties.forEach((property) => {
        if (!(property in def) || isNaN(def[property])) {
          def[property] = 0;
        }
        allNull = allNull && def[property] === null;
      });
      invalid = allNull;
    }
    if (invalid) {
      return null;
    }
    if (def.amPm === "am") {
      def.hours = def.hours % 12;
    } else if (def.amPm === "pm") {
      def.hours = def.hours % 12 + 12;
    }
    if ("timeZone" in def) {
      useUTC = true;
      def.minutes -= def.timeZone;
    }
    if (strict && (def.year == null || def.month == null || def.date == null)) {
      return null;
    }
    const args = [
      defaultValue(def.year, DEFAULT_YEAR),
      defaultValue(def.month, DEFAULT_MONTH),
      defaultValue(def.date, DEFAULT_DAY),
      def.hours,
      def.minutes,
      def.seconds,
      def.milliseconds
    ];
    return useUTC ? new Date(Date.UTC(...args)) : new Date(...args);
  }
  static toUTC(date) {
    return new Date(Date.UTC(
      date.getUTCFullYear(),
      date.getUTCMonth(),
      date.getUTCDate(),
      date.getUTCHours(),
      date.getUTCMinutes(),
      date.getUTCSeconds(),
      date.getUTCMilliseconds()
    ));
  }
  /**
   * Converts a date to string with the specified format. Formats heavily inspired by https://momentjs.com.
   * Available formats (input used for output below is `new Date(2018,8,9,18,7,8,145)`):
   *
   * | Unit                  | Token | Description & output                  |
   * |-----------------------|-------|---------------------------------------|
   * | Year                  | YYYY  | 2018                                  |
   * |                       | YY    | 18                                    |
   * |                       | Y     | 2018                                  |
   * | Quarter               | Q     | 3                                     |
   * |                       | Qo    | 3rd                                   |
   * | Month                 | MMMM  | September                             |
   * |                       | MMM   | Sep                                   |
   * |                       | MM    | 09                                    |
   * |                       | Mo    | 9th                                   |
   * |                       | M     | 9                                     |
   * | Week (iso)            | WW    | 37 (2 digit, zero padded)             |
   * |                       | Wo    | 37th                                  |
   * |                       | W     | 37                                    |
   * |                       | WWp   | Week 37 (localized prefix, zero pad)  |
   * |                       | Wp    | Week 37 (localized prefix)            |
   * |                       | WWp0  | W37 (localized prefix)                |
   * |                       | Wp0   | W37 (localized prefix)                |
   * | Date                  | DDDD  | Day of year, 3 digits                 |
   * |                       | DDDo  | Day of year, ordinal                  |
   * |                       | DDD   | Day of year                           |
   * |                       | DD    | 09                                    |
   * |                       | Do    | 9th                                   |
   * |                       | D     | 9                                     |
   * | Weekday               | dddd  | Sunday                                |
   * |                       | ddd   | Sun                                   |
   * |                       | dd    | Su                                    |
   * |                       | d1    | S                                     |
   * |                       | do    | 0th                                   |
   * |                       | d     | 0                                     |
   * | Hour                  | HH    | 18 (00 - 23)                          |
   * |                       | H     | 18 (0 - 23)                           |
   * |                       | hh    | 06 (00 - 12)                          |
   * |                       | h     | 6 (0 - 12)                            |
   * |                       | KK    | 19 (01 - 24)                          |
   * |                       | K     | 19 (1 - 24)                           |
   * |                       | kk    | 06 or 18, locale determines           |
   * |                       | k     | 6 or 18, locale determines            |
   * | Minute                | mm    | 07                                    |
   * |                       | m     | 7                                     |
   * | Second                | ss    | 08                                    |
   * |                       | s     | 8                                     |
   * | Millisecond           | S     | 1 (100ms)                             |
   * |                       | SS    | 14 (140ms)                            |
   * |                       | SSS   | 145 (145ms)                           |
   * | AM/PM                 | A     | AM or PM                              |
   * |                       | a     | am or pm                              |
   * | Predefined            | LT    | H: 2-digit (2d), m: 2d                |
   * | (uses browser locale) | LTS   | H: 2d, m: 2d, s : 2d                  |
   * |                       | LST   | Depends on 12 or 24 hour clock        |
   * |                       |       | 12h, H : 1d, m : 0 or 2d              |
   * |                       |       | 24h, H : 2d, m : 2d                   |
   * |                       | L     | Y: numeric (n), M : 2d, D : 2d        |
   * |                       | l     | Y: n, M : n, D : n                    |
   * |                       | LL    | Y: n, M : long (l), D : n             |
   * |                       | ll    | Y: n, M : short (s), D : n            |
   * |                       | LLL   | Y: n, M : l, D : n, H: n, m: 2d       |
   * |                       | lll   | Y: n, M : s, D : n, H: n, m: 2d       |
   * |                       | LLLL  | Y: n, M : l, D : n, H: n, m: 2d, d: l |
   * |                       | llll  | Y: n, M : s, D : n, H: n, m: 2d, d: s |
   *
   * Some examples:
   *
   * ```javascript
   * DateHelper.format(new Date(2019, 7, 16), 'dddd') -> Friday
   * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'HH:mm') --> 14:27
   * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'L HH') --> 2019-07-16 14
   * ```
   *
   * Arbitrary text can be embedded in the format string by wrapping it with {}:
   *
   * ```javascript
   * DateHelper.format(new Date(2019, 7, 16), '{It is }dddd{, yay!}') -> It is Friday, yay!
   * ```
   *
   * @param {Date} date Date
   * @param {String} [format] Desired format (uses `defaultFormat` if left out)
   * @returns {String} Formatted string
   * @category Parse & format
   */
  static format(date, format = DH.defaultFormat) {
    if (!date || isNaN(date)) {
      return null;
    }
    let formatter = formatCache[format], output = "";
    if (!formatter) {
      formatter = formatCache[format] = [];
      for (let i = 0; i < format.length; i++) {
        const formatMatch = format.slice(i).match(formatRegexp), predefined = formatMatch == null ? void 0 : formatMatch[0];
        if (predefined) {
          const localeFormats = this.localize("L{formats}") || {}, fn = localeFormats[predefined] || formats[predefined];
          formatter.push(fn);
          i += predefined.length - 1;
        } else if (format[i] === "{") {
          const index = format.indexOf("}", i + 1);
          if (index === -1) {
            formatter.push(format.substr(i + 1));
            i = format.length;
          } else {
            formatter.push(format.substring(i + 1, index));
            i = index;
          }
        } else {
          formatter.push(format[i]);
        }
      }
    }
    formatter.forEach((step) => {
      if (typeof step === "string") {
        output += step;
      } else {
        output += step(date);
      }
    });
    return output;
  }
  /**
   * Formats a range of `dates` using the specified `format`. Because two dates are involved, the `format` specifier
   * uses the tokens `S{}` and `E{}`. The text contained between the `{}` is the {@link #function-format-static format}
   * for the start date or end date, respectively. Text not inside these tokens is retained verbatim.
   *
   * For example:
   *
   * ```javascript
   *  DateHelper.formatRange(dates, 'S{DD MMM YYYY} - E{DD MMM YYYY}');
   * ```
   *
   * The above will format `dates[0]` based on the `S{DD MMM YYYY}` segment and `dates[1] using `E{DD MMM YYYY}`. The
   * `' - '` between these will remain between the two formatted dates.
   *
   * @param {Date[]} dates An array of start date and end date (`[startDate, endDate]`)
   * @param {String} format The format specifier
   * @returns {String}
   */
  static formatRange(dates, format) {
    return format.replace(
      rangeFormatPartRe,
      (s, which, fmt) => _DateHelper.format(dates[which === "S" ? 0 : 1], fmt)
    );
  }
  /**
   * Converts the specified amount of desired unit into milliseconds. Can be called by only specifying a unit as the
   * first argument, it then uses `amount = 1`.
   *
   * For example:
   *
   * ```javascript
   * asMilliseconds('hour') == asMilliseconds(1, 'hour')
   * ```
   *
   * @param {Number|String} amount Amount, what of is decided by specifying unit (also takes a unit which implies an amount of 1)
   * @param {String} [unit] Time unit (s, hour, months etc.)
   * @returns {Number}
   * @category Parse & format
   */
  static asMilliseconds(amount, unit = null) {
    if (typeof amount === "string") {
      unit = amount;
      amount = 1;
    }
    return DH.as("millisecond", amount, unit);
  }
  /**
   * Converts the passed Date to an accurate number of months passed since the epoch start.
   * @param {Date} time The Date to find the month value of
   * @returns {Number} The number of months since the system time epoch start. May be a fractional value
   */
  static asMonths(time) {
    const monthLength = DH.as("ms", DH.daysInMonth(time), "day"), fraction = (time.valueOf() - DH.startOf(time, "month").valueOf()) / monthLength;
    return time.getYear() * 12 + time.getMonth() + fraction;
  }
  static monthsToDate(months) {
    const intMonths = Math.floor(months), fraction = months - intMonths, result = new Date(0, intMonths), msInMonth = DH.as("ms", DH.daysInMonth(result), "days");
    result.setTime(result.getTime() + fraction * msInMonth);
    return result;
  }
  /**
   * Converts a millisecond time delta to a human-readable form. For example `1000 * 60 * 60 * 50`
   * milliseconds would be rendered as `'2 days, 2 hours'`.
   * @param {Number} delta The millisecond delta value
   * @param {Object} [options] Formatting options
   * @param {Boolean} [options.abbrev] Pass `true` to use abbreviated unit names, eg `'2d, 2h'` for the above example
   * @param {String} [options.precision] The minimum precision unit
   * @param {String} [options.separator] The separator to use
   * @param {Boolean} [options.asString] Pass `false` to return the result as an array, eg ['2d', '2h'] for the above example
   * @returns {String} Formatted string
   * @category Parse & format
   */
  static formatDelta(delta, options) {
    let abbrev, unitName;
    if (typeof options === "boolean") {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
    }
    const deltaObj = this.getDelta(delta, options), result = [], sep = (options == null ? void 0 : options.separator) || (abbrev ? "" : " ");
    for (unitName in deltaObj) {
      result.push(`${deltaObj[unitName]}${sep}${unitName}`);
    }
    return (options == null ? void 0 : options.asString) === false ? result : result.join(", ");
  }
  /**
   * Converts a millisecond time delta to an object structure. For example `1000 * 60 * 60 * 50`
   * milliseconds the result would be as:
   *
   * ```javascript
   * {
   *     day  : 2,
   *     hour : 2
   * }
   *```
   *
   * @param {Number} delta The millisecond delta value
   * @param {Object} [options] Formatting options
   * @param {Boolean} [options.abbrev] Pass `true` to use abbreviated unit names, eg `{ d: 2, h: 2 }` for the above example
   * @param {String} [options.precision] The minimum precision unit
   * @param {Boolean} [options.ignoreLocale] Pass true to return unlocalized unit name. Requires `abbrev` to be false
   * @param {String} [options.maxUnit] Name of the maximum unit in the output. e.g. if you pass `day` then you'll get
   * `{ h: 25 }` instead of `{ d: 1, h: 1 }`
   * @returns {Object} The object with the values for each unit
   */
  static getDelta(delta, options) {
    let abbrev, d, done, precision, unitName, maxUnit, ignoreLocale;
    if (typeof options === "boolean") {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
      precision = DH.normalizeUnit(options.precision);
      maxUnit = options.maxUnit;
      ignoreLocale = !abbrev && options.ignoreLocale;
    }
    const result = {}, getUnit = abbrev ? DH.getShortNameOfUnit : DH.getLocalizedNameOfUnit;
    const units = maxUnit ? deltaUnits.slice(deltaUnits.indexOf(maxUnit)) : deltaUnits;
    for (unitName of units) {
      d = DH.as(unitName, delta);
      done = precision === unitName;
      d = Math[done ? "round" : "floor"](d);
      if (d || done && !result.length) {
        result[ignoreLocale ? unitName : getUnit.call(DH, unitName, d !== 1)] = d;
        delta -= DH.as("ms", d, unitName);
      }
      if (done || !delta) {
        break;
      }
    }
    return result;
  }
  /**
   * Converts the specified amount of one unit (`fromUnit`) into an amount of another unit (`toUnit`).
   * @param {String} toUnit The name of units to convert to, eg: `'ms'`
   * @param {Number|String} amount The time to convert. Either the magnitude number form or a duration string such as '2d'
   * @param {String} [fromUnit='ms'] If the amount was passed as a number, the units to use to convert from
   * @returns {Number}
   * @category Parse & format
   */
  static as(toUnit, amount, fromUnit = "ms") {
    if (typeof amount === "string") {
      amount = DH.parseDuration(amount);
    }
    if (typeof amount === "object") {
      fromUnit = amount.unit;
      amount = amount.magnitude;
    }
    if (toUnit === fromUnit) {
      return amount;
    }
    toUnit = DH.normalizeUnit(toUnit);
    fromUnit = DH.normalizeUnit(fromUnit);
    if (toUnit === fromUnit) {
      return amount;
    } else if (unitMagnitudes[fromUnit] > unitMagnitudes[toUnit]) {
      return amount * Math.abs(validConversions[fromUnit][toUnit]);
    } else {
      return amount / Math.abs(validConversions[toUnit][fromUnit]);
    }
  }
  static formatContainsHourInfo(format) {
    const stripEscapeRe = /(\\.)/g, hourInfoRe = /([HhKkmSsAa]|LT|L{3,}|l{3,})/;
    return hourInfoRe.test(format.replace(stripEscapeRe, ""));
  }
  /**
   * Returns `true` for 24-hour format.
   * @param {String} format Date format
   * @returns {Boolean} `true` for 24-hour format
   * @category Parse & format
   */
  static is24HourFormat(format) {
    return DH.format(DH.getTime(13, 0, 0), format).includes("13");
  }
  //endregion
  //region Manipulate
  /**
   * Add days, hours etc. to a date. Always clones the date, original will be left unaffected.
   * @param {Date|String} date Original date
   * @param {Number|String|Core.data.Duration|DurationConfig} amount Amount of days, hours etc. or a string representation of a duration
   * as accepted by {@link #function-parseDuration-static} or an object with `{ magnitude, unit }` properties
   * @param {String} [unit='ms'] Unit for amount
   * @privateparam {Boolean} [clone=true] Pass `false` to affect the original
   * @returns {Date} New calculated date
   * @category Manipulate
   */
  static add(date, amount, unit = "ms", clone = true) {
    let d;
    if (typeof date === "string") {
      d = DH.parse(date);
    } else if (clone) {
      d = new Date(date.getTime());
    } else {
      d = date;
    }
    if (typeof amount === "string") {
      const duration = _DateHelper.parseDuration(amount);
      amount = duration.magnitude;
      unit = duration.unit;
    } else if (amount && typeof amount === "object") {
      unit = amount.unit;
      amount = amount.magnitude;
    }
    if (!unit || amount === 0) {
      return d;
    }
    unit = DH.normalizeUnit(unit);
    switch (unit) {
      case "millisecond":
        d.setTime(d.getTime() + amount);
        break;
      case "second":
        d.setTime(d.getTime() + amount * 1e3);
        break;
      case "minute":
        d.setTime(d.getTime() + amount * 6e4);
        break;
      case "hour":
        d.setTime(d.getTime() + amount * 36e5);
        break;
      case "day":
        if (amount % 1 === 0) {
          d.setDate(d.getDate() + amount);
          if (d.getHours() === 23 && date.getHours() === 0) {
            d.setHours(d.getHours() + 1);
          }
        } else {
          d.setTime(d.getTime() + amount * 864e5);
        }
        break;
      case "week":
        d.setDate(d.getDate() + amount * 7);
        break;
      case "month": {
        let day2 = d.getDate();
        if (day2 > 28) {
          day2 = Math.min(day2, DH.getLastDateOfMonth(DH.add(DH.getFirstDateOfMonth(d), amount, "month")).getDate());
        }
        d.setDate(day2);
        d.setMonth(d.getMonth() + amount);
        break;
      }
      case "quarter":
        DH.add(d, amount * 3, "month", false);
        break;
      case "year":
        d.setFullYear(d.getFullYear() + amount);
        break;
      case "decade":
        d.setFullYear(d.getFullYear() + amount * 10);
        break;
    }
    return d;
  }
  /**
   * Calculates the difference between two dates, in the specified unit.
   * @param {Date} start First date
   * @param {Date} end Second date
   * @param {String} [unit='ms'] Unit to calculate difference in
   * @param {Boolean} [fractional=true] Specify false to round result
   * @returns {Number} Difference in the specified unit
   * @category Manipulate
   */
  static diff(start, end, unit = "ms", fractional = true) {
    unit = DH.normalizeUnit(unit);
    if (!start || !end)
      return 0;
    let amount;
    switch (unit) {
      case "year":
        amount = DH.diff(start, end, "month") / 12;
        break;
      case "quarter":
        amount = DH.diff(start, end, "month") / 3;
        break;
      case "month":
        amount = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
        if (amount === 0 && fractional) {
          amount = DH.diff(start, end, "day", fractional) / DH.daysInMonth(start);
        }
        break;
      case "week":
        amount = DH.diff(start, end, "day") / 7;
        break;
      case "day": {
        const dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
        amount = (end - start + dstDiff * 60 * 1e3) / 864e5;
        break;
      }
      case "hour":
        amount = (end - start) / 36e5;
        break;
      case "minute":
        amount = (end - start) / 6e4;
        break;
      case "second":
        amount = (end - start) / 1e3;
        break;
      case "millisecond":
        amount = end - start;
        break;
    }
    return fractional ? amount : Math.round(amount);
  }
  /**
   * Sets the date to the start of the specified unit, by default returning a clone of the date instead of changing it
   * in place.
   * @param {Date} date Original date
   * @param {String} [unit='day'] Start of this unit, `'day'`, `'month'` etc
   * @param {Boolean} [clone=true] Manipulate a copy of the date
   * @param {Number} [weekStartDay] The first day of week, `0-6` (Sunday-Saturday). Defaults to the {@link #property-weekStartDay-static}
   * @returns {Date} Manipulated date
   * @category Manipulate
   */
  static startOf(date, unit = "day", clone = true, weekStartDay = DH.weekStartDay) {
    if (!date) {
      return null;
    }
    unit = DH.normalizeUnit(unit);
    if (clone) {
      date = DH.clone(date);
    }
    switch (unit) {
      case "year":
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "quarter":
        date.setMonth((DH.get(date, "quarter") - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "month":
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "week": {
        const delta = date.getDay() - weekStartDay;
        date.setDate(date.getDate() - delta);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      case "day":
        date.setHours(0, 0, 0, 0);
        return date;
      case "hour":
        date.getMinutes() > 0 && date.setMinutes(0);
      case "minute":
        date.getSeconds() > 0 && date.setSeconds(0);
      case "second":
        date.getMilliseconds() > 0 && date.setMilliseconds(0);
      case "millisecond":
        return date;
    }
  }
  /**
   * Returns the end point of the passed date, that is 00:00:00 of the day after the passed date.
   * @param {Date} date The date to return the end point of
   * @returns {Date} Manipulated date
   */
  static endOf(date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
  }
  /**
   * Creates a clone of the specified date
   * @param {Date} date Original date
   * @returns {Date} Cloned date
   * @category Manipulate
   */
  static clone(date) {
    return new Date(date.getTime());
  }
  /**
   * Removes time from a date (same as calling {@link #function-startOf-static startOf(date)}).
   * @param {Date} date Date to remove time from
   * @param {Boolean} [clone=true] Manipulate a copy of the date
   * @returns {Date} Manipulated date
   * @category Manipulate
   */
  static clearTime(date, clone = true) {
    if (!date) {
      return null;
    }
    if (clone) {
      date = new Date(date.getTime());
    }
    date.setHours(0, 0, 0, 0);
    return date;
  }
  static midnight(date, inclusive) {
    let ret = DH.clearTime(date);
    if (inclusive && ret < date) {
      ret = DH.add(ret, 1, "d");
    }
    return ret;
  }
  /**
   * Returns the elapsed milliseconds from the start of the specified date.
   * @param {Date} date Date to remove date from
   * @param {String} [unit='ms'] The time unit to return
   * @returns {Number} The elapsed milliseconds from the start of the specified date
   * @category Manipulate
   */
  static getTimeOfDay(date, unit = "ms") {
    const t = date.getHours() * validConversions.hour.millisecond + date.getMinutes() * validConversions.minute.millisecond + date.getSeconds() * validConversions.second.millisecond + date.getMilliseconds();
    return unit === "ms" ? t : DH.as(unit, t, "ms");
  }
  /**
   * Sets a part of a date (in place).
   * @param {Date} date Date to manipulate
   * @param {String|Object} unit Part of date to set, for example `'minute'`. Or an object like `{ second: 1, minute: 1 }`
   * @param {Number} amount Value to set
   * @returns {Date} Passed date instance modified according to the arguments
   * @category Manipulate
   */
  static set(date, unit, amount) {
    if (!unit) {
      return date;
    }
    if (typeof unit === "string") {
      switch (DH.normalizeUnit(unit)) {
        case "millisecond":
          if (amount !== 0 || date.getMilliseconds() > 0) {
            date.setMilliseconds(amount);
          }
          break;
        case "second":
          if (amount !== 0 || date.getSeconds() > 0) {
            date.setSeconds(amount);
          }
          break;
        case "minute":
          if (amount !== 0 || date.getMinutes() > 0) {
            date.setMinutes(amount);
          }
          break;
        case "hour":
          date.setHours(amount);
          break;
        case "day":
        case "date":
          date.setDate(amount);
          break;
        case "week":
          throw new Error("week not implemented");
        case "month":
          date.setMonth(amount);
          break;
        case "quarter":
          date.setDate(1);
          date.setMonth((amount - 1) * 3);
          break;
        case "year":
          date.setFullYear(amount);
          break;
      }
    } else {
      Object.entries(unit).sort((a, b) => unitMagnitudes[a[0]] - unitMagnitudes[b[0]]).forEach(([unit2, amount2]) => {
        DH.set(date, unit2, amount2);
      });
    }
    return date;
  }
  static setDateToMidday(date, clone = true) {
    return DH.set(DH.clearTime(date, clone), "hour", 12);
  }
  /**
   * Constrains the date within a min and a max date.
   * @param {Date} date The date to constrain
   * @param {Date} [min] Min date
   * @param {Date} [max] Max date
   * @returns {Date} The constrained date
   * @category Manipulate
   */
  static constrain(date, min2, max) {
    if (min2 != null) {
      date = DH.max(date, min2);
    }
    return max == null ? date : DH.min(date, max);
  }
  /**
   * Returns time with default year, month, and day (Jan 1, 2020).
   * @param {Number|Date} hours Hours value or the full date to extract the time of
   * @param {Number} [minutes=0] Minutes value
   * @param {Number} [seconds=0] Seconds value
   * @param {Number} [ms=0] Milliseconds value
   * @returns {Date} A new default date with the time extracted from the given date or from the time values provided individually
   * @category Manipulate
   */
  static getTime(hours, minutes = 0, seconds = 0, ms = 0) {
    if (hours instanceof Date) {
      ms = hours.getMilliseconds();
      seconds = hours.getSeconds();
      minutes = hours.getMinutes();
      hours = hours.getHours();
    }
    return new Date(DEFAULT_YEAR, DEFAULT_MONTH, DEFAULT_DAY, hours, minutes, seconds, ms);
  }
  /**
   * Copies hours, minutes, seconds, milliseconds from one date to another.
   *
   * @param {Date} targetDate The target date
   * @param {Date} sourceDate The source date
   * @returns {Date} The adjusted target date
   * @category Manipulate
   * @static
   */
  static copyTimeValues(targetDate, sourceDate) {
    targetDate.setHours(sourceDate.getHours());
    targetDate.setMinutes(sourceDate.getMinutes());
    targetDate.setSeconds(sourceDate.getSeconds());
    targetDate.setMilliseconds(sourceDate.getMilliseconds());
    return targetDate;
  }
  //endregion
  //region Comparison
  static get isDSTEnabled() {
    const year = (/* @__PURE__ */ new Date()).getFullYear(), jan = new Date(year, 0, 1), jul = new Date(year, 6, 1);
    return jan.getTimezoneOffset() !== jul.getTimezoneOffset();
  }
  static isDST(date) {
    const year = date.getFullYear(), jan = new Date(year, 0, 1), jul = new Date(year, 6, 1);
    return date.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  }
  /**
   * Determines if a date precedes another.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Boolean} `true` if first precedes second, otherwise false
   * @category Comparison
   */
  static isBefore(first, second) {
    return first < second;
  }
  /**
   * Determines if a date succeeds another.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Boolean} `true` if first succeeds second, otherwise false
   * @category Comparison
   */
  static isAfter(first, second) {
    return first > second;
  }
  /**
   * Checks if two dates are equal.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @param {String} [unit] Unit to calculate difference in. If not given, the comparison will be done up to a millisecond
   * @returns {Boolean} `true` if the dates are equal
   * @category Comparison
   */
  static isEqual(first, second, unit = null) {
    if (unit === null) {
      return first && second && first.getTime() === second.getTime();
    }
    return DH.startOf(first, unit) - DH.startOf(second, unit) === 0;
  }
  /**
   * Compares two dates using the specified precision.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @param {String} [unit] Unit to calculate difference in. If not given, the comparison will be done up to a millisecond
   * @returns {Number} `0` = equal, `-1` = first before second, `1` = first after second
   * @category Comparison
   */
  static compare(first, second, unit = null) {
    if (unit) {
      first = DH.startOf(first, unit);
      second = DH.startOf(second, unit);
    }
    if (first < second)
      return -1;
    if (first > second)
      return 1;
    return 0;
  }
  /**
   * Coerces the passed Date between the passed minimum and maximum values.
   * @param {Date} date The date to clamp between the `min` and `max`
   * @param {Date} min The minimum Date
   * @param {Date} max The maximum Date
   * @returns {Date} If the passed `date` is valid, a *new* Date object which is clamped between the `min` and `max`
   */
  static clamp(date, min2, max) {
    if (!isNaN(date)) {
      if (min2 != null) {
        date = Math.max(date, min2);
      }
      if (max != null) {
        date = Math.min(date, max);
      }
      return new Date(date);
    }
  }
  static isSameDate(first, second) {
    return DH.compare(first, second, "d") === 0;
  }
  static isSameTime(first, second) {
    return first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes() && first.getSeconds() === second.getSeconds() && first.getMilliseconds() === second.getMilliseconds();
  }
  /**
   * Checks if date is the start of specified unit.
   * @param {Date} date Date
   * @param {String} unit Time unit
   * @returns {Boolean} `true` if date is the start of specified unit
   * @category Comparison
   */
  static isStartOf(date, unit) {
    return DH.isEqual(date, DH.startOf(date, unit));
  }
  /**
   * Checks if this date is `>= start` and `< end`.
   * @param {Date} date The source date
   * @param {Date} start Start date
   * @param {Date} end End date
   * @returns {Boolean} `true` if this date falls on or between the given start and end dates
   * @category Comparison
   */
  static betweenLesser(date, start, end) {
    return start.getTime() <= date.getTime() && date.getTime() < end.getTime();
  }
  /**
   * Checks if this date is `>= start` and `<= end`.
   * @param {Date} date The source date
   * @param {Date} start Start date
   * @param {Date} end End date
   * @returns {Boolean} `true` if this date falls on or between the given start and end dates
   * @category Comparison
   */
  static betweenLesserEqual(date, start, end) {
    return start.getTime() <= date.getTime() && date.getTime() <= end.getTime();
  }
  /**
   * Returns `true` if dates intersect.
   * @param {Date} date1Start Start date of first span
   * @param {Date} date1End End date of first span
   * @param {Date} date2Start Start date of second span
   * @param {Date} date2End End date of second span
   * @returns {Boolean} Returns `true` if dates intersect
   * @category Comparison
   */
  static intersectSpans(date1Start, date1End, date2Start, date2End) {
    return DH.betweenLesser(date1Start, date2Start, date2End) || DH.betweenLesser(date2Start, date1Start, date1End);
  }
  /**
   * Compare two units. Returns `1` if first param is a greater unit than second param, `-1` if the opposite is true or `0` if they're equal.
   * @param {String} unit1 The 1st unit
   * @param {String} unit2 The 2nd unit
   * @returns {Number} Returns `1` if first param is a greater unit than second param, `-1` if the opposite is true or `0` if they're equal
   * @category Comparison
   */
  static compareUnits(unit1, unit2) {
    return Math.sign(unitMagnitudes[DH.normalizeUnit(unit1)] - unitMagnitudes[DH.normalizeUnit(unit2)]);
  }
  /**
   * Returns `true` if the first time span completely 'covers' the second time span.
   *
   * ```javascript
   * DateHelper.timeSpanContains(
   *     new Date(2010, 1, 2),
   *     new Date(2010, 1, 5),
   *     new Date(2010, 1, 3),
   *     new Date(2010, 1, 4)
   * ) ==> true
   * DateHelper.timeSpanContains(
   *   new Date(2010, 1, 2),
   *   new Date(2010, 1, 5),
   *   new Date(2010, 1, 3),
   *   new Date(2010, 1, 6)
   * ) ==> false
   * ```
   *
   * @param {Date} spanStart The start date for initial time span
   * @param {Date} spanEnd The end date for initial time span
   * @param {Date} otherSpanStart The start date for the 2nd time span
   * @param {Date} otherSpanEnd The end date for the 2nd time span
   * @returns {Boolean} `true` if the first time span completely 'covers' the second time span
   * @category Comparison
   */
  static timeSpanContains(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
    return otherSpanStart - spanStart >= 0 && spanEnd - otherSpanEnd >= 0;
  }
  //endregion
  //region Query
  /**
   * Get the first day of week, 0-6 (Sunday-Saturday).
   * This is determined by the current locale's `DateHelper.weekStartDay` parameter.
   * @property {Number}
   * @readonly
   */
  static get weekStartDay() {
    if (DH._weekStartDay == null) {
      DH._weekStartDay = this.localize("L{weekStartDay}") || 0;
    }
    return DH._weekStartDay;
  }
  /**
   * Get non-working days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
   * This is determined by the current locale's `DateHelper.nonWorkingDays` parameter.
   *
   * For example:
   * ```javascript
   * {
   *     0 : true, // Sunday
   *     6 : true  // Saturday
   * }
   * ```
   *
   * @property {Object<Number,Boolean>}
   * @readonly
   */
  static get nonWorkingDays() {
    return { ...this.localize("L{nonWorkingDays}") };
  }
  /**
   * Get non-working days as an array of day indices, 0-6 (Sunday-Saturday).
   * This is determined by the current locale's `DateHelper.nonWorkingDays` parameter.
   *
   * For example:
   *
   * ```javascript
   * [ 0, 6 ] // Sunday & Saturday
   * ```
   *
   * @property {Number[]}
   * @readonly
   * @internal
   */
  static get nonWorkingDaysAsArray() {
    return Object.keys(this.nonWorkingDays).map(Number);
  }
  /**
   * Get weekend days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
   * Weekends are days which are declared as weekend days by the selected country and defined by the current locale's
   * `DateHelper.weekends` parameter.
   * To get non-working days see {@link #property-nonWorkingDays-static}.
   *
   * For example:
   * ```javascript
   * {
   *     0 : true, // Sunday
   *     6 : true  // Saturday
   * }
   * ```
   * @property {Object<Number,Boolean>}
   * @readonly
   * @internal
   */
  static get weekends() {
    return { ...this.localize("L{weekends}") };
  }
  /**
   * Get the specified part of a date.
   * @param {Date} date
   * @param {String} unit Part of date, hour, minute etc.
   * @returns {Number} The requested part of the specified date
   * @category Query
   */
  static get(date, unit) {
    switch (DH.normalizeUnit(unit)) {
      case "millisecond":
        return date.getMilliseconds();
      case "second":
        return date.getSeconds();
      case "minute":
        return date.getMinutes();
      case "hour":
        return date.getHours();
      case "date":
      case "day":
        return date.getDate();
      case "week":
        return formats.W(date);
      case "month":
        return date.getMonth();
      case "quarter":
        return Math.floor(date.getMonth() / 3) + 1;
      case "year":
        return date.getFullYear();
    }
    return null;
  }
  /**
   * Get number of days in the current year for the supplied date.
   * @param {Date} date Date to check
   * @returns {Number} Days in year
   * @category Query
   * @internal
   */
  static daysInYear(date) {
    const fullYear = date.getFullYear(), duration = new Date(fullYear + 1, 0, 1) - new Date(fullYear, 0, 1);
    return this.as("day", duration);
  }
  /**
   * Get number of days in the current month for the supplied date.
   * @param {Date} date Date which month should be checked
   * @returns {Number} Days in month
   * @category Query
   */
  static daysInMonth(date) {
    return 32 - new Date(date.getFullYear(), date.getMonth(), 32).getDate();
  }
  /**
   * Get number of hours in the current day for the supplied date.
   * @param {Date} date Date to check
   * @returns {Number} Hours in day
   * @category Query
   * @internal
   */
  static hoursInDay(date) {
    const fullYear = date.getFullYear(), month2 = date.getMonth(), day2 = date.getDate(), duration = new Date(fullYear, month2, day2 + 1) - new Date(fullYear, month2, day2);
    return this.as("hour", duration);
  }
  /**
   * Converts unit related to the date to actual amount of milliseconds in it. Takes into account leap years and
   * different duration of months.
   * @param {Date} date Date
   * @param {String} unit Time unit
   * @returns {Number} Returns amount of milliseconds
   * @internal
   */
  static getNormalizedUnitDuration(date, unit) {
    let result;
    switch (unit) {
      case "month":
        result = DH.asMilliseconds(DH.daysInMonth(date), "day");
        break;
      case "year":
        result = DH.asMilliseconds(DH.daysInYear(date), "day");
        break;
      case "day":
        result = DH.asMilliseconds(DH.hoursInDay(date), "hour");
        break;
      default:
        result = DH.asMilliseconds(unit);
    }
    return result;
  }
  /**
   * Get the first date of the month for the supplied date.
   * @param {Date} date Date
   * @returns {Date} New Date instance
   * @category Query
   */
  static getFirstDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1);
  }
  /**
   * Get the last date of the month for the supplied date.
   * @param {Date} date Date
   * @returns {Date} New Date instance
   * @category Query
   */
  static getLastDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0);
  }
  /**
   * Get the earliest of two dates.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Date} Earliest date
   * @category Query
   */
  static min(first, second) {
    return first.getTime() < second.getTime() ? first : second;
  }
  /**
   * Get the latest of two dates.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Date} Latest date
   * @category Query
   */
  static max(first, second) {
    return first.getTime() > second.getTime() ? first : second;
  }
  /**
   * Get an incremented date. Incrementation based on specified unit and optional amount.
   * @param {Date} date Date
   * @param {String} unit Time unit
   * @param {Number} [increment=1] Increment amount
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   * @category Query
   */
  static getNext(date, unit, increment = 1, weekStartDay = DH.weekStartDay) {
    if (unit === "week") {
      const dt = DH.clone(date), day2 = dt.getDay();
      DH.startOf(dt, "day", false);
      DH.add(dt, weekStartDay - day2 + 7 * (increment - (weekStartDay <= day2 ? 0 : 1)), "day", false);
      if (dt.getDay() !== weekStartDay) {
        DH.add(dt, 1, "hour");
      }
      return dt;
    }
    return DH.startOf(DH.add(date, increment, unit), unit, false);
  }
  /**
   * Checks if date object is valid.
   *
   * For example:
   *
   * ```javascript
   * date = new Date('foo')
   * date instanceof Date // true
   * date.toString() // Invalid Date
   * isNaN(date) // true
   * DateHelper.isValidDate(date) // false
   *
   * date = new Date()
   * date instanceof Date // true
   * date.toString() // Mon Jan 13 2020 18:27:38 GMT+0300 (GMT+03:00)
   * isNaN(date) // false
   * DateHelper.isValidDate(date) // true
   * ```
   *
   * @param {Date} date Date
   * @returns {Boolean} `true` if date object is valid
   */
  static isValidDate(date) {
    return DH.isDate(date) && !isNaN(date);
  }
  /**
   * Checks if value is a date object. Allows to recognize date object even from another context,
   * like the top frame when used in an iframe.
   *
   * @param {*} value Value to check
   * @returns {Boolean} `true` if value is a date object
   */
  static isDate(value) {
    return value && toString3.call(value) === DATE_TYPE2;
  }
  /**
   * Get the start of the next day.
   * @param {Date} date Date
   * @param {Boolean} [clone=false] Clone date
   * @param {Boolean} [noNeedToClearTime=false] Flag to not clear time from the result
   * @returns {Date} Passed Date or new Date instance, depending on the `clone` flag
   * @category Query
   */
  static getStartOfNextDay(date, clone = false, noNeedToClearTime = false) {
    let nextDay = DH.add(noNeedToClearTime ? date : DH.clearTime(date, clone), 1, "day");
    if (nextDay.getDate() === date.getDate()) {
      const offsetNextDay = DH.add(DH.clearTime(date, clone), 2, "day").getTimezoneOffset(), offsetDate = date.getTimezoneOffset();
      nextDay = DH.add(nextDay, offsetDate - offsetNextDay, "minute");
    }
    return nextDay;
  }
  /**
   * Get the end of previous day.
   * @param {Date} date Date
   * @param {Boolean} [noNeedToClearTime=false] Flag to not clear time from the result
   * @returns {Date} New Date instance
   * @category Query
   */
  static getEndOfPreviousDay(date, noNeedToClearTime = false) {
    const dateOnly = noNeedToClearTime ? date : DH.clearTime(date, true);
    if (dateOnly - date) {
      return dateOnly;
    } else {
      return DH.add(dateOnly, -1, "day");
    }
  }
  /**
   * Returns a string describing the specified week. For example, `'39, September 2020'` or `'40, Sep - Oct 2020'`.
   * @param {Date} startDate Start date
   * @param {Date} [endDate] End date
   * @returns {String} String describing the specified week
   * @internal
   */
  static getWeekDescription(startDate, endDate = startDate) {
    const monthDesc = startDate.getMonth() === endDate.getMonth() ? _DateHelper.format(startDate, "MMMM") : `${_DateHelper.format(startDate, "MMM")} - ${_DateHelper.format(endDate, "MMM")}`, week = _DateHelper.getWeekNumber(startDate);
    return `${week[1]}, ${monthDesc} ${week[0]}`;
  }
  /**
   * Get week number for the date.
   * @param {Date} date The date
   * @param {Number} [weekStartDay] The first day of week, 0-6 (Sunday-Saturday). Defaults to the {@link #property-weekStartDay-static}
   * @returns {Number[]} year and week number
   * @category Query
   */
  static getWeekNumber(date, weekStartDay = _DateHelper.weekStartDay) {
    const jan01 = new Date(date.getFullYear(), 0, 1), dec31 = new Date(date.getFullYear(), 11, 31), firstDay = normalizeDay(jan01.getDay() - weekStartDay), lastDay = normalizeDay(dec31.getDay() - weekStartDay), dayNumber = getDayDiff(date, jan01);
    let weekNumber;
    if (firstDay < 4) {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7) + 1;
    } else {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7);
    }
    if (weekNumber) {
      let year = date.getFullYear();
      if (weekNumber === 53 && lastDay < 3) {
        year++;
        weekNumber = 1;
      }
      return [year, weekNumber];
    }
    const lastWeekOfLastYear = _DateHelper.getWeekNumber(new Date(date.getFullYear() - 1, 11, 31))[1];
    return [date.getFullYear() - 1, lastWeekOfLastYear];
  }
  //endregion
  //region Unit helpers
  /**
   * Turns `(10, 'day')` into `'10 days'` etc.
   * @param {Number} count Amount of unit
   * @param {String} unit Unit, will be normalized (days, d -> day etc.)
   * @returns {String} Amount formatted to string
   * @category Unit helpers
   */
  static formatCount(count, unit) {
    unit = DH.normalizeUnit(unit);
    if (count !== 1)
      unit += "s";
    return count + " " + unit;
  }
  /**
   * Get the ratio between two units ( year, month -> 1/12 ).
   * @param {String} baseUnit Base time unit
   * @param {String} unit Time unit
   * @param {Boolean} [acceptEstimate=false] If `true`, process negative values of validConversions
   * @returns {Number} Ratio
   * @category Unit helpers
   */
  static getUnitToBaseUnitRatio(baseUnit, unit, acceptEstimate = false) {
    baseUnit = DH.normalizeUnit(baseUnit);
    unit = DH.normalizeUnit(unit);
    if (baseUnit === unit)
      return 1;
    if (validConversions[baseUnit] && validConversions[baseUnit][unit] && (acceptEstimate || validConversions[baseUnit][unit] > 0)) {
      return 1 / DH.as(unit, 1, baseUnit);
    }
    if (validConversions[unit] && validConversions[unit][baseUnit] && (acceptEstimate || validConversions[unit][baseUnit] > 0)) {
      return DH.as(baseUnit, 1, unit);
    }
    return -1;
  }
  /**
   * Returns a localized abbreviated form of the name of the duration unit.
   * For example in the `EN` locale, for `'qrt'` it will return `'q'`.
   * @param {String} unit Duration unit
   * @returns {String} Localized abbreviated form of the name of the duration unit
   * @category Unit helpers
   */
  static getShortNameOfUnit(unit) {
    unit = DH.parseTimeUnit(unit);
    return DH.unitLookup[unit].abbrev;
  }
  /**
   * Returns a localized full name of the duration unit.
   *
   * For example in the `EN` locale, for `'d'` it will return either
   * `'day'` or `'days'`, depending on the `plural` argument
   *
   * Preserves casing of first letter.
   *
   * @static
   * @param {String} unit Time unit
   * @param {Boolean} [plural=false] Whether to return a plural name or singular
   * @returns {String} Localized full name of the duration unit
   * @category Unit helpers
   */
  static getLocalizedNameOfUnit(unit, plural = false) {
    const capitalize = unit.charAt(0) === unit.charAt(0).toUpperCase();
    unit = DH.normalizeUnit(unit);
    unit = DH.parseTimeUnit(unit);
    unit = DH.unitLookup[unit][plural ? "plural" : "single"];
    if (capitalize) {
      unit = StringHelper.capitalize(unit);
    }
    return unit;
  }
  /**
   * Normalizes a unit for easier usage in conditionals. For example `'year'`, `'years'`, `'y'` -> `'year'`.
   * @param {String} unit Time unit
   * @returns {String} Normalized unit name
   * @category Unit helpers
   */
  static normalizeUnit(unit) {
    if (!unit) {
      return null;
    }
    const unitLower = unit.toLowerCase();
    if (unitLower === "date") {
      return unitLower;
    }
    return canonicalUnitNames.includes(unitLower) ? unitLower : normalizedUnits[unit] || normalizedUnits[unitLower];
  }
  static getUnitByName(name) {
    return DH.normalizeUnit(name) || DH.normalizeUnit(DH.parseTimeUnit(name));
  }
  /**
   * Returns a duration of the timeframe in the given unit.
   * @param {Date} start The start date of the timeframe
   * @param {Date} end The end date of the timeframe
   * @param {String} unit Duration unit
   * @privateparam {Boolean} [doNotRound]
   * @returns {Number} The duration in the units
   * @category Unit helpers
   * @ignore
   */
  static getDurationInUnit(start, end, unit, doNotRound) {
    return DH.diff(start, end, unit, doNotRound);
  }
  /**
   * Checks if two date units align.
   * @private
   * @param {String} majorUnit Major time unit
   * @param {String} minorUnit Minor time unit
   * @returns {Boolean} `true` if two date units align
   * @category Unit helpers
   */
  static doesUnitsAlign(majorUnit, minorUnit) {
    return !(majorUnit !== minorUnit && minorUnit === "week");
  }
  static getSmallerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH.normalizeUnit(unit)] - 1] || null;
  }
  static getLargerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH.normalizeUnit(unit)] + 1] || null;
  }
  /**
   *
   * Rounds the passed Date value to the nearest `increment` value.
   *
   * Optionally may round relative to a certain base time point.
   *
   * For example `DH.round(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would round to 9:45 because that's the nearest integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when rounding to weeks. The configured {@link #property-weekStartDay-static}
   * dictates what the base of a week is.
   *
   * @param {Date} time The time to round
   * @param {String|Number} increment A millisecond value by which to round the time
   * May be specified in string form eg: `'15 minutes'`
   * @param {Date} [base] The start from which to apply the rounding
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static round(time, increment, base, weekStartDay) {
    return DH.snap("round", time, increment, base, weekStartDay);
  }
  /**
   *
   * Floor the passed Date value to the nearest `increment` value.
   *
   * Optionally may floor relative to a certain base time point.
   *
   * For example `DH.floor(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would floor to 9:15 because that's the closest lower integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when flooring to weeks. The configured {@link #property-weekStartDay-static}
   * dictates what the base of a week is.
   *
   * @param {Date} time The time to floor
   * @param {String|Number|DurationConfig|Object} increment A numeric millisecond value by which to floor the time.
   * or a duration in string form eg `'30 min'` or object form : `{unit: 'minute', magnitude: 30}`
   * or `{unit: 'minute', increment: 30}`
   * @param {Date} [base] The start from which to apply the flooring
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static floor(time, increment, base, weekStartDay) {
    return DH.snap("floor", time, increment, base, weekStartDay);
  }
  /**
   *
   * Ceils the passed Date value to the nearest `increment` value.
   *
   * Optionally may ceil relative to a certain base time point.
   *
   * For example `DH.ceil(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would ceil to 9:45 because that's the closest higher integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when ceiling to weeks. Use weekStartDay argument which default to the configured
   * {@link #property-weekStartDay-static} dictates what the base of a week is
   *
   * @param {Date} time The time to ceil
   * @param {String|Number|DurationConfig|Object} increment A numeric millisecond value by which to ceil the time
   * or a duration in string form eg `'30 min'` or object form : `{unit: 'minute', magnitude: 30}`
   * or `{unit: 'minute', increment: 30}`
   * @param {Date} [base] The start from which to apply the ceiling
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static ceil(time, increment, base, weekStartDay) {
    return DH.snap("ceil", time, increment, base, weekStartDay);
  }
  /**
   * Implementation for round, floor and ceil.
   * @internal
   */
  static snap(operation, time, increment, base, weekStartDay = DH.weekStartDay) {
    const snapFn = snapFns[operation];
    if (typeof increment === "string") {
      increment = DH.parseDuration(increment);
    }
    if (Objects.isObject(increment)) {
      const magnitude = increment.magnitude || increment.increment;
      switch (increment.unit) {
        case "week": {
          if (!base) {
            const weekDay = time.getDay();
            base = DH.add(
              DH.clearTime(time),
              weekDay >= weekStartDay ? weekStartDay - weekDay : -(weekDay - weekStartDay + 7),
              "day"
            );
          }
          return DH[operation](time, `${magnitude * 7} days`, base);
        }
        case "month": {
          time = DH.asMonths(time);
          let resultMonths;
          if (base) {
            base = DH.asMonths(base);
            resultMonths = base + snapFn(time - base, magnitude);
          } else {
            resultMonths = snapFn(time, magnitude);
          }
          return DH.monthsToDate(resultMonths);
        }
        case "quarter":
          return DH[operation](time, `${magnitude * 3} months`, base);
        case "year":
          return DH[operation](time, `${magnitude * 12} months`, base);
        case "decade":
          return DH[operation](time, `${magnitude * 10} years`, base);
      }
      increment = DH.as("ms", magnitude, increment.unit);
    }
    const timeUtcOffset = time.getTimezoneOffset() * 1e3 * 60;
    if (base) {
      const baseUtcOffset = base.getTimezoneOffset() * 1e3 * 60, diff = time - base + baseUtcOffset - timeUtcOffset, snappedDate = new Date(base.getTime() + snapFn(diff, increment)), dstChange = baseUtcOffset - snappedDate.getTimezoneOffset() * 1e3 * 60;
      if (dstChange) {
        DH.add(snappedDate, -dstChange, "ms", false);
      }
      return new Date(snappedDate);
    } else {
      return new Date(snapFn(time.valueOf() - timeUtcOffset, increment) + timeUtcOffset);
    }
  }
  //endregion
  //region Date picker format
  /**
   * Parses a typed duration value according to locale rules.
   *
   * The value is taken to be a string consisting of the numeric magnitude and the units:
   * - The numeric magnitude can be either an integer or a float value. Both `','` and `'.'` are valid decimal separators.
   * - The units may be a recognised unit abbreviation of this locale or the full local unit name.
   *
   * For example:
   * `'2d'`, `'2 d'`, `'2 day'`, `'2 days'` will be turned into `{ magnitude : 2, unit : 'day' }`
   * `'2.5d'`, `'2,5 d'`, `'2.5 day'`, `'2,5 days'` will be turned into `{ magnitude : 2.5, unit : 'day' }`
   *
   * **NOTE:** Doesn't work with complex values like `'2 days, 2 hours'`
   *
   * @param {String} value The value to parse
   * @param {Boolean} [allowDecimals=true] Decimals are allowed in the magnitude
   * @param {String} [defaultUnit] Default unit to use if only magnitude passed
   * @returns {DurationConfig} If successfully parsed, the result contains two properties, `magnitude` being a number, and
   * `unit` being the canonical unit name, *NOT* a localized name. If parsing was unsuccessful, `null` is returned
   * @category Parse & format
   */
  static parseDuration(value, allowDecimals = true, defaultUnit) {
    var _a2;
    const durationRegEx = allowDecimals ? withDecimalsDurationRegex : noDecimalsDurationRegex, match = durationRegEx.exec(value);
    if (value == null || !match) {
      return null;
    }
    const magnitude = parseNumber((_a2 = match[1]) == null ? void 0 : _a2.replace(",", ".")), unit = DH.parseTimeUnit(match[2]) || defaultUnit;
    if (!unit) {
      return null;
    }
    return {
      magnitude,
      unit
    };
  }
  /**
   * Parses a typed unit name, for example `'ms'` or `'hr'` or `'yr'` into the
   * canonical form of the unit name which may be passed to {@link #function-add-static}
   * or {@link #function-diff-static}.
   * @param {*} unitName Time unit name
   * @category Parse & format
   */
  static parseTimeUnit(unitName) {
    const unitMatch = unitName == null ? null : DH.durationRegEx.exec(unitName.toLowerCase());
    if (!unitMatch) {
      return null;
    }
    for (let unitOrdinal = 0; unitOrdinal < canonicalUnitNames.length; unitOrdinal++) {
      if (unitMatch[unitOrdinal + 1]) {
        return canonicalUnitNames[unitOrdinal];
      }
    }
  }
  //endregion
  //region Internal
  static getGMTOffset(date = /* @__PURE__ */ new Date()) {
    if (!date) {
      return;
    }
    const offsetInMinutes = date.getTimezoneOffset();
    if (!offsetInMinutes)
      return "Z";
    return (offsetInMinutes > 0 ? "-" : "+") + Math.abs(Math.trunc(offsetInMinutes / 60)).toString().padStart(2, "0") + ":" + Math.abs(offsetInMinutes % 60).toString().padStart(2, "0");
  }
  static fillDayNames() {
    const tempDate2 = /* @__PURE__ */ new Date("2000-01-01T12:00:00"), dayNames = DH._dayNames || [], dayShortNames = DH._dayShortNames || [];
    dayNames.length = 0;
    dayShortNames.length = 0;
    for (let day2 = 2; day2 < 9; day2++) {
      tempDate2.setDate(day2);
      dayNames.push(DH.format(tempDate2, "dddd"));
      dayShortNames.push(DH.format(tempDate2, "ddd"));
    }
    DH._dayNames = dayNames;
    DH._dayShortNames = dayShortNames;
  }
  static getDayNames() {
    return DH._dayNames;
  }
  static getDayName(day2) {
    return DH._dayNames[day2];
  }
  static getDayShortNames() {
    return DH._dayShortNames;
  }
  static getDayShortName(day2) {
    return DH._dayShortNames[day2];
  }
  static fillMonthNames() {
    const tempDate2 = /* @__PURE__ */ new Date("2000-01-15T12:00:00"), monthNames = DH._monthNames || [], monthShortNames = DH._monthShortNames || [], monthNamesIndex = {}, monthShortNamesIndex = {};
    monthNames.length = 0;
    monthShortNames.length = 0;
    for (let month2 = 0; month2 < 12; month2++) {
      tempDate2.setMonth(month2);
      const monthName = DH.format(tempDate2, "MMMM");
      monthNames.push(monthName);
      const monthShortName = DH.format(tempDate2, "MMM");
      monthShortNames.push(monthShortName);
      monthNamesIndex[monthName.toLowerCase()] = { name: monthName, value: month2 };
      monthShortNamesIndex[monthShortName.toLowerCase()] = { name: monthShortName, value: month2 };
    }
    DH._monthNames = monthNames;
    DH._monthShortNames = monthShortNames;
    DH._monthNamesIndex = monthNamesIndex;
    DH._monthShortNamesIndex = monthShortNamesIndex;
  }
  static getMonthShortNames() {
    return DH._monthShortNames;
  }
  static getMonthShortName(month2) {
    return DH._monthShortNames[month2];
  }
  static getMonthNames() {
    return DH._monthNames;
  }
  static getMonthName(month2) {
    return DH._monthNames[month2];
  }
  static set locale(name) {
    locale2 = name;
    intlFormatterCache = {};
    formatCache = {};
    formatRedirects = {};
  }
  static get locale() {
    return locale2;
  }
  static setupDurationRegEx(unitNames = [], unitAbbreviations = []) {
    const me = this, unitLookup = {};
    let unitAbbrRegEx = "";
    for (let i = 0; i < unitAbbreviations.length; i++) {
      const abbreviations = unitAbbreviations[i], unitNamesCfg = unitNames[i];
      unitNamesCfg.canonicalUnitName = canonicalUnitNames[i];
      unitLookup[unitNamesCfg.single] = unitLookup[unitNamesCfg.single.toUpperCase()] = unitLookup[unitNamesCfg.canonicalUnitName] = unitLookup[unitNamesCfg.canonicalUnitName.toUpperCase()] = unitNamesCfg;
      unitAbbrRegEx += `${i ? "|" : ""}(`;
      for (let j = 0; j < abbreviations.length; j++) {
        unitAbbrRegEx += `${abbreviations[j]}|`;
      }
      locale2 = me.localize("L{locale}") || "en-US";
      if (locale2 !== "en-US") {
        const canonicalAbbreviations = canonicalUnitAbbreviations[i];
        for (let j = 0; j < canonicalAbbreviations.length; j++) {
          unitAbbrRegEx += `${canonicalAbbreviations[j]}|`;
        }
      }
      unitAbbrRegEx += `${unitNamesCfg.single}|${unitNamesCfg.plural}|${unitNamesCfg.canonicalUnitName}|${unitNamesCfg.canonicalUnitName}s)`;
    }
    me.unitLookup = unitLookup;
    me.durationRegEx = new RegExp(`^(?:${unitAbbrRegEx})$`);
  }
  static applyLocale() {
    const me = this, unitAbbreviations = me.localize("L{unitAbbreviations}") || [], unitNames = me.unitNames = me.localize("L{unitNames}");
    if (unitNames === "unitNames") {
      return;
    }
    locale2 = me.localize("L{locale}") || "en-US";
    if (locale2 === "en-US") {
      ordinalSuffix = enOrdinalSuffix;
    } else {
      ordinalSuffix = me.localize("L{ordinalSuffix}") || ordinalSuffix;
    }
    formatCache = {};
    formatRedirects = {};
    parserCache = {};
    intlFormatterCache = {};
    DH._weekStartDay = null;
    DH.setupDurationRegEx(unitNames, unitAbbreviations);
    DH.fillDayNames();
    DH.fillMonthNames();
  }
  //endregion
};
__publicField(_DateHelper, "MS_PER_DAY", MS_PER_HOUR * 24);
var DateHelper = _DateHelper;
var DH = DateHelper;
DH.useIntlFormat = useIntlFormat;
LocaleManager_default.ion({
  locale: "applyLocale",
  prio: 1e3,
  thisObj: DH
});
if (LocaleManager_default.locale) {
  DH.applyLocale();
}
DateHelper._$name = "DateHelper";

// ../Core/lib/Core/helper/ObjectHelper.js
var { hasOwn: hasOwn2 } = Objects;
var toFixedFix = 1.005.toFixed(2) === "1.01" ? null : function(number, fractionDigits) {
  const split = number.toString().split("."), newNumber = +(!split[1] ? split[0] : split.join(".") + "1");
  return number.toFixed.call(newNumber, fractionDigits);
};
var ObjectHelper = class _ObjectHelper extends Objects {
  // These methods are inherited from Objects (an internal class) but need to be documented here for public use.
  // This is primarily because static methods, while inherited by JavaScript classes, are not displayed in derived
  // classes in the docs.
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`. Unlike `Object.assign`, this copy
   * also includes inherited properties.
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method assign
   * @static
   */
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`, only including properties that does
   * not already exist on `dest`. Unlike `Object.assign`, this copy also includes inherited properties.
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method assignIf
   * @static
   */
  /**
   * Creates a deep copy of the `value`. Simple objects ({@link #function-isObject-static}, arrays and `Date` objects
   * are cloned. The enumerable properties of simple objects and the elements of arrays are cloned recursively.
   * @param {*} value The value to clone.
   * @param {Function} [handler] An optional function to call for values of types other than simple object, array or
   * `Date`. This function should return the clone of the `value` passed to it. It is only called for truthy values
   * whose `typeof` equals `'object'`.
   * @param {*} handler.value The value to clone.
   * @returns {*} The cloned value.
   * @method clone
   * @static
   */
  /**
   * Converts a list of names (either a space separated string or an array), into an object with those properties
   * assigned truthy values. The converse of {@link #function-getTruthyKeys-static}.
   * @param {String|String[]} source The list of names to convert to object form.
   * @method createTruthyKeys
   * @static
   */
  /**
   * Gathers the names of properties which have truthy values into an array.
   *
   * This is useful when gathering CSS class names for complex element production.
   * Instead of appending to an array or string which may already contain the
   * name, and instead of contending with space separation and concatenation
   * and conditional execution, just set the properties of an object:
   *
   *     cls = {
   *         [this.selectedCls] : this.isSelected(thing),
   *         [this.dirtyCls] : this.isDirty(thing)
   *     };
   *
   * @param {Object} source Source of keys to gather into an array.
   * @returns {String[]} The keys which had a truthy value.
   * @method getTruthyKeys
   * @static
   */
  /**
   * Gathers the values of properties which are truthy into an array.
   * @param {Object} source Source of values to gather into an array.
   * @returns {String[]} The truthy values from the passed object.
   * @method getTruthyValues
   * @static
   */
  /**
   * Tests whether a passed object has any enumerable properties.
   * @param {Object} object
   * @returns {Boolean} `true` if the passed object has no enumerable properties.
   * @method isEmpty
   * @static
   */
  /**
   * Returns `true` if the `value` is a simple `Object`.
   * @param {Object} value
   * @returns {Boolean} `true` if the `value` is a simple `Object`.
   * @method isObject
   * @static
   */
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`, recursing when the properties of
   * both the source and `dest` are objects.
   * ```
   *  const o = {
   *      a : 1,
   *      b : {
   *          c : 2
   *      }
   *  };
   *  const o2 = {
   *      b : {
   *          d : 3
   *      }
   *  }
   *
   *  console.log(merge(o, o2));
   *
   *  > { a : 1, b : { c : 2, d : 3 } }
   * ```
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method merge
   * @static
   */
  /**
   * Returns the specific type of the given `value`. Unlike the `typeof` operator, this function returns the text
   * from the `Object.prototype.toString` result allowing `Date`, `Array`, `RegExp`, and others to be differentiated.
   * ```
   *  console.log(typeOf(null));
   *  > null
   *
   *  console.log(typeOf({}));
   *  > object
   *
   *  console.log(typeOf([]));
   *  > array
   *
   *  console.log(typeOf(new Date()));
   *  > date
   *
   *  console.log(typeOf(NaN));
   *  > nan
   *
   *  console.log(typeOf(/a/));
   *  > regexp
   * ```
   * @param {*} value
   * @returns {String}
   * @method typeOf
   * @static
   */
  /**
   * Returns value for a given path in the object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {*} Value associated with passed key
   * @method getPath
   * @static
   */
  /**
   * Sets value for a given path in the object
   * @param {Object} object Target object
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @param {*} value Value for a given path
   * @returns {Object} Returns passed object
   * @method setPath
   * @static
   */
  /**
   * Creates a new object where key is a property in array item (`ref` by default) or index in the array and value is array item.
   *
   * From:
   * ```
   * [
   *     {
   *          text : 'foo',
   *          ref : 'fooItem'
   *     },
   *     {
   *          text : 'bar'
   *     }
   * ]
   * ```
   *
   * To:
   * ```
   * {
   *     fooItem : {
   *         text : 'foo',
   *         ref  : 'fooItem'
   *     },
   *     1 : {
   *         text : 'bar'
   *     }
   * }
   * ```
   *
   * @param {Object[]} arrayOfItems Array to transform.
   * @param {String} [prop] Property to read the key from. `ref` by default.
   * @returns {Object} namedItems
   */
  static transformArrayToNamedObject(arrayOfItems, prop = "ref") {
    const namedItems = {};
    arrayOfItems.forEach((item, index) => {
      const key = item[prop] != null && item[prop].toString().length ? item[prop] : index;
      namedItems[key] = item;
    });
    return namedItems;
  }
  /**
   * Creates a new array from object values and saves key in a property (`ref` by default) of each item.
   *
   * From:
   * ```
   * {
   *     fooItem : {
   *         text : 'foo'
   *     },
   *     1 : {
   *         text : 'bar'
   *     },
   *     barItem : false // will be ignored
   * }
   * ```
   *
   * To:
   * ```
   * [
   *     {
   *          text : 'foo',
   *          ref : 'fooItem'
   *     },
   *     {
   *          text : 'bar',
   *          ref : 1
   *     }
   * ]
   * ```
   *
   * @param {Object} namedItems Object to transform.
   * @param {String} [prop] Property to save the key to. `ref` by default.
   * @returns {Object[]} arrayOfItems
   */
  static transformNamedObjectToArray(namedItems, prop = "ref") {
    return Object.keys(namedItems).filter((key) => namedItems[key]).map((key) => {
      const item = namedItems[key];
      item[prop] = key;
      return item;
    });
  }
  /**
   * Checks if two values are equal. Basically === but special handling of dates.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {*} true if values are equal, otherwise false
   */
  static isEqual(a, b, useIsDeeply = false) {
    if (a === null && b !== null || a === void 0 && b !== void 0 || b === null && a !== null || b === void 0 && a !== void 0) {
      return false;
    }
    if (a == null && b == null) {
      return true;
    }
    if (a === b) {
      return true;
    }
    const typeA = typeof a, typeB = typeof b;
    if (typeA === typeB) {
      switch (typeA) {
        case "number":
        case "string":
        case "boolean":
          return a === b;
      }
      switch (true) {
        case (a instanceof Date && b instanceof Date):
          return a.getTime() === b.getTime();
        case (Array.isArray(a) && Array.isArray(b)):
          return a.length === b.length ? a.every((v, idx) => OH.isEqual(v, b[idx], useIsDeeply)) : false;
        case (typeA === "object" && a.constructor.prototype === b.constructor.prototype):
          return useIsDeeply ? OH.isDeeplyEqual(a, b, useIsDeeply) : StringHelper.safeJsonStringify(a, "circular") === StringHelper.safeJsonStringify(b, "circular");
      }
    }
    return String(a) === String(b);
  }
  /**
   * Checks if two objects are deeply equal
   * @param {Object} a
   * @param {Object} b
   * @param {Object} [options] Additional comparison options
   * @param {Object} [options.ignore] Map of property names to ignore when comparing
   * @param {Function} [options.shouldEvaluate] Function used to evaluate if a property should be compared or not.
   * Return false to prevent comparison
   * @param {Function} [options.evaluate] Function used to evaluate equality. Return `true`/`false` as evaluation
   * result or anything else to let `isEqual` handle the comparison
   * @returns {Boolean}
   */
  static isDeeplyEqual(a, b, options = {}) {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    const aKeys = OH.keys(a, options.ignore), bKeys = OH.keys(b, options.ignore);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (let i = 0; i < aKeys.length; i++) {
      const aKey = aKeys[i], bKey = bKeys[i];
      if (aKey !== bKey) {
        return false;
      }
      const aVal = a[aKey], bVal = b[bKey];
      if (options.shouldEvaluate) {
        if (options.shouldEvaluate(
          aKey,
          {
            value: aVal,
            object: a
          },
          {
            value: bVal,
            object: b
          }
        ) === false) {
          continue;
        }
      }
      if (options.evaluate) {
        const result = options.evaluate(aKey, {
          value: aVal,
          object: a
        }, {
          value: bVal,
          object: b
        });
        if (result === false) {
          return false;
        }
        if (result === true) {
          continue;
        }
      }
      if (!OH.isEqual(aVal, bVal, options)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks if value B is partially equal to value A.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if values are partially equal, false otherwise
   */
  static isPartial(a, b) {
    a = String(a).toLowerCase();
    b = String(b).toLowerCase();
    return a.indexOf(b) !== -1;
  }
  /**
   * Checks if value a is smaller than value b.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if a < b
   */
  static isLessThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isBefore(a, b);
    }
    return a < b;
  }
  /**
   * Checks if value a is bigger than value b.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if a > b
   */
  static isMoreThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isAfter(a, b);
    }
    return a > b;
  }
  /**
   * Used by the Base class to make deep copies of defaultConfig blocks
   * @private
   */
  static fork(obj) {
    let ret, key, value;
    if (obj && obj.constructor === Object) {
      ret = Object.setPrototypeOf({}, obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (value.constructor === Object) {
            ret[key] = OH.fork(value);
          } else if (value instanceof Array) {
            ret[key] = value.slice();
          }
        }
      }
    } else {
      ret = obj;
    }
    return ret;
  }
  /**
   * Copies the named properties from the `source` parameter into the `dest` parameter.
   * @param {Object} dest The destination into which properties are copied.
   * @param {Object} source The source from which properties are copied.
   * @param {String[]} props The list of property names.
   * @returns {Object} The `dest` object.
   */
  static copyProperties(dest, source, props) {
    let prop, i;
    for (i = 0; i < props.length; i++) {
      prop = props[i];
      if (prop in source) {
        dest[prop] = source[prop];
      }
    }
    return dest;
  }
  /**
   * Copies the named properties from the `source` parameter into the `dest` parameter
   * unless the property already exists in the `dest`.
   * @param {Object} dest The destination into which properties are copied.
   * @param {Object} source The source from which properties are copied.
   * @param {String[]} props The list of property names.
   * @returns {Object} The `dest` object.
   */
  static copyPropertiesIf(dest, source, props) {
    if (source) {
      for (const prop of props) {
        if (!(prop in dest) && prop in source) {
          dest[prop] = source[prop];
        }
      }
    }
    return dest;
  }
  /**
   * Returns an array containing the keys and values of all enumerable properties from every prototype level for the
   * object. If `object` is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve entries.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @returns {Array}
   * @internal
   */
  static entries(object, ignore) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore == null ? void 0 : ignore[p])) {
          result.push([p, object[p]]);
        }
      }
    }
    return result;
  }
  /**
   * Populates an `object` with the provided `entries`.
   * @param {Array} entries The key/value pairs (2-element arrays).
   * @param {Object} [object={}] The object onto which to add `entries`.
   * @returns {Object} The passed `object` (by default, a newly created object).
   * @internal
   */
  static fromEntries(entries, object) {
    object = object || {};
    if (entries) {
      for (let i = 0; i < entries.length; ++i) {
        object[entries[i][0]] = entries[i][1];
      }
    }
    return object;
  }
  /**
   * Returns an array containing all enumerable property names from every prototype level for the object. If `object`
   * is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve property names.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @param {Function} [mapper] Optional function to call for each non-ignored item. If provided, the result of this
   * function is stored in the returned array. It is called with the array element as the first parameter, and the
   * index in the result array as the second argument (0 for the first, non-ignored element, 1 for the second and so
   * on).
   * @returns {String[]}
   */
  static keys(object, ignore, mapper) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore == null ? void 0 : ignore[p])) {
          result.push(mapper ? mapper(p, index) : p);
          ++index;
        }
      }
    }
    return result;
  }
  /**
   * Returns an array containing the values of all enumerable properties from every prototype level for the object.
   * If `object` is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve values.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @param {Function} [mapper] Optional function to call for each non-ignored item. If provided, the result of this
   * function is stored in the returned array. It is called with the array element as the first parameter, and the
   * index in the result array as the second argument (0 for the first, non-ignored element, 1 for the second and so
   * on).
   * @returns {Array}
   * @internal
   */
  static values(object, ignore, mapper) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore == null ? void 0 : ignore[p])) {
          result.push(mapper ? mapper(object[p], index) : object[p]);
          ++index;
        }
      }
    }
    return result;
  }
  //region Path
  /**
   * Checks if a given path exists in an object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {Boolean} Returns `true` if path exists or `false` if it does not
   */
  static pathExists(object, path) {
    const properties = path.split(".");
    return properties.every((property) => {
      if (!object || !(property in object)) {
        return false;
      }
      object = object[property];
      return true;
    });
  }
  /**
   * Creates a simple single level key-value object from complex deep object.
   * @param {Object} object Object to extract path and values from
   * @returns {Object} Key-value object where key is a path to the corresponding value
   * @internal
   *
   * ```javascript
   * // converts deep object
   * {
   *     foo : {
   *         bar : {
   *             test : 1
   *         }
   *     }
   * }
   * // into a single level object
   * {
   *     'foo.bar.test' : 1
   * }
   * ```
   */
  static pathifyKeys(object, fieldDataSourceMap) {
    const result = {};
    for (const key in object) {
      if (hasOwn2(object, key)) {
        const field = fieldDataSourceMap == null ? void 0 : fieldDataSourceMap[key];
        const usesPathKeys = (field == null ? void 0 : field.type) === "object" || (field == null ? void 0 : field.complexMapping) || !Boolean(fieldDataSourceMap);
        if (usesPathKeys && Array.isArray(object[key])) {
          result[key] = object[key].slice();
        } else if (usesPathKeys && object[key] instanceof Object) {
          const paths = this.pathifyKeys(object[key]);
          for (const path in paths) {
            result[`${key}.${path}`] = paths[path];
          }
        } else {
          result[key] = object[key];
        }
      }
    }
    return result;
  }
  /**
   * Removes value for a given path in the object. Doesn't cleanup empty objects.
   * @param {Object} object
   * @param {String} path Dot-separated path, e.g. `obj.child.someKey`
   * @internal
   */
  static deletePath(object, path) {
    path.split(".").reduce((result, key, index, array) => {
      if (result == null) {
        return null;
      }
      if (hasOwn2(result, key)) {
        if (index === array.length - 1) {
          delete result[key];
        } else {
          return result[key];
        }
      }
    }, object);
  }
  //endregion
  static coerce(from, to) {
    const fromType = Objects.typeOf(from), toType = Objects.typeOf(to), isString = typeof from === "string";
    if (fromType !== toType) {
      switch (toType) {
        case "string":
          return String(from);
        case "number":
          return Number(from);
        case "boolean":
          return isString && (!from || from === "false" || from === "0") ? false : Boolean(from);
        case "null":
          return isString && (!from || from === "null") ? null : false;
        case "undefined":
          return isString && (!from || from === "undefined") ? void 0 : false;
        case "date":
          return isString && isNaN(from) ? DateHelper.parse(from) : Date(Number(from));
      }
    }
    return from;
  }
  static wrapProperty(object, propertyName, newGetter, newSetter, deep = true) {
    const newProperty = {};
    let proto3 = Object.getPrototypeOf(object), existingProperty = Object.getOwnPropertyDescriptor(proto3, propertyName);
    while (!existingProperty && proto3 && deep) {
      proto3 = Object.getPrototypeOf(proto3);
      if (proto3) {
        existingProperty = Object.getOwnPropertyDescriptor(proto3, propertyName);
      }
    }
    if (existingProperty) {
      if (existingProperty.set) {
        newProperty.set = (v) => {
          existingProperty.set.call(object, v);
          newSetter && newSetter.call(object, existingProperty.get.call(object));
        };
      } else {
        newProperty.set = newSetter;
      }
      if (existingProperty.get) {
        newProperty.get = () => {
          let result = existingProperty.get.call(object);
          if (newGetter) {
            result = newGetter.call(object, result);
          }
          return result;
        };
      } else {
        newProperty.get = newGetter;
      }
    } else {
      newProperty.set = (v) => {
        object[`_${propertyName}`] = v;
        newSetter && newSetter.call(object, v);
      };
      newProperty.get = () => {
        let result = object[`_${propertyName}`];
        if (newGetter) {
          result = newGetter.call(object, result);
        }
        return result;
      };
    }
    Object.defineProperty(object, propertyName, newProperty);
  }
  /**
   * Intercepts access to a `property` of a given `object`.
   *
   * ```javascript
   *      ObjectHelper.hookProperty(object, 'prop', class {
   *          get value() {
   *              return super.value;
   *          }
   *          set value(v) {
   *              super.value = v;
   *          }
   *      });
   * ```
   * The use of `super` allows the hook's getter and setter to invoke the object's existing get/set.
   *
   * @param {Object} object
   * @param {String} property
   * @param {Function} hook A `class` defining a `value` property getter and/or setter.
   * @returns {Function} A function that removes the hook when called.
   * @internal
   */
  static hookProperty(object, property, hook) {
    const desc = _ObjectHelper.getPropertyDescriptor(hook.prototype, "value"), existingDesc = _ObjectHelper.getPropertyDescriptor(object, property), fieldName = `_${property}`, base = class {
      get value() {
        return existingDesc ? existingDesc.get.call(this) : this[fieldName];
      }
      set value(v) {
        if (existingDesc) {
          existingDesc.set.call(this, v);
        } else {
          this[fieldName] = v;
        }
      }
    }, baseDesc = _ObjectHelper.getPropertyDescriptor(base.prototype, "value");
    Object.setPrototypeOf(hook.prototype, base.prototype);
    Object.defineProperty(object, property, {
      configurable: true,
      get: desc.get || baseDesc.get,
      set: desc.set || baseDesc.set
    });
    return () => delete object[property];
  }
  /**
   * Finds a property descriptor for the passed object from all inheritance levels.
   * @param {Object} object The Object whose property to find.
   * @param {String} propertyName The name of the property to find.
   * @returns {Object} An ECMA property descriptor is the property was found, otherwise `null`
   */
  static getPropertyDescriptor(object, propertyName) {
    let result = null;
    for (let o = object; o && !result && !hasOwn2(o, "isBase"); o = Object.getPrototypeOf(o)) {
      result = Object.getOwnPropertyDescriptor(o, propertyName);
    }
    return result;
  }
  /**
   * Changes the passed object and removes all null and undefined properties from it
   * @param {Object} object Target object
   * @param {Boolean} [keepNull] Pass true to only remove undefined properties
   * @returns {Object} Passed object
   */
  static cleanupProperties(object, keepNull = false) {
    Object.entries(object).forEach(([key, value]) => {
      if (keepNull) {
        value === void 0 && delete object[key];
      } else {
        value == null && delete object[key];
      }
    });
    return object;
  }
  /**
   * Changes the passed object and removes all properties from it.
   * Used while mutating when need to keep reference to the object but replace its properties.
   * @param {Object} object Target object
   * @returns {Object} Passed object
   */
  static removeAllProperties(obj) {
    Object.keys(obj).forEach((key) => delete obj[key]);
    return obj;
  }
  //region Assert type
  /**
   * Checks that the supplied value is of the specified type.Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} type Expected type
   * @param {String} name Name of the value, used in error message
   * @param {Boolean} [allowNull] Accept `null` without throwing
   */
  static assertType(value, type, name) {
    const valueType = Objects.typeOf(value);
    if (value != null && valueType !== type) {
      throw new Error(`Incorrect type "${valueType}" for ${name}, expected "${type}"`);
    }
  }
  /**
   * Checks that the supplied value is a plain object. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertObject(value, name) {
    OH.assertType(value, "object", name);
  }
  /**
   * Checks that the supplied value is an instance of a Bryntum class. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertInstance(value, name) {
    OH.assertType(value, "instance", name);
  }
  /**
   * Checks that the supplied value is a Bryntum class. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertClass(value, name) {
    OH.assertType(value, "class", name);
  }
  /**
   * Checks that the supplied value is a function. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertFunction(value, name) {
    if (typeof value !== "function" || value.isBase || value.$$name) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a function)`);
    }
  }
  /**
   * Checks that the supplied value is a number. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertNumber(value, name) {
    const asNumber = Number(value);
    if (typeof value !== "number" || isNaN(asNumber)) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a Number)`);
    }
  }
  /**
   * Checks that the supplied value is a boolean. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertBoolean(value, name) {
    OH.assertType(value, "boolean", name);
  }
  /**
   * Checks that the supplied value is a string. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertString(value, name) {
    OH.assertType(value, "string", name);
  }
  /**
   * Checks that the supplied value is an array. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertArray(value, name) {
    OH.assertType(value, "array", name);
  }
  //endregion
  /**
   * Number.toFixed(), with polyfill for browsers that needs it
   * @param {Number} number
   * @param {Number} digits
   * @returns {String} A fixed point string representation of the passed number.
   */
  static toFixed(number, digits) {
    if (toFixedFix) {
      return toFixedFix(number, digits);
    }
    return number.toFixed(digits);
  }
  /**
   * Round the passed number to closest passed step value.
   * @param {Number} number The number to round.
   * @param {Number} [step] The step value to round to.
   * @returns {Number} The number rounded to the closest step.
   */
  static roundTo(number, step = 1) {
    return Math.round(number / step) * step;
  }
  /**
   * Round the passed number to the passed number of decimals.
   * @param {Number} number The number to round.
   * @param {Number} digits The number of decimal places to round to.
   * @returns {Number} The number rounded to the passed number of decimal places.
   */
  static round(number, digits) {
    if (digits == null) {
      return number;
    }
    const factor = 10 ** digits;
    return Math.round(number * factor) / factor;
  }
  /**
   * Returns a non-null entry from a Map for a given key path. This enables a specified defaultValue to be added "just
   * in time" which is returned if the key is not already present.
   * @param {Map} map The Map to find the key in (and potentially add to).
   * @param {String|Number|String[]|Number[]} path Dot-separated path, e.g. 'firstChild.childObject.someKey',
   * or the key path as an array, e.g. ['firstChild', 'childObject', 'someKey'].
   * @param {Object} [defaultValue] Optionally the value to insert if the key is not found.
   */
  static getMapPath(map, path, defaultValue2) {
    const keyPath = Array.isArray(path) ? path : typeof path === "string" ? path.split(".") : [path], simpleKey = keyPath.length === 1, topKey = keyPath[0], topValue = map.has(topKey) ? map.get(topKey) : map.set(topKey, simpleKey ? defaultValue2 : {}).get(topKey);
    if (simpleKey) {
      return topValue;
    }
    return OH.getPathDefault(topValue, keyPath.slice(1), defaultValue2);
  }
};
var OH = ObjectHelper;
ObjectHelper._$name = "ObjectHelper";

// ../Core/lib/Core/helper/util/DomClassList.js
var valueSymbol = Symbol("value");
var lengthSymbol = Symbol("length");
var DomClassList = class _DomClassList {
  static change(cls, add, remove, as = "string") {
    remove = _DomClassList.normalize(remove, "object");
    const after = _DomClassList.normalize(cls, "array").filter((c) => !remove[c]);
    if (add) {
      add = _DomClassList.normalize(add, "array");
      for (let i = 0; i < add.length; ++i) {
        if (!after.includes(add[i])) {
          after.push(add[i]);
        }
      }
    }
    return _DomClassList.normalize(after, as);
  }
  static from(classes, returnEmpty) {
    if (classes) {
      if (classes.isDomClassList) {
        returnEmpty = returnEmpty != null ? returnEmpty : true;
      } else {
        returnEmpty = returnEmpty != null ? returnEmpty : Objects.isObject(classes) && !Objects.isEmpty(classes);
        classes = new _DomClassList(classes);
      }
      if (!classes.value && !returnEmpty) {
        classes = null;
      }
    }
    return classes || (returnEmpty ? new _DomClassList() : null);
  }
  /**
   * Converts a class name of any understood type to a desired form.
   * @param {String|String[]|Object|Set|Map|HTMLElement} cls
   * @param {String} as Pass `'object'` to return an object with the class names as its keys (all keys will have a
   * value of `true`), or pass `'array'` to return an array of class names, or pass `'string'` (the default) to
   * return a space-separated string of class names.
   * @returns {String|String[]|Object}
   * @internal
   */
  static normalize(cls, as = "string") {
    cls = cls || "";
    const type = typeof cls, asArray = as === "array", asObject = as === "object", asString = !asArray && !asObject;
    let isString = type === "string", c, i, ret;
    if (type === "object") {
      if (cls.nodeType === Element.ELEMENT_NODE && typeof cls.getAttribute === "function") {
        cls = cls.getAttribute("class") || "";
        isString = true;
      } else if (cls == null ? void 0 : cls.isDomClassList) {
        cls = cls.values;
      } else if (cls instanceof DOMTokenList) {
        cls = Array.from(cls);
      } else if (cls instanceof Map) {
        cls = Array.from(cls.keys()).filter((k) => cls.get(k));
      } else if (cls instanceof Set) {
        cls = Array.from(cls);
      } else if (!Array.isArray(cls)) {
        cls = Objects.getTruthyKeys(cls);
      }
    }
    if (isString) {
      cls = [...new Set(StringHelper.split(cls))];
    }
    for (i = cls.length; i-- > 0; ) {
      c = cls[i];
      if (!c.length) {
        cls.splice(i, 1);
      } else if (c.includes(" ")) {
        cls.splice(i, 1, ...StringHelper.split(c));
      }
    }
    if (asArray) {
      ret = cls;
    } else if (asString) {
      ret = cls.join(" ");
    } else {
      ret = /* @__PURE__ */ Object.create(null);
      for (i = 0; i < cls.length; ++i) {
        ret[cls[i]] = true;
      }
    }
    return ret;
  }
  /**
   * Initializes a new DomClassList.
   * @param {...String|Object} classes The CSS classes as strings or objects.
   * @function constructor
   */
  constructor(...classes) {
    this.process(1, classes);
  }
  /**
   * Clears all class names from this DomClassList instance.
   * @returns {Core.helper.util.DomClassList} this DomClassList.
   */
  clear() {
    for (const key in this) {
      this[key] = false;
    }
    return this;
  }
  /**
   * Sets this DomClassList instance to represent the classes passed as either strings or objects.
   * @returns {Core.helper.util.DomClassList} this DomClassList.
   */
  set(...classes) {
    return this.clear().process(1, classes);
  }
  // To gain some speed in DomHelper.sync(), faster than instanceof etc
  get isDomClassList() {
    return true;
  }
  /**
   * Returns a clone of this DomClassList with all the same keys set.
   * @returns {Core.helper.util.DomClassList} A clone of this DomClassList.
   */
  clone() {
    return new _DomClassList(this);
  }
  /**
   * Returns a Boolean value, indicating whether this ClassList has the specified CSS class name.
   * @param {String} className CSS class name to check
   * @returns {Boolean} true if this ClassList contains the passed CSS class name, false otherwise
   */
  contains(className) {
    if (typeof className === "string" && className) {
      return Boolean(this[className]);
    }
    return false;
  }
  // An instance of this class may be assigned directly to an element's className
  // it will be coerced to a string value using this method.
  toString() {
    return this.length ? `${this.value} ` : "";
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Analogous to string.trim, returns the string value of this `DomClassList` with no trailing space.
   * @returns {String} A concatenated string value of all the class names in this `DomClassList`
   * separated by spaces.
   */
  trim() {
    return this.value;
  }
  /**
   * Compares this DomClassList to another DomClassList (or class name string of space separated classes).
   * If the same class names (regardless of order) are present, the two are considered equal.
   *
   * So `new DomClassList('foo bar bletch').isEqual('bletch bar foo')` would return `true`
   * @param {Core.helper.util.DomClassList|String} other The `DomClassList` or string of classes to compare to.
   * @returns {Boolean} `true` if the two contain the same class names.
   */
  isEqual(other) {
    const otherClasses = _DomClassList.normalize(other, "array"), len = otherClasses.length;
    if (this.length === len) {
      for (let i = 0; i < len; i++) {
        if (!this[otherClasses[i]]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Get/set string value.
   * Class names separated with space.
   * @property {String}
   */
  get value() {
    let value = this[valueSymbol], keys;
    if (value == null) {
      keys = Objects.getTruthyKeys(this);
      this[lengthSymbol] = keys.length;
      this[valueSymbol] = value = keys.join(" ");
    }
    return value;
  }
  set value(value) {
    const me = this, keys = Object.keys(me), len = keys.length;
    for (let i = 0; i < len; i++) {
      delete me[keys[i]];
    }
    if (value) {
      me.process(1, [value]);
    } else {
      delete me[valueSymbol];
    }
  }
  /**
   * Returns string values as an array.
   * @readonly
   * @property {String[]}
   */
  get values() {
    return Objects.getTruthyKeys(this);
  }
  get length() {
    return this.value ? this[lengthSymbol] : 0;
  }
  process(value, classes) {
    for (let cls, k, i = 0; i < classes.length; i++) {
      if (classes[i]) {
        cls = classes[i];
        if (cls.isDomClassList || Objects.isObject(cls)) {
          for (k in cls) {
            this[k] = value ? cls[k] : !cls[k];
          }
        } else {
          cls = _DomClassList.normalize(classes[i], "array");
          for (k = 0; k < cls.length; ++k) {
            this[cls[k]] = value;
          }
        }
      }
    }
    delete this[valueSymbol];
    return this;
  }
  /**
   * Adds/removes class names according to the passed object's properties.
   *
   * Properties with truthy values are added.
   * Properties with falsy values are removed.
   * @param {Object} classList Object containing properties to set/clear
   */
  assign(classList) {
    for (const cls in classList) {
      if (!this[cls] !== !classList[cls]) {
        this[cls] = classList[cls];
        delete this[valueSymbol];
      }
    }
    return this;
  }
  /**
   * Adds/removes this objects classes to the passed `classList` or element.
   *
   * Properties with truthy values are added.
   * Properties with falsy values are removed.
   * @param {HTMLElement|DOMTokenList} element The element or the element's `classList` to be updated.
   */
  assignTo(element) {
    const classList = element.nodeType === Element.ELEMENT_NODE ? element.classList : element, temp = _DomClassList.from(classList);
    temp.add(this);
    classList.value = temp.value;
  }
  /**
   * Add CSS class(es)
   * ```
   * myClassList.add('bold', 'small');
   * ```javascript
   * @param {String|String[]|Object} classes CSS classes to add
   */
  add(...classes) {
    return this.process(1, classes);
  }
  /**
   * Remove CSS class(es)
   * ```javascript
   * myClassList.remove('bold', 'small');
   * ```
   * @param {String} classes CSS classes to remove
   */
  remove(...classes) {
    return this.process(0, classes);
  }
  /**
   * Toggles the passed CSS class name.
   *
   * If the `force` parameter is passed, `true` means add the class name, `false` means remove it.
   *
   * ```javascript
   * myClassList.toggle('bold', isImportant);
   * ```
   * @param {String} className CSS class to toggle
   * @param {Boolean} [force] `true` to add the class, `false` to remove it.
   * @returns {Boolean} `true` if the operation changed the value.
   */
  toggle(className, flag = Boolean(!this[className])) {
    flag = Boolean(flag);
    if (Boolean(this[className]) !== flag) {
      this[className] = flag;
      delete this[valueSymbol];
      return true;
    }
  }
  /**
   * Analogous to the `String#split` method, but with no delimiter
   * parameter. This method returns an array containing the individual
   * CSS class names set.
   * @returns {String[]} The individual class names in this `DomClassList`
   */
  split() {
    return Objects.getTruthyKeys(this);
  }
  forEach(fn) {
    return Objects.getTruthyKeys(this).forEach(fn);
  }
};
DomClassList.prototype[valueSymbol] = null;
DomClassList._$name = "DomClassList";

// ../Core/lib/Core/GlobalEvents.js
var longpressMoveThreshold = 5;
var isFloatingWidget = (w) => w.floating;
var longPressCancelEvents = {
  touchend: 1,
  pointerup: 1
};
var ignoreModifierKeys = {
  Meta: 1,
  Control: 1,
  Alt: 1
};
var GlobalEvents = new class GlobalEventsHandler extends Base.mixin(Events_default) {
  suspendFocusEvents() {
    focusEventsSuspended = true;
  }
  resumeFocusEvents() {
    focusEventsSuspended = false;
  }
  setupFocusListenersOnce(rootElement, EventHelper2) {
    if (rootElement && !GlobalEvents.observedElements.has(rootElement)) {
      GlobalEvents.setupFocusListeners(rootElement, EventHelper2);
      GlobalEvents.observedElements.add(rootElement);
    }
  }
  detachFocusListeners(rootElement) {
    if (rootElement.$globalEventsDetacher) {
      rootElement.$globalEventsDetacher();
      rootElement.$globalEventsDetacher = null;
      GlobalEvents.observedElements.delete(rootElement);
    }
  }
  // This is imported by EventHelper and that makes the call to set up the listeners
  // `detach` argument is required to not setup more listeners than we need to. In case of salesforce we include floatroot
  // inside the webcomponent element and thus don't need default listeners on document. In regular webcomponents demo we
  // don't need to do it, because with multiple components on one page that would force us to make more complex lookups.
  setupFocusListeners(element = document, EventHelper2, detach = false) {
    const listeners = {
      element,
      touchstart(touchstart) {
        if (!globaltouchStart && touchstart.changedTouches.length === 1) {
          globaltouchStart = touchstart.changedTouches[0];
          if (!BrowserHelper.isAndroid) {
            const onMoveOrPointerUp = ({
              clientX,
              clientY,
              type
            }) => {
              if (longPressCancelEvents[type] || Math.max(Math.abs(clientX - globaltouchStart.clientX), Math.abs(clientY - globaltouchStart.clientY)) > longpressMoveThreshold) {
                contextMenuTouchId = null;
                touchMoveRemover();
                clearTimeout(tapholdTimer);
              }
            }, touchMoveRemover = EventHelper2.on({
              element: document,
              touchmove: onMoveOrPointerUp,
              touchend: onMoveOrPointerUp,
              pointermove: onMoveOrPointerUp,
              pointerup: onMoveOrPointerUp,
              capture: true
            }), tapholdTimer = setTimeout(() => {
              contextMenuTouchId = globaltouchStart.identifier;
              touchMoveRemover();
              touchstart.target.dispatchEvent(new MouseEvent("contextmenu", EventHelper2.copyEvent({}, touchstart)));
            }, EventHelper2.longPressTime);
          }
        } else {
          globaltouchStart = null;
        }
      },
      // Just this one has to be passive: false so that we are allowed to preventDefault
      // if we are part of a contextmenu longpress emulation. Otherwise the gesture will
      // proceed to cause a mousedown event.
      touchend: {
        handler: (event) => {
          if (globaltouchStart) {
            if (event.changedTouches[0].identifier === contextMenuTouchId) {
              event.stopImmediatePropagation();
              if (event.cancelable !== false) {
                event.preventDefault();
              }
            } else if (event.changedTouches.length === 1 && event.changedTouches[0].identifier === globaltouchStart.identifier) {
              GlobalEvents.trigger("globaltap", { event });
            }
            globaltouchStart = null;
          }
        },
        passive: false
      },
      mousedown: {
        handler: (event) => {
          lastInteractionType = "mouse";
          if (!globaltouchStart) {
            GlobalEvents.trigger("globaltap", { event });
          }
          currentMouseDown = event;
          const hasModifierKey = event.ctrlKey || event.altKey || event.shiftKey || event.metaKey;
          if (!currentKeyDown && hasModifierKey) {
            currentKeyDown = new KeyboardEvent("keydown", {
              key: event.ctrlKey ? "Control" : event.shiftKey ? "Shift" : event.altKey ? "Alt" : "Meta",
              ctrlKey: event.ctrlKey,
              altKey: event.altKey,
              shiftKey: event.shiftKey,
              metaKey: event.metaKey
            });
          } else if (currentKeyDown && !hasModifierKey) {
            currentKeyDown = null;
          }
        },
        passive: false
      },
      mouseup() {
        currentMouseDown = null;
      },
      pointerdown: {
        passive: false,
        handler: (event) => {
          var _a2;
          currentPointerDown = event;
          DomHelper.usingKeyboard = false;
          (_a2 = element.classList) == null ? void 0 : _a2.remove("b-using-keyboard");
          if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            DomHelper.removeClsGlobally(element, "b-using-keyboard");
          }
        }
      },
      pointerup: {
        passive: false,
        handler: (event) => {
          if ((currentPointerDown == null ? void 0 : currentPointerDown.pointerId) === event.pointerId) {
            currentPointerDown = null;
          }
        }
      },
      keydown(ev) {
        lastInteractionType = "key";
        currentKeyDown = ev;
        currentOverElement = ev.target;
        if (!ignoreModifierKeys[ev.key]) {
          DomHelper.usingKeyboard = true;
          if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            for (const node of element.children) {
              if (node.matches(".b-outer")) {
                node.classList.add("b-using-keyboard");
              }
            }
          } else {
            element.classList.add("b-using-keyboard");
          }
        }
      },
      mouseenter(ev) {
        currentOverElement = ev.target;
      },
      keypress() {
        lastInteractionType = "key";
      },
      keyup() {
        currentKeyDown = null;
      },
      focusin(focusin) {
        var _a2, _b, _c;
        const { Widget: Widget2 } = GlobalEvents;
        if (((_a2 = focusin.target) == null ? void 0 : _a2.shadowRoot) || ((_b = focusin.target) == null ? void 0 : _b._shadowRoot)) {
          return;
        }
        Widget2.resetFloatRootScroll();
        if (focusEventsSuspended) {
          return;
        }
        const fromElement = !focusin.relatedTarget ? null : focusin.relatedTarget instanceof HTMLElement ? focusin.relatedTarget : document.body, toElement = focusin.target || document.body, fromWidget = Widget2.fromElement(fromElement), toWidget = Widget2.fromElement(toElement), commonAncestor = DomHelper.getCommonAncestor(fromWidget, toWidget), backwards = !!(fromElement && toElement.compareDocumentPosition(fromElement) & 4), topVisibleModal = Widget2.query(isTopVisibleModal);
        let currentFocus = null;
        if (toElement && toElement !== document.body) {
          currentFocus = DomHelper.getActiveElement(toElement);
        } else {
          currentFocus = DomHelper.getActiveElement(document);
        }
        if (topVisibleModal && !topVisibleModal._isRevertingFocus) {
          if (!toWidget || !topVisibleModal.owns(toWidget) && !(topVisibleModal.element.compareDocumentPosition(toWidget.element) & 4 && toWidget.up(isFloatingWidget))) {
            return topVisibleModal.focus();
          }
        }
        let event = createWidgetEvent("focusout", fromElement, focusin.target, fromWidget, toWidget, backwards);
        for (let target = fromWidget, owner; target && target !== commonAncestor; target = owner) {
          owner = target.owner;
          if (!target.isDestroying && target.onFocusOut) {
            target.onFocusOut(event);
            if (focusin.target && currentFocus !== DomHelper.getActiveElement(focusin.target)) {
              return;
            }
          }
        }
        if (commonAncestor && focusin.target === commonAncestor.element) {
          if (!commonAncestor.isDestroying && DomHelper.getActiveElement(commonAncestor) === toElement && commonAncestor.focusElement && commonAncestor.focusElement !== commonAncestor.element) {
            if (!commonAncestor.element.contains(currentFocus) || commonAncestor.focusDescendant) {
              commonAncestor.setTimeout(() => {
                var _a3;
                return (_a3 = commonAncestor.focus) == null ? void 0 : _a3.call(commonAncestor);
              }, 0);
            }
          }
        } else {
          event = createWidgetEvent("focusin", toElement, fromElement, fromWidget, toWidget, backwards);
          for (let target = toWidget; target && target !== commonAncestor; target = target.owner) {
            if (!target.isDestroying) {
              (_c = target.onFocusIn) == null ? void 0 : _c.call(target, event);
            }
          }
        }
        const commonAncestorEl = DomHelper.getCommonAncestor((fromElement == null ? void 0 : fromElement.nodeType) === Element.ELEMENT_NODE ? fromElement : null, toElement) || toElement.parentNode;
        if (commonAncestorEl) {
          event = createWidgetEvent("focusmove", toElement, fromElement, fromWidget, toWidget, backwards, { bubbles: true });
          commonAncestorEl.dispatchEvent(event);
        }
      },
      focusout(focusout) {
        if (focusEventsSuspended) {
          return;
        }
        if (!focusout.relatedTarget || !GlobalEvents.Widget.fromElement(focusout.relatedTarget)) {
          const target = focusout.relatedTarget && focusout.relatedTarget instanceof HTMLElement ? focusout.relatedTarget : null;
          listeners.focusin({
            target,
            relatedTarget: focusout.target
          });
          currentKeyDown = currentMouseDown = null;
        }
      },
      // This will clear keydown and mousedown status on window blur
      blur: {
        element: globalThis,
        handler(event) {
          if (event.target === globalThis) {
            currentKeyDown = null;
            currentMouseDown = null;
          }
        }
      },
      capture: true,
      passive: true
    };
    detach && (detacher == null ? void 0 : detacher());
    detacher = this.detachEvents = element.$globalEventsDetacher = EventHelper2.on(listeners);
  }
  get lastInteractionType() {
    return lastInteractionType;
  }
  get shiftKeyDown() {
    return currentKeyDown == null ? void 0 : currentKeyDown.shiftKey;
  }
  get ctrlKeyDown() {
    return (currentKeyDown == null ? void 0 : currentKeyDown.ctrlKey) || (currentKeyDown == null ? void 0 : currentKeyDown.metaKey);
  }
  get altKeyDown() {
    return currentKeyDown == null ? void 0 : currentKeyDown.altKey;
  }
  get currentOverElement() {
    return currentOverElement;
  }
  isKeyDown(key) {
    return !key ? Boolean(currentKeyDown) : (currentKeyDown == null ? void 0 : currentKeyDown.key) === key || currentKeyDown[(key == null ? void 0 : key.toLowerCase()) + "Key"] === true;
  }
  isMouseDown(button = 0) {
    return (currentMouseDown == null ? void 0 : currentMouseDown.button) === button;
  }
  get currentMouseDown() {
    return currentMouseDown;
  }
  get currentPointerDown() {
    return currentPointerDown;
  }
  get currentTouch() {
    return globaltouchStart;
  }
  get currentKeyDown() {
    return currentKeyDown;
  }
}();
var isTopVisibleModal = (w) => w.isVisible && w.isTopModal;
GlobalEvents.observedElements = /* @__PURE__ */ new Set();
var globaltouchStart;
var contextMenuTouchId;
var focusEventsSuspended = false;
var lastInteractionType;
var currentKeyDown;
var currentMouseDown;
var currentPointerDown;
var currentOverElement;
var detacher;
function createWidgetEvent(eventName, target, relatedTarget, fromWidget, toWidget, backwards, options) {
  const result = new CustomEvent(eventName, options);
  Object.defineProperty(result, "_target", {
    get() {
      return target;
    }
  });
  Object.defineProperty(result, "relatedTarget", {
    get() {
      return relatedTarget;
    }
  });
  result.fromWidget = fromWidget;
  result.toWidget = toWidget;
  result.backwards = backwards;
  return result;
}
var GlobalEvents_default = GlobalEvents;

// ../Core/lib/Core/helper/EventHelper.js
var touchProperties = [
  "clientX",
  "clientY",
  "pageX",
  "pageY",
  "screenX",
  "screenY"
];
var isOption = {
  element: 1,
  thisObj: 1,
  once: 1,
  delegate: 1,
  delay: 1,
  capture: 1,
  passive: 1,
  throttled: 1,
  autoDetach: 1,
  expires: 1,
  block: 1
};
var configurable = true;
var returnTrueProp = {
  configurable,
  value: true
};
var normalizedKeyNames = {
  Spacebar: "Space",
  Del: "Delete",
  Esc: "Escape",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown"
};
var specialKeys = {
  Control: "ctrl",
  Alt: "alt",
  Shift: "shift"
};
var specialKeyRe = /^(ctrl|shift|alt|meta)$/;
var eventProps = [
  "altKey",
  "bubbles",
  "button",
  "buttons",
  "cancelBubble",
  "cancelable",
  "clientX",
  "clientY",
  "ctrlKey",
  "layerX",
  "layerY",
  "metaKey",
  "pageX",
  "pageY",
  "returnValue",
  "screenX",
  "screenY",
  "shiftKey"
];
var _EventHelper = class _EventHelper {
  static normalizeEvent(event) {
    return ObjectHelper.copyPropertiesIf(event, event.changedTouches[0] || event.touches[0], touchProperties);
  }
  /**
   * For use when synthesizing events from native DOM events. Copies valid properties from the passed
   * event into the destination object;
   * @param {Object} dest Destination object
   * @param {Event} event The event whose properties to copy
   * @returns {Object} An event construction object.
   * @internal
   */
  static copyEvent(dest, event) {
    return ObjectHelper.copyProperties(dest, event, eventProps);
  }
  /**
   * Returns the `[x, y]` coordinates of the event in the viewport coordinate system.
   * @param {Event} event The event
   * @returns {Number[]} The coordinate.
   */
  static getXY(event) {
    if (event.touches) {
      event = event.touches[0];
    }
    return [event.clientX, event.clientY];
  }
  /**
   * Returns the pixel distance between two mouse/touch/pointer events.
   * @param {Event} event1 The first event.
   * @param {Event} event2 The second event.
   * @returns {Number} The distance in pixels between the two events.
   */
  static getDistanceBetween(event1, event2) {
    const xy1 = EH.getXY(event1), xy2 = EH.getXY(event2);
    return Math.sqrt(Math.pow(xy1[0] - xy2[0], 2) + Math.pow(xy1[1] - xy2[1], 2));
  }
  /**
   * Returns a {@link Core.helper.util.Rectangle.Point} which encapsulates the `pageX/Y` position of the event.
   * May be used in {@link Core.helper.util.Rectangle} events.
   * @param {Event} event A browser mouse/touch/pointer event.
   * @returns {Core.helper.util.Rectangle.Point} The page point.
   */
  static getPagePoint(event) {
    return new Point(event.pageX, event.pageY);
  }
  /**
   * Returns a {@link Core.helper.util.Rectangle.Point} which encapsulates the `clientX/Y` position of the event.
   * May be used in {@link Core.helper.util.Rectangle} events.
   * @param {Event} event A browser mouse/touch/pointer event.
   * @returns {Core.helper.util.Rectangle.Point} The page point.
   */
  static getClientPoint(event) {
    return new Point(event.clientX, event.clientY);
  }
  /**
   * Add a listener or listeners to an element
   * The `options` parameter allows supplying options for the listener(s), for available options see {@link #typedef-ElementListenerConfig}.
   *
   * @param {HTMLElement} element The element to add a listener/listeners to.
   * @param {String|Object} eventName Either a string, being the name of the event to listen for,
   * or an options object containing event names and options as keys. See the options parameter
   * for details, or the {@link #function-on-static} method for details.
   * @param {Function} [handler] If the second parameter is a string event name, this is the handler function.
   * @param {ElementListenerConfig} [options] If the second parameter is a string event name, this is the options.
   * @returns {Function} A detacher function which removes all the listeners when called.
   */
  static addListener(element, eventName, handler, options) {
    if (element.nodeType) {
      if (typeof eventName === "string") {
        options = Object.assign({
          element,
          [eventName]: handler
        }, options);
      } else {
        options = Object.assign({
          element
        }, eventName);
      }
    } else {
      options = element;
    }
    return EH.on(options);
  }
  /**
   * Adds a listener or listeners to an element.
   * all property names other than the options listed below are taken to be event names,
   * and the values as handler specs.
   *
   * A handler spec is usually a function reference or the name of a function in the `thisObj`
   * option.
   *
   * But a handler spec may also be an options object containing a `handler` property which is
   * the function or function name, and local options, including `element` and `thisObj`
   * which override the top level options.
   *
   * The `options` parameter allows supplying options for the listener(s), for available options see {@link #typedef-ElementListenerConfig}.
   *
   *  Usage example
   *
   * ```javascript
   * construct(config) {
   *     super.construct(config);
   *
   *     // Add auto detaching event handlers to this Widget's reference elements
   *     EventHelper.on({
   *         element : this.iconElement,
   *         click   : '_handleIconClick',
   *         thisObj : this,
   *         contextmenu : {
   *             element : document,
   *             handler : '_handleDocumentContextMenu'
   *         }
   *     });
   * }
   *```
   *
   * The `click` handler on the `iconElement` calls `this._handleIconClick`.
   *
   * The `contextmenu` handler is added to the `document` element, but the `thisObj`
   * is defaulted in from the top `options` and calls `this._handleDocumentContextMenu`.
   *
   * Note that on touch devices, `dblclick` and `contextmenu` events are synthesized.
   * Synthesized events contain a `browserEvent` property containing the final triggering
   * event of the gesture. For example a synthesized `dblclick` event would contain a
   * `browserEvent` property which is the last `touchend` event. A synthetic `contextmenu`
   * event will contain a `browserEvent` property which the longstanding `touchstart` event.
   *
   * @param {ElementListenerConfig} options The full listener specification.
   * @returns {Function} A detacher function which removes all the listeners when called.
   */
  static on(options) {
    const element = options.element, thisObj = options.thisObj, handlerDetails = [];
    for (const eventName in options) {
      if (!isOption[eventName]) {
        let handlerSpec = options[eventName];
        if (typeof handlerSpec !== "object") {
          handlerSpec = {
            handler: handlerSpec
          };
        }
        const targetElement = handlerSpec.element || element;
        handlerDetails.push(EH.addElementListener(targetElement, eventName, handlerSpec, options));
      }
    }
    const detacher2 = () => {
      for (let handlerSpec, i = 0; i < handlerDetails.length; i++) {
        handlerSpec = handlerDetails[i];
        EH.removeEventListener(handlerSpec[0], handlerSpec[1], handlerSpec[2]);
      }
      handlerDetails.length = 0;
    };
    if (thisObj && options.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, detacher2, thisObj);
    }
    return detacher2;
  }
  /**
   * Used internally to add a single event handler to an element.
   * @param {HTMLElement} element The element to add the handler to.
   * @param {String} eventName The name of the event to add a handler for.
   * @param {Function|String|Object} handlerSpec Either a function to call, or
   * the name of a function to call in the `thisObj`, or an object containing
   * the handler local options.
   * @param {Function|String} [handlerSpec.handler] Either a function to call, or
   * the name of a function to call in the `thisObj`.
   * @param {HTMLElement} [handlerSpec.element] Optionally a local element for the listener.
   * @param {Object} [handlerSpec.thisObj] A local `this` specification for the handler.
   * @param {Object} defaults The `options` parameter from the {@link #function-addListener-static} call.
   * @private
   */
  static addElementListener(element, eventName, handlerSpec, defaults) {
    const handler = EH.createHandler(element, eventName, handlerSpec, defaults), { spec } = handler, expires = handlerSpec.expires || defaults.expires, options = spec.capture != null || spec.passive != null ? {
      capture: spec.capture,
      passive: spec.passive
    } : void 0;
    element.addEventListener(eventName, handler, options);
    if (expires) {
      const thisObj = handlerSpec.thisObj || defaults.thisObj, delayable = (thisObj == null ? void 0 : thisObj.isDelayable) ? thisObj : globalThis, { alt } = expires, delay = alt ? expires.delay : expires, { spec: spec2 } = handler;
      spec2.expires = expires;
      spec2.timerId = delayable[typeof delay === "number" ? "setTimeout" : "requestAnimationFrame"](() => {
        spec2.timerId = null;
        EH.removeEventListener(element, eventName, handler);
        if (alt && !handler.called) {
          (typeof alt === "string" ? thisObj[alt] : alt).call(thisObj);
        }
      }, delay, `listener-timer-${performance.now()}`);
    }
    return [element, eventName, handler, options];
  }
  // composedPath throws in salesforce
  // https://github.com/bryntum/support/issues/4432
  static getComposedPathTarget(event) {
    return event.composedPath()[0] || event.path[0];
  }
  static fixEvent(event) {
    var _a2, _b, _c;
    if (event.fixed) {
      return event;
    }
    const { type, target } = event;
    if (((target == null ? void 0 : target.shadowRoot) || ((_b = (_a2 = target == null ? void 0 : target.getRootNode) == null ? void 0 : _a2.call(target)) == null ? void 0 : _b.host)) && event.composedPath) {
      const targetElement = this.getComposedPathTarget(event), originalTarget = target;
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
      Object.defineProperty(event, "originalTarget", {
        value: originalTarget,
        configurable
      });
    }
    Object.defineProperty(event, "fixed", returnTrueProp);
    if (type.startsWith("key")) {
      const normalizedKeyName = normalizedKeyNames[event.key];
      if (normalizedKeyName) {
        Object.defineProperty(event, "key", {
          value: normalizedKeyName,
          configurable
        });
      }
      if (event.key === " " && !event.code) {
        Object.defineProperty(event, "code", {
          value: "Space",
          configurable
        });
      }
    }
    if (event.metaKey && !event.ctrlKey) {
      Object.defineProperty(event, "ctrlKey", returnTrueProp);
    }
    if (target && "offsetX" in event) {
      if (!Object.getOwnPropertyDescriptor(event, "borderOffsetX")) {
        Object.defineProperty(event, "borderOffsetX", {
          get: () => {
            return event.offsetX + (BrowserHelper.isSafari ? 0 : parseInt(target.ownerDocument.defaultView.getComputedStyle(target).getPropertyValue("border-left-width")));
          }
        });
      }
      if (!Object.getOwnPropertyDescriptor(event, "borderOffsetY")) {
        Object.defineProperty(event, "borderOffsetY", {
          get: () => {
            return event.offsetY + (BrowserHelper.isSafari ? 0 : parseInt(target.ownerDocument.defaultView.getComputedStyle(target).getPropertyValue("border-top-width")));
          }
        });
      }
    }
    if ((target == null ? void 0 : target.nodeType) === Element.DOCUMENT_NODE && "clientX" in event) {
      const targetElement = DomHelper.elementFromPoint(event.clientX, event.clientY);
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
    }
    if ((target == null ? void 0 : target.nodeType) === Element.TEXT_NODE) {
      const targetElement = event.target.parentElement;
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
    }
    if (((_c = event.relatedTarget) == null ? void 0 : _c.nodeType) === Element.TEXT_NODE) {
      const relatedTargetElement = event.target.parentElement;
      Object.defineProperty(event, "relatedTarget", {
        value: relatedTargetElement,
        configurable
      });
    }
    if (type.startsWith("touch") && event.touches.length) {
      this.normalizeEvent(event);
    }
    return event;
  }
  static createHandler(element, eventName, handlerSpec, defaults) {
    const delay = handlerSpec.delay || defaults.delay, throttled = handlerSpec.throttled || defaults.throttled, block = handlerSpec.block || defaults.block, once = "once" in handlerSpec ? handlerSpec.once : defaults.once, capture = "capture" in handlerSpec ? handlerSpec.capture : defaults.capture, passive = "passive" in handlerSpec ? handlerSpec.passive : defaults.passive, delegate = "delegate" in handlerSpec ? handlerSpec.delegate : defaults.delegate, wrappedFn = handlerSpec.handler, expires = handlerSpec.expires, thisObj = handlerSpec.thisObj || defaults.thisObj, { rtlSource = thisObj } = thisObj || {};
    let handler = (event, ...args) => {
      if (EH.playingDemo && event.isTrusted) {
        return;
      }
      if (thisObj == null ? void 0 : thisObj.isDestroyed) {
        return;
      }
      event = EH.fixEvent(event, rtlSource == null ? void 0 : rtlSource.rtl);
      handler.called = true;
      (typeof wrappedFn === "string" ? thisObj[wrappedFn] : wrappedFn).call(thisObj, event, ...args);
      delete event.target;
      delete event.relatedTarget;
      delete event.originalarget;
      delete event.key;
      delete event.code;
      delete event.ctrlKey;
      delete event.fixed;
    };
    if (block) {
      const wrappedFn2 = handler;
      let lastCallTime, lastTarget;
      handler = (e, ...args) => {
        const now2 = performance.now();
        if (!lastCallTime || e.target !== lastTarget || now2 - lastCallTime > block) {
          lastTarget = e.target;
          lastCallTime = now2;
          wrappedFn2(e, ...args);
        }
      };
    }
    if (delay != null) {
      const wrappedFn2 = handler, delayable = (thisObj == null ? void 0 : thisObj.setTimeout) ? thisObj : globalThis;
      handler = (...args) => {
        delayable.setTimeout(() => {
          wrappedFn2(...args);
        }, delay);
      };
    }
    if (throttled != null) {
      let alt, buffer = throttled;
      if (throttled.buffer) {
        alt = (e) => {
          return throttled.alt.call(EH, EH.fixEvent(e, rtlSource == null ? void 0 : rtlSource.rtl));
        };
        buffer = throttled.buffer;
      }
      if (thisObj == null ? void 0 : thisObj.isDelayable) {
        handler = thisObj.throttle(handler, {
          delay: buffer,
          throttled: alt
        });
      } else {
        handler = FunctionHelper.createThrottled(handler, buffer, thisObj, null, alt);
      }
    }
    if (once) {
      const wrappedFn2 = handler;
      handler = (...args) => {
        EH.removeEventListener(element, eventName, handler);
        wrappedFn2(...args);
      };
    }
    if (delegate) {
      const wrappedFn2 = handler;
      handler = (event, ...args) => {
        var _a2;
        event = EH.fixEvent(event, rtlSource == null ? void 0 : rtlSource.rtl);
        const delegatedTarget = ((_a2 = event.target.closest) == null ? void 0 : _a2.call) && event.target.closest(delegate);
        if (!delegatedTarget) {
          return;
        }
        Object.defineProperty(event, "currentTarget", {
          get: () => delegatedTarget,
          configurable: true
        });
        wrappedFn2(event, ...args);
      };
    }
    if (handlerSpec.thisObj && handlerSpec.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, () => EH.removeEventListener(element, eventName, handler), thisObj);
    }
    handler.spec = {
      delay,
      throttled,
      block,
      once,
      thisObj,
      capture,
      expires,
      passive,
      delegate
    };
    return handler;
  }
  static removeEventListener(element, eventName, handler) {
    const { expires, timerId, thisObj, capture } = handler.spec;
    if ((expires == null ? void 0 : expires.alt) && timerId) {
      const delayable = (thisObj == null ? void 0 : thisObj.isDelayable) ? thisObj : globalThis;
      delayable[typeof expires.delay === "number" ? "clearTimeout" : "cancelAnimationFrame"](timerId);
    }
    element.removeEventListener(eventName, handler, capture);
  }
  /**
   * Calls a callback when the described animation completes.
   *
   * @param {Object} detail
   * @param {HTMLElement} detail.element The element which is being animated.
   * @param {String|RegExp} [detail.animationName] The name of the animation to wait for.
   * @param {String} [detail.property] If no `animationName` specified, the CSS property
   * which is being animated.
   * @param {Function} detail.handler The function to call on animation end.
   * @param {Number} [detail.duration] Optional fallback time to wait until calling the callback.
   * @param {Object} [detail.thisObj] The `this` reference to call the callback with.
   * @param {Array} [detail.args] Optional arguments to call the callback with.
   * @param {Core.mixin.Delayable} [detail.timerSource] A Delayable to provide the fallback timeout.
   * @param {Boolean} [detail.runOnDestroy] If `timerSource` is a {@link Core.mixin.Delayable},
   * `true` to invoke the callback if it is destroyed during the animation.
   * @returns {Function} a function which detaches the animation end listener.
   */
  static onTransitionEnd({
    element,
    animationName,
    property,
    handler,
    mode = animationName ? "animation" : "transition",
    duration = DomHelper[`get${mode === "transition" ? "Property" : ""}${StringHelper.capitalize(mode)}Duration`](element, property),
    thisObj = globalThis,
    args = [],
    timerSource,
    runOnDestroy
  }) {
    let timerId;
    timerSource = timerSource || (thisObj.isDelayable ? thisObj : globalThis);
    const callbackArgs = [element, property, ...args], doCallback = () => {
      detacher2();
      if (!thisObj.isDestroyed) {
        if (thisObj.callback) {
          thisObj.callback(handler, thisObj, callbackArgs);
        } else {
          handler.apply(thisObj, callbackArgs);
        }
      }
    }, detacher2 = EH.on({
      element,
      [`${mode}end`]({ animationName: endedAnimation, propertyName, target }) {
        var _a2;
        if (target === element) {
          if (propertyName === property || (endedAnimation == null ? void 0 : endedAnimation.match(animationName))) {
            if (timerId) {
              (_a2 = timerSource.clearTimeout) == null ? void 0 : _a2.call(timerSource, timerId);
              timerId = null;
            }
            doCallback();
          }
        }
      }
    });
    if (duration != null) {
      timerId = timerSource.setTimeout(doCallback, duration + 50, "onTransitionEnd", runOnDestroy);
    }
    return detacher2;
  }
  /**
   * Waits for the described animation completes.
   *
   * @param {Object} config
   * @param {HTMLElement} config.element The element which is being animated.
   * @param {String|RegExp} [config.animationName] The name of the animation to wait for.
   * @param {String} [config.property] If no `animationName` specified, the CSS property
   * which is being animated.
   * @param {Number} [config.duration] Optional fallback time to wait until calling the callback.
   * @param {Core.mixin.Delayable} [config.timerSource] A Delayable to provide the fallback timeout.
   * @param {Boolean} [config.runOnDestroy] If `timerSource` is a {@link Core.mixin.Delayable},
   * `true` to invoke the callback if it is destroyed during the animation.
   * @async
   */
  static async waitForTransitionEnd(config) {
    return new Promise((resolve) => {
      config.handler = resolve;
      _EventHelper.onTransitionEnd(config);
    });
  }
  /**
   * Private function to wrap the passed function. The returned wrapper function to be used as
   * a `touchend` handler which will call the passed function passing a fabricated `dblclick`
   * event if there is a `click` within 300ms.
   * @param {Element} element element
   * @param {String|Function} handler The handler to call.
   * @param {Object} thisObj The owner of the function.
   * @private
   */
  static createDblClickWrapper(element, handler, thisObj) {
    let startId, secondListenerDetacher, tapholdTimer;
    return () => {
      if (!secondListenerDetacher) {
        secondListenerDetacher = EH.on({
          element,
          // We only get here if a touchstart arrives within 300ms of a click
          touchstart: (secondStart) => {
            startId = secondStart.changedTouches[0].identifier;
            secondStart.preventDefault();
          },
          touchend: (secondClick) => {
            if (secondClick.changedTouches[0].identifier === startId) {
              secondClick.preventDefault();
              clearTimeout(tapholdTimer);
              startId = secondListenerDetacher = null;
              const targetRect = Rectangle.from(secondClick.changedTouches[0].target, null, true), offsetX = secondClick.changedTouches[0].pageX - targetRect.x, offsetY = secondClick.changedTouches[0].pageY - targetRect.y, dblclickEventConfig = Object.assign({
                browserEvent: secondClick
              }, secondClick), dblclickEvent = new MouseEvent("dblclick", dblclickEventConfig);
              Object.defineProperties(dblclickEvent, {
                target: { value: secondClick.target },
                offsetX: { value: offsetX },
                offsetY: { value: offsetY }
              });
              if (typeof handler === "string") {
                handler = thisObj[handler];
              }
              handler.call(thisObj, dblclickEvent);
            }
          },
          once: true
        });
        tapholdTimer = setTimeout(() => {
          secondListenerDetacher();
          startId = secondListenerDetacher = null;
        }, EH.dblClickTime);
      }
    };
  }
  /**
   * Handles various inputs to figure out the name of the special key of the event.
   *
   * ```javascript
   * EventHelper.toSpecialKey('ctrl') // 'ctrlKey'
   * EventHelper.toSpecialKey(true)   // 'ctrlKey', default for PC (Cmd for Mac)
   * EventHelper.toSpecialKey(false)  // false
   * EventHelper.toSpecialKey('foo')  // false
   * ```
   *
   * @param {*} value User input value to process.
   * @param {String} defaultValue Default value to fall back to if `true` value is passed.
   * @returns {Boolean|String} Returns `false` if provided value cannot be converted to special key and special key
   * name otherwise.
   * @internal
   */
  static toSpecialKey(value, defaultValue2 = BrowserHelper.isMac ? "metaKey" : "ctrlKey") {
    let result = false;
    if (value === true) {
      result = defaultValue2;
    } else if (typeof value === "string") {
      value = value.toLowerCase();
      if (value.match(specialKeyRe)) {
        result = `${value}Key`;
      }
    }
    return result;
  }
  /**
   * If keyup event is triggered when special key is pressed, we don't get special key value from properties like
   * `ctrlKey`. Instead we need to read `event.key`. That property uses full name and we use abbreviations, so we
   * need to convert the key.
   * @param {String} code
   * @returns {String}
   * @internal
   */
  static specialKeyFromEventKey(code) {
    return specialKeys[code] || "no-special-key";
  }
};
/**
 * DOM event to trigger name mapping.
 * @internal
 */
__publicField(_EventHelper, "eventNameMap", {
  mousedown: "MouseDown",
  mouseup: "MouseUp",
  click: "Click",
  dblclick: "DblClick",
  contextmenu: "ContextMenu",
  mouseenter: "MouseEnter",
  mouseleave: "MouseLeave",
  mousemove: "MouseMove",
  mouseover: "MouseOver",
  mouseout: "MouseOut",
  keyup: "KeyUp",
  keydown: "KeyDown",
  keypress: "KeyPress"
});
var EventHelper = _EventHelper;
var EH = EventHelper;
EH.longPressTime = 700;
EH.dblClickTime = 300;
if (BrowserHelper.isTouchDevice) {
  EH.on({
    element: document,
    touchmove: (event) => {
      if (event.target.closest(".b-dragging")) {
        event.preventDefault();
      }
    },
    passive: false,
    capture: true
  });
}
EventHelper._$name = "EventHelper";

// ../Core/lib/Core/helper/DomHelper.js
var DEFAULT_FONT_SIZE = 14;
var t0t0 = { align: "t0-t0" };
var ELEMENT_NODE = Node.ELEMENT_NODE;
var TEXT_NODE = Node.TEXT_NODE;
var { isObject } = ObjectHelper;
var numberRe = /[+-]?\d*\.?\d+[eE]?-?\d*/g;
var numberReSrc = numberRe.source;
var translateMatrix2dRe = new RegExp(`matrix\\((?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(${numberReSrc}),\\s?(${numberReSrc})`);
var translateMatrix3dRe = new RegExp(`matrix3d\\((?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(-?\\d*),\\s?(-?\\d*)`);
var translateMatrixRe = new RegExp(`(?:${translateMatrix2dRe.source})|(?:${translateMatrix3dRe.source})`);
var pxTtranslateXRe = new RegExp(`translate(3d|X)?\\((${numberReSrc})px(?:,\\s?(${numberReSrc})px)?`);
var pxTtranslateYRe = new RegExp(`translate(3d|Y)?\\((${numberReSrc})px(?:,\\s?(${numberReSrc})px)?`);
var whiteSpaceRe2 = /\s+/;
var semicolonRe = /\s*;\s*/;
var colonRe = /\s*:\s*/;
var digitsRe = /^-?((\d+(\.\d*)?)|(\.?\d+))$/;
var elementPropKey = "$bryntum";
var elementCreateExpandos = {
  elementData: "",
  for: "htmlFor",
  retainElement: ""
};
var elementCreateProperties = {
  // these two are handled by being in elementCreateExpands:
  // elementData  : 1,
  // for          : 1,
  tag: 1,
  html: 1,
  text: 1,
  children: 1,
  tooltip: 1,
  style: 1,
  dataset: 1,
  parent: 1,
  nextSibling: 1,
  ns: 1,
  reference: 1,
  class: 1,
  className: 1,
  unmatched: 1,
  // Used by syncId approach
  onlyChildren: 1,
  // Used by sync to not touch the target element itself,
  listeners: 1,
  // eslint-disable-line bryntum/no-listeners-in-lib
  compareHtml: 1,
  // Sync
  syncOptions: 1,
  // Sync
  keepChildren: 1
  // Sync
};
var styleIgnoreProperties = {
  length: 1,
  parentRule: 1,
  style: 1
};
var nativeEditableTags = {
  INPUT: 1,
  TEXTAREA: 1
};
var nativeFocusableTags = {
  BUTTON: 1,
  IFRAME: 1,
  EMBED: 1,
  INPUT: 1,
  OBJECT: 1,
  SELECT: 1,
  TEXTAREA: 1,
  BODY: 1
};
var win = globalThis;
var doc = document;
var emptyObject4 = Object.freeze({});
var arraySlice = Array.prototype.slice;
var immediatePromise = Promise.resolve();
var fontProps = [
  "font-size",
  "font-size-adjust",
  "font-style",
  "font-weight",
  "font-family",
  "font-kerning",
  "font-stretch",
  "line-height",
  "text-transform",
  "text-decoration",
  "letter-spacing",
  "word-break"
];
var isHiddenWidget = (e) => e._hidden;
var parentNode = (el) => el.parentNode || el.host;
var mergeChildren = (dest, src, options) => {
  if (options.key === "children") {
    return ObjectHelper.mergeItems(dest, src, options);
  }
  return ObjectHelper.blend(dest, src, options);
};
var isVisible = (e) => {
  const style = e.ownerDocument.defaultView.getComputedStyle(e);
  return style.getPropertyValue("display") !== "none" && style.getPropertyValue("visibility") !== "hidden";
};
var hasLayout = (el) => el && (el === doc.body || Boolean(el.offsetParent) || (el.ownerDocument.defaultView && ("offsetParent" in el && DomHelper.getStyleValue(el, "position") !== "fixed") ? el.offsetParent : hasLayout(el.parentNode)));
var elementOrConfigToElement = (elementOrConfig) => {
  if (elementOrConfig instanceof Node) {
    return elementOrConfig;
  }
  if (typeof elementOrConfig === "string") {
    return DH2.createElementFromTemplate(elementOrConfig);
  }
  return DH2.createElement(elementOrConfig);
};
var canonicalStyles = /* @__PURE__ */ Object.create(null);
var canonicalizeStyle = (name, hasUnit) => {
  const entry = canonicalStyles[name] || [StringHelper.hyphenate(name), hasUnit];
  if (!canonicalStyles[name]) {
    canonicalStyles[entry[0]] = canonicalStyles[name] = entry;
  }
  return entry;
};
var getOffsetParent = (node) => node.ownerSVGElement ? node.ownerSVGElement.parentNode : node.offsetParent;
var slideInAnimationName = /b-slide-in-from-\w+/;
[
  "top",
  "right",
  "bottom",
  "left",
  "width",
  "height",
  "maxWidth",
  "maxHeight",
  "minWidth",
  "minHeight",
  "borderSpacing",
  "borderWidth",
  "borderTopWidth",
  "borderRightWidth",
  "borderBottomWidth",
  "borderLeftWidth",
  "marginTop",
  "marginRight",
  "marginBottom",
  "marginLeft",
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  "fontSize",
  "letterSpacing",
  "lineHeight",
  "outlineWidth",
  "textIndent",
  "wordSpacing"
].forEach((name) => canonicalizeStyle(name, true));
var scrollBarWidth = null;
var idCounter = 0;
var themeInfo = null;
var templateElement;
var htmlParser;
var scrollBarMeasureElement;
var DomHelper = class _DomHelper {
  /**
   * Animates the specified element to slide it into view within the visible viewport
   * of its parentElement from the direction of movement.
   *
   * So in a left-to-right Widget, `direction` 1 means it slides in from the right
   * and `direction` -1 means it slides in from the left. RTL reverses the movement.
   *
   * See the forward/backward navigations in {@link Core.widget.DatePicker} for an example
   * of this in action.
   *
   * If "next" should arrive from below and "previous" should arrive from above, add the
   * class `b-slide-vertical` to the element.
   * @param {HTMLElement} element The element to slide in.
   * @param {Number} direction
   * * `1` to slide in from the "next" direction.
   * * `-1` to slide in from the "previous" direction.
   *
   * If the element is inside an RTL widget the directions are reversed.
   * @async
   */
  static async slideIn(element, direction = 1) {
    const cls = `b-slide-in-${direction > 0 ? "next" : "previous"}`, {
      classList,
      parentNode: { classList: pClassList }
    } = element;
    pClassList.add(".b-sliding-child-element");
    classList.add(cls);
    await EventHelper.waitForTransitionEnd({
      element,
      animationName: slideInAnimationName
    });
    classList.remove(cls);
    pClassList.remove(".b-sliding-child-element");
  }
  /**
   * Returns `true` if the passed element is focusable either programmatically or through pointer gestures.
   * @param {HTMLElement} element The element to test.
   * @returns {Boolean} Returns `true` if the passed element is focusable
   */
  static isFocusable(element, skipAccessibilityCheck = false) {
    if (!skipAccessibilityCheck) {
      if (!DH2.isVisible(element) || DH2.Widget.fromElement(element, isHiddenWidget)) {
        return false;
      }
    }
    const nodeName = element.nodeName;
    return nativeFocusableTags[nodeName] || (nodeName === "A" || nodeName === "LINK") && !!element.href || element.getAttribute("tabIndex") != null || element.contentEditable === "true";
  }
  /**
   * Returns `true` if the passed element accepts keystrokes to edit its contents.
   * @returns {Boolean} Returns `true` if the passed element is editable.
   */
  static isEditable(element) {
    return element.isContentEditable || nativeEditableTags[element.nodeName];
  }
  /**
   * Returns the rectangle of the element which is currently visible in the browser viewport, i.e. user can find it on
   * screen, or `false` if it is scrolled out of view.
   * @param {HTMLElement} target The element to test.
   * @param {Boolean} [whole=false] Whether to check that whole element is visible, not just part of it.
   * If this is passed as true, the result will be a boolean, `true` or `false`.
   * @privateparam {Core.widget.Widget} [caller] the Widget aligning to the target.
   * @returns {Core.helper.util.Rectangle|Boolean} Returns the rectangle of the element which is currently visible in
   * the browser viewport, or `false` if it is out of view.
   */
  static isInView(target, whole = false, caller) {
    if (!hasLayout(target)) {
      return false;
    }
    const positioned = (caller == null ? void 0 : caller.positioned) && _DomHelper.getStyleValue(caller.element, "position") !== "fixed", docRect = Rectangle.from(globalThis), method = whole ? "contains" : "intersect", cOp = positioned && caller.element.offsetParent, cOpR = positioned && Rectangle.from(cOp);
    docRect.height = doc.scrollingElement.scrollHeight;
    if (target === doc.body) {
      return docRect;
    }
    const result = this.getViewportIntersection(target, docRect, method);
    if (result && positioned) {
      result.translate(doc.scrollingElement.scrollLeft, doc.scrollingElement.scrollTop);
    }
    return positioned && result ? result.translate(-cOpR.x + cOp.scrollLeft, -cOpR.y + cOp.scrollTop) : result;
  }
  /**
   * This method goes up the DOM tree checking that all ancestors are visible in the viewport
   * @param {HTMLElement} target Starting html element
   * @param {Core.helper.util.Rectangle} docRect Window rectangle
   * @param {'contains'|'intersect'} method 'contains' or 'intersect'
   * @returns {Core.helper.util.Rectangle}
   */
  static getViewportIntersection(target, docRect, method) {
    const { parentNode: parentNode2 } = target, { parentElement } = parentNode2.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? target.getRootNode().host : target, peStyle = parentElement.ownerDocument.defaultView.getComputedStyle(parentElement), parentScroll = peStyle.overflowX !== "visible" || peStyle.overflowY !== "visible", offsetParent = getOffsetParent(target);
    let result = Rectangle.from(target, null, true);
    for (let viewport = parentScroll ? target.parentNode : offsetParent; result && viewport !== doc.documentElement; viewport = viewport.parentNode) {
      if (viewport.nodeType === Node.DOCUMENT_FRAGMENT_NODE && viewport.host) {
        viewport = viewport.host.parentNode;
      }
      const isTop = viewport === doc.body, style = viewport.ownerDocument.defaultView.getComputedStyle(viewport);
      if (style.display === "contents") {
        continue;
      }
      if (isTop || style.overflow !== "visible") {
        const viewportRect = isTop ? docRect : Rectangle.client(viewport, null, true, true);
        result = viewportRect[method](result, false, true);
      }
    }
    return result;
  }
  /**
   * Returns `true` if the passed element is deeply visible. Meaning it is not hidden using `display`
   * or `visibility` and no ancestor node is hidden.
   * @param {HTMLElement} element The element to test.
   * @returns {Boolean} `true` if deeply visible.
   */
  static isVisible(element) {
    const document2 = element.ownerDocument;
    for (; element; element = parentNode(element)) {
      if (element === document2) {
        return true;
      }
      if (element.nodeType === element.ELEMENT_NODE && !isVisible(element)) {
        return false;
      }
    }
    return false;
  }
  /**
   * Returns true if DOM Event instance is passed. It is handy to override to support Locker Service.
   * @param event
   * @internal
   * @returns {Boolean}
   */
  static isDOMEvent(event) {
    return event instanceof Event;
  }
  /**
   * Merges specified source DOM config objects into a `dest` object.
   * @param {DomConfig} dest The destination DOM config object.
   * @param {...DomConfig} sources The DOM config objects to merge into `dest`.
   * @returns {DomConfig} The `dest` object.
   * @internal
   */
  static merge(dest, ...sources) {
    return ObjectHelper.blend(dest, sources, { merge: mergeChildren });
  }
  /**
   * Updates in-place a DOM config object whose `children` property may be an object instead of the typical array.
   * The keys of such objects become the `reference` property upon conversion.
   *
   * @param {DomConfig} domConfig
   * @param {Function} [namedChildren] A function to call for each named child element.
   * @privateparam {Boolean} [ignoreRefs] Not meant to be manually set, used when recursing.
   * @returns {DomConfig} Returns the altered DOM config
   * @internal
   */
  static normalizeChildren(domConfig, namedChildren, ignoreRefs) {
    var _a2;
    let children = domConfig == null ? void 0 : domConfig.children, child, i, name, kids, ref;
    if ((_a2 = domConfig == null ? void 0 : domConfig.syncOptions) == null ? void 0 : _a2.ignoreRefs) {
      ignoreRefs = true;
    }
    if (children && !(domConfig instanceof Node)) {
      if (Array.isArray(children)) {
        for (i = 0; i < children.length; ++i) {
          DH2.normalizeChildren(children[i], namedChildren, ignoreRefs);
        }
      } else {
        kids = children;
        domConfig.children = children = [];
        for (name in kids) {
          child = kids[name];
          if (child == null ? void 0 : child.isWidget) {
            child = child.element;
          }
          ref = !name.startsWith("$") && !DH2.isElement(child);
          ref && (namedChildren == null ? void 0 : namedChildren(
            name,
            /* hoist = */
            !ignoreRefs
          ));
          if (child) {
            if (!(child instanceof Node)) {
              if (child.reference === false) {
                delete child.reference;
              } else if (ref && typeof child !== "string") {
                child.reference = name;
              }
              DH2.normalizeChildren(child, namedChildren, ignoreRefs);
            }
            children.push(child);
          }
        }
      }
    }
    return domConfig;
  }
  static roundPx(px, devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const multiplier = 1 / devicePixelRatio;
    return Math.round(px / multiplier) * multiplier;
  }
  // For use when we are dividing a DOM element into even parts. The resulting value
  // must be floored to prevent overflow. But only floored to the device's resolution,
  // so raw Math.floor will not work - it would leave empty space in hi resolution screens.
  static floorPx(px, devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const multiplier = 1 / devicePixelRatio;
    return Math.floor(px * multiplier) / multiplier;
  }
  /**
   * Returns true if element has opened shadow root
   * @param {HTMLElement} element Element to check
   * @returns {Boolean}
   */
  static isCustomElement(element) {
    return Boolean(element == null ? void 0 : element.shadowRoot);
  }
  /**
   * Resolves element from point, checking shadow DOM if required
   * @param {Number} x
   * @param {Number} y
   * @returns {HTMLElement}
   */
  static elementFromPoint(x, y) {
    let el = document.elementFromPoint(x, y);
    if (DH2.isCustomElement(el)) {
      el = el.shadowRoot.elementFromPoint(x, y) || el;
    }
    return el;
  }
  /**
   * Resolves child element from point __in the passed element's coordinate space__.
   * @param {HTMLElement} parent The element to find the occupying element in.
   * @param {Number|Core.helper.util.Rectangle.Point} x Either the `X` part of a point, or the point to find.
   * @param {Number} [y] The `Y` part of the point.
   * @returns {HTMLElement}
   * @internal
   */
  static childFromPoint(el, x, y, parent = el) {
    const p = y == null ? x : new Rectangle(x, y, 0, 0);
    let result = null;
    Array.from(el.children).reverse().some((el2) => {
      if (Rectangle.from(el2, parent).contains(p)) {
        result = el2.children.length && DH2.childFromPoint(el2, p, null, parent) || el2;
        return true;
      }
    });
    return result;
  }
  /**
   * Converts a name/value pair of a style name and its value into the canonical (hyphenated) name of the style
   * property and a value with the `defaultUnit` suffix appended if no unit is already present in the `value`.
   *
   * For example:
   * ```javascript
   *  const [property, value] = DomHelper.unitize('marginLeft', 50);
   *  console.log(property, value);
   * ```
   *
   * ```
   *  > margin-left 50px
   * ```
   * @param {String} name
   * @param {String|Number} value
   * @param {String} [defaultUnit]
   * @returns {String[]}
   * @internal
   */
  static unitize(name, value, defaultUnit = "px") {
    const [trueName, hasUnits] = canonicalizeStyle(name);
    if (value != null) {
      value = String(value);
      value = hasUnits && digitsRe.test(value) ? value + defaultUnit : value;
    }
    return [trueName, value];
  }
  /**
   * Returns active element checking shadow dom too
   * @readonly
   * @property {HTMLElement}
   */
  static get activeElement() {
    let el = document.activeElement;
    while (el.shadowRoot) {
      el = el.shadowRoot.activeElement;
    }
    return el;
  }
  // returns active element for DOM tree / shadow DOM tree to which element belongs
  static getActiveElement(element) {
    if (element == null ? void 0 : element.isWidget) {
      element = element.element;
    }
    let el = ((element == null ? void 0 : element.getRootNode()) || document).activeElement;
    while (el == null ? void 0 : el.shadowRoot) {
      el = el.shadowRoot.activeElement;
    }
    return el;
  }
  // Returns the visible root (either document.body or a web component shadow root)
  static getRootElement(element) {
    var _a2;
    const root = (_a2 = element.getRootNode) == null ? void 0 : _a2.call(element), { nodeType } = root;
    return nodeType === Node.DOCUMENT_NODE ? root.body : nodeType === Node.DOCUMENT_FRAGMENT_NODE ? root : element.ownerDocument.contains(element) ? element.ownerDocument.body : null;
  }
  // Returns the topmost HTMLElement inside the current context (either document.body or a direct child of a web component shadow root)
  static getOutermostElement(element) {
    var _a2;
    const root = (_a2 = element.getRootNode) == null ? void 0 : _a2.call(element);
    if (root == null ? void 0 : root.body) {
      return root == null ? void 0 : root.body;
    }
    while (element.parentNode !== root && element.parentNode) {
      element = element.parentNode;
    }
    return element;
  }
  static isValidFloatRootParent(target) {
    return target === document.body || target.constructor.name === "ShadowRoot";
  }
  /**
   * Returns the `id` of the passed element. Generates a unique `id` if the element does not have one.
   * @param {HTMLElement} element The element to return the `id` of.
   */
  static getId(element) {
    return element.id || (element.id = "b-element-" + ++idCounter);
  }
  /**
   * Returns common widget/node ancestor for from/to arguments
   * @param {Core.widget.Widget|HTMLElement} from
   * @param {Core.widget.Widget|HTMLElement} to
   * @returns {Core.widget.Widget|HTMLElement}
   * @internal
   */
  static getCommonAncestor(from, to) {
    var _a2, _b;
    if (from === to) {
      return from;
    }
    while (from && !(((_a2 = from[from.isWidget ? "owns" : "contains"]) == null ? void 0 : _a2.call(from, to)) || from === to)) {
      from = ((_b = from.owner) == null ? void 0 : _b.isWidget) && from.owner !== from ? from.owner : from.parentNode;
    }
    return from;
  }
  //region Internal
  /**
   * Internal convenience fn to allow specifying either an element or a CSS selector to retrieve one
   * @private
   * @param {String|HTMLElement} elementOrSelector element or selector to lookup in DOM
   * @returns {HTMLElement}
   */
  static getElement(elementOrSelector) {
    if (elementOrSelector instanceof Element) {
      return elementOrSelector;
    }
    return doc.querySelector(elementOrSelector);
  }
  /**
   * Sets attributes passed as object to given element
   * @param {String|Element} elementOrSelector
   * @param {Object} attributes
   * @internal
   */
  static setAttributes(elementOrSelector, attributes) {
    const element = DH2.getElement(elementOrSelector);
    if (element && attributes) {
      for (const key in attributes) {
        if (attributes[key] == null) {
          element.removeAttribute(key);
        } else {
          element.setAttribute(key, attributes[key]);
        }
      }
    }
  }
  /**
   * Sets a CSS [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length) style value.
   * @param {String|HTMLElement} element The element to set the style in, or, if just the result is required,
   * the style magnitude to return with units added. If a nullish value is passed, an empty string
   * is returned.
   * @param {String} [style] The name of a style property which specifies a [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length)
   * @param {Number|String} [value] The magnitude. If a number is used, the value will be set in `px` units.
   * @returns {String} The style value string.
   */
  static setLength(element, style, value) {
    if (arguments.length === 1) {
      value = typeof element === "number" ? `${element}px` : element != null ? element : "";
    } else {
      element = DH2.getElement(element);
      value = element.style[style] = typeof value === "number" ? `${value}px` : value != null ? value : "";
    }
    return value;
  }
  /**
   * Returns string percentified and rounded value for setting element's height, width etc.
   * @param {String|Number} value percent value
   * @param {Number} digits number of decimal digits for rounding
   * @returns {string} percentified value or empty string if value can not be parsed
   * @internal
   */
  static percentify(value, digits = 2) {
    const mult = Math.pow(10, digits);
    return value == null || value === "" || isNaN(value) ? "" : `${Math.round(value * mult) / mult}%`;
  }
  //endregion
  //region Children, going down...
  /**
   * Gets the first direct child of `element` that matches `selector`.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {HTMLElement}
   * @category Query children
   */
  static getChild(element, selector) {
    return element.querySelector(":scope>" + selector);
  }
  /**
   * Checks if `element` has any child that matches `selector`.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {Boolean} true if any child matches selector
   * @category Query children
   */
  static hasChild(element, selector) {
    return DH2.getChild(element, selector) != null;
  }
  /**
   * Returns all child elements (not necessarily direct children) that matches `selector`.
   *
   * If `selector` starts with `'>'` or `'# '`, then all components of the `selector` must match inside of `element`.
   * The scope selector, `:scope` is prepended to the selector (and if `#` was used, it is removed).
   *
   * These are equivalent:
   *
   *      DomHelper.children(el, '# .foo .bar');
   *
   *      el.querySelectorAll(':scope .foo .bar');
   *
   * These are also equivalent:
   *
   *      DomHelper.children(el, '> .foo .bar');
   *
   *      el.querySelectorAll(':scope > .foo .bar');
   *
   * @param {HTMLElement} element The parent element
   * @param {String} selector The CSS selector
   * @returns {HTMLElement[]} Matched elements, somewhere below `element`
   * @category Query children
   */
  static children(element, selector) {
    if (selector[0] === ">" || selector.startsWith("# ")) {
      if (selector[0] === "#") {
        selector = selector.substr(2);
      }
      selector = ":scope " + selector;
    }
    return Array.from(element.querySelectorAll(selector));
  }
  // Salesforce doesn't yet support childElementCount. So we relace all native usages with this wrapper and
  // override it for salesforce environment.
  // https://github.com/bryntum/support/issues/3008
  static getChildElementCount(element) {
    return element.childElementCount;
  }
  /**
   * Looks at the specified `element` and all of its children for the one that first matches `selector`.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {HTMLElement} Matched element, either element or an element below it
   * @category Query children
   */
  static down(element, selector) {
    if (!element) {
      return null;
    }
    if (element.matches && element.matches(selector)) {
      return element;
    }
    selector = ":scope " + selector;
    return element.querySelector(selector);
  }
  /**
   * Checks if childElement is a descendant of parentElement (contained in it or a sub element)
   * @param {HTMLElement} parentElement Parent element
   * @param {HTMLElement} childElement Child element, at any level below parent (includes nested shadow roots)
   * @returns {Boolean}
   * @category Query children
   */
  static isDescendant(parentElement, childElement) {
    const parentRoot = DH2.getRootElement(parentElement), childRoot = DH2.getRootElement(childElement);
    if (childRoot && parentRoot !== childRoot && childRoot.host) {
      return DH2.isDescendant(parentRoot, childRoot.host);
    }
    return parentElement.contains(childElement);
  }
  /**
   * Returns the specified element of the given `event`. If the `event` is an `Element`, it is returned. Otherwise,
   * the `eventName` argument is used to retrieve the desired element property from `event` (this defaults to the
   * `'target'` property).
   * @param {Event|Element} event
   * @param {String} [elementName]
   * @returns {Element}
   */
  static getEventElement(event, elementName = "target") {
    return !event || DH2.isElement(event) ? event : event[elementName];
  }
  /**
   * Returns `true` if the provided value is _likely_ a DOM element. If the element can be assured to be from the
   * same document, `instanceof Element` is more reliable.
   * @param {*} value
   * @returns {Boolean}
   */
  static isElement(value) {
    return (value == null ? void 0 : value.nodeType) === document.ELEMENT_NODE && DH2.isNode(value);
  }
  /**
   * Returns `true` if the provided element is an instance of React Element.
   * All React elements require an additional $$typeof: Symbol.for('react.element') field declared on the object for security reasons.
   * The object which React.createElement() return has $$typeof property equals to Symbol.for('react.element')
   *
   * Sources:
   * https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html
   * https://github.com/facebook/react/pull/4832
   *
   * @param {*} element
   * @returns {Boolean}
   * @internal
   */
  static isReactElement(element) {
    return (element == null ? void 0 : element.$$typeof) === Symbol.for("react.element");
  }
  /**
   * Returns `true` if the provided value is _likely_ a DOM node. If the node can be assured to be from the same
   * document, `instanceof Node` is more reliable.
   * @param {*} value
   * @returns {Boolean}
   */
  static isNode(value) {
    return Boolean(value) && typeof value.nodeType === "number" && !isObject(value);
  }
  /**
   * Iterates over each result returned from `element.querySelectorAll(selector)`. Can also be called with only two
   * arguments, in which case the first argument is used as selector and document is used as the element.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @param {Function} fn Function called for each found element
   * @category Query children
   */
  static forEachSelector(element, selector, fn) {
    if (typeof element === "string") {
      throw new Error("DomHelper.forEachSelector must provide a root element context (for shadow root scenario)");
    }
    DH2.children(element, selector).forEach(fn);
  }
  /**
   * Iterates over the direct child elements of the specified element.
   * @param {HTMLElement} element Parent element
   * @param {Function} fn Function called for each child element
   * @category Query children
   */
  static forEachChild(element, fn) {
    Array.from(element.children).forEach(fn);
  }
  /**
   * Removes each element returned from `element.querySelectorAll(selector)`.
   * @param {HTMLElement} element
   * @param {String} selector
   * @category Query children
   */
  static removeEachSelector(element, selector) {
    DH2.forEachSelector(element, selector, (child) => child.remove());
  }
  static removeClsGlobally(element, ...classes) {
    classes.forEach((cls) => DH2.forEachSelector(element, "." + cls, (child) => child.classList.remove(cls)));
  }
  //endregion
  //region Parents, going up...
  /**
   * Looks at the specified element and all of its parents for the one that first matches selector.
   * @deprecated Since 5.3.9, use native `element.closest()` instead
   * @param {HTMLElement} element Element
   * @param {String} selector CSS selector
   * @returns {HTMLElement} Matched element, either the passed in element or an element above it
   * @category Query parents
   */
  static up(element, selector) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.up() deprecated, use native `element.closest()` instead");
    return element.closest(selector);
  }
  static getAncestor(element, possibleAncestorParents, outerElement = null) {
    let found = false, ancestor, parent = element;
    possibleAncestorParents = ArrayHelper.asArray(possibleAncestorParents);
    while (parent = parent.parentElement) {
      if (possibleAncestorParents.includes(parent)) {
        found = true;
        break;
      }
      if (outerElement && parent === outerElement)
        break;
      ancestor = parent;
    }
    if (!found)
      return null;
    return ancestor || element;
  }
  /**
   * Retrieves all parents to the specified element.
   * @param {HTMLElement} element Element
   * @returns {HTMLElement[]} All parent elements, bottom up
   * @category Query parents
   */
  static getParents(element) {
    const parents = [];
    while (element.parentElement) {
      parents.push(element.parentElement);
      element = element.parentElement;
    }
    return parents;
  }
  //endregion
  //region Creation
  /**
   * Converts the passed id to an id valid for usage as id on a DOM element.
   * @param {String} id
   * @returns {String}
   */
  static makeValidId(id, replaceValue = "") {
    return StringHelper.makeValidDomId(id, replaceValue);
  }
  /**
   * Creates an Element, accepts a {@link #typedef-DomConfig} object. Example usage:
   *
   * ```javascript
   * DomHelper.createElement({
   *   tag         : 'table', // defaults to 'div'
   *   className   : 'nacho',
   *   html        : 'I am a nacho',
   *   children    : [ { tag: 'tr', ... }, myDomElement ],
   *   parent      : myExistingElement // Or its id
   *   style       : 'font-weight: bold;color: red',
   *   dataset     : { index: 0, size: 10 },
   *   tooltip     : 'Yay!',
   *   ns          : 'http://www.w3.org/1999/xhtml'
   * });
   * ```
   *
   * @param {DomConfig} config Element config object
   * @param {Object} [options] An object specifying creation options. If this is a boolean value, it is
   * understood to be the `returnAll` option.
   * @param {Boolean} [options.ignoreRefs] Pass `true` to ignore element references.
   * @param {Boolean} [options.returnAll] Specify true to return all elements & child elements created as an array.
   * @privateparam {HTMLElement} [options.replaceElement] Pass element which will be replaced with a created one
   * @returns {HTMLElement|HTMLElement[]|Object<String,HTMLElement>} Single element or array of elements `returnAll` was set to true.
   * If any elements had a `reference` property, this will be an object containing a reference to
   * all those elements, keyed by the reference name.
   * @category Creation
   */
  static createElement(config = {}, options) {
    var _a2, _b;
    let returnAll = options, element, i, ignoreChildRefs, ignoreRefOption, ignoreRefs, key, name, value, refOwner, refs, syncIdField;
    if (typeof returnAll === "boolean") {
      throw new Error("Clean up");
    } else if (options) {
      ignoreRefs = options.ignoreRefs;
      refOwner = options.refOwner;
      refs = options.refs;
      returnAll = options.returnAll;
      syncIdField = options.syncIdField;
      if (ignoreRefs) {
        ignoreChildRefs = true;
        ignoreRefs = ignoreRefs !== "children";
      }
    }
    if (typeof config.parent === "string") {
      config.parent = document.getElementById(config.parent);
    }
    const parent = config.parent || config.nextSibling && config.nextSibling.parentNode, { dataset, html, reference, syncOptions, text } = config;
    if (syncOptions) {
      syncIdField = syncOptions.syncIdField || syncIdField;
      ignoreRefOption = syncOptions.ignoreRefs;
      if (ignoreRefOption) {
        ignoreChildRefs = true;
        ignoreRefs = ignoreRefOption !== "children";
        options = {
          ...options,
          ignoreRefs: true
        };
      }
    }
    if (ignoreRefs) {
      refOwner = null;
    }
    if (config.ns) {
      element = doc.createElementNS(config.ns, config.tag || "svg");
    } else {
      element = doc.createElement(config.tag || "div");
    }
    if (text != null) {
      DH2.setInnerText(element, text);
    } else if (html != null) {
      if (html instanceof DocumentFragment) {
        element.appendChild(html);
      } else {
        element.innerHTML = html;
      }
    }
    if (config.tooltip) {
      DH2.Widget.attachTooltip(element, config.tooltip);
    }
    if (config.style) {
      DH2.applyStyle(element, config.style);
    }
    if (dataset) {
      for (name in dataset) {
        value = dataset[name];
        if (value != null) {
          element.dataset[name] = value;
        }
      }
    }
    if (parent) {
      this.addChild(parent, element, config.nextSibling);
    }
    if (refOwner) {
      element.$refOwnerId = refOwner.id;
    }
    if (reference && !ignoreRefs) {
      if (refOwner) {
        element.$reference = reference;
        refOwner.attachRef(reference, element, config);
      } else {
        if (!refs) {
          options = Object.assign({}, options);
          options.refs = refs = {};
        }
        refs[reference] = element;
        element.setAttribute("data-reference", reference);
      }
    }
    const className = config.className || config.class, keys = Object.keys(config);
    if (className) {
      element.setAttribute("class", DomClassList.normalize(className));
    }
    for (i = 0; i < keys.length; ++i) {
      name = keys[i];
      value = config[name];
      if ((key = elementCreateExpandos[name]) != null) {
        element[key || name] = value;
      } else if (!elementCreateProperties[name] && name && value != null) {
        element.setAttribute(name, value);
      }
    }
    if (!config["aria-hidden"] && !config.role && !config.tabIndex && !_DomHelper.isFocusable(element, true) && !element.htmlFor) {
      element.setAttribute("role", "presentation");
    }
    (_b = options == null ? void 0 : options.callback) == null ? void 0 : _b.call(options, {
      action: "newElement",
      domConfig: config,
      targetElement: element,
      syncId: refOwner ? reference : options.syncIdField && ((_a2 = config.dataset) == null ? void 0 : _a2[options.syncIdField])
    });
    if (returnAll === true) {
      options.returnAll = returnAll = [element];
    } else if (Array.isArray(returnAll)) {
      returnAll.push(element);
    }
    if (config.children) {
      if (syncIdField) {
        element.syncIdMap = {};
      }
      config.children.forEach((child) => {
        var _a3, _b2, _c;
        if (child) {
          if (typeof child === "string") {
            const textNode = document.createTextNode(child);
            if (refOwner) {
              textNode.$refOwnerId = refOwner.id;
            }
            element.appendChild(textNode);
          } else if (isNaN(child.nodeType)) {
            child.parent = element;
            if (!child.ns && config.ns) {
              child.ns = config.ns;
            }
            const childElement = DH2.createElement(child, {
              ...options,
              ignoreRefs: (_b2 = (_a3 = config.syncOptions) == null ? void 0 : _a3.ignoreRef) != null ? _b2 : ignoreChildRefs
            }), syncId = (_c = child.dataset) == null ? void 0 : _c[syncIdField];
            if (syncId != null) {
              element.syncIdMap[syncId] = childElement;
            }
            delete child.parent;
          } else {
            element.appendChild(child);
          }
        }
      });
    }
    element.lastDomConfig = config;
    const result = refs || returnAll || element;
    if (config.replaceElement) {
      config.replaceElement.replaceWith(result);
    }
    return result;
  }
  /**
   * Create element(s) from a template (html string). Note that
   * `textNode`s are discarded unless the `raw` option is passed
   * as `true`.
   *
   * If the template has a single root element, then the single element will be returned
   * unless the `array` option is passed as `true`.
   *
   * If there are multiple elements, then an Array will be returned.
   *
   * @param {String} template The HTML string from which to create DOM content
   * @param {Object} [options] An object containing properties to modify how the DOM is created and returned.
   * @param {Boolean} [options.array] `true` to return an array even if there's only one resulting element.
   * @param {Boolean} [options.raw] Return all child nodes, including text nodes.
   * @param {Boolean} [options.fragment] Return a DocumentFragment.
   * @private
   */
  static createElementFromTemplate(template, options = emptyObject4) {
    const { array, raw, fragment } = options;
    let result;
    if (DH2.supportsTemplate) {
      (templateElement || (templateElement = doc.createElement("template"))).innerHTML = template;
      result = templateElement.content;
      if (fragment) {
        return result.cloneNode(true);
      }
    } else {
      result = (htmlParser || (htmlParser = new DOMParser())).parseFromString(template, "text/html").body;
      if (fragment) {
        const nodes = result.childNodes;
        result = document.createDocumentFragment();
        while (nodes.length) {
          result.appendChild(nodes[0]);
        }
        return result;
      }
    }
    if (raw) {
      result = result.childNodes;
    } else {
      result = result.children;
    }
    return result.length === 1 && !array ? result[0] : arraySlice.call(result);
  }
  /**
   * Dispatches a MouseEvent of the passed type to the element at the visible centre of the passed element.
   * @param {HTMLElement} targetElement The element whose center receives the mouse event.
   * @param {String} [type=contextmenu] The mouse event type to dispatch.
   * @internal
   */
  static triggerMouseEvent(targetElement, type = "contextmenu") {
    const isInView = this.isInView(targetElement), targetRect = isInView || Rectangle.from(targetElement), targetPoint = targetRect.center, contextmenuEvent = new MouseEvent(type, {
      clientX: targetPoint.x,
      clientY: targetPoint.y,
      bubbles: true
    });
    targetElement.dispatchEvent(contextmenuEvent);
  }
  /**
   * Inserts an `element` at first position in `into`.
   * @param {HTMLElement} into Parent element
   * @param {HTMLElement} element Element to insert, or an element config passed on to createElement()
   * @returns {HTMLElement}
   * @category Creation
   */
  static insertFirst(into, element) {
    if (element && element.nodeType !== ELEMENT_NODE && element.tag) {
      element = DH2.createElement(element);
    }
    return into.insertBefore(element, into.firstElementChild);
  }
  /**
   * Inserts a `element` before `beforeElement` in `into`.
   * @param {HTMLElement} into Parent element
   * @param {HTMLElement} element Element to insert, or an element config passed on to createElement()
   * @param {HTMLElement} beforeElement Element before which passed element should be inserted
   * @returns {HTMLElement}
   * @category Creation
   */
  static insertBefore(into, element, beforeElement) {
    if (element && element.nodeType !== ELEMENT_NODE && element.tag) {
      element = DH2.createElement(element);
    }
    return beforeElement ? into.insertBefore(element, beforeElement) : DH2.insertFirst(into, element);
  }
  static insertAt(parentElement, newElement, index) {
    const siblings = Array.from(parentElement.children);
    if (index >= siblings.length) {
      return DH2.append(parentElement, newElement);
    }
    const beforeElement = siblings[index];
    return DH2.insertBefore(parentElement, newElement, beforeElement);
  }
  /**
   * Appends element to parentElement.
   * @param {HTMLElement} parentElement Parent element
   * @param {HTMLElement|DomConfig|String} elementOrConfig Element to insert, or an element config passed on to
   * `createElement()`, or an html string passed to `createElementFromTemplate()`
   * @returns {HTMLElement}
   * @category Creation
   */
  static append(parentElement, elementOrConfig) {
    if (elementOrConfig.forEach) {
      if (Array.isArray(elementOrConfig)) {
        elementOrConfig = elementOrConfig.map((elementOrConfig2) => elementOrConfigToElement(elementOrConfig2));
      }
      if (parentElement.append) {
        parentElement.append(...elementOrConfig);
      } else {
        const docFrag = document.createDocumentFragment();
        elementOrConfig.forEach(function(child) {
          docFrag.appendChild(child);
        });
        parentElement.appendChild(docFrag);
      }
      return elementOrConfig;
    } else {
      return parentElement.appendChild(elementOrConfigToElement(elementOrConfig));
    }
  }
  //endregion
  //region Get position
  /**
   * Returns the element's `transform translateX` value in pixels.
   * @param {HTMLElement} element
   * @returns {Number} X transform
   * @category Position, get
   */
  static getTranslateX(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateXRe.exec(transformStyle);
    if (matches) {
      return parseFloat(matches[2]);
    } else {
      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(DH2.getStyleValue(element, "transform"));
      return matches ? parseFloat(matches[1] || matches[3]) : 0;
    }
  }
  /**
   * Returns the element's `transform translateY` value in pixels.
   * @param {HTMLElement} element
   * @returns {Number} Y coordinate
   * @category Position, get
   */
  static getTranslateY(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateYRe.exec(transformStyle);
    if (matches) {
      const y = parseFloat(matches[matches[1] === "Y" ? 2 : 3]);
      return isNaN(y) ? 0 : y;
    } else {
      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(DH2.getStyleValue(element, "transform"));
      return matches ? parseFloat(matches[2] || matches[4]) : 0;
    }
  }
  /**
   * Gets both X and Y coordinates as an array [x, y]
   * @param {HTMLElement} element
   * @returns {Number[]} [x, y]
   * @category Position, get
   */
  static getTranslateXY(element) {
    return [DH2.getTranslateX(element), DH2.getTranslateY(element)];
  }
  /**
   * Get elements X offset within a containing element
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number} X offset
   * @category Position, get
   */
  static getOffsetX(element, container = null) {
    return container ? element.getBoundingClientRect().left - container.getBoundingClientRect().left : element.offsetLeft;
  }
  /**
   * Get elements Y offset within a containing element
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number} Y offset
   * @category Position, get
   */
  static getOffsetY(element, container = null) {
    return container ? element.getBoundingClientRect().top - container.getBoundingClientRect().top : element.offsetTop;
  }
  /**
   * Gets elements X and Y offset within containing element as an array [x, y]
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number[]} [x, y]
   * @category Position, get
   */
  static getOffsetXY(element, container = null) {
    return [DH2.getOffsetX(element, container), DH2.getOffsetY(element, container)];
  }
  /**
   * Focus element without scrolling the element into view.
   * @param {HTMLElement} element
   */
  static focusWithoutScrolling(element) {
    function resetScroll(scrollHierarchy) {
      scrollHierarchy.forEach(({ element: element2, scrollLeft, scrollTop }) => {
        if (element2.scrollLeft !== scrollLeft) {
          element2.scrollLeft = scrollLeft;
        }
        if (element2.scrollTop !== scrollTop) {
          element2.scrollTop = scrollTop;
        }
      });
    }
    const preventScrollSupported = !BrowserHelper.isSafari;
    if (preventScrollSupported) {
      element.focus({ preventScroll: true });
    } else {
      const parents = DH2.getParents(element), scrollHierarchy = parents.map((parent) => ({
        element: parent,
        scrollLeft: parent.scrollLeft,
        scrollTop: parent.scrollTop
      }));
      element.focus();
      setTimeout(() => resetScroll(scrollHierarchy), 0);
    }
  }
  /**
   * Get elements X position on page
   * @param {HTMLElement} element
   * @returns {Number}
   * @category Position, get
   */
  static getPageX(element) {
    return element.getBoundingClientRect().left + win.pageXOffset;
  }
  /**
   * Get elements Y position on page
   * @param {HTMLElement} element
   * @returns {Number}
   * @category Position, get
   */
  static getPageY(element) {
    return element.getBoundingClientRect().top + win.pageYOffset;
  }
  /**
   * Returns extremal (min/max) size (height/width) of the element in pixels
   * @param {HTMLElement} element
   * @param {String} style minWidth/minHeight/maxWidth/maxHeight
   * @returns {Number}
   * @internal
   */
  static getExtremalSizePX(element, style) {
    const prop = StringHelper.hyphenate(style), measure = prop.split("-")[1];
    let value = DH2.getStyleValue(element, prop);
    if (/%/.test(value)) {
      if (element.parentElement) {
        value = parseInt(DH2.getStyleValue(element.parentElement, measure), 10);
      } else {
        value = NaN;
      }
    } else {
      value = parseInt(value, 10);
    }
    return value;
  }
  //endregion
  //region Set position
  /**
   * Set element's `scale`.
   * @param {HTMLElement} element
   * @param {Number} scaleX The value by which the element should be scaled in the X axis (0 to 1)
   * @param {Number} [scaleY] The value by which the element should be scaled in the Y axis (0 to 1).
   * Defaults to `scaleX`
   * @category Position, set
   * @internal
   */
  static setScale(element, scaleX, scaleY = scaleX) {
    const t = DH2.getStyleValue(element, "transform").split(/,\s*/);
    if (t.length > 1) {
      if (t[0].startsWith("matrix3d")) {
        t[0] = `matrix3d(${scaleX}`;
        t[5] = scaleY;
      } else {
        t[0] = `matrix(${scaleX}`;
        t[3] = scaleY;
      }
      element.style.transform = t.join(",");
    } else {
      element.style.transform = `scale(${scaleX}, ${scaleY})`;
    }
  }
  /**
   * Set element's `X` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} x The value by which the element should be translated from its default position.
   * @category Position, set
   */
  static setTranslateX(element, x) {
    const t = DH2.getStyleValue(element, "transform").split(/,\s*/);
    x = DH2.roundPx(x);
    if (t.length > 1) {
      t[t[0].startsWith("matrix3d") ? 12 : 4] = x;
      element.style.transform = t.join(",");
    } else {
      element.style.transform = `translateX(${x}px)`;
    }
  }
  /**
   * Set element's `Y` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} y  The value by which the element should be translated from its default position.
   * @category Position, set
   */
  static setTranslateY(element, y) {
    const t = DH2.getStyleValue(element, "transform").split(/,\s*/);
    y = DH2.roundPx(y);
    if (t.length > 1) {
      t[t[0].startsWith("matrix3d") ? 13 : 5] = y;
      element.style.transform = t.join(",") + ")";
    } else {
      element.style.transform = `translateY(${y}px)`;
    }
  }
  /**
   * Set element's style `top`.
   * @param {HTMLElement} element
   * @param {Number|String} y The top position. If numeric, `'px'` is used as the unit.
   * @category Position, set
   */
  static setTop(element, y) {
    DH2.setLength(element, "top", y);
  }
  /**
   * Set element's style `left`.
   * @param {HTMLElement} element
   * @param {Number|String} x The top position. If numeric, `'px'` is used as the unit.
   * @category Position, set
   */
  static setLeft(element, x) {
    DH2.setLength(element, "left", x);
  }
  static setTopLeft(element, y, x) {
    DH2.setLength(element, "top", y);
    DH2.setLength(element, "left", x);
  }
  static setRect(element, { x, y, width, height }) {
    DH2.setTopLeft(element, y, x);
    DH2.setLength(element, "width", width);
    DH2.setLength(element, "height", height);
  }
  /**
   * Set elements `X` and `Y` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} [x] The `X translation.
   * @param {Number} [y] The `Y translation.
   * @category Position, set
   */
  static setTranslateXY(element, x, y) {
    if (x == null) {
      return DH2.setTranslateY(element, y);
    }
    if (y == null) {
      return DH2.setTranslateX(element, x);
    }
    x = DH2.roundPx(x);
    y = DH2.roundPx(y);
    const t = DH2.getStyleValue(element, "transform").split(/,\s*/), is3d = t[0].startsWith("matrix3d");
    if (t.length > 1) {
      t[is3d ? 12 : 4] = x;
      t[is3d ? 13 : 5] = y;
      element.style.transform = t.join(",") + ")";
    } else {
      element.style.transform = `translate(${x}px, ${y}px)`;
    }
  }
  /**
   * Increase `X` translation
   * @param {HTMLElement} element
   * @param {Number} x The number of pixels by which to increase the element's `X` translation.
   * @category Position, set
   */
  static addTranslateX(element, x) {
    DH2.setTranslateX(element, DH2.getTranslateX(element) + x);
  }
  /**
   * Increase `Y` position
   * @param {HTMLElement} element
   * @param {Number} y The number of pixels by which to increase the element's `Y` translation.
   * @category Position, set
   */
  static addTranslateY(element, y) {
    DH2.setTranslateY(element, DH2.getTranslateY(element) + y);
  }
  /**
   * Increase X position
   * @param {HTMLElement} element
   * @param {Number} x
   * @category Position, set
   */
  static addLeft(element, x) {
    DH2.setLeft(element, DH2.getOffsetX(element) + x);
  }
  /**
   * Increase Y position
   * @param {HTMLElement} element
   * @param {Number} y
   * @category Position, set
   */
  static addTop(element, y) {
    DH2.setTop(element, DH2.getOffsetY(element) + y);
  }
  /**
   * Align the passed element with the passed target according to the align spec.
   * @param {HTMLElement} element The element to align.
   * @param {HTMLElement|Core.helper.util.Rectangle} target The target element or rectangle to align to
   * @param {AlignSpec} [alignSpec] See {@link Core.helper.util.Rectangle#function-alignTo} Defaults to `{ align : 't0-t0' }`
   * @param {Boolean} [round] Round the calculated Rectangles (for example if dealing with scrolling which
   * is integer based).
   */
  static alignTo(element, target, alignSpec = t0t0, round2) {
    target = target instanceof Rectangle ? target : Rectangle.from(target, true);
    const elXY = DH2.getTranslateXY(element), elRect = Rectangle.from(element, true);
    if (round2) {
      elRect.roundPx();
      target.roundPx();
    }
    const targetRect = elRect.alignTo(Object.assign(alignSpec, {
      target
    }));
    DH2.setTranslateXY(element, elXY[0] + targetRect.x - elRect.x, elXY[1] + targetRect.y - elRect.y);
  }
  //endregion
  //region Styles & CSS
  /**
   * Returns a style value or values for the passed element.
   * @param {HTMLElement} element The element to read styles from
   * @param {String|String[]} propName The property or properties to read
   * @param {Boolean} [inline=false] Pass as `true` to read the element's inline style.
   * Note that this could return inaccurate results if CSS rules apply to this element.
   * @returns {String|Object} The value or an object containing the values keyed by the requested property name.
   * @category CSS
   */
  static getStyleValue(element, propName, inline, pseudo) {
    const styles = inline ? element.style : element.ownerDocument.defaultView.getComputedStyle(element, pseudo);
    if (Array.isArray(propName)) {
      const result = {};
      for (const prop of propName) {
        result[prop] = styles.getPropertyValue(StringHelper.hyphenate(prop));
      }
      return result;
    }
    return styles.getPropertyValue(StringHelper.hyphenate(propName));
  }
  /**
   * Returns an object with the parse style values for the top, right, bottom, and left
   * components of the given edge style.
   *
   * The return value is an object with `top`, `right`, `bottom`, and `left` properties
   * for the respective components of the edge style, as well as `width` (the sum of
   * `left` and `right`) and `height` (the sum of `top` and `bottom`).
   *
   * @param {HTMLElement} element
   * @param {String} edgeStyle The element's desired edge style such as 'padding', 'margin',
   * or 'border'.
   * @param {String} [edges='trbl'] A string with one character codes for each edge. Only
   * those edges will be populated in the returned object. By default, all edges will be
   * populated.
   * @returns {Object}
   */
  static getEdgeSize(element, edgeStyle, edges) {
    const suffix = edgeStyle === "border" ? "-width" : "", ret = {
      raw: {}
    };
    for (const edge of ["top", "right", "bottom", "left"]) {
      if (!edges || edges.includes(edge[0])) {
        ret[edge] = parseFloat(
          ret.raw[edge] = DH2.getStyleValue(element, `${edgeStyle}-${edge}${suffix}`)
        );
      }
    }
    ret.width = (ret.left || 0) + (ret.right || 0);
    ret.height = (ret.top || 0) + (ret.bottom || 0);
    return ret;
  }
  /**
   * Splits a style string up into object form. For example `'font-weight:bold;font-size:150%'`
   * would convert to
   *
   * ```javascript
   * {
   *     font-weight : 'bold',
   *     font-size : '150%'
   * }
   * ```
   * @param {String} style A DOM style string
   * @returns {Object} the style declaration in object form.
   */
  static parseStyle(style) {
    if (typeof style === "string") {
      const styles = style.split(semicolonRe);
      style = {};
      for (let i = 0, { length } = styles; i < length; i++) {
        const propVal = styles[i].split(colonRe);
        style[propVal[0]] = propVal[1];
      }
    }
    return style || {};
  }
  /**
   * Applies specified style to the passed element. Style can be an object or a string.
   * @param {HTMLElement} element Target element
   * @param {String|Object} style Style to apply, 'border: 1px solid black' or { border: '1px solid black' }
   * @param {Boolean} [overwrite] Specify `true` to replace style instead of applying changes
   * @category CSS
   */
  static applyStyle(element, style, overwrite = false) {
    if (typeof style === "string") {
      if (overwrite) {
        if (style.length || element.style.cssText.length) {
          element.style.cssText = style;
        }
      } else {
        element.style.cssText += style;
      }
    } else if (style) {
      if (overwrite) {
        element.style.cssText = "";
      }
      if (style.style && typeof style.style !== "string") {
        style = ObjectHelper.assign({}, style, style.style);
      }
      let key, value;
      for (key in style) {
        if (!styleIgnoreProperties[key]) {
          [key, value] = DH2.unitize(key, style[key]);
          if (value == null) {
            element.style.removeProperty(key);
          } else {
            element.style.setProperty(key, value);
          }
        }
      }
      if (typeof style.style === "string") {
        element.style.cssText += style.style;
      }
    }
  }
  static getCSSText(style) {
    if (typeof style === "string") {
      return style;
    }
    let cssText = "";
    for (const key in style) {
      if (!styleIgnoreProperties[key]) {
        cssText += `${StringHelper.hyphenate(key)}:${style[key]};`;
      }
    }
    return cssText;
  }
  /**
   * Add multiple classes to elements classList.
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @deprecated Since 5.0. Use {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList/add add} method
   * for {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/classList Element.classlist}
   * @category CSS
   */
  static addClasses(element, classes) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.addClasses should be replaced by native classList.add");
    element.classList.add(...classes);
  }
  /**
   * Remove multiple classes from elements classList.
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @deprecated Since 5.0. Use {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList/remove remove} method
   * for {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/classList Element.classlist}
   * @category CSS
   */
  static removeClasses(element, classes) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.removeClasses should be replaced by native classList.remove");
    element.classList.remove(...classes);
  }
  /**
   * Toggle multiple classes in elements classList. Helper for toggling multiple classes at once.
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @param {Boolean} [force] Specify true to add classes, false to remove. Leave blank to toggle
   * @category CSS
   */
  static toggleClasses(element, classes, force = null) {
    classes = ArrayHelper.asArray(classes);
    if (force === true) {
      element.classList.add(...classes);
    } else if (force === false) {
      element.classList.remove(...classes);
    } else {
      classes.forEach((cls) => element.classList.toggle(cls));
    }
  }
  /**
   * Adds a CSS class to an element during the specified duration
   * @param {HTMLElement} element Target element
   * @param {String} cls CSS class to add temporarily
   * @param {Number} duration Duration in ms, 0 means cls will not be applied
   * @param {Core.mixin.Delayable} delayable The delayable to tie the setTimeout call to
   * @privateparam {String} name Timer name
   * @typings delayable -> {typeof Delayable}
   * @category CSS
   */
  static addTemporaryClass(element, cls, duration, delayable = globalThis, name = cls) {
    if (duration > 0) {
      element.classList.add(cls);
      delayable.setTimeout({
        fn: (cls2) => element.classList.remove(cls2),
        delay: duration,
        name,
        args: [cls],
        cancelOutstanding: true
      });
    }
  }
  /**
   * Reads computed style from the element and returns transition duration for a given property in milliseconds
   * @param {HTMLElement} element Target DOM element
   * @param {String} property Animated property name
   * @returns {Number} Duration in ms
   * @internal
   */
  static getPropertyTransitionDuration(element, property) {
    const style = globalThis.getComputedStyle(element), properties = style.transitionProperty.split(", "), durations = style.transitionDuration.split(", "), index = properties.indexOf(StringHelper.hyphenate(property));
    let result;
    if (index !== -1) {
      result = parseFloat(durations[index]) * 1e3;
    }
    return result;
  }
  /**
   * Reads computed style from the element and returns the animation duration for any
   * attached animation in milliseconds
   * @param {HTMLElement} element Target DOM element
   * @returns {Number} Duration in ms
   * @internal
   */
  static getAnimationDuration(element) {
    return parseFloat(DH2.getStyleValue(element, "animation-duration")) * 1e3;
  }
  //endregion
  //region Effects
  /**
   * Highlights the passed element or Rectangle according to the theme's highlighting rules.
   * Usually an animated framing effect.
   *
   * The framing effect is achieved by adding the CSS class `b-fx-highlight` which references
   * a `keyframes` animation named `b-fx-highlight-animation`. You may override the animation
   * name referenced, or the animation itself in your own CSS.
   *
   * @param {HTMLElement|Core.helper.util.Rectangle} element The element or Rectangle to highlight.
   */
  static highlight(element, delayable = globalThis) {
    if (element instanceof Rectangle) {
      return element.highlight();
    }
    return new Promise((resolve) => {
      delayable.setTimeout(() => {
        element.classList.add("b-fx-highlight");
        delayable.setTimeout(() => {
          element.classList.remove("b-fx-highlight");
          resolve();
        }, 1e3);
      }, 0);
    });
  }
  //endregion
  //region Measuring / Scrollbar
  /**
   * Measures the scrollbar width using a hidden div. Caches result
   * @property {Number}
   * @readonly
   */
  static get scrollBarWidth() {
    if (scrollBarWidth === null) {
      const element = scrollBarMeasureElement || (scrollBarMeasureElement = DH2.createElement({
        parent: doc.documentElement,
        className: "b-scrollbar-measure-element",
        style: "position:absolute;top:-9999em;height:100px;overflow-y:scroll"
      }));
      if (element.parentNode !== doc.documentElement) {
        doc.documentElement.appendChild(element);
      }
      scrollBarWidth = element.offsetWidth;
    }
    return scrollBarWidth;
  }
  static get scrollBarPadElement() {
    return {
      className: "b-yscroll-pad",
      children: [{
        className: "b-yscroll-pad-sizer"
      }]
    };
  }
  /**
   * Resets DomHelper.scrollBarWidth cache, triggering a new measurement next time it is read
   */
  static resetScrollBarWidth() {
    scrollBarWidth = null;
  }
  /**
   * Measures the text width using a hidden div
   * @param {String} text
   * @param {HTMLElement} sourceElement
   * @returns {Number} width
   * @category Measure
   */
  static measureText(text, sourceElement, useHTML = false, parentElement = void 0) {
    const offScreenDiv = DH2.getMeasureElement(sourceElement, parentElement);
    offScreenDiv[useHTML ? "innerHTML" : "innerText"] = text;
    const result = offScreenDiv.clientWidth;
    offScreenDiv.className = "";
    return result;
  }
  /**
   * Measures a relative size, such as a size specified in `em` units for the passed element.
   * @param {String} size The CSS size value to measure.
   * @param {HTMLElement} sourceElement
   * @param {Boolean} [round] Pass true to return exact width, not rounded value
   * @returns {Number} size The size in pixels of the passed relative measurement.
   * @category Measure
   */
  static measureSize(size, sourceElement, round2 = true) {
    if (!size) {
      return 0;
    }
    if (typeof size === "number") {
      return size;
    }
    if (!size.length) {
      return 0;
    }
    if (/^\d+(px)?$/.test(size)) {
      return parseInt(size);
    }
    if (sourceElement) {
      const offScreenDiv = DH2.getMeasureElement(sourceElement);
      offScreenDiv.innerHTML = "";
      offScreenDiv.style.width = DH2.setLength(size);
      const result = round2 ? offScreenDiv.offsetWidth : offScreenDiv.getBoundingClientRect().width;
      offScreenDiv.style.width = offScreenDiv.className = "";
      return result;
    }
    if (/^\d+em$/.test(size)) {
      return parseInt(size) * DEFAULT_FONT_SIZE;
    }
    return isNaN(size) ? 0 : parseInt(size);
  }
  // parentElement allows measurement to happen inside a specific element, allowing scoped css rules to match
  static getMeasureElement(sourceElement, parentElement = doc.body) {
    const sourceElementStyle = win.getComputedStyle(sourceElement), offScreenDiv = parentElement.offScreenDiv = parentElement.offScreenDiv || DH2.createElement({
      parent: parentElement,
      style: "position:fixed;top:-10000px;left:-10000px;visibility:hidden;contain:strict",
      className: "b-measure-element",
      children: [{
        style: "white-space:nowrap;display:inline-block;will-change:contents;width:auto;contain:none"
      }]
    }, { returnAll: true })[1];
    fontProps.forEach((prop) => {
      if (offScreenDiv.style[prop] !== sourceElementStyle[prop]) {
        offScreenDiv.style[prop] = sourceElementStyle[prop];
      }
    });
    offScreenDiv.className = sourceElement.className;
    if (offScreenDiv.parentElement.parentElement !== parentElement) {
      parentElement.appendChild(offScreenDiv.parentElement);
    }
    return offScreenDiv;
  }
  /**
   * Strips the tags from a html string, returning text content.
   *
   * ```javascript
   * DomHelper.stripTags('<div class="custom"><b>Bold</b><i>Italic</i></div>'); // -> BoldItalic
   * ```
   *
   * @internal
   * @param {String} htmlString HTML string
   * @returns {String} Text content
   */
  static stripTags(htmlString) {
    const parser = DH2.$domParser || (DH2.$domParser = new DOMParser()), doc2 = parser.parseFromString(htmlString, "text/html");
    return doc2.body.textContent;
  }
  //endregion
  //region Sync
  /**
   * Sync one source element attributes, children etc. to a target element. Source element can be specified as a html
   * string or an actual HTMLElement.
   *
   * NOTE: This function is superseded by {@link Core/helper/DomSync#function-sync-static DomSync.sync()}, which works
   * with DOM configs. For most usecases, use it instead.
   *
   * @param {String|HTMLElement} sourceElement Source "element" to copy from
   * @param {HTMLElement} targetElement Target element to apply to, can also be specified as part of the config object
   * @returns {HTMLElement} Returns the updated targetElement (which is also updated in place)
   */
  static sync(sourceElement, targetElement) {
    if (typeof sourceElement === "string") {
      if (sourceElement === "") {
        targetElement.innerHTML = "";
        return;
      } else {
        sourceElement = DH2.createElementFromTemplate(sourceElement);
      }
    }
    DH2.performSync(sourceElement, targetElement);
    return targetElement;
  }
  // Internal helper used for recursive syncing
  static performSync(sourceElement, targetElement) {
    if (sourceElement.outerHTML !== targetElement.outerHTML) {
      DH2.syncAttributes(sourceElement, targetElement);
      DH2.syncContent(sourceElement, targetElement);
      DH2.syncChildren(sourceElement, targetElement);
      return true;
    }
    return false;
  }
  // Attributes as map { attr : value, ... }, either from an html element or from a config
  static getSyncAttributes(element) {
    const attributes = {}, names = [];
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      if (attr.specified) {
        const name = attr.name.toLowerCase();
        attributes[name] = attr.value;
        names.push(name);
      }
    }
    return { attributes, names };
  }
  /**
   * Syncs attributes from sourceElement to targetElement.
   * @private
   * @param {HTMLElement} sourceElement
   * @param {HTMLElement} targetElement
   */
  static syncAttributes(sourceElement, targetElement) {
    const {
      attributes: sourceAttributes,
      names: sourceNames
    } = DH2.getSyncAttributes(sourceElement), {
      attributes: targetAttributes,
      names: targetNames
    } = DH2.getSyncAttributes(targetElement), hasDataset = sourceNames.includes("dataset"), toAdd = sourceNames.filter((attr) => !targetNames.includes(attr)), toRemove = targetNames.filter((attr) => !sourceNames.includes(attr) && (!hasDataset || !attr.startsWith("data-"))), toSync = sourceNames.filter((attr) => targetNames.includes(attr));
    if (toAdd.length > 0) {
      for (let i = 0; i < toAdd.length; i++) {
        const attr = toAdd[i];
        if (attr === "style") {
          DH2.applyStyle(targetElement, sourceAttributes.style, true);
        } else if (attr === "dataset") {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        } else {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
    if (toRemove.length > 0) {
      for (let i = 0; i < toRemove.length; i++) {
        targetElement.removeAttribute(toRemove[i]);
      }
    }
    if (toSync.length > 0) {
      for (let i = 0; i < toSync.length; i++) {
        const attr = toSync[i];
        if (attr === "style") {
          DH2.applyStyle(targetElement, sourceAttributes.style, true);
        } else if (attr === "dataset") {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        } else if (attr === "class" && (sourceAttributes.class.isDomClassList || typeof sourceAttributes.class === "object")) {
          let classList;
          if (sourceAttributes.class.isDomClassList) {
            classList = sourceAttributes.class;
          } else {
            classList = new DomClassList(sourceAttributes.class);
          }
          if (!classList.isEqual(targetAttributes.class)) {
            targetElement.setAttribute("class", classList);
          }
        } else if (targetAttributes[attr] !== sourceAttributes[attr]) {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
  }
  /**
   * Sync content (innerText) from sourceElement to targetElement
   * @private
   * @param {HTMLElement} sourceElement
   * @param {HTMLElement} targetElement
   */
  static syncContent(sourceElement, targetElement) {
    if (DH2.getChildElementCount(sourceElement) === 0) {
      targetElement.innerText = sourceElement.innerText;
    }
  }
  static setInnerText(targetElement, text) {
    const { firstChild } = targetElement;
    if ((firstChild == null ? void 0 : firstChild.nodeType) === Element.TEXT_NODE) {
      firstChild.data = text;
    } else {
      targetElement.textContent = text;
    }
  }
  /**
   * Sync traversing children
   * @private
   * @param {HTMLElement} sourceElement Source element
   * @param {HTMLElement} targetElement Target element
   */
  static syncChildren(sourceElement, targetElement) {
    const me = this, sourceNodes = arraySlice.call(sourceElement.childNodes), targetNodes = arraySlice.call(targetElement.childNodes);
    while (sourceNodes.length) {
      const sourceNode = sourceNodes.shift(), targetNode = targetNodes.shift();
      if (sourceNode && sourceNode.nodeType !== TEXT_NODE && sourceNode.nodeType !== ELEMENT_NODE) {
        throw new Error(`Source node type ${sourceNode.nodeType} not supported by DomHelper.sync()`);
      }
      if (targetNode && targetNode.nodeType !== TEXT_NODE && targetNode.nodeType !== ELEMENT_NODE) {
        throw new Error(`Target node type ${targetNode.nodeType} not supported by DomHelper.sync()`);
      }
      if (!targetNode) {
        targetElement.appendChild(sourceNode);
      } else {
        if (sourceNode.nodeType === targetNode.nodeType) {
          if (sourceNode.nodeType === TEXT_NODE) {
            targetNode.data = sourceNode.data;
          } else {
            if (sourceNode.tagName === targetNode.tagName) {
              me.performSync(sourceNode, targetNode);
            } else {
              targetElement.insertBefore(sourceNode, targetNode);
              targetNode.remove();
            }
          }
        } else if (sourceNode.nodeType === TEXT_NODE && targetNode.nodeType === ELEMENT_NODE) {
          targetElement.innerText = sourceNode.data.trim();
        } else {
          const logElement = sourceNode.parentElement || sourceNode;
          throw new Error(`Currently no support for transforming nodeType.
${logElement.outerHTML}`);
        }
      }
    }
    targetNodes.forEach((targetNode) => {
      targetNode.remove();
    });
  }
  /**
   * Replaces the passed element's `className` with the class names
   * passed in either Array or String format or Object.
   *
   * This method compares the existing class set with the incoming class set and
   * avoids mutating the element's class name set if possible.
   *
   * This can avoid browser style invalidations.
   * @param {HTMLElement} element The element whose class list to synchronize.
   * @param {String[]|String|Object} newClasses The incoming class names to set on the element.
   * @returns {Boolean} `true` if the DOM class list was changed.
   * @category CSS
   */
  static syncClassList(element, newClasses) {
    const { classList } = element, isString = typeof newClasses === "string", newClsArray = isString ? newClasses.split(whiteSpaceRe2) : DomClassList.normalize(newClasses, "array"), classCount = newClsArray.length;
    let changed = classList.length !== classCount, i;
    for (i = 0; !changed && i < classCount; i++) {
      changed = !classList.contains(newClsArray[i]);
    }
    if (changed) {
      element.className = isString ? newClasses : newClsArray.join(" ");
    }
    return changed;
  }
  /**
   * Applies the key state of the passed object or DomClassList to the passed element.
   *
   * Properties with a falsy value mean that property name is *removed* as a class name.
   *
   * Properties with a truthy value mean that property name is *added* as a class name.
   *
   * This is different from {@link #function-syncClassList-static}. That sets the `className` of the element to the
   * sum of all its truthy keys, regardless of what the pre-existing value of the `className` was, and ignoring falsy
   * keys.
   *
   * This _selectively_ updates the classes in the `className`. If there is a truthy key, the name is added. If there
   * is a falsy key, the name is removed.
   * @param {HTMLElement} element The element to apply the class list to .
   * @param {Object|Core.helper.util.DomClassList} classes The classes to add or remove.
   * @returns {Boolean} `true` if the DOM class list was changed.
   * @category CSS
   */
  static updateClassList(element, classes) {
    const { classList } = element;
    let cls, add, changed = false;
    for (cls in classes) {
      add = Boolean(classes[cls]);
      if (classList.contains(cls) !== add) {
        classList[add ? "add" : "remove"](cls);
        changed = true;
      }
    }
    return changed;
  }
  /**
   * Changes the theme to the passed theme name if possible.
   *
   * Theme names are case insensitive. The `href` used is all lower case.
   *
   * To use this method, the `<link rel="stylesheet">` _must_ use the default,
   * Bryntum-supplied CSS files where the `href` end with `<themeName>.css`, so that
   * it can be found in the document, and switched out for a new link with
   * the a modified `href`. The new `href` will use the same path, just
   * with the `themeName` portion substituted for the new name.
   *
   * If no `<link>` with that name pattern can be found, an error will be thrown.
   *
   * If you use this method, you  must ensure that the theme files are
   * all accessible on your server.
   *
   * Because this is an asynchronous operation, a `Promise` is returned.
   * The theme change event is passed to the success function. If the
   * theme was not changed, because the theme name passed is the current theme,
   * nothing is passed to the success function.
   *
   * The theme change event contains two properties:
   *
   *  - `prev` The previous Theme name.
   *  - `theme` The new Theme name.
   *
   * @param {String} newThemeName the name of the theme that should be applied
   * @privateparam {String} [defaultTheme] Optional, the name of the theme that should be used in case of fail
   * @returns {Promise} A promise who's success callback receives the theme change
   * event if the theme in fact changed. If the theme `href` could not be loaded,
   * the failure callback is called, passing the error event caught.
   * @async
   */
  static setTheme(newThemeName, defaultTheme) {
    newThemeName = newThemeName.toLowerCase();
    const { head } = document, oldThemeName = DH2.getThemeInfo(defaultTheme).name.toLowerCase();
    let oldThemeLinks = head.querySelectorAll("[data-bryntum-theme]:not([data-loading])"), loaded = 0;
    if (oldThemeName === newThemeName) {
      return immediatePromise;
    }
    DH2.removeEachSelector(head, "#bryntum-theme[data-loading],link[data-bryntum-theme][data-loading]");
    const themeEvent = {
      theme: newThemeName,
      prev: oldThemeName
    };
    function replaceTheme(oldThemeLink, resolve, reject) {
      const newThemeLink = _DomHelper.createElement({
        tag: "link",
        rel: "stylesheet",
        dataset: {
          loading: true,
          bryntumTheme: true
        },
        href: oldThemeLink.href.replace(oldThemeName, newThemeName),
        nextSibling: oldThemeLink
      });
      newThemeLink.addEventListener("load", () => {
        delete newThemeLink.dataset.loading;
        themeInfo = null;
        if (++loaded === oldThemeLinks.length) {
          oldThemeLinks.forEach((link) => link.remove());
          GlobalEvents_default.trigger("theme", themeEvent);
          resolve(themeEvent);
        }
      });
      newThemeLink.addEventListener("error", (e) => {
        delete newThemeLink.dataset.loading;
        reject(e);
      });
    }
    if (oldThemeLinks.length) {
      return new Promise((resolve, reject) => {
        oldThemeLinks.forEach((oldThemeLink, i) => {
          replaceTheme(oldThemeLink, resolve, reject, i === oldThemeLinks.length - 1);
        });
      });
    } else {
      const oldThemeLink = head.querySelector("#bryntum-theme:not([data-loading])") || head.querySelector(`[href*="${oldThemeName}.css"]:not([data-loading])`);
      if (!(oldThemeLink == null ? void 0 : oldThemeLink.href.includes(`${oldThemeName}.css`))) {
        throw new Error(`Theme link for ${oldThemeName} not found`);
      }
      oldThemeLinks = [oldThemeLink];
      return new Promise((resolve, reject) => replaceTheme(oldThemeLink, resolve, reject));
    }
  }
  /**
   * A theme information object about the current theme.
   *
   * Currently, this has only one property:
   *
   *   - `name` The current theme name.
   * @property {Object}
   * @readonly
   */
  static get themeInfo() {
    return _DomHelper.getThemeInfo();
  }
  /**
   * A theme information object about the current theme.
   *
   * Currently this has only one property:
   *
   *   - `name` The current theme name.
   * @param {String} defaultTheme the name of the theme used as backup value in case of fail
   * @param {HTMLElement} contextElement The element for which to find the theme. If using a
   * web component, the theme will be encapsulated in the web component's encapsulated style
   * so a context element is required. If no web components are in use, this may be omitted and
   * `document.body` will be used.
   * @returns {Object} info, currently it contains only one property - 'name'.
   * @private
   */
  static getThemeInfo(defaultTheme) {
    if (!themeInfo) {
      const testDiv = DH2.createElement({
        parent: document.body,
        className: "b-theme-info"
      }), themeData = DH2.getStyleValue(testDiv, "content", false, ":before");
      if (themeData) {
        try {
          themeInfo = JSON.parse(themeData.replace(/^["']|["']$|\\/g, ""));
        } catch (e) {
          themeInfo = null;
        }
      }
      themeInfo = themeInfo || (defaultTheme ? { name: defaultTheme } : null);
      testDiv.remove();
    }
    return themeInfo;
  }
  //endregion
  //region Transition
  static async transition({
    element: outerElement,
    selector = "[data-dom-transition]",
    duration,
    action,
    thisObj = this,
    addTransition = {},
    removeTransition = {}
  }) {
    const scrollers = /* @__PURE__ */ new Set(), beforeElements = Array.from(outerElement.querySelectorAll(selector)), beforeMap = new Map(beforeElements.map((element) => {
      let depth = 0, parent = element.parentElement;
      while (parent && parent !== outerElement) {
        depth++;
        parent = parent.parentElement;
      }
      element.$depth = depth;
      if (element.scrollHeight > element.offsetHeight && getComputedStyle(element).overflow === "auto") {
        element.$scrollTop = element.scrollTop;
        scrollers.add(element);
      }
      const { parentElement } = element, globalBounds = Rectangle.from(element, outerElement), localBounds = Rectangle.from(element, parentElement), style = getComputedStyle(parentElement), borderLeftWidth = parseFloat(style.borderLeftWidth);
      if (borderLeftWidth) {
        globalBounds.left -= borderLeftWidth;
        localBounds.left -= borderLeftWidth;
      }
      return [
        element.id,
        { element, globalBounds, localBounds, depth, parentElement }
      ];
    }));
    action.call(thisObj);
    const afterElements = Array.from(outerElement.querySelectorAll(selector)), afterMap = new Map(afterElements.map((element) => {
      const globalBounds = Rectangle.from(element, outerElement), localBounds = Rectangle.from(element, element.parentElement), style = globalThis.getComputedStyle(element.parentElement), borderLeftWidth = parseFloat(style.borderLeftWidth);
      if (borderLeftWidth) {
        globalBounds.left -= borderLeftWidth;
        localBounds.left -= borderLeftWidth;
      }
      return [
        element.id,
        { element, globalBounds, localBounds }
      ];
    })), styleProps = ["position", "top", "left", "width", "height", "padding", "margin", "zIndex", "minWidth", "minHeight", "opacity", "overflow"];
    for (const [id, before] of beforeMap) {
      const after = afterMap.get(id);
      if (after) {
        const { element } = after, { style, parentElement } = element, zIndex = parseInt(DH2.getStyleValue(element, "zIndex")), {
          globalBounds,
          localBounds,
          depth,
          parentElement: beforeParent
        } = before, parentChanged = beforeParent !== parentElement;
        ObjectHelper.copyProperties(element.$initial = { parentElement }, style, styleProps);
        let bounds;
        if (parentChanged) {
          after.bounds = after.globalBounds;
          bounds = globalBounds;
          outerElement.appendChild(element);
        } else {
          after.bounds = after.localBounds;
          bounds = localBounds;
          beforeParent.appendChild(element);
        }
        let overflow = "hidden";
        if (scrollers.has(element)) {
          element.$scrollPlaceholder = DH2.createElement({
            parent: element,
            style: {
              height: element.scrollHeight
            }
          });
          overflow = "auto";
        }
        const targetStyle = {
          position: "absolute",
          top: `${bounds.top}px`,
          left: `${bounds.left}px`,
          width: `${bounds.width}px`,
          height: `${bounds.height}px`,
          minWidth: 0,
          minHeight: 0,
          margin: 0,
          zIndex: depth + (zIndex || 0),
          overflow
        };
        if (element.dataset.domTransition !== "preserve-padding") {
          targetStyle.padding = 0;
        }
        Object.assign(style, targetStyle);
        after.processed = true;
      } else {
        const { element, localBounds: bounds, depth, parentElement } = before;
        element.$initial = { removed: true };
        Object.assign(element.style, {
          position: "absolute",
          top: `${bounds.top}px`,
          left: `${bounds.left}px`,
          width: `${bounds.width}px`,
          height: `${bounds.height}px`,
          minWidth: 0,
          minHeight: 0,
          padding: 0,
          margin: 0,
          zIndex: depth,
          overflow: "hidden"
          // Looks weird with content sticking out if height is transitioned
        });
        parentElement.appendChild(element);
        afterMap.set(id, { element, bounds, removed: true, processed: true });
        afterElements.push(element);
      }
    }
    for (const [, after] of afterMap) {
      if (!after.processed) {
        const { element } = after, { style, parentElement } = element, bounds = after.bounds = after.localBounds;
        element.classList.add("b-dom-transition-adding");
        ObjectHelper.copyProperties(element.$initial = { parentElement }, style, styleProps);
        Object.assign(style, {
          position: "absolute",
          top: addTransition.top ? 0 : `${bounds.top}px`,
          left: addTransition.left ? 0 : `${bounds.left}px`,
          width: addTransition.width ? 0 : `${bounds.width}px`,
          height: addTransition.height ? 0 : `${bounds.height}px`,
          opacity: addTransition.opacity ? 0 : null,
          zIndex: parentElement.$depth + 1,
          overflow: "hidden"
          // Looks weird with content sticking out if height is transitioned
        });
      }
    }
    for (const element of scrollers) {
      element.scrollTop = element.$scrollTop;
    }
    outerElement.classList.add("b-dom-transition");
    outerElement.firstElementChild.offsetWidth;
    for (const [, { element, bounds: afterBounds, removed }] of afterMap) {
      if (removed) {
        Object.assign(element.style, {
          top: removeTransition.top ? 0 : `${afterBounds.top}px`,
          left: removeTransition.left ? 0 : `${afterBounds.left}px`,
          width: removeTransition.width ? 0 : `${afterBounds.width}px`,
          height: removeTransition.height ? 0 : `${afterBounds.height}px`,
          opacity: removeTransition.opacity ? 0 : element.$initial.opacity
        });
      } else {
        Object.assign(element.style, {
          top: `${afterBounds.top}px`,
          left: `${afterBounds.left}px`,
          width: `${afterBounds.width}px`,
          height: `${afterBounds.height}px`,
          opacity: element.$initial.opacity
        });
      }
    }
    await AsyncHelper.sleep(duration);
    outerElement.classList.remove("b-dom-transition");
    for (const element of afterElements) {
      if (element.$initial) {
        if (element.$initial.removed) {
          element.remove();
        } else {
          ObjectHelper.copyProperties(element.style, element.$initial, styleProps);
          if (element.$scrollPlaceholder) {
            element.$scrollPlaceholder.remove();
            delete element.$scrollPlaceholder;
          }
          element.classList.remove("b-dom-transition-adding");
          element.$initial.parentElement.appendChild(element);
        }
      }
    }
    for (const element of scrollers) {
      element.scrollTop = element.$scrollTop;
      delete element.$scrollTop;
    }
  }
  //endregion
  static async loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  static isNamedColor(color) {
    return color && !/^(#|hsl|rgb|hwb|lab|lch|oklab|oklch)/.test(color);
  }
  static createColorStyle(color) {
    return (color == null ? void 0 : color.length) ? this.isNamedColor(color) ? `var(--cal-color-${color})` : color : "";
  }
  //#region Salesforce hooks
  // Wrap NodeFilter to support salesforce
  static get NodeFilter() {
    return NodeFilter;
  }
  static addChild(parent, child, sibling) {
    parent.insertBefore(child, sibling);
  }
  static cloneStylesIntoShadowRoot(shadowRoot, removeExisting) {
    return new Promise((resolve, reject) => {
      if (removeExisting) {
        shadowRoot.querySelectorAll('style, link[rel="stylesheet"]').forEach((el) => el.remove());
      }
      const links = document.querySelectorAll('link[rel="stylesheet"]');
      let loadCount = 0;
      links.forEach((node) => {
        const clone = node.cloneNode();
        clone.addEventListener("load", () => {
          loadCount += 1;
          if (loadCount === links.length) {
            resolve();
          }
        });
        clone.addEventListener("error", (e) => {
          reject(clone.href);
        });
        shadowRoot.appendChild(clone);
      });
      document.querySelectorAll("style").forEach((node) => {
        const clone = node.cloneNode();
        clone.innerText = node.innerText;
        shadowRoot.appendChild(clone);
      });
      if (!links.length) {
        resolve();
      }
    });
  }
  //#endregion
};
var DH2 = DomHelper;
var clearTouchTimer;
var clearTouchEvent = () => DH2.isTouchEvent = false;
var setTouchEvent = () => {
  DH2.isTouchEvent = true;
  clearTimeout(clearTouchTimer);
  clearTouchTimer = setTimeout(clearTouchEvent, 400);
};
doc.addEventListener("touchstart", setTouchEvent, true);
doc.addEventListener("touchend", setTouchEvent, true);
DH2.canonicalStyles = canonicalStyles;
DH2.supportsTemplate = "content" in doc.createElement("template");
DH2.elementPropKey = elementPropKey;
DH2.numberRe = numberRe;
if (!("children" in Node.prototype)) {
  const elementFilter = (node) => node.nodeType === node.ELEMENT_NODE;
  Object.defineProperty(Node.prototype, "children", {
    get: function() {
      return Array.prototype.filter.call(this.childNodes, elementFilter);
    }
  });
}
if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s) {
    const matches = (this.document || this.ownerDocument).querySelectorAll(s);
    let i = matches.length;
    while (--i >= 0 && matches.item(i) !== this) {
    }
    return i > -1;
  };
}
if (win.Element && !Element.prototype.closest) {
  Node.prototype.closest = Element.prototype.closest = function(s) {
    let el = this;
    if (!doc.documentElement.contains(el))
      return null;
    do {
      if (el.matches(s))
        return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === el.ELEMENT_NODE);
    return null;
  };
} else {
  Node.prototype.closest = function(selector) {
    var _a2;
    return (_a2 = this.parentNode) == null ? void 0 : _a2.closest(selector);
  };
}
(function(arr) {
  arr.forEach(function(item) {
    if (Object.prototype.hasOwnProperty.call(item, "remove")) {
      return;
    }
    Object.defineProperty(item, "remove", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function remove() {
        this.parentNode && this.parentNode.removeChild(this);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
globalThis.addEventListener("resize", () => scrollBarWidth = null);
DomHelper._$name = "DomHelper";

// ../Core/lib/Core/helper/util/Rectangle.js
var zeroBased;
var allBorders = ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"];
var allMargins = ["margin-top", "margin-right", "margin-bottom", "margin-left"];
var allPaddings = ["padding-top", "padding-right", "padding-bottom", "padding-left"];
var borderNames = {
  t: "border-top-width",
  r: "border-right-width",
  b: "border-bottom-width",
  l: "border-left-width"
};
var paddingNames = {
  t: "padding-top",
  r: "padding-right",
  b: "padding-bottom",
  l: "padding-left"
};
var alignSpecRe = /^([trblc])(\d*)-([trblc])(\d*)$/i;
var alignPointRe = /^([trblc])(\d*)$/i;
var edgeNames = [
  "top",
  "right",
  "bottom",
  "left"
];
var edgeIndices = {
  t: 0,
  r: 1,
  b: 2,
  l: 3
};
var defaultAlignments = [
  "b-t",
  "l-r",
  "t-b",
  "r-l"
];
var edgeAligments = {
  bt: 1,
  tb: 1,
  lr: 2,
  rl: 2
};
var zeroOffsets = Object.freeze([0, 0]);
var matchDimensions = ["width", "height"];
var parseEdges = (top, right = top, bottom = top, left = right) => {
  return Array.isArray(top) ? parseEdges.apply(null, top) : [top, right, bottom, left];
};
var emptyArray2 = Object.freeze([]);
function parseAlign(alignSpec, rtl) {
  const parts = alignSpecRe.exec(alignSpec), myEdge = parts[1], targetEdge = parts[3], mO = parseInt(parts[2] || 50), tO = parseInt(parts[4] || 50), myOffset = rtl && !(edgeIndices[myEdge] & 1) ? 100 - mO : mO, targetOffset = rtl && !(edgeIndices[targetEdge] & 1) ? 100 - tO : tO, edgeAligned = edgeAligments[myEdge + targetEdge];
  return {
    myAlignmentPoint: myEdge + myOffset,
    // l0
    myEdge,
    // l
    myOffset,
    // 0
    targetAlignmentPoint: targetEdge + targetOffset,
    // r0
    targetEdge,
    // r
    targetOffset,
    // 0
    startZone: edgeIndices[targetEdge],
    // 1 - start trying zone 1 in TRBL order
    edgeAligned
    // Edge-to-edge align requested
  };
}
function flipAlign(align) {
  return `${edgeNames[(edgeIndices[align.myEdge] + 2) % 4][0]}${align.myOffset}-${edgeNames[(edgeIndices[align.targetEdge] + 2) % 4][0]}${align.targetOffset}`;
}
function createOffsets(offset) {
  if (offset == null) {
    return zeroOffsets;
  } else if (typeof offset === "number") {
    return [offset, offset];
  }
  return offset;
}
var Rectangle = class _Rectangle {
  /**
   * Constructs a Rectangle
   * @param {Number} x The X coordinate
   * @param {Number} y The Y coordinate
   * @param {Number} width The width
   * @param {Number} height The height
   */
  constructor(x, y, width, height) {
    // Class does not extend Base, so we need to define this
    __publicField(this, "isRectangle", true);
    ObjectHelper.assertNumber(x, "Rectangle.x");
    ObjectHelper.assertNumber(y, "Rectangle.y");
    ObjectHelper.assertNumber(width, "Rectangle.width");
    ObjectHelper.assertNumber(height, "Rectangle.height");
    const me = this;
    if (width < 0) {
      x += width;
      width = -width;
    }
    if (height < 0) {
      y += height;
      height = -height;
    }
    me._x = x;
    me._y = y;
    me._width = width;
    me._height = height;
  }
  /**
   * Returns the Rectangle in document based coordinates of the passed element.
   *
   * *Note:* If the element passed is the `document` or `window` the `window`'s
   * rectangle is returned which is always at `[0, 0]` and encompasses the
   * browser's entire document viewport.
   * @param {HTMLElement|Core.widget.Widget|Core.widget.Mask} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll=false] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static from(element, relativeTo, ignorePageScroll) {
    if (typeof element === "string") {
      element = document.querySelector(element);
    } else if ((element == null ? void 0 : element.nodeType) === Node.DOCUMENT_FRAGMENT_NODE) {
      element = element.host || element.ownerDocument;
    }
    if (typeof relativeTo === "string") {
      relativeTo = document.querySelector(relativeTo);
    }
    if (element == null || element.isRectangle) {
      return element;
    }
    element = element.element || element;
    if (ignorePageScroll === void 0 && typeof relativeTo === "boolean") {
      ignorePageScroll = relativeTo;
      relativeTo = null;
    }
    if (!(relativeTo == null ? void 0 : relativeTo.isRectangle)) {
      if (relativeTo) {
        let { scrollLeft, scrollTop } = relativeTo;
        if (BrowserHelper.isSafari && relativeTo === document.body) {
          scrollLeft = scrollTop = 0;
        }
        relativeTo = _Rectangle.from(relativeTo).translate(-scrollLeft, -scrollTop);
      } else {
        if (!zeroBased) {
          zeroBased = new _Rectangle(0, 0, 0, 0);
        }
        relativeTo = zeroBased;
      }
    }
    const isViewport = element === document || element === globalThis, isSFViewport = element === document.body && document.body.offsetHeight === 0, sfElRect = isSFViewport && element.getBoundingClientRect(), viewRect = isSFViewport ? new _Rectangle(sfElRect.left, sfElRect.top, sfElRect.width, document.body.parentElement.scrollHeight) : isViewport ? new _Rectangle(0, 0, globalThis.innerWidth, globalThis.innerHeight) : element.getBoundingClientRect(), scrollOffset = ignorePageScroll || isViewport ? [0, 0] : [globalThis.pageXOffset, globalThis.pageYOffset];
    return new _Rectangle(
      viewRect.left + scrollOffset[0] - relativeTo.x,
      viewRect.top + scrollOffset[1] - relativeTo.y,
      viewRect.width,
      viewRect.height
    );
  }
  /**
   * Returns the Rectangle in viewport coordinates of the passed element.
   *
   * *Note:* If the element passed is the `document` or `window` the `window`'s rectangle is returned which is always
   * at `[0, 0]` and encompasses the browser's entire document viewport.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @returns {Core.helper.util.Rectangle} The Rectangle in viewport based coordinates. Relative to the _relativeTo_
   * parameter if provided.
   */
  static fromScreen(element, relativeTo) {
    return _Rectangle.from(
      element,
      relativeTo,
      /* ignorePageScroll = */
      true
    );
  }
  /**
   * Returns the inner Rectangle (within border) in document based coordinates of the passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static inner(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders);
      result.x += parseFloat(borders[borderNames.l]);
      result.y += parseFloat(borders[borderNames.t]);
      result.right -= parseFloat(borders[borderNames.r]);
      result.bottom -= parseFloat(borders[borderNames.b]);
    }
    return result;
  }
  /**
   * Returns the content Rectangle (within border and padding) in document based coordinates of the passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static content(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders), padding = DomHelper.getStyleValue(element, allPaddings);
      result.x += parseFloat(borders[borderNames.l]) + parseFloat(padding[paddingNames.l]);
      result.y += parseFloat(borders[borderNames.t]) + parseFloat(padding[paddingNames.t]);
      result.right -= parseFloat(borders[borderNames.r]) + parseFloat(padding[paddingNames.r]);
      result.bottom -= parseFloat(borders[borderNames.b]) + parseFloat(padding[paddingNames.b]);
    }
    return result;
  }
  /**
   * Returns the client Rectangle (within border and padding and scrollbars) in document based coordinates of the
   * passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @param {Boolean} [clipStickies] Return the Rectangle *within* any sticky elements docked at the element edges.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static client(element, relativeTo, ignorePageScroll = false, clipStickies) {
    const result = this.content(element, relativeTo, ignorePageScroll), scrollbarWidth = DomHelper.scrollBarWidth, stickies = clipStickies ? [...element.children].filter((e) => DomHelper.getStyleValue(e, "position") === "sticky") : emptyArray2;
    ;
    let padding;
    if (scrollbarWidth && !element.classList.contains("b-hide-scroll")) {
      if (element.scrollHeight > element.clientHeight && DomHelper.getStyleValue(element, "overflow-y") !== "hidden") {
        padding = parseFloat(DomHelper.getStyleValue(element, "padding-right"));
        result.right += padding - Math.max(padding, scrollbarWidth);
      }
      if (element.scrollWidth > element.clientWidth && DomHelper.getStyleValue(element, "overflow-x") !== "hidden") {
        padding = parseFloat(DomHelper.getStyleValue(element, "padding-bottom"));
        result.bottom += padding - Math.max(padding, scrollbarWidth);
      }
    }
    for (let i = 0, { length } = stickies; i < length; i++) {
      const e = stickies[i], r = this.fromScreen(e);
      if (parseFloat(DomHelper.getStyleValue(e, "left")) === 0) {
        result.x += r.width;
      } else if (parseFloat(DomHelper.getStyleValue(e, "right")) === 0) {
        result.right -= r.width;
      } else if (parseFloat(DomHelper.getStyleValue(e, "top")) === 0) {
        result.y += r.height;
      } else if (parseFloat(DomHelper.getStyleValue(e, "bottom")) === 0) {
        result.bottom -= r.height;
      }
    }
    return result;
  }
  /**
   * Returns the outer Rectangle (including margin) in document based coordinates of the passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates.
   * Relative to the _relativeTo_ parameter if passed.
   * @internal
   */
  static outer(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const margin = DomHelper.getStyleValue(element, allMargins);
      result.x -= parseFloat(margin["margin-left"]);
      result.y -= parseFloat(margin["margin-top"]);
      result.right += parseFloat(margin["margin-right"]);
      result.bottom += parseFloat(margin["margin-bottom"]);
    }
    return result;
  }
  /**
   * Returns a new rectangle created as the union of all supplied rectangles.
   * @param {Core.helper.util.Rectangle[]} rectangles
   * @returns {Core.helper.util.Rectangle}
   */
  static union(...rectangles) {
    let { x, y, right, bottom } = rectangles[0], current;
    if (rectangles.length > 1) {
      for (let i = 1; i < rectangles.length; i++) {
        current = rectangles[i];
        if (current.x < x) {
          x = current.x;
        }
        if (current.y < y) {
          y = current.y;
        }
        if (current.right > right) {
          right = current.right;
        }
        if (current.bottom > bottom) {
          bottom = current.bottom;
        }
      }
    }
    return new _Rectangle(x, y, right - x, bottom - y);
  }
  /**
   * Rounds this Rectangle to the pixel resolution of the current display or to the nearest
   * passed unit which defaults to the current display's [`devicePixelRatio`](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio).
   * @param {Number} [devicePixelRatio] device pixel ratio which defaults to `window.devicePixelRatio`
   */
  roundPx(devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const me = this;
    me._x = DomHelper.roundPx(me._x, devicePixelRatio);
    me._y = DomHelper.roundPx(me._y, devicePixelRatio);
    me._width = DomHelper.roundPx(me._width, devicePixelRatio);
    me._height = DomHelper.roundPx(me._height, devicePixelRatio);
    return me;
  }
  // This class doesn't extend Base and extending doesn't seem to be
  // the way to go. Instead we duplicate smallest piece of logic here
  static get $$name() {
    return hasOwnProperty.call(this, "$name") && this.$name || // _$name is filled by webpack for every class (cls._$name = '...')
    hasOwnProperty.call(this, "_$name") && this._$name || this.name;
  }
  get $$name() {
    return this.constructor.$$name;
  }
  /**
   * Creates a copy of this Rectangle.
   */
  clone() {
    const me = this, result = new _Rectangle(me.x, me.y, me.width, me.height);
    result.isAlignRectangle = me.isAlignRectangle;
    result.minHeight = me.minHeight;
    result.minWidth = me.minWidth;
    return result;
  }
  /**
   * Returns `true` if this Rectangle wholly contains the passed rectangle.
   *
   * Note that a {@link Core.helper.util.Rectangle.Point} may be passed.
   * @param {Core.helper.util.Rectangle} other The Rectangle to test for containment within this Rectangle
   * @returns {Boolean} `true` if the other Rectangle is wholly contained within this Rectangle
   */
  contains(other) {
    const me = this;
    if (other.isRectangle) {
      return other._x >= me._x && other._y >= me._y && other.right <= me.right && other.bottom <= me.bottom;
    } else {
      return false;
    }
  }
  /**
   * Checks if this Rectangle intersects the passed Rectangle
   * @param {Core.helper.util.Rectangle} other The Rectangle to intersect with this.
   * @param {Boolean} [useBoolean] Specify `true` to return a boolean value instead of constructing a new Rectangle
   * @param {Boolean} [allowZeroDimensions] `true` to consider zero-width or zero-hight rectangles as intersecting if coordinates indicate the intersection
   * @returns {Core.helper.util.Rectangle|Boolean} Returns the intersection Rectangle or `false` if there is no intersection.
   */
  intersect(other, useBoolean = false, allowZeroDimensions = false) {
    const me = this, y = Math.max(me.y, other.y), r = Math.min(me.right, other.right), b = Math.min(me.bottom, other.bottom), x = Math.max(me.x, other.x), intersect = allowZeroDimensions ? b >= y && r >= x : b > y && r > x;
    if (intersect) {
      return useBoolean ? true : new _Rectangle(x, y, r - x, b - y);
    } else {
      return false;
    }
  }
  equals(other, round2 = false) {
    const processor = round2 ? (x) => Math.round(x) : (x) => x;
    return other.isRectangle && processor(other.x) === processor(this.x) && processor(other.y) === processor(this.y) && processor(other.width) === processor(this.width) && processor(other.height) === processor(this.height);
  }
  /**
   * Translates this Rectangle by the passed vector. Size is maintained.
   * @param {Number} x The X translation vector.
   * @param {Number} y The Y translation vector.
   * @returns {Core.helper.util.Rectangle} This Rectangle;
   */
  translate(x, y) {
    this._x += x || 0;
    this._y += y || 0;
    return this;
  }
  /**
   * Moves this Rectangle to the passed `x`, `y` position. Size is maintained.
   * @param {Number} x The new X position.
   * @param {Number} y The new Y position.
   * @returns {Core.helper.util.Rectangle}  This Rectangle;
   */
  moveTo(x, y) {
    if (x != null) {
      this._x = x;
    }
    if (y != null) {
      this._y = y;
    }
    return this;
  }
  /**
   * Returns the vector which would translate this Rectangle (or Point) to the same position as the other Rectangle (or point)
   * @param {Core.helper.util.Rectangle|Core.helper.util.Rectangle.Point} other The Rectangle or Point to calculate the delta to.
   * @returns {Array} Returns a vector using format `[deltaX, deltaY]`
   * @internal
   */
  getDelta(other) {
    return [other.x - this.x, other.y - this.y];
  }
  /**
   * The center point of this rectangle.
   * @property {Core.helper.util.Rectangle.Point}
   */
  get center() {
    const result = new Point(this.x + this.width / 2, this.y + this.height / 2, 0, 0);
    result.target = this.target;
    return result;
  }
  /**
   * Get/sets the X coordinate of the Rectangle. Note that this does *not* translate the
   * Rectangle. The requested {@link #property-width} will change.
   * @property {Number}
   */
  set x(x) {
    const xDelta = x - this._x;
    this._x = x;
    this._width -= xDelta;
  }
  get x() {
    return this._x;
  }
  get start() {
    return this.left;
  }
  /**
   * Alias for x. To match DOMRect.
   * @property {Number}
   */
  set left(x) {
    this.x = x;
  }
  get left() {
    return this.x;
  }
  /**
   * Alias for y. To match DOMRect.
   * @property {Number}
   */
  set top(y) {
    this.y = y;
  }
  get top() {
    return this.y;
  }
  /**
   * Get/sets the Y coordinate of the Rectangle. Note that this does *not* translate the
   * Rectangle. The requested {@link #property-height} will change.
   * @property {Number}
   */
  set y(y) {
    const yDelta = y - this._y;
    this._y = y;
    this._height -= yDelta;
  }
  get y() {
    return this._y;
  }
  /**
   * Get/sets the width of the Rectangle. Note that the requested {@link #property-right} will change.
   * @property {Number}
   */
  set width(width) {
    this._width = width;
  }
  get width() {
    return this._width;
  }
  /**
   * Get/sets the height of the Rectangle. Note that the requested {@link #property-bottom} will change.
   * @property {Number}
   */
  set height(height) {
    this._height = height;
  }
  get height() {
    return this._height;
  }
  /**
   * Get/sets the right edge of the Rectangle. Note that the requested {@link #property-width} will change.
   *
   * The right edge value is exclusive of the calculated rectangle width. So x=0 and right=10
   * means a width of 10.
   * @property {Number}
   */
  set right(right) {
    this._width = right - this._x;
  }
  get right() {
    return this._x + this._width;
  }
  get end() {
    return this.right;
  }
  /**
   * Get/sets the bottom edge of the Rectangle. Note that the requested {@link #property-height} will change.
   *
   * The bottom edge value is exclusive of the calculated rectangle height. So y=0 and bottom=10
   * means a height of 10.
   * @property {Number}
   */
  set bottom(bottom) {
    this._height = bottom - this._y;
  }
  get bottom() {
    return this._y + this._height;
  }
  getStart(rtl, horizontal = true) {
    if (horizontal) {
      return rtl ? this.right : this.left;
    }
    return this.top;
  }
  getEnd(rtl, horizontal = true) {
    if (horizontal) {
      return rtl ? this.left : this.right;
    }
    return this.bottom;
  }
  get area() {
    return this.width * this.height;
  }
  set minWidth(minWidth) {
    const me = this;
    if (isNaN(minWidth)) {
      me._minWidth = null;
    } else {
      me._minWidth = Number(minWidth);
      if (!me.isAlignRectangle) {
        me.width = Math.max(me.width, me._minWidth);
      }
    }
  }
  get minWidth() {
    return this._minWidth;
  }
  set minHeight(minHeight) {
    const me = this;
    if (isNaN(minHeight)) {
      me._minHeight = null;
    } else {
      me._minHeight = Number(minHeight);
      if (!me.isAlignRectangle) {
        me.height = Math.max(me.height, me._minHeight);
      }
    }
  }
  get minHeight() {
    return this._minHeight;
  }
  /**
   * Modifies the bounds of this Rectangle by the specified deltas.
   * @param {Number} x How much to *add* to the x position.
   * @param {Number} y  How much to *add* to the y position.
   * @param {Number} width  How much to add to the width.
   * @param {Number} height  How much to add to the height.
   * @returns {Core.helper.util.Rectangle} This Rectangle
   */
  adjust(x, y, width, height) {
    const me = this;
    me.x += x;
    me.y += y;
    me.width += width;
    me.height += height;
    return me;
  }
  /**
   * Modifies the bounds of this rectangle by expanding them by the specified amount in all directions.
   * The parameters are read the same way as CSS margin values.
   *
   * - If one value is passed, all edges are inflated by that value.
   * - If two values are passed they are top/bottom inflation and left/right inflation.
   * - If four values are passed, that's top, right, bottom, left.
   * @param {Number} amount How much to inflate, or the top value if more than one values passed.
   * @param {Number} right How much to inflate the right side, or both left and right is only two values passed.
   * @param {Number} bottom How much to inflate the bottom side.
   * @param {Number} left How much to inflate the left side.
   * @returns {Core.helper.util.Rectangle} This Rectangle
   * @internal
   */
  inflate(top, right = top, bottom = top, left = right) {
    if (Array.isArray(top)) {
      [top, right, bottom, left] = parseEdges(top);
    }
    return this.adjust(-left, -top, right, bottom);
  }
  /**
   * Modifies the bounds of this rectangle by reducing them by the specified amount in all directions.
   * The parameters are read the same way as CSS margin values.
   *
   * - If one value is passed, all edges are deflated by that value.
   * - If two values are passed they are top/bottom deflation and left/right deflation.
   * - If four values are passed, that's top, right, bottom, left.
   * @param {Number} amount How much to deflate, or the top value if more than one values passed.
   * @param {Number} right How much to deflate the right side, or both left and right is only two values passed.
   * @param {Number} bottom How much to deflate the bottom side.
   * @param {Number} left How much to deflate the left side.
   * @returns {Core.helper.util.Rectangle} This Rectangle
   * @internal
   */
  deflate(top, right = top, bottom = top, left = right) {
    if (Array.isArray(top)) {
      [top, right, bottom, left] = parseEdges(top);
    }
    return this.adjust(left, top, -right, -bottom);
  }
  /**
   * Attempts constrain this Rectangle into the passed Rectangle. If the `strict` parameter is `true`
   * then this method will return `false` if constraint could not be achieved.
   *
   * If this Rectangle has a `minHeight` or `minWidth` property, size will be adjusted while attempting to constrain.
   *
   * Right and bottom are adjusted first leaving the top and bottom sides to "win" in the case that this Rectangle overflows
   * the constrainTo Rectangle.
   * @param {Core.helper.util.Rectangle} constrainTo The Rectangle to constrain this Rectangle into if possible.
   * @param {Boolean} strict Pass `true` to return false, and leave this Rectangle unchanged if constraint
   * could not be achieved.
   * @returns {Core.helper.util.Rectangle|Boolean} This Rectangle. If `strict` is true, and constraining was not successful, `false`.
   */
  constrainTo(constrainTo, strict) {
    const me = this, originalHeight = me.height, originalY = me.y, minWidth = me.minWidth || me.width, minHeight = me.minHeight || me.height;
    if (me.height >= constrainTo.height) {
      if (strict && minHeight > constrainTo.height) {
        return false;
      }
      me._y = constrainTo.y;
      me.height = constrainTo.height;
    }
    if (me.width >= constrainTo.width) {
      if (strict && minWidth > constrainTo.width) {
        me.y = originalY;
        me.height = originalHeight;
        return false;
      }
      me._x = constrainTo.x;
      me.width = constrainTo.width;
    }
    me.translate.apply(me, me.constrainVector = [
      Math.min(constrainTo.right - me.right, 0),
      Math.min(constrainTo.bottom - me.bottom, 0)
    ]);
    me.translate(Math.max(constrainTo.x - me.x, 0), Math.max(constrainTo.y - me.y, 0));
    return me;
  }
  /**
   * Returns a cloned version of this Rectangle aligned to a target Rectangle, or element or {@link Core.widget.Widget}.
   * @param {Object} spec Alignment specification.
   * @param {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} spec.target The Widget or element or Rectangle to align to.
   * @param {Number[]} [spec.anchorSize] The `[width, height]` of the anchor pointer when in `top` position. The
   * width is the baseline length, and the height is the height of the arrow. If passed, the anchor position
   * will be calculated to be at the centre of the overlap of the two aligned edges and returned in the `anchor`
   * property of the resulting Rectangle:
   *
   *     {
   *         edge: 'top',         // or 'right' or 'bottom' or 'left'
   *         x/y: offset          // dimension to translate and value to translate by.
   *     }
   *
   * @param {Object} [spec.anchorPosition] an `{ x: n, y: n }` anchor translation to be used *if the requested alignment
   * succeeds without violating constraints*. If a fallback alignment is used, the anchor will be centered in the
   * overlap of the aligned edges as usual.
   * @param {Boolean} [spec.overlap] True to allow this to overlap the target.
   * @param {String} spec.align The edge alignment specification string, specifying two points to bring together.
   *
   * Each point is described by an edge initial (`t` for top edge, `b` for bottom edge etc) followed
   * by a percentage along that edge.
   *
   * So the form would be `[trblc][n]-[trblc][n].` The `n` is the percentage offset along that edge
   * which defines the alignment point. This is not valid for alignment point `c` which means the center point.
   *
   * For example `t0-b0' would align this Rectangle's top left corner with the bottom left corner of the `target`.
   * @param {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} [spec.constrainTo] The Widget or Element or Rectangle to constrain to.
   * If the requested alignment cannot be constrained (it will first shrink the resulting Rectangle according
   * to the `minWidth` and `minHeight` properties of this rectangle), then it will try aligning at other edges
   * (honouring the `axisLock` option), and pick the fallback alignment which results in the shortest translation.
   * @param {Boolean} [spec.axisLock] Specify as a truthy value to fall back to aligning against the opposite
   * edge first if the requested alignment cannot be constrained into the `constrainTo` option. If specified
   * as `'flexible'`, then fallback will continue searching for solutions on the remaining two sides.
   * @param {Boolean} [spec.matchSize] When aligning edge-to-edge, match the length of the aligned-to
   * edge of the target. This is only honored when `axisLock` is enabled and alignment succeeds on the requested axis.
   * If __not__ aligning edge-to-edge, `matchSize` matches both dimensions of the target.
   * @param {Number|Number[]} [spec.offset] The 'x' and 'y' offset values to create an extra margin round the target
   * to offset the aligned widget further from the target. May be configured as -ve to move the aligned widget
   * towards the target - for example producing the effect of the anchor pointer piercing the target.
   * @param {Number|Number[]} [spec.constrainPadding] The amount of pixels to pad from the `constrainTo` target,
   * either a single value, or an array of values in CSS edge order.
   * @param {Boolean} [spec.rtl] Pass as true if this is being used in an RTL environment, and aligning 0% to
   * 100% along a horizontal edge must proceed from right to left.
   * @returns {Core.helper.util.Rectangle} A new Rectangle aligned as requested if possible, but if the requested position violates
   * the `constrainTo` Rectangle, the shortest translation from the requested position which obeys constraints will be used.
   */
  alignTo(spec) {
    let result = this.clone(), {
      target,
      constrainTo,
      constrainPadding
    } = spec, calculatedAnchorPosition, zone, resultZone, constrainingToViewport;
    if (target && !target.isRectangle) {
      target = _Rectangle.from(target.element ? target.element : target);
    }
    if (constrainTo) {
      if (!constrainTo.isRectangle) {
        constrainingToViewport = constrainTo === globalThis || constrainTo === document;
        const ignorePageScroll = "ignorePageScroll" in spec ? spec.ignorePageScroll : !constrainingToViewport;
        constrainTo = _Rectangle.from(constrainTo.element ? constrainTo.element : constrainTo, null, ignorePageScroll);
      }
      if (constrainPadding) {
        constrainPadding = parseEdges(constrainPadding);
        constrainPadding[0] = Math.min(constrainPadding[0], target.top);
        constrainPadding[1] = Math.min(constrainPadding[1], constrainTo.right - target.right);
        constrainPadding[2] = Math.min(constrainPadding[2], constrainTo.bottom - target.bottom);
        constrainPadding[3] = Math.min(constrainPadding[3], target.left);
        constrainTo = constrainTo.deflate.apply(constrainTo.clone(), constrainPadding);
      }
    }
    const me = this, targetOffsets = createOffsets(spec.offset), {
      align,
      axisLock,
      anchorSize,
      anchorPosition,
      matchSize,
      position,
      rtl
    } = spec, alignSpec = parseAlign(align, rtl), targetConstrainRect = constrainTo && constrainTo.clone(), constraintZones = [], zoneOrder = [{
      zone: zone = alignSpec.startZone,
      align
    }], matchDimension = matchSize && matchDimensions[alignSpec.startZone & 1], originalSize = me[matchDimension];
    if (matchDimension && axisLock) {
      result[matchDimension] = target[matchDimension];
    } else if (!alignSpec.edgeAligned && matchSize) {
      result.width = target.width;
      result.height = target.height;
    }
    if (constrainTo) {
      result.constrainTo(constrainTo);
    }
    if (constrainTo && alignSpec.startZone != null) {
      if (axisLock) {
        zoneOrder.push({
          zone: zone = (zone + 2) % 4,
          align: flipAlign(alignSpec)
        });
        if (axisLock === "flexible") {
          zoneOrder.push({
            zone: zone = (alignSpec.startZone + 1) % 4,
            align: defaultAlignments[zone]
          });
          zoneOrder.push({
            zone: zone = (zone + 2) % 4,
            align: defaultAlignments[zone]
          });
        }
      } else {
        for (let i = 1; i < 4; i++) {
          zoneOrder.push({
            zone: zone = (zone + 1) % 4,
            align: defaultAlignments[zone]
          });
        }
      }
    }
    if (anchorPosition) {
      const pos = alignSpec.startZone & 1 ? "y" : "x";
      calculatedAnchorPosition = {
        [pos]: anchorPosition[pos],
        edge: edgeNames[(alignSpec.startZone + 2) % 4]
      };
    }
    if (targetConstrainRect && target) {
      targetConstrainRect.adjust(-target.width, -target.height, target.width, target.height);
      target.constrainTo(targetConstrainRect);
    }
    result.minWidth = me.minWidth;
    result.minHeight = me.minHeight;
    if (position) {
      result.moveTo(position.x, position.y);
      result.translate.apply(result, targetOffsets);
      if (constrainTo) {
        result.constrainTo(constrainTo);
      }
    } else {
      const centerAligned = alignSpec.myEdge === "c" || alignSpec.targetEdge === "c", offsets = anchorSize && !centerAligned ? [anchorSize[1] + targetOffsets[0], anchorSize[1] + targetOffsets[1]] : targetOffsets, targetPoint = target.getAlignmentPoint(alignSpec.targetAlignmentPoint, offsets), myPoint = result.getAlignmentPoint(alignSpec.myAlignmentPoint);
      result.translate(targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]);
      let overlap = result.intersect(target, true);
      if (overlap) {
        if (constrainTo) {
          result.constrainTo(constrainTo);
        }
        resultZone = alignSpec.startZone;
        result.translate(...offsets);
      } else if (constrainTo && !constrainTo.contains(result)) {
        const requestedResult = result.clone(), solutions = [];
        let zone2, largestZone;
        calculatedAnchorPosition = null;
        constraintZones[0] = zone2 = constrainTo.clone();
        zone2.bottom = target.y - offsets[1];
        constraintZones[1] = zone2 = constrainTo.clone();
        zone2.x = target.right + offsets[0];
        constraintZones[2] = zone2 = constrainTo.clone();
        zone2.y = target.bottom + offsets[1];
        constraintZones[3] = zone2 = constrainTo.clone();
        zone2.right = target.x - offsets[0];
        for (let i = 0; i < zoneOrder.length; i++) {
          if (matchDimension && i == 2) {
            result[matchDimension] = originalSize;
          }
          zone2 = constraintZones[resultZone = zoneOrder[i].zone];
          result = result.alignTo({
            target,
            offsets,
            align: zoneOrder[i].align
          });
          if (result.constrainTo(zone2, true)) {
            solutions.push({
              result,
              zone: resultZone
            });
            if (!largestZone || result.width < me.width || result.height < me.height) {
              result.align = zoneOrder[i].align;
              break;
            }
          }
          if (!largestZone || zone2.area > largestZone.area) {
            const r = result.clone();
            switch (resultZone) {
              case 0:
                r.moveTo(null, zone2.bottom - r.height);
                break;
              case 1:
                r.moveTo(zone2.left);
                break;
              case 2:
                r.moveTo(null, zone2.top);
                break;
              case 3:
                r.moveTo(zone2.right - r.width);
                break;
            }
            largestZone = {
              area: zone2.area,
              result: r,
              zone: resultZone
            };
          }
        }
        if (solutions.length) {
          if (solutions.length > 1 && !axisLock) {
            solutions.sort((s12, s22) => {
              const s1TranslationDistance = Math.sqrt((requestedResult.x - s12.result.x) ** 2 + (requestedResult.y - s12.result.y) ** 2), s2TranslationDistance = Math.sqrt((requestedResult.x - s22.result.x) ** 2 + (requestedResult.y - s22.result.y) ** 2);
              return s1TranslationDistance - s2TranslationDistance;
            });
          }
          result = solutions[0].result;
          resultZone = solutions[0].zone;
        } else {
          result = largestZone.result;
          resultZone = largestZone.zone;
          if (constrainingToViewport) {
            result.constrainTo(constrainTo);
          }
        }
      } else {
        resultZone = alignSpec.startZone;
      }
      result.zone = resultZone;
      result.overlap = overlap = result.intersect(target, true);
      if (anchorSize && !overlap) {
        if (!calculatedAnchorPosition) {
          const isLeftOrRight = resultZone & 1, start = isLeftOrRight ? "y" : "x", end = isLeftOrRight ? "bottom" : "right", startValue = Math.max(target[start], result[start]), endValue = Math.min(target[end], result[end]);
          let anchorStart = startValue + (endValue - startValue) / 2 - anchorSize[0] / 2;
          const anchorEnd = anchorStart + anchorSize[0];
          if (anchorEnd > result[end]) {
            anchorStart -= anchorEnd - result[end];
          }
          if (anchorStart < result[start]) {
            anchorStart += result[start] - anchorStart;
          }
          calculatedAnchorPosition = {
            [start]: anchorStart - result[start],
            edge: edgeNames[(resultZone + 2) % 4]
          };
        }
        result.anchor = calculatedAnchorPosition;
      }
    }
    return result;
  }
  /**
   * Returns the `[x, y]` position of the specified anchor point of this Rectangle in <edge><offset> format.
   * for example passing "t50" will return the centre point of the top edge, passing "r0" will return the start
   * position of the right edge (the top right corner).
   *
   * Note that the offset defaults to 50, so "t" means the centre of the top edge.
   * @param {String} alignmentPoint The alignment point to calculate. Must match the RegExp `[trbl]\d*`
   * @param {Number[]} margins The `[x, y]` margins to add from the left/right, top/bottom edge.
   * @internal
   */
  getAlignmentPoint(alignmentPoint, margins = zeroOffsets) {
    const me = this, parts = alignPointRe.exec(alignmentPoint), edge = parts[1].toLowerCase(), edgeOffset = Math.min(Math.max(parseInt(parts[2] || 50), 0), 100) / 100;
    switch (edge) {
      case "t":
        return [me.x + me.width * edgeOffset, me.y - margins[1]];
      case "r":
        return [me.right + margins[0], me.y + me.height * edgeOffset];
      case "b":
        return [me.x + me.width * edgeOffset, me.bottom + margins[1]];
      case "l":
        return [me.x - margins[0], me.y + me.height * edgeOffset];
      case "c": {
        return [me.x + me.width / 2, me.y + me.height / 2];
      }
    }
  }
  /**
   * Highlights this Rectangle using the highlighting effect of {@link Core.helper.DomHelper}
   * on a transient element which encapsulates the region's area.
   */
  highlight() {
    const me = this, highlightElement = DomHelper.createElement({
      parent: document.body,
      style: `position:absolute;z-index:9999999;pointer-events:none;
                            left:${me.x}px;top:${me.y}px;width:${me.width}px;height:${me.height}px`
    });
    return DomHelper.highlight(highlightElement).then(() => highlightElement.remove());
  }
  /**
   * Visualizes this Rectangle by adding a DOM element which encapsulates the region's area into the provided parent element.
   * @param {DomConfig} config Element config object
   * @returns {Element} The highlight element
   * @internal
   */
  visualize(config, asDomConfig) {
    const me = this, domConfig = ObjectHelper.merge({
      style: {
        left: `${me.x}px`,
        top: `${me.y}px`,
        width: `${me.width}px`,
        height: `${me.height}px`,
        pointerEvents: "none",
        // If this visualization is provided a CSS class, let outside handle position + z-index
        ...config.class ? {} : { position: "absolute", "z-index": 9999999 }
      }
    }, config);
    return asDomConfig ? domConfig : DomHelper.createElement(domConfig);
  }
  toString(delimiter = ",") {
    return [`${this.top}px`, `${this.right}px`, `${this.bottom}px`, `${this.left}px`].join(delimiter);
  }
};
var Point = class extends Rectangle {
  /**
   * Creates a new Point encapsulating the event's page position.
   * @param {Event} event
   * @returns {Core.helper.util.Rectangle}
   * @typings ignore
   */
  static from(event) {
    const touchPoints = event.changedTouches, x = touchPoints ? touchPoints[0].screenX : event.screenX, y = touchPoints ? touchPoints[0].screenY : event.pageY;
    return new this.constructor(x, y);
  }
  /**
   * Constructs a Point
   * @param x The X coordinate
   * @param y The Y coordinate
   */
  constructor(x, y) {
    super(x, y, 0, 0);
  }
  /**
   * Coerces this Point to be within the passed Rectangle. Translates it into the bounds.
   * @param {Core.helper.util.Rectangle} into The Rectangle into which to coerce this Point.
   */
  constrain(into) {
    this.x = Math.min(Math.max(this.x, into.x), into.right - 1);
    this.y = Math.min(Math.max(this.y, into.y), into.bottom - 1);
    return this;
  }
  toArray() {
    return [this.x, this.y];
  }
};
Rectangle._$name = "Rectangle";

// ../Core/lib/Core/mixin/InstancePlugin.js
function getDescriptor(me, fnName) {
  const property = ObjectHelper.getPropertyDescriptor(me, fnName);
  return property && (property.get || property.set) ? property : null;
}
var InstancePlugin = class extends Base.mixin(Events_default, Localizable_default) {
  //region Config
  static get configurable() {
    return {
      clientListeners: null,
      /**
       * The plugin/feature `disabled` state.
       *
       * For a feature that is **off** by default that you want to enable later during runtime,
       * configure it with `disabled : true`.
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : {
       *              disabled : true // on and disabled, can be enabled later
       *          }
       *      }
       * });
       *
       * // enable the feature
       * grid.features.featureName.disabled = false;
       * ```
       *
       * If the feature is **disabled** by default, and you want to include and enable the feature, configure it as `true`:
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : true // on and enabled, can be disabled later
       *      }
       * });
       *
       * // disable the feature
       * grid.features.featureName.disabled = true;
       * ```
       *
       * If the feature is **on** by default, but you want to turn it **off**, configure it as `false`:
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : false // turned off, not included at all
       *      }
       * });
       * ```
       *
       * If the feature is **enabled** by default and you have no need of reconfiguring it,
       * you can omit the feature configuration.
       *
       * @prp {Boolean}
       * @default
       * @category Common
       */
      disabled: false,
      /**
       * The Widget which was passed into the constructor,
       * which is the Widget we are providing extra services for.
       * @member {Core.widget.Widget} client
       * @readonly
       * @category Misc
       * @advanced
       */
      /**
       * The widget which this plugin is to attach to.
       * @config {Core.widget.Widget}
       * @category Misc
       * @advanced
       */
      client: null,
      /**
       * @hideconfigs bubbleEvents, callOnFunctions
       */
      /**
       * @hidefunctions downloadTestCase, destroy
       */
      /**
       * @hideproperties isDestroyed
       */
      /**
       * @hideevents destroy, beforeDestroy
       */
      // The plugins can define their own keyMap which will then be merged with their client's keyMap.
      keyMap: null
    };
  }
  //endregion
  updateClient(client) {
    if (!this.owner) {
      this.owner = client;
    }
  }
  /**
   * This will merge a feature's (subclass of InstancePlugin) keyMap with it's client's keyMap.
   * @private
   */
  updateKeyMap(keyMap) {
    const { client } = this;
    client.keyMap = client.mergeKeyMaps(client.keyMap, keyMap, StringHelper.uncapitalize(this.constructor.$name));
  }
  //region Init
  /**
   * Call from another instance to add plugins to it.
   *
   * ```javascript
   * InstancePlugin.initPlugins(this, Search, Stripe);
   * ```
   *
   * @param plugInto Instance to mix into (usually this)
   * @param plugins Classes to plug in
   * @internal
   */
  static initPlugins(plugInto, ...plugins) {
    const property = plugInto.plugins || (plugInto.plugins = {});
    for (const PluginClass of plugins) {
      property[PluginClass.$$name] = new PluginClass(plugInto);
    }
  }
  /**
   * Simple wrapper for {@link #property-disabled} to make optional chaining simple:
   *
   * ```javascript
   * grid.features.myFeature?.enabled // returns true when feature exists and is enabled
   * ```
   * @returns {Boolean}
   * @internal
   */
  get enabled() {
    return !this.disabled;
  }
  // We can act as an owner of a widget, so must be able to participate in focus reversion
  getFocusRevertTarget() {
    var _a2;
    return (_a2 = this.client) == null ? void 0 : _a2.getFocusRevertTarget();
  }
  construct(...args) {
    const me = this;
    let [plugInto, config] = args, listeners;
    if (args.length === 1) {
      if (ObjectHelper.isObject(plugInto)) {
        config = plugInto;
        plugInto = config.client;
      }
    } else {
      config = ObjectHelper.assign({}, config);
      delete config.client;
    }
    me.client = plugInto;
    super.construct(config);
    me.applyPluginConfig(plugInto);
    listeners = me.clientListeners;
    if (listeners) {
      listeners = ObjectHelper.assign({}, listeners);
      listeners.thisObj = me;
      plugInto.ion(listeners);
    }
  }
  /**
   * Applies config as found in plugInto.pluginConfig, or published all if no config found.
   * @private
   * @param plugInto Target instance to plug into
   */
  applyPluginConfig(plugInto) {
    const me = this, config = me.pluginConfig || me.constructor.pluginConfig;
    if (config) {
      const { assign: assign2, chain, after, before, override } = config;
      assign2 && me.applyAssign(plugInto, assign2);
      (chain || after) && me.applyChain(plugInto, chain || after);
      before && me.applyChain(plugInto, before, false);
      override && me.applyOverride(plugInto, override);
    }
  }
  /**
   * Applies assigning for specified functions.
   * @private
   * @param plugInto
   * @param fnNames
   */
  applyAssign(plugInto, fnNames) {
    fnNames.forEach((fnName) => this.assign(plugInto, fnName));
  }
  /**
   * Applies chaining for specified functions.
   * @private
   * @param plugInto
   * @param functions
   * @param after
   */
  applyChain(plugInto, functions, after = true) {
    if (Array.isArray(functions)) {
      for (const fnName of functions) {
        this.chain(plugInto, fnName, fnName, after);
      }
    } else {
      for (const intoName in functions) {
        this.chain(plugInto, intoName, functions[intoName], after);
      }
    }
  }
  /**
   * Applies override for specified functions.
   * @private
   * @param plugInto
   * @param fnNames
   */
  applyOverride(plugInto, fnNames) {
    const me = this;
    if (!me.overridden) {
      me.overridden = {};
    }
    fnNames.forEach((fnName) => {
      if (!me[fnName]) {
        throw new Error(`Trying to chain fn ${plugInto.$$name}#${fnName}, but plugin fn ${me.$$name}#${fnName} does not exist`);
      }
      if (typeof plugInto[fnName] === "function") {
        me.overridden[fnName] = plugInto[fnName].bind(plugInto);
      }
      plugInto[fnName] = me[fnName].bind(me);
    });
  }
  /**
   * Assigns specified functions.
   * @private
   * @param plugInto
   * @param fnName
   */
  assign(plugInto, fnName) {
    const me = this, property = getDescriptor(me, fnName);
    if (property) {
      Object.defineProperty(plugInto, fnName, {
        configurable: true,
        enumerable: true,
        get: property.get && property.get.bind(me),
        set: property.set && property.set.bind(me)
      });
    } else {
      plugInto[fnName] = me[fnName].bind(me);
    }
  }
  //endregion
  //region Chaining
  /**
   * Chains functions. When the function is called on the target class all functions in the chain will be called in
   * the order they were added.
   * @private
   * @param plugInto
   * @param intoName
   * @param hookName
   * @param after
   */
  chain(plugInto, intoName, hookName, after = true) {
    let prio = 0;
    if (typeof intoName === "object") {
      intoName = intoName.fn;
    }
    if (typeof hookName === "object") {
      prio = hookName.prio || 0;
      hookName = hookName.fn;
    }
    const me = this, chains = plugInto.pluginFunctionChain || (plugInto.pluginFunctionChain = {}), hookFn = me[hookName] && me[hookName].bind(me), functionChainRunner = me.functionChainRunner;
    if (!hookFn) {
      throw new Error(`Trying to chain fn ${plugInto.$$name}#${hookName}, but plugin fn ${me.$$name}#${hookName} does not exist`);
    }
    if (!chains[intoName]) {
      let intoFn = plugInto[intoName];
      if (intoFn) {
        intoFn = intoFn.bind(plugInto);
        intoFn.$this = plugInto;
        intoFn.$prio = 0;
      }
      chains[intoName] = intoFn ? [intoFn] : [];
      plugInto[intoName] = (...params) => functionChainRunner(chains[intoName], params);
    }
    hookFn.$this = me;
    hookFn.$prio = prio;
    chains[intoName][after ? "push" : "unshift"](hookFn);
    chains[intoName].$sorted = false;
  }
  /**
   * Used to run multiple plugged in functions with the same name, see chain above. Returning false from a
   * function will abort chain.
   * @private
   * @param {Array} chain
   * @param {Array} params
   * @returns {*} value returned from last function in chain (or false if any returns false)
   */
  functionChainRunner(chain, params) {
    let fn, i, returnValue;
    if (!chain.$sorted) {
      chain.sort((a, b) => b.$prio - a.$prio);
      chain.$sorted = true;
    }
    for (i = 0; i < chain.length; i++) {
      fn = chain[i];
      if (!fn.$this.isDestroyed) {
        returnValue = fn(...params);
        if (returnValue === false) {
          break;
        }
      }
    }
    return returnValue;
  }
  //endregion
  /**
   * Called when disabling/enabling the plugin/feature, not intended to be called directly. To enable or disable a
   * plugin/feature, see {@link #property-disabled}.
   *
   * By default removes the cls of the plugin from its client. Override in subclasses to take any other actions necessary.
   * @category Misc
   * @advanced
   */
  doDisable(disable) {
    var _a2, _b, _c, _d;
    const me = this, { constructor } = me, cls = "featureClass" in constructor ? constructor.featureClass : `b-${constructor.$$name.toLowerCase()}`, key = StringHelper.uncapitalize(constructor.$$name);
    if (cls) {
      (_b = (_a2 = me.client) == null ? void 0 : _a2._element) == null ? void 0 : _b.classList[disable ? "remove" : "add"](cls);
    }
    if (!me.isConfiguring) {
      if (disable) {
        me.trigger("disable");
      } else {
        me.trigger("enable");
      }
      (_d = (_c = me.client).syncSplits) == null ? void 0 : _d.call(_c, (other) => {
        const otherFeature = other.features[key];
        if (otherFeature) {
          otherFeature.disabled = disable;
        }
      });
    }
  }
  updateDisabled(disabled) {
    this.doDisable(disabled);
  }
  throwOverrideIsMissing(data) {
    throw new Error(`Trying to override fn ${data.plugIntoName}#${data.fnName}, but plugin fn ${data.pluginName}#${data.fnName} does not exist`);
  }
  // Convenience method to read the rootElement from the owner widget
  get rootElement() {
    return this.client.rootElement;
  }
};
__publicField(InstancePlugin, "$name", "InstancePlugin");
InstancePlugin._$name = "InstancePlugin";

// ../Core/lib/Core/mixin/Pluggable.js
var Pluggable_default = (Target) => class Pluggable extends (Target || Base) {
  static get $name() {
    return "Pluggable";
  }
  /**
   * Specify plugins (an array of classes) in config
   * @config {Function[]} plugins
   * @category Misc
   * @advanced
   */
  /**
   * Map of applied plugins
   * @property {Object<String,Core.mixin.InstancePlugin>}
   * @readonly
   * @category Misc
   * @advanced
   */
  get plugins() {
    if (!this._plugins) {
      this._plugins = {};
    }
    return this._plugins;
  }
  set plugins(plugins) {
    if (plugins) {
      if (!Array.isArray(plugins))
        plugins = [plugins];
      InstancePlugin.initPlugins(this, ...plugins);
    }
    this.initPlugins();
  }
  /**
   * Template method which may be implemented in subclasses to initialize any plugins.
   * This method is empty in the `Pluggable` base class.
   * @internal
   */
  initPlugins() {
  }
  /**
   * Adds plugins to an instance.
   * @param {Function[]} plugins The plugins to add
   * @category Misc
   * @advanced
   */
  addPlugins(...plugins) {
    InstancePlugin.initPlugins(this, ...plugins);
  }
  /**
   * Checks if instance has plugin.
   * @param {String|Function} pluginClassOrName Plugin or name to check for
   * @returns {Boolean}
   * @category Misc
   * @advanced
   */
  hasPlugin(pluginClassOrName) {
    return this.getPlugin(pluginClassOrName) != null;
  }
  /**
   * Get a plugin instance.
   * @param {String|Function} pluginClassOrName
   * @returns {Core.mixin.InstancePlugin}
   * @category Misc
   * @advanced
   */
  getPlugin(pluginClassOrName) {
    var _a2;
    if (typeof pluginClassOrName === "function") {
      pluginClassOrName = pluginClassOrName.$$name;
    }
    return (_a2 = this.plugins) == null ? void 0 : _a2[pluginClassOrName];
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement thus.
  get widgetClass() {
  }
};

// ../Core/lib/Core/mixin/Delayable.js
var { defineProperty: defineProperty3 } = Reflect;
var performance2;
if (BrowserHelper.isBrowserEnv) {
  performance2 = globalThis.performance;
} else {
  performance2 = {
    now() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
  };
}
var globalDelays = null;
if (VersionHelper.isTestEnv) {
  const bryntum = globalThis.bryntum || (globalThis.bryntum = {});
  globalDelays = bryntum.globalDelays = {
    timeouts: /* @__PURE__ */ new Map(),
    intervals: /* @__PURE__ */ new Map(),
    animationFrames: /* @__PURE__ */ new Map(),
    idleCallbacks: /* @__PURE__ */ new Map(),
    isEmpty(includeIntervals = false) {
      return globalDelays.timeouts.size + globalDelays.animationFrames.size + globalDelays.idleCallbacks.size + (includeIntervals ? globalDelays.intervals.size : 0) === 0;
    },
    /**
     * Returns filtered delays array
     * @param {Object} options
     * @param {String[]} [options.ignoreTimeouts] array of delays names to ignore
     * @param {Number} [options.maxDelay] maximum delay in milliseconds. Timeouts with bigger delay will be filtered out
     * @param {Boolean} [options.includeIntervals] include intervals
     * @returns {Object[]} array of filtered delays
     * @internal
     */
    getFiltered({ ignoreTimeouts = [], maxDelay = 5e3, includeIntervals = false }) {
      const result = [], scopes = ["timeouts", "animationFrames", "idleCallbacks"];
      if (includeIntervals) {
        scopes.push("intervals");
      }
      for (const scope of scopes) {
        const map = globalDelays[scope];
        for (const [, entry] of map.entries()) {
          if (!ignoreTimeouts.includes(entry.name) && (!Number.isInteger(entry.delay) || entry.delay < maxDelay)) {
            result.push(entry);
          }
        }
      }
      return result;
    }
  };
}
var makeInvoker = (me, fn, wrapFn, options) => {
  const named = typeof fn === "string", appendArgs = (options == null ? void 0 : options.appendArgs) || [], invoker = () => {
    wrapFn.timerId = null;
    wrapFn.lastCallTime = performance2.now();
    const args = wrapFn.args;
    wrapFn.args = null;
    if (named) {
      me[fn](...args, ...appendArgs);
    } else {
      fn.call(me, ...args, ...appendArgs);
    }
    wrapFn.called = true;
    ++wrapFn.calls;
  };
  if (options) {
    me = options.thisObj || me;
  }
  wrapFn.lastCallTime = -9e9;
  wrapFn.calls = 0;
  wrapFn.invoker = invoker;
  invoker.wrapFn = wrapFn;
  return invoker;
};
var decorateWrapFn = (me, wrapFn, cancelFn = "clearTimeout") => {
  wrapFn.cancel = () => {
    if (wrapFn.isPending) {
      me[cancelFn](wrapFn.timerId);
      wrapFn.args = wrapFn.timerId = null;
    }
  };
  wrapFn.flush = () => {
    if (wrapFn.isPending) {
      me[cancelFn](wrapFn.timerId);
      wrapFn.timerId = null;
      wrapFn.invoker();
    }
  };
  wrapFn.now = (...args) => {
    wrapFn.cancel();
    wrapFn.args = args;
    wrapFn.invoker();
  };
  wrapFn.resume = (all) => {
    const n = wrapFn.suspended;
    wrapFn.suspended = all || n < 1 ? 0 : n - 1;
  };
  wrapFn.suspend = () => {
    ++wrapFn.suspended;
  };
  wrapFn.immediate = false;
  wrapFn.suspended = 0;
  wrapFn.timerId = null;
  defineProperty3(wrapFn, "isPending", {
    get() {
      return wrapFn.timerId !== null;
    }
  });
  return wrapFn;
};
var Delayable_default = (Target) => class Delayable extends (Target || Base) {
  static get $name() {
    return "Delayable";
  }
  static get declarable() {
    return [
      /**
       * This class property returns an object that specifies methods to wrap with configurable timer behaviors.
       *
       * It is used like so:
       * ```javascript
       *  class Foo extends Base.mixin(Delayable) {
       *      static get delayable() {
       *          return {
       *              expensiveMethod : 500
       *          };
       *      }
       *
       *      expensiveMethod() {
       *          this.things();
       *          this.moreThings();
       *          this.evenMoreThings();
       *      }
       *  }
       * ```
       * With the above in place, consider:
       * ```javascript
       *  let instance = new Foo();
       *
       *  instance.expensiveMethod();
       * ```
       * Instead of the above code immediately calling the `expensiveMethod()`, it will start a timer that will
       * invoke the method 500ms later. Because `expensiveMethod()` is an instance method, each instance of `Foo`
       * will have its own timer.
       *
       * NOTE: Only instance methods are currently supported (i.e., only non-`static` methods).
       *
       * #### Options
       * The value of each key configures how the method will be scheduled. If the value is a number, it is
       * promoted to a config object of `type='buffer'` as in the following:
       * ```javascript
       *  class Foo extends Base.mixin(Delayable) {
       *      static get delayable() {
       *          return {
       *              expensiveMethod : {
       *                  type  : 'buffer',
       *                  delay : 500
       *              }
       *          };
       *      }
       *  }
       * ```
       * The `type` property of the config object must be one of three values. Other options can be provided
       * depending on the `type`:
       *
       *  - `buffer`<br>
       *    Other options:
       *     - `delay` (Number) : The number of milliseconds to wait before calling the underlying method. A
       *       value of 0 is equivalent to setting `immediate: true`.
       *     - `immediate` (Boolean) : Set to `true` to call immediately (effectively disabling the buffer).
       *  - `raf` (short for "request animation frame")<br>
       *  - `idle` (short for "request idle callback") __Not available on Safari__ <br>
       *    Other options:
       *     - `cancelOutstanding` (Boolean) : Set to `true` to cancel any pending animation frame requests and
       *       schedule a new one on each call.
       *     - `immediate` (Boolean) : Set to `true` to call immediately.
       *  - `throttle`<br>
       *    Other options:
       *     - `delay` (Number) : The number of milliseconds to wait after each execution before another
       *       execution takes place. A value of 0 is equivalent to setting `immediate: true`.
       *     - `immediate` (Boolean) : Set to `true` to call immediately (effectively disabling the throttle).
       *
       * While `immediate: true` can be specified at the class level, it is more typical to set it on the
       * instance's method as described below.
       *
       * #### Delayable Method API
       * Delayable methods have a consistent API to manage their scheduling. This API is added to the methods
       * themselves.
       *
       * For example:
       * ```javascript
       *  let instance = new Foo();
       *
       *  instance.expensiveMethod();         // schedule a call in 500ms
       *  instance.expensiveMethod.isPending; // true
       *  instance.expensiveMethod.cancel();
       *  instance.expensiveMethod.flush();
       *  instance.expensiveMethod.now();
       *
       *  instance.expensiveMethod.delay = 10;
       *  instance.expensiveMethod();         // schedule a call in 10ms
       * ```
       *
       * ##### `isPending` (Boolean, readonly)
       * This boolean property will be `true` if a call has been scheduled, and false otherwise.
       *
       * ##### `cancel()`
       * Cancels a pending call if one has been scheduled. Otherwise this method does nothing.
       *
       * ##### `flush()`
       * Cancels the timer and causes the pending call to execute immediately. If there is no pending call, this
       * method does nothing.
       *
       * ##### `now()`
       * Cancels the timer (if one is pending) and executes the method immediately. If there is no pending call,
       * this method will still call the underlying method.
       *
       * @static
       * @member {Object<String,'raf'|Number|DelayableConfig>} delayable
       * @internal
       */
      "delayable"
    ];
  }
  doDestroy() {
    const me = this;
    super.doDestroy();
    if (me.timeoutIds) {
      me.timeoutIds.forEach((fn, id) => {
        if (typeof fn === "function") {
          fn();
        }
        clearTimeout(id);
        globalDelays == null ? void 0 : globalDelays.timeouts.delete(id);
      });
      me.timeoutIds = null;
    }
    if (me.timeoutMap) {
      me.timeoutMap.forEach((name, id) => clearTimeout(id));
      me.timeoutMap = null;
    }
    if (me.intervalIds) {
      me.intervalIds.forEach((id) => {
        clearInterval(id);
        globalDelays == null ? void 0 : globalDelays.intervals.delete(id);
      });
      me.intervalIds = null;
    }
    if (me.animationFrameIds) {
      me.animationFrameIds.forEach((id) => {
        cancelAnimationFrame(id);
        globalDelays == null ? void 0 : globalDelays.animationFrames.delete(id);
      });
      me.animationFrameIds = null;
    }
    if (me.idleCallbackIds) {
      me.idleCallbackIds.forEach((id) => {
        cancelIdleCallback(id);
        globalDelays == null ? void 0 : globalDelays.idleCallbacks.delete(id);
      });
      me.idleCallbackIds = null;
    }
  }
  /**
   * Check if a named timeout is active
   * @param name
   * @internal
   */
  hasTimeout(name) {
    var _a2;
    return Boolean((_a2 = this.timeoutMap) == null ? void 0 : _a2.has(name));
  }
  /**
   * Same as native setTimeout, but will be cleared automatically on destroy. If a propertyName is supplied it will
   * be used to store the timeout id.
   * @param {Object} timeoutSpec An object containing the details about that function, and the time delay.
   * @param {Function|String} timeoutSpec.fn The function to call, or name of function in this object to call. Used as the `name` parameter if a string.
   * @param {Number} timeoutSpec.delay The milliseconds to delay the call by.
   * @param {Object[]} timeoutSpec.args The arguments to pass.
   * @param {String} [timeoutSpec.name] The name under which to register the timer. Defaults to `fn.name`.
   * @param {Boolean} [timeoutSpec.runOnDestroy] Pass `true` if this function should be executed if the Delayable instance is destroyed while function is scheduled.
   * @param {Boolean} [timeoutSpec.cancelOutstanding] Pass `true` to cancel any outstanding invocation of the passed function.
   * @returns {Number}
   * @internal
   */
  setTimeout({ fn, delay, name, runOnDestroy, cancelOutstanding, args }) {
    if (arguments.length > 1 || typeof arguments[0] === "function") {
      [fn, delay, name, runOnDestroy] = arguments;
    }
    if (typeof fn === "string") {
      name = fn;
    } else if (!name) {
      name = fn.name || fn;
    }
    if (cancelOutstanding) {
      this.clearTimeout(name);
    }
    const me = this, timeoutIds = me.timeoutIds || (me.timeoutIds = /* @__PURE__ */ new Map()), timeoutMap = me.timeoutMap || (me.timeoutMap = /* @__PURE__ */ new Map()), timeoutId = setTimeout(() => {
      if (typeof fn === "string") {
        fn = me[name];
      }
      timeoutIds == null ? void 0 : timeoutIds.delete(timeoutId);
      timeoutMap == null ? void 0 : timeoutMap.delete(name);
      globalDelays == null ? void 0 : globalDelays.timeouts.delete(timeoutId);
      fn.apply(me, args);
    }, delay);
    timeoutIds.set(timeoutId, runOnDestroy ? fn : true);
    globalDelays == null ? void 0 : globalDelays.timeouts.set(timeoutId, {
      fn,
      delay,
      name
      /*, stack : new Error().stack*/
    });
    if (name) {
      timeoutMap.set(name, timeoutId);
    }
    return timeoutId;
  }
  /**
   * clearTimeout wrapper, either call with timeout id as normal clearTimeout or with timeout name (if you specified
   * a name to setTimeout())
   * property to null.
   * @param {Number|String} idOrName timeout id or name
   * @internal
   */
  clearTimeout(idOrName) {
    var _a2;
    let id = idOrName;
    if (typeof id === "string") {
      if (this.timeoutMap) {
        id = this.timeoutMap.get(idOrName);
        this.timeoutMap.delete(idOrName);
      } else {
        return;
      }
    }
    clearTimeout(id);
    (_a2 = this.timeoutIds) == null ? void 0 : _a2.delete(id);
    globalDelays == null ? void 0 : globalDelays.timeouts.delete(id);
  }
  /**
   * clearInterval wrapper
   * @param {Number} id
   * @internal
   */
  clearInterval(id) {
    var _a2;
    clearInterval(id);
    (_a2 = this.intervalIds) == null ? void 0 : _a2.delete(id);
    globalDelays == null ? void 0 : globalDelays.intervals.delete(id);
  }
  /**
   * Same as native setInterval, but will be cleared automatically on destroy
   * @param {Function} fn callback method
   * @param {Number} delay delay in milliseconds
   * @param {String} name delay name for debugging
   * @returns {Number}
   * @internal
   */
  setInterval(fn, delay, name) {
    const intervalId = setInterval(fn, delay);
    (this.intervalIds || (this.intervalIds = /* @__PURE__ */ new Set())).add(intervalId);
    globalDelays == null ? void 0 : globalDelays.intervals.set(intervalId, { fn, delay, name });
    return intervalId;
  }
  /**
   * Relays to native requestAnimationFrame and adds to tracking to have call automatically canceled on destroy.
   * @param {Function} fn
   * @param {Object[]} [extraArgs] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @returns {Number}
   * @internal
   */
  requestAnimationFrame(fn, extraArgs = [], thisObj = this) {
    const animationFrameIds = this.animationFrameIds || (this.animationFrameIds = /* @__PURE__ */ new Set()), frameId = requestAnimationFrame(() => {
      globalDelays == null ? void 0 : globalDelays.animationFrames.delete(frameId);
      animationFrameIds.delete(frameId) && fn.apply(thisObj, extraArgs);
    });
    animationFrameIds.add(frameId);
    globalDelays == null ? void 0 : globalDelays.animationFrames.set(frameId, { fn, extraArgs, thisObj });
    return frameId;
  }
  /**
   * Relays to native requestIdleCallback and adds to tracking to have call automatically canceled on destroy.
   * @param {Function} fn
   * @param {Object[]} [extraArgs] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @returns {Number}
   * @internal
   */
  requestIdleCallback(fn, extraArgs = [], thisObj = this) {
    const idleCallbackIds = this.idleCallbackIds || (this.idleCallbackIds = /* @__PURE__ */ new Set()), frameId = requestIdleCallback(() => {
      globalDelays == null ? void 0 : globalDelays.idleCallbacks.delete(frameId);
      idleCallbackIds.delete(frameId) && fn.apply(thisObj, extraArgs);
    });
    idleCallbackIds.add(frameId);
    globalDelays == null ? void 0 : globalDelays.idleCallbacks.set(frameId, { fn, extraArgs, thisObj });
    return frameId;
  }
  /**
   * Creates a function which will execute once, on the next animation frame. However many time it is
   * called in one event run, it will only be scheduled to run once.
   * @param {Function|String} fn The function to call, or name of function in this object to call.
   * @param {Object[]} [args] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Boolean} [cancelOutstanding] Cancel any outstanding queued invocation upon call.
   * @internal
   */
  createOnFrame(fn, args = [], thisObj = this, cancelOutstanding) {
    let rafId;
    const result = (...callArgs) => {
      if (rafId != null && cancelOutstanding) {
        this.cancelAnimationFrame(rafId);
        rafId = null;
      }
      if (rafId == null) {
        rafId = this.requestAnimationFrame(() => {
          if (typeof fn === "string") {
            fn = thisObj[fn];
          }
          rafId = null;
          callArgs.push(...args);
          fn.apply(thisObj, callArgs);
        });
      }
    };
    result.cancel = () => this.cancelAnimationFrame(rafId);
    return result;
  }
  /**
   * Relays to native cancelAnimationFrame and removes from tracking.
   * @param {Number} handle
   * @internal
   */
  cancelAnimationFrame(handle) {
    var _a2;
    cancelAnimationFrame(handle);
    (_a2 = this.animationFrameIds) == null ? void 0 : _a2.delete(handle);
    globalDelays == null ? void 0 : globalDelays.animationFrames.delete(handle);
  }
  /**
   * Relays to native cancelIdleCallback and removes from tracking.
   * @param {Number} handle
   * @internal
   */
  cancelIdleCallback(handle) {
    var _a2;
    cancelIdleCallback(handle);
    (_a2 = this.idleCallbackIds) == null ? void 0 : _a2.delete(handle);
    globalDelays == null ? void 0 : globalDelays.idleCallbacks.delete(handle);
  }
  async nextAnimationFrame() {
    return new Promise((resolve) => this.requestAnimationFrame(resolve));
  }
  /**
   * Wraps a function with another function that delays it specified amount of time, repeated calls to the wrapper
   * resets delay.
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Object|Number} options The delay in milliseconds or an options object.
   * @param {Number} options.delay The delay in milliseconds.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Object} [options.thisObj] The `this` reference for the function.
   * @returns {Function} Wrapped function to call.
   * @internal
   */
  buffer(fn, options) {
    let delay = options;
    if (options && typeof options !== "number") {
      delay = options.delay;
    } else {
      options = null;
    }
    const bufferWrapFn = (...params) => {
      if (bufferWrapFn.suspended) {
        return;
      }
      const { delay: delay2 } = bufferWrapFn;
      bufferWrapFn.cancel();
      bufferWrapFn.called = false;
      bufferWrapFn.args = params;
      if (bufferWrapFn.immediate || !delay2) {
        invoker();
      } else {
        bufferWrapFn.timerId = this.setTimeout(invoker, delay2);
      }
    }, invoker = makeInvoker(this, fn, bufferWrapFn, options);
    bufferWrapFn.delay = delay;
    return decorateWrapFn(this, bufferWrapFn);
  }
  /**
   * Returns a function that when called will schedule a call to `fn` on the next animation frame.
   *
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Boolean|Object} [options] An options object or the `cancelOutstanding` boolean property of it.
   * @param {Boolean} [options.cancelOutstanding] Pass `true` to cancel any pending animation frame requests and
   * schedule a new one on each call to the returned function.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Object} [options.thisObj] The `this` reference for the function.
   * @returns {Function}
   * @internal
   */
  raf(fn, options) {
    let cancelOutstanding = options;
    if (options && typeof options !== "boolean") {
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const rafWrapFn = (...params) => {
      if (rafWrapFn.suspended) {
        return;
      }
      if (rafWrapFn.cancelOutstanding) {
        rafWrapFn.cancel();
      }
      rafWrapFn.called = false;
      rafWrapFn.args = params;
      if (rafWrapFn.immediate) {
        invoker();
      } else if (!rafWrapFn.isPending) {
        rafWrapFn.timerId = this.requestAnimationFrame(invoker);
      }
    }, invoker = makeInvoker(this, fn, rafWrapFn, options);
    rafWrapFn.cancelOutstanding = cancelOutstanding;
    return decorateWrapFn(this, rafWrapFn, "cancelAnimationFrame");
  }
  idle(fn, options) {
    let cancelOutstanding = options;
    if (options && typeof options !== "boolean") {
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const idleWrapFn = (...params) => {
      if (idleWrapFn.suspended) {
        return;
      }
      if (idleWrapFn.cancelOutstanding) {
        idleWrapFn.cancel();
      }
      idleWrapFn.called = false;
      idleWrapFn.args = params;
      if (idleWrapFn.immediate) {
        invoker();
      } else if (!idleWrapFn.isPending) {
        idleWrapFn.timerId = this.requestIdleCallback(invoker);
      }
    }, invoker = makeInvoker(this, fn, idleWrapFn, options);
    idleWrapFn.cancelOutstanding = cancelOutstanding;
    this.setTimeout(() => this.idleCallbackIds.delete(idleWrapFn.timerId) && idleWrapFn.now(), 100);
    return decorateWrapFn(this, idleWrapFn, "cancelIdleCallback");
  }
  /**
   * Create a "debounced" function which will call on the "leading edge" of a timer period.
   * When first invoked will call immediately, but invocations after that inside its buffer
   * period will be rejected, and *one* invocation will be made after the buffer period has expired.
   *
   * This is useful for responding immediately to a first mousemove, but from then on, only
   * calling the action function on a regular timer while the mouse continues to move.
   *
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Number|Object} options The milliseconds to wait after each execution before another execution takes place
   * or a object containing options.
   * @param {Object} [options.thisObj] `this` reference for the function.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Function|String} [options.throttled] A function to call when the invocation is delayed due to buffer
   * time not having expired. If this is a string, it is looked up as a method on `this` instance (or `options.thisObj`
   * instead, if provided). When called, the same arguments are passed as would have been passed to `fn`, including
   * any `options.appendArgs`.
   * @internal
   */
  throttle(fn, options) {
    let delay = options, throttled;
    if (options && typeof options !== "number") {
      delay = options.delay;
      throttled = options.throttled;
    } else {
      options = null;
    }
    const me = this, throttleWrapFn = (...args) => {
      if (throttleWrapFn.suspended) {
        return;
      }
      const { delay: delay2 } = throttleWrapFn, elapsed = performance2.now() - throttleWrapFn.lastCallTime;
      throttleWrapFn.args = args;
      if (throttleWrapFn.immediate || elapsed >= delay2) {
        me.clearTimeout(throttleWrapFn.timerId);
        invoker();
      } else {
        if (!throttleWrapFn.isPending) {
          throttleWrapFn.timerId = me.setTimeout(invoker, delay2 - elapsed);
          throttleWrapFn.called = false;
        }
        if (throttled) {
          throttled.wrapFn.args = args;
          throttled();
        }
      }
    }, invoker = makeInvoker(me, fn, throttleWrapFn, options);
    throttleWrapFn.delay = delay;
    if (throttled) {
      throttled = makeInvoker(me, throttled, () => {
      }, options);
    }
    return decorateWrapFn(me, throttleWrapFn);
  }
  static setupDelayable(cls) {
    cls.setupDelayableMethods(cls.delayable);
  }
  /**
   * This method initializes the `delayable` methods on this class.
   * @param {Object} delayable The `delayable` property.
   * @param {Function} [cls] This parameter will be used internally to process static methods.
   * @private
   */
  static setupDelayableMethods(delayable, cls = null) {
    const me = this, statics = delayable.static, target = cls || me.prototype;
    if (statics) {
      delete delayable.static;
    }
    for (const name in delayable) {
      let options = delayable[name];
      const implName = name + "Now", type = typeof options;
      if (!target[implName]) {
        target[implName] = target[name];
      }
      if (type === "number") {
        options = {
          type: "buffer",
          delay: options
        };
      } else if (type === "string") {
        options = {
          type: options
        };
      }
      defineProperty3(target, name, {
        get() {
          const value = this[options.type]((...params) => {
            this[implName](...params);
          }, options);
          defineProperty3(this, name, { value });
          return value;
        }
      });
    }
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement thus.
  get widgetClass() {
  }
};

// ../Core/lib/Core/state/StateStorage.js
var StateStorage = class {
  /**
   * Returns an object with all stored keys and their values as its properties
   * @member {Object}
   */
  get data() {
    return /* @__PURE__ */ Object.create(null);
  }
  /**
   * Returns the stored keys as set by {@link #function-setItem}
   * @member {String[]}
   */
  get keys() {
    return [];
  }
  /**
   * Remove all stored keys
   */
  clear() {
  }
  /**
   * Returns key value as set by {@link #function-setItem}
   * @param {String} key
   * @returns {*}
   */
  getItem(key) {
    return null;
  }
  /**
   * Removes the specified key
   * @param {String} key
   */
  removeItem(key) {
  }
  /**
   * Sets the specified key to the given value
   * @param {String} key
   * @param {*} value The item value
   */
  setItem(key, value) {
  }
};
StateStorage._$name = "StateStorage";

// ../Core/lib/Core/state/StateProvider.js
var Local = class extends StateStorage {
  constructor(stateProvider) {
    super();
    this.prefix = stateProvider.prefix || "";
  }
  get isLocal() {
    return true;
  }
  get data() {
    const data = empty(), keys = this.keys;
    for (const key of keys) {
      data[key] = this.getItem(key);
    }
    return data;
  }
  get keys() {
    return getKeys(this.prefix, this.prefix.length);
  }
  clear() {
    const keys = getKeys(this.prefix);
    for (const key of keys) {
      localStorage.removeItem(key);
    }
  }
  getItem(key) {
    const value = localStorage.getItem(this.prefix + key);
    return value === null ? value : JSON.parse(value);
  }
  removeItem(key) {
    return localStorage.removeItem(this.prefix + key);
  }
  setItem(key, value) {
    return localStorage.setItem(this.prefix + key, JSON.stringify(value));
  }
};
var Memory = class extends StateStorage {
  constructor() {
    super();
    this.clear();
  }
  get isMemory() {
    return true;
  }
  get data() {
    return ObjectHelper.clone(this._data);
  }
  get keys() {
    return Object.keys(this._data);
  }
  clear() {
    this._data = empty();
  }
  getItem(key) {
    return key in this._data ? this._data[key] : null;
  }
  removeItem(key) {
    delete this._data[key];
  }
  setItem(key, value) {
    this._data[key] = value;
  }
};
var empty = () => /* @__PURE__ */ Object.create(null);
var getKeys = (prefix, pos = 0) => {
  const keys = [], count = localStorage.length;
  for (let key, i = 0; i < count; ++i) {
    key = localStorage.key(i);
    key.startsWith(prefix) && keys.push(key.slice(pos));
  }
  return keys;
};
var nullStorage = new StateStorage();
var storageTypes = {
  local: Local,
  memory: Memory
};
var StateProvider = class _StateProvider extends Base.mixin(Delayable_default, Events_default) {
  static get $name() {
    return "StateProvider";
  }
  static get configurable() {
    return {
      /**
       * The key prefix applied when using the `'local'` {@link #config-storage} type.
       * @config {String}
       * @default
       */
      prefix: "bryntum-state:",
      /**
       * Storage instance
       * @member {Core.state.StateStorage} storage
       */
      /**
       * One of the following storage types:
       *  - `local` : Stores data in the browser's `localStorage` using the {@link #config-prefix}.
       *  - `memory` : Stores data in the provider's memory.
       *
       * @config {'local'|'memory'|Core.state.StateStorage}
       * @default
       */
      storage: "local"
    };
  }
  static get delayable() {
    return {
      writeStatefuls: 50
    };
  }
  /**
   * The default {@link Core.mixin.State#config-stateProvider} for stateful objects.
   * @property {Core.state.StateProvider}
   */
  static get instance() {
    return this._instance;
  }
  static set instance(inst) {
    if (inst == null) {
      inst = nullProvider;
    } else {
      if (typeof inst === "string" || ObjectHelper.isClass(inst) || inst instanceof StateStorage) {
        inst = {
          storage: inst
        };
      }
      if (ObjectHelper.isObject(inst)) {
        inst = new _StateProvider(inst);
      }
    }
    this._instance = inst;
  }
  /**
   * Initializes the default `StateProvider` instance for the page. This method can be passed an instance or one of
   * the following type aliases:
   *
   *  - `'local'` : use `localStorage` to store application state (most common)
   *  - `'memory'` : holds application state in the `StateProvider` instance (used when state is saved to a server)
   *
   * Once the `StateProvider` is initialized, components that use {@link Core.mixin.State} and assign components a
   * {@link Core.mixin.State#config-stateId} will use this default provider to automatically save and restore their
   * state.
   *
   * @param {'local'|'memory'|Core.state.StateProvider} inst The state provider storage type ('local' or 'memory') or
   * the `StateProvider` instance.
   * @returns {Core.state.StateProvider}
   */
  static setup(inst) {
    this.instance = inst;
    return this.instance;
  }
  doDestroy() {
    self.writeStatefuls.flush();
    super.doDestroy();
  }
  /**
   * On read, this property returns all state data stored in the provider. On write, this property _adds_ all the
   * given values to the state provider's data. To replace the data, call {@link #function-clear} before assigning
   * this property. This is used to bulk populate this `StateProvider` with data for stateful components.
   * @member {Object}
   */
  get data() {
    return this.storage.data;
  }
  set data(data) {
    if (!data) {
      this.clear();
    } else {
      for (const key in data) {
        this.setValue(key, data[key]);
      }
    }
  }
  /**
   * Clears all state date
   * @returns {Core.state.StateProvider} this instance
   */
  clear() {
    this.storage.clear();
    return this;
  }
  changeStorage(storage) {
    if (storage == null) {
      storage = nullStorage;
    } else {
      if (typeof storage === "string") {
        if (!storageTypes[storage]) {
          throw new Error(`Invalid storage type "${storage}" (expected one of: "${Object.keys(storageTypes).join('", "')}")`);
        }
        storage = storageTypes[storage];
      }
      if (ObjectHelper.isClass(storage)) {
        storage = new storage(this);
      }
    }
    return storage;
  }
  /**
   * This method is called to schedule saving the given `stateful` object.
   * @param {Core.mixin.State} stateful The stateful object to save.
   * @param {Object} [options] An object of options that affect the state saving process.
   * @param {String} [options.id] The key for the saved state.
   * @param {Boolean} [options.immediate] Pass `true` to save the data synchronously instead of on a delay.
   * @internal
   */
  saveStateful(stateful, options) {
    (this.pendingSaves || (this.pendingSaves = [])).push([stateful, options]);
    this.writeStatefuls();
  }
  /**
   * A delayable method that flushes pending stateful objects.
   * @private
   */
  writeStatefuls() {
    const me = this, { pendingSaves } = me, n = pendingSaves == null ? void 0 : pendingSaves.length, stateIds = [], saved = [];
    me.pendingSaves = null;
    if (n) {
      for (let options, stateful, stateId, i = 0; i < n; ++i) {
        [stateful, options] = pendingSaves[i];
        if (!stateful.isDestroying && stateful.isSaveStatePending) {
          stateId = stateful.saveState({
            ...options,
            immediate: true
          });
          if (stateId) {
            stateIds.push(stateId);
            saved.push(stateful);
          }
        }
      }
      if (stateIds.length) {
        me.trigger("save", {
          stateIds,
          saved
        });
      }
    }
  }
  /**
   * Returns the stored state given its `key`.
   * @param {String} key The identifier of the state to return.
   * @returns {Object}
   */
  getValue(key) {
    this.writeStatefuls.flush();
    return this.storage.getItem(key);
  }
  /**
   * Stores the given state `value` under the specified `key`.
   * @param {String} key The identifier of the state value.
   * @param {Object} value The state value to set.
   * @returns {Core.state.StateProvider} this instance
   */
  setValue(key, value) {
    const me = this, { storage } = me, was = me.getValue(key);
    if (value != null) {
      storage.setItem(key, value);
      me.trigger("set", { key, value, was });
    } else if (was !== null) {
      storage.removeItem(key);
      me.trigger("remove", { key, was });
    }
    return me;
  }
};
var nullProvider = new StateProvider({
  storage: nullStorage
});
StateProvider._instance = nullProvider;
StateProvider._$name = "StateProvider";

// ../Core/lib/Core/mixin/State.js
var primitiveRe = /boolean|number|string/;
var State_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    afterConstruct() {
      super.afterConstruct();
      this.loadState();
    }
    finalizeInit() {
      this.loadState();
      super.finalizeInit();
    }
    /**
     * Returns `true` if this instance implements the {@link Core.mixin.State} interface.
     * @property {Boolean}
     * @readonly
     * @advanced
     */
    get isStateful() {
      return true;
    }
    /**
     * Returns `true` if this instance is ready to participate in state activities.
     * @property {Boolean}
     * @readonly
     * @internal
     */
    get isStatefulActive() {
      return !this.statefulSuspended && !this.isResponsivePending && !this.isResponsiveUpdating;
    }
    // state
    /**
     * Gets or sets a component's state
     * @property {Object}
     * @category State
     */
    get state() {
      return this._state = this.getState();
    }
    set state(state) {
      this._state = state;
      if (state) {
        this.applyState(state);
      }
    }
    // statefulEvents
    updateStatefulEvents(events) {
      var _a3;
      const me = this, listeners = {
        name: "statefulEvents",
        thisObj: me
      };
      me.detachListeners(listeners.name);
      if (events) {
        if (typeof events === "string") {
          events = StringHelper.split(events);
        } else if (!Array.isArray(events)) {
          events = ObjectHelper.getTruthyKeys(events);
        }
        if (events.length) {
          for (const event of events) {
            listeners[event] = "onStatefulEvent";
          }
          (_a3 = me.ion) == null ? void 0 : _a3.call(me, listeners);
        }
      }
    }
    // statefulId
    /**
     * Returns the state key to use for this instance. This will be either the {@link #config-stateId} or the
     * {@link Core.widget.Widget#config-id} (if explicitly specified and {@link #config-stateful} is not `false`).
     * @property {String}
     * @category State
     * @internal
     */
    get statefulId() {
      const me = this, { responsiveState } = me;
      let statefulId = me.stateId;
      if (statefulId == null && me.hasGeneratedId === false && me.stateful !== false) {
        statefulId = me.id;
      }
      if (statefulId && responsiveState) {
        statefulId = `${statefulId}[${responsiveState}]`;
      }
      return statefulId;
    }
    // statefulness
    /**
     * Returns an object whose truthy keys are the config properties to include in this object's {@link #property-state}.
     * @property {Object}
     * @category State
     * @readonly
     * @private
     */
    get statefulness() {
      const { stateful } = this;
      return Array.isArray(stateful) ? ObjectHelper.createTruthyKeys(stateful) : stateful;
    }
    // stateProvider
    get stateProvider() {
      return this._stateProvider || StateProvider.instance;
    }
    //---------------------------------------------------------------------------------------------------------------
    // Methods
    /**
     * Applies the given `state` to this instance.
     *
     * This method is not called directly, but is called when the {@link #property-state} property is assigned a value.
     *
     * This method is implemented by derived classes that have complex state which exceeds the simple list of config
     * properties provided by {@link #config-stateful}. In these cases, the `super` method can be called to handle any
     * config properties that are part of the complex state. The default implementation of this method will only assign
     * those config properties listed in {@link #config-stateful} from the provided `state` object.
     *
     * @param {Object} state The state object to apply to this instance.
     * @category State
     * @advanced
     */
    applyState(state) {
      state = this.pruneState(state);
      if (state) {
        this.setConfig(state);
      }
    }
    /**
     * Returns this object's state information.
     *
     * This method is not called directly, but is called to return the value of the {@link #property-state} property.
     *
     * This method is implemented by derived classes that have complex state which exceeds the simple list of config
     * properties provided by {@link #config-stateful}. In these cases, the `super` method can be called to gather the
     * config properties that are part of the complex state. The default implementation of this method will only copy
     * those config properties listed in {@link #config-stateful} to the returned `state` object.
     *
     * @returns {Object}
     * @category State
     * @advanced
     */
    getState() {
      const me = this, {
        initialConfig,
        statefulness,
        isConstructing: defaultState
      } = me, { configs } = me.$meta, source = defaultState ? Object.setPrototypeOf(initialConfig, me.$meta.config) : me;
      let state = null, key, value;
      if (statefulness) {
        state = {};
        for (key in statefulness) {
          if (statefulness[key]) {
            value = source[key];
            if (value == null ? void 0 : value.isStateful) {
              value = value.state;
            } else if (!defaultState) {
              if (ObjectHelper.isDate(value)) {
                value = DateHelper.format(value, "YYYY-MM-DDTHH:mm:ssZ");
              }
              if (configs[key].equal(value, initialConfig == null ? void 0 : initialConfig[key]) || !primitiveRe.test(typeof value)) {
                continue;
              }
            }
            state[key] = value;
          }
        }
      }
      return state;
    }
    /**
     * Loads this object's state from its {@link #config-stateProvider} and applies it to its {@link #property-state}.
     *
     * This method only acts upon its first invocation for a given instance (unless `true` is passed for the `reload`
     * parameter). This allows for flexibility in the timing of that call during the early stages of the instances'
     * lifecycle. To reload the state after this time, manually assign the desired value to the {@link #property-state}
     * property or call this method and pass `reload` as `true`.
     *
     * This method is called automatically during construction when a {@link #config-stateId} or (in some cases) an
     * explicit {@link Core.widget.Widget#config-id} is provided.
     *
     * @param {String} [stateId] An overriding key to use instead of this object's {@link #config-stateId}.
     * @param {Boolean} [reload=false] Pass `true` to load the state even if previously loaded.
     * @category State
     */
    loadState(stateId, reload) {
      if (typeof stateId === "boolean") {
        reload = stateId;
        stateId = null;
      }
      const me = this, { statefulLoaded } = me;
      if (me.isStatefulActive && (reload || !statefulLoaded)) {
        const state = me.loadStatefulData(stateId || (stateId = me.statefulId));
        if (!statefulLoaded && stateId) {
          me.defaultState = me.state;
          me.statefulLoaded = true;
        }
        if (state) {
          me.state = state;
        }
      }
    }
    loadStatefulData(stateId) {
      var _a3;
      stateId = this.isStatefulActive ? stateId || this.statefulId : null;
      return stateId && ((_a3 = this.stateProvider) == null ? void 0 : _a3.getValue(stateId));
    }
    resetDefaultState() {
      if (this.defaultState) {
        this.state = this.defaultState;
      }
    }
    resumeStateful(full = false) {
      this.statefulSuspended = full ? 0 : Math.max(this.statefulSuspended - 1, 0);
    }
    /**
     * Saves this object's state to its {@link #config-stateProvider}.
     *
     * When a {@link #config-stateId} or (in some cases) an explicit {@link Core.widget.Widget#config-id} is provided,
     * this method will be called automatically any time a config property listed in {@link #config-stateful} changes or
     * when a {@link #config-statefulEvents stateful event} is fired.
     *
     * Derived classes are responsible for calling this method whenever the persistent {@link #property-state} of the
     * object changes.
     *
     * @param {Object|String} [options] Options that affect the state saving process or, if a string, the state `id`.
     * @param {String} [options.id] The state id for the saved state (overrides {@link #config-stateId}).
     * @param {Boolean} [options.immediate] Pass `true` to save the data synchronously instead of on a delay.
     * @category State
     */
    saveState(options) {
      if (typeof options === "string") {
        options = {
          id: options
        };
      } else {
        options = options || {};
      }
      const me = this, { stateProvider } = me, statefulId = options.id || me.isStatefulActive && me.statefulId;
      if (statefulId && stateProvider) {
        if (options.immediate) {
          me.isSaveStatePending = false;
          stateProvider.setValue(statefulId, me.state);
        } else if (!me.isSaveStatePending) {
          me.isSaveStatePending = true;
          stateProvider.saveStateful(me, options);
        }
        return statefulId;
      }
    }
    suspendStateful() {
      ++this.statefulSuspended;
    }
    //---------------------------------------------------------------------------------------------------------------
    // Private / Internal
    onConfigChange({ name, value, was, config }) {
      super.onConfigChange({ name, value, was, config });
      if (!this.isConstructing && this.isStatefulActive && this.statefulId) {
        const { stateful } = this;
        if (Array.isArray(stateful) ? stateful.includes(name) : stateful == null ? void 0 : stateful[name]) {
          this.saveState();
        }
      }
    }
    onStatefulEvent() {
      if (!this.isConstructing) {
        this.saveState();
      }
    }
    /**
     * Returns an object that copies the {@link #config-stateful} config properties from the provided `state` object.
     *
     * @param {Object} state A state object from which to copy stateful configs.
     * @returns {Object}
     * @category State
     * @private
     */
    pruneState(state) {
      const { statefulness } = this;
      if (statefulness) {
        const pruned = {};
        for (const key in state) {
          if (statefulness[key]) {
            pruned[key] = state[key];
          }
        }
        state = pruned;
      }
      return state;
    }
    //---------------------------------------------------------------------------------------------------------------
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {
    }
  }, __publicField(_a2, "$name", "State"), __publicField(_a2, "configurable", {
    /**
     * This value can be one of the following:
     *
     * - `false` to not use an explicitly assigned {@link Core.widget.Widget#config-id} as the component's
     * {@link #config-stateId} (this is only necessary when there is a {@link #config-stateProvider}).
     * - An array of strings naming the config properties to save in the component's {@link #property-state}
     * object.
     * - An object whose truthy keys are the config properties to save in the component's {@link #property-state}
     * object.
     *
     * These last two uses of the `stateful` config property do not apply to components that have a complex
     * state, as described in the {@link Core.mixin.State State mixin documentation}.
     *
     * This config property is typically set by derived classes to a value including any config property that
     * the user can affect via the user interface. For example, the {@link Core.widget.Panel#config-collapsed}
     * config property is listed for a {@link Core.widget.Panel} since the user can toggle this config property
     * using the {@link Core.widget.panel.PanelCollapser#config-tool collapse tool}.
     *
     * @config {Boolean|Object|String[]}
     * @category State
     */
    stateful: {
      value: null,
      $config: {
        merge: "classList"
      }
    },
    /**
     * The events that, when fired by this component, should trigger it to save its state by calling
     * {@link #function-saveState}.
     *
     * ```javascript
     *  class MyStatefulComponent extends Base.mixin(State) {
     *      static get configurable() {
     *          return {
     *              statefulEvents : [ 'change', 'resize' ]
     *          };
     *      }
     *  }
     * ```
     * In the above example, {@link #function-saveState} will be called any time an instance of this class
     * fires the `change` or `resize` event.
     *
     * This config is typically set by derived classes as a way to ensure {@link #function-saveState} is called
     * whenever their persistent state changes.
     *
     * @config {Object|String[]}
     * @category State
     * @default
     */
    statefulEvents: {
      $config: {
        merge: "classList"
      },
      value: ["stateChange"]
    },
    /**
     * The key to use when saving this object's state in the {@link #config-stateProvider}. If this config is
     * not assigned, and {@link #config-stateful} is not set to `false`, the {@link Core.widget.Widget#config-id}
     * (if explicitly specified) will be used as the `stateId`.
     *
     * If neither of these is given, the {@link #function-loadState} and {@link #function-saveState} methods
     * will need to be called directly to make use of the `stateProvider`.
     *
     * For single page applications (SPA's), or multi-page applications (MPA's) that have common, stateful
     * components on multiple pages, the `stateId` should be unique across all stateful components (similar to DOM
     * element id's). MPA's that want each page to be isolated can more easily achieve that isolation using the
     * {@link Core.state.StateProvider#config-prefix}.
     *
     * @config {String}
     * @category State
     */
    stateId: null,
    /**
     * The `StateProvider` to use to save and restore this object's {@link #property-state}. By default, `state`
     * will be saved using the {@link Core.state.StateProvider#property-instance-static default state provider}.
     *
     * This config is useful for multi-page applications that have a set of common components that want to share
     * state across pages, as well as other components that want their state to be isolated. One of these groups
     * of stateful components could be assigned an explicit `stateProvider` while the other group could use the
     * default state provider.
     *
     * @config {Core.state.StateProvider}
     * @category State
     */
    stateProvider: null
  }), __publicField(_a2, "prototypeProperties", {
    statefulLoaded: false,
    statefulSuspended: 0
  }), _a2;
};

// ../Core/lib/Core/mixin/Identifiable.js
var idCounts = ObjectHelper.getPathDefault(globalThis, "bryntum.idCounts", /* @__PURE__ */ Object.create(null));
var idTypes = {
  string: 1,
  number: 1
};
var Identifiable_default = (Target) => class Identifiable extends (Target || Base) {
  static get $name() {
    return "Identifiable";
  }
  static get declarable() {
    return [
      "identifiable"
    ];
  }
  static get configurable() {
    return {
      /**
       * The id of this object.  If not specified one will be generated. Also used for lookups through the
       * static `getById` of the class which mixes this in. An example being {@link Core.widget.Widget}.
       *
       * For a {@link Core.widget.Widget Widget}, this is assigned as the `id` of the DOM
       * {@link Core.widget.Widget#config-element element} and must be unique across all elements
       * in the page's `document`.
       * @config {String}
       * @category Common
       */
      id: ""
    };
  }
  static setupIdentifiable(cls, meta) {
    const { identifiable } = cls;
    identifiable.idMap = /* @__PURE__ */ Object.create(null);
    Reflect.defineProperty(cls, "identifiable", {
      get() {
        return identifiable;
      }
    });
  }
  doDestroy() {
    this.constructor.unregisterInstance(this);
    super.doDestroy();
  }
  changeId(id) {
    return (this.hasGeneratedId = !id) ? this.generateAutoId() : id;
  }
  updateId(id, oldId) {
    const me = this, C = me.constructor;
    oldId && C.unregisterInstance(me, oldId);
    if (!me.hasGeneratedId || C.identifiable.registerGeneratedId !== false) {
      C.registerInstance(me, id);
    }
  }
  /**
   * This method generates an id for this instance.
   * @returns {String}
   * @internal
   */
  generateAutoId() {
    return this.constructor.generateId(`b-${this.$$name.toLowerCase()}-`);
  }
  static get all() {
    return Object.values(this.identifiable.idMap);
  }
  /**
   * Generate a new id, using an internal counter and a prefix.
   * @param {String} prefix Id prefix
   * @returns {String} Generated id
   */
  static generateId(prefix = "generatedId") {
    return prefix + (idCounts[prefix] = (idCounts[prefix] || 0) + 1);
  }
  static registerInstance(instance, instanceId = instance.id) {
    const { idMap } = this.identifiable;
    if (instanceId in idMap && !this.disableThrow) {
      throw new Error("Id " + instanceId + " already in use");
    }
    idMap[instanceId] = instance;
  }
  /**
   * Unregister Identifiable instance, normally done on destruction
   * @param {Object} instance Object to unregister
   * @param {String} id The id of the instance to unregister.
   */
  static unregisterInstance(instance, id = instance.id) {
    const { idMap } = this.identifiable;
    if (idTypes[typeof instance]) {
      delete idMap[instance];
    } else if (idMap[id] === instance) {
      delete idMap[id];
    }
  }
  static getById(id) {
    const idMap = this.identifiable.idMap;
    if (idMap) {
      return idMap[id];
    }
  }
  static get registeredInstances() {
    const idMap = this.identifiable.idMap;
    return idMap ? Object.values(idMap) : [];
  }
};

// ../Core/lib/Core/data/stm/mixin/ModelStm.js
var STM_PROP = Symbol("STM_PROP");
var unrecordedFields = {
  // This field's value is a by product of node insertion and must not be recorded here.
  // It's the node insertion operation which is recorded by STM.
  parentIndex: 1
};
var ModelStm_default = (Target) => class ModelStm extends (Target || Base) {
  static get $name() {
    return "ModelStm";
  }
  static get defaultConfig() {
    return {
      stm: null
    };
  }
  joinStore(store) {
    if (!this.stm) {
      this.stm = store.stm;
    }
  }
  unjoinStore(store, isReplacing = false) {
    var _a2;
    if (this.stm === store.stm) {
      this.stm = null;
    }
    (_a2 = super.unjoinStore) == null ? void 0 : _a2.call(this, store, isReplacing);
  }
  /**
   * Reference to STM manager, if used
   * @member {Core.data.stm.StateTrackingManager}
   * @category Misc
   */
  get stm() {
    return this[STM_PROP];
  }
  set stm(stm) {
    this[STM_PROP] = stm;
  }
  // Hook for chronograph entity field accessors, for example; task.duration = 123.
  // Triggers before setting the value.
  beforeChronoFieldSet(fieldName, value) {
    var _a2;
    const me = this;
    if (!me.inSetting && ((_a2 = me.stm) == null ? void 0 : _a2.enabled) && !unrecordedFields[fieldName] && !me.constructor.nonPersistableFields[fieldName]) {
      if (me.getFieldDefinition(fieldName)) {
        return { [fieldName]: { value, oldValue: me[fieldName] } };
      }
    }
    return null;
  }
  // Hook for chronograph entity field accessors, for example; task.duration = 123
  // Triggers after setting the value.
  afterChronoFieldSet(fieldName, value, wasSet) {
    wasSet && this.afterSet(fieldName, value, false, false, wasSet, true);
  }
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    const store = this.firstStore;
    return !(this.constructor.nonPersistableFields[fieldName] || oldValue == null && newValue == null || oldValue === newValue || oldValue instanceof Date && newValue instanceof Date && oldValue.getTime() === newValue.getTime() || fieldName === "id" || fieldName === "$PhantomId" || fieldName === "parentId" && store && store.oldIdMap[oldValue] === store.getById(newValue));
  }
  /**
   * Overridden to store initial data of the changed fields and to notify STM
   * manager about the change action if anything has been changed in result.
   *
   * The method is called from within {@link Core/data/Model#function-set} method.
   *
   * @private
   */
  afterSet(field, value, silent, fromRelationUpdate, wasSet, isChronoFieldSet) {
    const { stm } = this, nonPersistableFields = this.constructor.nonPersistableFields;
    if ((stm == null ? void 0 : stm.isBase) && stm.enabled && !unrecordedFields[field] && !nonPersistableFields[field]) {
      if (wasSet) {
        let shouldRecord;
        const [newData, oldData] = Object.keys(wasSet).reduce(
          (data, fieldName) => {
            const { value: value2, oldValue } = wasSet[fieldName];
            if (this.shouldRecordFieldChange(fieldName, oldValue, value2)) {
              shouldRecord = true;
              data[0][fieldName] = value2;
              data[1][fieldName] = oldValue;
            }
            return data;
          },
          [{}, {}]
        );
        if (shouldRecord) {
          stm.onModelUpdate(this, newData, oldData, isChronoFieldSet);
        }
      }
    }
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to obtain inserted
   * records initial parents and parent index, to be able to restore the state back upon undo.
   *
   * @param {Core.data.Model[]} childRecords
   * @returns {Array} Array of results from this call and any of super calls if any.
   *               This result is consumed by {@link #function-afterInsertChild} which pops
   *               from the result array to take only results of this method call and leave
   *               results from super calls untouched.
   *
   * @private
   */
  beforeInsertChild(childRecords) {
    var _a2;
    const preResult = ((_a2 = super.beforeInsertChild) == null ? void 0 : _a2.call(this, childRecords)) || [], { stm } = this;
    if (stm == null ? void 0 : stm.enabled) {
      preResult.push(
        childRecords.reduce((result, childRecord) => {
          if (childRecord.root === this.root) {
            result.set(childRecord, {
              parent: childRecord.parent,
              index: childRecord.parent ? childRecord.parentIndex : void 0
            });
          }
          return result;
        }, /* @__PURE__ */ new Map())
      );
    }
    return preResult;
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to notify {@link Core/data/stm/StateTrackingManager}
   * about children insertion. Provides it with all necessary context information collected
   * in {@link #function-beforeInsertChild} required to undo/redo the action.
   *
   * @private
   */
  afterInsertChild(index, childRecords, beforeResult, inserted) {
    var _a2;
    const { stm } = this;
    if (stm == null ? void 0 : stm.enabled) {
      const context = beforeResult.pop();
      if (inserted) {
        stm.onModelInsertChild(this, index, inserted, context);
      }
    }
    (_a2 = super.afterInsertChild) == null ? void 0 : _a2.call(this, index, childRecords, beforeResult, inserted);
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to obtain removed
   * records initial parent index, to be able to restore the state back upon undo.
   *
   * @param {Core.data.Model[]} childRecords
   * @param {Boolean} isMove
   * @returns {Array} Array of results from this call and any of super calls if any.
   *               This result is consumed by {@link #function-afterRemoveChild} which pops
   *               from the result array to take only results of this method call and leave
   *               results from super calls untouched.
   *
   * @private
   */
  beforeRemoveChild(childRecords, isMove) {
    const preResult = super.beforeRemoveChild ? super.beforeRemoveChild(childRecords, isMove) : [], { stm } = this;
    if ((stm == null ? void 0 : stm.enabled) && !isMove) {
      preResult.push(
        childRecords.reduce((result, childRecord) => {
          result.set(childRecord, { parentIndex: childRecord.parentIndex, orderedParentIndex: childRecord.orderedParentIndex });
          return result;
        }, /* @__PURE__ */ new Map())
      );
    }
    return preResult;
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to notify {@link Core/data/stm/StateTrackingManager}
   * about children removing. Provides it with all necessary context information collected
   * in {@link #function-beforeRemoveChild} required to undo/redo the action.
   *
   * @private
   */
  afterRemoveChild(childRecords, beforeResult, isMove) {
    var _a2;
    const { stm } = this;
    if ((stm == null ? void 0 : stm.enabled) && !isMove) {
      const context = beforeResult.pop();
      if (childRecords && childRecords.length) {
        stm.onModelRemoveChild(this, childRecords, context);
      }
    }
    (_a2 = super.afterRemoveChild) == null ? void 0 : _a2.call(this, childRecords, beforeResult, isMove);
  }
};

// ../Core/lib/Core/data/mixin/TreeNode.js
var defaultTraverseOptions = {
  includeFilteredOutRecords: false
};
var fixTraverseOptions = (options) => {
  options = options || false;
  if (typeof options === "boolean") {
    options = {
      includeFilteredOutRecords: options
    };
  }
  return options || defaultTraverseOptions;
};
var TreeNode_default = (Target) => class TreeNode extends (Target || Base) {
  static get $name() {
    return "TreeNode";
  }
  /**
   * This static configuration option allows you to control whether an empty parent task should be converted into a
   * leaf. Enable/disable it for a whole class:
   *
   * ```javascript
   * Model.convertEmptyParentToLeaf = false;
   * ```
   *
   * By specifying `true`, all empty parents will be considered leafs. Can also be assigned a configuration object
   * with the following Boolean properties to customize the behaviour:
   *
   * ```javascript
   * Model.convertEmptyParentToLeaf = {
   *     onLoad   : false,
   *     onRemove : true
   * }
   * ```
   *
   * @member {Boolean|{ onLoad : Boolean, onRemove : Boolean }} convertEmptyParentToLeaf
   * @property {Boolean} onLoad Apply the transformation on load to any parents without children (`children : []`)
   * @property {Boolean} onRemove Apply the transformation when all children have been removed from a parent
   * @default false
   * @static
   * @category Parent & children
   * */
  static set convertEmptyParentToLeaf(value) {
    if (value === true) {
      value = {
        onLoad: true,
        onRemove: true
      };
    } else if (value === false) {
      value = {
        onLoad: false,
        onRemove: false
      };
    }
    this._convertEmptyParentToLeaf = value;
  }
  constructor(...args) {
    super(...args);
    if (this.children) {
      this.orderedChildren = this.orderedChildren || [];
    }
  }
  static get convertEmptyParentToLeaf() {
    return this._convertEmptyParentToLeaf || { onLoad: false, onRemove: false };
  }
  /**
   * This is a read-only property providing access to the parent node.
   * @member {Core.data.Model} parent
   * @readonly
   * @category Parent & children
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which record id is the parent of the record.
   * @readonly
   * @field {String|Number|null} parentId
   * @category Tree
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which position the node takes in the parent's children array.
   * This index is set on load and gets updated automatically after row reordering, sorting, etc.
   * To save the order, need to persist the field on the server and when data is fetched to be loaded,
   * need to sort by this field.
   * @readonly
   * @field {Number} parentIndex
   * @category Tree
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which position the node takes in the parent's ordered children array.
   * This index is set on load and gets updated on reordering nodes in tree. Sorting and filtering
   * have no effect on it.
   * @readonly
   * @field {Number} orderedParentIndex
   * @category Tree
   */
  ingestChildren(childRecord, stores = this.stores) {
    const { inProcessChildren, constructor: MyClass } = this, store = stores[0];
    if (childRecord === true) {
      if (inProcessChildren) {
        return true;
      }
      return [];
    }
    if (childRecord) {
      childRecord = ArrayHelper.asArray(childRecord);
      const len = childRecord.length, result = [];
      for (let i = 0, child; i < len; i++) {
        child = childRecord[i];
        child = child.isModel ? child : store ? store.createRecord(child, false, true) : new MyClass(child, null, null, true);
        child = store ? store.processRecord(child) : child;
        result.push(child);
      }
      if (this.children === true && store) {
        const sorter = store.createSorterFn(store.sorters);
        result.sort(sorter);
      }
      return result;
    }
  }
  /**
   * Child nodes. To allow loading children on demand, specify `children : true` in your data. Omit the field for leaf
   * tasks.
   *
   * Note, if the tree store loads data from a remote origin, make sure {@link Core/data/AjaxStore#config-readUrl}
   * is specified, and optionally {@link Core/data/AjaxStore#config-parentIdParamName} is set, otherwise
   * {@link Core/data/Store#function-loadChildren} has to be implemented.
   * @field {Boolean|Object[]|Core.data.Model[]} children
   * @readonly
   * @category Parent & children
   */
  /**
   * Array of tree nodes without any filter applied. On first filter, will take order from sorted `children`, but
   * is not thereafter kept in sorted order, so order should not be relied upon.
   * @member {Core.data.Model[]|null} unfilteredChildren
   * @category Parent & children
   * @private
   */
  /**
   * Array of children unaffected by sorting and filtering, keeps original tree structure
   * @member {Core.data.Model[]|null} orderedChildren
   * @category Parent & children
   * @private
   */
  /**
   * Called during creation to also turn any children into Models joined to the same stores as this model
   * @internal
   * @category Parent & children
   */
  processChildren(stores = this.stores) {
    const me = this, { meta } = me;
    me.inProcessChildren = true;
    const children = me.ingestChildren(me.data[me.constructor.childrenField], stores);
    if (children) {
      const { convertEmptyParentToLeaf } = me.constructor, shouldConvert = convertEmptyParentToLeaf === true || convertEmptyParentToLeaf.onLoad;
      if (shouldConvert ? children.length : Array.isArray(children)) {
        meta.isLeaf = false;
        if (me.children === true) {
          me.children = [];
        } else if (children.length === 0) {
          me.children = children;
          return;
        }
        me.insertChild(children);
      } else if (children === true) {
        meta.isLeaf = false;
        me.children = true;
      } else if (!me.isRoot) {
        meta.isLeaf = me.constructor.convertEmptyParentToLeaf.onLoad;
      }
    }
    me.inProcessChildren = false;
  }
  /**
   * This method returns `true` if this record has all expanded ancestors and is therefore
   * eligible for inclusion in a UI.
   * @param {Core.data.Store} [store] Optional store, defaults to nodes first store
   * @returns {Boolean}
   * @readonly
   * @category Parent & children
   * @returns {Boolean}
   */
  ancestorsExpanded(store = this.firstStore) {
    const { parent } = this;
    return !parent || parent.isExpanded(store) && parent.ancestorsExpanded(store);
  }
  /**
   * Used by stores to assess the record's collapsed/expanded state in that store.
   * @param {Core.data.Store} store
   * @category Parent & children
   * @returns {Boolean}
   */
  isExpanded(store = this.firstStore) {
    const mapMeta = this.instanceMeta(store.id);
    if (!Object.prototype.hasOwnProperty.call(mapMeta, "collapsed")) {
      mapMeta.collapsed = !this.expanded;
    }
    return !mapMeta.collapsed;
  }
  // A read-only property. It provides the initial state upon load
  // The UI's expanded/collapsed state is in the store's meta map.
  get expanded() {
    return this.data.expanded;
  }
  /**
   * Depth in the tree at which this node exists. First visual level of nodes are at level 0, their direct children at
   * level 1 and so on.
   * @property {Number}
   * @readonly
   * @category Parent & children
   */
  get childLevel() {
    let node = this, ret = -1;
    while (node && !node.isRoot) {
      ++ret;
      node = node.parent;
    }
    return ret;
  }
  /**
   * Is a leaf node in a tree structure?
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isLeaf() {
    return this.meta.isLeaf !== false && !this.isRoot;
  }
  /**
   * Returns `true` if this node is the root of the tree
   * @member {Boolean} isRoot
   * @readonly
   * @category Parent & children
   */
  /**
   * Is a parent node in a tree structure?
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isParent() {
    return !this.isLeaf;
  }
  /**
   * Returns true for parent nodes with children loaded (there might still be no children)
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isLoaded() {
    return this.isParent && Array.isArray(this.children);
  }
  /**
   * Count all children (including sub-children) for a node (in its `firstStore´)
   * @member {Number}
   * @category Parent & children
   */
  get descendantCount() {
    return this.getDescendantCount();
  }
  /**
   * Count visible (expanded) children (including sub-children) for a node (in its `firstStore`)
   * @member {Number}
   * @category Parent & children
   */
  get visibleDescendantCount() {
    return this.getDescendantCount(true);
  }
  /**
   * Count visible (expanded)/all children for this node, optionally specifying for which store.
   * @param {Boolean} [onlyVisible] Specify `true` to only count visible (expanded) children.
   * @param {Core.data.Store} [store] A Store to which this node belongs
   * @returns {Number}
   * @category Parent & children
   */
  getDescendantCount(onlyVisible = false, store = this.firstStore) {
    const { children } = this;
    if (!children || !Array.isArray(children) || onlyVisible && !this.isExpanded(store)) {
      return 0;
    }
    return children.reduce((count, child) => count + child.getDescendantCount(onlyVisible), children.length);
  }
  /**
   * Retrieve all children, not including filtered out nodes (by traversing sub nodes)
   * @property {Core.data.Model[]}
   * @category Parent & children
   */
  get allChildren() {
    return this.getAllChildren(false);
  }
  /**
   * Retrieve all children, including filtered out nodes (by traversing sub nodes)
   * @property {Core.data.Model[]}
   * @private
   * @category Parent & children
   */
  get allUnfilteredChildren() {
    return this.getAllChildren(true);
  }
  getAllChildren(unfiltered = false) {
    const { [unfiltered ? "unfilteredChildren" : "children"]: children } = this;
    if (!children || children === true) {
      return [];
    }
    return children.reduce((all, child) => {
      all.push(child);
      all.push.apply(all, unfiltered ? child.allUnfilteredChildren : child.allChildren);
      return all;
    }, []);
  }
  /**
   * Get the first child of this node
   * @property {Core.data.Model}
   * @readonly
   * @category Parent & children
   */
  get firstChild() {
    const { children } = this;
    return (children == null ? void 0 : children.length) && children[0] || null;
  }
  /**
   * Get the last child of this node
   * @property {Core.data.Model}
   * @readonly
   * @category Parent & children
   */
  get lastChild() {
    const { children } = this;
    return (children == null ? void 0 : children.length) && children[children.length - 1] || null;
  }
  /**
   * Get the previous sibling of this node
   * @member {Core.data.Model} previousSibling
   * @readonly
   * @category Parent & children
   */
  /**
   * Get the next sibling of this node
   * @member {Core.data.Model} nextSibling
   * @readonly
   * @category Parent & children
   */
  /**
   * Returns count of all preceding sibling nodes (including their children).
   * @property {Number}
   * @category Parent & children
   */
  get previousSiblingsTotalCount() {
    let task = this.previousSibling, count = this.parentIndex;
    while (task) {
      count += task.descendantCount;
      task = task.previousSibling;
    }
    return count;
  }
  // This pair of accessors should never return undefined. This is required by `add task below` logic, which is trying
  // to get a task from the ordered tree, before which insert should happen. In the `addToChildren` logic there is a
  // distinction between `null` and `undefined`. `undefined` falls back to reference task in a visual tree, `null`
  // is meant to point out we should insert to the end of the ordered children list. This is really required for
  // `nextOrderedSibling`, another accessor is modified to keep behavior consistent.
  // https://github.com/bryntum/support/issues/7323
  get previousOrderedSibling() {
    var _a2, _b;
    return (_b = (_a2 = this.parent) == null ? void 0 : _a2.orderedChildren[this.orderedParentIndex - 1]) != null ? _b : null;
  }
  get nextOrderedSibling() {
    var _a2, _b;
    return (_b = (_a2 = this.parent) == null ? void 0 : _a2.orderedChildren[this.orderedParentIndex + 1]) != null ? _b : null;
  }
  get root() {
    var _a2;
    return ((_a2 = this.parent) == null ? void 0 : _a2.root) || this;
  }
  /**
   * Reading this property returns the id of the parent node, if this record is a child of a node.
   *
   * Setting this property appends this record to the record with the passed id **in the same store that this record
   * is already in**.
   *
   * Note that setting this property is **only valid if this record is already part of a tree store**.
   *
   * This is not intended for general use. This is for when a server responds to a record mutation and the server
   * decides to move a record to a new parent. If a `parentId` property is passed in the response data for a record,
   * that record will be moved.
   *
   * @property {Number|String|null}
   * @category Parent & children
   */
  get parentId() {
    return this.parent && !this.parent.isAutoRoot ? this.parent.id : null;
  }
  set parentId(parentId) {
    const me = this, { parent } = me, newParent = parentId === null ? me.firstStore.rootNode : me.firstStore.getById(parentId);
    if (!(newParent === parent || !parent && !newParent)) {
      if (me.isBatchUpdating) {
        me.meta.batchChanges.parentId = parentId;
      } else {
        if (newParent) {
          newParent.appendChild(me);
        } else {
          me.parent.removeChild(me);
        }
      }
    }
  }
  static set parentIdField(parentIdField) {
    this._parentIdField = parentIdField;
    Object.defineProperty(this.prototype, parentIdField, {
      set: function(parentId) {
        this.parentId = parentId;
      },
      get: function() {
        return this.parentId;
      }
    });
  }
  static get parentIdField() {
    return this._parentIdField || "parentId";
  }
  getChildren(options) {
    let result;
    if (options.includeFilteredOutRecords) {
      result = this.unfilteredChildren || this.children;
    } else if (options.useOrderedTree) {
      result = this.orderedChildren;
    } else {
      result = this.children;
    }
    return result;
  }
  /**
   * Traverses all child nodes recursively calling the passed function
   * on a target node **before** iterating the child nodes.
   * @param {Function} fn The function to call
   * @param {Boolean} [skipSelf=false] True to ignore self
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.useOrderedTree] True to traverse unsorted/unfiltered tree
   * @category Parent & children
   */
  traverse(fn, skipSelf, options) {
    options = fixTraverseOptions(options);
    const me = this, children = me.getChildren(options);
    if (!skipSelf) {
      fn.call(me, me);
    }
    for (let i = 0, l = children == null ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn, false, options);
    }
  }
  /**
   * Traverses all child nodes recursively calling the passed function
   * on child nodes of a target **before** calling it on the node.
   * @param {Function} fn The function to call
   * @param {Boolean} [skipSelf=false] True to skip this node in the traversal
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @category Parent & children
   */
  traverseBefore(fn, skipSelf, options) {
    options = fixTraverseOptions(options);
    const me = this, children = me.getChildren(options);
    for (let i = 0, l = children == null ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn, false, options);
    }
    if (!skipSelf) {
      fn.call(me, me);
    }
  }
  /**
   * Traverses child nodes recursively while fn returns true
   * @param {Function} fn
   * @param {Boolean} [skipSelf=false] True to skip this node in the traversal
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @category Parent & children
   * @returns {Boolean}
   */
  traverseWhile(fn, skipSelf, options) {
    options = fixTraverseOptions(options);
    const me = this;
    let goOn = skipSelf || fn.call(me, me) !== false;
    if (goOn) {
      const children = me.getChildren(options);
      if (children == null ? void 0 : children.length) {
        goOn = children.every((child) => child.traverseWhile(fn, false, options));
      }
    }
    return goOn;
  }
  /**
   * Bubbles up from this node, calling the specified function with each node.
   *
   * @param {Function} fn The function to call for each node
   * @param {Boolean} [skipSelf] True to skip this node in the traversal
   * @category Parent & children
   */
  bubble(fn, skipSelf = false) {
    let me = this;
    if (!skipSelf) {
      fn.call(me, me);
    }
    while (me.parent) {
      me = me.parent;
      fn.call(me, me);
    }
  }
  /**
   * Bubbles up from this node, calling the specified function with each node,
   * while the function returns true.
   *
   * @param {Function} fn The function to call for each node
   * @param {Boolean} [skipSelf] True to skip this node in the traversal
   * @category Parent & children
   * @returns {Boolean}
   */
  bubbleWhile(fn, skipSelf = false) {
    let me = this, goOn = true;
    if (!skipSelf) {
      goOn = fn.call(me, me);
    }
    while (goOn && me.parent) {
      me = me.parent;
      goOn = fn.call(me, me);
    }
    return goOn;
  }
  /**
   * Checks if this model contains another model as one of it's descendants
   *
   * @param {Core.data.Model|String|Number} childOrId child node or id
   * @param {Boolean} [skipSelf=false] True to ignore self in the traversal
   * @category Parent & children
   * @returns {Boolean}
   */
  contains(childOrId, skipSelf = false) {
    if (childOrId && typeof childOrId === "object") {
      childOrId = childOrId.id;
    }
    return !this.traverseWhile((node) => node.id != childOrId, skipSelf);
  }
  getTopParent(all) {
    let result;
    if (all) {
      result = [];
      this.bubbleWhile((t) => {
        result.push(t);
        return t.parent && !t.parent.isRoot;
      });
    } else {
      result = null;
      this.bubbleWhile((t) => {
        result = t;
        return t.parent && !t.parent.isRoot;
      });
    }
    return result;
  }
  /**
   * Append a child record(s) to any current children.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} childRecord Array of records/data or a single
   * record/data to append
   * @param {Boolean} [silent] Pass `true` to not trigger events during append
   * @returns {Core.data.Model|Core.data.Model[]|null}
   * @category Parent & children
   */
  appendChild(childRecord, silent = false, options = {}) {
    return this.insertChild(childRecord, null, silent, options);
  }
  /**
   * Insert a child record(s) before an existing child record.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} childRecord Array of records/data or a single
   * record/data to insert
   * @param {Core.data.Model} [before] Optional record to insert before, leave out to append to the end
   * @param {Boolean} [silent] Pass `true` to not trigger events during append
   * @returns {Core.data.Model|Core.data.Model[]|null}
   * @category Parent & children
   */
  insertChild(childRecord, before = null, silent = false, options = {}) {
    var _a2, _b, _c, _d, _e, _f, _g;
    const me = this, returnArray = Array.isArray(childRecord);
    childRecord = ArrayHelper.asArray(childRecord);
    if (typeof before === "number") {
      before = (_b = (_a2 = me.children) == null ? void 0 : _a2[before]) != null ? _b : null;
    }
    if (!silent && !me.stores.every((s) => s.trigger("beforeAdd", {
      records: childRecord,
      parent: me
    }) !== false)) {
      return null;
    }
    childRecord = me.ingestChildren(childRecord);
    const index = (_e = (_d = before == null ? void 0 : before.parentIndex) != null ? _d : (_c = me.children) == null ? void 0 : _c.length) != null ? _e : 0, preResult = (_f = me.beforeInsertChild) == null ? void 0 : _f.call(me, childRecord), inserted = me.internalAppendInsert(childRecord, before, silent, options);
    if (inserted.length) {
      me.convertToParent(silent);
    }
    (_g = me.afterInsertChild) == null ? void 0 : _g.call(me, index, childRecord, preResult, inserted);
    return returnArray || !inserted ? inserted : inserted[0];
  }
  /**
   * Converts a leaf node to a parent node, assigning an empty array as its children
   * @param {Boolean} [silent] Pass `true` to not trigger any event
   * @category Parent & children
   */
  convertToParent(silent = false) {
    const me = this, wasLeaf = me.isLeaf;
    me.meta.isLeaf = false;
    if (!me.children) {
      me.children = [];
    }
    if (wasLeaf && !me.root.isLoading && !silent) {
      me.signalNodeChanged({
        isLeaf: {
          value: false,
          oldValue: true
        }
      });
    }
  }
  signalNodeChanged(changes, stores = this.stores) {
    stores.forEach((s) => {
      s.trigger("update", { record: this, records: [this], changes });
      s.trigger("change", { action: "update", record: this, records: [this], changes });
    });
  }
  tryInsertChild() {
    return this.insertChild(...arguments);
  }
  internalAppendInsert(recordsToInsert, beforeRecord, silent, options) {
    const me = this, { stores, root, children } = me, { firstStore: rootStore } = root, { parentIdField } = me.constructor, parentId = me.id;
    let isNoop, start, i, newRecordsCloned, oldParentIndices, isMove;
    if (!root.isLoading && rootStore) {
      isMove = {};
      oldParentIndices = [];
      for (i = 0; i < recordsToInsert.length; i++) {
        const newRecord = recordsToInsert[i];
        isMove[newRecord.id] = newRecord.root === root;
        oldParentIndices[i] = newRecord.parentIndex;
      }
    }
    if (beforeRecord && beforeRecord.parent !== me) {
      beforeRecord = null;
    }
    if (children) {
      const insertAt = beforeRecord ? beforeRecord.parentIndex : children.length;
      if (children[start = insertAt] === recordsToInsert[0] || children[start = insertAt - 1] === recordsToInsert[0]) {
        for (isNoop = true, i = 0; isNoop && i < recordsToInsert.length; i++) {
          if (recordsToInsert[i] !== children[start + i]) {
            isNoop = false;
          }
        }
      }
    }
    if (isNoop) {
      return recordsToInsert;
    }
    for (i = 0; i < recordsToInsert.length; i++) {
      const newRecord = recordsToInsert[i], oldParent = newRecord.parent;
      if (rootStore && !root.isLoading) {
        newRecord.traverse((r) => {
          if (r.root === root) {
            isMove[r.id] = true;
          }
        });
      }
      if ((oldParent == null ? void 0 : oldParent.removeChild(newRecord, isMove == null ? void 0 : isMove[newRecord.id], silent, { isInserting: true, ...options })) === false) {
        if (!newRecordsCloned) {
          recordsToInsert = recordsToInsert.slice();
          newRecordsCloned = true;
        }
        recordsToInsert.splice(i--, 1);
      } else {
        newRecord.parent = me;
        newRecord.data[parentIdField] = parentId;
        const { meta } = newRecord;
        if (meta.modified[parentIdField] === parentId && !oldParent) {
          meta.oldParentId = parentId;
        }
        if (oldParent) {
          meta.oldParentId = oldParent.id;
        }
      }
    }
    if (recordsToInsert.length) {
      if (!Array.isArray(children)) {
        me.children = [];
      }
      if (!Array.isArray(me.orderedChildren)) {
        me.orderedChildren = [];
      }
      const insertAt = me.addToChildren(beforeRecord, recordsToInsert, options);
      stores.forEach((store) => {
        if (!store.isChained) {
          recordsToInsert.forEach((record) => {
            record.joinStore(store);
          });
          store.onNodeAddChild(me, recordsToInsert, insertAt, isMove, silent);
          recordsToInsert.forEach((record, i2) => {
            if (record.meta.oldParentId != null && !(me.inProcessChildren || me.isLoading)) {
              const toSet = {
                [parentIdField]: parentId,
                [me.getDataSource("parentIndex")]: record.parentIndex
              }, wasSet = {}, { modified, oldParentId } = record.meta, oldParentIndex = oldParentIndices[i2];
              delete record.meta.oldParentId;
              if (me.id !== oldParentId) {
                wasSet[parentIdField] = {
                  value: parentId,
                  oldValue: oldParentId
                };
              }
              if (record.parentIndex !== oldParentIndex) {
                wasSet.parentIndex = {
                  value: record.parentIndex,
                  oldValue: oldParentIndex
                };
              }
              if (modified[parentIdField] === me.id) {
                Reflect.deleteProperty(modified, parentIdField);
              } else if (!(parentIdField in modified)) {
                modified[parentIdField] = oldParentId;
              }
              if (isMove[record.id]) {
                const oldParent = store.getById(oldParentId);
                if (oldParent.isLeaf && !silent) {
                  oldParent.signalNodeChanged({
                    isLeaf: {
                      value: true,
                      oldValue: false
                    }
                  }, [store]);
                }
              }
              record.afterChange(toSet, wasSet);
            }
            record.traverse((node) => {
              if (!node.ignoreBag && !node.isLinked) {
                store.updateModifiedBagForRecord(node);
              }
            });
          });
        }
      });
    }
    return recordsToInsert;
  }
  /**
   * Remove a child record. Only direct children of this node can be removed, others are ignored.
   * @param {Core.data.Model|Core.data.Model[]} childRecords The record(s) to remove.
   * @param {Boolean} [isMove] Pass `true` if the record is being moved within the same store.
   * @param {Boolean} [silent] Pass `true` to not trigger events during remove.
   * @privateparam {Object} [options]
   * @privateparam {Object} [options.isInserting] `true` is passed when removal is part of record inserting (acted on by
   * ModelLink)
   * @returns {Core.data.Model[]} All records (including nested children) removed
   * @category Parent & children
   */
  removeChild(childRecords, isMove = false, silent = false, options = {}) {
    var _a2, _b;
    const me = this, allRemovedRecords = [], wasLeaf = me.isLeaf, {
      children,
      stores
    } = me;
    childRecords = ArrayHelper.asArray(childRecords);
    childRecords = childRecords.filter((r) => r.parent === me);
    if (!silent) {
      for (const store of stores) {
        if (!store.isChained && store.trigger("beforeRemove", {
          parent: me,
          records: childRecords,
          isMove
        }) === false) {
          return false;
        }
      }
    }
    const preResult = (_a2 = me.beforeRemoveChild) == null ? void 0 : _a2.call(me, childRecords, isMove);
    for (const childRecord of childRecords) {
      const { parentIdField } = childRecord.constructor, { modified } = childRecord.meta, oldParentId = childRecord.parent ? childRecord.parent.id : null;
      if (!(parentIdField in modified) && !childRecord.isLinked) {
        modified[parentIdField] = oldParentId;
      }
      const index = me.removeFromChildren(childRecord, options);
      stores.forEach((store) => {
        if (!store.isChained) {
          const { isRemoving } = store;
          store.isRemoving = true;
          allRemovedRecords.push(...store.onNodeRemoveChild(me, [childRecord], index, { isMove, silent }));
          store.isRemoving = isRemoving;
        }
      });
      if (!isMove) {
        childRecord.parent = childRecord.parentIndex = childRecord.unfilteredIndex = childRecord.nextSibling = childRecord.previousSibling = null;
        childRecord.data[parentIdField] = null;
      }
    }
    if ((me.unfilteredChildren || children).length === 0 && me.constructor.convertEmptyParentToLeaf.onRemove && !me.isRoot) {
      me.meta.isLeaf = true;
    }
    if (me.isLeaf !== wasLeaf && !silent && !isMove) {
      me.signalNodeChanged({
        isLeaf: {
          value: true,
          oldValue: false
        }
      });
    }
    (_b = me.afterRemoveChild) == null ? void 0 : _b.call(me, childRecords, preResult, isMove);
    return allRemovedRecords;
  }
  clearParentId() {
    const me = this;
    Reflect.deleteProperty(me.data, me.parentIdField);
    Reflect.deleteProperty(me.originalData, me.parentIdField);
    if (me.meta.modified) {
      Reflect.deleteProperty(me.meta.modified, me.parentIdField);
    }
  }
  /**
   * Replaces all child nodes with the new node set.
   * @param {Core.data.Model|Core.data.Model[]} childRecords The new child record set.
   * @returns {Core.data.Model[]}
   * @category Parent & children
   */
  replaceChildren(newChildren) {
    this.clearChildren();
    this.data[this.constructor.childrenField] = newChildren;
    this.processChildren();
    return this.children;
  }
  /**
   * Removes all child nodes from this node.
   * @param {Boolean} [silent=false] Pass `true` to not fire Store events during the remove.
   * @returns {Core.data.Model[]}
   * @category Parent & children
   */
  clearChildren(silent = false) {
    const me = this, { stores } = me, children = me.unfilteredChildren || me.children;
    me.children = [];
    me.orderedChildren = [];
    if (children && children !== true) {
      stores.forEach((store) => {
        if (!store.isChained) {
          store.onNodeRemoveChild(me, children, 0, { unfiltered: true, silent });
        }
      });
      if (me.unfilteredChildren) {
        me.unfilteredChildren = [];
      }
    }
  }
  /**
   * Removes all records from the rootNode
   * @private
   */
  clear() {
    var _a2;
    const me = this, { stores } = me, children = (_a2 = me.children) == null ? void 0 : _a2.slice();
    if (!me.isRoot || !children) {
      return;
    }
    for (const store of stores) {
      if (!store.isChained) {
        if (store.trigger("beforeRemove", {
          parent: me,
          records: children,
          isMove: false,
          removingAll: true
        }) === false) {
          return false;
        }
      }
    }
    me.children.length = 0;
    if (me.unfilteredChildren) {
      me.unfilteredChildren.length = 0;
    }
    stores.forEach((store) => {
      children.forEach((child) => {
        if (child.stores.includes(store)) {
          child.unjoinStore(store);
        }
        child.parent = child.parentIndex = child.nextSibling = child.previousSibling = null;
      });
      store.storage.suspendEvents();
      store.storage.clear();
      store.storage.resumeEvents();
      store.added.clear();
      store.modified.clear();
      store.trigger("removeAll");
      store.trigger("change", { action: "removeall" });
    });
  }
  updateChildrenIndices(children, indexName, silent = false) {
    let previousSibling = null;
    for (let i = 0; i < children.length; i++) {
      const child = children[i], oldValue = child[indexName];
      if (indexName === "parentIndex" || indexName === "orderedParentIndex") {
        if (oldValue === void 0 || silent) {
          child.setData(indexName, i);
        } else if (oldValue !== i) {
          child.set(indexName, i, true);
        }
      } else {
        child[indexName] = i;
      }
      if (indexName === "parentIndex") {
        child.previousSibling = previousSibling;
        if (previousSibling) {
          previousSibling.nextSibling = child;
        }
        if (i === children.length - 1) {
          child.nextSibling = null;
        }
        previousSibling = child;
      }
    }
  }
  addToChildren(beforeRecord, newRecords, options = {}) {
    var _a2;
    const me = this, configs = [
      [me.children, "parentIndex", beforeRecord],
      [me.unfilteredChildren, "unfilteredIndex", beforeRecord],
      [
        me.orderedChildren,
        "orderedParentIndex",
        // Distinguish null and undefined here. `null` means add to the end of the ordered tree
        (options == null ? void 0 : options.orderedBeforeNode) === void 0 ? (options == null ? void 0 : options.orderedParentIndex) !== void 0 ? me.orderedChildren[options == null ? void 0 : options.orderedParentIndex] : beforeRecord : options == null ? void 0 : options.orderedBeforeNode
      ]
    ];
    for (const config of configs) {
      const [children, indexName, beforeRecord2] = config;
      if (children) {
        const index = beforeRecord2 ? indexName === "orderedParentIndex" ? children.indexOf(beforeRecord2) : beforeRecord2[indexName] : children.length;
        config.push(index);
        children.splice(index, 0, ...newRecords);
        if (!((_a2 = options == null ? void 0 : options[indexName]) == null ? void 0 : _a2.skip)) {
          me.updateChildrenIndices(children, indexName);
        }
      }
    }
    return configs[0][3];
  }
  removeFromChildren(childRecord, options) {
    var _a2;
    const configs = [
      [this.children, "parentIndex"],
      [this.unfilteredChildren, "unfilteredIndex"],
      [this.orderedChildren, "orderedParentIndex"]
    ];
    for (const config of configs) {
      const [children, indexName] = config;
      if (children) {
        const index = children.indexOf(childRecord);
        config.push(index);
        if (index > -1) {
          children.splice(index, 1);
          if (!((_a2 = options == null ? void 0 : options[indexName]) == null ? void 0 : _a2.skip)) {
            this.updateChildrenIndices(children, indexName);
          }
        }
      }
    }
    return configs[0][2];
  }
  /**
   * Iterates orderedChildren array to apply sorting order according to `orderedParentIndex`.
   * Normally sorting is not required because order is maintained on append/insert. But is useful
   * when pasting number of records to restore their original order.
   * @param {Boolean} [deep=true] True to dive into children. False to sort own children.
   * @param {Boolean} [usePreviousOrder=false] Enable to use previous value of `orderedParentIndex`.
   * @returns {Set} Returns Set of moved nodes which require WBS update
   * @private
   */
  sortOrderedChildren(deep = true, usePreviousOrder = false) {
    const movedNodes = [];
    if (!this.isLeaf) {
      this.orderedChildren.sort((a, b) => {
        var _a2, _b;
        if (usePreviousOrder) {
          const aPrevIndex = (_a2 = a.meta.modified.orderedParentIndex) != null ? _a2 : a.orderedParentIndex, bPrevIndex = (_b = b.meta.modified.orderedParentIndex) != null ? _b : b.orderedParentIndex, result = aPrevIndex - bPrevIndex;
          if (result !== 0) {
            movedNodes.push(a);
            movedNodes.push(b);
          }
          return result;
        } else {
          return a.orderedParentIndex - b.orderedParentIndex;
        }
      });
      if (deep) {
        this.orderedChildren.forEach((child) => {
          movedNodes.push(...child.sortOrderedChildren(deep, usePreviousOrder));
        });
      }
      this.updateChildrenIndices(this.orderedChildren, "orderedParentIndex", true);
    }
    return new Set(movedNodes);
  }
  sortVisibleChildren(deep = true, sorterFn) {
    const me = this;
    if (!me.isLeaf) {
      me.children.sort(sorterFn);
      if (deep) {
        me.orderedChildren.forEach((child) => child.sortVisibleChildren(deep, sorterFn));
      }
      me.updateChildrenIndices(me.children, "parentIndex", true);
    }
  }
  sortUnfilteredChildren(deep = true, sorterFn) {
    const me = this;
    if (!me.isLeaf && me.unfilteredChildren) {
      me.unfilteredChildren.sort(sorterFn);
      if (deep) {
        me.orderedChildren.forEach((child) => child.sortUnfilteredChildren(deep, sorterFn));
      }
      me.updateChildrenIndices(me.unfilteredChildren, "unfilteredIndex", true);
    }
  }
  unjoinStore(store, isReplacing = false) {
    var _a2;
    const me = this;
    if (me.unfilteredChildren) {
      me.children = me.unfilteredChildren.slice();
      me.unfilteredChildren = null;
    }
    (_a2 = super.unjoinStore) == null ? void 0 : _a2.call(this, store, isReplacing);
  }
};

// ../Core/lib/Core/data/mixin/ModelLink.js
var propertyOverrides = {
  id: 1,
  stores: 1,
  parentIndex: 1,
  parent: 1,
  previousSibling: 1,
  nextSibling: 1,
  unfilteredIndex: 1
};
var proxyConfig = {
  get(target, prop) {
    if (prop === "proxyMeta") {
      return this.proxyMeta;
    }
    if (prop === "constructor") {
      return target.constructor;
    }
    if (prop === "setData") {
      return this.setDataOverride;
    }
    if (prop === "set") {
      return this.setOverride;
    }
    if (propertyOverrides[prop]) {
      return this.proxyMeta.data[prop];
    }
    return Reflect.get(target, prop, this.proxyRecord);
  },
  set(target, prop, value) {
    if (propertyOverrides[prop]) {
      this.proxyMeta.data[prop] = value;
    } else {
      target[prop] = value;
    }
    return true;
  },
  // Override setData & set to reroute parentIndex updates
  setDataOverride(toSet, value) {
    if (toSet === "parentIndex") {
      this.proxyMeta.data.parentIndex = value;
    } else {
      this.proxyMeta.originalRecord.setData(toSet, value);
    }
  },
  setOverride(field, value, ...args) {
    if (field === "parentIndex") {
      this.proxyMeta.data.parentIndex = value;
    } else {
      this.proxyMeta.originalRecord.set(field, value, ...args);
    }
  }
};
var ModelLink_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    /**
     * Creates a proxy record (using native Proxy) linked to this record (the original). The proxy records shares most
     * data with the original, except for its `id` (which is always generated), and ordering fields such as
     * `parentIndex` and `parentId` etc.
     *
     * Any change to the proxy record will be reflected on the original, and vice versa. A proxy record is not meant to
     * be persisted, only the original record should be persisted. Thus, proxy records are not added to stores change
     * tracking (added, modified and removed records).
     *
     * Removing the original record removes all proxies.
     *
     * Creating a proxy record allows a Store to seemingly contain the record multiple times, something that is
     * otherwise not possible. It also allows a record to be used in both a tree store and in a flat store.
     *
     * <div class="note">Note that not all UI features support linked records</div>
     *
     * @returns {Proxy} Proxy record linked to the original record
     * @typings {typeof Proxy}
     * @category Misc
     */
    link() {
      if (this.isLinked) {
        return this.$original.link();
      }
      const me = this, useConfig = {
        ...proxyConfig,
        // Data not shared with the original record
        proxyMeta: {
          originalRecord: me,
          data: {
            id: `${me.id}_link_${StringHelper.generateUUID()}`,
            stores: []
          }
        }
      }, proxyRecord = new Proxy(me, useConfig);
      useConfig.proxyRecord = proxyRecord;
      (me.meta.linkedRecords || (me.meta.linkedRecords = [])).push(proxyRecord);
      return proxyRecord;
    }
    /**
     * Is this record linked to another record?
     * @member {Boolean}
     * @readonly
     * @category Misc
     */
    get isLinked() {
      var _a3;
      return Boolean((_a3 = this.proxyMeta) == null ? void 0 : _a3.originalRecord);
    }
    /**
     * Are other records linked to this record?
     * @member {Boolean}
     * @readonly
     * @category Misc
     */
    get hasLinks() {
      return Boolean(!this.proxyMeta && this.$links.length);
    }
    // Logic to remove a link shared between removing in a flat store and a tree store
    removeLink(link, records = null, silent = false) {
      if (link.hasLinks) {
        for (const linked of link.$links.slice()) {
          if (records) {
            ArrayHelper.include(records, linked);
          } else {
            linked.remove(silent);
          }
        }
      } else if (link.isLinked) {
        ArrayHelper.remove(link.$original.$links, link);
      }
    }
    // Overrides beforeRemove in Model, to remove all linked records when original record is removed.
    beforeRemove(records) {
      this.removeLink(this, records);
    }
    // Overrides removeChild in TreeNode, to remove the original node and all linked nodes when either a linked or
    // original node is removed.
    removeChild(childRecords, isMove, silent, options) {
      if (!(options == null ? void 0 : options.isInserting)) {
        childRecords = ArrayHelper.asArray(childRecords);
        for (const child of childRecords) {
          this.removeLink(child, null, silent);
        }
      }
      return super.removeChild(childRecords, isMove, silent, options);
    }
    // Convenience getter for code keying by id that needs to work with both link and original
    get $originalId() {
      return this.$original.id;
    }
    // Convenience getter to retrieve linked records
    get $links() {
      var _a3;
      return (_a3 = this.meta.linkedRecords) != null ? _a3 : [];
    }
  }, __publicField(_a2, "$name", "ModelLink"), __publicField(_a2, "isModel", true), _a2;
};

// ../Core/lib/Core/mixin/Factoryable.js
var { defineProperty: defineProperty4 } = Reflect;
var ownerSymbol = Symbol("owner");
var typeSplitRe = /[\s,]+/;
var Factoryable_default = (Target) => class Factoryable extends (Target || Base) {
  static get $name() {
    return "Factoryable";
  }
  static get declarable() {
    return [
      /**
       * This property getter returns options that control the factory process. This property getter must be
       * defined by the class that mixes in `Factoryable` in order to initialize the factory properly.
       * ```
       *  static get factoryable() {
       *      return {
       *          defaultType : 'default'
       *      };
       *  }
       * ```
       * If there are no special options to provide, this method can return nothing (`undefined`):
       * ```
       *  static get factoryable() {
       *      // initialize the factory with all default options
       *  }
       * ```
       * @static
       * @member {Object} factoryable
       * @property {Boolean} [factoryable.caseless=true] Specify `false` to use case-sensitive type names. The
       * default is to ignore case.
       * @property {String} [factoryable.defaultType=null] The default type to create when a config object has
       * no `typeKey` property.
       * @property {Function|Function[]} [factoryable.extends] One or more classes that mix in `Factoryable` to
       * use for resolving type names when a type name is not found in this factory.
       * @property {String} [factoryable.typeKey='type'] The name of the property in a config object that holds
       * the type name.
       * @internal
       */
      "factoryable",
      /**
       * One or more additional type name aliases for this class. This can be useful for renaming and maintaining
       * a previous type name.
       * ```
       *  class Fit extends Layout {
       *      static type = 'fit';
       *
       *      static alias = 'fill';
       *  }
       * ```
       * @static
       * @member {String|String[]} alias
       * @internal
       */
      "alias",
      /**
       * The (canonical) type name for this class by which instances can be created using the static
       * {@link #function-create-static create()} method.
       * @static
       * @member {String} type
       */
      "type"
    ];
  }
  /**
   * Registers a class (`cls`) associated with the given `type`.
   * @param {String|String[]} type A string, array of strings or a comma-separated string containing the type names
   * for the specified `cls` class.
   * @param {Function} cls The class (constructor function)
   * @param {Boolean} [replace] Pass `true` to overwrite existing registered types. Otherwise, this method will throw
   * an exception if the `type` is already registered with this factory.
   * @internal
   */
  static register(type, cls, replace = globalThis.__BRYNTUM_EXAMPLE) {
    const { factoryable } = this.initClass(), { caseless, registry } = factoryable, types = StringHelper.split(type, typeSplitRe);
    for (let lower, name, i = 0; i < types.length; ++i) {
      name = types[i];
      lower = caseless ? name.toLowerCase() : name;
      if (!replace && lower in registry) {
        throw new Error(`Type "${name}" already registered with ${factoryable.class.name} factory`);
      }
      registry[name] = registry[lower] = cls.initClass();
    }
  }
  /**
   * Returns `true` if the passed instance is of the passed type or of a derived class.
   * @param {Object} instance The object to test.
   * @param {String} type The type to test against
   */
  static isA(instance, type) {
    return this.isType(instance, type, true);
  }
  /**
   * Returns `true` if the passed instance is of the passed type.
   * @param {Object} instance The object to test.
   * @param {String} type The type to test against
   * @param {Boolean} [deep] Pass `true` to return `true` if the class is a subclass of the passed type.
   */
  static isType(instance, type, deep) {
    const { factoryable } = this, { caseless, registry } = factoryable, typeCls = registry[caseless ? type.toLowerCase() : type];
    if (typeCls) {
      if (deep) {
        return instance instanceof typeCls;
      }
      return instance.constructor === typeCls;
    }
    return false;
  }
  static setupAlias(cls) {
    cls.register(cls.alias, cls);
  }
  static setupFactoryable(cls, meta) {
    const superClass = meta.super.class;
    let { factoryable } = cls;
    factoryable = {
      caseless: true,
      defaultType: null,
      extends: superClass.factoryable ? [superClass] : null,
      typeKey: "type",
      ...factoryable
    };
    factoryable.class = cls;
    factoryable.registry = /* @__PURE__ */ Object.create(null);
    if (factoryable.extends && !Array.isArray(factoryable.extends)) {
      factoryable.extends = [factoryable.extends];
    }
    defineProperty4(cls, "factoryable", {
      get() {
        return factoryable;
      }
    });
  }
  static setupType(cls, meta) {
    const { type } = cls;
    cls.register(type, cls, meta.replaceType);
    defineProperty4(cls.prototype, "type", {
      value: type
    });
  }
  /**
   * Creates an instance from this factory, given the type name or a config object.
   * @param {String|Object} config The type name string or config object.
   * @param {String|Function|Object} [options] Creation options (for details see {@link #function-reconfigure-static}).
   * @returns {Object}
   */
  static create(config, options) {
    return this.reconfigure(null, config, options);
  }
  /**
   * Reconfigures an optional existing instance based on the provided config and returns the correctly configured
   * instance. This will be the `existingInstance` if the `config` does not specify a different type.
   *
   * If `config` is `null` (or simply falsy), this method will destroy the `existingInstance` (if any) and return
   * `null`.
   *
   * If there is no `existingInstance`, the config must specify a type. That is, it must be a string (the type name)
   * or an object containing a `type` property, the `defaultType` must be provided or the factory itself must have
   * a `defaultType` specified (see {@link #property-factoryable-static}).
   *
   * When an `existingInstance` is provided and a type is specified, the instance will be reconfigured via `setConfig`
   * if it is of that type. Otherwise, the `existingInstance` is destroyed (if it is owned by the `options.owner`)
   * and a new instance of the correct type is created.
   *
   * @param {Object} existingInstance The instance to reconfigure. This can be `null`.
   *
   * @param {String|Object} config The type name string or config object.
   *
   * @param {String|Function|Object} [options] Additional options to control the reconfiguration process. If this
   * value is a string or a class constructor, it treated as `options.type`. If this value is a class instance, it
   * is used as the `options.owner`. If this is a function, it is treated as `options.setup`. NOTE: functions declared
   * using the `function` keyword are equivalent to class constructors. Use an arrow function or a class method to
   * avoid this when a `setup` function is intended.
   *
   * @param {String|Function} [options.type] The default type to use if the `config` object does not specify a type.
   *
   * @param {Object} [options.owner] The owner of any created instances. If the `existingInstance` is being replaced,
   * this value determines if the instance will be destroyed.
   *
   * @param {Object} [options.defaults] A config object of default values to use when creating a new instance.
   *
   * @param {Function|String} [options.setup] A function or the name of a method (on the `options.owner`) to call
   * prior to creating a new instance. It is passed the config object that will be used to create the instance. If a
   * truthy value is returned, that value is passed to the constructor instead of the provided config object.
   *
   * @param {Function|String} [options.transform] A function or the name of a method (on the `options.owner`) to call
   * with the raw config object prior to processing and the value it returns replaces the raw value. This function is
   * used to transform strings or arrays (for example) into proper config objects.
   *
   * @param {Function|String} [options.cleanup] A function or the name of a method (on the `options.owner`) to call
   * prior to destroying the `existingInstance`. The `existingInstance` is passed as the sole argument.
   *
   * @returns {Object} The reconfigured instance (either `existingInstance` or a new instance of the desired type)
   */
  static reconfigure(existingInstance, config, options) {
    const me = this, { factoryable } = me, { typeKey } = factoryable;
    let defaultType = options, cleanup, defaults, mergeType, owner, prepared, setup, t, transform, type;
    if (options && !ObjectHelper.isClass(options)) {
      defaultType = null;
      t = typeof options;
      if (t === "function") {
        setup = options;
      } else if (t === "string") {
        defaultType = options;
      } else if (ObjectHelper.isObject(options)) {
        cleanup = options.cleanup;
        defaults = options.defaults;
        owner = options.owner;
        setup = options.setup;
        defaultType = options.type;
        transform = options.transform;
      } else {
        owner = options;
      }
    }
    if (transform) {
      config = typeof transform === "string" ? owner[transform](config) : transform(config);
    }
    type = config;
    if (typeof type === "string") {
      config = {};
    } else if (config) {
      if (config === true) {
        config = {};
      }
      if (!ObjectHelper.isObject(config)) {
        if (owner && config !== existingInstance && (existingInstance == null ? void 0 : existingInstance[ownerSymbol]) === owner) {
          typeof cleanup === "string" ? owner[cleanup](existingInstance) : cleanup == null ? void 0 : cleanup(existingInstance);
          existingInstance.destroy();
        }
        return config;
      }
      type = config[typeKey];
    }
    type = type && me.resolveType(type);
    if (existingInstance) {
      if (config && (!type || existingInstance.constructor === type)) {
        if (typeKey in config) {
          config = ObjectHelper.assign({}, config);
          delete config[typeKey];
        }
        existingInstance.setConfig(config);
        return existingInstance;
      }
      if (owner && existingInstance[ownerSymbol] === owner) {
        typeof cleanup === "string" ? owner[cleanup](existingInstance) : cleanup == null ? void 0 : cleanup(existingInstance);
        existingInstance.destroy();
      }
    }
    if (config) {
      if (defaults) {
        if (!(mergeType = type)) {
          if (!(mergeType = defaults[typeKey] || defaultType || factoryable.defaultType)) {
            throw new Error(`No default mergeType defined for ${factoryable.class.name} factory`);
          }
          mergeType = me.resolveType(mergeType);
        }
        if (mergeType) {
          config = mergeType.mergeConfigs(defaults, config);
        }
      }
      if (setup) {
        prepared = typeof setup === "string" ? owner[setup](config, type, defaults) : setup(config, type, defaults);
        if (prepared === null) {
          return prepared;
        }
        config = prepared || config;
      }
      if (!type) {
        if (!(type = config[typeKey] || defaultType || factoryable.defaultType)) {
          throw new Error(`No default type defined for ${factoryable.class.name} factory`);
        }
        type = me.resolveType(type);
      }
      if (defaults && !mergeType) {
        config = type.mergeConfigs(defaults, config);
      }
      if (typeKey in config) {
        config = ObjectHelper.assign({}, config);
        delete config[typeKey];
      }
      config = new type(config);
      if (owner) {
        config[ownerSymbol] = owner;
      }
    }
    return config || null;
  }
  /**
   * This method returns the constructor of the class registered for the given type name.
   * @param {String} type The type name to look up.
   * @param {Boolean} [optional] Pass `true` to return `null` if `type` is not found instead of throwing an exception.
   * @returns {Function}
   */
  static resolveType(type, optional) {
    if (typeof type !== "string") {
      return type;
    }
    const { factoryable } = this, bases = factoryable.extends;
    let result = factoryable.registry[factoryable.caseless ? type.toLowerCase() : type], i;
    for (i = 0; !result && bases && i < bases.length; ++i) {
      result = bases[i].resolveType(
        type,
        /* optional = */
        true
      );
    }
    if (!result && !optional) {
      throw new Error(`Invalid type name "${type}" passed to ${factoryable.class.name} factory`);
    }
    return result;
  }
};

// ../Core/lib/Core/data/field/DataField.js
var { getOwnPropertyDescriptor: getOwnPropertyDescriptor2 } = Reflect;
var DataField = class extends Base.mixin(Factoryable_default) {
  static get $name() {
    return "DataField";
  }
  static get type() {
    return "auto";
  }
  static get factoryable() {
    return {
      defaultType: "auto"
    };
  }
  static get prototypeProperties() {
    return {
      /**
       * The name of the field.
       * @config {String} name
       */
      /**
       * The label text for a form item generated for this field. This is also used to create
       * a column header for a {@link #config-column} for this field.
       * @config {String} label
       */
      /**
       * A column config object for a column to display this field in a grid. For simple, atomic
       * data types, such as `date`, `string`, `boolean`, `number` and `integer`, this is optional
       * and the appropriate column type can be inferred.
       *
       * This also provides default values for column configuration if a configured column definition
       * for a grid lacks a property.
       *
       * For complex fields, such as identifiers which link to other records, a more capable
       * column type may be specified, for example a `type : `number'` field may be configured
       * with
       *
       * ```javascript
       * column : 'percent'
       * ```
       * or
       * ```javascript
       * column : {
       *     type : 'percent',
       *     width : 100
       * }
       * ```
       * if it represents a percentage value and needs appropriate rendering and editing.
       * @config {String|Object} column
       */
      /**
       * A config object for a widget to edit this field in a form. For simple, atomic
       * data types, such as `date`, `string`, `boolean`, `number` and `integer`, this is optional
       * and the appropriate input widget type can be inferred.
       *
       * For complex fields, such as identifiers which link to other records, a more capable
       * widget may be specified.
       * @config {String|InputFieldConfig} editor
       * @private
       */
      /**
       * A function that compares two values and returns a value < 0 if the first is less than the second, or 0
       * if the values are equal, or a value > 0 if the first is greater than the second.
       * @config {Function}
       * @param {Core.data.Model} value1
       * @param {Core.data.Model} value2
       * @returns {Number}
       * @default
       */
      compare: null,
      /**
       * A function that compares two objects or records using the `compare` function on the properties of each
       * objects based on the `name` of this field.
       * @config {Function}
       * @param {Core.data.Model} value1
       * @param {Core.data.Model} value2
       * @returns {Number}
       * @default
       * @internal
       */
      compareItems: null,
      /**
       * The property in a record's data object that contains the field's value.
       * Defaults to the field's `name`.
       * @config {String}
       */
      dataSource: null,
      /**
       * The default value to assign to this field in a record if no value is provided.
       * @config {*} defaultValue
       */
      /**
       * Setting to `true` will ensure this field is included in any update/insert request payload
       * when a Store / Project / CrudManager performs a request.
       * @config {Boolean}
       * @default
       */
      alwaysWrite: false,
      /**
       * Setting to `false` indicates that `null` is not a valid value.
       * @config {Boolean}
       * @default
       */
      nullable: true,
      /**
       * The value to return from {@link #function-print} for a `null` or `undefined` value.
       * @config {String}
       * @default
       */
      nullText: null,
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {*}
       * @default
       */
      nullValue: void 0,
      /**
       * Set to `false` to exclude this field when saving records to a server.
       * @config {Boolean}
       * @default
       */
      persist: true,
      /**
       * Set to `true` for the field's set accessor to ignore attempts to set this field.
       * @config {Boolean}
       * @default
       */
      readOnly: false,
      /**
       * By default, defined {@link Core.data.Model} fields may be used to create a grid column
       * suitable for displaying that field in a grid cell. Some fields may not be suitable for
       * features which automatically generate columns for view. These fields are created using
       * `internal : true`. Some examples are the `expanded` and `rowHeight` fields which are used
       * internally.
       * @config {Boolean}
       * @default
       */
      internal: false,
      useProp: null
    };
  }
  /**
   * The class that first defined this field. Derived classes that override a field do not change this property.
   * @member {Core.data.Model} definedBy
   * @private
   * @readonly
   */
  /**
   * The class that most specifically defined this field. Derived classes that override a field set this property to
   * themselves.
   * @member {Core.data.Model} owner
   * @private
   * @readonly
   */
  // NOTE: Since we create lots of instances, they have no life cycle (they are not destroyed) and are readonly after
  // creation, this class does not use configurable.
  construct(config) {
    const me = this;
    if (config) {
      me.name = config.name;
      Object.assign(me, config);
    }
    if (me.compare) {
      me.compareItems = (itemA, itemB) => me.compare(itemA == null ? void 0 : itemA[me.name], itemB == null ? void 0 : itemB[me.name]);
    }
  }
  /**
   * This method transforms a data value into the desired form for storage in the record's data object.
   *
   * ```javascript
   * export default class Task extends TaskModel {
   *    static get fields() {
   *        return [
   *            {
   *                name    : 'status',
   *                convert : (value, data) => {
   *                    if (value >= 100) {
   *                        return 'done';
   *                    }
   *                    else if (value > 0) {
   *                        return 'started';
   *                    }
   *                }
   *            }
   *        ];
   *    }
   * }
   * ```
   *
   * @method convert
   * @param {*} value The value to convert for storage in a record.
   * @param {Object} data The raw record data object
   * @returns {*} The converted value.
   */
  /**
   * This method transforms a data value into the desired form for transmitting to a server.
   * @method serialize
   * @param {*} value The value to serialize
   * @param {Core.data.Model} record The record that contains the value being serialized.
   * @returns {*} The serialized value.
   */
  /**
   * This optional method is called when setting a data value on a record.
   * @method set
   * @param {*} value The value to set
   * @param {Object} data The records future or current data object to set value to
   * @param {Core.data.Model} record The record that owns or will own the data object
   * @internal
   */
  /**
   * This optional method is called when a record using this field is created.
   * @method init
   * @param {Core.data.Model} record The record being created
   * @internal
   */
  /**
   * Create getter and setter functions for the specified field name under the specified key.
   * @internal
   */
  defineAccessor(target, force) {
    const { name, dataSource } = this;
    if (!force && name in target && target.$meta.hierarchy.some((current) => {
      var _a2;
      return ((_a2 = getOwnPropertyDescriptor2(current.prototype, name)) == null ? void 0 : _a2.enumerable) === false;
    })) {
      return;
    }
    Reflect.defineProperty(target, name, {
      configurable: true,
      // To allow removing it later
      enumerable: true,
      // no arrow functions here, need `this` to change to instance
      get: this.complexMapping ? function() {
        return this.complexGet(name, dataSource);
      } : function() {
        if (this.batching && name in this.meta.batchChanges) {
          return this.meta.batchChanges[name];
        }
        return dataSource in this.data ? this.data[dataSource] : this.data[name];
      },
      // no arrow functions here, need `this` to change to instance
      set(value) {
        const field = this.$meta.fields.map[name];
        if (!(field && field.readOnly)) {
          this.set(name, value);
        }
      }
    });
  }
  /**
   * Compares two values for this field and returns `true` if they are equal, and `false` if not.
   * @param {*} first The first value to compare for equality.
   * @param {*} second The second value to compare for equality.
   * @returns {Boolean} `true` if `first` and `second` are equal.
   */
  isEqual(first, second) {
    return ObjectHelper.isEqual(first, second);
  }
  /**
   * Returns the given field value as a `String`. If `value` is `null` or `undefined`, the value specified by
   * {@link #config-nullText} is returned.
   * @param {*} value The value to convert to a string.
   * @returns {String}
   */
  print(value) {
    return value == null ? this.nullText : this.printValue(value);
  }
  /**
   * Returns the given, non-null field value as a `String`.
   * @param {*} value The value to convert to a string (will not be `null` or `undefined`).
   * @returns {String}
   * @protected
   */
  printValue(value) {
    return String(value);
  }
};
DataField._$name = "DataField";

// ../Core/lib/Core/data/field/ArrayDataField.js
var ArrayDataField = class extends DataField {
  isEqual(a, b) {
    return a === b;
  }
  getAt(record, index) {
    return record.get(this.name)[index];
  }
};
__publicField(ArrayDataField, "$name", "ArrayDataField");
__publicField(ArrayDataField, "type", "array");
ArrayDataField.initClass();
ArrayDataField._$name = "ArrayDataField";

// ../Core/lib/Core/data/field/BooleanDataField.js
var BooleanDataField = class extends DataField {
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Boolean}
       * @default
       */
      nullValue: false
    };
  }
  isEqual(first, second) {
    if (first == null && second == null) {
      return true;
    }
    return super.isEqual(first, second);
  }
  convert(value) {
    var _a2;
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    if (((_a2 = value.toLowerCase) == null ? void 0 : _a2.call(value)) === "false") {
      return false;
    }
    return Boolean(value);
  }
};
__publicField(BooleanDataField, "$name", "BooleanDataField");
__publicField(BooleanDataField, "type", "boolean");
__publicField(BooleanDataField, "alias", "bool");
BooleanDataField.initClass();
BooleanDataField._$name = "BooleanDataField";

// ../Core/lib/Core/data/field/DateDataField.js
var DateDataField = class extends DataField {
  static get $name() {
    return "DateDataField";
  }
  static get type() {
    return "date";
  }
  static get prototypeProperties() {
    return {
      /**
       * The format of the date field.
       *
       * See {@link Core.helper.DateHelper DateHelper} for details.
       * @config {String} format
       * @default DateHelper.defaultFormat
       */
      format: null
    };
  }
  convert(value) {
    if (value == null) {
      if (!this.nullable) {
        value = this.nullValue;
      }
    } else if (value === "now") {
      value = /* @__PURE__ */ new Date();
    } else if (!(value instanceof Date)) {
      value = DateHelper.parse(value, this.format || DateHelper.defaultParseFormat);
      if (!value || isNaN(value)) {
        value = void 0;
      }
    }
    return value;
  }
  serialize(value) {
    if (value instanceof Date) {
      value = DateHelper.format(value, this.format || DateHelper.defaultFormat);
    }
    return value;
  }
  printValue(value) {
    return DateHelper.format(value, this.format || DateHelper.defaultFormat);
  }
};
DateDataField.initClass();
DateDataField._$name = "DateDataField";

// ../Core/lib/Core/data/field/StringDataField.js
var StringDataField = class extends DataField {
  static get $name() {
    return "StringDataField";
  }
  static get type() {
    return "string";
  }
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {String}
       * @default
       */
      nullValue: ""
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : String(value);
  }
};
StringDataField.initClass();
StringDataField._$name = "StringDataField";

// ../Core/lib/Core/data/field/IntegerDataField.js
var IntegerDataField = class extends DataField {
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Number}
       * @default
       */
      nullValue: 0,
      /**
       * The `Math` method to use to ensure fractional component is removed.
       * @config {'round'|'floor'|'ceil'}
       * @default
       */
      rounding: "round"
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : Math[this.rounding](Number(value));
  }
};
__publicField(IntegerDataField, "$name", "IntegerDataField");
__publicField(IntegerDataField, "type", "integer");
__publicField(IntegerDataField, "alias", "int");
IntegerDataField.initClass();
IntegerDataField._$name = "IntegerDataField";

// ../Core/lib/Core/data/field/ModelDataField.js
var ModelDataField = class extends DataField {
  static get $name() {
    return "ModelDataField";
  }
  static get type() {
    return "model";
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
  isEqual(first, second) {
    return first && second && second instanceof first.constructor && second.id == first.id;
  }
};
__publicField(ModelDataField, "configurable", {
  /**
   * Class used to contain data values in this field; should be a subclass of {@link Core.data.Model}.
   * Defining this configuration is necessary for some functionality (like filter editing) to identify the
   * type of data held by the field without data present.
   *
   * @config {Core.data.Model}
   * @typings {typeof Model}
   * @category Common
   */
  modelClass: null
});
ModelDataField.initClass();
ModelDataField._$name = "ModelDataField";

// ../Core/lib/Core/data/field/NumberDataField.js
var NumberDataField = class extends DataField {
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Number}
       * @default
       */
      nullValue: 0,
      /**
       * The numeric precision of this field. Values are rounded to the specified number of digits. If `null`,
       * the default, no rounding is performed.
       * @config {Number}
       * @default
       */
      precision: null
    };
  }
  isEqual(first, second) {
    return isNaN(Number(first)) && isNaN(Number(second)) || super.isEqual(first, second);
  }
  convert(value) {
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    value = Number(value);
    if (isNaN(value)) {
      return;
    }
    let scale = this.precision;
    if (scale) {
      scale = 10 ** scale;
      value = Math.round(value * scale) / scale;
    } else if (scale === 0) {
      value = Math.round(value);
    }
    return value;
  }
};
__publicField(NumberDataField, "$name", "NumberDataField");
__publicField(NumberDataField, "type", "number");
__publicField(NumberDataField, "alias", "float");
NumberDataField.initClass();
NumberDataField._$name = "NumberDataField";

// ../Core/lib/Core/data/field/ObjectDataField.js
var ObjectDataField = class extends DataField {
  static get $name() {
    return "ObjectDataField";
  }
  static get type() {
    return "object";
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
};
ObjectDataField.initClass();
ObjectDataField._$name = "ObjectDataField";

// ../Core/lib/Core/data/field/StoreDataField.js
var isIdAutoGenerated = (id) => typeof id === "string" && id.startsWith("_generated");
var StoreDataField = class extends DataField {
  /**
   * Store class to use when creating the store.
   *
   * ```javascript
   * class TodoStore extends Store {
   *     ...
   * }
   *
   * const task = new Store({
   *     static fields = [
   *         { type : 'store', name: 'todoItems', storeClass : TodoStore }
   *     ]
   * });
   * ```
   *
   * @config {Class} storeClass
   * @typings {typeof Store}
   */
  /**
   * Model class to use for the store (can also be configured as usual on the store class, this config is for
   * convenience).
   *
   * ```javascript
   * class TodoItem extends Model {
   *   ...
   * }
   *
   * const task = new Store({
   *     static fields = [
   *         { type : 'store', name: 'todoItems', storeClass : Store, modelClass : TodoItem }
   *     ]
   * });
   * ```
   *
   * @config {Class} modelClass
   * @typings {typeof Model}
   */
  /**
   * Optional store configuration object to apply when creating the store.
   *
   * ```javascript
   * const task = new Store({
   *     static fields = [
   *         {
   *             type       : 'store',
   *             name       : 'todoItems',
   *             storeClass : Store
   *             store      : {
   *                  syncDataOnLoad : false
   *             }
   *         }
   *     ]
   * });
   * ```
   *
   * @config {StoreConfig} store
   */
  // Initializer, called when creating a record. Sets up the store and populates it with any initial data
  init(data, record) {
    var _a2;
    const me = this, storeName = `${me.name}Store`, config = { skipStack: true, syncDataOnLoad: true };
    if (me.store) {
      ObjectHelper.assign(config, me.store);
    }
    if (me.modelClass) {
      config.modelClass = me.modelClass;
    }
    (_a2 = record[`init${StringHelper.capitalize(storeName)}`]) == null ? void 0 : _a2.call(record, config);
    if (!config.storeClass && !me.storeClass) {
      throw new Error(`Field '${me.name}' with type 'store' must have a storeClass configured`);
    }
    const store = record.meta[storeName] = new (config.storeClass || me.storeClass)(config);
    if (me.complexMapping) {
      ObjectHelper.setPath(data, me.dataSource, store);
    } else {
      data[me.dataSource] = store;
    }
    store.verifyNoGeneratedIds = false;
    store.usesId = !store.count || !store.every((record2) => record2.hasGeneratedId);
    store.$currentValue = me.getValue(store);
    store.ion({
      change: ({ action }) => {
        const value = me.getValue(store);
        if (!store.$isSettingStoreFieldData) {
          const oldPreserveCurrentDataset = store.$preserveCurrentDataset;
          store.$preserveCurrentDataset = me.subStore && (action === "update" || action === "remove" || action === "add");
          me.$isUpdatingRecord = true;
          record.set(me.name, value);
          me.$isUpdatingRecord = false;
          store.$preserveCurrentDataset = oldPreserveCurrentDataset;
        }
        store.$currentValue = value;
      }
    });
  }
  // Called when setting a new value to the field on a record
  set(value, data, record) {
    var _a2, _b;
    const me = this, storeName = `${me.name}Store`, { [storeName]: store } = record.meta;
    if (!store) {
      record.meta.initableValues.set(me, value);
      return false;
    }
    if (store.$isSettingStoreFieldData) {
      return;
    }
    store.$isSettingStoreFieldData = true;
    value = (_b = (_a2 = record[`process${StringHelper.capitalize(storeName)}Data`]) == null ? void 0 : _a2.call(record, value, record)) != null ? _b : value;
    if (!store.$preserveCurrentDataset) {
      store.data = value;
    }
    store.$isSettingStoreFieldData = false;
    store.usesId = !store.count || !store.every((record2) => record2.hasGeneratedId);
  }
  serialize(value, record) {
    const store = record.meta[`${this.name}Store`];
    return this.$isUpdatingRecord ? this.getValue(store) : store.$currentValue;
  }
  // Extract persistable values, optionally including id depending on if ids are used
  getValue(store) {
    return store.allRecords.map((r) => {
      const data = r.persistableData;
      if (!store.usesId) {
        delete data.id;
      }
      return data;
    });
  }
  isEqual(a, b) {
    if (a == null && b == null) {
      return true;
    } else if (a == null && b != null || a != null && b == null) {
      return false;
    } else {
      if (a.isStore && b.isStore) {
        return ObjectHelper.isDeeplyEqual(a.$currentValue, b.$currentValue);
      } else if (a.isStore && b.isStore || !a.isStore && !b.isStore) {
        return ObjectHelper.isEqual(a, b, true);
      } else {
        const store = a.isStore ? a : b, modelClass = store.modelClass, fields = modelClass.$meta.fields.defs, storeEntries = a.isStore ? a.$currentValue : b.$currentValue, arrayEntries = a.isStore ? b : a;
        if (storeEntries.length !== arrayEntries.length) {
          return false;
        } else {
          for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            if (!field.persist) {
              continue;
            }
            for (let k = 0; k < storeEntries.length; k++) {
              const storeValue = storeEntries[k][field.dataSource];
              const arrayValue = arrayEntries[k][field.dataSource];
              if (storeValue !== void 0 && arrayValue === void 0) {
                if (field.dataSource === modelClass.idField && isIdAutoGenerated(storeValue)) {
                  continue;
                }
                if (field.defaultValue !== void 0 && ObjectHelper.isEqual(field.defaultValue, storeValue, true)) {
                  continue;
                }
              }
              if (!ObjectHelper.isEqual(storeValue, arrayValue, true)) {
                return false;
              }
            }
          }
          return true;
        }
      }
    }
  }
  // Cloned value to be able to restore it later using STM
  getOldValue(record) {
    const store = record.meta[`${this.name}Store`];
    return store ? ObjectHelper.clone(store.$currentValue) : null;
  }
  getAt(record, index) {
    const store = record.meta[`${this.name}Store`];
    return store == null ? void 0 : store.getAt(index);
  }
};
__publicField(StoreDataField, "$name", "StoreDataField");
__publicField(StoreDataField, "type", "store");
StoreDataField.initClass();
StoreDataField._$name = "StoreDataField";

// ../Core/lib/Core/data/field/DurationUnitDataField.js
var DurationUnitDataField = class extends StringDataField {
  static get $name() {
    return "DurationUnitDataField";
  }
  static get type() {
    return "durationunit";
  }
  isEqual(first, second) {
    return DateHelper.compareUnits(first, second) === 0;
  }
};
DurationUnitDataField.initClass();
DurationUnitDataField._$name = "DurationUnitDataField";

// ../Core/lib/Core/data/Model.js
var nestedRe = new RegExp(/^(.*?)\.(.*)/);
var arrayRe = /(.*)\[(.*)]\.?(.*)/;
var { defineProperty: defineProperty5 } = Reflect;
var { hasOwn: hasOwn3 } = ObjectHelper;
var _undefined = void 0;
var internalProps = {
  children: 1,
  data: 1,
  meta: 1
};
var abbreviationFields = [
  "name",
  "title",
  "text",
  "label",
  "description"
];
var fieldDataTypes = {
  boolean: 1,
  number: 1,
  date: 1,
  object: 1
};
var fieldsOrder = {
  parentId: 1,
  $PhantomId: 2,
  id: 3
};
var _Model = class _Model extends Base.mixin(ModelStm_default, TreeNode_default, ModelLink_default) {
  static get $name() {
    return "Model";
  }
  static get declarable() {
    return [
      /**
       * Array of defined fields for this model class. Subclasses add new fields by implementing this static
       * getter:
       *
       * ```javascript
       * // Model defining two fields
       * class Person extends Model {
       *     static get fields() {
       *         return [
       *             { name : 'username', defaultValue : 'New person' },
       *             { name : 'birthdate', type : 'date' }
       *         ];
       *     }
       * }
       *
       * // Subclass overriding one of the fields
       * class Bot extends Person {
       *     static get fields() {
       *         return [
       *             // Default value of 'username' field is overridden, any other setting from the parents
       *             // definition is preserved
       *             { name : 'username', defaultValue : 'Bot' }
       *         ];
       *     }
       * }
       * ```
       *
       * Fields in a subclass are merged with those from the parent class, making it easy to override mappings,
       * formats etc.
       *
       * @member {Array<String|ModelFieldConfig|Core.data.field.DataField>} fields
       * @readonly
       * @static
       * @category Fields
       */
      "fields"
    ];
  }
  static get fields() {
    return [
      // The index of this item in its parent (respects filtering)
      {
        name: "parentIndex",
        type: "number",
        persist: false,
        internal: true
      },
      // The index of this item in its parent ghost (non-sortable) children array
      {
        name: "orderedParentIndex",
        type: "number",
        persist: false,
        internal: true
      },
      /**
       * Flag the record as read-only on the UI level, preventing the end user from manipulating it using editing
       * features such as cell editing and event dragging.
       *
       * Does not prevent altering the record programmatically, it can still be manipulated by application code.
       *
       * For more info, see the "Read-only records" section above.
       *
       * @field {Boolean} readOnly
       * @category Common
       */
      {
        name: "readOnly",
        type: "boolean"
      },
      /**
       * Start expanded or not (only valid for tree data)
       * @readonly
       * @field {Boolean} expanded
       * @category Tree
       */
      {
        name: "expanded",
        internal: true
      },
      /**
       * Only used when the store is grouped. This field references the owning group record(s), kept in a map
       * keyed by store id.
       * @internal
       * @field {Map} groupParent
       */
      {
        name: "groupParent",
        persist: false,
        internal: true
      }
    ];
  }
  /**
   * Template static getter which is supposed to be overridden to define default field values for the Model class.
   * Overrides `defaultValue` config specified by the {@link #property-fields-static} getter.
   * Returns a named object where key is a field name and value is a default value for the field.
   *
   * NOTE: This is a legacy way of defining default values, we recommend using {@link #property-fields-static} moving
   * forward.
   *
   * ```javascript
   * class Person extends Model {
   *     static get fields() {
   *         return [
   *             { name : 'username', defaultValue : 'New person' }
   *         ];
   *     }
   * }
   *
   * class Bot extends Person {
   *     static get defaults() {
   *         return {
   *             username : 'Bot' // default value of 'username' field is overridden
   *         };
   *     }
   * }
   * ```
   *
   * @member {Object} defaults
   * @static
   * @category Fields
   */
  /**
   * The data source for the id field which provides the ID of instances of this Model.
   * @property {String}
   * @category Fields
   */
  static set idField(idField) {
    this._assignedIdField = true;
    this._idField = idField;
  }
  static get idField() {
    return this._idField;
  }
  /**
   * The name of the data field which holds children of this Model when used in a tree structure
   * ```javascript
   * MyModel.childrenField = 'kids';
   * const parent = new MyModel({
   *     name : 'Dad',
   *     kids : [
   *         { name : 'Daughter' },
   *         { name : 'Son' }
   *     ]
   * });
   * ```
   * @property {String}
   * @category Fields
   */
  static set childrenField(childrenField) {
    this._childrenField = childrenField;
  }
  static get childrenField() {
    if (!this._childrenField) {
      const dataField = this.fieldMap.children;
      this._childrenField = (dataField == null ? void 0 : dataField.dataSource) || "children";
    }
    return this._childrenField;
  }
  /**
   * Returns index path to this node. This is the index of each node in the node path
   * starting from the topmost parent. (only relevant when its part of a tree store).
   * @returns {Number[]} The index of each node in the path from the topmost parent to this node.
   * @category Parent & children
   * @private
   */
  get indexPath() {
    const indices = [];
    let node = this, depth = node.childLevel;
    for (node = this; node && !node.isRoot; node = node.parent) {
      indices[depth--] = node.parentIndex + 1;
    }
    return indices;
  }
  /**
   * Unique identifier for the record. Might be mapped to another dataSource using idField, but always exposed as
   * record.id. Will get a generated value if none is specified in records data.
   *
   * {@note}Note that generated ids are meant to be temporary (phantom ids), they should not be serialized
   * but instead replaced by the backend on commit{/@note}
   *
   * @field {String|Number} id
   * @category Common
   */
  //region Init
  /**
   * Constructs a new record from the supplied data config.
   * @param {Object} [config] Raw model config
   * @param {Core.data.Store} [store] Data store
   * @param {Object} [meta] Meta data
   * @privateparam {Boolean} [skipExpose] Skip exposing properties from data
   * @privateparam {Boolean} [forceUseRaw] Force using raw data, used by copy to not clone data twice
   * @function constructor
   * @category Lifecycle
   */
  construct(config = {}, store = null, meta = null, skipExpose = false, forceUseRaw = false, rawData = false) {
    var _a2, _b;
    const me = this, stores = (_a2 = ArrayHelper.asArray(store)) != null ? _a2 : [], { constructor, fieldMap } = me;
    let configs = null;
    store = stores[0];
    me.meta = {
      modified: {},
      ...constructor.metaConfig,
      ...meta
    };
    if (constructor.applyConfigs) {
      configs = {};
      if (!me.useRawData || !me.useRawData.enabled) {
        config = { ...config };
      }
      const defaultConfig = me.getDefaultConfiguration();
      if (constructor.autoExposeFields) {
        for (const key in defaultConfig) {
          if (key in config) {
            if (config[key] !== void 0) {
              configs[key] = config[key];
            }
            delete config[key];
          }
        }
      } else {
        for (const key in config) {
          if (!(key in constructor.fieldMap)) {
            if (config[key] === void 0) {
              configs[key] = defaultConfig[key];
            } else {
              configs[key] = config[key];
            }
            delete config[key];
          }
        }
      }
    }
    super.construct(configs);
    if (!skipExpose) {
      constructor.exposeProperties(config, rawData);
    }
    if (!hasOwn3(constructor, "idFieldProcessed")) {
      let overriddenIdField = me.meta.idField;
      if (!overriddenIdField) {
        if (constructor._assignedIdField) {
          overriddenIdField = constructor.idField;
        } else if (store) {
          overriddenIdField = store.idField;
        }
      }
      if (overriddenIdField && overriddenIdField !== fieldMap.id.dataSource) {
        constructor.addField({
          name: "id",
          dataSource: overriddenIdField,
          internal: true
        });
      }
      constructor._idField = fieldMap.id.dataSource;
      constructor.idFieldProcessed = true;
    }
    me._internalId = _Model._internalIdCounter++;
    me.stores = [];
    me.unjoinedStores = [];
    if (!me.originalData) {
      me.originalData = config;
    }
    me.data = constructor.processData(config, false, store, me, forceUseRaw);
    ((_b = me.meta.initableValues) == null ? void 0 : _b.size) && me.assignInitables();
    if (me.id == null) {
      me.setData("id", me.generateId(store));
    }
    if (me.data[constructor.childrenField]) {
      me.processChildren(stores);
    }
    me.generation = 0;
  }
  /**
   * Set this property to `true` when adding a record on a conditional basis, that is, it is yet
   * to be confirmed as an addition.
   *
   * When this is set, the {@link #property-isPersistable} value of the record is **false**, and upon being
   * added to a Store it will *not* be eligible to be synced with the server as an added record.
   *
   * Subsequently, *clearing* this property means this record will become persistable and eligible
   * for syncing as an added record.
   * @property {Boolean}
   * @category Editing
   */
  set isCreating(isCreating) {
    const me = this;
    if (Boolean(me.meta.isCreating) !== isCreating) {
      me.meta.isCreating = isCreating;
      me.stores.forEach((s) => {
        s.onIsCreatingToggle(me, isCreating);
      });
    }
  }
  get isCreating() {
    return Boolean(this.meta.isCreating);
  }
  /**
   * Compares this Model instance to the passed instance. If they are of the same type, and all fields
   * (except, obviously, `id`) are equal, this returns `true`.
   * @param {Core.data.Model} other The record to compare this record with.
   * @returns {Boolean} `true` if the other is of the same class and has all fields equal.
   * @category Misc
   */
  equals(other) {
    if (other instanceof this.constructor) {
      for (let fields = this.$meta.fields.defs, i = 0, { length } = fields; i < length; i++) {
        const field = fields[i], { name } = field;
        if (name !== "id" && !field.isEqual(this.getValue(name), other.getValue(name))) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  get subclass() {
    return new this.constructor(Object.setPrototypeOf({
      id: _undefined
    }, this.data), this.stores[0], null, true);
  }
  /**
   * Processes raw data, converting values and setting defaults.
   * @private
   * @param {Object} data Raw data
   * @param {Boolean} [ignoreDefaults] Ignore setting default values, used when updating
   * @returns {Object} Processed data
   * @category Fields
   */
  static processData(data, ignoreDefaults = false, store, record, forceUseRaw) {
    const { fieldMap, fieldDataSourceMap, defaultValues } = this, { useRawData = { enabled: false } } = store || {}, processed = forceUseRaw || useRawData.enabled ? data : ObjectHelper.clone(data);
    let fieldName;
    ignoreDefaults = ignoreDefaults || useRawData.disableDefaultValue || forceUseRaw;
    if (!ignoreDefaults) {
      for (fieldName in defaultValues) {
        const field = fieldDataSourceMap[fieldName];
        let defaultValue2 = defaultValues[fieldName];
        if (Array.isArray(defaultValue2)) {
          defaultValue2 = defaultValue2.slice();
        }
        if (field == null ? void 0 : field.complexMapping) {
          if (ObjectHelper.getPath(processed, fieldName) === _undefined) {
            ObjectHelper.setPath(processed, fieldName, defaultValue2);
          }
        } else if (processed[fieldName] === _undefined) {
          processed[fieldName] = defaultValue2;
        }
      }
    }
    if (!useRawData.disableTypeConversion && !forceUseRaw) {
      for (fieldName in fieldMap) {
        const field = fieldMap[fieldName], { name, dataSource } = field, hasSource = dataSource !== name, complex = field.complexMapping, sourceExists = hasSource && (complex ? ObjectHelper.pathExists(data, dataSource) : dataSource in data), useNameForValue = name in data && (!hasSource || !sourceExists), convert = !useRawData.disableTypeConversion && field.convert;
        if (useNameForValue || convert) {
          if (!ignoreDefaults || useNameForValue || sourceExists) {
            const value = useNameForValue ? processed[name] : complex ? ObjectHelper.getPath(processed, dataSource) : processed[dataSource], converted = convert ? field.convert(value, data, record) : value;
            if (complex) {
              ObjectHelper.setPath(processed, dataSource, converted);
            } else {
              processed[dataSource] = converted;
            }
            if (hasSource) {
              delete processed[name];
            }
          }
        }
      }
    }
    this.$meta.fields.initable.length && this.initInitables(record, processed);
    return processed;
  }
  static setupClass(meta) {
    super.setupClass(meta);
    if (!meta.fields) {
      this.setupFields(this, meta);
    }
  }
  static setupFields(cls, meta) {
    var _a2, _b, _c, _d, _e;
    const classFields = hasOwn3(cls, "fields") && cls.fields, base = meta.super.fields, fieldsInfo = meta.fields = {
      defs: (_a2 = base == null ? void 0 : base.defs.slice()) != null ? _a2 : [],
      // Set to true when an instance's data object is run through exposeProperties
      exposedData: false,
      // These objects are all keyed by field name:
      defaults: base ? { ...base.defaults } : {},
      // value=field.defaultValue
      exposed: Object.create((_b = base == null ? void 0 : base.exposed) != null ? _b : null),
      // value=true if we've done defineProperty
      ordinals: Object.create((_c = base == null ? void 0 : base.ordinals) != null ? _c : null),
      // value=index in the defs array
      map: Object.create((_d = base == null ? void 0 : base.map) != null ? _d : null),
      // value=definition object
      sources: Object.create((_e = base == null ? void 0 : base.sources) != null ? _e : null)
      // value=source definition object
    };
    if (hasOwn3(cls, "defaults")) {
      Object.assign(fieldsInfo.defaults, cls.defaults);
    }
    if (hasOwn3(cls, "idField")) {
      cls.addField({
        name: "id",
        dataSource: cls.idField,
        internal: true
      });
      fieldsInfo.exposed[cls.idField] = true;
    }
    if (classFields == null ? void 0 : classFields.length) {
      classFields.map(cls.addField, cls);
    }
    fieldsInfo.initable = fieldsInfo.defs.filter((field) => field.init);
    cls.exposeRelations();
  }
  static get defaultValues() {
    return this.$meta.fields.defaults;
  }
  /**
   * An array containing all the _defined_ fields for this Model class. This will include all superclass's
   * defined fields.
   * @property {Core.data.field.DataField[]}
   * @static
   * @readonly
   * @category Fields
   */
  static get allFields() {
    return this.$meta.fields.defs;
  }
  /**
   * Same as {@link #property-allFields-static}.
   * @property {Core.data.field.DataField[]}
   * @readonly
   * @category Fields
   */
  get allFields() {
    return this.$meta.fields.defs;
  }
  /**
   * An object containing all the _defined_ fields for this Model class. This will include all superclass's
   * defined fields through its prototype chain. So be aware that `Object.keys` and `Object.entries` will only
   * access this class's defined fields.
   * @property {Object<String,Core.data.field.DataField>}
   * @static
   * @readonly
   * @category Fields
   */
  static get fieldMap() {
    return this.$meta.fields.map;
  }
  /**
   * Same as {@link #property-fieldMap-static}.
   * @property {Object<String,Core.data.field.DataField>}
   * @readonly
   * @category Fields
   */
  get fieldMap() {
    return this.$meta.fields.map;
  }
  static get fieldDataSourceMap() {
    return this.$meta.fields.sources;
  }
  /**
   * Makes getters and setters for fields (from definitions and data). Called once when class is defined and once when
   * data is loaded first time.
   * @internal
   * @param {Object} [data] Raw data
   * @param {Boolean} [raw=true] True if data is raw (contains data sources), False if data contains field names
   * @category Fields
   */
  static exposeProperties(data, raw = true) {
    const me = this, fieldsInfo = me.$meta.fields, fieldMapProperty = raw ? "exposed" : "map";
    if (data && me.autoExposeFields && !fieldsInfo.exposedData) {
      let dataProperty, fieldDef, type;
      for (dataProperty in data) {
        if (!fieldsInfo[fieldMapProperty][dataProperty] && dataProperty !== me.childrenField) {
          type = ObjectHelper.typeOf(data[dataProperty]);
          fieldDef = {
            name: dataProperty,
            dataSource: dataProperty,
            fromData: true
          };
          if (fieldDataTypes[type]) {
            fieldDef.type = type;
          }
          me.addField(fieldDef);
        }
      }
      fieldsInfo.exposedData = true;
    }
    me.exposeRelations();
  }
  /**
   * Add a field definition in addition to those predefined in `fields`.
   * @param {String|ModelFieldConfig} fieldDef A field name or definition
   * @category Fields
   */
  static addField(fieldDef) {
    if (fieldDef == null) {
      return;
    }
    if (typeof fieldDef === "string") {
      fieldDef = {
        name: fieldDef
      };
    }
    const me = this.initClass(), fieldsInfo = me.$meta.fields, { ordinals } = fieldsInfo, propertiesExposed = fieldsInfo.exposed, { name } = fieldDef, existing = fieldsInfo.map[name], dataSource = fieldDef.dataSource || (fieldDef.dataSource = name);
    let field, key;
    if (!existing || fieldDef.type && fieldDef.type !== existing.type) {
      field = DataField.create(fieldDef);
      field.definedBy = existing ? existing.definedBy : me;
      field.ordinal = existing ? existing.ordinal : ordinals[name] = fieldsInfo.defs.length;
    } else {
      field = Object.create(existing);
      for (key in fieldDef) {
        if (key !== "type") {
          field[key] = fieldDef[key];
        }
      }
    }
    field.owner = me;
    fieldsInfo.defs[field.ordinal] = field;
    fieldsInfo.map[name] = field;
    if (!fieldsInfo.sources[dataSource]) {
      fieldsInfo.sources[dataSource] = field;
    }
    if (dataSource.includes(".")) {
      field.complexMapping = true;
    }
    if (field.complexMapping) {
      propertiesExposed[dataSource.split(".")[0]] = true;
    } else {
      propertiesExposed[dataSource] = true;
    }
    if ("defaultValue" in field) {
      fieldsInfo.defaults[dataSource] = field.defaultValue;
    }
    if (!internalProps[name]) {
      field.defineAccessor(me.prototype);
    }
    me._nonPersistableFields = null;
    me._alwaysWriteFields = null;
    return field;
  }
  /**
   * Remove a field definition by name.
   * @param {String} fieldName Field name
   * @category Fields
   */
  static removeField(fieldName) {
    const me = this.initClass(), fieldsInfo = me.$meta.fields, definition = fieldsInfo.map[fieldName], { ordinals } = fieldsInfo, index = ordinals[fieldName];
    if (definition) {
      fieldsInfo.defs.splice(index, 1);
      delete ordinals[fieldName];
      delete fieldsInfo.defaults[fieldName];
      delete fieldsInfo.exposed[fieldName];
      delete fieldsInfo.map[fieldName];
      delete fieldsInfo.sources[definition.dataSource];
      for (const name in ordinals) {
        if (ordinals[name] > index) {
          --ordinals[name];
        }
      }
      delete me.prototype[fieldName];
    }
  }
  /**
   * Makes getters and setters for related records. Populates a Model#relation array with the relations, to allow it
   * to be modified later when assigning stores.
   * @internal
   * @category Relations
   */
  static exposeRelations() {
    const me = this;
    if (hasOwn3(me, "exposedRelations")) {
      return;
    }
    if (me.relations) {
      me.exposedRelations = [];
      for (const relationName in me.relations) {
        const relation = me.relations[relationName];
        relation.relationName = relationName;
        me.exposedRelations.push(relation);
        if (!Reflect.ownKeys(me.prototype).includes(relationName)) {
          defineProperty5(me.prototype, relationName, {
            enumerable: true,
            get: function() {
              return this.getForeign(relationName);
            },
            set: function(value) {
              this.setForeign(relationName, value, relation);
            }
          });
        }
      }
    }
  }
  //endregion
  //region Initable fields
  // Initializes any fields using a data type that has an init method, and caches the value to assign to that field to
  // be able to assign it after all others. That allows the initter to reference the records other data if needed
  // (baselines use that to reference the task to get default values)
  static initInitables(record, processedData) {
    const laterValues = record.meta.initableValues = /* @__PURE__ */ new Map();
    for (const field of this.$meta.fields.initable) {
      const value = ObjectHelper.getPath(processedData, field.dataSource);
      value !== void 0 && laterValues.set(field, value);
      !field.lazy && field.init(processedData, record);
    }
  }
  // Assigns values to the fields that were initialized earlier (see initInitables above)
  assignInitables() {
    const { initableValues } = this.meta;
    for (const [field, value] of initableValues) {
      if (field.set(value, this.data, this) !== false) {
        initableValues.delete(field);
      }
    }
  }
  //endregion
  //region Fields
  /**
   * Flag checked from Store when loading data that determines if fields found in first records should be exposed in
   * same way as predefined fields.
   *
   * {@note}Note that we for all but the most basic use cases recommend explicitly defining the fields.
   * Having them auto exposed can lead to unexpected behavior, if the first record is not complete (fields missing,
   * null etc).
   * {/@note}
   *
   * @property {Boolean}
   * @category Fields
   */
  static get autoExposeFields() {
    return true;
  }
  /**
   * This function forces correct field order. Correct order is parentId before id. If we process id field before
   * parentId, idMap won't be updated and changing parent node will lead to duplicated records in storage
   * @param {String} a
   * @param {String} b
   * @returns {number}
   * @private
   */
  static fieldSorter(a, b) {
    return (fieldsOrder[a] || 100) - (fieldsOrder[b] || 100);
  }
  /**
   * Convenience getter to get field definitions from class.
   * @property {Core.data.field.DataField[]}
   * @readonly
   * @category Fields
   */
  get fields() {
    return this.$meta.fields.defs;
  }
  /**
   * Convenience function to get the definition for a field from class.
   * @param {String} fieldName Field name
   * @returns {Core.data.field.DataField}
   * @category Fields
   */
  getFieldDefinition(fieldName) {
    return this.constructor.getFieldDefinition(fieldName);
  }
  getFieldDefinitionFromDataSource(dataSource) {
    return this.$meta.fields.sources[dataSource];
  }
  /**
   * Get the names of all fields in data.
   * @property {String[]}
   * @readonly
   * @category Fields
   */
  get fieldNames() {
    return Object.keys(this.data);
  }
  /**
   * Get the definition for a field by name.
   * @param {String} fieldName Field name
   * @returns {Core.data.field.DataField} Field definition or null if none found
   * @category Fields
   */
  static getFieldDefinition(fieldName) {
    var _a2, _b;
    const field = this.fieldMap[fieldName];
    if (!field) {
      if (fieldName.includes("[")) {
        const [, arrayFieldName, , path] = fieldName.match(arrayRe), arrayField = arrayFieldName.includes(".") ? this.getFieldDefinition(arrayFieldName) : this.fieldMap[arrayFieldName];
        if (arrayField == null ? void 0 : arrayField.isStoreDataField) {
          return (_a2 = arrayField.modelClass) == null ? void 0 : _a2.getFieldDefinition(path);
        }
      } else if (fieldName.includes(".")) {
        const [localFieldName, path] = fieldName.split(".", 2), modelField = this.fieldMap[localFieldName];
        if (modelField.isModelDataField && modelField.modelClass) {
          return (_b = modelField.modelClass) == null ? void 0 : _b.getFieldDefinition(path);
        }
      }
    }
    return field;
  }
  /**
   * Returns dataSource configuration for a given field name
   * @param {String} fieldName
   * @returns {String} Field `dataSource` mapping
   * @internal
   */
  static getFieldDataSource(fieldName) {
    var _a2;
    return ((_a2 = this.getFieldDefinition(fieldName)) == null ? void 0 : _a2.dataSource) || fieldName;
  }
  /**
   * Get the data source used by specified field. Returns the fieldName if no data source specified.
   * @param {String} fieldName Field name
   * @returns {String}
   * @category Fields
   */
  getDataSource(fieldName) {
    const def = this.constructor.getFieldDefinition(fieldName);
    return (def == null ? void 0 : def.dataSource) || (def == null ? void 0 : def.name);
  }
  /**
   * Processes input to a field, converting to expected type.
   * @param {String} fieldName Field name
   * @param {*} value Value to process
   * @returns {*} Converted value
   * @category Fields
   */
  static processField(fieldName, value, record) {
    const field = this.fieldMap[fieldName];
    return (field == null ? void 0 : field.convert) ? field.convert(value, this.data, record) : value;
  }
  //endregion
  //region Relations
  /**
   * Initializes model relations. Called from store when adding a record.
   * @private
   * @category Relations
   */
  initRelations() {
    const me = this, relations = me.constructor.exposedRelations;
    if (!relations) {
      return;
    }
    me.stores.forEach((store) => {
      var _a2;
      if (!store.modelRelations) {
        store.initRelations();
      }
      const relatedRecords = [];
      (_a2 = store.modelRelations) == null ? void 0 : _a2.forEach((config) => {
        relatedRecords.push({ related: me.initRelation(config), config });
      });
      store.updateRecordRelationCache(me, relatedRecords);
    });
  }
  /**
   * Initializes/updates a single relation.
   * @param config Relation config
   * @returns {Core.data.Model} Related record
   * @private
   * @category Relations
   */
  initRelation(config) {
    const me = this, foreignId = me.get(config.foreignKey), foreign = foreignId !== _undefined && typeof config.foreignStore !== "string" && config.foreignStore.getById(foreignId), relationCache = me.meta.relationCache || (me.meta.relationCache = {});
    relationCache[config.relationName] = foreign || (foreignId != null ? { id: foreignId, placeHolder: true } : null);
    return foreign;
  }
  removeRelation(config) {
    const { relationName, foreignKey, nullFieldOnRemove } = config;
    if (this.meta.relationCache[relationName]) {
      delete this.meta.relationCache[relationName];
      if (nullFieldOnRemove) {
        this.setData(foreignKey, null);
      }
    }
  }
  getForeign(name) {
    var _a2;
    return (_a2 = this.meta.relationCache) == null ? void 0 : _a2[name];
  }
  setForeign(name, value, config) {
    const id = _Model.asId(value);
    return this.set(config.foreignKey, id);
  }
  /**
   * Get a relation config by name, from the first store.
   * @param {String} name
   * @returns {Object}
   * @private
   * @category Relations
   */
  getRelationConfig(name) {
    var _a2, _b;
    return (_b = (_a2 = this.firstStore) == null ? void 0 : _a2.modelRelations) == null ? void 0 : _b.find((r) => r.foreignKey === name);
  }
  //endregion
  //region Get/set values, data handling
  flatGet(fieldName, dataSource) {
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return dataSource in this.data ? this.data[dataSource] : this.data[fieldName];
  }
  complexGet(fieldName, dataSource) {
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return ObjectHelper.getPath(this.data, dataSource);
  }
  /**
   * Get value for specified field name. You can also use the generated getters if loading through a Store.
   * If model is currently in batch operation this will return updated batch values which are not applied to Model
   * until endBatch() is called.
   * @param {String} fieldName Field name to get value from
   * @returns {*} Fields value
   * @category Fields
   */
  get(fieldName) {
    if (!fieldName) {
      return;
    }
    const me = this, field = me.fieldMap[fieldName];
    if (!field) {
      if (fieldName.includes("[")) {
        const [, arrayFieldName, index, path] = fieldName.match(arrayRe);
        const arrayField = me.fieldMap[arrayFieldName];
        if (arrayField == null ? void 0 : arrayField.getAt) {
          me._thisIsAUsedExpression(me[arrayFieldName]);
          const subRecord = arrayField.getAt(me, index);
          if (subRecord && path) {
            if (subRecord.isModel) {
              return subRecord.getValue(path);
            }
            return subRecord[path];
          }
          return subRecord;
        }
        return null;
      }
      if (fieldName.includes(".")) {
        if (!ObjectHelper.hasPath(me.data, fieldName)) {
          return ObjectHelper.getPath(me, fieldName);
        }
        return me.complexGet(fieldName, fieldName);
      }
    }
    if (field == null ? void 0 : field.complexMapping) {
      return me.complexGet(fieldName, field.dataSource);
    }
    return me.flatGet(fieldName, (field == null ? void 0 : field.dataSource) || fieldName);
  }
  // Used to get field values, replaces `record[fieldName]` in internal code to allow relations etc.
  getValue(fieldName) {
    if (!fieldName) {
      return;
    }
    if (fieldName in this) {
      return this[fieldName];
    }
    return this.get(fieldName);
  }
  // Used to set field values, replacing `record[fieldName] = value` to handle dot notation
  setValue(fieldName, value) {
    if (fieldName in this) {
      this[fieldName] = value;
    } else {
      this.set(fieldName, value);
    }
  }
  /**
   * Internal function used to update a records underlying data block (record.data) while still respecting field
   * mappings. Needed in cases where a field needs setting without triggering any associated behaviour and it has a
   * dataSource with a different name.
   *
   * For example:
   * ```javascript
   * // startDate mapped to data.beginDate
   * { name : 'startDate', dataSource : 'beginDate' }
   *
   * // Some parts of our code needs to update the data block without triggering any of the behaviour associated with
   * // calling set. This would then not update "beginDate":
   * record.data.startDate = xx;
   *
   * // But this would
   * record.setData('startDate', xx);
   * ```
   * @internal
   * @category Editing
   */
  setData(toSet, value) {
    var _a2, _b;
    const { data, fieldMap } = this;
    if (typeof toSet === "string") {
      const field = fieldMap[toSet], dataSource = (_a2 = field == null ? void 0 : field.dataSource) != null ? _a2 : toSet;
      if (field == null ? void 0 : field.set) {
        field.set(value, this.data, this);
      } else if (field == null ? void 0 : field.complexMapping) {
        ObjectHelper.setPath(data, dataSource, value);
      } else {
        data[dataSource] = value;
      }
    } else {
      const keys = Object.keys(toSet);
      for (let i = 0; i < keys.length; i++) {
        const fieldName = keys[i], field = fieldMap[fieldName], dataSource = (_b = field == null ? void 0 : field.dataSource) != null ? _b : fieldName;
        if (field == null ? void 0 : field.set) {
          field.set(value, this.data, this);
        } else if (dataSource) {
          if (field == null ? void 0 : field.complexMapping) {
            ObjectHelper.setPath(data, dataSource, toSet[fieldName]);
          } else {
            data[dataSource] = toSet[fieldName];
          }
        }
      }
    }
  }
  /**
   * Returns raw data from the encapsulated data object for the passed field name
   * @param {String} fieldName The field to get data for.
   * @returns {*} The raw data value for the field.
   * @category Editing
   */
  getData(fieldName) {
    var _a2;
    const field = this.fieldMap[fieldName], dataSource = (_a2 = field == null ? void 0 : field.dataSource) != null ? _a2 : fieldName;
    if (dataSource) {
      if (field == null ? void 0 : field.complexMapping) {
        return ObjectHelper.getPath(this.data, dataSource);
      }
      return this.data[dataSource];
    }
  }
  /**
   * Silently updates record's id with no flagging the property as modified.
   * Triggers onModelChange event for changed id.
   * @param {String|Number} value id value
   * @private
   */
  syncId(value) {
    const oldValue = this.id;
    if (oldValue !== value) {
      this.setData("id", value);
      const data = { id: { value, oldValue } };
      this.afterChange(data, data);
    }
  }
  /**
   * Set value for the specified field. You can also use the generated setters if loading through a Store.
   *
   * Setting a single field, supplying name and value:
   *
   * ```javascript
   * record.set('name', 'Clark');
   * ```
   *
   * Setting multiple fields, supplying an object:
   *
   * ```javascript
   * record.set({
   *     name : 'Clark',
   *     city : 'Metropolis'
   * });
   * ```
   *
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} [value] Value to set
   * @param {Boolean} [silent] Set to true to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [validOnly] If set to `true` it will ignore setting a `undefined` value, allowing conversion functions to invalidate a data input
   * @privateparam {Boolean} [triggerBeforeUpdate]
   * @fires Store#idChange
   * @fires Store#update
   * @fires Store#change
   * @category Editing
   */
  set(field, value, silent = false, fromRelationUpdate = false, skipAccessors = false, validOnly = false, triggerBeforeUpdate = true) {
    var _a2;
    const me = this;
    if (me.isBatchUpdating) {
      me.inBatchSet(field, value, silent || me.$silenceBatch);
      return null;
    } else {
      const wasSet = me.inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly, triggerBeforeUpdate);
      (_a2 = me.afterSet) == null ? void 0 : _a2.call(me, field, value, silent, fromRelationUpdate, wasSet);
      return wasSet;
    }
  }
  fieldToKeys(field, value) {
    if (typeof field !== "string") {
      return ObjectHelper.assign({}, field);
    }
    return {
      [field]: value
    };
  }
  inBatchSet(field, value, silent) {
    const me = this, {
      meta,
      constructor,
      fieldMap
    } = me, wasSet = {};
    let cmp, changed = false;
    if (typeof field !== "string") {
      Object.keys(me.fieldToKeys(field, value)).forEach((key) => {
        cmp = fieldMap[key] || ObjectHelper;
        value = constructor.processField(key, field[key], me);
        if (!cmp.isEqual(meta.batchChanges[key], value)) {
          wasSet[key] = {
            value,
            oldValue: me.get(key)
          };
          meta.batchChanges[key] = value;
          changed = true;
        }
      });
    } else {
      cmp = fieldMap[field] || ObjectHelper;
      if (!cmp.isEqual(meta.batchChanges[field], value)) {
        wasSet[field] = {
          value,
          oldValue: me.get(field)
        };
        meta.batchChanges[field] = value;
        changed = true;
      }
    }
    if (changed) {
      me.generation++;
      if (!silent) {
        const event = {
          action: "update",
          record: me,
          records: [me],
          changes: wasSet
        };
        me.stores.forEach((store) => {
          store.trigger("batchedUpdate", { ...event });
        });
        me.forEachLinked(
          (store, record) => store.trigger("batchedUpdate", { ...event, record, records: [record] })
        );
      }
    }
  }
  inSet(fieldNameOrObject, value, silent, fromRelationUpdate, skipAccessors = false, validOnly = false, triggerBeforeUpdate = true) {
    var _a2, _b, _c;
    const me = this, {
      data,
      meta,
      fieldMap,
      constructor
    } = me, {
      prototype: myProto,
      childrenField,
      relations
    } = constructor, wasSet = {}, toSet = me.fieldToKeys(fieldNameOrObject, value), keys = Object.keys(toSet).sort(constructor.fieldSorter);
    let changed = false;
    if (!silent && triggerBeforeUpdate && !me.triggerBeforeUpdate(toSet)) {
      return null;
    }
    me.inSetting = true;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key === childrenField) {
        continue;
      }
      if (key.includes("[")) {
        const [, arrayFieldName, index, path] = key.match(arrayRe), field2 = me.fieldMap[arrayFieldName];
        if (field2 == null ? void 0 : field2.getAt) {
          const subRecord = field2.getAt(me, index);
          if (subRecord.isModel) {
            subRecord.set(path, toSet[key]);
          } else {
            ObjectHelper.setPath(subRecord, path, toSet[key]);
          }
          continue;
        }
      }
      const complexKey = key.includes(".");
      if (relations && complexKey) {
        const [, relationName, prop] = key.match(nestedRe);
        if (relations[relationName]) {
          me[relationName].set(prop, toSet[key]);
          continue;
        }
      }
      const field = fieldMap[key], cmp = field || ObjectHelper, readOnly = field == null ? void 0 : field.readOnly, mapping = (_a2 = field == null ? void 0 : field.dataSource) != null ? _a2 : key, useProp = !skipAccessors && !field && key in myProto || (field == null ? void 0 : field.useProp), oldValue = useProp ? me[mapping] : (field == null ? void 0 : field.complexMapping) || complexKey ? ObjectHelper.getPath(data, mapping) : data[mapping], value2 = constructor.processField(key, toSet[key], me), val = toSet[key] = { value: value2 }, relation = me.getRelationConfig(key), isEqual2 = (v1, v2) => cmp.isEqual(v1, v2) || v1 == null && v2 == null;
      if (!readOnly && !isEqual2(oldValue, value2) && (!validOnly || value2 !== void 0)) {
        me.generation++;
        val.oldValue = (_c = (_b = field == null ? void 0 : field.getOldValue) == null ? void 0 : _b.call(field, me)) != null ? _c : oldValue;
        changed = true;
        if (key in meta.modified && isEqual2(meta.modified[key], value2)) {
          Reflect.deleteProperty(meta.modified, key);
          if (me.isReverting) {
            me.data[mapping] = value2;
          }
        } else if (!me.ignoreBag) {
          if (!(key in meta.modified)) {
            me.storeFieldChange(key, oldValue);
          }
          if (val.oldValue === _undefined) {
            Reflect.deleteProperty(val, "oldValue");
          }
        }
        wasSet[key] = val;
        me.applyValue(useProp, mapping, value2, skipAccessors, field);
        if (relation && !fromRelationUpdate) {
          me.initRelation(relation);
          me.stores.forEach((store) => store.cacheRelatedRecord(me, value2, relation.relationName, val.oldValue));
        }
      }
    }
    if (changed) {
      me.afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    me.inSetting = false;
    return changed ? wasSet : null;
  }
  // Provided as a hook for Engine to do what needs to be done which ever way a field value is changed
  applyValue(useProp, key, value, skipAccessors, field) {
    var _a2;
    const me = this;
    if (((field == null ? void 0 : field.dataSource) || key) === me.constructor.idField) {
      me.$isPhantom = false;
    }
    if (((field == null ? void 0 : field.dataSource) || key) === me.constructor.parentIdField) {
      if (!(((_a2 = me.parent) == null ? void 0 : _a2.isRoot) && (value == null || !me.firstStore.getById(value)))) {
        (me.firstStore.getById(value) || me.firstStore.rootNode).insertChild(me, null, false, {
          orderedParentIndex: { skip: true }
        });
      }
    } else if (useProp) {
      me[(field == null ? void 0 : field.name) || key] = value;
    } else if (field == null ? void 0 : field.set) {
      field.set(value, me.data, me);
    } else {
      let complexMapping = field == null ? void 0 : field.complexMapping;
      if (!field && key.includes(".")) {
        const nestedName = key.split(".")[0];
        field = me.constructor.fieldMap[nestedName];
        complexMapping = (field == null ? void 0 : field.complexMapping) || (field == null ? void 0 : field.type) === "object";
      }
      if (complexMapping) {
        ObjectHelper.setPath(me.data, key, value);
      } else {
        me.data[key] = value;
      }
    }
  }
  // skipAccessors argument is used in the engine override
  afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
    for (const store of this.stores) {
      store.onModelChange(this, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    this.forEachLinked(
      (store, record) => store.onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors)
    );
  }
  // Run fn for each store on each linked record
  forEachLinked(fn) {
    for (const linked of this.$links) {
      for (const store of linked.stores) {
        fn(store, linked);
      }
    }
  }
  /**
   * This yields `true` if this record is eligible for syncing with the server.
   * It can yield `false` if the record is in the middle of a {@link #property-isBatchUpdating batched update},
   * or if it is a {@link #property-isCreating tentative record} yet to be confirmed as a new addition.
   * @property {Boolean}
   * @readonly
   */
  get isPersistable() {
    return !this.isBatchUpdating && !this.isCreating;
  }
  /**
   * True if this model has any uncommitted changes.
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isModified() {
    return Boolean(this.meta.modified && Object.keys(this.meta.modified).length > 0);
  }
  get hasPersistableChanges() {
    return this.isPersistable && !ObjectHelper.isEmpty(this.rawModificationData);
  }
  /**
   * Returns true if this model has uncommitted changes for the provided field.
   * @param {String} fieldName Field name
   * @returns {Boolean} True if the field is changed
   * @category Editing
   */
  isFieldModified(fieldName) {
    return this.isModified && fieldName in this.meta.modified;
  }
  /**
   * Returns field value that should be persisted, or `undefined` if field is configured with `persist: false`.
   * @param {String|Core.data.field.DataField} nameOrField Name of the field to get value for, or its field definition
   * @private
   * @category Fields
   */
  getFieldPersistentValue(nameOrField) {
    const field = typeof nameOrField === "string" ? this.getFieldDefinition(nameOrField) : nameOrField, name = (field == null ? void 0 : field.name) || nameOrField;
    let result;
    if (!field || field.persist) {
      result = this.getValue(name);
      if (field == null ? void 0 : field.serialize) {
        result = field.serialize(result, this);
      }
    }
    return result;
  }
  /**
   * Get a map of the modified fields in form of an object. The field *names* are used as the property names
   * in the returned object.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modifications() {
    const data = this.rawModifications;
    if (data && Object.keys(data).length) {
      data[this.constructor.idField] = this.id;
    }
    return data;
  }
  get rawModifications() {
    const me = this, data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach((key) => {
      const value = me.getFieldPersistentValue(key);
      if (value !== _undefined) {
        data[key] = value;
        keySet = true;
      }
    });
    return keySet ? data : null;
  }
  /**
   * Get a map of the modified fields in form of an object. The field´s {@link Core.data.field.DataField#config-dataSource}
   * is used as the property name in the returned object. The record´s id is always included.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modificationData() {
    const data = this.rawModificationData;
    if (data && Object.keys(data).length) {
      ObjectHelper.setPath(data, this.constructor.idField, this.id);
    }
    return data;
  }
  /**
   * Returns a map of the modified persistable fields
   * @internal
   * @property {Object}
   * @category Editing
   */
  get rawModificationData() {
    const me = this, { fieldMap } = me.constructor, data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach((fieldName) => {
      let field = fieldMap[fieldName], dataSource = field == null ? void 0 : field.dataSource;
      if (fieldName.includes(".")) {
        const topLevelFieldName = fieldName.match(nestedRe)[1];
        field = fieldMap[topLevelFieldName];
        dataSource = fieldName;
      }
      if (field == null ? void 0 : field.persist) {
        const value = me.getFieldPersistentValue(fieldName);
        if (value !== _undefined) {
          ObjectHelper.setPath(data, dataSource, value);
          keySet = true;
        }
      }
    });
    return keySet ? data : null;
  }
  /**
   * Get a map of the modified data fields along with any {@link Core/data/field/DataField#config-alwaysWrite} fields,
   * in form of an object. The field´s *dataSource* is used as the property name in the returned object.
   * Used internally by AjaxStore / CrudManager when sending updates.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modificationDataToWrite() {
    const alwaysWriteFields = this.constructor.alwaysWriteFields, recordData = this.modificationData;
    alwaysWriteFields.forEach((fieldName) => {
      recordData[this.getFieldDefinition(fieldName).dataSource] = this.getFieldPersistentValue(fieldName);
    });
    return recordData;
  }
  /**
   * Returns data for **all** {@link Core.data.field.DataField#config-persist persistable} fields in form of an
   * object, using dataSource if present.
   * @property {Object}
   * @internal
   * @readonly
   * @category Editing
   */
  get persistableData() {
    const me = this, data = {};
    me.fields.forEach((field) => {
      const value = me.getFieldPersistentValue(field);
      if (value !== _undefined) {
        if (field == null ? void 0 : field.complexMapping) {
          ObjectHelper.setPath(data, field.dataSource, value);
        } else {
          data[field.dataSource] = value;
        }
      }
    });
    return data;
  }
  get dataByFieldName() {
    const { data } = this;
    return this.fields.reduce((result, field) => {
      if (ObjectHelper.hasPath(data, field.dataSource)) {
        result[field.name] = data[field.dataSource];
      }
      return result;
    }, {});
  }
  /**
   * True if this models changes are currently being committed.
   * @property {Boolean}
   * @category Editing
   */
  get isCommitting() {
    return Boolean(this.meta.committing);
  }
  /**
   * Clear stored changes, used on commit. Does not revert changes.
   * @param {Boolean} [includeDescendants] Supply `false` to not clear node descendants
   * @privateparam {Boolean} [removeFromStoreChanges] Update related stores modified collection or not
   * @privateparam {Object|null} [changes] Set of changes to clear on the record
   * @category Editing
   */
  clearChanges(includeDescendants = true, removeFromStoreChanges = true, changes = null) {
    const me = this, { meta } = me;
    if (changes) {
      for (const key in changes) {
        delete meta.modified[key];
      }
    } else {
      meta.modified = {};
    }
    const noChanges = ObjectHelper.isEmpty(meta.modified);
    meta.committing = false;
    if (removeFromStoreChanges) {
      me.stores.forEach((store) => {
        noChanges && store.modified.remove(me);
        store.added.remove(me);
        if (includeDescendants) {
          const descendants = store.collectDescendants(me).all;
          store.added.remove(descendants);
          noChanges && store.modified.remove(descendants);
        }
      });
    }
  }
  storeFieldChange(key, oldValue) {
    this.meta.modified[key] = oldValue;
  }
  /**
   * Reverts changes in this back to their original values.
   * @privateparam {Boolean} [silent] Specify `true` to not trigger events.
   * @category Editing
   */
  revertChanges(silent = false) {
    this.isReverting = true;
    this.set(this.meta.modified, _undefined, silent);
    this.isReverting = false;
  }
  setByDataSource(rawChanges) {
    var _a2;
    const me = this, {
      fieldDataSourceMap
    } = me.constructor, rawChangesSimplePaths = ObjectHelper.pathifyKeys(rawChanges, fieldDataSourceMap), changes = {};
    for (const dataSource in rawChangesSimplePaths) {
      const field = fieldDataSourceMap[dataSource], propName = (_a2 = field == null ? void 0 : field.name) != null ? _a2 : dataSource;
      changes[propName] = rawChangesSimplePaths[dataSource];
    }
    return me.set(changes);
  }
  applyChangeset(rawChanges, phantomIdField = "$PhantomId", remote = true) {
    var _a2;
    const me = this, modelClass = me.constructor, {
      idField,
      fieldDataSourceMap
    } = modelClass, rawChangesSimplePaths = ObjectHelper.pathifyKeys(rawChanges, fieldDataSourceMap), ownChangesSimplePaths = ObjectHelper.pathifyKeys(me.modificationData), changes = {}, idChanged = phantomIdField in rawChanges && !(idField in rawChanges);
    if (!idChanged && phantomIdField in rawChangesSimplePaths) {
      delete rawChangesSimplePaths[phantomIdField];
    }
    for (const dataSource in rawChangesSimplePaths) {
      const field = fieldDataSourceMap[dataSource], propName = (_a2 = field == null ? void 0 : field.name) != null ? _a2 : dataSource;
      if (remote || ((field == null ? void 0 : field.name) === idField ? idChanged : rawChangesSimplePaths[dataSource] === ownChangesSimplePaths[dataSource])) {
        changes[propName] = rawChangesSimplePaths[dataSource];
      }
    }
    const wasSet = me.set(changes);
    me.clearChanges(false, true, remote ? null : changes);
    return wasSet ? Object.entries(wasSet).reduce((result, [field, change]) => {
      result[field] = change.value;
      return result;
    }, {}) : {};
  }
  //endregion
  //region Id
  /**
   * Gets the records internalId. It is assigned during creation, guaranteed to be globally unique among models.
   * @property {Number}
   * @category Identification
   */
  get internalId() {
    return this._internalId;
  }
  /**
   * Returns true if the record is new and has not been persisted (and received a proper id).
   * @property {Boolean}
   * @readonly
   * @category Identification
   */
  get isPhantom() {
    return this.id === "" || this.id == null || this.hasGeneratedId || Boolean(this.$isPhantom);
  }
  get isModel() {
    return true;
  }
  /**
   * Checks if record has a generated id.
   *
   * New records are assigned a generated id based on a UUID (starting with `_generated`), which is intended to be
   * temporary and should be replaced by the backend on commit.
   *
   * @property {Boolean}
   * @category Identification
   */
  get hasGeneratedId() {
    return typeof this.id === "string" && this.id.startsWith("_generated");
  }
  static generateId(text = this.$$name) {
    return `_generated${text}_${StringHelper.generateUUID()}`;
  }
  /**
   * Generates an id for a new record (a phantom id), based on a UUID (starting with `_generated`).
   *
   * Generated ids are intended to be temporary and should be replaced by the backend on commit.
   *
   * @category Identification
   * @returns {String}
   */
  generateId() {
    return this.constructor.generateId();
  }
  /**
   * Gets the id of specified model or model data object, or the value if passed string/number.
   * @param {Core.data.Model|String|Number} model
   * @returns {String|Number} id
   * @category Identification
   */
  static asId(model) {
    return (model == null ? void 0 : model.isModel) ? model.id : ObjectHelper.isObject(model) ? model[this.fieldMap.id.dataSource] : model;
  }
  //endregion
  //region JSON
  /**
   * Get the records data as a json string.
   *
   * ```javascript
   * const record = new Model({
   *     title    : 'Hello',
   *     children : [
   *         ...
   *     ]
   * });
   *
   * const jsonString = record.json;
   *
   * //jsonString:
   * '{"title":"Hello","children":[...]}'
   * ```
   *
   * @member {String}
   * @category JSON
   */
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  /**
   * Used by `JSON.stringify()` to correctly convert this record to json.
   *
   * In most cases no point in calling it directly.
   *
   * ```
   * // This will call `toJSON()`
   * const json = JSON.stringify(record);
   * ```
   *
   * If called manually, the resulting object is a clone of `record.data` + the data of any children:
   *
   * ```
   * const record = new Model({
   *     title    : 'Hello',
   *     children : [
   *         ...
   *     ]
   * });
   *
   * const jsonObject = record.toJSON();
   *
   * // jsonObject:
   * {
   *     title : 'Hello',
   *     children : [
   *         ...
   *     ]
   * }
   * ```
   *
   * @returns {Object}
   * @category JSON
   */
  toJSON() {
    const { children, unfilteredChildren } = this, jsonData = this.persistableData;
    if (unfilteredChildren || children) {
      jsonData[this.constructor.childrenField] = (unfilteredChildren || children).map((c) => c.toJSON());
    }
    return jsonData;
  }
  /**
   * Represent the record as a string, by default as a JSON string. Tries to use an abbreviated version of the
   * object's data, using id + name/title/text/label/description. If no such field exists, the full data is used.
   *
   * ```javascript
   * const record = new Model({ id : 1, name : 'Steve Rogers', alias : 'Captain America' });
   * console.log(record.toString()); // logs { "id" : 1, "name" : "Steve Rogers" }
   * ```
   *
   * @returns {String}
   * @category JSON
   */
  toString() {
    const me = this, nameField = abbreviationFields.find((field) => field in me.constructor.fieldMap), data = nameField ? { [me.constructor.idField]: me.id, [nameField]: me[nameField] } : me.data;
    return StringHelper.safeJsonStringify(data);
  }
  //endregion
  //region Batch
  /**
   * True if this Model is currently batching its changes.
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isBatchUpdating() {
    return Boolean(this.batching);
  }
  /**
   * Returns `true` if this Model currently has outstanding batched changes for the specified field name.
   * @param {String} fieldName The field name to check for batched updates on.
   * @returns {Boolean}
   * @category Editing
   */
  hasBatchedChange(fieldName) {
    var _a2, _b;
    return (_b = (_a2 = this.meta) == null ? void 0 : _a2.batchChanges) == null ? void 0 : _b[fieldName];
  }
  /**
   * Begin a batch, which stores changes and commits them when the batch ends.
   * Prevents events from being fired during batch.
   *
   * ```javascript
   * record.beginBatch();
   * record.name = 'Mr Smith';
   * record.team = 'Golden Knights';
   * record.endBatch();
   * ```
   *
   * Please note that you can also set multiple fields in a single call using {@link #function-set}, which in many
   * cases can replace using a batch:
   *
   * ```javascript
   * record.set({
   *   name : 'Mr Smith',
   *   team : 'Golden Knights'
   * });
   * ```
   * @category Editing
   * @privateparam {Boolean} silentUpdates Suppress firing the `batchUpdatedEvent`
   */
  beginBatch(silentUpdates = false) {
    const me = this;
    if (!me.batching) {
      me.batching = 0;
      me.meta.batchChanges = {};
    }
    if (silentUpdates) {
      me.$silenceBatch = (me.$silenceBatch || 0) + 1;
    }
    me.batching++;
  }
  /**
   * End a batch, triggering events if data has changed.
   * @param {Boolean} [silent] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [silent=false] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [triggerBeforeUpdate=true]
   * @category Editing
  */
  endBatch(silent = false, skipAccessors = false, triggerBeforeUpdate = true) {
    const me = this, { parentIdField } = me.constructor;
    if (!me.batching) {
      return;
    }
    me.batching--;
    me.$silenceBatch && me.$silenceBatch--;
    if (me.batching > 0) {
      return;
    }
    if (!ObjectHelper.isEmpty(me.meta.batchChanges)) {
      let { batchChanges } = me.meta;
      me.meta.batchChanges = null;
      if (batchChanges[parentIdField]) {
        batchChanges = { ...batchChanges };
        me.parentId = batchChanges[parentIdField];
        delete batchChanges[parentIdField];
      }
      me.set(batchChanges, _undefined, silent, false, skipAccessors, void 0, triggerBeforeUpdate);
    }
  }
  /**
   * Cancels current batch operation. Any changes during the batch are discarded.
   * @category Editing
   */
  cancelBatch() {
    if (this.batching) {
      const me = this, { batchChanges } = me.meta, wasSet = {};
      me.batching = null;
      me.meta.batchChanges = null;
      me.generation++;
      if (!me.$silenceBatch) {
        Object.entries(batchChanges).forEach(([key, oldValue]) => {
          wasSet[key] = {
            oldValue,
            value: me[key]
          };
        });
        const event = {
          action: "update",
          record: me,
          records: [me],
          changes: wasSet
        };
        me.stores.forEach((store) => {
          store.trigger("batchedUpdate", { ...event });
        });
        me.forEachLinked((store, record) => {
          store.trigger("batchedUpdate", { ...event, record, records: [record] });
        });
      }
      me.$silenceBatch && me.$silenceBatch--;
    }
  }
  //endregion
  //region Events
  /**
   * Triggers beforeUpdate event for each store and checks if changes can be made from event return value.
   * @param {Object} changes Data changes
   * @returns {Boolean} returns true if data changes are accepted
   * @private
   */
  triggerBeforeUpdate(changes) {
    var _a2;
    return !((_a2 = this.stores) == null ? void 0 : _a2.some((s) => s.trigger("beforeUpdate", { record: this, changes }) === false));
  }
  //endregion
  //region Additional functionality
  /**
   * Makes a copy of this model, assigning the specified id or a generated id and also allowing you to pass field values to
   * the created copy.
   *
   * ```
   * const record = new Model({ name : 'Super model', hairColor : 'Brown' });
   * const clone = record.copy({ name : 'Super model clone' });
   * ```
   * @param {Number|String|Object} [newId] The id for the copied instance, or any field values to apply
   * (overriding the values from the source record). If no id provided, one will be auto-generated
   * @param {Boolean} [deep] True to also clone children
   * @returns {Core.data.Model} Copy of this model
   * @category Editing
   */
  copy(newId = null, deep) {
    const me = this, data = ObjectHelper.clone(me.data), idField = me.constructor.idField, useDeep = ObjectHelper.isObject(deep) ? deep.deep : deep;
    let id;
    if (newId && typeof newId === "object") {
      id = newId[idField];
      Object.assign(data, newId);
    } else {
      id = newId;
    }
    if (useDeep && me.children) {
      data.children = me.children.map((child) => child.copy(void 0, deep));
    } else {
      delete data.children;
      delete data.expanded;
    }
    if (me.$meta.fields.initable.length > 0) {
      const json = me.toJSON();
      for (const field of me.$meta.fields.initable) {
        data[field.name] = json[field.name];
      }
    }
    if (newId !== false) {
      data[idField] = id || me.generateId(me.firstStore);
    }
    const copy = new me.constructor(data, null, null, false, true);
    copy.originalInternalId = me.internalId;
    return copy;
  }
  // Copies data using the real field names to trigger setters
  copyData(fromRecord, raw, silent) {
    const propertiesAndValues = {};
    fromRecord.allFields.forEach(({ name: fieldName }) => {
      if (fieldName !== fromRecord.constructor.idField) {
        propertiesAndValues[fieldName] = raw ? fromRecord.get(fieldName) : fromRecord.getValue(fieldName);
      }
    });
    this.set(propertiesAndValues, null, silent);
  }
  /**
   * Removes this record from all stores (and in a tree structure, also from its parent if it has one).
   * @param {Boolean} [silent] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @category Editing
   */
  remove(silent = false) {
    const me = this, { parent, stores } = me;
    if (parent) {
      parent.removeChild(me);
    } else if (stores.length && !me.isSpecialRow) {
      const storesCopy = stores.slice();
      storesCopy.forEach((s) => s.remove(me, silent, false, true));
    }
  }
  // Called by stores before removing the record from the store. Returning false prevents the removal (overridden in
  // ModelLink.js)
  beforeRemove(stores, records) {
    return super.beforeRemove(stores, records);
  }
  //endregion
  //region Validation
  /**
   * Check if record has valid data. Default implementation returns true, override in your model to do actual validation.
   * @property {Boolean}
   * @category Editing
   */
  get isValid() {
    return true;
  }
  //endregion
  //region Store
  /**
   * Get the first store that this model is assigned to.
   * @property {Core.data.Store}
   * @readonly
   * @category Misc
   */
  get firstStore() {
    return this.stores.length > 0 && this.stores[0];
  }
  /**
   * Joins this record and any children to specified store, if not already joined.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @category Misc
   */
  joinStore(store) {
    var _a2;
    const me = this, { stores } = me;
    if (!stores.includes(store)) {
      const { unjoinedStores } = me;
      super.joinStore(store);
      store.register(me);
      stores.push(store);
      if (unjoinedStores.includes(store)) {
        unjoinedStores.splice(unjoinedStores.indexOf(store), 1);
      }
      me.isLoaded && me.children.forEach((child) => child.joinStore(store));
      me.initRelations();
      if (store.tree && !me.isRoot && !((_a2 = store.stm) == null ? void 0 : _a2.isRestoring)) {
        me.instanceMeta(store.id).collapsed = !me.expanded;
      }
    }
  }
  /**
   * Unjoins this record and any children from specified store, if already joined.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @param {Boolean} [isReplacing] `true` if this record is being replaced
   * @category Misc
   */
  unjoinStore(store, isReplacing = false) {
    var _a2, _b, _c;
    const me = this, { stores, unjoinedStores } = me;
    if (stores.includes(store)) {
      if (!store.isDestroying) {
        store.unregister(me);
        unjoinedStores.push(store);
      }
      (_b = (_a2 = me.unfilteredChildren || me.children) == null ? void 0 : _a2.forEach) == null ? void 0 : _b.call(_a2, (child) => child.unjoinStore(store, isReplacing));
      stores.splice(stores.indexOf(store), 1);
      (_c = super.unjoinStore) == null ? void 0 : _c.call(this, store, isReplacing);
      store.uncacheRelatedRecord(me);
    }
  }
  /**
   * Returns true if this record is contained in the specified store, or in any store if store param is omitted.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @returns {Boolean}
   * @category Misc
   */
  isPartOfStore(store) {
    if (store) {
      return store.includes(this);
    }
    return this.stores.length > 0;
  }
  /**
   * Returns true if this record is not part of any store.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  get isRemoved() {
    return !this.isPartOfStore();
  }
  //endregion
  //region Per instance meta
  /**
   * Used to set per external instance meta data. For example useful when using a record in multiple grids to store some state
   * per grid.
   * @param {String|Object} instanceOrId External instance id or the instance itself, if it has id property
   * @private
   * @category Misc
   */
  instanceMeta(instanceOrId) {
    var _a2;
    const { meta } = this, id = instanceOrId.id || instanceOrId;
    return ((_a2 = meta.map) == null ? void 0 : _a2[id]) || this.setInstanceMeta(id, {});
  }
  setInstanceMeta(instanceOrId, value) {
    const { meta } = this, id = instanceOrId.id || instanceOrId;
    if (!meta.map) {
      meta.map = {};
    }
    return meta.map[id] = value;
  }
  /**
   * When called on a group header row returns list of records in that group. Returns `undefined` otherwise.
   * @member {Core.data.Model[]|undefined} groupChildren
   * @category Grouping
   * @readonly
   */
  /**
   * Returns true for a group header record
   * @member {Boolean}
   * @category Grouping
   * @readonly
   */
  get isGroupHeader() {
    return "groupRowFor" in this.meta;
  }
  get isGroupFooter() {
    return "groupFooterFor" in this.meta;
  }
  get isSpecialRow() {
    var _a2;
    return Boolean((_a2 = this.meta) == null ? void 0 : _a2.specialRow);
  }
  get $original() {
    return this.isLinked ? this.proxyMeta.originalRecord : this;
  }
  //endregion
  static get nonPersistableFields() {
    const me = this;
    if (!me._nonPersistableFields) {
      me._nonPersistableFields = {};
      me.allFields.forEach((field) => {
        if (!field.persist || field.calculated) {
          me._nonPersistableFields[field.name] = 1;
        }
      });
    }
    return me._nonPersistableFields;
  }
  static get alwaysWriteFields() {
    const me = this;
    if (!me._alwaysWriteFields) {
      me._alwaysWriteFields = [];
      me.allFields.forEach((field) => {
        if (field.alwaysWrite) {
          me._alwaysWriteFields.push(field.name);
        }
      });
    }
    return me._alwaysWriteFields;
  }
  // Id with spaces and dots replaced by -, for safe usage as an id in DOM
  get domId() {
    return typeof this.id === "string" ? this.id.replace(/[ .]/g, "-") : this.id;
  }
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  // Convert custom modelClass to string, keeping custom fields
  static toJavaScriptValue(options) {
    const { names } = this.$meta, className = names[names.length - 2], superName = names[names.length - 3];
    return `class ${className} extends ${superName} { static fields = ${StringHelper.toJavaScriptValue(this.fields, options)}; }`;
  }
  // Get fields current values
  getCurrentConfig(options) {
    const { data, children } = this, { defaultValues, applyConfigs } = this.constructor, result = applyConfigs ? super.getCurrentConfig(options) : {};
    if (result) {
      for (const field of this.fields) {
        if (field.persist) {
          const value = ObjectHelper.getPath(data, field.dataSource);
          if (!field.isEqual(value, defaultValues[field.name])) {
            ObjectHelper.setPath(result, field.dataSource, Base.processConfigValue(value, options));
          }
        }
      }
      if (children) {
        if (Array.isArray(children)) {
          result.children = [];
          for (const child of children) {
            result.children.push(child.getCurrentConfig(options));
          }
        } else {
          result.children = children;
        }
      }
      if (this.hasGeneratedId) {
        delete result.id;
      }
      delete result.parentId;
      delete result.parentIndex;
    }
    return result;
  }
  //endregion
};
/**
 * Override in a subclass of Model to define relations to records in other stores.
 *
 * Always defined on the "one" side, not the "many" side.
 *
 * Expects an object where keys are relation names and values are {@link #typedef-RelationConfig relation configs}.
 *
 * This snippet will define a relation called `team`, allowing access to the foreign record via `player.team`. It
 * will point to a record in the `teamStore` (must be available as `record.firstStore.teamStore)` with an id
 * matching the players `teamId` field. The team record in turn, will have a field called `players` which is a
 * collection of all players in the team.
 *
 * ```javascript
 * class Player extends Model {
 *     static relations = {
 *         // Define a relation between a player and a team
 *         team : {
 *             foreignKey            : 'teamId',
 *             foreignStore          : 'teamStore',
 *             relatedCollectionName : 'players'
 *         }
 *     }
 * }
 *
 * const teamStore = new Store({
 *     data : [
 *         { id : 1, name : 'Brynas' },
 *         { id : 2, name : 'Leksand' }
 *     ]
 * });
 *
 * const playerStore = new Store({
 *     modelClass : Player,
 *     // Matches foreignStore, allowing records of playerStore to find the related store
 *     teamStore,
 *     data       : [
 *         // teamId is specified as foreignKey, will be used to match the team
 *         { id : 1, name : 'Nicklas Backstrom', teamId : 1  },
 *         { id : 2, name : 'Elias Lindholm',   teamId : 1  },
 *         { id : 3, name : 'Filip Forsberg',  teamId : 2  }
 *     ],
 * }
 *
 * playerStore.first.team.name // > Brynas
 * playerStore.last.team.name // > Leksand
 * teamStore.first.players // > [nick, elias]
 * teamStore.last.players // > [filip]
 * ```
 *
 * To access the related record from the many side, use dot notation for the field name. For example in a Grid
 * column:
 *
 * ```javascript
 * const grid = new Grid({
 *    store : playerStore,
 *    columns : [
 *        { field : 'name', text : 'Name' },
 *        { field : 'team.name', text : 'Team' }
 *    ]
 * });
 * ```
 *
 * @member {Object<String,RelationConfig>} relations
 * @static
 */
__publicField(_Model, "relations", null);
var Model = _Model;
Model._idField = "id";
Model._internalIdCounter = 1;
Model._assignedIdField = false;
Model.exposeProperties();
Model._$name = "Model";

// ../Core/lib/Core/data/Duration.js
var Duration = class _Duration {
  /**
   * Duration constructor.
   * @param {Number|String} magnitude Duration magnitude value or a duration + magnitude string ('2h', '4d')
   * @param {String} [unit] Duration unit value
   */
  constructor(magnitude, unit) {
    if (typeof magnitude === "number" || magnitude === null) {
      this._magnitude = magnitude;
      this._unit = unit;
    } else {
      if (typeof magnitude === "string") {
        Object.assign(this, DateHelper.parseDuration(magnitude));
      }
      if (typeof magnitude === "object") {
        Object.assign(this, magnitude);
      }
    }
  }
  /**
   * Get/Set numeric magnitude `value`.
   * @property {Number}
   */
  get magnitude() {
    return this._magnitude;
  }
  set magnitude(value) {
    this._magnitude = typeof value === "number" && value;
  }
  /**
   * Get/Set duration unit to use with the current magnitude value.
   * Valid values are:
   * - "millisecond" - Milliseconds
   * - "second" - Seconds
   * - "minute" - Minutes
   * - "hour" - Hours
   * - "day" - Days
   * - "week" - Weeks
   * - "month" - Months
   * - "quarter" - Quarters
   * - "year"- Years
   *
   * @member {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}
   */
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = DateHelper.parseTimeUnit(value);
  }
  get isValid() {
    return this._magnitude != null && Boolean(DateHelper.normalizeUnit(this._unit));
  }
  /**
   * The `milliseconds` property is a read only property which returns the number of milliseconds in this Duration
   * @property {Number}
   * @readonly
   */
  get milliseconds() {
    return this.isValid ? Math.round(DateHelper.asMilliseconds(this._magnitude, this._unit)) : 0;
  }
  /**
   * Returns truthy value if this Duration equals the passed value.
   * @param {Core.data.Duration} value
   * @returns {Boolean}
   */
  isEqual(value) {
    return Boolean(value) && this._magnitude != null && value._magnitude != null && this.milliseconds === value.milliseconds;
  }
  toString(useAbbreviation) {
    const me = this, abbreviationFn = useAbbreviation ? "getShortNameOfUnit" : "getLocalizedNameOfUnit";
    return me.isValid ? `${me._magnitude} ${DateHelper[abbreviationFn](me._unit, me._magnitude !== 1)}` : "";
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    return this.milliseconds;
  }
  diff(otherDuration) {
    return new _Duration({
      unit: this.unit,
      magnitude: DateHelper.as(this.unit, this.milliseconds - otherDuration.milliseconds)
    });
  }
};
Duration._$name = "Duration";

// ../Core/lib/Core/util/CollectionFilter.js
var nestedValueReducer = (object, path) => object == null ? void 0 : object[path];
var relativeDateUnitRegExp = /^is(this|next|last)(week|month|year)$/i;
var relativeDateOperators = [
  "isToday",
  "isTomorrow",
  "isYesterday",
  "isThisWeek",
  "isNextWeek",
  "isLastWeek",
  "isThisMonth",
  "isNextMonth",
  "isLastMonth",
  "isThisYear",
  "isNextYear",
  "isLastYear",
  "isYearToDate"
];
var _CollectionFilter = class _CollectionFilter extends Base.mixin(Identifiable_default) {
  static get defaultConfig() {
    return {
      /**
       * The value against which to compare the {@link #config-property} of candidate objects.
       * @config {*}
       */
      value: null,
      /**
       * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
       * May be:
       * `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`,
       * `'startsWith'`, `'endsWith'`, `'isIncludedIn'`, `'includes'`, `'doesNotInclude'`,
       * `'empty'`, `'notEmpty'`, `'between'`, `'notBetween'`, `'sameDay'`,
       * `'isToday'`, `'isTomorrow'`, `'isYesterday'`, `'isThisWeek'`, `'isLastWeek'`, `'isNextWeek'`, `'isThisMonth'`,
       * `'isLastMonth'`, `'isNextMonth'`, `'isThisYear'`, `'isLastYear'`, `'isNextYear'`, `'isYearToDate`',
       * `'isTrue'`, `'isFalse'`
       * @config {'='|'!='|'>'|'>='|'<'|'<='|'*'|'startsWith'|'endsWith'|'isIncludedIn'|'isNotIncludedIn'|'includes'|'doesNotInclude'|'empty'|'notEmpty'|'between'|'notBetween'|'sameDay'|'isToday'|'isTomorrow'|'isYesterday'|'isThisWeek'|'isLastWeek'|'isNextWeek'|'isThisMonth'|'isLastMonth'|'isNextMonth'|'isThisYear'|'isLastYear'|'isNextYear'|'isYearToDate'|'isTrue'|'isFalse'}
       */
      operator: null,
      /**
       * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
       * accepts a candidate object and returns `true` or `false`
       * @config {Function}
       * @param {*} data Data object for filtering
       * @returns {Boolean}
       */
      filterBy: null,
      /**
       * A function which accepts a value extracted from a candidate object using the {@link #config-property} name, and
       * returns the value which the filter should use to compare against its {@link #config-value}.
       * @config {Function}
       * @param {*} value
       * @returns {*}
       */
      convert: null,
      /**
       * Configure as `false` to have string comparisons case insensitive.
       * @config {Boolean}
       * @default
       */
      caseSensitive: true,
      /**
       * The `id` of this Filter for when used by a {@link Core.util.Collection} Collection.
       * By default the `id` is the {@link #config-property} value.
       * @config {String}
       */
      id: null,
      // Type is required to process the Date value in State API. Store doesn't always know about field type to
      // process filter value, when it applies it from the state, e.g. when you don't declare model field as `date`
      // type but provide a Date instance there. When DateColumn is used to shows this field, it could add date
      // filters to the store. When store is applying state it cannot just infer type, because model doesn't
      // declare it. Only column knows. So to properly process the Date instance for the filter State API would
      // have to process the field additionally, checking model field type and column type. So it is simpler to
      // make Filter to put this information. That way when filter is instantiated by the store, it can gracefully
      // handle value processing, converting date string to the Date instance.
      // Date is the only known value type so far which requires this processing.
      type: null,
      /**
       * Setting the `internal` config on a filter means that it is a fixed part of your store's operation.
       *
       * {@link Core.data.Store#function-clearFilters} does not remove `internal` filters. If you add an
       * `internal` filter, you must explicitly remove it if it is no longer required.
       *
       * Grid features which offer column-based filtering do *not* ingest existing store filters on
       * their data field if the filter is `internal`
       * @config {Boolean}
       * @default false
       */
      internal: null,
      /**
       * When `true`, the filter will not be applied.
       * @config {Boolean}
       * @default
       */
      disabled: false
    };
  }
  static get configurable() {
    return {
      /**
       * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
       * @member {String} property
       */
      /**
       * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
       * @config {String}
       */
      property: null
    };
  }
  construct(config) {
    if (typeof config === "function") {
      config = {
        filterBy: config
      };
    }
    if (!config.type) {
      if (DateHelper.isDate(config.value) || Array.isArray(config.value) && config.value.every(DateHelper.isDate)) {
        config.type = "date";
      } else if (config.value instanceof Duration) {
        config.type = "duration";
      }
    } else {
      if (config.type === "date" && config.value != null && !Array.isArray(config.value)) {
        config.value = new Date(config.value);
      } else if (config.type === "duration" && config.value != null && !Array.isArray(config.value)) {
        config.value = new Duration(config.value);
      }
    }
    super.construct(config);
  }
  /**
   * When in a Collection (A Collection holds its Filters in a Collection), we need an id.
   * @property {String}
   * @private
   */
  get id() {
    if (!this._id) {
      if (this.internal) {
        this._id = _CollectionFilter.generateId(`b-internal-${this.property}-filter-`);
      } else {
        this._id = this.property || _CollectionFilter.generateId("b-filter-");
      }
    }
    return this._id;
  }
  set id(id) {
    this._id = id;
  }
  onChange(propertyChanged) {
    var _a2;
    const me = this;
    if (!me.isConfiguring && ((_a2 = me.owner) == null ? void 0 : _a2.onFilterChanged) && !me.owner.isConfiguring) {
      me.owner.onFilterChanged(me, propertyChanged);
    }
  }
  get filterBy() {
    return this._filterBy || this.defaultFilterBy;
  }
  /**
   * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
   * accepts a candidate object and returns `true` or `false`
   * @type {Function}
   * @param {*} data Data object for filtering
   * @returns {Boolean} Returns `true` for data valid for including
   */
  set filterBy(filterBy) {
    this._filterBy = filterBy;
  }
  defaultFilterBy(candidate) {
    const me = this;
    let candidateValue;
    if (candidate.isModel) {
      candidateValue = candidate.getValue(me.property);
    } else if (me._propertyItems.length > 1) {
      candidateValue = me._propertyItems.reduce(nestedValueReducer, candidate);
    } else {
      candidateValue = candidate[me.property];
    }
    return me[me.operator](me.convert(candidateValue));
  }
  updateProperty(property) {
    this._propertyItems = property.split(".");
    this.onChange("property");
  }
  /**
   * The value against which to compare the {@link #config-property} of candidate objects.
   * @type {*}
   */
  set value(value) {
    const me = this;
    me._value = value;
    if (Array.isArray(value) && ({ date: 1, duration: 1 }[me.type] || value.length > 0 && typeof value[0] === "string")) {
      me._filterValue = value.map((v) => me.convert(v));
    } else if (!me.caseSensitive && Array.isArray(value) && value.length > 0 && typeof value[0] === "string") {
      me._filterValue = value.map((s) => s == null ? void 0 : s.toLowerCase());
    } else if (!me.caseSensitive && typeof value === "string") {
      me._filterValue = value.toLowerCase();
    } else {
      me._filterValue = me.convert(value);
    }
    me.onChange("value");
  }
  get value() {
    return this._value;
  }
  get filterValue() {
    return this._filterValue;
  }
  /**
   * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
   * May be:
   * `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`,
   * `'startsWith'`, `'endsWith'`, `'isIncludedIn'`, `'includes'`, `'doesNotInclude'`,
   * `'empty'`, `'notEmpty'`, `'between'`, `'notBetween'`,
   * `'isToday'`, `'isTomorrow'`, `'isYesterday'`, `'isThisWeek'`, `'isLastWeek'`, `'isNextWeek'`, `'isThisMonth'`,
   * `'isLastMonth'`, `'isNextMonth'`, `'isThisYear'`, `'isLastYear'`, `'isNextYear'`, `'isYearToDate`',
   * `'isTrue'`, `'isFalse'`
   * @type {'='|'!='|'>'|'>='|'<'|'<='|'*'|'startsWith'|'endsWith'|'isIncludedIn'|'isNotIncludedIn'|'includes'|'doesNotInclude'|'empty'|'notEmpty'|'between'|'notBetween'|'isToday'|'isTomorrow'|'isYesterday'|'isThisWeek'|'isLastWeek'|'isNextWeek'|'isThisMonth'|'isLastMonth'|'isNextMonth'|'isThisYear'|'isLastYear'|'isNextYear'|'isYearToDate'|'isTrue'|'isFalse'}
   */
  set operator(operator) {
    this._operator = operator;
    this.onChange("operator");
  }
  get operator() {
    const me = this;
    if (me._operator) {
      return me._operator;
    }
    if (Array.isArray(me.filterValue)) {
      return "isIncludedIn";
    }
    return typeof me.filterValue === "string" ? "*" : "=";
  }
  convert(value) {
    var _a2;
    if (this.operator !== "sameTime" && !(typeof this.filterValue === "string" && value instanceof Date)) {
      if (this.operator === "sameDay") {
        value = DateHelper.clearTime(value);
      }
      value = (_a2 = value == null ? void 0 : value.valueOf()) != null ? _a2 : value;
    }
    value = !this.caseSensitive && typeof value === "string" ? value.toLowerCase() : value;
    return value;
  }
  filter(candidate) {
    return this.filterBy(candidate);
  }
  startsWith(v) {
    return String(v).startsWith(this.filterValue);
  }
  endsWith(v) {
    return String(v).endsWith(this.filterValue);
  }
  isIncludedIn(v) {
    return this.filterValue.length === 0 || this.filterValue.includes(v);
  }
  isNotIncludedIn(v) {
    return !this.isIncludedIn(v);
  }
  includes(v) {
    return this.filterValue.length === 0 || String(v).includes(this.filterValue);
  }
  doesNotInclude(v) {
    return !this.includes(v);
  }
  sameTime(v) {
    return DateHelper.isSameTime(v, this.filterValue);
  }
  sameDay(v) {
    return v === this.filterValue;
  }
  "="(v) {
    return ObjectHelper.isEqual(v, this.filterValue);
  }
  "!="(v) {
    return !ObjectHelper.isEqual(v, this.filterValue);
  }
  ">"(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue);
  }
  ">="(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  "<"(v) {
    return ObjectHelper.isLessThan(v, this.filterValue);
  }
  "<="(v) {
    return ObjectHelper.isLessThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  "*"(v) {
    return ObjectHelper.isPartial(v, this.filterValue);
  }
  between(v) {
    const [start, end] = this._filterValue;
    return (ObjectHelper.isMoreThan(v, start) || ObjectHelper.isEqual(v, start)) && (ObjectHelper.isLessThan(v, end) || ObjectHelper.isEqual(v, end));
  }
  notBetween(v) {
    return !this.between(v);
  }
  empty(v) {
    return v === void 0 || v === null || String(v).length === 0;
  }
  notEmpty(v) {
    return !this.empty(v);
  }
  isToday(v) {
    return this.between(v);
  }
  isTomorrow(v) {
    return this.between(v);
  }
  isYesterday(v) {
    return this.between(v);
  }
  isThisWeek(v) {
    return this.between(v);
  }
  isNextWeek(v) {
    return this.between(v);
  }
  isLastWeek(v) {
    return this.between(v);
  }
  isThisMonth(v) {
    return this.between(v);
  }
  isNextMonth(v) {
    return this.between(v);
  }
  isLastMonth(v) {
    return this.between(v);
  }
  isThisYear(v) {
    return this.between(v);
  }
  isNextYear(v) {
    return this.between(v);
  }
  isLastYear(v) {
    return this.between(v);
  }
  isYearToDate(v) {
    return this.between(v);
  }
  isTrue(v) {
    return v === true;
  }
  isFalse(v) {
    return v === false;
  }
  // Fill in actual dates relative to now
  setRelativeDateValues() {
    this._filterValue = _CollectionFilter.getRelativeDateRange(this._operator).map((date) => date.valueOf());
  }
  static getRelativeDateRange(relativeExpr, now2 = /* @__PURE__ */ new Date()) {
    let todayStart, tomorrowStart, parts, oneTimeUnit, unitStart, which, timeUnit;
    switch (relativeExpr) {
      case "isYearToDate":
        return [DateHelper.floor(now2, "1 year"), now2];
      case "isToday":
        todayStart = DateHelper.floor(now2, "1 day");
        return [todayStart, DateHelper.add(todayStart, 1, "day")];
      case "isYesterday":
        todayStart = DateHelper.floor(now2, "1 day");
        return [DateHelper.add(todayStart, -1, "day"), todayStart];
      case "isTomorrow":
        tomorrowStart = DateHelper.getStartOfNextDay(now2);
        return [tomorrowStart, DateHelper.add(tomorrowStart, 1, "day")];
      case "isThisWeek":
      case "isNextWeek":
      case "isLastWeek":
      case "isThisMonth":
      case "isNextMonth":
      case "isLastMonth":
      case "isThisYear":
      case "isNextYear":
      case "isLastYear":
        parts = relativeExpr.toLowerCase().match(relativeDateUnitRegExp);
        if (!parts) {
          throw new Error(`Unrecognized relative date expression: ${relativeExpr}`);
        }
        [, which, timeUnit] = parts;
        oneTimeUnit = `1 ${timeUnit}`;
        unitStart = DateHelper.floor(now2, oneTimeUnit);
        if (which === "next") {
          unitStart = DateHelper.add(unitStart, 1, timeUnit);
        } else if (which === "last") {
          unitStart = DateHelper.add(unitStart, -1, timeUnit);
        }
        return [unitStart, DateHelper.add(unitStart, 1, timeUnit)];
    }
  }
  // Accepts an array or a Collection
  static generateFiltersFunction(filters) {
    if (!filters || !filters.length && !filters.count) {
      return FunctionHelper.returnTrue;
    }
    for (const filter of filters) {
      if (filter.type === "date" && relativeDateOperators.includes(filter._operator)) {
        filter.setRelativeDateValues();
      }
    }
    return function(candidate) {
      let match = true;
      for (const filter of filters) {
        if (!filter.disabled) {
          match = filter.filter(candidate);
        }
        if (!match) {
          break;
        }
      }
      return match;
    };
  }
};
__publicField(_CollectionFilter, "$name", "CollectionFilter");
var CollectionFilter = _CollectionFilter;
CollectionFilter._$name = "CollectionFilter";

// ../Core/lib/Core/helper/IdHelper.js
var idCounts2 = ObjectHelper.getPathDefault(globalThis, "bryntum.idCounts", /* @__PURE__ */ Object.create(null));
var IdHelper = class {
  /**
   * Generate a new id, using IdHelpers internal counter and a prefix
   * @param {String} prefix Id prefix
   * @returns {String} Generated id
   */
  static generateId(prefix = "generatedId") {
    return prefix + (idCounts2[prefix] = (idCounts2[prefix] || 0) + 1);
  }
};
IdHelper._$name = "IdHelper";

// ../Core/lib/Core/util/CollectionSorter.js
var CollectionSorter = class extends Base {
  static get defaultConfig() {
    return {
      /**
       * The name of a property of collection objects which yields the value to sort by.
       * @config {String}
       */
      property: null,
      /**
       * The direction to sort in, `'ASC'` or `'DESC'`
       * @config {'ASC'|'DESC'}
       * @default
       */
      direction: "ASC",
      /**
       * A function which takes the place of using {@link #config-property} and {@link #config-direction}.
       * The function is passed two objects from the collection to compare and must return the comparison result.
       * @config {Function}
       * @param {*} first The first value to compare
       * @param {*} second The second value to compare
       * @returns {Number}  Returns `1` if first value is greater than second value, `-1` if the opposite is true or `0` if they're equal
       */
      sortFn: null,
      /**
       * When using {@link #config-property}, this may be specified as a function which takes the raw
       * property value and returns the value to actually sort by.
       * @config {Function}
       * @param {*} value
       * @returns {*}
       */
      convert: null,
      /**
       * The `id` of this Sorter for when used by a {@link Core.util.Collection} Collection.
       * By default the `id` is the {@link #config-property} value.
       * @config {String}
       */
      id: null,
      /**
       * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
       * a locale string or a locale config to enable.
       *
       * Enabling this has big negative impact on sorting performance. For more info on `localeCompare()`, see
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
       *
       * ```javascript
       * collection.addSorter({ field: 'name', useLocaleSort : 'sv-SE' });
       * ```
       *
       * @config {Boolean|String|Object}
       * @default false
       */
      useLocaleSort: null
    };
  }
  construct(config) {
    if (typeof config === "function") {
      config = {
        sortFn: config
      };
    }
    super.construct(config);
  }
  /**
   * When in a Collection (A Collection holds its Sorters in a Collection), we need an id.
   * @property {String}
   * @private
   */
  get id() {
    return this._id || (this._id = this.property || IdHelper.generateId("b-sorter"));
  }
  set id(id) {
    this._id = id;
  }
  set sortFn(sortFn) {
    this._sortFn = sortFn;
  }
  get sortFn() {
    if (this._sortFn) {
      return this._sortFn;
    }
    return this.defaultSortFn;
  }
  /**
   * Default sortFn used when no sortFn specified. Uses the {@link #config-property},
   * {@link #config-direction}, and {@link #config-convert}.
   * @private
  */
  defaultSortFn(lhs, rhs) {
    const me = this, { convert, property, useLocaleSort } = me, multiplier = me.direction.toLowerCase() === "desc" ? -1 : 1;
    lhs = lhs[property];
    rhs = rhs[property];
    if (convert) {
      lhs = convert(lhs);
      rhs = convert(rhs);
    }
    if (useLocaleSort && lhs != null && rhs != null && typeof lhs === "string") {
      if (useLocaleSort === true) {
        return String(lhs).localeCompare(rhs);
      }
      if (typeof useLocaleSort === "string") {
        return String(lhs).localeCompare(rhs, useLocaleSort);
      }
      if (typeof useLocaleSort === "object") {
        return String(lhs).localeCompare(rhs, useLocaleSort.locale, useLocaleSort);
      }
    }
    return (lhs > rhs ? 1 : lhs < rhs ? -1 : 0) * multiplier;
  }
  static generateSortFunction(sorters, tieBreaker) {
    const items = sorters.isCollection ? sorters.values : sorters, n = items.length;
    return (lhs, rhs) => {
      let comp, i;
      for (i = 0; i < n; ++i) {
        comp = items[i].sortFn(lhs, rhs);
        if (comp) {
          return comp;
        }
      }
      return tieBreaker ? tieBreaker(lhs, rhs) : 0;
    };
  }
};
CollectionSorter._$name = "CollectionSorter";

// ../Core/lib/Core/util/Collection.js
var return0 = () => 0;
var reverseNumericSortFn = (a, b) => b - a;
var filteredIndicesProperty = Symbol("filteredIndicesProperty");
var emptyArray3 = Object.freeze([]);
var sortEvent = Object.freeze({
  action: "sort",
  added: emptyArray3,
  removed: emptyArray3,
  replaced: emptyArray3
});
var filterEvent = Object.freeze({
  action: "filter",
  added: emptyArray3,
  removed: emptyArray3,
  replaced: emptyArray3
});
var keyTypes = {
  string: 1,
  number: 1
};
function addItemToIndex(item, index, key, detectDuplicates) {
  if (index.unique !== false) {
    index.set(key, item);
    if (detectDuplicates) {
      index.count++;
    }
  } else {
    let set = index.get(key);
    if (!set) {
      set = /* @__PURE__ */ new Set();
      index.set(key, set);
    }
    set.add(item);
  }
}
function removeItemFromIndex(item, index, key) {
  if (index.unique !== false) {
    index.delete(key);
  } else if (index.has(key)) {
    index.get(key).delete(item);
    if (!index.get(key).size) {
      index.delete(key);
    }
  }
}
function doRebuildIndices(values, indices, keyProps, indexCount, ignoreDetectDuplicates = false) {
  for (let i = 0; i < values.length; i++) {
    const item = values[i];
    for (let j = 0; j < indexCount; j++) {
      const keyProp = keyProps[j], key = item[keyProp], index = indices[keyProp];
      addItemToIndex(item, index, key, !ignoreDetectDuplicates && index.onDuplicate);
    }
  }
}
var Collection = class _Collection extends Base.mixin(Events_default) {
  constructor() {
    super(...arguments);
    __publicField(this, "_sortFunction", null);
    __publicField(this, "_addedValues", null);
  }
  //region Config
  static get configurable() {
    return {
      /**
       * Specify the name of the property of added objects which provides the lookup key
       * @config {String}
       * @default
       */
      idProperty: "id",
      /**
       * Specify the names or index configs of properties which are to be indexed for fast lookup.
       *
       * Index configs use the format `{ property : string, unique : boolean }`. Unique indices stores one index
       * per entry, non-unique stores a `Set`. If left out, `unique` defaults to `true`
       *
       * @config {String[]|Object[]}
       * @property {String} property Property to index by
       * @property {Boolean} [unique=true] `true` for unique keys (~primary keys), `false` for non-unique keys
       * (~foreign keys)
       */
      extraKeys: null,
      /**
       * Automatically apply filters on item add.
       * @config {Boolean}
       * @default
       */
      autoFilter: true,
      /**
       * Automatically apply sorters on item add.
       * @config {Boolean}
       * @default
       */
      autoSort: true,
      /**
       * A {@link Core.util.CollectionSorter Sorter}, or Sorter config object, or
       * an array of these, to use to sort this Collection.
       * @config {CollectionSorterConfig[]}
       * @default
       */
      sorters: {
        $config: ["lazy"],
        value: []
      }
    };
  }
  get isCollection() {
    return true;
  }
  //endregion
  //region Init & destroy
  construct(config) {
    this.generation = 0;
    this._values = [];
    super.construct(config);
  }
  doDestroy() {
    var _a2;
    super.doDestroy();
    const me = this;
    me._values.length = 0;
    if (me.isFiltered) {
      me._filteredValues.length = 0;
      me.filters.destroy();
    }
    (_a2 = me._sorters) == null ? void 0 : _a2.destroy();
  }
  //endregion
  //region "CRUD"
  /**
   * Clears this collection.
   */
  clear() {
    const me = this, removed = me._values.slice();
    if (me.totalCount) {
      me._values.length = 0;
      if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
      me._indicesInvalid = true;
      me.generation++;
      me.trigger("change", {
        action: "clear",
        removed
      });
    }
  }
  /**
   * Compares the content of this Collection with the content of the passed Collection or
   * with the passed array. Order insensitive. This returns `true` if the two objects passed
   * contain the same set of items.
   * @param {Core.util.Collection|Array} other The Collection or array to compare with.
   * @param {Function} [map] Optionally a function to convert the items into a comparable object
   * to compare. For example `item => item.id` could be used to compare the ids of the
   * constituent items.
   * @returns {Boolean} `true` if the two objects passed have the same content.
   */
  equals(other, map) {
    if (other.isCollection) {
      other = other.values;
    }
    if (other.length === this.count) {
      let { values } = this;
      if (map) {
        other = other.map(map);
        values = values.map(map);
      }
      return ArrayHelper.delta(other, values).inBoth.length === this.count;
    }
    return false;
  }
  /**
   * Replaces the internal `values` array with the passed `values`, or `filteredValues` array with the passed `filteredValues`.
   * If `filteredValues` are not passed explicitly, but storage is filtered, decides internally `values` or `filteredValues` should
   * be replaced by passed `values`.
   *
   * Note that this takes ownership of the array, and the array must not be mutated by outside code.
   *
   * This is an internal utility method, not designed for use by application code.
   *
   * @param {Object} params Values and parameters to replace
   * @param {Object[]} params.values The new `values` array
   * @param {Object[]} [params.filteredValues] The new `filteredValues` array. Applicable only when storage is filtered.
   * @param {Boolean} [params.silent=false] If true, `change` event will not be fired
   * @param {Boolean} [params.isNewDataset=false] If true, `values` is a new dataset
   * @fires change
   * @internal
   */
  replaceValues({ values, filteredValues, silent = false, isNewDataset = false }) {
    const me = this;
    let replacedValues, replacedFilteredValues;
    if (me.isFiltered && !isNewDataset) {
      const filteredPassed = Boolean(filteredValues);
      if (!filteredPassed) {
        filteredValues = values.slice();
        values = null;
      } else if (values) {
        replacedValues = me._values;
        me._values = values.slice();
      }
      replacedFilteredValues = me._filteredValues;
      me._filteredValues = filteredValues.slice();
    } else {
      replacedValues = me._values;
      me._values = values.slice();
      filteredValues = null;
      if (me.isFiltered && isNewDataset && me.autoFilter) {
        me._filterFunction = null;
        me._filteredValues = me._values.filter(me.filterFunction);
      } else if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
    }
    me._indicesInvalid = true;
    me._addedValues = void 0;
    me.generation++;
    if (!silent) {
      me.trigger("change", {
        action: "replaceValues",
        replacedValues,
        replacedFilteredValues,
        values,
        filteredValues
      });
    }
  }
  set values(values) {
    this.invalidateIndices();
    this.splice(0, this._values.length, values);
  }
  /**
   * The set of values of this Collection. If this Collection {@link #property-isFiltered},
   * this yields the filtered data set.
   *
   * Setting this property replaces the data set.
   * @property {Object[]}
   */
  get values() {
    return this.isFiltered ? this._filteredValues : this._values;
  }
  /**
   * The set of filtered values of this Collection (those matching the current filters).
   * @property {Object[]}
   * @private
   */
  get filteredValues() {
    return this._filteredValues;
  }
  /**
   * Iterator that allows you to do `for (const item of collection)`
   */
  [Symbol.iterator]() {
    return this.values[Symbol.iterator]();
  }
  /**
   * Executes the passed function for each item in this Collection, passing in the item,
   * ths index, and the full item array.
   * @param {Function} fn The function to execute.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to include all items, bypassing filters.
   */
  forEach(fn, ignoreFilters = false) {
    (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).forEach(fn);
  }
  /**
   * Extracts ths content of this Collection into an array based upon the passed
   * value extraction function.
   * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to process an item even if it is filtered out.
   * @returns {Object[]} An array of values extracted from this Collection.
   */
  map(fn, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).map(fn);
  }
  /**
   * Returns an accumulated value based on the passed function similar to `Array.reduce`.
   * @param {Function} fn A function, which, when passed an accumulator value and an item, returns the new accumulator value.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to process an item even if it is filtered out.
   * @param {*} [accumulator=[]] The initial value of the accumulator.
   * @returns {*} the final accumulator value.
   */
  reduce(fn, ignoreFilters = false, accumulator = []) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).reduce(fn, accumulator);
  }
  /**
   * Returns the first item in this Collection which elicits a *truthy* return value from the passed function.
   * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to include filtered out items.
   * @returns {Object} The matched item, or `undefined`.
   */
  find(fn, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).find(fn);
  }
  get first() {
    return this.values[0];
  }
  get last() {
    return this.values[this.count - 1];
  }
  /**
   * The set of all values of this Collection regardless of filters applied.
   * @readonly
   * @property {Object[]}
   */
  get allValues() {
    return this._values;
  }
  /**
   * The set of values added to this Collection since the last sort or replaceValues operation.
   * @private
   * @readonly
   * @property {Object[]}
   */
  get addedValues() {
    return this._addedValues;
  }
  /**
   * This method ensures that every item in this Collection is replaced by the matched by
   * `id` item in the other Collection.
   *
   * By default, any items in this Collection which are __not__ in the other Collection are removed.
   *
   * If the second parameter is passed as `false`, then items which are not in the other
   * Collection are not removed.
   *
   * This can be used for example when updating a selected record Collection when a new
   * Store or new store dataset arrives. The selected Collection must reference the latest
   * versions of the selected record `id`s
   * @param {Core.util.Collection} other The Collection whose items to match.
   */
  match(other, allowRemove = true) {
    const me = this, { _values } = me, toRemove = [];
    me.forEach((item) => {
      const newInstance = other.get(item.id, true);
      if (newInstance) {
        const index = me.indexOf(item, true), oldInstance = _values[index];
        _values[index] = newInstance;
        me.removeFromIndices(oldInstance);
        me.addToIndices(newInstance);
      } else if (allowRemove) {
        toRemove.push(item);
      }
    });
    if (toRemove.length) {
      me.remove(toRemove);
    }
    if (me.isFiltered) {
      me._filteredValues = me._values.filter(me.filterFunction);
    }
    return toRemove;
  }
  /**
   * Adds items to this Collection. Multiple new items may be passed.
   *
   * By default, new items are appended to the existing values.
   *
   * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
   *
   * Any {@link #property-filters} {@link #property-filters} present are re-run.
   *
   * *Note that if application functionality requires add and remove, the
   * {@link #function-splice} operation is preferred as it performs both
   * operations in an atomic manner*
   * @param  {...Object} items The item(s) to add.
   */
  add(...items) {
    if (items.length === 1) {
      this.splice(this._values.length, null, ...items);
    } else {
      this.splice(this._values.length, null, items);
    }
  }
  /**
   * Removes items from this Collection. Multiple items may be passed.
   *
   * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
   *
   * Any {@link #property-filters} {@link #property-filters} present are re-run.
   *
   * *Note that if application functionality requires add and remove, the
   * {@link #function-splice} operation is preferred as it performs both
   * operations in an atomic manner*
   * @param  {...Object} items The item(s) to remove.
   */
  remove(...items) {
    if (items.length === 1) {
      this.splice(0, ...items);
    } else {
      this.splice(0, items);
    }
  }
  /**
   * Moves an individual item, or a block of items to another location.
   * @param {Object|Object[]} items The item/items to move.
   * @param {Object} [beforeItem] the item to insert the first item before. If omitted, the `item`
   * is moved to the end of the Collection.
   * @returns {Number} The new index of the `item`.
   */
  move(items, beforeItem) {
    items = ArrayHelper.asArray(items);
    while (items.length && items[0] === beforeItem) {
      items.shift();
    }
    if (!items.length) {
      return;
    }
    const me = this, { _values } = me, itemIndex = me.indexOf(items[0], true);
    if (items.length === 1 && _values[itemIndex + 1] === beforeItem) {
      return;
    }
    me.suspendEvents();
    me.remove(items);
    me.resumeEvents();
    const beforeIndex = beforeItem ? me.indexOf(beforeItem, true) : _values.length;
    if (beforeIndex === -1) {
      throw new Error("Collection move beforeItem parameter must be present in Collection");
    }
    _values.splice(beforeIndex, 0, ...items);
    me._indicesInvalid = 1;
    me.trigger("change", {
      action: "move",
      items,
      from: itemIndex,
      to: beforeIndex
    });
    return beforeIndex;
  }
  /**
   * The core data set mutation method. Removes and adds at the same time. Analogous
   * to the `Array` `splice` method.
   *
   * Note that if items that are specified for removal are also in the `toAdd` array,
   * then those items are *not* removed then appended. They remain in the same position
   * relative to all remaining items.
   *
   * @param {Number} index Index at which to remove a block of items. Only valid if the
   * second, `toRemove` argument is a number.
   * @param {Object[]|Number} [toRemove] Either the number of items to remove starting
   * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).
   * @param  {Object[]|Object} [toAdd] An item, or an array of items to add.
   */
  splice(index = 0, toRemove, ...toAdd) {
    const me = this, idProperty = me.idProperty, values = me._values, newIds = {}, removed = [], replaced = [], oldCount = me.totalCount;
    let added, mutated;
    if ((toAdd == null ? void 0 : toAdd.length) === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    if (me.trigger("beforeSplice", { index, toRemove, toAdd }) === false) {
      return;
    }
    if (toAdd) {
      if (oldCount && toAdd.length) {
        const idIndex = me.indices[idProperty];
        added = [];
        for (let i = 0; i < toAdd.length; i++) {
          const newItem = toAdd[i], id = newItem[idProperty], existingItem = idIndex.get(id), existingIndex = existingItem ? values.indexOf(existingItem) : -1;
          newIds[id] = true;
          if (existingIndex !== -1) {
            if (values[existingIndex] !== newItem) {
              replaced.push([values[existingIndex], newItem]);
              values[existingIndex] = newItem;
            }
          } else {
            added.push(newItem);
          }
        }
      } else {
        added = toAdd;
      }
    }
    if (toRemove) {
      if (typeof toRemove === "number") {
        toRemove = Math.min(toRemove, values.length - index);
        for (let removeIndex = index; toRemove; --toRemove) {
          const id = values[removeIndex][idProperty];
          if (newIds[id]) {
            index++;
            removeIndex++;
          } else {
            removed.push(values[removeIndex]);
            values.splice(removeIndex, 1);
            mutated = true;
          }
        }
      } else {
        let contiguous = added.length === 0, lastIdx;
        toRemove = ArrayHelper.asArray(toRemove);
        const removeIndices = toRemove.reduce((result, item) => {
          const isNumeric = typeof item === "number", idx = isNumeric ? item : me.indexOf(item, true);
          if (contiguous && (lastIdx != null && idx !== lastIdx + 1 || isNumeric)) {
            contiguous = false;
          }
          if (idx >= 0 && idx < oldCount) {
            result.push(idx);
          }
          lastIdx = idx;
          return result;
        }, []).sort(reverseNumericSortFn);
        if (contiguous) {
          if (removeIndices.length) {
            removed.push.apply(removed, toRemove);
            values.splice(removeIndices[removeIndices.length - 1], removeIndices.length);
            mutated = true;
          }
        } else {
          for (let i = 0; i < removeIndices.length; i++) {
            const removeIndex = removeIndices[i];
            if (removeIndex !== -1) {
              const id = values[removeIndex][idProperty];
              if (!newIds[id]) {
                removed.unshift(values[removeIndex]);
                values.splice(removeIndex, 1);
                mutated = true;
              }
            }
          }
        }
      }
      if (removed.length && !me._indicesInvalid) {
        removed.forEach(me.removeFromIndices, me);
      }
    }
    if (added.length) {
      values.splice(Math.min(index, values.length), 0, ...added);
      mutated = true;
      if (!me._indicesInvalid) {
        added.forEach(me.addToIndices, me);
      }
      if (!me._addedValues) {
        me._addedValues = /* @__PURE__ */ new Set();
      }
      for (const value of added) {
        me._addedValues.add(value);
      }
    }
    if (removed.length && me._addedValues) {
      for (const value of removed) {
        me._addedValues.delete(value);
      }
    }
    if (replaced.length && !me._indicesInvalid) {
      replaced.forEach((rep) => {
        me.removeFromIndices(rep[0]);
        me.addToIndices(rep[1]);
      });
    }
    if (mutated || replaced.length) {
      if (me.isSorted) {
        me.onSortersChanged();
      } else if (me.isFiltered) {
        if (me.autoFilter) {
          me.onFiltersChanged({ action: "splice", oldCount: 1 });
        } else {
          me._filteredValues.splice(Math.min(index, me._filteredValues.length), 0, ...added);
        }
      }
      me.generation++;
      me.trigger("change", {
        action: "splice",
        removed,
        added,
        replaced,
        oldCount
      });
    } else {
      me.trigger("noChange", {
        index,
        toRemove,
        toAdd
      });
    }
  }
  /**
   * Change the id of an existing member by mutating its {@link #config-idProperty}.
   * @param {String|Number|Object} item The item or id of the item to change.
   * @param {String|Number} newId The id to set in the existing member.
   */
  changeId(item, newId) {
    const me = this, { idProperty } = me, oldId = keyTypes[typeof item] ? item : item[idProperty], member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      me.removeIndexEntry(item, idProperty, oldId);
      me.addIndexEntry(item, idProperty, newId);
      member[idProperty] = newId;
    }
  }
  /**
   * Returns the item with the passed `id`. By default, filtered are honoured, and
   * if the item with the requested `id` is filtered out, nothing will be returned.
   *
   * To return the item even if it has been filtered out, pass the second parameter as `true`.
   * @param {*} id The `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
   * @returns {Object} The found item, or `undefined`.
   */
  get(id, ignoreFilters = false) {
    return this.getBy(this.idProperty, id, ignoreFilters);
  }
  getAt(index, ignoreFilters = false) {
    if (this.isFiltered && !ignoreFilters) {
      return this._filteredValues[index];
    } else {
      return this._values[index];
    }
  }
  /**
   * Returns the item with passed property name equal to the passed value. By default,
   * filtered are honoured, and if the item with the requested `id` is filtered out,
   * nothing will be returned.
   *
   * To return the item even if it has been filtered out, pass the third parameter as `true`.
   * @param {String} propertyName The property to test.
   * @param {*} value The value to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
   * @returns {Object} The found item, or `undefined`.
   */
  getBy(propertyName, value, ignoreFilters = false) {
    return this.findItem(propertyName, value, this.isFiltered && ignoreFilters);
  }
  /**
   * The number of items in this collection. Note that this honours filtering.
   * See {@link #property-totalCount};
   * @property {Number}
   * @readonly
   */
  get count() {
    return this.values.length;
  }
  /**
   * The number of items in this collection regardless of filtering.
   * @property {Number}
   * @readonly
   */
  get totalCount() {
    return this._values.length;
  }
  /**
   * The property name used to extract item `id`s from added objects.
   * @member {String} idProperty
   */
  updateIdProperty(idProperty) {
    this.addIndex({ property: idProperty, unique: true });
  }
  //endregion
  //region Sorting
  /**
   * The Collection of {@link Core.util.CollectionSorter Sorters} for this Collection.
   * @member {Core.util.Collection} sorters
   */
  changeSorters(sorters) {
    return new _Collection({
      values: ArrayHelper.asArray(sorters),
      internalListeners: {
        change: "onSortersChanged",
        thisObj: this
      }
    });
  }
  /**
   * Adds a Sorter to the Collection of Sorters which are operating on this Collection.
   *
   * A Sorter may be specified as an instantiated {@link Core.util.CollectionSorter}, or a config object for a
   * CollectionSorter of the form
   *
   *     {
   *         property  : 'age',
   *         direction : 'desc'
   *     }
   *
   * Note that by default, a Sorter *replaces* a Sorter with the same `property` to make
   * it easy to change existing Sorters. A Sorter's `id` is its `property` by default. You
   * can avoid this and add multiple Sorters for one property by configuring Sorters with `id`s.
   *
   * A Sorter may also be specified as a function which compares two objects eg:
   *
   *     (lhs, rhs) => lhs.customerDetails.age - rhs.customerDetails.age
   *
   * @param {CollectionSorterConfig} sorter A Sorter configuration object to add to the Collection
   * of Sorters operating on this Collection.
   * @returns {Core.util.CollectionSorter} The resulting Sorter to make it easy to remove Sorters.
   */
  addSorter(sorter) {
    const result = sorter instanceof CollectionSorter ? sorter : new CollectionSorter(sorter);
    this.sorters.add(result);
    return result;
  }
  /**
   * A flag which is `true` if this Collection has active {@link #property-sorters}.
   * @property {Boolean}
   * @readonly
   */
  get isSorted() {
    var _a2;
    return Boolean((_a2 = this._sorters) == null ? void 0 : _a2.count);
  }
  onSortersChanged() {
    const me = this;
    me._sortFunction = null;
    me._addedValues = null;
    me._values.sort(me.sortFunction);
    me.trigger("change", sortEvent);
  }
  /**
   * A sorter function which encapsulates the {@link Core.util.CollectionSorter Sorters} for this Collection.
   * @property {Function}
   * @param {*} first First value to compare
   * @param {*} second Second value to compare
   * @returns {Number} Returns `1` if first value is a greater unit than second value, `-1` if the opposite is true or `0` if they're equal
   * @readonly
   */
  get sortFunction() {
    if (!this._sortFunction) {
      if (this.isSorted) {
        this._sortFunction = CollectionSorter.generateSortFunction(this.sorters.values);
      } else {
        this._sortFunction = return0;
      }
    }
    return this._sortFunction;
  }
  //endregion
  //region Filtering
  /**
   * The Collection of {@link Core.util.CollectionFilter Filters} for this Collection.
   * @property {Core.util.Collection}
   * @readonly
   */
  get filters() {
    if (!this._filters) {
      this._filters = new _Collection({
        internalListeners: {
          change: "onFiltersChanged",
          thisObj: this
        }
      });
    }
    return this._filters;
  }
  /**
   * Adds a Filter to the Collection of Filters which are operating on this Collection.
   *
   * A Filter may be an specified as an instantiated {@link Core.util.CollectionFilter
   * CollectionFilter}, or a config object for a CollectionFilter of the form
   *
   *     {
   *         property : 'age',
   *         operator : '>=',
   *         value    : 21
   *     }
   *
   * Note that by default, a Filter *replaces* a Filter with the same `property` to make
   * it easy to change existing Filters. A Filter's `id` is its `property` by default. You
   * can avoid this and add multiple Filters for one property by configuring Filters with `id`s.
   *
   * A Filter may also be specified as a function which filters candidate objects eg:
   *
   *     candidate => candidate.customerDetails.age >= 21
   *
   * @param {CollectionFilterConfig|Core.util.CollectionFilter} filter A Filter or Filter configuration object to add
   * to the Collection of Filters operating on this Collection.
   * @returns {Core.util.CollectionFilter} The resulting Filter to make it easy to remove Filters.
   */
  addFilter(filter) {
    const result = filter instanceof CollectionFilter ? filter : new CollectionFilter(filter);
    this.filters.add(result);
    return result;
  }
  removeFilter(filter) {
    const { filters } = this;
    if (!filter.isCollectionFilter) {
      filter = filters.get(filter);
    }
    filters.remove(filter);
  }
  clearFilters() {
    this.filters.clear();
  }
  /**
   * A flag which is `true` if this Collection has active {@link #property-filters}.
   * @property {Boolean}
   * @readonly
   */
  get isFiltered() {
    return Boolean(this._filters && this._filters.count);
  }
  onFiltersChanged({ action, removed: gone, oldCount }) {
    const me = this, oldDataset = oldCount || action === "clear" && gone.length ? me._filteredValues : me._values;
    me._filterFunction = null;
    me._filteredValues = me._values.filter(me.filterFunction);
    me._indicesInvalid = true;
    const {
      toAdd: added,
      toRemove: removed
    } = ArrayHelper.delta(me._filteredValues, oldDataset, true);
    me.trigger("change", { ...filterEvent, added, removed });
  }
  /**
   * A filter function which encapsulates the {@link Core.util.CollectionFilter Filters}
   * for this Collection.
   * @property {Function}
   * @param {*} value Value to compare
   * @returns {Boolean} Returns `true` for value valid for including
   * @readonly
   */
  get filterFunction() {
    if (!this._filterFunction) {
      if (this.isFiltered) {
        this._filterFunction = CollectionFilter.generateFiltersFunction(this.filters.values);
      } else {
        this._filterFunction = FunctionHelper.returnTrue;
      }
    }
    return this._filterFunction;
  }
  //endregion
  //region Indexing
  changeExtraKeys(extraKeys) {
    const keys = ArrayHelper.asArray(extraKeys);
    return keys.map((config) => {
      if (typeof config === "string") {
        return { property: config, unique: true };
      }
      return config;
    });
  }
  updateExtraKeys(extraKeys) {
    for (let i = 0; i < extraKeys.length; i++) {
      this.addIndex(extraKeys[i]);
    }
  }
  /**
   * Adds a lookup index for the passed property name or index config. The index is built lazily when an index is
   * searched
   * @internal
   * @param {Object} indexConfig An index config
   * @param {String} indexConfig.property The property name to add an index for
   * @param {Boolean} [indexConfig.unique] Specify `false` to allow multiple entries of the same index, turning
   *   entries into sets
   * @param {Object} [indexConfig.dependentOn] The properties that make the key
   */
  addIndex(indexConfig) {
    const me = this;
    if (indexConfig) {
      (me._indices || (me._indices = {}))[indexConfig.property] = /* @__PURE__ */ new Map();
      Object.assign(me._indices[indexConfig.property], indexConfig);
      me.invalidateIndices();
      if (indexConfig.dependentOn) {
        me.hasCompositeIndex = true;
      }
    }
  }
  /**
   * Return the index of the item with the specified key having the specified value.
   *
   * By default, filtering is taken into account and this returns the index in the filtered dataset if present. To
   * bypass this, pass the third parameter as `true`.
   *
   * Only useful for indices configured with `unique: true`.
   *
   * @param {String} propertyName The name of the property to test.
   * @param {*} value The value to test for.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in
   * the original data set if the item is filtered out.
   * @returns {Number} The index of the item or `-1` if not found for unique indices
   */
  findIndex(propertyName, value, ignoreFilters = false) {
    const item = this.findItem(propertyName, value, ignoreFilters);
    if (!item) {
      return -1;
    }
    const values = this.isFiltered && !ignoreFilters ? this._filteredValues : this._values;
    return values.indexOf(item);
  }
  /**
   * Return the item with the specified key having the specified value.
   *
   * By default, filtering is taken into account. To bypass this, pass the third parameter as `true`.
   *
   * For indices configured with `unique: false`, a Set of items will be returned.
   *
   * @param {String} propertyName The name of the property to test.
   * @param {*} value The value to test for.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in
   * the original data set if the item is filtered out.
   * @returns {Object|Set} The found item or Set of items or null
   */
  findItem(propertyName, value, ignoreFilters = false) {
    var _a2;
    const me = this, { isFiltered } = me, index = isFiltered && !ignoreFilters ? me.indices[filteredIndicesProperty][propertyName] : me.indices[propertyName];
    if (index) {
      const item = (_a2 = index.get(value)) != null ? _a2 : typeof value === "string" && value.length && !isNaN(value) && index.get(Number(value)) || null;
      if (item != null) {
        return item;
      }
    } else {
      const values = isFiltered && !ignoreFilters ? me._filteredValues : me._values, count = values.length;
      for (let i = 0; i < count; i++) {
        const item = values[i];
        if (item[propertyName] == value) {
          return item;
        }
      }
    }
    return null;
  }
  removeIndex(propertyName) {
    delete this._indices[propertyName];
    this.hasCompositeIndex = Object.values(this.indices).some((index) => index.dependentOn);
  }
  /**
   * Returns the index of the item with the same `id` as the passed item.
   *
   * By default, filtering is honoured, so if the item in question has been added, but is currently filtered out of
   * visibility, `-1` will be returned.
   *
   * To find the index in the master, unfiltered dataset, pass the second parameter as `true`;
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
   * @returns {Number} The index of the item, or `-1` if not found.
   */
  indexOf(item, ignoreFilters = false) {
    return this.findIndex(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters);
  }
  /**
   * Returns `true` if this Collection includes an item with the same `id` as the passed item.
   *
   * By default, filtering is honoured, so if the item in question has been added,
   * but is currently filtered out of visibility, `false` will be returned.
   *
   * To query inclusion in the master, unfiltered dataset, pass the second parameter as `true`;
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
   * @returns {Boolean} True if the passed item is found.
   */
  includes(item, ignoreFilters = false) {
    if (Array.isArray(item)) {
      return item.some((item2) => this.includes(item2));
    }
    return Boolean(this.findItem(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters));
  }
  get indices() {
    if (this._indicesInvalid) {
      this.rebuildIndices();
    }
    return this._indices;
  }
  invalidateIndices() {
    this._indicesInvalid = true;
  }
  /**
   * Called when the Collection is mutated and the indices have been flagged as invalid.
   *
   * Rebuilds the indices object to allow lookup by keys.
   * @internal
   */
  rebuildIndices() {
    const me = this, isFiltered = me.isFiltered, indices = me._indices || (me._indices = {}), keyProps = Object.keys(indices), indexCount = keyProps.length, values = me._values;
    let detectDuplicates = false, filteredIndices;
    if (isFiltered) {
      filteredIndices = indices[filteredIndicesProperty] = {};
    }
    for (let i = 0; i < indexCount; i++) {
      const index = indices[keyProps[i]];
      index.clear();
      if (index.onDuplicate) {
        index.count = 0;
        detectDuplicates = true;
      }
      if (isFiltered) {
        let filteredIndex = filteredIndices[keyProps[i]];
        if (filteredIndex) {
          filteredIndex.clear();
        } else {
          filteredIndex = filteredIndices[keyProps[i]] = /* @__PURE__ */ new Map();
          filteredIndex.unique = index.unique;
        }
      }
    }
    doRebuildIndices(values, indices, keyProps, indexCount);
    if (detectDuplicates) {
      for (let i = 0; i < indexCount; i++) {
        const index = indices[keyProps[i]];
        if (index.onDuplicate && index.count > index.size) {
          const checked = /* @__PURE__ */ new Set();
          for (let j = 0; j < values.length; j++) {
            const item = values[j], key = item[keyProps[i]];
            if (checked.has(key)) {
              index.onDuplicate(item, key, index);
            }
            checked.add(key);
          }
        }
      }
    }
    if (isFiltered) {
      doRebuildIndices(me._filteredValues, filteredIndices, keyProps, indexCount, true);
    }
    me._indicesInvalid = false;
  }
  // Returns an array with [indices] or [indices, filteredIndices] if filtering is used
  getIndices(propertyName) {
    const indices = [this.indices[propertyName]];
    if (this.isFiltered) {
      indices.push(this.indices[filteredIndicesProperty][propertyName]);
    }
    return indices;
  }
  /**
   * Add an item to all indices
   * @param {*} item Item already available in the Collection
   * @private
   */
  addToIndices(item) {
    Object.keys(this.indices).forEach((propertyName) => {
      this.addIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  /**
   * Remove an item from all indices
   * @param {*} item Item already available in the Collection
   * @private
   */
  removeFromIndices(item) {
    Object.keys(this.indices).forEach((propertyName) => {
      this.removeIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  /**
   * Remove an entry from an index, and if filtering is used also from the filtered index.
   * @param {*} item Item already available in the Collection
   * @param {String} propertyName Property of the item, will be matched with configured indices
   * @param {*} oldValue Value to remove
   * @private
   */
  removeIndexEntry(item, propertyName, oldValue) {
    this.getIndices(propertyName).forEach((index) => removeItemFromIndex(item, index, oldValue));
  }
  /**
   * Add a new entry to an index, and if filtering is used also to the filtered index.
   * @param {*} item Item already available in the Collection
   * @param {String} propertyName Property of the item, will be matched with configured indices
   * @param {*} value Value to store
   * @private
   */
  addIndexEntry(item, propertyName, value) {
    this.getIndices(propertyName).forEach((index) => addItemToIndex(item, index, value));
  }
  /**
   * Call externally to update indices on item mutation (from Store)
   * @param {*} item Item already available in the Collection
   * @param {Object} wasSet Uses the `wasSet` format from Store, `{ field : { oldValue, newValue } }`
   * @internal
   */
  onItemMutation(item, wasSet) {
    const me = this;
    if (!me._indicesInvalid && Object.keys(me.indices).length > 1) {
      Object.keys(wasSet).forEach((propertyName) => {
        var _a2;
        const indexConfig = me.indices[propertyName];
        if (indexConfig) {
          const { value, oldValue } = wasSet[propertyName];
          me.removeIndexEntry(item, propertyName, oldValue);
          me.addIndexEntry(item, propertyName, value);
        }
        if (me.hasCompositeIndex) {
          const dependentIndex = Object.values(me.indices).find((index) => {
            var _a3;
            return (_a3 = index.dependentOn) == null ? void 0 : _a3[propertyName];
          });
          if (dependentIndex) {
            const keysAndOldValues = {};
            for (const o in dependentIndex.dependentOn) {
              keysAndOldValues[o] = ((_a2 = wasSet[o]) == null ? void 0 : _a2.oldValue) || item[o];
            }
            const oldIndex = item.buildIndexKey(keysAndOldValues);
            me.removeIndexEntry(item, dependentIndex.property, oldIndex);
            me.addIndexEntry(item, dependentIndex.property, item[dependentIndex.property]);
          }
        }
      });
    }
  }
  //endregion
};
Collection._$name = "Collection";

// ../Core/lib/Core/util/Bag.js
var nonPrimitives = /* @__PURE__ */ new WeakMap();
var safeIndexKey = (value) => {
  if (value && typeof value === "object") {
    let substitute = nonPrimitives.get(value);
    if (substitute === void 0) {
      substitute = Symbol("bscik");
      nonPrimitives.set(value, substitute);
    }
    value = substitute;
  }
  return value;
};
var Bag = class {
  constructor(config) {
    const me = this;
    me.generation = 0;
    me.items = /* @__PURE__ */ new Set();
    me.idMap = {};
    me.idProperty = "id";
    if (config) {
      if (config.idProperty) {
        me.idProperty = config.idProperty;
      }
      if (config.values) {
        me.values = config.values;
      }
    }
  }
  /**
   * Returns the item with the passed `id`.
   *
   * @param {*} id The `id` to find.
   * @returns {Object} The found item, or `undefined`.
   */
  get(key) {
    return this.idMap[safeIndexKey(key)];
  }
  /**
   * The number of items in this Bag.
   * @property {Number}
   * @readonly
   */
  get count() {
    return this.items.size;
  }
  /**
   * Adds the passed item(s) to this Bag. Existing items with the same ID
   * will be replaced.
   * @param {Object|Object[]} toAdd Item(s) to add.
   */
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    const me = this, {
      items,
      idMap,
      idProperty
    } = me, len = toAdd.length;
    for (let i = 0; i < len; i++) {
      const item = toAdd[i], key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), existingItem = idMap[key];
      if (existingItem == null) {
        idMap[key] = item;
        items.add(item);
        me.generation++;
      } else if (existingItem !== item) {
        idMap[key] = item;
        items.delete(existingItem);
        items.add(item);
      }
    }
  }
  /**
   * Returns `nth` item in this Bag.
   * @param {Number} nth The index of the matching item. Negative numbers index for the last item. For example, -1
   * returns the last item, -2 the 2nd to last item etc.
   * @returns {Object} The matched item, or `undefined`.
   */
  at(nth) {
    let item, ret;
    if (nth < 0) {
      nth += this.count;
    }
    for (item of this.items) {
      if (!nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  /**
   * Removes the passed item(s) from this Bag.
   * @param {Object|Object[]} toRemove Item(s) to remove.
   */
  remove(toRemove) {
    toRemove = ArrayHelper.asArray(toRemove);
    const { items, idMap, idProperty } = this, len = toRemove.length;
    for (let i = 0; i < len; i++) {
      const item = toRemove[i], key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), existingItem = idMap[key];
      if (existingItem != null) {
        items.delete(existingItem);
        delete idMap[key];
        this.generation++;
      }
    }
  }
  clear() {
    this.items.clear();
    this.idMap = {};
    this.generation++;
  }
  /**
   * Returns the number of items in this Bag which elicits a truthy return value from the passed function.
   * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
   * @returns {Number} The number of matched items.
   */
  countOf(fn) {
    let ret = 0, item;
    for (item of this.items) {
      if (fn(item)) {
        ++ret;
      }
    }
    return ret;
  }
  /**
   * Change the id of an existing member by mutating its idProperty.
   * @param {String|Number|Object} item The item or id of the item to change.
   * @param {String|Number} newId The id to set in the existing member.
   */
  changeId(item, newId) {
    const me = this, { idMap, idProperty } = me, oldId = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      member[idProperty] = newId;
      delete idMap[oldId];
      idMap[newId] = member;
    }
  }
  /**
   * Extracts the matching items from this Bag into an array based upon the passed value filter function.
   * @param {Function} fn A function, which, when passed an item, returns a `true` to place into the resulting array.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   * @returns {Object[]} An array of values extracted from this Bag.
   */
  filter(fn, thisObj) {
    const { items } = this, result = [];
    let i = 0;
    items.forEach((item) => {
      if (fn.call(thisObj, item, i++, items)) {
        result.push(item);
      }
    });
    return result;
  }
  /**
   * Returns `true` if this Collection includes an item with the same `id` as the passed item.
   *
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @returns {Boolean} True if the passed item is found.
   */
  includes(item) {
    const key = keyTypes[typeof item] ? item : safeIndexKey(item[this.idProperty]);
    return Boolean(this.idMap[key]);
  }
  /**
   * Extracts the content of this Bag into an array based upon the passed
   * value extraction function.
   * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   * @returns {Object[]} An array of values extracted from this Bag.
   */
  map(fn, thisObj) {
    const { items } = this, result = new Array(items.size);
    let i = 0;
    items.forEach((item) => {
      result[i] = fn.call(thisObj, item, i++, items);
    });
    return result;
  }
  /**
   * Executes the passed function for each item in this Bag, passing in the item.
   * @param {Function} fn The function to execute.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   */
  forEach(fn, thisObj) {
    return this.items.forEach(fn, thisObj);
  }
  /**
   * Returns `nth` item in this Bag which elicits a truthy return value from the provided matcher function `fn`.
   * @param {Function} fn A function which, when passed an item, returns `true` to select the item as a match.
   * @param {Number} [nth=0] The index of the matching item. By default, 0 returns the first item that matches
   * according to `fn`. Negative numbers index for the last item. For example, -1 returns the last matching item,
   * -2 the 2nd to last matching item etc..
   * @returns {Object} The matched item, or `undefined`.
   */
  find(fn, nth = 0) {
    let item, ret;
    if (nth < 0) {
      nth += this.countOf(fn);
    }
    for (item of this.items) {
      if (fn(item) && !nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  /**
   * Iterator that allows you to do for (let item of bag)
   */
  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }
  indexOf(item, matchFn) {
    let index = -1, it;
    for (it of this.items) {
      if (!matchFn || matchFn(it)) {
        ++index;
        if (it === item) {
          return index;
        }
      }
    }
    return -1;
  }
  /**
   * The set of values of this Bag.
   *
   * Setting this property replaces the data set.
   * @property {Object[]}
   */
  get values() {
    return [...this.items];
  }
  set values(values) {
    values = ArrayHelper.asArray(values);
    this.clear();
    this.add.apply(this, values);
    this.generation++;
  }
  /**
   * Sort the values of this Bag using the passed comparison function.
   *
   * Setting this property replaces the data set.
   * @param {Function} fn Comparison function which returns -ve, 0, or +ve
   */
  sort(fn) {
    this.values = this.values.sort(fn);
  }
  some(fn, thisObj) {
    return this.values.some(fn, thisObj);
  }
};
Bag._$name = "Bag";

// ../Core/lib/Core/data/mixin/StoreCRUD.js
var StoreCRUD_default = (Target) => class StoreCRUD extends (Target || Base) {
  static get $name() {
    return "StoreCRUD";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Commit changes automatically
       * @config {Boolean}
       * @default
       * @category Common
       */
      autoCommit: false
    };
  }
  static get properties() {
    return {
      isRemoving: false,
      suspendCount: 0
    };
  }
  //endregion
  //region Events
  /**
   * Fired after removing all records
   * @event removeAll
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired before committing changes. Return false from handler to abort commit
   * @event beforeCommit
   * @param {Core.data.Store} source This Store
   * @param {Object} changes Modification data
   */
  /**
   * Fired after committing changes
   * @event commit
   * @param {Core.data.Store} source This Store
   * @param {Object} changes Modification data
   */
  /**
   * Fired before records are removed from this store by the {@link #function-remove} or {@link #function-removeAll}.
   * Also fired when removing a child record in a tree store using {@link Core.data.mixin.TreeNode#function-removeChild}.
   * The remove may be vetoed by returning `false` from a handler.
   * @event beforeRemove
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records The records which are to be removed.
   * @param {Core.data.Model} parent The record from which children are being removed when using a tree store. Only
   * provided when removing a single node.
   * @param {Boolean} isMove This flag is `true` if the child node is being removed by
   * {@link Core.data.mixin.TreeNode#function-appendChild appendChild} to be moved
   * _within the same tree_.
   * @param {Boolean} removingAll This flag is `true` if the operation is removing the store's entire data set.
   * @preventable
   */
  /**
   * Fired before records are added to this store by the {@link #function-add} or {@link #function-insert}. In a tree
   * store, also fired by {@link Core.data.mixin.TreeNode#function-appendChild} and
   * {@link Core.data.mixin.TreeNode#function-insertChild}. The add or insert may be vetoed by returning `false`
   * from a handler.
   * @event beforeAdd
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records The records which are to be added
   * @param {Core.data.Model} parent The parent node when using a tree store
   * @preventable
   */
  /**
   * Fired after adding/inserting record(s). If the record was added to a parent, the `isChild` flag is set on the
   * event. If it was inserted, event contains `index`
   * @event add
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records Added records. In case of tree store, if branch is added, only branch root
   * is returned
   * @param {Core.data.Model[]} [allRecords] Flat list of all added records. In case of tree store, if branch is
   * added, all new records are returned, not only branch root
   * @param {Core.data.Model} [parent] If due to an {@link Core/data/mixin/TreeNode#function-appendChild}
   * call, this is the parent node added to.
   * @param {Number} [index] Insertion point in the store's {@link Core.data.Store#config-storage Collection}.
   * @param {Number} [oldIndex] Not used for tree stores. The index of the first record moved.
   * @param {Boolean} [isChild] Flag which is set to true if the records are added to a parent record
   * @param {Boolean} [isExpand] Flag which is set to true if records are added to the store by expanding parent
   * @param {Object} [isMove] An object keyed by the ids of the records which were moved from another
   * position in the store, or from another parent node in the store. The ids of moved records will be
   * property names with a value `true`.
   */
  /**
   * Fired when one or more records are removed
   * @event remove
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records Array of removed records. In case of tree store, if branch is removed, only branch root
   * is returned
   * @param {Core.data.Model[]} [allRecords] Flat array of all removed records. In case of tree store, if branch is
   * removed, all removed records are returned, not only branch root
   * @param {Core.data.Model} [parent] If due to a {@link Core.data.mixin.TreeNode#function-removeChild removeChild}
   * call, this is the parent node removed from. Only applicable when removing a single tree node.
   * @param {Number} [index] Visible index at which record was removed. In case the record was removed from a collapsed
   * branch, -1 is returned. For tree store, this is only provided when removing a single node.
   * @param {Boolean} [isChild] Flag which is set to true if the record was removed from a parent record
   * @param {Boolean} [isCollapse] Flag which is set to true if records were removed from the store by collapsing parent
   * @param {Boolean} [isMove] Passed as `true` if the remove was part of a move operation within this Store.
   */
  //endregion
  //region Add, insert & remove
  /**
   * Removes a record from this store. Fires a single {@link #event-remove} event passing the removed records.
   * @param {String|String[]|Number|Number[]|Core.data.Model|Core.data.Model[]} records Record/array of records (or record ids) to remove
   * @param {Boolean} [silent] Specify `true` to suppress events/autoCommit
   * @returns {Core.data.Model[]} Removed records
   * @fires beforeRemove
   * @fires remove
   * @fires change
   * @category CRUD
   */
  remove(records, silent = false) {
    const me = this, { storage } = me;
    records = ArrayHelper.asArray(records).reduce((result, r) => {
      r = me.getById(r);
      if (r) {
        result.push(r);
      }
      return result;
    }, []);
    if (records.length === 0) {
      return records;
    }
    if (!me.tree && !silent && me.trigger("beforeRemove", { records }) === false) {
      return [];
    }
    me.isRemoving = true;
    if (me.isGrouped) {
      const oldCount = storage.count, recordsInCollapsedGroups = [], changedGroupParents = /* @__PURE__ */ new Set();
      for (const rec of records) {
        const groupParent = rec.groupParent.get(me.id);
        if (groupParent.meta.collapsed) {
          recordsInCollapsedGroups.push(rec);
        }
        ArrayHelper.remove(groupParent.groupChildren, rec);
        ArrayHelper.remove(groupParent.unfilteredGroupChildren, rec);
        groupParent.meta.childCount--;
        changedGroupParents.add(groupParent);
      }
      for (const groupParent of changedGroupParents) {
        if (groupParent.groupChildren.length > 0) {
          me.onModelChange(groupParent, {}, {});
        }
      }
      if (recordsInCollapsedGroups.length) {
        storage.trigger("change", {
          action: "splice",
          removed: recordsInCollapsedGroups,
          added: [],
          replaced: [],
          oldCount
        });
      }
    } else if (me.tree) {
      const allRemovedRecords = [], removingMultiple = records.length > 1, firstRemoved = records[0], index = removingMultiple ? void 0 : storage.indexOf(firstRemoved), removeChildArgs = records.reduce((result, child) => {
        const { parent } = child;
        if (parent) {
          if (!result[parent.id]) {
            result[parent.id] = [parent, []];
          }
          result[parent.id][1].push(child);
        }
        return result;
      }, {}), removals = Array.from(Object.values(removeChildArgs));
      if (!silent && me.trigger("beforeRemove", { records, isMove: false, parent: removingMultiple ? void 0 : firstRemoved.parent }) === false) {
        me.isRemoving = false;
        return [];
      }
      me.suspendAutoCommit();
      removals.sort((a, b) => b[0].childLevel - a[0].childLevel);
      for (const [parent, children] of removals) {
        allRemovedRecords.push(...parent.removeChild(children, false, true));
      }
      if (!silent) {
        me.trigger("remove", {
          // parent is only relevant when removing single node
          parent: removingMultiple ? void 0 : firstRemoved.parent,
          index,
          isChild: true,
          allRecords: allRemovedRecords,
          isMove: false,
          records
        });
        me.trigger("change", {
          action: "remove",
          records
        });
      }
      me.resumeAutoCommit();
      me.isRemoving = false;
      return records;
    }
    if (records.length === 0) {
      me.isRemoving = false;
      return records;
    }
    for (const record of records) {
      record.beforeRemove(records);
    }
    if (silent) {
      me.suspendEvents();
    }
    storage.remove(records);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    me.isRemoving = false;
    return records;
  }
  /**
   * Clears store data. Used by removeAll, separate function for using with chained stores.
   * @private
   * @category CRUD
   */
  clear(isLoading = false) {
    var _a2, _b;
    const me = this, { storage } = me;
    if (me.storage.totalCount || ((_b = (_a2 = me.rootNode) == null ? void 0 : _a2.unfilteredChildren) == null ? void 0 : _b.length)) {
      if (!isLoading && me.trigger("beforeRemove", { records: storage.allValues, removingAll: true }) === false) {
        return null;
      }
      if (me.rootNode) {
        if (!me.isChained) {
          me.rootNode.clearChildren(isLoading);
        }
      } else if (isLoading) {
        const allRecords = me.registeredRecords;
        for (let i = allRecords.length - 1, rec; i >= 0; i--) {
          rec = allRecords[i];
          if (rec && !rec.isDestroyed) {
            rec.unjoinStore(me);
          }
        }
      }
      if (isLoading) {
        me.removed.clear();
        storage.suspendEvents();
      }
      storage.clear();
      if (isLoading) {
        storage.resumeEvents();
      }
      me.added.clear();
      me.modified.clear();
    }
  }
  /**
   * Removes all records from the store.
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Boolean} `true` unless the action was prevented, in which case it returns `false`
   * @fires beforeRemove
   * @fires removeAll
   * @fires change
   * @category CRUD
   */
  removeAll(silent = false) {
    const me = this, storage = me.storage;
    let result;
    me.isRemoving = true;
    if (silent) {
      storage.suspendEvents();
      const allRecords = me.registeredRecords;
      for (let i = allRecords.length - 1, rec; i >= 0; i--) {
        rec = allRecords[i];
        if (rec && !rec.isDestroyed && !rec.isRoot) {
          rec.unjoinStore(me);
        }
      }
    }
    if (me.tree) {
      result = me.rootNode.clear() !== false;
    } else {
      result = me.clear() !== null;
    }
    if (silent) {
      storage.resumeEvents();
    }
    me.isRemoving = false;
    return result;
  }
  /**
   * Add records to store.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Core.data.Model[]} Added records
   * @fires add
   * @fires change
   * @category CRUD
   */
  add(records, silent = false, options = {}) {
    const me = this, { storage } = me;
    records = ArrayHelper.asArray(records);
    if (!(records == null ? void 0 : records.length)) {
      return;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      const parentIdMap = /* @__PURE__ */ new Map(), parentIndexField = me.modelClass.getFieldDataSource("parentIndex"), { parentIdField } = me.modelClass, added2 = [];
      records.forEach((node) => {
        const parentId = node[parentIdField];
        if (!parentIdMap.has(parentId)) {
          parentIdMap.set(parentId, { append: [], insert: [] });
        }
        const entry = parentIdMap.get(parentId);
        if (!node.isModel && parentIndexField in node) {
          entry.insert.push(node);
        } else {
          entry.append.push(node);
        }
      });
      parentIdMap.forEach(({ append, insert }, parentId) => {
        const parentNode2 = parentId == null ? me.rootNode : me.getById(parentId);
        if (!parentNode2) {
          throw new Error(`Parent node with id ${parentId} not found, cannot add children.`);
        }
        if (append.length) {
          added2.push(...parentNode2.appendChild(append, silent, options));
        }
        if (insert.length) {
          for (const toInsert of insert) {
            added2.push(parentNode2.insertChild(toInsert, toInsert[parentIndexField], silent, options));
          }
        }
      });
      if (me.isFiltered && me.reapplyFilterOnAdd) {
        me.filter({
          silent: true
        });
      }
      if (me.reapplySortersOnAdd && !me.isSyncingDataOnLoad) {
        me.sort();
      }
      return added2;
    }
    if (!silent && me.trigger("beforeAdd", { records }) === false) {
      return null;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      return me.rootNode.appendChild(records);
    }
    const added = me.processRecords(records);
    if (silent) {
      me.suspendEvents();
    }
    me.addingClean = options.clean;
    storage.add(added);
    me.addingClean = false;
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  processRecords(records, onRecordCreated) {
    return records.map((data) => {
      const record = this.processRecord(data.isModel ? data : this.createRecord(data));
      onRecordCreated == null ? void 0 : onRecordCreated.call(this, record);
      return record;
    });
  }
  /**
   * Insert records into the store.
   * @param {Number} index Index to insert at
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to insert to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Core.data.Model[]} Inserted records
   * @fires add
   * @fires change
   * @category CRUD
   */
  insert(index, records, silent = false) {
    var _a2;
    const me = this, storage = me.storage, insertBefore = me.getAt(index), _records = storage.values, removeIndices = [];
    records = ArrayHelper.asArray(records);
    if (me.tree) {
      const root = me.rootNode;
      return root.insertChild(records, (_a2 = root.children) == null ? void 0 : _a2[index], silent);
    }
    if (!silent && me.trigger("beforeAdd", { records }) === false) {
      return null;
    }
    let isNoop, start, i;
    if (_records[start = index] === records[0] || _records[start = index - 1] === records[0]) {
      for (isNoop = true, i = 0; isNoop && i < records.length; i++) {
        if (records[i] !== _records[start + i]) {
          isNoop = false;
        }
      }
    }
    if (isNoop) {
      return null;
    }
    const added = me.processRecords(records, (record) => {
      const removedAtIndex = storage.indexOf(record);
      if (record.children && record.children.length && me.autoTree) {
        me.tree = true;
      }
      if (removedAtIndex > -1) {
        if (removedAtIndex < index && insertBefore)
          index--;
        removeIndices.push(removedAtIndex);
      }
      record.meta.previousIndex = removedAtIndex;
    });
    me.suspendEvents();
    me.storage.remove(removeIndices);
    me.resumeEvents();
    if (silent) {
      me.suspendEvents();
    }
    storage.splice(index, 0, ...added);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  /**
   * Moves a record, or block of records to another location.
   * @param {Core.data.Model|Core.data.Model[]} records The record(s) to move.
   * @param {Core.data.Model} beforeRecord the record to insert the first record(s) before.
   * @fires change
   * @category CRUD
   */
  move(records, beforeRecord) {
    if (this.isTree) {
      beforeRecord.parent.insertChild(records, beforeRecord);
    } else {
      this.storage.move(records, beforeRecord);
    }
  }
  //endregion
  //region Update multiple
  setMultiple(filterFn, field, value) {
    const me = this, records = [], changes = [];
    me.forEach((r) => {
      if (filterFn(r)) {
        changes.push(r.set(field, value, true));
        records.push(r);
      }
    });
    me.trigger("updateMultiple", { records, all: me.records.length === records.length });
    me.trigger("change", { action: "updatemultiple", records, all: me.records.length === records.length });
    if (me.reapplyFilterOnUpdate && me.isFiltered)
      me.filter();
  }
  setAll(field, value) {
    const me = this, changes = [];
    me.forEach((r) => {
      changes.push(r.set(field, value, true));
    });
    me.trigger("updateMultiple", { records: me.records, all: true });
    me.trigger("change", { action: "updatemultiple", records: me.records, all: true });
    if (me.reapplyFilterOnUpdate && me.isFiltered)
      me.filter();
  }
  //endregion
  //region Commit
  /**
   * Accepts all changes, resets the modification tracking:
   * * Clears change tracking for all records
   * * Clears added
   * * Clears modified
   * * Clears removed
   * Leaves the store in an "unmodified" state.
   * @internal
   */
  acceptChanges() {
    const me = this;
    me.added.forEach((r) => r.clearChanges(true, false));
    me.modified.forEach((r) => r.clearChanges(true, false));
    me.added.clear();
    me.modified.clear();
    me.removed.clear();
  }
  /**
   * Commits changes, per default only returns changes and resets tracking.
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Object} Changes, see {@link #property-changes}
   * @fires beforeCommit
   * @fires commit
   * @category CRUD
   */
  commit(silent = false) {
    const { changes } = this;
    if (!silent && this.trigger("beforeCommit", { changes }) === false) {
      return false;
    }
    this.acceptChanges();
    if (!silent) {
      this.trigger("commit", { changes });
    }
    return changes;
  }
  /**
   * Reverts all changes in the store (adds removed records back, and removes newly added records).
   * @fires change
   * @fires refresh
   * @category CRUD
   */
  revertChanges() {
    const me = this, { changes } = me;
    if (changes) {
      const event = { action: "clearchanges", changes };
      me.add(me.removed.values, true);
      me.remove(me.added.values, true);
      me.modified.forEach((r) => r.revertChanges(true));
      me.added.clear();
      me.modified.clear();
      me.removed.clear();
      me.trigger("change", event);
      me.trigger("refresh", event);
    }
  }
  /**
   * Get uncommitted changes as an object of added/modified/removed arrays of records.
   *
   * ```javascript
   * // Format:
   * {
   *      added: [], // array of Core.data.Model
   *      modified: [], // array of Core.data.Model
   *      removed: [] // array of Core.data.Model
   * }
   * ```
   *
   * @member {Object} changes
   * @property {Core.data.Model[]} changes.added Records that have been added
   * @property {Core.data.Model[]} changes.modified Records that have changes to persistable fields
   * @property {Core.data.Model[]} changes.removed Records that have been removed
   * @readonly
   * @category Records
   */
  get changes() {
    const me = this, modified = me.modified.values.filter((r) => r.rawModifications);
    return me.added.count || modified.length || me.removed.count ? {
      // Slicing to have changes intact when triggering commit
      added: me.added.values.slice(),
      modified,
      removed: me.removed.values.slice()
    } : null;
  }
  /**
   * Setting autoCommit to true automatically commits changes to records.
   * @property {Boolean}
   * @category Records
   */
  get autoCommit() {
    return this._autoCommit;
  }
  set autoCommit(auto) {
    this._autoCommit = auto;
    if (auto && this.changes) {
      this.commit();
    }
  }
  /**
   * Suspends automatic commits upon store changes. Can be called multiple times (it uses an internal counter).
   * @category Records
   */
  suspendAutoCommit() {
    this.suspendCount++;
  }
  /**
   * Resumes automatic commits upon store changes. Will trigger commit if the internal counter is 0.
   * @category Records
   */
  resumeAutoCommit(doCommit = true) {
    this.suspendCount--;
    if (this.autoCommit && doCommit) {
      this.doAutoCommit();
    }
  }
  doAutoCommit() {
    if (this.suspendCount <= 0) {
      this.commit();
    }
  }
  //endregion
};

// ../Core/lib/Core/data/mixin/StoreChanges.js
var StoreChanges_default = (Target) => class StoreChanges extends (Target || Base) {
  static get $name() {
    return "StoreChanges";
  }
  static get configurable() {
    return {
      /**
       * Specifies target to filter and sort after applying changeset:
       * * `'changes'` - apply sort and filter to changeset only (see more below)
       * * `'none'` - do not apply sort and filter
       *
       * ### `changes` behavior
       * If the store has filters in effect when the changeset is applied, the following rules will determine how the
       * filtered values are affected:
       * - Among added records, only those that match the filter will be included in the filtered set
       * - Among updated records, those that did not previously match the filter but now do will be added to the filtered set,
       *   and those that did match but no longer do will also remain in the filtered set. This means that new records may
       *   appear in the filtered set as a result of `applyChanges`, but records will not disappear until filters are
       *   re-applied.
       *
       * @default
       * @prp {'changes'|'none'}
       * @category Advanced
       */
      applyChangesetFilterSortTarget: "changes"
    };
  }
  /**
   * Applies changes from another store to this store. Useful if cloning records in one store to display in a
   * grid in a popup etc. to reflect back changes.
   * @param {Core.data.Store} otherStore
   * @category CRUD
   */
  applyChangesFromStore(otherStore) {
    const me = this, { changes } = otherStore;
    if (!changes) {
      return;
    }
    if (changes.added) {
      me.add(changes.added);
    }
    if (changes.removed) {
      me.remove(changes.removed.map((r) => r.id));
    }
    if (changes.modified) {
      changes.modified.forEach((record) => {
        const localRecord = me.getById(record.id);
        localRecord == null ? void 0 : localRecord.set(record.modifications);
      });
    }
  }
  /**
   * Applies a set of changes (presumable from a backend) expressed as an object matching the format outputted by the
   * {@link Core/data/Store#property-changes} property: `{ added : [], modified/updated : [], removed : [] }`
   *
   * `added` is expected to be an array of raw data objects consumable by the stores model class for records to add to
   * the store (see example snippet below).
   *
   * `modified` (or `updated` for compatibility with Schedulers CrudManager) is expected to have the same format as
   * `added`, but should always include the `id` of the record to update.
   *
   * Records that have been created locally and gets assigned a proper id by the backend are expected to also pass a
   * `phantomId` field (name of the field is configurable using the `phantomIdField` arg, more info on phantom ids
   * below), to match it with the current id of a local record (`id` will contain the new id).
   *
   * Note that it is also possible to pass this `phantomId` -> `id` mapping in the `added` array. When encountering a
   * record in that array that already exists in the local store, it will be treated the same was as a record in the
   * `modified` array.
   *
   * `removed` is expected to be an array of objects with the `{ id : xx }` shape. Any matches on an id in the store
   * will be removed, those and any non matches will also be cleared from the change tracking of the store.
   *
   * If the store has filters in effect when the changeset is applied, the following rules will determine how the
   * filtered values are affected:
   * - Among added records, only those that match the filter will be included in the filtered set
   * - Among updated records, those that did not previously match the filter but now do will be added to the filtered set,
   *   and those that did match but no longer do will also remain in the filtered set. This means that new records may
   *   appear in the filtered set as a result of `applyChanges`, but records will not disappear until filters are
   *   re-applied.
   *
   * As an example, consider a store with the following initial state and some operations performed on it:
   *
   * ```javascript
   * // Load some data into the store
   * store.data = [
   *     { id : 1, name : 'Minerva' },
   *     { id : 2, name : 'Mars' },
   *     { id : 3, name : 'Jupiter' }
   * ];
   * // Add a new record. It gets assigned a generated id,
   * // for example 'generated56'
   * store.add({ name : 'Artemis' });
   * // Remove Jupiter
   * store.remove(3);
   * ```
   *
   * After syncing those operations to a custom backend (however you chose to solve it in your application) we might
   * get the following response (see "Transforming a response to the correct format" below if your backend responds
   * in another format):
   *
   * ```javascript
   * const serverResponse = {
   *     added : [
   *         // Added by the backend, will be added locally
   *         { id : 5, name : 'Demeter' }
   *     ],
   *
   *     updated : [
   *         // Will change the name of Minerva -> Athena
   *         { id : 1, name : 'Athena' },
   *         // Will set proper id 4 for Artemis
   *         { $PhantomId : 'generated56', id : 4 }
   *     ],
   *
   *     removed : [
   *         // Confirmed remove of Jupiter
   *         { id : 3 },
   *         // Removed by the backend, Mars will be removed locally
   *         { id : 2 }
   *     ]
   * };
   * ```
   *
   * If that response is then passed to this function:
   *
   * ```javascript
   * store.applyChangeSet(serverResponse);
   * ```
   *
   * The end result will be the following data in the store:
   *
   * ```javascript
   * [
   *     { id : 1, name : 'Athena' }, // Changed name
   *     { id : 4, name : 'Artemis' }, // Got a proper id
   *     { id : 5, name : 'Demeter' } // Added by the backend
   * ]
   * ```
   *
   * ### Phantom ids
   *
   * When a record is created locally, it is always assigned a generated id. That id is called a phantom id (note that
   * it is assigned to the normal id field). When passing the new record to the backend, the id is sent with it. When
   * the backend inserts the record into the database, it (normally) gets a proper id assigned. That id then needs to
   * be passed back in the response, to update the local record with the correct id. Making sure that future updates
   * match the correct row in the database.
   *
   * For example a newly created record should be passed similar to this to the backend (pseudo format, up to the
   * application/backend to decide):
   *
   * ```json
   * {
   *     "added" : {
   *         "id" : "generated79",
   *         "name" : "Hercules",
   *         ...
   *     }
   * }
   * ```
   *
   * For the backend response to be applicable for this function, it should then respond with:
   *
   * ```json
   * {
   *     "updated" : {
   *         {
   *             "$PhantomId" : "generated79",
   *             "id" : 465
   *         }
   *     }
   * }
   * ```
   *
   * (Or, as stated above, it can also be passed in the "added" array. Which ever suits your backend best).
   *
   * This function will then change the id of the local record using the phantom id `generated79` to `465`.
   *
   * ### Transforming a response to the correct format
   *
   * This function optionally accepts a `transformFn`, a function that will be called with the `changes`. It is
   * expected to return a changeset in the format described above (`{ added : [], updated : [], removed : [] }`),
   * which then will be used to apply the changes.
   *
   * Consider the following "non standard" (made up) changeset:
   *
   * ```javascript
   * const changes = {
   *     // Database ids for records previously added locally
   *     assignedIds : {
   *         'phantom1' : 10,
   *         'phantom2' : 15
   *     },
   *     // Ids records removed by the backend
   *     removed : [11, 27],
   *     // Modified records, keyed by id
   *     altered : {
   *         12 : { name : 'Changed' }
   *     },
   *     // New records, keyed by id
   *     inserted : {
   *         20  : { name : 'New' }
   *     }
   * }
   * ```
   *
   * Since it does not match the expected format it has to be transformed:
   *
   * ```javascript
   * store.applyChangeset(changes, ({ assignedIds, inserted, altered, removed }) => ({
   *    // Convert inserted to [{ id : 20, name : 'New' }]
   *    added : Object.entries(inserted).map(([id, data] => ({ id, ...data }),
   *    updated : [
   *        // Convert assignedIds to [{ $PhantomId : 'phantom1', id : 10 }, ...]
   *       ...Object.entries(assignedIds).map(([phantomId, id])) => ({ $PhantomId : phantomId, id }),
   *       // Convert altered to [{ id : 12, name : 'Changed' }]
   *       ...Object.entries(modified).map(([id, data] => ({ id, ...data })
   *    ],
   *    // Convert removed to [{ id : 11 }, ...]
   *    removed : removed.map(id => ({ id }))
   * }));
   * ```
   *
   * The transform function above would output:
   *
   * ```javascript
   * {
   *     added : [
   *         {  id : 20, name : 'New' }
   *     ],
   *     updated : [
   *         { $PhantomId : 'phantom1', id : 10 },
   *         { $PhantomId : 'phantom2', id : 15 },
   *         {  id : 12, name : 'Changed' }
   *     ],
   *     removed : [
   *        { id : 11 },
   *        { id : 12 }
   *     ]
   * }
   * ```
   *
   * And that format can then be applied.
   *
   * @param {Object} changes Changeset to apply to the store, see specification above
   * @param {Function} [transformFn] Optional function used to preprocess a changeset in a different format,
   * should return an object with the format expected by this function (see above)
   * @param {String} [phantomIdField] Field used by the backend when communicating a record being assigned a proper id
   * instead of a phantom id (see above)
   * @privateparam {Boolean} [remote] Set to true to indicate changes are from the remote source. Remote changes have
   * precedence over local.
   * @privateparam {Boolean} [logChanges] Used by CrudManager to be able to revert specific changes later
   * @category CRUD
   */
  applyChangeset(changes, transformFn = null, phantomIdField = "$PhantomId", remote = true, logChanges = false) {
    var _a2, _b, _c, _d, _e;
    const me = this, { added, updated, modified, removed } = (_a2 = transformFn == null ? void 0 : transformFn(changes, me)) != null ? _a2 : changes, altered = (_b = updated != null ? updated : modified) != null ? _b : [], idDataSource = me.modelClass.getFieldDataSource("id"), parentIdDataSource = me.modelClass.getFieldDataSource("parentId"), log = logChanges ? /* @__PURE__ */ new Map() : null, allAdded = [], allAltered = [];
    let rootUpdated = false, modifiedParents = [];
    me.trigger("startApplyChangeset");
    me._groupVisibleRecordIds = [];
    me.isGrouped && me.forEach((record) => {
      me._groupVisibleRecordIds.push(record.id);
    });
    if ((added == null ? void 0 : added.length) > 0) {
      const toUpdate = [], toAdd = [];
      for (const data of added) {
        if (me.getById(data[phantomIdField]) || me.getById(ObjectHelper.getPath(data, idDataSource))) {
          toUpdate.push(data);
        } else {
          toAdd.push(data);
        }
      }
      altered.unshift.apply(altered, toUpdate);
      const prevReapplySortersOnAdd = me.reapplySortersOnAdd;
      me.reapplySortersOnAdd = false;
      const addedRecords = (_c = me.add(toAdd, false, { orderedParentIndex: { skip: true } })) != null ? _c : [];
      allAdded.push(...addedRecords);
      me.reapplySortersOnAdd = prevReapplySortersOnAdd;
      if (me.tree) {
        for (const record of addedRecords) {
          const { parent } = record;
          if (parent.isRoot) {
            rootUpdated = true;
            modifiedParents = [parent];
            break;
          }
          if (!parent.isRoot && modifiedParents.every((r) => !r.contains(parent))) {
            modifiedParents.push(parent);
          }
        }
      }
      for (const record of addedRecords) {
        log == null ? void 0 : log.set(record.id, record.data);
        record.clearChanges();
      }
    }
    if ((altered == null ? void 0 : altered.length) > 0) {
      for (const data of altered) {
        const phantomId = data[phantomIdField], id = ObjectHelper.getPath(data, idDataSource), parentId = ObjectHelper.getPath(data, parentIdDataSource), record = (_d = me.getById(phantomId)) != null ? _d : me.getById(id);
        if (record) {
          const newParentWasLeaf = parentId != null ? (_e = me.getById(parentId)) == null ? void 0 : _e.isLeaf : false;
          const changes2 = record.applyChangeset(data, phantomIdField, remote);
          if (newParentWasLeaf) {
            me.toggleCollapse(record.parent, false);
          }
          if (me.tree && !rootUpdated && modifiedParents.every((r) => !r.contains(record))) {
            if (record.parent.isRoot) {
              rootUpdated = true;
              modifiedParents = [record.parent];
            } else {
              modifiedParents.push(record.parent);
            }
          }
          log == null ? void 0 : log.set(id, changes2);
          allAltered.push(record);
        }
      }
    }
    if ((removed == null ? void 0 : removed.length) > 0) {
      me.applyRemovals(removed);
    }
    if (me.applyChangesetFilterSortTarget === "changes") {
      const parentsModifiedByFilter = me.filterChangeset(allAdded, allAltered);
      modifiedParents.push(...parentsModifiedByFilter);
    }
    me.afterChangesetApplied(modifiedParents);
    if (me.tree && me.isSorted && me.reapplySortersOnAdd && ((added == null ? void 0 : added.length) || (altered == null ? void 0 : altered.length))) {
      const refreshed = /* @__PURE__ */ new Set();
      modifiedParents.forEach((record) => {
        if (refreshed.has(record)) {
          return;
        }
        refreshed.add(record);
        record.sortVisibleChildren(false, me.sorterFn);
        record.sortUnfilteredChildren(false, me.sorterFn);
      });
      me.storage.replaceValues({
        values: me.collectDescendants(me.rootNode).visible,
        silent: true
      });
      me.afterPerformSort(false);
    }
    me._groupVisibleRecordIds = null;
    me.trigger("endApplyChangeset");
    return log;
  }
  afterChangesetApplied(modifiedParents) {
    const visited = /* @__PURE__ */ new Set();
    modifiedParents.forEach((parent) => {
      if (visited.has(parent)) {
        return;
      }
      parent.traverse((record) => {
        if (visited.has(record)) {
          return;
        }
        visited.add(record);
        record.sortOrderedChildren(false, false);
        if (record.children) {
          record.updateChildrenIndices(record.children, "parentIndex", true);
        }
        if (record.unfilteredChildren) {
          record.updateChildrenIndices(record.unfilteredChildren, "unfilteredIndex", true);
        }
      });
    });
  }
  // Apply removals, removing records and updating the `removed` bag to match.
  //
  // Accepts an array of objects containing an `id` property. Records in the store matching an entry in the array
  // will be removed from the store and the `removed` bag. Unmatched entries will be removed from the `removed` bag.
  applyRemovals(removals) {
    const me = this, { removed: removedStash } = me, idDataSource = me.modelClass.idField, toRemove = [];
    for (const removedEntry of removals) {
      const id = ObjectHelper.getPath(removedEntry, idDataSource);
      if (removedStash.includes(id)) {
        const record = removedStash.get(id);
        record.clearChanges(false, true, null);
        record.$isPhantom = true;
        removedStash.remove(id);
      } else {
        toRemove.push(id);
      }
    }
    me.remove(toRemove);
    for (const record of toRemove) {
      removedStash.remove(record);
    }
  }
  /**
   * Filters records that have been added/updated as part of a changeset. The `added` and `updated` parameters
   * are arrays of values that have already been added/updated in the Collection's values. This method brings
   * the Collection's `_filteredValues` in sync without performing a full sort or filter, using the following rules:
   *
   * - Added records that do not match the filter are removed from _filteredValues
   *
   * - Updated records that now match the filter are inserted at the correct position in _filteredValues
   *   if they were not formerly included
   *
   * - Updated records that formerly matched the filter, but now do not, are NOT removed from _filteredValues
   *
   * If the collection is sorted, either on its own or via a sort applied at the store level, that sort order is
   * respected when adding items to _filteredValues. If not, items are inserted in the same order they occur in
   * _values.
   *
   * @param {Object[]} added An array of unique values that were added as part of the changeset.
   * @param {Object[]} updated An array of unique values that were updated as part of the changeset.
   * @returns {Object[]} Any records that were added or removed from view, or whose children were modified.
   * @private
   */
  filterChangeset(added, updated) {
    const me = this, {
      isFiltered,
      tree,
      isGrouped,
      filtersFunction
    } = me, storeSortFunction = me.isSorted ? me.createSorterFn(me.sorters) : void 0, {
      allValues,
      addedValues,
      isSorted
    } = me.storage, sorter = storeSortFunction != null || isSorted ? storeSortFunction != null ? storeSortFunction : me.storage.sortFunction : null, modifiedParents = /* @__PURE__ */ new Set();
    if (!isFiltered) {
      return [];
    }
    let trigger = false, groupers;
    if (isGrouped) {
      groupers = me.groupers;
      me.clearGroupers(true);
    }
    if (tree) {
      const nodesToInclude = new Set(updated.filter(filtersFunction));
      for (const matchingAdd of added.filter(filtersFunction)) {
        nodesToInclude.add(matchingAdd);
      }
      nodesToInclude.forEach((node) => node.bubble((ancestor) => nodesToInclude.add(ancestor)));
      nodesToInclude.delete(me.rootNode);
      const nodesToIncludeByParent = ArrayHelper.groupBy(
        // filter out the nodes that are already included to `children`
        Array.from(nodesToInclude).filter((child) => {
          var _a2, _b;
          return !((_b = (_a2 = child.parent) == null ? void 0 : _a2.children) == null ? void 0 : _b.includes(child));
        }),
        "parentId"
      );
      for (const siblingsToInclude of Object.values(nodesToIncludeByParent)) {
        const { parent } = siblingsToInclude[0];
        if (parent.unfilteredChildren) {
          parent.children.push(...siblingsToInclude);
          modifiedParents.add(parent);
        }
      }
    } else if (sorter && !isGrouped) {
      const { filteredValues } = me.storage, sortedLength = addedValues ? filteredValues.findLastIndex((value) => !addedValues.has(value)) + 1 : filteredValues.length, sorted = filteredValues.slice(0, sortedLength), updatedMatches = new Set(updated.filter(filtersFunction));
      for (const value of filteredValues) {
        if (updatedMatches.has(value)) {
          updatedMatches.delete(value);
        }
      }
      for (const newMatch of updatedMatches) {
        sorted.push(newMatch);
      }
      sorted.sort(sorter);
      filteredValues.splice(0, sortedLength, ...sorted);
      trigger = true;
    } else {
      const updatedMatches = updated.filter((item) => filtersFunction(item) && !me.storage.includes(item));
      if (updatedMatches.length > 0) {
        me.includeInSubset(allValues, me.storage.filteredValues, updatedMatches);
        trigger = true;
      }
    }
    const nonMatchingAdds = new Set(added.filter((value) => !filtersFunction(value)));
    if (nonMatchingAdds.size > 0) {
      if (tree) {
        for (const addedChild of nonMatchingAdds) {
          ArrayHelper.remove(addedChild.parent.children, addedChild);
          modifiedParents.add(addedChild.parent);
        }
      } else {
        ArrayHelper.remove(me.storage.filteredValues, nonMatchingAdds);
      }
      trigger = true;
    }
    if (groupers) {
      me.group(groupers[0], null, false, true, true);
      trigger = true;
    }
    if (tree && modifiedParents.size > 0) {
      me.storage.replaceValues({
        values: me.collectDescendants(me.rootNode).visible,
        silent: true
      });
    } else if (trigger) {
      me._idMap = null;
      me.trigger("refresh");
    }
    return [...modifiedParents];
  }
  /**
   * Given an array `all`, an array `subset` that is a subset of `all` in the same order, and another array
   * `toInclude` that is a different subset of `all` disjoint with `subset`, add each item from `toInclude`
   * to `subset`, in an order matching the order in `all`. The order of `subset` must match the order of `all`.
   * The order of `toInclude` is unimportant.
   *
   * Modifies `subset` in-place.
   *
   * @param {Array} all An array of unique items (e.g. records)
   * @param {Array} subset An array containing a subset of the items in `all` (same order as `all`)
   * @param {Array} toInclude An array or items from `all` that should be included in `subset` (unordered)
   * @returns {Array} The subset modified in-place.
   * @private
   */
  includeInSubset(all, subset, toInclude) {
    const toIncludeSet = new Set(toInclude);
    let subsetIndex = 0, allIndex = 0, done = toIncludeSet.size === 0;
    while (allIndex < all.length && !done) {
      const subsetItem = subset[subsetIndex];
      let allItem = all[allIndex];
      while (subsetItem !== allItem) {
        if (toIncludeSet.has(allItem)) {
          subset.splice(subsetIndex, 0, allItem);
          subsetIndex++;
          toIncludeSet.delete(allItem);
          done = toIncludeSet.size === 0;
        }
        allItem = all[++allIndex];
      }
      if (toIncludeSet.has(subsetItem)) {
        toIncludeSet.delete(subsetItem);
      }
      if (subsetIndex < subset.length) {
        subsetIndex++;
      }
    }
    return subset;
  }
};

// ../Core/lib/Core/data/mixin/StoreFilter.js
var StoreFilter_default = (Target) => class StoreFilter extends (Target || Base) {
  static get $name() {
    return "StoreFilter";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Specify one or more {@link Core/util/CollectionFilter} config objects to apply initially.
       *
       * For example:
       *
       * ```javascript
       *  // Configure the store to filter in clients over the age of 30
       *  new Store({
       *      ...,
       *      filters : [{
       *          property : 'age',
       *          value    : 30,
       *          operator : '>'
       *      }],
       *      ...
       *  })
       * ```
       *
       * or:
       *
       * ```javascript
       *  // Configure the store to filter based on a complex operation
       *  new Store({
       *      ...,
       *      filters : [{
       *          filterBy(record) {
       *              // Return true or false for filtering in or out
       *              return shouldClientBeVisible(record);
       *          }
       *      }],
       *      ...
       *  })
       * ```
       *
       * @config {CollectionFilterConfig|CollectionFilterConfig[]}
       * @category Filtering
       */
      filters: null,
      /**
       * Specify true to reapply filters when a record is added to the store.
       * @config {Boolean}
       * @default
       * @category Filtering
       */
      reapplyFilterOnAdd: false,
      /**
       * Specify true to reapply filters when a record is updated in the store.
       * @config {Boolean}
       * @default
       * @category Filtering
       */
      reapplyFilterOnUpdate: false
    };
  }
  //endregion
  //region Events
  /**
   * Fired after applying filters to the store
   * @event filter
   * @param {Core.data.Store} source This Store
   * @param {Core.util.Collection} filters Filters used by this Store
   * @param {Core.data.Model[]} removed The records which were filtered out by the action.
   * @param {Core.data.Model[]} added The records which were filtered back in by the action.
   * @param {Core.data.Model[]} records Filtered records
   */
  //endregion
  //region Properties
  set reapplyFilterOnAdd(enable) {
    this.storage.autoFilter = enable;
  }
  get reapplyFilterOnAdd() {
    return this.storage.autoFilter;
  }
  /**
   * Currently applied filters. A collection of {@link Core.util.CollectionFilter} instances.
   * @type {Core.util.Collection}
   * @readonly
   * @category Sort, group & filter
   */
  set filters(filters) {
    const me = this, collection = me.filters;
    collection.clear();
    me._filtersFunction = null;
    if (filters) {
      if (filters.constructor.name === "Object") {
        for (const f of Object.entries(filters)) {
          if (f[0] === "filterBy" && typeof f[1] === "function") {
            collection.add(new CollectionFilter({
              filterBy: f[1]
            }));
          } else {
            collection.add(new CollectionFilter(f[1].constructor.name === "Object" ? Object.assign({
              property: f[0]
            }, f[1]) : {
              property: f[0],
              value: f[1]
            }));
          }
        }
      } else if (Array.isArray(filters)) {
        collection.add(...filters.map((filterConfig) => {
          if (filterConfig instanceof CollectionFilter) {
            return filterConfig;
          }
          return new CollectionFilter(filterConfig);
        }));
      } else if (filters.isCollection) {
        collection.add(...filters.values);
      } else {
        collection.add(new CollectionFilter({
          filterBy: filters
        }));
      }
      collection.forEach((item) => item.owner = me);
    }
  }
  get filters() {
    return this._filters || (this._filters = new Collection({ extraKeys: ["property"] }));
  }
  set filtersFunction(filtersFunction) {
    this._filtersFunction = filtersFunction;
  }
  get filtersFunction() {
    const me = this, { filters, isGrouped } = me;
    if (!me._filtersFunction) {
      if (filters.count) {
        const generatedFilterFunction = CollectionFilter.generateFiltersFunction(filters);
        me._filtersFunction = (candidate) => {
          if (isGrouped && candidate.isSpecialRow) {
            return candidate.groupChildren.some(generatedFilterFunction);
          }
          return generatedFilterFunction(candidate);
        };
      } else {
        me._filtersFunction = FunctionHelper.returnTrue;
      }
    }
    return me._filtersFunction;
  }
  /**
   * Check if store is filtered
   * @property {Boolean}
   * @readonly
   * @category Sort, group & filter
   */
  get isFiltered() {
    return this.filters.values.some((filter) => !filter.disabled);
  }
  //endregion
  traverseFilter(record) {
    const me = this, hitsCurrent = !record.isRoot && me.filtersFunction(record), children = record.unfilteredChildren || record.children;
    if (!children || !children.length) {
      return hitsCurrent;
    }
    if (!record.unfilteredChildren) {
      record.unfilteredChildren = record.children.slice();
    }
    record.children = record.unfilteredChildren.filter((r) => {
      return me.traverseFilter(r);
    });
    if (me.isSorted) {
      record.children.sort(me.sorterFn);
    }
    record.updateChildrenIndices(record.unfilteredChildren, "unfilteredIndex", true);
    record.updateChildrenIndices(record.children, "parentIndex", true);
    return hitsCurrent || Boolean(record.children.length);
  }
  traverseClearFilter(record) {
    const me = this;
    if (record.unfilteredChildren) {
      record.children = record.orderedChildren.slice();
      record.unfilteredChildren = null;
    }
    if (record.children) {
      if (me.isSorted) {
        record.children.sort(me.sorterFn);
      }
      record.children.forEach((r) => me.traverseClearFilter(r));
      record.updateChildrenIndices(record.children, "parentIndex", true);
    }
  }
  get latestFilterField() {
    return this.filters.last ? this.filters.last.property : null;
  }
  /**
   * Adds a single filter to the {@link #config-filters} collection. By default, filters are reevaluated
   * and a Store change event fired.
   *
   * If the `silent` parameter is passed as `true`, multiple filters can be added without causing data changes.
   *
   * When the filters are as required, call {@link #function-filter} with no parameters
   * to apply the filters to the store.
   *
   * @param {CollectionFilterConfig|Function} newFilter A {@link Core.util.CollectionFilter filter} config,
   * or a function to use for filtering.
   * @param {Boolean} [silent] Pass `true` to *not* refilter the store immediately. Such as when
   * adding multiple filters.
   * @returns {Core.util.CollectionFilter} The Filter instance that was added.
   * @returns {Promise|Core.util.CollectionFilter} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method
   * returns Collection filter inside a `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  addFilter(filter, silent = false) {
    const me = this;
    filter = filter instanceof CollectionFilter ? filter : new CollectionFilter(filter);
    filter.owner = me;
    me.filters.add(filter);
    if (!silent) {
      if (me.remoteFilter) {
        return me.filter().then(() => filter);
      } else {
        me.filter();
      }
    }
    return filter;
  }
  /**
   * Filters the store by **adding** the specified filter(s) to the existing filters collection applied to this Store.
   * If a filter has an {@link Core.util.CollectionFilter#config-id id} specified,
   * or a {@link Core.util.CollectionFilter#config-property property} specified,
   * it will search for corresponding filter(s) in the existing filters first and replace it with a new filter.
   * **It will not remove other filters applied to the store!**
   *
   * To **add** a new filter:
   *
   * ```javascript
   * // Filter using simple object
   * store.filter({
   *     property : 'age',
   *     operator : '>',
   *     value    : 90
   * });
   *
   * // Filter using function
   * store.filter(r => r.age < 90);
   *
   * // Filter using a named filter as a function
   * store.filter({
   *     id : 'my-filter',
   *     filterBy : record => record.score > 10
   * });
   * ```
   *
   * To **remove** a specific filter, but keep other filters applied
   *
   * ```javascript
   * // Remove by filter `id` or `property`. Filter `id` defaults to the `property` name.
   * store.removeFilter('age');
   * store.removeFilter('my-filter');
   * ```
   *
   * To **replace** all existing filters with a new filter
   *
   * ```javascript
   * // Remove all filters and filter using simple object
   * store.filter({
   *     filters : {
   *         property : 'age',
   *         operator : '<',
   *         value    : 90
   *     },
   *     replace : true
   * });
   *
   * // Remove all filters and filter using function
   * store.filter({
   *     filters : r => r.age > 90,
   *     replace : true
   * });
   *
   * // Remove all filters and filter using a named filter as a function
   * store.filter({
   *     filters : {
   *         id : 'my-filter',
   *         filterBy : record => record.score > 10
   *     },
   *     replace : true
   * });
   * ```
   *
   * Basically filters replacing is an equivalent of having two sequenced calls:
   * {@link #function-clearFilters clearFilters} and {@link #function-filter filter}.
   *
   * Call without arguments to reapply filters.
   *
   * ```javascript
   * // Re-filter the store
   * store.filter();
   * ```
   *
   * @param {Object|CollectionFilterConfig|CollectionFilterConfig[]|Function} newFilters
   *        A {@link Core.util.CollectionFilter filter} config,
   *        or an array of {@link Core.util.CollectionFilter filter} configs,
   *        or a function to use for filtering,
   *        or a special object like: ```{ replace : true, filters : newFilters }```
   * @param {Boolean} [newFilters.replace]
   *        A flag, indicating whether or not the previous filters should be removed.
   * @param {Boolean} [newFilters.silent]
   *        Set as true to not fire events. UI will not be informed about the changes.
   * @param {CollectionFilterConfig|CollectionFilterConfig[]|Function} [newFilters.filters]
   *        If `newFilters` is an object and `replace` property is defined in the `newFilters`,
   *        it means that special object is used and real filter configuration must be nested down to this `filters` property.
   *        It can be:
   *        A {@link Core.util.CollectionFilter filter} config,
   *        or an array of {@link Core.util.CollectionFilter filter} configs,
   *        or a function to use for filtering.
   * @fires filter
   * @fires change
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns Promise
   * which is resolved after data is loaded from remote server, otherwise it returns null value
   * @async
   * @category Sort, group & filter
   */
  filter(newFilters) {
    const me = this;
    let silent = false, internal;
    if (newFilters) {
      let fieldType = typeof newFilters;
      if (fieldType === "object") {
        if ("silent" in newFilters || "replace" in newFilters || newFilters.filters) {
          silent = newFilters.silent;
          if (newFilters.replace) {
            me.clearFilters(newFilters.filters.length === 0);
          }
          internal = newFilters.internal;
          newFilters = newFilters.filters;
          fieldType = typeof newFilters;
        }
      }
      if (newFilters) {
        const wasFiltered = me.isFiltered;
        me.isConfiguring = true;
        if (Array.isArray(newFilters)) {
          newFilters.forEach((f) => me.addFilter(f, true), me);
        } else if (fieldType === "function") {
          const filter = new CollectionFilter(newFilters);
          filter.internal = internal;
          me.addFilter(filter, true);
        } else if (fieldType === "string") {
          me.addFilter({
            property: newFilters,
            value: arguments[1]
          }, true);
        } else {
          me.addFilter(newFilters, true);
        }
        me.isConfiguring = false;
        if (!me.isFiltered && !wasFiltered) {
          return null;
        }
      }
    }
    me.filtersFunction = null;
    const result = me.performFilter(silent);
    me._idMap = null;
    return result;
  }
  /**
   * Perform filtering according to the {@link #property-filters} Collection.
   * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and
   * must not be overridden.
   * @private
   */
  performFilter(silent) {
    const me = this, { storage, filters, rootNode } = me, oldCount = me.count;
    me.trigger("beforeFilter", { filters });
    let added, removed;
    if (me.tree) {
      const oldDataset = storage.values;
      if (me.isFiltered) {
        me.traverseFilter(rootNode);
      } else {
        me.traverseClearFilter(rootNode);
      }
      const newDataset = me.collectDescendants(rootNode).visible;
      storage.replaceValues({
        values: newDataset,
        silent: true
      });
      const delta = ArrayHelper.delta(newDataset, oldDataset, true);
      added = delta.toAdd;
      removed = delta.toRemove;
    } else {
      storage.ion({
        change({ removed: r, added: a }) {
          removed = r;
          added = a;
        },
        once: true
      });
      if (me.isFiltered) {
        me.isGrouped && me.includeCollapsed();
        storage.addFilter({
          id: "primary-filter",
          filterBy: me.filtersFunction
        });
        me.isGrouped && me.excludeCollapsed();
      } else {
        storage.filters.clear();
      }
    }
    me.afterPerformFilter(silent || me.isRemoteDataLoading ? null : {
      action: "filter",
      filters,
      oldCount,
      added,
      removed,
      records: me.storage.values
    });
  }
  afterPerformFilter(event) {
    this.resetRelationCache();
    if (event) {
      this.triggerFilterEvent(event);
    }
  }
  // Used from filter() and StoreCRUD when reapplying filters
  triggerFilterEvent(event) {
    this.trigger("filter", event);
    if (!this.remoteFilter) {
      this.trigger("refresh", event);
      this.trigger("change", event);
    }
  }
  /**
   * *Adds* a function used to filter the store. Alias for calling `filter(fn)`. Return `true` from the function to
   * include record in filtered set
   *
   * ```javascript
   * store.filterBy(record => record.age > 25 && record.name.startsWith('A'));
   * ```
   *
   * @param {Function} fn Function used to test records
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  filterBy(fn) {
    return this.filter(fn);
  }
  /**
   * Removes the passed filter, or the filter by the passed ID from the {@link #config-filters} collection.
   * By default, filters are reevaluated and a Store change event fired.
   *
   * If the `silent` parameter is passed as `true`, multiple filters can be removed without causing data changes.
   *
   * When the filters are as required, call {@link #function-filter} with no parameters
   * to apply the filters to the store.
   *
   * ```javascript
   * // Only view top priority events
   * myEventStore.filter({
   *     id       : 'priorityFilter',
   *     property : 'priority',
   *     value    : 1,
   *     operator : '='
   * });
   *
   * // That individual filter can be removed like this
   * myEventStore.removeFilter('priorityFilter');
   *
   * // Add named filter as a function
   * store.filter({
   *     id : 'my filter',
   *     filterBy : record => record.score > 10
   * });
   *
   * // Remove named filter function
   * store.removeFilter('my filter');
   * ```
   *
   * @param {String|Core.util.CollectionFilter} idOrInstance Filter to remove, or ID of the filter to remove. By default,
   * filters are reevaluated and a change event fired.
   * @param {Boolean} [silent] Pass `true` to *not* refilter the store immediately. Such as when
   * removing multiple filters.
   * @returns {Promise|Core.util.CollectionFilter} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method
   * returns Collection filter inside a `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  removeFilter(idOrInstance, silent = false) {
    const me = this, filter = idOrInstance instanceof CollectionFilter ? idOrInstance : me.filters.get(idOrInstance);
    if (filter) {
      me.filters.remove(filter);
      me._filtersFunction = null;
      if (!silent) {
        if (me.remoteFilter) {
          return me.filter().then(() => filter);
        } else {
          me.filter();
        }
      }
      return filter;
    }
  }
  /**
   * Removes all filters from the store.
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  clearFilters(apply = true) {
    this.filters.remove(this.filters.values.filter((f) => !f.internal));
    if (apply) {
      return this.filter();
    }
  }
  convertFilterToString(field) {
    const filter = this.filters.getBy("property", field);
    return filter && !filter.filterBy ? String(filter) : "";
  }
  doDestroy() {
    var _a2;
    (_a2 = this._filters) == null ? void 0 : _a2.destroy();
    super.doDestroy();
  }
};

// ../Core/lib/Core/data/mixin/StoreGroup.js
var resortActions = {
  add: 1,
  replace: 1
};
var defaultGroupSortFn = ({ _groupValue: lhs }, { _groupValue: rhs }) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
var StoreGroup_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    static get properties() {
      return {
        collapsedGroups: /* @__PURE__ */ new Set()
      };
    }
    //endregion
    //region Init
    construct(config) {
      super.construct(config);
      this.ion({ change: "onDataChanged", thisObj: this });
    }
    get GroupRow() {
      var _a3;
      return this._GroupRowClass || (this._GroupRowClass = (_a3 = class extends this.modelClass {
        get isCollapsed() {
          return this.meta.collapsed;
        }
      }, __publicField(_a3, "isSpecialRow", true), // The calculated group value for this group header/footer.
      __publicField(_a3, "fields", [{
        name: "_groupValue"
      }]), _a3));
    }
    updateGroupers(groupers) {
      this.setGroupers(groupers);
    }
    /**
     * Set groupers.
     * @param {Grouper[]} groupers Array of groupers to apply to store
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns
     * `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @category Sort, group & filter
     */
    setGroupers(groupers, options = null) {
      const me = this, { storage } = me;
      let result;
      if (groupers == null ? void 0 : groupers.length) {
        me._groupers = groupers;
      } else if (me.groupers) {
        delete me._groupers;
        me.includeCollapsed();
        storage.replaceValues({
          values: me.removeHeadersAndFooters(storage._values),
          filteredValues: storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,
          silent: true
        });
        result = me.group(null, null, null, false, options == null ? void 0 : options.silent);
      }
      me._idMap = null;
      return result;
    }
    get unfilteredGroupRecords() {
      var _a3;
      const me = this;
      if (me.isGrouped) {
        const { generation } = me.storage;
        if (((_a3 = me._unfilteredGroupRecords) == null ? void 0 : _a3.generation) !== generation) {
          me._unfilteredGroupRecords = me.storage.allValues.filter((r) => r.isSpecialRow);
          me._unfilteredGroupRecords.generation = generation;
        }
      }
      return me._unfilteredGroupRecords || [];
    }
    /**
     * Returns group header record for the passed record or last group header in the store
     * @param {Core.data.Model} [targetRecord]
     * @param {Boolean} [ignoreFilter] Pass true to search in the complete collection
     * @returns {Core.data.Model}
     * @internal
     */
    getGroupHeaderForRecord(targetRecord, ignoreFilter = false) {
      if (this.isGrouped) {
        return targetRecord ? targetRecord.meta.groupRowFor ? targetRecord : targetRecord.groupParent.get(this.id) : this.groupRecords.last;
      }
    }
    // Temporarily include records from collapsed groups, for example prior to filtering
    includeCollapsed() {
      for (const groupId of this.collapsedGroups) {
        this.expand(this.getById(groupId), false);
      }
    }
    // Exclude records in collapsed groups, intended to be used after a call to includeCollapsed()
    excludeCollapsed() {
      for (const groupId of this.collapsedGroups) {
        this.collapse(this.getById(groupId));
      }
    }
    onDataChange({ source: storage, action, removed }) {
      var _a3;
      const me = this, { groupers } = me;
      if (groupers) {
        if (groupers.length) {
          if (action === "splice" && (removed == null ? void 0 : removed.length) || action === "move") {
            storage.replaceValues({
              ...me.prepareGroupRecords(),
              silent: true
            });
          }
        } else {
          storage.replaceValues({
            values: me.removeHeadersAndFooters(storage._values),
            filteredValues: storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,
            silent: true
          });
        }
      }
      (_a3 = super.onDataChange) == null ? void 0 : _a3.call(this, ...arguments);
    }
    move(records, beforeRecord) {
      const me = this;
      if (me.isGrouped && !me.tree) {
        let prevRecord = beforeRecord;
        if (beforeRecord == null ? void 0 : beforeRecord.isSpecialRow) {
          prevRecord = me.getPrev(beforeRecord, false, false);
          if (!prevRecord) {
            return;
          }
        }
        const targetGroupHeader = me.getGroupHeaderForRecord(prevRecord), groupField = me.groupers[0].field, newGroupValue = targetGroupHeader.meta.groupRowFor, { reapplyFilterOnUpdate } = me;
        me.reapplyFilterOnUpdate = false;
        me.beginBatch();
        records.forEach((record) => record.setValue(groupField, newGroupValue));
        me.endBatch();
        me.reapplyFilterOnUpdate = reapplyFilterOnUpdate;
        if (me.isFiltered && (beforeRecord == null ? void 0 : beforeRecord.isSpecialRow)) {
          const { unfilteredGroupRecords } = me, index = unfilteredGroupRecords.indexOf(targetGroupHeader);
          beforeRecord = unfilteredGroupRecords[index + 1];
        }
      }
      super.move(records, beforeRecord);
    }
    // private function that collapses on the data level
    collapse(groupRecord) {
      if (groupRecord && !groupRecord.meta.collapsed) {
        this.excludeGroupRecords(groupRecord);
        groupRecord.meta.collapsed = true;
        this.collapsedGroups.add(groupRecord.id);
        this.trigger("toggleGroup", { groupRecord, collapse: true });
        return true;
      }
      return false;
    }
    // private function that expands on the data level
    expand(groupRecord, updateMap = true) {
      if (groupRecord == null ? void 0 : groupRecord.meta.collapsed) {
        this.includeGroupRecords(groupRecord);
        groupRecord.meta.collapsed = false;
        updateMap && this.collapsedGroups.delete(groupRecord.id);
        updateMap && this.trigger("toggleGroup", { groupRecord, collapse: false });
        return true;
      }
      return false;
    }
    removeHeadersAndFooters(records) {
      return records.filter((r) => {
        var _a3;
        if (r.unfilteredGroupChildren) {
          r.groupChildren.length = r.unfilteredGroupChildren.length = r.meta.childCount = 0;
        }
        if (r.isSpecialRow || r.isLinked && ((_a3 = r.groupParent) == null ? void 0 : _a3.get(this.id))) {
          this.unregister(r);
          return false;
        }
        return true;
      });
    }
    prepareGroupRecords() {
      var _a3;
      const me = this, {
        GroupRow,
        isFiltered,
        reapplyFilterOnUpdate,
        groupRecords
      } = me, grouper = me.groupers[0], multiplier = grouper.ascending !== false ? 1 : -1, {
        field,
        fn: groupSortFn = defaultGroupSortFn
      } = grouper, byFn = typeof field === "function", groupingById = field === me.modelClass.idField, newGroupRecords = new Collection(), visibleRecordsIds = me._groupVisibleRecordIds || [], isVisible2 = (record) => {
        const matchesFilter = !isFiltered || me.filtersFunction(record);
        return reapplyFilterOnUpdate ? matchesFilter : matchesFilter || visibleRecordsIds.includes(record.id);
      }, collapseAll = Boolean(me.startGroupsCollapsed && !(groupRecords == null ? void 0 : groupRecords.count));
      groupRecords == null ? void 0 : groupRecords.forEach((groupRec) => {
        if (groupRec.isCollapsed) {
          me.includeGroupRecords(groupRec);
        }
      });
      const records = me.removeHeadersAndFooters(me.storage._values);
      if (me.sorters.length) {
        records.sort(me.sorterFn);
      }
      if (isFiltered) {
        me.filtersFunction = null;
      }
      records.forEach((rec) => {
        const original = rec, v = byFn ? field(rec) : rec[field], groupValues = ArrayHelper.asArray(v == void 0 ? "__novalue__" : v), multiValue = Array.isArray(groupValues), emptyArray9 = multiValue && !groupValues.length, length = emptyArray9 ? 1 : groupValues.length;
        for (let i = 0; i < length; i++) {
          const groupValue = emptyArray9 ? [] : groupValues[i], id = `group-header-${typeof groupValue === "number" ? groupValue : StringHelper.createId(groupValue)}`;
          let groupRec = newGroupRecords.get(id);
          if (!groupRec) {
            groupRec = (groupRecords == null ? void 0 : groupRecords.get(id)) || new GroupRow({
              [me.modelClass.idField]: id,
              [groupingById ? "" : field]: groupValue,
              _groupValue: groupValue
            }, me, {
              collapsed: collapseAll,
              specialRow: true,
              groupRowFor: groupValue,
              groupField: field,
              emptyArray: emptyArray9
            });
            newGroupRecords.add(groupRec);
            groupRec.meta.childCount = 0;
            groupRec.groupChildren = [];
            groupRec.unfilteredGroupChildren = [];
            groupRec.stores = [me];
          }
          me.register(groupRec);
          if (i > 0) {
            const links = original.groupLinks || (original.groupLinks = []);
            rec = links[groupValue] || (links[groupValue] = original.link());
            rec.stores = [me];
            me.register(rec);
          }
          if (!rec.groupParent) {
            rec.setData("groupParent", /* @__PURE__ */ new Map());
          }
          rec.groupParent.set(me.id, groupRec);
          if (isVisible2(rec)) {
            groupRec.groupChildren.push(rec);
            groupRec.meta.childCount++;
          }
          groupRec.unfilteredGroupChildren.push(rec);
        }
      });
      newGroupRecords._values.sort((lhs, rhs) => groupSortFn(lhs, rhs) * multiplier);
      if (me.useGroupFooters) {
        for (let index = 0, length = newGroupRecords.count; index < length; index++) {
          const groupRec = newGroupRecords.values[index], val = groupRec.meta.groupRowFor, id = `group-footer-${typeof val === "number" ? val : StringHelper.createId(val)}`, footer = me.getById(id) || new GroupRow({
            [me.modelClass.idField]: id,
            [groupingById ? "" : field]: val,
            _groupValue: val
          }, me, {
            specialRow: true,
            groupFooterFor: val,
            groupRecord: groupRec
          });
          footer.stores = [me];
          me.register(footer);
          footer.groupChildren = groupRec.groupChildren;
          newGroupRecords.splice(++index, 0, footer);
          length++;
          groupRec.groupChildren.push(footer);
          groupRec.unfilteredGroupChildren.push(footer);
          groupRec.meta.childCount++;
        }
      }
      me._idMap = null;
      const result = {
        values: newGroupRecords.reduce((result2, groupRec) => {
          if (!groupRec.isGroupFooter) {
            result2.push(groupRec);
            if (!groupRec.meta.collapsed) {
              result2.push(...groupRec.unfilteredGroupChildren);
            }
          }
          return result2;
        }, false, [])
      };
      if (isFiltered) {
        result.filteredValues = result.values.filter(isVisible2);
      }
      (_a3 = me.groupRecords) == null ? void 0 : _a3.forEach((oldGroupRec) => {
        if (!newGroupRecords.includes(oldGroupRec)) {
          oldGroupRec.destroy();
        }
      });
      me.groupRecords = newGroupRecords;
      return result;
    }
    //endregion
    //region Group and ungroup
    /**
     * Is store currently grouped?
     * @property {Boolean}
     * @readonly
     * @category Sort, group & filter
     */
    get isGrouped() {
      var _a3;
      return Boolean((_a3 = this.groupers) == null ? void 0 : _a3.length);
    }
    /**
     * Group records, either by replacing current sorters or by adding to them.
     * A grouper can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).
     * Works in the same way as a standard array sorter, except that returning `null` triggers the stores
     * normal sorting routine. Grouped store **must** always be sorted by the same field.
     *
     * ```javascript
     * // simple grouper
     * store.group('city');
     *
     * // grouper as object, descending order
     * store.group({ field : 'city', ascending : false });
     *
     * // using custom sorting function
     * store.group({
     *     field : 'city',
     *     fn : (recordA, recordB) => {
     *         // apply custom logic, for example:
     *         return recordA.city.length < recordB.city.length ? -1 : 1;
     *     }
     * });
     * ```
     *
     * @param {String|Object} field Field to group by.
     * Can also be a config containing a field to group by and a custom sorting function called `fn`.
     * @param {Boolean} [ascending] Sort order of the group titles
     * @param {Boolean} [add] Add a grouper (true) or use only this grouper (false)
     * @param {Boolean} [performSort] Trigger sort directly, which does the actual grouping
     * @param {Boolean} [silent] Set as true to not fire events
     * @category Sort, group & filter
     * @fires group
     * @fires refresh
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     */
    group(field, ascending, add = false, performSort = true, silent = false) {
      var _a3, _b;
      const me = this;
      let newGrouper, fn;
      if (field && typeof field === "object") {
        ascending = field.ascending;
        fn = field.fn;
        field = field.field;
      }
      if (add) {
        me.groupers.push(newGrouper = {
          field,
          ascending,
          complexMapping: field.includes(".")
        });
      } else if (field) {
        if (ascending == null) {
          ascending = ((_a3 = me.groupInfo) == null ? void 0 : _a3.field) === field && ((_b = me.groupInfo) == null ? void 0 : _b.fn) === fn ? !me.groupInfo.ascending : true;
        }
        me.groupInfo = newGrouper = {
          field,
          ascending,
          fn,
          complexMapping: field.includes(".")
        };
        me.groupers = [me.groupInfo];
      }
      if (newGrouper) {
        const { prototype: prototype2 } = me.modelClass;
        if (newGrouper.complexMapping && !Object.prototype.hasOwnProperty.call(prototype2, field)) {
          Object.defineProperty(prototype2, field, {
            get() {
              return ObjectHelper.getPath(this, field);
            }
          });
        }
      }
      if (performSort !== false) {
        if (me.remoteSort && !me.isRemoteDataLoading) {
          return me.sort(null, null, false, true).then(() => me.onAfterGrouping(silent));
        } else {
          me.sort(null, null, false, true);
        }
      }
      me.onAfterGrouping(silent);
    }
    onAfterGrouping(silent) {
      if (silent) {
        return;
      }
      const me = this, groupers = me.groupers || [];
      me.trigger("group", { isGrouped: me.isGrouped, groupers, records: me.storage.values });
      me.trigger("refresh", { action: "group", isGrouped: me.isGrouped, groupers, records: me.storage.values });
    }
    // Internal since UI does not support multi grouping yet
    /**
     * Add a grouping level (a grouper).
     * @param {String} field Field to group by
     * @param {Boolean} ascending Group direction
     * @category Sort, group & filter
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @internal
     */
    addGrouper(field, ascending = true) {
      return this.group(field, ascending, true);
    }
    // Internal since UI does not support multi grouping yet
    /**
     * Removes a grouping level (a grouper)
     * @param {String} field Grouper to remove
     * @category Sort, group & filter
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @internal
     */
    removeGrouper(field) {
      const me = this, { groupers } = me;
      if (!groupers) {
        return;
      }
      const index = groupers.findIndex((grouper) => grouper.field === field);
      if (index > -1) {
        groupers.splice(index, 1);
        if (!groupers.length) {
          return me.clearGroupers();
        } else {
          return me.group();
        }
      }
    }
    /**
     * Removes all groupers, turning store grouping off.
     * @privateparam {Boolean} [silent=false] Pass true to suppress events.
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @category Sort, group & filter
     */
    clearGroupers(silent = false) {
      return this.setGroupers(null, { silent });
    }
    //endregion
    //region Get and check
    /**
     * Check if a record belongs to a certain group (only for the first grouping level)
     * @param {Core.data.Model} record The Record
     * @param {*} groupValue The group value
     * @returns {Boolean} True if the record belongs to the group, otherwise false
     * @category Sort, group & filter
     */
    isRecordInGroup(record, groupValue) {
      var _a3;
      if (!this.isGrouped) {
        return null;
      }
      const groupField = (_a3 = this.groupers[0]) == null ? void 0 : _a3.field;
      return record.getValue(groupField) === groupValue && !record.isSpecialRow;
    }
    isInCollapsedGroup(record) {
      const parentGroupRec = record.groupParent.get(this.id);
      return parentGroupRec == null ? void 0 : parentGroupRec.meta.collapsed;
    }
    /**
     * Returns all records in the group with specified groupValue.
     * @param {*} groupValue
     * @returns {Core.data.Model[]} Records in specified group or null if store not grouped
     * @category Sort, group & filter
     */
    getGroupRecords(groupValue) {
      if (!this.isGrouped) {
        return null;
      }
      return this.storage.values.filter((record) => this.isRecordInGroup(record, groupValue));
    }
    /**
     * Get all group titles.
     * @returns {String[]} Group titles
     * @category Sort, group & filter
     */
    getGroupTitles() {
      if (!this.isGrouped) {
        return null;
      }
      return this.getDistinctValues(this.groupers[0].field);
    }
    //endregion
    onDataChanged({ changes, action }) {
      if (this.isGrouped && // If an action flagged as requiring resort is performed...
      (!changes && resortActions[action] || // ...or if the group field has changes...
      changes && this.groupers.some((grouper) => grouper.field in changes))) {
        this.sort();
      }
    }
    /**
     * Adds or removes records in a group from storage. Used when expanding/collapsing groups.
     * @private
     * @param {Core.data.Model} groupRecord Group which records should be added or removed
     * @param {Boolean} include Include (true) or exclude (false) records
     * @category Grouping
     */
    internalIncludeExcludeGroupRecords(groupRecord, include) {
      const me = this, index = me.indexOf(groupRecord), allIndex = me.allIndexOf(groupRecord), { id: mapId, storage } = me, {
        _filteredValues,
        _values
      } = storage, {
        meta,
        groupChildren,
        unfilteredGroupChildren
      } = groupRecord;
      if (allIndex === -1 || meta.collapsed && !include || !meta.collapsed && include) {
        return;
      }
      unfilteredGroupChildren.forEach(
        (child) => child.instanceMeta(mapId).hiddenByCollapse = !include
      );
      if (include) {
        if (_filteredValues) {
          _filteredValues.splice(index + 1, 0, ...groupChildren.filter((r) => !me.isAvailable(r)));
        }
        storage._values.splice(allIndex + 1, 0, ...unfilteredGroupChildren.filter((r) => !me.isAvailable(r)));
      } else {
        if (_filteredValues) {
          _filteredValues.splice(index + 1, groupChildren.length);
        }
        _values.splice(allIndex + 1, unfilteredGroupChildren.length);
      }
      storage._indicesInvalid = true;
      me._idMap = null;
    }
    /**
     * Removes records in a group from storage. Used when collapsing a group.
     * @private
     * @param groupRecord Group which records should be removed
     * @category Grouping
     */
    excludeGroupRecords(groupRecord) {
      this.internalIncludeExcludeGroupRecords(groupRecord, false);
    }
    /**
     * Adds records in a group to storage. Used when expanding a group.
     * @private
     * @param groupRecord Group which records should be added
     * @category Grouping
     */
    includeGroupRecords(groupRecord) {
      this.internalIncludeExcludeGroupRecords(groupRecord, true);
    }
    /**
     * Collects all group headers + children, whether expanded or not
     * @private
     * @param {Boolean} allRecords True to include filtered out records
     * @param {Boolean} includeHeaders True to also include group headers
     * @returns {Core.data.Model[]}
     */
    collectGroupRecords(allRecords, includeHeaders = true) {
      const records = allRecords ? this.storage.allValues : this.storage.values;
      return records.reduce((records2, record) => {
        if (record.isSpecialRow) {
          if (includeHeaders && !record.isGroupFooter) {
            records2.push(record);
          }
          if (record.isGroupHeader) {
            records2.push.apply(records2, record.groupChildren);
          }
        }
        return records2;
      }, []);
    }
  }, __publicField(_a2, "$name", "StoreGroup"), //region Config
  __publicField(_a2, "configurable", {
    /**
     * Currently used groupers.
     * To set groupers when remote sorting is enabled by {@link Core/data/AjaxStore#config-sortParamName} you should
     * use {@link #function-setGroupers} instead to be able to wait for the operation to finish.
     * @member {Grouper[]} groupers
     * @category Sort, group & filter
     */
    /**
     * Initial groupers, specify to have store grouped automatically after initially setting data
     * @config {Grouper[]}
     * @category Common
     */
    groupers: null,
    useGroupFooters: false,
    /**
     * To have all groups __initially loaded__ start collapsed, configure this as `true`.
     *
     * Note that this only affects the initial load of the store. Subsequent reloads maintain
     * current group state where possible.
     * @config {Boolean}
     * @default false
     * @category Advanced
     */
    startGroupsCollapsed: null
  }), _a2;
};

// ../Core/lib/Core/data/mixin/StoreProxy.js
var StoreProxy_default = (Target) => class StoreProxy extends (Target || Base) {
  static get configurable() {
    return {
      /**
       * Allow object like interaction with the Store. For example:
       *
       * ```javascript
       * const store = new Store({
       *    objectify : true,
       *    data      : [
       *        { id : 'batman', name : 'Bruce' }
       *    ]
       * });
       *
       * // retrieve using id as property
       * const record = store.batman;
       *
       * // add as property
       * store.superman = { name : 'Clark' };
       *
       * // delete to remove
       * delete store.batman;
       * ``
       *
       * @config {Boolean}
       * @default false
       */
      objectify: null
    };
  }
  initProxy() {
    if (!globalThis.Proxy) {
      throw new Error("Proxy not supported");
    }
    const proxy = new Proxy(this, {
      // Support getting records using `store[id/index]
      get(target, property) {
        if (property in target) {
          return target[property];
        }
        if (property === "$store") {
          return target;
        }
        let record = target.getById(property);
        if (!record && !isNaN(parseInt(property))) {
          record = target.getAt(parseInt(property));
        }
        return record;
      },
      // Support adding/replacing records using `store.id = { ...data }`
      set(target, property, value) {
        if (property in target || target.isDestroying || property === "_triggered") {
          target[property] = value;
        } else {
          target.add({ [target.modelClass.idField]: property, ...value });
        }
        return true;
      },
      // Support deleting records using `delete store.id`
      deleteProperty(target, property) {
        if (target.isDestroying) {
          delete target[property];
          return true;
        }
        return Boolean(target.remove(property).length);
      },
      // Support `id in store`
      has(target, property) {
        if (property in target) {
          return true;
        }
        if (property.startsWith("{") && property.endsWith("}")) {
          const data = StringHelper.safeJsonParse(property);
          property = data == null ? void 0 : data.id;
        }
        return target.includes(property);
      }
    });
    return proxy;
  }
};

// ../Core/lib/Core/data/mixin/StoreRelation.js
var StoreRelation_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    //region Init
    /**
     * Initialized relations, called from constructor
     * @private
     */
    initRelations(reset) {
      const me = this, relations = me.modelClass.exposedRelations;
      if (reset && me.modelRelations) {
        me.modelRelations.forEach((relation) => {
          var _a3;
          return (_a3 = relation.storeDetacher) == null ? void 0 : _a3.call(relation);
        });
      }
      if ((!me.modelRelations || me.modelRelations.length === 0 || reset) && relations) {
        me.modelRelations = [];
        relations == null ? void 0 : relations.forEach((modelRelationConfig) => {
          const config = { ...modelRelationConfig }, {
            foreignStore,
            relationName,
            relatedCollectionName
          } = config, relatedStore = typeof foreignStore === "string" ? me[foreignStore] : foreignStore;
          config.dependentStore = me;
          me.modelRelations.push(config);
          if (relatedStore) {
            config.foreignStoreProperty = config.foreignStore;
            config.foreignStore = relatedStore;
            const dependentStoreConfigs = relatedStore.dependentStoreConfigs;
            if (dependentStoreConfigs.has(me)) {
              const dependentConfigs = dependentStoreConfigs.get(me);
              if (reset) {
                const existingConfig = dependentConfigs.find((c) => c.relationName === relationName);
                if (existingConfig) {
                  ArrayHelper.remove(dependentConfigs, existingConfig);
                }
              }
              dependentConfigs.push(config);
            } else {
              dependentStoreConfigs.set(me, [config]);
            }
            if (relatedCollectionName) {
              relatedStore.initRelationCollection(config, me);
            }
            if (relatedStore.count > 0) {
              relatedStore.updateDependentStores("dataset", relatedStore.records);
            }
          }
        });
      }
    }
    /**
     * Called from other end of a relation when this store should hold a collection of related records.
     * @private
     * @param config
     * @param collectionStore
     */
    initRelationCollection(config, collectionStore) {
      const me = this, name = config.relatedCollectionName, collectionStores = me.collectionStores || (me.collectionStores = {});
      collectionStores[name] = {
        store: collectionStore,
        config
      };
      if (!me[name + "Store"]) {
        me[name + "Store"] = collectionStore;
      }
      if (me.count > 0) {
        me.initModelRelationCollection(name, me.allRecords);
      }
    }
    initModelRelationCollection(name, records) {
      const me = this;
      records.forEach((record) => {
        record.traverse((node) => {
          const useName = name in node ? `$related${StringHelper.capitalize(name)}` : name;
          Object.defineProperty(node, useName, {
            enumerable: true,
            configurable: true,
            get: function() {
              return me.getCollection(this, name);
            },
            set: function(value) {
              return me.setCollection(this, name, value);
            }
          });
        });
      });
    }
    /**
     * Updates relationCache for all records.
     * @private
     */
    resetRelationCache() {
      this.relationCache = {};
      this.forEach((record) => record.initRelations());
    }
    /**
     * Caches related records from related store on the local store.
     * @private
     * @param record Local record
     * @param relations Relations to related store
     */
    updateRecordRelationCache(record, relations) {
      relations == null ? void 0 : relations.forEach((relation) => {
        const { config } = relation, foreignId = relation.related ? relation.related.id : record.getValue(config.foreignKey);
        foreignId !== void 0 && this.cacheRelatedRecord(record, foreignId, config.relationName, foreignId);
      });
    }
    //endregion
    //region Getters
    /**
     * Returns records the relation cache. Same result as if retrieving the collection on the dependent store, but
     * without the need of accessing that store.
     * @internal
     * @param {String} name
     * @param {Core.data.Model|String|Number} recordOrId
     * @returns {Array}
     */
    getRelationCollection(name, recordOrId) {
      var _a3;
      const id = Model.asId(recordOrId);
      return ((_a3 = this.relationCache[name]) == null ? void 0 : _a3[id]) || [];
    }
    /**
     * Returns records from a collection of related records. Not to be called directly, called from Model getter.
     * @private
     * @param {Core.data.Model} record
     * @param {String} name
     * @returns {Array}
     */
    getCollection(record, name) {
      var _a3;
      const { config, store } = this.collectionStores[name];
      return ((_a3 = store.relationCache[config.relationName]) == null ? void 0 : _a3[record.id]) || [];
    }
    /**
     * Sets a collection of related records. Will updated the related store and trigger events from it. Not to be called
     * directly, called from Model setter.
     * @private
     */
    setCollection(model, name, records) {
      const { config, store } = this.collectionStores[name], relationCache = store.relationCache[config.relationName] || (store.relationCache[config.relationName] = {}), old = (relationCache[model.id] || []).slice(), added = [], removed = [];
      store.suspendEvents();
      old.forEach((record) => {
        if (!records.includes(record)) {
          record[config.foreignKey] = null;
          store.remove(record);
          removed.push(record);
        }
      });
      records.forEach((record) => {
        if (record.isModel instanceof Model) {
          if (!record.stores.includes(store)) {
            store.add(record);
            added.push(record);
          }
        } else {
          [record] = store.add(record);
          added.push(record);
        }
        record[config.foreignKey] = model.id;
      });
      store.resumeEvents();
      if (removed.length) {
        store.trigger("remove", { records: removed });
        store.trigger("change", { action: "remove", records: removed });
      }
      if (added.length) {
        store.trigger("add", { records: added });
        store.trigger("change", { action: "add", records: added });
      }
    }
    //endregion
    //region Caching
    /**
     * Adds a record to relation cache, optionally removing it if already there.
     * @private
     * @param record
     * @param id
     * @param name
     * @param uncacheId
     */
    cacheRelatedRecord(record, id, name, uncacheId = null) {
      const me = this, cache = me.relationCache[name] || (me.relationCache[name] = {});
      if (uncacheId !== null) {
        me.uncacheRelatedRecord(record, name, uncacheId);
      }
      if (id != null) {
        ArrayHelper.include(cache[id] || (cache[id] = []), record);
      }
    }
    /**
     * Removes a record from relation cache, for a specific relation (specify relation name and id) or for all relations
     * @private
     * @param record Record to remove from cache
     * @param name Optional, relation name
     * @param id Optional, id
     */
    uncacheRelatedRecord(record, name = null, id = null) {
      const me = this;
      function remove(relationName, relatedId) {
        const cache = me.relationCache[relationName], oldCache = cache == null ? void 0 : cache[relatedId];
        if (oldCache) {
          const uncacheIndex = oldCache.indexOf(record);
          uncacheIndex >= 0 && oldCache.splice(uncacheIndex, 1);
          if (oldCache.length === 0) {
            delete cache[relatedId];
          }
        }
      }
      if (id != null) {
        remove(name, id);
      } else {
        if (record.meta.relationCache) {
          Object.entries(record.meta.relationCache).forEach(
            ([relationName, relatedRecord]) => remove(relationName, relatedRecord == null ? void 0 : relatedRecord.id)
          );
        }
      }
    }
    /**
     * Updates related stores when store is cleared, a record is removed or added.
     * @private
     * @param {String} action
     * @param {Core.data.Model[]} records
     */
    updateDependentStores(action, records) {
      this.dependentStoreConfigs.forEach((configs) => {
        configs.forEach((config) => {
          const {
            dependentStore,
            relatedCollectionName,
            relationName,
            foreignKey
          } = config, cache = dependentStore.relationCache[relationName];
          if (action === "dataset") {
            relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
            dependentStore.forEach((record) => {
              const foreign = record.initRelation(config);
              foreign && dependentStore.cacheRelatedRecord(record, foreign.id, relationName, foreign.id);
            });
            return;
          }
          if (action === "removeall") {
            dependentStore.forEach((record) => record.removeRelation(config));
            delete dependentStore.relationCache[relationName];
            return;
          }
          if (action === "replace") {
            records = records.map((r) => r[1]);
          }
          if (action === "add" || action === "replace") {
            relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
          }
          if (action === "add" || action === "replace" || action === "remove") {
            records.forEach((record) => {
              const dependentRecords = cache == null ? void 0 : cache[record.id];
              switch (action) {
                case "remove":
                  if (dependentRecords) {
                    dependentRecords.forEach((dependentRecord) => dependentRecord.removeRelation(config));
                  }
                  break;
                case "add":
                case "replace":
                  dependentStore.forEach((dependentRecord) => {
                    if (dependentRecord.getValue(foreignKey) == record.id) {
                      dependentRecord.initRelation(config);
                      dependentStore.cacheRelatedRecord(dependentRecord, record.id, relationName);
                    }
                  });
                  break;
              }
            });
          }
        });
      });
    }
    /**
     * Updates relation cache and foreign key value when a related objects id is changed.
     * @private
     */
    updateDependentRecordIds(oldValue, value) {
      var _a3;
      (_a3 = this.dependentStoreConfigs) == null ? void 0 : _a3.forEach((configs) => {
        configs.forEach((config) => {
          var _a4;
          const {
            dependentStore,
            relationName,
            foreignKey
          } = config, cache = dependentStore.relationCache[relationName], localRecords = (_a4 = cache == null ? void 0 : cache[oldValue]) == null ? void 0 : _a4.slice();
          localRecords == null ? void 0 : localRecords.forEach((localRecord) => {
            dependentStore.cacheRelatedRecord(localRecord, value, relationName, oldValue);
            localRecord.set(foreignKey, value, false, true);
          });
        });
      });
    }
    //endregion
  }, __publicField(_a2, "$name", "StoreRelation"), _a2;
};

// ../Core/lib/Core/data/mixin/StoreSum.js
var StoreSum_default = (Target) => class StoreSum extends (Target || Base) {
  static get $name() {
    return "StoreSum";
  }
  /**
   * Returns sum calculated by adding value of specified field for specified records. Defaults to using all records
   * in store
   * @param {String} field Field to summarize by
   * @param {Core.data.Model[]} records Records to summarize, uses all records if unspecified.
   * @returns {Number}
   * @category Sum
   */
  sum(field, records = this.storage.values) {
    if (!records) {
      return 0;
    }
    return records.reduce((sum, record) => {
      if (record.isSpecialRow) {
        return sum;
      }
      const v = Number(record.getValue(field));
      return isNaN(v) ? sum : sum + v;
    }, 0);
  }
  /**
   * Returns min value for the specified field, can be used with Date or Number values. Defaults to look through all records in store
   * @param {String} field Field to find min value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number|Date}
   * @category Sum
   */
  min(field, records = this.storage.values) {
    if (!(records == null ? void 0 : records.length)) {
      return 0;
    }
    return records.reduce((min2, record) => {
      const fieldValue = record.getValue(field), type = typeof (fieldValue == null ? void 0 : fieldValue.valueOf());
      if (type === "number" && fieldValue < min2) {
        min2 = fieldValue;
      }
      return min2;
    }, records[0].getValue(field));
  }
  /**
   * Returns max value for the specified field, can be used with Date or Number values. Defaults to look through all records in store
   * @param {String} field Field to find max value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number|Date}
   * @category Sum
   */
  max(field, records = this.storage.values) {
    if (!(records == null ? void 0 : records.length)) {
      return 0;
    }
    return records.reduce((max, record) => {
      const fieldValue = record.getValue(field), type = typeof (fieldValue == null ? void 0 : fieldValue.valueOf());
      if (type === "number" && fieldValue > max) {
        max = fieldValue;
      }
      return max;
    }, records[0].getValue(field));
  }
  /**
   * Returns the average value for the specified field. Defaults to look through all records in store
   * @param {String} field Field to calculate average value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number}
   * @category Sum
   */
  average(field, records = this.storage.values) {
    if (!(records == null ? void 0 : records.length)) {
      return 0;
    }
    let count = 0;
    const sum = records.reduce((sum2, record) => {
      if (record.isSpecialRow) {
        return sum2;
      }
      const v = parseFloat(record.getValue(field));
      if (!isNaN(v)) {
        count++;
        return sum2 + v;
      } else {
        return sum2;
      }
    }, 0);
    return count > 0 ? sum / count : 0;
  }
  /**
   * Returns sum by adding value of specified field for records in the group with the specified groupValue.
   * @param {*} groupValue The group to summarize
   * @param {String} field Field to summarize by
   * @returns {Number} Sum or null if store not grouped
   * @category Sum
   */
  groupSum(groupValue, field) {
    return this.sum(field, this.getGroupRecords(groupValue));
  }
};

// ../Core/lib/Core/data/mixin/StoreSearch.js
var findInString = (value, text) => String(value).toLowerCase().includes(text);
var matchFns = {
  string: findInString,
  number: findInString,
  boolean: findInString,
  date: (value, text) => {
    if (value instanceof Date && text instanceof Date) {
      return value - text === 0;
    }
    return String(value.getMonth() + 1).includes(text) || String(value.getDate()).includes(text) || String(value.getFullYear()).includes(text);
  },
  object: (value, text) => value === text,
  // typeof null === object
  undefined: (value, text) => value === text
};
var StoreSearch_default = (Target) => class StoreSearch extends (Target || Base) {
  static get $name() {
    return "StoreSearch";
  }
  //region Search (multiple hits)
  /**
   * Find all hits matching the specified input
   * @param {String} text Value to search for
   * @param {String[]} fields Fields to search value in
   * @param {Function[]} [formatters] An array of field formatting functions to format the found value
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {StoreSearchResult[]} Array of hits, in the format { index: x, data: record }
   * @category Search
   */
  search(text, fields = null, formatters, searchAllRecords) {
    const records = this.isTree && !searchAllRecords ? this.rootNode.allChildren : this.getAllDataRecords(searchAllRecords), len = records.length, found = [];
    if (text == null) {
      return [];
    }
    if (typeof text === "string") {
      text = text.toLowerCase();
    }
    let i, j, record, value, valueType, comparison;
    for (i = 0; i < len; i++) {
      record = records[i];
      j = 0;
      for (const key of fields || record.fieldNames) {
        value = record.getValue(key);
        valueType = value instanceof Date ? "date" : typeof value;
        const formatter = formatters == null ? void 0 : formatters[j];
        if (formatter) {
          value = formatter(value);
          valueType = "string";
        }
        comparison = matchFns[valueType];
        if (value && (comparison == null ? void 0 : comparison(value, text))) {
          found.push({
            index: i,
            data: record,
            field: key,
            id: record.id
          });
        }
        j++;
      }
    }
    return found;
  }
  /**
   * Find occurrences of the specified `value` in the specified `field` on all records in the store
   * @param {String} field The record field to search in
   * @param {*} value Value to search for
   * @param {Boolean} distinct True to only return distinct matches, no duplicates
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {StoreSearchResult[]} Array of hits, in the format { index: x, data: record }
   * @category Search
   */
  findByField(field, value, distinct = false, searchAllRecords = false) {
    const records = this.getAllDataRecords(searchAllRecords), len = records.length, usedValues = /* @__PURE__ */ new Set(), found = [];
    let i, record, fieldValue;
    if (value != null) {
      value = String(value).toLowerCase();
    }
    for (i = 0; i < len; i++) {
      record = records[i];
      fieldValue = record.getValue(field);
      if (!distinct || !usedValues.has(fieldValue)) {
        const type = fieldValue instanceof Date ? "date" : typeof fieldValue, matchFn = matchFns[type];
        if (value == null && fieldValue === value || value === "" && fieldValue === "" || value && matchFn(fieldValue, value)) {
          found.push({
            id: record.id,
            index: i,
            data: record
          });
          if (distinct) {
            usedValues.add(fieldValue);
          }
        }
      }
    }
    return found;
  }
  //endregion
  //region Find (single hit)
  /**
   * Finds the first record for which the specified function returns true
   * @param {Function} fn Comparison function, called with record as parameter
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model} Record or undefined if none found
   *
   * ```javascript
   * store.find(record => record.color === 'blue');
   * ```
   *
   * @category Search
   */
  find(fn, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).find(fn);
  }
  /**
   * Finds the first record for which the specified field has the specified value
   * @param {String} fieldName Field name
   * @param {*} value Value to find
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model} Record or undefined if none found
   * @category Search
   */
  findRecord(fieldName, value, searchAllRecords = false) {
    const matchFn = (r) => ObjectHelper.isEqual(r[fieldName], value);
    if (this.isTree) {
      return this.query(matchFn, searchAllRecords)[0];
    }
    return this.getAllDataRecords(searchAllRecords).find(matchFn);
  }
  /**
   * Searches the Store records using the passed function.
   * @param {Function} fn A function that is called for each record. Return true to indicate a match
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model[]} An array of the matching Records
   * @category Search
   */
  query(fn, searchAllRecords = false) {
    if (this.isTree) {
      const matches = [];
      this.traverse((node) => {
        if (fn(node)) {
          matches.push(node);
        }
      }, void 0, void 0, searchAllRecords);
      return matches;
    }
    return this.getAllDataRecords(searchAllRecords).filter(fn);
  }
  //endregion
  //region Others
  /**
   * Returns true if the supplied function returns true for any record in the store
   * @param {Function} fn A function that should return true to indicate a match
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Boolean}
   *
   * ```javascript
   * store.some(record => record.age > 95); // true if any record has age > 95
   * ```
   *
   * @category Search
   */
  some(fn, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).some(fn);
  }
  //endregion
};

// ../Core/lib/Core/data/mixin/StoreSort.js
var StoreSort_default = (Target) => class StoreSort extends (Target || Base) {
  static get $name() {
    return "StoreSort";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
       * a locale string or a locale config to enable.
       *
       * Enabling this has big negative impact on sorting
       * performance. For more info on `localeCompare()`, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
       *
       * Examples:
       *
       * ```javascript
       * const store = new Store({
       *     // Swedish sorting
       *     useLocaleSort : 'sv-SE'
       * });
       *
       * const store = new Store({
       *     // Swedish sorting with custom casing order
       *     useLocaleSort : {
       *         locale    : 'sv-SE',
       *         caseFirst : 'upper'
       *     }
       * });
       * ```
       *
       * Can also be configured on a per-sorter basis:
       *
       * ```javascript
       * store.sort({ field: 'name', useLocaleSort : 'sv-SE' });
       * ```
       *
       * @config {Boolean|String|Object}
       * @default false
       * @category Advanced
       */
      useLocaleSort: null
    };
  }
  static get configurable() {
    return {
      /**
       * Initial sorters, format is:
       * ```javascript
       * { sorters : [{ field: 'name', ascending: false }, ...] }
       * // or
       * { sorters : ['name', ...] }
       * ```
       * @config {Sorter[]|String[]}
       * @category Common
       */
      sorters: [],
      /**
       * Specify true to sort this store after records are added.
       * @config {Boolean}
       * @default
       * @category Sorting
       */
      reapplySortersOnAdd: false
    };
  }
  //endregion
  //region Events
  /**
   * Fired before sorting
   * @event beforeSort
   * @param {Core.data.Store} source This Store
   * @param {Sorter[]} sorters Sorter configs
   * @param {Core.data.Model[]} records Records to sort
   */
  /**
   * Fired after sorting
   * @event sort
   * @param {Core.data.Store} source This Store
   * @param {Sorter[]} sorters Sorter configs
   * @param {Core.data.Model[]} records Sorted records
   */
  //endregion
  //region Properties
  /**
   * Currently applied sorters
   * @member {Sorter[]} sorters
   * @readonly
   * @category Sort, group & filter
   */
  /**
   * Is store sorted?
   * @property {Boolean}
   * @readonly
   * @category Sort, group & filter
   */
  get isSorted() {
    return Boolean(this.sorters.length) || this.isGrouped;
  }
  changeSorters(sorters) {
    return sorters.map((sorter) => this.normalizeSorterConfig(sorter, true));
  }
  updateReapplySortersOnAdd(enable) {
    this.storage.autoSort = enable;
  }
  //endregion
  //region Add & remove sorters
  /**
   * Sort records, either by replacing current sorters or by adding to them.
   * A sorter can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).
   * Works in the same way as a standard array sorter, except that returning `null` triggers the stores
   * normal sorting routine.
   *
   * ```javascript
   * // single sorter
   * store.sort('age');
   *
   * // single sorter as object, descending order
   * store.sort({ field : 'age', ascending : false });
   *
   * // multiple sorters
   * store.sort(['age', 'name']);
   *
   * // using custom sorting function
   * store.sort((recordA, recordB) => {
   *     // apply custom logic, for example:
   *     return recordA.name.length < recordB.name.length ? -1 : 1;
   * });
   *
   * // using locale specific sort (slow)
   * store.sort({ field : 'name', useLocaleSort : 'sv-SE' });
   * ```
   *
   * @param {String|Sorter[]|Sorter|Function} field Field to sort by.
   * Can also be an array of {@link Core.util.CollectionSorter sorter} config objects, or a sorting function, or a
   * {@link Core.util.CollectionSorter sorter} config.
   * @param {Boolean} [ascending] Sort order.
   * Applicable when the `field` is a string (if not specified and already sorted by the field, reverts direction),
   * or an object and `ascending` property is not specified for the object. `true` by default.
   * Not applicable when `field` is a function. `ascending` is always `true` in this case.
   * @param {Boolean} [add] If `true`, adds a sorter to the sorters collection.
   * Not applicable when `field` is an array. In this case always replaces active sorters.
   * @param {Boolean} [silent] Set as true to not fire events. UI will not be informed about the changes.
   * @category Sort, group & filter
   * @fires beforeSort
   * @fires sort
   * @fires refresh
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   */
  sort(field, ascending, add = false, silent = false) {
    const me = this, records = me.allRecords, currentSorters = me.sorters ? me.sorters.slice() : [];
    let currentDir = null, curSort;
    if (field) {
      if (Array.isArray(field)) {
        me.sorters = field.map((sorter) => me.normalizeSorterConfig(sorter, typeof sorter === "string" ? true : ascending));
      } else {
        const sorter = me.normalizeSorterConfig(field, ascending);
        if (add) {
          curSort = me.getCurrentSorterByField(sorter.field);
          if (curSort) {
            currentDir = curSort.ascending;
            curSort.ascending = sorter.ascending;
          } else {
            me.sorters.push(sorter);
          }
        } else {
          me.sorters = [sorter];
        }
      }
    }
    if (!silent && me.trigger("beforeSort", { sorters: me.sorters, records, currentSorters }) === false) {
      me.sorters = currentSorters;
      if (currentDir !== null) {
        curSort.ascending = currentDir;
      }
      return null;
    }
    return me.performSort(silent);
  }
  normalizeSorterConfig(field, ascending) {
    var _a2, _b, _c;
    const me = this, sorter = { ascending };
    if (typeof field === "object") {
      ObjectHelper.assign(sorter, field);
      if (field.fn) {
        delete sorter.fn;
        sorter.sortFn = field.fn;
      }
      sorter.ascending = (_a2 = field.ascending) != null ? _a2 : ascending;
    } else if (typeof field === "function") {
      sorter.sortFn = field;
    } else {
      sorter.field = field;
    }
    if (sorter.ascending == null) {
      const curSort = me.getCurrentSorterByField(sorter.field);
      sorter.ascending = curSort ? !curSort.ascending : true;
    }
    if (sorter.sortFn == null) {
      const compareItems = (_c = (_b = me.modelClass) == null ? void 0 : _b.$meta.fields.map[sorter.field]) == null ? void 0 : _c.compareItems;
      if (compareItems) {
        sorter.sortFn = compareItems;
      }
    }
    return sorter;
  }
  getCurrentSorterByField(field) {
    return typeof field === "string" && this.sorters.find((s) => s.field === field) || null;
  }
  /**
   * Add a sorting level (a sorter).
   * @param {String|Sorter[]|Sorter|Function} field Field to sort by. Can also be an array of sorters, or a sorting
   * function, or a {@link Core.util.CollectionSorter sorter} config.
   * @param {Boolean} [ascending] Sort order (used only if field specified as string)
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  addSorter(field, ascending = true) {
    return this.sort(field, ascending, true);
  }
  /**
   * Remove a sorting level (a sorter)
   * @param {String|Function} field Stop sorting by this field (or sorter function)
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  removeSorter(field) {
    const sorterIndex = this.sorters.findIndex((sorter) => sorter.field === field || sorter.sortFn === field);
    if (sorterIndex > -1) {
      this.sorters.splice(sorterIndex, 1);
      return this.sort();
    }
  }
  /**
   * Removes all sorters, turning store sorting off.
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  clearSorters(silent = false) {
    if (this.sorters.length) {
      this.sorters.length = 0;
      return this.sort(void 0, void 0, void 0, silent);
    }
  }
  //region
  //region Sorting logic
  /**
   * Creates a function used with Array#sort when sorting the store. Override to use your own custom sorting logic.
   * @param {Sorter[]} sorters An array of sorter config objects
   * @returns {Function}
   * @category Sort, group & filter
   */
  createSorterFn(sorters) {
    const storeLocaleSort = this.useLocaleSort;
    return (lhs, rhs) => {
      for (let i = 0; i < sorters.length; i++) {
        const sorter = sorters[i], { field, ascending = true, useLocaleSort = storeLocaleSort } = sorter, fn = sorter.fn || sorter.sortFn, direction = ascending ? 1 : -1;
        if (fn) {
          const val = fn.call(sorter, lhs, rhs);
          if (val === 0) {
            continue;
          }
          if (val !== null) {
            return val * direction;
          }
        }
        const lhsValue = lhs.isModel ? lhs.getValue(field) : lhs[field], rhsValue = rhs.isModel ? rhs.getValue(field) : rhs[field];
        if (lhsValue === rhsValue) {
          continue;
        }
        if (lhsValue == null) {
          return -direction;
        }
        if (rhsValue == null) {
          return direction;
        }
        if (useLocaleSort && typeof lhsValue === "string") {
          if (useLocaleSort === true) {
            return String(lhsValue).localeCompare(rhsValue) * direction;
          }
          if (typeof useLocaleSort === "string") {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort) * direction;
          }
          if (typeof useLocaleSort === "object") {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort.locale, useLocaleSort) * direction;
          }
        }
        if (lhsValue > rhsValue) {
          return direction;
        }
        if (lhsValue < rhsValue) {
          return -direction;
        }
      }
      return 0;
    };
  }
  /**
   * The sorter function for sorting records in the store.
   * @member {Function}
   * @internal
   * @readonly
   */
  get sorterFn() {
    return this.createSorterFn(this.remoteSort ? [{ field: "_remoteSortIndex" }] : this.sorters);
  }
  /**
   * Perform sorting according to the {@link #config-sorters} configured.
   * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and
   * must not be overridden.
   * @async
   * @private
   * @category Sort, group & filter
   */
  performSort(silent) {
    const me = this, { rootNode, storage, sorterFn: sorter } = me;
    if (me.tree) {
      !me.isChained && rootNode.traverse((node) => {
        if (node.isLoaded && node.isParent) {
          node.children.sort(sorter);
          node.updateChildrenIndices(node.children, "parentIndex", true);
        }
      });
      storage.replaceValues({
        values: me.collectDescendants(rootNode).visible,
        silent: true
      });
    } else if (me.isGrouped) {
      storage.replaceValues({
        ...me.prepareGroupRecords(),
        silent: true
      });
    } else {
      storage.replaceValues({
        values: storage.values.sort(sorter),
        silent: true
      });
    }
    me.afterPerformSort(silent || me.isRemoteDataLoading);
  }
  afterPerformSort(silent) {
    if (silent) {
      return;
    }
    const me = this;
    me._idMap = null;
    const event = {
      action: "sort",
      sorters: me.sorters,
      records: me.allRecords
    };
    me.trigger("sort", event);
    me.trigger("refresh", event);
  }
  //endregion
};

// ../Core/lib/Core/data/mixin/StoreChained.js
var returnTrue = () => true;
var StoreChained_default = (Target) => class StoreChained extends (Target || Base) {
  static get $name() {
    return "StoreChained";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Function used to filter records in the masterStore into a chained store. If not provided,
       * all records from the masterStore will be included in the chained store.
       * Return `true` to include the passed record, or a `false` to exclude it.
       * @config {Function}
       * @param {Core.data.Model} record
       * @returns {Boolean}
       * @category Chained store
       */
      chainedFilterFn: null,
      /**
       * Array of field names that should trigger filtering of chained store when the fields are updated.
       * @config {String[]}
       * @category Chained store
       */
      chainedFields: null,
      /**
       * Master store that a chained store gets its records from.
       * @config {Core.data.Store}
       * @category Chained store
       */
      masterStore: null,
      /**
       * Method names calls to which should be relayed to master store.
       * @config {String[]}
       * @category Chained store
       */
      doRelayToMaster: ["add", "remove", "insert"],
      /**
       * Method names calls to which shouldn't be relayed to master store.
       * @config {String}
       * @category Chained store
       */
      dontRelayToMaster: [],
      /**
       * If true, collapsed records in original tree will be excluded from the chained store.
       * @config {Boolean}
       * @category Chained store
       */
      excludeCollapsedRecords: true,
      chainSuspended: 0
    };
  }
  // All props should be predefined to work properly with objectified stores
  static get properties() {
    return {
      chainedStores: null
    };
  }
  //endregion
  construct(config) {
    super.construct(config);
    const me = this, { masterStore } = me, sort = me.syncOrder ? "sort" : "";
    if (masterStore) {
      me.methodNamesToRelay.forEach((fnName) => me[fnName] = (...params) => me.relayToMaster(fnName, params));
      me.removeAll = (...params) => {
        masterStore.remove(me.getRange(), ...params);
      };
      masterStore.ion({
        // HACK to have chained stores react early in a async events scenario (with engine). Could be turned
        // into a config, but this way one does not have to think about it
        changePreCommit: me.onMasterDataChangedPreCommit,
        change: me.onMasterDataChanged,
        [sort]: me.onMasterDataChanged,
        prio: 1,
        thisObj: me
      });
      if (!masterStore.chainedStores) {
        masterStore.chainedStores = [];
      }
      masterStore.chainedStores.push(me);
      me.fillFromMaster();
    }
  }
  //region Properties
  // For accessing the full set of records, whether chained or not
  get $master() {
    return this.masterStore || this;
  }
  /**
   * Is this a chained store?
   * @property {Boolean}
   * @readonly
   * @category Advanced
   */
  get isChained() {
    return Boolean(this.masterStore);
  }
  set chainedFilterFn(chainedFilterFn) {
    this._chainedFilterFn = this.thisObj ? chainedFilterFn.bind(this.thisObj) : chainedFilterFn;
  }
  get chainedFilterFn() {
    return this._chainedFilterFn || returnTrue;
  }
  get methodNamesToRelay() {
    const doIsArray = Array.isArray(this.doRelayToMaster), dontIsArray = Array.isArray(this.dontRelayToMaster);
    return doIsArray && this.doRelayToMaster.filter((name) => !dontIsArray || !this.dontRelayToMaster.includes(name)) || [];
  }
  //endregion
  //region Internal
  updateChainedStores() {
    if (this.chainedStores) {
      this.chainedStores.forEach((store) => store.fillFromMaster());
    }
  }
  /**
   * Updates records available in a chained store by filtering the master store records using
   * {@link #config-chainedFilterFn}
   * @category Chained store
   */
  fillFromMaster() {
    const me = this, { masterStore, isTree } = me;
    let records = [];
    if (!me.isChained) {
      throw new Error("fillFromMaster only allowed on chained store");
    }
    if (me.isChainSuspended) {
      return;
    }
    if (masterStore.isGrouped && masterStore.isFiltered) {
      masterStore.forEach((r) => records.push(r), masterStore, { includeFilteredOutRecords: true, includeCollapsedGroupRecords: true });
    } else {
      records = masterStore.allRecords.filter((r) => !r.isSpecialRow && me.chainedFilterFn(r));
    }
    if (isTree) {
      me.idRegister = {};
      me.internalIdRegister = {};
      records.forEach((r) => {
        if (r.stores.includes(me)) {
          me.register(r);
        } else {
          r.joinStore(me);
        }
      });
      if (me.excludeCollapsedRecords) {
        const children = me.getChildren(me.rootNode);
        records = me.doIncludeExclude(children, true);
      }
    }
    me.isFillingFromMaster = true;
    me.data = records;
    me.isFillingFromMaster = false;
  }
  /**
   * Commits changes back to master.
   * - the records deleted from chained store and present in master will be deleted from master
   * - the records added to chained store and missing in master will added to master
   * Internally calls {Store#function-commit commit()}.
   * @returns {Object} Changes, see Store#changes
   * @internal
   */
  commitToMaster() {
    const me = this, master = me.masterStore;
    if (!me.isChained) {
      throw new Error("commitToMaster only allowed on chained store");
    }
    master.beginBatch();
    master.remove(me.removed.values);
    master.add(me.added.values);
    master.endBatch();
    return me.commit();
  }
  /**
   * Relays some function calls to the master store
   * @private
   */
  relayToMaster(fnName, params) {
    return this.masterStore[fnName](...params);
  }
  // HACK, when used with engine the chained store will catch events early (sync) and prevent late (async) listeners
  onMasterDataChangedPreCommit(event) {
    this.onMasterDataChanged(event);
    this.$masterEventhandled = true;
  }
  /**
   * Handles changes in master stores data. Updates the chained store accordingly
   * @private
   */
  onMasterDataChanged({ action, changes, $handled, isMove }) {
    var _a2;
    if (this.$masterEventhandled) {
      this.$masterEventhandled = false;
      return;
    }
    if (isMove && action === "remove") {
      return;
    }
    if (action !== "update" || ((_a2 = this.chainedFields) == null ? void 0 : _a2.some((field) => field in changes))) {
      this.fillFromMaster();
    }
  }
  //endregion
  //region public API
  /**
   * Creates a chained store, a new Store instance that contains a subset of the records from current store.
   * Which records is determined by a filtering function, which is reapplied when data in the base store changes.
   *
   * ```javascript
   * const oldies = store.makeChained(record => record.age > 50);
   * // or use a simple query
   * const ages = store.makeChained(() => store.allRecords.distinct('age')));
   * ```
   *
   * If this store is a {@link Core.data.mixin.StoreTree#property-isTree tree} store, then the resulting chained store
   * will be a tree store sharing the same root node, but only child nodes which pass the `chainedFilterFn` will be
   * considered when iterating the tree through the methods such as
   * {@link Core.data.Store#function-traverse} or {@link Core.data.Store#function-forEach}.
   *
   * @param {Function} [chainedFilterFn] Either a filter function called for every record to determine if it should be
   * included (return true / false), or a query function called with no arguments (see example below). Defaults to
   * including all records (fn always returning true)
   * @param {String[]} [chainedFields] Array of fields that trigger filtering when they are updated
   * @param {StoreConfig} [config] Additional chained store configuration. See {@link Core.data.Store#configs}
   * @param {Class} [config.storeClass] The Store class to use if this Store type is not required.
   * @returns {Core.data.Store}
   * @category Chained store
   */
  makeChained(chainedFilterFn = returnTrue, chainedFields, config) {
    if (this.isChained) {
      const newChainedFilterFn = chainedFilterFn;
      chainedFilterFn = (r) => newChainedFilterFn(r) && this.chainedFilterFn(r);
    }
    return new ((config == null ? void 0 : config.storeClass) || this.constructor)({
      // Don't copy the legacy storeId, see Store#construct
      storeId: void 0,
      id: `${this.id}-chained-${StringHelper.generateUUID()}`,
      // Make sure we don't share instanceMeta with the master store
      ...config || {},
      tree: false,
      autoTree: false,
      // If someone ever chains a chained store, chain master instead
      masterStore: this.$master,
      modelClass: this.modelClass,
      // Chained store should never use syncDataOnLoad, that will create an infinite loop when they determine
      // that a record is added and then add it to master, repopulating this store and round we go
      syncDataOnLoad: false,
      chainedFilterFn,
      chainedFields
    });
  }
  /**
   * Alias for {@link Core.data.Store#function-makeChained}
   *
   * @param {Function} [chainedFilterFn] Either a filter function called for every record to determine if it should be
   * included (return true / false), or a query function called with no arguments (see example below). Defaults to
   * including all records (fn always returning true)
   * @param {String[]} [chainedFields] Array of fields that trigger filtering when they are updated
   * @param {StoreConfig} [config] Additional chained store configuration. See {@link Core.data.Store#configs}
   * @param {Class} [config.storeClass] The Store class to use if this Store type is not required.
   * @returns {Core.data.Store}
   * @category Chained store
   */
  chain() {
    return this.makeChained(...arguments);
  }
  //endregion
  doDestroy() {
    var _a2;
    (_a2 = this.chainedStores) == null ? void 0 : _a2.forEach((chainedStore) => chainedStore.destroy());
    super.doDestroy();
  }
  suspendChain() {
    this.chainSuspended++;
  }
  resumeChain(refill = false) {
    if (this.chainSuspended && !--this.chainSuspended && refill) {
      this.fillFromMaster();
    }
  }
  get isChainSuspended() {
    return this.chainSuspended > 0;
  }
};

// ../Core/lib/Core/data/mixin/StoreState.js
var StoreState_default = (Target) => class StoreState extends (Target || Base) {
  static get $name() {
    return "StoreState";
  }
  /**
   * Get store state. Used by State-plugin to serialize state
   * @private
   * @returns {{ sorters, groupers }}
   */
  getState() {
    const { sorters, groupers, filters } = this, state = {};
    if (sorters == null ? void 0 : sorters.length) {
      state.sorters = sorters.map((sorter) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(sorter));
        delete clone.fn;
        delete clone.sortFn;
        return clone;
      });
    }
    if (groupers == null ? void 0 : groupers.length) {
      state.groupers = groupers.map((grouper) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(grouper));
        delete clone.fn;
        return clone;
      });
    }
    if (filters == null ? void 0 : filters.values.length) {
      state.filters = filters.values.map((filter) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(filter.config));
        clone.value = filter.value;
        if (clone.caseSensitive) {
          delete clone.caseSensitive;
        }
        return clone;
      });
    }
    return state;
  }
  /**
   * Apply store state. Used by State-plugin to restore a previously serialized state
   * @private
   * @param {{ sorters, groupers }} state
   */
  applyState(state) {
    const me = this, {
      sorters = [],
      groupers = [],
      filters = []
    } = state, {
      sortParamName,
      filterParamName
    } = me;
    me.sorters = sorters.filter((sorter) => sorter.field || sorter.sortFn && !sortParamName);
    me.groupers = groupers.slice();
    me.sort();
    me.filters = filters.filter((filter) => filter.property || filter.filterBy && !filterParamName);
    me.filter();
  }
};

// ../Core/lib/Core/data/Wbs.js
var zeroPad = (v) => String(v).padStart(6, "0");
var Wbs = class _Wbs {
  /**
   * Wbs constructor.
   * @param {String|Number} value The value of WBS
   */
  constructor(value) {
    this.value = value;
    this._padded = null;
  }
  /**
   * The WBS value
   * @readonly
   * @member {String} value
   */
  set value(value) {
    this._value = String(value != null ? value : "");
  }
  get value() {
    return this._value;
  }
  /**
   * Returns a `Wbs` instance given a `value`. If the `value` is already a `Wbs` object, it is returned. Otherwise,
   * a new `Wbs` is created. If `value` is `null` or `undefined`, that value is returned.
   * @param {String|Number|Core.data.Wbs} value
   * @returns {Core.data.Wbs}
   */
  static from(value) {
    return value == null ? value : value instanceof _Wbs ? value : new _Wbs(value);
  }
  /**
   * Returns a WBS code where each component is 0-padded on the left to 6 digits. That is "1.2" is padded to be
   * "000001.000002". These values can be compared for proper semantic order (e.g., Wbs.pad('1.2') < Wbs.pad('1.10')).
   * @param {String|Number|Core.data.Wbs} value
   * @returns {String}
   * @private
   */
  static pad(value) {
    return value instanceof _Wbs ? value.valueOf() : _Wbs.split(value).map(zeroPad).join(".");
  }
  /**
   * Returns an array of digits from a given WBS code `value`. If the value cannot be converted, an empty array is
   * returned.
   * @param {String|Number|Core.data.Wbs} value
   * @returns {Number[]}
   * @private
   */
  static split(value) {
    let i, ret;
    if (value || value === 0) {
      switch (typeof value) {
        case "object":
          value = String(value);
        case "string":
          ret = value.split(".");
          for (i = ret.length; i-- > 0; ) {
            ret[i] = parseInt(ret[i], 10);
          }
          break;
        case "number":
          ret = [value];
          break;
      }
    }
    return ret || [];
  }
  /**
   * Compares two WBS values, returning 0 if equal, -1 if `lhs` is less than `rhs, or 1 if `lhs` is greater than `rhs`.
   * @param {String|Core.data.Wbs} lhs
   * @param {String|Core.data.Wbs} rhs
   * @returns {Number}
   */
  static compare(lhs, rhs) {
    if (lhs === rhs) {
      return 0;
    }
    if (!lhs || !rhs) {
      return lhs ? 1 : rhs ? -1 : 0;
    }
    lhs = _Wbs.pad(lhs);
    rhs = _Wbs.pad(rhs);
    return lhs < rhs ? -1 : rhs < lhs ? 1 : 0;
  }
  /**
   * Appends a sub-level WBS value to this WBS code and returns a `Wbs` instance for it.
   * @param {String|Number} value
   * @returns {Core.data.Wbs}
   */
  append(value) {
    const s = this.value;
    return _Wbs.from(s ? `${s}.${value}` : value);
  }
  /**
   * Returns truthy value if this Wbs equals the passed value.
   * @param {String|Core.data.Wbs} value
   * @returns {Boolean}
   */
  isEqual(value) {
    return !_Wbs.compare(this, value);
  }
  /**
   * Compares this WBS value with a specified pattern, returning `true` if they match. If the `pattern` is simply a
   * sequence of digits and decimal points (e.g., "1.2"), it is a match if it is a substring of this WBS code (e.g.,
   * "3.1.2.4"). If the `pattern` starts with `*` (e.g., "*.1.2"), it is a match if this WBS code ends with the text
   * following the `*` (e.g., "4.3.1.2"). If the `pattern` ends with `*`, it is a match if this WBS code starts with
   * the text up to the `*`.
   *
   * Some examples:
   * ```
   *  console.log(Wbs.from('1.2.3.4').match('2.3'));
   *  > true
   *  console.log(Wbs.from('1.2.3.4').match('*.4'));
   *  > true
   *  console.log(Wbs.from('1.2.3.4').match('1.2.*'));
   *  > true
   *
   *  console.log(Wbs.from('1.2.3.4').match('2.4'));
   *  > false
   *  console.log(Wbs.from('1.2.3.4').match('*.3'));
   *  > false
   *  console.log(Wbs.from('1.2.3.4').match('2.*'));
   *  > false
   * ```
   * @param {String} pattern A partial WBS code (e.g., "1.2"), optionally starting or ending with `*`.
   * @returns {Boolean}
   */
  match(pattern) {
    let ret = false;
    if (pattern) {
      const wbs = this.value, globLeft = pattern[0] === "*", globRight = pattern.endsWith("*"), n = pattern.length;
      if (globLeft === globRight) {
        ret = wbs.indexOf(globLeft ? pattern.substr(1, n - 2) : pattern) > -1;
      } else if (globLeft) {
        ret = wbs.endsWith(pattern.substr(1));
      } else {
        ret = wbs.startsWith(pattern.substr(0, n - 1));
      }
    }
    return ret;
  }
  toString() {
    return this.value;
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    var _a2;
    return (_a2 = this._padded) != null ? _a2 : this._padded = _Wbs.pad(this.value);
  }
};
Wbs._$name = "Wbs";

// ../Core/lib/Core/data/mixin/StoreTree.js
var emptyArray4 = Object.freeze([]);
var StopBranch = Symbol("StopBranch");
var StoreTree_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get StopBranch() {
      return StopBranch;
    }
    //region Getters
    /**
     * True if this Store is configured to handle tree data (with `tree : true`) or if this is a
     * {@link Core.data.Store#function-makeChained chained store} and the master store is a tree store.
     * @property {Boolean}
     * @readonly
     * @category Tree
     */
    get isTree() {
      return this.tree || this.masterStore && this.masterStore.tree;
    }
    /**
     * Returns all leaf records in a tree store
     * @property {Core.data.Model[]}
     * @category Tree
     */
    get leaves() {
      const me = this, result = [];
      if (me.isTree) {
        me.traverse((record) => {
          if (record.isLeaf) {
            result.push(record);
          }
        });
        return result;
      } else {
        me.allRecords.forEach((r) => {
          if (r.isLeaf) {
            result.push(r);
          }
          r.traverse((record) => {
            if (record.isLeaf) {
              result.push(record);
            }
          }, true);
        });
      }
      return result;
    }
    //endregion
    //region Children
    /**
     * Loads children for a parent node that uses load on demand (when expanding it). Base implementation does nothing,
     * either use AjaxStore which implements it, create your own subclass with an implementation or listen for
     * `toggleNode` and insert records when you have them available.
     * @param {Core.data.Model} parentRecord
     * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
     * vetoed by a {@link Core.data.AjaxStore#event-beforeLoadChildren} handler, or if an {@link Core.data.AjaxStore#event-exception} is detected.
     * The resolved function is passed the event object passed to any event handlers.
     * The rejected function is passed the {@link Core.data.AjaxStore#event-exception} event if an exception occurred,
     * or `false` if the load was vetoed by a {@link Core.data.AjaxStore#event-beforeLoadChildren} handler.
     * @category Tree
     */
    async loadChildren(parentRecord) {
    }
    /**
     * Called from Model when adding children. Not to be called directly, use Model#appendChild() instead.
     * @internal
     * @param {Core.data.mixin.TreeNode} parent
     * @param {Core.data.mixin.TreeNode[]} children
     * @param {Number} index
     * @param {Object} isMove
     * @param {Boolean} [silent]
     * @fires add
     * @fires change
     * @category Tree
     */
    onNodeAddChild(parent, children, index, isMove, silent = false) {
      var _a3;
      const me = this, isRootLoad = parent === me.rootNode && parent.isLoading, { storage } = me, { previousSibling } = children[0];
      let storeInsertionPoint;
      const { visible: toAddToUI, all: toAdd } = me.collectDescendants(children, void 0, void 0, {
        inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me)),
        applyFilter: me.isFiltered && me.reapplyFilterOnAdd
      });
      if (!isRootLoad && toAdd.length) {
        for (const record of toAdd) {
          if (!me.modified.includes(record) && !isMove[record.id]) {
            if (me.removed.includes(record)) {
              me.removed.remove(record);
            } else if (!record.isLinked) {
              me.added.add(record);
            }
          }
        }
      }
      if (isRootLoad && me.rootVisible) {
        toAddToUI.unshift(parent);
        toAdd.unshift(parent);
      }
      if (toAddToUI.length) {
        if (index === 0 || !previousSibling) {
          storeInsertionPoint = storage.indexOf(parent);
        } else {
          storeInsertionPoint = storage.indexOf(previousSibling) + previousSibling.getDescendantCount(true, me);
        }
        storage.suspendEvents();
        me.storage.splice(++storeInsertionPoint, 0, toAddToUI);
        storage.resumeEvents();
        me._idMap = null;
      } else {
        me._allRecords = null;
      }
      me.updateDependentStores("add", children);
      if (isRootLoad && toAddToUI.length) {
        if (me.sorters.length) {
          me.sort(null, null, false, true);
        }
        (_a3 = me.afterLoadData) == null ? void 0 : _a3.call(me);
        if (!silent) {
          const event = { action: "dataset", data: me._data, records: toAddToUI };
          me.trigger("refresh", event);
          me.trigger("change", event);
        }
      } else if (!silent) {
        const event = { action: "add", parent, isChild: true, isMove, records: children, allRecords: toAdd, index: storeInsertionPoint };
        me.trigger("add", event);
        me.trigger("change", event);
        if (Object.values(isMove).some((wasMoved) => wasMoved)) {
          const event2 = {
            newParent: parent,
            records: children.filter((record) => isMove[record.id]),
            oldParents: children.map((child) => {
              return me.getById(child.meta.oldParentId);
            })
          };
          me.trigger("move", event2);
        }
      }
    }
    onNodeRemoveChild(parent, children, index, flags = { isMove: false, silent: false, unfiltered: false }) {
      const me = this, { storage } = me, toRemoveFromUI = [], toRemove = [], { isMove, silent, unfiltered } = flags, removeUnfiltered = unfiltered && me.isFiltered, childrenToRemove = removeUnfiltered && parent.unfilteredChildren ? parent.unfilteredChildren : children;
      me.collectDescendants(childrenToRemove, toRemoveFromUI, toRemove, { inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me)), unfiltered: removeUnfiltered });
      if (!isMove) {
        for (const record of children) {
          record.unjoinStore(me);
        }
        for (const record of toRemove) {
          if (record.stores.includes(me)) {
            record.unjoinStore(me);
          }
          if (me.added.includes(record)) {
            me.added.remove(record);
          } else if (!record.isLinked) {
            me.removed.add(record);
          }
        }
        me.modified.remove(toRemove);
      }
      if (toRemoveFromUI.length) {
        index = storage.indexOf(toRemoveFromUI[0]);
        if (index > -1) {
          storage.suspendEvents();
          storage.splice(index, toRemoveFromUI.length);
          storage.resumeEvents();
          me._idMap = null;
        }
      } else {
        index = -1;
        me._allRecords = null;
      }
      if (!silent && (me.fireRemoveEventForMoveAction || !isMove)) {
        const event = {
          action: "remove",
          parent,
          isChild: true,
          isMove,
          records: children,
          allRecords: toRemove,
          index
        };
        me.trigger("remove", event);
        me.trigger("change", event);
      }
      return toRemove;
    }
    // IMPORTANT when using `applyFilter` option, should use the return value of this function
    // instead of relying on arguments mutation
    collectDescendants(node, visible = [], all = [], flags = {}) {
      var _a3;
      const me = this, { inCollapsedBranch = false, unfiltered = false, applyFilter = false } = flags, children = Array.isArray(node) ? node : (_a3 = me.getChildren(node, unfiltered)) != null ? _a3 : [];
      if (applyFilter) {
        return {
          visible: children.flatMap((child) => this.collectVisibleNodeDescendantsFiltered(child)),
          all: children.flatMap((child) => child.allChildren)
        };
      } else {
        for (let i = 0, len = children.length, child; i < len; i++) {
          child = children[i];
          if (!inCollapsedBranch) {
            visible.push(child);
          }
          all.push(child);
          me.collectDescendants(child, visible, all, {
            inCollapsedBranch: inCollapsedBranch || !child.isExpanded(me),
            unfiltered
          });
        }
        return { visible, all };
      }
    }
    collectVisibleNodeDescendantsFiltered(node) {
      const children = node.unfilteredChildren || node.children;
      if (!children || children.length === 0 || !node.isLeaf && !node.isExpanded(this)) {
        return this.filtersFunction(node) ? [node] : [];
      }
      const filteredChildren = children.flatMap((child) => this.collectVisibleNodeDescendantsFiltered(child));
      return filteredChildren.length || this.filtersFunction(node) ? [node, ...filteredChildren] : [];
    }
    /**
     * Returns the children of the passed branch node which this store owns. By default, this
     * is the entire `children` array.
     *
     * **If this store {@link Core.data.mixin.StoreChained#property-isChained isChained}**, then
     * this returns only the subset of children which are filtered into this store by the
     * {@link Core.data.mixin.StoreChained#config-chainedFilterFn chainedFilterFn}.
     * @param {Core.data.Model} parent The node to return the children of.
     * @returns {Core.data.Model[]}
     * @category Tree
     */
    getChildren(parent, unfiltered = false) {
      const me = this, children = (unfiltered || me.isChained) && parent.unfilteredChildren || parent.children;
      return !(children == null ? void 0 : children.length) ? emptyArray4 : me.isChained ? children.filter(me.chainedFilterFn).sort(me.sorterFn) : children;
    }
    /**
     * Includes or excludes all records beneath parentRecord in storage. Used when expanding or collapsing
     * nodes.
     * @private
     * @param parentRecord Parent record
     * @param include Include (true) or exclude (false)
     * @category Tree
     */
    internalToggleTreeSubRecords(parentRecord, include) {
      const me = this, { storage } = me, index = storage.indexOf(parentRecord), children = me.doIncludeExclude(me.getChildren(parentRecord), include);
      if (me.isFiltered && include && parentRecord.unfilteredChildren) {
        me.updateChildrenHiddenState(parentRecord);
      }
      if (children.length && index !== false) {
        storage.suspendEvents();
        if (include) {
          storage.splice(index + 1, 0, ...children);
          const event = { action: "add", isExpand: true, records: children, index: index + 1 };
          me.trigger("add", event);
          me.trigger("change", event);
        } else {
          storage.splice(index + 1, children.length);
          const event = { action: "remove", isCollapse: true, records: children, index: index + 1 };
          me.trigger("remove", event);
          me.trigger("change", event);
        }
        storage.resumeEvents();
        me._idMap = null;
      }
    }
    // Updates the hidden flag of its children while store is filtered
    updateChildrenHiddenState(parentRecord) {
      var _a3;
      (_a3 = parentRecord.unfilteredChildren) == null ? void 0 : _a3.forEach((child) => {
        child.instanceMeta(this.id).hidden = false;
        if (!child.isLeaf) {
          this.updateChildrenHiddenState(child);
        }
      });
    }
    doIncludeExclude(children, include, result = []) {
      const me = this, childCount = (children == null ? void 0 : children.length) || 0;
      for (let i = 0; i < childCount; i++) {
        const child = children[i];
        if (!me.isChained || me.chainedFilterFn(child)) {
          const mapMeta = child.instanceMeta(me.id);
          if (include || !mapMeta.hidden) {
            result.push(child);
          }
          mapMeta.hidden = !include;
          if (child.isExpanded(me)) {
            me.doIncludeExclude(me.getChildren(child), include, result);
          }
        }
      }
      return result;
    }
    /**
     * Collapse an expanded record or expand a collapsed. Optionally forcing a certain state.
     * @param {String|Number|Core.data.Model} idOrRecord Record (the record itself) or id of a record to toggle
     * @param {Boolean} [collapse] Force collapse (true) or expand (false)
     * @category Tree
     */
    async toggleCollapse(idOrRecord, collapse) {
      const me = this, record = me.getById(idOrRecord), meta = record.instanceMeta(me);
      if (collapse === void 0) {
        collapse = !meta.collapsed;
      }
      if (!meta.isLoadingChildren && !record.isLeaf && record.isExpanded(me) === collapse) {
        me.trigger("beforeToggleNode", { record, collapse });
        meta.collapsed = collapse;
        if (meta.collapsed) {
          me.onNodeCollapse(record);
          return true;
        } else {
          me.onNodeExpand(record);
          let success = true;
          if (!record.isLoaded) {
            meta.isLoadingChildren = true;
            try {
              await me.loadChildren(record);
            } catch (exception) {
              meta.collapsed = true;
              success = false;
              me.trigger("loadChildrenException", { record, exception });
            } finally {
              meta.isLoadingChildren = false;
            }
          }
          return success;
        }
      }
    }
    /**
     * Remove all records beneath parentRecord from storage.
     * @private
     * @param parentRecord Parent record
     * @category Tree
     */
    onNodeCollapse(parentRecord) {
      if (parentRecord.ancestorsExpanded(this)) {
        return this.internalToggleTreeSubRecords(parentRecord, false);
      }
    }
    /**
     * Add all records beneath parentRecord from storage.
     * @private
     * @param parentRecord Parent record
     * @category Tree
     */
    onNodeExpand(parentRecord) {
      if (parentRecord.ancestorsExpanded(this)) {
        return this.internalToggleTreeSubRecords(parentRecord, true);
      }
    }
    //endregion
    //region Transform flat data
    /**
     * Transforms flat data containing parent ids into tree data
     * @param {Object[]} data Flat raw data
     * @returns {Object[]} Tree data
     * @private
     */
    transformToTree(data) {
      const { parentIdField, idField, childrenField } = this.modelClass, indexById = /* @__PURE__ */ new Map(), parentIds = /* @__PURE__ */ new Set(), transformed = [];
      for (const node of data) {
        const id = node[idField];
        if (id != null) {
          indexById.set(id, node);
        }
      }
      const cloneParent = (node) => {
        const clone = Object.assign({}, node);
        clone[childrenField] = [];
        indexById.set(clone[idField], clone);
        parentIds.add(node[idField]);
        return clone;
      };
      for (let node of data) {
        const nodeId = node[idField];
        if (parentIds.has(nodeId)) {
          node = indexById.get(nodeId);
        } else {
          node = cloneParent(node);
        }
        const parentId = node[parentIdField];
        if (parentId != null) {
          let parent = indexById.get(parentId);
          if (parent) {
            if (!parent[childrenField]) {
              parent = cloneParent(parent);
            }
            parent[childrenField].push(node);
          }
        } else {
          if (node[childrenField]) {
            transformed.push(node);
          } else if (node[idField] != null) {
            transformed.push(cloneParent(node));
          } else {
            transformed.push(node);
          }
        }
      }
      indexById.forEach((parent) => {
        var _a3, _b;
        (_b = (_a3 = parent[childrenField]).sort) == null ? void 0 : _b.call(_a3, (child1, child2) => child1.parentIndex - child2.parentIndex);
      });
      return transformed;
    }
    /**
     * Transforms data into a tree with parent levels based on supplied fields.
     *
     * ```javascript
     * const newRoot = store.treeify(['name', r => r.age % 10]);
     * ```
     *
     * Generated parent records are indicated with `generatedParent` and `key` properties. The first one is set to
     * `true` and the latter one has a value for the group the parent represents.
     *
     * @param {Array<String|Function>} fields The field names, or a function to call to extract a value to create parent
     * nodes for records with the same value.
     * @param {Function} [parentTransform] A function which is called to allow the caller to transform the raw data
     * object of any newly created parent nodes.
     * @param {Boolean} [convertParents] Pass `true` to convert raw new parent data objects to this Store's
     * {@link Core.data.Store#config-modelClass}.
     * @returns {Core.data.Model} New root node
     * @internal
     */
    treeify(fields, parentTransform, convertParents = false) {
      const { length } = fields, parents = [], orphans = [], newRoot = {};
      let i, lastParents;
      for (i = 0; i < length; i++) {
        let field = fields[i];
        field = field.field || field;
        if (!fields[i].call) {
          fields[i] = (n) => n[field];
          fields[i].fieldName = field;
        }
        parents[i] = /* @__PURE__ */ new Map();
      }
      this.rootNode.traverse((n) => {
        var _a3;
        lastParents = [];
        if (n.isLeaf) {
          for (i = 0; i < length; i++) {
            const lastParentPath = ((_a3 = lastParents[(lastParents == null ? void 0 : lastParents.length) - 1]) == null ? void 0 : _a3.path) || "", nodeMap = parents[i], keys = ArrayHelper.asArray(fields[i](n)) || [], newParents = [];
            if (keys[0] === StopBranch) {
              break;
            }
            for (let j = 0, { length: length2 } = keys; j < length2; j++) {
              const key = keys[j], path = `${lastParentPath + ((key == null ? void 0 : key.isModel) ? key.id : key)}/`, id = StringHelper.makeValidDomId(`generated_${path}`, "_"), field = fields[i].fieldName, parent = nodeMap.get(id) || nodeMap.set(id, {
                id,
                key,
                path,
                expanded: true,
                readOnly: true,
                children: [],
                generatedParent: true,
                field,
                firstGroupChild: n
              }).get(id);
              newParents.push(parent);
            }
            lastParents.forEach((lastParent) => {
              newParents.forEach((parent) => {
                if (!lastParent.children.includes(parent)) {
                  lastParent.children.push(parent);
                }
              });
            });
            lastParents = newParents;
          }
          if (lastParents.length) {
            lastParents.forEach((lastParent, j) => lastParent.children.push(j ? n.link() : n));
          } else {
            orphans.push(n);
          }
        }
      }, true);
      if (parentTransform || convertParents) {
        parents.forEach((p) => p.forEach((p2, id, map) => {
          parentTransform == null ? void 0 : parentTransform(p2);
          if (convertParents) {
            p2 = this.createRecord(p2);
            map.set(id, p2);
          }
        }));
      }
      newRoot.children = [...parents[0].values(), ...orphans];
      const sort = (n) => {
        if (n.children) {
          n.children.sort((lhs, rhs) => {
            if (lhs.isLeaf === rhs.isLeaf) {
              if (lhs.isLeaf) {
                let result;
                for (let i2 = 0; !result && i2 < length; i2++) {
                  const lv = fields[i2](lhs), rv = fields[i2](rhs);
                  if (lv === StopBranch || rv === StopBranch) {
                    return lhs.isLeaf < rhs.isLeaf ? -1 : lhs.isLeaf > rhs.isLeaf ? 1 : 0;
                  }
                  result = lv < rv ? -1 : rv > lv ? 1 : 0;
                }
                return result;
              } else if (typeof lhs.key === "string" && typeof rhs.key === "string") {
                return lhs.key.localeCompare(rhs.key, void 0, { numeric: true });
              } else {
                return lhs.key < rhs.key ? -1 : lhs.key > rhs.key ? 1 : 0;
              }
            } else {
              return lhs.isLeaf < rhs.isLeaf ? -1 : lhs.isLeaf > rhs.isLeaf ? 1 : 0;
            }
          });
          n.children.forEach(sort);
        }
      };
      sort(newRoot);
      return newRoot;
    }
    //endregion
    treeifyFlatData(data) {
      const { childrenField, parentIdField } = this.modelClass;
      let hasParentId = false, shouldTransform = true;
      for (const node of data) {
        if (node.isModel || Array.isArray(node[childrenField])) {
          shouldTransform = false;
          break;
        }
        if (node[parentIdField] != null) {
          hasParentId = true;
        }
      }
      if (shouldTransform && hasParentId) {
        data = this.transformToTree(data);
      }
      return data;
    }
    /**
     * Increase the indentation level of one or more nodes in the tree
     * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to indent.
     * @fires indent
     * @fires change
     * @category Tree
     */
    async indent(nodes) {
      const me = this;
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes = nodes.filter((node) => {
        let result = Boolean(node.previousSibling);
        while (result && !node.isRoot) {
          result = !nodes.includes(node.parent);
          node = node.parent;
        }
        return result;
      });
      if (nodes.length && me.trigger("beforeIndent", { records: nodes }) !== false) {
        nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
        me.beginBatch();
        for (const node of nodes) {
          const newParent = node.previousSibling;
          newParent.appendChild(node);
          me.toggleCollapse(newParent, false);
        }
        me.endBatch();
        me.trigger("indent", { records: nodes });
        me.trigger("change", {
          action: "indent",
          records: nodes
        });
      }
    }
    /**
     * Decrease the indentation level of one or more nodes in the tree
     * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to outdent.
     * @fires outdent
     * @fires change
     * @category Tree
     */
    async outdent(nodes) {
      const me = this;
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes = nodes.filter((node) => {
        const { parent } = node;
        let result = parent && !parent.isRoot;
        while (result && !node.isRoot) {
          result = !nodes.includes(parent);
          node = node.parent;
        }
        return result;
      });
      if (nodes.length && me.trigger("beforeOutdent", { records: nodes }) !== false) {
        nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
        me.beginBatch();
        for (const node of nodes) {
          const { parent } = node, newChildren = parent.children.slice(parent.children.indexOf(node) + 1);
          parent.parent.insertChild(node, parent.nextSibling);
          node.appendChild(newChildren);
          me.toggleCollapse(node, false);
        }
        me.endBatch();
        me.trigger("outdent", { records: nodes });
        me.trigger("change", {
          action: "outdent",
          records: nodes
        });
      }
    }
  }, __publicField(_a2, "$name", "StoreTree"), /**
   * A special `Symbol` signalizing treeify method that the current record grouping should be stopped.
   *
   * ```javascript
   * const newRoot = workerStore.treeify([
   *     // group workers by company
   *     worker => {
   *         // if the worker is unemployed we don't put it in a group
   *         // we just show such record on the root level
   *         if (!worker.company) {
   *             return Store.StopBranch
   *         }
   *
   *         return worker.company;
   *     ]
   * ]);
   * ```
   * @member {Symbol} StopBranch
   * @static
   * @category Advanced
   */
  __publicField(_a2, "StopBranch", StopBranch), __publicField(_a2, "configurable", {
    /**
     * Set to `true` to on load transform a flat dataset with raw objects containing `parentId` into the format
     * expected for tree data.
     *
     * Example input format:
     *
     * ```javascript
     * [
     *   { id : 1, name : 'Parent' },
     *   { id : 2, name : 'Child', parentId : 1 }
     * ]
     * ```
     *
     * Will be transformed into:
     *
     * ```javascript
     * [
     *   {
     *     id       : 1,
     *     name     : 'Parent',
     *     children : [
     *       { id : 2, name : 'Child', parentId : 1 }
     *     ]
     *   }
     * ]
     * ```
     *
     * @config {Boolean}
     * @category Tree
     */
    transformFlatData: null,
    /**
     * This flag prevents firing of 'remove' event when moving a node in the tree. In 6.0 this will be the default
     * behavior and this flag will be removed.
     * @config {Boolean}
     * @category Tree
     */
    fireRemoveEventForMoveAction: VersionHelper.checkVersion("core", "6.0", "<")
  }), _a2;
};

// ../Core/lib/Core/helper/WalkHelper.js
var WalkHelper = class {
  /**
   * Pre-walks any hierarchical data structure
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static preWalk(data, childrenFn, fn) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack.pop();
      fn(node);
      children = childrenFn(node);
      if (children) {
        walkStack.push.apply(walkStack, children.slice().reverse());
      }
    }
  }
  /**
   * Pre-walks any hierarchical data structure, passing along a link to the parent node
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry, called with `parent` and `node`
   */
  static preWalkWithParent(data, childrenFn, fn) {
    const walkStack = [{ node: data, parent: null }];
    while (walkStack.length) {
      const { parent, node } = walkStack.pop();
      fn(parent, node);
      const children = childrenFn(node);
      if (Array.isArray(children)) {
        walkStack.push(...children.slice().reverse().map((child) => ({ node: child, parent: node })));
      }
    }
  }
  /**
   * Pre-walk unordered.
   *
   * Like {@link #function-preWalk-static} but doesn't reverse children before walk,
   * thus children will be walked last child first - first child last
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static preWalkUnordered(data, childrenFn, fn) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack.pop();
      fn(node);
      children = childrenFn(node);
      if (children) {
        walkStack.push.apply(walkStack, children);
      }
    }
  }
  /**
   * Post-walks any hierarchical data structure
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static postWalk(data, childrenFn, fn) {
    const visited = /* @__PURE__ */ new Map(), walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        fn(node);
        walkStack.pop();
      } else {
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
  /**
   * Pre-/Post-walks any hierarchical data structure calling inFn each node when it walks in,
   * and outFn when it walks out.
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} inFn  Function to call on each entry upon enter
   * @param {Function} outFn Function to call on each entry upon exit
   */
  static prePostWalk(data, childrenFn, inFn, outFn) {
    const visited = /* @__PURE__ */ new Map(), walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        outFn(node);
        walkStack.pop();
      } else {
        inFn(node);
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
};
WalkHelper._$name = "WalkHelper";

// ../Core/lib/Core/data/mixin/StoreSync.js
var StoreSync_default = (Target) => class StoreSync extends (Target || Base) {
  static get $name() {
    return "StoreSync";
  }
  static get configurable() {
    return {
      /**
       * Configure with `true` to sync loaded data instead of replacing existing with a new dataset.
       *
       * By default (or when configured with `false`) assigning to `store.data` replaces the entire dataset
       * with a new one, creating all new records:
       *
       * ```javascript
       * store.data = [ { id : 1, name : 'Saitama' } ];
       *
       * const first = store.first;
       *
       * store.data = [ { id : 1, name : 'One-Punch man' } ];
       *
       * // store.first !== first;
       * ```
       *
       * When configured with `true` the new dataset is instead synced against the old, figuring out what was
       * added, removed and updated:
       *
       * ```javascript
       * store.data = [ { id : 1, name : 'Saitama' } ];
       *
       * const first = store.first;
       *
       * store.data = [ { id : 1, name : 'One-Punch man' } ];
       *
       * // store.first === first;
       * ```
       *
       * After the sync, any configured sorters, groupers and filters will be reapplied.
       *
       * #### Threshold
       *
       * The sync operation has a configurable threshold, above which the operation will be treated as a
       * batch/refresh and only trigger a single `refresh` event. If threshold is not reached, individual events
       * will be triggered (single `add`, `remove` and possible multiple `update`). To enable the threshold,
       * supply a config object with a `threshold` property instead of `true`:
       *
       * ```javascript
       * const store = new Store({
       *     syncDataOnLoad : {
       *         threshold : '20%'
       *     }
       * });
       * ```
       *
       * `threshold` accepts numbers or strings. A numeric threshold means number of affected records, while a
       * string is used as a percentage of the whole dataset (appending `%` is optional). By default no threshold
       * is used.
       *
       * #### Missing fields
       *
       * The value of any field not supplied in the new dataset is by default kept as is (if record is not removed
       * by the sync). This behaviour is configurable, by setting `keepMissingValues : false` in a config object
       * it will reset any unspecified field back to their default values:
       *
       * ```javascript
       * const store = new Store({
       *     syncDataOnLoad : {
       *         keepMissingValues : false
       *     }
       * });
       * ```
       *
       * Considering the following sync operation:
       *
       * ```javascript
       * // Existing data
       * { id : 1, name : 'Saitama', powerLevel : 100 }
       * // Sync data
       * { id : 1, name : 'One-Punch Man' }
       * ```
       *
       * The result would by default (or when explicitly configured with `true`)  be:
       *
       * ```javascript
       * { id : 1, name : 'One-Punch Man', powerLevel : 100 }
       * ```
       *
       * If configured with `keepMissingValues : false` it would instead be:
       *
       * ```javascript
       * { id : 1, name : 'One-Punch Man' }
       * ```
       *
       * <div class="note">Never enable `syncDataOnLoad` on a chained store, it will create an infinite loop when
       * it is populated from the main store (the main store can use the setting)</div>
       *
       * @config {Boolean|SyncDataOnLoadOptions} syncDataOnLoad
       * @default false
       * @category Common
       */
      syncDataOnLoad: null,
      shouldSyncDataset: null,
      shouldSyncRecord: null
    };
  }
  /**
   * Syncs a new dataset against the already loaded one, only applying changes.
   * Not intended to be called directly, please configure store with `syncDataOnLoad: true` and assign to
   * `store.data` as usual instead.
   *
   * ```
   * const store = new Store({
   *    syncDataOnLoad : true,
   *    data : [
   *        // initial data
   *    ]
   * });
   *
   * store.data = [ // new data ]; //  Difference between initial data and new data will be applied
   * ```
   *
   * @param {Object[]|Core.data.Model[]} data New dataset, an array of records or data objects
   * @private
   */
  syncDataset(data) {
    var _a2;
    const me = this, { storage } = me, idsToCheck = (_a2 = me.shouldSyncDataset) == null ? void 0 : _a2.call(me, { data });
    if (idsToCheck === false) {
      return;
    }
    me.trigger("startApplyChangeset");
    me.isSyncingDataOnLoad = true;
    const { toAdd, toRemove, toMove, updated, ids } = me.tree ? me.syncTreeDataset(data, idsToCheck) : me.syncFlatDataset(data, idsToCheck);
    let { threshold } = me.syncDataOnLoad, surpassed = false;
    if (threshold) {
      if (typeof threshold === "string") {
        threshold = parseInt(threshold, 10) / 100 * me.count;
      }
      surpassed = toAdd.length + toRemove.length + toMove.length + updated.length > threshold;
    }
    if (me.tree) {
      if (toAdd.length) {
        const added = me.add(toAdd, surpassed);
        added.forEach((node) => node.clearParentId());
      }
      if (toMove.length) {
        for (const { parent, node, index } of toMove) {
          const newParent = me.getById(parent.id);
          newParent.insertChild(node, index);
        }
      }
      me.remove(toRemove, surpassed);
    } else {
      if (surpassed) {
        me.suspendEvents();
      }
      me.remove(toRemove);
      me.add(toAdd);
      if (surpassed) {
        me.resumeEvents();
      }
    }
    if (threshold && !surpassed) {
      updated.forEach(({ record, toSet, wasSet }) => me.onModelChange(record, toSet, wasSet));
    }
    me.acceptChanges();
    const event = { added: toAdd, removed: toRemove, updated, thresholdSurpassed: surpassed };
    if (me.isFiltered && !me.remoteFilter) {
      me.filter({
        silent: me.isRemoteDataLoading
      });
    }
    if (me.isGrouped) {
      me.group(null, null, false, true, me.isRemoteDataLoading);
    } else if (me.isSorted) {
      if (me.remoteSort) {
        storage.replaceValues({
          values: storage.values.sort(me.createSorterFn(me.sorters)),
          silent: true
        });
      } else {
        me.sort();
      }
    } else if (!me.tree) {
      if (storage.values.some((record, index) => record.id !== ids[index])) {
        storage.replaceValues({
          values: storage.values.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id)),
          silent: true
        });
        !surpassed && me.afterPerformSort();
      }
    } else {
      let unsorted = false, i = 0;
      WalkHelper.preWalk(
        me.rootNode,
        (n) => Array.isArray(n.children) && !unsorted ? n.children : null,
        (node) => {
          if (node.id !== ids[i++]) {
            unsorted = true;
          }
        }
      );
      if (unsorted) {
        me.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id), void 0, void 0, true);
        me.clearSorters(true);
        !surpassed && me.afterPerformSort();
      }
    }
    if (surpassed) {
      me.trigger("refresh", {
        action: "batch",
        data,
        records: storage.values,
        syncInfo: event
      });
    }
    me.isSyncingDataOnLoad = false;
    me.trigger("endApplyChangeset");
    me.trigger("loadSync", event);
  }
  // Used by syncDataset()
  syncFlatDataset(data, idsToCheck) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this, { idField, allFields } = me.modelClass, toRemove = [], toAdd = [], updated = [], usedIds = {}, ids = [], limitedSet = Array.isArray(idsToCheck);
    const { threshold, keepMissingValues } = me.syncDataOnLoad;
    let hitCount = 0;
    data.forEach((rawData) => {
      var _a2, _b, _c;
      rawData = rawData.isModel ? rawData.data : rawData;
      const id = rawData[idField], record = me.getById(id);
      if (!limitedSet || idsToCheck.includes(id)) {
        if (record) {
          if (((_a2 = me.shouldSyncRecord) == null ? void 0 : _a2.call(me, { record, data: rawData })) !== false) {
            (_b = me.beforeSyncRecord) == null ? void 0 : _b.call(me, { record, data: rawData });
            if (keepMissingValues === false) {
              for (const field of allFields) {
                if (!(field.dataSource in rawData) && field.dataSource in record.data) {
                  rawData[field.dataSource] = field.defaultValue;
                }
              }
            }
            const wasSet = record.set(rawData, null, Boolean(threshold));
            if (wasSet) {
              updated.push({
                record,
                wasSet,
                toSet: rawData
              });
            }
            (_c = me.afterSyncRecord) == null ? void 0 : _c.call(me, { record, data: rawData });
          }
        } else {
          toAdd.push(me.processRecord(me.createRecord(rawData)));
        }
      }
      if (record) {
        hitCount++;
      }
      usedIds[id] = 1;
      ids.push(id);
    });
    if (hitCount < me.allRecords.filter((x) => !x.isSpecialRow).length) {
      if (idsToCheck) {
        for (const id of idsToCheck) {
          if (!usedIds[id]) {
            toRemove.push(me.getById(id));
          }
        }
      } else {
        me.forEach((record) => {
          if (!usedIds[record.id]) {
            toRemove.push(record);
          }
        }, me, {
          includeFilteredOutRecords: true,
          includeCollapsedGroupRecords: true
        });
      }
    }
    return { toAdd, toRemove, toMove: [], updated, ids };
  }
  // Used by syncDataset()
  syncTreeDataset(data) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this, {
      idField,
      parentIdField,
      childrenField,
      allFields
    } = me.modelClass, {
      keepMissingValues,
      threshold
    } = me.syncDataOnLoad, toRemove = [], toAdd = [], toMove = [], updated = [], matchedNodes = /* @__PURE__ */ new Set(), ids = [];
    if (me.transformFlatData) {
      data = me.treeifyFlatData(data);
    }
    WalkHelper.preWalkWithParent({ isRoot: true, id: me.rootNode.id, children: data }, (n) => n.children, (parent, rawData) => {
      var _a2;
      if (parent) {
        const { id, node } = me.resolveSyncNode(rawData);
        if (node) {
          if (((_a2 = me.shouldSyncRecord) == null ? void 0 : _a2.call(me, { record: node, data: rawData })) !== false) {
            let childrenUpdated;
            const oldChildrenValue = node.children;
            if (oldChildrenValue !== true && rawData[childrenField] === true) {
              node.clearChildren();
              node.data[childrenField] = node.children = true;
              delete rawData[childrenField];
              me.toggleCollapse(node, true);
              childrenUpdated = true;
            }
            if (node.parent.id !== parent[idField]) {
              toMove.push({
                node,
                parent,
                index: parent[childrenField].indexOf(rawData)
              });
            }
            if (keepMissingValues === false) {
              for (const field of allFields) {
                if (field.name !== "parentId" && !(field.dataSource in rawData) && field.dataSource in node.data) {
                  rawData[field.dataSource] = field.defaultValue;
                }
              }
            }
            if (typeof rawData.expanded === "boolean") {
              this.toggleCollapse(node, !rawData.expanded);
            }
            const wasSet = node.set(rawData, null, Boolean(threshold));
            if (wasSet) {
              updated.push({
                record: node,
                wasSet,
                toSet: rawData
              });
            } else if (childrenUpdated) {
              node.signalNodeChanged({
                [childrenField]: {
                  value: true,
                  oldValue: oldChildrenValue
                }
              });
            }
          }
        } else {
          rawData[parentIdField] = parent[idField];
          toAdd.push({ ...rawData, ...Array.isArray(rawData[childrenField]) ? { children: [] } : void 0 });
        }
        matchedNodes.add(node);
        ids.push(id);
      }
    });
    if (matchedNodes.length !== data.length) {
      me.traverse((node) => {
        if (!matchedNodes.has(node)) {
          toRemove.push(node);
        }
      });
    }
    return { toAdd, toRemove, toMove, updated, ids };
  }
  // ColumnStore overrides this fn to allow syncing by field & type
  resolveSyncNode(rawData) {
    const id = rawData[this.modelClass.idField], node = this.getById(id);
    return { id, node };
  }
};

// ../Core/lib/Core/data/stm/mixin/StoreStm.js
var STM_PROP2 = Symbol("STM_PROP");
var StoreStm_default = (Target) => class StoreStm extends (Target || Base) {
  static get $name() {
    return "StoreStm";
  }
  static get defaultConfig() {
    return {
      /**
       * Reference to STM manager
       *
       * @config {Core.data.stm.StateTrackingManager}
       * @default
       * @category Advanced
       */
      stm: null,
      /**
       * Set to `false` to not record transaction during `applyChangeset` call
       *
       * @prp {Boolean}
       * @default
       * @category Advanced
       */
      ignoreRemoteChangesInSTM: false
    };
  }
  get stm() {
    return this[STM_PROP2];
  }
  set stm(stm) {
    var _a2;
    const me = this;
    if (me.stm !== stm) {
      if ((_a2 = me.stm) == null ? void 0 : _a2.hasStore(me)) {
        me.stm.removeStore(me);
      }
      me[STM_PROP2] = stm;
      if (me.stm && !me.stm.hasStore(me)) {
        me.stm.addStore(me);
      }
    }
  }
  // Overridden to notify STM about flat add action
  add(records, silent = false, options = {}) {
    let result;
    const { stm } = this;
    if (!this.tree && (stm == null ? void 0 : stm.enabled)) {
      result = super.add(records, silent);
      if (result == null ? void 0 : result.length) {
        stm.onStoreModelAdd(this, result, silent);
      }
    } else {
      result = super.add(records, silent, options);
    }
    return result;
  }
  // Overridden to notify STM about flat insert action
  insert(index, records, silent = false) {
    let result;
    const { stm } = this;
    if (!this.tree && (stm == null ? void 0 : stm.enabled)) {
      const context = (Array.isArray(records) ? records : [records]).reduce(
        (context2, r) => {
          const index2 = r instanceof Model ? this.indexOf(r) : void 0;
          if (index2 !== void 0 && index2 !== -1) {
            context2.set(r, index2);
          }
          return context2;
        },
        /* @__PURE__ */ new Map()
      );
      result = super.insert(index, records);
      if (result == null ? void 0 : result.length) {
        index = this.indexOf(result[0]);
        stm.onStoreModelInsert(this, index, result, context, silent);
      }
    } else {
      result = super.insert(index, records, silent);
    }
    return result;
  }
  // Overridden to notify STM about flat removing action
  remove(recordsOrIds, silent = false, fromRemoveChild) {
    let result;
    const { stm } = this;
    if (!this.tree && (stm == null ? void 0 : stm.enabled)) {
      const recordsOrIdsNormalized = (Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds]).map((r) => this.getById(r)).filter((r) => !!r);
      const context = recordsOrIdsNormalized.reduce(
        (context2, r) => {
          const index = this.indexOf(r);
          if (index !== void 0 && index !== -1) {
            context2.set(r, index);
          }
          return context2;
        },
        /* @__PURE__ */ new Map()
      );
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
      if (result == null ? void 0 : result.length) {
        stm.onStoreModelRemove(this, result, context, silent);
      }
    } else {
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
    }
    return result;
  }
  // Overridden to notify STM about flat clear action
  removeAll(silent) {
    const { stm } = this;
    let result;
    if (stm == null ? void 0 : stm.enabled) {
      const { tree, rootNode, allRecords } = this, wasNotEmpty = allRecords.length, records = tree ? rootNode.children.slice() : allRecords.slice();
      result = super.removeAll(silent);
      if (wasNotEmpty && this.count === 0) {
        stm.onStoreRemoveAll(this, records, silent);
      }
    } else {
      result = super.removeAll(silent);
    }
    return result;
  }
  beforeApplyChangeset() {
    const { stm, crudManager } = this;
    let shouldResume = false, transactionId = null;
    if (!(crudManager == null ? void 0 : crudManager.applyingChangeset) && (stm == null ? void 0 : stm.enabled)) {
      shouldResume = true;
      if (stm.isRecording) {
        transactionId = stm.stash();
      }
      if (this.ignoreRemoteChangesInSTM) {
        stm.disable();
      } else {
        stm.startTransaction();
      }
    }
    return { shouldResume, transactionId };
  }
  // When applying changes while STM is in the recording state, first we need to discard local changes, then apply
  // changes from remote, then try to apply local changes. This would emulate starting transaction as if data was
  // already in the correct state
  applyChangeset(changes, transformFn, phantomIdField, remote, logChanges) {
    const {
      shouldResume,
      transactionId
    } = this.beforeApplyChangeset(), log = super.applyChangeset(changes, transformFn, phantomIdField, remote, logChanges);
    this.afterApplyChangeset(shouldResume, transactionId);
    return log;
  }
  afterApplyChangeset(shouldResume, transactionId) {
    if (shouldResume) {
      const { stm } = this;
      if (this.ignoreRemoteChangesInSTM) {
        stm.enable();
      } else {
        stm.stopTransaction();
      }
      stm.applyStash(transactionId);
    }
  }
};

// ../Core/lib/Core/data/StoreBag.js
var StoreBag = class extends Bag {
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    return super.add(...toAdd.filter((record) => record.isPersistable));
  }
};
StoreBag._$name = "StoreBag";

// ../Core/lib/Core/data/Store.js
var dataAddRemoveActions = {
  splice: 1,
  clear: 1
};
var defaultTraverseOptions2 = {
  includeFilteredOutRecords: false,
  includeCollapsedGroupRecords: false
};
var fixTraverseOptions2 = (store, options) => {
  options = options || false;
  if (typeof options === "boolean") {
    options = {
      includeFilteredOutRecords: options,
      includeCollapsedGroupRecords: false
    };
  }
  return options || defaultTraverseOptions2;
};
var Store = class _Store extends Base.mixin(
  Delayable_default,
  Identifiable_default,
  Events_default,
  Pluggable_default,
  State_default,
  StoreFilter_default,
  StoreChanges_default,
  StoreCRUD_default,
  StoreRelation_default,
  // Private
  StoreSum_default,
  StoreSearch_default,
  StoreSort_default,
  StoreGroup_default,
  StoreChained_default,
  StoreState_default,
  StoreTree_default,
  StoreStm_default,
  StoreSync_default,
  StoreProxy_default
  // Private for now, thus not mentioned in @mixes block above
) {
  //region Config & properties
  static get $name() {
    return "Store";
  }
  static get properties() {
    return {
      relationCache: {},
      dependentStoreConfigs: /* @__PURE__ */ new Map(),
      addingClean: false
    };
  }
  static get configurable() {
    return {
      /**
       * Store's unique identifier.
       *
       * @member {String|Number} id
       * @readonly
       * @category Common
       */
      /**
       * Store's unique identifier. When set the store is added to a store map accessible through
       * `Store.getStore(id)`.
       *
       * @config {String|Number}
       * @category Common
       */
      id: true,
      /**
       * Class used to represent records in the store, should be a subclass of {@link Core.data.Model}. Only
       * applies when supplying data to the store (load, add), any supplied record instances are kept as is.
       *
       * ```javascript
       * class MyModel extends Model {
       *     static get fields() {
       *         return [
       *             'name',
       *             'city',
       *             'company'
       *         ]
       *     }
       * }
       *
       * const store = new Store({
       *     modelClass : MyModel,
       *     data : [
       *         { id : 1, name : 'Mark', city : 'London', company : 'Cool inc' },
       *         ...
       *     ]
       * });
       * ```
       *
       * @config {Core.data.Model}
       * @default
       * @typings {typeof Model}
       * @category Common
       */
      modelClass: Model,
      /**
       * Verify that loaded data does not contain any generated ids. If it does, a warning is logged on console.
       *
       * Set this to `false` to disable the check and give a very minor performance boost.
       *
       * @prp {Boolean}
       * @default
       */
      verifyNoGeneratedIds: true
    };
  }
  static get defaultConfig() {
    return {
      /**
       * An array of field definitions used to create a {@link Core.data.Model} (modelClass) subclass. Optional.
       * If the Model already has fields defined, these fields will extend those.
       *
       * ```javascript
       * const store = new Store({
       *     fields : ['name', 'city', 'company'],
       *     data   : [
       *         { id : 1, name : 'Mark', city : 'London', company : 'Cool inc' },
       *         ...
       *     ]
       * });
       * ```
       *
       * See {@link Core.data.Model} for more info on defining fields, changing data source and mapping fields to
       * nested objects.
       *
       * Note that pre-created record instances supplied to the store are kept as is and thus these fields will
       * not apply to them.
       *
       * @config {Array<String|ModelFieldConfig|Core.data.field.DataField>}
       * @category Common
       */
      fields: null,
      /**
       * Automatically detect from set data if used as tree store or flat store
       * @config {Boolean}
       * @default
       * @category Tree
       */
      autoTree: true,
      /**
       * Raw data to load initially.
       *
       * Expects an array of JavaScript objects, with properties matching store's fields (defined on its
       * {@link #config-modelClass model} or in the {@link #config-fields} config).
       *
       * ```javascript
       * const store = new Store({
       *     data : [
       *         { id : 1, name : 'Linda', city : 'NY' },
       *         { id : 2, name : 'Olivia', city : 'Paris' },
       *         ...
       *     ]
       * });
       * ```
       *
       * @config {Object[]|Core.data.Model[]}
       * @category Common
       */
      data: null,
      /**
       * `true` to act as a tree store.
       * @config {Boolean}
       * @category Tree
       */
      tree: false,
      callOnFunctions: true,
      /**
       * A {@link Core/util/Collection}, or Collection config object
       * to use to contain this Store's constituent records.
       * @config {Core.util.Collection|CollectionConfig}
       * @category Advanced
       */
      storage: null,
      /**
       * Retools the loaded data objects instead of making shallow copies of them. This increases performance but
       * pollutes the incoming data and does not allow remapping of fields (dataSource).
       *
       * Also allows disabling certain steps in data loading, to further improve performance. Either accepts an
       * object with the params described below or `true` which equals `disableDuplicateIdCheck` and
       * `disableTypeConversion`.
       *
       * ```javascript
       * // No duplicate id checking, no type conversions
       * new Store({ useRawData : true });
       *
       * new Store({
       *   // No type conversions only
       *   useRawData : {
       *     disableTypeConversion : true
       *   }
       * });
       * ```
       *
       * @config {Boolean|Object}
       * @param {Boolean} [disableDuplicateIdCheck] Data must not contain duplicate ids, check is bypassed.
       * @param {Boolean} [disableDefaultValue] Default values will not be applied to record fields.
       * @param {Boolean} [disableTypeConversion] No type conversions will be performed on record data.
       * @category Advanced
       */
      useRawData: false,
      /**
       * Specify `false` to prevent loading records without ids, a good practise to enforce when syncing with a
       * backend.
       *
       * By default Store allows loading records without ids, in which case a generated id will be assigned.
       *
       * @config {Boolean}
       * @default true
       * @category Advanced
       */
      allowNoId: true,
      /**
       * Prevent dynamically subclassing the modelClass. It does so by default to not pollute it when exposing
       * properties. Should rarely need to be used.
       * @config {Boolean}
       * @default false
       * @private
       * @category Advanced
       */
      preventSubClassingModel: null,
      /**
       * Store class to use when creating the store when it is a part of a
       * [CrudManager](https://bryntum.com/products/scheduler/docs/api/Scheduler/data/CrudManager).
       *
       * ```javascript
       * crudManager : {
       *      eventStore {
       *          storeClass : MyEventStore
       *      }
       * }
       * ```
       *
       * @config {Class}
       * @typings {typeof Store}
       * @category Advanced
       */
      storeClass: null
    };
  }
  static get identifiable() {
    return {
      registerGeneratedId: false
    };
  }
  /**
   * Class used to represent records. Defaults to class Model.
   * @member {Core.data.Model} modelClass
   * @typings {typeof Model}
   * @category Records
   */
  //endregion
  //region Events
  /**
   * Fired when the id of a record has changed
   * @event idChange
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {String|Number} oldValue Old id
   * @param {String|Number} value New id
   */
  /**
   * Fired before record is modified in this store.
   * Modification may be vetoed by returning `false` from a handler.
   * @event beforeUpdate
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {Object} changes Modification data
   */
  /**
   * Fired when a record is modified
   * @event update
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {Object} changes Modification data
   */
  /**
   * Fired when one of this Store's constituent records is modified while in
   * {@link Core.data.Model#function-beginBatch batched} state. This may be used to keep
   * UIs up to date while "tentative" changes are made to a record which must not be synced with a server.
   * @event batchedUpdate
   * @private
   */
  /**
   * Fired when the root node is set
   * @event rootChange
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} oldRoot The old root node.
   * @param {Core.data.Model} rootNode The new root node.
   */
  /**
   * Data in the store was changed. This is a catch-all event which is fired for all changes
   * which take place to the store's data.
   *
   * This includes mutation of individual records, adding and removal of records, as well as
   * setting a new data payload using the {@link #property-data} property, sorting, filtering,
   * and calling {@link Core.data.mixin.StoreCRUD#function-removeAll}.
   *
   * Simple databound widgets may use to the `change` event to refresh their UI without having to add multiple
   * listeners to the {@link #event-update}, {@link Core.data.mixin.StoreCRUD#event-add},
   * {@link Core.data.mixin.StoreCRUD#event-remove}, {@link #event-refresh} and
   * {@link Core.data.mixin.StoreCRUD#event-removeAll} events.
   *
   * A more complex databound widget such as a grid may use the more granular events to perform less
   * destructive updates more appropriate to each type of change. The properties will depend upon the value of the
   * `action` property.
   *
   * @event change
   * @param {Core.data.Store} source This Store.
   * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action
   * Name of action which triggered the change. May be one of the options listed above
   * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)
   * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`
   * @param {Object} changes Passed for the `'update'` action, info on which record fields changed
   */
  // NOTE: When updating params above, also update change event in ProjectModelMixin and dataChange in ProjectConsumer
  /**
   * Data in the store has completely changed, such as by a filter, or sort or load operation.
   * @event refresh
   * @param {Core.data.Store} source This Store.
   * @param {Boolean} batch Flag set to `true` when the refresh is triggered by ending a batch
   * @param {'dataset'|'sort'|'clearchanges'|'filter'|'create'|'update'|'delete'|'group'} action Name of
   * action which triggered the change. May be one of the options listed above.
   */
  //endregion
  /* break doc comment from next method */
  //region Init
  constructor(...args) {
    super(...args);
    if (this.objectify) {
      return this.initProxy();
    }
  }
  construct(config = {}) {
    const me = this;
    Object.assign(me, {
      added: new StoreBag(),
      removed: new StoreBag(),
      modified: new StoreBag(),
      idRegister: {},
      internalIdRegister: {},
      oldIdMap: {}
    });
    if (config.storeId) {
      config = ObjectHelper.assign({ id: config.storeId }, config);
    }
    super.construct(config);
    me.initRelations();
  }
  /**
   * Retrieves/creates a store based on the passed config.
   *
   * | Type              | Result                                                                 |
   * |-------------------|------------------------------------------------------------------------|
   * | Core.data.Store   | Returns supplied store as is                                           |
   * | String            | Retrieves an existing store by id                                      |
   * | Object            | Creates a new store using supplied config object                       |
   * | Object[]          | Creates a new store, populated with records created from supplied data |
   * | Core.data.Model[] | Creates a new store, populated with supplied records                   |
   *
   *
   * @param {Core.data.Store|StoreConfig|String|StoreConfig[]|Core.data.Model[]} config
   * @param {Object} [defaults] Config object to apply when creating a new store for passed data
   * @param {Function} [converterFn] Function called for each data object prior to creating a record from it. The
   * return value is used to create a record.
   * @private
   */
  static from(config, defaults = {}, converterFn = null) {
    if (config && !config.isStore) {
      if (typeof config === "string") {
        config = _Store.getStore(config);
      } else {
        if (Array.isArray(config)) {
          if (converterFn) {
            config = config.map((data) => data.isModel ? data : converterFn(data));
          }
          config = ObjectHelper.assign({}, defaults, { data: config });
        } else {
          config = ObjectHelper.assign({}, defaults, config);
        }
        config = new _Store(config);
      }
    }
    return config;
  }
  doDestroy() {
    var _a2, _b, _c, _d;
    const me = this, allRecords = me.registeredRecords;
    (_b = (_a2 = me.stm) == null ? void 0 : _a2.removeStore) == null ? void 0 : _b.call(_a2, me);
    for (let i = allRecords.length - 1, rec; i >= 0; i--) {
      rec = allRecords[i];
      if (!(rec == null ? void 0 : rec.isDestroyed)) {
        rec.unjoinStore(me);
      }
    }
    (_c = me._storage) == null ? void 0 : _c.destroy();
    if (!me.isChained) {
      (_d = me.rootNode) == null ? void 0 : _d.destroy();
    }
    super.doDestroy();
  }
  /**
   * Stops this store from firing events until {@link #function-endBatch} is called. Multiple calls to `beginBatch`
   * stack up, and will require an equal number of `endBatch` calls to resume events.
   *
   * Upon call of {@link #function-endBatch}, a {@link #event-refresh} event is triggered to allow UIs to
   * update themselves based upon the new state of the store.
   *
   * This is extremely useful when making a large number of changes to a store. It is important not to trigger
   * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
   * store are only updated once at the end of the updates.
   */
  beginBatch() {
    this.suspendEvents();
  }
  /**
   * Ends event suspension started by {@link #function-beginBatch}. Multiple calls to {@link #function-beginBatch}
   * stack up, and will require an equal number of `endBatch` calls to resume events.
   *
   * Upon call of `endBatch`, a {@link #event-refresh} event with `action: batch` is triggered to allow UIs to update
   * themselves based upon the new state of the store.
   *
   * This is extremely useful when making a large number of changes to a store. It is important not to trigger
   * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
   * store are only updated once at the end of the updates.
   */
  endBatch() {
    if (this.resumeEvents()) {
      const { values: records } = this.storage;
      this.trigger("refresh", {
        action: "batch",
        data: records,
        records
      });
    }
  }
  set storage(storage) {
    const me = this;
    if (storage == null ? void 0 : storage.isCollection) {
      me._storage = storage;
    } else {
      me._storage = new Collection(storage);
    }
    me._storage.autoFilter = me.reapplyFilterOnAdd;
    me._storage.autoSort = me.reapplySortersOnAdd;
    for (const r of me._storage) {
      r.joinStore(me);
    }
    me._storage.ion({
      change: "onDataChange",
      thisObj: me
    });
  }
  get storage() {
    if (!this._storage) {
      this.storage = {};
    }
    return this._storage;
  }
  /**
   * Returns all records (ignoring any filters) from the store.
   * @property {Core.data.Model[]}
   * @readonly
   * @category Records
   */
  get allRecords() {
    var _a2;
    const me = this;
    if (((_a2 = me._allRecords) == null ? void 0 : _a2.generation) !== me.storage.generation) {
      if (me.isTree) {
        const result = me.collectDescendants(me.rootNode, void 0, void 0, { unfiltered: true }).all;
        if (me.rootVisible) {
          result.unshift(me.rootNode);
        }
        me._allRecords = result;
      } else {
        me._allRecords = me.isGrouped ? me.collectGroupRecords() : me.storage.allValues;
      }
      me._allRecords.generation = me.storage.generation;
    }
    return me._allRecords;
  }
  // All records except special rows such group headers etc
  getAllDataRecords(searchAllRecords) {
    const me = this;
    if (me.tree) {
      return searchAllRecords ? me.allRecords : me.rootNode.allChildren;
    }
    return me.isGrouped ? me.collectGroupRecords(searchAllRecords, false) : searchAllRecords ? me.storage.allValues : me.storage.values;
  }
  /**
   * Called by owned record when the record has its {@link Core.data.Model#property-isCreating}
   * property toggled.
   * @param {Core.data.Model} record The record that is being changed.
   * @param {Boolean} isCreating The new value of the {@link Core.data.Model#property-isCreating} property.
   * @internal
   */
  onIsCreatingToggle(record, isCreating) {
    const me = this, newlyPersistable = record.isPersistable && !isCreating;
    me.added[newlyPersistable ? "add" : "remove"](record);
    if (newlyPersistable) {
      me.trigger("addConfirmed", { record });
      if (me.autoCommit) {
        me.doAutoCommit();
      }
    }
  }
  // Join added records to store, not called when loading
  joinRecordsToStore(records) {
    const { allCount } = this;
    for (let i = 0; i < records.length; i++) {
      const record = records[i];
      record.setData("parentIndex", allCount + i - records.length);
      record.joinStore(this);
    }
  }
  /**
   * Responds to mutations of the underlying storage Collection
   * @param {Object} event
   * @protected
   */
  onDataChange({ source: storage, action, added, removed, replaced, oldCount, items, from, to }) {
    const me = this, isAddRemove = dataAddRemoveActions[action], addedCount = isAddRemove && (added == null ? void 0 : added.length), removedCount = isAddRemove && (removed == null ? void 0 : removed.length);
    let filtersWereReapplied, sortersWereReapplied;
    me._idMap = null;
    if (addedCount) {
      me.joinRecordsToStore(added);
    }
    replaced == null ? void 0 : replaced.forEach(([oldRecord, newRecord]) => {
      oldRecord.unjoinStore(me, true);
      newRecord.joinStore(me);
    });
    super.onDataChange(...arguments);
    if (!me.isTree) {
      if (addedCount) {
        for (const record of added) {
          if (me.removed.includes(record)) {
            me.removed.remove(record);
          } else if (!me.addingClean && !record.isLinked) {
            me.added.add(record);
          }
        }
        filtersWereReapplied = !me.remoteFilter && me.isFiltered && me.reapplyFilterOnAdd;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
        sortersWereReapplied = !me.remoteSort && me.isSorted && me.reapplySortersOnAdd;
        if (sortersWereReapplied) {
          me.sort(null, null, false, true);
        }
      }
      if (removedCount) {
        for (const record of removed) {
          record.cancelBatch();
          record.unjoinStore(me);
          if (me.added.includes(record)) {
            me.added.remove(record);
          } else if (!record._undoingInsertion && !record.isCreating && !record.isLinked) {
            me.removed.add(record);
          }
        }
        me.modified.remove(removed);
        filtersWereReapplied = !me.remoteFilter && me.isFiltered;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
      }
    }
    switch (action) {
      case "clear":
        me.relationCache = {};
        me.updateDependentStores("removeall");
        me.trigger("removeAll");
        me.trigger("change", {
          action: "removeall"
        });
        break;
      case "splice":
        if (addedCount) {
          me.updateDependentStores("add", added);
          const oldIndex = added.reduce((lowest, record) => {
            const { previousIndex } = record.meta;
            if (previousIndex > -1 && previousIndex < lowest)
              lowest = previousIndex;
            return lowest;
          }, added[0].meta.previousIndex), index = storage.indexOf(added[0], !storage.autoFilter), params = {
            records: added,
            index
          };
          if (oldIndex > -1) {
            params.oldIndex = oldIndex;
          }
          me.trigger("add", params);
          me.trigger("change", Object.assign({ action: "add" }, params));
          if (filtersWereReapplied) {
            me.triggerFilterEvent({
              action: "filter",
              filters: me.filters,
              oldCount,
              records: me.storage.allValues
            });
          }
          if (sortersWereReapplied) {
            me.trigger("sort", { action: "sort", sorters: me.sorters, records: me.storage.allValues });
          }
        }
        if (removed.length) {
          me.updateDependentStores("remove", removed);
          me.trigger("remove", {
            records: removed
          });
          me.trigger("change", {
            action: "remove",
            records: removed
          });
        }
        if (replaced.length) {
          me.updateDependentStores("replace", replaced);
          me.trigger("replace", {
            records: replaced,
            all: me.records.length === replaced.length
          });
          me.trigger("change", {
            action: "replace",
            replaced,
            all: me.records.length === replaced.length
          });
        }
        break;
      case "filter":
        if (me.isGrouped || me.isSorted) {
          me.performSort(true);
        }
        break;
      case "move": {
        const start = Math.min(from, to), end = Math.min(me.storage.allValues.length - 1, Math.max(from, to));
        for (let allRecords = me.storage.allValues, i = start; i <= end; i++) {
          allRecords[i].setData("parentIndex", i);
        }
        me.trigger("move", {
          record: items[0],
          records: items,
          from,
          to
        });
        if (me.isFiltered) {
          me.performFilter();
        }
        me.trigger("change", {
          action,
          record: items[0],
          records: items,
          from,
          to
        });
        break;
      }
    }
  }
  onDataReplaced(action, data) {
    var _a2;
    const me = this, { storage } = me, all = storage.allValues, sorted = Boolean(me.sorters.length > 0);
    for (let i = 0; i < all.length; i++) {
      all[i].joinStore(me);
    }
    if (!me.remoteFilter && me.isFiltered) {
      me.filter({
        silent: true
      });
    }
    if (me.remoteSort) {
      if (me.isGrouped) {
        storage.replaceValues({
          // Need to update group records info (headers and footers)
          ...me.prepareGroupRecords(),
          silent: true
        });
      }
    } else {
      if (me.isGrouped) {
        me.group(null, null, false, !sorted, true);
      }
      if (sorted) {
        me.sort(null, null, false, true);
      }
    }
    if (!me.useRawData.disableDuplicateIdCheck) {
      const { idMap } = me;
      if (Object.keys(idMap).length < storage.values.length) {
        const collisions = [];
        storage.values.forEach((r) => idMap[r.id] ? delete idMap[r.id] : collisions.push(r));
        throw new Error(`Id collision on ${collisions.map((r) => r.id)}`);
      }
    }
    const event = { action, data, records: storage.values };
    me.updateDependentStores(action, event.records);
    (_a2 = me.afterLoadData) == null ? void 0 : _a2.call(me);
    if (!me.isRemoteDataLoading) {
      me.trigger("refresh", event);
    }
    me.trigger("change", event);
  }
  /**
   * This is called from Model after mutating any fields so that Stores can take any actions necessary at that point,
   * and distribute mutation event information through events.
   * @param {Core.data.Model} record The record which has just changed
   * @param {Object} toSet A map of the field names and values that were passed to be set
   * @param {Object} wasSet A map of the fields that were set. Each property is a field name, and
   * the property value is an object containing two properties: `oldValue` and `value` eg:
   * ```javascript
   *     {
   *         name {
   *             oldValue : 'Rigel',
   *             value : 'Nigel'
   *         }
   *     }
   *
   * @param {Boolean} silent Do not trigger events
   * @param {Boolean} fromRelationUpdate Update caused by a change in related model
   * @private
   */
  onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
    const me = this, event = {
      record,
      records: [record],
      changes: wasSet,
      // Cannot use isBatching, since change is triggered when batching has reached 0
      // (but before it is set to null)
      batch: record.batching != null,
      fromRelationUpdate
    }, committable = record.ignoreBag || record.isLinked ? false : me.updateModifiedBagForRecord(record);
    me.storage.onItemMutation(record, wasSet);
    if ("id" in wasSet) {
      const { oldValue, value } = toSet.id;
      me.updateDependentRecordIds(oldValue, value);
      me.onRecordIdChange({ record, oldValue, value });
    }
    if (!silent) {
      if ("id" in wasSet) {
        const { oldValue, value } = toSet.id;
        me.trigger("idChange", {
          store: me,
          record,
          oldValue,
          value
        });
      }
      me.onUpdateRecord(record, wasSet);
      me.trigger("update", event);
      me.trigger("change", Object.assign({ action: "update" }, event));
    }
    if (me.autoCommit && committable) {
      me.doAutoCommit();
    }
  }
  updateModifiedBagForRecord(record) {
    const me = this;
    let addedToBag = false;
    if (record.isModified) {
      if (!me.modified.includes(record) && !me.added.includes(record) && record.isPartOfStore(me) && !record.isRoot) {
        if (record.isPhantom) {
          me.added.add(record);
        } else {
          me.modified.add(record);
        }
        addedToBag = true;
      }
    } else {
      me.modified.remove(record);
    }
    return addedToBag;
  }
  get idMap() {
    const me = this, needsRebuild = !me._idMap, idMap = me._idMap || (me._idMap = {});
    if (needsRebuild) {
      const processedRecords = me.storage.values;
      for (let record, index = 0, visibleIndex = 0; index < processedRecords.length; index++) {
        record = processedRecords[index];
        idMap[record.id] = { index, visibleIndex, record };
        if (!record.isSpecialRow) {
          visibleIndex++;
        }
      }
      if (me.isFiltered) {
        for (let index = 0, l = me.storage._values.length; index < l; index++) {
          const record = me.storage._values[index];
          if (record.id in idMap) {
            idMap[record.id].unfilteredIndex = index;
          } else {
            idMap[record.id] = { index: -1, unfilteredIndex: index, record };
          }
        }
      }
    }
    return idMap;
  }
  changeModelClass(ClassDef) {
    const { fields } = this;
    this.originalModelClass = ClassDef;
    let ClassDefEx = ClassDef;
    if (fields == null ? void 0 : fields.length) {
      class ModelClass extends ClassDef {
        static get fields() {
          return fields;
        }
      }
      ClassDefEx = ModelClass;
    } else if (!this.preventSubClassingModel) {
      class ModelClass extends ClassDef {
      }
      ClassDefEx = ModelClass;
    }
    ClassDefEx.initClass();
    return ClassDefEx;
  }
  //endregion
  //region Store id & map
  set storeId(storeId) {
    this.id = storeId;
  }
  get storeId() {
    return this.id;
  }
  changeId(id, oldId) {
    return super.changeId(id !== true && id, oldId);
  }
  updateId(id, oldId) {
    const duplicate = _Store.getById(id);
    duplicate && _Store.unregisterInstance(duplicate);
    super.updateId(id, oldId);
  }
  generateAutoId() {
    return _Store.generateId(`store-`);
  }
  get tree() {
    return this._tree;
  }
  set tree(tree) {
    this._tree = tree;
    if (tree && !this.rootNode) {
      this.rootNode = this.buildRootNode();
      this.rootNode.isAutoRoot = true;
    }
  }
  // a hook to build a customized root node
  buildRootNode() {
    return {};
  }
  /**
   * Get a store from the store map by id.
   * @param {String|Number|Object[]} id The id of the store to retrieve, or an array of objects
   * from which to create the contents of a new Store.
   * @returns {Core.data.Store} The store with the specified id
   */
  static getStore(id, storeClass) {
    if (id instanceof _Store) {
      return id;
    }
    if (this.getById(id)) {
      return this.getById(id);
    }
    if (Array.isArray(id)) {
      let storeModel;
      const storeData = id.map((item) => {
        if (item instanceof Model) {
          storeModel = item.constructor;
        } else if (typeof item === "string") {
          item = {
            text: item
          };
        } else {
        }
        return item;
      });
      if (!storeModel) {
        class ModelClass extends Model {
        }
        storeModel = ModelClass;
      }
      id = {
        autoCreated: true,
        data: storeData,
        modelClass: storeModel,
        allowNoId: true
        // String items have no id and are not guaranteed to be unique
      };
      if (!storeClass) {
        storeClass = _Store;
      }
    }
    if (storeClass) {
      return new storeClass(id);
    }
  }
  /**
   * Get all registered stores
   * @property {Core.data.Store[]}
   */
  static get stores() {
    return _Store.registeredInstances;
  }
  //endregion
  //region Data
  /**
   * The invisible root node of this tree.
   * @property {Core.data.Model}
   * @readonly
   * @category Tree
   */
  get rootNode() {
    return this.masterStore ? this.masterStore.rootNode : this._rootNode;
  }
  set rootNode(rootNode) {
    var _a2;
    const me = this, oldRoot = me._rootNode;
    if (rootNode === oldRoot) {
      return;
    }
    if (oldRoot) {
      me.clear(true);
      me.removed.clear();
    }
    if (rootNode instanceof Model) {
      rootNode.instanceMeta(me).collapsed = false;
      me._rootNode = rootNode;
    } else {
      me._rootNode = rootNode = new me.modelClass(Object.assign({
        expanded: true,
        [me.modelClass.idField]: `${me.id}-rootNode`
      }, rootNode), me, null, true);
    }
    me._tree = true;
    rootNode.isRoot = true;
    rootNode.joinStore(me);
    if (((_a2 = rootNode.children) == null ? void 0 : _a2.length) || me.rootVisible) {
      rootNode.isLoading = true;
      me.onNodeAddChild(rootNode, rootNode.children || [], 0);
      rootNode.isLoading = false;
    }
    me.trigger("rootChange", { oldRoot, rootNode });
  }
  /**
   * Sets data in the store.
   *
   * Expects an array of JavaScript objects, with properties matching store's fields (defined on its
   * {@link #config-modelClass model} or in the {@link #config-fields} config).
   *
   * Called on initialization if data is in config otherwise call it yourself after ajax call etc. Can also be used to
   * get the raw original data.
   *
   * ```javascript
   * store.data = [
   *     { id : 1, name : 'Linda', city : 'NY' },
   *     { id : 2, name : 'Olivia', city : 'Paris' },
   *     ...
   * ];
   * ```
   *
   * @property {Object[]}
   * @fires refresh
   * @fires change
   * @category Records
   */
  set data(data) {
    this.setStoreData(data);
  }
  // For overridability in engine
  setStoreData(data) {
    const me = this, { idField, childrenField } = me.modelClass;
    if (me.transformFlatData && (data == null ? void 0 : data.length) > 0 && !Object.isExtensible(data[0])) {
      me.useRawData = me.useRawData || {
        disableDuplicateIdCheck: false,
        disableDefaultValue: false,
        disableTypeConversion: false
      };
      data = ObjectHelper.clone(data);
    }
    me.getConfig("plugins");
    me.processConfiguredListeners();
    if (data && !Array.isArray(data)) {
      data = ObjectHelper.transformNamedObjectToArray(data, idField);
    }
    me.tree = !me.isChained && (me.tree || Boolean(me.autoTree && (data == null ? void 0 : data.some((r) => r[childrenField]))));
    if (data && (me.remoteSort || me.remoteFilter)) {
      for (let i = 0; i < data.length; i++) {
        data[i]._remoteSortIndex = i;
      }
    }
    if (!me.syncDataOnLoad || !me._data) {
      me._data = data;
      if (me.tree) {
        if (me.transformFlatData) {
          data = me.treeifyFlatData(data);
        }
        const root = me.rootNode;
        root.isLoading = true;
        me.clear(true);
        root.appendChild(data);
        me.updateDependentStores("dataset", [root]);
        root.isLoading = false;
        if (data.length === 0) {
          const event = { action: "dataset", data: [], records: [] };
          me.trigger("refresh", event);
          me.trigger("change", event);
        } else if (me.isFiltered) {
          me.filter();
        }
      } else {
        me.loadData(data);
      }
      me.added.clear();
      me.removed.clear();
      me.modified.clear();
    } else {
      me.syncDataset(data);
    }
  }
  loadData(data, action = "dataset") {
    var _a2, _b;
    const me = this, { storage, allowNoId } = me, idField = me.modelClass.fieldMap.id.dataSource, creatingRecord = me.find((rec) => rec.isCreating);
    if (creatingRecord) {
      storage.values.splice(me.records.indexOf(creatingRecord), 1);
    }
    let warnGenerated = me.verifyNoGeneratedIds;
    me.removeHeadersAndFooters(me.storage.values);
    me._idMap = null;
    me.oldIdMap = {};
    if (data) {
      const isRaw = !(data[0] instanceof Model);
      if (isRaw) {
        me.modelClass.exposeProperties(data[0]);
        const count = data.length, records = new Array(count);
        for (let i = 0; i < count; i++) {
          const recordData = data[i];
          if (!allowNoId && recordData[idField] == null) {
            throw new Error(`Id required but not found on row ${i}`);
          }
          if (warnGenerated && ((_b = (_a2 = recordData[idField]) == null ? void 0 : _a2.startsWith) == null ? void 0 : _b.call(_a2, "_generated"))) {
            console.warn(`Generated id found in data: ${recordData[idField]}. Generated ids are temporary and should be replaced with real ids by the backend`);
            warnGenerated = false;
          }
          records[i] = me.processRecord(me.createRecord(recordData, true), true);
          records[i].setData("parentIndex", i);
        }
        me.clear(true);
        storage.replaceValues({
          values: records,
          isNewDataset: true,
          silent: true
        });
      } else {
        me.clear(true);
        storage.replaceValues({
          values: data.slice(),
          isNewDataset: true,
          silent: true
        });
      }
      if (creatingRecord && !storage.values.includes(creatingRecord)) {
        storage.values.push(creatingRecord);
      }
      me._data = data;
      me.onDataReplaced(action, data);
    } else {
      me.clear(true);
      me._data = null;
    }
    me.isSyncingDataOnLoad = false;
  }
  get data() {
    return this._data;
  }
  /**
   * Creates an array of records from this store from the `start` to the `end' - 1
   * @param {Number} [start] The index of the first record to return
   * @param {Number} [end] The index *after* the last record to return `(start + length)`
   * @returns {Core.data.Model[]} The requested records.
   * @category Records
   */
  getRange(start, end, all = true) {
    return (all ? this.storage.allValues : this.storage.values).slice(start, end);
  }
  /**
   * Creates a model instance, used internally when data is set/added. Override this in a subclass to do your own custom
   * conversion from data to record.
   * @param {Object} data Json data
   * @param {Boolean} [skipExpose=false] Supply true when batch setting to not expose properties multiple times
   * @category Records
   */
  createRecord(data, skipExpose = false, rawData = false) {
    return new this.modelClass(data, this, null, skipExpose, false, rawData);
  }
  processRecord(record, isDataset = false) {
    return record;
  }
  refreshData() {
    this.filter();
    this.sort();
  }
  onRecordIdChange({ record, oldValue, value }) {
    const me = this, idMap = me._idMap, { idRegister, oldIdMap } = me;
    me.storage._indicesInvalid = true;
    oldIdMap[oldValue] = record;
    if (idMap && !idMap[value]) {
      const entry = idMap[oldValue];
      delete idMap[oldValue];
      idMap[value] = entry;
    }
    me.added.changeId(oldValue, value);
    me.removed.changeId(oldValue, value);
    me.modified.changeId(oldValue, value);
    delete idRegister[oldValue];
    idRegister[value] = record;
    record.index = me.storage.indexOf(record);
  }
  onUpdateRecord(record, changes) {
    const me = this, { internalId } = changes, { internalIdRegister } = me;
    if (internalId) {
      this.storage._indicesInvalid = true;
      delete internalIdRegister[internalId.oldValue];
      internalIdRegister[internalId.value] = record;
    }
    if (me.reapplyFilterOnUpdate && me.isFiltered) {
      me.filter();
    }
  }
  get useRawData() {
    return this._useRawData;
  }
  set useRawData(options) {
    if (options === true) {
      this._useRawData = {
        enabled: true,
        disableDuplicateIdCheck: true,
        disableTypeConversion: true,
        disableDefaultValue: false
      };
    } else {
      this._useRawData = options ? Object.assign(options, { enabled: true }) : { enabled: false };
    }
  }
  //endregion
  //region Count
  /**
   * Number of records in the store
   * @param {Boolean} [countProcessed] Count processed (true) or real records (false)
   * @returns {Number} Record count
   * @category Records
   */
  getCount(countProcessed = true) {
    return countProcessed ? this.count : this.originalCount;
  }
  /**
   * Record count, for data records. Not including records added for group headers etc.
   * @property {Number}
   * @readonly
   * @category Records
   */
  get originalCount() {
    var _a2;
    return this.storage.totalCount - (((_a2 = this.groupRecords) == null ? void 0 : _a2.count) || 0);
  }
  /**
   * Record count, including records added for group headers etc.
   * @property {Number}
   * @readonly
   * @category Records
   */
  get count() {
    return this.storage.count;
  }
  /**
   * Returns the complete dataset size regardless of tree node collapsing or filtering
   * @property {Number}
   * @readonly
   * @category Records
   */
  get allCount() {
    return this.isTree ? this.rootNode.descendantCount : this.storage.totalCount;
  }
  //endregion
  //region Get record(s)
  /**
   * Returns all "visible" records.
   * **Note:** The returned value **may not** be mutated!
   * @property {Core.data.Model[]}
   * @readonly
   * @immutable
   * @category Records
   */
  get records() {
    return this.storage.values;
  }
  /**
   * Get the first record in the store.
   * @property {Core.data.Model}
   * @readonly
   * @category Records
   */
  get first() {
    return this.storage.values[0];
  }
  /**
   * Get the last record in the store.
   * @property {Core.data.Model}
   * @readonly
   * @category Records
   */
  get last() {
    return this.storage.values[this.storage.values.length - 1];
  }
  /**
   * Get the record at the specified index
   * @param {Number} index Index for the record
   * @returns {Core.data.Model} Record at the specified index
   * @category Records
   */
  getAt(index, all = false) {
    return this.storage.getAt(index, all);
  }
  // These are called by Model#join and Model#unjoin
  // register a record as a findable member keyed by id and internalId
  register(record) {
    const me = this;
    if (!me.useRawData.disableDuplicateIdCheck) {
      const existingRec = me.isTree && me.idRegister[record.id];
      if (existingRec && existingRec !== record) {
        throw new Error(`Id collision on ${record.id}`);
      }
    }
    me.idRegister[record.id] = record;
    me.internalIdRegister[record.internalId] = record;
  }
  unregister(record) {
    delete this.idRegister[record.id];
    delete this.internalIdRegister[record.internalId];
  }
  get registeredRecords() {
    return Object.values(this.idRegister);
  }
  /**
   * Get a record by id. Find the record even if filtered out, part of collapsed group or collapsed node
   * @param {Core.data.Model|String|Number} id Id of record to return.
   * @returns {Core.data.Model} A record with the specified id
   * @category Records
   */
  getById(id) {
    if (id == null ? void 0 : id.isModel) {
      const record = id;
      if (record.hasLinks && !this.storage.allValues.includes(record)) {
        return record.$links.find((r) => this.storage.allValues.includes(r));
      }
      return record;
    }
    return this.idRegister[id];
  }
  /**
   * Checks if a record is available, in the sense that it is not filtered out,
   * hidden in a collapsed group or in a collapsed node.
   * @param {Core.data.Model|String|Number} recordOrId Record to check
   * @returns {Boolean}
   * @category Records
   */
  isAvailable(recordOrId) {
    const record = this.getById(recordOrId);
    return record && this.storage.includes(record) || false;
  }
  /**
   * Get a record by internalId.
   * @param {Number} internalId The internalId of the record to return
   * @returns {Core.data.Model} A record with the specified internalId
   * @category Records
   */
  getByInternalId(internalId) {
    return this.internalIdRegister[internalId];
  }
  /**
   * Checks if the specified record is contained in the store
   * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record
   * @returns {Boolean}
   * @category Records
   */
  includes(recordOrId) {
    if (this.isTree) {
      return this.idRegister[Model.asId(recordOrId)] != null;
    }
    return this.indexOf(recordOrId) > -1;
  }
  //endregion
  //region Get index
  /**
   * Returns the index of the specified record/id, or `-1` if not found.
   * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record to return the index of.
   * @param {Boolean} [visibleRecords] Pass `true` to find the visible index.
   * as opposed to the dataset index. This omits group header records.
   * @param {Boolean} [allExceptFilteredOutRecords] For trees, when true this searches all except filtered out records
   * in the flattened tree, similar to a flat store.
   * @returns {Number} Index for the record/id, or `-1` if not found.
   * @category Records
   */
  indexOf(recordOrId, visibleRecords = false, allExceptFilteredOutRecords = false) {
    if ((recordOrId == null ? void 0 : recordOrId.isModel) && !recordOrId.stores.includes(this.$store || this)) {
      const linkedRecord = recordOrId.$links.find((r) => this.storage.allValues.includes(r));
      if (linkedRecord) {
        return this.indexOf(linkedRecord, visibleRecords);
      }
      return -1;
    }
    if (this.isTree) {
      return (allExceptFilteredOutRecords ? this.rootNode.allChildren : this.storage.values).indexOf(this.getById(recordOrId));
    }
    const id = Model.asId(recordOrId);
    if (id == null) {
      return -1;
    }
    const found = this.idMap[id];
    return found ? found[visibleRecords ? "visibleIndex" : "index"] : -1;
  }
  allIndexOf(recordOrId) {
    if (this.isTree) {
      return this.allRecords.indexOf(this.getById(recordOrId));
    } else {
      return this.storage.indexOf(recordOrId, true);
    }
  }
  //endregion
  //region Get values
  /**
   * Returns an array of distinct values for the specified field.
   *
   * ```javascript
   * store.getDistinctValues('age'); // Returns an array of the unique age values
   * ```
   *
   * @param {String} field Field to extract values for
   * @param {Boolean} [includeFilteredOutRecords] True to ignore any applied filters
   * @returns {Array} Array of values
   * @category Values
   */
  getDistinctValues(field, includeFilteredOutRecords = false) {
    const me = this, values = [], keys = {};
    let value;
    me.forEach((r) => {
      if (!r.isSpecialRow && !r.isRoot) {
        value = r.getValue(field);
        const primitiveValue = value instanceof Date ? value.getTime() : value;
        if (!keys[primitiveValue]) {
          values.push(value);
          keys[primitiveValue] = 1;
        }
      }
    }, me, { includeCollapsedGroupRecords: true, includeFilteredOutRecords });
    return values;
  }
  /**
   * Counts how many times the specified value appears in the store
   * @param {String} field Field to look in
   * @param {*} value Value to look for
   * @returns {Number} Found count
   * @category Values
   */
  getValueCount(field, value) {
    let count = 0;
    this.forEach((r) => {
      if (ObjectHelper.isEqual(r.getValue(field), value))
        count++;
    });
    return count;
  }
  //endregion
  //region JSON & console
  /**
   * Retrieve or set the data of all records as a JSON string
   *
   * ```javascript
   * const store = new Store({
   *     data : [
   *         { id : 1, name : 'Superman' },
   *         { id : 2, name : 'Batman' }
   *     ]
   * });
   *
   * const jsonString = store.json;
   *
   * //jsonString:
   * '[{"id":1,"name":"Superman"},{"id":2,"name":"Batman"}]
   * ```
   *
   * @property {String}
   */
  set json(json) {
    if (typeof json === "string") {
      json = StringHelper.safeJsonParse(json);
    }
    this.data = json;
  }
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  /**
   * Pretty printed version of {@link #property-json}
   * @readonly
   * @property {String}
   */
  get formattedJSON() {
    return StringHelper.safeJsonStringify(this, null, 4);
  }
  /**
   * Retrieve the data of all (unfiltered) records as an array of JSON objects.
   *
   * ```javascript
   * const store = new Store({
   *     data : [
   *         { id : 1, name : 'Superman' },
   *         { id : 2, name : 'Batman' }
   *     ]
   * });
   *
   * const jsonArray = store.toJSON();
   *
   * //jsonArray:
   * [{id:1,name:"Superman"},{id:2,name:"Batman"}]
   * ```
   *
   * @returns {Object[]}
   */
  toJSON() {
    return (this.isTree ? this.rootNode.unfilteredChildren || this.rootNode.children || [] : this.allRecords).map((record) => record.toJSON());
  }
  //endregion
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs(configs);
    delete configs.project;
  }
  // Extract current data for all accessible records
  getInlineData(options) {
    var _a2;
    const data = [];
    if (this.tree) {
      (_a2 = this.rootNode.children) == null ? void 0 : _a2.forEach((r) => data.push(r.getCurrentConfig(options)));
    } else {
      this.forEach((r) => data.push(r.getCurrentConfig(options)));
    }
    return data;
  }
  // Extract current configs and data
  getCurrentConfig(options) {
    var _a2;
    const result = super.getCurrentConfig(options), { state } = this;
    if (result) {
      if (result.data) {
        result.data = this.getInlineData(options);
      }
      delete result.project;
      delete result.stm;
      delete result.asyncEvents;
      if (((_a2 = result.modelClass) == null ? void 0 : _a2.$meta.hierarchy[result.modelClass.$meta.hierarchy.length - 2]) === this.constructor.defaultConfig.modelClass) {
        delete result.modelClass;
      }
      if (!this.tree) {
        delete result.tree;
      }
      if (state) {
        Object.assign(result, state);
      }
    }
    return result;
  }
  //endregion
  //region Iteration & traversing
  /**
   * Iterates over all normal records in store. Omits group header and footer records if this store is grouped.
   * @param {Function} fn A function that is called for each record. Returning `false` from that function cancels
   * iteration. It is called with the following arguments:
   * @param {Core.data.Model} fn.record Current record
   * @param {Number} fn.index Current index
   * @param {Object} [thisObj] `this` reference for the function
   * @param {Object|Boolean} [options] A boolean for `includeFilteredOutRecords`, or detailed options for
   * exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] `true` to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] `true` to also include records from collapsed groups of
   * grouped store
   * @category Iteration
   */
  forEach(fn, thisObj = this, options) {
    const me = this, callback = (r, i) => {
      if (!r.isRoot && !r.isSpecialRow) {
        return fn.call(thisObj, r, i);
      }
    };
    options = fixTraverseOptions2(me, options);
    if (me.isTree) {
      if (me.isChained) {
        options = {
          ...options,
          sorterFn: me.sorterFn
        };
      }
      me.rootNode.traverseWhile(callback, false, options);
    } else {
      const records = options.includeFilteredOutRecords ? me.storage.allValues : me.storage.values;
      if (me.isGrouped && options.includeCollapsedGroupRecords) {
        for (let i = 0; i < records.length; i++) {
          const record = records[i], groupChildren = options.includeFilteredOutRecords ? record.unfilteredGroupChildren : record.groupChildren;
          if (groupChildren && record.meta.collapsed === true) {
            for (let j = 0; j < groupChildren.length; j++) {
              const rec = groupChildren[j];
              if (callback(rec, j) === false) {
                return;
              }
            }
          } else if (callback(record, i) === false) {
            return;
          }
        }
      } else {
        for (let i = 0; i < records.length; i++) {
          if (callback(records[i], i) === false) {
            return;
          }
        }
      }
    }
  }
  /**
   * Equivalent to Array.map(). Creates a new array with the results of calling a provided function on every record
   * @param {Function} fn
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {Array}
   * @category Iteration
   */
  map(fn, thisObj = this) {
    return this.storage.values.map(fn, thisObj);
  }
  /**
   * Equivalent to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap Array.flatMap()}.
   * Creates a new array by spreading the results of calling a provided function on every record
   * @param {Function} fn A function returning an array of items to be spread into the new array, or a single item to include in it
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {Array} The new array
   * @category Iteration
   */
  flatMap(fn, thisObj = this) {
    return this.storage.values.flatMap(fn, thisObj);
  }
  /**
   * Equivalent to Array.every(). Returns `true` if every call of the provided function
   * on each record yields a truthy value.
   * @param {Function} fn
   * @param {Function} fn.record The record to test.
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store.
   * @param {Boolean} [ignoreFilters] Pass `true` to iterate all records including filtered out ones.
   * @returns {Array}
   * @category Iteration
   */
  every(fn, thisObj = this, ignoreFilters) {
    return this.storage[ignoreFilters ? "allValues" : "values"].every(fn, thisObj);
  }
  /**
   * Equivalent to Array.reduce(). Applies a function against an accumulator and each record (from left to right) to
   * reduce it to a single value.
   * @param {Function} fn
   * @param {*} initialValue
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {*}
   * @category Iteration
   */
  reduce(fn, initialValue = [], thisObj = this) {
    if (thisObj !== this) {
      fn = fn.bind(thisObj);
    }
    return this.storage.values.reduce(fn, initialValue, thisObj);
  }
  /**
   * Iterator that allows you to do for (let record of store)
   * @category Iteration
   */
  [Symbol.iterator]() {
    return this.storage.values[Symbol.iterator]();
  }
  /**
   * Traverse all tree nodes (only applicable for Tree Store)
   * @param {Function} fn The function to call on visiting each node.
   * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.
   * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or detailed options for exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] True to also include records from collapsed groups of grouped store
   * @param {Boolean} [options.useOrderedTree] True to traverse unsorted/unfiltered tree
   * @category Traverse
   */
  traverse(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions2(me, options);
    if (me.isTree) {
      if (typeof topNode === "boolean") {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn;
        fn = (node) => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverse(fn, skipTopNode, options);
    } else {
      me.forEach((rec) => rec.traverse(fn, false, options), me, options);
    }
  }
  /**
   * Traverse all tree nodes while the passed `fn` returns true
   * @param {Function} fn The function to call on visiting each node. Returning `false` from it stops the traverse.
   * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.
   * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.
   * @param {Object} [options] An options object to exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] True to also include records from collapsed groups of grouped store
   * @category Traverse
   */
  traverseWhile(fn, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions2(me, options);
    if (me.isTree) {
      if (typeof topNode === "boolean") {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn;
        fn = (node) => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverseWhile(fn, skipTopNode, options);
    } else {
      for (const record of me.storage) {
        if (record.traverse(fn, false, options) === false) {
          break;
        }
      }
    }
  }
  /**
   * Finds the next record.
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap=false] Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model} Next record or null if current is the last one
   * @category Traverse
   */
  getNext(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this, records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    const record = records[idx + 1];
    if (skipSpecialRows && record && record.isSpecialRow) {
      return me.getNext(records[idx + 1], wrap, true);
    }
    return record;
  }
  /**
   * Finds the previous record.
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap=false] Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model} Previous record or null if current is the last one
   * @category Traverse
   */
  getPrev(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this, records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    const record = records[idx - 1];
    if (skipSpecialRows && record && record.isSpecialRow && idx > 0) {
      return me.getPrev(records[idx - 1], wrap, true);
    }
    return record;
  }
  /**
   * Gets the next or the previous record. Optionally wraps from first -> last and vice versa
   * @param {String|Core.data.Model} recordOrId Record or records id
   * @param {Boolean} next Next (true) or previous (false)
   * @param {Boolean} wrap Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model}
   * @category Traverse
   * @internal
   */
  getAdjacent(recordOrId, next = true, wrap = false, skipSpecialRows = false) {
    return next ? this.getNext(recordOrId, wrap, skipSpecialRows) : this.getPrev(recordOrId, wrap, skipSpecialRows);
  }
  /**
   * Finds the next record among leaves (in a tree structure)
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model} Next record or null if current is the last one
   * @category Traverse
   * @internal
   */
  getNextLeaf(recordOrId, wrap = false) {
    const me = this, records = me.leaves, record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    return records[idx + 1];
  }
  /**
   * Finds the previous record among leaves (in a tree structure)
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model} Previous record or null if current is the last one
   * @category Traverse
   * @internal
   */
  getPrevLeaf(recordOrId, wrap = false) {
    const me = this, records = me.leaves, record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    return records[idx - 1];
  }
  /**
   * Gets the next or the previous record among leaves (in a tree structure). Optionally wraps from first -> last and
   * vice versa
   * @param {String|Core.data.Model} recordOrId Record or record id
   * @param {Boolean} [next] Next (true) or previous (false)
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model}
   * @category Traverse
   * @internal
   */
  getAdjacentLeaf(recordOrId, next = true, wrap = false) {
    return next ? this.getNextLeaf(recordOrId, wrap) : this.getPrevLeaf(recordOrId, wrap);
  }
  //endregion
};
Store.initClass();
Store._$name = "Store";

// ../Core/lib/Core/data/AjaxStore.js
var processParamEntry = (paramArray, entry) => {
  if (Array.isArray(entry[1])) {
    entry[1].forEach((value) => paramArray.push(encodeURIComponent(entry[0]) + "=" + encodeURIComponent(value)));
  } else {
    paramArray.push(encodeURIComponent(entry[0]) + "=" + encodeURIComponent(entry[1]));
  }
  return paramArray;
};
var immediatePromise2 = Promise.resolve();
var prependZeros = (num) => {
  return String(num).padStart(2, "0");
};
var dateToString = (date) => {
  return `${date.getFullYear()}-${prependZeros(date.getMonth() + 1)}-${prependZeros(date.getDate())}T${prependZeros(date.getHours())}:${prependZeros(date.getMinutes())}:${prependZeros(date.getSeconds())}.${date.getMilliseconds()}`;
};
var AjaxStore = class extends Store {
  // region Events
  /**
   * Fired when a remote request fails, either at the network level, or the server returns a failure, or an invalid
   * response.
   *
   * Note that when a {@link #function-commit} fails, more than one exception event will be triggered. The individual
   * operation, `create`, `update` or `delete` will trigger their own `exception` event, but the encapsulating commit
   * operation will also trigger an `exception` event when all the operations have finished, so if exceptions are
   * going to be handled gracefully, the event's `action` property must be examined, and the constituent operations of
   * the event must be examined.
   * @event exception
   * @param {Core.data.Store} source This Store
   * @param {Boolean} exception `true`
   * @param {'create'|'read'|'update'|'delete'|'commit'} action Action that failed, `'create'`, `'read'`,
   * `'update'` or `'delete'`. May also be fired with '`commit'` to indicate the failure of an aggregated `create`,
   * `update` and `delete` operation. In this case, the event will contain a property for each operation of the commit
   * named `'create'`, `'update'` and `'delete'`, each containing the individual `exception` events.
   * @param {'network'|'failure'} exceptionType The type of failure, `'network'` or `'server'`
   * @param {Response} response the `Response` object
   * @param {Object} json The decoded response object *if the exceptionType is `'server'`*
   */
  /**
   * Fired after committing added records
   * @event commitAdded
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired after committing modified records
   * @event commitModified
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired on successful load
   * @event load
   * @param {Core.data.Store} source This Store
   * @param {Object[]} data Data loaded
   * @param {Response} response the `Response` object
   * @param {Object} json The decoded response object.
   */
  /**
   * Fired on successful load of remote child nodes for a tree node.
   * @event loadChildren
   * @param {Core.data.Store} source This Store
   * @param {Object[]} data Data loaded
   * @param {Object} json The decoded response object.
   */
  /**
   * Fired after committing removed records
   * @event commitRemoved
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired before loading starts. Allows altering parameters and is cancelable
   * @event beforeLoad
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired before loading of remote child nodes of a tree node starts. Allows altering parameters and is cancelable
   * @event beforeLoadChildren
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * When the store {@link #property-isPaged is paged}, this is fired before loading a page and is cancelable
   * @event beforeLoadPage
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired when loading is beginning. This is not cancelable. Parameters in the event may still be
   * mutated at this stage.
   * @event loadStart
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired when loading of remote child nodes into a tree node is beginning. This is not cancelable. Parameters in the
   * event may still be mutated at this stage.
   * @event loadChildrenStart
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired before any remote request is initiated.
   * @event beforeRequest
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing key/value pairs that are passed on the request query string
   * @param {Object} body The body of the request to be posted to the server.
   * @param {'create'|'read'|'update'|'delete'} action Action that is making the request, `'create'`,
   * `'read'`, `'update'` or `'delete'`
   */
  /**
   * Fired after any remote request has finished whether successfully or unsuccessfully.
   * @event afterRequest
   * @param {Boolean} exception `true`. *Only present if the request triggered an exception.*
   * @param {'create'|'read'|'update'|'delete'} action Action that has finished, `'create'`, `'read'`,
   * `'update'` or `'delete'`
   * @param {'network'|'failure'} exceptionType The type of failure, `'network'` or `'server'`. *Only present
   * if the request triggered an exception.*
   * @param {Response} response The `Response` object
   * @param {Object} json The decoded response object if there was no `'network'` exception.
   */
  // endregion
  //region Config
  static get defaultConfig() {
    return {
      /**
       * A string keyed object containing the HTTP headers to add to each server request issued by this store.
       *
       * `AjaxStore` uses the Fetch API under the hood, read more about headers on
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#headers)
       *
       * Example usage:
       *
       * ```javascript
       * const store = new AjaxStore({
       *    headers : {
       *        Authorization : 'auth-contents-goes-here'
       *    }
       * });
       * ```
       *
       * @config {Object<String,String>}
       * @category Remote
       */
      headers: null,
      /**
       * An object containing the Fetch options to pass to each server request issued by this store. Use this to
       * control if credentials are sent and other options, read more at
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#supplying_request_options).
       *
       * Example usage:
       *
       * ```javascript
       * const store = new AjaxStore({
       *    fetchOptions : {
       *        credentials : 'omit',
       *        redirect    : 'error'
       *    }
       * });
       * ```
       *
       * @config {Object}
       * @category Remote
       */
      fetchOptions: null,
      /**
       * Specify `true` to send payloads as form data, `false` to send as regular JSON.
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      sendAsFormData: null,
      /**
       * Specify `true` to send all model fields when committing modified records (as opposed to just the
       * modified fields)
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      writeAllFields: null,
      /**
       * The name of the HTTP parameter passed to this Store's {@link #config-readUrl} to indicate the node `id`
       * to load when loading child nodes on demand if the node being expanded was created with data containing
       * `children: true`.
       * @config {String}
       * @default
       * @category Remote
       */
      parentIdParamName: "id",
      /**
       * The optional property name in JSON responses from the server that contains a boolean
       * success/fail status.
       * ```json
       * {
       *   "responseMeta" : {
       *   {
       *     "success" : true,
       *     "count" : 100
       *   },
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ]
       * }
       * ```
       *
       * The store would be configured with:
       * ```javascript
       *  {
       *      ...
       *      successDataProperty : 'responseMeta.success',
       *      responseTotalProperty : 'responseMeta.count'
       *      ...
       *  }
       *
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseSuccessProperty: "success",
      /**
       * The property name in JSON responses from the server that contains the data for the records
       * ```json
       * {
       *   "success" : true,
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ]
       * }
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseDataProperty: "data",
      /**
       * The property name in JSON responses from the server that contains the dataset total size
       * **when this store {@link #property-isPaged is paged}**
       * ```json
       * {
       *   "success" : true,
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ],
       *   // The property name used here should match that of 'responseTotalProperty'
       *   "total" : 65535
       * }
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseTotalProperty: "total",
      /**
       * The name of the HTTP parameter to use to pass any encoded filters when loading data from the server and a
       * filtered response is required.
       *
       * **Note:** When this is set, filters must be defined using a field name, an operator and a value
       * to compare, **not** a comparison function.
       * @config {String}
       * @category Remote
       */
      filterParamName: null,
      /**
       * Set this flag to true if you are filtering remote using restful URLs (e.g.
       * https://nominatim.openstreetmap.org/search/paris?format=json)
       *
       * **Note:** When this is set, the filter string is appended to the readUrl.
       * @config {Boolean}
       * @category Remote
       */
      restfulFilter: false,
      /**
       * The name of the HTTP parameter to use to pass any encoded sorters when loading data from the server and a
       * sorted response is required.
       *
       * **Note:** When this is set, sorters must be defined using a field name and an ascending flag,
       * **not** a sort function.
       * @config {String}
       * @category Remote
       */
      sortParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **one based** page number
       * required.
       * @config {String}
       * @category Paging
       */
      pageParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the
       * required page's starting record.
       * @config {String}
       * @category Paging
       */
      pageStartParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the
       * required page's starting record.
       * @config {String}
       * @default
       * @category Paging
       */
      pageSizeParamName: "pageSize",
      /**
       * Set to ´true´ to use restful {@link #config-httpMethods}
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      useRestfulMethods: null,
      /**
       * The HTTP methods to use for CRUD requests when {@link #config-useRestfulMethods} is enabled.
       *
       * ```javascript
       * new AjaxStore({
       *    useRestfulMethods : true,
       *    httpMethods : {
       *        create : 'POST',
       *        read   : 'POST',
       *        update : 'PATCH',
       *        delete : 'DELETE'
       *    }
       * });
       *
       * ```
       * @config {HttpMethods}
       * @default
       * @category Remote
       */
      httpMethods: {
        create: "POST",
        read: "GET",
        update: "PUT",
        delete: "DELETE"
      }
    };
  }
  // This function is called to automatically reload page whenever pageSize is set at runtime.
  updatePageSize(pageSize) {
    const me = this;
    if (!this.isConfiguring) {
      const currentPage = me.currentPage = me.currentPage ? Math.min(
        me.currentPage,
        Math.floor((me.allCount + pageSize - 1) / pageSize)
      ) : 1;
      if (pageSize) {
        me.loadPage(currentPage);
      }
    }
  }
  /**
   * Url to post newly created records to.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} createUrl
   * @category CRUD
   */
  /**
   * Url to read data from.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * If the store {@link #property-isPaged is paged}, the total dataset size must be returned in the
   * {@link #config-responseTotalProperty} property:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }],
   *         "total": 65535
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} readUrl
   * @category CRUD
   */
  /**
   * Url to post record modifications to.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} updateUrl
   * @category CRUD
   */
  /**
   * Url for deleting records.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true
   *     }
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} deleteUrl
   * @category CRUD
   */
  /**
   * True to initiate a load when the store is instantiated
   * @config {Boolean} autoLoad
   * @category Common
   */
  //endregion
  afterConstruct(config) {
    super.afterConstruct(config);
    if (this.autoLoad) {
      this.load().catch(() => {
      });
    }
  }
  /**
   * Returns a truthy value if the Store is currently loading.
   *
   * A load operation is initiated by a load call, but the network request is not sent until
   * after a delay until the next event loop because of allowing all operations which may
   * request a load to coalesce into one call.
   *
   * If the loading request is in this waiting state, the value will be `1`,
   *
   * If the network request is in flight, the value will be `2`
   * @property {Boolean|Number}
   * @readonly
   * @category CRUD
   */
  get isLoading() {
    return this._isLoading ? 2 : this.loadTriggerPromise ? 1 : false;
  }
  /**
   * Returns true if the Store is currently committing
   * @property {Boolean}
   * @readonly
   * @category CRUD
   */
  get isCommitting() {
    return Boolean(this.commitPromise);
  }
  set pageParamName(pageParamName) {
    if (this.tree) {
      throw new Error("Paging cannot be supported for tree stores");
    }
    if (this.pageStartParamName) {
      throw new Error("Configs pageStartParamName and pageParamName are mutually exclusive");
    }
    this._pageParamName = pageParamName;
  }
  get pageParamName() {
    return this._pageParamName;
  }
  set pageStartParamName(pageStartParamName) {
    if (this.tree) {
      throw new Error("Paging cannot be supported for tree stores");
    }
    if (this.pageParamName) {
      throw new Error("Configs pageParamName and pageStartParamName are mutually exclusive");
    }
    this._pageStartParamName = pageStartParamName;
  }
  get pageStartParamName() {
    return this._pageStartParamName;
  }
  /**
   * Yields true if this Store is loaded page by page. This yields `true` if either of the
   * {@link #config-pageParamName} of {@link #config-pageStartParamName} configs are set.
   * @property {Boolean}
   * @readonly
   * @category Paging
   */
  get isPaged() {
    return this.pageParamName || this.pageStartParamName;
  }
  /**
   * Yields the complete dataset size. If the store is {@link #property-isPaged is paged} this is the value
   * returned in the last loaded data block in the {@link #config-responseTotalProperty} property. Otherwise it is
   * the number of records in the store's underlying storage collection.
   * @property {Number}
   * @readonly
   * @category Paging
   */
  get allCount() {
    return "remoteTotal" in this ? this.remoteTotal : super.allCount;
  }
  /**
   * **If the store {@link #property-isPaged is paged}**, yields the highest page number in the dataset as calculated
   * from the {@link #config-responseTotalProperty}
   * returned in the last page data block loaded.
   * @property {Number}
   * @readonly
   * @category Paging
   */
  get lastPage() {
    if (this.isPaged) {
      return Math.floor((this.allCount + this.pageSize - 1) / this.pageSize);
    }
  }
  buildQueryString(url, ...paramObjects) {
    const hasParamsInUrl = url.includes("?"), queryString = Object.entries(Object.assign({}, ...paramObjects)).reduce(processParamEntry, []).join("&");
    return queryString ? (hasParamsInUrl ? "&" : "?") + queryString : "";
  }
  /**
   * Internal sort method.
   * Should not be used in application code directly.
   * @param silent
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @internal
   */
  async performSort(silent) {
    const me = this;
    if (me.remoteSort && !me.isRemoteDataLoading) {
      me.isRemoteDataLoading = true;
      const result = await me.internalLoad({}, "", (event) => {
        me.data = event.data;
        me.afterPerformSort(silent);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performSort(silent);
    }
  }
  /**
   * Internal filter method.
   * Should not be used in application code directly.
   * @param silent
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @internal
   */
  async performFilter(silent) {
    var _a2;
    const me = this;
    if (me.remoteFilter) {
      (_a2 = me.loadingPromise) == null ? void 0 : _a2.abort();
      me.isRemoteDataLoading = true;
      const oldCount = me.count, { filters } = me;
      me.currentPage = 1;
      const result = await me.internalLoad({}, "", (event) => {
        me.data = event.data;
        event = silent ? null : {
          action: "filter",
          filters,
          oldCount,
          records: me.storage.values
        };
        me.afterPerformFilter(event);
        me.trigger("refresh", event);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performFilter(silent);
    }
  }
  /**
   * A provided function which creates an array of values for the {@link #config-filterParamName} to pass
   * any filters to the server upon load.
   *
   * By default, this creates a JSON string containing the following properties:
   *
   * ```javascript
   *    [{
   *        field         : <theFieldName>
   *        operator      : May be: `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`, `'startsWith'`, `'endsWith'`
   *        value         : The value to compare
   *        caseSensitive : true for case sensitive comparisons
   *    }]
   * ```
   * @param {Core.util.CollectionFilter[]} filters The filters to encode.
   */
  encodeFilterParams(filters) {
    const result = [];
    for (const { property, operator, value, caseSensitive } of filters) {
      result.push({
        field: property,
        operator,
        value,
        caseSensitive
      });
    }
    return JSON.stringify(result, function(key, value) {
      return key === "" ? value : this[key] instanceof Date ? dateToString(this[key]) : value;
    });
  }
  /**
   * A provided function which creates an array of values for the {#config-sortParamName} to pass
   * any sorters to the server upon load.
   *
   * By default, this creates a JSON string containing the following properties:
   *
   * ```javascript
   *    [{
   *        field     : <theFieldName>
   *        ascending : true/false
   *    }]
   * ```
   *
   * @param {Sorter[]} sorters The sorters to encode.
   */
  encodeSorterParams(sorters) {
    return JSON.stringify(sorters.filter((sorter) => !sorter.sortFn).map((sorter) => sorter));
  }
  buildReadUrl() {
    const { readUrl } = this;
    if (this.restfulFilter && this.filters.count) {
      const url = readUrl.endsWith("/") ? readUrl : readUrl + "/";
      return url + this.filters.first.value;
    }
    return readUrl;
  }
  /**
   * Internal data loading method.
   * @returns {Promise}
   * @internal
   */
  internalLoad(params, eventName, successFn, delay = 0) {
    params = ObjectHelper.assign({}, this.params, params);
    const me = this, url = me.buildReadUrl(), event = { action: "read" + eventName, params, url };
    if (!url) {
      throw new Error("No load url specified");
    }
    if (me.trigger("beforeLoad" + eventName, event) === false) {
      throw false;
    }
    me.loadArgs = [url, event, params, eventName, successFn];
    if (delay === false) {
      return new Promise((resolve, reject) => me.sendLoadRequest(resolve, reject));
    }
    return me.loadTriggerPromise || (me.loadTriggerPromise = new Promise((resolve, reject) => {
      me.setTimeout({
        delay,
        fn: "sendLoadRequest",
        args: [resolve, reject],
        cancelOutstanding: true
      });
    }));
  }
  // Send the request for the internalLoad.
  // This is called on a timeout 1ms after the internalLoad call.
  async sendLoadRequest(resolve, reject) {
    const me = this, [
      url,
      event,
      params,
      eventName,
      successFn
    ] = me.loadArgs;
    me.loadTriggerPromise = null;
    if (url) {
      me._isLoading = true;
      me.trigger(`load${eventName}Start`, event);
      me.trigger("beforeRequest", event);
      if (me.filterParamName && me.isFiltered) {
        params[me.filterParamName] = me.encodeFilterParams(me.filters.values);
      }
      if (me.remoteSort && me.isSorted) {
        params[me.sortParamName] = me.encodeSorterParams(me.groupers ? me.groupers.concat(me.sorters) : me.sorters);
      }
      if (me.isPaged) {
        if (!(me.pageParamName in params || me.pageStartParamName in params)) {
          const page = Math.min(me.currentPage || 1, me.allCount ? me.lastPage : Infinity);
          if (me.pageParamName) {
            params[me.pageParamName] = page;
          } else {
            params[me.pageStartParamName] = (page - 1) * me.pageSize;
          }
        }
        params[me.pageSizeParamName] = me.pageSize;
      }
      const options = { headers: me.headers, parseJson: true };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.read;
        if (event.body) {
          options.body = JSON.stringify(event.body);
        }
      }
      try {
        const promise = me.loadingPromise = AjaxHelper.get(event.url + me.buildQueryString(event.url, params), ObjectHelper.assign(options, me.fetchOptions)), response = await promise, data = response.parsedJson, isArray3 = Array.isArray(data), success = isArray3 || data && ObjectHelper.getPath(data, me.responseSuccessProperty) !== false, remoteTotal = isArray3 ? null : ObjectHelper.getPath(data, me.responseTotalProperty);
        if (me.isDestroyed) {
          return;
        }
        me.loadingPromise = null;
        me._isLoading = false;
        event.response = response;
        event.json = data;
        if (success) {
          if (remoteTotal != null) {
            me.remoteTotal = parseInt(remoteTotal, 10);
          }
          if (me.isPaged) {
            if (me.remoteTotal >= 0) {
              const requestedPage = me.pageParamName ? params[me.pageParamName] : params[me.pageStartParamName] / me.pageSize + 1;
              me.currentPage = Math.min(requestedPage, me.lastPage);
            } else {
              throw new Error("A paged store must receive its responseTotalProperty in each data packet");
            }
          }
          event.data = isArray3 ? data : ObjectHelper.getPath(data, me.responseDataProperty);
          await successFn(event);
          !me.isDestroyed && me.trigger("load" + eventName, event);
          resolve(event);
        } else {
          Object.assign(event, {
            exception: true,
            exceptionType: "server",
            error: data == null ? void 0 : data.error
          });
          !me.isDestroyed && me.trigger("exception", event);
          reject(event);
        }
        !me.isDestroyed && me.trigger("afterRequest", event);
      } catch (responseOrError) {
        me._isLoading = false;
        event.exception = true;
        if (responseOrError instanceof Response) {
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        !me.isDestroyed && me.trigger("exception", event);
        reject(event);
        !me.isDestroyed && me.trigger("afterRequest", event);
      }
    }
  }
  /**
   * Load data from the {@link #config-readUrl}.
   * @param {Object} [params] A hash of parameters to append to querystring (will also append Store#params)
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoad} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoad} handler.
   * @fires beforeLoad
   * @fires loadStart
   * @fires beforeRequest
   * @fires load
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async load(params) {
    const me = this;
    if (me.isPaged) {
      return me.loadPage(me.currentPage || 1, params);
    } else {
      return me.internalLoad(params, "", (event) => {
        me.data = event.data;
      });
    }
  }
  /**
   * Loads children into specified parent record. Parent records id is sent as a param (param name configured with
   * {@link #config-parentIdParamName}.
   * @param {Core.data.Model} parentRecord Parent record
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoadChildren} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoadChildren} handler.
   * @fires beforeLoadChildren
   * @fires loadChildrenStart
   * @fires beforeRequest
   * @fires loadChildren
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async loadChildren(parentRecord) {
    return this.readUrl ? this.internalLoad({ [this.parentIdParamName]: parentRecord.id }, "Children", (event) => {
      event.parentRecord = parentRecord;
      if (parentRecord.children.length) {
        parentRecord.clearChildren(true);
      }
      parentRecord.data[parentRecord.constructor.childrenField] = event.data;
      parentRecord.processChildren(parentRecord.stores);
    }, false) : this.immediatePromise;
  }
  /**
   * Loads a page of data from the {@link #config-readUrl}.
   * @param {Number} page The *one based* page number to load.
   * @param {Object} params A hash of parameters to append to querystring (will also append Store#params)
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoadPage} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoadPage} handler.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async loadPage(page, params) {
    if (this.allCount) {
      page = Math.min(page, this.lastPage);
    }
    const me = this, pageParam = me.pageParamName ? {
      [me.pageParamName]: page
    } : {
      [me.pageStartParamName]: (page - 1) * me.pageSize
    };
    pageParam[me.pageSizeParamName] = me.pageSize;
    return me.internalLoad(ObjectHelper.assign(pageParam, params), "Page", (event) => {
      me.loadData(event.data, "pageLoad");
    });
  }
  /**
   * If this store {@link #property-isPaged is paged}, and is not already at the {@link #property-lastPage}
   * then this will load the next page of data.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
   */
  async nextPage(params) {
    const me = this;
    return me.isPaged && me.currentPage !== me.lastPage ? me.loadPage(me.currentPage + 1, params) : immediatePromise2;
  }
  /**
   * If this store {@link #property-isPaged is paged}, and is not already at the first page
   * then this will load the previous page of data.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
   */
  async previousPage(params) {
    return this.isPaged && this.currentPage !== 1 ? this.loadPage(this.currentPage - 1, params) : immediatePromise2;
  }
  /**
   * Commits all changes (added, modified and removed) using corresponding urls ({@link #config-createUrl},
   * {@link #config-updateUrl} and {@link #config-deleteUrl})
   * @fires beforeCommit
   * @returns {Promise} A Promise which is resolved only if all pending changes (Create, Update and Delete)
   * successfully resolve. Both the resolve and reject functions are passed a `commitState` object which is stored the
   * {@link #event-afterRequest} event for each request. Each event contains the `exception`, `request` and `response`
   * properties eg:
   *
   * ```javascript
   * {
   *      // If *all* commits succeeded
   *      success: true,
   *      changes: {
   *          added: [records...],
   *          modified: [records...],
   *          removed: [records...],
   *      },
   *      added: {
   *          source: theStore,
   *
   *          // Only if the add request triggered an exception
   *          exception: true,
   *
   *          // Only if the add request triggered an exception
   *          exceptionType: 'server', // Or 'network'
   *
   *          response: Response,
   *          json: parsedResponseObject
   *      },
   *      // Same format as added
   *      modified: {},
   *      removed: {}
   * }
   * ```
   *
   * If there were no pending changes, the resolve and reject functions are passed no parameters.
   *
   * Returns `false` if a commit operation is already in progress.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * @category CRUD
   */
  async commit() {
    const me = this, { changes } = me, allPromises = [];
    if (me.commitPromise) {
      return false;
    }
    if (!changes) {
      if (me.modified.count) {
        me.modified.forEach((record) => record.clearChanges(true, false));
        me.modified.clear();
      }
      return immediatePromise2;
    }
    if (me.trigger("beforeCommit", { changes }) !== false) {
      [...changes.added, ...changes.modified, ...changes.removed].forEach((record) => record.meta.committing = true);
      me.trigger("commitStart", { changes });
      const commitState = {
        action: "commit",
        exception: false,
        changes
      };
      let p = me.commitRemoved(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitAdded(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitModified(commitState);
      if (p) {
        allPromises.push(p);
      }
      if (!allPromises.length) {
        me.modified.forEach((r) => r.clearChanges(true, false));
        me.modified.clear();
        me.added.forEach((r) => r.clearChanges(true, false));
        me.added.clear();
        me.removed.clear();
        me.trigger("commit", { changes });
        return immediatePromise2;
      }
      p = allPromises.length === 1 ? allPromises[0] : Promise.all(allPromises);
      return me.commitPromise = new Promise((resolve, reject) => {
        p.then(() => {
          me.commitPromise = null;
          if (commitState.exception) {
            me.trigger("exception", commitState);
            reject(commitState);
          } else {
            me.trigger("commit", { changes });
            resolve(commitState);
          }
        }).catch(() => {
          me.commitPromise = null;
          reject(commitState);
        });
      });
    }
  }
  // Performs background autocommit with reject checking
  doAutoCommit() {
    if (this.suspendCount <= 0) {
      this.commit().catch((commitState) => {
        const { response } = commitState;
        if (!(response && (response.ok && response.parsedJson || [500, 404].includes(response.status)))) {
          throw commitState;
        }
      });
    }
  }
  /**
   * Commits added records by posting to {@link #config-createUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `add` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforeRequest
   * @fires commitAdded
   * @fires refresh
   * @fires exception
   * @fires afterRequest
   */
  commitAdded(commitState) {
    const me = this, added = me.added, event = { action: "create", params: me.params };
    return added.count && me.createUrl ? new Promise((resolve) => {
      const toAdd = added.values.map((r) => r.persistableData);
      commitState.create = event;
      event.body = { data: toAdd };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("data", JSON.stringify(toAdd));
        dataToSend = formData;
      }
      const options = { headers: me.headers, parseJson: true }, url = me.createUrl + me.buildQueryString(me.createUrl, me.params);
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.create;
      }
      AjaxHelper.post(url, dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then((response) => {
        const data = response.parsedJson, isArray3 = Array.isArray(data), success = isArray3 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success) {
          me.processReturnedData(added.values, isArray3 ? data : ObjectHelper.getPath(data, me.responseDataProperty));
          added.clear();
          me.trigger("commitAdded");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          added.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          commitState.exceptionType = event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        added.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
  }
  /**
   * Commits modified records by posting to {@link #config-updateUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `update` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforeRequest
   * @fires commitModified
   * @fires refresh
   * @fires exception
   * @fires afterRequest
   */
  commitModified(commitState) {
    const me = this, { modified } = me.changes, event = { action: "update", params: me.params }, result = modified.length && me.updateUrl ? new Promise((resolve) => {
      const modifications = modified.map((record) => {
        if (me.writeAllFields) {
          return record.persistableData;
        } else {
          return record.modificationDataToWrite;
        }
      }).filter((el) => !ObjectHelper.isEmpty(el));
      if (modifications.length === 0) {
        me.modified.clear();
        modified.forEach((r) => r.meta.committing = false);
        resolve();
        return;
      }
      commitState.update = event;
      event.body = { data: modifications };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("data", JSON.stringify(modifications));
        dataToSend = formData;
      }
      const options = { headers: me.headers, parseJson: true };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.update;
      }
      AjaxHelper.post(
        me.updateUrl + me.buildQueryString(me.updateUrl, me.params),
        dataToSend,
        ObjectHelper.assign(options, me.fetchOptions)
      ).then((response) => {
        const data = response.parsedJson, isArray3 = Array.isArray(data), success = isArray3 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success) {
          me.processReturnedData(modified, isArray3 ? data : ObjectHelper.getPath(data, me.responseDataProperty), true);
          me.modified.clear();
          me.trigger("commitModified");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          modified.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        modified.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
    if (!modified.length && me.modified.count) {
      me.modified.clear();
    }
    return result;
  }
  processReturnedData(localRecords, returnedData, isUpdating = false) {
    const me = this, Model2 = me.modelClass, idDataSource = Model2.fieldMap.id.dataSource;
    returnedData.forEach((recData, i) => {
      const record = localRecords[i];
      record.clearChanges(true, false);
      record.syncId(recData[idDataSource]);
      Object.assign(localRecords[i].data, Model2.processData(recData, isUpdating, me, record));
    });
  }
  /**
   * Commits removed records by posting to {@link #config-deleteUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `delete` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforerequest
   * @fires commitremoved
   * @fires refresh
   * @fires exception
   * @fires afterrequest
   */
  commitRemoved(commitState) {
    const me = this, removed = me.removed, event = { action: "delete", params: me.params };
    return removed.count && me.deleteUrl ? new Promise((resolve) => {
      commitState.delete = event;
      event.body = { ids: removed.map((r) => r.id) };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("id", JSON.stringify(dataToSend.ids));
        dataToSend = formData;
      }
      const options = { headers: me.headers, parseJson: true };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.delete;
      }
      AjaxHelper.post(
        me.deleteUrl + me.buildQueryString(me.deleteUrl, me.params),
        dataToSend,
        ObjectHelper.assign(options, me.fetchOptions)
      ).then((response) => {
        const data = response.parsedJson, isArray3 = Array.isArray(data), success = isArray3 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success) {
          removed.forEach((record) => record.meta.committing = false);
          removed.clear();
          me.trigger("commitRemoved");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          removed.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        removed.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
  }
  get remoteFilter() {
    return Boolean(this.filterParamName || this.restfulFilter);
  }
  get remoteSort() {
    return Boolean(this.sortParamName);
  }
};
__publicField(AjaxStore, "$name", "AjaxStore");
__publicField(AjaxStore, "configurable", {
  /**
   * An object containing key/value pairs that are passed on the request query string.
   * @prp {Object}
   * @category Remote
   */
  params: null,
  /**
   * When paging of data is requested by setting _either_ the {@link #config-pageParamName} _or_ the
   * {@link #config-pageStartParamName}, this is the value to send in the {@link #config-pageSizeParamName}.
   *
   * **Note:** Setting pageSize at runtime will automatically reload the page.
   * @prp {Number}
   * @default
   * @category Paging
   */
  pageSize: 50
});
AjaxStore._$name = "AjaxStore";

// ../Core/lib/Core/data/DomDataStore.js
var DomDataStore = class {
  /**
   * Get data that is connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {String} [key] The name of the property in the element data to return
   * @returns {Object} Data
   */
  static get(element, key) {
    const result = element._domData || (element._domData = {});
    return key != null ? result[key] : result;
  }
  /**
   * Remove data connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {String} key The name of the property in the element data to remove.
   */
  static remove(element, key) {
    const { _domData } = element, was = _domData == null ? void 0 : _domData[key];
    _domData == null ? true : delete _domData[key];
    return was;
  }
  /**
   * Set data connected to specified element (completely replacing any existing).
   * To update data, use DomDataStore#assign instead.
   * @param {HTMLElement} element DOM element
   * @param {Object|String} data Data object to set, or property name to set
   * @param {*} [value] If the previous parameter was a property name, this is the value to set.
   */
  static set(element, data, value) {
    if (arguments.length === 3) {
      (element._domData || (element._domData = {}))[data] = value;
    } else {
      element._domData = data;
    }
  }
  /**
   * Updates data connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {Object} data Data to assign
   */
  static assign(element, data) {
    Object.assign(element._domData || (element._domData = {}), data);
  }
};
DomDataStore._$name = "DomDataStore";

// ../Core/lib/Core/helper/CSSHelper.js
var CSSHelper = class {
  /**
   * Inserts a CSS style rule based upon the passed text
   * @param {String} cssText The text of the rule including selector and rule body just as it would
   * be specified in a CSS file.
   * @returns {CSSRule} The resulting CSS Rule object if the add was successful.
   */
  static insertRule(cssText, parentElement = document.head) {
    const styleSheet = this.getStyleSheet(parentElement), oldCount = styleSheet.cssRules.length;
    styleSheet.insertRule(cssText, 0);
    if (styleSheet.cssRules.length > oldCount) {
      return styleSheet.cssRules[0];
    }
  }
  /**
   * Looks up the first rule which matched the passed selector.
   * @param {String|Function} selector Either the selector string to exactly match or a function which
   * when passed a required selector, returns `true`.
   * @returns {CSSRule} The first matching CSS Rule object if any found.
   */
  static findRule(selector) {
    let result;
    const isFn = typeof selector === "function";
    Array.prototype.find.call(document.head.querySelectorAll("link[rel=stylesheet],style[type*=css]"), (element) => {
      result = Array.prototype.find.call(element.sheet.rules || element.sheet.cssRules, (r) => {
        return isFn ? selector(r) : r.selectorText === selector;
      });
      if (result) {
        return true;
      }
    });
    return result;
  }
  static getStyleSheet(parentElement = document.head) {
    if (!parentElement.$bryntumStylesheet) {
      parentElement.$bryntumStylesheet = DomHelper.createElement({
        tag: "style",
        id: "bryntum-private-styles",
        type: "text/css",
        parent: parentElement
      }).sheet;
    }
    return parentElement.$bryntumStylesheet;
  }
  /**
   * Returns current CSS version
   * @returns {String}
   * @internal
   */
  static getCSSVersion() {
    return getComputedStyle(document.documentElement).getPropertyValue("--bryntum-version").replace(/[" ]/gm, "");
  }
};
CSSHelper._$name = "CSSHelper";

// ../Core/lib/Core/helper/DomSync.js
var arraySlice2 = Array.prototype.slice;
var emptyArray5 = Object.freeze([]);
var emptyObject5 = Object.freeze({});
var htmlRe2 = /[&<]/;
var { getPrototypeOf: getPrototypeOf2 } = Object;
var { toString: toString4 } = Object.prototype;
var { isEqual, isObject: isObject2 } = ObjectHelper;
var checkEqualityIgnore = {
  parent: 1,
  elementData: 1,
  ns: 1,
  syncOptions: 1
};
var makeCheckEqualityOptions = () => ({
  ignore: checkEqualityIgnore,
  refsFound: /* @__PURE__ */ new Set()
});
var isClass = {
  class: 1,
  className: 1,
  classname: 1
};
var simpleTypes = {
  bigint: 1,
  boolean: 1,
  function: 1,
  number: 1,
  // object
  string: 1,
  symbol: 1
  // undefined
};
var syncIgnoreAttributes = {
  tag: 1,
  html: 1,
  text: 1,
  children: 1,
  tooltip: 1,
  parent: 1,
  nextSibling: 1,
  ns: 1,
  reference: 1,
  elementData: 1,
  retainElement: 1,
  compareHtml: 1,
  syncOptions: 1,
  listeners: 1,
  // eslint-disable-line bryntum/no-listeners-in-lib
  isReleased: 1,
  null: 1,
  "": 1,
  keepChildren: 1,
  retainChildren: 1
};
var addAndCacheCls = (cls, lastDomConfig) => {
  const propertyName = "className" in lastDomConfig ? "className" : "class", propertyValue = lastDomConfig[propertyName];
  if (propertyValue) {
    if (typeof propertyValue === "string") {
      const value = propertyValue.split(" ");
      if (!value.includes(cls)) {
        value.push(cls);
        lastDomConfig[propertyName] = value.join(" ");
      }
    } else if (Array.isArray(propertyValue)) {
      if (!propertyValue.includes(cls)) {
        propertyValue.push(cls);
      }
    } else if (propertyValue.isDomClassList) {
      propertyValue.add(cls);
    } else if (ObjectHelper.isObject(propertyValue)) {
      propertyValue[cls] = 1;
    }
  }
};
var removeAndUncacheCls = (cls, lastDomConfig) => {
  const propertyName = "className" in lastDomConfig ? "className" : "class", propertyValue = lastDomConfig[propertyName];
  if (propertyValue) {
    if (typeof propertyValue === "string") {
      const value = propertyValue.split(" ");
      if (value.includes(cls)) {
        value.splice(value.indexOf(cls), 1);
        lastDomConfig[propertyName] = value.join(" ");
      }
    } else if (Array.isArray(propertyValue)) {
      if (propertyValue.includes(cls)) {
        propertyValue.splice(propertyValue.indexOf(cls), 1);
      }
    } else if (propertyValue.isDomClassList) {
      propertyValue.remove(cls);
    } else if (ObjectHelper.isObject(propertyValue)) {
      delete propertyValue[cls];
    }
  }
};
var DomSync = class _DomSync {
  /**
   * Compares two DOM configs or properties of such objects for equality.
   * @param {Object} is The new value.
   * @param {Object} was The old value.
   * @param {Object} options An object with various options to control the comparison.
   * @param {Object} options.ignore An object containing names of attributes to ignore having `true` value.
   * @param {Map} options.equalityCache A map that can be used to record equality results for objects to avoid
   * recomputing the result for the same objects.
   * @param {Set} options.refsFound A Set that must be populated with the values of any `reference` properties found.
   * @param {Boolean|String} [ignoreRefs] Pass `true` to ignore `reference` properties on domConfigs. Pass `'children'`
   * to ignore `reference` properties only on child element configs.
   * @returns {Boolean}
   * @private
   */
  static checkEquality(is, was, options, ignoreRefs) {
    var _a2;
    if (is === was) {
      return true;
    }
    if (is == null) {
      return was == null;
    }
    if (!is || !was) {
      return false;
    }
    const typeA = typeof is, typeB = typeof was;
    if (typeA !== typeB || simpleTypes[typeA]) {
      return false;
    }
    let cache = options.equalityCache || (options.equalityCache = /* @__PURE__ */ new Map()), ignoreChildRefs = Boolean(ignoreRefs), equal2, i, ignore, ignoreRefOpt, key, syncOptions, val;
    cache = cache.get(is) || cache.set(is, /* @__PURE__ */ new Map()).get(is);
    equal2 = cache.get(was);
    if (equal2 === void 0) {
      equal2 = true;
      if (getPrototypeOf2(is) !== getPrototypeOf2(was) || is instanceof Node) {
        equal2 = false;
      } else if (Array.isArray(is)) {
        i = is.length;
        if (i !== was.length) {
          equal2 = false;
        } else {
          while (i-- > 0) {
            if (!_DomSync.checkEquality(is[i], was[i], options, ignoreChildRefs)) {
              equal2 = false;
              break;
            }
          }
        }
      } else {
        syncOptions = is.syncOptions;
        ignoreRefOpt = syncOptions == null ? void 0 : syncOptions.ignoreRefs;
        if (ignoreRefOpt) {
          ignoreChildRefs = true;
          ignoreRefs = ignoreRefOpt !== "children";
        }
        ignore = options.ignore || emptyObject5;
        for (key in was) {
          if (!ignore[key] && !(key in is) && !(ignoreRefs && key === "reference")) {
            equal2 = false;
            break;
          }
        }
        if (equal2) {
          if (toString4.call(was) === "[object Date]") {
            equal2 = is.getTime() === was.getTime();
          } else if (DomHelper.isReactElement(is) || DomHelper.isReactElement(was)) {
            equal2 = false;
          } else {
            for (key in is) {
              if (!ignore[key] && !(ignoreRefs && key === "reference")) {
                if (!(key in was)) {
                  equal2 = false;
                  break;
                }
                val = is[key];
                if (!_DomSync.checkEquality(val, was[key], options, ignoreChildRefs)) {
                  equal2 = false;
                  break;
                }
              }
            }
          }
        }
      }
      if (!ignoreRefs && isObject2(is) && is.reference) {
        (_a2 = options.refsFound) == null ? void 0 : _a2.add(is.reference);
      }
      cache.set(was, equal2);
    }
    return equal2;
  }
  /**
   * Sync a DOM config to a target element
   * @param {Object} options Options object
   * @param {DomConfig} options.domConfig A DOM config object
   * @param {HTMLElement} options.targetElement Target element to apply to
   * @param {Boolean} [options.strict=false] Specify `true` to limit synchronization to only the values set by
   * previous calls. Styles and classes placed directly on the DOM elements by other means will not be affected.
   * @param {String} [options.syncIdField] Field in dataset to use to match elements for re-usage
   * @param {String|String[]} [options.affected] The references affected by a partial sync.
   * @param {Function} [options.callback] A function that will be called on element re-usage, creation and similar
   * @param {Boolean} [options.configEquality] A function that will be called to compare an incoming config to
   * the last config applied to the `targetElement`. This function returns `true` if the passed values are equal and
   * `false` otherwise.
   * @returns {HTMLElement} Returns the updated target element (which is also updated in place)
   */
  static sync(options) {
    var _a2;
    const optionsIn = options, { refOwner } = options, refsWas = refOwner == null ? void 0 : refOwner.byRef, checkEqualityOptions = makeCheckEqualityOptions();
    let affected = options.affected, i, ref, targetNode, lastDomConfig;
    if (typeof affected === "string") {
      affected = [affected];
    }
    options = {
      ...options,
      checkEqualityOptions
    };
    if (refOwner) {
      refOwner.byRef = {};
      if (affected) {
        for (ref in refsWas) {
          if (!affected.includes(ref)) {
            refOwner.byRef[ref] = refsWas[ref];
          }
        }
      }
      options.refsWas = refsWas;
    }
    optionsIn.changed = _DomSync.performSync(options, options.targetElement);
    if (refOwner) {
      if (!affected) {
        affected = Object.keys(refsWas);
      }
      for (i = 0; i < affected.length; ++i) {
        ref = affected[i];
        targetNode = refsWas[ref];
        if (checkEqualityOptions.refsFound.has(ref) || targetNode.retainElement) {
          refOwner.byRef[ref] = targetNode;
        } else {
          lastDomConfig = targetNode.lastDomConfig;
          (_a2 = targetNode.blur) == null ? void 0 : _a2.call(targetNode);
          targetNode.remove();
          refOwner.detachRef(ref, targetNode, lastDomConfig);
        }
      }
    }
    return options.targetElement;
  }
  static performSync(options, targetElement) {
    const { domConfig, callback } = options, { lastDomConfig } = targetElement, configIsEqual = options.configEquality || _DomSync.checkEquality;
    if (!configIsEqual(domConfig, lastDomConfig, options.checkEqualityOptions, options.ignoreRefs)) {
      if (domConfig) {
        if (!domConfig.onlyChildren) {
          _DomSync.syncAttributes(domConfig, targetElement, options);
          _DomSync.syncContent(domConfig, targetElement);
        }
        if (!domConfig.keepChildren) {
          _DomSync.syncChildren(options, targetElement);
        }
      } else {
        targetElement.innerHTML = null;
        targetElement.syncIdMap = null;
      }
      targetElement.lastDomConfig = !((domConfig == null ? void 0 : domConfig.onlyChildren) && lastDomConfig) ? domConfig : {
        ...lastDomConfig,
        children: domConfig.children
      };
      return true;
    } else {
      callback == null ? void 0 : callback({
        action: "none",
        domConfig,
        targetElement
      });
    }
    return false;
  }
  //region Attributes
  static syncDataset(domConfig, targetElement) {
    const { lastDomConfig } = targetElement, sameConfig = domConfig === lastDomConfig, source = Object.keys(domConfig.dataset), target = lastDomConfig && lastDomConfig.dataset && Object.keys(lastDomConfig.dataset), delta = ArrayHelper.delta(source, target);
    let attr, i, name, value;
    for (i = 0; i < delta.onlyInA.length; i++) {
      attr = delta.onlyInA[i];
      value = domConfig.dataset[attr];
      if (value != null) {
        targetElement.setAttribute(`data-${StringHelper.hyphenate(attr)}`, value);
      }
    }
    for (i = 0; i < delta.inBoth.length; i++) {
      attr = delta.inBoth[i];
      value = domConfig.dataset[attr];
      if (sameConfig || value != lastDomConfig.dataset[attr]) {
        name = `data-${StringHelper.hyphenate(attr)}`;
        if (value == null) {
          targetElement.removeAttribute(name);
        } else {
          targetElement.setAttribute(name, value);
        }
      }
    }
    for (i = 0; i < delta.onlyInB.length; i++) {
      targetElement.removeAttribute(`data-${StringHelper.hyphenate(delta.onlyInB[i])}`);
    }
  }
  /**
   * Adds CSS classes to the element and to the cache.
   * @param {Core.helper.util.DomClassList|String|String[]|Object} cls
   * @param {HTMLElement} targetElement A previously DomSynced element
   * @internal
   */
  static addCls(cls, targetElement) {
    const { lastDomConfig } = targetElement;
    cls = DomClassList.normalize(cls, "array");
    cls.forEach((cls2) => {
      targetElement.classList.add(cls2);
      addAndCacheCls(cls2, lastDomConfig);
    });
  }
  /**
   * Adds CSS classes from the element and from the cache.
   * @param {Core.helper.util.DomClassList|String|String[]|Object} cls
   * @param {HTMLElement} targetElement A previously DomSynced element
   * @internal
   */
  static removeCls(cls, targetElement) {
    const { lastDomConfig } = targetElement;
    cls = DomClassList.normalize(cls, "array");
    cls.forEach((cls2) => {
      targetElement.classList.remove(cls2);
      removeAndUncacheCls(cls2, lastDomConfig);
    });
  }
  static syncClassList(domConfig, targetElement, lastDomConfig) {
    let cls = domConfig.className || domConfig.class, changed = false, c, currentClasses, i, k, keep, last;
    if (lastDomConfig) {
      currentClasses = DomClassList.normalize(targetElement, "array");
      cls = DomClassList.normalize(cls, "object");
      last = DomClassList.normalize(lastDomConfig.className || lastDomConfig.class, "object");
      keep = [];
      for (i = 0, k = currentClasses.length; i < k; ++i) {
        c = currentClasses[i];
        if (cls[c] || !(c in last)) {
          last[c] = 1;
          keep.push(c);
        } else {
          changed = true;
        }
      }
      for (c in cls) {
        if (!last[c]) {
          keep.push(c);
          changed = true;
        }
      }
      if (!changed) {
        return;
      }
      cls = keep.join(" ");
    } else {
      cls = DomClassList.normalize(cls);
    }
    targetElement.setAttribute("class", cls);
  }
  // Attributes as map { attr : value, ... }
  static getSyncAttributes(domConfig) {
    const attributes = {}, names = [];
    if (domConfig) {
      Object.keys(domConfig).forEach((attr) => {
        if (!syncIgnoreAttributes[attr]) {
          const name = attr.toLowerCase();
          attributes[name] = domConfig[attr];
          names.push(name);
        }
      });
    }
    return { attributes, names };
  }
  static syncAttributes(domConfig, targetElement, options) {
    const { lastDomConfig } = targetElement, sameConfig = domConfig === lastDomConfig, sourceSyncAttrs = _DomSync.getSyncAttributes(domConfig), {
      attributes: sourceAttributes,
      names: sourceNames
    } = sourceSyncAttrs, {
      attributes: targetAttributes,
      names: targetNames
    } = sameConfig ? sourceSyncAttrs : _DomSync.getSyncAttributes(lastDomConfig), {
      onlyInA: toAdd,
      onlyInB: toRemove,
      inBoth: toSync
    } = sameConfig ? {
      onlyInA: emptyArray5,
      onlyInB: emptyArray5,
      inBoth: sourceNames
    } : ArrayHelper.delta(sourceNames, targetNames);
    let attr, i;
    for (i = 0; i < toAdd.length; i++) {
      attr = toAdd[i];
      const sourceAttr = sourceAttributes[attr];
      if (attr === "style" && sourceAttr != null) {
        DomHelper.applyStyle(targetElement, sourceAttr, true);
      } else if (attr === "dataset") {
        _DomSync.syncDataset(domConfig, targetElement);
      } else if (isClass[attr]) {
        _DomSync.syncClassList(domConfig, targetElement);
      } else if (sourceAttr != null) {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }
    for (i = 0; i < toRemove.length; i++) {
      targetElement.removeAttribute(toRemove[i]);
    }
    for (i = 0; i < toSync.length; i++) {
      attr = toSync[i];
      const sourceAttr = sourceAttributes[attr], targetAttr = targetAttributes[attr];
      if (sourceAttr == null) {
        targetElement.removeAttribute(attr);
      } else if (attr === "style") {
        if (options.strict) {
          if (sameConfig) {
            _DomSync.syncStyles(targetElement, sourceAttr);
          } else if (!isEqual(sourceAttr, targetAttr, true)) {
            _DomSync.syncStyles(targetElement, sourceAttr, targetAttr);
          }
        } else if (sameConfig || !isEqual(sourceAttr, targetAttr, true)) {
          DomHelper.applyStyle(targetElement, sourceAttr, true);
        }
      } else if (attr === "dataset") {
        _DomSync.syncDataset(domConfig, targetElement);
      } else if (isClass[attr]) {
        _DomSync.syncClassList(domConfig, targetElement, options.strict && targetElement.lastDomConfig);
      } else if (sameConfig || sourceAttr !== targetAttr) {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }
  }
  static syncStyles(targetElement, sourceAttr, targetAttr) {
    let styles, key, value;
    if (!targetAttr) {
      styles = sourceAttr;
    } else {
      styles = {};
      sourceAttr = DomHelper.parseStyle(sourceAttr);
      targetAttr = DomHelper.parseStyle(targetAttr);
      if (sourceAttr) {
        for (key in sourceAttr) {
          value = sourceAttr[key];
          if (targetAttr[key] !== value) {
            styles[key] = value;
          }
        }
      }
      for (key in targetAttr) {
        if (!(key in sourceAttr)) {
          styles[key] = "";
        }
      }
    }
    DomHelper.applyStyle(targetElement, styles);
  }
  //endregion
  //region Content
  static syncContent(domConfig, targetElement) {
    var _a2;
    const { html, text } = domConfig, content = text != null ? text : html;
    targetElement.didSetTextContent = false;
    if (domConfig.elementData) {
      targetElement.elementData = domConfig.elementData;
    }
    if (content instanceof DocumentFragment) {
      if (targetElement.childNodes.length === 1 && DomHelper.getChildElementCount(targetElement) === 0 && content.childNodes.length === 1 && DomHelper.getChildElementCount(content) === 0) {
        DomHelper.setInnerText(targetElement, content.firstChild.data);
      } else {
        targetElement.innerHTML = "";
        targetElement.appendChild(content);
      }
    } else if (html != null && htmlRe2.test(html)) {
      targetElement.innerHTML = String(html);
    } else if (content != null) {
      const { lastDomConfig } = targetElement;
      if (((_a2 = lastDomConfig == null ? void 0 : lastDomConfig.children) == null ? void 0 : _a2.length) || (lastDomConfig == null ? void 0 : lastDomConfig.html) && htmlRe2.test(targetElement.lastDomConfig.html)) {
        targetElement.innerHTML = content;
      } else {
        DomHelper.setInnerText(targetElement, String(content));
        targetElement.didSetTextContent = true;
      }
    }
  }
  static insertTextNode(text, targetElement, callback, refOwner, beforeElement = null) {
    const newNode = document.createTextNode(text);
    targetElement.insertBefore(newNode, beforeElement);
    if (refOwner) {
      newNode.$refOwnerId = refOwner.id;
    }
    callback == null ? void 0 : callback({
      action: "newNode",
      domConfig: text,
      targetElement: newNode
    });
  }
  static insertElement(domConfig, targetElement, targetNode, refOwner, syncIdMap, syncId, options) {
    var _a2;
    const newElement = options.ns ? document.createElementNS(options.ns, domConfig.tag || "svg") : document.createElement(domConfig.tag || "div");
    targetElement.insertBefore(newElement, targetNode);
    _DomSync.performSync(options, newElement);
    if (syncId != null) {
      syncIdMap[syncId] = newElement;
    }
    if (!domConfig.role && !domConfig.tabIndex && !domConfig["aria-hidden"] && !DomHelper.isFocusable(newElement, true) && !newElement.htmlFor) {
      newElement.setAttribute("role", "presentation");
    }
    if (refOwner) {
      newElement.$refOwnerId = refOwner.id;
      if (syncId) {
        newElement.$reference = syncId;
        refOwner.attachRef(syncId, newElement, domConfig);
      }
    }
    (_a2 = options.callback) == null ? void 0 : _a2.call(options, {
      action: "newElement",
      domConfig,
      targetElement: newElement,
      syncId
    });
  }
  //endregion
  //region Children
  static syncChildren(options, targetElement) {
    var _a2, _b, _c, _d;
    let {
      domConfig,
      syncIdField,
      callback,
      releaseThreshold,
      configEquality,
      ns,
      refOwner,
      refsWas,
      strict,
      checkEqualityOptions,
      ignoreRefs
    } = options, cleanupNodes = null, index, nextNode, syncId;
    const syncOptions = domConfig.syncOptions || {};
    if ((_a2 = domConfig.html) != null ? _a2 : domConfig.text) {
      return;
    }
    ignoreRefs = Boolean((_b = syncOptions.ignoreRefs) != null ? _b : ignoreRefs);
    if (ignoreRefs) {
      refOwner = refsWas = null;
    }
    if ("strict" in syncOptions) {
      strict = syncOptions.strict;
    }
    const newSyncIdMap = refOwner ? refOwner.byRef : {}, sourceConfigs = arraySlice2.call(domConfig.children || []), targetNodes = arraySlice2.call(targetElement.childNodes), syncIdMap = refsWas || targetElement.syncIdMap || {}, releasedIdMap = targetElement.releasedIdMap || {}, nextTarget = (remove) => {
      while (targetNodes.length && targetNodes[0].parentNode !== targetElement) {
        targetNodes.shift();
      }
      return (remove ? targetNodes.shift() : targetNodes[0]) || null;
    };
    syncIdField = syncOptions.syncIdField || syncIdField;
    strict = syncOptions.strict || strict;
    callback = syncOptions.callback || callback;
    configEquality = syncOptions.configEquality || configEquality;
    releaseThreshold = "releaseThreshold" in syncOptions ? syncOptions.releaseThreshold : releaseThreshold;
    if (syncIdField) {
      targetElement.syncIdMap = newSyncIdMap;
    }
    const syncChildOptions = {
      checkEqualityOptions: checkEqualityOptions || makeCheckEqualityOptions(),
      ignoreRefs,
      refOwner,
      refsWas,
      strict,
      syncIdField,
      releaseThreshold,
      callback,
      configEquality
    };
    while (sourceConfigs.length) {
      const sourceConfig = sourceConfigs.shift();
      syncId = null;
      if (!sourceConfig) {
        continue;
      }
      if (DomHelper.isReactElement(sourceConfig)) {
        callback({ jsx: sourceConfig, targetElement, domConfig });
        continue;
      }
      if (Array.isArray(sourceConfig)) {
        this.syncChildren({
          ...options,
          domConfig: {
            ...options.domConfig,
            children: sourceConfig
          }
        }, targetElement);
        continue;
      }
      if (sourceConfig instanceof Node) {
        nextNode = nextTarget();
        if (sourceConfig !== nextNode) {
          targetElement.insertBefore(sourceConfig, nextNode);
        }
        index = targetNodes.indexOf(sourceConfig);
        if (index > -1) {
          targetNodes.splice(index, 1);
        }
        continue;
      }
      const isTextNode = typeof sourceConfig === "string";
      syncChildOptions.domConfig = sourceConfig;
      syncChildOptions.ns = sourceConfig.ns || ns;
      if (!isTextNode) {
        if (refOwner) {
          syncId = sourceConfig.reference;
        } else if (syncIdField && sourceConfig.dataset) {
          syncId = sourceConfig.dataset[syncIdField];
        }
        if (syncId != null && !sourceConfig.unmatched) {
          const syncTargetElement = syncIdMap[syncId] || releasedIdMap[syncId];
          if (syncTargetElement) {
            const { lastDomConfig } = syncTargetElement;
            if (syncTargetElement.retainElement) {
            } else if (_DomSync.performSync(syncChildOptions, syncTargetElement)) {
              callback == null ? void 0 : callback({
                action: "reuseOwnElement",
                domConfig: sourceConfig,
                targetElement: syncTargetElement,
                lastDomConfig,
                syncId
              });
            }
            if (sourceConfig.retainElement) {
              syncTargetElement.retainElement = true;
            }
            newSyncIdMap[syncId] = syncTargetElement;
            ArrayHelper.remove(targetNodes, syncTargetElement);
            delete releasedIdMap[syncId];
            syncTargetElement.isReleased = false;
            nextNode = nextTarget();
            if (syncTargetElement.parentNode !== targetElement || strict && syncTargetElement.nextSibling !== nextNode) {
              targetElement.insertBefore(syncTargetElement, nextNode);
            }
          } else if (strict) {
            _DomSync.insertElement(
              sourceConfig,
              targetElement,
              nextTarget(),
              refOwner,
              newSyncIdMap,
              syncId,
              syncChildOptions
            );
          } else {
            sourceConfigs.push(sourceConfig);
            sourceConfig.unmatched = true;
          }
          continue;
        }
        if (sourceConfig.unmatched) {
          delete sourceConfig.unmatched;
        }
      }
      let beforeNode = null, targetNode = null, cleanupNode;
      while (!targetNode && (cleanupNode = nextTarget(true))) {
        if (refOwner) {
          if (cleanupNode.$refOwnerId !== refOwner.id) {
            continue;
          }
          if (cleanupNode.$reference) {
            if (!strict) {
              continue;
            }
            beforeNode = cleanupNode;
            break;
          }
          targetNode = cleanupNode;
        } else if (!cleanupNode.retainElement) {
          targetNode = cleanupNode;
        }
        if (!targetNode) {
          (cleanupNodes || (cleanupNodes = [])).push(cleanupNode);
        }
      }
      if (beforeNode || !targetNode) {
        if (isTextNode) {
          _DomSync.insertTextNode(sourceConfig, targetElement, callback, refOwner, beforeNode);
        } else {
          _DomSync.insertElement(
            sourceConfig,
            targetElement,
            beforeNode,
            refOwner,
            newSyncIdMap,
            syncId,
            syncChildOptions
          );
        }
      } else {
        if (!isTextNode && targetNode.nodeType === Node.ELEMENT_NODE && (sourceConfig.tag || "div").toLowerCase() === targetNode.tagName.toLowerCase()) {
          const { lastDomConfig } = targetNode, result = _DomSync.performSync(syncChildOptions, targetNode);
          if (syncIdField && ((_c = lastDomConfig == null ? void 0 : lastDomConfig.dataset) == null ? void 0 : _c[syncIdField]) != null) {
            const lastSyncId = lastDomConfig.dataset[syncIdField];
            delete releasedIdMap[lastSyncId];
            delete syncIdMap[lastSyncId];
          }
          if (syncId != null) {
            newSyncIdMap[syncId] = targetNode;
          }
          targetNode.isReleased = false;
          result && (callback == null ? void 0 : callback({
            action: "reuseElement",
            domConfig: sourceConfig,
            targetElement: targetNode,
            lastDomConfig,
            syncId
          }));
        } else if (isTextNode && targetNode.nodeType === Node.TEXT_NODE) {
          targetNode.data = sourceConfig;
        } else {
          if (isTextNode) {
            _DomSync.insertTextNode(sourceConfig, targetElement, callback, refOwner, targetNode);
          } else {
            _DomSync.insertElement(
              sourceConfig,
              targetElement,
              targetNode,
              refOwner,
              newSyncIdMap,
              syncId,
              syncChildOptions
            );
          }
          (_d = targetNode.blur) == null ? void 0 : _d.call(targetNode);
          targetNode.remove();
        }
      }
    }
    if (targetElement.didSetTextContent && targetNodes.length === 1 && targetNodes[0].nodeType === Node.TEXT_NODE) {
      return;
    }
    if (domConfig.retainChildren) {
      return;
    }
    while (nextNode = nextTarget(true)) {
      if (!refOwner || nextNode.$refOwnerId === refOwner.id && !nextNode.$reference) {
        (cleanupNodes || (cleanupNodes = [])).push(nextNode);
      }
    }
    if (cleanupNodes) {
      _DomSync.syncChildrenCleanup(
        targetElement,
        cleanupNodes,
        newSyncIdMap,
        callback,
        refOwner,
        releaseThreshold,
        syncIdField
      );
    }
  }
  static syncChildrenCleanup(targetElement, cleanupNodes, newSyncIdMap, callback, refOwner, releaseThreshold, syncIdField) {
    var _a2;
    let releaseCount = 0, ref;
    for (const targetNode of cleanupNodes) {
      const { lastDomConfig } = targetNode;
      if (targetNode.nodeType === Element.TEXT_NODE) {
        targetNode.remove();
        continue;
      }
      if (!targetNode.retainElement) {
        if (!refOwner && syncIdField && (releaseThreshold == null || releaseCount < releaseThreshold)) {
          if (!targetNode.isReleased) {
            targetNode.className = "b-released";
            targetNode.isReleased = true;
            if (lastDomConfig == null ? void 0 : lastDomConfig.dataset) {
              if (!targetElement.releasedIdMap) {
                targetElement.releasedIdMap = {};
              }
              targetElement.releasedIdMap[lastDomConfig.dataset[syncIdField]] = targetNode;
            }
            callback == null ? void 0 : callback({
              action: "releaseElement",
              domConfig: lastDomConfig,
              lastDomConfig,
              targetElement: targetNode
            });
            if (lastDomConfig) {
              lastDomConfig.isReleased = true;
              if (lastDomConfig.className) {
                lastDomConfig.className = "b-released";
              }
              if (lastDomConfig.class) {
                lastDomConfig.class = "b-released";
              }
              if (lastDomConfig.style) {
                lastDomConfig.style = null;
              }
            }
          }
          releaseCount++;
        } else {
          (_a2 = targetNode.blur) == null ? void 0 : _a2.call(targetNode);
          targetNode.remove();
          if (refOwner) {
            ref = targetNode.$reference;
            if (ref) {
              refOwner.detachRef(ref, targetNode, lastDomConfig);
            }
          }
          if (targetElement.releasedIdMap && syncIdField && (lastDomConfig == null ? void 0 : lastDomConfig.dataset)) {
            delete targetElement.releasedIdMap[lastDomConfig.dataset[syncIdField]];
          }
          callback == null ? void 0 : callback({
            action: "removeElement",
            domConfig: targetNode.lastDomConfig,
            lastDomConfig: targetNode.lastDomConfig,
            targetElement: targetNode
          });
        }
      } else if (syncIdField) {
        if (lastDomConfig) {
          newSyncIdMap[targetNode.dataset[syncIdField]] = targetNode;
        }
      }
    }
  }
  /**
   * Remove a child element without syncing, for example when dragging an element to some other parent.
   * Removes it both from DOM and the parent elements syncMap
   * @param {HTMLElement} parentElement
   * @param {HTMLElement} childElement
   */
  static removeChild(parentElement, childElement) {
    if (parentElement.contains(childElement)) {
      const syncIdMap = parentElement.syncIdMap;
      if (syncIdMap) {
        const index = Object.values(syncIdMap).indexOf(childElement);
        if (index > -1) {
          delete syncIdMap[Object.keys(syncIdMap)[index]];
        }
      }
      parentElement.removeChild(childElement);
    }
  }
  /**
   * Adds a child element without syncing, making it properly available for later syncs. Useful for example
   * when dragging and dropping an element from some other parent.
   * @param {HTMLElement} parentElement
   * @param {HTMLElement} childElement
   * @param {String|Number} syncId
   */
  static addChild(parentElement, childElement, syncId) {
    parentElement.appendChild(childElement);
    if (!parentElement.syncIdMap) {
      parentElement.syncIdMap = {};
    }
    parentElement.syncIdMap[syncId] = childElement;
  }
  /**
   * Get a child element using a dot separated syncIdMap path.
   *
   * ```javascript
   * DomSync.getChild(eventWrap, 'event.percentBar');
   * ```
   *
   * @param {HTMLElement} element "root" element, under which the path starts
   * @param {String} path Dot '.' separated path of syncIdMap entries
   * @returns {HTMLElement} Child element or `null` if path did not match any element
   */
  static getChild(element, path) {
    var _a2;
    const syncIds = String(path).split(".");
    for (const id of syncIds) {
      element = (_a2 = element == null ? void 0 : element.syncIdMap) == null ? void 0 : _a2[id];
      if (!element) {
        return null;
      }
    }
    return element;
  }
  //endregion
};
DomSync._$name = "DomSync";

// ../Core/lib/Core/helper/util/Fullscreen.js
var Fullscreen = class {
  static init() {
    const fnNames = ["fullscreenEnabled", "requestFullscreen", "exitFullscreen", "fullscreenElement"], prefixFn = (prefix) => fnNames.map((fn) => {
      let result = prefix + StringHelper.capitalize(fn);
      if (prefix === "moz") {
        result = result.replace("screen", "Screen");
        if ("mozCancelFullScreen" in document && fn === "exitFullscreen") {
          result = "mozCancelFullScreen";
        }
      }
      return result;
    });
    this.functions = "fullscreenEnabled" in document && fnNames || "webkitFullscreenEnabled" in document && prefixFn("webkit") || "mozFullScreenEnabled" in document && prefixFn("moz") || "msFullscreenEnabled" in document && prefixFn("ms") || [];
    const eventNames = [
      "fullscreenchange",
      "fullscreenerror"
    ], msEventNames = [
      "MSFullscreenChange",
      "MSFullscreenError"
    ], prefixEvt = (prefix) => eventNames.map((eventName) => prefix + StringHelper.capitalize(eventName));
    this.events = "fullscreenEnabled" in document && eventNames || "webkitFullscreenEnabled" in document && prefixEvt("webkit") || "mozFullscreenEnabled" in document && prefixEvt("moz") || "msFullscreenEnabled" in document && msEventNames || [];
    this.onFullscreenChange(this.onInternalFullscreenChange.bind(this));
  }
  /**
   * True if the fullscreen mode is supported and enabled, false otherwise
   * @property {Boolean}
   */
  static get enabled() {
    return Boolean(this.functions[0] && document[this.functions[0]]);
  }
  /**
   * Request entering the fullscreen mode.
   * @param {HTMLElement} element Element to be displayed fullscreen
   * @returns {Promise} A promise which is resolved with a value of undefined when the transition to full screen is complete.
   */
  static async request(element) {
    return this.functions[1] && (element == null ? void 0 : element[this.functions[1]]());
  }
  /**
   * Exit the previously entered fullscreen mode.
   * @returns {Promise} A promise which is resolved once the user agent has finished exiting full-screen mode
   */
  static async exit() {
    return this.functions[2] && document[this.functions[2]]();
  }
  /**
   * True if fullscreen mode is currently active, false otherwise
   * @property {Boolean}
   */
  static get isFullscreen() {
    return !!this.element;
  }
  static get element() {
    return this.functions[3] && document[this.functions[3]];
  }
  /**
   * Installs the passed listener to fullscreenchange event
   * @param {Function} fn The listener to install
   */
  static onFullscreenChange(fn) {
    if (this.events[0]) {
      document.addEventListener(this.events[0], fn);
    }
  }
  /**
   * Uninstalls the passed listener from fullscreenchange event
   * @param {Function} fn
   */
  static unFullscreenChange(fn) {
    if (this.events[0]) {
      document.removeEventListener(this.events[0], fn);
    }
  }
  // Make sure the floatRoot is added to any element going fullscreen
  static onInternalFullscreenChange() {
    const me = this, { element: fullscreenElement } = me;
    if (fullscreenElement) {
      if (!fullscreenElement.closest(".b-floatroot")) {
        const rootElement = DomHelper.getRootElement(fullscreenElement), { floatRoot } = rootElement;
        if (floatRoot) {
          me._floatRoot = floatRoot;
          me._oldParent = floatRoot.parentElement;
          fullscreenElement.appendChild(floatRoot);
        }
      }
    } else {
      if (me._floatRoot) {
        me._oldParent.appendChild(me._floatRoot);
      }
      me._oldParent = null;
      me._floatRoot = null;
    }
  }
};
Fullscreen.init();
Fullscreen._$name = "Fullscreen";

// ../Core/lib/Core/helper/ResizeMonitor.js
var resizeFireTimer = null;
var resizedQueue = [];
var isAbsolutelyPositioned = (n) => {
  var _a2;
  return n.nodeType === n.ELEMENT_NODE && ((_a2 = n.ownerDocument.defaultView) == null ? void 0 : _a2.getComputedStyle(n).getPropertyValue("position")) === "absolute";
};
var ResizeMonitor = class _ResizeMonitor {
  /**
   * Adds a resize listener to the passed element which is called when the element
   * is resized by layout.
   * @param {HTMLElement} element The element to listen for resizing.
   * @param {Function} handler The handling function. Will be passed the element.
   */
  static addResizeListener(element, handler) {
    const me = this;
    if (element === document || element === globalThis) {
      element = document.body;
    }
    if (element.nodeType === element.DOCUMENT_FRAGMENT_NODE) {
      element = element.host;
    }
    if (!element.classList.contains("b-resize-monitored")) {
      element.classList.add("b-resize-monitored");
      element._bResizemonitor = {
        handlers: []
      };
    }
    if (element === document.body) {
      if (!me.hasWindowResizeListener) {
        globalThis.addEventListener("resize", me.onWindowResize);
        me.hasWindowResizeListener = true;
      }
    } else if (globalThis.ResizeObserver) {
      if (!me.resizeObserver) {
        me.resizeObserver = new ResizeObserver(me.onElementResize);
      }
      me.resizeObserver.observe(element);
    } else {
      element.classList.add("b-no-resizeobserver");
      const [monitors, expand, shrink] = DomHelper.createElement({
        parent: element,
        className: "b-resize-monitors",
        children: [{
          className: "b-resize-monitor-expand"
        }, {
          className: "b-resize-monitor-shrink"
        }]
      }, { returnAll: true });
      expand.scrollLeft = expand.scrollTop = shrink.scrollLeft = shrink.scrollTop = 1e6;
      expand.addEventListener("scroll", me.onSizeMonitorScroll, true);
      shrink.addEventListener("scroll", me.onSizeMonitorScroll, true);
      (handler.targetMutationMonitor = new MutationObserver((m) => {
        const addedNodes = [], removedNodes = [];
        for (const mr of m) {
          if (mr.type === "childList") {
            addedNodes.push.apply(addedNodes, mr.addedNodes);
            removedNodes.push.apply(removedNodes, mr.removedNodes);
          }
        }
        const changedNodes = [
          ...addedNodes.filter((r) => !removedNodes.includes(r)),
          ...removedNodes.filter((r) => !addedNodes.includes(r))
        ];
        if (changedNodes.length === 0) {
          return;
        }
        if (changedNodes.length > 0 && changedNodes.every(isAbsolutelyPositioned)) {
          return;
        }
        expand.dispatchEvent(new CustomEvent("scroll", { bubbles: false }));
      })).observe(element, {
        childList: true,
        subtree: true
      });
      handler.monitorElement = monitors;
    }
    element._bResizemonitor.handlers.push(handler);
  }
  /**
   * Removes a resize listener from the passed element.
   * @param {HTMLElement} element The element to listen for resizing.
   * @param {Function} handler The handling function to remove.
   */
  static removeResizeListener(element, handler) {
    if (element) {
      if (element === document || element === globalThis) {
        element = document.body;
      }
      const resizeMonitor = element._bResizemonitor;
      let listenerCount = 0;
      if (resizeMonitor && resizeMonitor.handlers) {
        ArrayHelper.remove(resizeMonitor.handlers, handler);
        listenerCount = resizeMonitor.handlers.length;
      }
      if (!listenerCount) {
        element.classList.remove("b-resize-monitored");
        if (this.resizeObserver) {
          this.resizeObserver.unobserve(element);
        } else {
          if (handler.monitorElement) {
            handler.monitorElement.remove();
            handler.monitorElement = null;
          }
          if (handler.targetMutationMonitor) {
            handler.targetMutationMonitor.disconnect();
          }
        }
      }
    }
  }
  static onElementResize(entries) {
    for (const resizeObserverEntry of entries) {
      const resizedElement = resizeObserverEntry.target, resizeMonitor = resizedElement._bResizemonitor, newRect = resizeObserverEntry.contentRect || resizedElement.getBoundingClientRect();
      if (hasLayout(resizedElement)) {
        if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
          const oldRect = resizeMonitor.rectangle;
          resizeMonitor.rectangle = newRect;
          for (const resizeHandler of resizeMonitor.handlers) {
            resizeHandler(resizedElement, oldRect, newRect);
          }
        }
      }
    }
  }
  static onSizeMonitorScroll(e) {
    var _a2;
    if (e.target.isConnected || ((_a2 = document.body) == null ? void 0 : _a2.contains(e.target))) {
      e.stopImmediatePropagation();
      const monitorNode = e.target.parentNode, resizedElement = monitorNode.parentNode, resizeMonitor = resizedElement._bResizemonitor, newRect = resizedElement.getBoundingClientRect();
      if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
        resizedQueue.push([resizedElement, resizeMonitor.rectangle, newRect]);
        resizeMonitor.rectangle = newRect;
        if (!resizeFireTimer) {
          resizeFireTimer = requestAnimationFrame(_ResizeMonitor.fireResizeEvents);
        }
      }
      monitorNode.firstChild.scrollLeft = monitorNode.firstChild.scrollTop = monitorNode.childNodes[1].scrollTop = monitorNode.childNodes[1].scrollLeft = 1e6;
    }
  }
  static onWindowResize(e) {
    const resizedElement = document.body, resizeMonitor = resizedElement._bResizemonitor, oldRect = resizeMonitor.rectangle;
    resizeMonitor.rectangle = document.documentElement.getBoundingClientRect();
    for (const resizeHandler of resizeMonitor.handlers) {
      resizeHandler(resizedElement, oldRect, resizeMonitor.rectangle);
    }
  }
  static fireResizeEvents() {
    for (const resizedEntry of resizedQueue) {
      for (const resizeHandler of resizedEntry[0]._bResizemonitor.handlers) {
        if (resizedEntry[0].offsetParent) {
          resizeHandler.apply(this, resizedEntry);
        }
      }
    }
    resizeFireTimer = null;
    resizedQueue.length = 0;
  }
  static removeGlobalListeners() {
    globalThis.removeEventListener("resize", this.onWindowResize);
  }
};
ResizeMonitor._$name = "ResizeMonitor";

// ../Core/lib/Core/helper/util/Scroller.js
var scrollLiterals = {
  auto: "auto",
  true: "auto",
  false: "hidden",
  "hidden-scroll": "auto",
  clip: BrowserHelper.supportsOverflowClip ? "clip" : "hidden"
};
var scrollerCls = "b-widget-scroller";
var defaultScrollOptions = {
  block: "nearest"
};
var immediatePromise3 = Promise.resolve();
var scrollPromise = (element) => new Promise((resolve) => EventHelper.on({
  element: element === document.documentElement ? globalThis : element,
  scroll: resolve,
  once: true
}));
var xAxis = {
  x: 1
};
var isScrollable = {
  auto: 1,
  scroll: 1
};
var isScrollableConfig = {
  true: 1,
  auto: 1
};
var allScroll = {
  overflowX: "auto",
  overflowY: "auto"
};
var normalizeEdgeOffset = (edgeOffset) => {
  var _a2, _b, _c, _d;
  let top, bottom, start, end;
  if (!edgeOffset) {
    top = bottom = start = end = 0;
  } else if (typeof edgeOffset === "number") {
    top = bottom = start = end = edgeOffset;
  } else {
    top = (_a2 = edgeOffset.top) != null ? _a2 : 0;
    bottom = (_b = edgeOffset.bottom) != null ? _b : 0;
    start = (_c = edgeOffset.start) != null ? _c : 0;
    end = (_d = edgeOffset.end) != null ? _d : 0;
  }
  return { top, bottom, start, end };
};
var Scroller = class _Scroller extends Delayable_default(Events_default(Base)) {
  static get configurable() {
    return {
      /**
       * The widget which is to scroll.
       * @config {Core.widget.Widget}
       */
      widget: null,
      /**
       * The element which is to scroll. Defaults to the {@link Core.widget.Widget#property-overflowElement} of
       * the configured {@link #config-widget}
       * @config {HTMLElement}
       */
      element: {
        $config: {
          nullify: true
        },
        value: null
      },
      /**
       * The element, or a selector which identifies a descendant element whose size
       * will affect the scroll range.
       * @config {HTMLElement|String}
       */
      contentElement: {
        $config: {
          nullify: true
        },
        value: null
      },
      /**
       * How to handle overflowing in the `X` axis.
       * May be:
       * * `'auto'`
       * * `'visible'`
       * * `'hidden'`
       * * `'scroll'`
       * * `'hidden-scroll'` Meaning scrollable from the UI but with no scrollbar,
       * for example a grid header. Only on platforms which support this feature.
       * * `true` - meaning `'auto'`
       * * `false` - meaning `'hidden'`
       * * `clip` - Uses `clip` where supported. Where not supported it uses
       * `hidden` and rolls back any detected scrolls in this dimension.
       * @config {String|Boolean}
       */
      overflowX: null,
      /**
       * How to handle overflowing in the `Y` axis.
       * May be:
       * * `'auto'`
       * * `'visible'`
       * * `'hidden'`
       * * `'scroll'`
       * * `'hidden-scroll'` Meaning scrollable from the UI but with no scrollbar.
       * Only on platforms which support this feature.
       * * `true` - meaning `'auto'`
       * * `false` - meaning `'hidden'`
       * * `clip` - Uses `clip` where supported. Where not supported it uses
       * `hidden` and rolls back any detected scrolls in this dimension.
       * @config {String|Boolean}
       */
      overflowY: null,
      /**
       * If configured as `true`, the {@link #config-element} is not scrolled but is translated using CSS
       * transform when controlled by this class's API. Scroll events are fired when the element is translated.
       * @default
       * @config {Boolean}
       */
      translate: null,
      x: 0,
      y: 0,
      rtlSource: null,
      /**
       * Configure as `true` to immediately sync partner scrollers when being synced by a controlling partner
       * instead of waiting for our own `scroll` event to pass the scroll on to partners.
       * @prp {Boolean}
       * @default false
       */
      propagateSync: null
    };
  }
  static get delayable() {
    return {
      onScrollEnd: {
        type: "buffer",
        delay: 100
      }
    };
  }
  /**
   * Fired when scrolling happens on this Scroller's element. The event object is a native `scroll` event
   * with the described extra properties injected.
   * @event scroll
   * @param {Core.widget.Widget} widget The owning Widget which has been scrolled.
   * @param {Core.helper.util.Scroller} source This Scroller
   */
  /**
   * Fired when scrolling finished on this Scroller's element. The event object is the last native `scroll` event
   * fires by the element with the described extra properties injected.
   * @event scrollend
   * @param {Core.widget.Widget} widget The owning Widget which has been scrolled.
   * @param {Core.helper.util.Scroller} source This Scroller
   */
  /**
   * The `overflow-x` setting for the widget. `true` means `'auto'`.
   * @member {Boolean|String} overflowX
   */
  /**
   * The `overflow-y` setting for the widget. `true` means `'auto'`.
   * @member {Boolean|String} overflowY
   */
  get isRTL() {
    var _a2;
    return Boolean((_a2 = this.rtlSource) == null ? void 0 : _a2.rtl);
  }
  syncOverflowState() {
    const me = this, { element } = me, {
      hasOverflowX,
      hasOverflowY
    } = me, x = me.hasOverflowX = element.scrollWidth > element.clientWidth, y = me.hasOverflowY = element.scrollHeight > element.clientHeight;
    if (hasOverflowX !== x || hasOverflowY !== y) {
      const classList = new DomClassList(element.classList, {
        "b-horizontal-overflow": x,
        "b-vertical-overflow": y
      });
      DomHelper.syncClassList(element, classList);
      if (!me.isConfiguring) {
        me.trigger("overflowChange", { x, y });
      }
    }
  }
  /**
   * Returns `true` if there is overflow in the specified axis.
   * @param {'x'|'y'} [axis='y'] The axis to check scrollbar for. Note that this is subtly different to asking
   * whether an axis is showing a space-consuming scrollbar, see {@link #function-hasScrollbar}.
   * @internal
   */
  hasOverflow(axis = "y") {
    const me = this, overflowSetting = me[`overflow${axis.toUpperCase()}`], otherAxis = me[`overflow${axis === "y" ? "x" : "y"}`];
    if (!DomHelper.scrollBarWidth || !isScrollableConfig[overflowSetting] || otherAxis === "hidden-scroll") {
      const dimension = axis === "y" ? "Height" : "Width";
      return me[`scroll${dimension}`] > me[`client${dimension}`];
    }
    return me[`hasOverflow${axis.toUpperCase()}`];
  }
  /**
   * Returns `true` if there is a *space-consuming* scrollbar controlling scroll in the specified axis.
   * @param {'x'|'y'} [axis='y'] The axis to check scrollbar for. Note that this is subtly different to asking
   * whether an axis *has any* overflow, see {@link #function-hasOverflow}.
   * @internal
   */
  hasScrollbar(axis = "y") {
    const { element } = this;
    if (element && DomHelper.scrollBarWidth) {
      const vertical = axis === "y", dimension = vertical ? "Width" : "Height", clientSize = element[`client${dimension}`], borderSize = parseInt(DomHelper.getStyleValue(element, `border${vertical ? "Left" : "Top"}Width`)) + parseInt(DomHelper.getStyleValue(element, `border${vertical ? "Right" : "Bottom"}Width`)), difference = element[`offset${dimension}`] - borderSize - clientSize;
      return Math.abs(difference - DomHelper.scrollBarWidth) < 2;
    }
  }
  /**
   * Partners this Scroller with the passed scroller in order to sync the scrolling position in the passed axes
   * @param {Core.helper.util.Scroller} otherScroller
   * @param {String|Object} [axes='x'] `'x'` or `'y'` or `{x: true/false, y: true/false}` axes to sync
   * @param {Boolean} [axes.x] Sync horizontal scroll
   * @param {Boolean} [axes.y] Sync vertical scroll
   */
  addPartner(otherScroller, axes = xAxis) {
    const me = this;
    if (typeof axes === "string") {
      axes = {
        [axes]: 1
      };
    }
    if (!me.partners) {
      me.partners = {};
    }
    me.partners[otherScroller.id] = {
      scroller: otherScroller,
      axes
    };
    if (axes.x) {
      otherScroller.x = me.x;
    }
    if (axes.y) {
      otherScroller.y = me.y;
    }
    if (!otherScroller.isPartneredWith(me)) {
      otherScroller.addPartner(me, axes);
    }
  }
  eachPartner(fn) {
    const { partners } = this;
    if (partners) {
      Object.values(partners).forEach(fn);
    }
  }
  /**
   * Breaks the link between this Scroller and the passed Scroller set up by the
   * {@link #function-addPartner} method.
   * @param {Core.helper.util.Scroller} otherScroller The Scroller to unlink from.
   */
  removePartner(otherScroller) {
    if (otherScroller && this.isPartneredWith(otherScroller)) {
      delete this.partners[otherScroller.id];
      otherScroller.removePartner(this);
    }
  }
  isPartneredWith(otherScroller) {
    var _a2;
    return Boolean((_a2 = this.partners) == null ? void 0 : _a2[otherScroller.id]);
  }
  /**
   * Breaks the link between this Scroller and all other Scrollers set up by the
   * {@link #function-addPartner} method.
   * @internal
   */
  clearPartners() {
    if (this.partners) {
      Object.values(this.partners).forEach((otherScroller) => otherScroller.scroller.removePartner(this));
    }
  }
  /**
   * Scrolls the passed element or {@link Core.helper.util.Rectangle} into view according to the passed options.
   * @param {HTMLElement|Core.helper.util.Rectangle} element The element or a Rectangle in document space to scroll
   * into view.
   * @param {BryntumScrollOptions} [options] How to scroll.
   * @returns {Promise} A promise which is resolved when the element has been scrolled into view.
   */
  async scrollIntoView(element, options = defaultScrollOptions) {
    const me = this, { isRectangle } = element, originalRect = isRectangle ? element : Rectangle.from(element), { xDelta, yDelta } = me.getDeltaTo(element, options), result = me.scrollBy(xDelta, yDelta, options);
    if (options.highlight || options.focus) {
      result.then(() => {
        var _a2, _b;
        element = isRectangle ? originalRect.translate(-xDelta, -yDelta) : (_b = (_a2 = options.elementAfterScroll) == null ? void 0 : _a2.call(options)) != null ? _b : element;
        if (options.highlight) {
          if (isNaN(options.highlight)) {
            (me.widget || me).callback(options.highlight, null, [element]);
          } else {
            DomHelper.highlight(element, me);
          }
        }
        if (options.focus) {
          DomHelper.focusWithoutScrolling(element);
        }
      });
    }
    return result;
  }
  /**
   * Scrolls the passed element into view according to the passed options.
   * @param {HTMLElement} element The element in document space to scroll into view.
   * @param {BryntumScrollOptions} [options] How to scroll.
   * @returns {Promise} A promise which is resolved when the element has been scrolled into view.
   */
  static async scrollIntoView(element, options = defaultScrollOptions, rtl = false) {
    const target = Rectangle.from(element), animate = typeof options === "object" ? options.animate : options, scrollable = _Scroller._globalScroller || (_Scroller._globalScroller = new _Scroller()), deltas = [];
    scrollable.rtlSource = { rtl };
    let totalX = 0, totalY = 0, result;
    for (let ancestor = element.parentNode; ancestor.nodeType === Node.ELEMENT_NODE; ancestor = ancestor.parentNode) {
      if (ancestor === document.body && ancestor !== document.scrollingElement) {
        continue;
      }
      const style = ancestor === document.scrollingElement ? allScroll : ancestor.ownerDocument.defaultView.getComputedStyle(ancestor);
      if (options.y !== false && isScrollable[style.overflowY] && ancestor.scrollHeight > ancestor.clientHeight || options.x !== false && isScrollable[style.overflowX] && ancestor.scrollWidth > ancestor.clientWidth) {
        scrollable.element = ancestor;
        scrollable.positionDirty = true;
        const { xDelta, yDelta } = scrollable.getDeltaTo(target, options);
        if (xDelta || yDelta) {
          deltas.push({
            element: ancestor,
            x: ancestor.scrollLeft,
            y: ancestor.scrollTop,
            xDelta,
            yDelta
          });
          target.translate(-xDelta, -yDelta);
          totalX += xDelta;
          totalY += yDelta;
        }
      }
    }
    if (deltas.length) {
      const absX = Math.abs(totalX), absY = Math.abs(totalY);
      let duration = animate && (typeof animate === "number" ? animate : typeof animate.duration === "number" ? animate.duration : 300);
      if (duration && (absX > 10 || absY > 10)) {
        if (Math.max(absX, absY) < 50) {
          duration = Math.min(duration, 500);
        }
        result = scrollable.scrollAnimation = FunctionHelper.animate(duration, (progress) => {
          const isEnd = progress === 1;
          for (const { element: element2, x, y, xDelta, yDelta } of deltas) {
            scrollable.element = element2;
            if (xDelta) {
              scrollable.x = Math[rtl ? "min" : "max"](x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
            }
            if (yDelta) {
              scrollable.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
            }
          }
        }, null, animate.easing);
        result.then(() => {
          scrollable.scrollAnimation = null;
        });
      } else {
        for (const { element: element2, xDelta, yDelta } of deltas) {
          element2.scrollTop += yDelta;
          element2.scrollLeft += xDelta;
        }
        result = scrollPromise(deltas[deltas.length - 1].element);
      }
    } else {
      result = immediatePromise3;
    }
    if (options.highlight || options.focus) {
      result.then(() => {
        if (options.highlight) {
          if (isNaN(options.highlight)) {
            scrollable.callback(options.highlight, null, [element]);
          } else {
            DomHelper.highlight(element, scrollable);
          }
        }
        if (options.focus) {
          element.focus();
        }
      });
    }
    return result;
  }
  /**
   * Scrolls by the passed deltas according to the passed options.
   * @param {Number} [xDelta=0] How far to scroll in the X axis.
   * @param {Number} [yDelta=0] How far to scroll in the Y axis.
   * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
   * @param {Boolean} [options.silent] Set to `true` to suspend `scroll` events during scrolling.
   * @param {AnimateScrollOptions|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @returns {Promise} A promise which is resolved when the scrolling has finished.
   */
  scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions) {
    const me = this, animate = typeof options === "object" ? options.animate : options, absX = Math.abs(xDelta), absY = Math.abs(yDelta);
    if (me.scrollAnimation) {
      me.scrollAnimation.cancel();
      me.scrollAnimation = null;
    }
    if (xDelta || yDelta) {
      me.silent = options.silent;
    }
    let duration = animate && (typeof animate === "number" ? animate : typeof animate.duration === "number" ? animate.duration : 300);
    if (duration && (absX > 10 || absY > 10)) {
      const { x, y } = me;
      let lastX = x, lastY = y;
      if (Math.max(absX, absY) < 50) {
        duration = Math.min(duration, 500);
      }
      me.scrollAnimation = FunctionHelper.animate(duration, (progress) => {
        var _a2, _b;
        const isEnd = progress === 1;
        if (xDelta) {
          if (Math.abs(me.x - lastX) > 1 && !options.force) {
            return (_a2 = me.scrollAnimation) == null ? void 0 : _a2.cancel();
          }
          me.x = Math.max(x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
        }
        if (yDelta) {
          if (Math.abs(me.y - lastY) > 1 && !options.force) {
            return (_b = me.scrollAnimation) == null ? void 0 : _b.cancel();
          }
          me.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
        }
        lastX = me.x;
        lastY = me.y;
      }, me, animate.easing);
      me.element.classList.add("b-scrolling");
      me.scrollAnimation.then(() => {
        if (!me.isDestroyed) {
          me.element.classList.remove("b-scrolling");
          me.scrollAnimation = null;
        }
      });
      return me.scrollAnimation;
    } else {
      if (xDelta || yDelta) {
        const xBefore = me.x, yBefore = me.y;
        if (Math.round(absX) >= 1) {
          me.x += xDelta;
        }
        if (Math.round(absY) >= 1) {
          me.y += yDelta;
        }
        if (me.x !== xBefore || me.y !== yBefore) {
          return scrollPromise(me.element);
        }
      }
      return immediatePromise3;
    }
  }
  /**
   * Scrolls to the passed position according to the passed options.
   * @param {Number} [toX=0] Where to scroll to in the X axis.
   * @param {Number} [toY=0] Where to scroll to in the Y axis.
   * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
   * @param {AnimateScrollOptions|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @returns {Promise} A promise which is resolved when the scrolling has finished.
   */
  async scrollTo(toX, toY, options) {
    const { x, y } = this, xDelta = toX == null ? 0 : toX - x, yDelta = toY == null ? 0 : toY - y;
    this.scrollingToCenter = options == null ? void 0 : options.scrollingToCenter;
    return this.scrollBy(xDelta, yDelta, options);
  }
  doDestroy() {
    var _a2, _b;
    const me = this;
    if (me._element) {
      me._element.removeEventListener("scroll", me.scrollHandler);
      (_a2 = me.wheelListenerRemover) == null ? void 0 : _a2.call(me);
    }
    (_b = me.scrollAnimation) == null ? void 0 : _b.cancel();
    Object.values(me.partners || {}).forEach(({ scroller }) => scroller.removePartner(me));
    super.doDestroy();
  }
  /**
   * Respond to style changes to monitor scroll *when this Scroller is in `translate: true` mode.*
   * @param {Object[]} mutations The ElementMutation records.
   * @private
   */
  onElMutation(mutations) {
    const me = this, [x, y] = DomHelper.getTranslateXY(me.element);
    if (me._x !== -x || me.y !== -y) {
      const scrollEvent = new CustomEvent("scroll", { bubbles: true });
      Object.defineProperty(scrollEvent, "target", {
        get: () => me.element
      });
      me.onScroll(scrollEvent);
    }
  }
  onElResize() {
    const me = this, { widget } = me;
    if (!(widget == null ? void 0 : widget.isAnimating)) {
      me.syncOverflowState();
    } else if (widget.findListener("animationend", "onElResize", me) === -1) {
      widget.ion({
        animationEnd: "onElResize",
        thisObj: me,
        once: true
      });
    }
  }
  onScroll(e) {
    const me = this, { _x, _y, element } = me;
    let vetoed = 0;
    if (me.overflowX === "clip" && element.scrollLeft !== _x) {
      element.scrollLeft = _x;
      ++vetoed;
    }
    if (me.overflowY === "clip" && element.scrollTop !== _y) {
      element.scrollTop = _y;
      ++vetoed;
    }
    if (vetoed === 2) {
      return;
    }
    if (!me.widget || !me.widget.isDestroyed) {
      me.positionDirty = true;
      if (!element.classList.contains("b-scrolling")) {
        element.classList.add("b-scrolling");
      }
      e.widget = me.widget;
      e.scrollingToCenter = me.scrollingToCenter;
      if (!me.silent) {
        me.trigger("scroll", e);
      }
      me.syncPartners();
      me.controllingPartner = null;
      me.onScrollEnd(e);
    }
  }
  /**
   * Syncs all attached scrolling partners with the scroll state of this Scroller.
   * @param {Boolean} force Allow this to sync a partner which is controlling this via a sync.
   * @param {Boolean} [propagate] Propagate any change immediately onwards through
   * further linked partners immediately rather than waiting for our own scroll event.
   * @internal
   */
  syncPartners(force, propagate = this.propagateSync) {
    const me = this;
    if (me.partners) {
      Object.values(me.partners).forEach(({ axes, scroller }) => {
        if (scroller !== me.controllingPartner || force) {
          if (scroller.sync(me, axes) && propagate) {
            scroller.syncPartners(force, propagate);
          }
        }
      });
    }
  }
  onScrollEnd(e) {
    const me = this;
    if (me.silent) {
      me.silent = false;
    }
    me.trigger("scrollEnd", e);
    me.scrollingToCenter = false;
    me.controllingPartner = null;
    me.element.classList.remove("b-scrolling");
  }
  /**
   * Returns the xDelta and yDelta values in an object from the current scroll position to the
   * passed element or Rectangle.
   * @param {HTMLElement|Core.helper.util.Rectangle} element The element or a Rectangle to calculate deltas for.
   * @param {Object} [options] How to scroll.
   * @param {'start'|'end'|'center'|'nearest'} [options.block] How far to scroll the element.
   * @param {Number} [options.edgeOffset] A margin around the element or rectangle to bring into view.
   * @param {Boolean} [options.x] Pass as `false` to disable scrolling in the `X` axis.
   * @param {Boolean} [options.y] Pass as `false` to disable scrolling in the `Y` axis.
   * @param {Boolean} [options.constrainToScrollable=true] Pass as `false` to allow offsets beyond the available scroll range.
   * @returns {Object} `{ xDelta, yDelta }`
   * @internal
   */
  getDeltaTo(element, options) {
    const me = this;
    if (!me.viewport) {
      return {
        xDelta: 0,
        yDelta: 0
      };
    }
    const {
      x,
      y,
      scrollWidth,
      scrollHeight,
      isRTL
    } = me, elementRect = element instanceof Rectangle ? element : Rectangle.from(element), block = options.block || "nearest", scrollerRect = me.viewport, edgeOffset = normalizeEdgeOffset(options.edgeOffset), xOffset = scrollerRect.width >= elementRect.width + (edgeOffset.start + edgeOffset.end) ? edgeOffset : { start: 0, end: 0 }, yOffset = scrollerRect.height >= elementRect.height + (edgeOffset.top + edgeOffset.bottom) ? edgeOffset : { top: 0, bottom: 0 }, constrainTo = new Rectangle(
      isRTL ? scrollerRect.right - -x - scrollWidth : scrollerRect.x - x,
      scrollerRect.y - y,
      scrollWidth,
      scrollHeight
    ), elRect = elementRect.clone().adjust(-xOffset.start, -yOffset.top, xOffset.end, yOffset.bottom).constrainTo(constrainTo), targetRect = elRect.clone(), xFactor = me.isRTL ? -1 : 1;
    let xDelta = 0, yDelta = 0;
    if (block === "start") {
      targetRect.moveTo(scrollerRect.x + (me.isRTL ? scrollerRect.width - targetRect.width : 0), scrollerRect.y);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else if (block === "end") {
      targetRect.moveTo(scrollerRect.x + (!me.isRTL ? scrollerRect.width - targetRect.width : 0), scrollerRect.bottom - targetRect.height);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else if (block === "center") {
      const center = scrollerRect.center;
      targetRect.moveTo(center.x - targetRect.width / 2, center.y - targetRect.height / 2);
      xDelta = xDelta || elRect.x - targetRect.x;
      yDelta = yDelta || elRect.y - targetRect.y;
    } else {
      if (targetRect.width > scrollerRect.width) {
        xDelta = targetRect.x - scrollerRect.x;
      } else {
        if (targetRect.right > scrollerRect.right) {
          xDelta = targetRect.right - scrollerRect.right;
        } else if (targetRect.x < scrollerRect.x) {
          xDelta = targetRect.x - scrollerRect.x;
        }
      }
      if (targetRect.height > scrollerRect.height) {
        yDelta = targetRect.y - scrollerRect.y;
      } else {
        if (targetRect.bottom > scrollerRect.bottom) {
          yDelta = targetRect.bottom - scrollerRect.bottom;
        } else if (targetRect.y < scrollerRect.y) {
          yDelta = targetRect.y - scrollerRect.y;
        }
      }
    }
    xDelta = xFactor * Math.round(xDelta);
    yDelta = Math.round(yDelta);
    if (options.constrainToScrollable !== false) {
      xDelta = Math.max(Math.min(xDelta, me.maxX - x), -x);
      yDelta = Math.max(Math.min(yDelta, me.maxY - y), -y);
    }
    return {
      xDelta: options.x === false ? 0 : xDelta,
      yDelta: options.y === false ? 0 : yDelta
    };
  }
  /**
   * A {@link Core/helper/util/Rectangle} describing the bounds of the scrolling viewport.
   * @property {Core.helper.util.Rectangle}
   */
  get viewport() {
    return Rectangle.client(this.element);
  }
  updateWidget(widget) {
    this.rtlSource = this.owner = widget;
  }
  updateElement(element, oldElement) {
    var _a2;
    const me = this;
    if (me === _Scroller._globalScroller) {
      me._element = element;
      me.positionDirty = true;
      return;
    }
    const scrollHandler = me.scrollHandler || (me.scrollHandler = me.onScroll.bind(me)), resizeHandler = me.resizeHandler || (me.resizeHandler = me.onElResize.bind(me));
    if (oldElement) {
      if (me.translate) {
        (_a2 = me.mutationObserver) == null ? void 0 : _a2.disconnect();
      } else {
        oldElement.removeEventListener("scroll", scrollHandler);
        oldElement.classList.remove(scrollerCls);
        oldElement.style.overflowX = oldElement.style.overflowY = "";
      }
      ResizeMonitor.removeResizeListener(oldElement, resizeHandler);
    }
    if (element) {
      if (me.translate) {
        if (!me.mutationObserver) {
          me.mutationObserver = new MutationObserver(me.mutationHandler || (me.mutationHandler = me.onElMutation.bind(me)));
        }
        me._x = me._y = 0;
        if (document.contains(element)) {
          const [x, y] = DomHelper.getTranslateXY(element);
          me._x = -x;
          me._y = -y;
        }
        me.mutationObserver.observe(element, { attributes: true });
      } else {
        element.addEventListener("scroll", scrollHandler);
        element.classList.add(scrollerCls);
      }
      ResizeMonitor.addResizeListener(element, resizeHandler);
      if (!me.widget) {
        me.rtlSource = {
          get rtl() {
            return DomHelper.getStyleValue(element, "direction") === "rtl";
          }
        };
      }
      if (me.isRTL) {
        element.classList.add("b-rtl");
      }
      if (me.positionDirty) {
        me.updateOverflowX(me.overflowX);
        me.updateOverflowY(me.overflowY);
      }
      me.syncOverflowState();
      if (me.isConfiguring) {
        me._x && me.updateX(me._x);
        me._y && me.updateY(me._y);
      }
    }
    me.positionDirty = true;
  }
  /**
   * The horizontal scroll position of the widget.
   *
   * Note that this is always +ve. Horizontal scrolling using the `X` property akways proceeds
   * in the +ve direction.
   *
   * @property {Number}
   */
  get x() {
    const me = this, { element } = me;
    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = Math.abs(element.scrollLeft);
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._x;
  }
  /**
   * The natural DOM horizontal scroll position of the widget.
   *
   * Note that this proceeds from 0 into negative space in RTL mode.
   *
   * @property {Number}
   */
  get scrollLeft() {
    return this.x * (this.isRTL ? -1 : 1);
  }
  changeX(x) {
    x = Math.max(x, 0);
    if (!this.isConfiguring || x) {
      return x;
    }
    this._x = x;
  }
  updateContentElement(contentElement) {
    if (contentElement) {
      contentElement = typeof contentElement === "string" ? this.element.querySelector(contentElement) : contentElement;
      ResizeMonitor.addResizeListener(contentElement, this.resizeHandler);
    }
  }
  updateX(x) {
    var _a2;
    const me = this, { element } = me;
    if (element && !((_a2 = me.widget) == null ? void 0 : _a2.isConfiguring)) {
      x = Math.round(x);
      me.trigger("scrollStart", { x });
      if (me.translate) {
        DomHelper.setTranslateX(element, -x);
      } else {
        element.scrollLeft = me.isRTL ? -x : x;
      }
    }
    me.positionDirty = true;
  }
  /**
   * Syncs this Scroller with the passed Scroller in the passed axes.
   * @param {Core.helper.util.Scroller} controllingPartner The Scroller which is dictating our new scroll position.
   * @param {Object} axes `{x : <boolean>, y : <boolean> }` which axes to sync.
   * @param {Boolean} axes.x Sync horizontal scroll.
   * @param {Boolean} axes.y Sync vertical scroll.
   * @returns {Boolean} `true` if this Scroller needed the passed axes syncing, `false`
   * if no changes were made.
   * @internal
   */
  sync(controllingPartner, axes) {
    const me = this, { x, y } = axes;
    let result = false;
    if (x != null) {
      if (me.x !== controllingPartner.x) {
        me.controllingPartner = controllingPartner;
        me.x = controllingPartner.x;
        result = true;
      }
    }
    if (y != null) {
      if (me.y !== controllingPartner.y) {
        me.controllingPartner = controllingPartner;
        me.y = controllingPartner.y;
        result = true;
      }
    }
    return result;
  }
  /**
   * The vertical scroll position of the widget.
   * @property {Number}
   */
  get y() {
    const me = this, { element } = me;
    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = element.scrollLeft;
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._y;
  }
  changeY(y) {
    if (!this.isConfiguring || y) {
      return y;
    }
    this._y = y;
  }
  updateY(y) {
    const { element, widget } = this;
    if (element && !(widget == null ? void 0 : widget.isConfiguring)) {
      this.trigger("scrollStart", { y });
      if (this.translate) {
        DomHelper.setTranslateY(element, -y);
      } else {
        element.scrollTop = y;
      }
    }
    this.positionDirty = true;
  }
  /**
   * The maximum `X` scrollable position of the widget.
   * @property {Number}
   * @readonly
   */
  get maxX() {
    return this.scrollWidth - this.clientWidth;
  }
  /**
   * The maximum `Y` scrollable position of the widget.
   * @property {Number}
   * @readonly
   */
  get maxY() {
    return this.scrollHeight - this.clientHeight;
  }
  /**
   * The furthest possible `scrollLeft` position of the widget. Will be -ve
   * if in writing direction is RTL.
   * @property {Number}
   * @readonly
   */
  get lastScrollLeft() {
    return (this.scrollWidth - this.clientWidth) * (this.isRTL ? -1 : 1);
  }
  updateOverflowX(overflowX, oldOverflowX) {
    const me = this, { element, translate } = me, { style, classList } = element;
    if (oldOverflowX === "hidden-scroll") {
      classList.remove("b-hide-scroll");
    }
    if (overflowX === "hidden-scroll" && !translate) {
      const otherAxisScrollable = isScrollable[style.overflowY];
      if (otherAxisScrollable) {
        overflowX = "hidden";
        me.enableWheel();
      } else {
        classList.add("b-hide-scroll");
      }
    }
    if (!translate) {
      style.overflowX = scrollLiterals[overflowX] || overflowX;
    }
    if (!me.isConfiguring) {
      me.positionDirty = true;
      me.syncOverflowState();
    }
  }
  updateOverflowY(overflowY, oldOverflowY) {
    const me = this, { element, translate } = me, { style, classList } = element;
    if (oldOverflowY === "hidden-scroll") {
      classList.remove("b-hide-scroll");
    }
    if (overflowY === "hidden-scroll" && !translate) {
      const otherAxisScrollable = isScrollable[style.overflowX];
      if (otherAxisScrollable) {
        overflowY = "hidden";
        me.enableWheel();
      } else {
        classList.add("b-hide-scroll");
      }
    }
    if (!translate) {
      style.overflowY = scrollLiterals[overflowY] || overflowY;
    }
    if (!me.isConfiguring) {
      me.positionDirty = true;
      me.syncOverflowState();
    }
  }
  enableWheel() {
    if (!this.wheelListenerRemover) {
      this.wheelListenerRemover = EventHelper.on({
        element: this.element,
        wheel: "onWheel",
        thisObj: this
      });
    }
  }
  onWheel(e) {
    if (Math.abs(e.deltaX) > Math.abs(e.deltaY) && this.overflowX === "hidden-scroll") {
      this.x += e.deltaX;
    } else if (this.overflowY === "hidden-scroll") {
      this.y += e.deltaY;
    }
  }
  /**
   * The horizontal scroll range of the widget.
   * @property {Number}
   * @readonly
   */
  get scrollWidth() {
    var _a2, _b;
    return (_b = (_a2 = this.element) == null ? void 0 : _a2.scrollWidth) != null ? _b : 0;
  }
  set scrollWidth(scrollWidth) {
    const me = this, { element, isRTL } = me;
    let stretcher = me.widthStretcher;
    if (stretcher && scrollWidth == null) {
      stretcher.remove();
      me.widthStretcher = null;
    } else if (scrollWidth) {
      scrollWidth = Math.abs(scrollWidth);
      if (!stretcher) {
        stretcher = me.widthStretcher = DomHelper.createElement({
          className: "b-scroller-stretcher b-horizontal-stretcher",
          // Should survive its surroundings being DomSynced
          retainElement: true
        });
      }
      stretcher.style.transform = `translateX(${(scrollWidth - 1) * (isRTL ? -1 : 1)}px)`;
      if (element && !element.contains(stretcher)) {
        element.insertBefore(stretcher, element.firstElementChild);
      }
    }
    if (me.propagate !== false) {
      me.eachPartner(({ scroller }) => {
        scroller.propagate = false;
        scroller.scrollWidth = scrollWidth;
        delete scroller.propagate;
      });
    }
    me.positionDirty = true;
    me.syncOverflowState();
  }
  get scrollHeight() {
    var _a2, _b;
    return (_b = (_a2 = this.element) == null ? void 0 : _a2.scrollHeight) != null ? _b : 0;
  }
  /**
   * The vertical scroll range of the widget. May be set to larger than the actual data
   * height to enable virtual scrolling. This is how the grid extends its scroll range
   * while only rendering a small subset of the dataset.
   * @property {Number}
   */
  set scrollHeight(scrollHeight) {
    const me = this, stretcher = me.stretcher || (me.stretcher = DomHelper.createElement({
      className: "b-scroller-stretcher"
    }));
    stretcher.style.transform = `translateY(${scrollHeight - 1}px)`;
    if (me.element && me.element.lastChild !== stretcher) {
      me.element.appendChild(stretcher);
    }
    me.positionDirty = true;
    me.syncOverflowState();
  }
  /**
   * The client width of the widget.
   * @property {Number}
   * @readonly
   */
  get clientWidth() {
    var _a2;
    return ((_a2 = this.element) == null ? void 0 : _a2.clientWidth) || 0;
  }
  /**
   * The client height of the widget.
   * @property {Number}
   * @readonly
   */
  get clientHeight() {
    var _a2;
    return ((_a2 = this.element) == null ? void 0 : _a2.clientHeight) || 0;
  }
  /**
   * The unique ID of this Scroller
   * @property {String}
   * @readonly
   */
  get id() {
    if (!this._id) {
      if (this.widget) {
        this._id = `${this.widget.id}-scroller`;
      } else {
        this._id = IdHelper.generateId("scroller-");
      }
    }
    return this._id;
  }
  //region Extract configs
  // This function is not meant to be called by any code other than Base#getCurrentConfig().
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs();
    delete configs.widget;
    delete configs.element;
  }
  //endregion
};
Scroller._$name = "Scroller";

// ../Core/lib/Core/helper/util/Promissory.js
var Promissory = class {
  constructor(fn) {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
    if (fn) {
      fn(this);
    }
  }
};
Promissory._$name = "Promissory";

// ../Core/lib/Core/widget/Renderable.js
var { defineProperty: defineProperty6 } = Reflect;
var Renderable = class _Renderable extends Base.mixin(Localizable_default, Events_default, Delayable_default, Identifiable_default) {
  static get configurable() {
    return {
      /**
       * The top-level DOM element for this object. This element is produced from the {@link #function-renderDom}
       * method of the derived class. As configs used by `renderDom` change, a synchronization of the DOM is
       * scheduled by calling {@link #function-refreshDom}. This call is made automatically by this class, making
       * it rarely necessary to call `refreshDom` directly.
       * @config {HTMLElement}
       * @category DOM
       */
      element: null
    };
  }
  static get delayable() {
    return {
      refreshDom: "raf"
    };
  }
  static get identifiable() {
    return {};
  }
  /**
   * Returns the Set of configs defined as `render: true`, that is, the configs that determine the rendering (via
   * `renderDom`). If no such configs are defined, this method returns `null`.
   *
   * @returns {Set}
   * @private
   */
  static get renderConfigs() {
    const me = this, meta = me.$meta;
    let renderConfigs = meta.renderConfigs, configs, name;
    if (renderConfigs === void 0) {
      renderConfigs = null;
      configs = meta.configs;
      for (name in configs) {
        if (configs[name].render) {
          (renderConfigs || (renderConfigs = /* @__PURE__ */ new Set())).add(name);
        }
      }
      meta.renderConfigs = me.prototype.$renderConfigs = renderConfigs;
    }
    return renderConfigs;
  }
  //region Init
  construct(...args) {
    this.$iid = ++_Renderable.$idSeed;
    this.byRef = {};
    super.construct(...args);
    if (this.onDraw !== _Renderable.prototype.onDraw) {
      this.initDrawable();
    }
  }
  startConfigure(config) {
    this.element = this.renderContext.renderDom();
    super.startConfigure(config);
  }
  //endregion
  //region Configs
  get element() {
    this.refreshDom.flush();
    return this._element;
  }
  /**
   * This is called when the `element` config is assigned (via the setter).
   * @param {HTMLElement} element The new element being assigned.
   * @param {HTMLElement|null} oldElement The old element (previously assigned) or `null`.
   * @returns {HTMLElement}
   * @private
   */
  changeElement(element, oldElement) {
    const me = this;
    if (oldElement) {
      oldElement.remove();
    }
    if (element) {
      element.id = me.id;
      element = DomHelper.createElement(element, {
        refOwner: me
      });
    }
    return element;
  }
  updateId(id, oldId) {
    const me = this;
    if (oldId) {
      const element = me.element;
      element.id = id;
      me.fixRefOwnerId(element, id, oldId);
    }
  }
  //endregion
  //region Misc
  /**
   * Returns the `classList` of this instance's `element`.
   * @property {DOMTokenList}
   */
  get classes() {
    return this.element.classList;
  }
  /**
   * This method fixes the element's `$refOwnerId` when this instance's `id` is changing.
   * @param {HTMLElement} el The element to fix.
   * @param {String} id The new id being assigned.
   * @param {String} oldId The old id (previously assigned).
   * @private
   */
  fixRefOwnerId(el, id, oldId) {
    if (el.$refOwnerId === oldId) {
      el.$refOwnerId = id;
      const ref = el.$reference;
      if (ref) {
        el.id = `${id}-${ref}`;
      }
      for (const c of el.childNodes) {
        this.fixRefOwnerId(c, id, oldId);
      }
    }
  }
  onConfigChange({ name }) {
    if (!this.isConfiguring && this.$renderConfigs.has(name)) {
      this.refreshDom();
    }
  }
  //endregion
  //region Rendering
  /**
   * This method is called by `DomHelper.createElement` and `DomSync.sync` as new reference elements are created.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {Object} domConfig The DOM config object.
   * @private
   */
  attachRef(name, el, domConfig) {
    const me = this, key = "_" + name, { listeners } = domConfig;
    if (!(key in me)) {
      defineProperty6(me, name, {
        get() {
          me.refreshDom.flush();
          return me[key];
        },
        set(el2) {
          me[key] = el2;
        }
      });
    }
    el.id = `${me.id}-${name}`;
    me.byRef[name] = el;
    me[name] = el;
    if (listeners) {
      domConfig.listeners = {
        on: listeners,
        un: EventHelper.on(Object.assign({
          element: el,
          thisObj: me
        }, listeners))
      };
    }
  }
  /**
   * This method is called by `DomSync.sync` as reference elements are removed from the DOM.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {Object} domConfig The DOM config object.
   * @private
   */
  detachRef(name, el, domConfig) {
    if (domConfig.listeners) {
      domConfig.listeners.un();
      domConfig.listeners = null;
    }
    this[name] = null;
    delete this.byRef[name];
  }
  /**
   * This method returns a {@link Core.helper.DomHelper#function-createElement-static} config object that describes
   * the desired elements for this instance.
   *
   * This method is called to produce the initial DOM structure and again as necessary to generate the DOM for the
   * current state. The DOM produced by these subsequent calls is then passed through
   * {@link Core.helper.DomSync#function-sync-static DomSync.sync()} to update the DOM.
   * @returns {Object}
   */
  renderDom() {
    return {};
  }
  /**
   * This property is the object to use when calling the `renderDom` method. It may evaluate to this instance (if
   * the class declares its render configs) or a helper object to track config usage during the `renderDom` call.
   * @property {Object}
   * @private
   */
  get renderContext() {
    const me = this, meta = me.$meta, C = me.constructor;
    let renderConfigs = meta.renderConfigs || C.renderConfigs, context = me;
    if (!renderConfigs) {
      context = Object.create(me);
      renderConfigs = /* @__PURE__ */ new Set();
      for (const name in meta.configs) {
        defineProperty6(context, name, {
          get() {
            renderConfigs.add(name);
            return me[name];
          }
        });
      }
      context.renderDom = () => {
        return me.renderDom.call(context);
      };
      me.$renderConfigs = renderConfigs;
    }
    defineProperty6(me, "renderContext", {
      value: context
    });
    return context;
  }
  /**
   * This method synchronized the DOM produced by {@link #function-renderDom} with what was previously produced and
   * updates the elements accordingly.
   *
   * This method is buffered such that calls to it do not immediately execute. To perform the refresh immediately,
   * do this:
   *```
   *  instance.refreshDom.now();
   *```
   * To flush any potential updates to the DOM (and do nothing if there are none), do this:
   *```
   *  instance.refreshDom.flush();
   *```
   * To determine if there are updates to the DOM pending, do this:
   *```
   *  if (instance.refreshDom.isPending) {
   *      ...
   *  }
   *```
   */
  refreshDom() {
    DomSync.sync({
      targetElement: this.element,
      domConfig: this.renderContext.renderDom(),
      refOwner: this,
      // This limits the sync() to only removing the classes and styles added by previous renderings. This
      // allows dynamically added styles and classes to be preserved:
      strict: true
    });
  }
  //endregion
  onListen(eventName) {
    if (eventName === "draw") {
      this.initDrawable();
    }
  }
  initDrawable() {
    const me = this;
    if (!me.intersector) {
      let el = Object.values(me.byRef).find((el2) => el2.classList.contains("b-drawable"));
      if (!el) {
        el = me.element;
        el.classList.add("b-drawable");
      }
      me.intersector = new IntersectionObserver((entries) => {
        if (!me.isDestroyed) {
          entries.forEach((ent) => {
            if (ent.isIntersecting) {
              me.onDraw({
                count: ++me.drawCounter
              });
            }
          });
        }
      });
      me.intersector.observe(el);
    }
  }
  onDraw(ev) {
    this.trigger("draw", ev);
  }
};
Renderable.$idSeed = 0;
Object.assign(Renderable.prototype, {
  drawCounter: 0,
  hasGeneratedId: false,
  intersector: null
});
Renderable._$name = "Renderable";

// ../Core/lib/Core/widget/Mask.js
var _Mask = class _Mask extends Renderable {
  construct(config) {
    if (config) {
      let el = config.element, cfg;
      if (el) {
        VersionHelper.deprecate("Core", "4.0.0", 'Mask "element" config has been renamed to "target"');
        config = cfg = Object.assign({}, config);
        delete cfg.element;
        cfg.target = el;
      }
      el = config.target;
      if (typeof el === "string") {
        config = cfg = cfg || Object.assign({}, config);
        cfg.target = config.owner[el];
      }
    }
    super.construct(config);
    const me = this, { type } = me;
    if (!me.target) {
      me.target = document.body;
    }
    me.maskName = `mask${typeof type === "string" ? type.trim() : ""}-${_Mask.counter++}`;
    me.show();
  }
  doDestroy() {
    const me = this, { element } = me;
    if (me.type === "trial") {
      return false;
    }
    if (element) {
      me.element = null;
      if (me.mode.endsWith("blur")) {
        DomHelper.forEachChild(element, (child) => {
          child.classList.remove(`b-masked-${me.mode}`);
        });
      }
      me.target.classList.remove("b-masked");
      me.target[me.maskName] = null;
      ArrayHelper.remove(_Mask.masks, me);
    }
    super.doDestroy();
  }
  get maskElement() {
    return this.element;
  }
  set error(value) {
    this.setConfig(this.errorDefaults);
    this.text = value;
  }
  renderDom() {
    const me = this, { maxProgress } = me;
    return {
      class: {
        "b-mask": 1,
        "b-delayed-show": me.showDelay,
        "b-widget": 1,
        [`b-mask-${me.mode}`]: 1,
        "b-progress": maxProgress,
        "b-prevent-transitions": !me.useTransition
      },
      children: [{
        reference: "maskContent",
        class: "b-mask-content b-drawable",
        children: [
          maxProgress ? {
            reference: "progressElement",
            class: "b-mask-progress-bar",
            style: {
              width: `${Math.max(0, Math.min(100, Math.round(me.progress / maxProgress * 100)))}%`
            }
          } : null,
          {
            reference: "maskText",
            class: "b-mask-text",
            html: (me.icon ? `<i class="b-mask-icon ${me.icon}"></i>` : "") + me.text
          }
        ]
      }]
    };
  }
  //endregion
  //region Static
  static mergeConfigs(...sources) {
    const ret = {};
    for (const src of sources) {
      if (typeof src === "string") {
        ret.text = src;
      } else {
        ObjectHelper.assign(ret, src);
      }
    }
    return ret;
  }
  /**
   * Shows a mask with the specified message.
   *
   * Masks stack, call {@link #function-unmask-static} to remove the topmost mask. Or call {@link #function-close}
   * on the returned mask to close it specifically.
   *
   * @param {String|MaskConfig} text Message
   * @param {HTMLElement} target The element to mask
   * @returns {Core.widget.Mask}
   */
  static mask(text, target = document.body) {
    return _Mask.new({ target }, typeof text !== "string" ? { ...text } : { text });
  }
  /**
   * Close the topmost mask for the specified element
   * @param {HTMLElement} element Element to unmask
   * @returns {Promise|null} A promise which is resolved when the mask is gone, or null if element is not masked
   */
  static unmask(element = document.body) {
    const masks = this.getElementMasks(element);
    if (masks.length > 0) {
      return masks[masks.length - 1].close();
    }
    return null;
  }
  /**
   * Close all masks for the specified element
   * @internal
   */
  static unmaskAll(element = document.body) {
    return this.getElementMasks(element).forEach((mask) => mask.close());
  }
  static getElementMasks(element) {
    return this.masks.filter((mask) => mask.target === element);
  }
  //endregion
  //region Config
  updateAutoClose(delay) {
    this.deferredClose.cancel();
    if (delay) {
      this.deferredClose.delay = delay;
      this.deferredClose();
    }
  }
  updateCover() {
    this.syncCover();
  }
  syncCover() {
    var _a2, _b;
    (_b = (_a2 = this.owner) == null ? void 0 : _a2.syncMaskCover) == null ? void 0 : _b.call(_a2, this);
  }
  onOwnerResize() {
    this.syncCover();
  }
  updateOwner(owner) {
    this.detachListeners("cover");
    owner == null ? void 0 : owner.ion({
      name: "cover",
      recompose: "onOwnerResize",
      resize: "onOwnerResize",
      thisObj: this
    });
  }
  updateShowDelay(delay) {
    const { delayedShow } = this;
    delayedShow.delay = delay;
    if (!delay) {
      delayedShow.flush();
    }
  }
  //endregion
  //region Show & hide
  deferredClose() {
    var _a2;
    const { owner } = this;
    this.close().then(() => {
      var _a3;
      (_a3 = owner == null ? void 0 : owner.onMaskAutoClose) == null ? void 0 : _a3.call(owner, this);
    });
    (_a2 = owner == null ? void 0 : owner.onMaskAutoClosing) == null ? void 0 : _a2.call(owner, this);
  }
  delayedShow() {
    this.classes.remove("b-delayed-show");
  }
  /**
   * Show mask
   */
  show() {
    const me = this, { element, target, hiding, maskName } = me;
    if (hiding) {
      hiding.resolve();
      me.hiding = null;
      me.clearTimeout("hide");
    }
    if (me.showDelay) {
      element.classList.add("b-delayed-show");
      me.delayedShow();
    }
    element.classList.add("b-visible");
    element.classList.remove("b-hidden");
    target.classList.add("b-masked");
    if (!target[maskName]) {
      target[maskName] = me;
      target.appendChild(element);
    }
    ArrayHelper.include(_Mask.masks, me);
    me.shown = true;
    me.trigger("show");
    if (me.mode.endsWith("blur")) {
      DomHelper.forEachChild(target, (child) => {
        if (child !== element) {
          child.classList.add(`b-masked-${me.mode}`);
        }
      });
    }
  }
  /**
   * Hide mask
   * @returns {Promise} A promise which is resolved when the mask is hidden, or immediately if already hidden
   */
  hide() {
    const me = this, { target, element } = me;
    let { hiding } = me;
    if (!hiding) {
      if (!me.shown) {
        return Promise.resolve();
      }
      me.hiding = hiding = new Promissory();
      me.shown = false;
      element.classList.remove("b-visible");
      element.classList.add("b-hidden");
      target.classList.remove("b-masked");
      if (me.mode.endsWith("blur")) {
        DomHelper.forEachChild(target, (child) => {
          if (child !== element) {
            child.classList.remove(`b-masked-${me.mode}`);
          }
        });
      }
      hiding.promise = hiding.promise.then(() => {
        if (me.hiding === hiding) {
          me.hiding = null;
        }
      });
      me.setTimeout(() => hiding.resolve(), 500, "hide");
    }
    return hiding.promise;
  }
  /**
   * Close mask (removes it)
   * @returns {Promise} A promise which is resolved when the mask is closed
   */
  async close() {
    await this.hide();
    this.destroy();
  }
  //endregion
};
//region Config
__publicField(_Mask, "$name", "Mask");
__publicField(_Mask, "type", "mask");
__publicField(_Mask, "configurable", {
  /**
   * Set this config to trigger an automatic close after the desired delay:
   * ```javascript
   *  mask.autoClose = 2000;
   * ```
   * If the mask has an `owner`, its `onMaskAutoClosing` method is called when the close starts and its
   * `onMaskAutoClose` method is called when the close finishes.
   * @config {Number}
   * @private
   */
  autoClose: null,
  /**
   * The portion of the {@link #config-target} element to be covered by this mask. By default, the mask fully
   * covers the `target`. In some cases, however, it may be desired to only cover the `'body'` (for example,
   * in a grid).
   *
   * This config is set in conjunction with `owner` which implements the method `syncMaskCover`.
   *
   * @config {String}
   * @private
   */
  cover: null,
  /**
   * The icon to show next to the text. Defaults to showing a spinner
   * @config {String}
   * @default
   */
  icon: "b-icon b-icon-spinner",
  errorDefaults: {
    icon: "b-icon b-icon-warning",
    autoClose: 3e3,
    showDelay: 0
  },
  /**
   * The maximum value of the progress indicator
   * @property {Number}
   */
  maxProgress: null,
  /**
   * Mode: bright, bright-blur, dark or dark-blur
   * @config {'bright'|'bright-blur'|'dark'|'dark-blur'}
   * @default
   */
  mode: "dark",
  /**
   * Number expressing the progress
   * @property {Number}
   */
  progress: null,
  // The owner is involved in the following features:
  //
  // - The `autoClose` timer calls `onMaskAutoClose`.
  // - The `cover` config calls `syncMaskCover`.
  // - If the `target` is a string, that string names the property of the `owner` that holds the
  //   `HTMLElement` reference.
  /**
   * The owning widget of this mask. This is required if `target` is a string.
   *
   * @config {Core.widget.Widget}
   */
  owner: {
    $config: "nullify",
    value: null
  },
  /**
   * The element to be masked. If this config is a string, that string is the name of the property of the
   * `owner` that holds the `HTMLElement` that is the actual target of the mask.
   *
   * NOTE: In prior releases, this used to be specified as the `element` config, but that is now, as with
   * `Widget`, the primary element of the mask.
   *
   * @config {String|HTMLElement}
   */
  target: null,
  /**
   * The text (or HTML) to show in mask
   * @prp {String}
   */
  text: null,
  type: null,
  /**
   * The number of milliseconds to delay before making the mask visible. If set, the mask will have an
   * initial `opacity` of 0 but will function in all other ways as a normal mask. Setting this delay can
   * reduce flicker in cases where load operations are typically short (for example, a second or less).
   *
   * @config {Number}
   */
  showDelay: null,
  useTransition: false
});
__publicField(_Mask, "delayable", {
  deferredClose: 0,
  delayedShow: 0,
  syncCover: {
    type: "throttle",
    delay: 100
  }
});
//endregion
//region Init
// Used to give masks unique names
__publicField(_Mask, "counter", 0);
// Tracks open masks
__publicField(_Mask, "masks", []);
var Mask = _Mask;
Mask._$name = "Mask";

// ../Core/lib/Core/widget/mixin/KeyMap.js
var KeyMap_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    /**
     * Override to attach the keyMap keydown event listener to something else than this.element
     * @private
     */
    get keyMapElement() {
      return this.element;
    }
    /**
     * Override to make keyMap resolve subcomponent actions to something else than this.features.
     * @private
     */
    get keyMapSubComponents() {
      return this.features;
    }
    /**
     * Returns the `keyMap` property name which matches the passed KeyboardEvent if any.
     * @param {KeyboardEvent} keyEvent
     * @param {Object} [keyMap=this.keyMap]
     * @returns {String} the key into the `keyMap` matched by the passed KeyboardEvent
     * @internal
     */
    matchKeyMapEntry(keyEvent, keyMap = this.keyMap) {
      if (keyMap && !keyEvent.handled && keyEvent.key !== void 0) {
        return ObjectHelper.keys(keyMap).find((keyString) => {
          const keys = keyString.split("+"), requireAlt = keys.includes("Alt"), requireShift = keys.includes("Shift"), requireCtrl = keys.includes("Ctrl");
          let actualKey = keys[keys.length - 1].toLowerCase();
          if (actualKey === "space") {
            actualKey = " ";
          }
          return actualKey === keyEvent.key.toLowerCase() && (!keyEvent.altKey && !requireAlt || keyEvent.altKey && requireAlt) && (!keyEvent.ctrlKey && !requireCtrl || keyEvent.ctrlKey && requireCtrl) && (!keyEvent.shiftKey && !requireShift || keyEvent.shiftKey && requireShift);
        });
      }
    }
    /**
     * Called on keyMapElement keyDown
     * @private
     */
    performKeyMapAction(event) {
      var _a3;
      const { keyMap } = this;
      let actionHandled = false;
      if (keyMap && !event.handled && event.key !== void 0) {
        const key = this.matchKeyMapEntry(event);
        if (keyMap[key]) {
          const actions = ArrayHelper.asArray(keyMap[key]);
          event.fromKeyMap = true;
          let preventDefault;
          for (let action of actions) {
            preventDefault = true;
            if (ObjectHelper.isObject(action)) {
              if (!action.handler) {
                continue;
              }
              if (action.preventDefault === false) {
                preventDefault = false;
              }
              action = action.handler;
            }
            if (typeof action === "string") {
              const {
                thisObj,
                handler
              } = this.resolveKeyMapAction(action);
              if (((_a3 = thisObj.isActionAvailable) == null ? void 0 : _a3.call(thisObj, { key, action, event, actionName: action.split(".").pop() })) !== false) {
                if (handler.call(thisObj, event) !== false) {
                  actionHandled = true;
                  break;
                }
              }
            } else if (action.call(this) !== false) {
              actionHandled = true;
              break;
            }
          }
          delete event.fromKeyMap;
          if (actionHandled) {
            if (preventDefault) {
              event.preventDefault();
            }
            event.handled = true;
          }
        }
      }
      return actionHandled;
    }
    /**
     * Resolves correct `this` and handler function.
     * If subComponent (action includes a dot) it will resolve in keyMapSubComponents (defaults to this.features).
     *
     * For example, in feature configurable:
     * `keyMap: {
     *     ArrowUp: 'navigateUp'
     * }`
     *
     * Will be translated (by InstancePlugin) to:
     * `keyMap: {
     *     ArrowUp: 'featureName.navigateUp'
     * }
     *
     * And resolved to correct function path here.
     *
     * Override to change action function mapping.
     * @private
     */
    resolveKeyMapAction(action) {
      const { keyMapSubComponents } = this;
      if (action.startsWith("up.") || action.startsWith("this.")) {
        return this.resolveCallback(action);
      }
      if (keyMapSubComponents && action.includes(".")) {
        const [component, actionName] = action.split(".");
        if (component && actionName) {
          return {
            thisObj: keyMapSubComponents[component],
            handler: keyMapSubComponents[component][actionName]
          };
        }
      }
      return {
        thisObj: this,
        handler: this[action]
      };
    }
    updateKeyMap(keyMap) {
      var _a3;
      (_a3 = this.keyMapDetacher) == null ? void 0 : _a3.call(this);
      if (!ObjectHelper.isEmpty(keyMap)) {
        this.keyMapDetacher = EventHelper.on({
          element: this.keyMapElement,
          keydown: "keyMapOnKeyDown",
          thisObj: this
        });
      }
    }
    // Hook on to this to catch keydowns before keymap does
    keyMapOnKeyDown(event) {
      this.performKeyMapAction(event);
    }
    /**
     * This function is used for merging two keyMaps with each other. It can be used for example by a Grid's feature to
     * merge the fetature's keyMap into the Grid's with the use of a subPrefix.
     * @param {Object} target - The existing keyMap.
     * @param {Object} source - The keyMap we want to merge into target.
     * @param {Object} subPrefix - If keyMap actions in source should be prefixed, the prefix should be provided here.
     * As example, the prefix * `rowCopyPaste` will give the action 'rowCopyPaste.action'.
     * @private
     */
    mergeKeyMaps(target, source, subPrefix = null) {
      const mergedKeyMap = {};
      if (target) {
        ObjectHelper.assign(mergedKeyMap, target);
      }
      for (const key in source) {
        if (!source[key]) {
          continue;
        }
        const existingActions = ArrayHelper.asArray(target == null ? void 0 : target[key]), actions = [];
        if (existingActions == null ? void 0 : existingActions.length) {
          actions.push(...existingActions);
        }
        if (!(existingActions == null ? void 0 : existingActions.some((a) => {
          const handler = a.handler ? a.handler : a;
          return typeof handler === "string" && handler.startsWith(subPrefix + ".");
        }))) {
          for (const action of ArrayHelper.asArray(source[key])) {
            if (ObjectHelper.isObject(action) && action.handler) {
              actions.push(ObjectHelper.assignIf({
                handler: (subPrefix ? subPrefix + "." : "") + action.handler
              }, action));
            } else if (typeof action === "function") {
              actions.push(action);
            } else {
              actions.push((subPrefix ? subPrefix + "." : "") + action);
            }
          }
          actions.sort((a, b) => {
            const weight = (a.weight || 0) - (b.weight || 0);
            if (weight === 0 && (existingActions == null ? void 0 : existingActions.length)) {
              return existingActions.indexOf(a) - existingActions.indexOf(b);
            }
            return weight;
          });
        }
        mergedKeyMap[key] = actions;
      }
      return mergedKeyMap;
    }
  }, __publicField(_a2, "$name", "KeyMap"), __publicField(_a2, "configurable", {
    keyMap: {
      value: null,
      $config: {
        merge: "objects",
        nullify: true
      }
    }
  }), _a2;
};

// ../Core/lib/Core/widget/mixin/RTL.js
var RTL_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    // Replace generated is-property, to reduce risk of confusion
    get isRTL() {
      return this.rtl;
    }
    updateRtl(rtl) {
      const { element } = this;
      if (element) {
        element.classList.toggle("b-rtl", rtl === true);
        element.classList.toggle("b-ltr", rtl === false);
      }
    }
    startConfigure(config) {
      var _a3, _b;
      (_a3 = super.startConfigure) == null ? void 0 : _a3.call(this, arguments);
      if (!config.floating && config.rtl == null) {
        const me = this, el = config.rootElement || config.forElement || ((_b = me.parent) == null ? void 0 : _b.contentElement) || (me.floating ? me.floatRoot : me.changeElementRef(me.getRenderContext(config)[0] || config.adopt || document.body)), owner = config.owner || config.parent || me.constructor.fromElement(el);
        if (owner) {
          config.rtl = owner[owner.isConfiguring ? "peekConfig" : "getConfig"]("rtl");
        } else {
          config.rtl = (el == null ? void 0 : el.nodeType) === 1 && getComputedStyle(el).getPropertyValue("direction") === "rtl";
        }
        if (config.rtl) {
          me.configDone.rtl = false;
        }
      }
    }
    // Render is only called on outer widgets, children read their setting from their owner unless explicitly set
    render(...args) {
      var _a3, _b;
      super.render && super.render(...args);
      if (BrowserHelper.isChrome && BrowserHelper.chromeVersion < 87 || BrowserHelper.isFirefox && BrowserHelper.firefoxVersion < 66 || BrowserHelper.isSafari && BrowserHelper.safariVersion < 14.1) {
        this.element.classList.add("b-legacy-inset");
      }
      if (getComputedStyle(this.element).direction === "rtl" || ((_a3 = this.owner) == null ? void 0 : _a3.rtl)) {
        this.rtl = true;
        (_b = this.childItems) == null ? void 0 : _b.forEach((i) => i.rtl = true);
      }
    }
  }, __publicField(_a2, "$name", "RTL"), __publicField(_a2, "configurable", {
    /**
     * If a widget is rendered into an element which has computed style `direction:rtl`, this property will be
     * set to `true`
     *
     * Rendering a widget into an element which, either by a CSS rule, or by its inline `style` has an
     * explicit direction will cause the widget to use that direction regardless of the owning document's
     * direction.
     *
     * In this way, an RTL widget may operate normally inside an LTR page and vice versa.
     *
     * If you are using Bryntum widgets in a different direction to that of the owning document, you
     * must use the following CSS rule to have Popups such as tooltips and event editors use
     * the desired direction instead of the direction of the document:
     *
     * ```CSS
     * .b-float-root {
     *     direction : xxx; // Floatings widgets to differ from the document
     * }
     * ```
     * @member {Boolean} rtl
     * @readonly
     * @private
     */
    /**
     * This may be configured as `true` to make the widget's element use the `direction:rtl` style.
     * @config {Boolean}
     * @default false
     * @private
     */
    rtl: null
  }), _a2;
};

// ../Core/lib/Core/widget/Widget.js
var assignValueDefaults = Object.freeze({
  highlight: false,
  onlyName: false
});
var floatRoots = [];
var highlightExternalChange = "highlightExternalChange";
var isTransparent = /transparent|rgba\(0,\s*0,\s*0,\s*0\)/;
var renderConfigObserver = Symbol("renderConfigObserver");
var textInputTypes = {
  INPUT: 1,
  TEXTAREA: 1
};
var addElementListeners = (me, element, domConfig, refName) => {
  let listeners = (domConfig == null ? void 0 : domConfig.listeners) || (domConfig == null ? void 0 : domConfig.internalListeners);
  listeners = (listeners == null ? void 0 : listeners.on) || listeners;
  if (listeners) {
    const un = EventHelper.on(ObjectHelper.assign({
      element,
      thisObj: me
    }, listeners));
    if (refName) {
      (me._refListeners || (me._refListeners = /* @__PURE__ */ Object.create(null)))[refName] = un;
    } else {
      domConfig.listeners = {
        on: listeners,
        un
      };
    }
  }
};
var mergeAnim = (value, was) => {
  return value && was && was[ObjectHelper.keys(value)[0]] ? Config.merge(value, was) : value;
};
var widgetTriggerPaint = (w) => {
  w.isVisible && w.triggerPaint();
};
var negationPseudo = /^:not\((.+)\)$/;
var nonFlowedPositions = /absolute|fixed/i;
var isScaled = (w) => w.scale != null;
var { hasOwn: hasOwn4 } = ObjectHelper;
var { defineProperty: defineProperty7 } = Reflect;
var parseDuration = (d) => parseFloat(d) * (d.endsWith("ms") ? 1 : 1e3);
var alignedClass = [
  "b-aligned-above",
  "b-aligned-right",
  "b-aligned-below",
  "b-aligned-left"
];
var returnFalseProp = {
  configurable: true,
  get() {
    return false;
  }
};
var localizeRE = /(?:L\{([^}.]+)\})/;
var localizeTooltip = (string, part) => "L{Tooltip." + part + "}";
var alignSpecRe2 = /^([trblc])(\d*)-([trblc])(\d*)$/i;
var mergeAlign = (oldValue, newValue) => {
  if (alignSpecRe2.test(oldValue)) {
    oldValue = { align: oldValue };
  }
  if (alignSpecRe2.test(newValue)) {
    newValue = { align: newValue };
  }
  return Config.merge(oldValue, newValue);
};
var callbackRe = /^[\w.]+$/;
var alignChangeDims = {
  1: "maxHeight",
  2: "height",
  4: "maxWidth",
  8: "width"
};
var isSingletonWidget = (w) => !w.isRipple && !w.closest((w2) => w2.isMessageDialog || w2.isSharedTooltip);
var Widget = class _Widget extends Base.mixin(Localizable_default, Events_default, Delayable_default, Identifiable_default, Factoryable_default, KeyMap_default, RTL_default) {
  //region Config
  // Used when a config is a class and internally stored as a DomClassList
  // So that subclasses can add class names.
  static mergeCls(newValue, oldValue) {
    if (oldValue && newValue) {
      newValue = new DomClassList(oldValue).assign(typeof newValue === "string" ? new DomClassList(newValue) : newValue);
    } else if (newValue && !newValue.isDomClassList) {
      newValue = new DomClassList(newValue);
    }
    return newValue;
  }
  /**
   * Class name getter.
   * Used when original ES6 class name is minified or mangled during production build.
   * Should be overridden in each class which extends Widget or it descendants.
   *
   * ```javascript
   * class MyNewClass extends Widget {
   *     static get $name() {
   *        return 'MyNewClass';
   *     }
   * }
   * ```
   *
   * @static
   * @member {String} $name
   * @advanced
   */
  static get $name() {
    return "Widget";
  }
  /**
   * Widget name alias which you can use in the `items` of a Container widget.
   *
   * ```javascript
   * class MyWidget extends Widget {
   *     static get type() {
   *        return 'mywidget';
   *     }
   * }
   * ```
   *
   * ```javascript
   * const panel = new Panel({
   *    title : 'Cool widgets',
   *    items : [
   *       { type : 'mywidget', html : 'Lorem ipsum dolor sit amet...' }
   *    ]
   * });
   * ```
   *
   * @static
   * @member {String} type
   */
  static get type() {
    return "widget";
  }
  static get configurable() {
    return {
      /**
       * Get this widget's encapsulating HTMLElement, which is created along with the widget but added to DOM at
       * render time.
       * @member {HTMLElement} element
       * @readonly
       * @category DOM
       */
      /**
       * A {@link Core.helper.DomHelper#function-createElement-static} config object or HTML string from which to
       * create the Widget's element.
       * @private
       * @config {DomConfig|String}
       * @category DOM
       */
      element: true,
      /**
       * Set to false to not call onXXX method names (e.g. `onShow`, `onClick`), as an easy way to listen for events.
       *
       * ```javascript
       * const container = new Container({
       *     callOnFunctions : true
       *
       *     onHide() {
       *          // Do something when the 'hide' event is fired
       *     }
       * });
       * ```
       * @config {Boolean}
       * @default
       */
      callOnFunctions: true,
      /**
       * Get/set widgets id
       * @member {String} id
       * @category DOM
       */
      /**
       * Widget id, if not specified one will be generated. Also used for lookups through Widget.getById
       * @config {String}
       * @category DOM
       */
      id: "",
      /**
       * The HTML to display initially or a function returning the markup (called at widget construction time)
       *
       * This may be specified as the name of a function which can be resolved in the component ownership
       * hierarchy, such as 'up.getHTML' which will be found on an ancestor Widget.
       *
       * @config {String|Function}
       * @param {Core.widget.Widget} widget The calling Widget
       * @returns {String}
       * @category DOM
       */
      html: null,
      /**
       * Set HTML content safely, without disturbing sibling elements which may have been
       * added to the {@link #property-contentElement} by plugins and features.
       * When specifying html, this widget's element will also have the {@link #config-htmlCls}
       * added to its classList, to allow targeted styling.
       * @member {String} content
       * @category DOM
       * @advanced
       */
      /**
       * The HTML content that coexists with sibling elements which may have been added to the
       * {@link #property-contentElement} by plugins and features.
       * When specifying html, this widget's element will also have the {@link #config-htmlCls}
       * class added to its classList, to allow targeted styling.
       * @config {String} content
       * @category DOM
       * @advanced
       */
      content: null,
      /**
       * Custom CSS classes to add to element.
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the class names:
       * ```javascript
       *  cls : {
       *      'b-my-class'     : 1,
       *      [this.extraCls]  : 1,
       *      [this.activeCls] : this.isActive
       *  }
       *  ```
       *
       * @prp {String|Object}
       * @category CSS
       */
      cls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      /**
       * Custom CSS class name suffixes to apply to the elements rendered by this widget. This may be specified
       * as a space separated string, an array of strings, or as an object in which property names with truthy
       * values are used as the class names.
       *
       * For example, consider a `Panel` with a `ui` config like so:
       *
       * ```javascript
       *  new Panel({
       *      text : 'OK',
       *      ui   : 'light'
       *  });
       * ```
       * This will apply the CSS class `'b-panel-ui-light'` to the main element of the panel as well as its many
       * child elements. This allows simpler CSS selectors to match the child elements of this particular panel
       * UI:
       *
       * ```css
       *  .b-panel-content.b-panel-ui-light {
       *      background-color : #eee;
       *  }
       * ```
       * Using the {@link #config-cls cls config} would make matching the content element more complex, and in
       * the presence of {@link Core.widget.Panel#config-strips docked items} and nested panels, impossible to
       * target accurately.
       *
       * @config {String|Object}
       * @category CSS
       */
      ui: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      /**
       * Determines how a {@link Core.widget.Panel#config-collapsed} panel will treat this widget if it resides
       * within the panel's header (for example, as one of its {@link Core.widget.Panel#config-strips} or
       * {@link Core.widget.Panel#config-tools}).
       *
       * Valid options are:
       *  - `null` : The widget will be moved to the overlay header when the panel is collapsed (the default).
       *  - `false` : The widget will be unaffected when the panel is collapsed and will remain in the primary
       *    panel header at all times.
       *  - `'hide'` : The widget will be hidden when the panel is collapsed.
       *  - `'overlay'` : The widget will only appear in the collapsed panel's overlay header. See
       *    {@link Core.widget.panel.PanelCollapserOverlay collapsible type='overlay'}.
       *
       * @config {Boolean|'hide'|'overlay'}
       * @internal
       */
      collapsify: null,
      /**
       * Custom CSS classes to add to the {@link #property-contentElement}.
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the class names:
       * ```javascript
       *  cls : {
       *      'b-my-class'     : 1,
       *      [this.extraCls]  : 1,
       *      [this.activeCls] : this.isActive
       *  }
       *  ```
       *
       * @config {String|Object}
       * @category CSS
       * @advanced
       */
      contentElementCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      /**
       * Custom CSS classes to add to this widget's `element`. This property is typically used internally to
       * assign default CSS classes while allowing `cls` to alter these defaults. It is not recommended that
       * client code set this config but instead should set `cls`.
       *
       * For example, to remove a class defined by `defaultCls` using `cls`, declare the class name as a key with
       * a falsy value:
       *
       * ```javascript
       *  cls : {
       *      'default-class' : false
       *  }
       * ```
       * @config {String|Object|String[]}
       * @internal
       */
      defaultCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      /**
       * Controls the placement of this widget when it is added to a {@link Core.widget.Panel panel's }
       * {@link Core.widget.Panel#config-strips strips collection}. Typical values for this config are `'top'`,
       * `'bottom'`, `'left'`, or `'right'`, which cause the widget to be placed on that side of the panel's
       * body. Such widgets are called "edge strips".
       *
       * Also accepts direction neutral horizontal values `'start'` and `'end'`.
       *
       * If this config is set to `'header'`, the widget is placed in the panel's header, following the title. If
       * this config is set to `'pre-header'`, the widget is placed before the title. Such widgets are called
       * "header strips".
       *
       * @config {'top'|'bottom'|'left'|'right'|'start'|'end'|'header'|'pre-header'|Object} dock
       * @category Layout
       */
      dock: null,
      /**
       * The events to forward from an overflow twin to its origin widget.
       *
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the event names:
       * ```javascript
       *  forwardTwinEvents : {
       *      change : this.syncTwinOnChange,
       *      input  : 1
       *  }
       *  ```
       * NOTE: This config cannot be dynamically changed after the `overflowTwin` has been created (see
       * {@link #function-ensureOverflowTwin}.
       * @config {String|String[]|Object}
       * @internal
       */
      forwardTwinEvents: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      parent: null,
      /**
       * The {@link Core.widget.Tab tab} created for this widget when it is placed in a
       * {@link Core.widget.TabPanel}.
       * @member {Core.widget.Tab} tab
       * @readonly
       * @category Misc
       */
      /**
       * A configuration for the {@link Core.widget.Tab tab} created for this widget when it is placed in a
       * {@link Core.widget.TabPanel}. For example, this config can be used to control the icon of the `tab` for
       * this widget:
       *
       * ```javascript
       *  items : [{
       *      type : 'panel',
       *      // other configs...
       *
       *      tab : {
       *          icon : 'b-fa-wrench'
       *      }
       *  }, ... ]
       * ```
       *
       * Another use for this config is to set the tab's {@link Core.widget.mixin.Rotatable#config-rotate} value
       * differently than the default managed by the `TabPanel`:
       *
       * ```javascript
       *  items : [{
       *      type : 'panel',
       *      // other configs...
       *
       *      tab : {
       *          rotate : false   // don't rotate even if tabBar is docked left or right
       *      }
       *  }, ... ]
       * ```
       *
       * Set this to `false` to prevent the creation of a `tab` for this widget. In this case, this widget must
       * be {@link #function-show shown} explicitly. The {@link Core.widget.TabPanel#config-activeTab} for the
       * tab panel will be -1 in this situation.
       *
       * ```javascript
       *  items : [{
       *      type : 'panel',
       *      tab  : false,    // no tab for this item
       *
       *      // other configs...
       *  }, ... ]
       * ```
       *
       * @config {Boolean|TabConfig} tab
       * @category Misc
       */
      tab: null,
      /**
       * An object specifying attributes to assign to the root element of this widget
       * @internal
       * @config {Object}
       * @category Misc
       */
      elementAttributes: null,
      /**
       * The CSS class(es) to add when HTML content is being applied to this widget.
       * @config {String|Object}
       * @category CSS
       */
      htmlCls: {
        $config: {
          merge: "classList"
        },
        value: {
          "b-html": 1
        }
      },
      /**
       * Custom style spec to add to element
       * @config {String}
       * @category CSS
       */
      style: null,
      /**
       * Get/set element's disabled state
       * @member {Boolean} disabled
       * @category Misc
       */
      /**
       * Disable or enable the widget. It is similar to {@link #config-readOnly} except a disabled widget
       * cannot be focused, uses a different rendition (usually greyish) and does not allow selecting its value.
       * @default false
       * @config {Boolean}
       * @category Misc
       */
      disabled: null,
      /**
       * Get/set element's readOnly state. This is only valid if the widget is an input
       * field, __or contains input fields at any depth__. Updating this property will trigger
       * a {@link #event-readOnly} event.
       *
       * All descendant input fields follow the widget's setting. If a descendant
       * widget has a readOnly config, that is set.
       * @member {Boolean} readOnly
       * @category Misc
       */
      /**
       * Whether this widget is read-only.  This is only valid if the widget is an input
       * field, __or contains input fields at any depth__.
       *
       * All descendant input fields follow the widget's setting. If a descendant
       * widget has a readOnly config, that is set.
       * @default false
       * @config {Boolean}
       * @category Misc
       */
      readOnly: {
        value: null,
        default: false,
        $config: null
      },
      /**
       * Determines if the widgets read-only state should be controlled by its parent.
       *
       * When set to `false`, setting a parent container to read-only will not affect the widget. When set to
       * `true`, it will.
       *
       * @category Misc
       * @config {Boolean}
       * @default false
       */
      ignoreParentReadOnly: null,
      /**
       * Element (or element id) to adopt as this Widget's encapsulating element. The widget's
       * content will be placed inside this element.
       *
       * If this widget has not been configured with an id, it will adopt the id of the element
       * in order to preserve CSS rules which may apply to the id.
       * @config {HTMLElement|String}
       * @default
       * @category DOM
       */
      adopt: null,
      /**
       * Element (or the id of an element) to append this widget's element to. Can be configured, or set once at
       * runtime. To access the element of a rendered widget, see {@link #property-element}.
       * @prp {HTMLElement}
       * @accepts {HTMLElement|String}
       * @category DOM
       */
      appendTo: null,
      /**
       * Element (or element id) to insert this widget before. If provided, {@link #config-appendTo} config is ignored.
       * @prp {HTMLElement|String}
       * @category DOM
       */
      insertBefore: null,
      /**
       * Element (or element id) to append this widget element to, as a first child. If provided, {@link #config-appendTo} config is ignored.
       * @prp {HTMLElement|String}
       * @category DOM
       */
      insertFirst: null,
      /**
       * Object to apply to elements dataset (each key will be used as a data-attribute on the element)
       * @config {Object}
       * @category DOM
       */
      dataset: null,
      /**
       * Tooltip for the widget, either as a string or as a Tooltip config object.
       *
       * By default, the Widget will use a single, shared instance to display its tooltip as configured,
       * reconfiguring it to the specification before showing it. Therefore, it may not be permanently
       * mutated by doing things such as adding fixed event listeners.
       *
       * To have this Widget *own* its own `Tooltip` instance, add the property `newInstance : true`
       * to the configuration. In this case, the tooltip's {@link #property-owner} will be this Widget.
       *
       * __Note that in the absence of a configured {@link #config-ariaDescription}, the tooltip's value
       * will be used to populate an `aria-describedBy` element within this Widget.__
       * @config {String|TooltipConfig}
       * @category Misc
       */
      tooltip: {
        $config: ["lazy", "nullify"],
        value: null
      },
      /**
       * Set to false to not show the tooltip when this widget is {@link #property-disabled}
       * @config {Boolean}
       * @default
       * @category Misc
       */
      showTooltipWhenDisabled: true,
      /**
       * Prevent tooltip from being displayed on touch devices. Useful for example for buttons that display a
       * menu on click etc, since the tooltip would be displayed at the same time.
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      preventTooltipOnTouch: null,
      /**
       * When this is configured as `true` a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)
       * is used to monitor this element for size changes caused by either style manipulation, or by CSS
       * layout.
       *
       * Size changes are announced using the {@link #event-resize} event.
       * @config {Boolean}
       * @default false
       * @category Misc
       * @advanced
       */
      monitorResize: {
        $config: ["lazy", "nullify"],
        value: null
      },
      /**
       * Set to `true` to apply the default mask to the widget. Alternatively, this can be the mask message or a
       * {@link Core.widget.Mask} config object.
       * @config {Boolean|String|MaskConfig}
       * @category Misc
       */
      masked: {
        $config: "nullify",
        value: null
      },
      /**
       * This config object contains the defaults for the {@link Core.widget.Mask} created for the
       * {@link #config-masked} config. Any properties specified in the `masked` config will override these
       * values.
       * @config {MaskConfig}
       * @category Misc
       */
      maskDefaults: {
        target: "element"
      },
      cache: {},
      /**
       * Set to `true` to move the widget out of the document flow and position it
       * absolutely in browser viewport space.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      floating: null,
      /**
       * Set to `true` when a widget is rendered into another widget's {@link #property-contentElement}, but must
       * not participate in the standard layout of that widget, and must be positioned relatively to that
       * widget's {@link #property-contentElement}.
       *
       * {@link Core.widget.Editor Editor}s are positioned widgets.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      positioned: null,
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       * Set to `true` to be able to drag a widget freely on the page. Or set to an object with a ´handleSelector´
       * property which controls when a drag should start.
       *
       * ```javascript
       *
       * draggable : {
       *     handleSelector : ':not(button)'
       * }
       *
       * ```
       *
       * @config {Boolean|Object}
       * @property {String} handleSelector CSS selector used to determine if drag can be started from a
       * mouse-downed element inside the widget
       * @default false
       * @category Float & align
       */
      draggable: null,
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * How to align this element with its target when {@link #function-showBy} is called
       * passing a simple element as an align target.
       *
       * Either a full alignment config object, or for simple cases, the edge alignment string to use.
       *
       * When using a simple string, the format is `'[trblc]n-[trblc]n'` and it specifies our edge and
       * the target edge plus optional offsets from 0 to 100 along the edges to align to. Also supports direction
       * independent edges horizontally, `s` for start and `e` for end (maps to `l` and `r` for LTR, `r` and `l`
       * for RTL).
       *
       * See the {@link #function-showBy} function for more details about using the object form.
       *
       * Once set, this is stored internally in object form.
       * @config {AlignSpec|String}
       * @category Float & align
       */
      align: {
        $config: {
          merge: mergeAlign
        },
        value: "t-b"
      },
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       * Set to `true` to centre the Widget in browser viewport space.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      centered: null,
      /**
       * _Only valid if this Widget is {@link #config-floating} or {@link #config-positioned}._
       * Element, Widget or Rectangle to which this Widget is constrained.
       * @config {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle}
       * @default document.body
       * @category Float & align
       */
      constrainTo: void 0,
      /**
       * _Only valid if this Widget is {@link #config-floating} and being shown through {@link #function-showBy}._
       * `true` to show a connector arrow pointing to the align target.
       * @config {Boolean}
       * @default false
       * @category Float & align
       */
      anchor: null,
      /**
       * The owning Widget of this Widget. If this Widget is directly contained, this will be the containing Widget.
       * If there is a `forElement`, this config will be that element's encapsulating Widget.
       *
       * If this Widget is floating, this config must be specified by the developer.
       * @config {Core.widget.Widget}
       * @category Misc
       */
      owner: null,
      /**
       * Defines what to do if document is scrolled while Widget is visible (only relevant when floating is set to true).
       * Valid values: ´null´: do nothing, ´hide´: hide the widget or ´realign´: realign to the target if possible.
       * @config {'hide'|'realign'|null}
       * @default
       * @category Float & align
       */
      scrollAction: null,
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * An object which defined which CSS style property should be animated upon hide, and how it should be
       * animated eg:
       *
       * ```javascript
       * {
       *    opacity: {
       *        to : 0,
       *        duration: '10s',
       *        delay: '0s'
       *    }
       * }
       * ```
       *
       * Set to `'false'` to disable animation.
       *
       * @config {Boolean|Object}
       * @category Float & align
       */
      hideAnimation: {
        $config: {
          merge: mergeAnim
        },
        value: null
      },
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * An object which defined which CSS style property should be animated upon show, and how it should be
       * animated eg:
       *
       * ```javascript
       * {
       *    opacity: {
       *        to : 1,
       *        duration: '10s',
       *        delay: '0s'
       *    }
       * }
       * ```
       *
       * Set to `'false'` to disable animation.
       *
       * @config {Boolean|Object}
       * @category Float & align
       */
      showAnimation: {
        $config: {
          merge: mergeAnim
        },
        value: null
      },
      /**
       * The x position for the widget.
       *
       * _Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element._
       *
       * @config {Number}
       * @default
       * @category Float & align
       */
      x: null,
      /**
       * The y position for the widget.
       *
       * _Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element._
       *
       * @config {Number}
       * @default
       * @category Float & align
       */
      y: null,
      /**
       * Accessor to the {@link Core.helper.util.Scroller} which can be used
       * to both set and read scroll information.
       * @member {Core.helper.util.Scroller} scrollable
       * @category Layout
       */
      /**
       * Specifies whether (and optionally in which axes) a Widget may scroll. `true` means this widget may scroll
       * in both axes. May be an object containing boolean `overflowX` and `overflowY` properties which are
       * applied to CSS style properties `overflowX` and `overflowY`. If they are boolean, they are translated to
       * CSS overflow properties thus:
       *
       * *`true` -> `'auto'`
       * *`false` -> `'hidden'`
       *
       * After initialization, this property yields a {@link Core.helper.util.Scroller} which may be used to both
       * set and read scroll information.
       *
       * A Widget uses its `get overflowElement` property to select which element is to be scrollable. By default,
       * in the base `Widget` class, this is the Widget's encapsulating element. Subclasses may implement `get
       * overflowElement` to scroll inner elements.
       * @config {Boolean|ScrollerConfig|Core.helper.util.Scroller}
       * @default false
       * @category Scrolling
       */
      scrollable: {
        $config: ["lazy", "nullify"],
        value: null
      },
      /**
       * The class to instantiate to use as the {@link #config-scrollable}. Defaults to
       * {@link Core.helper.util.Scroller}.
       * @internal
       * @config {Core.helper.util.Scroller}
       * @typings {typeof Scroller}
       * @category Scrolling
       */
      scrollerClass: Scroller,
      /**
       * The name of the property to set when a single value is to be applied to this Widget. Such as when used
       * in a grid WidgetColumn, this is the property to which the column's `field` is applied.
       * @config {String}
       * @default 'html'
       * @category Misc
       */
      defaultBindProperty: "html",
      /**
       * Event that should be considered the default action of the widget. When that event is triggered the
       * widget is also expected to trigger an `action` event. Purpose is to allow reacting to most widgets in
       * a coherent way.
       * @private
       * @config {String}
       * @category Misc
       */
      defaultAction: null,
      /**
       * When set to `true`, this widget is considered as a whole when processing {@link Core.widget.Toolbar}
       * overflow. When `false`, this widget's child items are considered instead.
       *
       * When set to the string `'none'`, this widget is ignored by overflow processing. This option should be
       * used with caution as it prevents the overflow algorithm from moving such widgets into the overflow
       * popup which may result in not clearing enough space to avoid overflowing the toolbar.
       * @config {Boolean|String}
       * @default true
       * @category Layout
       * @internal
       */
      overflowable: {
        value: null,
        default: true,
        $config: null
      },
      /**
       * Widget's width, used to set element style.width. Either specify a valid width string or a number, which
       * will get 'px' appended. We recommend using CSS as the primary way to control width, but in some cases
       * this config is convenient.
       * @config {String|Number}
       * @category Layout
       */
      width: null,
      /**
       * Widget's height, used to set element style.height. Either specify a valid height string or a number, which
       * will get 'px' appended. We recommend using CSS as the primary way to control height, but in some cases
       * this config is convenient.
       * @config {String|Number}
       * @category Layout
       */
      height: null,
      /**
       * The element's maxHeight. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-height}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      maxHeight: null,
      /**
       * The elements maxWidth. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-width}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      maxWidth: null,
      /**
       * The elements minWidth. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-width}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      minWidth: null,
      /**
       * The element's minHeight. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-height}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      minHeight: null,
      // not public, only used by us in docs
      scaleToFitWidth: null,
      allowGrowWidth: true,
      // only used if scaleToFitWidth is true
      /**
       * Get element's margin property. This may be configured as a single number or a `TRBL` format string.
       * numeric-only values are interpreted as pixels.
       * @member {Number|String} margin
       * @category Layout
       */
      /**
       * Widget's margin. This may be configured as a single number or a `TRBL` format string.
       * numeric-only values are interpreted as pixels.
       * @config {Number|String}
       * @category Layout
       */
      margin: null,
      /**
       * Get element's flex property. This may be configured as a single number or a format string:
       *
       *      <flex-grow> <flex-shrink> <flex-basis>
       *
       * Numeric-only values are interpreted as the `flex-grow` value.
       * @member {Number|String} flex
       * @category Layout
       */
      /**
       * When this widget is a child of a {@link Core.widget.Container}, it will by default be participating in a
       * flexbox layout. This config allows you to set this widget's
       * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex">flex</a> style.
       * This may be configured as a single number or a `<flex-grow> <flex-shrink> <flex-basis>` format string.
       * numeric-only values are interpreted as the `flex-grow` value.
       * @config {Number|String}
       * @category Layout
       */
      flex: null,
      /**
       * A widgets weight determines its position among siblings when added to a {@link Core.widget.Container}.
       * Higher weights go further down.
       * @config {Number}
       * @category Layout
       */
      weight: null,
      /**
       * Get/set this widget's `align-self` flexbox setting. This may be set to modify how this widget is aligned
       * within the cross axis of a flexbox layout container.
       * @member {String} alignSelf
       * @category Layout
       */
      /**
       * When this widget is a child of a {@link Core.widget.Container}, it will by default be participating in a
       * flexbox layout. This config allows you to set this widget's
       * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-self">align-self</a> style.
       * @config {String}
       * @category Layout
       */
      alignSelf: null,
      /**
       * Configure as `true` to have the component display a translucent ripple when its
       * {@link #property-focusElement}, or {@link #property-element} is tapped *if the
       * current theme supports ripples*. Out of the box, only the Material theme supports ripples.
       *
       * This may also be a config object containing the properties listed below.
       *
       * eg:
       *```
       *    columns  : [{}...],
       *    ripple   : {
       *        color : 'red',
       *        clip  : '.b-grid-row'
       *    },
       *    ...
       *```
       * @config {Boolean|Object}
       * @property {String} [delegate] A CSS selector to filter which child elements trigger ripples. By default,
       * the ripple is clipped to the triggering element.
       * @property {String} [color='#000'] A CSS color name or specification.
       * @property {Number} [radius=100] The ending radius of the ripple. Note that it will be clipped by the
       * target element by default.
       * @property {String} [clip] A string which describes how to clip the ripple if it is not to be clipped to
       * the default element. Either the property of the widget to use as the clipping element, or a selector to
       * allow clipping to the closest matching ancestor to the target element.
       * @category Misc
       */
      ripple: null,
      /**
       * A title to display for the widget. Only in effect when inside a container that uses it (such as TabPanel)
       * @default
       * @config {String}
       * @category DOM
       */
      title: null,
      localizableProperties: ["title", "ariaLabel", "ariaDescription"],
      // Set this flag to require element to have a size to be considered visible
      requireSize: false,
      /**
       * An identifier by which this widget will be registered in the {@link Core.widget.Container#property-widgetMap}
       * of all ancestor containers.
       *
       * If omitted, this widget will be registered using its {@link #config-id}. In most cases `ref` is
       * preferable over `id` since `id` is required to be globally unique while `ref` is not.
       *
       * The `ref` value is also added to the elements dataset, to allow targeting it using CSS etc.
       * @prp {String}
       * @readonly
       * @category Misc
       */
      ref: null,
      /**
       * Get/set the widget hidden state.
       *
       * Note: `hidden : false` does *not* mean that this widget is definitely visible.
       * To ascertain visibility, use the {@link #property-isVisible} property.
       * @member {Boolean} hidden
       * @category Visibility
       */
      /**
       * Configure with true to make widget initially hidden.
       * @default false
       * @config {Boolean}
       * @category Layout
       */
      hidden: null,
      /**
       * Text alignment: 'left', 'center' or 'right'. Also accepts direction neutral 'start' and 'end'.
       *
       * Applied by adding a `b-text-align-xx` class to the widgets element. Blank by default, which does not add
       * any alignment class.
       *
       * To be compliant with RTL, 'left' yields same result as 'start' and 'right' as 'end'.
       *
       * @config {'left'|'center'|'right'|'start'|'end'}
       * @category Layout
       */
      textAlign: null,
      // When adding our scroll listeners to hide/realign, we ignore events
      // happening too quickly as a result of the show/align action
      ignoreScrollDuration: 500,
      /**
       * The tag name of this Widget's root element
       * @config {String}
       * @default
       * @category DOM
       * @advanced
       */
      tag: "div",
      /**
       * Set this config to `false` to disable batching DOM updates on animation frames for this widget. This
       * has the effect of synchronously updating the DOM when configs affecting the rendered DOM are modified.
       * Depending on the situation, this could simplify code while increasing time spent updating the DOM.
       * @config {Boolean}
       * @default true
       * @internal
       */
      recomposeAsync: null,
      /**
       * If you are rendering this widget to a shadow root inside a web component, set this config to the shadowRoot
       * @config {ShadowRoot}
       * @default
       * @category Misc
       */
      rootElement: null,
      htmlMutationObserver: {
        $config: ["lazy", "nullify"],
        value: {
          childList: true,
          subtree: true
        }
      },
      role: {
        $config: "lazy",
        value: "presentation"
      },
      /**
       * A localizable string (May contain `'L{}'` tokens which resolve in the locale file) to inject as
       * the `aria-label` attribute.
       *
       * This widget is passed as the `templateData` so that functions in the locale file can
       * interrogate the widget's state.
       * @config {String}
       * @category Accessibility
       * @advanced
       */
      ariaLabel: {
        $config: "lazy",
        value: null
      },
      /**
       * A localizable string (May contain `'L{}'` tokens which resolve in the locale file) to inject
       * into an element which will be linked using the `aria-describedby` attribute.
       *
       * This widget is passed as the `templateData` so that functions in the locale file can
       * interrogate the widget's state.
       * @config {String}
       * @category Accessibility
       * @advanced
       */
      ariaDescription: {
        $config: "lazy",
        value: null
      },
      ariaElement: "element",
      ariaHasPopup: null,
      realignTimeout: 300,
      testConfig: {
        ignoreScrollDuration: 100,
        realignTimeout: 50
      },
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * When configured as `true`, this widget uses {@link Core.helper.BrowserHelper#property-isMobile-static}
       * to maximize itself on mobile devices.
       * @prp {Number|String}
       * @category Float & align
       */
      maximizeOnMobile: null
    };
  }
  static get prototypeProperties() {
    return {
      /**
       * true if no id was set, will use generated id instead (widget1, ...). Toggle automatically on creation
       * @member {Boolean} hasGeneratedId
       * @private
       * @category Misc
       */
      hasGeneratedId: false,
      /**
       * This readonly property is `true` for normal widgets in the {@link Core.widget.Container#config-items} of
       * a container. It is `false` for special widgets such as a {@link Core.widget.Panel#config-tbar}.
       * @member {Boolean} innerItem
       * @internal
       * @category Misc
       */
      innerItem: true
    };
  }
  static get declarable() {
    return [
      /**
       * This property declares the set of config properties that affect a Widget's rendering, i.e., the configs
       * used by the {@link #function-compose} method.
       *
       * For example:
       * ```javascript
       *  class Button extends Widget {
       *      static renderConfigs = [ 'cls', 'iconCls', 'text' ];
       *  }
       * ```
       *
       * Alternatively this can be an object:
       *
       * ```javascript
       *  class Button extends Widget {
       *      static renderConfigs = {
       *          cls     : true,
       *          iconCls : true,
       *          text    : true
       *      };
       *  }
       * ```
       * @member {Object|String[]} renderConfigs
       * @static
       * @category Configuration
       * @internal
       */
      "renderConfigs"
    ];
  }
  /**
   * An object providing the `record` and `column` for a widget embedded inside a {@link Grid.column.WidgetColumn}
   *
   * ```javascript
   * columns : [
   *    {
   *        type   : 'widget',
   *        widgets: [{
   *            type     : 'button',
   *            icon     : 'b-fa b-fa-trash',
   *            onAction : ({ source : btn }) => btn.cellInfo.record.remove()
   *        }]
   *    }
   * ]
   * ```
   * @readonly
   * @member {Object} cellInfo
   * @property {Core.data.Model} cellInfo.record Record for the widgets row
   * @property {Object} cellInfo.column Column the widget is displayed in
   * @category Misc
   */
  static get delayable() {
    return {
      recompose: "raf",
      doHideOrRealign: "raf",
      // Screen size and orientation changes must be buffered in line with.
      // ResponsiveMixin whose responsiveUpdate method is on a RAF.
      onAlignConstraintChange: "raf"
    };
  }
  static get factoryable() {
    return {
      defaultType: "widget"
    };
  }
  static get identifiable() {
    return {};
  }
  /**
   * Returns an array containing all existing Widgets. The returned array is generated by this call and is not an
   * internal structure.
   * @property {Core.widget.Widget[]}
   * @readonly
   * @internal
   */
  static get all() {
    return super.all;
  }
  /**
   * Get/set the {@link #config-recomposeAsync} config for all widgets. Setting this value will set the config for
   * all existing widgets and will be the default value for newly created widgets. Set this value to `null` to disable
   * the default setting for new widgets while leaving existing widgets unaffected.
   * @property {Boolean}
   * @internal
   */
  static get recomposeAsync() {
    return _Widget._recomposeAsync;
  }
  static set recomposeAsync(value) {
    _Widget._recomposeAsync = value;
    if (value != null) {
      const { all } = _Widget;
      for (let i = 0; i < all.length; ++i) {
        if (all[i].isComposable) {
          all[i].recomposeAsync = value;
        }
      }
    }
  }
  isType(type, deep) {
    return _Widget.isType(this, type, deep);
  }
  static setupRenderConfigs(cls, meta) {
    const classRenderConfigs = meta.getInherited("renderConfigs"), { renderConfigs } = cls;
    if (renderConfigs) {
      if (Array.isArray(renderConfigs)) {
        for (const name of renderConfigs) {
          classRenderConfigs[name] = true;
        }
      } else {
        ObjectHelper.assign(classRenderConfigs, renderConfigs);
      }
      classRenderConfigs[renderConfigObserver] = null;
    }
  }
  /**
   * Call once per class for custom widgets to have them register with the `Widget` class, allowing them to be created
   * by type.
   *
   * For example:
   * ```javascript
   * class MyWidget extends Widget {
   *   static get type() {
   *     return 'mywidget';
   *   }
   * }
   * MyWidget.initClass();
   * ```
   * @method initClass
   * @static
   * @category Lifecycle
   * @advanced
   */
  //endregion
  //region Init & destroy
  construct(config = {}, ...args) {
    const me = this, { domSyncCallback } = me;
    if (!globalThis.bryntum.cssVersion) {
      const cssVersion = globalThis.bryntum.cssVersion = CSSHelper.getCSSVersion(), jsVersion = VersionHelper.getVersion("core");
      if (cssVersion && cssVersion !== jsVersion) {
        console.warn(`CSS version ${cssVersion} doesn't match bundle version ${jsVersion}!
Make sure you have imported css from the appropriate product version.`);
      }
    }
    me.configureAriaDescription = config.ariaDescription;
    me._isAnimatingCounter = 0;
    me.alignmentChanges = 0;
    me.byRef = /* @__PURE__ */ Object.create(null);
    me.onTargetResize = me.onTargetResize.bind(me);
    me.onFullscreenChange = me.onFullscreenChange.bind(me);
    me.domSyncCallback = domSyncCallback.$nullFn ? null : domSyncCallback.bind(me);
    me._isUserAction = false;
    super.construct(config, ...args);
    const { recomposeAsync } = _Widget;
    if (recomposeAsync != null && me.recomposeAsync == null) {
      me.recomposeAsync = recomposeAsync;
    }
    me.finalizeInit();
  }
  startConfigure(config) {
    super.startConfigure(config);
    const me = this, { adopt, element } = me;
    if (adopt) {
      me.adoptElement(element, adopt, config.id);
      me.updateElement(me._element, element);
    }
  }
  /**
   * Called by the Base constructor after all configs have been applied.
   * @internal
   * @category Lifecycle
   */
  finalizeInit() {
    var _a2;
    const me = this, refElement = me.insertBefore || me.appendTo || me.insertFirst || me.adopt;
    if (refElement) {
      if (me.owner || ((_a2 = refElement.nodeType ? refElement : document.getElementById(refElement)) == null ? void 0 : _a2.isConnected)) {
        me.render();
      } else {
        me.onFirstResizeAfterConnect = me.onFirstResizeAfterConnect.bind(me);
        ResizeMonitor.addResizeListener(refElement, me.onFirstResizeAfterConnect);
      }
    }
  }
  onFirstResizeAfterConnect(el) {
    ResizeMonitor.removeResizeListener(el, this.onFirstResizeAfterConnect);
    if (!this.isDestroyed && !this.rendered) {
      this.render();
    }
  }
  doDestroy() {
    var _a2, _b, _c, _d;
    const me = this, {
      preExistingElements,
      element,
      adopt,
      _refListeners,
      _rootElement,
      eventRoot
    } = me;
    if (Fullscreen.element === element) {
      Fullscreen.exit();
    }
    if (_refListeners) {
      Object.values(_refListeners, (un) => un());
      me._refListeners = null;
    }
    if (element) {
      const sharedTooltip = !me._tooltip && _rootElement && ((_a2 = _Widget.Tooltip) == null ? void 0 : _a2.getSharedTooltip(_rootElement, eventRoot, true));
      if ((sharedTooltip == null ? void 0 : sharedTooltip.owner) === me) {
        sharedTooltip.owner = null;
        sharedTooltip.hide();
      }
      me.onExitFullscreen();
      me.clearTimeout(me.scrollListenerTimeout);
      me.clearTimeout(me.resizeListenerTimeout);
      me.removeTransientListeners();
      if (me.floating || me.positioned) {
        me.hide(false);
      } else {
        me.revertFocus();
      }
      ResizeMonitor.removeResizeListener(element.parentElement, me.onParentElementResize);
      ResizeMonitor.removeResizeListener(element, me.onElementResize);
      if (adopt) {
        for (let nodes = Array.from(element.childNodes), i = 0, { length } = nodes; i < length; i++) {
          const el = nodes[i];
          if (!preExistingElements.includes(el) && el !== me.floatRoot) {
            el.remove();
          }
        }
        element.className = me.adoptedElementClassName;
        element.style.cssText = me.adoptedElementCssText;
      }
      (_b = me.dragEventDetacher) == null ? void 0 : _b.call(me);
      (_c = me.dragOverEventDetacher) == null ? void 0 : _c.call(me);
      me.dragGhost.remove();
    }
    (_d = me.connectedObserver) == null ? void 0 : _d.disconnect();
    super.doDestroy();
    if (eventRoot && !Object.values(_Widget.identifiable.idMap).some(isSingletonWidget)) {
      GlobalEvents_default.detachFocusListeners(eventRoot);
    }
    if (!adopt) {
      element.remove();
    }
  }
  //endregion
  //region Values
  get assignValueDefaults() {
    return assignValueDefaults;
  }
  get valueName() {
    return this.name || this.ref || this.id;
  }
  getValueName(onlyName) {
    onlyName = onlyName && typeof onlyName === "object" ? onlyName.onlyName : onlyName;
    return onlyName ? this.name : this.valueName;
  }
  assignFieldValue(values, key, value) {
    const me = this, valueBindProperty = me.defaultBindProperty;
    if (valueBindProperty in me) {
      me[valueBindProperty] = value;
    }
  }
  assignValue(values, options = assignValueDefaults) {
    const me = this, hec = me[highlightExternalChange], key = me.getValueName(options);
    if (key && (!values || key in values)) {
      if (options.highlight === false) {
        me[highlightExternalChange] = false;
      }
      me.assignFieldValue(values, key, values ? values[key] : null);
      me[highlightExternalChange] = hec;
    }
  }
  gatherValue(values) {
    const me = this, valueBindProperty = me.defaultBindProperty;
    if (me.constructor !== _Widget && valueBindProperty in me) {
      values[me.name || me.ref || me.id] = me[valueBindProperty];
    }
  }
  gatherValues(values) {
    this.eachWidget((widget) => widget.gatherValue(values), false);
  }
  //endregion
  get forwardTwinEvents() {
    const value = this._forwardTwinEvents;
    return value && ObjectHelper.getTruthyKeys(value);
  }
  /**
   * This widget's twin that is placed in an overflow menu when this widget has been hidden by its owner, typically
   * a {@link Core.widget.Toolbar} due to {@link Core.widget.Toolbar#config-overflow}. The `overflowTwin` is created
   * lazily by {@link #function-ensureOverflowTwin}.
   *
   * @member {Core.widget.Widget} overflowTwin
   * @readonly
   * @internal
   */
  /**
   * This method returns the config object to use for creating this widget's {@link #property-overflowTwin}.
   *
   * @param {Function|Object} [overrides] If an object is passed, it is a set of config properties to override the
   * config object returned by {@link #function-configureOverflowTwin}. If a function is passed, it is called with
   * the config object. The function may either alter the object it is given or return a replacement.
   * @returns {Object} The `overflowTwin` config object
   * @internal
   */
  configureOverflowTwin(overrides) {
    var _a2;
    const me = this;
    let config = ObjectHelper.clone(me.initialConfig);
    delete config.id;
    config.hidden = false;
    config.type = me.type;
    config._overflowTwinOrigin = me;
    config.disabled = me.disabled;
    if ("value" in me) {
      config.value = me.value;
    }
    (_a2 = me.forwardTwinEvents) == null ? void 0 : _a2.forEach((ev) => {
      delete config[`on${StringHelper.capitalize(ev)}`];
    });
    if (overrides) {
      config = typeof overrides === "function" ? overrides(config) || config : ObjectHelper.assign(config, overrides);
    }
    return config;
  }
  /**
   * This method creates the {@link #property-overflowTwin} for this widget. It is called by
   * {@link #function-ensureOverflowTwin} if the `overflowTwin` does not yet exist.
   *
   * The config for the {@link #property-overflowTwin} is produced by {@link #function-configureOverflowTwin}.
   *
   * @param {Function|Object} [overrides] If an object is passed, it is a set of config properties to override the
   * config object returned by {@link #function-configureOverflowTwin}. If a function is passed, it is called with
   * the config object. The function may either alter the object it is given or return a replacement.
   * @returns {Core.widget.Widget} The `overflowTwin`
   * @internal
   */
  createOverflowTwin(overrides) {
    var _a2;
    const me = this, config = me.configureOverflowTwin(overrides), overflowTwin = _Widget.create(config);
    (_a2 = me.forwardTwinEvents) == null ? void 0 : _a2.forEach((ev) => {
      overflowTwin.ion({
        [ev]: (info) => {
          if (me.overflowTwin === info.source) {
            info = ObjectHelper.assign({}, info);
            delete info.source;
            me.trigger(info.eventName, info);
          }
        }
      });
    });
    return overflowTwin;
  }
  /**
   * This method returns the existing {@link #property-overflowTwin} or creates it, if it has not yet been created
   * (see {@link #function-createOverflowTwin}).
   *
   * @param {Function|Object} [overrides] If an object is passed, it is a set of config properties to override the
   * config object returned by {@link #function-configureOverflowTwin}. If a function is passed, it is called with
   * the config object. The function may either alter the object it is given or return a replacement.
   * @param {Function} [onCreate] A function to call when the `overflowTwin` is initially created.
   * @returns {Core.widget.Widget} The `overflowTwin`
   * @internal
   */
  ensureOverflowTwin(overrides, onCreate) {
    let { overflowTwin } = this;
    if (!overflowTwin) {
      this.overflowTwin = overflowTwin = this.createOverflowTwin(overrides);
      onCreate == null ? void 0 : onCreate(overflowTwin);
    }
    return overflowTwin;
  }
  //---------------------------------------------------------------------------------------------------------
  //region Render
  /**
   * Returns `true` if this class uses `compose()` to render itself.
   * @returns {Boolean}
   * @internal
   */
  get isComposable() {
    return !this.compose.$nullFn;
  }
  adoptElement(element, adopt, id) {
    var _a2;
    const me = this, adoptElement = typeof adopt === "string" ? document.getElementById(adopt) : adopt, previousHolder = _Widget.fromElement(adoptElement);
    if (previousHolder && previousHolder.adopt && previousHolder !== me) {
      const previousHolderAdopt = typeof previousHolder.adopt === "string" ? document.getElementById(previousHolder.adopt) : previousHolder.adopt;
      if (previousHolderAdopt === adoptElement) {
        previousHolder.destroy();
      }
    }
    me.preExistingElements = Array.from(adoptElement.childNodes);
    me.adoptedElementClassName = adoptElement.className;
    me.adoptedElementCssText = adoptElement.style.cssText;
    if (adoptElement.id && !id) {
      me.id = element.id = adoptElement.id;
    }
    DomHelper.syncAttributes(element, adoptElement);
    for (let i = 0, { length } = element.childNodes; i < length; i++) {
      adoptElement.appendChild(element.childNodes[0]);
    }
    delete me._contentRange;
    me._element = adoptElement;
    const domConfig = element.lastDomConfig, listeners = domConfig == null ? void 0 : domConfig.listeners;
    if (listeners && me.isComposable) {
      (_a2 = listeners.un) == null ? void 0 : _a2.call(listeners);
      addElementListeners(me, adoptElement, domConfig);
    }
    adoptElement.lastDomConfig = domConfig || adoptElement.lastDomConfig;
    adoptElement.$refOwnerId = me.id;
    if (!me.scaleToFitWidth) {
      me.getConfig("monitorResize");
    }
  }
  /**
   * Defines an element reference accessor on the class prototype. This accessor is used to flush any pending DOM
   * changes prior to accessing such elements.
   * @param {String} name
   * @param {String} key
   * @private
   */
  addRefAccessor(name, key) {
    const { prototype: prototype2 } = this.constructor;
    defineProperty7(prototype2, key, {
      writable: true,
      value: null
    });
    defineProperty7(prototype2, name, {
      get() {
        this.recompose.flush();
        return this[key];
      },
      set(el) {
        this[key] = el;
      }
    });
  }
  /**
   * This method is called by `DomHelper.createElement` and `DomSync.sync` as new reference elements are created.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {DomConfig} [domConfig] The DOM config object.
   * @internal
   */
  attachRef(name, el, domConfig) {
    const me = this, key = "_" + name;
    el.dataset && (el.dataset.ownerCmp = me.id);
    if (me.isComposable) {
      if (!(key in me)) {
        me.addRefAccessor(name, key);
      }
      addElementListeners(me, el, domConfig, name);
    }
    me.byRef[name] = el;
    me[name] = el;
  }
  /**
   * This method is called by `DomSync.sync` as reference elements are removed from the DOM.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {DomConfig} domConfig The DOM config object.
   * @internal
   */
  detachRef(name, el, domConfig) {
    const me = this, listeners = me._refListeners;
    if (listeners == null ? void 0 : listeners[name]) {
      listeners[name]();
      delete listeners[name];
    }
    me[name] = null;
    delete me.byRef[name];
  }
  /**
   * This method is called following an update to the widget's rendered DOM.
   * @internal
   */
  afterRecompose() {
  }
  /**
   * Returns a {@link Core.helper.DomHelper#function-createElement-static} config object that defines this widget's
   * DOM structure. This object should be determined using {@link Core.Base#property-configurable-static} properties
   * to ensure this method is called again if these properties are modified.
   *
   * For more information see {@link Core.widget.Widget class documentation}.
   * @returns {DomConfig}
   * @advanced
   */
  compose() {
    return {
      class: DomClassList.normalize(this.widgetClassList, "object")
    };
  }
  /**
   * This method iterates the class hierarchy from Widget down to the class of this instance and calls any `compose`
   * methods implemented by derived classes.
   * @returns {Object}
   * @private
   */
  doCompose() {
    const me = this, { $meta: meta } = me, classes = meta.hierarchy, renderConfigs = meta.renderConfigs || meta.getInherited("renderConfigs");
    let { composers } = meta, domConfig = null, c, key, i, proto3;
    me.recompose.suspend();
    if (!composers) {
      meta.composers = composers = [];
      for (i = classes.indexOf(_Widget); i < classes.length; ++i) {
        proto3 = classes[i].prototype;
        if (hasOwn4(proto3, "compose")) {
          composers.push(proto3);
        }
      }
      if (!hasOwn4(renderConfigs, renderConfigObserver)) {
        renderConfigs[renderConfigObserver] = {
          get(name) {
            renderConfigs[name] = true;
          }
        };
      }
    }
    me.configObserver = renderConfigs[renderConfigObserver];
    for (i = 0; i < composers.length; ++i) {
      c = composers[i].compose.call(me, domConfig);
      domConfig = domConfig ? DomHelper.merge(domConfig, c) : c;
    }
    if (hasOwn4(me, "compose") && (c = me.compose)) {
      c = c.call(me, domConfig);
      DomHelper.merge(domConfig, c);
    }
    me.configObserver = null;
    return DomHelper.normalizeChildren(domConfig, (childName, hoist) => {
      if (hoist) {
        key = "_" + childName;
        if (!(key in me)) {
          me.addRefAccessor(childName, key);
        }
      }
    });
  }
  get element() {
    if (this.isComposable && !this.isDestroying) {
      this.recompose.flush();
    }
    return this._element;
  }
  /**
   * Template method called during DOM updates. See {@link Core.helper.DomSync#function-sync-static DomSync.sync()}.
   * @param {Object} info Properties describing the sync action taken.
   * @internal
   */
  domSyncCallback(info) {
  }
  changeElement(element) {
    const me = this, compose = me.isComposable;
    if (compose) {
      element = me.doCompose();
    }
    if (typeof element === "string") {
      element = DomHelper.createElementFromTemplate(element);
    } else if (ObjectHelper.isObject(element)) {
      element = DomHelper.createElement(element, {
        refOwner: me,
        callback: me.domSyncCallback
        // mimic DomSync callbacks (needed by TaskBoard)
      });
      me.recompose.resume();
      compose && addElementListeners(me, element, element.lastDomConfig);
    } else if (DomHelper.isReactElement(me.peekConfig("html"))) {
      element = document.createElement("div");
    } else if (element.nodeType !== 1) {
      element = DomHelper.createElementFromTemplate(me.template(me));
    }
    element.id = me.id;
    if (me.elementAttributes) {
      DomHelper.setAttributes(element, me.elementAttributes);
    }
    return element;
  }
  updateElement(element) {
    const me = this, { className } = element, { contentElement, contentElementCls, isComposable } = me, hasChildContent = contentElement !== element, namedElements = !isComposable && element.querySelectorAll("[data-reference]"), classes = isComposable ? [] : me.widgetClassList;
    let uiClasses = (hasChildContent || !isComposable) && me.uiClasses;
    className && classes.unshift(className);
    me._hidden && classes.push("b-hidden");
    me._readOnly && classes.push("b-readonly");
    FunctionHelper.noThrow(
      element,
      "remove"
      /*, () => { debugger; } /**/
    );
    if (uiClasses) {
      if (contentElementCls == null ? void 0 : contentElementCls.value) {
        uiClasses = uiClasses.slice();
        uiClasses.push(contentElementCls.value);
      }
      uiClasses = uiClasses.join(" ");
    } else {
      uiClasses = contentElementCls == null ? void 0 : contentElementCls.value;
    }
    if (uiClasses) {
      if (hasChildContent) {
        contentElement.className += " " + uiClasses;
      } else {
        classes.push(uiClasses);
      }
    }
    if (!me.parent) {
      const { defaultCls } = me, { outerCls } = _Widget;
      classes.push(...defaultCls ? outerCls.filter((c) => !(c in defaultCls) || defaultCls[c]) : outerCls);
    }
    element.className = classes.join(" ");
    if (namedElements) {
      for (let el, i = 0; i < namedElements.length; ++i) {
        el = namedElements[i];
        me.attachRef(el.getAttribute("data-reference"), el);
        el.removeAttribute("data-reference");
      }
    }
    if (!me.adopt && !me.scaleToFitWidth) {
      me.getConfig("monitorResize");
    }
    me.getConfig("role");
    me.getConfig("ariaLabel");
    me.getConfig("ariaDescription");
    if (me._html) {
      me.getConfig("htmlMutationObserver");
    }
    me.trigger("elementCreated", { element });
  }
  updateAriaDescription(ariaDescription) {
    const { ariaElement } = this, descElId = `${this.id}-aria-desc-el`;
    if (ariaDescription) {
      const ariaDescEl = this._ariaDescEl || (this._ariaDescEl = DomHelper.createElement({
        className: "b-aria-desc-element",
        id: descElId,
        parent: ariaElement
      }));
      ariaDescEl.innerText = ariaDescription.match(localizeRE) ? this.L(ariaDescription, this) : ariaDescription;
      ariaElement.setAttribute("aria-describedBy", ariaDescEl.id);
    } else if (ariaElement.getAttribute("aria-describedby") === descElId) {
      ariaElement.removeAttribute("aria-describedBy");
    }
  }
  updateAriaLabel(ariaLabel) {
    DomHelper.setAttributes(this.ariaElement, {
      "aria-label": (ariaLabel == null ? void 0 : ariaLabel.match(localizeRE)) ? this.L(ariaLabel, this) : ariaLabel
    });
  }
  updateAriaHasPopup(ariaHasPopup) {
    DomHelper.setAttributes(this.ariaElement, {
      "aria-haspopup": ariaHasPopup
    });
  }
  updateRole(role) {
    var _a2, _b;
    if (role) {
      (_a2 = this.ariaElement) == null ? void 0 : _a2.setAttribute("role", role);
    } else {
      (_b = this.ariaElement) == null ? void 0 : _b.removeAttribute("role");
    }
  }
  get ariaElement() {
    this.getConfig("element");
    const { _ariaElement } = this;
    return _ariaElement.nodeType === Node.ELEMENT_NODE ? _ariaElement : ObjectHelper.getPath(this, _ariaElement);
  }
  /**
   * This method determines if this widget (typically a {@link Core.widget.Tool}) should be placed in the header of
   * the calling {@link Core.widget.Panel}.
   * @param {Object} options An object specifying various options.
   * @param {Boolean} options.collapsed True if the panel is in a {@link Core.widget.Panel#config-collapsed} state.
   * @param {Boolean} options.alt True if the panel is rendering its alternate panel header, false for the primary header.
   * @returns {Boolean}
   * @internal
   */
  isCollapsified({ collapsed, alt }) {
    const { collapsify } = this, hideIfCollapsed = collapsify === "hide", alwaysPrimary = collapsify === false, altIfCollapsedElsePrimary = collapsify == null, alwaysAlt = collapsify === "overlay";
    return alt ? alwaysAlt || altIfCollapsedElsePrimary && collapsed : alwaysPrimary || hideIfCollapsed || altIfCollapsedElsePrimary && !collapsed;
  }
  /**
   * Calling this {@link Core.mixin.Delayable#property-delayable-static} method marks this widget as dirty. The DOM
   * will be updated on the next animation frame:
   *
   * ```javascript
   *  widget.recompose();
   *
   *  console.log(widget.recompose.isPending);
   *  > true
   * ```
   *
   * A pending update can be flushed by calling `flush()` (this does nothing if no update is pending):
   *
   * ```javascript
   *  widget.recompose.flush();
   * ```
   *
   * This can be combined in one call to force a DOM update without first scheduling one:
   *
   * ```javascript
   *  widget.recompose.now();
   * ```
   * @advanced
   */
  async recompose() {
    const me = this, options = {
      targetElement: me.element,
      domConfig: me.doCompose(),
      refOwner: me,
      callback: me.domSyncCallback,
      // This limits the sync() to only removing the classes and styles added by previous renderings. This
      // allows dynamically added styles and classes to be preserved:
      strict: true
    };
    if (me.transitionRecompose) {
      me.isTransitioningDom = true;
      await DomHelper.transition(ObjectHelper.assign({
        element: me.element,
        action() {
          DomSync.sync(options);
        }
      }, me.transitionRecompose));
      if (me.isDestroyed) {
        return;
      }
      me.isTransitioningDom = false;
      me.trigger("transitionedRecompose");
    } else {
      DomSync.sync(options);
    }
    if (options.changed) {
      me.afterRecompose();
      me.trigger("recompose");
    }
    me.resumeRecompose();
  }
  // To allow hooking into resuming recompose, used by TaskBoard
  resumeRecompose() {
    this.recompose.resume();
  }
  changeElementRef(el) {
    if (typeof el === "string") {
      const id = el;
      if (!(el = document.getElementById(id))) {
        throw new Error(`No element found with id '${id}'`);
      }
    }
    return el;
  }
  changeAppendTo(appendTo) {
    return this.changeElementRef(appendTo);
  }
  updateAppendTo(appendTo) {
    if (!this.isConfiguring && appendTo) {
      this.render();
    }
  }
  changeInsertBefore(insertBefore) {
    return this.changeElementRef(insertBefore);
  }
  updateInsertBefore(insertBefore) {
    if (!this.isConfiguring && insertBefore) {
      this.render();
    }
  }
  changeInsertFirst(insertFirst) {
    return this.changeElementRef(insertFirst);
  }
  updateInsertFirst(insertFirst) {
    if (!this.isConfiguring && insertFirst) {
      this.render();
    }
  }
  /**
   * Interprets the {@link #config-appendTo}, {@link #config-insertBefore} and {@link #config-insertFirst}
   * configs to return an array containing `[parentElement, insertBefore]`
   * @internal
   * @param {Core.widget.Widget} source The widget for which to ascertain its render context.
   * @returns {HTMLElement[]} The `[parentElement, insertBefore]` elements.
   */
  getRenderContext(config = this, renderTo) {
    let parentElement = renderTo || config.appendTo, { insertFirst, insertBefore } = config;
    if (insertFirst) {
      parentElement = insertFirst;
      insertBefore = parentElement.firstChild;
    }
    if (insertBefore) {
      if (!parentElement) {
        parentElement = insertBefore.parentElement;
      }
    }
    return [parentElement, insertBefore || void 0];
  }
  render(renderTo, triggerPaint = true) {
    const me = this, { element } = me, [
      parentElement,
      insertBefore
    ] = me.getRenderContext(me, renderTo);
    me.emptyCache();
    if (me.syncElement && me.currentElement) {
      DomHelper.sync(element, me.currentElement);
    } else {
      parentElement == null ? void 0 : parentElement.insertBefore(element, insertBefore);
      me.currentElement = element;
    }
    if (_Widget.fromElement(element.parentElement)) {
      element.classList.remove(..._Widget.outerCls);
    }
    super.render(parentElement, triggerPaint);
    me.rendered = true;
    me.getConfig("role");
    if (triggerPaint) {
      me.getConfig("contentRange");
      me.triggerPaint();
    }
    me.setupFocusListeners();
  }
  /**
   * A function which, when passed an instance of this Widget, produces a valid HTML string which is compiled
   * to create the encapsulating element for this Widget, and its own internal DOM structure.
   *
   * Note that this just creates the DOM structure that *this* Widget owns. If it contains child widgets
   * (Such as for example a grid), this is not included. The template creates own structure.
   *
   * Certain elements within the generated element can be identified as special elements with a `reference="name"`
   * property. These will be extracted from the element upon creation and injected as the named property into
   * the Widget. For example, a {@link Core.widget.TextField} will have an `input` property which is its
   * `<input>` element.
   * @param {Core.widget.Widget} me The widget for which to produce the initial HTML structure.
   * @internal
   */
  template({ tag, html, htmlCls, name }) {
    const me = this;
    if (typeof html === "string" && callbackRe.test(html) && me.resolveCallback(html, me, false)) {
      html = me.callback(html, me, [me]);
    }
    const content = (html == null ? void 0 : html.call) ? html.call(me, me) : html;
    return `<${tag} class="${content ? htmlCls : ""}" ${name ? `data-name="${name}"` : ""}>${content || ""}</${tag}>`;
  }
  updateRecomposeAsync(async) {
    this.recompose.immediate = !async;
  }
  //endregion
  //---------------------------------------------------------------------------------------------------------
  onConfigChange({ name }) {
    var _a2;
    if (this._element && !this.isDestroying && ((_a2 = this.$meta.renderConfigs) == null ? void 0 : _a2[name])) {
      this.recompose();
    }
  }
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  // Clean up configs
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs(configs);
    delete configs.parent;
  }
  // Extract config's current value, special handling for style
  getConfigValue(name, options) {
    if (name === "style") {
      return this._style;
    }
    return super.getConfigValue(name, options);
  }
  // Extract current value of all initially used configs, special handling for widget type
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    if ((options == null ? void 0 : options.depth) > 0) {
      result.type = this.type;
    }
    return result;
  }
  //endregion
  /**
   * Get widgets elements dataset or assign to it
   * @property {Object}
   * @category DOM
   */
  get dataset() {
    return this.element.dataset;
  }
  changeDataset(dataset) {
    ObjectHelper.assign(this.dataset, dataset);
  }
  get dragGhost() {
    return this.constructor._dragGhost || (this.constructor._dragGhost = DomHelper.createElement({
      // Safari won't allow dragging an empty node
      html: "\xA0",
      style: "position:absolute;top:-10000em;left:-10000em"
    }));
  }
  updateParent(parent) {
    const { _element: element } = this;
    if (element) {
      element.classList[parent ? "remove" : "add"](..._Widget.outerCls);
    }
  }
  get constrainTo() {
    let result = this._constrainTo;
    result = result === void 0 ? globalThis : (result == null ? void 0 : result.nodeType) === Node.DOCUMENT_FRAGMENT_NODE ? result.host || result.ownerDocument : result;
    if (this.positioned) {
      const { offsetParent } = this.element;
      if (offsetParent && DomHelper.getStyleValue(offsetParent, "overflow") === "hidden") {
        result = Rectangle.from(offsetParent).moveTo(0, 0);
      } else if (result && !result.isRectangle) {
        const isViewport = result === document || result === globalThis;
        result = Rectangle.from(result, offsetParent);
        if (isViewport) {
          result.translate(globalThis.pageXOffset, globalThis.pageYOffset);
        }
      }
    }
    return result;
  }
  updateCentered(value) {
    const {
      element,
      _anchorElement
    } = this;
    if (value && !this.floating && !this.positioned) {
      throw new Error("`centered` is only relevant when a Widget is `floating` or `positioned`");
    }
    if (value) {
      element.classList.add("b-centered");
      element.style.transform = element.style.left = element.style.top = "";
      _anchorElement == null ? void 0 : _anchorElement.classList.add("b-hide-display");
      element.classList.remove("b-anchored");
    } else {
      element.classList.remove("b-centered");
    }
  }
  /**
   * The child element into which content should be placed. This means where {@link #config-html} should be put,
   * or, for {@link Core.widget.Container Container}s, where child items should be rendered.
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   * @advanced
   */
  get contentElement() {
    return this.element;
  }
  get contentRange() {
    const me = this, { contentElement } = me, contentRange = me._contentRange || (me._contentRange = new Range());
    if (contentRange.collapsed) {
      contentRange.setStart(contentElement, me.contentRangeStartOffset || 0);
      contentRange.setEnd(contentElement, me.contentRangeEndOffset || contentElement.childNodes.length);
    }
    return contentRange;
  }
  /**
   * This method fixes the element's `$refOwnerId` when this instance's `id` is changing.
   * @param {Node} el The element or DOM node to fix.
   * @param {String} id The new id being assigned.
   * @param {String} oldId The old id (previously assigned).
   * @private
   */
  fixRefOwnerId(el, id, oldId) {
    if (el.$refOwnerId === oldId) {
      el.$refOwnerId = id;
      for (let { childNodes } = el, i = childNodes.length; i-- > 0; ) {
        this.fixRefOwnerId(childNodes[i], id, oldId);
      }
    }
  }
  get placement() {
    var _a2;
    const me = this, { element } = me;
    let adjRect, placement, rect;
    if ((element == null ? void 0 : element.offsetParent) && !nonFlowedPositions.test(DomHelper.getStyleValue(element, "position"))) {
      const next = element.nextElementSibling, previous = element.previousElementSibling, last = !next && previous;
      placement = DomHelper.getStyleValue(element.parentElement, "flex-direction");
      if (placement) {
        placement = placement.startsWith("row") ? "h" : "v";
      } else {
        adjRect = (_a2 = next || previous) == null ? void 0 : _a2.getBoundingClientRect();
        rect = adjRect && element.getBoundingClientRect();
        placement = adjRect && Math.abs(adjRect.top - rect.top) < Math.abs(adjRect.left - rect.left) ? "h" : "v";
      }
      placement += placement === "h" ? last ? "r" : "l" : last ? "b" : "t";
    }
    return placement;
  }
  updateId(id, oldId) {
    super.updateId(id, oldId);
    if (oldId) {
      const { byRef, element } = this;
      for (const ref in byRef) {
        byRef[ref].dataset && (byRef[ref].dataset.ownerCmp = id);
      }
      element.id = id;
      this.fixRefOwnerId(element, id, oldId);
    }
  }
  /**
   * Get/set widgets elements style. The setter accepts a cssText string or a style config object, the getter always
   * returns a CSSStyleDeclaration
   * @property {CSSStyleDeclaration}
   * @accepts {String|Object|CSSStyleDeclaration}
   * @category DOM
   */
  get style() {
    const { element } = this;
    return (element == null ? void 0 : element.ownerDocument.defaultView.getComputedStyle(element)) || this._style;
  }
  updateStyle(style) {
    this.element && DomHelper.applyStyle(this.element, style);
  }
  updateTitle(title) {
    if (this.titleElement) {
      this.titleElement.innerHTML = title;
    }
  }
  //region floating
  // Hook used by Tooltip to handle RTL
  beforeAlignTo(spec) {
  }
  /**
   * If this Widget is {@link #config-floating} or {@link #config-positioned}, and visible, aligns the widget
   * according to the passed specification. To stop aligning, call this method without arguments.
   * @param {AlignSpec|HTMLElement} [spec] Alignment options. May be an alignment specification object, or an
   * `HTMLElement` to align to using this Widget's {@link #config-align} configuration.
   * @category Float & align
   */
  alignTo(spec) {
    var _a2;
    const me = this, {
      lastAlignSpec,
      element
    } = me, {
      offsetParent,
      style,
      classList
    } = element;
    if (lastAlignSpec) {
      lastAlignSpec.monitorIntersection && me.intersectionObserver.unobserve(lastAlignSpec.target);
      if (isFinite(lastAlignSpec.zone)) {
        element.classList.remove(alignedClass[lastAlignSpec.zone]);
      }
    }
    if (!spec) {
      me.removeTransientListeners();
      me.anchor = me.lastAlignSpec = null;
      return;
    }
    me.beforeAlignTo(spec);
    if (spec.nodeType === Element.ELEMENT_NODE || spec.isWidget || spec.$$name === "Point") {
      spec = {
        target: spec
      };
    }
    me.releaseSizeConstraints();
    const {
      scrollable,
      constrainTo
    } = me, elMinHeight = DomHelper.measureSize(DomHelper.getStyleValue(element, "minHeight"), element), elMinWidth = DomHelper.measureSize(DomHelper.getStyleValue(element, "minWidth"), element), positioned = me.positioned && DomHelper.getStyleValue(element, "position") !== "fixed", scale = me.scale || 1, passedTarget = spec.target, targetEvent = spec.domEvent || spec.event || passedTarget, target = (passedTarget == null ? void 0 : passedTarget.isRectangle) ? passedTarget : (passedTarget == null ? void 0 : passedTarget.element) || passedTarget, aligningToElement = (target == null ? void 0 : target.nodeType) === Element.ELEMENT_NODE, aligningToEvent = ((_a2 = targetEvent == null ? void 0 : targetEvent.target) == null ? void 0 : _a2.nodeType) === Element.ELEMENT_NODE;
    spec = spec.realignTarget ? spec : ObjectHelper.assign({
      aligningToEvent,
      aligningToElement,
      constrainTo,
      align: "b-t",
      // we can end up w/o a value for this if an object replaces a string
      axisLock: me.axisLock,
      anchor: me.anchor
    }, me.align, spec);
    const minWidth = spec.minWidth || elMinWidth, minHeight = spec.minHeight || elMinHeight;
    me.lastAlignSpec = spec;
    if (aligningToEvent) {
      delete spec.target;
      spec.domEvent = targetEvent;
      spec.anchoredTo = targetEvent.target;
      spec.position = new Point(targetEvent.clientX + 1, targetEvent.clientY + 1);
    } else if (aligningToElement) {
      spec.target = target;
      if (hasLayout(target instanceof SVGElement ? target.closest("svg") : target)) {
        spec = Object.setPrototypeOf({}, spec);
        spec.target = me.lastAlignSpec.targetRect = spec.realignTarget || (spec.allowTargetOut ? Rectangle.from(target, positioned ? offsetParent : null, !positioned) : DomHelper.isInView(target, false, me));
        if (!spec.target) {
          const result2 = me.hide();
          if (!me.isDestroyed) {
            me.lastAlignSpec.targetOutOfView = true;
          }
          return result2;
        }
        spec.target.height = Math.max(spec.target.height, 1);
        spec.target.width = Math.max(spec.target.width, 1);
        me.lastAlignSpec.anchoredTo = target;
      }
    }
    if (spec.anchor) {
      spec.anchorSize = me.anchorSize;
      if (!element.contains(me.anchorPathElement)) {
        element.appendChild(me.anchorElement);
      }
    }
    me.isAligning = true;
    me.trigger("beforeAlign", spec);
    const myPosition = Rectangle.from(element, positioned ? offsetParent : null, true), {
      width: startWidth,
      height: startHeight
    } = myPosition;
    myPosition.isAlignRectangle = true;
    minWidth && (myPosition.minWidth = minWidth * scale);
    minHeight && (myPosition.minHeight = minHeight * scale);
    me.isAligning = false;
    spec.rtl = me.rtl;
    if (spec.align.includes("s") || spec.align.includes("e")) {
      if (me.rtl) {
        spec.align = spec.align.replace(/s/g, "r").replace(/e/g, "l");
      } else {
        spec.align = spec.align.replace(/s/g, "l").replace(/e/g, "r");
      }
    }
    const result = me.lastAlignSpec.result = myPosition.alignTo(spec);
    let { align, anchor, x, y, width, height, overlap } = result;
    me.lastAlignSpec.zone = result.zone;
    if (height != startHeight) {
      const shrunk = height < startHeight;
      me.alignmentChanges = me.alignmentChanges | (shrunk ? 1 : 2);
      style[me.alignedHeightStyle = alignChangeDims[me.alignmentChanges & 3]] = `${height / scale}px`;
      if (shrunk && !me._minHeight && elMinHeight) {
        style.minHeight = `${Math.min(height, elMinHeight) / scale}px`;
      }
      if (scrollable) {
        scrollable.overflowY = shrunk;
      }
    }
    if (width != startWidth) {
      const shrunk = width < startWidth;
      me.alignmentChanges = me.alignmentChanges | (shrunk ? 4 : 8);
      style[me.alignedWidthStyle = alignChangeDims[me.alignmentChanges & 12]] = `${width / scale}px`;
      if (shrunk && !me._minWidth && elMinWidth) {
        style.minWidth = `${Math.min(width, elMinWidth) / scale}px`;
      }
      if (scrollable) {
        scrollable.overflowX = shrunk;
      }
    }
    if (align && me.alignmentChanges) {
      const newRect = Rectangle.from(element, positioned ? offsetParent : null, true);
      spec.align = align;
      const newResult = me.lastAlignSpec.result = newRect.alignTo(spec);
      anchor = newResult.anchor;
      x = newResult.x;
      y = newResult.y;
      width = newResult.width;
      height = newResult.height;
    }
    if (!me.centered) {
      me.setXY(x, y);
    }
    if (!result.overlap && isFinite(result.zone)) {
      classList.add(alignedClass[result.zone]);
    }
    if (anchor == null ? void 0 : anchor.edge) {
      const { edge } = anchor, { anchorElement } = me, { style: anchorStyle } = anchorElement, elRect = Rectangle.from(element), colorMatchPoint = [];
      if (edge === "top" || edge === "bottom") {
        colorMatchPoint[0] = anchor.x;
        colorMatchPoint[1] = edge === "top" ? 1 : elRect.height - 1;
      } else {
        colorMatchPoint[0] = edge === "left" ? 1 : elRect.width - 1;
        colorMatchPoint[1] = anchor.y;
      }
      anchorStyle.display = "none";
      let colourSource = DomHelper.childFromPoint(element, ...colorMatchPoint);
      if (((colourSource == null ? void 0 : colourSource.matches(":focus")) || colourSource === GlobalEvents_default.currentOverElement) && element.compareDocumentPosition(colourSource) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
        colourSource = colourSource.parentNode;
      }
      if (colourSource && colourSource !== document) {
        let fillColour = DomHelper.getStyleValue(colourSource, "background-color");
        while (fillColour.match(isTransparent) && DomHelper.getStyleValue(colourSource, "position") !== "absolute") {
          colourSource = colourSource.parentNode;
          if (colourSource === document) {
            break;
          }
          fillColour = DomHelper.getStyleValue(colourSource, "background-color");
        }
        if (fillColour.match(isTransparent)) {
          me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
        } else {
          me.anchorPathElement.setAttribute("fill", fillColour);
        }
      }
      anchorStyle.transform = anchorStyle.display = "";
      anchorElement.className = `b-anchor b-anchor-${edge}`;
      anchor.x && (anchor.x /= scale);
      anchor.y && (anchor.y /= scale);
      DomHelper.setTranslateXY(anchorElement, anchor.x, anchor.y);
      classList.add("b-anchored");
    } else if (me._anchorElement) {
      me.anchorElement.classList.add("b-hide-display");
      classList.remove("b-anchored");
    }
    if (!aligningToElement) {
      style.pointerEvents = "none";
      const el = DomHelper.elementFromPoint(x, y);
      if (!me.owns(el)) {
        me.lastAlignSpec.anchoredTo = el;
      }
      style.pointerEvents = "";
    }
    if ((me.scrollAction === "realign" && aligningToElement || me.scrollAction === "hide") && !me.documentScrollListener) {
      me.clearTimeout(me.scrollListenerTimeout);
      if (spec.monitorTargetMutation && !me.targetObserver) {
        const targetObserver = me.targetObserver || (me.targetObserver = new MutationObserver(me.onTargetParentMutation.bind(me)));
        targetObserver.observe(DomHelper.getRootElement(target), {
          childList: true,
          attributes: true,
          subtree: true
        });
      }
      me.scrollListenerTimeout = me.setTimeout(() => {
        var _a3, _b;
        const targetRoot = (_b = (_a3 = aligningToElement ? target : me.lastAlignSpec.anchoredTo).getRootNode) == null ? void 0 : _b.call(_a3);
        me.documentScrollListener = EventHelper.addListener(document, "scroll", "doHideOrRealign", {
          capture: true,
          thisObj: me
        });
        if (targetRoot == null ? void 0 : targetRoot.mode) {
          me.targetRootScrollListener = EventHelper.addListener(targetRoot, "scroll", "doHideOrRealign", {
            capture: true,
            thisObj: me
          });
        }
      }, me.scrollAction === "hide" ? me.ignoreScrollDuration : 0);
    }
    if (aligningToElement) {
      if (spec.monitorResize && !me.targetResizeListener) {
        ResizeMonitor.addResizeListener(target, me.onTargetResize);
        me.targetResizeListener = true;
      }
      if (spec.monitorIntersection && !(overlap || target.contains(element) || target.ownerSVGElement)) {
        me.intersectionObserver.observe(target);
      }
    }
    if (!BrowserHelper.isAndroid) {
      if (!me.constrainListeners) {
        const el = (constrainTo == null ? void 0 : constrainTo.isRectangle) ? globalThis : constrainTo;
        me.clearTimeout(me.resizeListenerTimeout);
        me.resizeListenerTimeout = me.setTimeout(() => {
          me.constrainListeners = true;
          ResizeMonitor.addResizeListener(el || globalThis, me.onAlignConstraintChange);
        }, me.ignoreScrollDuration);
      }
    }
  }
  onTargetParentMutation(mutationRecords) {
    var _a2;
    const { element, lastAlignSpec } = this;
    if (lastAlignSpec == null ? void 0 : lastAlignSpec.aligningToElement) {
      if (!((_a2 = lastAlignSpec.target) == null ? void 0 : _a2.isConnected)) {
        this.hide();
      } else if (mutationRecords.some(({ target }) => target.contains(lastAlignSpec.target) && !element.contains(target))) {
        this.realign();
      }
    }
  }
  get intersectionObserver() {
    return this._intersectionObserver || (this._intersectionObserver = new IntersectionObserver(this.onTargetIntersectionchange.bind(this), {
      root: BrowserHelper.isSafari ? this.rootElement : this.rootElement.ownerDocument
    }));
  }
  onTargetIntersectionchange(entries) {
    if (!this.isDestroyed) {
      const e = entries[entries.length - 1];
      if (!e.isIntersecting) {
        this.onAlignTargetOutOfView(e.target);
      }
    }
  }
  onTargetResize() {
    const { lastAlignSpec } = this;
    if (lastAlignSpec) {
      const {
        width: lastWidth,
        height: lastHeight
      } = lastAlignSpec.targetRect, {
        width,
        height
      } = lastAlignSpec.target.getBoundingClientRect();
      if (width !== lastWidth || height !== lastHeight) {
        this.onAlignConstraintChange(...arguments);
      }
    }
  }
  /**
   * This method is called when the {@link #function-alignTo} target element loses intersection with the
   * visible viewport. That means it has been scrolled out of view, or becomes zero size, or hidden or
   * is removed from the DOM.
   *
   * The base class implementation hides by default.
   * @param {HTMLElement} target The alignTo target that is no longer in view.
   * @internal
   */
  onAlignTargetOutOfView(target) {
    this.hide();
    this.lastAlignSpec && (this.lastAlignSpec.targetOutOfView = true);
  }
  onAlignConstraintChange(el, oldRect, { height }) {
    const { style } = this.contentElement, { overflowY } = style;
    this.setTimeout(this.realign, 50);
    if (oldRect && height > oldRect.height) {
      style.overflowY = "hidden";
      this.requestAnimationFrame(() => style.overflowY = overflowY);
    }
  }
  /**
   * Called when an element which affects the position of this Widget's
   * {@link #function-alignTo align target} scrolls so that this can realign.
   *
   * If the target has scrolled out of view, then this Widget is hidden.
   * @internal
   */
  realign() {
    const me = this, { lastAlignSpec } = me;
    if ((me.floating || me.positioned) && lastAlignSpec && me.isVisible) {
      if (lastAlignSpec.aligningToElement) {
        const insideTarget = lastAlignSpec.target.contains(this.element), realignTarget = DomHelper.isInView(lastAlignSpec.target, false, me);
        if (!lastAlignSpec.allowTargetOut && (!hasLayout(lastAlignSpec.target) || !realignTarget)) {
          me.hide();
          if (!me.isDestroyed) {
            me.lastAlignSpec.targetOutOfView = true;
          }
          return;
        }
        lastAlignSpec.realignTarget = insideTarget ? null : realignTarget;
      }
      DomHelper.addTemporaryClass(me.element, "b-realigning", me.realignTimeout, me);
      me.alignTo(lastAlignSpec);
    }
  }
  /**
   * Returns the specified bounding rectangle of this widget.
   * @param {'border'|'client'|'content'|'inner'|'outer'} [which='border'] By default, the rectangle returned is the
   * bounding rectangle that contains the `element` border. Pass any of these values to retrieve various rectangle:
   *  - `'border'` to get the {@link Core.helper.util.Rectangle#function-from-static border rectangle} (the default).
   *  - `'client'` to get the {@link Core.helper.util.Rectangle#function-client-static client rectangle}.
   *  - `'content'` to get the {@link Core.helper.util.Rectangle#function-content-static content rectangle}.
   *  - `'inner'` to get the {@link Core.helper.util.Rectangle#function-inner-static inner rectangle}.
   *  - `'outer'` to get the {@link Core.helper.util.Rectangle#function-outer-static outer rectangle}.
   * @param {HTMLElement|Core.widget.Widget} [relativeTo] Optionally, a parent element or widget in whose space to
   * calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll=false] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle}
   * @internal
   */
  rectangle(which, relativeTo, ignorePageScroll) {
    return this.rectangleOf("element", which, relativeTo, ignorePageScroll);
  }
  /**
   * Returns the specified bounding rectangle of the specified child `element` of this widget.
   * @param {String} [element] The child element name.
   * @param {'border'|'client'|'content'|'inner'|'outer'} [which='border'] By default, the rectangle returned
   * is the bounding rectangle that contains the `element` border. Pass any of these values to retrieve various
   * rectangle:
   *  - `'border'` to get the {@link Core.helper.util.Rectangle#function-from-static border rectangle} (the default).
   *  - `'client'` to get the {@link Core.helper.util.Rectangle#function-client-static client rectangle}.
   *  - `'content'` to get the {@link Core.helper.util.Rectangle#function-content-static content rectangle}.
   *  - `'inner'` to get the {@link Core.helper.util.Rectangle#function-inner-static inner rectangle}.
   *  - `'outer'` to get the {@link Core.helper.util.Rectangle#function-outer-static outer rectangle}.
   * @param {HTMLElement|Core.widget.Widget} [relativeTo] Optionally, a parent element or widget in whose space to
   * calculate the Rectangle. If `element` is not `'element'`, then this defaults to the widget's primary element.
   * @param {Boolean} [ignorePageScroll=false] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle}
   * @internal
   */
  rectangleOf(element, which, relativeTo, ignorePageScroll) {
    if (typeof which !== "string") {
      ignorePageScroll = relativeTo;
      relativeTo = which;
      which = "";
    } else if (which === "border") {
      which = "";
    }
    if (typeof relativeTo === "boolean") {
      ignorePageScroll = relativeTo;
      relativeTo = void 0;
    }
    if (element !== "element" && relativeTo === void 0) {
      relativeTo = this.element;
    }
    relativeTo = (relativeTo == null ? void 0 : relativeTo.isWidget) ? relativeTo.element : relativeTo;
    return Rectangle[which || "from"](this[element], relativeTo, ignorePageScroll);
  }
  releaseSizeConstraints() {
    const me = this, {
      scrollable,
      element,
      alignmentChanges
    } = me, { style } = element;
    if (alignmentChanges & 12) {
      DomHelper.setLength(element, me.alignedWidthStyle, me[`_last${StringHelper.capitalize(me.alignedWidthStyle)}`] || "");
      style.minWidth = me._minWidth || "";
      if (scrollable) {
        scrollable.overflowY = scrollable.config.overflowY;
      }
    }
    if (alignmentChanges & 3) {
      DomHelper.setLength(element, me.alignedHeightStyle, me[`_last${StringHelper.capitalize(me.alignedHeightStyle)}`] || "");
      style.minHeight = me._minHeight || "";
      if (scrollable) {
        scrollable.overflowX = scrollable.config.overflowX;
      }
    }
    me.alignmentChanges = 0;
  }
  /**
   * Only valid for {@link #config-floating} Widgets. Moves to the front of the visual stacking order.
   * @category Float & align
   */
  toFront() {
    const { element } = this, parent = this.floating ? this.floatRoot : this.positioned ? element == null ? void 0 : element.parentNode : null, widgetsFrag = document.createDocumentFragment();
    if (this.containsFocus) {
      for (let followingEl = element.nextSibling, nextEl; followingEl; followingEl = nextEl) {
        nextEl = followingEl.nextSibling;
        if (parent.contains(followingEl) && !this.owns(followingEl)) {
          widgetsFrag.appendChild(followingEl);
        }
      }
      parent.insertBefore(widgetsFrag, element);
    } else {
      parent.appendChild(element);
    }
  }
  //endregion
  //region Getters/setters
  updateRef(ref) {
    this.element.dataset.ref = ref;
  }
  /**
   * The child element which scrolls if any. This means the element used by the {@link #config-scrollable}.
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   * @advanced
   */
  get overflowElement() {
    return this.contentElement;
  }
  get maxHeightElement() {
    return this.element;
  }
  changeAlign(align) {
    return typeof align === "string" ? { align } : align;
  }
  changeScrollable(scrollable, oldScrollable) {
    if (typeof scrollable === "boolean") {
      scrollable = {
        overflowX: scrollable,
        overflowY: scrollable
      };
    }
    if (scrollable) {
      scrollable.element = this.overflowElement;
      scrollable.widget = this;
      if (!scrollable.isScroller) {
        scrollable = oldScrollable ? oldScrollable.setConfig(scrollable) : new this.scrollerClass(scrollable);
      }
      scrollable.syncOverflowState();
    } else {
      oldScrollable == null ? void 0 : oldScrollable.destroy();
    }
    return scrollable;
  }
  handleReactElement(html) {
    const parent = this.closest((cmp) => cmp.reactComponent);
    if (parent == null ? void 0 : parent.reactComponent) {
      parent.reactComponent.processWidgetContent({
        reactElement: html,
        widget: this,
        reactComponent: parent.reactComponent
      });
    }
  }
  /**
   * Get/set HTML to display. When specifying HTML, this widget's element will also have the
   * {@link #config-htmlCls} added to its classList, to allow targeted styling.
   * @property {String}
   * @category DOM
   */
  get html() {
    if (this.initializingElement || !this.element) {
      return this.content || this._html;
    }
    return this.contentElement.innerHTML;
  }
  updateHtml(html) {
    const me = this, isClearing = html == null, {
      element,
      contentElement,
      htmlCls
    } = me;
    if (!element && DomHelper.isReactElement(html)) {
      me.whenVisible(() => me.handleReactElement(html));
      return;
    }
    if (element) {
      me.updatingHtml = true;
      const anchorEl = contentElement === element && me._anchorElement;
      if (htmlCls) {
        htmlCls.values.forEach((value) => element.classList[isClearing ? "remove" : "add"](value));
      }
      if (anchorEl) {
        element.removeChild(anchorEl);
      }
      if (html && typeof html === "object") {
        if (DomHelper.isReactElement(html)) {
          me.handleReactElement(html);
        } else {
          DomSync.sync({
            domConfig: {
              ...html,
              onlyChildren: true
            },
            targetElement: me.contentElement
          });
        }
      } else {
        me.contentElement.innerHTML = isClearing ? "" : html;
      }
      me.getConfig("htmlMutationObserver");
      if (anchorEl) {
        element.appendChild(anchorEl);
      }
      if (me.isComposable) {
        me.recompose();
      } else if (me.floating || me.positioned) {
        if (!me.isAligning) {
          me.realign();
        }
      }
    }
  }
  changeHtmlMutationObserver(htmlMutationObserver, was) {
    const me = this, { contentElement } = me;
    was == null ? void 0 : was.disconnect();
    if (htmlMutationObserver) {
      const result = new MutationObserver(() => {
        if (me.updatingHtml) {
          me.updatingHtml = false;
        } else {
          me._html = contentElement.innerHTML;
        }
      });
      result.observe(contentElement, htmlMutationObserver);
      return result;
    }
  }
  updateContent(html) {
    const me = this, isClearing = html == null, { element, htmlCls } = me;
    if (element) {
      const { contentRange } = me;
      if (htmlCls) {
        htmlCls.values.forEach((value) => element.classList[isClearing ? "remove" : "add"](value));
      }
      if (element.isConnected) {
        contentRange.deleteContents();
        if (!isClearing) {
          contentRange.insertNode(DomHelper.createElementFromTemplate(html, {
            fragment: true
          }));
        }
      } else {
        me.contentElement.innerHTML = html;
      }
      me.contentRangeStartOffset = contentRange.startOffset;
      me.contentRangeEndOffset = contentRange.endOffset;
      if ((me.floating || me.positioned) && !me.isAligning) {
        me.realign();
      }
    }
  }
  onThemeChange() {
    var _a2;
    if ((_a2 = this.anchorElement) == null ? void 0 : _a2.offsetParent) {
      this._anchorSize = null;
      this.realign();
    }
  }
  /**
   * Returns an `[x, y]` array containing the width and height of the anchor arrow used when
   * aligning this Widget to another Widget or element.
   *
   * The height is the height of the arrow when pointing upwards, the width is the width
   * of the baseline.
   * @property {Number[]}
   * @category Float & align
   */
  get anchorSize() {
    const me = this;
    let result = this._anchorSize;
    if (!result) {
      const borderWidth = parseFloat(DomHelper.getStyleValue(me.element, "border-top-width")), borderColour = DomHelper.getStyleValue(me.element, "border-top-color"), anchorElement = me.anchorElement, { className } = anchorElement, svgEl = anchorElement.firstElementChild, pathElement = me.anchorPathElement = svgEl.lastElementChild, hidden = me._hidden;
      anchorElement.className = "b-anchor b-anchor-top";
      let backgroundColour = DomHelper.getStyleValue(me.contentElement, "background-color");
      if (backgroundColour.match(isTransparent)) {
        backgroundColour = DomHelper.getStyleValue(me.element, "background-color");
      }
      me.defaultAnchorBackgroundColor = backgroundColour;
      result = anchorElement.getBoundingClientRect();
      const [width, height] = result = me._anchorSize = [result.width, result.height];
      anchorElement.className = className;
      svgEl.setAttribute("height", height + borderWidth);
      svgEl.setAttribute("width", width);
      pathElement.setAttribute("d", `M0,${height}L${width / 2},0.5L${width},${height}`);
      if (borderWidth) {
        pathElement.setAttribute("stroke-width", borderWidth);
        pathElement.setAttribute("stroke", borderColour);
      }
      result[1] -= borderWidth;
      if (hidden) {
        me.element.classList.add("b-hidden");
      }
      if (!me.themeChangeListener) {
        me.themeChangeListener = GlobalEvents_default.ion({
          theme: "onThemeChange",
          thisObj: me
        });
      }
      me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
    }
    return result;
  }
  get anchorElement() {
    const me = this;
    if (!me._anchorElement) {
      const useFilter = me.floating, filterId = `${me.id}-shadow-filter`;
      me._anchorElement = DomHelper.createElement({
        parent: me.element,
        className: "b-anchor b-anchor-top",
        children: [{
          tag: "svg",
          ns: "http://www.w3.org/2000/svg",
          version: "1.1",
          class: "b-pointer-el",
          children: [useFilter ? {
            tag: "defs",
            children: [{
              tag: "filter",
              id: filterId,
              children: [{
                tag: "feDropShadow",
                dx: 0,
                dy: -1,
                stdDeviation: 1,
                "flood-opacity": 0.2
              }]
            }]
          } : null, {
            tag: "path",
            [useFilter ? "filter" : ""]: `url(#${filterId})`
          }]
        }]
      });
    }
    return me._anchorElement;
  }
  updateAnchor(anchor) {
    if (this._anchorElement) {
      this._anchorElement.classList[anchor ? "remove" : "add"]("b-hide-display");
    }
  }
  updateDraggable(draggable) {
    var _a2, _b, _c;
    const me = this, { element } = me;
    if (draggable) {
      me.dragEventDetacher = EventHelper.addListener({
        element,
        dragstart: "onWidgetDragStart",
        dragend: "onWidgetDragEnd",
        thisObj: me
      });
      me.dragDetacher = EventHelper.on({
        element,
        mousedown(event) {
          const { target } = event, closestWidget = _Widget.fromElement(target);
          if (!event.target.closest(".b-field-inner") && // Only allow drag to start when the action originates from the widget element itself,
          // or one of its toolbars. https://github.com/bryntum/support/issues/3214
          closestWidget === this || this.strips && Object.values(this.strips).includes(closestWidget)) {
            element.setAttribute("draggable", "true");
          }
        },
        // Only needed for automatic listener removal on destruction of the thisObj
        thisObj: me
      });
    } else {
      (_a2 = me.dragEventDetacher) == null ? void 0 : _a2.call(me);
      (_b = me.dragOverEventDetacher) == null ? void 0 : _b.call(me);
      (_c = me.dragDetacher) == null ? void 0 : _c.call(me);
    }
  }
  onWidgetDragStart(e) {
    var _a2;
    const me = this;
    if (!me.validateDragStartEvent(e)) {
      return;
    }
    const {
      element,
      align,
      constrainTo
    } = me, positioned = me.positioned && DomHelper.getStyleValue(element, "position") !== "fixed", parentElement = positioned ? element.parentElement : me.rootElement, myRect = Rectangle.from(element, positioned ? parentElement : null), dragStartX = e.clientX, dragStartY = e.clientY, scrollingPageElement = document.scrollingElement || document.body, [widgetX, widgetY] = positioned ? DomHelper.getOffsetXY(element, parentElement) : me.getXY(), constrainRect = (_a2 = positioned ? Rectangle.content(parentElement).moveTo(0, 0) : constrainTo && ((constrainTo == null ? void 0 : constrainTo.isRectangle) ? constrainTo : Rectangle.from(constrainTo))) == null ? void 0 : _a2.deflate(align.constrainPadding || 0), dragListeners = {
      element: parentElement,
      dragover: (event) => {
        element.classList.remove("b-centered");
        myRect.moveTo(
          widgetX + event.clientX - dragStartX - (positioned ? 0 : scrollingPageElement.scrollLeft),
          widgetY + event.clientY - dragStartY - (positioned ? 0 : scrollingPageElement.scrollTop)
        );
        if (constrainRect) {
          myRect.constrainTo(constrainRect);
        }
        DomHelper.setTranslateXY(element, myRect.x, myRect.y);
      }
    };
    if (BrowserHelper.isTouchDevice) {
      dragListeners.touchmove = (e13) => e13.preventDefault();
    }
    me.floatRoot.appendChild(me.dragGhost);
    me.setDragImage(e);
    e.dataTransfer.effectAllowed = "none";
    me.dragOverEventDetacher = EventHelper.addListener(dragListeners);
    me.alignTo();
  }
  /**
   * Validates a `dragstart` event with respect to the target element. Dragging is not normally
   * initiated when the target is interactive such as an input field or its label, or a button.
   * This may be overridden to provide custom drag start validation.
   * @param {DragEvent} e The `dragstart` event to validate.
   * @returns {Boolean} Return `true` if the drag is to be allowed.
   * @internal
   */
  validateDragStartEvent(e) {
    var _a2;
    const me = this, { element } = me, actualTarget = DomHelper.elementFromPoint(e.clientX, e.clientY), { handleSelector } = me.draggable;
    if (handleSelector) {
      const blacklist = (_a2 = negationPseudo.exec(handleSelector)) == null ? void 0 : _a2[1];
      if (blacklist) {
        if (actualTarget.closest(`#${element.id} ${blacklist}`)) {
          e.preventDefault();
          return false;
        }
      } else if (!actualTarget.closest(`#${element.id} ${handleSelector}`)) {
        e.preventDefault();
        return false;
      }
    }
    return true;
  }
  setDragImage(e) {
    if (e.dataTransfer.setDragImage) {
      e.dataTransfer.setData("application/node type", "");
      e.dataTransfer.setDragImage(this.dragGhost, -9999, -9999);
    }
  }
  setStyle(name, value) {
    DomHelper.applyStyle(this.element, ObjectHelper.isObject(name) ? name : { [name]: value });
    return this;
  }
  onWidgetDragEnd() {
    this.dragGhost.remove();
    this.dragOverEventDetacher();
    this.element.removeAttribute("draggable");
  }
  changeFloating(value) {
    return Boolean(value);
  }
  changePositioned(value) {
    return Boolean(value);
  }
  updatePositioned(positioned) {
    this.element.classList[positioned ? "add" : "remove"]("b-positioned");
  }
  getXY() {
    return [
      DomHelper.getPageX(this.element),
      DomHelper.getPageY(this.element)
    ];
  }
  /**
   * Moves this Widget to the x,y position. Both arguments can be omitted to just set one value.
   *
   * *For {@link #config-floating} Widgets, this is a position in the browser viewport.*
   * *For {@link #config-positioned} Widgets, this is a position in the element it was rendered into.*
   *
   * @param {Number} [x]
   * @param {Number} [y]
   * @category Float & align
   */
  setXY(x, y) {
    const me = this, { element } = me;
    if (me.floating || me.positioned) {
      if (x != null) {
        me._x = x;
      }
      if (y != null) {
        me._y = y;
      }
      if (DomHelper.getStyleValue(element, "position") === "fixed") {
        const r = element.getBoundingClientRect(), [cx, cy] = DomHelper.getTranslateXY(element), xDelta = x - r.x, yDelta = y - r.y;
        DomHelper.setTranslateXY(element, cx + xDelta, cy + yDelta);
      } else {
        DomHelper.setTranslateXY(element, me._x || 0, me._y || 0);
      }
      if (me.isConstructing) {
        me.centered = false;
      } else {
        element.classList.remove("b-centered");
      }
    }
  }
  /**
   * Moves this Widget to the desired x position.
   *
   * Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element.
   * @property {Number}
   * @category Float & align
   */
  get x() {
    return this.getXY()[0];
  }
  changeX(x) {
    this.setXY(x);
  }
  /**
   * Moves this Widget to the desired y position.
   *
   * Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element.
   * @property {Number}
   * @category Float & align
   */
  get y() {
    return this.getXY()[1];
  }
  changeY(y) {
    this.setXY(null, y);
  }
  /**
   * Get elements offsetWidth or sets its style.width, or specified width if element not created yet.
   * @property {Number}
   * @accepts {Number|String}
   * @category Layout
   */
  get width() {
    const me = this, element = me.element;
    if (me.monitorResize) {
      if (me._width == null) {
        me._width = element.offsetWidth;
      }
      return me._width;
    }
    return element.offsetWidth;
  }
  changeWidth(width) {
    const me = this;
    DomHelper.setLength(me.element, "width", width);
    me._lastWidth = width;
    me._oldWidth = me._width;
    me._width = null;
    me._flex = null;
    me.element.style.flex = "";
  }
  // This method is used by State API to drop cached width early to not rely on ResizeMonitor
  clearWidthCache() {
    this._width = null;
  }
  /**
   * Get/set elements maxWidth. Getter returns max-width from elements style, which is always a string. Setter accepts
   * either a String or a Number (which will have 'px' appended). Note that like {@link #config-width},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get maxWidth() {
    return DomHelper.measureSize(this.element.style.maxWidth, this.element);
  }
  updateMaxWidth(maxWidth) {
    this._lastMaxWidth = maxWidth;
    DomHelper.setLength(this.element, "maxWidth", maxWidth);
  }
  /**
   * Get/set elements minWidth. Getter returns min-width from elements style, which is always a string. Setter accepts
   * either a String or a Number (which will have 'px' appended). Note that like {@link #config-width},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get minWidth() {
    return DomHelper.measureSize(this.element.style.minWidth, this.element);
  }
  updateMinWidth(minWidth) {
    DomHelper.setLength(this.element, "minWidth", minWidth);
  }
  updateFlex(flex) {
    this.getConfig("width");
    if (typeof flex === "number" || !isNaN(flex)) {
      flex = `${flex} ${flex}`;
    }
    this.element.style.flex = flex;
    this.element.style.width = "";
  }
  updateAlignSelf(alignSelf) {
    this.element.style.alignSelf = alignSelf;
  }
  updateMargin(margin) {
    this.element.style.margin = this.parseTRBL(margin).join(" ");
  }
  updateTextAlign(align, oldAlign) {
    oldAlign && this.element.classList.remove(`b-text-align-${oldAlign}`);
    this.element.classList.add(`b-text-align-${align}`);
  }
  updatePlaceholder(placeholder) {
    if (this.input) {
      if (placeholder == null) {
        this.input.removeAttribute("placeholder");
      } else {
        this.input.placeholder = placeholder;
      }
    }
  }
  /**
   * Get element's offsetHeight or sets its style.height, or specified height if element no created yet.
   * @property {Number}
   * @accepts {Number|String}
   * @category Layout
   */
  get height() {
    const me = this, element = me.element;
    if (me.monitorResize) {
      if (me._height == null) {
        me._height = element.offsetHeight;
      }
      return me._height;
    }
    return element.offsetHeight;
  }
  changeHeight(height) {
    DomHelper.setLength(this.element, "height", height);
    this._lastHeight = height;
    this._height = null;
  }
  /**
   * Get/set element's maxHeight. Getter returns max-height from elements style, which is always a string. Setter
   * accepts either a String or a Number (which will have 'px' appended). Note that like {@link #config-height},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get maxHeight() {
    return DomHelper.measureSize(this.maxHeightElement.style.maxHeight, this.element);
  }
  updateMaxHeight(maxHeight) {
    this._lastMaxHeight = maxHeight;
    DomHelper.setLength(this.maxHeightElement, "maxHeight", maxHeight);
  }
  /**
   * Get/set element's minHeight. Getter returns min-height from elements style, which is always a string. Setter
   * accepts either a String or a Number (which will have 'px' appended). Note that like {@link #config-height},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get minHeight() {
    return DomHelper.measureSize(this.element.style.minHeight, this.element);
  }
  updateMinHeight(minHeight) {
    DomHelper.setLength(this.element, "minHeight", minHeight);
  }
  updateDisabled(disabled = false) {
    const {
      element,
      focusElement,
      ariaElement
    } = this;
    this.trigger("beforeUpdateDisabled", { disabled });
    if (disabled) {
      this.revertFocus();
      if (this._disabled !== disabled) {
        return;
      }
    }
    if (element) {
      element.classList[disabled ? "add" : "remove"]("b-disabled");
      if (focusElement) {
        focusElement.disabled = disabled;
      }
      if (ariaElement) {
        ariaElement.setAttribute("aria-disabled", disabled);
      }
    }
    this.onDisabled(disabled);
  }
  /**
   * Called when disabled state is changed.
   * Override in subclass that needs special handling when being disabled.
   * @param {Boolean} disabled current state
   * @private
   */
  onDisabled(disabled) {
  }
  /**
   * Disable the widget
   */
  disable() {
    this.disabled = true;
  }
  /**
   * Enable the widget
   */
  enable() {
    this.disabled = false;
  }
  /**
   * Requests fullscreen display for this widget
   * @returns {Promise} A Promise which is resolved with a value of undefined when the transition to full screen is complete.
   */
  requestFullscreen() {
    const me = this, result = Fullscreen.request(me.floating ? me.floatRoot : me.element);
    Fullscreen.onFullscreenChange(me.onFullscreenChange);
    me.element.classList.add("b-fullscreen");
    return result;
  }
  /**
   * Exits fullscreen mode
   * @returns {Promise} A Promise which is resolved once the user agent has finished exiting full-screen mode
   */
  exitFullscreen() {
    return Fullscreen.exit();
  }
  onFullscreenChange() {
    if (!Fullscreen.isFullscreen) {
      this.onExitFullscreen();
    }
  }
  onExitFullscreen() {
    Fullscreen.unFullscreenChange(this.onFullscreenChange);
    this.element.classList.remove("b-fullscreen");
  }
  /**
   * Get/set a tooltip on the widget. Accepts a string or tooltip config (specify true (or 'true') to use placeholder
   * as tooltip). When using a string it will configure the tooltip with `textContent: true` which enforces a default
   * max width.
   *
   * By default, this uses a singleton Tooltip instance which may be accessed from the `{@link Core.widget.Widget}`
   * class under the name `Widget.tooltip`. This is configured according to the config object on pointer over.
   *
   * To request a separate instance be created just for this widget, add `newInstance : true` to the configuration.
   *
   * @property {String|TooltipConfig}
   * @category Misc
   */
  get tooltip() {
    var _a2;
    const me = this;
    if (me._tooltip) {
      return me._tooltip;
    } else {
      const tooltip = (_a2 = _Widget.Tooltip) == null ? void 0 : _a2.getSharedTooltip(me.rootElement, me.eventRoot);
      if (tooltip && tooltip.activeTarget === me._element && tooltip.isVisible) {
        return tooltip;
      }
    }
  }
  //noinspection JSAnnotator
  changeTooltip(tooltip, oldTooltip) {
    var _a2;
    const me = this, { element } = me;
    if (tooltip) {
      if (!(me.preventTooltipOnTouch && BrowserHelper.isTouchDevice)) {
        if (!tooltip.isTooltip && tooltip.constructor.name !== "Object") {
          tooltip = {
            html: typeof tooltip === "string" ? tooltip : me.placeholder,
            textContent: true
          };
        }
        if (!me.configureAriaDescription) {
          me.ariaDescription = ((_a2 = tooltip.html) == null ? void 0 : _a2.match(localizeRE)) ? tooltip.html.replace(localizeRE, localizeTooltip) : tooltip.html;
        }
        if ((oldTooltip == null ? void 0 : oldTooltip.isTooltip) || tooltip.newInstance) {
          tooltip.type = "tooltip";
          if (!tooltip.forElement)
            tooltip.forElement = element;
          if (!("showOnHover" in tooltip) && !tooltip.forSelector)
            tooltip.showOnHover = true;
          if (!("autoClose" in tooltip))
            tooltip.autoClose = true;
          tooltip = _Widget.reconfigure(oldTooltip, tooltip, me);
          me.detachListeners("tooltipValueListener");
          if (!me.configureAriaDescription) {
            tooltip.ion({
              name: "tooltipValueListener",
              innerHtmlUpdate: "onTooltipValueChange",
              thisObj: me
            });
          }
        } else {
          element.dataset.btip = true;
          me.tipConfig = tooltip;
          return;
        }
      }
    } else {
      if (oldTooltip) {
        if (tooltip == null && oldTooltip.isTooltip) {
          oldTooltip.destroy();
        } else {
          oldTooltip.html = null;
          return;
        }
      } else {
        delete element.dataset.btip;
      }
    }
    return tooltip;
  }
  /**
   * The shared {@link Core.widget.Tooltip} instance which handles
   * {@link Core.widget.Widget#config-tooltip tooltips} which are __not__ configured
   * with `newInstance : true`.
   * @member {Core.widget.Tooltip} tooltip
   * @readonly
   * @static
   */
  // This property is defined in the Tooltip module but must be documented here.
  // If our tooltip is dynamic, then we must update our aria-describedBy whenever it changes.
  onTooltipValueChange({ value, source }) {
    this.ariaDescription = typeof value == "string" ? value : source.contentElement.innerText;
  }
  get tooltipText() {
    const tooltip = this._tooltip;
    if (tooltip) {
      return tooltip.isTooltip ? tooltip.contentElement.innerText : typeof tooltip === "string" ? tooltip : tooltip.html;
    } else if (this.tipConfig) {
      return this.tipConfig.html;
    }
  }
  /**
   * Determines visibility by checking if the Widget is hidden, or any ancestor is hidden and that it has an
   * element which is visible in the DOM
   * @property {Boolean}
   * @category Visibility
   * @readonly
   */
  get isVisible() {
    const me = this, { element } = me;
    let owner;
    return Boolean(
      element && !me._hidden && !me.isDestroying && element.isConnected && (!me.requireSize || hasLayout(element)) && (!(owner = me.containingWidget) || owner.isVisible)
    );
  }
  // If the callback is a function (instead of the name of the function),
  // the id must be converted into string format to be used as key for `toCallWhenVisible` map element
  whenVisible(callback, thisObj = this, args, id = callback.toString()) {
    var _a2;
    const me = this;
    if (me.isVisible && me.isPainted) {
      (_a2 = me.toCallWhenVisible) == null ? void 0 : _a2.delete(id);
      me.callback(callback, thisObj, args);
    } else {
      (me.toCallWhenVisible || (me.toCallWhenVisible = /* @__PURE__ */ new Map())).set(id, { callback, thisObj, args });
    }
  }
  /**
   * Focuses this widget if it has a focusable element.
   */
  focus() {
    if (this.isFocusable) {
      DomHelper.focusWithoutScrolling(this.focusElement);
    }
  }
  /**
   * Get this widget's primary focus holding element if this widget is itself focusable, or contains focusable widgets.
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   * @advanced
   */
  get focusElement() {
  }
  get isFocusable() {
    const focusElement = !this.isDestroying && this.isVisible && !this.disabled && this.focusElement;
    return focusElement && (focusElement === document.body || focusElement.offsetParent);
  }
  /**
   * Shows this widget
   * @param {Object} [options] modifications to the show operation
   * @param {AlignSpec} [options.align] An alignment specification as passed to {@link #function-alignTo}
   * @param {Boolean} [options.animate=true] Specify as `false` to omit the {@link #config-showAnimation}
   * @category Visibility
   * @returns {Promise} A promise which is resolved when the widget is shown
   */
  async show({ align, animate = true } = {}) {
    const me = this, {
      element,
      floating
    } = me, { style } = element, showAnimation = animate && me.showAnimation;
    let styleProp, animProps, trigger = !me.isVisible;
    if (trigger) {
      trigger = me.trigger("beforeShow");
      if (ObjectHelper.isPromise(trigger)) {
        trigger = await trigger;
      }
    }
    if (trigger !== false && (!me.internalBeforeShow || me.internalBeforeShow() !== false)) {
      return new Promise((resolve) => {
        me.cancelHideShowAnimation();
        me.updateCentered(me._centered);
        if (floating) {
          const floatRoot = me.floatRoot;
          if (!floatRoot.contains(element)) {
            if (me.rendered) {
              floatRoot.appendChild(me.element);
            } else {
              me.render(floatRoot, false);
            }
          }
          if (style.transform.includes("scale")) {
            me.scale = null;
            style.transform = style.transformOrigin = "";
          }
          const scaledAncestor = me.closest(isScaled);
          if (scaledAncestor) {
            const { scale } = scaledAncestor;
            me.scale = scale;
            style.transform = `scale(${scale})`;
            style.transformOrigin = `0 0`;
          }
        }
        me._hidden = false;
        element.classList.remove("b-hidden");
        if (floating && !isVisible(element)) {
          me.hide(false);
          resolve();
        }
        me.onConfigChange({
          name: "hidden",
          value: false,
          was: true,
          config: me.$meta.configs.hidden
        });
        if (showAnimation) {
          styleProp = Object.keys(showAnimation)[0];
          animProps = showAnimation[styleProp];
          const currentAnimation = me.currentAnimation = {
            showing: true,
            styleProp,
            resolve
          };
          me.isAnimating = true;
          style.transition = "none";
          style[styleProp] = animProps.from;
          DomHelper.getStyleValue(element, styleProp);
          me.currentAnimation.detacher = EventHelper.onTransitionEnd({
            element,
            property: styleProp,
            duration: parseDuration(animProps.duration) + 20,
            handler: () => me.afterHideShowAnimate(currentAnimation),
            thisObj: me
          });
          style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
          style[styleProp] = animProps.to;
        }
        me.afterShow(align, !showAnimation ? resolve : null);
      });
    } else {
      return Promise.resolve();
    }
  }
  /**
   * Show aligned to another target element or {@link Core.widget.Widget} or {@link Core.helper.util.Rectangle}
   * @param {AlignSpec|HTMLElement|Number[]} align Alignment specification, or the element to align to using the
   * configured {@link #config-align}.
   * @category Float & align
   * @returns {Promise} A promise which is resolved when the widget is shown
   */
  async showBy(align, yCoord, options) {
    const me = this, isArray3 = Array.isArray(align);
    if (isArray3 || typeof align === "number") {
      const xy = isArray3 ? align : [align, yCoord];
      align = Object.assign({
        target: new Point(xy[0] + 1, xy[1] + 1),
        // Override any matchSize that we might have in our align config.
        // Otherwise we are going to be 1px wide/high
        matchSize: false,
        align: "t0-b0"
      }, isArray3 ? yCoord : options);
    }
    me.requireSize = true;
    if (me.isVisible) {
      DomHelper.addTemporaryClass(me.element, "b-realigning", 300, me);
      me.alignTo(align);
    } else {
      return me.show({ align });
    }
  }
  /**
   * Show this widget anchored to a coordinate
   * @param {Number|Number[]} x The x position (or an array with [x,y] values) to show by
   * @param {Number} [y] The y position to show by
   * @param {AlignSpec} [options] See {@link #function-showBy} for reference
   * @category Float & align
   * @deprecated Since 5.0.2. Use {@link #function-showBy} method with the same signature.
   * @returns {Promise} A promise which is resolved when the widget is shown
   */
  async showByPoint() {
    VersionHelper.deprecate("Core", "6.0.0", "Widget.showByPoint() replaced by Widget.showBy() with the same signature");
    return this.showBy(...arguments);
  }
  afterShow(align, resolveFn) {
    var _a2, _b;
    const me = this;
    me.trigger("show");
    me._configuredAnchorState = me.anchor;
    (_b = (_a2 = me.owner) == null ? void 0 : _a2.onChildShow) == null ? void 0 : _b.call(_a2, me);
    me.triggerPaint();
    if (me.floating || me.positioned) {
      if (align) {
        me.alignTo(align);
      } else if (me.centered) {
        me.alignTo({
          target: me.constrainTo,
          align: "c-c"
        });
      } else if (me.forElement) {
        me.alignTo(me.forElement);
      }
    }
    resolveFn == null ? void 0 : resolveFn();
  }
  onChildHide(hidden) {
    if (hidden.floating) {
      this.ariaElement.removeAttribute("aria-owns");
    }
  }
  onChildShow(shown) {
    if (shown.floating) {
      this.ariaHasPopup = shown.role;
      this.ariaElement.setAttribute("aria-owns", shown.id);
    }
  }
  triggerPaint() {
    const me = this, { element, toCallWhenVisible } = me, firstPaint = !me.isPainted;
    if (me.isVisible) {
      if (firstPaint) {
        me.getConfig("scrollable");
        if (me.scaleToFitWidth && !me.monitorResize) {
          me.onParentElementResize = me.onParentElementResize.bind(me);
          ResizeMonitor.addResizeListener(element.parentElement, me.onParentElementResize);
          me.updateScale();
        }
        if (!me.hideBryntumDomMessage && (me.isTaskBoardBase || me.isGridBase || me.isCalendar)) {
          element.insertBefore(new Comment("POWERED BY BRYNTUM (https://bryntum.com)"), element.firstChild);
        }
        if (me.onConnectedCallback && globalThis.ResizeObserver) {
          me.connectedObserver = new ResizeObserver(() => {
            if (me.isElementConnected && !element.isConnected) {
              me.onConnectedCallback(false);
              me.isElementConnected = false;
            } else if (!me.isElementConnected && element.isConnected) {
              me.onConnectedCallback(true, me.isElementConnected == null);
              me.isElementConnected = true;
            }
          });
          me.connectedObserver.observe(element);
        }
      }
      me.eachWidget(widgetTriggerPaint, false);
      if (firstPaint) {
        me.getConfig("tooltip");
        if (!_Widget.Ripple && _Widget.RippleClass) {
          _Widget.Ripple = new _Widget.RippleClass({
            rootElement: me.rootElement
          });
        }
        if (globalThis.DocsBrowser && me.floating && me.closest((w) => {
          var _a2;
          return (_a2 = w.element) == null ? void 0 : _a2.closest(".fiddlePanelResult,.b-owned-by-fiddle");
        })) {
          element.classList.add("b-owned-by-fiddle");
        }
      }
      me.isPainted = true;
      firstPaint && me.triggerConfigs("paint");
      me.onInternalPaint({ firstPaint });
      me.trigger("paint", { firstPaint });
      if (toCallWhenVisible == null ? void 0 : toCallWhenVisible.size) {
        for (const { callback, thisObj, args } of toCallWhenVisible.values()) {
          me.callback(callback, thisObj, args);
        }
        toCallWhenVisible.clear();
      }
      if (firstPaint) {
        if (me.monitorResize && !me.scaleToFitWidth) {
          ResizeMonitor.onElementResize([{ target: element }]);
        }
      }
    }
  }
  onInternalPaint() {
  }
  cancelHideShowAnimation() {
    const me = this, { currentAnimation, element } = me;
    if (currentAnimation) {
      me.isAnimating = false;
      if (element.classList.contains("b-hiding")) {
        element.classList.remove("b-hiding");
        me._hidden = false;
      }
      currentAnimation.detacher();
      currentAnimation.resolve();
      element.style.transition = element.style[currentAnimation.styleProp] = "";
      me.currentAnimation = null;
      me.trigger(`${currentAnimation.showing ? "show" : "hide"}AnimationEnd`);
    }
  }
  afterHideShowAnimate(currentAnimation) {
    const me = this;
    if (currentAnimation === me.currentAnimation) {
      me.element.classList.remove("b-hiding");
      me.cancelHideShowAnimation();
      if (me._hidden) {
        me.afterHideAnimation();
      }
    }
  }
  /**
   * Temporarily changes the {@link #property-isVisible} to yield `false` regardless of this
   * Widget's true visibility state. This can be useful for suspending operations which rely on
   * the {@link #property-isVisible} property.
   *
   * This increments a counter which {@link #function-resumeVisibility} decrements.
   * @internal
   */
  suspendVisibility() {
    this._visibilitySuspended = (this._visibilitySuspended || 0) + 1;
    Object.defineProperty(this, "isVisible", returnFalseProp);
  }
  /**
   * Resumes visibility. If the suspension counter is returned to zero by this, then the
   * {@link #event-paint} event is triggered, causing a cascade of `paint` events on all
   * descendants. This can be prevented by passing `false` as the only parameter.
   * @param {Boolean} [triggerPaint=true] Trigger the {@link #event-paint} event.
   * @internal
   */
  resumeVisibility(triggerPaint = true) {
    if (!--this._visibilitySuspended) {
      delete this.isVisible;
      if (triggerPaint) {
        this.triggerPaint();
      }
    }
  }
  /**
   * Hide widget
   * @param {Boolean} animate Pass `true` (default) to animate the hide action
   * @category Visibility
   * @returns {Promise} A promise which is resolved when the widget has been hidden
   */
  hide(animate = true) {
    return new Promise((resolve) => {
      const me = this, {
        element,
        lastAlignSpec
      } = me, { style } = element, hideAnimation = animate && me.hideAnimation;
      me.clearTimeout(me.scrollListenerTimeout);
      me.clearTimeout(me.resizeListenerTimeout);
      if (!me._hidden && me.trigger("beforeHide", { animate }) !== false) {
        me._hidden = true;
        if (lastAlignSpec) {
          lastAlignSpec.targetOutOfView = null;
          if (lastAlignSpec.monitorIntersection) {
            me.intersectionObserver.takeRecords();
            me.intersectionObserver.unobserve(lastAlignSpec.target);
          }
        }
        me.onConfigChange({
          name: "hidden",
          value: true,
          was: false,
          config: me.$meta.configs.hidden
        });
        if (!element) {
          resolve();
          return;
        }
        if (element.contains(DomHelper.getActiveElement(element))) {
          me.revertFocus(true);
        }
        if (me.isDestroyed) {
          resolve();
          return;
        }
        me.cancelHideShowAnimation();
        if (hideAnimation) {
          const styleProp = Object.keys(hideAnimation)[0], animProps = hideAnimation[styleProp];
          if (Number(getComputedStyle(me.element)[styleProp]) !== animProps.to) {
            const currentAnimation = me.currentAnimation = {
              hiding: true,
              styleProp,
              resolve
            };
            element.classList.add("b-hiding");
            me.isAnimating = true;
            me.currentAnimation.detacher = EventHelper.onTransitionEnd({
              element,
              property: styleProp,
              duration: parseDuration(animProps.duration) + 20,
              handler: () => me.afterHideShowAnimate(currentAnimation),
              thisObj: me
            });
            style[styleProp] = animProps.from;
            DomHelper.getStyleValue(element, styleProp);
            style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
            style[styleProp] = animProps.to;
          } else {
            element.classList.add("b-hidden");
          }
        } else {
          element.classList.add("b-hidden");
        }
        me.afterHide(!hideAnimation && resolve, hideAnimation);
      }
    });
  }
  doHideOrRealign({ target, isTrusted }) {
    const me = this, {
      lastAlignSpec,
      element
    } = me, anchoredTo = lastAlignSpec == null ? void 0 : lastAlignSpec.anchoredTo, lastTarget = lastAlignSpec == null ? void 0 : lastAlignSpec.target, position = lastAlignSpec == null ? void 0 : lastAlignSpec.position, activeEl = DomHelper.getActiveElement(me);
    if (
      // If it's a synthesized scroll event (such as from our ResizeMonitor polyfill), ignore it.
      !isTrusted || // Realign happens on frame, might have been removed from DOM so check whether it has layout
      !hasLayout(element) || // event.target might be missing with LockerService enabled. we still need to call the logic as it does not
      // depend much on the scroll target
      target && // If the scroll is inside our element, ignore it.
      (element.contains(target) || target.nodeType === Element.ELEMENT_NODE && me.owns(target) || // If we're scrolling because a focused textual input field which we contain is being shifted into view,
      // we must not reposition - we'll just move with the document content.
      target.nodeType === Element.DOCUMENT_NODE && element.contains(activeEl) && textInputTypes[activeEl] && globalThis.innerHeight < document.body.offsetHeight)
    ) {
      return;
    }
    if (lastAlignSpec.aligningToElement) {
      const newTarget = DomHelper.isInView(lastTarget, false, me);
      if (newTarget && newTarget.equals(lastAlignSpec.targetRect)) {
        return;
      }
    }
    const xy = me.scrollAction === "hide" && me.getXY();
    me.realign();
    if (!me.isDestroyed && isVisible(element) && me.scrollAction === "hide") {
      const [newX, newY] = me.getXY(), moved = newX !== xy[0] || newY !== xy[1];
      if ((lastAlignSpec == null ? void 0 : lastAlignSpec.aligningToEvent) || (moved || (lastTarget == null ? void 0 : lastTarget.$$name) === "Point" || position) && (!anchoredTo || !hasLayout(anchoredTo) || target && DomHelper.isDescendant(target, anchoredTo))) {
        me.hide();
      }
    }
  }
  afterHide(resolveFn = null, hideAnimation = this.hideAnimation) {
    var _a2, _b;
    const me = this;
    me._anchor = me._configuredAnchorState;
    me.removeTransientListeners();
    if (!hideAnimation) {
      me.afterHideAnimation();
    }
    me.trigger("hide");
    (_b = (_a2 = me.owner) == null ? void 0 : _a2.onChildHide) == null ? void 0 : _b.call(_a2, me);
    resolveFn && resolveFn();
  }
  removeTransientListeners() {
    var _a2, _b, _c;
    const me = this, {
      targetObserver,
      lastAlignSpec
    } = me;
    me.clearTimeout(me.resizeListenerTimeout);
    me.clearTimeout(me.scrollListenerTimeout);
    if (targetObserver) {
      targetObserver.disconnect();
      delete me.targetObserver;
    }
    me.documentScrollListener = (_a2 = me.documentScrollListener) == null ? void 0 : _a2.call(me);
    me.targetRootScrollListener = (_b = me.targetRootScrollListener) == null ? void 0 : _b.call(me);
    if (me.targetResizeListener) {
      ResizeMonitor.removeResizeListener(lastAlignSpec.target, me.onTargetResize);
      me.targetResizeListener = false;
    }
    if (me.constrainListeners) {
      const el = ((_c = lastAlignSpec.constrainTo) == null ? void 0 : _c.isRectangle) ? globalThis : lastAlignSpec.constrainTo;
      ResizeMonitor.removeResizeListener(el || globalThis, me.onAlignConstraintChange);
      me.constrainListeners = false;
    }
  }
  afterHideAnimation() {
    const me = this, { element } = me;
    if (me.floating && me.floatRoot.contains(element)) {
      element.remove();
    } else {
      element.classList.add("b-hidden");
    }
    if (me.defaultAnchorBackgroundColor) {
      me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
    }
  }
  changeHidden(value) {
    const me = this;
    let ret;
    if (me.isConfiguring) {
      ret = Boolean(value);
      me.element.classList[value ? "add" : "remove"]("b-hidden");
    } else {
      me.trigger("beforeChangeHidden", { hidden: value });
      if (value) {
        me.hide();
      } else {
        me.show();
      }
    }
    return ret;
  }
  /**
   * Get id assigned by user (not generated id)
   * @returns {String}
   * @readonly
   * @private
   * @category Misc
   */
  get assignedId() {
    return this.hasGeneratedId ? null : this.id;
  }
  /**
   * Get this Widget's parent when used as a child in a {@link Core.widget.Container},
   * @member {Core.widget.Widget} parent
   * @readonly
   * @category Widget hierarchy
   */
  /**
   * Get the owning Widget of this Widget. If this Widget is directly contained, then the containing
   * Widget is returned. If this Widget is floating, the configured `owner` property is returned.
   * If there is a `forElement`, that element's encapsulating Widget is returned.
   * @property {Core.widget.Widget}
   * @readonly
   * @category Widget hierarchy
   */
  get owner() {
    return this.parent || this._owner || this.containingWidget;
  }
  get containingWidget() {
    var _a2, _b;
    let result = this.parent;
    if (!result) {
      const owningEl = ((_a2 = this.forElement) == null ? void 0 : _a2.nodeType) === Element.ELEMENT_NODE ? this.forElement : (_b = this.element) == null ? void 0 : _b.parentNode;
      result = (owningEl == null ? void 0 : owningEl.closest(".b-widget")) && _Widget.fromElement(owningEl);
    }
    return result;
  }
  /**
   * Get this Widget's previous sibling in the parent {@link Core.widget.Container Container}, or, if not
   * in a Container, the previous sibling widget in the same _parentElement_.
   * @property {Core.widget.Widget}
   * @readonly
   * @category Widget hierarchy
   */
  get previousSibling() {
    return this.getSibling(-1);
  }
  /**
   * Get this Widget's next sibling in the parent {@link Core.widget.Container Container}, or, if not
   * in a Container, the next sibling widget in the same _parentElement_.
   * @property {Core.widget.Widget}
   * @readonly
   * @category Widget hierarchy
   */
  get nextSibling() {
    return this.getSibling(1);
  }
  getSibling(increment) {
    const me = this, { parent } = me, siblings = parent ? parent.childItems : Array.from(me.element.parentElement.querySelectorAll(".b-widget"));
    return parent ? siblings[siblings.indexOf(me) + increment] : _Widget.fromElement(siblings[siblings.indexOf(me.element) + increment]);
  }
  /**
   * Looks up the {@link #property-owner} axis to find an ancestor which matches the passed selector.
   * The selector may be a widget type identifier, such as `'grid'`, or a function which will return
   * `true` when passed the desired ancestor.
   * @param {String|Function} [selector] A Type identifier or selection function. If not provided, this method returns
   * the {@link #property-owner} of this widget
   * @param {Boolean} [deep] When using a string identifier, pass `true` if all superclasses should be included, i.e.,
   * if a `Grid` should match `'widget'`.
   * @param {Number|String|Core.widget.Widget} [limit] how many steps to step up before aborting the search, or a
   * selector to stop at or the topmost ancestor to consider.
   * @returns {Core.widget.Widget|*}
   * @category Widget hierarchy
   */
  up(selector, deep, limit) {
    var _a2;
    const { owner } = this;
    return selector ? (_a2 = owner == null ? void 0 : owner.closest) == null ? void 0 : _a2.call(owner, selector, deep, limit) : owner;
  }
  /**
   * Starts with this Widget, then Looks up the {@link #property-owner} axis to find an ancestor which matches the
   * passed selector. The selector may be a widget type identifier, such as `'grid'`, or a function which will return
   * `true` when passed the desired ancestor.
   * @param {String|Function} selector A Type identifier or selection function.
   * @param {Boolean} [deep] When using a string identifier, pass `true` if all superclasses should be included, i.e.,
   * if a `Grid` should match `'widget'`.
   * @param {Number|String|Core.widget.Widget} [limit] how many steps to step up before aborting the search, or a
   * selector to stop at or the topmost ancestor to consider.
   * @category Widget hierarchy
   */
  closest(selector, deep, limit) {
    const limitType = typeof limit, numericLimit = limitType === "number", selectorLimit = limitType === "string";
    for (let result = this, steps = 1; result; result = result.owner, steps++) {
      if (_Widget.widgetMatches(result, selector, deep)) {
        return result;
      }
      if (numericLimit && steps >= limit) {
        return;
      } else if (selectorLimit && _Widget.widgetMatches(result, limit, deep)) {
        return;
      } else if (result === limit) {
        return;
      }
    }
  }
  /**
   * Returns `true` if this Widget owns the passed Element, Event or Widget. This is based on the widget hierarchy,
   * not DOM containment. So an element in a `Combo`'s dropdown list will be owned by the `Combo`.
   * @param {HTMLElement|Event|Core.widget.Widget} target The element event or Widget to test for being
   * within the ownership tree of this Widget.
   * @category Widget hierarchy
   */
  owns(target) {
    if (target) {
      if ("eventPhase" in target) {
        target = target.target;
      }
      if (target.nodeType === Element.ELEMENT_NODE) {
        if (this.element.contains(target)) {
          return true;
        }
        target = _Widget.fromElement(target);
      }
      while (target) {
        if (target === this) {
          return true;
        }
        target = target.owner;
      }
    }
    return false;
  }
  /**
   * Iterate over all ancestors of this widget.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   * @param {Function} fn Function to execute for all ancestors. Terminate iteration by returning `false`.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   * @category Widget hierarchy
   */
  eachAncestor(fn) {
    let ancestor = this.owner;
    while (ancestor) {
      if (fn(ancestor) === false) {
        return false;
      }
      ancestor = ancestor.owner;
    }
    return true;
  }
  changeMaximizeOnMobile(maximizeOnMobile) {
    const me = this;
    if (me.floating && BrowserHelper.isMobile) {
      const { initialConfig } = me;
      if (maximizeOnMobile) {
        me.centered = me.modal = false;
        me.maximized = true;
      } else {
        me.centered = initialConfig.modal;
        me.modal = initialConfig.centered;
        me.maximized = initialConfig.maximized;
      }
    }
  }
  changeMonitorResize(monitorResize, oldMonitorResize) {
    const result = this.scaleToFitWidth ? false : Boolean(monitorResize);
    if (result !== Boolean(oldMonitorResize)) {
      return result;
    }
  }
  updateMonitorResize(monitorResize) {
    const me = this;
    if (!hasOwn4(me, "onElementResize")) {
      me.onElementResize = me.onElementResize.bind(me);
    }
    ResizeMonitor[monitorResize ? "addResizeListener" : "removeResizeListener"](me.element, me.onElementResize);
  }
  changeReadOnly(readOnly) {
    readOnly = Boolean(readOnly);
    if (Boolean(this._readOnly) !== readOnly) {
      return readOnly;
    }
  }
  updateReadOnly(readOnly) {
    var _a2;
    (_a2 = this.element) == null ? void 0 : _a2.classList[readOnly ? "add" : "remove"]("b-readonly");
    if (!this.isConfiguring) {
      this.eachWidget((widget) => {
        if (widget.ignoreParentReadOnly) {
          return;
        }
        if (!("_originalReadOnly" in widget)) {
          widget._originalReadOnly = widget.config.readOnly || false;
        }
        widget.readOnly = readOnly || widget._originalReadOnly;
      }, false);
      this.trigger("readOnly", { readOnly });
    }
  }
  /**
   * Iterate over all widgets owned by this widget and any descendants.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   * @param {Function} fn A function to execute upon each descendant widget.
   * Iteration terminates if this function returns `false`.
   * @param {Core.widget.Widget} fn.widget The current descendant widget.
   * @param {Object} fn.control An object containing recursion control options.
   * @param {Boolean} fn.control.down A copy of the `deep` parameter. This can be adjusted by `fn` to decide which
   * widgets should be recursed. This value will always be the value of `deep` on entry and the value of `control.down`
   * upon return determines the recursion into the current widget.
   * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   * @category Widget hierarchy
   */
  eachWidget(fn, deep = true) {
    const widgets = this.childItems, length = (widgets == null ? void 0 : widgets.length) || 0, control = {};
    for (let i = 0; i < length; i++) {
      const widget = widgets[i];
      control.down = deep;
      if (fn(widget, control) === false) {
        return false;
      }
      if (control.down && widget.eachWidget) {
        if (widget.eachWidget(fn, deep) === false) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Returns an array of all descendant widgets which the passed
   * filter function returns `true` for.
   * @param {Function} filter A function which, when passed a widget,
   * returns `true` to include the widget in the results.
   * @returns {Core.widget.Widget[]} All matching descendant widgets.
   * @category Widget hierarchy
   */
  queryAll(filter) {
    const result = [];
    this.eachWidget((w) => {
      if (filter(w)) {
        result.push(w);
      }
    });
    return result;
  }
  /**
   * Returns the first descendant widgets which the passed
   * filter function returns `true` for.
   * @param {Function} filter A function which, when passed a widget,
   * returns `true` to return the widget as the sole result.
   * @returns {Core.widget.Widget} The first matching descendant widget.
   * @category Widget hierarchy
   */
  query(filter) {
    let result = null;
    this.eachWidget((w) => {
      if (filter(w)) {
        result = w;
        return false;
      }
    });
    return result;
  }
  /**
   * Get a widget by ref, starts on self and traverses up the owner hierarchy checking `widgetMap` at each level.
   * Not checking the top level widgetMap right away to have some acceptance for duplicate refs.
   * @param {String} ref ref to find
   * @returns {Core.widget.Widget}
   * @internal
   * @category Widget hierarchy
   */
  getWidgetByRef(ref) {
    var _a2, _b;
    if (ref instanceof _Widget) {
      return ref;
    }
    return ((_a2 = this == null ? void 0 : this.widgetMap) == null ? void 0 : _a2[ref]) || ((_b = this == null ? void 0 : this.owner) == null ? void 0 : _b.getWidgetByRef(ref));
  }
  onFocusIn(e) {
    const me = this, { element } = me;
    me.containsFocus = true;
    me.focusInEvent = e;
    if (me.floating || me.positioned) {
      me.toFront();
    }
    element.classList.add("b-contains-focus");
    me.updateAriaLabel(me.localizeProperty("ariaLabel"));
    me.updateAriaDescription(me.localizeProperty("ariaDescription"));
    if (element.contains(e._target) && me.onInternalKeyDown && !me.keyDownListenerRemover) {
      me.keyDownListenerRemover = EventHelper.on({
        element,
        keydown: "onInternalKeyDown",
        thisObj: me
      });
    }
    me.trigger("focusin", e);
  }
  onFocusOut(e) {
    const me = this;
    if (me.keyDownListenerRemover) {
      me.keyDownListenerRemover();
      me.keyDownListenerRemover = null;
    }
    if (!me.isDestroyed) {
      if (!e.relatedTarget) {
        me.revertFocus(!me.isVisible);
      }
      me.containsFocus = false;
      me.element.classList.remove("b-contains-focus");
      me.updateAriaLabel(me.localizeProperty("ariaLabel"));
      me.updateAriaDescription(me.localizeProperty("ariaDescription"));
      me.trigger("focusout", e);
    }
  }
  /**
   * Returns a function that will set the focus (`document.activeElement`) to the most consistent element possible
   * based on the focus state at the time this method was called. Derived classes can implement `captureFocusItem()`
   * to refine this process to include logical items (e.g., a grid cell) that would be more stable than DOM element
   * references.
   *
   * If this widget does not contain the focus, the returned function will do nothing.
   * @returns {Function}
   * @internal
   */
  captureFocus() {
    const me = this, activeElementWas = DomHelper.getActiveElement(me), restore = me.contains(activeElementWas) && me.captureFocusItem(activeElementWas);
    return (scrollIntoView, force) => {
      if (restore && !me.isDestroying) {
        const activeElementNow = DomHelper.getActiveElement(me);
        if (activeElementNow !== activeElementWas || force) {
          restore(scrollIntoView);
        }
      }
    };
  }
  /**
   * This method is called by `captureFocus()` when this widget contains the focus and it returns a function that
   * restores the focus to the correct internal element. The returned function is only called if the current
   * `document.activeElement` is different from the passed `activeElement`.
   *
   * This method can be replaced by derived classes to capture stable identifiers for the currently focused, logical
   * item (for example, a cell of a grid).
   *
   * @param {HTMLElement} activeElement The current `document.activeElement`.
   * @returns {Function} Returns a function that accepts a boolean argument. Defaults to `true`, `false` attempts to
   * focus without scrolling.
   * @internal
   */
  captureFocusItem(activeElement) {
    return (scrollIntoView = true) => {
      if (this.contains(activeElement)) {
        scrollIntoView ? activeElement.focus() : DomHelper.focusWithoutScrolling(activeElement);
      }
    };
  }
  /**
   * Returns `true` if this widget is or contains the specified element or widget.
   * @param {HTMLElement|Core.widget.Widget} elementOrWidget The element or widget
   * @param {Boolean} [strict] Pass `true` to test for strict containment (if `elementOrWidget` is this widget, the
   * return value will be `false`).
   * @returns {Boolean}
   * @category Widget hierarchy
   */
  contains(elementOrWidget, strict) {
    const { element } = this;
    if (elementOrWidget && element) {
      if (elementOrWidget.isWidget) {
        elementOrWidget = elementOrWidget.element;
      }
      return element.contains(elementOrWidget) && (!strict || element !== elementOrWidget);
    }
  }
  /**
   * If this Widget contains focus, focus is reverted to the source from which it entered if possible,
   * or to a close relative if not.
   * @param {Boolean} [force] Pass as `true` to move focus to the previously focused item, or the
   * closest possible relative even if this widget does not contain focus.
   * @advanced
   */
  revertFocus(force) {
    var _a2;
    const me = this, activeElement = DomHelper.getActiveElement(me);
    let target = (_a2 = me.focusInEvent) == null ? void 0 : _a2.relatedTarget;
    if (force || me.containsFocus && (target == null ? void 0 : target.nodeType) === Element.ELEMENT_NODE && me.element.contains(activeElement)) {
      if (!target || !DomHelper.isFocusable(target)) {
        target = me.getFocusRevertTarget();
      }
      me._isRevertingFocus = true;
      if (target && DomHelper.isFocusable(target)) {
        target._isRevertingFocus = true;
        DomHelper.focusWithoutScrolling(target);
        target._isRevertingFocus = false;
      } else {
        activeElement == null ? void 0 : activeElement.blur();
      }
      me._isRevertingFocus = false;
    }
  }
  /**
   * This method finds a close sibling (or parent, or parent's sibling etc. recursively) to which focus
   * can be directed in the case of revertFocus not having a focusable element from our focusInEvent.
   *
   * This can happen when the "from" component is destroyed or hidden. We should endeavour to prevent
   * focus escaping to `document.body` for accessibility and ease of use, and keep focus close.
   * @internal
   */
  getFocusRevertTarget() {
    var _a2;
    const me = this, {
      owner,
      focusInEvent
    } = me, searchDirection = focusInEvent ? focusInEvent.backwards ? 1 : -1 : -1;
    let target = focusInEvent && focusInEvent.relatedTarget;
    const toComponent = target && _Widget.fromElement(target);
    if (owner && !owner.isDestroyed && (!target || !DomHelper.isFocusable(target) || toComponent && !toComponent.isFocusable)) {
      target = null;
      if (owner.eachWidget) {
        const siblings = [];
        owner.eachWidget((w) => {
          if (w === me || w.isFocusable) {
            siblings.push(w);
          }
        }, false);
        if (siblings.length > 1) {
          const myIndex = siblings.indexOf(me);
          target = siblings[myIndex + searchDirection] || siblings[myIndex - searchDirection];
        }
      }
      if (!target && owner.isFocusable) {
        target = owner;
      }
      target = target ? target.focusElement : (_a2 = owner.getFocusRevertTarget) == null ? void 0 : _a2.call(owner);
    }
    return target;
  }
  /**
   * Returns a `DomClassList` computed from the `topMostBase` (e.g., `Widget` or `Panel`) with the given `suffix`
   * appended to each `widgetClass`.
   * @param {Function} topMostBase The top-most base class constructor at which to start gathering classes.
   * @param {String} [suffix] An optional suffix to apply to all widget classes.
   * @returns {Core.helper.util.DomClassList}
   * @internal
   * @category DOM
   */
  getStaticWidgetClasses(topMostBase, suffix) {
    const classList = new DomClassList(), hierarchy = this.$meta.hierarchy;
    let cls, i, name, widgetClass, widgetClassProperty;
    for (i = hierarchy.indexOf(topMostBase); i < hierarchy.length; ++i) {
      cls = hierarchy[i];
      widgetClassProperty = Reflect.getOwnPropertyDescriptor(cls.prototype, "widgetClass");
      if (widgetClassProperty == null ? void 0 : widgetClassProperty.get) {
        widgetClass = widgetClassProperty.get.call(this);
      } else {
        name = hasOwn4(cls, "$$name") || hasOwn4(cls, "$name") || hasOwn4(cls, "_$name") ? cls.$$name : cls.name;
        if (name.length < 3 || name.includes("$")) {
          console.warn(
            `Class "${name}" extending "${cls.$name}" should have "$name" static getter with no less than 3 chars.`
          );
        }
        widgetClass = `b-${name.toLowerCase()}`;
      }
      if (widgetClass) {
        classList.add(suffix ? widgetClass + suffix : widgetClass);
      }
    }
    return classList;
  }
  get rootUiClass() {
    return _Widget;
  }
  /**
   * Returns the `DomClassList` for this widget's class. This object should not be mutated.
   * @returns {Core.helper.util.DomClassList}
   * @internal
   * @category DOM
   */
  get staticClassList() {
    const { $meta: meta } = this;
    let classList = meta.staticClassList;
    if (!classList) {
      meta.staticClassList = classList = this.getStaticWidgetClasses(_Widget);
      BrowserHelper.isTouchDevice && classList.add("b-touch");
    }
    return classList;
  }
  /**
   * Returns the cross-product of the classes `staticClassList` with each `ui` as an array of strings.
   *
   * For example, a Combo with a `ui: 'foo bar'` would produce:
   *
   *      [
   *          'b-widget-foo', 'b-field-foo', 'b-textfield-foo', 'b-pickerfield-foo', 'b-combo-foo',
   *          'b-widget-bar', 'b-field-bar', 'b-textfield-bar', 'b-pickerfield-bar', 'b-combo-bar'
   *      ]
   *
   * @returns {String[]}
   * @internal
   * @category DOM
   */
  get uiClasses() {
    this.getConfig("ui");
    return this._uiClasses;
  }
  /**
   * Returns the cross-product of the classes `staticClassList` with each `ui` as a `DomClassList` instance.
   *
   * For example, a Combo with a `ui: 'foo bar'` would produce:
   *
   * ```javascript
   *      new DomClassList({
   *          'b-field-ui-foo'       : 1,
   *          'b-textfield-ui-foo'   : 1,
   *          'b-pickerfield-ui-foo' : 1,
   *          'b-combo-ui-foo'       : 1,
   *
   *          'b-field-ui-bar'       : 1,
   *          'b-textfield-ui-bar'   : 1,
   *          'b-pickerfield-ui-bar' : 1,
   *          'b-combo-ui-bar'       : 1
   *      });
   * ```
   *
   * A Panel with a `ui: 'foo bar'` would produce:
   *
   * ```javascript
   *      new DomClassList({
   *          'b-panel-ui-foo' : 1,
   *          'b-panel-ui-bar' : 1
   *      });
   * ```
   * @returns {Core.helper.util.DomClassList}
   * @internal
   * @category DOM
   */
  get uiClassList() {
    this.getConfig("ui");
    return this._uiClassList;
  }
  /**
   * Used by the Widget class internally to create CSS classes based on this Widget's
   * inheritance chain to allow styling from each level to apply.
   *
   * For example Combo would yield `"["b-widget", "b-field", "b-textfield", "b-pickerfield", "b-combo"]"`
   *
   * May be implemented in subclasses to add or remove classes from the super.widgetClassList
   * @returns {String[]} The css class list named using the class name.
   * @internal
   * @category DOM
   */
  get widgetClassList() {
    const me = this, { cls, defaultCls, uiClasses } = me;
    let { staticClassList } = me;
    if (defaultCls || cls) {
      staticClassList = staticClassList.clone();
      defaultCls && staticClassList.assign(defaultCls);
      cls && staticClassList.assign(cls);
    }
    const classList = staticClassList.values;
    uiClasses && classList.push(...uiClasses);
    me.floating && classList.push("b-floating");
    if (me.collapsify === "hide") {
      classList.push("b-collapsify-hide");
    }
    return classList;
  }
  changeCls(cls) {
    return DomClassList.from(cls);
  }
  updateCls(cls, was) {
    if (!this.isConfiguring && !this.isComposable) {
      const { element } = this;
      if (was) {
        ObjectHelper.getTruthyKeys(was).forEach((c) => element.classList.remove(c));
      }
      cls.assignTo(element);
    }
  }
  changeContentElementCls(cls) {
    return DomClassList.from(cls);
  }
  changeHtmlCls(cls) {
    return DomClassList.from(cls);
  }
  changeDefaultCls(cls) {
    return DomClassList.from(
      cls,
      /* returnEmpty */
      true
    );
  }
  changeUi(ui) {
    return DomClassList.from(ui);
  }
  updateUi(ui) {
    let uiClassList = null, cls, suffix;
    if (ui) {
      const staticClassList = this.getStaticWidgetClasses(this.rootUiClass);
      for (suffix in ui) {
        if (ui[suffix]) {
          for (cls in staticClassList) {
            if (staticClassList[cls]) {
              (uiClassList || (uiClassList = new DomClassList()))[`${cls}-ui-${suffix}`] = 1;
            }
          }
        }
      }
    }
    this._uiClasses = uiClassList == null ? void 0 : uiClassList.values;
    this._uiClassList = uiClassList;
  }
  //endregion
  //region Cache
  /**
   * Gets dom elements in the view. Caches the results for faster future calls.
   * @param {String} query CSS selector
   * @param {Boolean} children true to fetch multiple elements
   * @param {HTMLElement} element Element to use as root for the query, defaults to the views outermost element
   * @returns {HTMLElement|HTMLElement[]|null} A single element or an array of elements (if parameter children is set to true)
   * @internal
   * @category DOM
   */
  fromCache(query, children = false, element = this.element) {
    if (!element)
      return null;
    const me = this;
    if (!me.cache[query]) {
      me.cache[query] = children ? DomHelper.children(element, query) : DomHelper.down(element, query);
    }
    return me.cache[query];
  }
  /**
   * Clear caches, forces all calls to fromCache to requery dom. Called on render/rerender.
   * @internal
   * @category DOM
   */
  emptyCache() {
    this.cache = {};
  }
  //endregion
  //region Mask
  changeMasked(mask, maskInstance) {
    var _a2;
    if (((_a2 = this.masked) == null ? void 0 : _a2.type) === "trial") {
      return;
    }
    if (mask === true || mask === "") {
      mask = "\xA0";
    }
    if (maskInstance && !maskInstance.isDestroyed) {
      if (typeof mask === "string") {
        maskInstance.text = mask;
        mask = maskInstance;
      } else if (mask) {
        maskInstance.setConfig(mask);
        mask = maskInstance;
      } else {
        maskInstance.destroy();
      }
    } else if (mask) {
      const Mask2 = _Widget.resolveType("mask");
      mask = Mask2.mergeConfigs(this.maskDefaults, mask);
      mask.owner = this;
      mask = Mask2.mask(mask);
    }
    return mask || null;
  }
  onMaskAutoClose(mask) {
    if (mask.isDestroyed && mask === this.masked) {
      this.masked = null;
    }
  }
  /**
   * Mask the widget, showing the specified message
   * @param {String|MaskConfig} msg Mask message (or a {@link Core.widget.Mask} config object
   * @returns {Core.widget.Mask}
   */
  mask(msg) {
    this.masked = msg;
    return this.masked;
  }
  /**
   * Unmask the widget
   */
  unmask() {
    this.masked = null;
  }
  //endregion
  //region Monitor resize
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    this._width = element.offsetWidth;
    this._height = element.offsetHeight;
  }
  onElementResize(resizedElement, lastRect) {
    var _a2;
    const me = this, { element } = me, oldWidth = (_a2 = me._width) != null ? _a2 : me._oldWidth, oldHeight = me._height, newWidth = element.offsetWidth, newHeight = element.offsetHeight;
    if (me.floating && lastRect) {
      me.onFloatingWidgetResize(...arguments);
    }
    if (!me.suspendResizeMonitor && (oldWidth !== newWidth || oldHeight !== newHeight)) {
      me.onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight);
      me.trigger("resize", { width: newWidth, height: newHeight, oldWidth, oldHeight });
    }
  }
  onFloatingWidgetResize(resizedElement, lastRect, myRect) {
    const me = this, {
      lastAlignSpec,
      constrainTo
    } = me;
    if (me.isVisible && lastAlignSpec && lastAlignSpec.target) {
      const heightChange = !lastRect || myRect.height !== lastRect.height, widthChange = !lastRect || myRect.width !== lastRect.width, failsConstraint = constrainTo && !Rectangle.from(constrainTo).contains(Rectangle.from(me.element, null, true));
      if (heightChange && lastAlignSpec.zone !== 2 || widthChange && lastAlignSpec.zone !== 1 || failsConstraint) {
        me.requestAnimationFrame(() => me.realign());
      }
    }
  }
  updateScale() {
    const me = this, element = me.element, parentElement = element.parentElement;
    if (!me.configuredWidth) {
      me.configuredWidth = me.width;
    }
    element.style.display = "none";
    const rect = Rectangle.client(parentElement), scale = rect.width / me.configuredWidth, adjustedScale = me.scale = me.allowGrowWidth ? Math.min(scale, 1) : scale;
    element.style.transform = `scale(${adjustedScale})`;
    element.style.transformOrigin = "top left";
    element.style.display = "";
    if (me.allowGrowWidth && scale > 1) {
      me.width = me.configuredWidth * scale;
    }
  }
  onParentElementResize(event) {
    this.updateScale();
  }
  //endregion
  /**
   * Returns a `TRBL` array of values parse from the passed specification. This can be used to parse`
   * a value list for `margin` or `padding` or `border-width` etc - any CSS value which takes a `TRBL` value.
   * @param {Number|String|String[]} values The `TRBL` value
   * @param {String} [units=px] The units to add to values which are specified as numeric.
   * @internal
   */
  parseTRBL(values, units = "px") {
    values = values || 0;
    if (typeof values === "number") {
      return [`${values}${units}`, `${values}${units}`, `${values}${units}`, `${values}${units}`];
    }
    const parts = values.split(" "), len = parts.length;
    if (len === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else if (len === 2) {
      parts[2] = parts[0];
      parts[3] = parts[1];
    } else if (len === 3) {
      parts[3] = parts[1];
    }
    return [
      isFinite(parts[0]) ? `${parts[0]}${units}` : parts[0],
      isFinite(parts[1]) ? `${parts[1]}${units}` : parts[2],
      isFinite(parts[2]) ? `${parts[2]}${units}` : parts[3],
      isFinite(parts[3]) ? `${parts[3]}${units}` : parts[4]
    ];
  }
  // Returns root node for this widget, either a document or a shadowRoot
  get documentRoot() {
    var _a2;
    return ((_a2 = this.owner) == null ? void 0 : _a2.documentRoot) || this.element.getRootNode();
  }
  // Returns the root from which to add global events. Prioritizes owner last.
  get eventRoot() {
    var _a2, _b;
    return ((_a2 = this.element) == null ? void 0 : _a2.isConnected) ? DomHelper.getRootElement(this.element) : ((_b = this.owner) == null ? void 0 : _b.eventRoot) || this._rootElement;
  }
  // Returns top most DOM element of the visible DOM tree for this widget element, either document.body or a shadowRoot
  get rootElement() {
    var _a2, _b;
    const me = this;
    if (!me._rootElement) {
      let root = ((_a2 = me.owner) == null ? void 0 : _a2.rootElement) || DomHelper.getRootElement(me.forElement || (((_b = me.element) == null ? void 0 : _b.isConnected) ? me.element : me.getRenderContext()[0] || me.element));
      if (!root) {
        root = document.body;
      }
      me._rootElement = root;
    }
    return me._rootElement;
  }
  get floatRoot() {
    var _a2;
    const me = this, { rootElement } = me;
    let { floatRoot } = rootElement;
    if (!floatRoot) {
      const { outerCls } = _Widget, themeName = (_a2 = DomHelper.getThemeInfo(null, rootElement)) == null ? void 0 : _a2.name;
      if (!DomHelper.isValidFloatRootParent(rootElement)) {
        throw new Error("Attaching float root to wrong root");
      }
      if (themeName) {
        outerCls.push(`b-theme-${themeName.toLowerCase()}`);
      }
      floatRoot = rootElement.floatRoot = DomHelper.createElement({
        className: `b-float-root ${outerCls.join(" ")}`,
        parent: rootElement
      });
      floatRoots.push(floatRoot);
      if (BrowserHelper.isAndroid) {
        floatRoot.style.height = `${screen.height}px`;
        EventHelper.on({
          element: globalThis,
          orientationchange: () => floatRoot.style.height = `${screen.height}px`,
          thisObj: this
        });
      }
      GlobalEvents_default.ion({
        theme: ({ theme, prev }) => {
          floatRoot.classList.add(`b-theme-${theme.toLowerCase()}`);
          floatRoot.classList.remove(`b-theme-${prev.toLowerCase()}`);
        }
      });
    } else if (!rootElement.contains(floatRoot)) {
      rootElement.appendChild(floatRoot);
    }
    return floatRoot;
  }
  get floatRootMaxZIndex() {
    let max = 1;
    Array.from(this.floatRoot.children).forEach((child) => {
      const zIndex = parseInt(getComputedStyle(child).zIndex || 0, 10);
      if (zIndex > max) {
        max = zIndex;
      }
    });
    return max;
  }
  static resetFloatRootScroll() {
    floatRoots.forEach((floatRoot) => floatRoot.scrollTop = floatRoot.scrollLeft = 0);
  }
  static get floatRoots() {
    return floatRoots;
  }
  static removeFloatRoot(floatRoot) {
    floatRoots.splice(floatRoots.indexOf(floatRoot), 1);
  }
  // CSS classes describing outer-most Widgets to provide styling / behavioral CSS style rules
  static get outerCls() {
    const result = ["b-outer"], { platform } = BrowserHelper;
    if (platform) {
      result.push(`b-${platform}`);
    }
    if (BrowserHelper.isTouchDevice) {
      result.push("b-touch-events");
    }
    if (BrowserHelper.isMobile) {
      result.push("b-mobile");
    }
    if (DomHelper.scrollBarWidth) {
      result.push("b-visible-scrollbar");
    } else {
      result.push("b-overlay-scrollbar");
    }
    if (BrowserHelper.isChrome) {
      result.push("b-chrome");
    } else if (BrowserHelper.isSafari) {
      result.push("b-safari");
    } else if (BrowserHelper.isFirefox) {
      result.push("b-firefox");
    }
    if (BrowserHelper.isPhone) {
      result.push("b-phone");
    }
    if (!globalThis.ResizeObserver) {
      result.push("b-no-resizeobserver");
    }
    return result;
  }
  get isAnimating() {
    return this._isAnimatingCounter > 0;
  }
  set isAnimating(value) {
    const me = this, { _isAnimatingCounter } = me;
    me._isAnimatingCounter = Math.max(0, _isAnimatingCounter + (value ? 1 : -1));
    if (_isAnimatingCounter === 0 && value) {
      me.element.classList.add("b-animating");
      me.trigger("animationStart");
    } else if (_isAnimatingCounter === 1 && !value) {
      me.element.classList.remove("b-animating");
      me.trigger("animationEnd");
    }
  }
  // Waits until all transitions are completed
  async waitForAnimations() {
    if (this.isAnimating) {
      await this.await("animationend", { checkLog: false });
    }
  }
  /**
   * Analogous to `document.querySelector`, finds the first Bryntum widget matching the passed
   * selector. Right now, only class name (lowercased) selector strings, or
   * a filter function which returns `true` for required object are allowed:
   *
   * ```javascript
   * Widget.query('grid').destroy();
   * ```
   *
   * @param {String|Function} selector A lowercased class name, or a filter function.
   * @param {Boolean} [deep] Specify `true` to search the prototype chain (requires supplying a string `selector`). For
   * example 'widget' would then find a Grid
   * @returns {Core.widget.Widget} The first matched widget if any.
   * @category Widget hierarchy
   */
  static query(selector, deep = false) {
    const { idMap } = _Widget.identifiable;
    for (const id in idMap) {
      if (_Widget.widgetMatches(idMap[id], selector, deep)) {
        return idMap[id];
      }
    }
    return null;
  }
  /**
   * Analogous to document.querySelectorAll, finds all Bryntum widgets matching the passed
   * selector. Right now, only registered widget `type` strings, or a filter function which
   * returns `true` for required object are allowed:
   *
   * ```javascript
   * let allFields = Widget.queryAll('field', true);
   * ```
   *
   * @param {String|Function} selector A lowercased class name, or a filter function.
   * @param {Boolean} [deep] Specify `true` to search the prototype chain (requires supplying a string `selector`). For
   * example 'widget' would then find a Grid
   * @returns {Core.widget.Widget[]} The first matched widgets if any - an empty array will be returned
   * if no matches are found.
   * @category Widget hierarchy
   */
  static queryAll(selector, deep = false) {
    const { idMap } = _Widget.identifiable, result = [];
    for (const id in idMap) {
      if (_Widget.widgetMatches(idMap[id], selector, deep)) {
        result.push(idMap[id]);
      }
    }
    return result;
  }
  /**
   * Returns the Widget which owns the passed element (or event).
   * @param {HTMLElement|Event} element The element or event to start from
   * @param {String|Function} [type] The type of Widget to scan upwards for. The lowercase
   * class name. Or a filter function which returns `true` for the required Widget
   * @param {HTMLElement|Number} [limit] The number of components to traverse upwards to find a
   * match of the type parameter, or the element to stop at
   * @returns {Core.widget.Widget|null} The found Widget or null
   * @category Misc
   */
  static fromElement(element, type, limit) {
    const typeOfType = typeof type;
    if (element && !element.nodeType) {
      element = element.target;
    }
    if (typeOfType === "number" || type && type.nodeType === Element.ELEMENT_NODE) {
      limit = type;
      type = null;
    }
    let target = element, depth = 0, topmost, cmpId, cmp;
    if (typeof limit !== "number") {
      topmost = limit;
      limit = Number.MAX_VALUE;
    }
    if (typeOfType === "string") {
      type = type.toLowerCase();
    }
    while (target && target.nodeType === Element.ELEMENT_NODE && depth < limit && target !== topmost) {
      cmpId = target.dataset && target.dataset.ownerCmp || target.id;
      if (cmpId) {
        cmp = _Widget.getById(cmpId);
        if (cmp) {
          if (type) {
            if (typeOfType === "function") {
              if (type(cmp)) {
                return cmp;
              }
            } else if (_Widget.widgetMatches(cmp, type, true)) {
              return cmp;
            }
          } else {
            return cmp;
          }
        }
        depth++;
      }
      target = target.parentNode;
    }
    return null;
  }
  /**
   * Returns the Widget which owns the passed CSS selector.
   *
   * ```javascript
   * const button = Widget.fromSelector('#my-button');
   * ```
   *
   * @param {String} selector CSS selector
   * @returns {Core.widget.Widget|null} The found Widget or null
   * @category Misc
   */
  static fromSelector(selector) {
    const element = document.querySelector(selector);
    return element ? _Widget.fromElement(element) : null;
  }
  // NOTE: Not named `triggerChange` to not conflict with existing fn on Field
  /**
   * Triggers a 'change' event with the supplied params. After triggering it also calls `onFieldChange()` on each
   * ancestor the implements that function, supplying the same set of params.
   * @param {Object} params Event params, used both for triggering and notifying ancestors
   * @param {Boolean} [trigger] `false` to not trigger, only notifying ancestors
   * @internal
   */
  triggerFieldChange(params, trigger = true) {
    var _a2;
    if (trigger) {
      this.trigger("change", params);
    }
    (_a2 = this.eachAncestor) == null ? void 0 : _a2.call(this, (ancestor) => {
      var _a3, _b;
      (_a3 = ancestor.onFieldChange) == null ? void 0 : _a3.call(ancestor, params);
      if ((_b = ancestor.isolateFieldChange) == null ? void 0 : _b.call(ancestor, this)) {
        return false;
      }
    });
  }
  /**
   * Returns `true` if the given `field`'s value change should be isolated (kept hidden by this widget). By default,
   * this method returns the value of {@link Core.widget.Container#config-isolateFields} for all fields.
   * @param {Core.widget.Field} field The field in question.
   * @internal
   */
  isolateFieldChange(field) {
    return this.isolateFields;
  }
  // Sets up the focus listeners, one set for every document root (shadow root or document)
  setupFocusListeners() {
    GlobalEvents_default.setupFocusListenersOnce(this.eventRoot, EventHelper);
  }
  static widgetMatches(candidate, selector, deep) {
    if (selector === "*") {
      return true;
    }
    if (typeof selector === "function") {
      return selector(candidate);
    }
    return _Widget.isType(candidate, selector, deep);
  }
  /**
   * Attached a tooltip to the specified element.
   *
   * ```javascript
   * Widget.attachTooltip(element, {
   *   text: 'Useful information goes here'
   * });
   * ```
   *
   * @param {HTMLElement} element Element to attach tooltip for
   * @param {TooltipConfig|String} configOrText Tooltip config or tooltip string, see example and source
   * @returns {HTMLElement} The passed element
   * @category Misc
   */
  static attachTooltip(element, configOrText) {
    if (typeof configOrText === "string")
      configOrText = { html: configOrText };
    _Widget.create(Object.assign({
      forElement: element
    }, configOrText), "tooltip");
    return element;
  }
  //region RTL
  // Since we use flexbox docking flips correctly out of the box. start and end values can be mapped straight to
  // left and right, for both LTR and RTL
  changeDock(dock) {
    if (dock === "start") {
      return "left";
    }
    if (dock === "end") {
      return "right";
    }
    return dock;
  }
  updateRtl(rtl) {
    super.updateRtl(rtl);
    this.eachWidget((item) => {
      if (!("rtl" in item.initialConfig)) {
        item.rtl = rtl;
      }
    });
  }
  //endregion
};
var proto2 = Widget.prototype;
["compose", "domSyncCallback"].forEach((fn) => proto2[fn].$nullFn = true);
Widget.initClass();
Widget.register("mask", Mask);
DomHelper.Widget = Widget;
GlobalEvents_default.Widget = Widget;
Mask.identifiable.idMap = Widget.identifiable.idMap;
Object.assign(globalThis.bryntum || (globalThis.bryntum = {}), {
  get: Widget.getById.bind(Widget),
  query: Widget.query,
  queryAll: Widget.queryAll,
  fromElement: Widget.fromElement,
  fromSelector: Widget.fromSelector
});
Widget._$name = "Widget";

// ../Core/lib/Core/widget/layout/Layout.js
var Layout = class extends Base.mixin(Events_default, Factoryable_default) {
  get contentElement() {
    var _a2;
    return (_a2 = this.owner) == null ? void 0 : _a2.contentElement;
  }
  onChildAdd(item) {
  }
  onChildRemove(item) {
  }
  renderChildren() {
    const me = this, { owner, itemCls } = me, { contentElement, items } = owner, ownerItemCls = owner.itemCls, itemCount = items == null ? void 0 : items.length;
    if (itemCount) {
      owner.textContent = false;
      for (let i = 0; i < itemCount; i++) {
        const item = items[i], { element } = item, { classList } = element;
        element.dataset.itemIndex = i;
        if (classList.contains("b-outer")) {
          classList.remove(...Widget.outerCls);
        }
        if (itemCls) {
          classList.add(itemCls);
        }
        if (ownerItemCls) {
          classList.add(ownerItemCls);
        }
        item.render(contentElement, Boolean(owner.isPainted));
      }
    }
    me.syncPendingConfigs();
    me.syncChildCount();
  }
  removeChild(child) {
    const me = this, { element } = child, { owner, itemCls } = me, { contentElement } = owner, ownerItemCls = owner.itemCls;
    if (contentElement.contains(element)) {
      element.remove();
    }
    delete element.dataset.itemIndex;
    if (itemCls) {
      element.classList.remove(itemCls);
    }
    if (ownerItemCls) {
      element.classList.remove(ownerItemCls);
    }
    me.fixChildIndices();
    me.syncChildCount();
  }
  appendChild(child) {
    const { element } = child, { owner, itemCls } = this, { contentElement } = owner, ownerItemCls = owner.itemCls;
    element.dataset.itemIndex = owner.indexOfChild(child);
    owner.textContent = false;
    if (itemCls) {
      element.classList.add(itemCls);
    }
    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }
    child.render(contentElement, Boolean(owner.isPainted));
    this.syncChildCount();
  }
  insertChild(toAdd, childIndex) {
    const me = this, { element } = toAdd, { owner, itemCls } = me, { contentElement } = owner, nextSibling = DomHelper.getChild(contentElement, `[data-item-index="${childIndex}"]`), ownerItemCls = owner.itemCls;
    owner.textContent = false;
    if (itemCls) {
      element.classList.add(itemCls);
    }
    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }
    contentElement.insertBefore(element, nextSibling);
    toAdd.render(null, Boolean(owner.isPainted));
    me.fixChildIndices();
    me.syncChildCount();
  }
  fixChildIndices() {
    this.owner.items.forEach((child, index) => {
      child.element.dataset.itemIndex = index;
    });
  }
  syncChildCount() {
    var _a2;
    const { owner } = this, { length } = owner.items;
    (_a2 = owner.contentElement) == null ? void 0 : _a2.classList[length === 1 ? "add" : "remove"]("b-single-child");
  }
  /**
   * Registers a layout `config` property that cannot be acted upon at this time but must wait for the `owner` to
   * fully render its elements (in particular the `contentElement`).
   * @param {String} config The name of the config to sync later.
   * @internal
   */
  syncConfigLater(config) {
    const pendingConfigs = this.pendingConfigs || (this.pendingConfigs = []);
    if (!pendingConfigs.includes(config)) {
      pendingConfigs.push(config);
    }
  }
  /**
   * Sets the specified `style` to the value of the config given its `name`.
   * @param {Object} options The name of the config with the value to apply to the given `style`.
   * @param {String} options.name The name of the config with the value to apply to the given `style`.
   * @param {String} options.style The style property to set on the `contentElement`.
   * @param {String[]} [options.classes] A list of config values that should be added as CSS classes.
   * @param {Object} [options.map] An mapping object to convert the config's value to the `style` value.
   * @internal
   */
  syncConfigStyle({ name, style, classes, map }) {
    const me = this, baseCls = `b-box-${name}-`, { contentElement } = me, raw = me[name];
    let value = (map == null ? void 0 : map[raw]) || raw;
    if (contentElement) {
      if (classes) {
        const { classList } = contentElement;
        classes.forEach((c) => {
          if (c !== value) {
            classList.remove(baseCls + c);
          }
        });
        if (classes.includes(value)) {
          classList.add(baseCls + value);
          value = "";
        }
      }
      contentElement.style[style] = value;
    } else {
      me.syncConfigLater(name);
    }
  }
  syncPendingConfigs() {
    const me = this, { pendingConfigs } = me;
    let name;
    if (pendingConfigs) {
      me.pendingConfigs = null;
      while (name = pendingConfigs.pop()) {
        me[me.$meta.configs[name].updater](me[name]);
      }
    }
  }
};
__publicField(Layout, "type", "default");
__publicField(Layout, "configurable", {
  /**
   * The owning Widget.
   * @member {Core.widget.Widget} owner
   * @readonly
   */
  /**
   * @config {Core.widget.Widget} owner
   * @private
   */
  owner: null,
  /**
   * The CSS class which should be added to the owning {@link Core.widget.Container}'s.
   * {@link Core.widget.Widget#property-contentElement}.
   * @config {String}
   */
  containerCls: "b-auto-container",
  /**
   * The CSS class which should be added to the encapsulating element of child items.
   * @config {String}
   */
  itemCls: null
});
// establish this class as the Factoryable base
__publicField(Layout, "factoryable", {
  defaultType: "default"
});
Layout.initClass();
Layout._$name = "Layout";

// ../Core/lib/Core/widget/Ripple.js
var lastTouchTime = 0;
var hasRipple = (w) => w.ripple;
var Ripple = class extends Widget {
  static get defaultConfig() {
    return {
      old_element: {
        children: [{
          className: "b-ripple-inner",
          reference: "rippleElement"
        }]
      },
      element: {
        children: [{
          tag: "svg",
          class: "b-ripple-inner",
          reference: "rippleElement",
          ns: "http://www.w3.org/2000/svg",
          version: "1.1",
          viewBox: "0 0 100 100",
          children: [{
            reference: "circleElement",
            tag: "circle",
            cx: "0",
            cy: "0",
            r: 10
          }]
        }]
      },
      floating: true,
      hideAnimation: false,
      showAnimation: false,
      scrollAction: "realign",
      color: "rgba(0,0,0,.3)",
      startRadius: 10,
      radius: 100
    };
  }
  afterConstruct() {
    super.afterConstruct();
    EventHelper.on({
      element: this.rootElement,
      mousedown: "onRippleControllingEvent",
      thisObj: this,
      capture: true,
      once: true
    });
  }
  onRippleControllingEvent(event) {
    var _a2;
    const me = this;
    me.show();
    const rippleAnimation = DomHelper.getStyleValue(me.circleElement, "animationName");
    me.hide();
    (_a2 = me.listenerDetacher) == null ? void 0 : _a2.call(me);
    if (rippleAnimation && rippleAnimation !== "none") {
      me.listenerDetacher = EventHelper.on({
        // Trap all mousedowns and see if the encapsulating Component is configured to ripple
        mousedown: {
          element: me.rootElement,
          capture: true,
          handler: "onMousedown"
        },
        touchstart: {
          element: me.rootElement,
          capture: true,
          handler: "onTouchStart"
        },
        // Hide at the end of the ripple
        animationend: {
          element: me.circleElement,
          handler: "onAnimationEnd"
        },
        thisObj: me
      });
      if (event.type === "mousedown") {
        me.onMousedown(event);
        GlobalEvents_default.ion({
          theme: "onRippleControllingEvent",
          thisObj: this
        });
      }
    }
  }
  onTouchStart(event) {
    lastTouchTime = performance.now();
    this.handleTriggerEvent(event);
  }
  onMousedown(event) {
    if (performance.now() - lastTouchTime > 200) {
      this.handleTriggerEvent(event);
    }
  }
  handleTriggerEvent(event) {
    const targetWidget = Widget.fromElement(event.target, hasRipple);
    if (targetWidget) {
      const rippleCfg = targetWidget.ripple, target = rippleCfg.delegate ? event.target.closest(rippleCfg.delegate) : targetWidget.focusElement || targetWidget.element;
      if (target) {
        const ripple = ObjectHelper.assign({
          event,
          target,
          radius: this.radius
        }, rippleCfg);
        if (typeof ripple.clip === "string") {
          ripple.clip = targetWidget[ripple.clip] || event.target.closest(ripple.clip);
          if (!ripple.clip) {
            return;
          }
        }
        this.ripple(ripple);
      }
    }
  }
  ripple({
    event,
    point = EventHelper.getClientPoint(event),
    target = event.target,
    clip = target,
    radius = this.radius,
    color = this.color
  }) {
    this.clip = clip;
    clip = Rectangle.from(clip, null, true);
    const me = this, centreDelta = clip.getDelta(point), rippleStyle = me.rippleElement.style, circleElement = me.circleElement, borderRadius = DomHelper.getStyleValue(target, "border-radius");
    me.hide();
    rippleStyle.transform = `translateX(${centreDelta[0]}px) translateY(${centreDelta[1]}px)`;
    rippleStyle.height = rippleStyle.width = `${radius}px`;
    me.element.style.borderRadius = borderRadius;
    circleElement.setAttribute("r", radius);
    circleElement.setAttribute("fill", color);
    me.showBy({
      target: clip,
      align: "c-c",
      matchSize: true
    });
  }
  // When fully expanded, it's all over.
  onAnimationEnd(event) {
    if (event.animationName === "b-ripple-expand") {
      this.hide();
    }
  }
};
__publicField(Ripple, "$name", "Ripple");
__publicField(Ripple, "type", "ripple");
Widget.RippleClass = Ripple;
Ripple._$name = "Ripple";

// ../Core/lib/Core/widget/Container.js
var emptyObject6 = Object.freeze({});
var { isArray: isArray2 } = Array;
var returnWeight = (i) => i.weight;
var sortByWeight = ({ weight: a }, { weight: b }) => {
  if (typeof a === "string" || typeof b === "string") {
    return String(a).localeCompare(String(b));
  }
  return (a != null ? a : Number.MAX_SAFE_INTEGER) - (b != null ? b : Number.MAX_SAFE_INTEGER);
};
var isNotHidden = (w) => w && !w.hidden;
var stylesToCheck = ["display", "flex-direction"];
var boxLayouts = {
  default: 1,
  box: 1
};
var Container = class extends Widget {
  static get configurable() {
    return {
      /**
       * An object containing typed child widget config objects or Widgets. May also be specified
       * as an array.
       *
       * If configured as an Object, the property names are used as the child component's
       * {@link Core.widget.Widget#config-ref} name, and the value is the child component's config object.
       *
       * ```javascript
       *
       *  class MyContainer extends Container {
       *      static get configurable() {
       *          return {
       *              items : {
       *                  details : {
       *                      type : 'panel',
       *                      ....
       *                  },
       *                  button : {
       *                      type : 'button',
       *                      text : 'Save'
       *                  }
       *              }
       *          }
       *      }
       *  }
       *
       *  new MyContainer({
       *      title    : 'Test Container',
       *      floating : true,
       *      centered : true,
       *      width    : 600,
       *      height   : 400,
       *      layout   : 'fit',
       *      items    : {
       *          button : {
       *              disabled : true
       *          },
       *          details : {
       *              title : 'More coolness',
       *              html  : 'Details content'
       *          }
       *      }
       *  }).show();
       * ```
       *
       * The order of the child widgets is determined by the order they are defined in `items`, but can also be
       * affected by configuring a {@link Core.widget.Widget#config-weight} on one or more widgets.
       *
       * To remove existing items, set corresponding keys to `null`.
       *
       * If you want to customize child items of an existing class, you can do this using the child widget
       * 'ref' identifier (useful for reconfiguring Event Editor in Scheduler / Gantt):
       *
       * ```javascript
       *  new MyCustomTabPanel({
       *      items    : {
       *          // Reconfigure tabs
       *          firstTab : {
       *              title : 'My custom title'
       *          },
       *          secretTab : null // hide this tab
       *      }
       *  }).show();
       * ```
       *
       * @config {Object<String,ContainerItemConfig|MenuItemConfig|Boolean|null>|Array<ContainerItemConfig|MenuItemConfig|Core.widget.Widget>}
       * @category Content
       */
      items: null,
      /**
       * An array of {@link #config-items child item} _config objects_ which is to be converted into
       * instances only when this Container is rendered, rather than eagerly at construct time.
       *
       * _This is mutually exclusive with the {@link #config-items} config._
       *
       * @config {Object<String,ContainerItemConfig>|ContainerItemConfig[]|Core.widget.Widget[]}
       * @category Content
       */
      lazyItems: {
        $config: ["lazy"],
        value: null
      },
      /**
       * A config object containing default settings to apply to all child widgets.
       * @config {Object}
       * @category Content
       */
      defaults: null,
      defaultType: "widget",
      /**
       * The CSS style properties to apply to the {@link Core.widget.Widget#property-contentElement}.
       *
       * By default, a Container's {@link Core.widget.Widget#property-contentElement} uses flexbox layout, so this
       * config may contain the following properties:
       *
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction">flexDirection</a> default '`row`'
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap">flexWrap</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-flow">flexFlow</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content">justifyContent</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-items">alignItems</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-content">alignContent</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/place-content">placeContent</a>
       * @prp {Object}
       * @category Layout
       */
      layoutStyle: null,
      /**
       * An optional CSS class to add to child items of this container.
       * @config {String}
       * @category CSS
       */
      itemCls: null,
      /**
       * The {@link #config-layout} as an instance of {@link Core.widget.layout.Layout}.
       * This is a helper class which adds and removes child widgets to this Container's
       * DOM and applies CSS classes based upon its requirements.
       *
       * The {@link Core.widget.layout.Card card} layout provides for showing one child
       * widget at a time, and provides a switching API to change which child widget is
       * currently active.
       * @member {Core.widget.layout.Layout} layout
       * @category Layout
       */
      /**
       * The short name of a helper class which manages rendering and styling of child items.
       *
       * Or a config object which includes a `type` property which specifies which type
       * of layout to use, and how to configure that layout.
       *
       * By default, the only special processing that is applied is that the Container class's
       * {@link #config-itemCls} is added to child items.
       *
       * Containers use CSS flexbox in its default configuration to arrange child items. You may either use the
       * {@link #config-layoutStyle} configuration to tune how child items are layed out, or use one of the built
       * in helper classes which include:
       *
       *  - `fit` A single child item is displayed fitting exactly into the
       *  {@link Core.widget.Widget#property-contentElement}.
       *  - `card` Child items are displayed one at a time, size to fit the
       *  {@link Core.widget.Widget#property-contentElement} and are slid in from the side when activated.
       *  - `box` Child items are layed out using flexbox.
       *
       * For example:
       * ```javascript
       * {
       *     id     : 'myContainer',
       *     // Our child items flow downwards and are stretched to fill our width
       *     layout : {
       *         type       : 'box',
       *         direction  : 'column'
       *         align      : 'stretch'
       *     }
       * }
       * @config {String|ContainerLayoutConfig}
       * @category Layout
       */
      layout: {
        type: "default"
      },
      /**
       * An object containing named config objects which may be referenced by name in any {@link #config-items}
       * object. For example, a specialized {@link Core.widget.Menu Menu} subclass may have a `namedItems` default
       * value defined like this:
       *
       * ```javascript
       *  namedItems : {
       *      removeRow : {
       *          text : 'Remove row',
       *          onItem() {
       *              this.ownerGrid.remove(this.ownerGrid.selectedRecord);
       *          }
       *      }
       *  }
       * ```
       *
       * Then whenever that subclass is instantiated and configured with an {@link #config-items} object, the
       * items may be configured like this:
       *
       * ```javascript
       *  items : {
       *      removeRow : true,   // The referenced namedItem will be applied to this
       *      otherItemRef : {
       *          text : 'Option 2',
       *          onItem() {
       *          }
       *      }
       * }
       * ```
       * @config {Object<string,ContainerItemConfig>}
       * @category Content
       */
      namedItems: null,
      /**
       * When set to `true`, this widget is considered as a whole when processing {@link Core.widget.Toolbar}
       * overflow. When `false`, this widget's child items are considered instead.
       *
       * When set to the string `'none'`, this widget is ignored by overflow processing. This option should be
       * used with caution as it prevents the overflow algorithm from moving such widgets into the overflow
       * popup which may result in not clearing enough space to avoid overflowing the toolbar.
       * @config {Boolean|String}
       * @default false
       * @category Layout
       * @internal
       */
      overflowable: {
        value: null,
        default: false,
        $config: null
      },
      /**
       * Specify `true` for a container used to show text markup. It will apply the CSS class `b-text-content`
       * which specifies a default max-width that makes long text more readable.
       *
       * This CSS class is automatically removed if the container adds/defines child Widgets.
       * @config {Boolean}
       * @default
       * @category Content
       */
      textContent: true,
      /**
       * {@link Core.data.Model Record} whose values will be used to populate fields in the container.
       *
       * Any descendant widgets of this Container with a `name` property (or a `ref` if no name is configured)
       * will have its value set to the value of that named property of the record.
       *
       * If no record is passed, the widget has its value set to `null`.
       *
       * To strictly match by the `name` property, configure {@link #config-strictRecordMapping} as `true`.
       *
       * @prp {Core.data.Model}
       * @category Record
       */
      record: null,
      /**
       * Specify `true` to match fields by their `name` property only when assigning a {@link #config-record},
       * without falling back to `ref`.
       *
       * @prp {Boolean}
       * @default false
       * @category Record
       */
      strictRecordMapping: null,
      /**
       * Update assigned {@link #config-record} automatically on field changes
       * @config {Boolean}
       * @category Record
       */
      autoUpdateRecord: null,
      /**
       * Update fields if the {@link #config-record} changes
       * @config {Boolean}
       * @internal
       */
      autoUpdateFields: null,
      /**
       * Specify `true` to make this container hide when it has no visible children (Either empty
       * or all children hidden).
       *
       * Container will show itself when there are visible children, ie: hidden children are
       * shown, or new visible children are added.
       * @config {Boolean}
       * @default
       * @category Layout
       */
      hideWhenEmpty: null,
      contentElMutationObserver: {
        $config: ["lazy", "nullify"],
        value: true
      },
      /**
       * Specify `true` to isolate record changes to this container and its ancestors. Prevents record updates
       * from propagating up from here and also prevents record updates from parent from propagating down to us.
       *
       * @config {Boolean}
       * @default false
       * @internal
       */
      isolateFields: false,
      /**
       * Can be set to `true` to make a focus of a focusable encapsulating element relay focus down into a
       * focusable child. This is normally `false` to allow mousedown to begin text selection in Popups.
       * @internal
       */
      focusDescendant: false,
      // Our own setValues/getValues system should not set/get HTML content
      defaultBindProperty: null,
      /**
       * A {@link #function-query} selector function which can identify the descendant widget to which
       * focus should be directed by default.
       *
       * By default, the first focusable descendant widget is chosen. This may direct focus to a different
       * widget:
       *
       * ```javascript
       *     new Popup({
       *         title        : 'Details',
       *         width        : '25em',
       *         centered     : true,
       *         modal        : true,
       *
       *         // Focus goes straight to OK button in the bottom toolbar on show
       *         defaultFocus : w => w.ref === 'okButton',
       *         items        : {
       *             nameField : {
       *                 type  : 'textfield',
       *                 label : 'Name'
       *             },
       *             ageField  : {
       *                 type  : 'numberfield',
       *                 label : 'Name'
       *             }
       *         },
       *         bbar     : {
       *             items : {
       *                 okButton : {
       *                     text    : 'OK',
       *                     handler : okFunction
       *                 },
       *                 cncelButton : {
       *                     text    : 'Cancel',
       *                     handler : cancelFunction
       *                 }
       *             }
       *         }
       *     }).show();
       * ```
       * @config {Function}
       * @param {Core.widget.Widget} widget Widget passed to method
       * @returns {Boolean} truthy value if widget is the default one
       */
      defaultFocus: null
    };
  }
  static get prototypeProperties() {
    return {
      // These classes have opinions about how fields should fill the space, so allow them to be replaced by the
      // less opinionated b-hbox/b-vbox classes when that is not desired. Using ":not(.b-toolbar-content)" in
      // the CSS does not scale now that FieldSet wants similar treatment... adding more ":not()"s is not only a
      // messy approach, it increases the selector specificity and causes interference with other selectors (e.g.
      // TimePicker's number field rules).
      flexRowCls: "b-flex-row",
      flexColCls: "b-flex-column",
      /**
       * @member {Boolean} initialItems
       * This property is `true` until the container's initial `items` config has been processed. This property
       * is set to `false` by the `updateItems` method.
       * @readonly
       * @internal
       */
      initialItems: true
    };
  }
  startConfigure(config) {
    const items = config.items || config.lazyItems;
    if (!(this.hasItems = Boolean(items && (isArray2(items) ? items : Object.keys(items)).length))) {
      this.initialItems = false;
    }
    super.startConfigure(config);
  }
  /**
   * Returns the first widget in this Container.
   * @property {Core.widget.Widget}
   * @readonly
   */
  get firstItem() {
    return this.getAt(0);
  }
  /**
   * Returns the last widget in this Container.
   * @property {Core.widget.Widget}
   * @readonly
   */
  get lastItem() {
    return this.getAt(-1);
  }
  /**
   * Returns the widget at the specified `index` in this Container.
   * @param {Number} index The index of the widget to return. Negative numbers index for the last item. For example,
   * `index = -1` returns the last matching item, -2 the 2nd to last matching item etc..
   * @returns {Core.widget.Widget} The requested widget.
   */
  getAt(index) {
    return this.ensureItems().at(index);
  }
  /**
   * Removes the passed child/children from this Container.
   * @param  {...Core.widget.Widget} toRemove The child or children to remove.
   * @returns {Core.widget.Widget|Core.widget.Widget[]} All the removed items. An array if multiple items
   * were removed, otherwise, just the item removed.
   */
  remove(...toRemove) {
    let returnArray = true;
    if (toRemove.length === 1) {
      if (isArray2(toRemove[0])) {
        toRemove = toRemove[0];
      } else {
        returnArray = false;
      }
    }
    const me = this, { _items } = me, result = [];
    for (let i = 0; i < toRemove.length; i++) {
      const childToRemove = toRemove[i];
      if (_items.includes(childToRemove)) {
        _items.remove(childToRemove);
        me.layout.removeChild(childToRemove);
        result.push(childToRemove);
        me.onChildRemove(childToRemove);
      }
    }
    return returnArray ? result : result[0];
  }
  /**
   * Removes all children from this Container.
   * @returns {Core.widget.Widget[]} All the removed items.
   */
  removeAll() {
    return this.remove(this.items);
  }
  /**
   * Appends the passed widget / widgets or config(s) describing widgets to this Container.
   *
   * If the widgets specify a `weight`, they are inserted at the correct index compared to the existing items weights.
   *
   * @param {ContainerItemConfig|ContainerItemConfig[]|Core.widget.Widget|Core.widget.Widget[]} toAdd The child or children instances (or config objects) to add.
   * @returns {Core.widget.Widget|Core.widget.Widget[]} All the added widgets. An array if multiple items
   * were added, otherwise just the item added.
   */
  add(...toAdd) {
    const me = this, items = me.ensureItems(), result = [];
    let returnArray = true, childToAdd, i, index;
    if (toAdd.length === 1) {
      if (isArray2(toAdd[0])) {
        toAdd = toAdd[0];
      } else {
        returnArray = false;
      }
    }
    for (i = 0; i < toAdd.length; i++) {
      childToAdd = toAdd[i];
      if (childToAdd.isWidget) {
        childToAdd.parent = me;
      } else {
        childToAdd = me.createWidget(childToAdd);
      }
      if ((childToAdd == null ? void 0 : childToAdd.weight) != null) {
        index = ArrayHelper.findInsertionIndex(childToAdd, items.values, sortByWeight);
        result.push(me.insert(childToAdd, index));
      } else if (childToAdd) {
        if (!items.includes(childToAdd)) {
          items.add(childToAdd);
          me.onChildAdd(childToAdd);
          me.layout.appendChild(childToAdd);
          result.push(childToAdd);
        }
      }
    }
    return returnArray ? result : result[0];
  }
  ensureItems() {
    const me = this;
    me.getConfig("items");
    me.getConfig("lazyItems");
    if (!me._items) {
      me.items = [];
    }
    return me._items;
  }
  /**
   * Inserts the passed widget into this Container at the specified position.
   * @param  {Core.widget.Widget} toAdd The child to insert.
   * @param {Number|Core.widget.Widget} index The index to insert at or the existing child to insert before.
   * @returns {Core.widget.Widget} The added widget.
   */
  insert(toAdd, index) {
    const me = this, items = me.ensureItems();
    if (toAdd instanceof Widget) {
      toAdd.parent = me;
    } else {
      toAdd = me.createWidget(toAdd);
    }
    if (items.includes(index)) {
      index = me.indexOfChild(index);
    }
    index = Math.min(index, items.count);
    const newValues = items.values;
    newValues.splice(index, 0, toAdd);
    items.values = newValues;
    me.onChildAdd(toAdd);
    me.layout.insertChild(toAdd, index);
    return toAdd;
  }
  indexOfChild(child) {
    return this.items.indexOf(child);
  }
  changeLazyItems(lazyItems) {
    this.items = lazyItems;
    this.layout.renderChildren();
  }
  changeItems(items, oldItems) {
    const me = this, newItems = [], result = new Bag();
    if (isArray2(items)) {
      me.processItemsArray(items, newItems);
    } else if (items) {
      me.processItemsObject(items, me.namedItems, newItems);
    }
    if (newItems.some(returnWeight)) {
      newItems.sort(sortByWeight);
    }
    result.add(newItems);
    if (oldItems) {
      oldItems.forEach((w) => {
        me.remove(w);
        if (!result.includes(w) && w._createdBy === me) {
          w.destroy();
        }
      });
    }
    return result;
  }
  afterConstruct() {
    const { rtl } = this, { classList } = this.contentElement;
    classList.toggle("b-rtl", rtl === true);
    classList.toggle("b-ltr", rtl === false);
  }
  updateRtl(rtl) {
    super.updateRtl(rtl);
    const { contentElement } = this;
    if (contentElement) {
      contentElement.classList.toggle("b-rtl", rtl === true);
      contentElement.classList.toggle("b-ltr", rtl === false);
    }
  }
  updateItems(items, oldItems) {
    let index = 0;
    items.forEach((item) => {
      this.onChildAdd(item);
      if (oldItems && !oldItems.temporary) {
        this.layout.insertChild(item, index);
      }
      ++index;
    });
    this.initialItems = false;
  }
  updateHideWhenEmpty() {
    this.syncChildCount(this.rendered);
  }
  /**
   * A property, which, when *read*, returns an array of the child items of this container in rendered order.
   *
   * This property may also be *set* to change the child items of the container. Just as in the
   * {@link #config-items initial items configuration}, the new value may either be an array of
   * Widgets/Widget configs or an object.
   *
   * If specified as an Object, the property names are used as the child Widget's
   * {@link Core.widget.Widget#config-ref} name, and the value is the child Widget/Widget config.
   *
   * When setting this, any items which are *only* in the outgoing child items which were created
   * by this container from raw config objects are destroyed.
   *
   * Usage patterns:
   *
   * ```javascript
   * myContainer.items = {
   *     name : {
   *         type  : 'textfield',
   *         label : 'User name'
   *     },
   *     age : {
   *         type  : 'numberfield',
   *         label : 'User age'
   *     }
   * };
   * ```
   *
   * or
   *
   * ```javascript
   * myContainer.items = [{
   *     ref   : 'name',
   *     type  : 'textfield',
   *     label : 'User name'
   * },
   *     ref   : 'age',
   *     type  : 'numberfield',
   *     label : 'User age'
   * }];
   * ```
   * @property {Core.widget.Widget[]}
   * @accepts {Array<ContainerItemConfig|MenuItemConfig|Core.widget.Widget>|Object<String,ContainerItemConfig|MenuItemConfig>}
   */
  get items() {
    const me = this;
    me.getConfig("lazyItems");
    if (!me._items) {
      if (me.initializingItems) {
        return [];
      }
      me._items = new Bag();
      me._items.temporary = true;
    }
    return me._items.values;
  }
  processItemsArray(items, result) {
    const len = items.length;
    let i, item;
    for (i = 0; i < len; i++) {
      item = items[i];
      if (item instanceof Widget) {
        item.parent = this;
        item.element.classList.remove(...Widget.outerCls);
      } else {
        item = this.createWidget(item);
      }
      if (item) {
        if (item.ref || item.id) {
          this.addDescendant(item);
        }
        result.push(item);
      }
    }
  }
  processItemsObject(items, namedItems, result) {
    let item, ref;
    for (ref in items) {
      item = items[ref];
      if (item) {
        if (namedItems && ref in namedItems) {
          item = typeof item === "object" ? ObjectHelper.merge(ObjectHelper.clone(namedItems[ref]), item) : namedItems[ref];
        }
        if (item) {
          if (item instanceof Widget) {
            item.parent = this;
          } else {
            if (item instanceof Object) {
              item.ref = ref;
            }
            item = this.createWidget(item);
          }
          if (item) {
            item.ref = ref;
            this.addDescendant(item);
            result.push(item);
          }
        }
      }
    }
  }
  onChildAdd(item) {
    if (item.innerItem && this.readOnly && !item.ignoreParentReadOnly) {
      item.readOnly = true;
    }
    this.onChildAddLayout(item);
    if (item.ref || item.id) {
      for (let current = this; current; current = current.parent) {
        current.addDescendant(item);
      }
    }
    this.syncChildCount(true);
  }
  onChildAddLayout(item) {
    if (item.innerItem) {
      this.layout.onChildAdd(item);
    }
  }
  onChildHide(hidden) {
    var _a2;
    super.onChildHide(hidden);
    if ((_a2 = this._items) == null ? void 0 : _a2.includes(hidden)) {
      this.syncChildCount(true);
    }
  }
  onChildShow(shown) {
    var _a2;
    super.onChildShow(shown);
    if ((_a2 = this._items) == null ? void 0 : _a2.includes(shown)) {
      this.syncChildCount(true);
    }
  }
  syncChildCount(enforceHideWhenEmpty) {
    if (!this.isConfiguring) {
      const me = this, {
        // This must be our direct child item payload, not all items owned by this Container.
        // It's used to sync the b-first-visible-child/b-last-visible-child class presence.
        items,
        hasItems
      } = me, visibleItems = items.filter(isNotHidden), { length: visibleLength } = visibleItems;
      me.visibleChildCount = visibleLength;
      if (me.hideWhenEmpty && enforceHideWhenEmpty) {
        const shouldHide = Boolean(!visibleLength);
        if (Boolean(me._hidden) !== shouldHide) {
          me.hidden = shouldHide;
        }
      }
      items.forEach((childItem) => childItem.element.classList.remove("b-last-visible-child", "b-first-visible-child"));
      if (visibleLength) {
        visibleItems[0].element.classList.add("b-first-visible-child");
        visibleItems[visibleLength - 1].element.classList.add("b-last-visible-child");
      }
      me.hasItems = Boolean(me.childItems.length);
      me.contentElement.classList[visibleLength ? "remove" : "add"]("b-no-visible-children");
      if (!me.isComposable) {
        me.updateTextContent(me._textContent);
      } else if (hasItems !== me.hasItems) {
        me.recompose();
      }
    }
  }
  syncFlexDirection() {
    const me = this, { contentElement, flexColCls, flexRowCls } = me, classList = new DomClassList(contentElement.className), styles = DomHelper.getStyleValue(contentElement, stylesToCheck);
    classList[flexRowCls] = classList[flexColCls] = 0;
    if (styles.display === "flex") {
      classList[styles["flex-direction"] === "row" ? flexRowCls : flexColCls] = 1;
    }
    DomHelper.syncClassList(contentElement, classList);
  }
  addDescendant(item) {
    const ref = item.ref || item.id, widgetMap = this._widgetMap || (this._widgetMap = {});
    if (!widgetMap[ref]) {
      widgetMap[ref] = item;
    }
  }
  onChildRemove(item) {
    const me = this, ref = item.ref || item.id;
    if (ref) {
      for (let current = me; current; current = current.parent) {
        if (current.widgetMap[ref] === item) {
          delete current.widgetMap[ref];
        }
      }
    }
    me.layout.onChildRemove(item);
    me.syncChildCount(true);
  }
  /**
   * An object which contains a map of descendant widgets keyed by their {@link Core.widget.Widget#config-ref}.
   * All descendant widgets will be available in the `widgetMap`.
   * @property {Object<String,Core.widget.Widget>}
   * @readonly
   * @category Widget hierarchy
   */
  get widgetMap() {
    if (!this._widgetMap) {
      this._widgetMap = {};
    }
    if (!this.initializingItems) {
      this.getConfig("items");
    }
    return this._widgetMap;
  }
  //region Record & values
  changeRecord(record) {
    this._record = record == null ? emptyObject6 : null;
    return record;
  }
  updateRecord(record) {
    var _a2;
    const me = this;
    (_a2 = me.recordUpdateDetacher) == null ? void 0 : _a2.call(me);
    me.trigger("beforeSetRecord", { record });
    me.setValues(record, {
      onlyName: me.strictRecordMapping,
      highlight: Boolean(me.$highlight)
    });
    if (me.autoUpdateFields && (record == null ? void 0 : record.firstStore)) {
      me.recordUpdateDetacher = record.firstStore.ion({
        update: me.onRecordUpdated,
        thisObj: me
      });
    }
  }
  setRecord(record, highlightChanges) {
    this.$highlight = highlightChanges;
    this.record = record;
    this.$highlight = false;
  }
  onRecordUpdated({ record }) {
    if (record === this.record) {
      this.setValues(this.record, true, true);
    }
  }
  /**
   * A function called by descendant widgets after they trigger their 'change' event, in reaction to field changes.
   * By default, implements the functionality for the `autoUpdateRecord` config.
   *
   * @param {Object} params Normally the event params used when triggering the 'change' event
   * @internal
   */
  onFieldChange({ source, userAction }) {
    if (this.autoUpdateRecord && userAction) {
      const { record, strictRecordMapping } = this, { name, ref, isValid = true, value } = source, key = strictRecordMapping ? name : name || ref;
      if (record && key && isValid) {
        if (record.isModel) {
          record.setValue(key, value);
        } else {
          record[key] = value;
        }
      }
    }
  }
  getValues(filterFn) {
    const values = {};
    this.eachWidget((widget, control) => {
      if (widget.isolateFields) {
        control.down = false;
      } else if ("name" in widget && (!filterFn || filterFn(widget))) {
        values[widget.name] = widget.value;
      }
    }, true);
    return values;
  }
  /**
   * Retrieves or sets all values from/to contained widgets.
   *
   * The property set or read from a contained widget is its {@link Core.widget.Widget#config-defaultBindProperty}.
   *
   * This defaults to the `value` for fields.
   *
   * You may add child widgets which may accept and yield a value to/from another property, such as a `Button` having
   * its {@link Core.widget.Button#config-href} set.
   *
   * Accepts and returns a map, using {@link Core.widget.Field#config-name}, {@link Core.widget.Widget#config-ref} or
   * {@link Core.widget.Widget#config-id} (in that order) as keys.
   *
   * ```javascript
   * const container = new Container({
   *     appendTo : document.body,
   *     items    : {
   *         firstName : {
   *             type : 'textfield
   *         },
   *         surName : {
   *             type : 'textfield
   *         }
   *         saveButton : {
   *             type                : 'button',
   *             text                : 'Save',
   *             defaultBindProperty : 'href'
   *             href                : '#'
   *         }
   *     }
   * });
   *
   * container.values = {
   *     firstName  : 'Clark',
   *     surname    : 'Kent',
   *     saveButton : '#save-route'
   * };
   * ```
   *
   * @property {Object<String,Object>}
   */
  get values() {
    const values = {};
    this.gatherValue(values);
    return values;
  }
  set values(values) {
    this.assignValue(values);
  }
  /**
   * Returns `true` if currently setting values. Allow fields to change highlighting to distinguishing between
   * initially setting values and later on changing values.
   * @property {Boolean}
   */
  get isSettingValues() {
    return Boolean(this.assigningValues);
  }
  get assigningValues() {
    var _a2;
    return this._assigningValues || ((_a2 = this.parent) == null ? void 0 : _a2.assigningValues);
  }
  set assigningValues(v) {
    this._assigningValues = v;
  }
  assignValue(values, options) {
    super.assignValue(values, options);
    if (!this.isolateFields) {
      this.setValues(values, options);
    }
  }
  gatherValue(values) {
    super.gatherValue(values);
    if (!this.isolateFields) {
      this.gatherValues(values);
    }
  }
  setValues(values, options = this.assignValueDefaults) {
    this.assigningValues = options;
    this.eachWidget((widget) => widget.assignValue(values, options), false);
    this.assigningValues = false;
  }
  //endregion
  get hasNoChildren() {
    const me = this, { items, lazyItems } = me.initialConfig, itemsArray = items && (isArray2(items) ? items : ObjectHelper.values(items)), lazyItemsArray = lazyItems && (isArray2(lazyItems) ? lazyItems : ObjectHelper.values(lazyItems)), whichItems = me.isConfiguring ? lazyItemsArray || itemsArray : me.items;
    return !(whichItems == null ? void 0 : whichItems.filter(isNotHidden).length);
  }
  afterRecompose() {
    super.afterRecompose();
    this.realign();
  }
  updateTextContent(textContent) {
    const me = this;
    if (!me.isComposable) {
      const needsClass = Boolean(textContent && me.hasNoChildren), { classList } = me.contentElement, changed = needsClass !== classList.contains("b-text-content");
      if (changed) {
        classList[needsClass ? "add" : "remove"]("b-text-content");
        if (me.rendered) {
          me.realign();
        }
      }
    }
  }
  updateLayoutStyle(layoutStyle) {
    DomHelper.applyStyle(this.contentElement, layoutStyle);
  }
  updateElement(element) {
    super.updateElement(...arguments);
    if (element) {
      const { classList } = this.contentElement, { containerCls } = this.layout;
      classList.add("b-content-element");
      if (containerCls) {
        classList.add(containerCls);
      }
    }
  }
  onInternalPaint() {
    var _a2;
    (_a2 = super.onInternalPaint) == null ? void 0 : _a2.call(this, ...arguments);
    this.getConfig("contentElMutationObserver");
  }
  changeContentElMutationObserver(contentElMutationObserver, oldContentElMutationObserver) {
    if (oldContentElMutationObserver) {
      oldContentElMutationObserver.takeRecords();
      oldContentElMutationObserver.disconnect();
    }
    if (contentElMutationObserver) {
      const me = this, {
        element,
        contentElement
      } = me;
      contentElMutationObserver = new MutationObserver((mutations) => me.onContentElMutation(mutations));
      contentElMutationObserver.observe(contentElement, { attributes: true });
      if (contentElement !== element) {
        contentElMutationObserver.observe(element, { attributes: true });
      }
      me.syncFlexDirection();
    }
    return contentElMutationObserver;
  }
  onContentElMutation(mutations) {
    if (boxLayouts[this.layout.type] && this.isVisible && mutations.some((m) => this.contentElement.contains(m.target))) {
      this.syncFlexDirection();
    }
  }
  changeLayout(config, existingLayout) {
    return Layout.reconfigure(existingLayout, config, {
      owner: this,
      defaults: {
        owner: this
      }
    });
  }
  // Items to iterate over
  get childItems() {
    return this.items;
  }
  /**
   * Returns a directly contained widget by id
   * @param {String} id The widget id
   * @returns {Core.widget.Widget}
   */
  getWidgetById(id) {
    return this.widgetMap[id];
  }
  /**
   * This function is called prior to creating widgets, override it in subclasses to allow containers to modify the
   * configuration of each widget. When adding a widget to a container hierarchy each parent containers
   * `processWidgetConfig` will be called. Returning false from the function prevents the widget from being added at
   * all.
   */
  processWidgetConfig(widget) {
  }
  /**
   * This method combines container {@link #config-defaults}
   * @param {String|ContainerItemConfig} widgetConfig
   * @param {String|Function} [type] The type of widget described by `widgetConfig`.
   * @returns {ContainerItemConfig}
   * @internal
   */
  setupWidgetConfig(widgetConfig, type) {
    const me = this;
    if (typeof widgetConfig === "string") {
      widgetConfig = {
        html: widgetConfig
      };
    } else if (widgetConfig.nodeType === Element.ELEMENT_NODE) {
      widgetConfig = {
        element: widgetConfig,
        id: widgetConfig.id
      };
    }
    if (typeof type === "string" || !type && (type = widgetConfig.type)) {
      if (type === "checkbox" && BrowserHelper.isMobile && Widget.resolveType("slidetoggle", true)) {
        type = widgetConfig.type = "slidetoggle";
      }
      type = Widget.resolveType(type, true);
    }
    widgetConfig = (type || Widget).mergeConfigs(me.defaults, widgetConfig, { parent: me });
    for (let ancestor = widgetConfig.parent; ancestor; ancestor = ancestor.parent) {
      if (ancestor.processWidgetConfig(widgetConfig) === false) {
        return null;
      }
    }
    if (me.trigger("beforeWidgetCreate", { widgetConfig }) === false) {
      return null;
    }
    return widgetConfig;
  }
  /**
   * This function converts a Widget config object into a Widget.
   * @param {ContainerItemConfig} widget A Widget config object.
   * @internal
   */
  createWidget(widget) {
    const result = Widget.create(this.setupWidgetConfig(widget), this.defaultType);
    result && (result._createdBy = this);
    return result;
  }
  // Reapply defaults, not used during config
  updateDefaults(defaults, oldDefaults) {
    if (!this.isConfiguring && defaults) {
      const entries = Object.entries(defaults);
      this.eachWidget((widget) => {
        entries.forEach(([prop, value]) => {
          if (!oldDefaults || widget[prop] === oldDefaults[prop]) {
            widget[prop] = value;
          }
        });
      }, false);
    }
  }
  render() {
    this.getConfig("lazyItems");
    this.layout.renderChildren();
    this.syncChildCount();
    super.render(...arguments);
  }
  get focusElement() {
    const firstFocusable = this.query(this.defaultFocus || ((w) => {
      var _a2;
      return w.isFocusable && w.ref !== "close" && !((_a2 = w.ref) == null ? void 0 : _a2.endsWith("collapse"));
    }));
    if (firstFocusable) {
      return firstFocusable.focusElement;
    }
    return super.focusElement;
  }
  doDestroy() {
    var _a2;
    (_a2 = this._items) == null ? void 0 : _a2.forEach((widget) => {
      var _a3;
      return (_a3 = widget.destroy) == null ? void 0 : _a3.call(widget);
    });
    this.layout.destroy();
    super.doDestroy();
  }
  /**
   * Returns `true` if all contained fields are valid, otherwise `false`
   * @property {Boolean}
   */
  get isValid() {
    let valid = true;
    this.eachWidget((widget) => {
      if (widget.isVisible && "isValid" in widget && !widget.isValid) {
        valid = false;
      }
    }, true);
    return valid;
  }
};
__publicField(Container, "$name", "Container");
__publicField(Container, "type", "container");
Container.initClass();
Container._$name = "Container";

// ../Core/lib/Core/util/Animator.js
var { assign } = ObjectHelper;
var now = () => performance.now();
var nostart = { start: false };
var unitRe = /^[.\d]+([^\d].*)?$/;
var getTransitions = (element) => {
  const $bryntum = element.$bryntum || (element.$bryntum = {});
  return $bryntum.transitions || ($bryntum.transitions = /* @__PURE__ */ Object.create(null));
};
var milliseconds = (duration, unit) => {
  var _a2;
  if (typeof duration === "string") {
    unit = (_a2 = unitRe.exec(duration)) == null ? void 0 : _a2[1];
    duration = parseFloat(duration);
  }
  return duration && duration * (unit === "s" || !unit && duration < 10 ? 1e3 : 1);
};
var syncTransitions = (element) => {
  const all = ObjectHelper.values(getTransitions(element)).filter((a) => a.completed == null).map((a) => a.toString());
  element.style.transition = all.join(", ");
};
var Anim = (Target) => class Anim extends Target {
  static get prototypeProperties() {
    return {
      _delay: null,
      _duration: null,
      _retain: null,
      _timing: null,
      _unit: null,
      owner: null,
      reverting: null
    };
  }
  constructor(...args) {
    super(...args);
    this.id = ++idSeed;
  }
  start() {
    this.startTime = now();
  }
  get delay() {
    var _a2, _b, _c;
    return milliseconds((_c = (_b = this._delay) != null ? _b : (_a2 = this.owner) == null ? void 0 : _a2.delay) != null ? _c : 0, this.unit);
  }
  set delay(v) {
    this._delay = v;
  }
  get duration() {
    var _a2;
    const { owner, unit } = this;
    return milliseconds((_a2 = this._duration) != null ? _a2 : owner ? owner.duration : Animator.defaultDuration, unit);
  }
  set duration(v) {
    this._duration = v;
  }
  get elapsed() {
    return now() - this.startTime;
  }
  get remaining() {
    return this.duration - this.elapsed;
  }
  get retain() {
    var _a2, _b;
    return (_b = this._retain) != null ? _b : (_a2 = this.owner) == null ? void 0 : _a2.retain;
  }
  set retain(v) {
    this._retain = v;
  }
  get timing() {
    var _a2, _b;
    return (_b = this._timing) != null ? _b : (_a2 = this.owner) == null ? void 0 : _a2.timing;
  }
  set timing(v) {
    this._timing = v;
  }
  get unit() {
    var _a2, _b;
    return (_b = this._unit) != null ? _b : (_a2 = this.owner) == null ? void 0 : _a2.unit;
  }
  set unit(v) {
    this._unit = v;
  }
};
var idSeed = 0;
var AnimatorTransition = class _AnimatorTransition extends Base.mixin(Anim) {
  static get $name() {
    return "AnimatorTransition";
  }
  static get prototypeProperties() {
    return {
      element: null,
      property: null,
      from: null,
      to: null,
      completed: null,
      promissory: null,
      reverting: null
    };
  }
  afterConstruct() {
    super.afterConstruct();
    const me = this, { element, transitions } = me;
    let { property } = me;
    [property, me.to] = DomHelper.unitize(property, me.to);
    me.from = DomHelper.unitize(property, me.from)[1];
    me.promissory = new Promissory();
    me.property = property;
    const was = transitions[property];
    transitions[property] = me;
    let { from } = me;
    if (was) {
      me.from = was.to;
      from = null;
      was.destroy();
    }
    if (from === null) {
      from = me.getCurrentStyleValue();
      if (!was) {
        me.from = from;
      }
    }
    element.style[property] = from;
    me.getCurrentStyleValue();
  }
  doDestroy() {
    const me = this;
    me.finish(false);
    if (me.completed && !me.retain) {
      me.clearStyle();
    }
    super.doDestroy();
  }
  get promise() {
    var _a2;
    return (_a2 = this.promissory) == null ? void 0 : _a2.promise;
  }
  get transitions() {
    return getTransitions(this.element);
  }
  clearStyle() {
    this.setStyle("");
  }
  finish(complete) {
    const me = this, { transitions, promissory, property } = me;
    if (promissory) {
      me.completed = complete;
      me.promissory = null;
      promissory.resolve(complete);
      if (transitions[property] === me) {
        delete transitions[property];
        if (!complete) {
          syncTransitions(me.element);
          me.clearStyle();
        }
      } else {
        me.completed = false;
      }
    }
  }
  getCurrentStyleValue() {
    return DomHelper.getStyleValue(this.element, this.property);
  }
  revert() {
    const { duration, elapsed, element, from, property, _retain: retain, _timing: timing } = this;
    return new _AnimatorTransition({
      element,
      property,
      retain,
      timing,
      duration: Math.round(Math.min(duration, elapsed)),
      reverting: this,
      to: from,
      unit: "ms"
    });
  }
  setStyle(value) {
    this.element.style[this.property] = value;
  }
  start() {
    const me = this, { delay, duration, element, property } = me;
    EventHelper.onTransitionEnd({
      element,
      property,
      duration: delay + duration + 20,
      thisObj: me.owner,
      handler: () => {
        var _a2;
        return (_a2 = me.finish) == null ? void 0 : _a2.call(me, true);
      }
      // finish() is gone if destroyed
    });
    super.start();
    me.setStyle(me.to);
  }
  toString() {
    const { delay, duration, property, timing } = this;
    return `${property} ${duration}ms ${timing || "ease-in-out"}${delay ? ` ${delay}ms` : ""}`;
  }
};
AnimatorTransition.initClass();
var Animator = class _Animator extends Base.mixin(Anim) {
  static get $name() {
    return "Animator";
  }
  static get prototypeProperties() {
    return {
      /**
       * The optional delay before starting the animation. Numbers less than 10 are assumed to be seconds
       * (instead of milliseconds) unless the `unit` property is specified.
       * @config {Number|String} delay
       */
      /**
       * The duration of the animation. Numbers less than 10 are assumed to be seconds (instead of milliseconds)
       * unless the `unit` property is specified.
       * @config {Number|String} duration
       * @default
       */
      /**
       * The element to animate.
       * @config {HTMLElement} element
       */
      element: null,
      /**
       * A callback function called when the animation completes. This is called after restoring styles to the
       * original values (based on {@link #config-retain}). When this function is provided, `retain` defaults to
       * `false`. By implementing this function, a CSS class can be applied to the {@link #config-element} to
       * give the proper style, while the inline styles are removed (e.g., a hide animation based on opacity).
       *
       * For example:
       * ```javascript
       *  const anim = Animator.run({
       *      element,
       *      duration : 500,
       *      opacity  : 0,
       *
       *      finalize() {
       *          element.classList.add('hidden');
       *      }
       *  });
       *
       *  await anim.done();
       * ```
       *
       * @config {Function} finalize
       * @returns {void}
       */
      finalize: null,
      /**
       * A callback function called when the animation completes. This is called prior to restoring styles to the
       * original values (based on {@link #config-retain}).
       *
       * @config {Function} prefinalize
       * @returns {void}
       * @internal
       */
      prefinalize: null,
      /**
       * Set to `true` to retain the style property values after the animation. This defaults to `true` if a
       * {@link #config-finalize} function is not specified, and `false` otherwise. When a `finalize` function
       * is provided, it is typically to apply a CSS class to achieve the desired styling so that inline styles
       * can be removed.
       * @config {Boolean} retain
       */
      /**
       * The [timing function](https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function) for
       * the animation.
       * @config {String} timing
       * @default 'ease-in-out'
       */
      /**
       * The duration/delay unit (either `'s'` or `'ms'`).
       * @config {'s'|'ms'} unit
       */
      /**
       * This readonly property is set to `true` when the animation completes or `false` if the animation is
       * aborted (by calling the `destroy()` method).
       * @member {Boolean} completed
       * @readonly
       */
      completed: null,
      /**
       * An array containing a mixture of `Animator` and/or `AnimatorTransition` objects, depending on what was
       * specified at construction time.
       * @member {Core.util.Animator[]|AnimatorTransition[]} items
       * @readonly
       */
      /**
       * When passed at construction time, `items` can be an array of other `Animator` config objects. This can be
       * used to animate multiple elements and wait for this instance to be {@link #function-done done}.
       * @config {Core.util.Animator[]} items
       */
      items: null
    };
  }
  static register(name, fn) {
    if (ObjectHelper.isObject(name)) {
      ObjectHelper.entries(name).forEach((entry) => _Animator.register(...entry));
      return;
    }
    _Animator.fx[name] = fn;
    _Animator[name] = (options) => {
      if (DomHelper.isElement(options)) {
        options = {
          element: options,
          [name]: {}
        };
      } else {
        options = {
          element: options.element,
          [name]: options
        };
        delete options[name].element;
      }
      return _Animator.run(options);
    };
  }
  /**
   * A short-hand way to create an `Animator` instance and call its {@link #function-start} method.
   *
   * ```javascript
   *  const anim = Animator.run({
   *      element,
   *      duration : 500,
   *
   *      // style transitions:
   *      opacity : 0
   *  });
   *
   *  await anim.done();
   * ```
   * @param {Core.util.Animator|AnimatorConfig} options A config object for an `Animator` instance.
   * @returns {Core.util.Animator}
   */
  static run(options) {
    return new _Animator(options).start();
  }
  constructor(options) {
    var _a2;
    super(null);
    const me = this, items = [], properties = {};
    let anim, fx, key, t;
    if (Array.isArray(options)) {
      me.items = options;
    } else {
      for (key in options) {
        (_Animator.specialPropsRe.test(key) ? me : properties)[key] = options[key];
      }
    }
    ObjectHelper.keys(properties).forEach((property) => {
      t = properties[property];
      if (t != null && t !== false && t === t) {
        if (!(fx = _Animator.fx[property])) {
          t = assign(me.defaults, typeof t === "object" ? t : { to: t });
          t.owner = me;
          t.property = property;
          anim = new AnimatorTransition(t);
        } else {
          t = assign(me.defaults, fx(t, me, property));
          t.owner = me;
          anim = new _Animator(t);
        }
        items.push(anim);
      }
    });
    (_a2 = me.items) == null ? void 0 : _a2.forEach((item) => {
      if (ObjectHelper.isInstantiated(item)) {
        item.owner = me;
      } else {
        item = assign(me.defaults, item);
        item.owner = me;
        item = new _Animator(item);
      }
      items.push(item);
    });
    me.items = items;
    me.promise = (items.length === 1 ? items[0].promise : Promise.all(items.map((it) => it.promise))).then((res) => {
      var _a3;
      (_a3 = me.finish) == null ? void 0 : _a3.call(me, res);
      return me.completed || false;
    });
  }
  doDestroy() {
    this.items.forEach((a) => a.destroy());
    super.doDestroy();
  }
  get defaults() {
    return {
      element: this.element
    };
  }
  get retain() {
    const { _retain, finalize, owner } = this;
    return _retain != null ? _retain : finalize ? false : owner ? owner.retain : true;
  }
  set retain(v) {
    super.retain = v;
  }
  /**
   * Returns a `Promise` that resolves to a `Boolean` when this animation completes. The resolved value is that of
   * this instance's {@link #property-completed} property.
   * @async
   */
  done() {
    return this.promise;
  }
  finish(complete) {
    var _a2, _b;
    const me = this, { items } = me;
    syncTransitions(me.element);
    me.completed = typeof complete === "boolean" ? complete : !complete.some((a) => !a);
    (_a2 = me.prefinalize) == null ? void 0 : _a2.call(me, me.completed, me);
    while (items.length) {
      items.pop().destroy();
    }
    (_b = me.finalize) == null ? void 0 : _b.call(me, me.completed, me);
  }
  revert(options) {
    var _a2;
    const me = this, { reverting } = me, start = !options || ((_a2 = options.start) != null ? _a2 : true);
    let anim = me.defaults;
    if (reverting) {
      if (reverting.finalize) {
        anim.finalize = reverting.finalize;
      }
      if (reverting.prefinalize) {
        anim.prefinalize = reverting.prefinalize;
      }
      anim.retain = reverting._retain;
    }
    anim = assign(anim, options, {
      items: me.items.map((it) => it.revert(nostart)),
      reverting: me
    });
    anim = new _Animator(anim);
    start && anim.start();
    return anim;
  }
  /**
   * Starts this animation and returns a reference to itself. This method is called automatically by the
   * {@link #function-run-static} method.
   * @returns {Core.util.Animator}
   */
  start() {
    const { element, items } = this;
    super.start();
    if (items.length) {
      syncTransitions(element);
      items.forEach((a) => a.start());
    }
    return this;
  }
};
Animator.initClass().Transition = AnimatorTransition;
Animator.specialPropsRe = new RegExp(`^(?:${Object.keys(Animator.prototypeProperties).concat(
  Object.keys(Animator.superclass.prototypeProperties)
).map((s) => s[0] === "_" ? s.substr(1) : s).join("|")})$`);
Animator.defaultDuration = 200;
Animator.fx = {};
Animator.register({
  /**
   * A compound animation to achieve `transform: scale()` and `opacity: 0`. The `scale` defaults to 8 but can be set
   * in the `anim` config object.
   *
   * For example
   * ```javascript
   *  const puff = Animator.puff(element);
   *
   *  const puff = Animator.puff({
   *      element,
   *      scale : 12
   *  });
   * ```
   *
   * This compound animation can also be specified in an `Animator` config object along with other style transitions:
   * ```javascript
   *  const anim = Animator.run({
   *      element,
   *      marginLeft : -200,
   *      puff       : true   // true for default scale, a number, or config object
   *  });
   * ```
   * @param {Element|AnimatorConfig|Core.util.Animator} anim The element to animate or the config object containing at least
   * the `element` property. This config object can contain an optional `scale` property to adjust the animation's
   * `transform: scale()` value.
   * @param {Number} [anim.scale=8] The scale value for the `transform:scale()` transition.
   * @returns {Core.util.Animator}
   * @static
   */
  puff(anim) {
    if (anim === true) {
      anim = {};
    } else if (typeof anim !== "object") {
      anim = {
        transform: `scale(${anim})`
      };
    } else if (anim.scale) {
      anim = ObjectHelper.clone(anim);
      anim.transform = `scale(${anim.scale})`;
      delete anim.scale;
    }
    return assign({
      opacity: 0,
      transform: "scale(8)"
    }, anim);
  }
});
Animator._$name = "Animator";

// ../Core/lib/Core/util/ClickRepeater.js
var ClickRepeater = class extends Base.mixin(Delayable_default) {
  static get configurable() {
    return {
      /**
       * The element on which to fire autorepeating `click` events when the mouse is held down.
       * @config {HTMLElement}
       */
      element: null,
      /**
       * A query selector which specifies subtargets of this ClickRepeater's {@link #config-element}
       * which act as the click auto repeat event targets.
       * @config {String}
       * @default
       */
      delegate: null,
      /**
       * How long in milliSeconds to pause before starting the click repeats.
       * @config {Number}
       * @default
       */
      delay: 500,
      /**
       * Clicks per second to start firing after the initial {@link #config-delay}
       * @config {Number}
       * @default
       */
      startRate: 2,
      /**
       * Clicks per second to fire at top speed, after accelerating over the {@link #config-accelerateDuration}
       * @config {Number}
       * @default
       */
      endRate: 20,
      /**
       * How long in milliseconds to accelerate from the
       * {@link #config-startRate} to the {@link #config-startRate}.
       * @config {Number}
       * @default
       */
      accelerateDuration: 4e3,
      pressedCls: "b-pressed"
    };
  }
  doDestroy() {
    var _a2;
    (_a2 = this.mousedownRemover) == null ? void 0 : _a2.call(this);
    this.cancel();
    super.doDestroy();
  }
  cancel() {
    var _a2, _b, _c;
    const me = this;
    (_a2 = me.activeElement) == null ? void 0 : _a2.classList.remove(me.pressedCls);
    me.activeElement = null;
    (_b = me.acceleration) == null ? void 0 : _b.cancel();
    me.activeListenerRemover = (_c = me.activeListenerRemover) == null ? void 0 : _c.call(me);
    me.clearTimeout(me.autoRepeatTimer);
    me.clearTimeout(me.repeatTimer);
  }
  updateElement(element) {
    var _a2;
    (_a2 = this.mousedownRemover) == null ? void 0 : _a2.call(this);
    this.mousedownRemover = EventHelper.on({
      element,
      mousedown: "onMouseDown",
      thisObj: this
    });
  }
  onMouseDown(e) {
    const me = this, target = me.delegate ? e.target.closest(me.delegate) : me.element;
    me.cancel();
    if (target) {
      me.activeElement = target;
      me.triggerEvent = e;
      target.classList.add(me.pressedCls);
      me.activeListenerRemover = EventHelper.on({
        mouseup: {
          element: document,
          capture: true,
          handler: "onMouseUp"
        },
        mousemove: {
          element: target,
          handler: "onTargetMouseMove"
        },
        mouseleave: {
          element: target,
          handler: "onTargetMouseLeave"
        },
        mouseenter: {
          element: target,
          handler: "onTargetMouseEnter"
        },
        thisObj: me
      });
      me.autoRepeatTimer = me.setTimeout("startAutoRepeat", me.delay);
    }
  }
  onMouseUp() {
    this.cancel();
  }
  onTargetMouseLeave() {
    this.activeElement.classList.remove(this.pressedCls);
    this.clearTimeout(this.repeatTimer);
  }
  onTargetMouseEnter(e) {
    const me = this;
    if (!e.buttons) {
      me.cancel();
    } else {
      me.activeElement.classList.add(me.pressedCls);
      me.triggerEvent = e;
      me.fireClick();
    }
  }
  onTargetMouseMove(e) {
    this.triggerEvent = e;
  }
  startAutoRepeat() {
    const me = this;
    me.interval = me.startInterval = 1e3 / me.startRate;
    me.accelerationDelta = me.startInterval - 1e3 / me.endRate;
    me.fireClick();
    me.acceleration = FunctionHelper.animate(me.accelerateDuration, me.nextTick, me, "easeOutQuad");
  }
  nextTick(progress) {
    this.interval = this.startInterval - this.accelerationDelta * progress;
  }
  fireClick() {
    const me = this, clickEvent = new MouseEvent("click", me.triggerEvent);
    me.triggerEvent.target.dispatchEvent(clickEvent);
    me.repeatTimer = me.setTimeout(me.fireClick, me.interval);
  }
};
ClickRepeater._$name = "ClickRepeater";

// ../Core/lib/Core/widget/mixin/Rotatable.js
var autoRotateRe = /^(?:undefined|null|LEFT|RIGHT)$/;
var inverted = {
  TOP: "BOTTOM",
  RIGHT: "LEFT",
  BOTTOM: "TOP",
  LEFT: "RIGHT"
};
var canonicalDock = (dock) => {
  const DOCK = dock == null ? void 0 : dock.toUpperCase();
  return [DOCK, DOCK === "LEFT" || DOCK === "RIGHT"];
};
var Rotatable_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    static get configurable() {
      return {
        /**
         * Set to `'left'` to rotate the button content 90 degrees counter-clockwise or `'right'` for clockwise.
         * @member {'left'|'right'} rotate
         */
        /**
         * Specify `'left'` to rotate the button content 90 degrees counter-clockwise or `'right'` for clockwise.
         * @config {'left'|'right'}
         */
        rotate: null,
        invertRotate: null
      };
    }
    compose() {
      const { rotate } = this;
      return {
        class: {
          [`b-rotate-${(rotate || "").toLowerCase()}`]: rotate,
          "b-rotate-vertical": rotate
        }
      };
    }
    syncRotationToDock(dock) {
      if (autoRotateRe.test(String(this.rotate))) {
        const [DOCK, vertical] = canonicalDock(dock);
        this.rotate = vertical ? this.invertRotate ? inverted[DOCK] : DOCK : null;
      }
    }
    get widgetClass() {
      return null;
    }
  }, __publicField(_a2, "$name", "Rotatable"), _a2;
};

// ../Core/lib/Core/widget/Tool.js
var Tool = class extends Widget.mixin(Rotatable_default) {
  compose() {
    const { align, href } = this;
    return {
      tag: href != null ? "a" : "button",
      class: {
        [`b-align-${align || "end"}`]: 1,
        "b-icon": 1
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: "onInternalClick"
      }
    };
  }
  get focusElement() {
    return this.element;
  }
  get panel() {
    var _a2, _b;
    if (((_a2 = this.parent) == null ? void 0 : _a2.isPanel) && ((_b = this.element) == null ? void 0 : _b.parentNode.matches(".b-panel-header"))) {
      return this.parent;
    }
  }
  changeAlign(align) {
    return align;
  }
  onInternalClick(domEvent) {
    const me = this, { handler, panel } = me, bryntumEvent = { domEvent, tool: me };
    if (me.disabled) {
      return;
    }
    me.trigger("click", bryntumEvent);
    if (!me.isDestroyed) {
      me.trigger("action", bryntumEvent);
      if (!me.isDestroyed && (panel == null ? void 0 : panel.trigger("toolClick", bryntumEvent)) !== false) {
        handler && me.callback(handler, panel, [domEvent, panel, me]);
      }
    }
  }
  onInternalKeyDown(keyEvent) {
    const keyName = keyEvent.key.trim() || keyEvent.code;
    if (keyName === "Enter") {
      keyEvent.cancelBubble = true;
      keyEvent.stopPropagation();
    }
  }
  updateDisabled(disabled, was) {
    var _a2;
    super.updateDisabled(disabled, was);
    disabled && ((_a2 = this.repeat) == null ? void 0 : _a2.cancel());
  }
  changeRepeat(repeat, oldRepeat) {
    oldRepeat == null ? void 0 : oldRepeat.destroy();
    return repeat && ClickRepeater.new({
      element: this.element
    }, repeat);
  }
};
__publicField(Tool, "$name", "Tool");
__publicField(Tool, "type", "tool");
__publicField(Tool, "configurable", {
  /**
   * Specify `'start'` to place the tool before the owner's central element (e.g., the `title` of the panel).
   * @config {'start'|'end'}
   * @default 'end'
   * @category Float & align
   */
  align: {
    value: null,
    $config: {
      merge: "replace"
    }
  },
  /**
   * If provided, turns the tool into a link
   * @config {String}
   */
  href: null,
  /**
   * The function to call when this tool is clicked. May be a function or function name
   * prepended by `"up."` that is resolvable in an ancestor component (such as an owning
   * Grid, Scheduler, Calendar, Gantt or TaskBoard)
   *
   * @config {Function|String} handler
   * @param {Event} handler.event The DOM event which activated the tool
   * @param {Core.widget.Panel} handler.panel The owning Panel of the tool
   * @param {Core.widget.Tool} handler.tool The clicked Tool
   * @returns {void}
   */
  /**
   * A {@link Core.util.ClickRepeater } config object to specify how click-and-hold gestures repeat the click
   * action.
   * @config {ClickRepeaterConfig}
   */
  repeat: null,
  defaultBindProperty: null
});
Tool.initClass();
Tool._$name = "Tool";

// ../Core/lib/Core/widget/panel/CollapseTool.js
var rightRe = /right/i;
var autoAlign = (tool) => (tool.collapsed || tool.collapsing) && // special case to align the expand tool with the collapse tool
tool.owner.expandedHeaderDock === "top" && tool.owner.collapsible.direction.match(rightRe) ? "start" : "end";
var CollapseTool = class extends Tool {
  static get configurable() {
    return {
      /**
       * Set to `false` to disable automatic adjustment of the {@link #config-align} config based on the state
       * of the panel's {@link Core.widget.Panel#config-collapsed} config and the
       * {@link Core.widget.panel.PanelCollapser#config-direction}.
       *
       * If this is set to a function, that function is called passing the owning `Panel` instance and its
       * return value is assigned to the {@link #config-align} config.
       *
       * @config {Boolean|Function}
       * @param {Core.widget.Panel} owner The owning `Panel` instance
       * @returns {Boolean} Auto align value
       * @default
       */
      autoAlign: true,
      collapsed: null,
      collapsing: null,
      collapsify: false,
      // ...unaffected when the panel is collapsed
      direction: "up",
      // Our own setValues/getValues system should not set/get HTML content
      defaultBindProperty: null
    };
  }
  compose() {
    const { collapsed, direction } = this;
    return {
      class: {
        [`b-icon-collapse-${direction}`]: 1,
        "b-collapsed": collapsed
      }
    };
  }
  changeAutoAlign(v) {
    return v === true ? autoAlign : v;
  }
  syncAutoAlign() {
    const { autoAlign: autoAlign2 } = this;
    if (autoAlign2) {
      this.align = autoAlign2(this);
    }
  }
  updateAutoAlign() {
    this.syncAutoAlign();
  }
  updateCollapsed() {
    this.syncAutoAlign();
  }
  updateCollapsing() {
    this.syncAutoAlign();
  }
  updateDirection() {
    this.syncAutoAlign();
  }
};
__publicField(CollapseTool, "$name", "CollapseTool");
__publicField(CollapseTool, "type", "collapsetool");
CollapseTool.initClass();
CollapseTool._$name = "CollapseTool";

// ../Core/lib/Core/widget/panel/PanelCollapser.js
var defaultedDirectionRe = /^(?:UP|DOWN|LEFT|RIGHT)$/;
var dockBeforeRe = /^(left|top)$/i;
var emptyObject7 = {};
var headerDockRe = /^b-dock-(top|left|right|bottom)$/;
var revealerCls = "b-panel-collapse-revealer";
var sideDockRe = /^(?:left|right)$/i;
var unflexCls = "b-collapse-unflex";
var { round } = Math;
var canonicalDirection = ["up", "down", "left", "right"].reduce((o, v) => {
  o[v.toUpperCase()] = o[v] = v;
  return o;
}, {});
var clipByDock = {
  top: ["top", "bottom"],
  right: ["right", "left"],
  bottom: ["bottom", "top"],
  left: ["left", "right"]
};
var collapseDirectionByPlacement = {
  hl: "LEFT",
  hr: "RIGHT",
  vb: "DOWN",
  vt: "UP"
};
var crossAxis = {
  h: "w",
  w: "h"
};
var dockByDirection = {
  up: "top",
  right: "right",
  down: "bottom",
  left: "left"
};
var dockIsHorz = {
  top: false,
  right: true,
  bottom: false,
  left: true
};
var directionByDock = {
  top: "UP",
  right: "RIGHT",
  bottom: "DOWN",
  left: "LEFT"
};
var transverseTransform = {
  top: (rect) => `translate(0, -${round(rect.height || 0)}px)`,
  bottom: (rect) => `translate(0, ${round(rect.height || 0)}px)`,
  right: (rect) => `translate(${round(rect.width || 0)}px, 0)`,
  left: (rect) => `translate(-${round(rect.width || 0)}px, 0)`
};
var idSeed2 = 0;
var PanelCollapser = class extends Base.mixin(Factoryable_default) {
  static get configurable() {
    return {
      /**
       * An animation config object.
       * @config {Object} animation
       * @property {Number} [animation.duration=200] The duration of the animation (in milliseconds).
       */
      animation: {
        duration: 200
      },
      /**
       * Tracks whether or not the panel is collapsed.
       * @config {Boolean}
       * @private
       */
      collapsed: {
        value: null,
        $config: null,
        default: false
      },
      /**
       * Specifies the direction of panel collapse. The default value for this config is determined dynamically
       * based on the {@link Core.widget.Panel#config-header header's} `dock` property and the containing layout's
       * flex direction and, therefore, often does not need to be explicitly specified.
       *
       * This config can be any of the following:
       * - `'up'`
       * - `'down'`
       * - `'left'`
       * - `'right'`
       *
       * @config {'up'|'down'|'left'|'right'}
       */
      direction: null,
      /**
       * The tooltip to use for the collapse tool when the panel is expanded.
       * @config {String}
       */
      collapseTooltip: "L{Collapse}",
      /**
       * The tooltip to use for the expand tool when the panel is collapsed.
       * @config {String}
       */
      expandTooltip: "L{Expand}",
      panel: {
        value: null,
        $config: "nullify"
      },
      /**
       * To support the panel's collapsed size, a minimum width and height may be assigned to the panel's header,
       * based on this config and the panel's positioning style.
       *
       * When a panel is collapsed it may need to retain the pre-collapse dimension perpendicular to the collapse
       * {@link #config-direction}. For example, the height of a panel that collapses to the left. The dimension
       * parallel to the collapse (the width in this example) may also need to be supported using the pre-collapse
       * size of the panel's header.
       *
       * When this config is set to `true`, or by default when the owning panel is `position: absolute`, both
       * axes are given a minimum size based on the panel's pre-collapse size. When this config is `false`, no
       * minimum sizes will be assigned.
       *
       * This config can also be a string containing the single letters 'w' and/or 'h' indicating which axis/axes
       * of the panel header should be assigned a minimum size. That is, 'w' to assign only a minimum width, 'h'
       * for only a minimum height, or 'wh' to assign both.
       *
       * @config {String|Boolean}
       * @internal
       */
      supportAxis: null,
      /**
       * The collapse/expand tool. The `type` of this instance should not be changed but the tool instance can be
       * configured in other ways via this config property.
       * @config {ToolConfig|Core.widget.Tool}
       */
      tool: {
        type: "collapsetool",
        handler(ev) {
          var _a2;
          (_a2 = this.collapsible) == null ? void 0 : _a2.onCollapseClick(ev);
        }
      }
    };
  }
  static get factoryable() {
    return {
      defaultType: "inline"
    };
  }
  get collapsing() {
    return this.collapsingExpanding === "collapsing";
  }
  get collapsingExpanding() {
    var _a2;
    const state = (_a2 = this.currentOperation) == null ? void 0 : _a2.collapsing;
    return state == null ? null : state ? "collapsing" : "expanding";
  }
  get currentDock() {
    var _a2, _b, _c, _d;
    return (_d = (_c = (_b = (_a2 = this.panel) == null ? void 0 : _a2.header) == null ? void 0 : _b.dock) == null ? void 0 : _c.toLowerCase()) != null ? _d : "top";
  }
  get expanding() {
    return this.collapsingExpanding === "expanding";
  }
  get collapseTool() {
    var _a2, _b;
    return (_b = (_a2 = this.panel) == null ? void 0 : _a2.tools) == null ? void 0 : _b.collapse;
  }
  get collapseDim() {
    return sideDockRe.test(this.collapseDir) ? "width" : "height";
  }
  getCollapseDir(canonical) {
    var _a2;
    let { direction, panel } = this;
    if (!direction || defaultedDirectionRe.test(direction)) {
      const placement = panel == null ? void 0 : panel.placement;
      if (placement) {
        direction = collapseDirectionByPlacement[placement];
      } else {
        direction = directionByDock[((_a2 = panel == null ? void 0 : panel.header) == null ? void 0 : _a2.dock) || "top"];
      }
    }
    return canonical ? canonicalDirection[direction] : direction;
  }
  get collapseDir() {
    return this.getCollapseDir(true);
  }
  get collapseDock() {
    return this.collapseInfo[0];
  }
  get collapseInfo() {
    const { panel } = this, headerDock2 = panel.hasHeader && panel.expandedHeaderDock;
    let dock = dockByDirection[this.collapseDir], transverse = false;
    if (headerDock2) {
      if (!(transverse = dockIsHorz[dock] !== dockIsHorz[headerDock2])) {
        dock = headerDock2;
      }
    }
    return [dock, transverse];
  }
  get toolsConfig() {
    const { direction, tool } = this;
    return tool && {
      collapse: ObjectHelper.assign({
        direction: direction.toLowerCase()
      }, tool)
    };
  }
  beforeCollapse(operation) {
    const { panel } = this, { element } = panel;
    if (element.contains(DomHelper.getActiveElement(element))) {
      panel.revertFocus(true);
    }
  }
  changeTool(tool) {
    const me = this, { panel } = me;
    if (me.isConfiguring || me.isDestroying || !panel || panel.isDestroying) {
      return tool;
    }
    panel.tools = {
      collapse: tool
    };
  }
  collapse(collapsed) {
    var _a2, _b;
    const me = this, { panel } = me, operation = {
      id: ++idSeed2,
      completed: false,
      panel
    };
    let { currentOperation } = me;
    collapsed = collapsed != null ? collapsed : true;
    if (ObjectHelper.isObject(collapsed)) {
      operation.collapsed = true;
      ObjectHelper.assign(operation, collapsed);
      collapsed = operation.collapsed;
      delete operation.collapsed;
    }
    operation.collapsing = collapsed;
    operation.previous = currentOperation != null ? currentOperation : null;
    if (collapsed !== me.collapsed) {
      if (currentOperation) {
        if (currentOperation.collapsing !== collapsed) {
          operation.animation = currentOperation.animation.revert({
            finalize() {
              var _a3;
              (_a3 = me.collapseFinalize) == null ? void 0 : _a3.call(me, operation, true);
            }
          });
          operation.collapsing = collapsed;
          currentOperation = operation;
        }
      } else {
        operation.animation = ObjectHelper.clone(("animation" in operation ? operation : me).animation);
        if (me.beforeCollapse(operation) !== false) {
          if (operation.animation) {
            operation.animation.finalize = (complete) => {
              var _a3;
              return (_a3 = me.collapseFinalize) == null ? void 0 : _a3.call(me, operation, complete);
            };
          }
          panel.changingCollapse = true;
          me[collapsed ? "collapseBegin" : "expandBegin"](operation);
          if (operation.animation) {
            currentOperation = operation;
          } else {
            operation.completed = true;
            me[collapsed ? "collapseEnd" : "expandEnd"](operation);
          }
          panel.changingCollapse = false;
          if (!operation.animation) {
            me.onComplete(collapsed ? "collapse" : "expand");
          }
        }
      }
    } else if (currentOperation && currentOperation.collapsing !== collapsed) {
      me[collapsed ? "expandRevert" : "collapseRevert"](operation);
      operation.animation = currentOperation.animation.revert({
        finalize() {
          var _a3;
          (_a3 = me.collapseFinalize) == null ? void 0 : _a3.call(me, operation, false);
        }
      });
      currentOperation = operation;
    }
    me.currentOperation = currentOperation;
    return (_b = (_a2 = currentOperation == null ? void 0 : currentOperation.animation) == null ? void 0 : _a2.done()) != null ? _b : Promise.resolve(collapsed === me.collapsed);
  }
  collapseFinalize(operation, complete) {
    const me = this, { currentOperation, panel } = me, action = panel.collapsed ? "expand" : "collapse";
    if (currentOperation === operation) {
      me.currentOperation = null;
      operation.completed = complete;
      panel.changingCollapse = true;
      me[action + "End"](operation);
      panel.changingCollapse = false;
      complete && me.onComplete(action);
    }
  }
  applyHeaderDock(collapsed, flush = true) {
    const me = this, { currentDock, panel } = me, dock = collapsed ? me.collapseDock : panel.expandedHeaderDock;
    if (dock !== currentDock && panel.hasHeader) {
      panel.header = {
        dock
      };
      flush && panel.recompose.flush();
    }
  }
  composeHeader(header) {
    const { panel } = this, { class: cls } = header, dock = panel.expandedHeaderDock || Object.keys(cls).filter((k) => cls[k] && headerDockRe.test(k)).map((k) => headerDockRe.exec(k)[1][0]);
    cls[revealerCls] = 1;
    cls[`b-collapsible-${dock[0]}${this.collapseDir[0]}`] = 1;
    return header;
  }
  composeTitle(title) {
    title.class[revealerCls] = 1;
    return title;
  }
  collapseBegin(operation) {
    var _a2;
    const me = this, { animation } = operation, { collapseDim, collapseTool, panel } = me, { element, placement } = panel, [collapseDock, transverse] = me.collapseInfo, collapseToolClasses = collapseTool == null ? void 0 : collapseTool.element.classList, unflex = !placement || placement[0] === "h" && collapseDim === "width" || placement[0] === "v" && collapseDim === "height";
    me.configuredWidth = panel._lastWidth;
    me.configuredHeight = panel._lastHeight;
    me.transverseCollapse = transverse;
    me.applyHeaderDock(true);
    const panelRect = panel.rectangle(), bodyWrapRect = me.lockInnerSize().moveTo(0, 0), bodyWrapClipRect = bodyWrapRect.clone(), clipDir = clipByDock[collapseDock], headerRect = (_a2 = panel.headerElement) == null ? void 0 : _a2.getBoundingClientRect(), collapsedSize = round((headerRect == null ? void 0 : headerRect[collapseDim]) || 0);
    element.classList.toggle(unflexCls, unflex);
    if (animation) {
      bodyWrapClipRect[clipDir[0]] = bodyWrapClipRect[clipDir[1]];
      element.classList.add("b-collapsing");
      collapseToolClasses == null ? void 0 : collapseToolClasses.add("b-collapsed", "b-collapsing");
      if (collapseTool) {
        collapseTool.collapsing = true;
      }
      if (collapseToolClasses) {
        collapseToolClasses.remove("b-collapsed");
        panel.rectangle();
        collapseToolClasses.remove("b-collapsing");
        collapseToolClasses.add("b-collapsed");
      }
      animation.element = element;
      animation.retain = true;
      animation[collapseDim] = {
        from: round(panelRect[collapseDim]),
        to: collapsedSize
      };
      animation.items = [{
        element: me.innerElement,
        retain: false,
        clip: {
          from: `rect(${bodyWrapRect})`,
          to: `rect(${bodyWrapClipRect})`
        }
      }];
      if (transverse) {
        animation.items.push({
          element: panel.headerElement,
          duration: animation.duration,
          retain: false,
          transform: {
            from: transverseTransform[collapseDock](headerRect),
            to: `translate(0, 0)`
          }
        });
      }
      operation.animation = Animator.run(animation);
    } else {
      element.style[collapseDim] = `${collapsedSize}px`;
      if (collapseTool) {
        collapseToolClasses.add("b-collapsing", "b-collapsed");
        collapseTool.rectangle();
        collapseToolClasses.remove("b-collapsing");
      }
    }
  }
  collapseEnd(operation) {
    const me = this, { collapseTool } = me;
    me.panel.element.classList.remove("b-collapsing");
    if (collapseTool) {
      collapseTool.collapsing = false;
    }
    if (operation.completed) {
      me.collapsed = true;
    } else {
      me.applyHeaderDock(false);
      me.restoreConfiguredSize();
      me.lockInnerSize(false);
    }
  }
  collapseRevert(operation) {
    var _a2;
    (_a2 = this.collapseTool) == null ? void 0 : _a2.element.classList.remove("b-collapsed");
  }
  expandBegin(operation) {
    const me = this, { animation } = operation, { collapseDim, collapseTool, panel } = me, [collapseDock, transverse] = me.collapseInfo, { element } = panel, elementClassList = element.classList, unflex = elementClassList.contains(unflexCls), fromRect = panel.rectangle();
    elementClassList.remove("b-collapsed", "b-collapsing");
    panel.element.style[collapseDim] = "";
    me.restoreConfiguredSize();
    me.lockInnerSize(false);
    const toRect = panel.rectangle(), bodyWrapRect = me.lockInnerSize().moveTo(0, 0), bodyWrapClipRect = bodyWrapRect.clone(), clipDir = clipByDock[me.collapseDock];
    collapseTool == null ? void 0 : collapseTool.element.classList.remove("b-collapsed");
    if (animation) {
      bodyWrapClipRect[clipDir[0]] = bodyWrapClipRect[clipDir[1]];
      elementClassList.add("b-collapsed", "b-expanding");
      unflex && elementClassList.add(unflexCls);
      animation.element = element;
      animation[collapseDim] = {
        from: round(fromRect[collapseDim]),
        to: round(toRect[collapseDim])
      };
      animation.items = [{
        element: me.innerElement,
        retain: false,
        clip: {
          from: `rect(${bodyWrapClipRect})`,
          to: `rect(${bodyWrapRect})`
        }
      }];
      if (transverse) {
        animation.items.push({
          element: panel.headerElement,
          duration: animation.duration,
          retain: false,
          transform: {
            from: `translate(0, 0)`,
            to: transverseTransform[collapseDock](fromRect)
          }
        });
      }
      operation.animation = Animator.run(animation);
    }
  }
  expandEnd(operation) {
    const me = this;
    me.panel.element.classList.remove("b-expanding");
    if (operation.completed) {
      me.collapsed = false;
      me.applyHeaderDock(false);
      me.restoreConfiguredSize();
      me.lockInnerSize(false);
    }
  }
  expandRevert(operation) {
    var _a2;
    (_a2 = this.collapseTool) == null ? void 0 : _a2.element.classList.add("b-collapsed");
  }
  get innerElement() {
    return this.panel.collapseWrapElement || this.panel.bodyWrapElement;
  }
  get innerSizeElement() {
    return this.transverseCollapse ? this.panel.element : this.innerElement;
  }
  get supportAxis() {
    let { _supportAxis } = this;
    const fullSupport = _supportAxis === true;
    if (fullSupport || _supportAxis == null) {
      _supportAxis = this.collapseDim[0];
      if (fullSupport || DomHelper.getStyleValue(this.panel.element, "position") === "absolute") {
        _supportAxis += crossAxis[_supportAxis];
      }
    }
    return _supportAxis || "";
  }
  lockInnerSize(lock = true) {
    const me = this, { innerElement, panel } = me, supportAxis = lock ? me.supportAxis : "", panelEl = panel.element, headerEl = panel.headerElement, headerRect = lock && headerEl && Rectangle.from(headerEl, panelEl), innerRect = lock && Rectangle.from(me.innerSizeElement, panelEl), innerStyle = innerElement.style;
    if (headerEl) {
      headerEl.style.minWidth = supportAxis.includes("w") ? `${headerRect.width}px` : "";
      headerEl.style.minHeight = supportAxis.includes("h") ? `${headerRect.height}px` : "";
    }
    innerStyle.width = lock ? `${innerRect.width}px` : "";
    innerStyle.height = lock ? `${innerRect.height}px` : "";
    innerElement.classList[lock ? "add" : "remove"]("b-panel-collapse-size-locker");
    return innerRect;
  }
  onCollapseClick(e) {
    let collapsed = this.collapsing ? false : this.expanding ? true : !this.collapsed;
    if (e.altKey) {
      collapsed = {
        animation: null,
        collapsed
      };
    }
    this.collapse(collapsed);
  }
  onComplete(action) {
    var _a2;
    (_a2 = this.panel) == null ? void 0 : _a2.trigger(action);
  }
  onHeaderClick({ event }) {
    if (event.button === 0 && this.panel.collapsed && event.target.classList.contains(revealerCls)) {
      this.onRevealerClick();
    }
  }
  onPanelConfigChange({ name, value }) {
    const me = this, { panel } = me;
    if (name === "collapsed") {
      if (panel.isPainted) {
        me.collapsed = value;
      }
    } else if (name === "header" && !panel.changingCollapse) {
      me.syncDirection();
    }
  }
  onPanelPaint() {
    this.syncDirection();
    if (this.panel.collapsed && !this.collapsed) {
      this.collapse({
        animation: null,
        collapsed: true
      });
    }
  }
  onRevealerClick() {
    this.panel._collapse({ collapsed: false });
  }
  restoreConfiguredSize(which) {
    const { configuredHeight, configuredWidth, panel } = this;
    which = which != null ? which : "wh";
    panel.element.classList.remove(unflexCls);
    if (configuredWidth != null && which.includes("w")) {
      panel.width = configuredWidth;
    }
    if (configuredHeight != null && which.includes("h")) {
      panel.height = configuredHeight;
    }
  }
  splitHeaderItems({ as, dock } = emptyObject7) {
    var _a2;
    return (_a2 = this.panel) == null ? void 0 : _a2.splitHeaderItems({ as, dock, alt: true });
  }
  syncDirection() {
    const me = this, { direction } = me;
    if (!direction || defaultedDirectionRe.test(direction)) {
      me.direction = me.getCollapseDir();
    }
  }
  changeCollapsed(collapsed) {
    return Boolean(collapsed);
  }
  updateCollapsed(collapsed) {
    const { collapseTool, panel } = this;
    if (panel) {
      panel.collapsed = collapsed;
      panel.element.classList[collapsed ? "add" : "remove"]("b-collapsed");
    }
    if (collapseTool) {
      collapseTool.collapsed = collapsed;
    }
  }
  updateDirection(direction) {
    const { collapseTool, panel } = this;
    if (collapseTool) {
      collapseTool.direction = canonicalDirection[direction];
    }
    if (panel == null ? void 0 : panel.rendered) {
      panel.recompose();
    }
  }
  updatePanel(panel) {
    var _a2;
    const me = this;
    me.syncDirection();
    (_a2 = me.panelChangeDetacher) == null ? void 0 : _a2.call(me);
    me.panelChangeDetacher = panel && FunctionHelper.after(panel, "onConfigChange", "onPanelConfigChange", me, {
      return: false
    });
  }
  wrapCollapser(key, body) {
    var _a2;
    const me = this, [collapseDock, transverse] = me.collapseInfo;
    if (!transverse) {
      return [key, body];
    }
    const { collapseDir, panel } = me, { expandedHeaderDock, header: panelHeader, uiClassList } = panel, recollapse = (_a2 = panel.tools) == null ? void 0 : _a2.recollapse, [before, after] = me.splitHeaderItems({ as: "element", dock: collapseDock }), title = panel.hasHeader ? panel.title || (panelHeader == null ? void 0 : panelHeader.title) || "\xA0" : null, headerElement = title && {
      tag: "header",
      class: new DomClassList({
        ...uiClassList,
        [`b-dock-${expandedHeaderDock}`]: 1,
        "b-panel-header": 1,
        "b-panel-collapser-header": 1
      }, panelHeader == null ? void 0 : panelHeader.cls),
      children: [
        ...before,
        {
          reference: "collapserTitleElement",
          html: title,
          class: {
            ...uiClassList,
            [`b-align-${(panelHeader == null ? void 0 : panelHeader.titleAlign) || "start"}`]: 1,
            "b-header-title": 1
          }
        },
        ...after
      ]
    };
    if (recollapse) {
      recollapse.direction = collapseDir;
    }
    return [
      "collapseWrapElement",
      {
        class: {
          ...uiClassList,
          [`b-panel-collapser-header-${expandedHeaderDock}`]: 1,
          [`b-panel-collapser-${collapseDir}`]: 1,
          [`b-${dockIsHorz[expandedHeaderDock] ? "h" : "v"}box`]: 1,
          "b-panel-collapser": 1,
          "b-box-center": 1
        },
        children: dockBeforeRe.test(expandedHeaderDock) ? {
          collapserHeaderElement: headerElement,
          [key]: body
        } : {
          [key]: body,
          collapserHeaderElement: headerElement
        }
      }
    ];
  }
};
__publicField(PanelCollapser, "$name", "PanelCollapser");
__publicField(PanelCollapser, "type", "inline");
PanelCollapser.maps = {
  clipByDock,
  dockByDirection,
  dockIsHorz
};
PanelCollapser.initClass();
PanelCollapser._$name = "PanelCollapser";

// ../Core/lib/Core/util/DynamicObject.js
var PENDING = Symbol("pendingCreate");
var DynamicObject = class extends Base {
  static get prototypeProperties() {
    return {
      /**
       * Optional function that will be passed an instance prior to destroying it.
      *
       * @config {Function}
       * @param {String} name The property name in the Dynamic object by which the new instance may be referenced
       * @param {Object} instance The value of the property
       * @returns {void}
       */
      cleanup: null,
      /**
       * Optional name of the config property managed by this instance. If changes are made directly, this
       * property is used to run the `onConfigChange` method of the `owner`.
       * @config {String}
       */
      configName: null,
      /**
       * Optional function to call as instances are created. Each new instance is passed to this function.
       *
       * @config {Function}
       * @param {Object} instance The newly created instance.
       * @param {String} key The property name in the dynamic object by which the new instance may be referenced.
       * @returns {void}
       */
      created: null,
      /**
       * The {@link Core.mixin.Factoryable factory} to use to create instances.
       * @config {Object}
       */
      factory: null,
      /**
       * By default, the name of the member is used for the type. Set this config to `true` to also allow the
       * config object for a property to contain a `type` property. Set this to `false` to ignore the name of the
       * member and rely on the {@link #config-factory} to process the config object.
       * @config {Boolean|String}
       * @default
       */
      inferType: "name",
      /**
       * The owning object to pass along to the instances as the `ownerName` property.
       * @config {Object}
       */
      owner: null,
      /**
       * The property name by which to store the `owner` on each instance.
       * @config {String}
       */
      ownerName: null,
      /**
       * Set to `false` to prevent using a `Proxy` even if that JavaScript platform feature is available. Using
       * a `Proxy` is ideal because it allows for all forms of access to the dynamic properties to be handled
       * instead of only those that have predefined configuration values.
       * @config {Boolean}
       * @private
       */
      proxyable: typeof Proxy !== "undefined",
      /**
       * Optional function that will be passed a config object prior to instantiating an object. This function
       * can either modify the passed object or return a new object.
       *
       * @config {Function}
       * @param {Object} config The config object used to create the object
       * @param {String} name The property name in the Dynamic object by which the new instance may be referenced
       * @returns {Object|null}
       */
      setup: null,
      /**
       * Optional function that will be passed a raw config object prior to processing and the value it returns
       * replaces the raw value. This function is used to transform strings or arrays (for example) into proper
       * config objects.
       *
       * @config {Function}
       * @param {*} config The original value of the config object parameter
       * @returns {*}
       */
      transform: null
    };
  }
  static get properties() {
    return {
      /**
       * Holds config objects for each defined object. These are used to hold class and instance config values
       * and use them to create instances on first request, or when `flush()` is called. Further, if the instance
       * is initially assigned instead of retrieved, these values act as the defaults for the instance and are
       * combined with those provided in the assignment.
       * @member {Object} defaults
       * @private
       */
      defaults: {},
      /**
       * This object holds the actual instances that are retrieved by the dynamic accessor or `Proxy`.
       * @member {Object} instances
       * @private
       */
      instances: {},
      /**
       * The object that contains the dynamic accessors for each instance. This object is not used when using a
       * `Proxy`.
       * @member {Object} object
       * @private
       */
      object: /* @__PURE__ */ Object.create({})
    };
  }
  /**
   * Returns the `Proxy` instance used to manage dynamic assignments. If the JavaScript platform does not support the
   * `Proxy` class, this will be `null`.
   * @property {Proxy}
   * @private
   */
  get proxy() {
    const me = this;
    let proxy = null;
    if (me.proxyable) {
      proxy = new Proxy(me.instances, {
        get(o, name) {
          return me.get(name);
        },
        set(o, name, value) {
          me.set(name, value);
          return true;
        },
        deleteProperty(o, name) {
          me.set(name, null);
          return true;
        }
      });
    }
    Reflect.defineProperty(me, "proxy", {
      configurable: true,
      // allow destroy() to delete it
      value: proxy
    });
    return proxy;
  }
  /**
   * Returns the object that contains the dynamic properties. This may be a `Proxy` instance or an object with getter
   * and setter accessors.
   * @property {Object}
   * @internal
   */
  get target() {
    return this.proxy || this.object;
  }
  /**
   * This method establishes the initial definition of a dynamic property. When using a `Proxy`, this method simply
   * needs to cache away the initial config for use by the getter. When `Proxy` is unavailable, this method will
   * also defined a getter/setter to intercept access to the dynamic property.
   * @param {String} name The name of the dynamic property.
   * @param {Object} config The initial config object for the dynamic property.
   * @private
   */
  define(name, config) {
    const me = this, { transform } = me, transformed = transform ? transform(config, name) : config, instantiated = ObjectHelper.isInstantiated(transformed);
    me.instances[name] = PENDING;
    if (!instantiated) {
      me.setDefaults(name, transformed);
    }
    me.defineProp(name, true);
    if (instantiated) {
      me.set(name, transformed);
    }
  }
  /**
   * Define the get/set accessors for `name` on our `object` or its prototype.
   * @param {String} name
   * @param {Boolean} [base] Pass `true` to indicate the property should be defined on the prototype.
   * @private
   */
  defineProp(name, base) {
    const me = this, { object } = me;
    if (!me.proxy) {
      Reflect.defineProperty(base ? Object.getPrototypeOf(object) : object, name, {
        configurable: !base,
        enumerable: true,
        get() {
          return me.get(name);
        },
        set(value) {
          return me.set(name, value);
        }
      });
    }
  }
  /**
   * Ensures that all defined members are touched to trigger their creation.
   * @internal
   */
  flush() {
    var _a2;
    const me = this;
    try {
      me.updating = true;
      for (const name in me.defaults) {
        me.get(name);
      }
      me.afterConfigureOwner = (_a2 = me.afterConfigureOwner) == null ? void 0 : _a2.call(me);
    } finally {
      me.updating = false;
    }
  }
  /**
   * Returns (lazily creating as necessary) the value of a dynamic property given its name.
   * @param {String} name
   * @returns {Object}
   * @private
   */
  get(name) {
    const { defaults, instances } = this;
    if (instances[name] === PENDING) {
      this.set(name, PENDING);
    }
    return instances[name] || defaults[name] && null;
  }
  /**
   * Sets the value of a dynamic property given its name and value.
   * @param {String} name
   * @param {Object} value
   * @private
   */
  set(name, value) {
    var _a2;
    const me = this, { cleanup, configName, defaults, factory, instances, owner, setup, transform, updating } = me, inform = owner && configName && !updating, was = instances[name] === PENDING ? null : instances[name], instance = factory.reconfigure(was, value === PENDING ? {} : value || null, {
      cleanup: cleanup && ((instance2) => cleanup(instance2, name)),
      defaults: defaults[name] || me.setDefaults(name, {}),
      owner: me.owner,
      setup: setup && ((config, type, defaults2) => setup(config, name, type, defaults2)),
      transform: transform && ((config) => transform(config, name))
    });
    if (instance !== was) {
      const before = inform && { ...instances };
      instances[name] = instance;
      if (instance) {
        me.defineProp(name);
        (_a2 = me.created) == null ? void 0 : _a2.call(me, instance, name);
      } else {
        delete me.object[name];
        delete instances[name];
      }
      if (inform) {
        owner.onConfigChange({
          name: configName,
          config: owner.$meta.configs[configName],
          value: me.target,
          was: before
        });
      }
    }
  }
  /**
   * Stores the default config values for use in the factory reconfiguration process.
   * @param {String} name The name and default type of the dynamic property. Depending on {@link #config-inferType},
   * this may not be overridden by a type property in the config object.
   * @param {Object} config The config object.
   * @returns {Object}
   * @private
   */
  setDefaults(name, config) {
    const { defaults, factory, inferType, instances, owner, ownerName } = this, { typeKey } = factory.factoryable;
    config = config === true ? {} : ObjectHelper.assign({}, config);
    if (inferType === "name" || inferType === true && !config[typeKey]) {
      config[typeKey] = name;
    }
    if (ownerName) {
      config[ownerName] = owner;
    }
    config.beforeConfigure = (instance) => {
      instances[name] = instance;
    };
    return defaults[name] = config;
  }
  /**
   * Updates the members of `object` based on the provided configuration.
   * @param {Object} members The configuration for the instances of `object`.
   * @internal
   */
  update(members) {
    const me = this, { owner } = me;
    let name, config;
    try {
      me.updating = true;
      if (members) {
        for (name in members) {
          config = members[name];
          if (me.defaults[name]) {
            me.set(name, config);
          } else if (config) {
            me.define(name, config);
          }
        }
      } else {
        for (name in me.instances) {
          me.set(name, null);
        }
      }
    } finally {
      me.updating = false;
    }
    if (owner) {
      if (!owner.isConfiguring) {
        me.flush();
      } else if (!me.afterConfigureOwner) {
        me.afterConfigureOwner = FunctionHelper.before(owner, "afterConfigure", "flush", me);
      }
    }
  }
};
DynamicObject.initClass();
DynamicObject._$name = "DynamicObject";

// ../Core/lib/Core/widget/mixin/Toolable.js
var emptyArray6 = [];
var emptyObject8 = {};
var toolConfigs = {
  align: 1,
  // hidden : 1,
  weight: 1
};
var Toolable_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Widget) {
    static get configurable() {
      return {
        /**
         * The {@link Core.widget.Tool tools} as specified by the {@link #config-tools} configuration. Each is a
         * {@link Core.widget.Tool} instance which may be hidden, shown and observed and styled just like any other
         * widget.
         * @member {Object<String,Core.widget.Tool>} tools
         * @accepts {Object<String,Core.widget.Tool|ToolConfig>}
         * @category Content
         */
        /**
         * The {@link Core.widget.Tool tools} to add either before or after the `title` in the Panel header. Each
         * property name is the reference by which an instantiated tool may be retrieved from the live
         * `{@link #property-tools}` property.
         * @config {Object<String,ToolConfig>} tools
         * @category Content
         */
        tools: {
          value: null,
          $config: {
            nullify: true
          }
        },
        /**
         * An object containing config defaults for corresponding {@link #config-tools} objects with a matching name.
         *
         * This object contains a key named `'*'` with default config properties to apply to all tools. This
         * object provides the default `type` (`'tool').
         * @config {Object} toolDefaults
         * @private
         */
        toolDefaults: {
          "*": {
            type: "tool",
            align: "end"
          }
        }
      };
    }
    byWeightSortFn(a, b) {
      return (a.weight || 0) - (b.weight || 0);
    }
    byWeightReverseSortFn(a, b) {
      return (b.weight || 0) - (a.weight || 0);
    }
    gatherTools({ align, alt, refs } = emptyObject8) {
      var _a3, _b, _c;
      const { collapsed, tools } = this, options = { collapsed, alt };
      let ret = [], alignment, key, i, item, tool;
      for (key in tools) {
        tool = tools[key];
        alignment = (_c = (_b = (_a3 = tool == null ? void 0 : tool.align) == null ? void 0 : _a3.align) != null ? _b : tool == null ? void 0 : tool.align) != null ? _c : "end";
        if (alignment === align && tool.isCollapsified(options)) {
          ret.push(tool);
        }
      }
      ret.sort(this[align === "end" ? "byWeightReverseSortFn" : "byWeightSortFn"]);
      if (refs) {
        const asWidget = refs === "widget", asRefs = {};
        for (i = 0; i < ret.length; ++i) {
          item = ret[i];
          asRefs[item.ref] = asWidget ? item : item.element;
        }
        ret = asRefs;
      }
      return ret;
    }
    getEndTools({ alt, refs } = emptyObject8) {
      return this.gatherTools({ align: "end", alt, refs });
    }
    getStartTools({ alt, refs } = emptyObject8) {
      return this.gatherTools({ align: "start", alt, refs });
    }
    get childItems() {
      return [
        ...this.getStartTools(),
        ...this._items || emptyArray6,
        ...this.getEndTools()
      ];
    }
    changeTools(tools, oldTools) {
      const me = this, manager = me.$tools || (me.$tools = new DynamicObject({
        configName: "tools",
        factory: Widget,
        inferType: false,
        // the name of a tool in the tools object is not its type
        owner: me,
        created(instance) {
          var _a3, _b;
          instance.innerItem = false;
          (_b = instance.syncRotationToDock) == null ? void 0 : _b.call(instance, (_a3 = me.header) == null ? void 0 : _a3.dock);
          FunctionHelper.after(instance, "onConfigChange", (ret, { name }) => {
            if (toolConfigs[name]) {
              me.onConfigChange({
                name: "tools",
                value: manager.target
              });
            }
          });
          me.onChildAdd(instance);
        },
        setup(config, name) {
          config = ObjectHelper.merge({}, me.toolDefaults["*"], me.toolDefaults[name], config);
          config.parent = me;
          config.ref = name;
          return config;
        }
      }));
      manager.update(tools);
      if (!oldTools) {
        return manager.target;
      }
    }
    get widgetClass() {
    }
  }, __publicField(_a2, "$name", "Toolable"), _a2;
};

// ../Core/lib/Core/widget/mixin/Badge.js
var Badge_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    static get configurable() {
      return {
        /**
         * Get/sets and display badge, set to null or empty string to hide.
         * @member {String} badge
         * @category Misc
         */
        /**
         * Initial text to show in badge.
         * @config {String} badge
         * @category Misc
         */
        badge: null
      };
    }
    compose() {
      const { badge } = this;
      return {
        dataset: {
          badge
        },
        class: {
          "b-badge": badge != null && badge !== ""
        }
      };
    }
  }, __publicField(_a2, "$name", "Badge"), _a2;
};

// ../Core/lib/Core/widget/Button.js
var bIcon = /(?:^|\s)b-icon-/;
var bFa = /(?:^|\s)b-fa-/;
var defaultToggleable = Symbol("defaultToggleable");
var fullConfigKeys = ["items", "type", "widgets", "html", "listeners"];
var menuListenersName = Symbol("defaultListener");
var Button = class extends Widget.mixin(Badge_default, Rotatable_default) {
  static get configurable() {
    return {
      /**
       * Button icon class.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       * @prp {String}
       */
      icon: null,
      /**
       * The menu icon class to show when the button has a menu. Set to `null` to not show a menu icon.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * @prp {String}
       * @default
       */
      menuIcon: "b-icon-picker",
      /**
       * Icon class for the buttons pressed state. Only applies to toggle buttons
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       *
       * ```
       * new Button({
       *    // Icon for unpressed button
       *    icon        : 'b-fa-wine-glass',
       *
       *    // Icon for pressed button
       *    pressedIcon : 'b-fa-wine-glass-alt',
       *
       *    // Only applies to toggle buttons
       *    toggleable  : true
       * });
       * ```
       *
       * @prp {String}
       */
      pressedIcon: null,
      /**
       * Button icon alignment. May be `'start'` or `'end'`. Defaults to `'start'`
       * @prp {'start'|'end'}
       * @default
       */
      iconAlign: "start",
      /**
       * The button behavioral type, will be applied as a `type` attribute to this button's element.
       * @prp {'button'|'submit'|'reset'}
       * @default
       */
      behaviorType: "button",
      /**
       * The button's text.
       * @prp {String}
       */
      text: {
        value: null,
        $config: null,
        default: ""
      },
      /**
       * Button color (should have match in button.scss or your custom styling). Valid values in Bryntum themes
       * are:
       * * b-amber
       * * b-blue
       * * b-dark-gray
       * * b-deep-orange
       * * b-gray
       * * b-green
       * * b-indigo
       * * b-lime
       * * b-light-gray
       * * b-light-green
       * * b-orange
       * * b-purple
       * * b-red
       * * b-teal
       * * b-white
       * * b-yellow
       * Combine with specifying `b-raised` for raised/filled style (theme dependent).
       *
       * ```
       * new Button({
       *    color : 'b-teal b-raised'
       * });
       * ```
       *
       * @prp {String}
       */
      color: null,
      /**
       * Enabled toggling of the button (stays pressed when pressed).
       * @prp {Boolean}
       * @default false
       */
      toggleable: defaultToggleable,
      /**
       * Initially pressed or not. Only applies with `toggleable = true`.
       *
       * ```javascript
       * const toggleButton = new Button({
       *    toggleable : true,
       *    text : 'Enable cool action'
       * });
       * ```
       * @prp {Boolean}
       * @default
       */
      pressed: false,
      /**
       * Indicates that this button is part of a group where only one button can be pressed. Assigning a value
       * also sets `toggleable` to `true`.
       *
       * When part of a {@link Core.widget.ButtonGroup}, you can set {@link Core.widget.ButtonGroup#config-toggleGroup}
       * on it as an alternative to on each button. This config can then be used to override that value if needed.
       *
       * ```javascript
       * const yesButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'Yes'
       * });
       *
       * const noButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'No'
       * });
       * ```
       * @prp {String}
       */
      toggleGroup: null,
      /**
       * Set to `true` to perform action on clicking the button if it's already pressed
       * and belongs to a {@link #config-toggleGroup}.
       * @config {Boolean}
       * @default
       */
      supportsPressedClick: false,
      ripple: {
        radius: 75
      },
      forwardTwinEvents: ["action", "toggle"],
      localizableProperties: ["text"],
      /**
       * Returns the instantiated menu widget as configured by {@link #config-menu}.
       * @member {Core.widget.Widget} menu
       */
      /**
       * A submenu configuration object, or an array of MenuItem configuration objects from which to create a
       * submenu which is shown when this button is pressed.
       *
       * Note that this does not have to be a Menu. The `type` config can be used to specify any widget as the
       * submenu.
       *
       * May also be specified as a fully instantiated {@link Core.widget.Widget#config-floating floating Widget}
       * such as a {@link Core/widget/Popup}.
       * @config {Object<String,MenuItemConfig|ContainerItemConfig>|Array<MenuItemConfig|ContainerItemConfig>}
       */
      menu: {
        $config: ["lazy", "nullify"],
        value: null
      },
      menuDefaults: {
        type: "menu",
        autoShow: false,
        autoClose: true,
        floating: true,
        scrollAction: "realign",
        align: "t0-b0"
      },
      /**
       * If provided, turns the button into a link.
       * <div class="note">Not compatible with the {@link Core.widget.Widget#config-adopt} config.</div>
       * @prp {String}
       */
      href: null,
      /**
       * The `target` attribute for the {@link #config-href} config
       * @prp {String}
       */
      target: null,
      // Our own setValues/getValues system should not set/get HTML content
      defaultBindProperty: null
    };
  }
  updateElement(element, oldElement) {
    var _a2, _b, _c;
    const me = this, { constructor } = me, result = super.updateElement(element, oldElement), menu = me.peekConfig("menu"), role = menu ? menu.isWidget ? menu.role : ((_b = (_a2 = constructor.resolveType(menu.type)) == null ? void 0 : _a2.configurable) == null ? void 0 : _b.role) || ((_c = constructor.configurable.menuDefaults) == null ? void 0 : _c.type) || "menu" : false;
    me.ariaHasPopup = role;
    return result;
  }
  compose() {
    const {
      color,
      href,
      icon,
      iconAlign,
      pressed,
      pressedIcon,
      target,
      text,
      toggleable,
      toggleGroup,
      menuIcon,
      behaviorType
    } = this, hasMenu = this.hasConfig("menu"), iconCls = pressed && pressedIcon ? pressedIcon : icon;
    return {
      tag: href ? "a" : "button",
      href,
      target,
      type: behaviorType,
      class: {
        [`b-icon-align-${iconAlign}`]: icon,
        [color]: Boolean(color),
        "b-pressed": pressed && toggleable,
        "b-text": Boolean(text),
        "b-has-menu": hasMenu
      },
      [toggleable && !hasMenu ? "aria-pressed" : ""]: pressed,
      dataset: {
        group: toggleGroup
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: "onInternalClick",
        mousedown: "onInternalMousedown"
      },
      children: {
        iconElement: (icon || pressedIcon) && {
          // This element is a purely visual cue with no meaning to the A11Y tree
          "aria-hidden": true,
          tag: "i",
          class: {
            ...DomClassList.normalize(iconCls, "object"),
            "b-icon": bIcon.test(iconCls),
            "b-fa": bFa.test(iconCls)
          }
        },
        label: text && {
          tag: "label",
          for: this.id,
          text
        },
        menuIconElement: hasMenu && menuIcon && {
          tag: "i",
          class: {
            "b-icon": bIcon.test(menuIcon),
            "b-fa": bFa.test(menuIcon),
            "b-button-menu-icon": 1,
            [menuIcon]: 1
          }
        }
      }
    };
  }
  //endregion
  configureOverflowTwin(overrides) {
    const me = this, config = super.configureOverflowTwin(overrides);
    if (!config.text) {
      config.text = me.text || me.tooltipText;
    }
    return config;
  }
  onHide() {
    var _a2;
    (_a2 = this._menu) == null ? void 0 : _a2.hide();
  }
  /**
   * Iterate over all widgets owned by this widget and any descendants.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   *
   * _Due to the {@link #config-menu} config being a lazy config and only being converted to be a
   * `Menu` instance just before it's shown, the menu will not be part of the iteration before
   * it has been shown once_.
   * @function eachWidget
   * @param {Function} fn A function to execute upon all descendant widgets.
   * Iteration terminates if this function returns `false`.
   * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   */
  get childItems() {
    return this._menu && [this.menu];
  }
  onFocusOut(e) {
    var _a2;
    super.onFocusOut(e);
    (_a2 = this.menu) == null ? void 0 : _a2.hide();
  }
  //region Getters/Setters
  get focusElement() {
    return this.element;
  }
  changeText(text) {
    return text == null ? "" : text;
  }
  changeToggleable(toggleable) {
    if (toggleable === defaultToggleable) {
      return this.toggleGroup || this.config.menu;
    }
    return toggleable;
  }
  changeMenu(menu, oldMenu) {
    const me = this, { element: forElement } = me;
    if (menu) {
      if (menu.isWidget) {
        menu.forElement = forElement;
        menu.owner = me;
        menu.constrainTo = me.rootElement;
      } else {
        if (typeof menu === "object" && !fullConfigKeys.some((key) => key in menu)) {
          menu = {
            lazyItems: menu
          };
        }
        menu = Widget.reconfigure(oldMenu, menu ? ObjectHelper.merge({
          owner: me,
          constrainTo: me.rootElement,
          forElement
        }, me.menuDefaults, menu) : null, me);
      }
      menu.align.constrainPadding = 10;
      me.detachListeners(menuListenersName);
      menu.ion({
        name: menuListenersName,
        beforeShow: "onMenuBeforeShow",
        hide: "onMenuHide",
        show: "onMenuShow",
        thisObj: this
      });
    } else {
      oldMenu == null ? void 0 : oldMenu.destroy();
    }
    return menu;
  }
  onMenuBeforeShow({ source }) {
    return this.trigger("beforeShowMenu", {
      menu: source
    });
  }
  onMenuShow() {
    this.ariaElement.setAttribute("aria-expanded", true);
  }
  onMenuHide() {
    this.ariaElement.setAttribute("aria-expanded", false);
    this.toggle(false);
  }
  updateMenu(menu) {
    this.toggleable = Boolean(menu);
  }
  updatePressed(pressed) {
    var _a2, _b;
    const me = this;
    if (!me.toggleable || me.isConfiguring) {
      return;
    }
    const { menu } = me;
    if (pressed) {
      DomHelper.forEachSelector(me.rootElement, `button[data-group=${me.toggleGroup}]`, (btnEl) => {
        if (btnEl !== me.element) {
          Widget.getById(btnEl.id).pressed = false;
        }
      });
    }
    if (menu) {
      if (!menu.initialConfig.minWidth) {
        menu.minWidth = me.width;
      }
      menu.align.minHeight = (_a2 = menu._minHeight) != null ? _a2 : 100;
      menu.align.minWidth = (_b = menu._minWidth) != null ? _b : 100;
      menu[pressed ? "show" : "hide"]();
    }
    me.trigger("toggle", { pressed, userAction: me._isUserAction });
  }
  //endregion
  //region Events
  onInternalMousedown(event) {
    var _a2;
    if (((_a2 = this._menu) == null ? void 0 : _a2.containsFocus) && this.pressed) {
      event.preventDefault();
    }
  }
  /**
   * Triggers events when user clicks button
   * @fires click
   * @fires action
   * @internal
   */
  onInternalClick(event) {
    const me = this, bryntumEvent = { event };
    if (me.disabled) {
      return;
    }
    me._isUserAction = true;
    if (me.toggleable) {
      if (me.toggleGroup && me.pressed && !me.supportsPressedClick) {
        return;
      }
      if (!me.toggleGroup || !me.pressed) {
        me.toggle(!me.pressed);
      }
      if (me.isDestroyed) {
        return;
      }
    }
    me.trigger("click", bryntumEvent);
    if (!me.isDestroyed) {
      me.trigger("action", bryntumEvent);
    }
    if (!me.href) {
      event.preventDefault();
      event.stopPropagation();
    }
    me._isUserAction = false;
  }
  //endregion
  //region Misc
  /**
   * Toggle button state (only use with toggleable = true)
   * @param {Boolean} pressed Specify to force a certain toggle state
   * @fires toggle
   */
  toggle(pressed = !this.pressed) {
    if (this.trigger("beforeToggle", { pressed, userAction: this._isUserAction }) !== false) {
      this.pressed = pressed;
    }
  }
  //endregion
};
//region Config
__publicField(Button, "$name", "Button");
__publicField(Button, "type", "button");
Button.initClass();
Button._$name = "Button";

// ../Core/lib/Core/widget/layout/Box.js
var directionCls = [
  "b-hbox",
  "b-vbox"
];
var syncAlign = {
  name: "align",
  style: "alignItems"
};
var syncContentAlign = {
  name: "contentAlign",
  style: "alignContent"
};
var syncDirection = {
  name: "direction",
  style: "flexDirection"
};
var syncJustify = {
  name: "justify",
  style: "justifyContent",
  classes: ["stretch"]
};
var syncWrap = {
  name: "wrap",
  style: "flexWrap",
  map: {
    false: "nowrap",
    true: "wrap",
    reverse: "wrap-reverse"
  }
};
var Box = class extends Layout {
  /**
   * Set this value to `true` to set the [flex-direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction)
   * style of the {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}
   * to `column`. Or alternatively, set {@link #config-horizontal} to `false`.
   * @config {Boolean} vertical
   * @default false
   */
  get vertical() {
    return this.horizontal === false;
  }
  set vertical(v) {
    return this.horizontal = !v;
  }
  updateAlign() {
    this.syncConfigStyle(syncAlign);
  }
  updateContentAlign() {
    this.syncConfigStyle(syncContentAlign);
  }
  updateDirection() {
    this.syncConfigStyle(syncDirection);
  }
  updateHorizontal() {
    var _a2;
    const me = this, classList = (_a2 = me.contentElement) == null ? void 0 : _a2.classList, vertical = Number(me.vertical);
    if (classList) {
      classList.remove(directionCls[1 - vertical]);
      classList.add(directionCls[vertical]);
    } else {
      me.syncConfigLater("horizontal");
    }
    me.syncDirection();
  }
  updateJustify() {
    this.syncConfigStyle(syncJustify);
  }
  updateReverse() {
    this.syncDirection();
  }
  updateWrap() {
    this.syncConfigStyle(syncWrap);
  }
  syncDirection() {
    const me = this, { reverse } = me;
    me.direction = reverse ? `${me.vertical ? "column" : "row"}${reverse ? "-reverse" : ""}` : null;
  }
};
__publicField(Box, "$name", "Box");
__publicField(Box, "type", "box");
__publicField(Box, "alias", "hbox");
__publicField(Box, "configurable", {
  containerCls: "b-box-container",
  itemCls: "b-box-item",
  /**
   * Sets the [align-items](https://developer.mozilla.org/en-US/docs/Web/CSS/align-items) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * @config {String} align
   * @default 'stretch'
   */
  align: null,
  /**
   * Sets the [align-content](https://developer.mozilla.org/en-US/docs/Web/CSS/align-content) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * @config {String} contentAlign
   * @default 'normal'
   */
  contentAlign: null,
  /**
   * Sets the [direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * This config is not set directly. Set {@link #config-horizontal}, {@link #config-vertical}, and/or
   * {@link #config-reverse} instead.
   * @config {String} direction
   * @private
   */
  direction: null,
  /**
   * Set this value to `false` to set the [flex-direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction)
   * style of the {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}
   * to `column`. Or alternatively, set {@link #config-vertical} to `true`.
   * @config {Boolean} horizontal
   * @default
   */
  horizontal: true,
  /**
   * Sets the [justify-content](https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * @config {String} justify
   * @default 'flex-start'
   */
  justify: null,
  /**
   * Set this value to `true` to add `'-reverse'` to the [flex-direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction)
   * style of the {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * This config combines with {@link #config-horizontal} or {@link #config-vertical} to set the `flex-direction`
   * style.
   * @config {Boolean} reverse
   * @default false
   */
  reverse: null,
  /**
   * Sets the [flex-wrap](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   *
   * The value of `true` is equivalent to `'wrap'`, `false` is equivalent to `'nowrap'`, and `'reverse'` is
   * equivalent to `'wrap-reverse'`.
   *
   * ```javascript
   *  layout : {
   *      type : 'box',
   *      wrap : false        // equivalent to 'nowrap'
   *      wrap : true         // equivalent to 'wrap'
   *      wrap : 'reverse'    // equivalent to 'wrap-reverse'
   *  }
   * ```
   * @config {String|Boolean} wrap
   * @default false
   */
  wrap: null
});
Box.initClass();
Box._$name = "Box";

// ../Core/lib/Core/widget/layout/VBox.js
var VBox = class extends Box {
};
__publicField(VBox, "$name", "VBox");
__publicField(VBox, "type", "vbox");
__publicField(VBox, "configurable", {
  horizontal: false
});
VBox.initClass();
VBox._$name = "VBox";

// ../Core/lib/Core/widget/Toolbar.js
var asElementRefs = { refs: "element" };
var onCreateTwin = (overflowTwin) => overflowTwin.element.style.margin = "";
var isToolbar = (w) => w.isToolbar;
var itemScoreFn = (ent) => ent[0] + (ent[1].minifiable ? 0 : 9e9);
var twinOverrides = {
  // If the initialConfig was hidden, we must override that
  hidden: false,
  // Item must obey menu's align-items : stretch style.
  width: ""
};
var twinOverridesHorz = {
  ...twinOverrides,
  // Don't allow horizontal flex styles to apply in the vertical layout of the Menu.
  flex: ""
};
var _axisProps = [{
  box: "hbox",
  clientSizeProp: "clientWidth",
  edgeProp: "right",
  flexDir: "row",
  horizontal: true,
  max: "maxX",
  overflow: "overflowX",
  pos: "x",
  scrollSize: "scrollWidth",
  sizeProp: "width"
}, {
  box: "vbox",
  clientSizeProp: "clientHeight",
  edgeProp: "bottom",
  flexDir: "column",
  horizontal: false,
  max: "maxY",
  overflow: "overflowY",
  pos: "y",
  scrollSize: "scrollHeight",
  sizeProp: "height"
}];
var defaultRepeat = {
  delay: 0,
  startRate: 40,
  endRate: 200,
  accelerateDuration: 500
};
var nonSyncedConfigs = {
  menu: 1,
  pressed: 1
};
var _Toolbar = class _Toolbar extends Container.mixin(Toolable_default) {
  static get delayable() {
    return {
      syncOverflowVisibility: {
        type: "raf",
        cancelOutstanding: true
      }
      // && 50   // restore the "&& 50" here to help when debugging syncOverflowVisibility
    };
  }
  static get configurable() {
    return {
      defaultType: "button",
      dock: "top",
      layout: {
        type: "box"
      },
      /**
       * An object containing typed child widget config objects or {@link Core/widget/Widget Widgets}. Can also be
       * specified as an array.
       *
       * If configured as an Object, the property names are used as the child component's
       * {@link Core.widget.Widget#config-ref} name, and the value is the child component's config object.
       *
       * ```javascript
       *  new Toolbar({
       *      appendTo : document.body
       *      items    : [{
       *          type : 'button',
       *          onClick() {
       *
       *          }
       *      }]
       *  })
       * ```
       *
       * Some special items can also be added:
       *
       * - `->` Pushes following items to the other side
       * - `|` Adds a vertical separator
       *
       * ```javascript
       *  new Toolbar({
       *      appendTo : document.body
       *      items    : [
       *      {
       *          type : 'button',
       *          text : 'Click me',
       *          onClick() {
       *
       *          }
       *      },
       *      '|', // separator
       *      {
       *          type : 'textfield',
       *          label : 'Enter name'
       *      },
       *      // Align following items to the end of the toolbar
       *      '->',
       *      {
       *          type : 'button',
       *          text : 'Save',
       *          onClick() {
       *
       *          }
       *      }]
       *  })
       * ```
       *
       * @config {Object<String,ToolbarItems|Boolean|null>|ToolbarItems[]|Core.widget.Widget[]} items
       * @category Content
       */
      /**
       * How this Toolbar should deal with items that overflow its main axis.
       *
       * Values may be:
       * - `'menu'` A button with a menu is shown and the menu contains the overflowing items.
       * - `'scroll'` The items overflow and mey be scrolled into view using the mouse or scroll buttons.
       * - `null` Disable overflow handling
       *
       * When mode is `'menu'`, clones of overflowing toolbar item are created and added to a Menu. Any config
       * changes to the original toolbar item are propagated to the menu's clone, so disabling a toolbar
       * item will make the clone in the menu disabled.
       *
       * The clone of an input field will propagate its `value` changes back to the original. The
       * overflow button, its menu, and the clones should not be accessed or manipulated by application code.
       *
       * Note that cloned items will be allocated a unique, generated ID because all IDs must be unique,
       * so CSS targeting an element ID will not apply to a clone in the overflow menu.
       *
       * Values may also be specified in object form containing the following properties:
       * @config {String|Object|null} overflow
       * @property {'scroll'|'menu'} overflow.type `'scroll'` or `'menu'`
       * @property {ClickRepeaterConfig} overflow.repeat A config object to reconfigure the
       * {@link Core.util.ClickRepeater} which controls auto repeat speed when holding down the scroll buttons
       * when `type` is `'scroll'`
       * @property {Function} overflow.filter A filter function which may return a falsy value to prevent toolbar
       * items from being cloned into the overflow menu.
       * @default 'menu'
       */
      overflow: {
        // Wait until first paint to evaluate so that we can read our CSS style.
        // Set to null on destroy which destroys the overflow Tools and Scroller.
        $config: ["lazy", "nullify"],
        value: {
          type: "menu"
        }
      },
      toolDefaults: {
        overflowMenuButton: {
          type: "button",
          hidden: true,
          icon: "b-icon-menu",
          menuIcon: null,
          ariaLabel: "Show overflowing items",
          defaultCls: {
            "b-overflow-button": 1
          }
        },
        overflowScrollEnd: {
          handler: "up.onEndScrollClick",
          hidden: true,
          defaultCls: {
            "b-icon-angle-right": 1,
            "b-overflow-button": 1,
            "b-icon": 1
          }
        },
        overflowScrollStart: {
          align: "start",
          handler: "up.onStartScrollClick",
          hidden: true,
          defaultCls: {
            "b-icon-angle-left": 1,
            "b-overflow-button": 1,
            "b-icon": 1
          }
        }
      },
      /**
       * Custom CSS class to add to toolbar widgets
       * @config {String}
       * @category CSS
       */
      widgetCls: null,
      /**
       * Determines if the toolbars read-only state should be controlled by its parent.
       *
       * When set to `false`, setting a parent container to read-only will not affect the widget. When set to
       * `true`, it will.
       *
       * @category Misc
       * @config {Boolean}
       * @default
       */
      ignoreParentReadOnly: true
    };
  }
  static get prototypeProperties() {
    return {
      flexRowCls: "b-hbox",
      flexColCls: "b-vbox"
    };
  }
  /**
   * Returns the Core.widget.Widget[] of items to hide to clear an overflow. The `visibleItems` array should be in
   * order of the `items` in the container.
   * @param {Core.widget.Widget[]} visibleItems
   * @returns {Array}
   * @private
   */
  static getEvictionList(visibleItems) {
    const ret = visibleItems.filter((it) => it.overflowable !== "none");
    ret.forEach((it, n) => ret[n] = [n, it]);
    ret.sort((a, b) => itemScoreFn(b) - itemScoreFn(a));
    return ret;
  }
  compose() {
    const me = this, { axisProps, dock } = me, endToolElementRefs = me.getEndTools(asElementRefs), startToolElementRefs = me.getStartTools(asElementRefs);
    return {
      class: {
        [`b-dock-${dock}`]: 1,
        [`b-${dock}-toolbar`]: 1,
        [`b-${axisProps.box}`]: 1
      },
      children: {
        ...startToolElementRefs,
        toolbarContent: {
          class: {
            "b-box-center": 1,
            "b-toolbar-content": 1
          }
        },
        ...endToolElementRefs
      }
    };
  }
  get axisProps() {
    return _axisProps[this.layout.horizontal ? 0 : 1];
  }
  get contentElement() {
    return this.toolbarContent;
  }
  get overflowMenuButton() {
    var _a2;
    return (_a2 = this.tools) == null ? void 0 : _a2.overflowMenuButton;
  }
  get overflowType() {
    const { overflow } = this;
    return typeof overflow === "string" ? overflow : overflow == null ? void 0 : overflow.type;
  }
  onChildAdd(item) {
    var _a2;
    super.onChildAdd(item);
    this.processAddedLeafItem(item);
    (_a2 = item.syncRotationToDock) == null ? void 0 : _a2.call(item, this.dock);
  }
  onChildRemove(item) {
    super.onChildRemove(item);
    this.syncOverflowVisibility();
  }
  processAddedLeafItem(item) {
    FunctionHelper.after(item, "onConfigChange", this.onLeafItemConfigChange, item);
    if (item.isContainer) {
      item.eachWidget((w) => this.processAddedLeafItem(w));
    }
  }
  onInternalPaint({ firstPaint }) {
    var _a2;
    (_a2 = super.onInternalPaint) == null ? void 0 : _a2.call(this, ...arguments);
    if (firstPaint) {
      this.getConfig("overflow");
    }
  }
  updateDock(dock) {
    var _a2;
    const me = this, { layout } = me, { vertical } = layout;
    layout.vertical = canonicalDock(dock)[1];
    if (!me.initialItems) {
      if (vertical !== layout.vertical) {
        me.updateOverflow(me.overflow);
      }
      for (const item of me.childItems) {
        (_a2 = item.syncRotationToDock) == null ? void 0 : _a2.call(item, dock);
      }
    }
  }
  updateOverflow(overflow, oldOverflow) {
    var _a2, _b;
    const me = this, { axisProps, contentElement, overflowType } = me, { flexDir } = axisProps, overflowMenu = (_a2 = me.overflowMenuButton) == null ? void 0 : _a2._menu, overflowTools = {};
    if (overflowMenu) {
      if (overflow) {
        overflowMenu == null ? void 0 : overflowMenu.removeAll();
      } else {
        overflowMenu.eachWidget((overflowTwin) => {
          overflowTwin._overflowTwinOrigin.overflowTwin = null;
        });
      }
    }
    if (oldOverflow === "menu") {
      overflowTools.overflowMenuButton = null;
    } else if (oldOverflow === "scroll") {
      overflowTools.overflowScrollStart = overflowTools.overflowScrollEnd = null;
    }
    if (overflowType === "menu") {
      (_b = me.scrollable) == null ? void 0 : _b.destroy();
      contentElement.style.overflow = contentElement.style.overflowX = contentElement.style.overflowY = "";
      overflowTools.overflowMenuButton = {
        cls: {
          [`b-${flexDir}-menu`]: 1
        }
      };
    } else if (overflowType === "scroll") {
      const repeat = typeof overflow === "object" && (overflow == null ? void 0 : overflow.repeat) || defaultRepeat;
      me.scrollable = {
        [axisProps.overflow]: "hidden-scroll",
        element: contentElement,
        internalListeners: {
          scroll: "onContentScroll",
          thisObj: me
        }
      };
      overflowTools.overflowScrollStart = {
        repeat,
        invertRotate: true,
        cls: {
          [`b-${flexDir}-start-scroller`]: 1
        }
      };
      overflowTools.overflowScrollEnd = {
        repeat,
        invertRotate: true,
        cls: {
          [`b-${flexDir}-end-scroller`]: 1
        }
      };
    }
    me.tools = overflowTools;
    if (overflowType) {
      contentElement.classList.add("b-overflow");
      me.monitorResize = true;
      me.syncOverflowVisibility();
    } else {
      contentElement.classList.remove("b-overflow");
      me.monitorResize = false;
    }
  }
  onContentScroll() {
    this.syncScrollerState();
  }
  onStartScrollClick() {
    this.scrollable[this.axisProps.pos] -= 2;
  }
  onEndScrollClick() {
    this.scrollable[this.axisProps.pos] += 2;
  }
  // Only called when monitorResize is true, which is only set when we have an overflow mode
  onInternalResize() {
    super.onInternalResize(...arguments);
    if (this.isPainted) {
      this.syncOverflowVisibility();
    }
  }
  syncOverflowVisibility() {
    const me = this, { overflowType, contentElement, isVisible: isVisible2 } = me, { clientSizeProp, edgeProp, sizeProp } = me.axisProps, { overflowMenuButton, overflowScrollStart, overflowScrollEnd } = me.tools, rtl = me.rtl && me.layout.horizontal, menuOverflow = overflowType === "menu", getAvailSpace = () => Math.ceil(
      contentElement[clientSizeProp] + // Since we cannot simply hide these to remove their influence, we need to add their width/height:
      (!overflowScrollStart || overflowScrollStart.hidden ? 0 : overflowScrollStart.rectangle("outer")[sizeProp]) + (!overflowScrollEnd || overflowScrollEnd.hidden ? 0 : overflowScrollEnd.rectangle("outer")[sizeProp])
    ), getContentSize = () => {
      if (visibleItems.length === 0) {
        return 0;
      }
      const rect = visibleItems[visibleItems.length - 1].rectangle(contentElement);
      return Math.floor(rtl ? contentElement[clientSizeProp] - rect.left : rect[edgeProp]);
    };
    let availableSpace, contentSize, eviction, evictionList, it, itemSize, minifiable, minifiables, minified, overflowable, overflowItems, visibleItems;
    if (!isVisible2 || !overflowType || me.items.length === 0) {
      return;
    }
    me.inSyncOverflowVisibility = true;
    overflowMenuButton == null ? void 0 : overflowMenuButton.hide();
    me.eachWidget((item, control) => {
      minifiable = item.minifiable;
      overflowable = item.overflowable;
      overflowable = minifiable ? overflowable || minifiable : overflowable;
      if (item.floating) {
        control.down = false;
      } else {
        control.down = !overflowable;
        if (item.innerItem) {
          if (item._toolbarOverflow) {
            item.hidden = item._toolbarOverflow = false;
          }
          if (item._toolbarMinified) {
            item.minified = item._toolbarMinified = false;
          }
          if (item.isVisible) {
            minifiable && (minifiables || (minifiables = [])).push(item);
            overflowable && (visibleItems || (visibleItems = [])).push(item);
          }
        }
      }
    });
    if (visibleItems) {
      availableSpace = getAvailSpace();
      contentSize = getContentSize();
    }
    if (visibleItems && contentSize > availableSpace) {
      if (menuOverflow) {
        while (contentSize > availableSpace && (it = minifiables == null ? void 0 : minifiables.pop())) {
          itemSize = contentSize;
          it._toolbarMinified = true;
          it.minified = true;
          contentSize = getContentSize();
          itemSize -= contentSize;
          (minified || (minified = [])).push([it, itemSize]);
        }
        if (contentSize > availableSpace) {
          overflowMenuButton.show();
          availableSpace = getAvailSpace();
          evictionList = _Toolbar.getEvictionList(visibleItems);
          for (eviction of evictionList) {
            if (contentSize > availableSpace) {
              it = eviction[1];
              it._toolbarOverflowWidth = it.width;
              it._toolbarOverflow = true;
              it.hidden = true;
              visibleItems.splice(visibleItems.indexOf(it), 1);
              (overflowItems || (overflowItems = [])).push(eviction);
              contentSize = getContentSize();
            }
          }
          if (overflowItems) {
            overflowItems.sort((a, b) => a[0] - b[0]).forEach((ent, n) => overflowItems[n] = ent[1]);
            while (minified == null ? void 0 : minified.length) {
              [it, itemSize] = minified.pop();
              if (contentSize + itemSize <= availableSpace && !it._toolbarOverflow) {
                contentSize += itemSize;
                it.minified = it._toolbarMinified = false;
              }
            }
            me.syncOverflowMenuButton(overflowItems);
          } else {
            overflowMenuButton.hide();
          }
        }
      } else {
        overflowScrollEnd.show();
        overflowScrollStart.show();
        me.syncScrollerState();
      }
    } else if (!menuOverflow) {
      overflowScrollEnd == null ? void 0 : overflowScrollEnd.hide();
      overflowScrollStart == null ? void 0 : overflowScrollStart.hide();
    }
    me.inSyncOverflowVisibility = false;
  }
  syncOverflowMenuButton(overflowItems) {
    var _a2;
    const me = this, { axisProps, overflowMenuButton } = me, menu = {
      cls: "b-toolbar-overflow-menu",
      minWidth: 280,
      items: [],
      align: {
        align: axisProps.horizontal ? "t100-b100" : "r100-l100",
        axisLock: "flexible"
      }
    };
    me.addToMenu(menu, overflowItems.filter((item) => me.overflowItemFilter(item)));
    if ((_a2 = overflowMenuButton._menu) == null ? void 0 : _a2.isMenu) {
      const existingMenu = overflowMenuButton.menu, {
        toAdd,
        toRemove
      } = ArrayHelper.delta(menu.items, existingMenu.items, 1);
      existingMenu.remove(toRemove);
      if (existingMenu.items.length) {
        for (let i = toAdd.length - 1; i >= 0; i--) {
          existingMenu.insert(toAdd[i], 0);
        }
      } else {
        existingMenu.add(toAdd);
      }
    } else {
      overflowMenuButton.menu = menu;
    }
  }
  syncScrollerState() {
    const me = this, { axisProps, scrollable } = me, { overflowScrollStart, overflowScrollEnd } = me.tools, scrollPos = scrollable[axisProps.pos], maxScrollPos = scrollable[axisProps.max];
    overflowScrollStart.disabled = !scrollPos;
    overflowScrollEnd.disabled = Math.abs(Math.ceil(scrollPos)) >= Math.abs(maxScrollPos);
  }
  overflowItemFilter(item) {
    const { filter } = this.overflow;
    return Boolean(filter ? filter.call(this, item) : DomHelper.getChildElementCount(item.element));
  }
  addToMenu(menu, overflowingItems) {
    const overrides = this.horizontal ? twinOverridesHorz : twinOverrides;
    for (const item of overflowingItems) {
      const overflowTwin = item.ensureOverflowTwin(overrides, onCreateTwin);
      menu.items.push(overflowTwin);
    }
  }
  // Note that this is called with the thisObj of the tbar item being reconfigured.
  // It propagates the new setting into its toolbar overflow clone.
  onLeafItemConfigChange(origResult, { name, value }) {
    const item = this, toolbar = item.up(isToolbar), overflow = toolbar.hasConfig("overflow"), { overflowTwin } = item;
    if (!overflow || (toolbar == null ? void 0 : toolbar.inSyncOverflowVisibility) || name === "hidden" && value === item._toolbarOverflow) {
      return;
    }
    if (overflowTwin && !nonSyncedConfigs[name]) {
      overflowTwin[name] = value;
    }
    if ((toolbar == null ? void 0 : toolbar.isPainted) && item.ref !== "overflowMenuButton") {
      if (!(item.isTextField && name === "value" && (item.containsFocus || (overflowTwin == null ? void 0 : overflowTwin.containsFocus)))) {
        toolbar.syncOverflowVisibility();
      }
    }
  }
  createWidget(widget) {
    if (widget === "->") {
      widget = {
        type: "widget",
        cls: "b-toolbar-fill"
      };
    } else if (widget === "|") {
      widget = {
        type: "widget",
        cls: "b-toolbar-separator"
      };
    } else if (typeof widget === "string") {
      widget = {
        type: "widget",
        cls: "b-toolbar-text",
        html: widget
      };
    }
    const result = super.createWidget(widget);
    if (this.widgetCls) {
      result.element.classList.add(this.widgetCls);
    }
    return result;
  }
};
__publicField(_Toolbar, "$name", "Toolbar");
__publicField(_Toolbar, "type", "toolbar");
var Toolbar = _Toolbar;
Toolbar.initClass();
Toolbar._$name = "Toolbar";

// ../Core/lib/Core/widget/Panel.js
var acceptNode = (e) => !e.classList.contains("b-focus-trap") && DomHelper.isFocusable(e) ? DomHelper.NodeFilter.FILTER_ACCEPT : DomHelper.NodeFilter.FILTER_SKIP;
var emptyArray7 = [];
var emptyObject9 = {};
var emptySplit = [emptyArray7, emptyArray7];
var finishBodyWrap = (config, classes, final) => {
  const { vertical } = config;
  delete config.vertical;
  return {
    ...config,
    class: {
      ...classes,
      [`b-${vertical ? "v" : "h"}box`]: 1,
      "b-box-center": 1,
      "b-panel-bar-wrap": !final
    }
  };
};
var wrapBody = (inner, bodyWrapTag, vertical = false) => {
  const wrap = {
    vertical,
    children: inner ? [inner] : []
  };
  if (bodyWrapTag) {
    wrap.tag = bodyWrapTag;
  }
  return wrap;
};
var setCls = (elOrConfig, cls) => {
  if (elOrConfig == null ? void 0 : elOrConfig.classList) {
    elOrConfig == null ? void 0 : elOrConfig.classList.add(cls);
  } else if (elOrConfig == null ? void 0 : elOrConfig.class) {
    if (typeof elOrConfig.class === "string") {
      elOrConfig.class = { [elOrConfig.class]: 1 };
    }
    elOrConfig.class[cls] = 1;
  }
};
var barConfigs = {
  dock: 1,
  hidden: 1,
  weight: 1
};
var dockDirection = {
  //       [vertical, before]
  top: [true, true],
  bottom: [true, false],
  left: [false, true],
  right: [false, false]
};
var headerDock = {
  header: 1,
  "pre-header": 1
};
var _Panel = class _Panel extends Container.mixin(State_default, Toolable_default) {
  static get configurable() {
    return {
      localizableProperties: ["title"],
      /**
       * Controls whether the panel is collapsed (the body of the panel is hidden while only the header is
       * visible). Only valid if the panel is {@link #config-collapsible}.
       * @config {Boolean}
       * @category Layout
       */
      collapsed: {
        value: null,
        $config: null,
        default: false
      },
      /**
       * This config enables collapsibility for the panel. See {@link #config-collapsed}.
       *
       * For example:
       * ```javascript
       *      {
       *          type        : 'panel',
       *          collapsible : true
       *      }
       * ```
       * This is managed by an instance of {@link Core.widget.panel.PanelCollapser} which can be configured if an
       * object is passed for this config property:
       * ```javascript
       *      {
       *          type        : 'panel',
       *          collapsible : {
       *              direction : 'left'
       *          }
       *      }
       * ```
       * The config object form can contain a `type` property to specify the type of collapse the panel will use.
       * This property can be one of the following:
       *
       * - `'inline'` (see {@link Core.widget.panel.PanelCollapser})
       * - `'overlay'` (see {@link Core.widget.panel.PanelCollapserOverlay})
       *
       * @config {Boolean|PanelCollapserConfig|PanelCollapserOverlayConfig}
       * @category Layout
       */
      collapsible: {
        value: null,
        $config: "nullify"
      },
      /**
       * Custom CSS classes to add to the panel's body element.
       *
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the class names:
       *
       * ```javascript
       *  bodyCls : {
       *      'b-my-class'     : 1,
       *      [this.extraCls]  : 1,
       *      [this.activeCls] : this.isActive
       *  }
       *  ```
       *
       * @config {String|Object}
       * @category CSS
       */
      bodyCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      bodyTag: null,
      bodyWrapTag: null,
      /**
       * By default, tabbing within a Panel is not contained, ie you can TAB out of the Panel
       * forwards or backwards.
       * Configure this as `true` to disallow tabbing out of the Panel, and make tabbing circular within this Panel.
       * @config {Boolean}
       * @default false
       * @category Content
       */
      trapFocus: null,
      /**
       * Get/set this Panel's title. This may only be set when a header exists. If a header
       * has been disabled by configuring the {@link #config-header} as `false`, setting it
       * will have no effect.
       * @member {String} title
       */
      /**
       * A title to display in the header. Causes creation and docking of a header
       * to the top if no header is configured.
       *
       * If specified, overrides any title configured within the {@link #config-header} configuration.
       * @default
       * @config {String}
       * @category Misc
       */
      title: null,
      /**
       * A config {@link PanelHeader object} for the panel's header or a string in place of a `title`.
       *
       * Configuring this as `false` explicitly removes the header bar, overriding any
       * {@link #config-tools} or {@link #config-title} configs.
       * @default
       * @config {String|Boolean|PanelHeader}
       * @category Content
       */
      header: null,
      stateful: ["collapsed"],
      /**
       * An object containing config defaults for corresponding {@link #config-strips} objects with a matching name.
       *
       * By default, this object contains the keys `'bbar'` and `'tbar'` to provide default config values for the
       * {@link #config-bbar} and {@link #config-tbar} configs.
       *
       * This object also contains a key named `'*'` with default config properties to apply to all strips. This
       * object provides the default `type` (`'toolbar') and {@link Core.widget.Widget#config-dock} (`'top'`)
       * property for strips.
       * @config {Object} stripDefaults
       * @internal
       * @category Content
       */
      stripDefaults: {
        "*": {
          type: "toolbar",
          dock: "top"
        },
        bbar: {
          dock: "bottom",
          weight: -1e3
        },
        tbar: {
          weight: -1e3
        }
      },
      /**
       * An object containing widgets keyed by name. By default (when no `type` is given), strips are
       * {@link Core.widget.Toolbar toolbars}. If the value assigned to a strip is an array, it is converted to
       * the toolbar's {@link Core.widget.Container#config-items}.
       *
       * The {@link #config-bbar} and {@link #config-tbar} configs are shortcuts for adding toolbars to the
       * panel's `strips`.
       *
       * Strips are arranged based on their {@link Core.widget.Widget#config-dock} and
       * {@link Core.widget.Widget#config-weight} configs.
       *
       * For widgets using a `dock` of `'top'`, `'bottom'`, `'left'`, `'right'`, `'start'` or `'end'`(an "edge
       * strip"), the higher the `weight` assigned to a widget, the closer that widget will be to the panel body.
       *
       * For widgets with `'header'` or `'pre-header'` for `dock` (a "header strip"), higher `weight` values
       * cause the widget to be placed closer to the panel's title.
       *
       * ```javascript
       *  new Panel({
       *      title : 'Test',
       *      html  : 'Panel strip test',
       *      strips : {
       *          left : [{
       *              text : 'Go'
       *          }]
       *      }
       *  });
       * ```
       * @config {Object<String,ContainerItemConfig>} strips
       * @category Content
       */
      strips: {
        value: null,
        $config: "nullify"
      },
      toolDefaults: {
        close: {
          weight: -1e3
        },
        collapse: {
          weight: -990
        }
      },
      /**
       * Config object of a footer. May contain a `dock`, `html` and a `cls` property. A footer is not a widget,
       * but rather plain HTML that follows the last element of the panel's body and {@link #config-strips}.
       *
       * The `dock` property may be `top`, `right`, `bottom`, `left`, `start` or `end`
       *
       * @config {Object|String}
       * @property {'top'|'right'|'bottom'|'left'|'start'|'end'} dock Where to dock
       * @property {String} html Html to populate the footer with
       * @property {String} cls CSS class to add to the footer
       * @default
       * @category Content
       */
      footer: null,
      /**
       * This config is used with {@link Core.widget.panel.PanelCollapserOverlay} to programmatically control the
       * visibility of the panel's body. In this mode of collapse, the body of a collapsed panel is a floating
       * overlay. Setting this config to `true` will show this element, while `false` will hide it.
       * @config {Boolean}
       * @private
       */
      revealed: null,
      /**
       * The tool Widgets as specified by the {@link #config-tools} configuration
       * (and the {@link Core.widget.Popup#config-closable} configuration in the Popup subclass).
       * Each is a {@link Core.widget.Widget} instance which may be hidden, shown and observed and styled
       * just like any other widget.
       *
       * ```javascript
       * panel.tools.add = {
       *     cls : 'b-fa b-fa-plus',
       *     handler() {
       *         // Clicked the tool
       *     }
       * }
       * ```
       * @member {Object<String,Core.widget.Tool>} tools
       * @accepts {Object<String,Core.widget.Tool|ToolConfig>}
       */
      /**
       * The {@link Core.widget.Tool tools} to add either before or after the `title` in the Panel header. Each
       * property name is the reference by which an instantiated tool may be retrieved from the live
       * `{@link Core.widget.mixin.Toolable#property-tools}` property.
       * ```javascript
       * new Panel({
       *     ...
       *     tools : {
       *         add : {
       *             cls : 'b-fa b-fa-plus',
       *             handler() {
       *                 // Clicked the tool
       *             }
       *         }
       *     }
       * });
       * ```
       * @config {Object<string,ToolConfig>} tools
       * @category Content
       */
      /**
       * Get toolbar {@link Core.widget.Toolbar} docked to the top of the panel
       * @member {Core.widget.Toolbar} tbar
       * @readonly
       * @category Content
       */
      /**
       * A Config object representing the configuration of a {@link Core.widget.Toolbar},
       * or array of config objects representing the child items of a Toolbar.
       *
       * This creates a toolbar docked to the top of the panel immediately below the header.
       * @config {Array<ContainerItemConfig|String>|ToolbarConfig}
       * @category Content
       */
      tbar: null,
      /**
       * Get toolbar {@link Core.widget.Toolbar} docked to the bottom of the panel
       * @member {Core.widget.Toolbar} bbar
       * @readonly
       * @category Content
       */
      /**
       * A Config object representing the configuration of a {@link Core.widget.Toolbar},
       * or array of config objects representing the child items of a Toolbar.
       *
       * This creates a toolbar docked to the bottom of the panel immediately above the footer.
       * @config {Array<ContainerItemConfig|String>|ToolbarConfig}
       * @category Content
       */
      bbar: null,
      role: "region"
    };
  }
  //endregion
  /**
   * A header {@link #config-tools tool} has been clicked.
   * @event toolClick
   * @param {Core.widget.Tool} source - This Panel.
   * @param {Core.widget.Tool} tool - The tool which is being clicked.
   */
  /**
   * Fires when a Panel is collapsed using the {@link Core.widget.Panel#config-collapsible} setting.
   * @event collapse
   * @param {Core.widget.Panel} source - This Panel.
   */
  /**
   * Fires when a Panel is expanded using the {@link Core.widget.Panel#config-collapsible} setting.
   * @event expand
   * @param {Core.widget.Panel} source - This Panel.
   */
  //region Composition
  updateElement(element, oldElement) {
    const result = super.updateElement(element, oldElement);
    if (this.titleElement) {
      DomHelper.setAttributes(this.ariaElement, {
        "aria-describedby": this.titleElement.id
      });
    }
    return result;
  }
  compose() {
    const me = this, { collapsible, focusable, hasItems, revealed, tools } = me, header = me.composeHeader(), horz = (header == null ? void 0 : header.class["b-dock-left"]) || (header == null ? void 0 : header.class["b-dock-right"]);
    let body = me.composeBody(), key = "bodyWrapElement";
    if (collapsible) {
      [key, body] = collapsible.wrapCollapser(key, body);
    }
    return {
      tabIndex: hasItems && focusable !== false || focusable ? 0 : null,
      class: {
        [`b-panel-collapsible-${collapsible == null ? void 0 : collapsible.type}`]: collapsible,
        [`b-panel-collapse-${collapsible == null ? void 0 : collapsible.collapseDir}`]: collapsible,
        [`b-${horz ? "h" : "v"}box`]: 1,
        "b-panel-collapsible": collapsible,
        "b-panel-has-header": header,
        "b-panel-has-tools": tools ? 1 : 0,
        "b-panel-overlay-revealed": revealed
      },
      children: {
        topFocusTrap: {
          "aria-hidden": true,
          tabIndex: 0,
          class: {
            "b-focus-trap": 1
          }
        },
        // Note: we always put header before bodyWrap since it is likely (though untested) to be better for
        // a11y. We use flexbox order to make the right/bottom docking appear correct but it is likely that
        // the DOM order of the <header> element vs (optional) <footer> is important to screen readers.
        headerElement: header,
        [key]: body,
        bottomFocusTrap: {
          "aria-hidden": true,
          tabIndex: 0,
          class: {
            "b-focus-trap": 1,
            "b-end-focus-trap": 1
          }
        }
      }
    };
  }
  composeBody() {
    var _a2, _b;
    const me = this, { bodyCls, bodyConfig, bodyWrapTag, footer, uiClassList } = me, strips = ObjectHelper.values(me.strips, (k, v) => !dockDirection[v == null ? void 0 : v.dock]).sort(me.byWeightSortFn), innermostStrips = {
      top: null,
      right: null,
      bottom: null,
      left: null
    };
    let bar, before, dock, i, name, vertical, wrap;
    if (footer) {
      dock = footer.dock || "bottom";
      strips.unshift({
        dock,
        element: {
          tag: "footer",
          reference: "footerElement",
          html: typeof footer === "string" ? footer : footer.html,
          class: {
            ...uiClassList,
            [`b-dock-${dock}`]: 1,
            [`${footer.cls || ""}`]: 1
          }
        }
      });
    }
    if (bodyCls) {
      if (!bodyConfig[name = "className"]) {
        name = "class";
      }
      bodyConfig[name] = new DomClassList(bodyConfig[name]).assign(bodyCls);
    }
    for (i = strips.length; i-- > 0; ) {
      bar = strips[i];
      [vertical, before] = dockDirection[bar.dock];
      if (!wrap) {
        wrap = wrapBody(bodyConfig, bodyWrapTag, vertical);
      } else if (wrap.vertical !== vertical) {
        wrap = wrapBody(finishBodyWrap(wrap, uiClassList), "", vertical);
      }
      wrap.children[before ? "unshift" : "push"](bar.element);
      innermostStrips[bar.dock] = bar;
    }
    setCls(innermostStrips.top, "b-innermost");
    setCls(innermostStrips.right, "b-innermost");
    setCls(innermostStrips.bottom, "b-innermost");
    setCls(innermostStrips.left, "b-innermost");
    const body = finishBodyWrap(wrap || wrapBody(bodyConfig, bodyWrapTag), uiClassList, true);
    body.class[`${(_a2 = me.layout) == null ? void 0 : _a2.containerCls}-panel`] = Boolean((_b = me.layout) == null ? void 0 : _b.containerCls);
    body.class["b-panel-body-wrap"] = 1;
    body.class[`b-${me.$$name.toLowerCase()}-body-wrap`] = 1;
    return body;
  }
  get hasHeader() {
    if (this.header === false) {
      return false;
    }
    const { header, title, tools, parent } = this, hasVisibleTools = this.maximizable || Object.values(tools || {}).some((tool) => !tool.hidden);
    return header || !(parent == null ? void 0 : parent.suppressChildHeaders) && (title || hasVisibleTools);
  }
  get rootUiClass() {
    return _Panel;
  }
  composeHeader(force) {
    var _a2;
    const me = this;
    if (!me.hasHeader && !force) {
      return;
    }
    const header = me.header || {}, dock = header.dock || "top", [before, after] = me.splitHeaderItems({ as: "element", dock }), classes = me.$meta.hierarchy, title = me.composeTitle(header), cls = new DomClassList({
      [`b-dock-${dock}`]: 1,
      ...me.uiClassList
    }, header.cls);
    let i, name;
    for (i = classes.indexOf(_Panel); i < classes.length; ++i) {
      name = classes[i].$$name;
      if (name !== "Grid") {
        cls[`b-${name.toLowerCase()}-header`] = 1;
      }
    }
    const headerConfig = {
      tag: "header",
      class: cls,
      children: [
        ...before,
        title,
        ...after
      ]
    };
    return ((_a2 = me.collapsible) == null ? void 0 : _a2.composeHeader(headerConfig)) || headerConfig;
  }
  composeTitle(header) {
    var _a2;
    const title = typeof header === "string" ? header : this.title || header.title, titleConfig = {
      reference: "titleElement",
      id: `${this.id}-panel-title`,
      html: title != null ? title : "\xA0",
      class: {
        [`b-align-${header.titleAlign || "start"}`]: 1,
        "b-header-title": 1,
        ...this.uiClassList
      }
    };
    if (ObjectHelper.isObject(title)) {
      delete titleConfig.html;
      ObjectHelper.merge(titleConfig, title);
    }
    return ((_a2 = this.collapsible) == null ? void 0 : _a2.composeTitle(titleConfig)) || titleConfig;
  }
  // Needed to make title go through recompose
  updateTitle() {
  }
  afterRecompose() {
    var _a2;
    super.afterRecompose();
    const me = this, { headerElement } = me;
    (_a2 = me._headerClickDetacher) == null ? void 0 : _a2.call(me);
    me._headerClickDetacher = headerElement && EventHelper.on({
      element: headerElement,
      // Click might have lead to panel being destroyed (clicking close tool with `hideAction : 'destroy'`)
      click: (ev) => {
        var _a3;
        return (_a3 = me.trigger) == null ? void 0 : _a3.call(me, "headerClick", { event: ev });
      }
    });
  }
  onHeaderClick(info) {
    var _a2;
    (_a2 = this.collapsible) == null ? void 0 : _a2.onHeaderClick(info);
  }
  onInternalPaint() {
    var _a2;
    super.onInternalPaint(...arguments);
    (_a2 = this.collapsible) == null ? void 0 : _a2.onPanelPaint(this);
  }
  splitHeaderItems({ as, dock, alt } = emptyObject9) {
    var _a2, _b, _c, _d;
    const me = this, asElement = as === "element", { collapsed } = me, endTools = me.getEndTools({ alt }), startTools = me.getStartTools({ alt }), strips = ObjectHelper.values(
      me.strips,
      (k, v) => !headerDock[v == null ? void 0 : v.dock] && v.isCollapsified({ collapsed, alt })
    );
    let ret = emptySplit, after, before, i;
    if (strips.length + endTools.length + startTools.length) {
      ret = [
        // the problem w/mixing tools and strips is the strip weight needs to do two jobs (one when docked
        // in the body and one when docked in the header)
        before = [
          ...startTools,
          ...strips.filter((e) => e.dock === "pre-header").sort(me.byWeightSortFn)
        ],
        after = [
          ...strips.filter((e) => e.dock === "header").sort(me.byWeightReverseSortFn),
          ...endTools
        ]
      ];
      for (i = 0; i < before.length; ++i) {
        dock && ((_b = (_a2 = before[i]).syncRotationToDock) == null ? void 0 : _b.call(_a2, dock));
        if (asElement) {
          before[i] = before[i].element;
        }
      }
      for (i = 0; i < after.length; ++i) {
        dock && ((_d = (_c = after[i]).syncRotationToDock) == null ? void 0 : _d.call(_c, dock));
        if (asElement) {
          after[i] = after[i].element;
        }
      }
    }
    return ret;
  }
  set bodyConfig(bodyConfig) {
    this._bodyConfig = bodyConfig;
  }
  get bodyConfig() {
    const me = this, { bodyTag } = me, result = ObjectHelper.merge({
      reference: "bodyElement",
      className: {
        ...me.getStaticWidgetClasses(_Panel, "-content"),
        "b-box-center": 1,
        "b-text-content": me.textContent && me.hasNoChildren
      }
    }, me._bodyConfig);
    if (bodyTag) {
      result.tag = bodyTag;
    }
    if (me.initializingElement || !me._element) {
      result.html = me.content || me._html;
    }
    return result;
  }
  //endregion
  //region Configs
  changeBodyCls(cls) {
    return DomClassList.from(cls);
  }
  changeTbar(bar) {
    this.getConfig("strips");
    this.strips = {
      tbar: bar
    };
    return this.strips.tbar;
  }
  changeBbar(bar) {
    this.getConfig("strips");
    this.strips = {
      bbar: bar
    };
    return this.strips.bbar;
  }
  // Override to iterate docked Toolbars in the correct order around contained widgets.
  get childItems() {
    var _a2;
    const me = this, strips = ObjectHelper.values(me.strips, (k, v) => !dockDirection[v == null ? void 0 : v.dock]).sort(me.byWeightSortFn), [before, after] = me.splitHeaderItems(), [before2, after2] = ((_a2 = me.collapsible) == null ? void 0 : _a2.splitHeaderItems()) || emptySplit;
    return [
      ...before,
      ...before2,
      ...after,
      ...after2,
      ...strips.filter((b) => dockDirection[b.dock][1]),
      // the "before" strips come before the items
      ...me._items || emptyArray7,
      ...strips.filter((b) => !dockDirection[b.dock][1]).reverse()
    ];
  }
  changeStrips(strips, oldStrips) {
    const me = this, manager = me.$strips || (me.$strips = new DynamicObject({
      configName: "strips",
      factory: Widget,
      inferType: false,
      // the name of a bar in the strips object is not its type
      owner: me,
      created(instance) {
        var _a2;
        const { dock } = instance;
        if (!headerDock[dock] && !dockDirection[dock]) {
          throw new Error(
            `Invalid dock value "${dock}"; must be: top, left, right, bottom, header, or pre-header`
          );
        }
        FunctionHelper.after(instance, "onConfigChange", (ret, { name }) => {
          if (barConfigs[name]) {
            me.onConfigChange({
              name: "strips",
              value: manager.target
            });
          }
        });
        instance.innerItem = false;
        me.onChildAdd(instance);
        instance.parent = me;
        (_a2 = instance.layout) == null ? void 0 : _a2.renderChildren();
        if (instance.hasItems) {
          me.hasItems = true;
        }
      },
      setup(config, name) {
        config = ObjectHelper.merge(ObjectHelper.clone(me.stripDefaults["*"]), me.stripDefaults[name], config);
        config.parent = me;
        config.ref = name;
        return config;
      },
      transform(config) {
        if (Array.isArray(config)) {
          config = {
            items: config
          };
        }
        return config || null;
      }
    }));
    manager.update(strips);
    if (!oldStrips) {
      return manager.target;
    }
  }
  //endregion
  //region Collapse/Expand
  /**
   * This property is `true` if the panel is currently collapsing.
   * @property {Boolean}
   * @readonly
   * @category Layout
   */
  get collapsing() {
    var _a2;
    return (_a2 = this.collapsible) == null ? void 0 : _a2.collapsing;
  }
  /**
   * This property is `true` if the panel is currently either collapsing or expanding.
   * @property {Boolean}
   * @readonly
   * @internal
   * @category Layout
   */
  get collapsingExpanding() {
    var _a2;
    return (_a2 = this.collapsible) == null ? void 0 : _a2.collapsingExpanding;
  }
  /**
   * This property is `true` if the panel is currently expanding.
   * @property {Boolean}
   * @readonly
   * @category Layout
   */
  get expanding() {
    var _a2;
    return (_a2 = this.collapsible) == null ? void 0 : _a2.expanding;
  }
  changeCollapsed(value) {
    const me = this, { collapsible } = me;
    me.recompose.flush();
    value = Boolean(value);
    if (!collapsible || me.changingCollapse || !me.isPainted) {
      return value;
    }
    collapsible == null ? void 0 : collapsible.collapse({
      animation: null,
      collapsed: value
    });
  }
  changeCollapsible(collapsible, was) {
    const me = this;
    me.getConfig("tools");
    if (collapsible) {
      if (collapsible === true) {
        collapsible = {};
      } else if (typeof collapsible === "string") {
        collapsible = {
          [dockDirection[collapsible] ? "direction" : "type"]: collapsible
        };
      }
    }
    return PanelCollapser.reconfigure(was, collapsible, {
      owner: me,
      defaults: {
        panel: me
      },
      cleanup() {
        if (me.collapsed) {
          was.collapse({
            animation: null,
            collapsed: false
          });
          me._collapsed = 1;
        }
      }
    });
  }
  updateCollapsible(collapsible) {
    const me = this, tools = collapsible == null ? void 0 : collapsible.toolsConfig;
    me.tools = {
      collapse: (tools == null ? void 0 : tools.collapse) || null,
      recollapse: (tools == null ? void 0 : tools.recollapse) || null
    };
    if (collapsible && me.isPainted && me.collapsed) {
      me._collapsed = 1;
    }
    if (me.collapsed === 1) {
      me.collapsed = true;
    }
  }
  _collapse(collapsed, options) {
    var _a2;
    if (options !== true && options !== void 0) {
      if (options === false) {
        collapsed.collapsed = !collapsed.collapsed;
      } else if (typeof options === "number") {
        collapsed.animation = {
          duration: options
        };
      } else if (options === null) {
        collapsed.animation = options;
      } else if (options === true) {
      } else if ("animation" in options) {
        ObjectHelper.merge(collapsed, options);
      } else {
        collapsed.animation = options;
      }
    }
    return (_a2 = this.collapsible) == null ? void 0 : _a2.collapse(collapsed);
  }
  collapse(options) {
    return this._collapse({ collapsed: true }, options);
  }
  expand(options) {
    return this._collapse({ collapsed: false }, options);
  }
  /**
   * Toggles collapsed state of the panel.
   * Collapses an expanded or expands a collapsed panel.
   * @privateparam [options] options object with animation config (for internal use)
   * @returns {Boolean} `true` value for collapsed panel or `false` for expanded
   */
  toggleCollapsed(options) {
    return this.collapsed ? this.expand(options) : this.collapse(options);
  }
  //endregion
  //region Misc
  get expandedHeaderDock() {
    var _a2, _b, _c;
    return (_c = (_b = this._expandedHeaderDock) != null ? _b : (_a2 = this.initialConfig.header) == null ? void 0 : _a2.dock) != null ? _c : "top";
  }
  set expandedHeaderDock(v) {
    this._expandedHeaderDock = v == null ? void 0 : v.toLowerCase();
  }
  updateHeader(header) {
    if (!this.changingCollapse) {
      this.expandedHeaderDock = header == null ? void 0 : header.dock;
    }
  }
  updateTrapFocus(trapFocus) {
    var _a2;
    const me = this;
    me.element.classList[trapFocus ? "add" : "remove"]("b-focus-trapped");
    me.focusTrapListener = (_a2 = me.focusTrapListener) == null ? void 0 : _a2.call(me);
    if (trapFocus) {
      me.focusTrapListener = EventHelper.on({
        element: me.element,
        focusin: "onFocusTrapped",
        delegate: ".b-focus-trap",
        thisObj: me
      });
      if (!me.treeWalker) {
        me.treeWalker = this.setupTreeWalker(me.element, DomHelper.NodeFilter.SHOW_ELEMENT, acceptNode);
      }
    }
  }
  setupTreeWalker(root, whatToShow, filter) {
    return document.createTreeWalker(root, whatToShow, filter);
  }
  onFocusTrapped(e) {
    const me = this, treeWalker = me.treeWalker;
    if (e.target === me.bottomFocusTrap) {
      treeWalker.currentNode = me.topFocusTrap;
      treeWalker.nextNode();
    } else if (e.target === me.topFocusTrap) {
      treeWalker.currentNode = me.bottomFocusTrap;
      treeWalker.previousNode();
    } else {
      return;
    }
    me.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }
  get focusElement() {
    return this.hasItems && (super.focusElement || this.element);
  }
  get contentElement() {
    return this.element && this.bodyElement;
  }
  get widgetClassList() {
    var _a2;
    const me = this, result = super.widgetClassList;
    if (me.hasHeader) {
      result.push("b-panel-has-header", `b-header-dock-${((_a2 = me.header) == null ? void 0 : _a2.dock) || "top"}`);
    }
    if (me.tbar) {
      result.push("b-panel-has-top-toolbar");
    }
    if (me.bbar) {
      result.push("b-panel-has-bottom-toolbar");
    }
    return result;
  }
};
//region Config
__publicField(_Panel, "$name", "Panel");
__publicField(_Panel, "type", "panel");
var Panel = _Panel;
Panel.initClass();
Panel._$name = "Panel";

// ../Core/lib/Core/widget/Popup.js
var _Popup = class _Popup extends Panel {
  static get configurable() {
    return {
      /**
       * Auto show flag for Popup.
       * If truthy then Popup is shown automatically upon hover.
       * @config {Boolean}
       * @default
       */
      autoShow: true,
      /**
       * By default, a Popup is transient, and will {@link #function-close} when the user clicks or
       * taps outside its owned widgets and when focus moves outside its owned widgets.
       *
       * **Note**: {@link #config-modal Modal} popups won't {@link #function-close} when focus moves outside even
       * if autoClose is `true`.
       *
       * Configure as `false` to make a Popup non-transient.
       * @config {Boolean}
       * @default
       */
      autoClose: true,
      /**
       * Show popup when user clicks the element that it is anchored to. Cannot be combined with showOnHover
       * @config {Boolean}
       * @default
       */
      showOnClick: false,
      /**
       * DOM element to attach popup.
       * @config {HTMLElement}
       */
      forElement: null,
      monitorResize: true,
      floating: true,
      hidden: true,
      axisLock: true,
      // Flip edges if align violates constrainTo
      hideAnimation: {
        opacity: {
          from: 1,
          to: 0,
          duration: ".3s",
          delay: "0s"
        }
      },
      showAnimation: {
        opacity: {
          from: 0,
          to: 1,
          duration: ".4s",
          delay: "0s"
        }
      },
      stripDefaults: {
        bbar: {
          layout: {
            justify: "flex-end"
          }
        }
      },
      testConfig: {
        hideAnimation: null,
        showAnimation: null
      },
      /**
       * The action to take when calling the {@link #function-close} method.
       * By default, the popup is hidden.
       *
       * This may be set to `'destroy'` to destroy the popup upon close.
       * @config {'hide'|'destroy'}
       * @default
       */
      closeAction: "hide",
      /**
       * By default, tabbing within a Popup is circular - that is it does not exit.
       * Configure this as `false` to allow tabbing out of the Popup.
       * @config {Boolean}
       * @default
       */
      trapFocus: true,
      /**
       * By default a Popup is focused when it is shown.
       * Configure this as `false` to prevent automatic focus on show.
       * @config {Boolean}
       * @default
       */
      focusOnToFront: true,
      /**
       * Show a tool in the header to close this Popup, and allow `ESC` close it.
       * The tool is available in the {@link Core.widget.mixin.Toolable#property-tools} object
       * under the name `close`. It uses the CSS class `b-popup-close` to apply a
       * default close icon. This may be customized with your own CSS rules.
       * @default false
       * @config {Boolean}
       */
      closable: null,
      /**
       * Show a tool in the header to maximize this popup
       * @config {Boolean}
       * @default false
       */
      maximizable: null,
      /**
       * Optionally show an opaque mask below this Popup when shown.
       * Configure this as `true` to show the mask.
       *
       * When a Popup is modal, it defaults to being {@link Core.widget.Widget#config-centered}.
       * Also, it won't {@link #function-close} when focus moves outside even if {@link #config-autoClose} is
       * `true`.
       *
       * The default action is to focus the popup.
       *
       * Usage:
       * ```javascript
       * new Popup({
       *     title  : 'I am modal',
       *     modal  : {
       *         closeOnMaskTap : true
       *     },
       *     height : 100,
       *     width  : 200
       * });
       * ```
       *
       * @default false
       * @config {Boolean|Object}
       * @property {Boolean} [closeOnMaskTap=false] Specify as `true` to close when mask is tapped.
       * @property {Boolean} [transparent=false] Specify as `true` to use a transparent mask.
       */
      modal: null,
      /**
       * Set to `true` to make this widget take all available space in the visible viewport.
       * @member {Boolean} maximized
       * @category Float & align
       */
      /**
       * Set to `true` to make this widget take all available space in the visible viewport.
       * @config {Boolean}
       * @default false
       * @category Float & align
       */
      maximized: null,
      tools: {
        close: {
          cls: "b-popup-close",
          handler: "close",
          weight: -1e3,
          ariaLabel: "L{Popup.close}",
          hidden: true
          // shown when closable set to true
        },
        maximize: {
          cls: "b-popup-expand",
          handler: "toggleMaximized",
          weight: -999,
          hidden: true
          // shown when maximizable set to true
        }
      },
      highlightReturnedFocus: true,
      role: "dialog"
    };
  }
  //endregion
  //region Init & destroy
  finalizeInit() {
    const me = this, { forElement } = me;
    me.anchoredTo = forElement;
    me.initialAnchor = me.anchor;
    if (forElement && me.showOnClick) {
      if (!me.initialConfig.autoShow) {
        me.autoShow = false;
      }
      EventHelper.on({
        element: forElement,
        click: "onElementUserAction",
        thisObj: me
      });
    }
    super.finalizeInit();
    if (me.autoShow && (!forElement || DomHelper.isVisible(forElement))) {
      if (me.autoShow === true) {
        me.show();
      } else {
        me.setTimeout(() => me.show(), me.autoShow);
      }
    }
  }
  onInternalPaint({ firstPaint }) {
    var _a2;
    (_a2 = super.onInternalPaint) == null ? void 0 : _a2.call(this, ...arguments);
    const me = this;
    if (firstPaint && me.headerElement) {
      EventHelper.on({
        element: me.headerElement,
        dblclick: me.onHeaderDblClick,
        thisObj: me
      });
    }
  }
  doDestroy() {
    this.syncModalMask();
    super.doDestroy();
  }
  //endregion
  compose() {
    const { hasNoChildren, textContent } = this;
    return {
      class: {
        // Popup has extra CSS responsibilities at the top level.
        // The CSS needs to know whether it should impose a max-width.
        "b-text-popup": Boolean(textContent && hasNoChildren)
      }
    };
  }
  //region Show/hide
  /**
   * Performs the configured {@link #config-closeAction} upon this popup.
   * By default, the popup hides. The {@link #config-closeAction} may be
   * configured as `'destroy'`.
   * @fires beforeclose If popup is not hidden
   */
  close() {
    const me = this;
    if (!me._hidden && me.trigger("beforeClose") !== false || // we should destroy it even if it's hidden just omit beforeclose event
    me._hidden && me.closeAction === "destroy") {
      me.modal && me.closeAction === "destroy" && me.revertFocus();
      me.unmask();
      if (me.containsFocus && me.highlightReturnedFocus) {
        me.setTimeout(() => me.element.classList.add("b-using-keyboard"), 0);
      }
      return me[me.closeAction]();
    }
  }
  toggleMaximized() {
    this.maximized = !this.maximized;
  }
  updateMaximized(value) {
    DomHelper.toggleClasses(this.element, ["b-maximized"], value);
  }
  //endregion
  //region Events
  onInternalKeyDown(event) {
    const me = this;
    if (event.key === "Escape") {
      event.stopImmediatePropagation();
      if (me.floating || me.positioned) {
        me.close(true);
      } else if (me.collapsible) {
        if (me.revealed) {
          me.collapsible.toggleReveal();
        } else {
          me.collapse();
        }
      }
    }
  }
  onDocumentMouseDown({ event }) {
    const me = this, { owner } = me, { target } = event;
    if (event.type !== "touchend" && (owner == null ? void 0 : owner.isButton) && owner._menu === me && owner.element.contains(target)) {
      event.preventDefault();
      return false;
    }
    if (me.modal && target === _Popup.modalMask) {
      event.preventDefault();
      if (me.modal.closeOnMaskTap) {
        me.close();
      } else if (!me.containsFocus) {
        me.focus();
      }
    } else if (!me.owns(target) && me.autoClose && !me.containsFocus) {
      me.close();
    }
  }
  get isTopModal() {
    return DomHelper.isVisible(_Popup.modalMask) && this.element.previousElementSibling === _Popup.modalMask;
  }
  onFocusIn(e) {
    const activeEl = DomHelper.getActiveElement(this);
    super.onFocusIn(e);
    if (DomHelper.getActiveElement(this) === activeEl && e.target === this.element) {
      this.focus();
    }
  }
  onFocusOut(e) {
    const usingVirtualKeyboard = globalThis.visualViewport && globalThis.visualViewport.height < document.documentElement.clientHeight - 1;
    if (!usingVirtualKeyboard && !this.modal && this.autoClose) {
      this.close();
    }
    super.onFocusOut(e);
  }
  onShow() {
    var _a2;
    const me = this;
    if (me.autoClose || me.modal) {
      me.addDocumentMouseDownListener();
    }
    if (me.focusOnToFront) {
      me.focus();
    }
    (_a2 = super.onShow) == null ? void 0 : _a2.call(this);
    me.syncModalMask();
  }
  addDocumentMouseDownListener() {
    if (!this.mouseDownRemover) {
      this.mouseDownRemover = GlobalEvents_default.ion({
        globaltap: "onDocumentMouseDown",
        thisObj: this
      });
    }
  }
  updateModal(modal) {
    if (modal) {
      this.floating = true;
    }
  }
  syncModalMask() {
    const me = this, {
      modal,
      element
    } = me;
    element.setAttribute("aria-modal", Boolean(modal));
    if (modal && me.isVisible) {
      if (typeof me._x !== "number" && typeof me._y !== "number") {
        me.centered = true;
        me.anchor = false;
      }
      me.modalMask.classList.remove("b-hide-display");
      me.modalMask.classList.toggle("b-modal-transparent", Boolean(modal.transparent));
      element.classList.add("b-modal");
    } else if (me.isPainted) {
      element.classList.remove("b-modal");
      const remainingModals = me.floatRoot.querySelectorAll(".b-modal"), topModal = remainingModals.length ? _Popup.fromElement(remainingModals[remainingModals.length - 1], "popup") : null;
      if (topModal) {
        topModal.syncModalMask();
      } else {
        _Popup.modalMask.classList.add("b-hide-display");
      }
    }
  }
  onHide() {
    var _a2, _b;
    const me = this;
    (_a2 = me.mouseDownRemover) == null ? void 0 : _a2.call(me);
    me.mouseDownRemover = null;
    (_b = super.onHide) == null ? void 0 : _b.call(this);
    me.syncModalMask();
  }
  onElementUserAction() {
    this.show();
  }
  onHeaderDblClick() {
    if (this.maximizable) {
      this.toggleMaximized();
    }
  }
  //endregion
  updateClosable(closable) {
    this.tools.close.hidden = !closable;
  }
  updateMaximizable(maximizable) {
    this.tools.maximize.hidden = !maximizable;
  }
  /**
   * Returns the modal mask element for this Popup correctly positioned just below this Popup.
   * @internal
   */
  get modalMask() {
    const { modalMask } = _Popup;
    if (modalMask.nextElementSibling !== this.element) {
      this.floatRoot.insertBefore(modalMask, this.element);
    }
    return modalMask;
  }
  /**
   * Returns the modal mask element. It does NOT guarantee its placement in the DOM relative
   * to any Popup. To get the modal mask for a particular Popup, use the instance property.
   * @internal
   */
  static get modalMask() {
    if (!this._modalMask) {
      this._modalMask = DomHelper.createElement({
        className: "b-modal-mask b-hide-display"
      });
      EventHelper.on({
        element: this._modalMask,
        wheel: (e) => e.preventDefault()
      });
    }
    return this._modalMask;
  }
};
//region Config
__publicField(_Popup, "$name", "Popup");
__publicField(_Popup, "type", "popup");
var Popup = _Popup;
Popup.initClass();
Popup._$name = "Popup";

// ../Core/lib/Core/widget/Menu.js
var validKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowRight: 1,
  ArrowLeft: 1,
  Enter: 1,
  Escape: 1
};
var Menu = class extends Popup {
  static get configurable() {
    return {
      layout: "vbox",
      focusable: true,
      align: "t-b",
      scrollAction: "hide",
      /**
       * Specify false to prevent the menu from getting focus when hovering items
       * @default
       * @config {Boolean}
       */
      focusOnHover: null,
      // We do need a Scroller so that we can use its API to scroll around.
      // But the overflow flags default to false.
      scrollable: false,
      defaultType: "menuitem",
      tools: {
        // To get rid of the close tool from Popup
        close: false
      },
      role: "menu",
      ariaElement: "bodyElement"
    };
  }
  /**
   * Currently open sub menu, if any
   * @member {Core.widget.Menu} currentSubMenu
   * @readonly
   */
  //endregion
  /**
   * A descendant menu item has been activated.
   *
   * Note that this event bubbles up through parents and can be
   * listened for on a top level {@link Core.widget.Menu Menu} for convenience.
   * @event item
   * @param {Core.widget.MenuItem} item - The menu item which is being actioned.
   * @param {Core.widget.Menu} menu - Menu containing the menu item
   */
  /**
   * The checked state of a descendant menu item has changed.
   *
   * Note that this event bubbles up through parents and can be
   * listened for on a top level {@link Core.widget.Menu Menu} for convenience.
   * @event toggle
   * @param {Core.widget.MenuItem} item - The menu item whose checked state changed.
   * @param {Core.widget.Menu} menu - Menu containing the menu item
   * @param {Boolean} checked - The _new_ checked state.
   */
  /* break doc comment */
  //region Init
  construct(config) {
    if (Array.isArray(config)) {
      config = {
        lazyItems: config
      };
    }
    super.construct(config);
    EventHelper.on({
      element: this.element,
      click: "onMouseClick",
      mouseover: "onMouseOver",
      mouseenter: "onMouseEnter",
      mouseleave: "onMouseLeave",
      thisObj: this
    });
  }
  afterShow() {
    const { items, element } = this, hasSubmenu = items.some((item) => Boolean(item._menu));
    if (hasSubmenu) {
      element.classList.add("b-menu-with-submenu");
    }
    const hasIcon = items.some((item) => item.icon);
    if (hasIcon) {
      element.classList.add("b-menu-with-icon");
    }
    super.afterShow(...arguments);
  }
  createWidget(item) {
    if (typeof item === "string") {
      item = {
        text: item
      };
    }
    return super.createWidget(item);
  }
  get focusElement() {
    var _a2;
    const me = this, fromParentMenu = (_a2 = me.parentMenu) == null ? void 0 : _a2.element.contains(DomHelper.getActiveElement(me.parentMenu)), firstWidget = me.items[0];
    if (fromParentMenu || DomHelper.usingKeyboard || !(firstWidget instanceof MenuItem)) {
      return super.focusElement;
    }
    return me.element;
  }
  //endregion
  onDocumentMouseDown({ event }) {
    if (!this.parentMenu || !this.parentMenu.owns(event.target)) {
      return super.onDocumentMouseDown(...arguments);
    }
  }
  //region Show
  hide(animate) {
    var _a2, _b;
    const me = this;
    super.hide(animate);
    if (!me.isVisible) {
      (_b = (_a2 = me.currentSubMenu) == null ? void 0 : _a2.hide) == null ? void 0 : _b.call(_a2, animate);
      if (me.parentMenu) {
        me.parentMenu.currentSubMenu = null;
      }
    }
  }
  show() {
    super.show(...arguments);
    const { parentMenu } = this;
    if (this.isVisible && parentMenu) {
      parentMenu.currentSubMenu = this;
    }
  }
  //endregion
  //region Events
  /**
   * Activates a menu item if user clicks on it
   * @private
   */
  onMouseClick(event) {
    const menuItem = event.target.closest(".b-menuitem");
    if (menuItem) {
      this.triggerElement(menuItem, event);
    }
  }
  /**
   * Activates menu items on hover. On real mouse hover, not on a touchstart.
   * @private
   */
  onMouseOver(event) {
    var _a2;
    if (this.focusOnHover !== false) {
      const fromItemElement = (_a2 = event.relatedTarget) == null ? void 0 : _a2.closest(".b-widget"), toItemElement = event.target.closest(".b-widget"), overItem = Widget.fromElement(toItemElement);
      if (!DomHelper.isTouchEvent && toItemElement && toItemElement !== fromItemElement && overItem.parent === this) {
        this.setTimeout({
          fn: "handleMouseOver",
          delay: 30,
          args: [overItem],
          cancelOutstanding: true
        });
      }
    }
  }
  handleMouseOver(overItem) {
    overItem.focus();
  }
  onMouseEnter() {
    this.clearTimeout(this.closeTimer);
  }
  // unselect any menu item if mouse leaves the menu element (unless it enters a child menu)
  onMouseLeave(event) {
    const me = this, { relatedTarget } = event, leavingToChild = relatedTarget && me.owns(relatedTarget);
    let targetCmp = relatedTarget instanceof HTMLElement && Widget.fromElement(relatedTarget), shouldHideMenu = !leavingToChild;
    if (targetCmp) {
      while (targetCmp.ownerCmp) {
        targetCmp = targetCmp.ownerCmp;
      }
      shouldHideMenu &= !DomHelper.getAncestor(targetCmp.element, [event.target]);
    }
    if (!leavingToChild && shouldHideMenu) {
      if (me.currentSubMenu && !me.currentSubMenu.closeTimer) {
        me.currentSubMenu.hide();
      }
      if (me.element.contains(DomHelper.getActiveElement(me)) && DomHelper.getActiveElement(me).matches(".b-menuitem")) {
        me.focusElement.focus();
      }
    }
  }
  /**
   * Keyboard navigation. Up/down, close with esc, activate with enter
   * @private
   */
  onInternalKeyDown(event) {
    const sourceWidget = Widget.fromElement(event), isFromWidget = sourceWidget && sourceWidget !== this && !(sourceWidget instanceof MenuItem);
    if (event.key === "Escape") {
      (isFromWidget ? this : this.rootMenu).close();
      return;
    }
    super.onInternalKeyDown(event);
    if (isFromWidget) {
      return;
    }
    if (validKeys[event.key]) {
      event.preventDefault();
    }
    const el = this.element, active = DomHelper.getActiveElement(el);
    this.navigateFrom(active !== el && el.contains(active) ? active : null, event.key, event);
  }
  navigateFrom(active, key, event) {
    const me = this, { treeWalker } = me, item = active && me.getItem(active), enterSubMenu = me.rtl ? "ArrowLeft" : "ArrowRight", exitSubMenu = me.rtl ? "ArrowRight" : "ArrowLeft";
    let toActivate;
    switch (key) {
      case "ArrowUp":
        treeWalker.currentNode = active || (active = me.bottomFocusTrap);
        treeWalker.previousNode();
        toActivate = treeWalker.currentNode;
        break;
      case "ArrowDown":
        treeWalker.currentNode = active || (active = me.topFocusTrap);
        treeWalker.nextNode();
        toActivate = treeWalker.currentNode;
        break;
      case " ":
        if (active && !active.classList.contains("b-disabled")) {
          if (item == null ? void 0 : item.menu) {
            me.openSubMenu(active, item);
          } else {
            me.triggerElement(active, event);
          }
        }
        break;
      case enterSubMenu:
        if (active && (item == null ? void 0 : item.menu) && !active.classList.contains("b-disabled")) {
          const openedMenu = me.openSubMenu(active, item);
          openedMenu == null ? void 0 : openedMenu.focus();
        } else {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;
      case exitSubMenu:
        if (me.isSubMenu) {
          me.hide();
        } else if (!active) {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;
      case "Enter":
        if (active && !active.classList.contains("b-disabled")) {
          me.triggerElement(active, event);
        }
        break;
    }
    if (toActivate) {
      if (toActivate === me.element) {
        me.navigateFrom(me.bottomFocusTrap, "ArrowUp", event);
      } else if (toActivate === active) {
        me.navigateFrom(me.topFocusTrap, "ArrowDown", event);
      } else {
        toActivate.focus();
      }
    }
  }
  //endregion
  //region Activate menu item
  getItem(item) {
    if (item != null) {
      if (typeof item === "number") {
        return this.items[item];
      }
      if (item.nodeType === Element.ELEMENT_NODE) {
        return Widget.fromElement(item, "menuitem", this.contentElement);
      }
      return this.items.find((c) => c.id == item);
    }
  }
  /**
   * Activate a menu item (from its element)
   * @private
   * @fires item
   * @param menuItemElement
   */
  triggerElement(menuItemElement, event) {
    const item = this.getItem(menuItemElement);
    if (item && !item.disabled) {
      item.doAction(event);
    }
  }
  /**
   * Returns true if this menu is a sub menu.
   * To find out which menu is the parent, check {@link #property-parentMenu}.
   * @type {Boolean}
   * @readonly
   */
  get isSubMenu() {
    var _a2;
    return this === ((_a2 = this.owner) == null ? void 0 : _a2.menu);
  }
  /**
   * Opens a submenu anchored to a menu item
   * @private
   * @param element
   * @param item
   */
  openSubMenu(element, item) {
    var _a2;
    const me = this, subMenu = item.menu;
    if (subMenu) {
      if (!subMenu.isVisible) {
        const event = { item, element };
        if (me.trigger("beforeSubMenu", event) === false) {
          return;
        }
        if (((_a2 = item.onBeforeSubMenu) == null ? void 0 : _a2.call(item, event)) === false) {
          return;
        }
        subMenu.show();
      }
      return me.currentSubMenu = subMenu;
    }
  }
  /**
   * Get/set focused menu item.
   * Shows submenu if newly focused item has a menu and is not disabled.
   * @property {HTMLElement}
   */
  set selectedElement(element) {
    const me = this, lastSelected = me._selectedElement;
    if (lastSelected) {
      const lastItem = me.getItem(lastSelected), lastItemMenu = lastItem == null ? void 0 : lastItem.menu;
      lastItemMenu == null ? void 0 : lastItemMenu.hide();
      lastSelected.classList.remove("b-active");
    }
    me._selectedElement = element;
    if (element) {
      const doFocus = DomHelper.isFocusable(element);
      element.classList.add("b-active");
      me.scrollable.scrollIntoView(element, {
        animate: !doFocus,
        focus: doFocus
      });
    }
  }
  get selectedElement() {
    return this._selectedElement;
  }
  selectFirst() {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = this.topFocusTrap;
    treeWalker.nextNode();
    this.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }
  //endregion
  //region Close
  /**
   * Gets the parent Menu if this Menu is a submenu, or `undefined`.
   * @property {Core.widget.Menu}
   */
  get parentMenu() {
    var _a2;
    const result = this.owner;
    return result && (result.isMenu ? result : (_a2 = result.up) == null ? void 0 : _a2.call(result, "menu"));
  }
  /**
   * Gets this menus root menu, the very first menu shown in a sub menu hierarchy
   * @property {Core.widget.Menu}
   * @private
   */
  get rootMenu() {
    let menu = this;
    while (menu.parentMenu instanceof this.constructor) {
      menu = menu.parentMenu;
    }
    return menu;
  }
  //endregion
};
//region Config
__publicField(Menu, "$name", "Menu");
__publicField(Menu, "type", "menu");
Menu.initClass();
Menu._$name = "Menu";

// ../Core/lib/Core/widget/MenuItem.js
var bIcon2 = /^b-icon-/;
var bFa2 = /^b-fa-/;
var MenuItem = class extends Widget {
  static get configurable() {
    return {
      /**
       * If configured with a `Boolean` value, a checkbox is displayed
       * as the start icon, and the {@link #event-toggle} event is fired
       * when the checked state changes.
       * @config {Boolean}
       */
      checked: null,
      /**
       * Set to `true` to display a border above this menu item, if there are other visible menu items before it.
       * @config {Boolean}
       * @default false
       */
      separator: null,
      /**
       * Indicates that this menu item is part of a group where only one can be checked. Assigning a value
       * also sets `toggleable` to `true`.
       * ```
       * const yesButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'Yes'
       * });
       *
       * const noButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'No'
       * });
       * ```
       * @prp {String}
       */
      toggleGroup: null,
      /**
       * Returns the instantiated menu widget as configured by {@link #config-menu}.
       * @member {Core.widget.Widget} menu
       * @readonly
       */
      /**
       * A submenu configuration object, or an array of MenuItem configuration
       * objects from which to create a submenu.
       *
       * Configuration object example:
       * ```javascript
       * new Menu({
       *     // Menu items
       *     items : {
       *         move : {
       *             text : 'Main item',
       *             menu : {
       *                 // Submenu items
       *                 firstItem : {
       *                     text : 'Sub-item 1',
       *                     onItem({ eventRecord }) {}
       *                 },
       *                 secondItem : {
       *                     text : 'Sub-item 2',
       *                     onItem({ eventRecord }) {}
       *                 }
       *             }
       *         }
       *     }
       * });
       * ```
       *
       * Array of items example:
       * ```javascript
       * new Menu({
       *     // Menu items
       *     items : {
       *         move : {
       *             text : 'Main item',
       *             // Submenu items
       *             menu : [
       *                 {
       *                     text : 'Sub-item 1',
       *                     onItem({ eventRecord }) {}
       *                 },
       *                 {
       *                     text : 'Sub-item 2',
       *                     onItem({ eventRecord }) {}
       *                 }
       *             ]
       *         }
       *     }
       * });
       * ```
       *
       * Note that this does not have to be a Menu. The `type` config can be used to specify any widget as the submenu.
       * ```javascript
       * new Menu({
       *     // Menu items
       *     items : {
       *         move : {
       *             text : 'Main item',
       *             // Submenu items
       *             menu : [
       *                 {
       *                     type  : 'textfield',
       *                     label : 'Type here'
       *                 },
       *                 {
       *                     type : 'button',
       *                     text : 'Confirm'
       *                 }
       *             ]
       *         }
       *     }
       * });
       * ```
       *
       * @config {Object<String,MenuItemConfig|ContainerItemConfig>|Array<MenuItemConfig|ContainerItemConfig>}
       */
      menu: {
        value: null,
        $config: ["lazy", "nullify"]
      },
      /**
       * Item icon class.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       * @config {String}
       */
      icon: null,
      /**
       * The text to be displayed in the item
       * @prp {String} text
       */
      /**
       * By default, upon activate, non-checkbox menu items will collapse
       * the owning menu hierarchy.
       *
       * Configure this as `false` to cause the menu to persist after
       * activating an item
       * @config {Boolean}
       */
      closeParent: null,
      /**
       * If provided, turns the menu item into a link
       * @config {String}
       */
      href: null,
      /**
       * The `target` attribute for the {@link #config-href} config
       * @config {'_self'|'_blank'|'_parent'|'_top'|null}
       */
      target: null,
      localizableProperties: ["text"],
      role: "menuitem",
      closeMenuDelay: 200
    };
  }
  updateElement(element, oldElement) {
    const result = super.updateElement(element, oldElement);
    if (typeof this.checked === "boolean") {
      this.role = "menuitemcheckbox";
    }
    this.ariaHasPopup = this.hasMenu ? "menu" : false;
    return result;
  }
  compose() {
    var _a2;
    const me = this, { checked, href, hasMenu, separator, target, text, toggleGroup } = me, isCheckItem = typeof checked === "boolean", icon = me.icon || (isCheckItem ? "b-fw-icon" : ""), checkCls = `b-icon-${toggleGroup ? "radio-" : ""}`, hasCustomContent = typeof text === "object";
    return {
      tag: href ? "a" : "div",
      tabIndex: -1,
      href,
      target,
      class: {
        "b-has-submenu": hasMenu,
        "b-checked": checked,
        // Support both separator config and directly setting separator class
        "b-separator": separator || ((_a2 = me.cls) == null ? void 0 : _a2["b-separator"])
      },
      dataset: {
        group: me.toggleGroup
      },
      // Only set aria-checked if it's a check item
      [isCheckItem ? "aria-checked" : ""]: checked,
      // Only set expanded if there's a submenu to expand
      [hasMenu ? "aria-expanded" : ""]: false,
      children: {
        iconElement: icon && {
          // This element is a purely visual cue with no meaning to the A11Y tree
          "aria-hidden": true,
          tag: "i",
          class: {
            "b-fa": bFa2.test(icon),
            "b-icon": bIcon2.test(icon),
            "b-menuitem-icon": 1,
            [`${checkCls}checked`]: checked === true,
            [`${checkCls}unchecked`]: checked === false,
            ...DomClassList.normalize(icon, "object")
          }
        },
        textElement: {
          tag: "span",
          html: hasCustomContent ? null : text,
          class: {
            "b-menu-text": 1,
            "b-menu-custom-content": hasCustomContent
          },
          children: hasCustomContent ? [text] : null
        },
        subMenuIcon: hasMenu && {
          // This element is a purely visual cue with no meaning to the A11Y tree
          "aria-hidden": true,
          tag: "i",
          class: {
            "b-fw-icon": 1,
            "b-icon-sub-menu": 1
          }
        }
      }
    };
  }
  /**
   * Actions this item. Fires the {@link #event-item} event, and if this is a {@link #config-checked} item, toggles
   * the checked state, firing the {@link #event-toggle} event.
   */
  doAction(event) {
    const item = this, menu = this.parent, itemEvent = { menu, item, element: item.element, bubbles: true, domEvent: event };
    if (typeof item.checked === "boolean") {
      const newCheckedState = !item.checked;
      if (!item.toggleGroup || newCheckedState) {
        item.checked = !item.checked;
      }
    } else if (item.href && event.key) {
      item.element.click();
    }
    item.trigger("beforeItem", itemEvent);
    item.trigger("item", itemEvent);
    if (item.closeParent && menu) {
      menu.rootMenu.close();
      if (event && !item.href) {
        event.preventDefault();
      }
    }
  }
  get focusElement() {
    return this.element;
  }
  get contentElement() {
    return this.textElement;
  }
  get isFocusable() {
    const { focusElement } = this;
    return focusElement && this.isVisible && (focusElement === document.body || focusElement.offsetParent);
  }
  get hasMenu() {
    return this.hasConfig("menu");
  }
  get childItems() {
    const { _menu } = this;
    return _menu ? [_menu] : [];
  }
  get text() {
    return this.html;
  }
  set text(text) {
    this.html = text;
  }
  onFocusIn(e) {
    super.onFocusIn(e);
    if (!this.disabled && this.menu) {
      this.delay("openMenu", 200);
    }
  }
  onFocusOut(e) {
    this.clearTimeout("openMenu");
    super.onFocusOut(e);
    if (this._menu) {
      this.menu.closeTimer = this.menu.setTimeout(() => this.closeMenu(), this.closeMenuDelay);
    }
  }
  openMenu(andFocus) {
    const { menu } = this;
    if (!this.disabled && menu) {
      menu.focusOnToFront = andFocus;
      menu.show();
    }
  }
  onChildShow(shown) {
    super.onChildShow(shown);
    this.ariaElement.setAttribute("aria-expanded", true);
  }
  closeMenu() {
    if (this._menu instanceof Widget) {
      this.menu.close();
    }
  }
  onChildHide(hidden) {
    super.onChildHide(hidden);
    this.ariaElement.setAttribute("aria-expanded", false);
  }
  changeToggleGroup(toggleGroup) {
    if (toggleGroup && typeof this.checked !== "boolean") {
      this.checked = false;
    }
    return toggleGroup;
  }
  /**
   * Get/sets the checked state of this `MenuItem` and fires the {@link #event-toggle}
   * event upon change.
   *
   * Note that this must be configured as a `Boolean` to enable the checkbox UI.
   * @member {Boolean} checked
   */
  changeChecked(checked, old) {
    if (this.isConfiguring || typeof old === "boolean") {
      return Boolean(checked);
    }
  }
  updateChecked(checked) {
    const me = this;
    if (!me.isConfiguring) {
      if (me.toggleGroup) {
        me.uncheckToggleGroupMembers();
      }
      me.element.setAttribute("aria-checked", checked);
      me.trigger("toggle", {
        menu: me.owner,
        item: me,
        element: me.element,
        bubbles: true,
        checked
      });
    }
  }
  getToggleGroupMembers() {
    const me = this, { checked, toggleGroup, element } = me, result = [];
    if (checked && toggleGroup) {
      DomHelper.forEachSelector(me.rootElement, `[data-group=${toggleGroup}]`, (otherElement) => {
        if (otherElement !== element) {
          const partnerCheckItem = Widget.fromElement(otherElement);
          partnerCheckItem && result.push(partnerCheckItem);
        }
      });
    }
    return result;
  }
  uncheckToggleGroupMembers() {
    if (this.checked && this.toggleGroup) {
      this.getToggleGroupMembers().forEach((widget) => widget.checked = false);
    }
  }
  get closeParent() {
    const result = typeof this.checked === "boolean" ? this._closeParent : this._closeParent !== false;
    return result && !this.hasMenu;
  }
  changeMenu(config, existingMenu) {
    const me = this, { constrainTo, scrollAction } = me.owner;
    if (config && typeof config === "object" && !("items" in config) && !("widgets" in config) && !("html" in config)) {
      config = {
        lazyItems: config
      };
    }
    return Menu.reconfigure(existingMenu, config, {
      owner: me,
      defaults: {
        type: "menu",
        align: "s0-e0",
        anchor: true,
        autoClose: true,
        autoShow: false,
        cls: "b-sub-menu",
        // Makes the anchor hoverable to avoid mouseleave
        forElement: me.element,
        owner: me,
        ariaLabel: me.text,
        constrainTo,
        scrollAction
      }
    });
  }
};
//region Config
__publicField(MenuItem, "$name", "MenuItem");
__publicField(MenuItem, "type", "menuitem");
MenuItem.initClass();
MenuItem._$name = "MenuItem";

// ../Core/lib/Core/feature/base/ContextMenuBase.js
var contextMenuKeyEvent;
var ContextMenuBase = class extends InstancePlugin {
  static get $name() {
    return "ContextMenuBase";
  }
  //region Config
  static get configurable() {
    return {
      /**
       * This is a type of the context menu used to generate correct names for methods and events.
       * Should be in camel case. Required to be set in subclass.
       * @config {String}
       * @readonly
       */
      type: null,
      /**
       * Gets the Menu instance that this feature is using.
       * @member {Core.widget.Menu} menu
       * @readonly
       */
      /**
       * A config which will be applied when creating the Menu component.
       * @config {MenuConfig}
       */
      menu: {
        $config: ["lazy", "nullify"],
        value: {
          type: "menu",
          autoShow: false,
          closeAction: "hide",
          scrollAction: "hide",
          constrainTo: globalThis
        }
      },
      /**
       * {@link Core/widget/Menu} items object containing named child menu items to apply to the feature's
       * provided context menu.
       *
       * This may add extra items as below, but may also remove any of the default items by configuring the name
       * of the item as `null`.
       *
       * ```javascript
       * features : {
       *     cellMenu : {
       *         // This object is applied to the Feature's predefined default items
       *         items : {
       *             switchToDog : {
       *                 text : 'Dog',
       *                 icon : 'b-fa b-fa-fw b-fa-dog',
       *                 onItem({record}) {
       *                     record.dog = true;
       *                     record.cat = false;
       *                 },
       *                 weight : 500     // Make this second from end
       *             },
       *             switchToCat : {
       *                 text : 'Cat',
       *                 icon : 'b-fa b-fa-fw b-fa-cat',
       *                 onItem({record}) {
       *                     record.dog = false;
       *                     record.cat = true;
       *                 },
       *                 weight : 510     // Make this sink to end
       *             },
       *             add : null // We do not want the "Add" submenu to be available
       *         }
       *     }
       * }
       * ```
       *
       * @config {Object<String,MenuItemConfig|Boolean|null>}
       */
      items: {},
      /**
       * Event which is used to show context menu.
       * Available options are: 'contextmenu', 'click', 'dblclick' or `false` to disable.
       * Default value is used from {@link Grid/view/GridBase#config-contextMenuTriggerEvent}
       * @config {String|Boolean}
       */
      triggerEvent: false,
      /**
       * A CSS selector targeting an element, such as an ellipsis icon that when
       * clicked will trigger the menu to show.
       * @config {String}
       */
      clickTriggerSelector: null,
      /**
       * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
       * @config {Object<String,String>} keyMap
       */
      keyMap: {
        " ": { handler: "showContextMenuByKey", weight: 100 },
        "Ctrl+Space": "showContextMenuByKey"
      }
    };
  }
  // Plugin configuration. This plugin chains some of the functions in Grid.
  // The contextmenu event is emulated from a taphold gesture on touch platforms.
  static get pluginConfig() {
    return {
      assign: ["showContextMenu"],
      chain: [
        "onElementContextMenu",
        "onElementClick",
        "onElementDblClick"
      ]
    };
  }
  //endregion
  //region Init
  construct(...args) {
    var _a2;
    super.construct(...args);
    if (!((_a2 = this.type) == null ? void 0 : _a2.length)) {
      throw new Error(`Config 'type' is required to be specified for context menu`);
    }
  }
  //endregion
  //region Events
  /**
   * This event fires on the owning widget when an item is selected in the context menu.
   * @event contextMenuItem
   * @on-owner
   * @param {Core.widget.Widget} source The owning widget
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   */
  /**
   * This event fires on the owning widget when a check item is toggled in the context menu.
   * @event contextMenuToggleItem
   * @on-owner
   * @param {Core.widget.Widget} source The owning widget
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   * @param {Boolean} checked Checked or not
   */
  onElementContextMenu(event) {
    this.onElementEvent(event);
  }
  onElementClick(event) {
    this.onElementEvent(event);
  }
  onElementDblClick(event) {
    this.onElementEvent(event);
  }
  onElementEvent(event) {
    if (!event.handled && this.triggerEvent === event.type) {
      if (event.ctrlKey === true && !BrowserHelper.isMac) {
        event.preventDefault();
        return;
      }
      const originalEvent = event;
      if (contextMenuKeyEvent) {
        const { target } = contextMenuKeyEvent;
        event = EventHelper.fixEvent(new MouseEvent(event.type, event));
        Object.defineProperty(event, "target", { get: () => target, configurable: true });
        event.preventDefault = function() {
          originalEvent.preventDefault();
          originalEvent.handled = true;
        };
      }
      this.internalShowContextMenu(event);
    } else if (event.type === "click" && this.clickTriggerSelector && event.target.matches(this.clickTriggerSelector)) {
      this.internalShowContextMenu(event, { align: "l-r", target: event.target });
    }
  }
  showContextMenuByKey(event) {
    if (!DomHelper.isEditable(event.target)) {
      const target = this.getKeyboardContextMenuTarget(event.target);
      if (target) {
        contextMenuKeyEvent = event;
        DomHelper.triggerMouseEvent(target, this.triggerEvent);
        event.handled = true;
        event.preventDefault();
        event.stopImmediatePropagation();
        contextMenuKeyEvent = null;
        return true;
      }
    }
    return false;
  }
  // Pick a target child of a keydowned element to fire a contextmenu event through.
  getKeyboardContextMenuTarget(targetElement) {
    const targetRect = DomHelper.isInView(targetElement);
    return targetElement.children.length ? DomHelper.childFromPoint(targetElement, targetRect.width / 2, targetRect.height / 2) : targetElement;
  }
  //endregion
  //region Menu handlers
  internalShowContextMenu(domEvent, alignSpec) {
    const me = this;
    if (me.disabled) {
      return;
    }
    const data = me.getDataFromEvent(domEvent);
    if (!domEvent.handled && !domEvent.defaultPrevented && data && me.shouldShowMenu(data)) {
      if (domEvent.type === "contextmenu" && BrowserHelper.isSafari && domEvent.ctrlKey && !domEvent.metaKey) {
        EventHelper.on({
          element: domEvent.target,
          capture: true,
          once: true,
          thisObj: this,
          click(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        });
      }
      data.domEvent = domEvent;
      me.showContextMenu(data, alignSpec);
    }
  }
  getDataFromEvent(event) {
    return {
      event,
      targetElement: this.getTargetElementFromEvent(event)
    };
  }
  getTargetElementFromEvent(event) {
    return event.target;
  }
  /**
   * Shows the context menu.
   * @param {Event} event The initiating event.
   * @param {AlignSpec|HTMLElement} [alignSpec] Menu alignment specification, or an element to align to
   * @on-owner
   */
  async showContextMenu(event, alignSpec) {
    var _a2, _b;
    const me = this, isDOMEvent = DomHelper.isDOMEvent(event), menuContext = isDOMEvent ? me.getDataFromEvent(event) : event, domEvent = isDOMEvent ? event : menuContext.domEvent;
    (_a2 = me._menu) == null ? void 0 : _a2.hide();
    if (me.disabled) {
      return;
    }
    me.menuContext = menuContext;
    const {
      type,
      client,
      processItems
    } = me, elCenter = DomHelper.isInView(menuContext.targetElement).center;
    Objects.assign(menuContext, {
      feature: me,
      point: (domEvent == null ? void 0 : domEvent.clientX) ? [domEvent.clientX + 1, domEvent.clientY + 1] : [elCenter.x, elCenter.y],
      menu: me,
      items: {},
      selection: client.selectedRecords
    });
    me.callChainablePopulateMenuMethod(menuContext);
    Objects.merge(menuContext.items, me.baseItems);
    me.preventDefaultEvent(menuContext);
    if ((!processItems || await me.callback(processItems, client, [menuContext]) !== false) && me.hasActiveMenuItems(menuContext)) {
      me.populateItemsWithData(menuContext);
      if (me.beforeContextMenuShow(menuContext) !== false) {
        const { menu } = me;
        let result = client.trigger(`${type}MenuBeforeShow`, menuContext);
        if (ObjectHelper.isPromise(result)) {
          domEvent.handled = true;
          result = await result;
        }
        if (result !== false) {
          menu.items = menuContext.items;
          menu.showBy(alignSpec || {
            target: menuContext.domEvent
          });
          (_b = me.touchMoveDetacher) == null ? void 0 : _b.call(me);
          me.touchMoveDetacher = EventHelper.on({
            element: client.element,
            touchmove: () => menu.hide(),
            thisObj: menu,
            once: true
          });
          if (domEvent) {
            domEvent.preventDefault();
            domEvent.handled = true;
          }
        }
      }
    }
  }
  /**
   * Returns the base, configured-in menu items set from the configured items, taking into
   * account the namedItems the feature offers.
   * @property {Object[]}
   * @readonly
   * @internal
   */
  get baseItems() {
    if (!this._baseItems) {
      const me = this, { namedItems } = me, baseItems = me._baseItems = Objects.assign({}, me.items);
      for (const ref in baseItems) {
        const item = baseItems[ref];
        if (item) {
          if (namedItems && ref in namedItems) {
            baseItems[ref] = typeof item === "object" ? Objects.merge(Objects.clone(namedItems[ref]), item) : namedItems[ref];
          } else if (item === true) {
            delete baseItems[ref];
          }
        }
      }
    }
    return this._baseItems;
  }
  /**
   * Hides the context menu
   * @internal
   */
  hideContextMenu(animate) {
    var _a2;
    (_a2 = this.menu) == null ? void 0 : _a2.hide(animate);
  }
  callChainablePopulateMenuMethod(eventParams) {
    var _a2, _b;
    (_b = (_a2 = this.client)[`populate${StringHelper.capitalize(this.type)}Menu`]) == null ? void 0 : _b.call(_a2, eventParams);
  }
  hasActiveMenuItems(eventParams) {
    return Object.values(eventParams.items).some((item) => item && !item.hidden);
  }
  /**
   * Override this function and return `false` to prevent the context menu from being shown. Returns `true` by default.
   * @returns {Boolean}
   * @internal
   */
  shouldShowMenu() {
    return true;
  }
  beforeContextMenuShow(eventParams) {
  }
  populateItemsWithData(eventParams) {
  }
  preventDefaultEvent(eventParams) {
    var _a2;
    (_a2 = eventParams.event) == null ? void 0 : _a2.preventDefault();
  }
  //endregion
  //region Configurables
  changeTriggerEvent(triggerEvent) {
    return triggerEvent || this.client.contextMenuTriggerEvent;
  }
  changeMenu(menu, oldMenu) {
    const me = this, {
      client,
      type
    } = me;
    if (menu) {
      return Menu.reconfigure(oldMenu, menu ? Menu.mergeConfigs({
        owner: client,
        rootElement: client.rootElement,
        onItem(itemEvent) {
          client.trigger(`${type}MenuItem`, itemEvent);
        },
        onToggle(itemEvent) {
          client.trigger(`${type}MenuToggleItem`, itemEvent);
        },
        onDestroy() {
          me.menu = null;
        },
        // Load up the item event with the contextual info
        onBeforeItem(itemEvent) {
          Object.assign(itemEvent, me.menuContext);
        },
        onShow({ source: menu2 }) {
          me.menuContext.menu = menu2;
          client.trigger(`${type}MenuShow`, me.menuContext);
        }
      }, menu) : null, me);
    } else if (oldMenu == null ? void 0 : oldMenu.isWidget) {
      oldMenu.destroy();
    }
  }
  //endregion
};
ContextMenuBase._$name = "ContextMenuBase";

// ../Core/lib/Core/helper/TemplateHelper.js
var tagSpaceRe = />[ \t\r\n]+</g;
var multiSpaceRe = /\s\s+/g;
var TemplateHelper = class _TemplateHelper {
  /**
   * Tag function for template literals that does some basic cleanup
   * @private
   */
  static tpl(strings, ...values) {
    let count = 0, output = values.map((val, i) => {
      let ret = strings[i];
      if (Array.isArray(val)) {
        ret += val.reduce((ack, item) => ack += (typeof item === "string" ? item.trim() : item) + "\n", "");
      } else {
        if (val === void 0) {
          val = "";
        }
        ret += typeof val === "string" ? val.trim() : val;
      }
      count++;
      return ret;
    }).join("");
    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }
    return output.replace(tagSpaceRe, "><").replace(multiSpaceRe, " ").trim();
  }
  /**
   * Tag function for template literals that does some basic cleanup. Version for docs that do not remove blank space,
   * to keep code snippets formatting intact.
   * @private
   */
  static docsTpl(strings, ...values) {
    let count = 0, output = values.map((val, i) => {
      let ret = strings[i];
      if (Array.isArray(val)) {
        ret += val.reduce((ack, item) => ack += (typeof item === "string" ? item.trim() : item) + "\n", "");
      } else {
        if (val === void 0) {
          val = "";
        }
        ret += typeof val === "string" ? val.trim() : val;
      }
      count++;
      return ret;
    }).join("");
    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }
    return output.replace(tagSpaceRe, "><").trim();
  }
  static repeat(times) {
    return function(...args) {
      return _TemplateHelper.tpl(...args).repeat(times);
    };
  }
  static loop(times) {
  }
};
TemplateHelper._$name = "TemplateHelper";

// ../Core/lib/Core/helper/TimeZoneHelper.js
var TimeZoneOffsetInfo = class extends Array {
  constructor(timeZone, year) {
    super();
    this.timeZone = timeZone;
    this.year = year;
  }
};
var TimeZoneDate = class {
  constructor(asString, timeZone) {
    this.asString = asString;
    this.timeZone = timeZone;
    this.asArray = parseStringDate(asString);
  }
  // Lazy, used in TZH.toTimeZone
  get asLocalDate() {
    if (!this._asLocalDate) {
      this._asLocalDate = new Date(...this.asArray);
    }
    return this._asLocalDate;
  }
  // Lazy, used when finding offsets
  get asTicksUtc() {
    if (!this._asTicksUtc) {
      this._asTicksUtc = new Date(Date.UTC(...this.asArray)).getTime();
    }
    return this._asTicksUtc;
  }
};
var toTimeZoneInternal = (date, timeZone) => {
  const tzDateString = date.toLocaleString("sv-SE", { timeZone });
  return new TimeZoneDate(tzDateString, timeZone);
};
var getOffsetUtc = (ticks, timeZone) => {
  const { asTicksUtc, asString } = toTimeZoneInternal(new Date(ticks), timeZone);
  return { offset: (ticks - asTicksUtc) / 6e4, tzTicksUtc: asTicksUtc, tzString: asString };
};
var parseStringDate = (stringDate) => {
  const parsed = stringDate.split(/[\s-:]/).map((i) => i * 1);
  parsed[1] -= 1;
  return parsed;
};
var min = -6e4;
var hour = 36e5;
var day = -864e5;
var month = 2592e6;
var findOffsetDates = (timeZone, year) => {
  const cached = offsetDateCache.get(timeZone, year);
  if (cached) {
    return cached;
  }
  const offsets = new TimeZoneOffsetInfo(timeZone, year), startUtcTicks = new Date(Date.UTC(year, 0, 1)).getTime();
  let ticks = startUtcTicks, incr = month, monthIndex = 0, previousOffset = [], currentOffset = null, tzTicksUtc, tzString, offset, done;
  while (!done) {
    ({ offset, tzTicksUtc, tzString } = getOffsetUtc(ticks, timeZone));
    if (currentOffset == null) {
      currentOffset = offset;
      offsets.push({ offset });
    } else if (incr > 0 && offset !== currentOffset) {
      incr = incr === month ? day : min;
    } else if (incr < 0 && offset === currentOffset) {
      if (incr === day) {
        incr = hour;
      } else {
        if (offsets.length === 1) {
          offsets.push(previousOffset);
          currentOffset = previousOffset.offset;
        } else {
          offsets[0].startTicks = previousOffset.startTicks;
          offsets[0].startDateString = previousOffset.startDateString;
          done = true;
        }
        incr = month;
      }
    }
    previousOffset = { offset, startDateString: tzString, startTicks: tzTicksUtc };
    if (incr === month) {
      ticks = startUtcTicks;
      ticks += monthIndex * month;
      monthIndex += 1;
    }
    ticks += incr;
    if (monthIndex > 11) {
      done = true;
    }
  }
  offsetDateCache.set(offsets);
  return offsets;
};
var offsetDateCache = {
  _cache: {},
  get(timeZone, year) {
    var _a2;
    return (_a2 = this._cache[timeZone]) == null ? void 0 : _a2[year];
  },
  set(offsetInfo) {
    const { timeZone } = offsetInfo, { _cache } = this;
    if (!_cache[timeZone]) {
      _cache[timeZone] = {};
    }
    _cache[timeZone][offsetInfo.year] = offsetInfo;
  }
};
var TimeZoneHelper = class {
  static get $name() {
    return "TimeZoneHelper";
  }
  /**
   * Adjusts the time of the specified date to match the specified time zone. i.e. "what time is it now in this
   * timezone?"
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * Note that this time zone calculation relies on the browsers built-in functionality to convert a local date to a
   * string in a given time zone and then converting the string back into a date. If browsers time zone information
   * or interpretation is inaccurate or lacks data, the conversion will probably be inaccurate as well.
   *
   * ```javascript
   * const localDate = new Date(2020, 7, 31, 7); // UTC+2 ('Europe/Stockholm')
   * const cstDate   = TimeZoneHelper.toTimezone(localDate, 'America/Chicago'); // 2020, 7, 31, 0 (still UTC+2, but
   * // appear as UTC-6)
   * ```
   *
   * @static
   * @param {Date} date
   * @param {String|Number} timeZone Timezone supported by `Intl.DateFormat` or a UTC offset in minutes
   * @returns {Date}
   */
  static toTimeZone(date, timeZone) {
    if (typeof timeZone === "number") {
      return this.toUtcOffset(date, timeZone);
    }
    const tzDate = toTimeZoneInternal(date, timeZone);
    if (tzDate.asArray[3] !== tzDate.asLocalDate.getHours()) {
      console.warn("Incorrect time zone conversion due to local DST-switch detected");
    }
    return tzDate.asLocalDate;
  }
  /**
   * Adjusts the time of the specified date to match local system time zone in the specified time zone. i.e. "what
   * time in my timezone would match time in this timezone?"
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * Note that this time zone calculation relies on the browsers built-in functionality to convert a date from a given
   * timezone into a local date by calculating specified time zone UTC offsets and using those to perform the date
   * conversion. If browsers time zone information or interpretation is inaccurate or lacks data, the conversion will
   * probably be inaccurate as well.
   *
   * ```javascript
   * const cstDate   = new Date(2022, 8, 27, 4); // CST 'America/Chicago'
   * const localDate = TimeZoneHelper.fromTimeZone(cstDate, 'America/Chicago'); // 2022, 8, 27, 11 (UTC+2 Europe/Stockholm)
   * ```
   *
   * @static
   * @param {Date} date
   * @param {String|Number} timeZone Timezone supported by Intl.DateFormat or a UTC offset in minutes
   * @returns {Date}
   */
  static fromTimeZone(date, timeZone) {
    if (typeof timeZone === "number") {
      return this.fromUtcOffset(date, timeZone);
    }
    const dateArr = this.dateAsArray(date), offsetDates = findOffsetDates(timeZone, date.getUTCFullYear());
    let useOffset = offsetDates[0].offset;
    if (offsetDates.length === 2) {
      const utcTicks = Date.UTC(...dateArr);
      if (utcTicks >= offsetDates[1].startTicks && utcTicks < offsetDates[0].startTicks) {
        useOffset = offsetDates[1].offset;
      }
    }
    dateArr[4] += useOffset;
    return new Date(Date.UTC(...dateArr));
  }
  /**
   * Adjusts the time of the specified date with provided UTC offset in minutes
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * ```javascript
   * const localDate = new Date(2020, 7, 31, 7); // UTC+2
   * const utcDate   = TimeZoneHelper.toUtcOffset(localDate, 0); // 2020, 7, 31, 5 (still UTC+2, but appear as UTC+0)
   * ```
   *
   * @static
   * @private
   * @param {Date} date
   * @param {Number} utcOffset in minutes
   * @returns {Date}
   */
  static toUtcOffset(date, utcOffset) {
    const offset = date.getTimezoneOffset() + utcOffset;
    return new Date(date.getTime() + offset * 60 * 1e3);
  }
  /**
   * Adjusts the time of the specified date by removing the provided UTC offset in minutes.
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * ```javascript
   * const utcDate = new Date(2020, 7, 31, 7); // UTC
   * const utcDate = TimeZoneHelper.fromUtcOffset(localDate, 0); // 2020, 7, 31, 9 (matches 2020-08-31 07:00+00:00)
   * ```
   *
   * @static
   * @private
   * @param {Date} date
   * @param {Number} utcOffset in minutes
   * @returns {Date}
   */
  static fromUtcOffset(date, utcOffset) {
    const offset = -date.getTimezoneOffset() - utcOffset;
    return new Date(date.getTime() + offset * 60 * 1e3);
  }
  // Converts a date into an array of its parts ([year, month, day, etc.]).
  // Convenient as a date info bearer which is not affected by local time zone
  static dateAsArray(date) {
    return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];
  }
};
TimeZoneHelper.findOffsetDates = findOffsetDates;
TimeZoneHelper._$name = "TimeZoneHelper";

// ../Core/lib/Core/helper/util/Navigator.js
var Navigator = class extends Base.mixin(Events_default, Factoryable_default) {
  static get $name() {
    return "Navigator";
  }
  // Factoryable type name
  static get type() {
    return "navigator";
  }
  static get configurable() {
    return {
      /**
       * The owning Widget which is using this Navigator.
       * @config {Core.widget.Widget}
       */
      ownerCmp: null,
      /**
       * If the items in the owning widget are naturally tabbable, then the Navigator does not
       * need to listen for navigation keys and move focus. It just reacts to natural focus
       * movement.
       * @config {Boolean}
       */
      itemsTabbable: null,
      /**
       * The encapsulating element in which navigation takes place.
       * @config {HTMLElement}
       */
      target: null,
      /**
       * The element which provides key events for navigation. Optional. Defaults to the {@link #config-target} element.
       * @config {HTMLElement}
       */
      keyEventTarget: null,
      /**
       * An optional key event processor which may preprocess the key event. Returning `null` prevents processing of the event.
       * @param {KeyboardEvent} event
       * @returns {Boolean|null}
       * @config {Function}
       */
      processEvent: null,
      /**
       * A query selector which identifies descendant elements within the {@link #config-target} which are navigable.
       * @config {String}
       */
      itemSelector: null,
      /**
       * The currently focused element within the {@link #config-target}.
       * @config {HTMLElement}
       */
      activeItem: null,
      /**
       * A CSS class name to add to focused elements.
       * @config {String}
       * @default
       */
      focusCls: "b-active",
      /**
       * An object containing key definitions keyed by the key name eg:
       *
       * ```javascript
       *  keys : {
       *      "CTRL+Space" : 'onCtrlSpace',
       *      Enter        : 'onEnterKey'
       *  }
       * ```
       *
       * The {@link #config-ownerCmp} is used as the `this` reference and to resolve string method names.
       *
       * Modified key names must be created prepending one or more `'CTRL+'`, `'SHIFT+'`, `'ALT+'`
       * in that order, for example `"CTRL+SHIFT+Enter" : 'showMenu'`
       * @config {Object<String,String>}
       * @default
       */
      keys: null,
      /**
       * Configure as `true` to also navigate when the `CTRL` modifier key is used along with
       * navigation keys.
       * @config {Boolean}
       * @default false
       */
      allowCtrlKey: null,
      /**
       * Configure as `true` to also navigate when the `SHIFT` modifier key is used along with
       * navigation keys.
       * @config {Boolean}
       * @default false
       */
      allowShiftKey: null,
      scrollDuration: 50,
      /**
       * Configure as, or set to `true` to disable the processing of keys.
       * @config {Boolean}
       */
      disabled: null,
      datasetIdProperty: "id",
      testConfig: {
        scrollDuration: 1
      }
    };
  }
  static get factoryable() {
    return {
      defaultType: "navigator"
    };
  }
  get activeItem() {
    const { _activeItem } = this;
    if (this.target.contains(_activeItem)) {
      return _activeItem;
    }
    this._activeItem = null;
  }
  updateOwnerCmp(ownerCmp) {
    if (!this.itemSelector) {
      this.itemSelector = `.${this.ownerCmp.itemCls}`;
    }
    DomHelper.setAttributes(this.keyEventTarget, {
      "aria-activedescendant": `${this.owner.id}-active-descendant`
    });
  }
  set navigationEvent(navigationEvent) {
    const { owner } = this;
    this._navigationEvent = owner.navigationEvent = navigationEvent;
    if (navigationEvent) {
      Promise.resolve(1).then(() => this.navigationEvent = null);
    }
  }
  get navigationEvent() {
    return this._navigationEvent;
  }
  static getComposedKeyName(keyEvent) {
    const keyName = (keyEvent.key || "").trim() || keyEvent.code;
    return `${keyEvent.ctrlKey ? "CTRL+" : ""}${keyEvent.shiftKey ? "SHIFT+" : ""}${keyEvent.altKey ? "ALT+" : ""}${keyName}`;
  }
  onKeyDown(keyEvent) {
    var _a2;
    const me = this, {
      ownerCmp,
      itemSelector,
      activeItem,
      itemsTabbable
    } = me, { target } = keyEvent, firstItem = me.target.querySelector(itemSelector), keyName = (keyEvent.key || "").trim() || keyEvent.code, composedKeyName = me.constructor.getComposedKeyName(keyEvent), validTarget = target.matches(itemSelector) || target === me.keyEventTarget;
    if (!me.disabled && me.processEvent) {
      keyEvent = me.processEvent.call(ownerCmp, keyEvent);
    }
    if (keyEvent && !me.disabled && firstItem && me.target.offsetParent && validTarget) {
      if (!itemsTabbable) {
        if (me.inlineFlow == null) {
          const itemContainer = firstItem.parentNode, itemPositionStyle = DomHelper.getStyleValue(firstItem, "position"), itemDisplayStyle = DomHelper.getStyleValue(firstItem, "display"), itemFloatStyle = DomHelper.getStyleValue(firstItem, "float");
          me.inlineFlow = itemPositionStyle === "absolute" || itemDisplayStyle === "inline" || itemDisplayStyle === "inline-block" || itemFloatStyle === "left" || itemFloatStyle === "right" || DomHelper.getStyleValue(itemContainer, "display") === "flex" && DomHelper.getStyleValue(itemContainer, "flex-direction") === "row";
        }
        if (!me.prevKey) {
          if (me.inlineFlow) {
            me.prevKey = "ArrowLeft";
            me.nextKey = "ArrowRight";
          } else {
            me.prevKey = "ArrowUp";
            me.nextKey = "ArrowDown";
          }
        }
      }
      me.navigationEvent = keyEvent;
      if (activeItem) {
        switch (keyName) {
          case me.prevKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            keyEvent.handled = true;
            me.navigatePrevious(keyEvent);
            break;
          case me.nextKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            keyEvent.handled = true;
            me.navigateNext(keyEvent);
            break;
          default: {
            const keyHandler = (_a2 = me.keys) == null ? void 0 : _a2[composedKeyName];
            if (keyHandler && !me.disabled) {
              if (me.callback(keyHandler, me.thisObj || ownerCmp, [keyEvent]) === false) {
                return;
              }
            } else if (ownerCmp.onInternalKeyDown) {
              ownerCmp.onInternalKeyDown(keyEvent);
            }
            if (DomHelper.getActiveElement(target) !== target) {
              keyEvent.preventDefault();
            }
            if (itemsTabbable) {
              return;
            }
          }
        }
      } else {
        if (itemsTabbable) {
          return;
        }
        if (keyName === me.nextKey || keyName === me.prevKey) {
          me.activeItem = me.getDefaultNavigationItem(keyEvent);
        }
      }
      if (me.activeItem !== activeItem) {
        me.triggerNavigate(keyEvent);
      }
    }
  }
  getDefaultNavigationItem(keyEvent) {
    const { target, itemSelector, prevKey, nextKey } = this;
    if (target.compareDocumentPosition(keyEvent.target) & 4 && keyEvent.key === prevKey) {
      return target.querySelector(`${itemSelector}:last-of-type`);
    }
    if (target.compareDocumentPosition(keyEvent.target) & 2 && keyEvent.key === nextKey) {
      return target.querySelector(`${itemSelector}`);
    }
  }
  navigatePrevious(keyEvent) {
    const me = this, previous = me.previous;
    keyEvent.preventDefault();
    if (previous) {
      me.ownerCmp.scrollable.scrollIntoView(previous, { animate: me.scrollDuration }).then(() => {
        me.activeItem = previous;
        me.triggerNavigate(keyEvent);
      });
    }
  }
  navigateNext(keyEvent) {
    const me = this, next = me.next;
    keyEvent.preventDefault();
    if (next) {
      me.ownerCmp.scrollable.scrollIntoView(next, { animate: me.scrollDuration }).then(() => {
        me.activeItem = next;
        me.triggerNavigate(keyEvent);
      });
    }
  }
  get owner() {
    return this.ownerCmp;
  }
  get previous() {
    return this.getAdjacent(-1);
  }
  get next() {
    return this.getAdjacent(1);
  }
  /**
   * Returns the next or previous navigable element starting from the passed `from` element,
   * navigating in the passed direction.
   * @param {HTMLElement} [from] The start point. Defaults to the current {@link #config-activeItem}
   * @param {Number} [direction=1] The direction. -1 for backwards, else forwards.
   */
  getAdjacent(direction = 1, from = this.activeItem) {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = from;
    treeWalker[direction < 0 ? "previousNode" : "nextNode"]();
    if (treeWalker.currentNode !== this.activeItem) {
      return treeWalker.currentNode;
    }
  }
  onTargetFocusIn(focusInEvent) {
    var _a2;
    const me = this, {
      target,
      relatedTarget
    } = focusInEvent, {
      owner,
      itemsTabbable,
      skipScrollIntoView,
      previousActiveItem
    } = me;
    if (!target.matches(".b-focus-trap")) {
      if (target.matches(me.itemSelector)) {
        me.skipScrollIntoView = true;
        me.activeItem = target;
        me.skipScrollIntoView = skipScrollIntoView;
        if (me.activeItem && itemsTabbable) {
          me.triggerNavigate(focusInEvent);
        }
      } else if (target === me.target) {
        const fromWhere = relatedTarget ? target.compareDocumentPosition(relatedTarget) : 0;
        if (fromWhere & Node.DOCUMENT_POSITION_CONTAINED_BY) {
          (_a2 = owner.previousSibling) == null ? void 0 : _a2.focus();
        } else {
          me.activeItem = previousActiveItem && me.target.contains(previousActiveItem) ? previousActiveItem : 0;
        }
      }
    }
  }
  onTargetFocusOut(focusOutEvent) {
    const me = this, { relatedTarget } = focusOutEvent;
    if (!(relatedTarget == null ? void 0 : relatedTarget.matches(".b-focus-trap"))) {
      if (!relatedTarget || !me.target.contains(relatedTarget) || !relatedTarget.matches(me.itemSelector)) {
        if (me.activeItem) {
          me.activeItem = null;
          if (me.itemsTabbable) {
            me.triggerNavigate(focusOutEvent);
          }
        }
      }
    }
  }
  onTargetMouseDown(mouseDownEvent) {
    const me = this, target = mouseDownEvent.target.closest(me.itemSelector);
    me.navigationEvent = mouseDownEvent;
    if (me.itemsTabbable) {
      if (target === me.activeItem) {
        me.triggerNavigate(mouseDownEvent);
      }
    } else if (me.ownerCmp.itemsFocusable === false) {
      me.onFocusGesture(mouseDownEvent);
    } else if (target) {
      mouseDownEvent.preventDefault();
      DomHelper.focusWithoutScrolling(target);
    }
  }
  onTargetClick(clickEvent) {
    var _a2;
    const me = this, { skipScrollIntoView } = me;
    if (me.skipNextClick || ((_a2 = me.navigationEvent) == null ? void 0 : _a2.ignoreNavigation)) {
      me.skipNextClick = false;
      return;
    }
    if (me.disabled) {
      return;
    }
    me.skipScrollIntoView = true;
    if (me.processEvent) {
      clickEvent = me.processEvent.call(me.ownerCmp, clickEvent);
    }
    if (clickEvent) {
      me.activeItem = clickEvent.target.closest(me.itemSelector);
      me.triggerNavigate(clickEvent);
    }
    me.skipScrollIntoView = skipScrollIntoView;
  }
  // We have to prevent focus moving from eg, an input field when we mousedown
  // or touchtap a non focusable item when ownerCmp has itemsFocusable: false.
  // If the event was not on an item, we must allow it through to allow Lists
  // to contain other widgets.
  onFocusGesture(event) {
    if (event.target === this.ownerCmp.contentElement || event.target.closest(this.itemSelector) && this.ownerCmp.itemsFocusable === false) {
      event.preventDefault();
    }
  }
  acceptNode(node) {
    return node.offsetParent && node.matches && node.matches(this.itemSelector) ? DomHelper.NodeFilter.FILTER_ACCEPT : DomHelper.NodeFilter.FILTER_SKIP;
  }
  changeActiveItem(activeItem) {
    if (activeItem != null) {
      if (this.ownerCmp.getItem) {
        activeItem = this.ownerCmp.getItem(activeItem);
      }
    }
    return activeItem;
  }
  updateActiveItem(activeItem, oldActiveItem) {
    var _a2;
    const me = this, { ownerCmp } = me, isActive = oldActiveItem && me.target.contains(oldActiveItem), needsFocus = activeItem && DomHelper.isFocusable(activeItem) && activeItem !== DomHelper.getActiveElement(activeItem);
    if (isActive) {
      me.previousActiveItem = oldActiveItem;
    }
    if (oldActiveItem) {
      oldActiveItem.classList.remove(me.focusCls);
      oldActiveItem.removeAttribute("id");
    }
    if (activeItem != null) {
      if (me.skipScrollIntoView) {
        if (needsFocus) {
          DomHelper.focusWithoutScrolling(activeItem);
        }
      } else {
        (_a2 = ownerCmp.scrollable) == null ? void 0 : _a2.scrollIntoView(activeItem, {
          block: "nearest",
          focus: needsFocus,
          silent: me.scrollSilently
        });
      }
      if (activeItem === oldActiveItem && isActive) {
        return;
      }
      activeItem.classList.add(me.focusCls);
      activeItem.id = `${me.owner.id}-active-descendant`;
      me._activeItem = activeItem;
    } else {
      me._activeItem = null;
      if (oldActiveItem === DomHelper.getActiveElement(oldActiveItem)) {
        ownerCmp.revertFocus();
      }
    }
  }
  updateTarget(target, oldTarget) {
    const me = this, listeners = {
      element: target,
      thisObj: me,
      focusin: "onTargetFocusIn",
      focusout: "onTargetFocusOut",
      // If items are tabbable the mousedown handler will not force the issue by focusing
      // the closest item. We just need to trigger the method so that it is hookable
      mousedown: {
        handler: "onTargetMouseDown",
        delegate: me.itemSelector
      }
    };
    if (!me.itemsTabbable && !me.itemsFocusable) {
      listeners.click = "onTargetClick";
    }
    if (!Object.prototype.hasOwnProperty.call(me, "acceptNode")) {
      me.acceptNode = me.acceptNode.bind(me);
      me.acceptNode.acceptNode = me.acceptNode;
    }
    EventHelper.on(listeners);
    me.treeWalker = me.setupTreeWalker(target, DomHelper.NodeFilter.SHOW_ELEMENT, me.acceptNode);
    if (!me.keyEventTarget) {
      me.keyEventTarget = target;
    }
    (me.targetMutationMonitor = new MutationObserver(me.onTargetChildListChange.bind(me))).observe(target, {
      childList: true,
      subtree: true
    });
  }
  setupTreeWalker(root, whatToShow, filter) {
    return document.createTreeWalker(root, whatToShow, filter);
  }
  onTargetChildListChange() {
    var _a2;
    const me = this, {
      activeItem,
      datasetIdProperty
    } = me;
    if (activeItem) {
      if (me.target.contains(activeItem)) {
        if (!activeItem.classList.contains(me.focusCls)) {
          activeItem.classList.add(me.focusCls);
        }
      } else {
        me.activeItem = me.target.querySelector(`${me.itemSelector}.${me.focusCls}[data-${StringHelper.hyphenate(datasetIdProperty)}="${activeItem.dataset[datasetIdProperty]}"]`) || ((_a2 = me.target.querySelector(`${me.itemSelector}.${me.focusCls}`)) == null ? void 0 : _a2[activeItem.dataset.index]) || null;
      }
    }
  }
  changeKeyEventTarget(keyEventTarget) {
    this._keyEventTarget = keyEventTarget;
    EventHelper.on({
      element: keyEventTarget,
      keydown: "onKeyDown",
      thisObj: this
    });
  }
  triggerNavigate(event, item = this.activeItem) {
    var _a2;
    const navEvent = {
      event,
      item,
      oldItem: this.previousActiveItem
    };
    this.trigger("navigate", navEvent);
    (_a2 = this.ownerCmp) == null ? void 0 : _a2.trigger("navigate", navEvent);
  }
};
Navigator._$name = "Navigator";

// ../Core/lib/Core/mixin/LoadMaskable.js
var LoadMaskable_default = (Target) => {
  var _a2;
  return _a2 = class extends Target {
    static get configurable() {
      return {
        /**
         * A {@link Core.widget.Mask} config object to adjust the {@link Core.widget.Widget#config-maskDefaults}
         * when data is loading. The message and optional configuration from the
         * {@link Core.mixin.LoadMaskable#config-loadMask} config take priority over these options, just as they do
         * for `maskDefaults`, respectively.
         *
         * The final mask configuration for a load mask is as if the following were applied:
         *
         * ```
         *  Object.assign({},
         *      widget.maskDefaults,
         *      widget.loadMaskDefaults,
         *      widget.loadMask);
         * ```
         * @config {MaskConfig}
         * @category Masking
         */
        loadMaskDefaults: {
          useTransition: true,
          showDelay: 1e3
        },
        /**
         * A {@link Core.widget.Mask} config object to adjust the {@link Core.widget.Widget#config-maskDefaults}
         * when an error occurs loading data.
         *
         * Set to `false` to disable showing data loading error mask.
         *
         * The final mask configuration for an error mask is as if the following were applied:
         *
         * ```
         *  Object.assign({},
         *      widget.maskDefaults,
         *      widget.loadMaskDefaults,
         *      widget.loadMaskError,
         *      errorMessage);
         * ```
         * @config {MaskConfig|Core.widget.Mask|Boolean}
         * @category Masking
         */
        loadMaskError: {
          icon: "b-icon b-icon-warning",
          autoClose: 3e3,
          showDelay: 0
        },
        /**
         * A {@link Core.widget.Mask} config object, or a message to be shown when a store is performing a remote
         * operation, or Crud Manager is loading data from the sever. Set to `null` to disable default load mask.
         *
         * @config {String|MaskConfig|null}
         * @default "Loading..."
         * @category Masking
         */
        loadMask: {
          text: "L{GridBase.loadMask}"
        },
        /**
         * A {@link Core.widget.Mask} config object, or a message to be shown when Crud Manager
         * is persisting changes on the server. Set to `null` to disable default sync mask.
         *
         * This config is similar to {@link Core.mixin.LoadMaskable#config-loadMask} but designed for saving data.
         *
         * To create a custom sync mask need to subscribe to the Crud Manager events and show
         * {@link Core.widget.Mask Mask} on `beforeSend` and hide it on `requestDone` and `requestFail`.
         *
         * To create a custom sync mask, set this config to `null` and subscribe to the CrudManager's events to
         * show or hide the {@link Core.widget.Widget#config-masked mask} as desired.
         *
         * ```javascript
         *  widget.crudManager.on({
         *      loadStart() {
         *          widget.masked = {
         *              text : 'Data is loading...'
         *          };
         *      },
         *      load() {
         *          widget.masked = null;
         *      },
         *      loadCanceled() {
         *          widget.masked = null;
         *      },
         *      syncStart() {
         *          widget.masked = null;
         *      },
         *      sync() {
         *          widget.masked = null;
         *      },
         *      syncCanceled() {
         *          widget.masked = null;
         *      },
         *      requestFail({ response }) {
         *          widget.masked.error = response.message || 'Sync failed';
         *      }
         *  });
         *
         *  store.load();
         * ```
         *
         * @config {String|MaskConfig|null}
         * @default "Saving changes, please wait..."
         * @category Masking
         */
        syncMask: {
          text: "L{GridBase.syncMask}"
        },
        localizableProperties: ["loadMask.text", "syncMask.text"],
        testConfig: {
          loadMaskError: {
            icon: "b-icon b-icon-warning",
            autoClose: 500,
            showDelay: 0
          }
        }
      };
    }
    /**
     * Applies the {@link Core.mixin.LoadMaskable#config-loadMask} as the {@link Core.widget.Widget#config-masked mask}
     * for this widget.
     * @returns {Core.widget.Mask}
     * @internal
     */
    applyLoadMask() {
      const me = this, { loadMask } = me;
      if (loadMask) {
        me.masked = Mask.mergeConfigs(me.loadMaskDefaults, loadMask);
      }
      return me.masked;
    }
    /**
     * Updates the current {@link Core.widget.Widget#config-masked mask} for this widget to present the specified
     * `error`.
     * @param {String} error The error message to display in the mask.
     * @returns {Core.widget.Mask}
     * @internal
     */
    applyMaskError(error) {
      const { loadMaskError, masked } = this;
      if (loadMaskError === false) {
        masked.hide();
      } else if (masked) {
        ObjectHelper.assign(masked.errorDefaults, loadMaskError);
        masked.error = error;
      }
      return masked;
    }
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {
    }
  }, __publicField(_a2, "$name", "LoadMaskable"), _a2;
};

// ../Core/lib/Core/util/DayTime.js
var MILLIS_PER_MINUTE = 60 * 1e3;
var MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;
var MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;
var timeRe = /(\d+)?:?(\d*)/;
var DayTime = class _DayTime {
  /**
   * Returns a string of "HH:MM" for a given time of day in milliseconds.
   * @param {Number} timeOfDay The time of day in milliseconds.
   * @returns {String}
   * @private
   */
  static format(timeOfDay) {
    const h = Math.floor(timeOfDay / MILLIS_PER_HOUR), m = Math.floor(timeOfDay / MILLIS_PER_MINUTE) % 60;
    return `${h}:${m < 10 ? "0" : ""}${m}`;
  }
  /**
   * Parses a time of day which may be a number (0-24 for the hour of the day) or a string in "H:MM" format and
   * returns the time of day as a number of milliseconds.
   *
   * If `time` is a `Date` instance, its time of day is returned.
   * @param {Date|Number|String} time
   * @returns {Number}
   * @private
   */
  static parse(time) {
    const type = typeof time;
    if (type === "string") {
      const match = timeRe.exec(time);
      time = Number(match[1] || 0) * MILLIS_PER_HOUR + Number(match[2] || 0) * MILLIS_PER_MINUTE;
    } else if (type !== "number") {
      time = DateHelper.getTimeOfDay(time);
    } else if (time <= 24) {
      time *= MILLIS_PER_HOUR;
    }
    return Math.min(Math.max(Math.floor(time), 0), MILLIS_PER_DAY);
  }
  constructor(config) {
    let startShift = 0, startTime, endTime;
    if (config == null ? void 0 : config.isDayView) {
      startShift = config.dayStartShift;
      startTime = config.dayStartTime;
      endTime = config.dayEndTime;
    } else if (typeof config === "number") {
      startShift = startTime = endTime = config;
    } else if (config) {
      startShift = config.startShift;
      startTime = config.timeStart;
      endTime = config.timeEnd;
    }
    this.startShift = startShift = _DayTime.parse(startShift || 0);
    this.timeEnd = (endTime == null ? (startShift + MILLIS_PER_DAY) % MILLIS_PER_DAY : _DayTime.parse(endTime)) || MILLIS_PER_DAY;
    this.timeStart = startTime == null ? startShift : _DayTime.parse(startTime);
  }
  get startHour() {
    return Math.floor(this.timeStart / MILLIS_PER_HOUR);
  }
  get endHour() {
    return Math.floor(this.timeEnd / MILLIS_PER_HOUR);
  }
  /**
   * The number of milliseconds from the day's `startShift` to its `timeStart`.
   * @member {Number}
   */
  get startTimeOffsetMs() {
    const { startShift, timeStart } = this;
    return timeStart < startShift ? MILLIS_PER_DAY - startShift + timeStart : timeStart - startShift;
  }
  /**
   * The `Date` object for the most recently started, shifted day. The time of this `Date` will be the `startShift`.
   * It is possible for this date to be yesterday on a midnight-based calendar. For example, if the `startShift` is
   * 6PM and the current time is 6AM on May 20, this value will be 6PM of May 19 (the most recently started day).
   * @member {Date}
   */
  get today() {
    return this.startOfDay(/* @__PURE__ */ new Date());
  }
  /**
   * Returns `Date` object for the nearest (shifted) day ending after the given `date`. The time of this `Date` will
   * be the `startShift`.
   *
   * It is possible for this date to be in the next day on a midnight-based calendar. For example, if the `startShift`
   * is 6PM and `date` is 7PM on May 20, this method will return 6PM of May 21 (the nearest day ending).
   * @param {Date} date The date for which to find the nearest day ending.
   * @returns {Date}
   */
  ceil(date) {
    const ret = this.startOfDay(date);
    if (ret < date) {
      ret.setDate(ret.getDate() + 1);
    }
    return ret;
  }
  /**
   * Returns `true` if the time of day for the given `date` is between `timeStart` and `timeEnd`.
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance to test.
   * @returns {Boolean}
   */
  contains(date) {
    return !this.outside(date);
  }
  /**
   * Returns a "YYYY-MM-DD" string for the given `date`. This value will match the `date` if the time of day is at or
   * after `startShift`, but will be the prior date otherwise.
   * @param {Date|Number} date The date from which to compute the 'YYYY-MM-DD' key.
   * @returns {String}
   */
  dateKey(date) {
    date = this.shiftDate(date, -1);
    return DateHelper.makeKey(date);
  }
  /**
   * Returns a `Date` instance with `startShift` as the time of day and the Y/M/D of the given `date`.
   * @param {Date} date The date's year, month, and day values.
   * @returns {Date}
   */
  dayOfDate(date) {
    return this.shiftDate(DateHelper.clearTime(date));
  }
  /**
   * Returns the day of week (0-8) for the given `date`. This value will match the `date` if the time of day is at or
   * after `startShift`, but will be the prior day otherwise.
   * @param {Date|Number} date The date from which to compute the day of week.
   * @returns {Number}
   */
  dayOfWeek(date) {
    date = this.shiftDate(date, -1);
    return date.getDay();
  }
  /**
   * Returns the difference between the time of day of the given `date` and `timeStart` in the specified time `unit`.
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance.
   * @param {String} unit The desired unit of time to return (see {@link Core.helper.DateHelper#function-as-static}).
   * @returns {Number}
   */
  delta(date, unit = "ms") {
    const { timeStart } = this, time = _DayTime.parse(date), t = (this.startShift && time < timeStart ? time + MILLIS_PER_DAY : time) - timeStart;
    return unit === "ms" ? t : DateHelper.as(unit, t, "ms");
  }
  /**
   * Returns the duration of the visible day (between `timeStart` and `timeEnd`) in the specified time `unit`.
   * @param {String} unit The desired unit of time to return (see {@link Core.helper.DateHelper#function-as-static}).
   * @returns {Number}
   */
  duration(unit = "ms") {
    const { timeStart, timeEnd } = this, millis = timeStart < timeEnd ? timeEnd - timeStart : MILLIS_PER_DAY - timeStart + timeEnd;
    return unit === "ms" ? millis : DateHelper.as(unit, millis, "ms");
  }
  /**
   * Returns `true` if this instance describes the same day as the `other`.
   * @param {Core.util.DayTime} other The other instance to which `this` instance should be tested for equality.
   * @returns {Boolean}
   */
  equals(other) {
    return this.startShift === (other == null ? void 0 : other.startShift) && this.timeStart === other.timeStart && this.timeEnd === other.timeEnd;
  }
  /**
   * Returns `true` if the times of day described by `startDate` and `endDate` intersect the visible time of this day.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  intersects(startDate, endDate) {
    const me = this, { timeStart, timeEnd } = me, [date0, date1] = me._dateRangeArgs(startDate, endDate), [start, end] = me.timeRange(date0, date1);
    if (timeStart < timeEnd) {
      if (start < end) {
        return start < timeEnd && timeStart <= end;
      }
      return start < timeEnd || timeStart <= end;
    }
    return !(start < end) || start < timeEnd || timeStart <= end;
  }
  /**
   * Returns `true` if the given date range is contained within one day.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  isIntraDay(startDate, endDate) {
    const me = this, [date0, date1] = me._dateRangeArgs(startDate, endDate), dayStart = me.startOfDay(date0), diff = MILLIS_PER_DAY - DateHelper.diff(dayStart, date1, "ms");
    if (diff < 0) {
      return false;
    }
    return diff > 0 || dayStart < date0;
  }
  /**
   * Returns `true` if the given date range or event crosses the day boundary.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  isInterDay(timeSpan) {
    return timeSpan.allDay || !this.isIntraDay(...arguments);
  }
  /**
   * Returns -1, 0, or 1 based on whether the time of day for the given `date` is before `timeStart` (-1), or after
   * `timeEnd` (1), or between these times (0).
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance to test.
   * @returns {Number}
   */
  outside(date) {
    const { startShift, timeStart, timeEnd } = this, time = _DayTime.parse(date);
    if (timeStart < timeEnd) {
      if (time < timeStart) {
        return time < startShift ? 1 : -1;
      }
      if (time < timeEnd) {
        return 0;
      }
      return time < startShift ? -1 : 1;
    }
    if (time < timeEnd || time >= timeStart) {
      return 0;
    }
    return time < startShift ? 1 : -1;
  }
  parseKey(key) {
    return this.dayOfDate(DateHelper.parseKey(key));
  }
  /**
   * Returns the given `date` shifted forward (`direction` > 0) or backward (`direction` < 0) by the `startShift`.
   * @param {Number|Date} date The date as a `Date` or the millisecond UTC epoch.
   * @param {Number} direction A value > 0 to shift `date` forward, or < 0 to shift it backwards.
   * @returns {Date}
   */
  shiftDate(date, direction = 1) {
    const { startShift } = this, type = typeof date;
    date = type === "number" ? new Date(date) : type === "string" ? DateHelper.parse(date) : new Date(date.getTime());
    if (direction && startShift) {
      date.setMilliseconds(direction > 0 ? startShift : -startShift);
    }
    return date;
  }
  /**
   * Sorts the given set of `events` by the maximum of `startDate` and `startOfDay` for the given `date`, followed
   * by `duration` in case of a tie.
   * @param {Date} date The day for which events are to be sorted.
   * @param {Object[]} events The events to sort, typically an `Scheduler.model.EventModel[]` but any objects with
   * both `startDate` and `endDate` fields are acceptable.
   * @returns {Object[]} The passed `events` array.
   * @internal
   */
  sortEvents(date, events) {
    const startOfDay = this.startOfDay(date);
    return events == null ? void 0 : events.sort((event1, event2) => {
      event1 = event1.eventRecord || event1;
      event2 = event2.eventRecord || event2;
      let { startDate: start1 } = event1, { startDate: start2 } = event2;
      if (!start1) {
        return -1;
      }
      if (!start2) {
        return 1;
      }
      start1 = start1 < startOfDay ? startOfDay : start1;
      start2 = start2 < startOfDay ? startOfDay : start2;
      return start1 - start2 || event2.endDate - start2 - (event1.endDate - start1);
    });
  }
  /**
   * Returns `Date` object for the nearest started (shifted) day prior to the given `date`. The time of this `Date`
   * will be the `startShift`.
   *
   * It is possible for this date to be in the prior day on a midnight-based calendar. For example, if the `startShift`
   * is 6PM and `date` is 6AM on May 20, this method will return 6PM of May 19 (the nearest started day).
   * @param {Date} date The date for which to find the nearest started day.
   * @returns {Date}
   */
  startOfDay(date) {
    date = this.shiftDate(date, -1);
    date = DateHelper.clearTime(date);
    date = this.shiftDate(date);
    return date;
  }
  /**
   * Returns a range of {@link Core.helper.DateHelper#function-getTimeOfDay-static times of day} for the given
   * date range.
   * @param {Date} startDate The start date of the date range or an event record containing both `startDate` and `endDate` fields
   * @param {Date} [endDate] The end date if `startDate` is not an event record
   * @returns {Number[]}
   */
  timeRange(startDate, endDate) {
    const [start, end] = this._dateRangeArgs(startDate, endDate);
    return [DateHelper.getTimeOfDay(start), DateHelper.getTimeOfDay(end)];
  }
  toString() {
    const { startShift, timeEnd, timeStart } = this, suffix = startShift ? `@${_DayTime.format(startShift)}` : "", prefix = _DayTime.format(timeStart);
    if (timeStart === timeEnd) {
      return startShift ? suffix : prefix;
    }
    return `${prefix}-${_DayTime.format(timeEnd)}${suffix}`;
  }
  /**
   * Decodes the arguments and returns a pair of `Date` objects for the start and end of the date range.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Date[]}
   * @private
   */
  _dateRangeArgs(startDate, endDate) {
    return startDate.isModel ? [startDate.startDate, startDate.endingDate] : [startDate, endDate];
  }
};
DayTime.MIDNIGHT = new DayTime({
  startShift: 0,
  timeStart: 0,
  timeEnd: 24
});
DayTime.MILLIS_PER_MINUTE = MILLIS_PER_MINUTE;
DayTime.MILLIS_PER_HOUR = MILLIS_PER_HOUR;
DayTime.MILLIS_PER_DAY = MILLIS_PER_DAY;
DayTime._$name = "DayTime";

// ../Core/lib/Core/util/ScrollManager.js
var ScrollManager = class extends Delayable_default(Base) {
  //region Default config
  static get configurable() {
    return {
      /**
       * Default element to use for scrolling. Can be overridden in calls to `startMonitoring()`.
       * @config {HTMLElement}
       */
      element: null,
      /**
       * Width in pixels of the area at the edges of an element where scrolling should be triggered
       * @config {Number}
       * @default
       */
      zoneWidth: 50,
      /**
       * Scroll speed, higher number is slower. Calculated as "distance from zone edge / scrollSpeed"
       * @config {Number}
       * @default
       */
      scrollSpeed: 5,
      /**
       * The direction(s) to scroll ('horizontal', 'vertical' or 'both')
       * @config {'horizontal'|'vertical'|'both'}
       * @default
       */
      direction: "both",
      /**
       * Number of milliseconds to wait before scroll starts when the mouse is moved close to an edge monitored by this scroll manager
       * @config {Number}
       * @default
       */
      startScrollDelay: 500,
      /**
       * Set to true to stop scrolling when pointing device leaves the scrollable element.
       * @config {Boolean}
       * @default
       */
      // https://github.com/bryntum/support/issues/394
      stopScrollWhenPointerOut: false,
      testConfig: {
        scrollSpeed: 2,
        startScrollDelay: 100
      },
      activeScroll: {
        $config: ["lazy"],
        value: {}
      },
      monitoring: {
        $config: ["lazy", "nullify"],
        value: true
      },
      owner: null
    };
  }
  changeMonitoring(value, was) {
    was == null ? void 0 : was.clear();
    return /* @__PURE__ */ new Map();
  }
  //endregion
  doDestroy() {
    this.stopMonitoring();
    super.doDestroy();
  }
  /**
   * Returns true if some of the monitored elements is being scrolled at the moment.
   * @property {Boolean}
   * @readonly
   */
  get isScrolling() {
    return Object.keys(this.activeScroll).length !== 0;
  }
  get rtl() {
    var _a2;
    return (_a2 = this.owner) == null ? void 0 : _a2.rtl;
  }
  //region Start/stop monitoring
  /**
   * Starts monitoring an element. It will be scrolled if mouse is pressed and within `zoneWidth` pixels from element
   * edge. Supports monitoring multiple elements using `scrollables` option:
   *
   * ```javascript
   * new ScrollManager({ element : '.item' }).startMonitoring({
   *     scrollables : [
   *         {
   *             // Applies config to all elements matching `.item .child-item`
   *             // selector
   *             element : '.child-item',
   *             // Only manage vertical scroll
   *             direction : 'vertical',
   *             // Specific callback for this scrollable. Shared callback is
   *             // ignored.
   *             callback : () => console.log('Specific callback')
   *         },
   *         {
   *             // Instance can be used
   *             element : document.querySelector('.item .child2')
   *             // Direction and callback are not provided, so element will
   *             // be scrollable in horizontal direction and will use shared
   *             // callback
   *         }
   *     ],
   *     direction : 'horizontal',
   *     callback  : () => console.log('Shared callback')
   * })
   * ```
   *
   * @param {Object} config Element which might be scrolled or config { element, callback, thisObj }
   * @param {'horizontal'|'vertical'|'both'} [config.direction] Direction to scroll. Overrides default scroll direction
   * @param {Function} [config.callback] Callback to execute on every scroll of the target element.
   *
   * ```javascript
   * startMonitoring({
   *     callback(monitor) {
   *         // Current left and top scroll of the monitored element
   *         console.log(monitor.scrollLeft)
   *         console.log(monitor.scrollTop)
   *         // Scroll position relative to the initial position
   *         console.log(monitor.relativeScrollLeft)
   *         console.log(monitor.relativeScrollTop)
   *     }
   * })
   * ```
   *
   * @param {Object} [config.thisObj] Scope for the callback.
   * @param {Object[]} [config.scrollables] Array of configs if multiple elements should be monitored.
   * @param {HTMLElement|String} [config.scrollables.0.element] Element or selector.
   * @param {'horizontal'|'vertical'|'both'} [config.scrollables.0.direction] Direction to scroll. Overrides upper config object direction.
   * @param {Function} [config.scrollables.0.callback] Callback to execute on every scroll of the target element.
   * Overrides upper config object callback.
   * @returns {Function} Returns function to cleanup instantiated monitors
   * ```javascript
   * const detacher = new ScrollManager({ element }).startMonitoring({ ... });
   * detacher(); // All monitors setup by the previous call are removed
   * ```
   */
  startMonitoring(config = {}) {
    const me = this, {
      element,
      direction: defaultDirection
    } = me, {
      scrollables = [],
      direction = defaultDirection,
      callback
    } = config, attachedElements = [];
    if (!scrollables.length) {
      scrollables.push({ element });
    }
    scrollables.forEach((scrollable) => {
      const target = scrollable.element;
      if (typeof target === "string") {
        DomHelper.forEachSelector(element, target, (element2) => {
          me.createMonitor(element2, scrollable.direction || direction, scrollable.callback || callback);
          attachedElements.push(element2);
        });
      } else {
        me.createMonitor(target, scrollable.direction || direction, scrollable.callback || callback);
        attachedElements.push(target);
      }
    });
    return function detacher2() {
      var _a2;
      (_a2 = me.stopMonitoring) == null ? void 0 : _a2.call(me, attachedElements);
    };
  }
  createMonitor(element, direction, callback) {
    const { monitoring } = this;
    if (!monitoring.has(element)) {
      monitoring.set(element, new ScrollManagerMonitor({
        scrollManager: this,
        element,
        direction,
        callback
      }));
    }
  }
  /**
   * Stops monitoring an element. If no particular element is given, stop monitoring everything.
   * @param {HTMLElement|HTMLElement[]} [element] Element or array of elements for which monitoring is not desired any
   * more and should stop as soon as possible.
   */
  stopMonitoring(element) {
    const me = this, { monitoring } = me;
    element = ArrayHelper.asArray(element);
    if (monitoring) {
      if (!element) {
        monitoring.forEach((monitor) => me.stopMonitoring(monitor.element));
        return;
      }
      element.forEach((element2) => {
        const monitor = monitoring.get(element2);
        element2.classList.remove("b-scrolling");
        if (monitor) {
          monitor.destroy();
          monitoring.delete(element2);
        }
      });
    }
  }
  //endregion
  /*
   * Attempts to reserve given scrolling direction for the given monitor.
   * @param {String} direction 'horizontal' or 'vertical'
   * @param {Object} monitor
   * @returns {Boolean} Returns true in case scroll direction was reserved for given monitor. False otherwise.
   * @private
   */
  requestScroll(direction, monitor) {
    const { activeScroll } = this;
    if (direction in activeScroll && activeScroll[direction] !== monitor) {
      return false;
    } else {
      activeScroll[direction] = monitor;
      return true;
    }
  }
  /*
   * Releases all scroll directions, blocked by given monitor
   * @param {Object} monitor
   * @private
   */
  releaseScroll(monitor) {
    const { activeScroll = {} } = this;
    Object.keys(activeScroll).forEach((key) => {
      if (activeScroll[key] === monitor) {
        delete activeScroll[key];
      }
    });
  }
  //#region Scroll position
  getRelativeScroll(element, direction = "left") {
    let result = 0;
    this.monitoring.forEach((monitor, monitoredElement) => {
      if (DomHelper.isDescendant(monitoredElement, element)) {
        result += direction === "left" ? monitor.scrollRelativeLeft : monitor.scrollRelativeTop;
      }
    });
    return result;
  }
  //#endregion
};
var ScrollManagerMonitor = class extends Base {
  construct(config) {
    const me = this, { element } = config, startScrollLeft = element.scrollLeft, startScrollTop = element.scrollTop;
    Object.assign(config, { startScrollLeft, startScrollTop });
    super.construct(config);
    EventHelper.on({
      element,
      scroll: "onElementScroll",
      pointermove: "onMouseMove",
      // Capture pointermove events early to start scrolling from top elements
      capture: true,
      thisObj: me
    });
    EventHelper.on({
      element,
      pointerleave: "onPointerLeave",
      thisObj: me
    });
  }
  doDestroy() {
    this.stopScroll();
    super.doDestroy();
  }
  /**
   * Starts scrolling (see #performScroll). Called from onMouseMove.
   * @private
   */
  startScroll() {
    const me = this;
    if (me.pendingScrollFinalize) {
      me.scrollManager.releaseScroll(me);
      me.pendingScrollFinalize = false;
    }
    me.scrolling = true;
    me.performScroll();
  }
  /**
   * Stops scrolling. Called from onMouseMove.
   * @private
   */
  stopScroll(force = null) {
    const me = this, finalize = () => {
      me.pendingScrollFinalize = false;
      if (!me.isDestroyed) {
        me.scrollManager.releaseScroll(me);
        me.scrolling = false;
      }
    };
    if (me.scrollRequested) {
      me.scrollManager.cancelAnimationFrame(me.frameId);
      me.scrollRequested = false;
    }
    me.scrollManager.clearTimeout(me.scrollTimeout);
    me.scrollTimeout = null;
    if (!force && (me.ongoingScrollTop || me.ongoingScrollLeft)) {
      me.pendingScrollFinalize = true;
      Promise.all([me.ongoingScrollTop, me.ongoingScrollLeft].filter(Boolean)).then(() => me.pendingScrollFinalize && finalize());
    } else {
      me.ongoingScrollTop = me.ongoingScrollLeft = null;
      finalize();
    }
  }
  onPointerLeave() {
    this.scrollManager.stopScrollWhenPointerOut && this.stopScroll();
  }
  /**
   * Listener for mouse move on monitored element. Determines if scrolling is needed, and if so how fast to scroll.
   * See #zoneWidth & #scrollSpeed configs.
   * @private
   * @param {MouseEvent} event
   */
  onMouseMove(event) {
    const me = this, {
      scrollManager
    } = me, box = me.element.getBoundingClientRect(), width = scrollManager.zoneWidth, speed = scrollManager.scrollSpeed;
    me.scrollDeltaX = me.scrollDeltaY = 0;
    if (me.direction !== "vertical") {
      const { scrollLeft, scrollWidth, clientWidth } = me.element;
      if (scrollManager.rtl) {
        if (event.clientX < box.left + width && scrollWidth + scrollLeft - clientWidth >= 1) {
          me.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
        } else if (event.clientX > box.right - width && scrollLeft < 0) {
          me.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
        }
      } else {
        if (event.clientX > box.right - width && scrollWidth - scrollLeft - clientWidth >= 1) {
          me.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
        } else if (event.clientX < box.left + width && scrollLeft > 0) {
          me.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
        }
      }
    }
    if (me.direction !== "horizontal") {
      const { scrollTop, scrollHeight, clientHeight } = me.element;
      if (event.clientY > box.bottom - width && scrollHeight - scrollTop - clientHeight >= 1) {
        me.scrollDeltaY = Math.round((width - (box.bottom - event.clientY)) / speed) + 1;
      } else if (event.clientY < box.top + width && scrollTop > 0) {
        me.scrollDeltaY = -Math.round((width + (box.top - event.clientY)) / speed) - 1;
      }
    }
    if (me.scrollDeltaX !== 0 && !scrollManager.requestScroll("horizontal", me)) {
      me.scrollDeltaX = 0;
    }
    if (me.scrollDeltaY !== 0 && !scrollManager.requestScroll("vertical", me)) {
      me.scrollDeltaY = 0;
    }
    if (me.scrollDeltaX === 0 && me.scrollDeltaY === 0) {
      me.scrolling && me.stopScroll();
    } else if (!me.scrollTimeout) {
      me.scrollTimeout = scrollManager.setTimeout(() => me.startScroll(), scrollManager.startScrollDelay);
    }
  }
  /**
   * Scrolls by an amount determined by config.scrollDeltaX/Y on each frame. Start/stop by calling #startScroll and
   * #stopScroll.
   * @private
   */
  performScroll() {
    const me = this, { element } = me;
    if (me.scrolling && !me.scrollRequested) {
      if (me.scrollDeltaX !== 0) {
        const oldScrollLeft = element.scrollLeft, newScrollLeft = Math.min(oldScrollLeft + me.scrollDeltaX, element.scrollWidth - element.clientWidth);
        element.scrollLeft = newScrollLeft;
        if (element.scrollLeft !== oldScrollLeft) {
          me.ongoingScrollLeft = new Promise((resolve) => element.addEventListener("scroll", resolve, { once: true }));
        } else {
          me.ongoingScrollLeft = null;
          me.scrollDeltaX = 0;
        }
      }
      if (me.scrollDeltaY !== 0) {
        const oldScrollTop = element.scrollTop, newScrollTop = Math.min(oldScrollTop + me.scrollDeltaY, element.scrollHeight - element.clientHeight);
        element.scrollTop = newScrollTop;
        if (element.scrollTop !== oldScrollTop) {
          me.ongoingScrollTop = new Promise((resolve) => element.addEventListener("scroll", resolve, { once: true }));
        } else {
          me.ongoingScrollTop = null;
          me.scrollDeltaY = 0;
        }
      }
      if (me.scrollDeltaX !== 0 || me.scrollDeltaY !== 0) {
        me.scrollRequested = true;
        me.frameId = me.scrollManager.requestAnimationFrame(() => {
          me.scrollRequested = false;
          me.performScroll(me);
        });
      } else {
        me.stopScroll();
      }
    }
  }
  onElementScroll() {
    var _a2, _b;
    (_b = (_a2 = this.config) == null ? void 0 : _a2.callback) == null ? void 0 : _b.call(this.thisObj || this.scrollManager, this);
  }
  get scrollLeft() {
    return this.element.scrollLeft;
  }
  get scrollTop() {
    return this.verticalElement ? this.verticalElement.scrollTop : this.element.scrollTop;
  }
  get scrollRelativeLeft() {
    return this.scrollLeft - this.startScrollLeft;
  }
  get scrollRelativeTop() {
    return this.scrollTop - this.startScrollTop;
  }
  // There could be several scrollables controlling different axes. If we want to calculate combined scroll from all
  // those monitors (e.g. for the case when we drag scheduler event in both directions), we should ask scroll manager
  // to iterate over monitored elements and aggregate scroll.
  getRelativeLeftScroll(element) {
    return this.scrollManager.getRelativeScroll(element, "left");
  }
  getRelativeTopScroll(element) {
    return this.scrollManager.getRelativeScroll(element, "top");
  }
};
ScrollManager._$name = "ScrollManager";

// ../Core/lib/Core/widget/Tooltip.js
var realignTransitions = {
  left: true,
  right: true,
  top: true,
  bottom: true,
  transform: true
};
var isBoolean = {
  true: 1,
  false: 1
};
var immediatePromise4 = Promise.resolve();
var _Tooltip = class _Tooltip extends Popup {
  /**
   * Triggered before tooltip widget is shown. Return `false` to prevent the action.
   * @preventable
   * @async
   * @event beforeShow
   * @param {Core.widget.Tooltip} source The Tooltip
   * @param {Event} source.triggeredByEvent The event that triggered this Tooltip to show.
   */
  static get configurable() {
    return {
      /**
       * By default, a Tooltip is transient, and will {@link #function-hide} when the mouse exits the target
       * element. Configure as `false` to make a Tooltip non-transient.
       * @config {Boolean}
       * @default
       */
      autoHide: true,
      /**
       * By default, a Tooltip is transient, and will {@link #function-hide} when the user clicks or
       * taps outside its widget. Configure as `false` to make a Tooltip non-transient when user clicks outside it.
       *
       * If you would like the Tooltip to stay visible when mouse leaves the Tooltip target, please see
       * {#config-autoHide}.
       *
       * @config {Boolean} autoClose
       * @default true
       */
      /**
       * Horizontal offset from mouse when {@link #config-anchorToTarget} is `false`.
       *
       * Direction independent, the value is internally flipped (by multiplying it with -1) for RTL.
       *
       * @config {Number}
       * @default
       */
      mouseOffsetX: 15,
      /**
       * Vertical offset from mouse when {@link #config-anchorToTarget} is `false`
       * @config {Number}
       * @default
       */
      mouseOffsetY: 15,
      html: {
        // Ensure the html setter can never veto the operation as a no-change.
        // Because of beforeShow listeners augmenting the content.
        $config: {
          equals: () => false
        }
      },
      /**
       * A method, or the *name* of a method called to update the tooltip's content when the
       * cursor is moved over a target. It receives one argument containing context about the
       * tooltip and show operation. The function should return a string, or a Promise yielding
       * a string.
       *
       * ```javascript
       * new Grid({
       *     title    : 'Client list',
       *     appendTo : myElement,
       *     store    : myStore,
       *     columns  : myColumns,
       *     tbar     : {
       *         items : {
       *             text : 'Reload,
       *             tooltip : {
       *                 // Will look in ownership hierarchy for the method
       *                 // which will be found on the grid.
       *                 getHtml : 'up.getReloadButtonTip'
       *             }
       *         }
       *     },
       *     getReloadButtonTip() {
       *         return `Reload ${this.title}`;
       *     }
       * });
       * ```
       *
       * @config {Function|String}
       * @param {Object} context
       * @param {Core.widget.Tooltip} context.tip The tooltip instance
       * @param {HTMLElement} context.element The Element for which the Tooltip is monitoring mouse movement
       * @param {HTMLElement} context.activeTarget The target element that triggered the show
       * @param {Event} context.event The raw DOM event
       * @returns {String|Promise}
       */
      getHtml: null,
      /**
       * DOM element to attach tooltip to. By default, the mouse entering this element will kick off a timer
       * (see {@link #config-hoverDelay}) to show itself.
       *
       * If the {@link #config-forSelector} is specified, then mouse entering matching elements within the `forElement`
       * will trigger the show timer to start.
       *
       * Note that when moving from matching element to matching element within the `forElement`, the tooltip
       * will remain visible for {@link #config-hideDelay} milliseconds after exiting one element, so that rapidly
       * entering another matching element will not cause hide+show flicker. To prevent this behaviour configure
       * with `hideDelay: 0`.
       * @config {HTMLElement}
       */
      forElement: null,
      /**
       * By default, once a tooltip is shown aligned as requested, it stays put.
       *
       * Setting this to `true` causes the tooltip to be aligned by the mouse,
       * offset by `[{@link #config-mouseOffsetX}, {@link #config-mouseOffsetY}]` and
       * keeps the tooltip aligned to the mouse maintaining the configured offsets
       * as the mouse moves within its activating element.
       * @config {Boolean}
       * @default false
       */
      trackMouse: null,
      /**
       * By default, a tooltip displays static content. In the Scheduler however, there are
       * plenty of uses cases when the tip content is based on the current mouse position (dragging events, resizing events, schedule hover tip, drag creation of events etc). Set
       * to `true` to update contents on mouse movement.
       * @config {Boolean}
       * @private
       * @default
       */
      updateContentOnMouseMove: false,
      /**
       * A CSS selector which targets child elements of the {@link #config-forElement} that should produce a
       * tooltip when hovered over.
       * @config {String}
       */
      forSelector: null,
      /**
       * By default, when moving rapidly from target to target, if, when mouseovering
       * a new target, the tip is still visible, the tooltip does not hide, it remains
       * visible, but updates its content however it is configured to do so.
       *
       * Configure `hideOnDelegateChange : true` to have the tip hide, and then trigger
       * a new show delay upon entry of a new target while still visible.
       * @config {Boolean}
       * @default false
       */
      hideOnDelegateChange: null,
      /**
       * Set to true to anchor tooltip to the triggering target. If set to `false`, the tooltip
       * will align to the mouse position. When set to `false`, it will also set `anchor: false`
       * to hide anchor arrow.
       * @config {Boolean}
       * @default
       */
      anchorToTarget: true,
      /**
       * Show on hover
       * @config {Boolean}
       * @default false
       */
      showOnHover: null,
      /**
       * The amount of time to hover before showing
       * @prp {Number}
       * @default
       */
      hoverDelay: 500,
      /**
       * Show immediately when created
       * @config {Boolean}
       * @default
       */
      autoShow: false,
      /**
       * The time (in milliseconds) that the Tooltip should stay visible for when it shows over its
       * target. If the tooltip is anchored to its target, then moving the mouse during this time
       * resets the timer so that the tooltip will remain visible.
       *
       * Defaults to `0` which means the Tooltip will persist until the mouse leaves the target.
       * @config {Number}
       * @default
       */
      dismissDelay: 0,
      /**
       * The time (in milliseconds) for which the Tooltip remains visible when the mouse leaves the target.
       *
       * May be configured as `false` to persist visible after the mouse exits the target element. Configure it
       * as 0 to always retrigger `hoverDelay` even when moving mouse inside `fromElement`
       * @config {Number|Boolean}
       * @default
       */
      hideDelay: 500,
      /**
       * The message to show while an async tooltip is fetching its content.
       * @config {String}
       * @default
       */
      loadingMsg: "Loading...",
      /**
       * Keep the tooltip open if user moves the mouse over it.
       *
       * If this is *not* explicitly configured as `false`, then this is automatically set
       * when there are any visible, interactive child items added such as {@link #config-tools}, or
       * {@link #config-items} which are interactive such as buttons or input fields.
       * @config {Boolean}
       * @default false
       */
      allowOver: null,
      anchor: true,
      align: {
        align: "b-t",
        // This signals to the align code that this widget is prepared to shrink
        // in height in order to comply with alignTo specifications.
        // Without a minHeight, it is assumed that the height of the widget
        // is inviolable.
        minHeight: 300
      },
      axisLock: true,
      /**
       * The HTML element that triggered this Tooltip to show
       * @readonly
       * @member {HTMLElement} activeTarget
       */
      activeTarget: null,
      testConfig: {
        hideDelay: 100,
        hoverDelay: 100,
        showAnimation: null,
        hideAnimation: null
      }
    };
  }
  //endregion
  //region Events
  /**
   * Triggered when a mouseover event is detected on a potential target element.
   * Return false to prevent the action
   * @event pointerOver
   * @param {Core.widget.Tooltip} sourceThe tooltip instance.
   * @param {Event} event The mouseover event.
   */
  //endregion
  //region Properties
  //endregion
  //region Init & destroy
  afterConfigure() {
    const me = this, { forSelector } = me;
    if (forSelector) {
      me.showOnHover = me.showOnHover !== false;
      if (!me.forElement) {
        if (!me.anchorToTarget) {
          me.trackMouse = true;
        }
        me.forElement = me.rootElement.host || me.rootElement;
      }
    }
    super.afterConfigure();
    if (me.forElement && me.showOnHover) {
      me.pointerOverOutDetacher = EventHelper.on({
        element: me.forElement,
        // Using pointerover/pointerout since mouseover events are not fired in Chrome when the native `disabled`
        // attribute is present https://github.com/bryntum/support/issues/3179
        pointerover: "internalOnPointerOver",
        pointerout: "internalOnPointerOut",
        thisObj: me
      });
    }
  }
  doDestroy() {
    var _a2;
    (_a2 = this.pointerOverOutDetacher) == null ? void 0 : _a2.call(this);
    super.doDestroy();
  }
  set focusOnToFront(focusOnToFront) {
    super.focusOnToFront = focusOnToFront;
  }
  get focusOnToFront() {
    return super.focusOnToFront && DomHelper.usingKeyboard;
  }
  get focusElement() {
    const result = super.focusElement;
    if (result !== this.element) {
      return result;
    }
  }
  get anchorToTarget() {
    return this._anchorToTarget && !this.trackMouse;
  }
  get anchor() {
    return super.anchor && !this.trackMouse;
  }
  set anchor(anchor) {
    super.anchor = anchor;
  }
  //endregion
  //region Hovering, show and hide
  onDocumentMouseDown({ event }) {
    const me = this, { triggeredByEvent } = me;
    if (triggeredByEvent && DomHelper.isTouchEvent) {
      if (event.pageX === triggeredByEvent.pageX && event.pageY === triggeredByEvent.pageY && me.activeTarget.contains(event.target) && performance.now() - triggeredByEvent.timeStamp < 500) {
        return;
      }
    }
    me.abortDelayedShow();
    super.onDocumentMouseDown({ event });
  }
  internalOnPointerOver(event) {
    const me = this, { target, relatedTarget } = event, { forElement, forSelector, activeTarget } = me;
    let newTarget;
    if (me.disabled || me.owner && !me.owner.showTooltipWhenDisabled && me.owner.disabled) {
      return;
    }
    if (me.allowOver && me.element.contains(target)) {
      return;
    }
    if (forSelector) {
      newTarget = me.filterTarget(target);
      if ((activeTarget == null ? void 0 : activeTarget.contains(target)) && activeTarget.contains(relatedTarget) && newTarget === activeTarget) {
        return;
      }
      if (newTarget && (relatedTarget == null ? void 0 : relatedTarget.closest(forSelector)) === newTarget) {
        return;
      }
    } else if (!forElement.contains(relatedTarget)) {
      newTarget = forElement;
    } else {
      return;
    }
    if (newTarget) {
      me.handleForElementOver(event, newTarget);
    } else if (activeTarget) {
      me.handleForElementOut();
    }
  }
  filterTarget(element) {
    return element.closest(this.forSelector);
  }
  // Handle a transitioned reposition when the activeTarget moved beneath the pointer.
  // When it comes to an end, if the mouseout has not hidden, then realign at the new position
  // if the activeTarget is still beneath the pointer.
  onTransitionEnd(event) {
    var _a2;
    const me = this, { currentOverElement: currentOverElement2 } = _Tooltip;
    if (realignTransitions[event.propertyName]) {
      if (me.allowOver && me.element.contains(currentOverElement2)) {
        return;
      }
      if (((_a2 = me.activeTarget) == null ? void 0 : _a2.contains(currentOverElement2)) && !me.trackMouse) {
        me.realign();
      }
    }
  }
  async handleForElementOver(event, newTarget) {
    const me = this, {
      activeTarget,
      hideOnDelegateChange,
      anchorToTarget
    } = me, isNewTarget = newTarget !== activeTarget, needsHide = isNewTarget && hideOnDelegateChange;
    if (me.trigger("pointerOver", { event, target: newTarget }) === false) {
      me.internalOnPointerOut(event);
    } else {
      me.triggeredByEvent = event;
      if (me.hasTimeout("hide")) {
        me.abortDelayedHide();
        if (!isNewTarget) {
          return;
        }
      }
      if (!hideOnDelegateChange && me.element.classList.contains("b-hiding")) {
        me.cancelHideShowAnimation();
      }
      if (!me._hidden && needsHide) {
        me.hide(false);
      }
      me.activeTarget = newTarget;
      if (me.isVisible) {
        const result = me.updateContent();
        if (Objects.isPromise(result) && !me.loadingMsg) {
          await result;
        }
        if (me.trigger("beforeShow") === false) {
          return me.hide();
        }
        me.alignTo({
          [anchorToTarget ? "target" : "position"]: anchorToTarget ? newTarget : "mouse",
          overlap: !(anchorToTarget && me.anchor)
        });
        me.trigger("show");
        me.afterShowByTarget();
      } else {
        me.delayShow(newTarget);
      }
    }
  }
  async delayShow(target) {
    var _a2;
    const me = this;
    if ((_a2 = me.currentAnimation) == null ? void 0 : _a2.showing) {
      me.cancelHideShowAnimation();
    }
    if (!me.isVisible && !me.hasTimeout("show")) {
      if (!me.hoverDelay || me.forSelector && Date.now() - me.lastHidden < me.quickShowInterval) {
        const result = me.updateContent();
        if (Objects.isPromise(result) && !me.loadingMsg) {
          await result;
        }
        me.showByTarget(target);
      } else {
        me.addDocumentMouseDownListener();
        if (!me.listeningForMouseMove && !me.anchorToTarget) {
          me.mouseMoveRemover = EventHelper.on({
            element: me.rootElement,
            mousemove: "onMouseMove",
            thisObj: me
          });
        }
        me.setTimeout(async () => {
          if (me.activeTarget === target && target.isConnected) {
            const result = me.updateContent();
            if (Objects.isPromise(result) && !me.loadingMsg) {
              await result;
            }
            me.showByTarget(target);
          }
        }, !me.triggeredByEvent || me.triggeredByEvent.type === "pointerover" ? me.hoverDelay : 0, "show");
      }
    } else if (me.isVisible) {
      me.showByTarget(target);
    }
  }
  changeAllowOver(allowOver) {
    if (!this.inAfterShow) {
      this.configuredAllowOver = allowOver;
    }
    return allowOver;
  }
  updateAllowOver(allowOver) {
    var _a2;
    const me = this, { element } = me;
    element.classList.toggle("b-allow-over", Boolean(allowOver));
    if (allowOver) {
      me.allowOverlisteners = EventHelper.on({
        element,
        mouseenter: "onOwnElementMouseEnter",
        mouseleave: "internalOnPointerOut",
        thisObj: me
      });
    } else {
      (_a2 = me.allowOverlisteners) == null ? void 0 : _a2.call(me);
    }
  }
  updateContent() {
    const me = this;
    if (me.getHtml) {
      const result = me.callback(me.getHtml, me, [{
        tip: me,
        element: me.element,
        activeTarget: me.activeTarget,
        event: me.triggeredByEvent
      }]);
      me.html = result;
      return result;
    }
  }
  // There are 3 possible scenarios:
  // - Static content
  // - Remote content being loaded (meaning we (possibly) set a loading message as the `html`
  // - Tooltip acts as a Container
  get hasContent() {
    return Boolean(DomHelper.isReactElement(this._html) || (this._html !== "" && (typeof this.html === "string" && this.html.length) || this.items.length));
  }
  internalBeforeShow() {
    return (this.updateContentOnMouseMove || this.hasContent) && !this.disabled;
  }
  /**
   * Shows a spinner and a message to indicate an async flow is ongoing
   * @param {String} message The message, defaults to {@link #config-loadingMsg}
   */
  showAsyncMessage(message = this.optionalL(this.loadingMsg)) {
    if (message) {
      this.html = `
                <div class="b-tooltip-loading">
                    <i class="b-icon b-icon-spinner"></i>
                    ${message}
                </div>
            `;
    }
  }
  showByTarget(target) {
    var _a2;
    const me = this, { anchorToTarget } = me;
    me.mouseMoveRemover = (_a2 = me.mouseMoveRemover) == null ? void 0 : _a2.call(me);
    me.showBy({
      [anchorToTarget ? "target" : "position"]: anchorToTarget ? target : "mouse",
      overlap: !(anchorToTarget && me.anchor)
    });
  }
  afterShowByTarget() {
    const me = this, { dismissDelay } = me;
    me.abortDelayedShow();
    if (dismissDelay) {
      me.setTimeout("hide", dismissDelay);
    }
    if (me.element.parentNode) {
      me.toFront();
    }
    if (!me.mouseMoveRemover && (me.trackMouse || me.updateContentOnMouseMove)) {
      me.mouseMoveRemover = EventHelper.on({
        element: me.rootElement,
        pointermove: "onMouseMove",
        thisObj: me
      });
    }
    me.inAfterShow = true;
    me.allowOver = me.allowOver || me.configuredAllowOver != false && me.childItems.some((w) => w.isVisible && !w.disabled && w.focusElement);
    me.inAfterShow = false;
  }
  updateActiveTarget(newTarget, lastTarget) {
    if (newTarget && !this.isConfiguring) {
      this.trigger("overTarget", { newTarget, lastTarget });
    }
  }
  internalOnPointerOut(event) {
    var _a2;
    const me = this, toElement = event.relatedTarget;
    if (me.allowOver && me.element.contains(toElement)) {
      return;
    }
    if (me.element.contains(event.target) && ((_a2 = me.activeTarget) == null ? void 0 : _a2.contains(toElement))) {
      return;
    }
    if (me.activeTarget && !me.activeTarget.contains(toElement)) {
      me.handleForElementOut();
    }
  }
  handleForElementOut() {
    const me = this, { hideDelay } = me;
    if (me.trigger("pointerOut") === false) {
      me.activeTarget = null;
      return true;
    }
    me.abortDelayedShow();
    if (me.isVisible && hideDelay !== false) {
      me.abortDelayedHide();
      if (hideDelay > 0) {
        me.setTimeout("hide", hideDelay);
      } else {
        me.hide();
      }
    }
  }
  show(spec) {
    const me = this;
    if (!spec && me.forElement && me.anchorToTarget && !me.forSelector) {
      me.showByTarget(me.forElement);
    } else {
      super.show(...arguments);
    }
    if (me.isVisible) {
      me.afterShowByTarget();
      if (me.forElement && !me.transitionEndDetacher && !me._hidden) {
        me.transitionEndDetacher = EventHelper.on({
          element: me.forElement,
          transitionend: "onTransitionEnd",
          thisObj: me
        });
      }
    }
  }
  get hideDelay() {
    return this.autoHide ? this._hideDelay : false;
  }
  hide() {
    var _a2, _b;
    const me = this;
    me.abortDelayedShow();
    if (!me._hidden) {
      me.abortDelayedHide();
      const result = super.hide(...arguments);
      me.lastHidden = Date.now();
      me.activeTarget = null;
      (_a2 = me.mouseMoveRemover) == null ? void 0 : _a2.call(me);
      me.mouseMoveRemover = null;
      (_b = me.transitionEndDetacher) == null ? void 0 : _b.call(me);
      me.transitionEndDetacher = null;
      return result;
    } else {
      return immediatePromise4;
    }
  }
  abortDelayedShow() {
    var _a2, _b, _c;
    const me = this;
    if (me.hasTimeout("show")) {
      (_a2 = me.mouseDownRemover) == null ? void 0 : _a2.call(me);
      me.mouseDownRemover = null;
      me.clearTimeout("show");
      (_b = me.mouseMoveRemover) == null ? void 0 : _b.call(me);
      me.mouseMoveRemover = null;
      (_c = me.transitionEndDetacher) == null ? void 0 : _c.call(me);
      me.transitionEndDetacher = null;
    }
  }
  /**
   * Stops both timers which may hide this tooltip, the one which counts down from mouseout
   * and the one which counts down from mouseover show for dismissDelay ms
   * @private
   */
  abortDelayedHide() {
    this.clearTimeout("hide");
  }
  realign() {
    const me = this, spec = me.lastAlignSpec;
    if (!me.isConfiguring && !me.isVisible && (spec == null ? void 0 : spec.targetOutOfView)) {
      if (spec.allowTargetOut || DomHelper.isInView(spec.target, false, me)) {
        me.show();
        spec.targetOutOfView = false;
      }
    }
    super.realign();
  }
  alignTo(spec) {
    const me = this, mouseOffsetX = (me.mouseOffsetX || 1) * (me.rtl ? -1 : 1), mouseOffsetY = me.mouseOffsetY || 1, xMargin = Math.max(Math.min(mouseOffsetX, 5), 0), yMargin = Math.max(Math.min(mouseOffsetY, 5), 0);
    if (!me.isVisible) {
      return;
    }
    let mousePosition;
    if (!me.anchorToTarget && spec.position === "mouse") {
      mousePosition = new Point(
        me.triggeredByEvent.pageX - globalThis.scrollX,
        me.triggeredByEvent.pageY - globalThis.scrollY
      );
      spec.position = new Point(
        mousePosition.x + (mouseOffsetX || 1) - (mouseOffsetX < 0 ? me.width : 0),
        mousePosition.y + (mouseOffsetY || 1) - (mouseOffsetY < 0 ? me.height : 0)
      );
    }
    if (spec && !(me.triggeredByEvent && me.element.contains(me.triggeredByEvent.target))) {
      if (spec.nodeType === Node.ELEMENT_NODE) {
        spec = {
          target: spec
        };
      }
    }
    super.alignTo(spec);
    if (mousePosition && me.lastAlignSpec.result.inflate(yMargin, xMargin).contains(mousePosition)) {
      me.lastAlignSpec.position = "mouse";
      me.mouseOffsetY = -mouseOffsetY;
      me.mouseOffsetX = -mouseOffsetX;
      me.realign();
      me.mouseOffsetY = mouseOffsetY;
      me.mouseOffsetX = mouseOffsetX;
    }
  }
  //endregion
  //region Tooltip contents
  /**
   * Get/set the HTML to display. When specifying HTML, this widget's element will also have `b-html` added to its
   * classList, to allow targeted styling. To create async tooltip and show the {@link #config-loadingMsg}, see code below:
   * For example:
   *
   * ```javascript
   * new Tooltip({
   *     listeners : {
   *         beforeShow : ({ source : tip }) => {
   *             tip.showAsyncMessage();
   *             AjaxHelper.get('someurl').then(response => tip.html = 'Done!');
   *         }
   *     }
   * });
   * ```
   *
   * @member {String} html
   * @category DOM
   */
  changeHtml(htmlOrPromise) {
    const me = this;
    if (Objects.isPromise(htmlOrPromise)) {
      me.showAsyncMessage();
      htmlOrPromise.target = me.activeTarget;
      htmlOrPromise.then((html) => {
        if (htmlOrPromise.target === me.activeTarget) {
          me.html = html;
        }
      });
      return;
    }
    if (typeof htmlOrPromise !== "object") {
      htmlOrPromise = htmlOrPromise != null ? me.optionalL(String(htmlOrPromise)) : "";
    }
    return htmlOrPromise;
  }
  updateHtml(value, was) {
    const me = this;
    let empty2 = value === "";
    if (!empty2) {
      super.updateHtml(value, was);
      if (me.hasContent) {
        if (me.isVisible) {
          me.realign();
        }
        if (!Objects.isPromise(value)) {
          me.trigger("innerHtmlUpdate", { value });
        }
      } else {
        empty2 = true;
      }
    }
    if (empty2) {
      me.hide();
    }
  }
  //endregion
  //region Events
  /**
   * Mouse move event listener which updates tooltip
   * @private
   */
  onMouseMove(event) {
    const me = this, {
      forElement,
      activeTarget
    } = me, isHiding = me.hasTimeout("hide"), target = event.target;
    me.triggeredByEvent = event;
    if (!me._hidden) {
      let hideVetoed;
      const isWithinTarget = activeTarget == null ? void 0 : activeTarget.contains(target), isElementOut = !isWithinTarget && me.forSelector && activeTarget && !isHiding && target.nodeType === Node.ELEMENT_NODE && !target.matches(me.forSelector) && !(me.allowOver && me.element.contains(target)), containingElement = (forElement == null ? void 0 : forElement.document) ? forElement.document.documentElement : forElement, forElementContainsTarget = containingElement && (containingElement.contains ? containingElement.contains(target) : containingElement.compareDocumentPosition(target) & 16);
      if (isElementOut) {
        hideVetoed = me.handleForElementOut();
      }
      if (hideVetoed || !isHiding || forElementContainsTarget) {
        if (me.dismissDelay && !isHiding) {
          me.setTimeout("hide", me.dismissDelay);
        }
        if (me.updateContentOnMouseMove && me.getHtml) {
          me.html = me.callback(me.getHtml, me, [{
            tip: me,
            element: me.element,
            forElement: activeTarget,
            event
          }]);
          if (!me.html) {
            me.hide();
            return;
          }
        }
        if (me.trackMouse) {
          me.alignTo({
            position: "mouse",
            ignorePageScroll: true
          });
        }
      }
    }
  }
  // Handle if implementer has defined "showOnClick"
  onElementUserAction(event) {
    this.internalOnPointerOver(event);
  }
  onOwnElementMouseEnter(event) {
    this.abortDelayedHide();
  }
  //endregion
  // rootElement = where to find the float root
  // forElement = where to set up listeners
  // Can be different when using a shadowRoot not part of a webcomponent
  static getSharedTooltip(rootElement, forElement, skipCreating) {
    var _a2, _b, _c;
    let sharedTooltip = (_b = (_a2 = forElement.bryntum) == null ? void 0 : _a2.tooltip) == null ? void 0 : _b.get(_Tooltip);
    if (!sharedTooltip && !skipCreating) {
      if (!((_c = forElement.bryntum) == null ? void 0 : _c.tooltip)) {
        ObjectHelper.setPath(forElement, "bryntum.tooltip", /* @__PURE__ */ new Map());
      }
      const map = forElement.bryntum.tooltip;
      map.set(_Tooltip, true);
      sharedTooltip = new _Tooltip({
        forElement,
        rootElement,
        forSelector: "[data-btip]",
        resetCfg: {},
        isSharedTooltip: true,
        cls: "b-tooltip-shared",
        internalListeners: {
          // Reconfigure on pointerOver
          pointerOver({ source: me, target }) {
            for (const key in me.resetCfg) {
              if (key === "listeners") {
                me.un(me.resetCfg[key].set);
              } else if (key !== "html") {
                me[key] = me.resetCfg[key].was;
              }
            }
            me.resetCfg = {};
            const forComponent = Widget.getById(target.id), config = (forComponent == null ? void 0 : forComponent.tipConfig) || me.gatherDataConfigs(target.dataset);
            if (forComponent && forComponent.element !== target || !forComponent && target.matches(".b-widget") || // Respect our forComponent's wish to not show when it's disabled
            (forComponent == null ? void 0 : forComponent.disabled) && !forComponent.showTooltipWhenDisabled) {
              return false;
            }
            me.owner = forComponent;
            for (const key in config) {
              me.resetCfg[key] = {
                set: config[key],
                was: me[key]
              };
              if (key === "listeners") {
                me.ion(config[key]);
              } else {
                me[key] = config[key];
              }
            }
          },
          hide({ source: me }) {
            me.owner = null;
          }
        },
        gatherDataConfigs(dataset) {
          const me = this, config = {};
          for (const key in dataset) {
            if (key.startsWith("btip")) {
              if (key.length > 4) {
                const configProp = StringHelper.uncapitalize(key.substr(4));
                if (configProp in me.getDefaultConfiguration()) {
                  const value = dataset[key];
                  config[configProp] = isBoolean[value] ? value === "true" : isNaN(value) ? value : parseInt(value, 10);
                }
              } else {
                config.html = dataset[key];
              }
            }
          }
          return config;
        },
        filterTarget(element) {
          const target = element.closest(this.forSelector);
          if (target) {
            return target;
          }
          if (_Tooltip.showOverflow && element.closest(".b-widget")) {
            while ((element == null ? void 0 : element.nodeType) === Element.ELEMENT_NODE) {
              if (DomHelper.getStyleValue(element, "text-overflow") === "ellipsis" && element.clientWidth < element.scrollWidth) {
                this.html = StringHelper.encodeHtml(element.textContent);
                return element;
              }
              element = element.parentNode;
            }
          }
        }
      });
      EventHelper.on({
        element: forElement,
        mouseenter: (event) => _Tooltip.currentOverElement = event.target,
        // If mouse is not used for editing cell then Tooltip has no `currentOverElement` and no error tooltip is shown. We use keydown event.target for this
        keydown: (event) => _Tooltip.currentOverElement = event.target,
        capture: true,
        thisObj: sharedTooltip
      });
      map.set(_Tooltip, sharedTooltip);
    }
    return sharedTooltip;
  }
  static encodeConfig(tooltip) {
    const dataset = {};
    if (typeof tooltip === "string") {
      dataset.btip = tooltip;
    } else {
      for (const config in tooltip) {
        dataset[`btip${config === "html" ? "" : StringHelper.capitalize(config)}`] = tooltip[config];
      }
    }
    return dataset;
  }
};
//region Default config
__publicField(_Tooltip, "$name", "Tooltip");
__publicField(_Tooltip, "type", "tooltip");
var Tooltip = _Tooltip;
Tooltip.initClass();
Object.defineProperty(Widget, "tooltip", {
  get() {
    return Tooltip.getSharedTooltip(document.body, document.body);
  }
});
Widget.Tooltip = Tooltip;
Tooltip._$name = "Tooltip";

// ../Core/lib/Core/widget/mixin/Labelable.js
var Labelable_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    static get configurable() {
      return {
        /**
         * Get/set fields label. Please note that the Field needs to have a label specified from start for this to
         * work, otherwise no element is created.
         * @member {String} label
         */
        /**
         * Label, prepended to field
         * @config {String}
         * @category Label
         */
        label: null,
        /**
         * Label position, either 'before' the field or 'above' the field
         * @config {'before'|'above'}
         * @default
         * @category Label
         */
        labelPosition: "before",
        /**
         * CSS class name or class names to add to any configured {@link #config-label}
         * @config {String|Object}
         * @category Label
         */
        labelCls: null,
        /**
         * The width to apply to the `<label>` element. If a number is specified, `px` will be used.
         * @config {String|Number}
         * @localizable
         * @category Label
         */
        labelWidth: {
          value: null,
          $config: {
            localeKey: "L{labelWidth}"
          }
        }
      };
    }
    get hasLabel() {
      return Boolean(this.label);
    }
    compose() {
      const { hasLabel, labelPosition } = this;
      return {
        class: {
          [`b-label-${labelPosition}`]: hasLabel,
          "b-has-label": hasLabel
        }
      };
    }
    changeLabel(label) {
      return label || "";
    }
    setupLabel(lbl) {
      return ObjectHelper.assign({
        tag: "label",
        for: `${this.id}-input`,
        class: `b-label b-align-${lbl.align || "start"}`
      }, lbl);
    }
    updateLabelWidth(newValue) {
      if (this.labelElement) {
        this.labelElement.style.flex = `0 0 ${DomHelper.setLength(newValue)}`;
        this.inputWrap.style.flexBasis = newValue == null ? "" : "auto";
      }
    }
    //endregion
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {
    }
  }, //region Config
  __publicField(_a2, "$name", "Labelable"), _a2;
};

// ../Core/lib/Core/widget/FieldContainer.js
var FieldContainer = class extends Container {
  static get configurable() {
    return {
      /**
       * An animation config object to use when expanding or collapsing the field's
       * {@link Core.widget.Field#config-container}.
       * @config {Object} animation
       * @property {Number} [animation.duration=300] The duration of the animation (in milliseconds).
       * @internal
       */
      animation: {
        duration: 300
      },
      /**
       * Controls whether the field is collapsed (that is, the field's {@link Core.widget.Field#config-container}
       * is hidden).
       * @config {Boolean}
       * @default false
       */
      collapsed: null,
      /**
       * The animator performing the field's currently running expand or collapse animation.
       * @config {Core.util.Animator}
       * @private
       */
      collapser: {
        value: null,
        $config: "nullify"
        // to abort animations on destroy
      },
      /**
       * A mapping object for config properties of the items in the {@link Core.widget.Field#config-container}.
       * The keys are the config names and the values are functions that compute the config value when passed
       * the field instance.
       *
       * For example, this is the default:
       * ```javascript
       *      syncableConfigs : {
       *          disabled : field => field.disabled
       *      }
       * ```
       * This indicates that the config property named with the key ('disabled') should be assigned to the result
       * of the function assigned to that key (`field => field.disabled`). In other words, when the field is
       * {@link Core.widget.Field#config-disabled}, all of the field's items should also be disabled.
       *
       * @config {Object}
       * @internal
       */
      syncableConfigs: null,
      /**
       * This object holds truthy values for each config property that, when modified, should trigger a sync of
       * this field's items as defined in {@link #config-syncableConfigs}.
       * @config {Object}
       * @internal
       */
      syncConfigTriggers: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      testConfig: {
        animation: {
          duration: 10
        }
      }
    };
  }
  static get delayable() {
    return {
      syncChildConfigs: "raf"
    };
  }
  get inline() {
    var _a2;
    return (_a2 = this.owner.inline) != null ? _a2 : this.ensureItems().count === 1;
  }
  changeCollapsed(collapsed) {
    if (this.togglingCollapse) {
      this.togglingCollapse = false;
      return collapsed;
    }
    this.toggleCollapse(Boolean(collapsed));
  }
  updateCollapsed(collapsed) {
    var _a2;
    this.collapser = (_a2 = this.collapser) == null ? void 0 : _a2.destroy();
    this.setCollapsedCls(collapsed);
  }
  updateCollapser(collapser, was) {
    if (was && was.completed == null) {
      if (!was.reverting || !collapser) {
        was.destroy();
      }
    }
    this.setOwnerCls("b-collapsing", collapser);
  }
  //endregion
  /**
   * This property is `true` if the field container is currently collapsing.
   * @property {Boolean}
   * @readonly
   */
  get collapsing() {
    const { collapser } = this;
    return collapser != null && collapser.collapsed;
  }
  /**
   * This property is `true` if the field container is currently either collapsing or expanding.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  get collapsingExpanding() {
    return this.collapser != null;
  }
  /**
   * This property is `true` if the field container is currently expanding.
   * @property {Boolean}
   * @readonly
   */
  get expanding() {
    const { collapser } = this;
    return collapser != null && !collapser.collapsed;
  }
  collapse(animation) {
    this.toggleCollapse(true, animation);
  }
  expand(animation) {
    this.toggleCollapse(false, animation);
  }
  setCollapsedCls(collapsed) {
    this.setOwnerCls("b-collapsed", collapsed);
  }
  setOwnerCls(cls, state) {
    var _a2, _b;
    (_b = (_a2 = this.owner) == null ? void 0 : _a2.element) == null ? void 0 : _b.classList[state ? "add" : "remove"](cls);
  }
  syncChildConfigs() {
    const me = this, { owner, syncableConfigs } = me;
    if (syncableConfigs) {
      let destProp, val;
      for (destProp in syncableConfigs) {
        val = syncableConfigs[destProp](owner);
        me.eachWidget(
          (item) => {
            item[destProp] = val;
          },
          /* deep = */
          false
        );
      }
    }
    owner.afterSyncChildConfigs(me);
  }
  syncContainer() {
    const { inline, layout } = this;
    if (this.autoLayout) {
      layout.horizontal = inline;
      layout.justify = inline ? "center" : "stretch";
    }
  }
  toggleCollapse(collapsed, animation) {
    const me = this, { animation: collapseAnimation, collapser, inline } = me, { containerWrapElement } = me.owner, finalize = (complete) => {
      if (complete) {
        me.element.style.height = "";
        me.togglingCollapse = true;
        me.collapsed = collapsed;
        me.collapser = null;
      }
    };
    if (collapsed == null) {
      collapsed = !me.collapsed;
    }
    if (animation !== false && animation !== null) {
      if (!containerWrapElement || !me.isVisible) {
        animation = null;
      } else {
        if (animation === true) {
          animation = {};
        } else if (typeof animation === "number") {
          animation = {
            duration: animation
          };
        }
        animation = collapseAnimation || animation ? ObjectHelper.merge({}, collapseAnimation, animation) : null;
      }
    }
    if (!animation) {
      me.togglingCollapse = true;
      me.collapsed = collapsed;
    } else if (collapser && collapsed !== collapser.collapsed) {
      me.collapser = collapser.revert({ finalize });
      me.collapser.collapsed = collapsed;
    } else if (!collapser && collapsed !== me.collapsed) {
      !collapsed && me.setCollapsedCls(false);
      const { element } = me, { height } = element.getBoundingClientRect(), expanded = inline ? 1 : height;
      !collapsed && me.setCollapsedCls(true);
      element.style.height = `${height}px`;
      me.collapser = Animator.run(ObjectHelper.merge({
        finalize,
        element: containerWrapElement,
        [inline ? "opacity" : "height"]: {
          from: collapsed ? expanded : 0,
          to: collapsed ? 0 : expanded
        }
      }, animation));
      me.collapser.collapsed = collapsed;
    }
  }
};
//region Config
__publicField(FieldContainer, "$name", "FieldContainer");
__publicField(FieldContainer, "type", "fieldcontainer");
FieldContainer.initClass();
FieldContainer._$name = "FieldContainer";

// ../Core/lib/Core/widget/Field.js
var byWeight = (l, r) => (l.weight || 0) - (r.weight || 0);
var byWeightReverse = (l, r) => (r.weight || 0) - (l.weight || 0);
var emptyArray8 = [];
var triggerConfigs = {
  align: true,
  weight: true
};
var _Field = class _Field extends Widget.mixin(Badge_default, Labelable_default) {
  static get configurable() {
    return {
      defaultBindProperty: "value",
      /**
       * @hideconfigs htmlCls, content, tag, scrollable, html
       */
      /**
       * Text to display in empty field.
       * @config {String} placeholder
       */
      placeholder: null,
      /**
       * Gets or sets the value. The returned type will depend upon the Field subclass.
       *
       * `TextField` returns a `String`.
       *
       * `NumberField` returns a `Number`.
       *
       * `DateField` and `TimeField` return a `Date` object, and `null` if the field is empty.
       *
       * `Combo` will return a `String` if configured with `items` as a simple string array.
       * Otherwise it will return the {@link Core.widget.Combo#config-valueField} value from the
       * selected record, or `null` if no selection has been made.
       * @member {*} value
       */
      /**
       * Default value
       * @config {String}
       */
      value: "",
      /**
       * Name of the field which is used as a key to get/set values from/to the field.
       * Used prior to {@link Core.widget.Widget#config-ref ref} and {@link Core.widget.Widget#config-id id} in
       * {@link Core.widget.Container#property-values Container.values}.
       *
       * The config is useful when the field is used in EventEditor or TaskEditor to load/save values automatically.
       * @config {String}
       */
      name: null,
      /**
       * The labels to add either before or after the input field.
       * Each label may have the following properties:
       * * `html` The label text.
       * * `align` `'start'` or `'end'` which end of the field the label should go.
       * @config {Object[]}
       * @property {String} html Label text
       * @property {'start'|'end'} align Which end of the file the label should go
       * @category Label
       */
      labels: null,
      /**
       * Configure as `true` to indicate that a `null` field value is to be marked as invalid.
       * @config {Boolean}
       * @default false
       */
      required: null,
      /**
       * Show a trigger to clear field, and allow `SHIFT+BACKSPACE` key to clear field if this field is
       * not {@link #config-readOnly}. The trigger is available in the {@link #property-triggers} object
       * under the name `clear`. May also be an object which configures the `clear`
       * {@link #property-triggers trigger}.
       * @config {Boolean|FieldTriggerConfig}
       * @default false
       */
      clearable: null,
      /**
       * If this field is not {@link #config-readOnly}, then setting this option means that pressing
       * the `ESCAPE` key after editing the field will revert the field to the value it had when
       * the user focused the field. If the field is _not_ changed from when focused, the {@link #config-clearable}
       * behaviour will be activated.
       * @config {Boolean}
       * @default false
       */
      revertOnEscape: null,
      /**
       * An optional string to display inside the input field as an overlay. This can be useful for displaying
       * a field's units.
       *
       * This config is ignored if {@link #config-hintHtml} is set.
       *
       * For example:
       * ```javascript
       *  {
       *      type  : 'numberfield',
       *      label : 'Temperature',
       *      hint  : '°C'
       *  }
       * ```
       *
       * This config can be set to a function to dynamically generate the `hint` text:
       * ```javascript
       *  {
       *      type  : 'numberfield',
       *      label : 'Duration',
       *      hint  : ({ value }) => (value === 1) ? 'Day' : 'Days'
       *  }
       * ```
       *
       * The function is passed an object with the following properties:
       *
       *  - `source` A reference to the field instance.
       *  - `value` The current value of the field.
       *
       * A `hint` function will be called when the field changes value.
       *
       * @config {String|Function}
       * @param {Object} data A data object
       * @param {Core.widget.Field} data.source A reference to the field instance
       * @param {*} data.value The current value of the field
       * @returns {String}
       * @category Label
       */
      hint: null,
      /**
       * This config is similar to {@link #config-hint} except that this config is used to display HTML content.
       * Since this can allow malicious content to be executed, be sure not to include user-entered data or to
       * encode such data (see {@link Core.helper.StringHelper#function-encodeHtml-static}).
       *
       * If this config is set, {@link #config-hint} is ignored.
       *
       * For example:
       * ```javascript
       *  {
       *      type     : 'numberfield',
       *      label    : 'Temperature',
       *      hintHtml : '<i>°C</i>'
       *  }
       * ```
       *
       * This config can be set to a function to dynamically generate the `hintHtml` text:
       * ```javascript
       *  {
       *      type     : 'numberfield',
       *      label    : 'Duration',
       *      hintHtml : ({ value }) => (value === 1) ? '<i>Day</i>' : '<i>Days</i>'
       *  }
       * ```
       *
       * The function is passed an object with the following properties:
       *
       *  - `source` A reference to the field instance.
       *  - `value` The current value of the field.
       *
       * A `hintHtml` function will be called when the field changes value.
       *
       * @config {String|Function}
       * @param {Object} data A data object
       * @param {Core.widget.Field} data.source A reference to the field instance
       * @param {*} data.value The current value of the field
       * @returns {String}
       * @category Label
       */
      hintHtml: null,
      /**
       * The width to apply to the `<input>` element. If a number is specified, `px` will be used.
       * @config {String|Number}
       * @category Input element
       */
      inputWidth: null,
      /**
       * The delay in milliseconds to wait after the last keystroke before triggering a change event.
       * Set to 0 to not trigger change events from keystrokes (listen for input event instead to have
       * immediate feedback, change will still be triggered on blur).
       *
       * If the field is {@link #config-clearable}, the change event fires immediately on receiving
       * the clear gesture.
       * @config {Number}
       * @default
       */
      keyStrokeChangeDelay: 0,
      /**
       * Makes the field unmodifiable by user action. The input area is not editable, and triggers
       * are unresponsive.
       *
       * This is a wider-acting setting than {@link #config-editable} which *only* sets the
       * `readOnly` attribute of the `<input>` field.
       *
       * {@link Core.widget.PickerField}s such as `Combo` and `DateField` can be `editable : false`, but still
       * modifiable through the UI.
       * @prp {Boolean}
       */
      readOnly: null,
      /**
       * Set to false to prevent user from editing the field. For TextFields it is basically the same as setting
       * {@link #config-readOnly}, but for PickerFields there is a distinction where it allows you to pick a value
       * but not to type one in the field.
       *
       * {@link Core.widget.PickerField}s such as `Combo` and `DateField` can be `editable : false`, but still
       * modifiable through the UI.
       *
       * On mobile devices, {@link Core.widget.PickerField}s are set to `editable : false` by
       * default so that the user must select a value from the dropdown picker rather than having
       * to type a value which will cause a display of the virtual keyboard.
       *
       * If typing is essential to the functioning of the field, configuring the field
       * with `editable : true` will override this behaviour.
       * @prp {Boolean}
       * @default true
       */
      editable: true,
      defaultAction: "change",
      /**
       * The trigger Widgets as specified by the {@link #config-triggers} configuration and the
       * {@link #config-clearable} configuration. Each is a {@link Core.widget.Widget} instance which may
       * be hidden, shown and observed and styled just like any other widget.
       * @member {Object<String,Core.widget.Widget>} triggers
       */
      /**
       * The triggers to add either before or after the input field. Each property name is the reference by which
       * an instantiated Trigger Widget may be retrieved from the live `{@link #property-triggers}` property.
       *
       * Each trigger may have the following properties:
       * * `cls` The CSS class to apply.
       * * `handler` A method in the field to call upon click
       * * `align` `'start'` or `'end'` which end of the field the trigger should go.
       * * `weight` (Optional) Higher weighted triggers gravitate towards the input field.
       *
       * ```javascript
       * const textField = new TextField({
       *   triggers : {
       *       check : {
       *           cls : 'b-fa b-fa-check',
       *           handler() {
       *               ...
       *           }
       *       },
       *       ...
       *   }
       * })
       * ```
       *
       * @config {Object<String,FieldTriggerConfig>}
       */
      triggers: null,
      /**
       * Specify `false` to prevent field from being highlighted when on external value changes
       * @config {Boolean}
       */
      highlightExternalChange: true,
      localizableProperties: ["label", "title", "placeholder", "labelWidth"],
      /**
       * Specify `true` to auto select field contents on focus
       * @config {Boolean}
       * @default
       */
      autoSelect: false,
      /**
       * Sets the native `autocomplete` property of the underlying input element. For more information, please refer to
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete)
       * @config {String}
       * @default
       * @category Input element
       */
      autoComplete: "off",
      /**
       * Sets the native `spellcheck` property of the underlying input element. For more information, please refer to
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/spellcheck)
       * @config {Boolean}
       * @category Input element
       */
      spellCheck: null,
      /**
       * Set to `false` to not highlight a field as invalid while typing, to instead show it on ENTER key press
       * or similar.
       * @config {Boolean}
       * @category Input element
       */
      validateOnInput: true,
      /**
       * Sets custom attributes of the underlying input element. For more information, please refer to
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes)
       * @config {Object}
       * @default
       * @category Input element
       */
      inputAttributes: null,
      /**
       * Sets the `type` attribute of the underlying input element (password, hidden, date, color, etc).
       * @config {String}
       * @category Input element
       */
      inputType: "text",
      /**
       * Text alignment for the input field.
       * @config {String}
       * @category Input element
       */
      inputAlign: null,
      /**
       * A list of property names to be set in the underlying input element from properties
       * by the same name in this Field object if the value is not `== null`.
       * @private
       * @category Input element
       */
      attributes: {
        value: [
          "placeholder",
          "autoComplete",
          "spellCheck",
          "minLength",
          "maxLength",
          "pattern",
          "tabIndex",
          "min",
          "max"
        ],
        $config: {
          merge: "distinct"
        }
      },
      nullValue: {
        $config: null,
        value: null,
        default: null
        // store _value=null on prototype
      },
      updatedClsDuration: 500,
      inputReadOnly: false,
      ariaElement: "input",
      /**
       * The configuration for additional items associated to this field. This is typically used to add contextual
       * fields related to a {@link Core.widget.Checkbox checkbox} or {@link Core.widget.Radio radio button}. See
       * these classes for examples of nested fields.
       *
       * This config can be provided as an array of widget config objects, an object with named widgets (see
       * {@link Core.widget.FieldContainer#config-namedItems}, or a config object for the whole
       * {@link Core.widget.FieldContainer field container}.
       *
       * To determine if the object is a `namedItems` object or a {@link Core.widget.FieldContainer field container}
       * config, the object is checked for either a `type` or an `items` property. If it has either of these
       * properties, it is a field container config object. Configuring the container is useful for applying
       * {@link Core.widget.FieldContainer#config-cls classes} or {@link Core.widget.FieldContainer#config-style styles}
       * to the container as a whole.
       *
       * For example, to add named items:
       * ```javascript
       *  new Checkbox({
       *      text : 'Separate shipping address',
       *      container : {
       *          address1 : {
       *              type : 'textfield'
       *          },
       *          address2 : {
       *              type : 'textfield'
       *          }
       *      }
       *  });
       * ```
       *
       * To style the container as well, move the items to the `items` property and add `cls`:
       * ```javascript
       *  new Checkbox({
       *      text : 'Separate shipping address',
       *      container : {
       *          cls   : 'address-form',
       *          items : {
       *              address1 : {
       *                  type : 'textfield'
       *              },
       *              address2 : {
       *                  type : 'textfield'
       *              }
       *          }
       *      }
       *  });
       * ```
       *
       * @config {Core.widget.FieldContainer}
       * @accepts {Object<string,ContainerItemConfig>|ContainerItemConfig[]|FieldContainerConfig}
       * @category Container
       */
      container: {
        $config: "nullify",
        value: null
      },
      /**
       * The default configuration for the {@link #config-container}.
       * @config {Core.widget.FieldContainer}
       * @accepts {Core.widget.FieldContainer|FieldContainerConfig}
       * @category Container
       * @internal
       */
      containerDefaults: {
        type: "fieldcontainer",
        syncableConfigs: {
          disabled: (field) => field.disabled
        },
        syncConfigTriggers: {
          disabled: 1
        }
      },
      /**
       * The config controls how the value of nested items are handled when a parent container gets or sets its
       * {@link Core.widget.Container#property-values}.
       *
       * The valid values for this config are:
       *  - `null` (the default) will include the values of this field's items if this field stores its own value.
       *  - `true` to always include the values of this field's items.
       *  - `false` to never include the values of this field's items.
       *  - `'nested'` to include the values of this field's items as a nested object under the field's `name`.
       *    This field's `value` is stored as the `'value'` property of that object.
       *  - Any other string is treated as the name of a property on this field. When truthy, the values of this
       *    field's items will be included.
       *  - A function can be supplied that must return a value given this field as its sole argument. If that
       *    value is truthy, this field's items will be included.
       *
       * @config {Boolean|String|Function}
       * @param {Core.widget.Field} field Field instance
       * @returns {Boolean}
       * @category Container
       */
      containValues: null,
      /**
       * Set this config to `true` to always display items horizontally along with this field. This assigns an
       * {@link Core.widget.layout.Box hbox} as the {@link Core.widget.Container#config-layout} to the
       * {@link #config-container}.
       *
       * Alternatively, set this config to `false` to wrap this field's items below. This assigns a
       * {@link Core.widget.layout.VBox} as the {@link Core.widget.Container#config-layout} to the
       * {@link #config-container}.
       *
       * This config defaults to `true` if there is exactly one item, and `false` otherwise.
       * @config {Boolean}
       * @category Container
       */
      inline: null,
      testConfig: {
        updatedClsDuration: 10
      },
      keyMap: {}
    };
  }
  static get delayable() {
    return {
      highlightChanged: "raf"
    };
  }
  doDestroy() {
    var _a2, _b, _c;
    const me = this, { triggers } = me, errorTip = me.isPainted && _Field.getSharedErrorTooltip(me.rootElement, true);
    (_a2 = me.inputListenerRemover) == null ? void 0 : _a2.call(me);
    (_b = me.keyListenerRemover) == null ? void 0 : _b.call(me);
    (_c = me.container) == null ? void 0 : _c.destroy();
    super.doDestroy();
    if (triggers) {
      for (const t of Object.values(triggers)) {
        t.destroy();
      }
    }
    if ((errorTip == null ? void 0 : errorTip.field) === me) {
      errorTip.hide();
    }
  }
  get childItems() {
    const { container, triggers } = this, ret = triggers ? Object.values(triggers) : [];
    return container ? [...ret, ...container.childItems] : ret;
  }
  get invalidValueError() {
    return "L{invalidValue}";
  }
  /**
   * A singleton error tooltip which activates on hover of invalid fields.
   * before show, it gets a reference to the field and interrogates its
   * active error list to display as the tip content.
   * @member {Core.widget.Tooltip}
   * @readonly
   */
  get errorTip() {
    return this.constructor.getSharedErrorTooltip(this.rootElement);
  }
  static getSharedErrorTooltip(rootElement, doNotCreate) {
    var _a2;
    let sharedErrorTooltip = (_a2 = rootElement.bryntum) == null ? void 0 : _a2.errorTooltip;
    if (!sharedErrorTooltip && !doNotCreate) {
      rootElement.bryntum = rootElement.bryntum || {};
      sharedErrorTooltip = new Tooltip({
        cls: "b-field-error-tip",
        forSelector: ".b-field.b-invalid .b-field-inner",
        align: {
          align: "l-r",
          monitorTargetMutation: true
        },
        scrollAction: "realign",
        trapFocus: false,
        rootElement,
        onBeforeShow() {
          const tip = this, field = Widget.fromElement(tip.activeTarget);
          if (field) {
            const errors = field.getErrors();
            if (errors) {
              tip.html = errors.join("<br>");
              tip.field = field;
              return true;
            }
          }
          return false;
        }
      });
      rootElement.bryntum.errorTooltip = sharedErrorTooltip;
    }
    return sharedErrorTooltip;
  }
  /**
   * A singleton error tooltip which activates on hover of invalid fields.
   * before show, it gets a reference to the field and interrogates its
   * active error list to display as the tip content.
   *
   * Please note: Not applicable when using widgets inside a shadow root
   * @member {Core.widget.Tooltip}
   * @readonly
   * @static
   */
  static get errorTip() {
    return this.getSharedErrorTooltip(document.body);
  }
  //endregion
  //region Event
  /**
   * Fired when the user types into this field.
   * @event input
   * @param {Core.widget.Field} source This field
   * @typings source -> {Core.widget.Field||any}
   * @param {String} value - This field's value
   * @typings value -> {String||Number||Boolean||any}
   * @param {Event} event - The triggering DOM event
   */
  /**
   * Fired when this field's value changes.
   * @event change
   * @param {Core.widget.Field} source - This Field
   * @typings source -> {Core.widget.Field||any}
   * @param {String} value - This field's value
   * @typings value -> {String||Number||Boolean||any}
   * @param {String} oldValue - This field's previous value
   * @typings oldValue -> {String||Number||Boolean||any}
   * @param {Boolean} valid - True if this field is in a valid state
   * @param {Event} event - The triggering DOM event if any
   * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
   *
   * @typings checked -> {Boolean} // Used for compatibility with Checkbox event
   */
  /**
   * User performed default action (typed into this field).
   * @event action
   * @param {Core.widget.Field} source - This Field
   * @typings source -> {Core.widget.Field||any}
   * @param {String} value - This field's value
   * @typings value -> {String||Number||Boolean||any}
   * @param {String} oldValue - This field's previous value
   * @typings oldValue -> {String||Number||Boolean||any}
   * @param {Boolean} valid - True if this field is in a valid state
   * @param {Event} event - The triggering DOM event if any
   * @param {Core.data.Model} record Selected record. Available for fields with records selection functionality
   * @param {Core.data.Model[]} records Selected records as an array. Available for fields with records selection functionality
   * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
   *
   * @typings checked -> {Boolean} // Used for compatibility with Checkbox event
   */
  /**
   * Fired when this field is {@link #function-clear cleared}.
   *
   * This will be triggered when a user clicks this field's clear {@link #property-triggers trigger}
   * @event clear
   * @param {Core.widget.Field} source - This Field
   * @typings source -> {Core.widget.Field||any}
   */
  /**
   * User clicked one of this field's {@link #property-triggers}
   * @event trigger
   * @param {Core.widget.Field} source This field
   * @typings source -> {Core.widget.Field||any}
   * @param {Core.widget.Widget} trigger The trigger activated by click or touch tap.
   */
  //endregion
  //region Init
  construct(config) {
    super.construct(config);
    const me = this;
    if (me.keyStrokeChangeDelay) {
      me.changeOnKeyStroke = me.buffer(me.internalOnChange, me.keyStrokeChangeDelay);
    }
  }
  // Adding triggers keymap to field keymap with prefix 'triggerName.';
  changeKeyMap(keyMap) {
    var _a2;
    const me = this;
    let mergedKeyMap = {};
    if (keyMap) {
      if (!me._fieldKeyMap) {
        me._fieldKeyMap = keyMap;
        ObjectHelper.assign(mergedKeyMap, keyMap);
      } else {
        ObjectHelper.assign(mergedKeyMap, me._fieldKeyMap);
      }
    }
    for (const triggerName in me.triggers) {
      if ((_a2 = me.triggers[triggerName]) == null ? void 0 : _a2.keyMap) {
        mergedKeyMap = me.mergeKeyMaps(mergedKeyMap, me.triggers[triggerName].keyMap, triggerName);
      }
    }
    return mergedKeyMap;
  }
  get keyMapSubComponents() {
    return this.triggers;
  }
  onFocusIn(e) {
    const me = this;
    me.valueOnFocus = ObjectHelper.clone(me.value);
    me.validOnFocus = !(me.errors && Object.keys(me.errors).length);
    super.onFocusIn(e);
    me.focusing = true;
    me.syncInvalid();
    me.focusing = false;
  }
  onFocusOut(e) {
    super.onFocusOut(e);
    this.syncRequired();
    this.onEditComplete();
  }
  /**
   * Template function which may be implemented by subclasses to synchronize
   * input state and validity state upon completion of the edit.
   * @internal
   */
  onEditComplete() {
  }
  get rootUiClass() {
    return _Field;
  }
  compose() {
    this.getConfig("clearable");
    const me = this, { container, innerElements, label, labels, labelCls, readOnly, triggers } = me, triggerInstances = ObjectHelper.values(triggers, (k, v) => !v), startTriggers = triggerInstances.filter((t) => t.align === "start").sort(byWeight), endTriggers = triggerInstances.filter((t) => t.align !== "start").sort(byWeightReverse), setupLabel = me.setupLabel.bind(me), innerChildren = [
      ...startTriggers.map((t) => t.element),
      ...innerElements,
      ...endTriggers.map((t) => t.element)
    ];
    return {
      class: {
        "b-has-start-trigger": startTriggers.length,
        "b-no-input": !innerElements.length,
        "b-readonly": readOnly,
        "b-field-container": Boolean(container),
        "b-field-container-inline": container == null ? void 0 : container.inline
      },
      children: [
        ...(labels || emptyArray8).filter((t) => t && t.align !== "end").map(setupLabel),
        (label || null) && setupLabel({
          reference: "labelElement",
          class: `b-label b-align-start ${labelCls || ""}`,
          html: label
        }),
        innerChildren.length ? {
          class: "b-field-inner",
          reference: "inputWrap",
          children: innerChildren
        } : null,
        ...(labels || emptyArray8).filter((t) => (t == null ? void 0 : t.align) === "end").map(setupLabel),
        ...container ? [{
          reference: "containerWrapElement",
          children: [container.element],
          class: {
            "b-field-container-wrap": 1
          }
        }] : emptyArray8
      ]
    };
  }
  updateElement(element, was) {
    var _a2;
    const me = this, value = me.initialConfig.value, { input } = me;
    super.updateElement(element, was);
    if (value != null) {
      me.value = value;
    }
    me.syncEmpty();
    me.updateInputReadOnly(me.inputReadOnly);
    me.syncInvalid();
    const keyEventElement = input || me.focusElement;
    (_a2 = me.keyListenerRemover) == null ? void 0 : _a2.call(me);
    me.keyListenerRemover = keyEventElement && EventHelper.on({
      element: keyEventElement,
      thisObj: me,
      keydown: "internalOnKeyEvent",
      keypress: "internalOnKeyEvent",
      keyup: "internalOnKeyEvent"
    });
  }
  // Subclasses may implement this.
  // Needed because Checkbox produces an array of two elements as its innerElements
  get innerElements() {
    return [this.inputElement];
  }
  /**
   * The input element at the heart if this field
   * @member {HTMLElement} input
   */
  get inputElement() {
    const { attributes, inputAttributes, id, inputCls, inputType, name } = this, domConfig = ObjectHelper.assign({
      reference: "input",
      tag: "input",
      type: inputType,
      name: name || id,
      id: `${id}-input`,
      retainElement: true
      // allow the input to be transplanted as in combo/chipView
    }, inputAttributes);
    if (inputCls) {
      domConfig.class = inputCls;
    }
    for (let key, value, i = attributes.length; i-- > 0; ) {
      key = attributes[i];
      value = this[key];
      if (value != null) {
        domConfig[key] = value;
      }
    }
    return domConfig;
  }
  //endregion
  //region Focus & select
  get caretPos() {
    return this.textSelection[0];
  }
  set caretPos(value) {
    this.textSelection = value;
  }
  get focusElement() {
    return this.input;
  }
  get textSelection() {
    var _a2;
    const input = this.input;
    let ret;
    try {
      ret = [input.selectionStart, input.selectionEnd, input.selectionDirection];
    } catch (e) {
      ret = ((_a2 = input.value) == null ? void 0 : _a2.length) || 0;
      ret = [ret, ret];
    }
    return ret;
  }
  set textSelection(value) {
    if (typeof value === "number") {
      this.select(value, value);
    } else {
      this.select(...value);
    }
  }
  get hasTextSelection() {
    const [selectionStart, selectionEnd] = this.textSelection;
    return selectionStart && selectionEnd - selectionStart > 0;
  }
  /**
   * Returns the input value for this field's input element that will be present if
   * the event carrying the given text is allowed to proceed.
   * @param {String} text
   * @returns {String}
   * @private
   */
  getAfterValue(text) {
    const [begin, end] = this.textSelection, value = this.input.value;
    return `${value.substr(0, begin)}${text}${value.substr(end || begin)}`;
  }
  /**
   * Selects the field contents. Optionally may be passed a start and end.
   * @param {Number} [start] The start index from which to select the input.
   * @param {Number} [end] The index at which to end the selection of the input.
   */
  select(start, end) {
    const input = this.focusElement;
    if (input.value.length) {
      if (arguments.length === 0) {
        this.selectAll();
        return;
      }
      if (!this.supportsTextSelection) {
        return;
      }
      input.setSelectionRange(start, end);
    }
  }
  moveCaretToEnd() {
    const input = this.input;
    if (input.createTextRange) {
      const range = input.createTextRange();
      range.collapse(false);
      range.select();
    } else if (this.supportsTextSelection) {
      this.select(input.value.length, input.value.length);
    }
  }
  selectAll() {
    this.focusElement.select();
  }
  // called on value changes to update styling of empty vs non-empty field
  syncEmpty() {
    var _a2;
    const { isEmptyInput, isEmpty, element } = this, clear = (_a2 = this.triggers) == null ? void 0 : _a2.clear, empty2 = isEmptyInput && isEmpty;
    if (element) {
      if (clear) {
        clear[empty2 ? "hide" : "show"]();
      }
      element.classList.toggle("b-empty", empty2);
    }
  }
  updateHint() {
    this.syncHint();
  }
  updateHintHtml() {
    this.syncHint();
  }
  syncHint() {
    const me = this, { input, hint, hintHtml } = me, parent = input == null ? void 0 : input.parentElement;
    if (input) {
      let hintValue = hintHtml || hint;
      const hintElement = me.hintElement || hintValue && (me.hintElement = DomHelper.createElement({
        parent,
        className: "b-field-hint",
        nextSibling: input.nextSibling,
        children: [{
          className: "b-field-hint-content"
        }]
      }));
      if (hintElement) {
        if (typeof hintValue === "function") {
          hintValue = hintValue({ source: me, value: me.value });
        }
        hintElement.firstChild[hintHtml ? "innerHTML" : "textContent"] = hintValue || "";
      }
      me.element.classList[hintValue ? "remove" : "add"]("b-field-no-hint");
    }
  }
  syncInvalid() {
    const me = this, { isPainted } = me;
    me.updatingInvalid = true;
    if (isPainted) {
      const { isValid, element, inputWrap } = me;
      element.classList[isValid ? "remove" : "add"]("b-invalid");
      if (isValid) {
        const errorTip = me.constructor.getSharedErrorTooltip(me.rootElement, true);
        if ((errorTip == null ? void 0 : errorTip.isVisible) && errorTip.field === me) {
          errorTip.hide();
        }
      } else {
        const errorTip = me.errorTip;
        if (errorTip && (me.containsFocus || me.isVisible && inputWrap.contains(Tooltip.currentOverElement))) {
          if (errorTip.activeTarget === inputWrap && errorTip.isVisible) {
            errorTip.onBeforeShow();
          } else {
            errorTip.activeTarget = inputWrap;
            errorTip.showBy(inputWrap);
          }
        }
      }
    }
    me.updatingInvalid = false;
  }
  //endregion
  //region Getters/setters
  updateEditable() {
    this.syncInputReadOnly();
  }
  syncInputReadOnly() {
    this.getConfig("readOnly");
    this.inputReadOnly = this._readOnly || this.editable === false;
  }
  updateInputReadOnly(readOnly) {
    const me = this, { input, inputListenerRemover } = me;
    if (input) {
      input.readOnly = readOnly ? "readOnly" : null;
      if (readOnly) {
        me.inputListenerRemover = inputListenerRemover == null ? void 0 : inputListenerRemover();
      } else if (!inputListenerRemover) {
        me.inputListenerRemover = EventHelper.on({
          element: input,
          thisObj: me,
          focus: "internalOnInputFocus",
          change: "internalOnChange",
          input: "internalOnInput"
        });
      }
    }
  }
  changeReadOnly(value) {
    return Boolean(value);
  }
  updateReadOnly(readOnly) {
    this.syncInputReadOnly();
  }
  updateClearable(clearable) {
    const me = this;
    me.getConfig("triggers");
    me.triggers = {
      clear: clearable && ObjectHelper.assign({
        cls: "b-icon-remove",
        weight: 1e3,
        key: "Shift+backspace",
        handler() {
          me._isUserAction = true;
          me.clear(...arguments);
          me._isUserAction = false;
        }
      }, clearable) || null
    };
  }
  changeTriggers(triggers, was) {
    const me = this, manager = me.$triggers || (me.$triggers = new DynamicObject({
      configName: "triggers",
      factory: _Field.Trigger,
      inferType: false,
      // the name of a trigger in the triggers object is not its type
      owner: me,
      created(instance) {
        FunctionHelper.after(instance, "onConfigChange", (ret, { name }) => {
          if (triggerConfigs[name]) {
            me.onConfigChange({
              name: "triggers",
              value: manager.target
            });
          }
        });
      },
      setup(config, name) {
        config.reference = config.ref = name;
        config.parent = me;
      }
    }));
    if (me.stepTriggers === false && (triggers.back || triggers.forward)) {
      triggers = ObjectHelper.assign({}, triggers);
      delete triggers.back;
      delete triggers.forward;
    }
    manager.update(triggers);
    if (me.element) {
      me.keyMap = me.keyMap;
    }
    if (!was) {
      return manager.target;
    }
  }
  updateInputWidth(newValue) {
    this.input.style.width = DomHelper.setLength(newValue);
    this.element.classList.add("b-has-width");
  }
  updateInputAlign(newValue) {
    this.input.style.textAlign = newValue;
  }
  /**
   * Returns true if the field value is valid
   * @type {Boolean}
   * @readonly
   */
  get isValid() {
    const me = this;
    if (!me.disabled) {
      me.syncRequired();
      if (me.errors && Object.keys(me.errors).length) {
        return false;
      }
      const validity = me.validity;
      if (validity) {
        return validity.valid;
      }
    }
    return true;
  }
  /**
   * Returns `true` if this field is empty. That is, if it would violate the {@link #config-required}
   * setting.
   *
   * This may have different definitions in subclasses from simple text fields.
   * @type {Boolean}
   * @readonly
   */
  get isEmpty() {
    return this.value == null || this.value === "";
  }
  /**
   * Returns true if the field's input is empty
   * @type {Boolean}
   * @readonly
   */
  get isEmptyInput() {
    return !this.input || this.input.value == null || this.input.value === "";
  }
  /**
   * Returns the DOM `ValidityState` for this widget's input element, or `null` if there
   * isn't one.
   * @returns {ValidityState}
   * @private
   */
  get validity() {
    const input = this.input;
    return input == null ? void 0 : input.validity;
  }
  // Called by Editor.js, for overriding in subclasses that require async setting of values (custom editors in React)
  async setValue(value) {
    this.value = value;
  }
  changeValue(value, was) {
    if (value == null) {
      value = this.nullValue;
    }
    if (this.hasChanged(was, value)) {
      return value;
    }
    if (value === "") {
      this.syncRequired();
    }
    return was;
  }
  updateValue(value, oldValue) {
    const me = this;
    if (!me.isConfiguring) {
      me.syncRequired();
      if (!me.inputting) {
        me.triggerChange();
      }
    }
    if (!me.inputting) {
      me._lastValue = value;
    }
    me.syncInputFieldValue();
    if (me.overflowTwin && !me._overflowTwinSync) {
      me._overflowTwinSync = true;
      me.overflowTwin.value = value;
      me._overflowTwinSync = false;
    }
  }
  /**
   * Compares this field's value with its previous value. May be overridden in subclasses
   * which have more complex value types. See, for example, {@link Core.widget.DurationField}.
   * @param {*} oldValue
   * @param {*} newValue
   * @private
   */
  hasChanged(oldValue, newValue) {
    return newValue !== oldValue;
  }
  /**
   * Called by the base Field class's `set value` to sync the state of the UI with the field's value.
   *
   * Relies upon the class implementation of `get inputValue` to return a string representation of
   * the value for user consumption and editing.
   * @private
   */
  syncInputFieldValue(skipHighlight = false) {
    const me = this, { input, parent, inputValueAttr, inputValue } = me;
    if (input && !me.inputting && input[inputValueAttr] !== inputValue) {
      input[inputValueAttr] = inputValue;
      if (!me.isConfiguring && !me.containsFocus && me.highlightExternalChange) {
        input.classList.remove("b-field-updated");
        me.clearTimeout("removeUpdatedCls");
        if (parent) {
          const { assigningValues } = parent;
          if (assigningValues === true || (assigningValues == null ? void 0 : assigningValues.highlight) === false) {
            skipHighlight = true;
          }
        }
        if (!skipHighlight) {
          me.highlightChanged();
        }
      }
    }
    me.syncEmpty();
    me.syncInvalid();
  }
  highlightChanged() {
    this.input.classList.add("b-field-updated");
    this.setTimeout("removeUpdatedCls", this.updatedClsDuration);
  }
  removeUpdatedCls() {
    this.input.classList.remove("b-field-updated");
  }
  /**
   * A String representation of the value of this field for {@link #function-syncInputFieldValue} to use
   * as the input element's value.
   *
   * Subclasses may override this to create string representations.
   *
   * For example, {@link Core.widget.DateField}'s implementation will format the field date
   * value according to its configured {@link Core.widget.DateField#config-format}. And {@link Core.widget.Combo}'s
   * implementation will return the {@link Core.widget.Combo#config-displayField} of the selected record.
   * @internal
   * @readOnly
   */
  get inputValue() {
    return this.value == null ? "" : this.value;
  }
  get inputValueAttr() {
    return "value";
  }
  get supportsTextSelection() {
    const input = this.focusElement;
    return input && (input.tagName.toLowerCase() === "textarea" || input.type && /text|search|password|tel|url/.test(input.type));
  }
  //endregion
  //region Events
  internalOnInputFocus() {
    if (this.autoSelect) {
      this.selectAll();
    }
  }
  /**
   * Trigger event when fields input changes
   * @fires change
   * @private
   */
  internalOnChange(event) {
    const me = this;
    if (me.hasChanged(me._lastValue, me.value) && me.isValid) {
      me.triggerChange(event, true);
      me._lastValue = me.value;
    }
  }
  triggerChange(event, userAction = Boolean(this._isUserAction)) {
    const me = this, {
      value,
      _lastValue: oldValue,
      isValid: valid
    } = me;
    me.syncHint();
    me.triggerFieldChange({ value, oldValue, event, userAction, valid });
    if (me.defaultAction === "change") {
      me.trigger("action", { value, oldValue, event, userAction, valid });
    }
  }
  fetchInputValue() {
    this.value = this.input[this.inputValueAttr];
  }
  /**
   * Trigger event when user inputs into field
   * @fires input
   * @param event
   * @private
   */
  internalOnInput(event) {
    var _a2;
    const me = this;
    if (!me.validateOnInput) {
      me.errorTip.hide();
    }
    me.inputting = true;
    me.fetchInputValue();
    me.inputting = false;
    me.trigger("input", { value: me.value, event });
    (_a2 = me.changeOnKeyStroke) == null ? void 0 : _a2.call(me, event);
  }
  /**
   * Returns `true` if the {@link #property-input} field needs to be synced with the internal
   * {@link #property-value} of this field.
   *
   * May be overridden in subclasses where this is more complex such as multiSelect Combo
   * with a `ChipView` where the input area does not reflect the field's value.
   * @private
   */
  get needsInputSync() {
    var _a2;
    return this.input[this.inputValueAttr] !== String((_a2 = this.inputValue) != null ? _a2 : "");
  }
  internalOnKeyEvent(event) {
    const me = this, { value } = me;
    let stopEvent = false;
    if (event.type === "keydown") {
      if (event.key === "Escape" && !(me.readOnly || me.disabled)) {
        const wasValid = me.isValid, initialValue = "initialValue" in me ? me.initialValue : me.valueOnFocus, valueChanged = me.hasChanged(initialValue, value), { needsInputSync } = me;
        if (me.revertOnEscape && (!wasValid || valueChanged || needsInputSync)) {
          if (valueChanged) {
            me.value = initialValue;
          }
          if (needsInputSync) {
            me.syncInputFieldValue(true);
          }
          me.clearError();
          stopEvent = (valueChanged || needsInputSync) && me.isValid || wasValid !== me.validOnFocus;
        }
      }
    }
    if (!me.isDestroyed) {
      if (stopEvent) {
        event.stopImmediatePropagation();
      }
      me.trigger(event.type, { event });
    }
  }
  /**
   * Clears the value of this Field, and triggers the {@link #event-clear} event.
   */
  clear(event) {
    const me = this, { value } = me;
    if (value !== me.nullValue || me.input.value.length > 0) {
      me.value = me.nullValue;
      me.clearError();
      me.syncInvalid();
      me.trigger("clear", { event });
    }
  }
  /**
   * Called when disabled state is changed.
   * Used to add or remove 'b-invalid' class for the invalid field based on current disabled state.
   * @private
   */
  onDisabled() {
    this.syncInvalid();
  }
  //endregion
  //region Error
  syncRequired() {
    var _a2;
    const me = this;
    if (!me.isConfiguring && !me.focusing && me.required && me.isEmpty && !((_a2 = me.parent) == null ? void 0 : _a2.isSettingValues)) {
      me.setError("L{fieldRequired}", me.updatingInvalid);
    } else {
      me.clearError("L{fieldRequired}", me.updatingInvalid);
    }
  }
  /**
   * Adds an error message to the list of errors on this field.
   * By default, the field's valid/invalid state is updated; pass
   * `false` as the second parameter to disable that if multiple
   * changes are being made to the error state.
   *
   * Note, that you need to manually remove the added error with the {@link #function-clearError} method
   * to "release" the normal data update process (invalid data won't be synced). You can also use the 3rd
   * argument of this method to automatically remove the error upon the next user interaction.
   *
   * @param {String} error A locale string, or message to use as an error message.
   * @param {Boolean} [silent=false] Pass as `true` to skip updating the field's valid/invalid state.
   * @param {Boolean} [temporary=false] Pass as `true` to remove the error upon the next user interaction.
   */
  setError(error, silent, temporary) {
    const me = this;
    (me.errors || (me.errors = {}))[me.optionalL(error)] = 1;
    if (!silent) {
      me.syncInvalid();
    }
    if (temporary) {
      const clearError = () => {
        me.clearError(error);
        remover();
      }, remover = me.ion({
        keydown: clearError,
        focusOut: clearError
      });
    }
  }
  /**
   * Removes an error message from the list of errors on this field.
   *
   * By default, the field's valid/invalid state is updated; pass `false` as the second parameter to disable that if
   * multiple changes are being made to the error state.
   *
   * @param {String} [error] A locale string, or message to remove. If not passed, all errors are cleared.
   * @param {Boolean} [silent=false] Pass as `true` to skip updating the field's valid/invalid state.
   */
  clearError(error, silent) {
    const me = this;
    if (me.errors) {
      if (error) {
        delete this.errors[this.optionalL(error)];
      } else {
        me.errors = {};
      }
    }
    if (!silent) {
      me.syncInvalid();
    }
  }
  /**
   * Returns an array of error messages as set by {@link #function-setError}, or
   * `undefined` if there are currently no errors.
   * @returns {String[]} The errors for this field, or `undefined` if there are no errors.
   */
  getErrors() {
    const me = this;
    if (!me.isValid) {
      const validity = me.validity, stateName = ObjectHelper.keys(validity).find((key) => key !== "valid" && key !== "customError" && validity[key]), errorKeys = me.errors && Object.keys(me.errors);
      let errors;
      if (errorKeys == null ? void 0 : errorKeys.length) {
        errors = errorKeys;
      } else if (validity.customError) {
        errors = [me.input.validationMessage];
      } else if (stateName) {
        errors = [me.L(stateName, {
          // In case min/max limits are present they will be used in the translation
          min: me.min,
          max: me.max
        })];
      } else {
        errors = [me.L(me.invalidValueError)];
      }
      if ((errors == null ? void 0 : errors.length) > 0) {
        return errors;
      }
    }
  }
  //endregion
  createOverflowTwin(overrides) {
    const me = this, overflowTwin = super.createOverflowTwin(overrides);
    overflowTwin.ion({
      change({ value }) {
        me._overflowTwinSync = true;
        me.value = value;
        me._overflowTwinSync = false;
      }
    });
    return overflowTwin;
  }
  //region Container
  get containerCollapsed() {
    var _a2;
    return (_a2 = this.container) == null ? void 0 : _a2.collapsed;
  }
  set containerCollapsed(collapsed) {
    const { container } = this;
    if (container) {
      container.collapsed = collapsed;
    }
  }
  afterSyncChildConfigs(container) {
  }
  changeContainer(config, existing) {
    if (config && (Array.isArray(config) || !("type" in config || "items" in config))) {
      config = {
        items: config
      };
    }
    const me = this, defaults = config && ObjectHelper.merge({
      owner: me,
      layout: "box"
    }, me.containerDefaults), container = Widget.reconfigure(existing, config, {
      owner: me,
      defaults
    });
    if (container) {
      container.autoLayout = (defaults == null ? void 0 : defaults.layout) === "box";
      if (container === existing) {
        container.syncContainer();
        return;
      }
    }
    return container;
  }
  onConfigChange(info) {
    var _a2, _b;
    super.onConfigChange(info);
    if ((_b = (_a2 = this.container) == null ? void 0 : _a2.syncConfigTriggers) == null ? void 0 : _b[info.name]) {
      this.container.syncChildConfigs();
    }
  }
  assignValue(values, options) {
    const me = this, { container, containValues } = me, valueName = me.getValueName(options), storedValue = values && valueName in values;
    if (container && containValues !== false) {
      if (values && containValues === "nested") {
        if (storedValue) {
          values = ObjectHelper.clone(values[valueName]);
          super.assignValue({
            // Removing 'value:true' from nested values is a trick done by checkbox (could be done by
            // any toggle-like thing) so just put true back in:
            [valueName]: values && !("value" in values) || values.value
          }, options);
          if (values) {
            delete values.value;
          }
          container.assignValue(values, options);
        }
      } else {
        super.assignValue(values, options);
        container.assignValue(values, options);
      }
    } else {
      super.assignValue(values, options);
    }
  }
  gatherValue(values) {
    super.gatherValue(values);
    this.gatherValues(values);
  }
  gatherValues(values, storedValue) {
    const me = this, { container, containValues, valueName } = me, cvt = typeof containValues;
    storedValue = storedValue != null ? storedValue : valueName in values;
    if (container && containValues !== false) {
      if (containValues === "nested") {
        if (storedValue) {
          values[valueName] = {
            value: values[valueName],
            ...container.values
          };
        }
      } else if (containValues === true || containValues == null && storedValue || cvt === "string" && me[containValues] || cvt === "function" && containValues(me)) {
        container.gatherValues(values);
      }
    }
  }
  updateContainer(container, was) {
    was && this.detachListeners(was.id);
    if (container) {
      if (!container.rendered) {
        container.render();
      }
      container.syncContainer();
      container.syncChildConfigs();
    }
  }
  //endregion
};
//region Config
__publicField(_Field, "$name", "Field");
__publicField(_Field, "type", "field");
var Field = _Field;
Field.Trigger = class FieldTrigger extends Widget {
  static get $name() {
    return "FieldTrigger";
  }
  static get factoryable() {
    return {
      defaultType: Field.Trigger,
      extends: null
    };
  }
  // Factoryable type name
  static get type() {
    return "trigger";
  }
  // Align is a simple string at this level
  static get configurable() {
    return {
      align: null,
      weight: null,
      role: void 0
    };
  }
  get field() {
    return this.parent;
  }
  construct() {
    super.construct(...arguments);
    if (this.key) {
      this.keyMap = {
        [this.key]: "onClick"
      };
    }
  }
  compose() {
    return {
      "aria-hidden": true,
      class: {
        [`b-align-${this.align || "end"}`]: 1,
        "b-icon": 1
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: "onClick",
        mousedown: "onMousedown"
      }
    };
  }
  changeAlign(align) {
    return align;
  }
  onClick(e) {
    const me = this, { field } = me;
    if (!(field.disabled || field.readOnly)) {
      if (e.key) {
        e.preventDefault();
      }
      if (field.trigger("trigger", { trigger: me }) !== false && me.handler) {
        field.callback(me.handler, field, [e, me]);
      }
    }
  }
  onMousedown(e) {
    const field = this.field, isKeyEvent = "key" in e;
    if (!isKeyEvent && DomHelper.isTouchEvent) {
      if (field.editable) {
        field.editable = false;
        field.setTimeout(() => field.editable = true, 500);
      }
    }
    e.preventDefault();
    if (DomHelper.getActiveElement(field.input) !== field.input) {
      field.focus();
    }
  }
};
Field.SpinTrigger = class SpinTrigger extends Field.Trigger {
  static get $name() {
    return "SpinTrigger";
  }
  // Factoryable type name
  static get type() {
    return "spintrigger";
  }
  static get configurable() {
    return {
      repeat: {
        $config: ["nullify"],
        value: true
      }
    };
  }
  compose() {
    return {
      children: {
        upButton: {
          class: {
            "b-icon": 1,
            "b-spin-up": 1
          }
        },
        downButton: {
          class: {
            "b-icon": 1,
            "b-spin-down": 1
          }
        }
      }
    };
  }
  updateRepeat(repeat) {
    var _a2;
    (_a2 = this.clickRepeater) == null ? void 0 : _a2.destroy();
    this.clickRepeater = repeat ? ClickRepeater.new({
      element: this.element
    }, repeat) : null;
  }
  onClick(e) {
    const me = this, { field } = me;
    if (!(field.disabled || field.readOnly)) {
      if (e.target === me.upButton) {
        field.doSpinUp(e.shiftKey);
      } else if (e.target === me.downButton) {
        field.doSpinDown(e.shiftKey);
      }
    }
  }
};
Field.Trigger.initClass();
Field.SpinTrigger.initClass();
Widget.register(Field.Trigger, "trigger");
Widget.register(Field.SpinTrigger, "spintrigger");
Field._$name = "Field";

// ../Core/lib/Core/widget/TextField.js
var TextField = class extends Field {
  static get configurable() {
    return {
      /**
       * The tab index of the input field
       * @config {Number} tabIndex
       * @category Input element
       */
      /**
       * The min number of characters for the input field
       * @config {Number} minLength
       * @category Field
       */
      /**
       * The max number of characters for the input field
       * @config {Number} maxLength
       * @category Field
       */
      nullValue: ""
    };
  }
  construct(config) {
    if ((config == null ? void 0 : config.inputType) === "hidden") {
      config.hidden = true;
    }
    super.construct(...arguments);
  }
};
__publicField(TextField, "$name", "TextField");
__publicField(TextField, "type", "textfield");
__publicField(TextField, "alias", "text");
TextField.initClass();
TextField._$name = "TextField";

// ../Core/lib/Core/widget/PickerField.js
var PickerField = class extends TextField {
  static get configurable() {
    return {
      /**
       * User can edit text in text field (otherwise only pick from attached picker)
       * @config {Boolean}
       * @default
       */
      editable: true,
      /**
       * The name of the element property to which the picker should size and align itself.
       * @config {String}
       * @default element
       */
      pickerAlignElement: "inputWrap",
      // Does not get set, but prevents PickerFields inheriting value:'' from Field.
      value: null,
      triggers: {
        expand: {
          cls: "bars"
        }
      },
      /**
       * By default PickerField's picker is transient, and will {@link #function-hidePicker} when the user clicks or
       * taps outside or when focus moves outside picker.
       *
       * Configure as `false` to make picker non-transient.
       * @config {Boolean}
       * @default
       * @deprecated This will be removed in 6.0
       */
      autoClose: true,
      /**
       * Configure as `true` to have the picker expand upon focus enter.
       * @config {Boolean}
       */
      autoExpand: null,
      /**
       * Configuration object for the {@link Core.widget.List picker} on initialization. Returns the
       * {@link Core.widget.List picker} instance at runtime.
       * A config object which is merged into the generated picker configuration on initialization
       * to allow specific use cases to override behaviour.
       * For example:
       *
       * ```javascript
       *     picker: {
       *         align: {
       *             anchor: true
       *         }
       *     }
       * ```
       *
       * Returns the picker instance at runtime.
       *
       * @prp {Core.widget.Widget}
       * @accepts {Object}
       * @readonly
       */
      picker: {
        value: {
          floating: true
        },
        $config: ["lazy", "nullify"]
      },
      inputType: "text",
      // We need to realign the picker if we resize (eg a multiSelect Combo's ChipView wrapping)
      monitorResize: true,
      nullValue: null
    };
  }
  //endregion
  //region Init & destroy
  doDestroy() {
    var _a2;
    (_a2 = this.globalTapListener) == null ? void 0 : _a2.call(this);
    super.doDestroy();
  }
  changeEditable(editable) {
    if (BrowserHelper.isMobile && this.initialConfig.editable !== true) {
      editable = false;
    }
    return editable;
  }
  updateAutoClose(autoClose) {
    !autoClose && VersionHelper.deprecate("Core", "6.0.0", "PickerField.autoClose is no longer supported");
  }
  updateEditable(editable) {
    var _a2;
    const me = this, {
      element,
      ariaElement,
      nonEditableClickTarget
    } = me, { expand } = me.triggers, narrow = globalThis.matchMedia("(max-width: 410px)").matches;
    super.updateEditable(...arguments);
    element.classList.toggle("b-not-editable", !editable);
    if (editable === false) {
      if (BrowserHelper.isMobile && narrow) {
        expand == null ? void 0 : expand.hide();
      }
      ariaElement.removeAttribute("aria-autocomplete");
      (_a2 = me.globalTapListener) == null ? void 0 : _a2.call(me);
      EventHelper.on({
        element: nonEditableClickTarget,
        click: (e) => {
          const target = nonEditableClickTarget.getRootNode().elementFromPoint(e.clientX, e.clientY);
          if (e.target === nonEditableClickTarget && target === nonEditableClickTarget) {
            me.onTriggerClick(e);
          }
        },
        thisObj: me
      });
    } else {
      expand == null ? void 0 : expand.show();
      ariaElement.setAttribute("aria-autocomplete", "list");
      me.globalTapListener = GlobalEvents_default.ion({
        globaltap: "showKeyboard",
        thisObj: me
      });
    }
  }
  get nonEditableClickTarget() {
    return this.input;
  }
  updateElement(element, oldElement) {
    var _a2;
    const result = super.updateElement(element, oldElement), picker = this.peekConfig("picker"), role = picker ? picker.isWidget ? picker.role : (_a2 = this.constructor.resolveType(picker.type)) == null ? void 0 : _a2.$meta.config.role : false;
    DomHelper.setAttributes(this.ariaElement, {
      "aria-expanded": false
    });
    this.ariaHasPopup = role;
    return result;
  }
  //endregion
  //region Picker
  changePicker(picker, oldPicker) {
    throw new Error("changePicker(oldPicker, newPicker) must be implemented in PickerField subclass implementations");
  }
  /**
   * Iterate over all widgets owned by this widget and any descendants.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   *
   * _Due to the {@link #config-picker} config being a lazy config and only being converted to be a
   * `List` instance just before it's shown, the picker will not be part of the iteration before
   * it has been shown once_.
   * @function eachWidget
   * @param {Function} fn A function to execute upon all descendant widgets.
   * Iteration terminates if this function returns `false`.
   * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   */
  get childItems() {
    const result = super.childItems;
    if (this._picker) {
      result.push(this.picker);
    }
    return result;
  }
  //endregion
  //region Events
  /**
   * Check if field value is valid
   * @internal
   */
  onEditComplete() {
    super.onEditComplete();
    this.autoClosePicker();
  }
  onElementResize(resizedElement) {
    const me = this;
    if (me.pickerVisible) {
      me.picker.requestAnimationFrame(me.picker.realign, null, me.picker);
    }
    super.onElementResize(resizedElement);
  }
  /**
   * Allows using arrow keys to open/close list. Relays other keypresses to list if open.
   * @private
   */
  internalOnKeyEvent(event) {
    const me = this;
    let callSuper = true;
    if (event.type === "keydown" && !me.disabled && !event.shiftKey && !event.ctrlKey) {
      if (me.pickerVisible) {
        const { picker } = me;
        if (event.key === "Escape") {
          event.preventDefault();
          event.stopImmediatePropagation();
          me.hidePicker();
          callSuper = false;
        } else if (picker.onInternalKeyDown) {
          picker.onInternalKeyDown(event);
        } else if (event.key === "ArrowDown") {
          if (picker.focusable) {
            picker.focus();
          }
        }
      } else if (event.key === "ArrowDown") {
        event.stopImmediatePropagation();
        event.preventDefault();
        me.onTriggerClick(event);
      }
    }
    if (callSuper) {
      super.internalOnKeyEvent(event);
    }
  }
  onFocusIn(e) {
    const me = this;
    super.onFocusIn(e);
    if (me.autoExpand) {
      me.minChars = 0;
      me.onTriggerClick(e);
      me.ignoreTriggerClick = true;
      me.setTimeout(() => me.ignoreTriggerClick = false, 100);
    }
  }
  /**
   * User clicked trigger icon, toggle list.
   * @private
   */
  onTriggerClick(event) {
    if (!this.disabled) {
      this.togglePicker("key" in event);
    }
  }
  /**
   * User clicked on an editable input field. If it's a touch event
   * ensure that the keyboard is shown.
   * @private
   */
  showKeyboard({ event }) {
    const input = this.input;
    if (DomHelper.isTouchEvent && DomHelper.getActiveElement(input) === input && event.target === input) {
      GlobalEvents_default.suspendFocusEvents();
      input.blur();
      input.focus();
      GlobalEvents_default.resumeFocusEvents();
    }
  }
  //endregion
  //region Toggle picker
  /**
   * Toggle the {@link #property-picker} visibility
   * @privateparam {Boolean} [focus] Pass `true` to focus the picker when it gets shown.
   */
  togglePicker(focus) {
    if (this.pickerVisible) {
      this.hidePicker();
    } else {
      this.showPicker(focus);
    }
  }
  /**
   * Show the {@link #property-picker}
   * @privateparam {Boolean} [focus] Pass `true` to focus the picker when it gets shown.
   */
  showPicker(focus) {
    const me = this, { picker } = me;
    if (!me.pickerHideShowListenersAdded) {
      picker.ion({
        show: "onPickerShow",
        hide: "onPickerHide",
        thisObj: me
      });
      me.pickerHideShowListenersAdded = true;
    }
    DomHelper.setAttributes(me.ariaElement, {
      "aria-controls": picker.id,
      "aria-expanded": true
    });
    picker.autoClose = me.autoClose;
    picker.show();
    if (picker.isVisible) {
      if (focus) {
        me.focusPicker();
      }
    }
  }
  onPickerShow() {
    const me = this;
    me.pickerVisible = true;
    me.element.classList.add("b-open");
    me.trigger("togglePicker", { show: true });
    me.pickerTapOutRemover = GlobalEvents_default.ion({
      globaltap: "onPickerTapOut",
      thisObj: me
    });
    me.pickerKeyDownRemover = EventHelper.on({
      element: me.picker.element,
      keydown: "onPickerKeyDown",
      thisObj: me
    });
  }
  onPickerHide() {
    var _a2, _b;
    const me = this;
    me.ariaElement.setAttribute("aria-expanded", false);
    me.pickerVisible = false;
    me.element.classList.remove("b-open");
    me.trigger("togglePicker", { show: false });
    (_a2 = me.pickerTapOutRemover) == null ? void 0 : _a2.call(me);
    (_b = me.pickerKeyDownRemover) == null ? void 0 : _b.call(me);
  }
  onPickerTapOut({ event }) {
    if (!this.containsFocus && !this.owns(event.target)) {
      this.autoClosePicker();
    }
  }
  onPickerKeyDown(event) {
    if (event.key === "Tab" && !this.picker.trapFocus) {
      const activeEl = DomHelper.getActiveElement(this.input), forwardedEvent = new KeyboardEvent("keydown", event);
      this.input.dispatchEvent(forwardedEvent);
      if (forwardedEvent.defaultPrevented) {
        event.preventDefault();
      }
      if (DomHelper.getActiveElement(this.input) === activeEl) {
        this.input.focus();
      } else {
        event.preventDefault();
      }
      if (!this.isDestroyed) {
        this.hidePicker();
      }
    }
  }
  //endregion
  //region Visibility
  autoClosePicker() {
    if (this.autoClose) {
      this.hidePicker();
    }
  }
  /**
   * Hide picker
   */
  hidePicker() {
    if (this.pickerVisible) {
      this.picker.hide();
    }
  }
  focusPicker() {
  }
  focus() {
    const input = this.input;
    if (DomHelper.isTouchEvent && this.editable) {
      input.readOnly = true;
      this.setTimeout(() => input.readOnly = false, 500);
    }
    super.focus();
  }
  //endregion
};
//region Config
__publicField(PickerField, "$name", "PickerField");
__publicField(PickerField, "type", "pickerfield");
PickerField._$name = "PickerField";

// ../Core/lib/Core/widget/List.js
var itemRange = document.createRange();
var List = class extends Widget {
  static get configurable() {
    return {
      itemCls: "b-list-item",
      selectedCls: "b-selected",
      selectIconCls: "b-icon-check",
      tag: "ul",
      /**
       * An array of Objects which are converted into records and used to create this
       * List's {@link #config-store}
       * @config {Object[]}
       */
      items: null,
      /**
       * The model field to render into each list item
       * @config {String}
       * @default
       */
      displayField: "text",
      /**
       * A {@link Core.data.Store} which provides the records which map to List items. Each record is passed through the
       * {@link #config-itemTpl} to produce the DOM structure of the List. May be generated from an array of {@link #config-items}.
       *
       * The store may also be configured as an array of records, or record data objects from which records may be constructed.
       * @config {Object|Object[]|Core.data.Store}
       */
      store: null,
      navigator: true,
      scrollable: {
        overflowX: false,
        overflowY: true
      },
      itemsFocusable: true,
      /**
       * Configure as `true` to allow multi select and add checkboxes to the items
       * @prp {Boolean}
       * @default
       */
      multiSelect: false,
      /**
       * Select/deselect all if `CMD`/`CTRL` is pressed when clicking
       * @prp {Boolean}
       * @default false
       */
      toggleAllIfCtrlPressed: false,
      /**
       * True to add a collapse icon to toggle groups being collapsed or expanded
       * @prp {Boolean}
       * @default false
       */
      collapsibleGroups: false,
      /**
       * Set to `true` to add a "Select all" item to the list to select/unselect all items at once.
       * Only applies when {@link #config-multiSelect} mode is enabled.
       * @config {Boolean|String}
       * @default false
       */
      selectAllItem: false,
      /**
       * Template function which, when passed a record, returns the textual HTML for that item. Defaults to a
       * function returning the value of the record´s {@link #config-displayField}
       *
       * @config {Function}
       * @param {Core.data.Model} record The record
       * @returns {String}
       */
      itemTpl(record) {
        let text = StringHelper.encodeHtml(record.getValue(this.displayField));
        if (text == null || text === "") {
          text = "&nbsp;";
        }
        return text;
      },
      /**
       * Configure this as a function or the name of a function, which when passed a record in the
       * list, returns a style string to apply to its list item.
       *
       * @config {Function|String} getItemStyle
       * @param {Core.data.Model} record The record
       * @returns {String}
       */
      getItemStyle: null,
      /**
       * Configure this as a function or the name of a function, which when passed a record in the
       * list, returns a CSS class name string to apply to its list item.
       *
       * @config {Function|String} getItemCls
       * @param {Core.data.Model} record The record
       * @returns {String}
       */
      getItemCls: null,
      /**
       * Template function which is passed a group record and the uppercased group field name. The text returned
       * will be rendered as the group header.
       *
       * @config {Function}
       * @param {Core.data.Model} record The record
       * @param {String} groupName The current group name
       * @returns {String}
       */
      groupHeaderTpl(record, groupName) {
        let name = StringHelper.encodeHtml(groupName);
        if (name == null || name === "") {
          name = "&nbsp;";
        }
        return `${this.allowGroupSelect ? this.itemIconTpl(record) : ""}${name}`;
      },
      /**
       * Configure as `true` to allow selecting groups (all the group child records will be toggled). Only
       * applicable when the store is grouped.
       * @config {Boolean}
       * @default
       */
      allowGroupSelect: true,
      /**
       * Configure as `true` to clear selection when clicking on empty space inside the List´s element.
       * @config {Boolean}
       * @default false
       */
      clearSelectionOnEmptySpaceClick: false,
      /**
       * A {@link Core.util.Collection}, or Collection config object to use to contain this List's selected
       * records.
       *
       * Or, an array encapsulating the initial selection which this List is to have upon Store load. This may be
       * an array of `id`s , or an array of objects with an `id` property:
       *
       * ```javascript
       * new List({
       *     // initially select record IDs 1 and 5 when store loads
       *     selected : [1, 5]
       * });
       * ```
       * @config {Object[]|Number[]|String[]|Core.util.Collection|CollectionConfig}
       */
      selected: {
        $config: ["nullify", "lazy"],
        value: []
      },
      /**
       * Configure as `true` to activate items on mouseover. This is used by the Combo
       * field when using a List as its dropdown.
       * @config {Boolean}
       */
      activateOnMouseover: null,
      role: "listbox",
      keyMap: {
        "Ctrl+a": "selectAll"
      }
    };
  }
  //endregion
  //region Events
  /**
   * User activated an item in the list either by pointer or keyboard.
   * The active record, list item index, and the triggering event are passed.
   * @event item
   * @param {Core.widget.List} source The List instance
   * @param {Core.data.Model} record Activated record
   * @param {Number} index List item index
   * @param {Event} event Triggering event
   */
  /**
   * User going to activate an item in the list either by pointer or keyboard.
   * The active record, list item index, and the triggering event are passed.
   * It is preventable by returning `false`
   * @event beforeItem
   * @preventable
   * @param {Core.widget.List} source The List instance
   * @param {Core.data.Model} record Activated record
   * @param {Number} args List item index
   * @param {Event} event Triggering event
   */
  /**
   * Fired when selection changes
   * @event selectionChange
   * @param {Core.widget.List} source The List instance
   * @param {Core.data.Model[]} selected An array of the currently selected records
   */
  //endregion
  construct(config, ...args) {
    var _a2;
    const me = this;
    if (Array.isArray(config)) {
      config = {
        items: config
      };
    }
    super.construct(config, ...args);
    const { element } = me, { classList } = element;
    if (me.multiSelect) {
      classList.add("b-multiselect");
    }
    if ((_a2 = me.store) == null ? void 0 : _a2.count) {
      me.refresh();
    } else {
      classList.add("b-empty");
    }
    EventHelper.on({
      element,
      delegate: me.itemSelector,
      mouseover: "onMouseOver",
      thisObj: me
    });
    EventHelper.on({
      element,
      click: "onClick",
      thisObj: me
    });
  }
  doDestroy() {
    var _a2;
    this.detachListeners("store");
    (_a2 = this.navigator) == null ? void 0 : _a2.destroy();
    super.doDestroy();
  }
  onFocusIn(e) {
    var _a2;
    this.restoreActiveItem((_a2 = e._target) == null ? void 0 : _a2.closest(this.itemSelector));
    super.onFocusIn(e);
  }
  contentTpl() {
    const me = this, allRecordsTpl = me.store.records.map((record, i) => me.itemWrapperTpl(record, i));
    if (me.multiSelect && me.selectAllItem !== false) {
      allRecordsTpl.unshift(me.selectAllItemTpl());
    }
    return TemplateHelper.tpl`${allRecordsTpl}`;
  }
  itemWrapperTpl(record, i) {
    const {
      selected,
      getItemStyle,
      store
    } = this, style = getItemStyle ? `style="${this.callback(getItemStyle, this, [record])}"` : "";
    if (store.isGrouped && !record.isGroupHeader) {
      const groupRecord = record.groupParent.get(store.id);
      if (groupRecord.meta.collapsed) {
        return "";
      }
    }
    return TemplateHelper.tpl`<li ${style} class="${this.getItemClasses(record, i)}" role="option" aria-selected="${selected.includes(record)}" data-index="${i}" data-id="${StringHelper.encodeHtml(record.id)}" ${this.itemsFocusable ? 'tabindex="-1"' : ""}>${this.itemContentTpl(record, i)}</li>`;
  }
  itemContentTpl(record, i) {
    if (record.isGroupHeader) {
      let result = this.groupHeaderTpl(record, StringHelper.capitalize(record.meta.groupRowFor));
      if (this.collapsibleGroups) {
        const arrowDirection = record.meta.collapsed ? "right" : "down";
        result += `<button class="b-button b-tool b-icon b-icon-collapse-${arrowDirection} b-list-expander-icon" data-noselect></button>`;
      }
      return result;
    }
    return `${this.itemIconTpl(record, i)}${this.itemTpl(record, i)}`;
  }
  itemIconTpl(record, i) {
    return this.multiSelect ? `<i class="b-selected-icon b-icon ${this.selectIconCls}"></i>` : "";
  }
  selectAllItemTpl() {
    const selectedCls = this.allSelected ? "b-selected" : "";
    return `<li class="${this.itemCls} b-select-all-item ${selectedCls}" data-noselect data-select-all data-id="select-all">${this.itemIconTpl({})}<div>${this.L("selectAll")}</div></li>`;
  }
  getItemClasses(record) {
    var _a2;
    const me = this, { getItemCls } = me, activeItem = (_a2 = me._navigator) == null ? void 0 : _a2.activeItem, isActive = (activeItem == null ? void 0 : activeItem.dataset.id) == record.id, groupHeaderCls = "groupRowFor" in record.meta ? "b-list-item-group-header" : "", isSelected = me.selected.includes(record) || record.isSpecialRow && record.groupChildren.every((r) => me.selected.includes(r)), itemCls = getItemCls ? this.callback(getItemCls, this, [record]) : "";
    return `${me.itemCls} ${record.cls || ""} ${itemCls} ${isSelected ? me.selectedCls : ""} ${isActive ? me.navigator.focusCls : ""} ${groupHeaderCls}`;
  }
  onBeforeStoreLoad() {
    this.mask(this.L("L{loading}"));
  }
  onAfterStoreRequest() {
    this.unmask();
  }
  onStoreChange({ source: store, action, records, record, changes }) {
    const me = this, { selected } = me;
    switch (action) {
      case "dataset": {
        selected.match(store.storage, !me._externallyOwnedSelection);
        break;
      }
      case "remove":
        selected.remove(records);
        break;
      case "clear":
        me.deselectAll();
        break;
      case "update": {
        const { id } = changes;
        if (id) {
          DomHelper.setAttributes(
            me.contentElement.querySelector(StringHelper.encodeAttributeSelector(`data-id`, id.oldValue)),
            {
              "data-id": id.value
            }
          );
        }
        me.refreshItem(record);
        return;
      }
    }
    me.refresh();
  }
  onStoreRefresh() {
    if (this._selected) {
      this.refresh();
    } else {
      this.getConfig("selected");
    }
  }
  refresh() {
    var _a2;
    const me = this;
    if (me.isVisible && me.store) {
      const activeItem = (_a2 = me.navigator) == null ? void 0 : _a2.activeItem;
      me.paintListener = null;
      const node = DomHelper.createElementFromTemplate(me.contentTpl(), { fragment: true });
      me.clearItems().insertNode(node);
      if (activeItem) {
        me.restoreActiveItem(activeItem);
      }
      me.refreshCount = (me.refreshCount || 0) + 1;
      me.element.classList[me.store.count > 0 ? "remove" : "add"]("b-empty");
      me.updateSelectAllState();
    } else if (!me.paintListener) {
      me.paintListener = me.ion({
        paint: "refresh",
        thisObj: me,
        once: true
      });
    }
  }
  clearItems() {
    const me = this, firstItem = me.contentElement.querySelector(me.itemSelector), lastChild = me.contentElement.lastChild;
    if (firstItem) {
      const items = me.contentElement.querySelectorAll(`${me.itemSelector}:not(.b-mask)`);
      itemRange.setStartBefore(firstItem);
      itemRange.setEndAfter(items[items.length - 1]);
      itemRange.deleteContents();
    } else {
      if (lastChild) {
        itemRange.setStartAfter(lastChild);
        itemRange.setEndAfter(lastChild);
      } else {
        itemRange.setStart(me.contentElement, 0);
        itemRange.setEnd(me.contentElement, 0);
      }
    }
    return itemRange;
  }
  refreshItem(...records) {
    for (const record of records) {
      const item = this.getItem(record);
      if (item) {
        const index = this.store.indexOf(record), newItem = DomHelper.createElementFromTemplate(this.itemWrapperTpl(record, index));
        DomHelper.sync(newItem, item);
      }
    }
  }
  getItem(recordOrId) {
    if (recordOrId != null) {
      if (typeof recordOrId === "number") {
        return this.contentElement.querySelector(`[data-index="${recordOrId < 0 ? this.store.count + recordOrId : recordOrId}"]`);
      } else if (recordOrId.nodeType === Element.ELEMENT_NODE) {
        recordOrId = recordOrId.dataset.id;
      }
      if ((recordOrId == null ? void 0 : recordOrId.id) != null) {
        recordOrId = recordOrId.id;
      }
      return this.contentElement.querySelector(StringHelper.encodeAttributeSelector(`data-id`, recordOrId));
    }
  }
  /**
   * Searches up from the specified element for a list item and returns the associated record.
   * @param {HTMLElement} element Element somewhere within a list item element
   * @returns {Core.data.Model} Record for the item
   */
  getRecordFromElement(element) {
    if (element.target) {
      element = element.target;
    }
    element = element.closest(this.itemSelector);
    return this.store.getAt(parseInt(element.dataset.index));
  }
  //region getters/setters
  /**
   * May be *set* as an array of Objects which are converted into records and used to create this
   * List's {@link #config-store}
   * @member {Object[]} items
   */
  updateItems(items) {
    var _a2;
    const me = this, newStore = Store.getStore(ArrayHelper.asArray(items));
    if ((_a2 = me.store) == null ? void 0 : _a2.autoCreated) {
      me.store.data = (newStore == null ? void 0 : newStore.records) || [];
    } else {
      me.store = newStore;
    }
  }
  updateDisabled(disabled) {
    super.updateDisabled(...arguments);
    this.navigator && (this.navigator.disabled = disabled);
  }
  changeSelected(selected, oldSelected) {
    const me = this, internalListeners = {
      change: "onInternalSelectionChange",
      thisObj: me
    };
    oldSelected == null ? void 0 : oldSelected.un(internalListeners);
    if (selected) {
      if (selected.isCollection) {
        me._externallyOwnedSelection = true;
        selected.ion(internalListeners);
      } else {
        me._externallyOwnedSelection = false;
        selected = ArrayHelper.asArray(selected).reduce((r, s) => {
          s = s.isModel ? s : me.store.getById(s);
          if (s) {
            r.push(s);
          }
          return r;
        }, []);
        if (oldSelected) {
          oldSelected.splice(0, oldSelected.count, selected);
          selected = oldSelected;
          me.refresh();
        } else {
          const records = selected;
          selected = me._selected = new Collection({
            internalListeners
          });
          selected.add(records);
        }
      }
    } else {
      oldSelected == null ? void 0 : oldSelected.destroy();
    }
    return selected;
  }
  updateSelected(selected) {
    if (selected) {
      this.refresh();
    }
  }
  get itemSelector() {
    return `.${this.itemCls}`;
  }
  /**
   * Gets/sets the collection of selected records.
   *
   * When used as a setter, a record, or record `id` or array of same may be passed to
   * set the selected records.
   * @property {Core.util.Collection}
   * @accepts {Core.data.Model|Core.data.Model[]|String|String[]|Number|Number[]}
   */
  get selected() {
    return this._selected;
  }
  updateMultiSelect(value, old) {
    if (!value && old && this.selected.count > 1) {
      this.deselect(this.selected.allValues.slice(1));
    }
  }
  /**
   * Get the backing store, a {@link Core.data.Store} holding the records used to generate list items
   * @property {Core.data.Store}
   * @readonly
   */
  get store() {
    this.getConfig("items");
    return this._store;
  }
  changeStore(store) {
    const me = this;
    if (!(store instanceof Store)) {
      if (Array.isArray(store)) {
        store = {
          data: store
        };
      }
      store = new Store(store);
    }
    me.detachListeners("store");
    if (store) {
      const storeListeners = {
        name: "store",
        change: "onStoreChange",
        refresh: "onStoreRefresh",
        thisObj: me
      };
      if (store.readUrl) {
        storeListeners.beforeLoad = "onBeforeStoreLoad";
        storeListeners.afterRequest = "onAfterStoreRequest";
      }
      if (store.isGrouped) {
        me.element.classList.add("b-grouped");
        storeListeners.groupchange = "onStoreRefresh";
      }
      store.ion(storeListeners);
    }
    return store;
  }
  updateStore(store) {
    if (store == null ? void 0 : store.records.length) {
      this.getConfig("selected");
    }
    if (!this.refreshCount) {
      this.refresh();
    }
  }
  changeNavigator(navigator2, oldNavigator) {
    const me = this, { element } = me;
    if (element) {
      navigator2 = Navigator.reconfigure(oldNavigator, navigator2 ? Navigator.mergeConfigs({
        ownerCmp: me,
        disabled: me.disabled,
        target: element,
        keyEventTarget: element
      }, navigator2) : null, me);
      if ((navigator2 == null ? void 0 : navigator2.keyEventTarget) === element && !me.itemsTabbable) {
        element.tabIndex = 0;
      }
    }
    return navigator2;
  }
  get minAlignHeight() {
    const lastItem = this.element.lastElementChild, minHeight = this.minHeight;
    if (minHeight != null) {
      return lastItem ? Math.min(lastItem.offsetTop + lastItem.offsetHeight, minHeight) : 0;
    }
  }
  //endregion
  //region Hide/Show
  alignTo(...args) {
    super.minHeight = this.minAlignHeight;
    super.alignTo(...args);
  }
  hide(...args) {
    this.navigator && (this.navigator.activeItem = null);
    return super.hide(...args);
  }
  show() {
    const { refreshCount } = this, { previousActiveItem } = this.navigator;
    super.minHeight = this._minHeight;
    const retVal = super.show(...arguments);
    if (this.refreshCount === refreshCount) {
      this.restoreActiveItem(previousActiveItem, true);
    }
    return retVal;
  }
  /**
   * Sets the passed record as the current focused record for keyboard navigation and selection purposes.
   * @param {Core.data.Model} activeItem The item to highlight as the active ("focused") item.
   * @param {String|Boolean} [block='nearest'] The block scroll specification to scroll
   * the item into view. Defaults to `'nearest'` which means a minimal scroll, only if
   * the item is actually out of view. Passing `true` is for when the List is aligned
   * to a picker and the selected item should be scrolled to be close to the picker,
   * however that is aligned. See `Combo.showPicker` for usage.
   * @internal
   */
  restoreActiveItem(activeItem = this.navigator.previousActiveItem, block = "nearest") {
    const me = this, { navigator: navigator2, lastAlignSpec } = me;
    if (activeItem != null) {
      if (typeof block !== "string") {
        const alignZone = lastAlignSpec ? lastAlignSpec.zone : 1;
        block = alignZone & 1 ? "nearest" : alignZone ? "start" : "end";
      }
      activeItem = me.getItem(activeItem);
      if (activeItem && !me.disabled) {
        me.scrollable.scrollIntoView(activeItem, {
          block
        });
        navigator2.activeItem = activeItem;
      }
    }
  }
  //endregion
  //region Events
  /**
   * Focuses list items on hover.
   * @private
   */
  onMouseOver(event) {
    const me = this, itemElement = event.currentTarget;
    if (!DomHelper.isTouchEvent && itemElement && me.navigator && me.activateOnMouseover) {
      me.setTimeout({
        fn: "handleMouseOver",
        delay: 30,
        args: [itemElement],
        cancelOutstanding: true
      });
    }
  }
  handleMouseOver(itemElement) {
    this.navigator.activeItem = itemElement;
  }
  /**
   * Selects list items on click.
   * @private
   */
  onClick(event) {
    const itemElement = event.target.closest(this.itemSelector);
    if (itemElement) {
      this.onItemClick(itemElement, event);
    } else if (this.clearSelectionOnEmptySpaceClick) {
      this.deselectAll();
    }
  }
  onSpaceKey(event) {
    if (event.target.nodeName.toUpperCase() !== "INPUT" || event.target.readOnly) {
      this.onEnterKey(event);
    }
  }
  onEnterKey(event) {
    const active = this.navigator.activeItem;
    if (active && !this.disabled) {
      this.onItemClick(active, event);
      event.stopImmediatePropagation();
      event.preventDefault();
    }
  }
  /**
   * Key events which are not navigation are delegated up to here by the Navigator
   * @private
   */
  onInternalKeyDown(event) {
    const me = this;
    switch (event.key) {
      case "ArrowLeft":
        me.collapseItem();
        break;
      case "ArrowRight":
        me.expandItem();
        break;
      case " ":
        me.onSpaceKey(event);
        break;
      case "Enter":
        me.onEnterKey(event);
        break;
    }
  }
  collapseItem() {
    const { activeItem } = this.navigator;
    if (activeItem) {
      this.toggleCollapse(this.getRecordFromElement(activeItem), true);
    }
  }
  expandItem() {
    const { activeItem } = this.navigator;
    if (activeItem) {
      this.toggleCollapse(this.getRecordFromElement(activeItem), false);
    }
  }
  //endregion
  onItemClick(item, event) {
    var _a2;
    const me = this, { allowGroupSelect } = me, index = parseInt(item.dataset.index), record = me.store.getAt(index), isSpecialRow = record == null ? void 0 : record.isSpecialRow, isNoSelect = item.contains(event.target.closest("[data-noselect]"));
    if (me.disabled || me.trigger("beforeItem", { item, record, index, event, userAction: true }) === false) {
      return;
    }
    me._isUserAction = true;
    if (item.contains(event.target.closest("[data-select-all]"))) {
      me.onSelectAllClick(item, event);
    } else if (event.target.matches(".b-list-expander-icon")) {
      me.toggleCollapse(record);
      return;
    } else if (record && !isNoSelect && (!isSpecialRow || allowGroupSelect)) {
      const { selected } = me, groupParent = (_a2 = record.groupParent) == null ? void 0 : _a2.get(me.store.id);
      if (me.multiSelect) {
        let isSelected = selected.includes(record), toAddRemove = record;
        if (me.toggleAllIfCtrlPressed && event.ctrlKey) {
          toAddRemove = me.store.records;
        } else if (allowGroupSelect && isSpecialRow) {
          isSelected = !record.groupChildren.some((rec) => !selected.includes(rec));
          item.classList.toggle("b-selected", !isSelected);
          toAddRemove = record.groupChildren;
        }
        selected[isSelected ? "remove" : "add"](toAddRemove);
        if (!isSpecialRow && groupParent && allowGroupSelect) {
          const groupItem = me.getItem(groupParent);
          groupItem.classList.toggle("b-selected", groupParent.groupChildren.every((r) => selected.includes(r)));
        }
      } else {
        selected.splice(0, selected.count, record);
      }
    }
    if (me.isDestroyed) {
      return;
    }
    me.lastClicked = record;
    me.trigger("item", {
      item,
      record,
      index,
      event,
      userAction: true
    });
    me._isUserAction = false;
  }
  /**
   * Handles items being added or removed from the selected Collection
   * @param {Object} changeEvent
   * @private
   */
  onInternalSelectionChange({ action, removed, added, replaced }) {
    const me = this, {
      selectedCls,
      unselectedCls
    } = me;
    let record, item;
    if (action === "clear") {
      for (item of me.element.querySelectorAll(`.${selectedCls}`)) {
        item.classList.remove(selectedCls);
        item.setAttribute("aria-selected", false);
        unselectedCls && item.classList.remove(unselectedCls);
      }
    } else if (action !== "replaceValues") {
      for (record of removed) {
        item = me.getItem(record);
        if (item) {
          item.classList.remove(selectedCls);
          item.setAttribute("aria-selected", false);
        }
      }
      for (record of added) {
        item = me.getItem(record);
        if (item) {
          item.classList.add(selectedCls);
          item.setAttribute("aria-selected", true);
        }
      }
    }
    me.selectAllItem && me.updateSelectAllState();
    me.trigger("selectionChange", { selected: me.selected.values });
  }
  onSelectAllClick(item) {
    const checked = item.classList.contains(this.selectedCls);
    if (checked) {
      this.deselectAll();
    } else {
      this.selectAll();
    }
  }
  updateSelectAllState() {
    var _a2;
    (_a2 = this.element.querySelector(".b-select-all-item")) == null ? void 0 : _a2.classList.toggle(this.selectedCls, this.allSelected);
  }
  /**
   * Yields `true` if all the available items are selected.
   * @property {Boolean}
   * @readonly
   */
  get allSelected() {
    const { selected, store } = this;
    return selected.count && (store.isFiltered ? store.records.every((r) => selected.includes(r)) : store.count === selected.count);
  }
  /**
   * Selects all items in this list.
   * @category Selection
   */
  selectAll(keyEvent) {
    const me = this;
    if (me.multiSelect || !keyEvent) {
      me.selected.add(me.store.records);
      if (keyEvent && !me.navigator.activeItem) {
        me.navigator.activeItem = me.getItem(-1);
      }
    }
  }
  /**
   * Deselects all selected items
   * @category Selection
   */
  deselectAll() {
    this.selected.clear();
  }
  /**
   * Selects the passed item(s).
   *
   * An item to select may be the `id` of a record in this List's {@link #config-store}, or
   * it may be an object with an `id` __property__ which is the `id` of a record in this List's
   * {@link #config-store} (For example one of the records).
   * @param {String|String[]|Number|Number[]|Object|Object[]} toSelect
   * @category Selection
   */
  select(toSelect) {
    const { store } = this, { modelClass } = store;
    toSelect = ArrayHelper.asArray(toSelect).reduce((v, c) => {
      c = store.getById(modelClass.asId(c));
      if (c) {
        v.push(c);
      }
      return v;
    }, []);
    this.selected.add(toSelect);
  }
  /**
   * Deselects the passed item(s).
   *
   * An item to deselect may be the `id` of a record in this List's {@link #config-store}, or
   * it may be an object with an `id` __property__ which is the `id` of a record in this List's
   * {@link #config-store} (For example one of the records).
   * @param {String|String[]|Number|Number[]|Object|Object[]} toSelect
   * @category Selection
   */
  deselect(toDeselect) {
    const { modelClass } = this.store;
    toDeselect = ArrayHelper.asArray(toDeselect).reduce((v, c) => {
      c = this.selected.get(modelClass.asId(c));
      if (c) {
        v.push(c);
      }
      return v;
    }, []);
    this.selected.remove(toDeselect);
  }
  /**
   * Toggles the collapsed state of a group header record
   * @param {Core.data.Model} record The group record
   * @param {Boolean} [collapse] Force collapse (true) or expand (false)
   * @fires togglegroup
   */
  toggleCollapse(groupRecord, collapse) {
    if (!groupRecord.isGroupHeader) {
      return;
    }
    collapse = collapse === void 0 ? !groupRecord.meta.collapsed : collapse;
    this.store[collapse ? "collapse" : "expand"](groupRecord);
    this.refresh();
    this.trigger("toggleGroup", { groupRecord, collapse });
  }
  updateCollapsibleGroups(value, old) {
    if (old && !value) {
      const { store } = this;
      store.groupRecords.forEach((record) => store.expand(record));
    }
    this.refresh();
  }
};
//region Config
__publicField(List, "$name", "List");
__publicField(List, "type", "list");
List.initClass();
List.prototype.navigatorClass = Navigator;
List._$name = "List";

// ../Core/lib/Core/widget/ChipView.js
var ChipView = class extends List {
  static get configurable() {
    return {
      itemCls: "b-chip",
      /**
       * Configure as `true` to allow multi select and allow clicking and key navigation
       * to select multiple chips.
       * @config {Boolean}
       * @default
       */
      multiSelect: false,
      /**
       * Configure as `true` to display a clickable close icon after the {@link Core.widget.List#config-itemTpl}.
       * When tapped, the configured {@link #config-closeHandler} is called passing the
       * associated record.
       *
       * Chips may also be selected using the `LEFT` and `RIGHT` arrows (And the `Shift` key to
       * do multiple, contiguous election). Pressing the `DELETE` or `BACKSPACE` key passes the
       * selected records to the {@link #config-closeHandler}
       * @config {Boolean}
       * @default
       */
      closable: true,
      /**
       * A template function, which, when passed a record, returns the markup which
       * encapsulates a chip's icon to be placed before the {@link Core.widget.List#config-itemTpl}.
       * @config {Function}
       * @param {Core.data.Model} record The record to provide an icon for
       * @returns {DomConfig|String|null}
       */
      iconTpl: null,
      /**
       * If {@link #config-closable} is `true`, this is the name of a callback function
       * to handle what the "close" action means. If not provided, the record representing the chip is removed
       * from the store
       *
       * @config {String|Function}
       * @params {Core.data.Model[]} records Records to be closed
       * @params {Object} options Close options
       * @returns {void}
       */
      closeHandler: null
    };
  }
  itemContentTpl(record, i) {
    const me = this;
    return TemplateHelper.tpl`${me.iconTpl ? this.iconTpl(record) : ""}
            ${me.itemTpl(record, i)}
            ${me.closable ? '<div class="b-icon b-close-icon b-icon-clear" data-noselect></div>' : ""}`;
  }
  onInternalKeyDown(event) {
    const me = this;
    if (me.closable && me.selected.count && (event.key === "Delete" || event.key === "Backspace")) {
      me.callback(me.closeHandler, me.owner, [me.selected.values, { isKeyEvent: true }]);
    } else {
      super.onInternalKeyDown(event);
    }
  }
  updateClosable(closable) {
    this.element.classList[closable ? "add" : "remove"]("b-chips-closable");
    this.navigator && (this.navigator.disabled = !closable);
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  onClick(event) {
    const me = this, item = event.target.closest(`.${me.itemCls}`);
    if (me.closable && event.target.classList.contains("b-close-icon")) {
      const record = me.store.getAt(parseInt(item.dataset.index));
      if (me.closeHandler) {
        me.callback(me.closeHandler, me.owner, [[record]]);
      } else {
        me.store.remove(record);
      }
    } else {
      super.onClick(event);
    }
  }
};
//region Config
__publicField(ChipView, "$name", "ChipView");
__publicField(ChipView, "type", "chipview");
ChipView.initClass();
ChipView._$name = "ChipView";

// ../Core/lib/Core/widget/Combo.js
var errorFieldRequired = "L{Field.fieldRequired}";
var errorValidateFilter = "L{Field.validateFilter}";
var errorRecordNotCommitted = "L{Combo.recordNotCommitted}";
var filterKeyTypes = /[\w\s]/;
var Combo = class extends PickerField {
  static get configurable() {
    return {
      /**
       * Optionally a {@link Core.util.CollectionFilter Filter} config object which the combo should use for
       * filtering using the typed value.
       * This may use a `filterBy` property to test its `value` against any field in the passed record.
       * ```javascript
       * {
       *     type          : 'combo',
       *     store         : myStore,
       *     primaryFilter : {
       *         filterBy(record) {
       *             if (this.value == null) {
       *                 return true;
       *             }
       *             const value = this.value.toLowerCase();
       *
       *             // Match typed value with forename or surname
       *             return record.forename.toLowerCase().startsWith(value)
       *                 || record.surname.toLowerCase().startsWith(value);
       *         }
       *     }
       * }
       * ```
       * @config {CollectionFilterConfig}
       */
      primaryFilter: {},
      /**
       * Configuration object for the {@link Core.widget.List picker} on initialization. Returns the
       * {@link Core.widget.List picker} instance at runtime.
       *
       * For example:
       *
       * ```javascript
       * new Combo({
       *     ...
       *     // configure the combobox picker
       *     picker : {
       *         listeners : {
       *             // prevent selection of item with id == 2
       *             beforeItem : ({ record }) => record.id !== 2
       *         }
       *     }
       * })
       * ```
       *
       * @prp {Core.widget.List}
       * @accepts {ListConfig}
       */
      picker: {
        type: "list",
        floating: true,
        scrollAction: "realign",
        itemsFocusable: false,
        activateOnMouseover: true,
        align: {
          align: "t0-b0",
          axisLock: true
        },
        maxHeight: 324,
        scrollable: {
          overflowY: true
        },
        autoShow: false,
        focusOnHover: false
      },
      /**
       * Configure as `true` to allow selection of multiple values from the dropdown list.
       *
       * Each value is displayed as a "Chip" to the left of the input area. Chips may be
       * selected using the `LEFT` and `RIGHT` arrow keys and deleted using the `DELETE` key
       * to remove values from the field. There is also a clickable close icon in each chip.
       *
       * Use {@link Core.widget.List#config-toggleAllIfCtrlPressed} to implement "select all" behaviour.
       *
       * ```javascript
       * {
       *     type   : 'combo',
       *     store  : myStore,
       *     picker : {
       *         toggleAllIfCtrlPressed : true
       *     }
       * }
       * ```
       *
       * @config {Boolean}
       * @default false
       */
      multiSelect: null,
      /**
       * Rows to display in the dropdown (list items).
       *
       * If an object, the property names provide the {@link #config-value} for the Combo, and
       * the property values provide the displayed test in the list and input area eg:
       *
       *     items : {
       *         small  : 'Small',
       *         medium : 'Medium',
       *         large  : 'Large'
       *     }
       *
       * If an array, each entry may be
       *  - an object containing properties which must include
       * the {@link #config-valueField} and {@link #config-displayField} which populates the dropdown
       * with text and provides the corresponding field value.
       *  - An array whose first value provides the {@link #config-value} for the Combo and whose
       * second value provides the displayed test in the list and input area.
       *  - An array of values where the {@link #config-valueField} and {@link #config-displayField} are the same.
       *
       * eg:
       *
       *     items : [
       *         {value : 'small',  text : 'Small'},
       *         {value : 'medium', text : 'Medium'},
       *         {value : 'large',  text : 'Large'},
       *     ]
       *
       * or
       *
       *     items : [
       *         ['small',  'Small'],
       *         ['medium', 'Medium'],
       *         ['large',  'Large'],
       *     ]
       *
       * or
       *
       *     items : [ 'Small', 'Medium', 'Large' ]
       *
       * @config {Object[]|String[]|Object}
       */
      items: null,
      /**
       * Store used to populate items. Also accepts a Store config object
       * @prp {Core.data.Store|StoreConfig}
       */
      store: null,
      /**
       * Field used for item value when populating from store. Setting this to `null` will
       * yield the selected record as the Combo's {@link #property-value}.
       * @config {String|null}
       */
      valueField: void 0,
      /**
       * Field used for item text when populating from store
       * @config {String}
       * @default
       */
      displayField: "text",
      /**
       * Width of picker, defaults to this combo's {@link #config-pickerAlignElement} width
       * @config {Number}
       */
      pickerWidth: null,
      /**
       * The minimum string length to trigger the filtering, only relevant when {@link #config-editable} is `true`.
       *
       * This defaults to `1` in the case of local filtering, but `4` if the
       * {@link #config-filterParamName} is set to cause remote dropdown loading.
       *
       * @config {Number}
       * @default
       */
      minChars: null,
      selected: null,
      /**
       * Template string used to render the list items in the dropdown list
       *
       * ```javascript
       * new Combo({
       *     listItemTpl : ({ text }) => `<div class="combo-color-box ${text}"></div>${text}`,
       *     editable    : false,
       *     items       : [
       *         'Black',
       *         'Green',
       *         'Orange',
       *         'Pink',
       *         'Purple',
       *         'Red',
       *         'Teal'
       *     ]
       * });
       * ```
       *
       * @config {Function}
       * @param {Core.data.Model} record The record representing the item being rendered
       * @returns {String|null}
       */
      listItemTpl: null,
      /**
       * Template function that can be used to customize the displayed value
       * @param {Core.data.Model} record The record to provide a textual value for
       * @param {Core.widget.Combo} combo A reference to this Combo
       * @config {Function}
       * @returns {String|null}
       */
      displayValueRenderer: null,
      /**
       * CSS class to add to picker
       * @config {String}
       */
      listCls: null,
      triggers: {
        expand: {
          cls: "b-icon-picker",
          handler: "onTriggerClick"
        }
      },
      /**
       * If the dropdown is to be populated with a filtered query to a remote server, specify the
       * name of the parameter to pass the typed string here. By default, the string is simply sent
       * as the value of the parameter. For special encoding, configure the combo with {@link #config-encodeFilterParams}
       * @config {String}
       */
      filterParamName: null,
      /**
       * A function which creates an array of values for the {#config-filterParamName} to pass
       * any filters to the server upon load.
       *
       * The default behaviour is just to set the parameter value to the filter's `value`,
       * but the filter can be fully encoded for example:
       *
       * ```javascript
       *    {
       *        encodeFilterParams(filters) {
       *            const result = [];
       *
       *            for (const { property, operator, value, caseSensitive } of filters) {
       *                result.push(JSON.stringify({
       *                    field : property,
       *                    operator,
       *                    value,
       *                    caseSensitive
       *                }));
       *           }
       *        return result;
       *    }
       * ```
       * @config {Function}
       * @param {Object[]} filters filters
       * @returns {Object[]} array of values
       */
      encodeFilterParams: (filters) => filters.map((f) => f.value),
      /**
       * If `false`, filtering will be triggered once you exceed {@link #config-minChars}. To filter only when
       * hitting Enter key, set this to `true`;
       * @config {Boolean}
       */
      filterOnEnter: false,
      /**
       * Configure as `true` to hide the expand trigger. This is automatically set to `true` if
       * remote filtering is enabled by setting the {@link #config-filterParamName} config.
       * @config {Boolean}
       * @default false
       */
      hideTrigger: null,
      /**
       * This implies that the picker will display an anchor pointer, but also means that the picker will align closer
       * to the input field so that the pointer pierces the {@link #config-pickerAlignElement}
       * @config {Boolean}
       * @default false
       */
      overlayAnchor: null,
      /**
       * The delay in milliseconds to wait after the last keystroke before filtering the list.
       *
       * This is a minimum of 300ms for remote filtering to keep network requests manageable, and
       * defaults to 10ms for locally filtered stores.
       * @config {Number}
       * @default
       */
      keyStrokeFilterDelay: null,
      defaultAction: "select",
      /**
       * How to query the store upon click of the expand trigger. Specify one of these values:
       *
       *  - `'all'` - Clear the filter and display the whole dataset in the dropdown.
       *  - `'last'` - Filter the dataset using the last filter value.
       *  - `null`/any other - Use the value in the input field to filter the dataset.
       *
       * @config {'all'|'last'|null}
       * @default
       */
      triggerAction: "all",
      /**
       * The name of an operator type as implemented in {@link Core.util.CollectionFilter#config-operator}
       * to use when filtering the dropdown list based upon the typed value.
       *
       * This defaults to `'startsWith'`, but the `'*'` operator may be used to match all
       * values which _contain_ the typed value.
       *
       * Not used when {@link #config-filterParamName} is set to cause remote dropdown loading.
       * The exact filtering operation is up to the server.
       *
       * @default
       * @prp {'='|'!='|'>'|'>='|'<'|'<='|'*'|'startsWith'|'endsWith'|'isIncludedIn'}
       */
      filterOperator: "startsWith",
      /**
       * Configure as `true` to force case matching when filtering the dropdown list based upon the typed value.
       *
       * @config {Boolean}
       * @default false
       */
      caseSensitive: false,
      /**
       * By default, the picker is hidden on selection in single select mode, and
       * remains to allow more selections when {@link #config-multiSelect} is `true`.
       * Setting this to a `Boolean` value can override that default.
       * @config {Boolean}
       */
      hidePickerOnSelect: null,
      /**
       * A config object to configure the {@link Core.widget.ChipView} to display the
       * selected value set when {@link #config-multiSelect} is `true`.
       *
       * For example the {@link Core.widget.List#config-itemTpl} or
       * {@link Core.widget.ChipView#config-iconTpl} might be configured to display
       * richer chips for selected items.
       * @config {ChipViewConfig}
       */
      chipView: {
        $config: ["lazy", "nullify"],
        value: {
          type: "combochipview"
        }
      },
      chipStore: {
        $config: ["lazy", "nullify"],
        value: {}
      },
      /**
       * When {@link #config-multiSelect} is `true`, you may configure `filterSelected` as
       * `true` to hide items in the dropdown when they are added to the selection.
       * It will appear as if the requested item has "moved" into the field's
       * {@link #config-chipView ChipView}.
       *
       * @config {Boolean}
       * @default false
       */
      filterSelected: null,
      /**
       * Text to display in the drop down when there are no items in the underlying store
       * @config {String}
       * @default
       */
      emptyText: null,
      /**
       * Get/sets combo value, selects corresponding item in the list
       * Setting null clears the field.
       *
       * If {@link #config-multiSelect} is `true`, then multiple values may be passed as an array.
       * If the values are records, these become the selected record set held by {@link #property-valueCollection},
       * and the `value` yielded by this field is an array of all the {@link #config-valueField}s from the records.
       * @fires select
       * @fires action
       * @member {Object|Number|String} value
       */
      /**
       * The initial value of this Combo box. In single select mode (default) it's a simple string value, for
       * {@link #config-multiSelect} mode, it should be an array of record ids.
       * @config {String|Number|String[]|Number[]}
       * @default
       */
      value: null,
      valueCollection: {
        $config: ["nullify", "lazy"],
        value: {}
      },
      /**
       * `true` to cause the field to be in an invalid state while the typed filter string does not match a record in the store.
       * @config {Boolean}
       * @default
       */
      validateFilter: true,
      /**
       * `true` to clear value typed to a multiselect combo when picker is collapsed
       * @config {Boolean}
       * @default
       */
      clearTextOnPickerHide: true,
      // set to true to destroy the old combo store when it is replaced with a new store
      destroyStore: false,
      /**
       * A key value which, when typed in a {@link #config-multiSelect} Combo, selects the
       * currently active item in the picker, and clears the input field ready for another
       * match to be typed.
       * @config {String}
       * @default
       */
      multiValueSeparator: ",",
      /**
       * If configured as `true`, this means that when an unmatched string is typed into the
       * combo's input field, and `ENTER`, or the {@link #config-multiValueSeparator} is typed,
       * a new record will be created using the typed string as the {@link #config-displayField}.
       *
       * If configured as a function, or the name of a function in the owning component hierarchy, the function
       * will be called passing the string and combo field instance and should return the record to add (if any).
       *
       * The new record will be appended to the store, and the value selected.
       *
       * If the Store is an {@link Core.data.AjaxStore}, the new record will be eiligible for
       * syncing to the database through its {@link Core.data.AjaxStore#config-createUrl createUrl}.
       *
       * If the `AjaxStore` is configured to {@link Core.data.AjaxStore#config-autoCommit autoCommit},
       * the record will be synced immediately. If the server does not accept the new addition,
       * the field is placed temporarily into an invalid state with a message that explains this.
       *
       * For example:
       *
       * ```javascript
       *     new Combo({
       *         label : 'Employee name',
       *         store : employees,
       *         createOnUnmatched(name, combo) {
       *             name = validateEmployeeName(name);
       *
       *             if (name) {
       *                 return new Employee({
       *                     name,
       *                     email : generateEmployeeEmail(name)
       *                 });
       *             }
       *             else {
       *                 combo.setError('Invalid new employee name');
       *             }
       *         }
       *     });
       * ```
       * @config {Function|String|Boolean}
       * @param {String} name Record name
       * @param {Core.widget.Combo} combo Combo instance
       * @returns {Core.data.Model} New record
       */
      createOnUnmatched: null,
      role: "combobox",
      /**
       * Configure this as `true` to render the dropdown list as a permanently visible list
       * in the document flow immediately below the input area instead of as a popup.
       *
       * This also hides the expand trigger since it is not needed.
       * @config {Boolean}
       * @default false
       */
      inlinePicker: null,
      testConfig: {
        // So that locally filtered tests do not have to wait after type gestures.
        // Note that for remote filtering, we set a min of 300ms
        keyStrokeFilterDelay: 0
      },
      /**
       * Configure this as `true` and the items display field values will be localized. The display field values
       * need to be a locale string.
       * @config {Boolean}
       * @private
       * @default
       */
      localizeDisplayFields: false,
      /**
       * Provide a function that returns items to be shown in the combo's selector.
       * @config {Function}
       * @private
       */
      buildItems: null
    };
  }
  /**
   * A constant value for the {@link #config-triggerAction} config to indicate that clicking the trigger should
   * filter the dataset using the last filter query string, *not* the input field value.
   * @member {String} queryLast
   * @readonly
   * @static
   */
  static get queryLast() {
    return "last";
  }
  //endregion
  construct(config) {
    super.construct(...arguments);
    if (!this.store) {
      this.items = [];
    }
    if (this.filterOnEnter) {
      this.hideTrigger = true;
    }
  }
  startConfigure(config) {
    this.usingRecordAsValue = config.valueField === null;
    super.startConfigure(...arguments);
  }
  afterConfigure() {
    super.afterConfigure();
    const me = this;
    if (!ObjectHelper.hasOwn(me, "_value")) {
      me._value = me.valueField === me.displayField ? "" : null;
      me._lastValue = me._lastValue || me._value;
    }
  }
  get childItems() {
    const { _chipView, _picker } = this, result = super.childItems;
    if (_chipView) {
      result.push(_chipView);
    }
    if (_picker) {
      result.push(_picker);
    }
    return result;
  }
  get innerElements() {
    var _a2;
    const chipViewElement = (_a2 = this._chipView) == null ? void 0 : _a2.element, { input, inputElement } = this;
    if (chipViewElement) {
      DomSync.sync({
        targetElement: input,
        domConfig: inputElement
      });
    }
    return [chipViewElement || inputElement];
  }
  updateInlinePicker(inlinePicker) {
    if (inlinePicker) {
      this.element.classList.add("b-inline-picker");
      this.getConfig("picker");
      this.triggers.expand = null;
      this.pickerVisible = true;
    }
  }
  hidePicker() {
    if (!this.inlinePicker) {
      return super.hidePicker(...arguments);
    }
  }
  changeChipStore(chipStore) {
    if (chipStore && !(chipStore instanceof Store)) {
      chipStore = new Store(Store.mergeConfigs({
        storage: this.valueCollection
      }, chipStore));
    }
    return chipStore;
  }
  updateChipStore(store, was) {
    was == null ? void 0 : was.destroy();
  }
  changeChipView(chipView, oldChipView) {
    const me = this;
    me.element.classList[chipView ? "add" : "remove"]("b-uses-chipview");
    if (chipView) {
      const { input } = me;
      if (!me.chipStore) {
        me.chipStore = {};
      }
      return ComboChipView.reconfigure(oldChipView, chipView, {
        defaults: {
          parent: me,
          insertBefore: input,
          store: me.chipStore,
          closable: !me.readOnly,
          navigator: {
            type: "combochipnavigator",
            keyEventTarget: input
          }
        }
      });
    }
    oldChipView == null ? void 0 : oldChipView.destroy();
  }
  updateChipView(chipView) {
    var _a2;
    const me = this;
    me._chipViewEventDetacher = (_a2 = me._chipViewEventDetacher) == null ? void 0 : _a2.call(me);
    me.chipStore = chipView == null ? void 0 : chipView.store;
    if (chipView) {
      chipView.element.appendChild(me.input);
      me._chipViewEventDetacher = EventHelper.on({
        element: chipView.element,
        mousedown: "onChipViewMousedown",
        thisObj: me
      });
    }
  }
  updateMultiSelect(multiSelect, oldMultiSelect) {
    const me = this, {
      input,
      element
    } = me, fixValue = !me.isConfiguring;
    let { value } = me;
    element.classList[multiSelect ? "add" : "remove"]("b-multiselect");
    if (multiSelect) {
      const { chipView } = me, { parentNode: parentNode2 } = input, chipViewEl = chipView == null ? void 0 : chipView.element;
      if (chipViewEl && chipViewEl !== parentNode2) {
        parentNode2.insertBefore(chipViewEl, input);
        chipViewEl.appendChild(input);
        me.chipView.refresh();
      }
      input.value = "";
      if (fixValue) {
        value = ArrayHelper.asArray(value);
      }
    } else {
      const chipView = me._chipView, { parentNode: parentNode2 } = input, chipViewEl = chipView == null ? void 0 : chipView.element;
      if (chipViewEl === parentNode2) {
        chipViewEl.parentNode.insertBefore(input, chipViewEl);
        chipViewEl.remove();
        element.classList.remove("b-uses-chipview");
      }
      if (fixValue && typeof value !== "string") {
        value = (value == null ? void 0 : value.length) ? value[0] : null;
      }
    }
    if (fixValue) {
      me.value = value;
    }
  }
  onChipViewMousedown(mousedownEvent) {
    mousedownEvent.preventDefault();
    if (!this.containsFocus) {
      this.focus();
    }
  }
  onChipClose(records, options = {}) {
    if (options.isKeyEvent && this.input.value === "" || !options.isKeyEvent) {
      this._isUserAction = true;
      this.valueCollection.remove(records);
      this._isUserAction = false;
    }
  }
  updateFilterParamName(filterParamName) {
    if (this.hideTrigger !== false) {
      this.hideTrigger = Boolean(filterParamName);
    }
  }
  updateHideTrigger(hideTrigger) {
    this.element.classList[hideTrigger ? "add" : "remove"]("b-hide-trigger");
  }
  //region Getters/setters
  updateKeyStrokeFilterDelay(delay) {
    this.filterOnInput.delay = delay;
  }
  updateReadOnly(readOnly) {
    super.updateReadOnly(...arguments);
    this._chipView && (this._chipView.closable = !readOnly);
  }
  updateDisabled(disabled) {
    super.updateDisabled(...arguments);
    this._chipView && (this._chipView.closable = !disabled);
  }
  updateFilterOperator(filterOperator) {
    if (this.primaryFilter) {
      this.primaryFilter.operator = filterOperator;
    }
  }
  get minChars() {
    const minChars = this._minChars;
    if (minChars != null) {
      return minChars;
    }
    return this.remoteFilter ? 4 : 1;
  }
  get validateFilter() {
    return this._validateFilter && !this.createOnUnmatched;
  }
  get items() {
    return this.store.allRecords;
  }
  updateBuildItems(fn) {
    if (fn) {
      this.items = fn.call(this);
    }
  }
  /**
   * Prepares items to work in attached menu (converts strings to items)
   * @private
   */
  changeItems(items) {
    const me = this;
    if (items == null) {
      if (me.store && !me.store.isItemStore) {
        return;
      }
      items = [];
    }
    if (me.buildItems && !(items == null ? void 0 : items.length)) {
      items = me.buildItems();
    }
    if (items instanceof Store) {
      me.store = items;
      return;
    }
    const displayField = me.displayField;
    let itemModel, valueField = me.valueField, storeData;
    if (Array.isArray(items)) {
      storeData = items.map((item) => {
        let result = item;
        if (item instanceof Model) {
          itemModel = item.constructor;
          if (!valueField) {
            me.valueField = valueField = itemModel.idField;
          }
        } else {
          if (typeof item === "string" || typeof item === "number") {
            if (!valueField) {
              me.valueField = valueField = me.displayField;
            }
            result = {
              [valueField]: item,
              [displayField]: item
            };
          } else {
            if (!valueField) {
              me.valueField = valueField = "value";
            }
            if (Array.isArray(item)) {
              result = {
                [valueField]: item[0],
                [displayField]: item[1]
              };
            }
          }
        }
        if (item.selected) {
          me.value = result;
        }
        return result;
      });
    } else {
      if (!valueField) {
        me.valueField = valueField = "value";
      }
      storeData = [];
      Object.entries(items).forEach(([key, value]) => {
        storeData.push({
          [valueField]: key,
          [displayField]: value
        });
      });
    }
    if (me.store) {
      me.store.data = storeData;
    } else {
      const valueFieldDefinition = valueField === displayField ? {
        name: "value",
        dataSource: displayField
      } : valueField;
      if (!itemModel) {
        class ModelClass extends Model {
          static get idField() {
            return me.valueField;
          }
          static set idField(idField) {
            super.idField = idField;
          }
          static get fields() {
            return [valueFieldDefinition, displayField];
          }
        }
        itemModel = ModelClass;
      }
      me.store = new Store({
        isItemStore: true,
        data: storeData,
        idField: valueField,
        // We frequently populate combos with data from other stores, don't want warnings for consuming local
        // records from those stores with generated ids
        verifyNoGeneratedIds: false,
        modelClass: itemModel
      });
    }
  }
  get value() {
    const me = this, { valueCollection, valueField } = me;
    if (valueField == null) {
      return me.multiSelect ? valueCollection.values.slice() : valueCollection.first;
    }
    let value;
    if (me.multiSelect) {
      value = valueCollection.count ? valueCollection.map((r) => r[valueField]) : me._lastValue || [];
    } else {
      value = valueCollection.count ? valueCollection.first[valueField] : me._lastValue;
    }
    return value;
  }
  set value(value) {
    super.value = value;
  }
  // Documented in superclass.
  get needsInputSync() {
    return this.usesChipView ? false : !this.editable;
  }
  changeValue(value, oldValue) {
    var _a2, _b;
    const me = this;
    if (value === oldValue) {
      me.syncInputFieldValue(true);
      return;
    }
    if (!me.multiSelect && Array.isArray(value) && value.length > 1) {
      throw new Error("Multiple values cannot be set to a non-multiSelect Combo");
    }
    me.triggerConfig("items");
    if (!me.inputting) {
      (_a2 = me._chipView) == null ? void 0 : _a2.selected.clear();
    }
    if (!me.store) {
      me.items = [];
    }
    const {
      valueField,
      displayField,
      store,
      valueCollection,
      _picker
    } = me, { storage } = store, hidePicker = (_b = me.hidePickerOnSelect) != null ? _b : !me.multiSelect, isUserAction = me._isUserAction || (_picker == null ? void 0 : _picker._isUserAction) || hidePicker && me.pickerVisible || false;
    if (!me.remoteFilter && store.isAjaxStore && !store.count) {
      store.ion({ load: () => me.value = value, once: true, thisObj: me });
      me._lastValue = value;
      return;
    }
    let record;
    if (value != null) {
      const arrayPassed = Array.isArray(value), values = arrayPassed ? value.slice() : [value];
      if (me.remoteFilter) {
        if (value != null) {
          if (ObjectHelper.isObject(value) || value.isModel) {
            me.store.data = [value];
            me.valueCollection.splice(0, me.valueCollection.count, me.store.first);
          } else {
            const wasConfiguring = me.isConfiguring;
            me.primaryFilter.setConfig({
              value,
              disabled: false
            });
            store.performFilter(true).then(() => {
              if (me.isDestroyed) {
                return;
              }
              const { isConfiguring } = me;
              me.isConfiguring = wasConfiguring;
              valueCollection.splice(0, valueCollection.count, store.allRecords);
              me.isConfiguring = isConfiguring;
            });
          }
          return;
        }
      } else if (store.isFiltered) {
        me.primaryFilter.disabled = true;
        store.filter();
      }
      for (let i = 0, len = values.length; i < len; i++) {
        let currentValue = values[i];
        if (currentValue instanceof Model) {
          if (!storage.includes(currentValue, true)) {
            store.add(currentValue);
          }
        } else {
          const isObject3 = ObjectHelper.isObject(currentValue);
          if (isObject3) {
            currentValue = currentValue[store.modelClass.fieldMap[valueField].dataSource];
          }
          record = storage.getBy(displayField, currentValue) || storage.getBy(valueField, currentValue) || (valueCollection.getBy(displayField, currentValue) || valueCollection.getBy(valueField, currentValue));
          if (record instanceof Set) {
            record = [...record][0];
          }
          if (record) {
            if (isObject3) {
              record.set(values[i]);
            }
            values[i] = record;
          } else {
            values.splice(i, 1);
            len--;
            i--;
          }
        }
      }
      const noMatches = !values.length;
      const vcGen = valueCollection.generation;
      valueCollection.splice(0, valueCollection.count, values);
      if (noMatches) {
        me._value = arrayPassed && value.length === 0 ? null : value;
        me._lastValue = me._value;
      }
      if (noMatches || valueCollection.generation === vcGen) {
        me.syncInputFieldValue();
      }
      me.syncEmpty();
      if (noMatches && !me.isConfiguring) {
        me.triggerFieldChange({
          value,
          oldValue,
          userAction: isUserAction,
          valid: me.isValid
        });
      }
    } else {
      if (valueCollection.count) {
        valueCollection.clear();
      } else {
        const oldValue2 = me._value;
        me._value = null;
        me.syncInputFieldValue();
        me.syncEmpty();
        if (!me.isConfiguring) {
          me.triggerFieldChange({
            value,
            oldValue: oldValue2,
            userAction: isUserAction,
            valid: me.isValid
          });
        }
      }
    }
    me._lastValue = me._value;
  }
  hasChanged(oldValue, newValue) {
    if (this.multiSelect) {
      return !ObjectHelper.isEqual(oldValue, newValue);
    }
    return super.hasChanged(...arguments);
  }
  onComboStoreChange({ action }) {
    if (action !== "filter") {
      this.syncInputFieldValue(true);
    }
  }
  syncInputFieldValue(skipHighlight) {
    var _a2;
    if (this.usesChipView) {
      (_a2 = this.chipView) == null ? void 0 : _a2.refresh();
    } else {
      super.syncInputFieldValue(skipHighlight);
    }
  }
  get usesChipView() {
    return Boolean(this.multiSelect && this._chipView);
  }
  /**
   * Returns `true` if this field has no selected records.
   * @property {Boolean}
   * @readonly
   */
  get isEmpty() {
    return this.valueCollection.count === 0;
  }
  get inputValue() {
    const me = this;
    let result = me.selected ? me.selected[me.displayField] : me.value;
    if (me.displayValueRenderer) {
      result = me.callback(me.displayValueRenderer, me, [me.selected, me]);
    }
    return result == null ? "" : result;
  }
  get nonEditableClickTarget() {
    var _a2;
    return this.multiSelect && ((_a2 = this.chipView) == null ? void 0 : _a2.element) || super.nonEditableClickTarget;
  }
  /**
   * A {@link Core/util/Collection} which holds the currently selected records
   * from the store which dictates this field's value.
   *
   * Usually, this will contain one record, the record selected.
   *
   * When {@link #config-multiSelect} is `true`, there may be several records selected.
   * @member {Core.util.Collection} valueCollection
   * @readonly
   */
  changeValueCollection(valueCollection, oldValueCollection) {
    oldValueCollection == null ? void 0 : oldValueCollection.destroy();
    if (valueCollection) {
      if (!valueCollection.isCollection) {
        valueCollection = new Collection({
          internalListeners: {
            noChange: "onValueCollectionNoChange",
            change: "onValueCollectionChange",
            prio: -1e3,
            // The ChipView must react to changes first.
            thisObj: this
          }
        });
      }
      return valueCollection;
    }
  }
  changePrimaryFilter(primaryFilter) {
    if (primaryFilter.isCollectionFilter) {
      primaryFilter.setConfig({
        disabled: true,
        property: this.displayField,
        operator: this.filterOperator,
        caseSensitive: this.caseSensitive
      });
    } else {
      if (typeof primaryFilter === "function") {
        primaryFilter = {
          filterBy: primaryFilter
        };
      }
      primaryFilter = new CollectionFilter({
        // Need an id to replace any existing combo filter on the store.
        id: "primary",
        disabled: true,
        property: this.displayField,
        operator: this.filterOperator,
        caseSensitive: this.caseSensitive,
        ...primaryFilter
      });
    }
    return primaryFilter;
  }
  changeStore(store) {
    const me = this, storeFilters = [], {
      valueCollection,
      keyStrokeFilterDelay,
      filterParamName
    } = me;
    if (Array.isArray(store)) {
      me.items = store;
      return;
    }
    let remoteFilter;
    if (store) {
      if (store.isStore) {
        const sharedFilter = store.filters.get("primary");
        if (me.remoteFilter) {
          store.filterParamName = filterParamName;
        }
        remoteFilter = store.remoteFilter || store.restfulFilter;
        if (sharedFilter) {
          me.primaryFilter = sharedFilter;
        } else {
          storeFilters.push(me.primaryFilter);
        }
      } else {
        if (typeof store === "string") {
          store = Store.getStore(store);
        } else {
          store = new (store.readUrl ? AjaxStore : Store)(store);
          me.destroyStore = true;
        }
        remoteFilter = me.remoteFilter || store.restfulFilter;
        if (remoteFilter && filterParamName) {
          store.filterParamName = filterParamName;
          if (me.encodeFilterParams) {
            store.encodeFilterParams = me.encodeFilterParams;
          }
        }
        storeFilters.push(me.primaryFilter);
      }
      if (!me.valueField && !me.usingRecordAsValue) {
        me.valueField = store.modelClass.idField;
      }
      if (me.filterSelected) {
        const selectedItemsFilter = (r) => !me.containsFocus || !valueCollection.includes(r);
        if (remoteFilter) {
          store.storage.autoFilter = true;
          store.storage.addFilter({
            id: `${me.id}-selected-filter`,
            filterBy: selectedItemsFilter
          });
        } else {
          storeFilters.push(selectedItemsFilter);
          store.reapplyFilterOnAdd = true;
        }
      }
      valueCollection.addIndex({
        property: me.displayField,
        unique: false
      });
      valueCollection.addIndex({
        property: me.valueField,
        unique: true
      });
      storeFilters.forEach((f) => store.addFilter(f, true));
      if (remoteFilter) {
        me.keyStrokeFilterDelay = Math.max(300, keyStrokeFilterDelay || 0);
      } else {
        me.keyStrokeFilterDelay = keyStrokeFilterDelay != null ? keyStrokeFilterDelay : 10;
      }
    }
    return store;
  }
  updateStore(store, oldStore) {
    const me = this, { _picker } = me;
    let storeListeners;
    if (me.destroyStore && oldStore) {
      oldStore.destroy();
    }
    if (_picker) {
      _picker.store = store;
    }
    store.storage.addIndex({
      property: me.displayField,
      unique: false
    });
    store.storage.addIndex({
      property: me.valueField,
      unique: true
    });
    storeListeners = {
      filter: "onStoreFilter"
    };
    if (me.displayValueRenderer) {
      (storeListeners || (storeListeners = {})).change = "onComboStoreChange";
    }
    me.detachListeners("store");
    (store == null ? void 0 : store.storage) && me.valueCollection.match(store.storage);
    me.syncInputFieldValue();
    if (storeListeners) {
      storeListeners.name = "store";
      storeListeners.thisObj = me;
      store.ion(storeListeners);
    }
  }
  get remoteFilter() {
    var _a2;
    return Boolean(this.filterParamName || ((_a2 = this._store) == null ? void 0 : _a2.restfulFilter));
  }
  /**
   * Get selected record.
   * @property {Core.data.Model[]}
   * @readonly
   */
  get record() {
    return this.selected;
  }
  /**
   * Get the selected record(s).
   * @property {Core.data.Model[]}
   * @readonly
   */
  get records() {
    return this.valueCollection.values.slice();
  }
  get selected() {
    const { store } = this;
    return this.multiSelect ? this.valueCollection.values.slice().sort((l, r) => store.indexOf(l) - store.indexOf(r))[0] : this.valueCollection.first;
  }
  //endregion
  //region Value handling
  /**
   * Check if field value is valid
   * @internal
   */
  onEditComplete() {
    const me = this, selectionCount = me.valueCollection.count;
    super.onEditComplete();
    if (selectionCount) {
      me.clearError(errorValidateFilter);
      me.syncInputFieldValue();
    }
    if (me.required && !selectionCount) {
      me.setError(errorFieldRequired);
    }
  }
  //endregion
  //region Events
  /**
   * User clicked trigger icon, toggle list.
   * @private
   */
  onTriggerClick(event) {
    var _a2;
    const me = this, activatePicker = "key" in event;
    if (me.ignoreTriggerClick || me.remoteFilter && me.filterOnEnter) {
      return;
    }
    if (me.pickerVisible) {
      me.hidePicker();
    } else if (!me.readOnly && !me.disabled) {
      switch ((_a2 = me.triggerAction) == null ? void 0 : _a2.toLowerCase()) {
        case "all":
          me.doFilter(null, activatePicker);
          break;
        case "last":
          me.doFilter(me.lastQuery, activatePicker);
          break;
        default:
          me.doFilter(me.input.value, activatePicker);
      }
    }
  }
  /**
   * User types into input field in editable combo, show list and filter it.
   * @private
   */
  internalOnInput(event) {
    const me = this;
    me.syncEmpty();
    me.syncInputWidth();
    me.filterOnInput(event);
    me.trigger("input", { value: me.input.value, event });
  }
  filterOnInput(event) {
    const me = this, { value } = event.type === "input" ? event.target : me.input, inputLen = value.length;
    me.inputting = true;
    if (me.inlinePicker || inputLen >= me.minChars && (!me.filterOnEnter || event.key === "Enter")) {
      me.doFilter(value);
    } else {
      if (me.validateFilter && !me.remoteFilter) {
        me[inputLen ? "setError" : "clearError"](errorValidateFilter);
      }
      me.hidePicker();
    }
    me.inputting = false;
  }
  syncInputWidth() {
    const me = this;
    if (me.usesChipView) {
      const input = me.input, inputPadding = me._inputPadding || (me._inputPadding = DomHelper.getEdgeSize(input, "padding", "lr")), value = input.value || "", width = (
        // +'W' to avoid text getting clipped or horizontal scrolling
        DomHelper.measureText(value + "W", input, false, me.element) + inputPadding.width
      );
      input.style.flex = `1 1 ${Math.ceil(width)}px`;
    }
  }
  doFilter(queryString, activatePicker) {
    var _a2;
    const me = this, {
      store,
      // Force the lazy config to create picker since the List needs to add its beforeLoad listener
      picker
    } = me, disableFilter = queryString == null || queryString === "";
    me.lastQuery = queryString;
    me.primaryFilter.setConfig({
      value: queryString,
      disabled: disableFilter
    });
    if (me.remoteFilter) {
      store.clear(true);
    }
    const onAfterFilter = () => {
      const { navigator: navigator2, isVisible: isVisible2 } = picker;
      if (store.count) {
        if (!disableFilter && navigator2) {
          navigator2.activeItem = 0;
        }
      } else if (!me.remoteFilter && !disableFilter) {
        if (navigator2) {
          navigator2.activeItem = null;
        }
        if (me.validateFilter) {
          me.setError(errorValidateFilter);
        }
      }
      isVisible2 && picker.realign();
    };
    (_a2 = me.filterPromise = store.filter()) == null ? void 0 : _a2.then(() => {
      me.filterPromise = null;
      onAfterFilter();
    });
    if (!me.inlinePicker) {
      if (picker == null ? void 0 : picker.isVisible) {
        if (picker.lastAlignSpec.zone === 0) {
          picker.realign();
        }
      } else {
        me.showPicker(activatePicker);
      }
    }
    if (!me.filterPromise) {
      onAfterFilter();
    }
  }
  onStoreFilter({ source: store }) {
    const me = this, picker = me._picker, dataset = picker == null ? void 0 : picker.element.dataset, { count } = store;
    if (me.remoteFilter) {
      if (count) {
        if (picker) {
          picker.navigator.activeItem = 0;
        }
      } else {
        if (me.validateFilter) {
          me.setError(errorValidateFilter);
        }
      }
      if (me.filterSelected && me.valueCollection.count) {
        store.storage.onFiltersChanged({ action: "splice", oldCount: 1 });
        if (picker) {
          picker.refresh();
        }
      }
    }
    if (dataset) {
      if (me.createOnUnmatched && !count && me.primaryFilter.value != null) {
        dataset.addNewValue = me.L("L{addNewValue}")(me.primaryFilter.value);
      } else {
        dataset == null ? true : delete dataset.addNewValue;
      }
    }
  }
  /**
   * This reacts to our {@link #property-valueCollection} being mutated in any way.
   * The `change`, `select` and `action` events are fired here.
   *
   * This could happen in four ways:
   *
   *  - User selected or deselected an item in the dropdown list.
   *  - `set value` changes the content.
   *  - The {@link #config-multiSelect} Chip view (which uses this in its store) deletes a record.
   *  - The application programmatically mutates the {@link #property-valueCollection}.
   *
   * @private
   */
  onValueCollectionChange({ source: valueCollection }) {
    var _a2, _b, _c, _d;
    const me = this, { multiSelect, _picker } = me, hidePicker = (_a2 = me.hidePickerOnSelect) != null ? _a2 : !multiSelect, record = multiSelect ? valueCollection.values.slice() : valueCollection.first, records = valueCollection.values.slice(), isUserAction = me._isUserAction || (_picker == null ? void 0 : _picker._isUserAction) || hidePicker && me.pickerVisible || false, oldValue = me._value;
    if (hidePicker) {
      me.hidePicker();
    }
    if (!valueCollection.count && me.required) {
      me.setError(errorFieldRequired);
    } else {
      me.clearError(errorFieldRequired);
      me.clearError(errorValidateFilter);
    }
    if (me.validateFilter && record) {
      me.clearError(errorValidateFilter);
    }
    if (me.filterSelected) {
      const navigator2 = _picker == null ? void 0 : _picker.navigator, activeItem = Number((_c = (_b = navigator2 == null ? void 0 : navigator2.activeItem) == null ? void 0 : _b.dataset) == null ? void 0 : _c.index);
      if (me.remoteFilter) {
        me.store.storage.onFiltersChanged({ action: "splice", oldCount: 1 });
        if (me._picker) {
          me._picker.refresh();
        }
      } else {
        me.store.filter();
      }
      if (!isNaN(activeItem)) {
        navigator2.activeItem = Math.min(_picker.store.count, activeItem);
      }
    }
    me._value = null;
    me._lastValue = null;
    const value = me.cacheCurrentValue(me.value);
    me.syncInputFieldValue();
    me.syncEmpty();
    if (!me.isConfiguring) {
      me.triggerFieldChange({
        value,
        oldValue,
        userAction: isUserAction,
        valid: me.isValid
      });
      (_d = me.trigger) == null ? void 0 : _d.call(me, "select", { record, records, userAction: isUserAction });
      if (me.defaultAction === "select") {
        me.trigger("action", { value, record, records, userAction: isUserAction });
      }
    }
  }
  // Caching a copy of current value, which can be changed by subclasses (see AssignmentField for reference)
  cacheCurrentValue(v) {
    return this._value = v;
  }
  /**
   * This listens for when a record from the list is selected, but is already part of
   * the selection and so the {@link #property-valueCollection} rejects that as a no-op.
   * At this point, the user will still expect the picker to hide.
   * @param {Object} event The noChange event containing the splice parameters
   * @private
   */
  onValueCollectionNoChange({ toAdd }) {
    if (!this.inlinePicker && !this.multiSelect && toAdd.length && this.pickerVisible) {
      this.picker.hide();
      this.syncInputFieldValue();
    }
  }
  //endregion
  //region Picker
  showPicker() {
    var _a2;
    const me = this, { picker } = me;
    if (me.readOnly || me.inlinePicker) {
      return;
    }
    picker.multiSelect = me.multiSelect;
    super.showPicker(...arguments);
    if (me.overlayAnchor && !picker.align.offset) {
      picker.align.offset = -picker.anchorSize[1];
      picker.realign();
    }
    if (picker.restoreActiveItem) {
      if (me.multiSelect) {
        picker.restoreActiveItem(((_a2 = picker.navigator) == null ? void 0 : _a2.previousActiveItem) || me.selected || 0, true);
      } else {
        picker.restoreActiveItem(me.selected || 0, true);
      }
    }
    me.input.focus();
  }
  /**
   * Creates default picker widget
   *
   * @internal
   */
  changePicker(picker, oldPicker) {
    if (picker) {
      const me = this, pickerWidth = me.pickerWidth || (picker == null ? void 0 : picker.width), config = List.mergeConfigs({
        owner: me,
        store: me.store,
        selected: me.valueCollection,
        multiSelect: me.multiSelect,
        cls: me.listCls,
        displayField: me.displayField,
        forElement: me[me.pickerAlignElement],
        align: {
          matchSize: pickerWidth == null,
          anchor: me.overlayAnchor,
          target: me[me.pickerAlignElement],
          // Reasonable minimal height to fit few combo items below the combo.
          // When height is not enough, list will appear on top. That works for windows higher than 280px,
          // worrying about shorter windows sounds overkill.
          // We cannot use relative measures here, each combo list item is ~40px high
          minHeight: me.inlinePicker ? null : Math.min(3, me.store.count) * 40
        },
        [me.listItemTpl ? "itemTpl" : void 0]: me.listItemTpl,
        width: pickerWidth,
        navigator: {
          keyEventTarget: me.input
        }
      }, picker);
      if (me.inlinePicker) {
        Object.assign(config, {
          floating: false,
          align: null,
          activateOnMouseover: false,
          maxHeight: null,
          appendTo: me.element
        });
      }
      picker = List.reconfigure(oldPicker, picker ? config : null, me);
      picker.element.classList.add("b-combo-picker");
      picker.element.dataset.emptyText = me.emptyText ? me.L(me.emptyText) : me.L("L{noResults}");
      picker.ion({
        navigate: "onPickerNavigate",
        thisObj: me
      });
      EventHelper.on({
        element: picker.element,
        pointerdown: (event) => me.onPickerNavigate({ event }),
        thisObj: me
      });
    } else {
      oldPicker == null ? void 0 : oldPicker.destroy();
    }
    return picker;
  }
  onPickerNavigate({ event }) {
    if (event.target.matches("[data-add-new-value]")) {
      this.addNewRecord(this.primaryFilter.value);
    }
  }
  onPickerHide() {
    const me = this;
    super.onPickerHide();
    if (me.multiSelect && me.clearTextOnPickerHide) {
      me.input.value = "";
    }
  }
  //endregion
  async internalOnKeyEvent(keyEvent) {
    var _a2;
    const me = this, value = me.input[me.inputValueAttr], inputLen = value.length, { key } = keyEvent, {
      primaryFilter,
      store,
      _picker: picker,
      multiSelect
    } = me;
    if (keyEvent.type === "keydown" && (picker == null ? void 0 : picker.isVisible) && picker.navigator) {
      const { activeItem } = picker.navigator;
      if (activeItem && multiSelect && key === me.multiValueSeparator) {
        me.input.value = "";
        primaryFilter.setConfig({
          value: "",
          disabled: true
        });
        store.filter();
        picker.onItemClick(activeItem, keyEvent);
        picker.hide();
        keyEvent.preventDefault();
        return;
      }
      if (!activeItem && me.createOnUnmatched && (multiSelect && key === me.multiValueSeparator || key === "Enter")) {
        keyEvent.preventDefault();
        await me.addNewRecord(value);
        return;
      }
    }
    if (!me.editable && me.pickerVisible) {
      if (key === "Backspace" && ((_a2 = primaryFilter.value) == null ? void 0 : _a2.length)) {
        primaryFilter.value = primaryFilter.value.substring(0, primaryFilter.value.length - 1);
        me.store.filter();
        picker.restoreActiveItem(0);
      } else if (keyEvent.type == "keypress" && key.match(filterKeyTypes)) {
        if (!me.lastFilterKepressTime || keyEvent.timeStamp - me.lastFilterKepressTime > 2e3) {
          primaryFilter.value = "";
        }
        primaryFilter.setConfig({
          value: (primaryFilter.value || "") + key,
          disabled: false
        });
        me.store.filter();
        picker.restoreActiveItem(0);
      }
      me.lastFilterKepressTime = keyEvent.timeStamp;
    }
    super.internalOnKeyEvent(...arguments);
    if (keyEvent.type === "keydown" && key === "Enter" && me.filterOnEnter && inputLen >= me.minChars) {
      keyEvent.stopPropagation();
      me.filterOnInput.now(keyEvent);
    }
  }
  async addNewRecord(value) {
    var _a2, _b;
    const me = this, {
      store,
      _picker: picker,
      valueCollection,
      multiSelect,
      primaryFilter
    } = me, remoteAutoCommit = store.remoteFilter && store.autoCommit;
    if (me.filterPromise) {
      await me.filterPromise;
    }
    if (!remoteAutoCommit) {
      primaryFilter.setConfig({
        value: "",
        disabled: true
      });
      store.filter();
    }
    const [newRecord] = store.add(me.callback(me.createOnUnmatched, me, [value, me]));
    if (store.isCommitting) {
      let error;
      try {
        await store.commitPromise;
      } catch (exception) {
        error = (_b = (_a2 = exception.response) == null ? void 0 : _a2.parsedJson) == null ? void 0 : _b.error;
      }
      if (newRecord.isPhantom) {
        me.clearError();
        me.setError(error || errorRecordNotCommitted, false, true);
        store.remove(newRecord);
        store.removed.remove(newRecord);
      }
    }
    if (remoteAutoCommit) {
      primaryFilter.setConfig({
        value: "",
        disabled: true
      });
      store.filter();
    }
    me.input.value = "";
    if (store.includes(newRecord)) {
      valueCollection.splice(multiSelect ? valueCollection.count : 0, multiSelect ? 0 : valueCollection.count, newRecord);
    }
    picker == null ? void 0 : picker.hide();
  }
  changeCreateOnUnmatched(createOnUnmatched) {
    if (createOnUnmatched === true) {
      createOnUnmatched = this.defaultRecordCreater;
    }
    return createOnUnmatched;
  }
  defaultRecordCreater(value) {
    return this.store.createRecord({
      [this.displayField]: value
    });
  }
  updateLocalization() {
    var _a2;
    super.updateLocalization();
    const me = this, { displayField } = me;
    let { localizedDisplayFieldsMap } = me;
    if (me.localizeDisplayFields === true) {
      if (!localizedDisplayFieldsMap) {
        me.localizedDisplayFieldsMap = localizedDisplayFieldsMap = /* @__PURE__ */ new Map();
      }
      if (!me.store && me.buildItems) {
        me.items = me.buildItems();
      }
      for (const item of me.items) {
        if (item.id) {
          let localeString = localizedDisplayFieldsMap.get(item.id);
          if (!localeString && ((_a2 = item[displayField]) == null ? void 0 : _a2.startsWith("L{"))) {
            localeString = item[displayField];
            localizedDisplayFieldsMap.set(item.id, localeString);
          }
          if (localeString) {
            item[displayField] = me.L(localeString);
          }
        }
      }
      me.syncInputFieldValue();
    }
  }
};
//region Config
__publicField(Combo, "$name", "Combo");
__publicField(Combo, "type", "combo");
__publicField(Combo, "alias", "combobox,dropdown");
__publicField(Combo, "delayable", {
  filterOnInput: 0
});
var ComboChipView = class extends ChipView {
  static get $name() {
    return "ComboChipView";
  }
  static get type() {
    return "combochipview";
  }
  static get defaultConfig() {
    return {
      closeHandler: "up.onChipClose",
      itemsFocusable: false,
      multiSelect: true,
      itemTpl(record) {
        return StringHelper.encodeHtml(record.getValue(this.owner.displayField));
      },
      scrollable: {
        overflowY: "auto"
      }
    };
  }
};
var ComboChipNavigator = class extends Navigator {
  static get $name() {
    return "ComboChipNavigator";
  }
  // Factoryable type name
  static get type() {
    return "combochipnavigator";
  }
  static get configurable() {
    return {
      allowShiftKey: true
    };
  }
  onTargetClick(clickEvent) {
    const me = this, item = clickEvent.target.closest(me.itemSelector);
    if (item && !clickEvent.target.classList.contains("b-close-icon")) {
      if (!clickEvent.shiftKey && !item.contains(clickEvent.target.closest("[data-noselect]"))) {
        me.ownerCmp.selected.clear();
      }
      me.inClickHandler = true;
      me.activeItem = item;
      me.inClickHandler = false;
    }
  }
  onKeyDown(keyEvent) {
    if (keyEvent.key !== "Enter" && !keyEvent.target.selectionStart && !keyEvent.target.selectionEnd) {
      super.onKeyDown(keyEvent);
    }
  }
  updateActiveItem(activeItem, oldActiveItem) {
    const chipView = this.ownerCmp;
    super.updateActiveItem(activeItem, oldActiveItem);
    if (activeItem && !this.inClickHandler) {
      chipView.selected.add(chipView.getRecordFromElement(activeItem));
    }
  }
  navigatePrevious(keyEvent) {
    const chipView = this.ownerCmp;
    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.previous) {
      super.navigatePrevious(keyEvent);
    } else {
      this.activeItem = null;
    }
  }
  navigateNext(keyEvent) {
    const chipView = this.ownerCmp;
    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.next) {
      super.navigateNext(keyEvent);
    } else {
      this.activeItem = null;
    }
  }
};
Combo.initClass();
ComboChipView.initClass();
ComboChipNavigator.initClass();
Combo._$name = "Combo";

// ../Core/lib/Core/widget/Checkbox.js
var whenNotChecked = (field) => !field.value;
var Checkbox = class extends Field {
  static get configurable() {
    return {
      inputType: "checkbox",
      /**
       * Specify `true` to automatically {@link Core.widget.FieldContainer#config-collapsed collapse} the field's
       * {@link #config-container} when the field is not {@link #property-checked}.
       *
       * Alternatively, this can be a function that returns the desired `collapse` state when passed the field
       * instance as its one parameter.
       *
       * @config {Boolean|Function}
       * @returns {Boolean}
       * @default false
       */
      autoCollapse: null,
      containerDefaults: {
        syncableConfigs: {
          disabled: (field) => field.disabled || !field.value
        },
        syncConfigTriggers: {
          autoCollapse: 1,
          value: 1
        }
      },
      /**
       * Get/set label
       * @member {String} name
       */
      /**
       * Text to display on checkbox label
       * @config {String}
       */
      text: "",
      /**
       * The value to provide for this widget in {@link Core.widget.Container#property-values} when it is
       * {@link #property-checked}.
       * A value of `undefined` will cause this widget not to include its value when checked.
       * @config {*}
       * @default
       */
      checkedValue: true,
      /**
       * The value to provide for this widget in {@link Core.widget.Container#property-values} when it is not
       * {@link #property-checked}.
       *
       * A value of `undefined` will cause this widget to not include its value when it is unchecked.
       * @config {*}
       * @default
       */
      uncheckedValue: false,
      /**
       * The checked state. The same as `value`.
       * @config {Boolean} checked
       */
      /**
       * Checkbox color, must have match in CSS
       * @config {String}
       */
      color: null,
      /**
       * Get/set value
       * @member {String} value
       */
      /**
       * Sets input fields value attribute
       * @config {String}
       */
      value: "",
      toggleGroup: null,
      localizableProperties: ["label", "text"]
    };
  }
  //endregion
  //region Init
  construct(config) {
    if ("checked" in config) {
      config = ObjectHelper.assign({}, config);
      config.value = config.checked;
      delete config.checked;
    }
    super.construct(config);
    this.syncHasText();
  }
  get textLabelCls() {
    return "b-checkbox-label";
  }
  // Implementation needed at this level because it has two inner elements in its inputWrap
  get innerElements() {
    return [
      this.inputElement,
      {
        tag: "label",
        class: this.textLabelCls,
        for: `${this.id}-input`,
        reference: "textLabel",
        html: this.text || ""
      }
    ];
  }
  get inputElement() {
    const config = super.inputElement;
    if (this.toggleGroup) {
      config.dataset = {
        group: this.toggleGroup
      };
    }
    config.listeners = {
      click: "internalOnClick",
      change: "internalOnChange",
      input: "internalOnInput"
    };
    return config;
  }
  //endregion
  //region Toggle
  /**
   * Get/set checked state. Equivalent to `value` config.
   * @property {Boolean}
   */
  get checked() {
    return this.value;
  }
  set checked(value) {
    this.value = value;
  }
  syncHasText() {
    this.element.classList[this.text ? "add" : "remove"]("b-text");
  }
  updateText(value) {
    if (this.textLabel) {
      this.syncHasText();
      this.textLabel.innerHTML = value;
    }
  }
  afterSyncChildConfigs(container) {
    super.afterSyncChildConfigs(container);
    let { autoCollapse } = this;
    if (autoCollapse) {
      autoCollapse = autoCollapse === true ? whenNotChecked : autoCollapse;
      container.collapsed = autoCollapse(this);
    }
  }
  assignFieldValue(values, key, value) {
    this.value = value === this.checkedValue || (value === this.uncheckedValue ? false : null);
  }
  fetchInputValue() {
    if (!this.readOnly) {
      this.value = this.input.checked;
    }
  }
  gatherValue(values) {
    var _a2;
    const me = this, value = me.value ? me.checkedValue : me.uncheckedValue, storedValue = value !== void 0, { valueName } = me;
    if (storedValue) {
      values[valueName] = value;
    }
    me.gatherValues(values, storedValue);
    if (value === true && ((_a2 = values[valueName]) == null ? void 0 : _a2.value) === value) {
      delete values[valueName].value;
    }
  }
  changeValue(value) {
    return value === "false" ? false : Boolean(value);
  }
  updateValue(value) {
    var _a2;
    const me = this, changed = me.input.checked !== value;
    me.input.checked = value;
    (_a2 = me.container) == null ? void 0 : _a2.syncChildConfigs();
    if (changed && !me.inputting && !me.isConfiguring) {
      me.uncheckToggleGroupMembers();
      me.triggerChange(false, null);
    }
  }
  get inputValueAttr() {
    return "checked";
  }
  updateColor(value, was) {
    const classes = this.element.classList;
    if (was) {
      classes.remove(was);
    }
    if (value) {
      classes.add(value);
    }
  }
  getToggleGroupMembers() {
    const me = this, { checked, toggleGroup, input: checkedElement, type } = me, result = [];
    if (checked && toggleGroup) {
      DomHelper.forEachSelector(me.rootElement, `input[type=${type}][data-group=${toggleGroup}]`, (inputEl) => {
        if (inputEl !== checkedElement) {
          const partnerCheckbox = Widget.fromElement(inputEl);
          partnerCheckbox && result.push(partnerCheckbox);
        }
      });
    }
    return result;
  }
  uncheckToggleGroupMembers() {
    if (this.checked && this.toggleGroup) {
      this.getToggleGroupMembers().forEach((widget) => widget.checked = false);
    }
  }
  /**
   * Check the box
   */
  check() {
    this.checked = true;
  }
  /**
   * Uncheck the box
   */
  uncheck() {
    this.checked = false;
  }
  /**
   * Toggle checked state. If you want to force a certain state, assign to {@link #property-checked} instead.
   */
  toggle() {
    this.checked = !this.checked;
  }
  //endregion
  //region Events
  internalOnClick(event) {
    if (this.readOnly) {
      event.preventDefault();
      return false;
    }
    return this.trigger("click", { event });
  }
  /**
   * Triggers events when user toggles the checkbox
   * @fires beforeChange
   * @fires change
   * @fires action
   * @private
   */
  internalOnChange(event) {
    const me = this;
    if (me.readOnly && me.value !== me.input.checked) {
      me.input.checked = me.value;
      return;
    }
    me.value = me.input.checked;
    if (!me.inputting) {
      me.inputting = true;
      me.triggerChange(true, event);
      me.inputting = false;
    }
  }
  // Need to catch changes even if readOnly, because of chrome behaviour when re-enabling
  updateInputReadOnly(readOnly) {
  }
  /**
   * Triggers events when checked state is changed
   * @fires beforeChange
   * @fires change
   * @fires action
   * @private
   */
  triggerChange(userAction, event) {
    const me = this, { checked } = me.input;
    const eventObject = { checked, value: checked, oldValue: !checked, userAction, valid: true, event }, prevented = !checked && userAction && me.toggleGroup && me.getToggleGroupMembers().filter((widget) => widget.isVisible && !widget.disabled).length || // Since Widget has Events mixed in configured with 'callOnFunctions' this will also call onBeforeChange,
    // onChange and onAction
    me.trigger("beforeChange", eventObject) === false;
    if (prevented) {
      me.input.checked = me._value = !checked;
    } else {
      me.triggerFieldChange(eventObject, false);
      if (userAction) {
        me.uncheckToggleGroupMembers();
      }
      me.trigger("action", eventObject);
      me.trigger("change", eventObject);
      return true;
    }
  }
  //endregion
};
//region Config
__publicField(Checkbox, "$name", "Checkbox");
__publicField(Checkbox, "type", "checkbox");
__publicField(Checkbox, "alias", "check");
Checkbox.initClass();
Checkbox._$name = "Checkbox";

// ../Core/lib/Core/widget/ColorPicker.js
var ColorPicker = class extends List {
  configure(config) {
    super.configure(config);
    this.setItems();
    this.ion({
      item: "onColorSelect"
    });
  }
  setItems() {
    const me = this, { colors, colorClasses } = me;
    let useColors = colorClasses || colors;
    if (me.addNoColorItem) {
      useColors = [...useColors];
      useColors.push(null);
    }
    me.items = useColors.map((color) => !color || typeof color == "string" ? { color, text: (colorClasses ? StringHelper.capitalize(color) : color) || me.L("L{noColor}") } : color);
  }
  afterConfigure() {
    var _a2;
    super.afterConfigure(...arguments);
    if (this.addNoColorItem || this.value) {
      this.select((_a2 = this.value) != null ? _a2 : null);
    }
  }
  updateColors() {
    if (!this.isConfiguring) {
      this.setItems();
    }
  }
  updateAddNoColorItem() {
    if (!this.isConfiguring) {
      this.setItems();
    }
  }
  onColorSelect({ record }) {
    var _a2;
    this.refresh();
    const event = { color: record.color, record, bubbles: true };
    (_a2 = this.colorSelected) == null ? void 0 : _a2.call(this, event);
    this.trigger("colorSelected", event);
  }
  select(value) {
    if (!value || typeof value === "string") {
      value = this.store.findRecord("color", value != null ? value : null);
    }
    value && super.select(value);
  }
  updateColumns(columns) {
    this.style = `grid-template-columns:repeat(${columns}, 1fr);`;
  }
  getColorClassName(color) {
    var _a2, _b;
    if (((_a2 = this.colorClasses) == null ? void 0 : _a2.includes(color)) || ((_b = this.colorClasses) == null ? void 0 : _b.find((r) => r && r.color === color))) {
      return this.colorClassPrefix + color;
    }
    return color ? "" : "b-no-color";
  }
};
__publicField(ColorPicker, "$name", "ColorPicker");
__publicField(ColorPicker, "type", "colorpicker");
__publicField(ColorPicker, "configurable", {
  itemsFocusable: false,
  navigator: {
    focusCls: "b-color-active"
  },
  itemWrapperTpl(record, i) {
    const { selected } = this, { color, text } = record, colorClassName = this.getColorClassName(color);
    return TemplateHelper.tpl`
                    <li
                        class="${this.getItemClasses(record, i)} ${colorClassName}"
                        role="option"
                        aria-selected="${selected.includes(record)}"
                        data-index="${i}"
                        data-id="${StringHelper.encodeHtml(color)}"
                        data-btip="${text}"
                        ${this.itemsFocusable ? 'tabindex="-1"' : ""}
                        style="${colorClassName ? "" : "background-color: " + color}"
                    ></li>`;
  },
  /**
   * Array of internal color class names, without prefix, like `red`, `violet` etc. If specified, this will
   * take precedence over {@link #config-colors}.
   * @config {String[]}
   * @private
   */
  colorClasses: null,
  /**
   * Prefix to be inserted before the color class names in {@link #config-colorClasses}, like `b-sch-`
   * @config {String}
   * @private
   */
  colorClassPrefix: null,
  /**
   * Array of CSS color strings from which the user can chose from.
   *
   * Provide an array of string CSS colors:
   * ```javascript
   * new ColorMenu({
   *     colors : ['#00FFFF', '#F0FFFF', '#89CFF0', '#0000FF', '#7393B3']
   * });
   * ```
   *
   * The colors can also be named. To do that, put them in an object with a `color` and a `text` property, like:
   * ```javascript
   * new ColorMenu({
   *    colors : [
   *        { color : '#000000', text : 'Black'},
   *        { color : '#FF0000', text : 'Red'},
   *        { color : '#00FF00', text : 'Green'},
   *        { color : '#0000FF', text : 'Blue'},
   *        { color : '#FFFFFF', text : 'White'},
   *    ]
   * });
   * ```
   *
   * Default colors are:
   * <div class="b-colorbox b-inline" style="background-color: #45171D"></div>#45171D
   * <div class="b-colorbox b-inline" style="background-color: #F03861"></div>#F03861
   * <div class="b-colorbox b-inline" style="background-color: #FF847C"></div>#FF847C
   * <div class="b-colorbox b-inline" style="background-color: #FECEA8"></div>#FECEA8
   * <div class="b-colorbox b-inline" style="background-color: #A5F2E7"></div>#A5F2E7
   * <div class="b-colorbox b-inline" style="background-color: #AA83F3"></div>#AA83F3
   * <div class="b-colorbox b-inline" style="background-color: #8983F3"></div>#8983F3
   * <div class="b-colorbox b-inline" style="background-color: #A10054"></div>#A10054
   * <div class="b-colorbox b-inline" style="background-color: #073059"></div>#073059
   * <div class="b-colorbox b-inline" style="background-color: #2866AB"></div>#2866AB
   * <div class="b-colorbox b-inline" style="background-color: #5FBDC5"></div>#5FBDC5
   * <div class="b-colorbox b-inline" style="background-color: #D8D95C"></div>#D8D95C
   * <div class="b-colorbox b-inline" style="background-color: #FFDEDE"></div>#FFDEDE
   * <div class="b-colorbox b-inline" style="background-color: #F7F3CE"></div>#F7F3CE
   * <div class="b-colorbox b-inline" style="background-color: #C5ECBE"></div>#C5ECBE
   * <div class="b-colorbox b-inline" style="background-color: #3E3E3E"></div>#3E3E3E
   * <div class="b-colorbox b-inline" style="background-color: #405559"></div>#405559
   * <div class="b-colorbox b-inline" style="background-color: #68868C"></div>#68868C
   * <div class="b-colorbox b-inline" style="background-color: #EDEDED"></div>#EDEDED
   * <div class="b-colorbox b-inline" style="background-color: #D3D6DB"></div>#D3D6DB
   * <div class="b-colorbox b-inline" style="background-color: #3A4750"></div>#3A4750
   * <div class="b-colorbox b-inline" style="background-color: #303841"></div>#303841
   * <div class="b-colorbox b-inline" style="background-color: #BE3144"></div>#BE3144
   * @prp {String[]}
   */
  colors: [
    "#45171D",
    "#F03861",
    "#FF847C",
    "#FECEA8",
    "#A5F2E7",
    "#AA83F3",
    "#8983F3",
    "#A10054",
    "#073059",
    "#2866AB",
    "#5FBDC5",
    "#D8D95C",
    "#FFDEDE",
    "#F7F3CE",
    "#C5ECBE",
    "#3E3E3E",
    "#405559",
    "#68868C",
    "#EDEDED",
    "#D3D6DB",
    "#3A4750",
    "#303841",
    "#BE3144"
  ],
  /**
   * Adds an option to set no background color
   * @prp {Boolean}
   */
  addNoColorItem: true,
  /**
   * The color items is displayed in a grid layout with 6 columns as default. Change this to another number to
   * affect appearance.
   * @prp {Number}
   */
  columns: 6,
  /**
   * A callback function that will be called when the user selects a color in the picker.
   * @param {Object} event Object containing event data
   * @param {Core.data.Model} event.record The selected color's record instance
   * @param {String} event.color The string color value
   * @config {Function}
   * @returns {void}
   */
  colorSelected: null
});
ColorPicker.initClass();
ColorPicker._$name = "ColorPicker";

// ../Core/lib/Core/widget/layout/Fit.js
var Fit = class extends Layout {
};
__publicField(Fit, "$name", "Fit");
__publicField(Fit, "type", "fit");
__publicField(Fit, "configurable", {
  containerCls: "b-fit-container",
  itemCls: "b-fit-item"
});
Fit.initClass();
Fit._$name = "Fit";

// ../Core/lib/Core/widget/Editor.js
var Editor = class extends Container {
  //endregion
  //region Events
  /**
   * Fired before the editor is shown to start an edit operation. Returning `false` from a handler vetoes the edit operation.
   * @event beforeStart
   * @param {HTMLElement} target The element which the Editor is to overlay to edit its content.
   * @param {Core.data.Model} [record] The record being edited.
   * @param {String} [field] The name of the field if a record is being edited.
   * @param {Object} value - The value to be edited.
   * @param {String|AlignSpec} align - How to align the editor.
   * @param {Boolean} hideTarget `true` if the target is to be hidden during the edit.
   * @param {Boolean|Object} matchSize Whether to match the target size. See {@link #config-matchSize}
   * @param {Boolean} matchSize.width Match width
   * @param {Boolean} matchSize.height Match height
   * @param {Boolean} matchFont Whether to match the target's font. See {@link #config-matchFont}
   * @param {Boolean} focus Whether to focus the editor's field.
   * @preventable
   */
  /**
   * Fired when an edit operation has begun.
   * @event start
   * @param {Object} value - The starting value of the field.
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fired when an edit completion has been requested, either by `ENTER`, or focus loss (if configured to complete on blur).
   * The completion may be vetoed, in which case, focus is moved back into the editor.
   * @event beforeComplete
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The new value.
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   * @param {Function} [finalize] An async function may be injected into this property
   * which performs asynchronous finalization tasks such as complex validation of confirmation. The
   * value `true` or `false` must be returned.
   * @param {Object} [finalize.context] An object describing the editing context upon requested completion of the edit.
   * @preventable
   */
  /**
   * Edit has been completed, and any associated record or element has been updated.
   * @event complete
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The new value.
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fired when cancellation has been requested, either by `ESC`, or focus loss (if configured to cancel on blur).
   * The cancellation may be vetoed, in which case, focus is moved back into the editor.
   * @event beforeCancel
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The new value.
   * @param {Event} event - Included if the cancellation was triggered by a DOM event
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   * @preventable
   */
  /**
   * Edit has been canceled without updating the associated record or element.
   * @event cancel
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The value of the field.
   * @param {Event} event - Included if the cancellation was triggered by a DOM event
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fire to relay a `keypress` event from the field.
   * @event keypress
   * @param {Event} event - The key event.
   */
  //endregion
  afterConfigure() {
    const me = this;
    super.afterConfigure();
    me.onTargetSizeChange = me.onTargetSizeChange.bind(me);
    EventHelper.on({
      element: me.element,
      keydown: "onKeyDown",
      contextmenu: "stopMouseEvents",
      mousedown: "stopMouseEvents",
      mouseover: "stopMouseEvents",
      mouseout: "stopMouseEvents",
      mouseup: "stopMouseEvents",
      click: "stopMouseEvents",
      dblclick: "stopMouseEvents",
      thisObj: me
    });
    me.ion({
      beforeHide: "beforeEditorHide",
      hide: "afterEditorHide",
      thisObj: me
    });
    LocaleManager_default.ion({
      locale: "onLocaleChange",
      thisObj: me
    });
  }
  onLocaleChange() {
    const { inputField } = this;
    if (inputField && !inputField.isDestroyed) {
      if (inputField.syncInputFieldValue) {
        inputField.syncInputFieldValue(true);
      } else if (!(inputField instanceof Field)) {
      }
    }
  }
  render(renderTo) {
    const oldParent = this.element.parentNode, [parentElement] = this.getRenderContext(this, renderTo);
    parentElement.classList.add("b-editing");
    super.render(...arguments);
    if ((oldParent == null ? void 0 : oldParent.classList) && parentElement !== oldParent) {
      oldParent.classList.remove("b-editing");
    }
  }
  /**
   * Start editing
   * @param {Object} editObject An object containing details about what to edit.
   * @param {HTMLElement|Core.helper.util.Rectangle} editObject.target the element or Rectangle to align to.
   * @param {String} [editObject.align=t0-t0] How to align to the target.
   * @param {Boolean} [editObject.matchSize=true] Match editor size to target size.
   * @param {Boolean} [editObject.matchFont=true] Match editor's font-size size to target's font-size.
   * @param {Core.data.Model} [editObject.record] The record to edit.
   * @param {String} [editObject.field] The field name in the record to edit. This defaults to the `name` of the
   * {@link #config-inputField}. Also if record has method set + capitalized field, method will be called, e.g. if
   * record has method named `setFoobar` and this config is `foobar`, then instead of `record.foobar = value`,
   * `record.setFoobar(value)` will be called.
   * @param {Object} [editObject.value] The value to edit.
   * @param {Boolean} [editObject.focus=true] Focus the field.
   * @param {Boolean} [editObject.fitTargetContent] Pass `true` to allow the Editor to expand beyond the width of its
   * target element if its content overflows horizontally. This is useful if the editor has triggers to display, such
   * as a combo.
   * @returns {Promise} Resolved promise returns`true` if editing has been started, `false` if an
   * {@link #event-beforeStart} listener has vetoed the edit.
   */
  async startEdit(editObject) {
    var _a2, _b, _c;
    const me = this;
    editObject = ObjectHelper.assignIf(editObject, {
      align: me.align,
      hideTarget: me.hideTarget,
      matchSize: me.matchSize,
      matchFont: me.matchFont,
      fitTargetContent: me.fitTargetContent,
      focus: true
    });
    if (me.trigger("beforeStart", editObject) !== false) {
      const {
        target,
        hideTarget,
        matchSize,
        matchFont,
        fitTargetContent,
        record,
        field = me.inputField.name,
        focus
      } = editObject, { inputField } = me, { input } = inputField, targetFontSize = DomHelper.getStyleValue(target, "font-size"), targetFontFamily = DomHelper.getStyleValue(target, "font-family");
      let { value, align } = editObject;
      if (record && field) {
        me.record = record;
        me.dataField = field;
        if (value === void 0) {
          value = record.getValue(field);
        }
      }
      if (matchSize) {
        if (target instanceof HTMLElement) {
          me.updateSize(target, matchSize);
        }
        if (target instanceof HTMLElement) {
          ResizeMonitor.addResizeListener(target, me.onTargetSizeChange);
        }
      }
      if (input) {
        if (matchFont) {
          input.style.fontSize = targetFontSize;
          input.style.fontFamily = targetFontFamily;
        } else {
          input.style.fontSize = input.style.fontFamily = "";
        }
      }
      me.assigningValues = true;
      (_a2 = inputField.clearError) == null ? void 0 : _a2.call(inputField);
      if ("setValue" in inputField) {
        await inputField.setValue(value);
      } else {
        inputField.value = value;
      }
      me.assigningValues = false;
      if (typeof align === "string") {
        align = { align };
      }
      await me.showBy({
        target,
        allowTargetOut: true,
        ...align
      });
      if (fitTargetContent) {
        const overflow = input.scrollWidth - input.clientWidth;
        if (overflow > 0) {
          me.width += overflow + DomHelper.scrollBarWidth;
        }
      }
      focus && ((_b = inputField.focus) == null ? void 0 : _b.call(inputField));
      if (target.nodeType === Element.ELEMENT_NODE) {
        if (hideTarget) {
          target.classList.add("b-hide-visibility");
        }
      }
      me.editing = true;
      const convertedValue = inputField.value;
      me.trigger("start", { value: convertedValue });
      if (Array.isArray(convertedValue) && inputField.editingRecords && ((_c = convertedValue[0]) == null ? void 0 : _c.isModel)) {
        me.oldValue = convertedValue.map((record2) => record2.copy(record2.id));
      } else {
        me.oldValue = convertedValue;
        if (Array.isArray(me.oldValue)) {
          me.oldValue = me.oldValue.slice();
        }
      }
      inputField.initialValue = me.oldValue;
      return true;
    }
    return false;
  }
  async refreshEdit() {
    if (this.isVisible) {
      const { record, dataField, inputField } = this;
      if (record && dataField) {
        const value = record.getValue(dataField);
        if (!ObjectHelper.isEqual(inputField.value, value)) {
          await inputField.setValue(value);
        }
      }
    }
  }
  finishEdit() {
    const { target, aligningToElement } = this.lastAlignSpec;
    if (aligningToElement) {
      target.classList.remove("b-editing");
      target.classList.remove("b-hide-visibility");
    }
    this.editing = false;
    this.trigger("finishEdit");
  }
  onKeyDown(event) {
    var _a2;
    const me = this;
    switch (event.key) {
      case me.completeKey:
        me.completeEdit(null, event);
        event.stopImmediatePropagation();
        break;
      case me.cancelKey:
        me.cancelEdit(event);
        event.stopImmediatePropagation();
        break;
    }
    (_a2 = me.trigger) == null ? void 0 : _a2.call(me, "keydown", { event });
  }
  stopMouseEvents(e) {
    if (!this.allowMouseEvents) {
      e.stopPropagation();
    }
  }
  onFocusOut(event) {
    super.onFocusOut(event);
    const me = this;
    if (!me.isFinishing && me.editing) {
      switch (me.blurAction) {
        case "cancel":
          me.cancelEdit(event);
          break;
        case "complete":
          me.completeEdit(null, event);
      }
    }
  }
  /**
   * Complete the edit, and, if associated with a record, update the record if possible.
   * If editing is completed, the editor is hidden.
   *
   * If the field is invalid, the `{@link #config-invalidAction}` config is used to decide
   * upon the course of action.
   *
   * If a {@link #event-beforeComplete} handler returns `false` then editing is not completed.
   *
   * If the field's values has not been changed, then editing is terminated through {@link #function-cancelEdit}.
   *
   * @returns {Boolean} `true` if editing ceased, `false` if the editor is still active.
   */
  async completeEdit(finalize, triggeredByEvent) {
    var _a2, _b, _c, _d;
    const me = this, { inputField, oldValue, record } = me, invalidAction = inputField.invalidAction || (inputField.allowInvalid === false ? "block" : me.invalidAction), { value } = inputField;
    if (!me.isVisible) {
      return;
    }
    if (!inputField.isValid && invalidAction !== "allow") {
      if (invalidAction === "block") {
        (_a2 = inputField.focus) == null ? void 0 : _a2.call(inputField);
        return false;
      } else if (invalidAction === "revert") {
        return me.cancelEdit(triggeredByEvent) !== false;
      }
    } else if (ObjectHelper.isEqual(value, oldValue)) {
      return me.cancelEdit(triggeredByEvent) !== false;
    } else {
      const context = { inputField, record, value, oldValue };
      if (me.trigger("beforeComplete", context) === false) {
        (_b = inputField.focus) == null ? void 0 : _b.call(inputField);
      } else {
        if (!finalize) {
          finalize = context.finalize || ((_c = context.editorContext) == null ? void 0 : _c.finalize);
        }
        if (finalize) {
          let result = await finalize(context);
          if (result === true) {
            me.onEditComplete();
          } else {
            if (inputField.setError) {
              const error = result || inputField.invalidValueError, clearError = () => {
                listeners();
                inputField.clearError(error);
              }, listeners = inputField.ion({
                change: clearError,
                input: clearError
              });
              inputField.setError(error);
            }
            if (invalidAction === "block") {
              (_d = inputField.focus) == null ? void 0 : _d.call(inputField);
            } else if (invalidAction === "revert") {
              await inputField.setValue(oldValue);
              result = true;
            }
            result = false;
          }
          return result;
        } else {
          me.onEditComplete();
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Cancel the edit and hide the editor.
   */
  cancelEdit(triggeredByEvent) {
    var _a2;
    const me = this, { inputField, oldValue } = me, { value } = inputField;
    if (me.editing && !me.isFinishing && me.trigger("beforeCancel", { value, oldValue, event: triggeredByEvent }) !== false) {
      (_a2 = inputField.clearError) == null ? void 0 : _a2.call(inputField);
      me.isFinishing = true;
      me.hide();
      me.trigger("cancel", { value, oldValue, event: triggeredByEvent });
      me.finishEdit();
      me.isFinishing = false;
    } else {
      return false;
    }
  }
  // Handle updating what needs to be updated.
  onEditComplete() {
    const me = this, { record, dataField, inputField, oldValue } = me, { value } = inputField;
    if (!me.isFinishing) {
      me.isFinishing = true;
      me.hide();
      if (record) {
        const setterName = `set${StringHelper.capitalize(dataField)}`;
        if (record[setterName]) {
          record[setterName](value);
        } else {
          record.setValue(dataField, value);
        }
      }
      me.trigger("complete", { value, oldValue });
      me.finishEdit();
      me.isFinishing = false;
    }
  }
  doDestroy() {
    if (this.createdInputField) {
      this.inputField.destroy();
    }
    super.doDestroy();
  }
  set owner(owner) {
    this._owner = owner;
  }
  // This is a positioned widget appended to a Widget's contentElement. It may have no owner link.
  // Grab the owner by finding what widget it is inside.
  get owner() {
    return this._owner || Widget.fromElement(this.element.parentNode);
  }
  changeInputField(inputField, oldInputField) {
    const me = this;
    if (oldInputField) {
      oldInputField.destroy();
    }
    if (typeof inputField === "string") {
      inputField = {
        type: inputField
      };
    }
    if (!(inputField instanceof Widget)) {
      inputField = Widget.create(inputField);
      me.createdInputField = true;
    }
    if (me.completeOnChange) {
      inputField.ion({
        change: "onInputFieldChange",
        thisObj: me
      });
    }
    inputField.parent = me;
    return inputField;
  }
  updateInputField(inputField) {
    this.removeAll();
    this.add(inputField);
  }
  get inputField() {
    return this.items[0];
  }
  onInputFieldChange() {
    if (this.containsFocus) {
      this.completeEdit();
    }
  }
  onTargetSizeChange(resizedElement, oldRect, newRect) {
    if (oldRect && newRect) {
      this.updateSize(resizedElement);
    }
  }
  updateSize(targetEl, matchSize = this.lastMatchSize) {
    const me = this, rect = Rectangle.inner(targetEl);
    me.width = matchSize.width === false ? "auto" : rect.width - me.align.offset[0];
    me.height = matchSize.height === false ? "auto" : rect.height;
    me.lastMatchSize = matchSize;
  }
  beforeEditorHide() {
    if (this.editing && !this.isFinishing) {
      this.cancelEdit();
      return false;
    }
  }
  afterEditorHide() {
    if (this.positioned) {
      this.element.remove();
    }
    ResizeMonitor.removeResizeListener(this.lastAlignSpec.target, this.onTargetSizeChange);
  }
};
//region Config
__publicField(Editor, "$name", "Editor");
__publicField(Editor, "type", "editor");
__publicField(Editor, "configurable", {
  positioned: true,
  hidden: true,
  layout: "fit",
  /**
   * The alignment config for how this editor aligns to a target when asked to {@link #function-startEdit}
   * @config {AlignSpec}
   * @default
   */
  align: {
    align: "t0-t0",
    offset: [0, 0]
  },
  /**
   * Controls whether to hide the target element when asked to {@link #function-startEdit}
   * @config {Boolean}
   * @default
   */
  hideTarget: false,
  /**
   * By default, an Editor matches both dimensions, width and height of the element it is targeted at in the
   * {@link #function-startEdit} function.
   *
   * Configure this as false to allow the editor's configured dimensions, or its CSS-imposed dimensions size it.
   *
   * This may also operate with more granularity by specifying both dimensions in an object:
   *
   * ```javascript
   *     // Editor can exceed its target's height
   *     matchSize : {
   *         width  : true,
   *         height : false
   *     }
   * ```
   * @config {Boolean|Object}
   * @property {Boolean} width `true` to match width
   * @property {Boolean} height `true`to match height
   * @default
   */
  matchSize: true,
  /**
   * Controls whether the editor should match target element's font when asked to {@link #function-startEdit}
   * @config {Boolean}
   * @default
   */
  matchFont: true,
  /**
   * Controls whether the editor should expand its width if the input field has overflow {@link #function-startEdit}
   * @config {Boolean}
   * @default
   */
  fitTargetContent: false,
  /**
   * A config object, or the `type` string of the widget (usually a {@link Core.widget.Field} subclass,
   * i.e. {@link Core.widget.TextField}) which this editor will encapsulate.
   * @prp {Core.widget.Widget}
   * @accepts {InputFieldConfig|String}
   * @default
   */
  inputField: "textfield",
  /**
   * What action should be taken when focus moves out of the editor, either by `TAB` or clicking outside.
   * May be `'complete'` or `'cancel`'. Any other value results in no action being taken upon focus leaving the editor
   * leaving the application to listen for the {@link #event-focusOut focusOut} event.
   * @config {'complete'|'cancel'|null}
   * @default
   */
  blurAction: "complete",
  /**
   * The name of the `key` which completes the edit.
   *
   * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for key names.
   * @config {String}
   * @default
   */
  completeKey: "Enter",
  /**
   * The name of the `key` which cancels the edit.
   *
   * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for key names.
   * @config {String}
   * @default
   */
  cancelKey: "Escape",
  /**
   * How to handle a request to complete the edit if the field is invalid. There are three choices:
   *  - `block` The default. The edit is not exited, the field remains focused.
   *  - `allow` Allow the edit to be completed.
   *  - `revert` The field value is reverted and the edit is completed.
   * @config {'block'|'allow'|'revert'}
   * @default
   */
  invalidAction: "block",
  /**
   * Configure as `true` to have editing complete as soon as the field fires its `change` event.
   * @config {Boolean}
   * @default false
   */
  completeOnChange: null,
  isolateFields: true
});
Editor.initClass();
Editor._$name = "Editor";

export {
  __publicField,
  __privateGet,
  __privateAdd,
  __privateSet,
  BrowserHelper,
  StringHelper,
  Objects,
  VersionHelper,
  Config,
  Base,
  ArrayHelper,
  FunctionHelper,
  Events_default,
  AsyncHelper,
  AjaxHelper,
  LocaleHelper,
  LocaleManager_default,
  Localizable_default,
  unitMagnitudes,
  DateHelper,
  ObjectHelper,
  parseAlign,
  Rectangle,
  Point,
  DomClassList,
  EventHelper,
  DomHelper,
  GlobalEvents_default,
  InstancePlugin,
  Pluggable_default,
  Delayable_default,
  StateStorage,
  StateProvider,
  State_default,
  Identifiable_default,
  ModelStm_default,
  TreeNode_default,
  ModelLink_default,
  Factoryable_default,
  DataField,
  ArrayDataField,
  BooleanDataField,
  DateDataField,
  StringDataField,
  IntegerDataField,
  ModelDataField,
  NumberDataField,
  ObjectDataField,
  StoreDataField,
  Model,
  Duration,
  CollectionFilter,
  IdHelper,
  CollectionSorter,
  Collection,
  Bag,
  StoreCRUD_default,
  StoreChanges_default,
  StoreFilter_default,
  StoreGroup_default,
  StoreProxy_default,
  StoreRelation_default,
  StoreSum_default,
  StoreSearch_default,
  StoreSort_default,
  StoreChained_default,
  StoreState_default,
  Wbs,
  StoreTree_default,
  WalkHelper,
  StoreSync_default,
  StoreStm_default,
  Store,
  AjaxStore,
  DomDataStore,
  CSSHelper,
  DomSync,
  Fullscreen,
  ResizeMonitor,
  Scroller,
  Promissory,
  Renderable,
  Mask,
  KeyMap_default,
  RTL_default,
  Widget,
  Layout,
  Ripple,
  Container,
  Animator,
  ClickRepeater,
  Rotatable_default,
  Tool,
  CollapseTool,
  PanelCollapser,
  DynamicObject,
  Toolable_default,
  Badge_default,
  Button,
  Toolbar,
  Panel,
  Popup,
  MenuItem,
  Menu,
  ContextMenuBase,
  TemplateHelper,
  TimeZoneHelper,
  Navigator,
  LoadMaskable_default,
  DayTime,
  ScrollManager,
  Tooltip,
  Labelable_default,
  FieldContainer,
  Field,
  TextField,
  PickerField,
  List,
  ChipView,
  Combo,
  Checkbox,
  ColorPicker,
  Editor
};
//# sourceMappingURL=chunk-MZVS5JQA.js.map
