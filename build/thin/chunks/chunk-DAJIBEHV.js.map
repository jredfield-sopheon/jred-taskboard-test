{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/widget/graph/Histogram.js", "../../../../Core/lib/Core/widget/graph/Scale.js"],
  "sourcesContent": ["import Widget from '../Widget.js';\nimport StringHelper from '../../helper/StringHelper.js';\nimport DomSync from '../../helper/DomSync.js';\nimport Tooltip from '../Tooltip.js';\nimport Objects from '../../helper/util/Objects.js';\n/**\n * @module Core/widget/graph/Histogram\n */\nconst\n    ns = 'http://www.w3.org/2000/svg',\n    // Outline series must overlay bars\n    typePrio = {\n        bar     : 1,\n        outline : 2,\n        text    : 3\n    },\n    byOrder = (l, r) => parseInt(l.order, 10) - parseInt(r.order, 10),\n    byDatasetOrder = (l, r) => parseInt(l.dataset.order, 10) - parseInt(r.dataset.order, 10),\n    getField = s => s.field,\n    returnFalse = () => false,\n    classesDelimiter = /\\s+/;\n/**\n * An object representing a series settings.\n *\n * @typedef {Object} HistogramSeries\n * @property {'bar'|'outline'} type The series type specifying how it is rendered, as solid bars or outlines.\n * @property {String} [field] The name of the property to to read value from. By default matches the series\n * identifier.\n * @property {Boolean} [stretch=false] Provide `true` to stretch the series bars to take the whole vertical space\n * Applicable to `bar` type series only.\n * @property {String} [id] The series identifier. When configuring the series this value is automatically taken from\n * the key name the series is provided. For example in the bellow code the series `id` will be set to `salary`:\n * ```javascript\n * series : {\n *     salary : {\n *         type : 'bar'\n *     },\n *     ...\n * }\n * ```\n */\n/**\n * Displays a simple bar histogram based upon an array of data objects passed in the {@link #config-data} config.\n *\n * @extends Core/widget/Widget\n * @classtype histogram\n */\nexport default class Histogram extends Widget {\n    //region Config\n    static type = 'histogram';\n    static $name = 'Histogram';\n    static get configurable() {\n        return {\n            /**\n             * An array of data objects used to drive the histogram. The property/properties used\n             * are defined in the {@link #config-series} option.\n             * @config {Object[]}\n             * @default\n             */\n            data : null,\n            /**\n             * The values to represent in bar form.\n             * @config {Number[]}\n             */\n            values : null,\n            /**\n             * Object enumerating data series for the histogram.\n             * The object keys are treated as series identifiers and values are objects that\n             * can contain the following properties:\n             *  - `type` A String, either `'bar'` or `'outline'`\n             *  - `field` A String, the name of the property to use from the data objects in the {@link #config-data} option.\n             * If the value is omitted the series identifier is used as the property name.\n             * @config {Object<String, HistogramSeries>}\n             */\n            series : null,\n            /**\n             * By default, the bars are scaled based upon the detected max value across all the series.\n             * A specific top value to represent the 100% height may be configured.\n             * @config {Number}\n             */\n            topValue : null,\n            element : {\n                children : [{\n                    ns,\n                    tag                 : 'svg',\n                    reference           : 'svgElement',\n                    width               : '100%',\n                    height              : '100%',\n                    preserveAspectRatio : 'none',\n                    children            : [{\n                        ns,\n                        tag       : 'g',\n                        reference : 'scaledSvgGroup'\n                    }, {\n                        ns,\n                        tag       : 'g',\n                        reference : 'unscaledSvgGroup'\n                    }]\n                }]\n            },\n            /**\n             * By default, all bars are rendered, even those with zero height. Configure this as `true`\n             * to omit zero height bars.\n             * @config {Boolean}\n             * @default\n             */\n            omitZeroHeightBars : false,\n            /**\n             * By default, the histogram calls {@link #config-getBarText} once per each datum.\n             * So the function is supposed to output all the series values the way it needs.\n             * Configure this as `false` to call the function for each series value\n             * if you need to display the values separately or having different styling.\n             * @config {Boolean}\n             * @default\n             */\n            singleTextForAllBars : true,\n            monitorResize : true,\n            /**\n             * A Function which returns a CSS class name to add to a rectangle element.\n             * The following parameters are passed:\n             * @config {Function}\n             * @param {HistogramSeries} series The series being rendered\n             * @param {Object} rectConfig The rectangle configuration object\n             * @param {Object} datum The datum being rendered\n             * @param {Number} index The index of the datum being rendered\n             * @returns {String} CSS class name of the rectangle element\n             * @returns {String} CSS class name\n             */\n            getRectClass(series, rectConfig, datum, index) {\n                return '';\n            },\n            /**\n             * A Function which returns a CSS class name to add to a path element\n             * built for an `outline` type series.\n             * The following parameters are passed:\n             * @param {HistogramSeries} series The series being rendered\n             * @param {Object[]} data The series data\n             * @returns {String} CSS class name of the path element\n             * @config {Function}\n             */\n            getOutlineClass(series, data) {\n                return '';\n            },\n            /**\n             * A Function which returns the tooltip text to display when hovering a bar.\n             * The following parameters are passed:\n             *\n             * @config {Function}\n             * @param {HistogramSeries} series The series being rendered\n             * @param {Object} rectConfig The rectangle configuration object\n             * @param {Object} datum The datum being rendered\n             * @param {Number} index The index of the datum being rendered\n             * @returns {String} Tip for the the bar.\n             */\n            getBarTip(series, rectConfig, datum, index) {},\n            /**\n             * A Function which returns the text to render inside a bar.\n             * The following parameters are passed:\n             * @param {Object} datum The datum being rendered\n             * @param {Number} index The index of the datum being rendered\n             * @param {HistogramSeries} [series] The series (provided if {@link #config-singleTextForAllBars}\n             * is `false`)\n             * @returns {String} Text to render in the bar.\n             * @config {Function}\n             */\n            getBarText(datum, index, series) {\n                return '';\n            },\n            getRectConfig : null,\n            getBarTextRenderData(renderData, datum, index, series) {\n                return renderData;\n            },\n            getBarTextTip(renderData, datum, index, series) {}\n        };\n    }\n    static properties = {\n        refreshSuspended : 0\n    };\n    //endregion\n    //region Init\n    construct(config) {\n        const me = this;\n        super.construct(config);\n        me.scheduleRefresh = me.createOnFrame(me.refresh, [], me, true);\n        me.refresh();\n    }\n    set tip(tip) {\n        const me = this;\n        me.tip?.destroy();\n        if (tip) {\n            me._tip = Tooltip.new({\n                owner             : me,\n                forElement        : me.svgElement,\n                forSelector       : 'rect',\n                internalListeners : {\n                    beforeShow : 'up.onBeforeTipShow'\n                }\n            }, tip);\n        }\n        else {\n            me._tip = null;\n        }\n    }\n    onElementResize() {\n        super.onElementResize(...arguments);\n        const svgRect = this.svgElement.getBoundingClientRect();\n        this.scaledSvgGroup.setAttribute('transform', `scale(${svgRect.width} ${svgRect.height})`);\n    }\n    onBeforeTipShow({ source : tip }) {\n        const index = parseInt(tip.activeTarget.dataset.index);\n        tip.html = tip.contentTemplate({\n            histogram : this,\n            index\n        });\n    }\n    updateSeries(value) {\n        const\n            me     = this,\n            series = me._series = {};\n        let\n            index = 0,\n            barSeriesCount = 0;\n        for (const id in value) {\n            // Providing\n            //\n            // \"series\" : {\n            //     \"foo\" : false\n            //     ...\n            //\n            // disables the \"foo\" series (that could be defined on a prototype level for example)\n            if (value[id] !== false) {\n                const data = series[id] = Objects.merge({}, value[id]);\n                // default field name is series identifier\n                if (!data.field) {\n                    data.field = id;\n                }\n                // default type is \"bar\"\n                if (!data.type) {\n                    data.type = 'bar';\n                }\n                if (!('order' in data)) {\n                    data.order = typePrio[data.type] * 10 + index;\n                }\n                if (!('index' in data)) {\n                    data.index = index;\n                }\n                if (data.type === 'bar') {\n                    data.index = barSeriesCount++;\n                }\n                data.id = id;\n                index++;\n            }\n        }\n        // Calculate the top value from all the series\n        if (!me.topValue && me._data) {\n            me.topValue = me.getDataTopValue(me._data);\n        }\n        if (!me.refreshSuspended) {\n            me.scheduleRefresh();\n        }\n    }\n    getDataTopValue(data, series) {\n        const fields   = Object.values(series || this.series).map(getField);\n        let result = 0, datum;\n        for (let i = 0, { length } = data; i < length; i++) {\n            datum = data[i];\n            for (let j = 0, { length } = fields; j < length; j++) {\n                result = Math.max(result, datum[fields[j]]);\n            }\n        }\n        return result;\n    }\n    updateData(data) {\n        const me = this;\n        me._data = data;\n        // Calculate the top value from all the series\n        if (!me.topValue && me._data && me._series) {\n            me.topValue = me.getDataTopValue(data);\n        }\n        if (!me.refreshSuspended) {\n            me.scheduleRefresh();\n        }\n    }\n    updateTopValue(value) {\n        const me = this;\n        me._topValue = value;\n        // Calculate the top value from all the series\n        if (!value && me._data) {\n            me._topValue = me.getDataTopValue(me._data);\n        }\n        if (!me.refreshSuspended) {\n            me.scheduleRefresh();\n        }\n    }\n    // Must exist from the start because configuration setters call it.\n    // Once configured, will be replaced with a function which schedules a refresh for the next animation frame.\n    scheduleRefresh() {\n    }\n    suspendRefresh() {\n        this.refreshSuspended++;\n    }\n    resumeRefresh() {\n        if (this.refreshSuspended) {\n            this.refreshSuspended--;\n        }\n    }\n    refresh(params) {\n        const\n            me             = this,\n            {\n                series,\n                _tip,\n                topValue,\n                singleTextForAllBars\n            }              = me,\n            // extra arguments to pass through\n            extraArgs = params?.args || [],\n            histogramElements = [],\n            textElements = [];\n        // bail out if there is no series provided\n        if (!series) {\n            return;\n        }\n        for (const data of Object.values(series).sort(byOrder)) {\n            const elConfig = me[`draw${StringHelper.capitalize(data.type)}`](data, ...extraArgs);\n            if (Array.isArray(elConfig)) {\n                histogramElements.push.apply(histogramElements, elConfig);\n            }\n            else {\n                histogramElements.push(elConfig);\n            }\n            // if it's told we should have separate texts for bars\n            if (!singleTextForAllBars && data.type === 'bar') {\n                textElements.push(...me.drawText(data, ...extraArgs));\n            }\n        }\n        // sort again since user could change order in a hook\n        histogramElements.sort(byDatasetOrder);\n        if (singleTextForAllBars) {\n            textElements.push(...me.drawText(null, ...extraArgs));\n        }\n        else {\n            textElements.sort(byDatasetOrder);\n        }\n        DomSync.sync({\n            domConfig : {\n                width               : '100%',\n                height              : '100%',\n                preserveAspectRatio : 'none',\n                dataset             : {\n                    topValue\n                },\n                children : [\n                    {\n                        ns,\n                        tag       : 'g',\n                        reference : 'scaledSvgGroup',\n                        children  : histogramElements\n                    },\n                    {\n                        ns,\n                        tag       : 'g',\n                        reference : 'unscaledSvgGroup',\n                        children  : textElements\n                    }\n                ]\n            },\n            configEquality : returnFalse,\n            targetElement  : me.svgElement\n        });\n        if (_tip && _tip.isVisible) {\n            me.onBeforeTipShow({ source : _tip });\n        }\n    }\n    drawBar(series, ...args) {\n        const\n            me           = this,\n            {\n                topValue,\n                data,\n                omitZeroHeightBars,\n                barStyle\n            }            = me,\n            {\n                field,\n                order,\n                stretch\n            }            = series,\n            { length }   = data,\n            defaultWidth = 1 / length,\n            children     = [],\n            seriesId     = StringHelper.createId(series.id),\n            seriesIndex  = series.index,\n            forceHeight  = stretch ? 1 : undefined;\n        let width;\n        for (let index = 0, x = 0, { length } = data; index < length; index++, x += width) {\n            const datum = data[index];\n            let rectConfig = (datum.rectConfig = {\n                ns,\n                tag     : 'rect',\n                dataset : {}\n            });\n            const\n                value = datum[field],\n                // limit height with topValue otherwise the histogram looks fine\n                // yet the bar tooltip picks wrong Y-coordinate and there is an empty space between it and the bar\n                height = value ? forceHeight || datum.height || (value > topValue ? topValue : value) / topValue : 0,\n                y = 1 - height,\n                barTip = me.callback('getBarTip', me, [series, rectConfig, datum, index, ...args]);\n            // use either provided width or the calculated value\n            width = datum.width || defaultWidth;\n            if (barStyle) {\n                rectConfig.style = barStyle;\n            }\n            else {\n                delete rectConfig.style;\n            }\n            Object.assign(rectConfig.dataset, {\n                index,\n                order,\n                series : seriesId\n            });\n            const\n                rectClass = {\n                    [`b-series-${seriesId}`]          : 1,\n                    [`b-series-index-${seriesIndex}`] : 1\n                },\n                classes = me.callback('getRectClass', me, [series, rectConfig, datum, index, ...args]);\n            if (classes) {\n                classes.split(classesDelimiter).forEach(cls => rectClass[cls] = 1);\n            }\n            Object.assign(rectConfig, {\n                x,\n                y,\n                width,\n                height,\n                class : rectClass\n            });\n            if (barTip) {\n                rectConfig.dataset.btip = barTip;\n            }\n            else {\n                delete rectConfig.dataset.btip;\n            }\n            if (me.getRectConfig) {\n                rectConfig = me.getRectConfig(rectConfig, datum, index, series, ...args);\n            }\n            if (rectConfig && (rectConfig.height || !omitZeroHeightBars)) {\n                children.push(rectConfig);\n            }\n        }\n        return children;\n    }\n    changeGetRectConfig(fn) {\n        return fn ? this.bindCallback(fn) : null;\n    }\n    drawOutline(series, ...args) {\n        const\n            me           = this,\n            {\n                topValue,\n                data\n            }            = me,\n            {\n                field,\n                order,\n                id\n            }            = series,\n            defaultWidth = 1 / data.length,\n            coords       = ['M 0,1'],\n            result       = {\n                ns,\n                tag     : 'path',\n                dataset : {\n                    order,\n                    id\n                }\n            };\n        let\n            barWidth,\n            command1 = 'M',\n            command2 = 'L';\n        for (let i = 0, x = 0, { length } = data; i < length; i++) {\n            const barHeight = 1 - data[i][field] / topValue;\n            // use either provided with or the calculated value\n            barWidth = data[i].width || defaultWidth;\n            coords.push(`${command1} ${x},${barHeight} ${command2} ${x += barWidth},${barHeight}`);\n            command1 = command2 = '';\n        }\n        // coords.push('1,1');\n        result.class = `b-series-${series.id} b-series-index-${series.index} ` +\n            me.callback('getOutlineClass', me, [series, data, ...args]);\n        result.d = coords.join(' ');\n        return result;\n    }\n    drawText(series, ...args) {\n        const\n            me                = this,\n            { data }          = me,\n            defaultWidth      = 1 / data.length,\n            defaultY          = '100%',\n            unscaledSvgGroups = [];\n        for (let index = 0, width, x = 0, { length } = data; index < length; index++, x += width) {\n            width = data[index].width || defaultWidth;\n            const barText = me.callback('getBarText', me, [data[index], index, series, ...args]);\n            if (barText) {\n                const renderData = me.callback('getBarTextRenderData', me, [{\n                    ns,\n                    tag       : 'text',\n                    className : 'b-bar-legend',\n                    html      : barText,\n                    left      : x,\n                    width,\n                    x         : `${(x + width / 2) * 100}%`,\n                    y         : data[index].y !== undefined ? data[index].y : defaultY,\n                    dataset   : {\n                        index,\n                        series\n                    }\n                }, data[index], index, series, ...args]);\n                const barTip = me.callback('getBarTextTip', me, [renderData, data[index], index, series, ...args]);\n                if (barTip) {\n                    renderData.dataset.btip = barTip;\n                }\n                else {\n                    delete renderData.dataset.btip;\n                }\n                unscaledSvgGroups.push(renderData);\n            }\n        }\n        return unscaledSvgGroups;\n    }\n    //endregion\n}\nHistogram.initClass();\nHistogram._$name = 'Histogram';", "import Widget from '../Widget.js';\nimport DomSync from '../../helper/DomSync.js';\n/**\n * @module Core/widget/graph/Scale\n */\nconst\n    ns = 'http://www.w3.org/2000/svg';\n/**\n * Displays a scale with ticks and labels.\n *\n * @extends Core/widget/Widget\n * @classtype scale\n */\nexport default class Scale extends Widget {\n    //region Config\n    static $name = 'Scale';\n    static type = 'scale';\n    static get configurable() {\n        return {\n            scalePoints : null,\n            // Padding after the max scale point.\n            // Expressed as the share of the height.\n            scaleMaxPadding : 0.1,\n            /**\n             * Configure as `true` to create a horizontal scale. Scales are vertical by default.\n             * @config {Boolean}\n             */\n            horizontal : false,\n            /**\n             * Side to align the scale to. Defaults to `bottom` for {@link #config-horizontal} Scales\n             * and `right` for vertical Scales.\n             * @config {String}\n             */\n            align : {\n                value   : false,\n                $config : {\n                    merge : 'replace'\n                }\n            },\n            element : {\n                children : [{\n                    ns,\n                    tag                 : 'svg',\n                    reference           : 'svgElement',\n                    width               : '100%',\n                    height              : '100%',\n                    preserveAspectRatio : 'none',\n                    children            : [{\n                        ns,\n                        tag       : 'g',\n                        reference : 'scaledSvgGroup',\n                        children  : [{\n                            ns,\n                            tag       : 'path',\n                            reference : 'pathElement'\n                        }]\n                    }, {\n                        ns,\n                        tag       : 'g',\n                        reference : 'unscaledSvgGroup'\n                    }]\n                }]\n            },\n            monitorResize : true\n        };\n    }\n    //endregion\n    //region Init\n    construct(config) {\n        super.construct(config);\n        this.scheduleRefresh = this.createOnFrame(this.refresh, [], this, true);\n        this.refresh();\n    }\n    changeAlign(align) {\n        if (!align) {\n            align = this.horizontal ? 'bottom' : 'right';\n        }\n        return align;\n    }\n    updateAlign(align, oldAlign) {\n        this.element.classList.remove(`b-align-${oldAlign}`);\n        this.element.classList.add(`b-align-${align}`);\n    }\n    updateHorizontal(horizontal, oldHorizontal) {\n        this.element.classList.remove(`b-scale-${oldHorizontal ? 'horizontal' : 'vertical'}`);\n        this.element.classList.add(`b-scale-${horizontal ? 'horizontal' : 'vertical'}`);\n    }\n    onElementResize() {\n        super.onElementResize(...arguments);\n        this.scheduleRefresh();\n    }\n    // Must exist from the start because configuration setters call it.\n    // Once configured, will be replaced with a function which schedules a refresh for the next animation frame.\n    scheduleRefresh() {\n    }\n    refresh() {\n        if (!this.scalePoints) {\n            return;\n        }\n        const\n            me             = this,\n            {\n                horizontal,\n                width,\n                height,\n                align,\n                scalePoints,\n                scaleMaxPadding\n            }                  = me,\n            scaleMax           = scalePoints[scalePoints.length - 1]?.value,\n            path               = [],\n            labels             = [];\n        const posFactor = 1 / (scaleMax + scaleMaxPadding * scaleMax);\n        me.scaledSvgGroup.setAttribute('transform', `scale(${horizontal ? width : 1} ${horizontal ? 1 : height})`);\n        for (const point of scalePoints) {\n            const isLabelStep = Boolean(point.text),\n                pos = posFactor * point.value;\n            if (isLabelStep) {\n                const label = {\n                    ns,\n                    tag       : 'text',\n                    className : 'b-scale-tick-label',\n                    html      : point.text,\n                    dataset   : {\n                        tick : point.value\n                    }\n                };\n                if (horizontal) {\n                    label.x = `${pos * 100}%`;\n                    label.y = align === 'top' ? '1.6em' : height - 12;\n                }\n                else {\n                    label.x = align === 'left' ? '12' : `${width - 12}`;\n                    label.y = `${(1 - pos) * 100}%`;\n                }\n                labels.push(label);\n            }\n            if (horizontal) {\n                if (align === 'top') {\n                    path.push(`M${pos},0 L${pos},${isLabelStep ? 10 : 5}`);\n                }\n                else {\n                    path.push(`M${pos},${height} L${pos},${height - (isLabelStep ? 10 : 5)}`);\n                }\n            }\n            else {\n                if (align === 'left') {\n                    path.push(`M0,${1 - pos} L${isLabelStep ? 10 : 5},${1 - pos}`);\n                }\n                else {\n                    path.push(`M${width},${1 - pos} L${width - (isLabelStep ? 10 : 5)},${1 - pos}`);\n                }\n            }\n        }\n        me.pathElement.setAttribute('d', path.join(''));\n        DomSync.syncChildren({\n            domConfig : { children : labels }\n        }, me.unscaledSvgGroup);\n    }\n    //endregion\n}\nScale.initClass();\nScale._$name = 'Scale';"],
  "mappings": ";;;;;;;;;;AAQA,IACI,KAAK;AADT,IAGI,WAAW;AAAA,EACP,KAAU;AAAA,EACV,SAAU;AAAA,EACV,MAAU;AACd;AAPJ,IAQI,UAAU,CAAC,GAAG,MAAM,SAAS,EAAE,OAAO,EAAE,IAAI,SAAS,EAAE,OAAO,EAAE;AARpE,IASI,iBAAiB,CAAC,GAAG,MAAM,SAAS,EAAE,QAAQ,OAAO,EAAE,IAAI,SAAS,EAAE,QAAQ,OAAO,EAAE;AAT3F,IAUI,WAAW,OAAK,EAAE;AAVtB,IAWI,cAAc,MAAM;AAXxB,IAYI,mBAAmB;AA2BvB,IAAqB,YAArB,cAAuC,OAAO;AAAA,EAI1C,WAAW,eAAe;AACtB,WAAO;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOH,MAAO;AAAA;AAAA;AAAA;AAAA;AAAA,MAKP,QAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAUT,QAAS;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMT,UAAW;AAAA,MACX,SAAU;AAAA,QACN,UAAW,CAAC;AAAA,UACR;AAAA,UACA,KAAsB;AAAA,UACtB,WAAsB;AAAA,UACtB,OAAsB;AAAA,UACtB,QAAsB;AAAA,UACtB,qBAAsB;AAAA,UACtB,UAAsB,CAAC;AAAA,YACnB;AAAA,YACA,KAAY;AAAA,YACZ,WAAY;AAAA,UAChB,GAAG;AAAA,YACC;AAAA,YACA,KAAY;AAAA,YACZ,WAAY;AAAA,UAChB,CAAC;AAAA,QACL,CAAC;AAAA,MACL;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAOA,oBAAqB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MASrB,sBAAuB;AAAA,MACvB,eAAgB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAYhB,aAAa,QAAQ,YAAY,OAAO,OAAO;AAC3C,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAUA,gBAAgB,QAAQ,MAAM;AAC1B,eAAO;AAAA,MACX;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAYA,UAAU,QAAQ,YAAY,OAAO,OAAO;AAAA,MAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAW7C,WAAW,OAAO,OAAO,QAAQ;AAC7B,eAAO;AAAA,MACX;AAAA,MACA,eAAgB;AAAA,MAChB,qBAAqB,YAAY,OAAO,OAAO,QAAQ;AACnD,eAAO;AAAA,MACX;AAAA,MACA,cAAc,YAAY,OAAO,OAAO,QAAQ;AAAA,MAAC;AAAA,IACrD;AAAA,EACJ;AAAA;AAAA;AAAA,EAMA,UAAU,QAAQ;AACd,UAAM,KAAK;AACX,UAAM,UAAU,MAAM;AACtB,OAAG,kBAAkB,GAAG,cAAc,GAAG,SAAS,CAAC,GAAG,IAAI,IAAI;AAC9D,OAAG,QAAQ;AAAA,EACf;AAAA,EACA,IAAI,IAAI,KAAK;AA1LjB;AA2LQ,UAAM,KAAK;AACX,aAAG,QAAH,mBAAQ;AACR,QAAI,KAAK;AACL,SAAG,OAAO,QAAQ,IAAI;AAAA,QAClB,OAAoB;AAAA,QACpB,YAAoB,GAAG;AAAA,QACvB,aAAoB;AAAA,QACpB,mBAAoB;AAAA,UAChB,YAAa;AAAA,QACjB;AAAA,MACJ,GAAG,GAAG;AAAA,IACV,OACK;AACD,SAAG,OAAO;AAAA,IACd;AAAA,EACJ;AAAA,EACA,kBAAkB;AACd,UAAM,gBAAgB,GAAG,SAAS;AAClC,UAAM,UAAU,KAAK,WAAW,sBAAsB;AACtD,SAAK,eAAe,aAAa,aAAa,SAAS,QAAQ,KAAK,IAAI,QAAQ,MAAM,GAAG;AAAA,EAC7F;AAAA,EACA,gBAAgB,EAAE,QAAS,IAAI,GAAG;AAC9B,UAAM,QAAQ,SAAS,IAAI,aAAa,QAAQ,KAAK;AACrD,QAAI,OAAO,IAAI,gBAAgB;AAAA,MAC3B,WAAY;AAAA,MACZ;AAAA,IACJ,CAAC;AAAA,EACL;AAAA,EACA,aAAa,OAAO;AAChB,UACI,KAAS,MACT,SAAS,GAAG,UAAU,CAAC;AAC3B,QACI,QAAQ,GACR,iBAAiB;AACrB,eAAW,MAAM,OAAO;AAQpB,UAAI,MAAM,EAAE,MAAM,OAAO;AACrB,cAAM,OAAO,OAAO,EAAE,IAAI,QAAQ,MAAM,CAAC,GAAG,MAAM,EAAE,CAAC;AAErD,YAAI,CAAC,KAAK,OAAO;AACb,eAAK,QAAQ;AAAA,QACjB;AAEA,YAAI,CAAC,KAAK,MAAM;AACZ,eAAK,OAAO;AAAA,QAChB;AACA,YAAI,EAAE,WAAW,OAAO;AACpB,eAAK,QAAQ,SAAS,KAAK,IAAI,IAAI,KAAK;AAAA,QAC5C;AACA,YAAI,EAAE,WAAW,OAAO;AACpB,eAAK,QAAQ;AAAA,QACjB;AACA,YAAI,KAAK,SAAS,OAAO;AACrB,eAAK,QAAQ;AAAA,QACjB;AACA,aAAK,KAAK;AACV;AAAA,MACJ;AAAA,IACJ;AAEA,QAAI,CAAC,GAAG,YAAY,GAAG,OAAO;AAC1B,SAAG,WAAW,GAAG,gBAAgB,GAAG,KAAK;AAAA,IAC7C;AACA,QAAI,CAAC,GAAG,kBAAkB;AACtB,SAAG,gBAAgB;AAAA,IACvB;AAAA,EACJ;AAAA,EACA,gBAAgB,MAAM,QAAQ;AAC1B,UAAM,SAAW,OAAO,OAAO,UAAU,KAAK,MAAM,EAAE,IAAI,QAAQ;AAClE,QAAI,SAAS,GAAG;AAChB,aAAS,IAAI,GAAG,EAAE,OAAO,IAAI,MAAM,IAAI,QAAQ,KAAK;AAChD,cAAQ,KAAK,CAAC;AACd,eAAS,IAAI,GAAG,EAAE,QAAAA,QAAO,IAAI,QAAQ,IAAIA,SAAQ,KAAK;AAClD,iBAAS,KAAK,IAAI,QAAQ,MAAM,OAAO,CAAC,CAAC,CAAC;AAAA,MAC9C;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,WAAW,MAAM;AACb,UAAM,KAAK;AACX,OAAG,QAAQ;AAEX,QAAI,CAAC,GAAG,YAAY,GAAG,SAAS,GAAG,SAAS;AACxC,SAAG,WAAW,GAAG,gBAAgB,IAAI;AAAA,IACzC;AACA,QAAI,CAAC,GAAG,kBAAkB;AACtB,SAAG,gBAAgB;AAAA,IACvB;AAAA,EACJ;AAAA,EACA,eAAe,OAAO;AAClB,UAAM,KAAK;AACX,OAAG,YAAY;AAEf,QAAI,CAAC,SAAS,GAAG,OAAO;AACpB,SAAG,YAAY,GAAG,gBAAgB,GAAG,KAAK;AAAA,IAC9C;AACA,QAAI,CAAC,GAAG,kBAAkB;AACtB,SAAG,gBAAgB;AAAA,IACvB;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,kBAAkB;AAAA,EAClB;AAAA,EACA,iBAAiB;AACb,SAAK;AAAA,EACT;AAAA,EACA,gBAAgB;AACZ,QAAI,KAAK,kBAAkB;AACvB,WAAK;AAAA,IACT;AAAA,EACJ;AAAA,EACA,QAAQ,QAAQ;AACZ,UACI,KAAiB,MACjB;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ,IAAiB,IAEjB,aAAY,iCAAQ,SAAQ,CAAC,GAC7B,oBAAoB,CAAC,GACrB,eAAe,CAAC;AAEpB,QAAI,CAAC,QAAQ;AACT;AAAA,IACJ;AACA,eAAW,QAAQ,OAAO,OAAO,MAAM,EAAE,KAAK,OAAO,GAAG;AACpD,YAAM,WAAW,GAAG,OAAO,aAAa,WAAW,KAAK,IAAI,CAAC,EAAE,EAAE,MAAM,GAAG,SAAS;AACnF,UAAI,MAAM,QAAQ,QAAQ,GAAG;AACzB,0BAAkB,KAAK,MAAM,mBAAmB,QAAQ;AAAA,MAC5D,OACK;AACD,0BAAkB,KAAK,QAAQ;AAAA,MACnC;AAEA,UAAI,CAAC,wBAAwB,KAAK,SAAS,OAAO;AAC9C,qBAAa,KAAK,GAAG,GAAG,SAAS,MAAM,GAAG,SAAS,CAAC;AAAA,MACxD;AAAA,IACJ;AAEA,sBAAkB,KAAK,cAAc;AACrC,QAAI,sBAAsB;AACtB,mBAAa,KAAK,GAAG,GAAG,SAAS,MAAM,GAAG,SAAS,CAAC;AAAA,IACxD,OACK;AACD,mBAAa,KAAK,cAAc;AAAA,IACpC;AACA,YAAQ,KAAK;AAAA,MACT,WAAY;AAAA,QACR,OAAsB;AAAA,QACtB,QAAsB;AAAA,QACtB,qBAAsB;AAAA,QACtB,SAAsB;AAAA,UAClB;AAAA,QACJ;AAAA,QACA,UAAW;AAAA,UACP;AAAA,YACI;AAAA,YACA,KAAY;AAAA,YACZ,WAAY;AAAA,YACZ,UAAY;AAAA,UAChB;AAAA,UACA;AAAA,YACI;AAAA,YACA,KAAY;AAAA,YACZ,WAAY;AAAA,YACZ,UAAY;AAAA,UAChB;AAAA,QACJ;AAAA,MACJ;AAAA,MACA,gBAAiB;AAAA,MACjB,eAAiB,GAAG;AAAA,IACxB,CAAC;AACD,QAAI,QAAQ,KAAK,WAAW;AACxB,SAAG,gBAAgB,EAAE,QAAS,KAAK,CAAC;AAAA,IACxC;AAAA,EACJ;AAAA,EACA,QAAQ,WAAW,MAAM;AACrB,UACI,KAAe,MACf;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ,IAAe,IACf;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,IACJ,IAAe,QACf,EAAE,OAAO,IAAM,MACf,eAAe,IAAI,QACnB,WAAe,CAAC,GAChB,WAAe,aAAa,SAAS,OAAO,EAAE,GAC9C,cAAe,OAAO,OACtB,cAAe,UAAU,IAAI;AACjC,QAAI;AACJ,aAAS,QAAQ,GAAG,IAAI,GAAG,EAAE,QAAAA,QAAO,IAAI,MAAM,QAAQA,SAAQ,SAAS,KAAK,OAAO;AAC/E,YAAM,QAAQ,KAAK,KAAK;AACxB,UAAI,aAAc,MAAM,aAAa;AAAA,QACjC;AAAA,QACA,KAAU;AAAA,QACV,SAAU,CAAC;AAAA,MACf;AACA,YACI,QAAQ,MAAM,KAAK,GAGnB,SAAS,QAAQ,eAAe,MAAM,WAAW,QAAQ,WAAW,WAAW,SAAS,WAAW,GACnG,IAAI,IAAI,QACR,SAAS,GAAG,SAAS,aAAa,IAAI,CAAC,QAAQ,YAAY,OAAO,OAAO,GAAG,IAAI,CAAC;AAErF,cAAQ,MAAM,SAAS;AACvB,UAAI,UAAU;AACV,mBAAW,QAAQ;AAAA,MACvB,OACK;AACD,eAAO,WAAW;AAAA,MACtB;AACA,aAAO,OAAO,WAAW,SAAS;AAAA,QAC9B;AAAA,QACA;AAAA,QACA,QAAS;AAAA,MACb,CAAC;AACD,YACI,YAAY;AAAA,QACR,CAAC,YAAY,QAAQ,EAAE,GAAa;AAAA,QACpC,CAAC,kBAAkB,WAAW,EAAE,GAAI;AAAA,MACxC,GACA,UAAU,GAAG,SAAS,gBAAgB,IAAI,CAAC,QAAQ,YAAY,OAAO,OAAO,GAAG,IAAI,CAAC;AACzF,UAAI,SAAS;AACT,gBAAQ,MAAM,gBAAgB,EAAE,QAAQ,SAAO,UAAU,GAAG,IAAI,CAAC;AAAA,MACrE;AACA,aAAO,OAAO,YAAY;AAAA,QACtB;AAAA,QACA;AAAA,QACA;AAAA,QACA;AAAA,QACA,OAAQ;AAAA,MACZ,CAAC;AACD,UAAI,QAAQ;AACR,mBAAW,QAAQ,OAAO;AAAA,MAC9B,OACK;AACD,eAAO,WAAW,QAAQ;AAAA,MAC9B;AACA,UAAI,GAAG,eAAe;AAClB,qBAAa,GAAG,cAAc,YAAY,OAAO,OAAO,QAAQ,GAAG,IAAI;AAAA,MAC3E;AACA,UAAI,eAAe,WAAW,UAAU,CAAC,qBAAqB;AAC1D,iBAAS,KAAK,UAAU;AAAA,MAC5B;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA,EACA,oBAAoB,IAAI;AACpB,WAAO,KAAK,KAAK,aAAa,EAAE,IAAI;AAAA,EACxC;AAAA,EACA,YAAY,WAAW,MAAM;AACzB,UACI,KAAe,MACf;AAAA,MACI;AAAA,MACA;AAAA,IACJ,IAAe,IACf;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,IACJ,IAAe,QACf,eAAe,IAAI,KAAK,QACxB,SAAe,CAAC,OAAO,GACvB,SAAe;AAAA,MACX;AAAA,MACA,KAAU;AAAA,MACV,SAAU;AAAA,QACN;AAAA,QACA;AAAA,MACJ;AAAA,IACJ;AACJ,QACI,UACA,WAAW,KACX,WAAW;AACf,aAAS,IAAI,GAAG,IAAI,GAAG,EAAE,OAAO,IAAI,MAAM,IAAI,QAAQ,KAAK;AACvD,YAAM,YAAY,IAAI,KAAK,CAAC,EAAE,KAAK,IAAI;AAEvC,iBAAW,KAAK,CAAC,EAAE,SAAS;AAC5B,aAAO,KAAK,GAAG,QAAQ,IAAI,CAAC,IAAI,SAAS,IAAI,QAAQ,IAAI,KAAK,QAAQ,IAAI,SAAS,EAAE;AACrF,iBAAW,WAAW;AAAA,IAC1B;AAEA,WAAO,QAAQ,YAAY,OAAO,EAAE,mBAAmB,OAAO,KAAK,MAC/D,GAAG,SAAS,mBAAmB,IAAI,CAAC,QAAQ,MAAM,GAAG,IAAI,CAAC;AAC9D,WAAO,IAAI,OAAO,KAAK,GAAG;AAC1B,WAAO;AAAA,EACX;AAAA,EACA,SAAS,WAAW,MAAM;AACtB,UACI,KAAoB,MACpB,EAAE,KAAK,IAAa,IACpB,eAAoB,IAAI,KAAK,QAC7B,WAAoB,QACpB,oBAAoB,CAAC;AACzB,aAAS,QAAQ,GAAG,OAAO,IAAI,GAAG,EAAE,OAAO,IAAI,MAAM,QAAQ,QAAQ,SAAS,KAAK,OAAO;AACtF,cAAQ,KAAK,KAAK,EAAE,SAAS;AAC7B,YAAM,UAAU,GAAG,SAAS,cAAc,IAAI,CAAC,KAAK,KAAK,GAAG,OAAO,QAAQ,GAAG,IAAI,CAAC;AACnF,UAAI,SAAS;AACT,cAAM,aAAa,GAAG,SAAS,wBAAwB,IAAI,CAAC;AAAA,UACxD;AAAA,UACA,KAAY;AAAA,UACZ,WAAY;AAAA,UACZ,MAAY;AAAA,UACZ,MAAY;AAAA,UACZ;AAAA,UACA,GAAY,IAAI,IAAI,QAAQ,KAAK,GAAG;AAAA,UACpC,GAAY,KAAK,KAAK,EAAE,MAAM,SAAY,KAAK,KAAK,EAAE,IAAI;AAAA,UAC1D,SAAY;AAAA,YACR;AAAA,YACA;AAAA,UACJ;AAAA,QACJ,GAAG,KAAK,KAAK,GAAG,OAAO,QAAQ,GAAG,IAAI,CAAC;AACvC,cAAM,SAAS,GAAG,SAAS,iBAAiB,IAAI,CAAC,YAAY,KAAK,KAAK,GAAG,OAAO,QAAQ,GAAG,IAAI,CAAC;AACjG,YAAI,QAAQ;AACR,qBAAW,QAAQ,OAAO;AAAA,QAC9B,OACK;AACD,iBAAO,WAAW,QAAQ;AAAA,QAC9B;AACA,0BAAkB,KAAK,UAAU;AAAA,MACrC;AAAA,IACJ;AACA,WAAO;AAAA,EACX;AAAA;AAEJ;AAAA;AApeI,cAFiB,WAEV,QAAO;AACd,cAHiB,WAGV,SAAQ;AA6Hf,cAhIiB,WAgIV,cAAa;AAAA,EAChB,kBAAmB;AACvB;AAqWJ,UAAU,UAAU;AACpB,UAAU,SAAS;;;AClhBnB,IACIC,MAAK;AAOT,IAAqB,QAArB,cAAmC,OAAO;AAAA,EAItC,WAAW,eAAe;AACtB,WAAO;AAAA,MACH,aAAc;AAAA;AAAA;AAAA,MAGd,iBAAkB;AAAA;AAAA;AAAA;AAAA;AAAA,MAKlB,YAAa;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,MAMb,OAAQ;AAAA,QACJ,OAAU;AAAA,QACV,SAAU;AAAA,UACN,OAAQ;AAAA,QACZ;AAAA,MACJ;AAAA,MACA,SAAU;AAAA,QACN,UAAW,CAAC;AAAA,UACR,IAAAA;AAAA,UACA,KAAsB;AAAA,UACtB,WAAsB;AAAA,UACtB,OAAsB;AAAA,UACtB,QAAsB;AAAA,UACtB,qBAAsB;AAAA,UACtB,UAAsB,CAAC;AAAA,YACnB,IAAAA;AAAA,YACA,KAAY;AAAA,YACZ,WAAY;AAAA,YACZ,UAAY,CAAC;AAAA,cACT,IAAAA;AAAA,cACA,KAAY;AAAA,cACZ,WAAY;AAAA,YAChB,CAAC;AAAA,UACL,GAAG;AAAA,YACC,IAAAA;AAAA,YACA,KAAY;AAAA,YACZ,WAAY;AAAA,UAChB,CAAC;AAAA,QACL,CAAC;AAAA,MACL;AAAA,MACA,eAAgB;AAAA,IACpB;AAAA,EACJ;AAAA;AAAA;AAAA,EAGA,UAAU,QAAQ;AACd,UAAM,UAAU,MAAM;AACtB,SAAK,kBAAkB,KAAK,cAAc,KAAK,SAAS,CAAC,GAAG,MAAM,IAAI;AACtE,SAAK,QAAQ;AAAA,EACjB;AAAA,EACA,YAAY,OAAO;AACf,QAAI,CAAC,OAAO;AACR,cAAQ,KAAK,aAAa,WAAW;AAAA,IACzC;AACA,WAAO;AAAA,EACX;AAAA,EACA,YAAY,OAAO,UAAU;AACzB,SAAK,QAAQ,UAAU,OAAO,WAAW,QAAQ,EAAE;AACnD,SAAK,QAAQ,UAAU,IAAI,WAAW,KAAK,EAAE;AAAA,EACjD;AAAA,EACA,iBAAiB,YAAY,eAAe;AACxC,SAAK,QAAQ,UAAU,OAAO,WAAW,gBAAgB,eAAe,UAAU,EAAE;AACpF,SAAK,QAAQ,UAAU,IAAI,WAAW,aAAa,eAAe,UAAU,EAAE;AAAA,EAClF;AAAA,EACA,kBAAkB;AACd,UAAM,gBAAgB,GAAG,SAAS;AAClC,SAAK,gBAAgB;AAAA,EACzB;AAAA;AAAA;AAAA,EAGA,kBAAkB;AAAA,EAClB;AAAA,EACA,UAAU;AA/Fd;AAgGQ,QAAI,CAAC,KAAK,aAAa;AACnB;AAAA,IACJ;AACA,UACI,KAAiB,MACjB;AAAA,MACI;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,IACJ,IAAqB,IACrB,YAAqB,iBAAY,YAAY,SAAS,CAAC,MAAlC,mBAAqC,OAC1D,OAAqB,CAAC,GACtB,SAAqB,CAAC;AAC1B,UAAM,YAAY,KAAK,WAAW,kBAAkB;AACpD,OAAG,eAAe,aAAa,aAAa,SAAS,aAAa,QAAQ,CAAC,IAAI,aAAa,IAAI,MAAM,GAAG;AACzG,eAAW,SAAS,aAAa;AAC7B,YAAM,cAAc,QAAQ,MAAM,IAAI,GAClC,MAAM,YAAY,MAAM;AAC5B,UAAI,aAAa;AACb,cAAM,QAAQ;AAAA,UACV,IAAAA;AAAA,UACA,KAAY;AAAA,UACZ,WAAY;AAAA,UACZ,MAAY,MAAM;AAAA,UAClB,SAAY;AAAA,YACR,MAAO,MAAM;AAAA,UACjB;AAAA,QACJ;AACA,YAAI,YAAY;AACZ,gBAAM,IAAI,GAAG,MAAM,GAAG;AACtB,gBAAM,IAAI,UAAU,QAAQ,UAAU,SAAS;AAAA,QACnD,OACK;AACD,gBAAM,IAAI,UAAU,SAAS,OAAO,GAAG,QAAQ,EAAE;AACjD,gBAAM,IAAI,IAAI,IAAI,OAAO,GAAG;AAAA,QAChC;AACA,eAAO,KAAK,KAAK;AAAA,MACrB;AACA,UAAI,YAAY;AACZ,YAAI,UAAU,OAAO;AACjB,eAAK,KAAK,IAAI,GAAG,OAAO,GAAG,IAAI,cAAc,KAAK,CAAC,EAAE;AAAA,QACzD,OACK;AACD,eAAK,KAAK,IAAI,GAAG,IAAI,MAAM,KAAK,GAAG,IAAI,UAAU,cAAc,KAAK,EAAE,EAAE;AAAA,QAC5E;AAAA,MACJ,OACK;AACD,YAAI,UAAU,QAAQ;AAClB,eAAK,KAAK,MAAM,IAAI,GAAG,KAAK,cAAc,KAAK,CAAC,IAAI,IAAI,GAAG,EAAE;AAAA,QACjE,OACK;AACD,eAAK,KAAK,IAAI,KAAK,IAAI,IAAI,GAAG,KAAK,SAAS,cAAc,KAAK,EAAE,IAAI,IAAI,GAAG,EAAE;AAAA,QAClF;AAAA,MACJ;AAAA,IACJ;AACA,OAAG,YAAY,aAAa,KAAK,KAAK,KAAK,EAAE,CAAC;AAC9C,YAAQ,aAAa;AAAA,MACjB,WAAY,EAAE,UAAW,OAAO;AAAA,IACpC,GAAG,GAAG,gBAAgB;AAAA,EAC1B;AAAA;AAEJ;AAAA;AAjJI,cAFiB,OAEV,SAAQ;AACf,cAHiB,OAGV,QAAO;AAiJlB,MAAM,UAAU;AAChB,MAAM,SAAS;",
  "names": ["length", "ns"]
}
