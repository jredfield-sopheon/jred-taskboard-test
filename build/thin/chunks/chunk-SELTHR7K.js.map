{
  "version": 3,
  "sources": ["../../../../Scheduler/lib/Scheduler/data/util/recurrence/RecurrenceLegend.js", "../../../../Scheduler/lib/Scheduler/feature/base/EditBase.js", "../../../../Scheduler/lib/Scheduler/view/EventEditor.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/field/RecurrenceCombo.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/RecurrenceLegendButton.js", "../../../../Scheduler/lib/Scheduler/view/recurrence/RecurrenceEditor.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/RecurringEventEdit.js", "../../../../Scheduler/lib/Scheduler/widget/ResourceCombo.js", "../../../../Scheduler/lib/Scheduler/feature/EventEdit.js", "../../../../Scheduler/lib/Scheduler/widget/ResourceFilter.js", "../../../../Scheduler/lib/Scheduler/widget/SchedulerDatePicker.js"],
  "sourcesContent": ["import Localizable from '../../../../Core/localization/Localizable.js';\nimport DayRuleEncoder from './RecurrenceDayRuleEncoder.js';\nimport DateHelper from '../../../../Core/helper/DateHelper.js';\n/**\n * @module Scheduler/data/util/recurrence/RecurrenceLegend\n */\n/**\n * A static class allowing to get a human readable description of the provided recurrence.\n *\n * ```javascript\n * const event = new EventModel({\n *      startDate : new Date(2018, 6, 3),\n *      endDate   : new Date(2018, 6, 4)\n * });\n * const recurrence = new RecurrenceModel({\n *      frequency : 'WEEKLY',\n *      days : ['MO', 'TU', 'WE']\n * });\n * event.recurrence = recurrence;\n * // \"Weekly on Mon, Tue and Wed\"\n * RecurrenceLegend.getLegend(recurrence);\n * ```\n *\n * @mixes Core/localization/Localizable\n */\nexport default class RecurrenceLegend extends Localizable() {\n    static get $name() {\n        return 'RecurrenceLegend';\n    }\n    static get allDaysValueAsArray() {\n        return ['SU', 'MO', 'TU', 'WE', 'TH', 'FR', 'SA'];\n    }\n    static get allDaysValue() {\n        return this.allDaysValueAsArray.join(',');\n    }\n    static get workingDaysValue() {\n        return this.allDaysValueAsArray.filter((day, index) => !DateHelper.nonWorkingDays[index]).join(',');\n    }\n    static get nonWorkingDaysValue() {\n        return this.allDaysValueAsArray.filter((day, index) => DateHelper.nonWorkingDays[index]).join(',');\n    }\n    /**\n     * Returns the provided recurrence description. The recurrence might be assigned to a timespan model,\n     * in this case the timespan start date should be provided in the second argument.\n     * @param {Scheduler.model.RecurrenceModel} recurrenceRecurrence model.\n     * @param {Date} [timeSpanStartDate] The recurring timespan start date. Can be omitted if the recurrence is assigned\n     * to a timespan model (and the timespan has {@link Scheduler.model.TimeSpan#field-startDate} filled). Then start\n     * date will be retrieved from the model.\n     * @returns {String} The recurrence description.\n     */\n    static getLegend(recurrence, timeSpanStartDate) {\n        const\n            me                                                         = this,\n            { timeSpan, interval, days, monthDays, months, positions } = recurrence,\n            startDate                                                  = timeSpanStartDate || timeSpan.startDate,\n            tplData                                                    = { interval };\n        let fn;\n        switch (recurrence.frequency) {\n            case 'DAILY':\n                return interval === 1 ? me.L('L{Daily}') : me.L('L{Every {0} days}', tplData);\n            case 'WEEKLY':\n                if (days && days.length) {\n                    tplData.days = me.getDaysLegend(days);\n                }\n                else if (startDate) {\n                    tplData.days = DateHelper.getDayName(startDate.getDay());\n                }\n                return me.L(interval === 1 ? 'L{Weekly on {1}}' : 'L{Every {0} weeks on {1}}', tplData);\n            case 'MONTHLY':\n                if (days && days.length && positions && positions.length) {\n                    tplData.days = me.getDaysLegend(days, positions);\n                }\n                else if (monthDays && monthDays.length) {\n                    // sort dates to output in a proper order\n                    monthDays.sort((a, b) => a - b);\n                    tplData.days = me.arrayToText(monthDays);\n                }\n                else if (startDate) {\n                    tplData.days = startDate.getDate();\n                }\n                return me.L(interval === 1 ? 'L{Monthly on {1}}' : 'L{Every {0} months on {1}}', tplData);\n            case 'YEARLY':\n                if (days && days.length && positions && positions.length) {\n                    tplData.days = me.getDaysLegend(days, positions);\n                }\n                else {\n                    tplData.days = startDate.getDate();\n                }\n                if (months && months.length) {\n                    // sort months to output in a proper order\n                    months.sort((a, b) => a - b);\n                    if (months.length > 2) {\n                        fn = month => DateHelper.getMonthShortName(month - 1);\n                    }\n                    else {\n                        fn = month => DateHelper.getMonthName(month - 1);\n                    }\n                    tplData.months = me.arrayToText(months, fn);\n                }\n                else {\n                    tplData.months = DateHelper.getMonthName(startDate.getMonth());\n                }\n                return me.L(interval === 1 ? 'L{Yearly on {1} of {2}}' : 'L{Every {0} years on {1} of {2}}', tplData);\n        }\n    }\n    static getDaysLegend(days, positions) {\n        const\n            me      = this,\n            tplData = { position : '' };\n        let fn;\n        if (positions && positions.length) {\n            tplData.position = me.arrayToText(positions, position => me.L(`L{position${position}}`));\n        }\n        if (days.length) {\n            days.sort((a, b) => DayRuleEncoder.decodeDay(a)[0] - DayRuleEncoder.decodeDay(b)[0]);\n            switch (days.join(',')) {\n                case me.allDaysValue :\n                    tplData.days = me.L('L{day}');\n                    break;\n                case me.workingDaysValue :\n                    tplData.days = me.L('L{weekday}');\n                    break;\n                case me.nonWorkingDaysValue :\n                    tplData.days = me.L('L{weekend day}');\n                    break;\n                default :\n                    if (days.length > 2) {\n                        fn = day => DateHelper.getDayShortName(DayRuleEncoder.decodeDay(day)[0]);\n                    }\n                    else {\n                        fn = day => DateHelper.getDayName(DayRuleEncoder.decodeDay(day)[0]);\n                    }\n                    tplData.days = me.arrayToText(days, fn);\n            }\n        }\n        return me.L('L{daysFormat}', tplData);\n    }\n    // Converts array of items to a human readable list.\n    // For example: [1,2,3,4]\n    // to: \"1, 2, 3 and 4\"\n    static arrayToText(array, fn) {\n        if (fn) {\n            array = array.map(fn);\n        }\n        return array.join(', ').replace(/,(?=[^,]*$)/, this.L('L{ and }'));\n    }\n}\nRecurrenceLegend._$name = 'RecurrenceLegend';", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport DateField from '../../../Core/widget/DateField.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport Config from '../../../Core/Config.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\n/**\n * @module Scheduler/feature/base/EditBase\n */\nconst\n    DH             = DateHelper,\n    scheduleFields = ['startDate', 'endDate', 'resource', 'recurrenceRule'],\n    makeDate       = (fields) => {\n        // single field, update record directly\n        if (fields.length === 1) return fields[0].value;\n        // two fields, date + time\n        else if (fields.length === 2) {\n            const\n                [date, time] = fields[0] instanceof DateField ? fields : fields.reverse(),\n                dateValue    = DH.parse(date.value);\n            if (dateValue && time.value) {\n                dateValue.setHours(\n                    time.value.getHours(),\n                    time.value.getMinutes(),\n                    time.value.getSeconds(),\n                    time.value.getMilliseconds()\n                );\n            }\n            // Clone to not end up sharing dates\n            return dateValue ? DateHelper.clone(dateValue) : null;\n        }\n        // shouldn't happen...\n        return null;\n    },\n    copyTime       = (dateTo, dateFrom) => {\n        const d = new Date(dateTo.getTime());\n        d.setHours(dateFrom.getHours(), dateFrom.getMinutes());\n        return d;\n    },\n    adjustEndDate  = (startDate, startTime, me) => {\n        // The end datetime just moves in response to the changed start datetime, keeping the same duration.\n        if (!me.editor.assigningValues && startDate && startTime && me.endDateField && me.endTimeField) {\n            const newEndDate = DH.add(copyTime(me.startDateField.value, me.startTimeField.value), me._durationMS, 'milliseconds');\n            me.endDateField.value = newEndDate;\n            me.endTimeField.value = DH.clone(newEndDate);\n        }\n    };\n/**\n * Base class for EventEdit. Not to be used directly.\n *\n * @extends Core/mixin/InstancePlugin\n */\nexport default class EditBase extends InstancePlugin {\n    //region Config\n    static get configurable() {\n        return {\n            /**\n             * True to save and close this panel if ENTER is pressed in one of the input fields inside the panel.\n             * @config {Boolean}\n             * @default\n             * @category Editor\n             */\n            saveAndCloseOnEnter : true,\n            triggerEvent : null,\n            /**\n             * This config parameter is passed to the `startDateField` and `endDateField` constructor.\n             * @config {String}\n             * @default\n             * @category Editor widgets\n             */\n            dateFormat : 'L', // date format that uses browser locale\n            /**\n             * This config parameter is passed to the `startTimeField` and `endTimeField` constructor.\n             * @config {String}\n             * @default\n             * @category Editor widgets\n             */\n            timeFormat : 'LT', // date format that uses browser locale\n            /**\n             * Default editor configuration, which widgets it shows etc.\n             *\n             * This is the entry point into configuring any aspect of the editor.\n             *\n             * The {@link Core.widget.Container#config-items} configuration of a Container\n             * is *deeply merged* with its default `items` value. This means that you can specify\n             * an `editorConfig` object which configures the editor, or widgets inside the editor:\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventEdit  : {\n             *             editorConfig : {\n             *                 autoClose : false,\n             *                 modal     : true,\n             *                 cls       : 'editor-widget-cls',\n             *                 items : {\n             *                     resourceField : {\n             *                         hidden : true\n             *                     },\n             *                     // Add our own event owner field at the top of the form.\n             *                     // Weight -100 will make it sort top the top.\n             *                     ownerField : {\n             *                         weight : -100,\n             *                         type   : 'usercombo',\n             *                         name   : 'owner',\n             *                         label  : 'Owner'\n             *                     }\n             *                 },\n             *                 bbar : {\n             *                     items : {\n             *                         deleteButton : false\n             *                     }\n             *                 }\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             * @config {PopupConfig}\n             * @category Editor\n             */\n            editorConfig : null,\n            /**\n             * An object to merge with the provided items config of the editor to override the\n             * configuration of provided fields, or add new fields.\n             *\n             * To remove existing items, set corresponding keys to `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventEdit  : {\n             *             items : {\n             *                 // Merged with provided config of the resource field\n             *                 resourceField : {\n             *                     label : 'Calendar'\n             *                 },\n             *                 recurrenceCombo : null,\n             *                 owner : {\n             *                     weight : -100, // Will sort above system-supplied fields which are weight 0\n             *                     type   : 'usercombo',\n             *                     name   : 'owner',\n             *                     label  : 'Owner'\n             *                 }\n             *             }\n             *         }\n             *     }\n             * });\n             *```\n             *\n             * The provided fields are called\n             *  - `nameField`\n             *  - `resourceField`\n             *  - `startDateField`\n             *  - `startTimeField`\n             *  - `endDateField`\n             *  - `endTimeField`\n             *  - `recurrenceCombo`\n             *  - `editRecurrenceButton`\n             * @config {Object<String,ContainerItemConfig|Boolean|null>}\n             * @category Editor widgets\n             */\n            items : null,\n            /**\n             * The week start day used in all date fields of the feature editor form by default.\n             * 0 means Sunday, 6 means Saturday.\n             * Defaults to the locale's week start day.\n             * @config {Number}\n             */\n            weekStartDay : null\n        };\n    }\n    //endregion\n    //region Init & destroy\n    construct(client, config) {\n        const me = this;\n        client.eventEdit = me;\n        super.construct(client, ObjectHelper.assign({\n            weekStartDay : client.weekStartDay\n        }, config));\n        me.clientListenersDetacher = client.ion({\n            [me.triggerEvent] : 'onActivateEditor',\n            dragCreateEnd     : 'onDragCreateEnd',\n            // Not fired at the Scheduler level.\n            // Calendar, which inherits this, implements this event.\n            eventAutoCreated : 'onEventAutoCreated',\n            thisObj          : me\n        });\n    }\n    doDestroy() {\n        this.clientListenersDetacher();\n        this._editor?.destroy();\n        super.doDestroy();\n    }\n    //endregion\n    //region Editing\n    // Not implemented at this level.\n    // Scheduler Editing relies on being called at point of event creation.\n    onEventAutoCreated() {}\n    changeEditorConfig(editorConfig) {\n        const { items } = this;\n        // Merge items which is an Object with the default editorConfig's items\n        if (items) {\n            editorConfig = Objects.clone(editorConfig);\n            editorConfig.items = Config.merge(items, editorConfig.items);\n        }\n        return editorConfig;\n    }\n    changeItems(items) {\n        this.cleanItemsConfig(items);\n        return items;\n    }\n    // Remove any items configured as === true which just means default config options\n    cleanItemsConfig(items) {\n        for (const ref in items) {\n            const itemCfg = items[ref];\n            if (itemCfg === true) {\n                delete items[ref];\n            }\n            else if (itemCfg?.items) {\n                this.cleanItemsConfig(itemCfg.items);\n            }\n        }\n    }\n    onDatesChange({ value, source }) {\n        const\n            me = this;\n        if ((source === me.endDateField || source === me.endTimeField) && me.startDateField) {\n            const\n                newEndDate   = me.endTimeField?.value && me.endDateField?.value ? copyTime(me.endDateField.value, me.endTimeField.value) : me.endDateField?.value,\n                newStartDate = me.startTimeField?.value && me.startDateField?.value ? copyTime(me.startDateField.value, me.startTimeField.value) : me.startDateField?.value;\n            if (newEndDate && newStartDate) {\n                me._durationMS = newEndDate - newStartDate;\n            }\n        }\n        // End date can never be less than start date\n        if (me.startDateField && me.endDateField) {\n            me.endDateField.min = me.startDateField.value;\n        }\n        if (me.endTimeField) {\n            // If the event starts and ends on the same day, the time fields need\n            // to have their min and max set against each other.\n            if (DH.isEqual(DH.clearTime(me.startDateField?.value), DH.clearTime(me.endDateField?.value))) {\n                me.endTimeField.min = me.startTimeField.value;\n            }\n            else {\n                me.endTimeField.min = null;\n            }\n        }\n        switch (source.ref) {\n            case 'startDateField':\n                me.startTimeField?.value && adjustEndDate(value, me.startTimeField.value, me);\n                break;\n            case 'startTimeField':\n                me.startDateField?.value && adjustEndDate(me.startDateField.value, value, me);\n                break;\n        }\n    }\n    //endregion\n    //region Save\n    async save() {\n        throw new Error('Implement in subclass');\n    }\n    get values() {\n        const\n            me          = this,\n            { editor }  = me,\n            startFields = [],\n            endFields   = [],\n            { values }  = editor;\n        // The standard values getter will produce (almost) what we want, however, there are some special fields that\n        // we need to take over. Remove those fields:\n        scheduleFields.forEach(f => delete values[f]);\n        editor.eachWidget(widget => {\n            const { name } = widget;\n            // If the widget is part of the recurrence editor, we don't gather it.\n            if (!name || widget.hidden || widget.up(w => w === me.recurrenceEditor)) {\n                delete values[name];\n                return;\n            }\n            switch (name) {\n                case 'startDate':\n                    startFields.push(widget);\n                    break;\n                case 'endDate':\n                    endFields.push(widget);\n                    break;\n                case 'resource':\n                    values[name] = widget.record;\n                    break;\n                case 'recurrenceRule':\n                    // If recurrence set to null, completely clear the recurrenceRule.\n                    // Otherwise it will still be perceived as recurring with the rule 'FREQ=none'\n                    values[name] = editor.widgetMap.recurrenceCombo?.value === 'none' ? '' : widget.value;\n                    break;\n                // Ignore other widgets and allow the standard values getter to provide them:\n                // default:\n                //     values[name] = widget.value;\n            }\n        }, true);\n        // if is changing from not allDay to allDay should consider time fields to not change them on makeDate\n        if (values.allDay && !me.eventRecord.allDay) {\n            startFields.push(me.startTimeField);\n            endFields.push(me.endTimeField);\n        }\n        // Handle fields being configured away\n        if (startFields.length) {\n            values.startDate = makeDate(startFields);\n        }\n        if (endFields.length) {\n            values.endDate = makeDate(endFields);\n        }\n        // Since there is no duration field in the editor,\n        // we don't need to recalculate duration value on each date change.\n        // It's enough to return correct duration value in `values`,\n        // so the record will get updated with the correct data.\n        if (('startDate' in values) && ('endDate' in values)) {\n            values.duration = DH.diff(values.startDate, values.endDate, me.editor.record.durationUnit, true);\n        }\n        return values;\n    }\n    /**\n     * Template method, intended to be overridden. Called before the event record has been updated.\n     * @param {Scheduler.model.EventModel} eventRecord The event record\n     *\n     **/\n    onBeforeSave(eventRecord) {}\n    /**\n     * Template method, intended to be overridden. Called after the event record has been updated.\n     * @param {Scheduler.model.EventModel} eventRecord The event record\n     *\n     **/\n    onAfterSave(eventRecord) {}\n    /**\n     * Updates record being edited with values from the editor\n     * @private\n     */\n    updateRecord(record) {\n        const { values } = this;\n        // Clean resourceId / resources out of values when using assignment store, it will handle the assignment\n        if (this.assignmentStore) {\n            delete values.resource;\n        }\n        this._durationMS = DateHelper.asMilliseconds(values.duration ?? record.duration, record.durationUnit);\n        return record.set(values);\n    }\n    //endregion\n    //region Events\n    onBeforeEditorShow() {\n        const\n            { eventRecord, editor } = this.editingContext,\n            { nameField } = editor.widgetMap;\n        // Editing new event. Make sure user doesn't have to clear the input field.\n        // Record field value still should be there because a rendered event block\n        // looks bad with no text in it.\n        // nameField may have been configured away.\n        if (nameField && eventRecord.isCreating) {\n            // Avoid initial invalid because required state.\n            editor.assigningValues = true;\n            nameField.value = '';\n            editor.assigningValues = false;\n            // Show new event text as a placeholder\n            nameField._configuredPlaceholder = nameField.placeholder;\n            nameField.placeholder = eventRecord.name;\n        }\n    }\n    resetEditingContext() {\n        const me = this;\n        if (!me.editingContext) {\n            return;\n        }\n        const\n            { client }              = me,\n            { editor, eventRecord } = me.editingContext,\n            { eventStore }          = client,\n            { nameField }           = editor.widgetMap;\n        // This will remove the record from the store, *and* from the added bag, so no sync will take place.\n        if (eventRecord.isCreating) {\n            // Ensure that during the engine's async processing of the remove, the element is non-interactive.\n            // Mousedown on the just-created element itself passes through here, and the immediate mouseup\n            // after that instigates a click which will find no corresponding event.\n            if (client.isTimelineBase) {\n                me.editingContext.eventElement?.closest('[data-event-id]').classList.add('b-released');\n            }\n            eventStore.remove(eventRecord);\n            // Clear isCreating *after* removal.\n            // Store doesn't register as a removed record if isCreating is set\n            eventRecord.isCreating = false;\n        }\n        // Revert any placeholder that we may have set\n        // nameField may have been configured away.\n        if (nameField) {\n            nameField.placeholder = nameField._configuredPlaceholder;\n        }\n        client.element.classList.remove('b-eventeditor-editing');\n        // Reset context\n        me.targetEventElement = me.editingContext = editor._record = null;\n    }\n    onPopupKeyDown({ event }) {\n        const me = this;\n        if (!me.readOnly && event.key === 'Enter' && me.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {\n            // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden\n            event.preventDefault();\n            // If enter key was hit in an input element of a start field, need to adjust end date fields (the same way as if #onDatesChange handler was called)\n            if (event.target.name === 'startDate') {\n                me.startTimeField && adjustEndDate(me.startDateField.value, me.startTimeField.value, me);\n            }\n            me.onSaveClick();\n        }\n    }\n    async finalizeStmCapture(saved) {\n    }\n    async onSaveClick() {\n        this.editor.focus();\n        this.isFinalizingEventSave = true;\n        const saved = await this.save();\n        this.isFinalizingEventSave = false;\n        if (saved) {\n            await this.finalizeStmCapture(false);\n            this.editor.close();\n            /**\n             * Fires on the owning Scheduler after editor is closed by any action - save, delete or cancel\n             * @event afterEventEdit\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             */\n            this.client.trigger('afterEventEdit');\n        }\n        return saved;\n    }\n    async onDeleteClick() {\n        // `deleteEvent` call actually additionally closes the editor for some reason\n        // see the comment for `editor.revertFocus();` call in EventEdit.js feature\n        // that triggers `resetEditingContext` in which by default we assume canceling flow\n        // so we need to detect that context is being reset for delete action somehow\n        this.isDeletingEvent = true;\n        const removed = await this.deleteEvent();\n        this.isDeletingEvent = false;\n        if (removed) {\n            await this.finalizeStmCapture(false);\n            const { editor } = this;\n            // We expect deleteEvent will trigger close if autoClose is true and focus has moved out,\n            // otherwise need to call it manually\n            if (!editor.autoClose || editor.containsFocus) {\n                editor.close();\n            }\n            this.client.trigger('afterEventEdit');\n        }\n    }\n    async onCancelClick() {\n        this.isCancelingEdit = true;\n        this.editor.close();\n        this.isCancelingEdit = false;\n        if (this.hasStmCapture) {\n            await this.finalizeStmCapture(true);\n        }\n        this.client.trigger('afterEventEdit');\n    }\n    //endregion\n}\nEditBase._$name = 'EditBase';", "import Store from '../../Core/data/Store.js';\nimport Popup from '../../Core/widget/Popup.js';\nimport '../../Core/widget/SlideToggle.js';\nimport '../../Core/widget/panel/PanelCollapserOverlay.js';\n/**\n * @module Scheduler/view/EventEditor\n */\n/**\n * Provided event editor dialog.\n *\n * @extends Core/widget/Popup\n * @private\n */\nexport default class EventEditor extends Popup {\n    // Factoryable type name\n    static get type() {\n        return 'eventeditor';\n    }\n    static get $name() {\n        return 'EventEditor';\n    }\n    static get configurable() {\n        return {\n            items     : [],\n            draggable : {\n                handleSelector : ':not(button,.b-field-inner)' // Ignore buttons and field inners\n            },\n            axisLock : 'flexible',\n            scrollable : {\n                // In case editor is very tall or window is small, make it scrollable\n                overflowY : true\n            },\n            readOnly : null,\n            /**\n             * A Function (or *name* of a function) which produces a customized Panel header based upon the event being edited.\n             *\n             * @config {Function|String}\n             * @param {Scheduler.model.EventModel} eventRecord The record being edited\n             * @returns {String} The Panel title.\n             */\n            titleRenderer : null,\n            // We want to maximize on phones and tablets\n            maximizeOnMobile : true\n        };\n    }\n    updateLocalization() {\n        super.updateLocalization(...arguments);\n        // Use this if there's no titleRenderer\n        this.initialTitle = this.title || '';\n    }\n    chainResourceStore() {\n        return this.eventEditFeature.resourceStore.chain(\n            record => !record.isSpecialRow,\n            null,\n            {\n                // It doesn't need to be a Project-based Store\n                storeClass              : Store,\n                // Need to show all records in the combo. Required in case resource store is a tree.\n                excludeCollapsedRecords : false\n            }\n        );\n    }\n    processWidgetConfig(widget) {\n        if (widget.type?.includes('date') && widget.weekStartDay == null) {\n            widget.weekStartDay = this.weekStartDay;\n        }\n        if (widget.type === 'extraItems') {\n            return false;\n        }\n        const\n            { eventEditFeature } = this,\n            fieldConfig          = {};\n        if (widget.ref === 'resourceField') {\n            const { store } = widget;\n            // Can't use store directly since it may be grouped and then contains irrelevant group records\n            widget.store = this.chainResourceStore();\n            // Allow the incoming widget's config to augment its store\n            if (store) {\n                widget.store.setConfig(store);\n            }\n            // When events are loaded with resourceId, we should only support single select.\n            // Only override this if the widget has not been explicitly configured\n            // with multiSelect.\n            if (!('multiSelect' in widget)) {\n                widget.multiSelect = !eventEditFeature.eventStore.usesSingleAssignment;\n            }\n        }\n        if ((widget.name === 'startDate' || widget.name === 'endDate') && widget.type === 'date') {\n            fieldConfig.format = eventEditFeature.dateFormat;\n        }\n        if ((widget.name === 'startDate' || widget.name === 'endDate') && widget.type === 'time') {\n            fieldConfig.format = eventEditFeature.timeFormat;\n        }\n        Object.assign(widget, fieldConfig);\n        return super.processWidgetConfig(widget);\n    }\n    setupEditorButtons() {\n        const\n            { record }       = this,\n            { deleteButton } = this.widgetMap;\n        // Hide delete button if we are readOnly or the event is in a create phase\n        // which means we are editing a dblclick-created or drag-created event.\n        if (deleteButton) {\n            deleteButton.hidden = this.readOnly || record.isCreating;\n        }\n    }\n    // This will be called if the editor is floating\n    onBeforeShow(...args) {\n        this.setupUIForEditing();\n        super.onBeforeShow?.(...args);\n    }\n    // This will be called if the editor is docked\n    onBeforeToggleReveal({ reveal }) {\n        // Only when revealing, not when sliding out\n        if (reveal) {\n            this.setupUIForEditing();\n        }\n    }\n    setupUIForEditing() {\n        const\n            me               = this,\n            {\n                record,\n                titleRenderer\n            }                = me;\n        me.setupEditorButtons();\n        if (titleRenderer) {\n            me.title = me.callback(titleRenderer, me, [record]);\n        }\n        else {\n            me.title = me.initialTitle;\n        }\n    }\n    onInternalKeyDown(event) {\n        this.trigger('keyDown', { event });\n        super.onInternalKeyDown(event);\n    }\n    updateReadOnly(readOnly) {\n        const\n            {\n                deleteButton,\n                saveButton,\n                cancelButton\n            } = this.widgetMap;\n        super.updateReadOnly(readOnly);\n        if (deleteButton) {\n            deleteButton.hidden = readOnly;\n        }\n        if (saveButton) {\n            saveButton.hidden = readOnly;\n        }\n        if (cancelButton) {\n            cancelButton.hidden = readOnly;\n        }\n    }\n}\n// Register this widget type with its Factory\nEventEditor.initClass();\nEventEditor._$name = 'EventEditor';", "import RecurrenceFrequencyCombo from './RecurrenceFrequencyCombo.js';\n/**\n * @module Scheduler/view/recurrence/field/RecurrenceCombo\n */\n/**\n * A combobox field for selecting a recurrence pattern: `Daily`, `Weekly`, `Monthly` or `Yearly` if the recurrence\n * has no other non-default settings, or `Custom...` if the recurrence has custom setting applied.\n *\n * {@inlineexample Scheduler/view/RecurrenceCombo.js}\n *\n * @extends Scheduler/view/recurrence/field/RecurrenceFrequencyCombo\n * @classtype recurrencecombo\n */\nexport default class RecurrenceCombo extends RecurrenceFrequencyCombo {\n    static get $name() {\n        return 'RecurrenceCombo';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencecombo';\n    }\n    static get defaultConfig() {\n        return {\n            customValue             : 'custom',\n            placeholder             : 'None',\n            splitCls                : 'b-recurrencecombo-split',\n            items                   : true,\n            highlightExternalChange : false\n        };\n    }\n    buildItems() {\n        const me = this;\n        return [\n            { value : 'none', text : 'L{None}' },\n            ...super.buildItems(),\n            { value : me.customValue, text : 'L{Custom}', cls : me.splitCls }\n        ];\n    }\n    set value(value) {\n        // Use 'none' instead of falsy value\n        value = value || 'none';\n        super.value = value;\n    }\n    get value() {\n        return super.value;\n    }\n    set recurrence(recurrence) {\n        const me = this;\n        if (recurrence) {\n            me.value = me.isCustomRecurrence(recurrence) ? me.customValue : recurrence.frequency;\n        }\n        else {\n            me.value = null;\n        }\n    }\n    isCustomRecurrence(recurrence) {\n        const { interval, days, monthDays, months } = recurrence;\n        return Boolean(interval > 1 || (days && days.length) || (monthDays && monthDays.length) || (months && months.length));\n    }\n};\n// Register this widget type with its Factory\nRecurrenceCombo.initClass();\nRecurrenceCombo._$name = 'RecurrenceCombo';", "import Button from '../../../Core/widget/Button.js';\nimport RecurrenceLegend from '../../data/util/recurrence/RecurrenceLegend.js';\n/**\n * @module Scheduler/view/recurrence/RecurrenceLegendButton\n */\n/**\n * A button which displays the associated {@link #property-recurrence} info in a human readable form.\n * @extends Core/widget/Button\n * @classtype recurrencelegendbutton\n */\nexport default class RecurrenceLegendButton extends Button {\n    static get $name() {\n        return 'RecurrenceLegendButton';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrencelegendbutton';\n    }\n    static get defaultConfig() {\n        return {\n            localizableProperties : [],\n            recurrence            : null\n        };\n    }\n    /**\n     * Sets / gets the recurrence to display description for.\n     * @property {Scheduler.model.RecurrenceModel}\n     */\n    set recurrence(recurrence) {\n        this._recurrence = recurrence;\n        this.updateLegend();\n    }\n    get recurrence() {\n        return this._recurrence;\n    }\n    set eventStartDate(eventStartDate) {\n        this._eventStartDate = eventStartDate;\n        this.updateLegend();\n    }\n    get eventStartDate() {\n        return this._eventStartDate;\n    }\n    updateLegend() {\n        const { recurrence } = this;\n        this.text = recurrence ? RecurrenceLegend.getLegend(recurrence, this.eventStartDate) : '';\n    }\n    onLocaleChange() {\n        // on locale switch we update the button text to use proper language\n        this.updateLegend();\n    }\n    updateLocalization() {\n        this.onLocaleChange();\n        super.updateLocalization();\n    }\n}\n// Register this widget type with its Factory\nRecurrenceLegendButton.initClass();\nRecurrenceLegendButton._$name = 'RecurrenceLegendButton';", "import Popup from '../../../Core/widget/Popup.js';\nimport './RecurrenceEditorPanel.js';\n/**\n * @module Scheduler/view/recurrence/RecurrenceEditor\n */\n/**\n * Class implementing a dialog to edit a {@link Scheduler.model.RecurrenceModel recurrence model}. The class is used by\n * the {@link Scheduler.view.mixin.RecurringEvents recurring events} feature, and you normally don't need to instantiate\n * it.\n *\n * Before showing the dialog need to use {@link Core.widget.Container#property-record} to load a\n * {@link Scheduler.model.RecurrenceModel recurrence model} data into the editor fields. For example:\n *\n * ```javascript\n * // make the editor instance\n * const editor = new RecurrenceEditor();\n * // load recurrence model into it\n * editor.record = new RecurrenceModel({ frequency : \"WEEKLY\" });\n * // display the editor\n * editor.show();\n * ```\n *\n * @extends Core/widget/Popup\n * @classtype recurrenceeditor\n */\nexport default class RecurrenceEditor extends Popup {\n    static get $name() {\n        return 'RecurrenceEditor';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'recurrenceeditor';\n    }\n    static get configurable() {\n        return {\n            draggable : true,\n            closable  : true,\n            floating  : true,\n            cls       : 'b-recurrenceeditor',\n            title     : 'L{Repeat event}',\n            autoClose : true,\n            width     : 470,\n            items     : {\n                recurrenceEditorPanel : {\n                    type  : 'recurrenceeditorpanel',\n                    title : null\n                }\n            },\n            bbar : {\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    foo : {\n                        type   : 'widget',\n                        cls    : 'b-label-filler',\n                        weight : 100\n                    },\n                    saveButton : {\n                        color   : 'b-green',\n                        text    : 'L{Save}',\n                        onClick : 'up.onSaveClick',\n                        weight  : 200\n                    },\n                    cancelButton : {\n                        color   : 'b-gray',\n                        text    : 'L{Object.Cancel}',\n                        onClick : 'up.onCancelClick',\n                        weight  : 300\n                    }\n                }\n            },\n            scrollable : {\n                overflowY : true\n            }\n        };\n    }\n    updateReadOnly(readOnly) {\n        super.updateReadOnly(readOnly);\n        // No save or cancel buttons. It's purely for information display when in readOnly mode\n        this.bbar.hidden = readOnly;\n    }\n    get recurrenceEditorPanel() {\n        return this.widgetMap.recurrenceEditorPanel;\n    }\n    updateRecord(record) {\n        this.recurrenceEditorPanel.record = record;\n    }\n    onSaveClick() {\n        const me = this;\n        if (me.saveHandler) {\n            me.saveHandler.call(me.thisObj || me, me, me.record);\n        }\n        else {\n            me.recurrenceEditorPanel.syncEventRecord();\n            me.close();\n        }\n    }\n    onCancelClick() {\n        const me = this;\n        if (me.cancelHandler) {\n            me.cancelHandler.call(me.thisObj || me, me, me.record);\n        }\n        else {\n            me.close();\n        }\n    }\n}\n// Register this widget type with its Factory\nRecurrenceEditor.initClass();\nRecurrenceEditor._$name = 'RecurrenceEditor';", "import Widget from '../../../Core/widget/Widget.js';\nimport Base from '../../../Core/Base.js';\nimport '../../view/recurrence/RecurrenceConfirmationPopup.js';\nimport '../../view/recurrence/field/RecurrenceCombo.js';\nimport '../../view/recurrence/RecurrenceLegendButton.js';\nimport '../../view/recurrence/RecurrenceEditor.js';\n/**\n * @module Scheduler/feature/mixin/RecurringEventEdit\n */\n/**\n * This mixin class provides recurring events functionality to the {@link Scheduler.feature.EventEdit event editor}.\n * @mixin\n */\nexport default Target => class RecurringEventEdit extends (Target || Base) {\n    static get $name() {\n        return 'RecurringEventEdit';\n    }\n    static get configurable() {\n        return {\n            recurringEventsItems : {\n                /**\n                 * Reference to the `Repeat` event field, if used\n                 * @member {Scheduler.view.recurrence.field.RecurrenceCombo} recurrenceCombo\n                 * @readonly\n                 */\n                recurrenceCombo : {\n                    type   : 'recurrencecombo',\n                    label  : 'L{EventEdit.Repeat}',\n                    ref    : 'recurrenceCombo',\n                    weight : 700\n                },\n                /**\n                 * Reference to the button that opens the event repeat settings dialog, if used\n                 * @member {Scheduler.view.recurrence.RecurrenceLegendButton} editRecurrenceButton\n                 * @readonly\n                 */\n                editRecurrenceButton : {\n                    type                 : 'recurrencelegendbutton',\n                    ref                  : 'editRecurrenceButton',\n                    name                 : 'recurrenceRule',\n                    color                : 'b-gray',\n                    menuIcon             : null,\n                    flex                 : 1,\n                    weight               : 800,\n                    ignoreParentReadOnly : true\n                }\n            },\n            /**\n             * Set to `false` to hide recurring fields in event editor, even if the\n             * {@link Scheduler.view.mixin.RecurringEvents#config-enableRecurringEvents Recurring Events} is `true`\n             * and a recurring event is being edited.\n             * @config {Boolean}\n             * @category Recurring\n             */\n            showRecurringUI : null\n        };\n    }\n    changeEditorConfig(editorConfig) {\n        editorConfig.items = { ...editorConfig.items, ...this.recurringEventsItems };\n        // EditBase inserts extraItems *after* all default items are in\n        editorConfig = super.changeEditorConfig(editorConfig);\n        return editorConfig;\n    }\n    doDestroy() {\n        this._recurrenceConfirmation?.destroy();\n        this._recurrenceEditor?.destroy();\n        super.doDestroy();\n    }\n    onEditorConstructed(editor) {\n        const me = this;\n        editor.ion({\n            hide    : me.onRecurringEventEditorHide,\n            thisObj : me\n        });\n        if (me.editRecurrenceButton) {\n            me.editRecurrenceButton.menu = me.recurrenceEditor;\n        }\n        me.recurrenceCombo?.ion({\n            change  : me.onRecurrenceComboChange,\n            thisObj : me\n        });\n    }\n    updateReadOnly(readOnly) {\n        if (this._recurrenceEditor) {\n            this._recurrenceEditor.readOnly = readOnly;\n        }\n    }\n    internalShowEditor() {\n        this.toggleRecurringFieldsVisibility(this.client.enableRecurringEvents && this.showRecurringUI !== false);\n    }\n    toggleRecurringFieldsVisibility(show = true) {\n        const methodName = show ? 'show' : 'hide';\n        this.editRecurrenceButton?.[methodName]?.();\n        this.recurrenceCombo?.[methodName]?.();\n    }\n    onRecurringEventEditorHide() {\n        if (this.recurrenceEditor?.isVisible) {\n            this.recurrenceEditor.hide();\n        }\n        if (this.recurrenceConfirmation?.isVisible) {\n            this.recurrenceConfirmation.hide();\n        }\n    }\n    // Builds RecurrenceModel to load into the recurrenceEditor\n    // It builds the model based on either:\n    // - recurrence rule string (if provided)\n    // - or the event being edited recurrence (if the event is repeating)\n    // - or simply make a recurrence model w/ default state (by default means: Frequency=Daily, Interval=1)\n    makeRecurrence(rule) {\n        const\n            event     = this.eventRecord,\n            eventCopy = event.copy();\n        let recurrence = event.recurrence;\n        if (!rule && recurrence) {\n            recurrence = recurrence.copy();\n        }\n        else {\n            recurrence = new event.recurrenceModel(rule ? { rule } : {});\n        }\n        // bind cloned recurrence to the cloned event\n        recurrence.timeSpan = eventCopy;\n        // update cloned event w/ start date from the UI field\n        eventCopy.setStartDate(this.values.startDate);\n        recurrence.suspendTimeSpanNotifying();\n        return recurrence;\n    }\n    onRecurrableEventBeforeSave({ eventRecord, context }) {\n        const me = this;\n        // Other views features may trigger beforeEventSave, so only react when *we* are editing.\n        if (me.isEditing && !eventRecord.isCreating && eventRecord.supportsRecurring &&\n                (eventRecord.isRecurring || eventRecord.isOccurrence)) {\n            me.recurrenceConfirmation.confirm({\n                actionType : 'update',\n                eventRecord,\n                changerFn() {\n                    context.finalize(true);\n                },\n                cancelFn() {\n                    context.finalize(false);\n                }\n            });\n            // signalizes that we plan to decide save or not asynchronously\n            context.async = true;\n        }\n    }\n    set recurrenceConfirmation(recurrenceConfirmation) {\n        this._recurrenceConfirmation = recurrenceConfirmation;\n    }\n    get recurrenceConfirmation() {\n        const me = this;\n        let recurrenceConfirmation = me._recurrenceConfirmation;\n        if (!recurrenceConfirmation || !recurrenceConfirmation.$$name) {\n            recurrenceConfirmation = Widget.create({\n                type  : 'recurrenceconfirmation',\n                owner : me.editor,\n                ...recurrenceConfirmation\n            });\n            me._recurrenceConfirmation = recurrenceConfirmation;\n        }\n        return recurrenceConfirmation;\n    }\n    set recurrenceEditor(recurrenceEditor) {\n        this._recurrenceEditor = recurrenceEditor;\n    }\n    get recurrenceEditor() {\n        const me = this;\n        let recurrenceEditor = me._recurrenceEditor;\n        // Recurrence editor is centered and modal.\n        if (!recurrenceEditor || !recurrenceEditor.$$name) {\n            me._recurrenceEditor = recurrenceEditor = Widget.create({\n                type         : 'recurrenceeditor',\n                autoShow     : false,\n                centered     : true,\n                modal        : true,\n                // It's used as the Menu of a Button which syncs the width unless it's already set\n                minWidth     : 'auto',\n                constrainTo  : globalThis,\n                anchor       : false,\n                rootElement  : me.rootElement,\n                saveHandler  : me.recurrenceEditorSaveHandler,\n                onBeforeShow : me.onBeforeShowRecurrenceEditor.bind(me),\n                thisObj      : me,\n                ...recurrenceEditor\n            });\n            // Must set *after* construction, otherwise it becomes the default state\n            // to reset readOnly back to.  Must use direct property access because\n            // getter consults state of editor.\n            recurrenceEditor.readOnly = me._readOnly;\n        }\n        return recurrenceEditor;\n    }\n    onBeforeShowRecurrenceEditor() {\n        const\n            me                                = this,\n            { recurrenceEditor, eventRecord } = me;\n        if (recurrenceEditor && eventRecord?.supportsRecurring) {\n            // if the event has no recurrence yet ..initialize it before showing recurrence editor\n            if (!me.recurrence) {\n                me.recurrence = me.makeRecurrence();\n            }\n            // update the cloned recurrence w/ up to date start date value\n            me.recurrence.timeSpan.setStartDate(me.values.startDate);\n            // load RecurrenceModel record into the recurrence editor\n            recurrenceEditor.record = me.recurrence;\n            // In case they drag it. Centered falls off if the widget has position set.\n            recurrenceEditor.centered = true;\n        }\n    }\n    loadRecurrenceData(recurrence) {\n        this.recurrence = recurrence;\n        this.updateRecurrenceFields(recurrence);\n    }\n    updateRecurrenceFields(recurrence) {\n        const\n            me                       = this,\n            { editRecurrenceButton } = me;\n        if (me.recurrenceCombo) {\n            me.recurrenceCombo.recurrence = recurrence;\n        }\n        // update the recurrence legend\n        if (editRecurrenceButton) {\n            editRecurrenceButton.recurrence = recurrence;\n            editRecurrenceButton.value = recurrence ? recurrence.rule : null;\n            if (recurrence && me.client.enableRecurringEvents && me.showRecurringUI !== false) {\n                editRecurrenceButton.show();\n            }\n            else {\n                editRecurrenceButton.hide();\n            }\n        }\n    }\n    onRecurrenceComboChange({ source, value, userAction }) {\n        if (userAction) {\n            const\n                me                   = this,\n                { recurrenceEditor } = me;\n            if (value === source.customValue) {\n                // if user picked \"Custom\" - show recurrence editor\n                // This will recurse through the change event into the opposite side\n                // of the value test which will call updateRecurrenceFields, where the\n                // assignment to the value of the recurrenceCombo will be a non-change.\n                // That will sync the state of the recurrenceButton.\n                me.recurrenceCombo.recurrence = me.makeRecurrence();\n                if (recurrenceEditor.centered) {\n                    recurrenceEditor.show();\n                }\n                else {\n                    recurrenceEditor.show((me.editRecurrenceButton || source).element);\n                }\n            }\n            // user has picked some frequency -> make a new recurrence based on it\n            else {\n                me.loadRecurrenceData(value && value !== 'none' ? me.makeRecurrence(`FREQ=${value}`) : null);\n            }\n        }\n    }\n    recurrenceEditorSaveHandler(editor, recurrence) {\n        // apply changes to the kept recurrence\n        editor.recurrenceEditorPanel.syncEventRecord(recurrence);\n        // update the recurrence related UI\n        this.updateRecurrenceFields(recurrence);\n        editor.close();\n    }\n    onDatesChange(...args) {\n        super.onDatesChange(...args);\n        if (!this.loadingRecord && this.editRecurrenceButton) {\n            const { startDate } = this.values;\n            if (startDate) {\n                this.editRecurrenceButton.eventStartDate = startDate;\n            }\n        }\n    }\n    internalLoadRecord(eventRecord) {\n        if (eventRecord?.supportsRecurring) {\n            this.loadRecurrenceData(eventRecord.recurrence ? this.makeRecurrence() : null);\n        }\n    }\n    updateRecord(record) {\n        // Special handling for when setting recurrence to \"None\". Since button gets hidden its value is not picked up\n        // by the normal flow.\n        if (record.recurrenceRule && !this.recurrence) {\n            record.recurrenceRule = null;\n        }\n        return super.updateRecord(record);\n    }\n};\n", "import Combo from '../../Core/widget/Combo.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n/**\n * @module Scheduler/widget/ResourceCombo\n */\n/**\n * A Combo subclass which selects resources, optionally displaying the {@link Scheduler.model.ResourceModel#field-eventColor}\n * of each resource in the picker and in the input area.\n *\n * {@inlineexample Scheduler/widget/ResourceCombo.js}\n *\n * @extends Core/widget/Combo\n * @classtype resourcecombo\n * @inputfield\n */\nexport default class ResourceCombo extends Combo {\n    static get $name() {\n        return 'ResourceCombo';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'resourcecombo';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Show the {@link Scheduler.model.ResourceModel#field-eventColor event color} for each resource\n             * @config {Boolean}\n             * @default false\n             */\n            showEventColor : null,\n            displayField : 'name',\n            valueField   : 'id',\n            picker : {\n                cls : 'b-resourcecombo-picker',\n                itemIconTpl(record) {\n                    if (this.owner.showEventColor) {\n                        const\n                            { eventColor } = record,\n                            isStyleColor   = !DomHelper.isNamedColor(eventColor),\n                            style          = eventColor ? (isStyleColor ? ` style=\"color:${eventColor}\"` : '') : ' style=\"display:none\"',\n                            colorClass     = !eventColor || isStyleColor ? '' : ` b-sch-foreground-${eventColor}`;\n                        return `<div class=\"b-icon b-icon-square${colorClass}\"${style}></div>`;\n                    }\n                    if (this.multiSelect) {\n                        return `<div class=\"b-icon b-icon-square\"></div>`;\n                    }\n                    return '';\n                }\n            }\n        };\n    }\n    changeShowEventColor(showEventColor) {\n        return Boolean(showEventColor);\n    }\n    updateShowEventColor(showEventColor) {\n        this.element.classList.toggle('b-show-event-color', Boolean(showEventColor));\n        this._picker?.element.classList.toggle('b-show-event-color', Boolean(showEventColor));\n    }\n    changePicker(picker, oldPicker) {\n        picker = super.changePicker(picker, oldPicker);\n        picker?.element.classList.toggle('b-show-event-color', Boolean(this.showEventColor));\n        return picker;\n    }\n    // Implementation needed at this level because it has two inner elements in its inputWrap\n    get innerElements() {\n        return [\n            {\n                class     : 'b-icon b-resource-icon b-icon-square b-hide-display',\n                reference : 'resourceIcon'\n            },\n            this.inputElement\n        ];\n    }\n    syncInputFieldValue() {\n        const\n            me            = this,\n            {\n                resourceIcon,\n                lastResourceIconCls\n            }             = me,\n            { classList } = resourceIcon,\n            eventColor    = me.selected?.eventColor ?? '';\n        super.syncInputFieldValue();\n        // Remove last colour whichever way it was done\n        resourceIcon.style.color = '';\n        lastResourceIconCls && classList.remove(lastResourceIconCls);\n        me.lastResourceIconCls = null;\n        if (eventColor) {\n            if (DomHelper.isNamedColor(eventColor)) {\n                me.lastResourceIconCls = `b-sch-foreground-${eventColor}`;\n                classList.add(me.lastResourceIconCls);\n            }\n            else {\n                resourceIcon.style.color = eventColor;\n            }\n            classList.remove('b-hide-display');\n        }\n        else {\n            classList.add('b-hide-display');\n        }\n    }\n}\n// Register this widget type with its Factory\nResourceCombo.initClass();\nResourceCombo._$name = 'ResourceCombo';", "import EditBase from './base/EditBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport '../view/EventEditor.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport RecurringEventEdit from './mixin/RecurringEventEdit.js';\nimport '../../Core/widget/TextField.js';\nimport '../../Scheduler/widget/ResourceCombo.js';\nimport TimeSpan from '../../Scheduler/model/TimeSpan.js';\nimport '../../Core/widget/DateField.js';\nimport '../../Core/widget/TimeField.js';\nimport '../../Core/widget/Button.js';\nimport '../widget/EventColorField.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport AsyncHelper from '../../Core/helper/AsyncHelper.js';\nimport TaskEditStm from './mixin/TaskEditStm.js';\n/**\n * @module Scheduler/feature/EventEdit\n */\nconst punctuation = /[^\\w\\d]/g;\n/**\n * Feature that displays a popup containing widgets for editing event data.\n *\n * {@inlineexample Scheduler/feature/EventEdit.js}\n *\n * To customize its contents you can:\n *\n * * Reconfigure built-in widgets by providing override configs in the {@link Scheduler.feature.base.EditBase#config-items} config.\n * * Change the date format of the date & time fields: {@link Scheduler.feature.base.EditBase#config-dateFormat} and {@link Scheduler.feature.base.EditBase#config-timeFormat }\n * * Configure provided widgets in the editor and add your own in the {@link Scheduler.feature.base.EditBase#config-items} config.\n * * Remove fields related to recurring events configuration (such as `recurrenceCombo`) by setting {@link Scheduler.feature.mixin.RecurringEventEdit#config-showRecurringUI} config to `false`.\n * * Advanced: Reconfigure the whole editor widget using {@link #config-editorConfig}\n *\n * ## Built-in widgets\n *\n * The built-in widgets are:\n *\n * | Widget ref             | Type                                                     | Weight | Description                                                    |\n * |------------------------|----------------------------------------------------------|--------|----------------------------------------------------------------|\n * | `nameField`            | {@link Core.widget.TextField}                            | 100    | Edit name                                                      |\n * | `resourceField`        | {@link Scheduler.widget.ResourceCombo}                   | 200    | Pick resource(s)                                               |\n * | `startDateField`       | {@link Core.widget.DateField}                            | 300    | Edit startDate (date part)                                     |\n * | `startTimeField`       | {@link Core.widget.TimeField}                            | 400    | Edit startDate (time part)                                     |\n * | `endDateField`         | {@link Core.widget.DateField}                            | 500    | Edit endDate (date part)                                       |\n * | `endTimeField`         | {@link Core.widget.TimeField}                            | 600    | Edit endDate (time part)                                       |\n * | `recurrenceCombo`      | {@link Scheduler.view.recurrence.field.RecurrenceCombo}  | 700    | Select recurrence rule (only visible if recurrence is used)    |\n * | `editRecurrenceButton` | {@link Scheduler.view.recurrence.RecurrenceLegendButton} | 800    | Edit the recurrence rule  (only visible if recurrence is used) |\n * | `colorField` \u00B9         | {@link Scheduler.widget.EventColorField}                 | 700    | Choose background color for the event bar                      |\n *\n * **\u00B9** Set the {@link Scheduler.view.SchedulerBase#config-showEventColorPickers} config to `true` to enable this field\n *\n * The built-in buttons are:\n *\n * | Widget ref             | Type                                                                     | Weight | Description                                                    |\n * |------------------------|--------------------------------------------------------------------------|--------|----------------------------------------------------------------|\n * | `saveButton`           | {@link Core.widget.Button}                                               | 100    | Save event button on the bbar                                  |\n * | `deleteButton`         | {@link Core.widget.Button}                                               | 200    | Delete event button on the bbar                                |\n * | `cancelButton`         | {@link Core.widget.Button}                                               | 300    | Cancel event editing button on the bbar                        |\n *\n * ## Removing a built-in item\n *\n * To remove a built-in widget, specify its `ref` as `null` in the `items` config:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventEdit : {\n *             items : {\n *                 // Remove the start time field\n *                 startTimeField : null\n *             }\n *         }\n *     }\n * })\n * ```\n *\n * Bottom buttons may be hidden using the `bbar` config passed to `editorConfig`:\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventEdit : {\n *             editorConfig : {\n *                 bbar : {\n *                     items : {\n *                         deleteButton : null\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * })\n * ```\n *\n * To remove fields related to recurring events configuration (such as `recurrenceCombo`), set {@link Scheduler.feature.mixin.RecurringEventEdit#config-showRecurringUI} config to `false`.\n *\n * ## Customizing a built-in widget\n *\n * To customize a built-in widget, use its `ref` as the key in the `items` config and specify the configs you want\n * to change (they will merge with the widgets default configs):\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventEdit : {\n *             items : {\n *                 // ref for an existing field\n *                 nameField : {\n *                     // Change its label\n *                     label : 'Description'\n *                 }\n *             }\n *         }\n *     }\n * })\n * ```\n *\n * ## Adding custom widgets\n *\n * To add a custom widget, add an entry to the `items` config. The `name` property links the input field to a field in\n * the loaded event record:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventEdit : {\n *             items : {\n *                 // Key to use as fields ref (for easier retrieval later)\n *                 color : {\n *                     type  : 'combo',\n *                     label : 'Color',\n *                     items : ['red', 'green', 'blue'],\n *                     // name will be used to link to a field in the event record when loading and saving in the editor\n *                     name  : 'eventColor'\n *                 }\n *             }\n *         }\n *     }\n * })\n * ```\n *\n * ## Video guides\n * {@frameworktabs}\n * {@react}\n * [@youtube](https://www.youtube.com/embed/ghWLmifpO_4)\n * {@endreact}\n * {@vue}\n * [@youtube](https://www.youtube.com/embed/o7xQ6B_Y04w)\n * {@endvue}\n * {@angular}\n * **Coming soon!**\n * {@endangular}\n * {@endframeworktabs}\n *\n * For more info on customizing the event editor, please see \"Customize event editor\" guide.\n *\n * This feature is **enabled** by default\n *\n * @mixes Scheduler/feature/mixin/RecurringEventEdit\n * @extends Scheduler/feature/base/EditBase\n * @demo Scheduler/eventeditor\n * @classtype eventEdit\n * @feature\n */\nexport default class EventEdit extends EditBase.mixin(TaskEditStm, RecurringEventEdit, Delayable) {\n    //region Config\n    static get $name() {\n        return 'EventEdit';\n    }\n    static get configurable() {\n        return {\n            /**\n             * The event that shall trigger showing the editor. Defaults to `eventdblclick`, set to `''` or null to\n             * disable editing of existing events.\n             * @config {String}\n             * @default\n             * @category Editor\n             */\n            triggerEvent : 'eventdblclick',\n            /**\n             * The data field in the model that defines the eventType.\n             * Applied as class (b-eventtype-xx) to the editors element, to allow showing/hiding fields depending on\n             * eventType. Dynamic toggling of fields in the editor is activated by adding an `eventTypeField` field to\n             * your widget:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *    features : {\n             *       eventEdit : {\n             *           items : {\n             *               eventTypeField : {\n             *                  type  : 'combo',\n             *                  name  : 'eventType',\n             *                  label : 'Type',\n             *                  items : ['Appointment', 'Internal', 'Meeting']\n             *               }\n             *           }\n             *        }\n             *     }\n             * });\n             * ```\n             * Note, your event model class also must declare this field:\n             * ```javascript\n             *  class MyEvent extends EventModel {\n             *      static get fields() {\n             *          return [\n             *              { name : 'eventType' }\n             *          ];\n             *      }\n             *  }\n             * ```\n             * @config {String}\n             * @default\n             * @category Editor\n             */\n            typeField : 'eventType',\n            /**\n             * The current {@link Scheduler.model.EventModel} record, which is being edited by the event editor.\n             * @property {Scheduler.model.EventModel}\n             * @readonly\n             */\n            eventRecord : null,\n            /**\n             * Specify `true` to put the editor in read only mode.\n             * @config {Boolean}\n             * @default false\n             */\n            readOnly : null,\n            /**\n             * The configuration for the internal editor widget. With this config you can control the *type*\n             * of editor (defaults to `Popup`) and which widgets to show,\n             * change the items in the `bbar`, or change whether the popup should be modal etc.\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventEdit  : {\n             *             editorConfig : {\n             *                 modal  : true,\n             *                 cls    : 'my-editor' // A CSS class,\n             *                 items  : {\n             *                     owner : {\n             *                         weight : -100, // Will sort above system-supplied fields which are weight 100 to 800\n             *                         type   : 'usercombo',\n             *                         name   : 'owner',\n             *                         label  : 'Owner'\n             *                     },\n             *                     agreement : {\n             *                         weight : 1000, // Will sort below system-supplied fields which are weight 100 to 800\n             *                         type   : 'checkbox',\n             *                         name   : 'agreement',\n             *                         label  : 'Agree to terms'\n             *                     },\n             *                     resourceField : {\n             *                         // Apply a special filter to limit the Combo's access\n             *                         // to resources.\n             *                         store  {\n             *                             filters : [{\n             *                                 filterBy(resource) {\n             *                                     return shouldShowResource(record);\n             *                                 }\n             *                             }]\n             *                         }\n             *                     }\n             *                 },\n             *                 bbar : {\n             *                     items : {\n             *                         deleteButton : {\n             *                             hidden : true\n             *                         }\n             *                     }\n             *                 }\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * Or to use your own custom editor:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventEdit  : {\n             *             editorConfig : {\n             *                 type : 'myCustomEditorType'\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             * @config {Object}\n             * @category Editor\n             */\n            editorConfig : {\n                type        : 'eventeditor',\n                title       : 'L{EventEdit.Edit event}',\n                closable    : true,\n                localeClass : this,\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    /**\n                     * Reference to the name field, if used\n                     * @member {Core.widget.TextField} nameField\n                     * @readonly\n                     */\n                    nameField : {\n                        type      : 'text',\n                        label     : 'L{Name}',\n                        clearable : true,\n                        name      : 'name',\n                        weight    : 100,\n                        required  : true\n                    },\n                    /**\n                     * Reference to the resource field, if used\n                     * @member {Core.widget.Combo} resourceField\n                     * @readonly\n                     */\n                    resourceField : {\n                        type                    : 'resourcecombo',\n                        label                   : 'L{Resource}',\n                        name                    : 'resource',\n                        editable                : true,\n                        valueField              : 'id',\n                        displayField            : 'name',\n                        highlightExternalChange : false,\n                        destroyStore            : true,\n                        weight                  : 200\n                    },\n                    /**\n                     * Reference to the start date field, if used\n                     * @member {Core.widget.DateField} startDateField\n                     * @readonly\n                     */\n                    startDateField : {\n                        type             : 'date',\n                        clearable        : false,\n                        required         : true,\n                        label            : 'L{Start}',\n                        name             : 'startDate',\n                        validateDateOnly : true,\n                        weight           : 300\n                    },\n                    /**\n                     * Reference to the start time field, if used\n                     * @member {Core.widget.TimeField} startTimeField\n                     * @readonly\n                     */\n                    startTimeField : {\n                        type      : 'time',\n                        clearable : false,\n                        required  : true,\n                        name      : 'startDate',\n                        cls       : 'b-match-label',\n                        weight    : 400\n                    },\n                    /**\n                     * Reference to the end date field, if used\n                     * @member {Core.widget.DateField} endDateField\n                     * @readonly\n                     */\n                    endDateField : {\n                        type             : 'date',\n                        clearable        : false,\n                        required         : true,\n                        label            : 'L{End}',\n                        name             : 'endDate',\n                        validateDateOnly : true,\n                        weight           : 500\n                    },\n                    /**\n                     * Reference to the end time field, if used\n                     * @member {Core.widget.TimeField} endTimeField\n                     * @readonly\n                     */\n                    endTimeField : {\n                        type      : 'time',\n                        clearable : false,\n                        required  : true,\n                        name      : 'endDate',\n                        cls       : 'b-match-label',\n                        weight    : 600\n                    },\n                    colorField : {\n                        label  : 'L{SchedulerBase.color}',\n                        type   : 'eventColorField',\n                        name   : 'eventColor',\n                        weight : 700\n                    }\n                },\n                bbar : {\n                    // When readOnly, child buttons are hidden\n                    hideWhenEmpty : true,\n                    defaults : {\n                        localeClass : this\n                    },\n                    items : {\n                        /**\n                         * Reference to the save button, if used\n                         * @member {Core.widget.Button} saveButton\n                         * @readonly\n                         */\n                        saveButton : {\n                            color  : 'b-blue',\n                            cls    : 'b-raised',\n                            text   : 'L{Save}',\n                            weight : 100\n                        },\n                        /**\n                         * Reference to the delete button, if used\n                         * @member {Core.widget.Button} deleteButton\n                         * @readonly\n                         */\n                        deleteButton : {\n                            text   : 'L{Delete}',\n                            weight : 200\n                        },\n                        /**\n                         * Reference to the cancel button, if used\n                         * @member {Core.widget.Button} cancelButton\n                         * @readonly\n                         */\n                        cancelButton : {\n                            text   : 'L{Object.Cancel}',\n                            weight : 300\n                        }\n                    }\n                }\n            },\n            targetEventElement : null\n        };\n    }\n    static get pluginConfig() {\n        return {\n            chain : [\n                'populateEventMenu',\n                'onEventEnterKey',\n                'editEvent'\n            ]\n        };\n    }\n    //endregion\n    //region Init & destroy\n    construct(scheduler, config) {\n        // Default to the scheduler's state, but configs may override\n        this.readOnly = scheduler.readOnly;\n        super.construct(scheduler, config);\n        scheduler.ion({\n            projectChange : 'onChangeProject',\n            readOnly      : 'onClientReadOnlyToggle',\n            thisObj       : this\n        });\n    }\n    get scheduler() {\n        return this.client;\n    }\n    get project() {\n        return this.client.project;\n    }\n    //endregion\n    //region Editing\n    /**\n     * Get/set readonly state\n     * @property {Boolean}\n     */\n    get readOnly() {\n        return this._editor ? this.editor.readOnly : this._readOnly;\n    }\n    updateReadOnly(readOnly) {\n        super.updateReadOnly(readOnly);\n        if (this._editor) {\n            this.editor.readOnly = readOnly;\n        }\n    }\n    onClientReadOnlyToggle({ readOnly }) {\n        this.readOnly = readOnly;\n    }\n    /**\n     * Returns the editor widget representing this feature\n     * @member {Core.widget.Popup}\n     */\n    get editor() {\n        const\n            me              = this,\n            editorListeners = {\n                beforehide : 'resetEditingContext',\n                beforeshow : 'onBeforeEditorShow',\n                keydown    : 'onPopupKeyDown',\n                thisObj    : me\n            };\n        let { _editor : editor } = me;\n        if (editor) {\n            return editor;\n        }\n        editor = me._editor = Widget.create(me.getEditorConfig());\n        const {\n            startDateField,\n            startTimeField,\n            endDateField,\n            endTimeField\n        } = editor.widgetMap;\n        // If the date field doesn't exist, the time field must encapsulate the\n        // date component of the start/end points and must lay out right.\n        if (!startDateField && startTimeField) {\n            startTimeField.keepDate = true;\n            startTimeField.label = me.L('Start');\n            startTimeField.flex = '1 0 100%';\n        }\n        if (!endDateField && endTimeField) {\n            endTimeField.keepDate = true;\n            endTimeField.label = me.L('End');\n            endTimeField.flex = '1 0 100%';\n        }\n        // If the default Popup has been reconfigured to be static, add it as a child of our client.\n        if (!editor.floating && !editor.positioned) {\n            // If not configured with an appendTo, we add it as a child of our client.\n            if (!editor.element.parentNode) {\n                me.client.add(editor);\n            }\n            delete editorListeners.beforehide;\n            delete editorListeners.beforeshow;\n            editorListeners.beforeToggleReveal = 'onBeforeEditorToggleReveal';\n        }\n        // Must set *after* construction, otherwise it becomes the default state\n        // to reset readOnly back to. Must use direct property access because\n        // getter consults state of editor.\n        editor.readOnly = me._readOnly;\n        if (editor.items.length === 0) {\n            console.warn('Event Editor configured without any `items`');\n        }\n        // add listeners programmatically so users cannot override them accidentally\n        editor.ion(editorListeners);\n        /**\n         * Fired before the editor will load the event record data into its input fields. This is useful if you\n         * want to modify the fields before data is loaded (e.g. set some input field to be readonly)\n         * @on-owner\n         * @event eventEditBeforeSetRecord\n         * @param {Core.widget.Container} source The editor widget\n         * @param {Scheduler.model.EventModel} record The record\n         */\n        me.scheduler.relayEvents(editor, ['beforeSetRecord'], 'eventEdit');\n        // assign widget variables, using widget name: startDate -> me.startDateField\n        // widgets with id set use that instead, id -> me.idField\n        Object.values(editor.widgetMap).forEach(widget => {\n            const ref = widget.ref || widget.id;\n            // don't overwrite if already defined\n            if (ref && !me[ref]) {\n                me[ref] = widget;\n                switch (widget.name) {\n                    case 'startDate':\n                    case 'endDate':\n                        widget.ion({ change : 'onDatesChange', thisObj : me });\n                        break;\n                }\n            }\n        });\n        // launch onEditorConstructed hook if provided\n        me.onEditorConstructed?.(editor);\n        me.eventTypeField?.ion({ change : 'onEventTypeChange', thisObj : me });\n        me.saveButton?.ion({ click : 'onSaveClick', thisObj : me });\n        me.deleteButton?.ion({ click : 'onDeleteClick', thisObj : me });\n        me.cancelButton?.ion({ click : 'onCancelClick', thisObj : me });\n        return editor;\n    }\n    getEditorConfig() {\n        const\n            me                 = this,\n            { cls, scheduler } = me,\n            result             = ObjectHelper.assign({\n                owner            : scheduler,\n                eventEditFeature : me,\n                weekStartDay     : me.weekStartDay,\n                align            : 'b-t',\n                id               : `${scheduler.id}-event-editor`,\n                autoShow         : false,\n                anchor           : true,\n                scrollAction     : 'realign',\n                constrainTo      : globalThis,\n                cls\n            }, me.editorConfig);\n        // User configuration may have included a render target which means the editor\n        // will not be floating.\n        if (Widget.prototype.getRenderContext(result)[0]) {\n            result.floating = false;\n        }\n        // If the default Popup has been reconfigured to be static, ensure it starts\n        // life as a visible but collapsed panel.\n        if (result.floating === false && !result.positioned) {\n            result.collapsible = {\n                type           : 'overlay',\n                direction      : 'right',\n                autoClose      : false,\n                tool           : null,\n                recollapseTool : null\n            };\n            result.collapsed = true;\n            result.hidden = result.anchor = false;\n            result.hide = function() {\n                this.collapsible.toggleReveal(false);\n            };\n        }\n        if (!scheduler.showEventColorPickers && result.items.colorField) {\n            result.items.colorField.hidden = true;\n        }\n        // Layout-affecting props must be available early so that appendTo ends up with\n        // correct layout.\n        result.onElementCreated = me.updateCSSVars.bind(this);\n        return result;\n    }\n    updateCSSVars({ element }) {\n        // must result in longest format, ie 2 digits for date and all time parts.\n        const\n            time               = new Date(2000, 12, 31, 23, 55, 55),\n            dateLength         = DateHelper.format(time, this.dateFormat).replace(punctuation, '').length,\n            timeLength         = DateHelper.format(time, this.timeFormat).replace(punctuation, '').length,\n            dateTimeLength     = dateLength + timeLength;\n        element.style.setProperty('--date-time-length', `${dateTimeLength}em`);\n        element.style.setProperty('--date-width-difference', `${(dateLength - timeLength) / 2}em`);\n    }\n    // Called from editEvent() to actually show the editor\n    async internalShowEditor(eventRecord, resourceRecord, align = null) {\n        const\n            me            = this,\n            { scheduler } = me,\n            { useInitialAnimation } = scheduler,\n            // Align to the element (b-sch-event) and not the wrapper\n            eventElement = align?.target?.nodeType === Element.ELEMENT_NODE\n                ? align.target\n                : scheduler.getElementFromEventRecord(eventRecord, resourceRecord),\n            isPartOfStore = eventRecord.isPartOfStore(scheduler.eventStore);\n        align = align ?? {\n            // Align to the element (b-sch-event) and not the wrapper\n            target : eventElement,\n            anchor : true\n        };\n        // Event not in current TimeAxis - cannot be edited without extending the TimeAxis.\n        // If there's no event element and the eventRecord is not in the store, we still\n        // edit centered on the Scheduler - we're adding a new event\n        if (align.target || (!isPartOfStore || eventRecord.resources.length === 0) || eventRecord.isCreating) {\n            // need to add this css class as early as possible to prevent\n            // the event tooltip from appearing\n            scheduler.element.classList.add('b-eventeditor-editing');\n            me.resourceRecord = resourceRecord;\n            const { editor } = me;\n            me.editingContext = {\n                eventRecord,\n                resourceRecord,\n                eventElement,\n                editor,\n                isPartOfStore\n            };\n            super.internalShowEditor?.(eventRecord, resourceRecord, align);\n            if (me.typeField) {\n                me.toggleEventType(eventRecord.getValue(me.typeField));\n            }\n            me.loadRecord(eventRecord, resourceRecord);\n            // If it's a static child of the client which is collapsed, expand it.\n            // Floating components focusOnShow by default, this will need to be focused.\n            if (editor.collapsed) {\n                // The *initial* reveal does not animate unless the toggleReveal call is delayed.\n                await AsyncHelper.sleep(100);\n                await editor.collapsible.toggleReveal(true);\n                editor.focus();\n            }\n            // Honour alignment settings \"anchor\" and \"centered\" which may be injected from editorConfig.\n            else if (editor.centered || !editor.anchor || !editor.floating) {\n                editor.show();\n            }\n            // avoid aligning to an event being animated into place, just center in these cases\n            else if (eventElement && (!eventRecord.isCreating || !useInitialAnimation || useInitialAnimation === true || useInitialAnimation === 'fade-in')) {\n                me.targetEventElement = eventElement;\n                editor.showBy(align);\n            }\n            // We are adding an unrendered event. Display the editor centered\n            else {\n                editor.show();\n                // Must be done after show because show always reverts to its configured centered setting.\n                editor.updateCentered(true);\n            }\n            // Adjust time field step increment based on timeAxis resolution\n            const timeResolution = scheduler.timeAxisViewModel.timeResolution;\n            if (timeResolution.unit === 'hour' || timeResolution.unit === 'minute') {\n                const step = `${timeResolution.increment}${timeResolution.unit}`;\n                if (me.startTimeField) {\n                    me.startTimeField.step = step;\n                }\n                if (me.endTimeField) {\n                    me.endTimeField.step = step;\n                }\n            }\n            // Might end up here with the old listener still around in monkey test for stress demo in turbo mode.\n            // Some action happening during edit, but cannot track down what is going on\n            me.detachListeners('changesWhileEditing');\n            scheduler.eventStore.ion({\n                change  : me.onChangeWhileEditing,\n                refresh : me.onChangeWhileEditing,\n                thisObj : me,\n                name    : 'changesWhileEditing'\n            });\n        }\n    }\n    onChangeWhileEditing() {\n        const me = this;\n        // If event was removed, cancel editing\n        // - however, there's one valid case when even can be removed during save finalization - that is when\n        // all its assignments has been removed - in such case ignore the removal and do not call the `onCancelClick`\n        // because that will reject the STM transaction and revert all changes\n        // - also, do not trigger it when the editor is configured with the `autoUpdateRecord` - because in such case\n        // the data change will be happening right during the editing\n        if (!me.editor.autoUpdateRecord && !me.isFinalizingEventSave && me.isEditing && me.editingContext.isPartOfStore && !me.eventRecord.isPartOfStore(me.scheduler.eventStore)) {\n            me.onCancelClick();\n        }\n    }\n    // Fired in a listener so that it's after the auto-called onBeforeShow listeners so that\n    // subscribers to the beforeEventEditShow are called at exactly the correct lifecycle point.\n    onBeforeEditorShow() {\n        super.onBeforeEditorShow(...arguments);\n        /**\n         * Fires on the owning Scheduler when the editor for an event is available but before it is populated with\n         * data and shown. Allows manipulating fields etc.\n         * @event beforeEventEditShow\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler\n         * @param {Scheduler.feature.EventEdit} eventEdit The eventEdit feature\n         * @param {Scheduler.model.EventModel} eventRecord The record about to be shown in the event editor.\n         * @param {Scheduler.model.ResourceModel} resourceRecord The Resource record for the event. If the event\n         * is being created, it will not contain a resource, so this parameter specifies the resource the\n         * event is being created for.\n         * @param {HTMLElement} eventElement The element which represents the event in the scheduler display.\n         * @param {Core.widget.Popup} editor The editor\n         */\n        this.scheduler.trigger('beforeEventEditShow', {\n            eventEdit : this,\n            ...this.editingContext\n        });\n    }\n    updateTargetEventElement(targetEventElement, oldTargetEventElement) {\n        targetEventElement?.classList.add('b-editing');\n        oldTargetEventElement?.classList.remove('b-editing');\n    }\n    /**\n     * Opens an editor for the passed event. This function is exposed on Scheduler and can be called as\n     * `scheduler.editEvent()`.\n     * @param {Scheduler.model.EventModel} eventRecord Event to edit\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] The Resource record for the event.\n     * This parameter is needed if the event is newly created for a resource and has not been assigned, or when using\n     * multi assignment.\n     * @param {HTMLElement} [element] Element to anchor editor to (defaults to events element)\n     * @on-owner\n     */\n    editEvent(eventRecord, resourceRecord, element = null, stmCapture = null) {\n        const\n            me = this,\n            { client } = me,\n            { simpleEventEdit } = client.features;\n        if (me.isEditing) {\n            // old editing flow already running, clean it up\n            me.resetEditingContext();\n        }\n        // If simple edit feature is active, use it when a new event is created\n        if (me.disabled || eventRecord.readOnly || (eventRecord.isCreating && simpleEventEdit?.enabled)) {\n            return;\n        }\n        /**\n         * Fires on the owning Scheduler before an event is displayed in an editor.\n         * This may be listened for to allow an application to take over event editing duties. Returning `false`\n         * stops the default editing UI from being shown.\n         * @event beforeEventEdit\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler\n         * @param {Scheduler.feature.EventEdit} eventEdit The eventEdit feature\n         * @param {Scheduler.model.EventModel} eventRecord The record about to be shown in the event editor.\n         * @param {Scheduler.model.ResourceModel} resourceRecord The Resource record for the event. If the event\n         * is being created, it will not contain a resource, so this parameter specifies the resource the\n         * event is being created for.\n         * @param {HTMLElement} eventElement The element which represents the event in the scheduler display.\n         * @preventable\n         */\n        if (client.trigger('beforeEventEdit', {\n            eventEdit    : me,\n            eventRecord,\n            resourceRecord,\n            eventElement : client.getElementFromEventRecord?.(eventRecord, resourceRecord) || element\n        }) === false) {\n            client.element.classList.remove('b-eventeditor-editing');\n            return false;\n        }\n        if (stmCapture) {\n            me.applyStmCapture(stmCapture);\n            me.hasStmCapture = true;\n            // indicate that editor has been opened, and is now managing the \"stm capture\"\n            stmCapture.transferred = true;\n        }\n        // it is set to `false` by calendar, to ignore the STM mechanism\n        else if (stmCapture !== false && !client.isCalendar && !me.hasStmCapture) {\n            me.captureStm(true);\n        }\n        return me.doEditEvent(...arguments).then(result => {\n            if (!me.isDestroying) {\n                // The Promise being async allows a mouseover to trigger the event tip\n                // unless we add the editing class immediately (But only if we actually began editing).\n                if (!me.isEditing && !client.isCalendar && !me.rejectingStmTransaction) {\n                    // probably a custom event editor was used or editing was vetoed for some other reason\n                    if (result !== false && me.hasStmCapture) {\n                        // Skip stm rejection if built-in editor is disabled in beforeEventEdit (using of custom event editor)\n                        return me.freeStm(false);\n                    }\n                    else {\n                        return me.freeStm();\n                    }\n                }\n            }\n        });\n    }\n    /**\n     * Returns true if the editor is currently active\n     * @readonly\n     * @property {Boolean}\n     */\n    get isEditing() {\n        const { _editor } = this;\n        return Boolean(\n            // Editor is not visible if it is collapsed and not expanded\n            _editor?.isVisible && !(_editor.collapsed && !_editor.revealed)\n        );\n    }\n    // editEvent is the single entry point in the base class.\n    // Subclass implementations of the action may differ, so are implemented in doEditEvent\n    async doEditEvent(eventRecord, resourceRecord, element = null) {\n        const\n            me            = this,\n            { scheduler } = me,\n            isNewRecord   = eventRecord.isCreating;\n        if (!resourceRecord) {\n            // Need to handle resourceId for edge case when creating an event with resourceId and editing it before\n            // adding it to the EventStore\n            resourceRecord = eventRecord.resource || me.resourceStore.getById(eventRecord.resourceId);\n        }\n        if (isNewRecord) {\n            // Ensure temporal data fields are ready when the editor is shown\n            TimeSpan.prototype.normalize.call(eventRecord);\n        }\n        // If element is specified (call triggered by EventDragCreate)\n        // Then we can align to that, and no scrolling is necessary.\n        // If we are simply being asked to edit a new event which is not\n        // yet added, the editor is centered, and no scroll is necessary\n        if (element || isNewRecord || eventRecord.resources.length === 0) {\n            return me.internalShowEditor(eventRecord, resourceRecord, element ? {\n                target : element\n            } : null);\n        }\n        else {\n            // Ensure event is in view before showing the editor.\n            // Note that we first need to extend the time axis to include\n            // currently out of range events.\n            await scheduler.scrollResourceEventIntoView(resourceRecord, eventRecord, {\n                animate        : true,\n                edgeOffset     : 0,\n                extendTimeAxis : false\n            });\n            if (!scheduler.isDestroyed) {\n                await me.internalShowEditor(eventRecord, resourceRecord);\n                if (!scheduler.isDestroyed) {\n                    scheduler.element.classList.remove('b-eventeditor-editing');\n                }\n            }\n        }\n    }\n    /**\n     * Sets fields values from record being edited\n     * @private\n     */\n    loadRecord(eventRecord, resourceRecord) {\n        this.loadingRecord = true;\n        this.internalLoadRecord(eventRecord, resourceRecord);\n        this.loadingRecord = false;\n    }\n    get eventRecord() {\n        return this._editor?.record;\n    }\n    internalLoadRecord(eventRecord, resourceRecord) {\n        const\n            me                        = this,\n            { eventStore }            = me.client,\n            { editor, resourceField } = me;\n        me.resourceRecord = resourceRecord;\n        // Update chained store early, to have records in place when setting value below (avoids adding the resource to\n        // empty combo store, https://github.com/bryntum/support/issues/5378). It is not done automatically for\n        // grouping/trees or when project is replaced\n        if (resourceField && resourceField.store?.masterStore !== me.resourceStore) {\n            resourceField.store = editor.chainResourceStore();\n        }\n        editor.record = eventRecord;\n        if (resourceField) {\n            const resources = eventStore.assignmentStore.getResourcesForEvent(eventRecord);\n            // Flag on parent Container to indicate that initially blank fields are valid\n            editor.assigningValues = true;\n            // If this is an unassigned event, select the resource we've been provided\n            if (!eventRecord.isOccurrence && !eventStore.storage.includes(eventRecord, true) && resourceRecord) {\n                me.resourceField.value = resourceRecord.getValue(me.resourceField.valueField);\n            }\n            else if (me.assignmentStore) {\n                me.resourceField.value = resources.map((resource) => resource.getValue(me.resourceField.valueField));\n            }\n            editor.assigningValues = false;\n        }\n        super.internalLoadRecord(eventRecord, resourceRecord);\n    }\n    toggleEventType(eventType) {\n        // expose eventType in dataset, for querying and styling\n        this.editor.element.dataset.eventType = eventType || '';\n        this.editor.eachWidget(widget => { // need {}'s here so we don't return false and end iteration\n            widget.dataset?.eventType && (widget.hidden = widget.dataset.eventType !== eventType);\n        });\n    }\n    //endregion\n    //region Save\n    async finalizeEventSave(eventRecord, resourceRecords, resolve, reject) {\n        const\n            me = this,\n            {\n                scheduler,\n                assignmentStore\n            }  = me;\n        const aborted = false;\n        // Prevent multiple commits from this flow\n        assignmentStore.suspendAutoCommit();\n        // Avoid multiple redraws, from event changes + assignment changes\n        scheduler.suspendRefresh();\n        me.onBeforeSave(eventRecord);\n        eventRecord.beginBatch();\n        me.updateRecord(eventRecord);\n        eventRecord.endBatch();\n        if (!eventRecord.isOccurrence) {\n            if (me.resourceField) {\n                assignmentStore.assignEventToResource(eventRecord, resourceRecords, null, true);\n            }\n        }\n        // An occurrence event record may have changed only resources value. In that case we'll never get into afterChange() method that\n        // apply changed data and make an event \"real\", because resources is not a field and a record won't be marked as dirty.\n        // We used temporary field to save updated resources list and get into afterChange() method.\n        else if (resourceRecords) {\n            eventRecord.set('resourceRecords', resourceRecords);\n        }\n        // If it was a provisional event, passed in here from drag-create or dblclick or contextmenu,\n        // it's now it's no longer a provisional event and will not be removed in resetEditingContext\n        // Also, when promoted to be permanent, auto syncing will kick in if configured.\n        eventRecord.isCreating = false;\n        if (!aborted) {\n            await scheduler.project.commitAsync();\n        }\n        assignmentStore.resumeAutoCommit();\n        // Redraw once\n        scheduler.resumeRefresh(true);\n        if (!aborted) {\n            /**\n             * Fires on the owning Scheduler after an event is successfully saved\n             * @event afterEventSave\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler instance\n             * @param {Scheduler.model.EventModel} eventRecord The record about to be saved\n             */\n            scheduler.trigger('afterEventSave', { eventRecord });\n            me.onAfterSave(eventRecord);\n        }\n        resolve(aborted ? false : eventRecord);\n    }\n    /**\n     * Saves the changes (applies them to record if valid, if invalid editor stays open)\n     * @private\n     * @fires beforeEventSave\n     * @fires beforeEventAdd\n     * @fires afterEventSave\n     * @async\n     */\n    save() {\n        return new Promise((resolve, reject) => {\n            const\n                me                         = this,\n                { scheduler, eventRecord } = me;\n            if (!eventRecord || !me.editor.isValid) {\n                resolve(false);\n                return;\n            }\n            const\n                { eventStore, values } = me,\n                resourceRecords        = me.resourceField?.records || (me.resourceRecord ? [me.resourceRecord] : []);\n            // Check for potential overlap scenarios before saving\n            if (!me.scheduler.allowOverlap && eventStore) {\n                let { startDate, endDate } = values;\n                // Should support using a duration field instead of the end date field\n                if (!endDate) {\n                    if ('duration' in values) {\n                        endDate = DateHelper.add(startDate, values.duration, values.durationUnit || eventRecord.durationUnit);\n                    }\n                    else if ('fullDuration' in values) {\n                        endDate = DateHelper.add(startDate, values.fullDuration);\n                    }\n                    else {\n                        endDate = eventRecord.endDate;\n                    }\n                }\n                const abort = resourceRecords.some(resource => {\n                    return !eventStore.isDateRangeAvailable(startDate, endDate, eventRecord, resource);\n                });\n                if (abort) {\n                    resolve(false);\n                    return;\n                }\n            }\n            const context = {\n                finalize(saveEvent) {\n                    try {\n                        if (saveEvent !== false) {\n                            me.finalizeEventSave(eventRecord, resourceRecords, resolve, reject);\n                        }\n                        else {\n                            resolve(false);\n                        }\n                    }\n                    catch (e) {\n                        reject(e);\n                    }\n                }\n            };\n            /**\n             * Fires on the owning Scheduler before an event is saved.\n             * Return `false` to immediately prevent saving\n             *\n             * ```javascript\n             *  scheduler.on({\n             *      beforeEventSave() {\n             *          // prevent saving if some custom variable hasn't 123 value\n             *          return myCustomValue === 123;\n             *      }\n             *  });\n             * ```\n             * or a `Promise` yielding `true` or `false` for async vetoing.\n             *\n             * ```javascript\n             *  scheduler.on({\n             *      beforeEventSave() {\n             *          const\n             *              // send ajax request\n             *              response = await fetch('http://my-server/check-parameters.php'),\n             *              data     = await response.json();\n             *\n             *          // decide whether it's ok to save based on response \"okToSave\" property\n             *          return data.okToSave;\n             *      }\n             *  });\n             * ```\n             *\n             * @event beforeEventSave\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler instance\n             * @param {Scheduler.model.EventModel} eventRecord The record about to be saved\n             * @param {Scheduler.model.ResourceModel[]} resourceRecords The resources to which the event is assigned\n             * @param {Object} values The new values\n             * @param {Object} context Extended save context:\n             * @param {Boolean} [context.async] Set this to `true` in a listener to indicate that the listener will asynchronously decide to prevent or not the event save.\n             * @param {Function} context.finalize Function to call to finalize the save. Used when `async` is `true`. Provide `false` to the function to prevent the save.\n             * @preventable\n             * @async\n             */\n            const triggerResult = scheduler.trigger('beforeEventSave', { eventRecord, resourceRecords, values, context });\n            // Helper function to handle beforeEventSave listeners result\n            function handleEventResult(result, eventRecord, context) {\n                // save prevented by a listener\n                if (result === false) {\n                    resolve(false);\n                }\n                else {\n                    me.onRecurrableEventBeforeSave({ eventRecord, context });\n                    // truthy context.async means than a listener will decide to approve saving asynchronously\n                    if (!context.async) {\n                        context.finalize();\n                    }\n                }\n            }\n            if (ObjectHelper.isPromise(triggerResult)) {\n                triggerResult.then(result => handleEventResult(result, eventRecord, context));\n            }\n            else {\n                handleEventResult(triggerResult, eventRecord, context);\n            }\n        });\n    }\n    //endregion\n    //region Delete\n    /**\n     * Delete event being edited\n     * @fires beforeEventDelete\n     * @private\n     * @async\n     */\n    deleteEvent() {\n        this.detachListeners('changesWhileEditing');\n        return new Promise((resolve, reject) => {\n            const\n                me                      = this,\n                { eventRecord, editor } = me;\n            me.scheduler.removeEvents([eventRecord], removeRecord => {\n                // The reason it does it here is to move focus *before* it gets deleted,\n                // and then there's code in the delete to see that it's deleting the focused one,\n                // and jump forwards or backwards to move to the next or previous event\n                // See 'Should allow key activation' test in tests/view/mixins/EventNavigation.t.js\n                if (removeRecord && editor.containsFocus) {\n                    editor.revertFocus();\n                }\n                resolve(removeRecord);\n            }, editor);\n        });\n    }\n    //endregion\n    //region Stores\n    onChangeProject() {\n        // Release resource store on project change, it will be re-chained on next show\n        if (this.resourceField) {\n            this.resourceField.store = {}; // Cannot use null\n        }\n    }\n    get eventStore() {\n        return this.scheduler.project.eventStore;\n    }\n    get resourceStore() {\n        return this.scheduler.project.resourceStore;\n    }\n    get assignmentStore() {\n        return this.scheduler.project.assignmentStore;\n    }\n    //endregion\n    //endregion\n    //region Events\n    onActivateEditor({ eventRecord, resourceRecord, eventElement }) {\n        this.editEvent(eventRecord, resourceRecord, eventElement);\n    }\n    onDragCreateEnd({ eventRecord, resourceRecord, proxyElement, stmCapture }) {\n        this.editEvent(eventRecord, resourceRecord, proxyElement, stmCapture);\n    }\n    // chained from EventNavigation\n    onEventEnterKey({ assignmentRecord, eventRecord, target }) {\n        const\n            { client }  = this,\n            // Event can arrive from the wrap element in some products (such as Calendar)\n            // so in these cases, we must use querySelector to look *inside* the element.\n            element     = target[target.matches(client.eventSelector) ? 'querySelector' : 'closest'](client.eventInnerSelector);\n        if (assignmentRecord) {\n            this.editEvent(eventRecord, assignmentRecord.resource, element);\n        }\n        else if (eventRecord) {\n            this.editEvent(eventRecord, eventRecord.resource, element);\n        }\n    }\n    // Toggle fields visibility when changing eventType\n    onEventTypeChange({ value }) {\n        this.toggleEventType(value);\n    }\n    //endregion\n    //region Context menu\n    populateEventMenu({ eventRecord, resourceRecord, items }) {\n        if (!this.scheduler.readOnly && !this.disabled) {\n            items.editEvent = {\n                text        : 'L{EventEdit.Edit event}',\n                localeClass : this,\n                icon        : 'b-icon b-icon-edit',\n                weight      : 100,\n                disabled    : eventRecord.readOnly,\n                onItem      : () => {\n                    this.editEvent(eventRecord, resourceRecord);\n                }\n            };\n        }\n    }\n    //endregion\n    onBeforeEditorToggleReveal({ reveal }) {\n        if (reveal) {\n            this.editor.setupEditorButtons();\n        }\n        // reveal true/false is analogous to show/hide\n        this[reveal ? 'onBeforeEditorShow' : 'resetEditingContext']();\n    }\n    async resetEditingContext() {\n        const me = this;\n        me.detachListeners('changesWhileEditing');\n        // super call has to go before the `me.rejectStmTransaction();` below\n        // because it can be removing an event manually, bypassing the stm\n        super.resetEditingContext();\n        // client does not use STM for task editing (at least yet)\n        if (me.hasStmCapture && !me.isDeletingEvent && !me.isCancelingEdit) {\n            await me.freeStm(false);\n        }\n        // Clear to prevent retaining project\n        me.resourceRecord = null;\n    }\n    finalizeStmCapture(shouldReject) {\n        return this.freeStm(!shouldReject);\n    }\n    updateLocalization() {\n        if (this._editor) {\n            this.updateCSSVars({ element : this._editor.element });\n        }\n        super.updateLocalization(...arguments);\n    }\n}\nEventEdit._$name = 'EventEdit'; GridFeatureManager.registerFeature(EventEdit, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventEdit, false, ['SchedulerPro', 'ResourceHistogram']);\nEventEdit.initClass();\n", "import List from '../../Core/widget/List.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\n/**\n * @module Scheduler/widget/ResourceFilter\n */\n/**\n * A List which allows selection of resources to filter a specified eventStore to only show\n * events for the selected resources.\n *\n * Because this widget maintains a state that can be changed through the UI, it offers some of the\n * API of an input field. It has a read only {@link #property-value} property, and it fires a\n * {@link #event-change} event.\n *\n * @extends Core/widget/List\n * @classtype resourceFilter\n * @widget\n */\nexport default class ResourceFilter extends List {\n    static get $name() {\n        return 'ResourceFilter';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'resourcefilter';\n    }\n    static get delayable() {\n        return {\n            applyFilters : 'raf'\n        };\n    }\n    static get configurable() {\n        return {\n            /**\n             * The {@link Scheduler.data.EventStore EventStore} to filter.\n             * Events for resources which are deselected in this List will be filtered out.\n             * @config {Scheduler.data.EventStore}\n             */\n            eventStore : null,\n            multiSelect            : true,\n            toggleAllIfCtrlPressed : true,\n            collapsibleGroups      : true,\n            itemTpl                : record => StringHelper.encodeHtml(record.name || ''),\n            /**\n             * An optional filter function to apply when loading resources from the project's\n             * resource store. Defaults to loading all resources.\n             *\n             * **This is called using this `ResourceFilter` as the `this` object.**\n             *\n             * @config {Function|String}\n             * @param {Scheduler.model.ResourceModel} resource Resorce for filtering\n             * @returns {Boolean} Returns `true` to include the passed resource\n             * @default\n             */\n            masterFilter : (resource) => true,\n            /**\n             * By default, deselecting list items filters only the {@link #config-eventStore} so that\n             * events for the deselected resources are hidden from view. The `resourceStore` is __not__\n             * filtered.\n             *\n             * Configure this as `true` to also filter the `resourceStore` so that deselected resources\n             * are also hidden from view (They will remain in this `List`)\n             * @config {Boolean}\n             * @default false\n             */\n            filterResources : null\n        };\n    }\n    itemIconTpl(record, i) {\n        const\n            { eventColor } = record,\n            // Named colors are applied using CSS\n            cls            = DomHelper.isNamedColor(eventColor) ? ` b-sch-foreground-${eventColor}` : '',\n            // CSS style color is used as is\n            style          = !cls && eventColor ? ` style=\"color:${eventColor}\"` : '';\n        return this.multiSelect ? `<div class=\"b-selected-icon b-icon${cls}\"${style}></div>` : '';\n    }\n    changeStore(store) {\n        if (this.eventStore) {\n            return super.changeStore(...arguments);\n        }\n        // If we have no eventStore yet, we cannot have a store.\n        // So in that case, just cache the configuration object for use when\n        // the eventStore arrives.\n        else {\n            this._storeConfig = store;\n        }\n    }\n    changeEventStore(eventStore) {\n        // Force ingestion of store.\n        // changeStore above won't upgrade it to be a Store because we have no eventStore yet.\n        // It will cache the config object as _storeConfig\n        this.getConfig('store');\n        return eventStore;\n    }\n    updateEventStore(eventStore) {\n        const\n            me                 = this,\n            // This will be the raw store config block cached by changeStore.\n            chainedStoreConfig = me._storeConfig || {},\n            // Allow configuration of the filter for loading records from the master store.\n            { resourceStore }  = eventStore,\n            store              = me.store = resourceStore.chain(me.masterFilter, null, {\n                ...chainedStoreConfig,\n                syncOrder : true\n            }),\n            changeListeners    = {\n                change  : 'onStoreChange',\n                thisObj : me\n            };\n        // We need to sync selection and rendering on changes fired from master store\n        store.un(changeListeners);\n        resourceStore.ion(changeListeners);\n        if (!resourceStore.count) {\n            resourceStore.project.ion({\n                name    : 'project',\n                refresh : 'initFilter',\n                thisObj : me\n            });\n        }\n        else {\n            me.initFilter();\n        }\n    }\n    changeMasterFilter(masterFilter) {\n        // Cannot use bind, otherwise fillFromMaster's check for whether it's a filter function fails.\n        const me = this;\n        // If we are filtering the resource store, we cannot now fill ourselves from the filtered\n        // view of the resource store. Otherwise, the list would hide the list items as they are deselected.\n        if (!me.filterResources) {\n            return function(r) {\n                return me.callback(masterFilter, me, [r]);\n            };\n        }\n    }\n    initFilter() {\n        const me = this;\n        if (me.eventStore.resourceStore.count) {\n            // Must only read selected *if* the resourceStore has received data.\n            // The lazy selected config must be left uningested until we have data.\n            const { selected } = me;\n            // We default to all resources selected unless this was configured with\n            // an initialSelection.\n            if (!selected.count) {\n                // If the initially configured selection was expicitly empty, apply the filter now\n                if (me.initialConfig.selected?.length === 0) {\n                    me.onInternalSelectionChange({ source : selected, added : [], removed : [] });\n                }\n                else {\n                    // Use allRecords in case it consists of collapsed groups\n                    selected.add(me.store.allRecords.filter(r => !r.isGroupHeader));\n                }\n            }\n            me.detachListeners('project');\n        }\n    }\n    onStoreRefresh({ source : store, action }) {\n        // We need to re-enable the filter if the store becomes filtered.\n        // We only disable the filter if we know that we have selected all available\n        // resources.\n        if (action === 'filter' && this.eventStoreFilter) {\n            const\n                { eventStoreFilter } = this,\n                { disabled }       = eventStoreFilter,\n                newDisabled        = !store.isFiltered && this.allSelected;\n            if (newDisabled !== disabled) {\n                eventStoreFilter.disabled = newDisabled;\n                this.applyFilters();\n            }\n        }\n        super.onStoreRefresh(...arguments);\n    }\n    onInternalSelectionChange({ source : selected, added, removed }) {\n        // Filter disabled if all resources selected\n        const\n            me       = this,\n            // Only disable the filter if the allSelected method is seeing *all* of the\n            // records from its masterStore with no filtering.\n            disabled = !me.store.isFiltered && me.allSelected;\n        super.onInternalSelectionChange(...arguments);\n        let filtersAdded = false;\n        // If this is the first selection change triggered from the first project refresh\n        // in which all the resources are selected, then we ony need to apply the filters.\n        // if *not* all resources are selected, ie if added.length !== entire store length.\n        if (!me.eventStoreFilter) {\n            // Our client EventStore is filtered to only show events for our selected resources.\n            // Events without an associated resource are filtered into visibility.\n            // The addFilter function with silent param adds the filter but don't reevaluate filtering.\n            me.eventStoreFilter = me.eventStore.addFilter({\n                id       : `${me.id}-filter-instance`,\n                filterBy : e => !e.resource || me.selected.includes(e.resources),\n                disabled\n            }, added?.length === me.store.count);\n            filtersAdded = true;\n        }\n        if (me.filterResources && !me.resourceStoreFilter) {\n            // Our client EventStore is filtered to only show events for our selected resources.\n            // Events without an associated resource are filtered into visibility.\n            // The addFilter function with silent param adds the filter but don't reevaluate filtering.\n            me.resourceStoreFilter = me.eventStore.resourceStore.addFilter({\n                id       : `${me.id}-filter-instance`,\n                filterBy : r => me.selected.includes(r),\n                disabled\n            }, added?.length === me.store.count);\n            filtersAdded = true;\n        }\n        // The filters have been just added and so will take effect. No need to call applyFilter.\n        if (filtersAdded) {\n            return;\n        }\n        // Filter disabled if all resources selected\n        me.eventStoreFilter.disabled = disabled;\n        me.resourceStoreFilter && (me.resourceStoreFilter.disabled = disabled);\n        // Have the client EventStore refresh its filtering but after a small delay so the List UI updates immediately.\n        me.applyFilters();\n        if (me.eventListeners.change) {\n            const\n                value    = selected.values,\n                oldValue = value.concat(removed);\n            ArrayHelper.remove(oldValue, ...added);\n            /**\n             * Fired when this widget's selection changes\n             * @event change\n             * @param {String} value - This field's value\n             * @param {String} oldValue - This field's previous value\n             * @param {Core.widget.Field} source - This ResourceFilter\n             */\n            me.triggerFieldChange({\n                value,\n                oldValue\n            });\n        }\n    }\n    /**\n     * An array encapsulating the currently selected resources.\n     * @member {Scheduler.model.ResourceModel[]}\n     * @readonly\n     */\n    get value() {\n        return this.selected.values;\n    }\n    applyFilters() {\n        this.eventStore.filter();\n        this.filterResources && this.eventStore.resourceStore.filter();\n    }\n    doDestroy() {\n        this.store?.destroy();\n        super.doDestroy();\n    }\n}\n// Register this widget type with its Factory\nResourceFilter.initClass();\nResourceFilter._$name = 'ResourceFilter';", "import DatePicker from '../../Core/widget/DatePicker.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\n/**\n * @module Scheduler/widget/SchedulerDatePicker\n */\n/**\n * A subclass of {@link Core.widget.DatePicker} which is able to show the presence of\n * events in its cells if configured with an {@link #config-eventStore}, and\n * {@link #config-showEvents} is set to a truthy value.\n *\n * The `datepicker` Widget type is implemented by this class when this class is imported, or built\n * into a bundle, and so any {@link Core.widget.DateField} may have its\n * {@link Core.widget.PickerField#config-picker} configured to use its capabilities of showing\n * the presence of events in its date cells.\n *\n * {@inlineexample Scheduler/widget/SchedulerDatePicker.js}\n *\n *\n * @extends Core/widget/DatePicker\n * @classtype datepicker\n * @widget\n */\nexport default class SchedulerDatePicker extends DatePicker {\n    static get $name() {\n        return 'SchedulerDatePicker';\n    }\n    static get type() {\n        return 'datepicker';\n    }\n    static get configurable() {\n        return {\n            /**\n             * How to show presence of events in the configured {@link #config-eventStore} in the\n             * day cells. Values may be:\n             *\n             * * `false` - Do not show events in cells.\n             * * `true` - Show a themeable bullet to indicate the presence of events for a date.\n             * * `'count'` - Show a themeable badge containing the event count for a date.\n             * @config {Boolean|'count'}\n             * @default false\n             */\n            showEvents : null,\n            /**\n             * The {@link Scheduler.data.EventStore event store} from which the in-cell event presence\n             * indicators are drawn.\n             * @config {Scheduler.data.EventStore}\n             */\n            eventStore : null,\n            /**\n             * A function, or the name of a function in the ownership hierarchy to filter which events\n             * are collected into the day cell data blocks.\n             *\n             * Return `true` to include the passed event, or a *falsy* value to exclude the event.\n             *\n             * @config {Function|String}\n             * @param {Scheduler.model.EventModel} event Event for filtering\n             * @returns {Boolean} Return `true` to include the passed event\n             */\n            eventFilter : {\n                $config : 'lazy',\n                value   : null\n            }\n        };\n    }\n    construct(config) {\n        // Handle deprecated events config. It is now showEvents.\n        // events conflicts with the events data which may be passed in\n        if ('events' in config) {\n            config = {\n                ...config,\n                showEvents : config.events\n            };\n            delete config.events;\n            VersionHelper.deprecate(VersionHelper['calendar'] ? 'Calendar' : 'Scheduler', '6.0.0', 'DatePicker#events should be configured as showEvents');\n        }\n        super.construct(config);\n    }\n    changeEventFilter(eventFilter) {\n        if (typeof eventFilter === 'string') {\n            const { handler, thisObj } = this.resolveCallback(eventFilter);\n            eventFilter = handler.bind(thisObj);\n        }\n        return eventFilter;\n    }\n    doRefresh() {\n        // Hidden widgets must not query the EventStore for loading on demand to be able to use\n        // the EventStore's dateRangeRequested event.\n        if (this.isVisible || !this.showEvents) {\n            this.refreshEventsMap();\n            return super.doRefresh(...arguments);\n        }\n        else {\n            this.whenVisible('doRefresh');\n        }\n    }\n    updateShowEvents(showEvents, oldShowEvents) {\n        const\n            me            = this,\n            { classList } = me.contentElement;\n        let { eventStore } = me;\n        // Begin any animations in the next AF\n        me.requestAnimationFrame(() => {\n            me.element.classList.toggle('b-datepicker-with-events', Boolean(showEvents));\n            me.owner?.element.classList.toggle('b-datepicker-with-events', Boolean(showEvents));\n            showEvents && classList.add(`b-show-events-${showEvents}`);\n            classList.remove(`b-show-events-${oldShowEvents}`);\n        });\n        if (showEvents) {\n            if (!eventStore) {\n                const eventStoreOwner = me.up(w => w.eventStore);\n                if (eventStoreOwner) {\n                    eventStore = eventStoreOwner.eventStore;\n                }\n                else {\n                    throw new Error('DatePicker configured with events but no eventStore');\n                }\n            }\n        }\n        else {\n            me.eventsMap = null;\n        }\n        if (!me.isConfiguring) {\n            me.updateEventStore(eventStore);\n            me.doRefresh();\n        }\n    }\n    refreshEventsMap() {\n        const me = this;\n        if (me.showEvents) {\n            me.eventsMap = me.eventStore.getEventCounts({\n                startDate : me.startDate,\n                endDate   : me.endDate,\n                dateMap   : me.eventsMap,\n                filter    : me.eventFilter\n            });\n        }\n    }\n    updateEventStore(eventStore) {\n        // Add a listener to refresh on any event change unless the listener is already added.\n        if (eventStore.findListener('change', 'refresh', this) === -1) {\n            eventStore?.[this.showEvents ? 'on' : 'un']?.({\n                change  : 'refresh',\n                thisObj : this\n            });\n        }\n    }\n    cellRenderer({ cell, date }) {\n        const\n            { showEvents } = this,\n            count          = this.eventCounts?.get?.(DateHelper.makeKey(date)),\n            isCount        = showEvents === 'count';\n        delete cell.dataset.btip;\n        if (count) {\n            if (!isCount && this.eventCountTip) {\n                cell.dataset.btip = this.L('L{ResourceInfoColumn.eventCountText}', count);\n            }\n            DomHelper.createElement({\n                dataset : {\n                    count\n                },\n                class : {\n                    [isCount ? 'b-cell-events-badge' : 'b-icon b-icon-circle'] : 1,\n                    [SchedulerDatePicker.getEventCountClass(count)]            : 1\n                },\n                parent                  : cell,\n                [isCount ? 'text' : ''] : count\n            });\n        }\n    }\n    static getEventCountClass(count) {\n        if (count) {\n            if (count < 4) {\n                return 'b-datepicker-1-to-3-events';\n            }\n            if (count < 7) {\n                return 'b-datepicker-4-to-6-events';\n            }\n            return 'b-calendar-7-or-more-events';\n        }\n        return '';\n    }\n    static setupClass(meta) {\n        // We take over the type name 'datepicker' when we are in the app\n        meta.replaceType = true;\n        super.setupClass(meta);\n    }\n}\n// Register this widget type with its Factory\nSchedulerDatePicker.initClass();\nSchedulerDatePicker._$name = 'SchedulerDatePicker';"],
  "mappings": "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",
  "names": ["eventRecord", "context"]
}
