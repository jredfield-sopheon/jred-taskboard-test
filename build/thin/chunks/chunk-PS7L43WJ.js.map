{
  "version": 3,
  "sources": ["../../../../Scheduler/lib/Scheduler/column/ScaleColumn.js", "../../../../Scheduler/lib/Scheduler/feature/base/ResourceTimeRangesBase.js", "../../../../Scheduler/lib/Scheduler/view/DependencyEditor.js", "../../../../Scheduler/lib/Scheduler/feature/DependencyEdit.js", "../../../../Scheduler/lib/Scheduler/feature/ScheduleContext.js", "../../../../Scheduler/lib/Scheduler/feature/EventCopyPaste.js", "../../../../Scheduler/lib/Scheduler/feature/EventDrag.js", "../../../../Scheduler/lib/Scheduler/feature/EventDragCreate.js", "../../../../Scheduler/lib/Scheduler/feature/EventTooltip.js", "../../../../Scheduler/lib/Scheduler/feature/StickyEvents.js", "../../../../Scheduler/lib/Scheduler/feature/TimeRanges.js", "../../../../Scheduler/lib/Scheduler/view/mixin/DelayedRecordsRendering.js", "../../../../Scheduler/lib/Scheduler/view/TimelineHistogramRendering.js", "../../../../Scheduler/lib/Scheduler/view/TimelineHistogramBase.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineHistogramGrouping.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineHistogramScaleColumn.js", "../../../../Scheduler/lib/Scheduler/view/TimelineHistogram.js"],
  "sourcesContent": ["import Column from '../../Grid/column/Column.js';\nimport ColumnStore from '../../Grid/data/ColumnStore.js';\nimport Scale from '../../Core/widget/graph/Scale.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/column/ScaleColumn\n */\n/**\n * An object representing a point on the scale displayed by {@link Scheduler.column.ScaleColumn}.\n *\n * @typedef {Object} ScalePoint\n * @property {Number} value Point value\n * @property {String} unit Point value unit\n * @property {String} text Point text label\n */\n/**\n * A specialized column showing a graduated scale from a defined array of values\n * and labels. This column is used in the {@link Scheduler.view.TimelineHistogram} and is not editable. Normally\n * you should not need to interact with this class directly.\n *\n * @extends Grid/column/Column\n * @classtype scale\n * @column\n */\nexport default class ScaleColumn extends Column {\n    //region Config\n    static $name = 'ScaleColumn';\n    static type = 'scale';\n    static isScaleColumn = true;\n    static get fields() {\n        return [\n            'scalePoints'\n        ];\n    }\n    static get defaults() {\n        return {\n            text            : '\\xa0',\n            width           : 40,\n            minWidth        : 40,\n            field           : 'scalePoints',\n            cellCls         : 'b-scale-cell',\n            editor          : false,\n            sortable        : false,\n            groupable       : false,\n            filterable      : false,\n            alwaysClearCell : false,\n            scalePoints     : null\n        };\n    }\n    //endregion\n    //region Constructor/Destructor\n    onDestroy() {\n        this.scaleWidget.destroy();\n    }\n    //endregion\n    //region Internal\n    set width(width) {\n        super.width = width;\n        this.scaleWidget.width = width;\n    }\n    get width() {\n        return super.width;\n    }\n    applyValue(useProp, key, value) {\n        // pass value to scaleWidget\n        if (key === 'scalePoints') {\n            this.scaleWidget[key] = value;\n        }\n        return super.applyValue(...arguments);\n    }\n    buildScaleWidget() {\n        const me = this;\n        const scaleWidget = new Scale({\n            owner         : me.grid,\n            appendTo      : me.grid.floatRoot,\n            cls           : 'b-hide-offscreen',\n            align         : 'right',\n            scalePoints   : me.scalePoints,\n            monitorResize : false\n        });\n        Object.defineProperties(scaleWidget, {\n            width : {\n                get() {\n                    return me.width;\n                },\n                set(width) {\n                    this.element.style.width = `${width}px`;\n                    this._width = me.width;\n                }\n            },\n            height : {\n                get() {\n                    return this._height;\n                },\n                set(height) {\n                    this.element.style.height = `${height}px`;\n                    this._height = height;\n                }\n            }\n        });\n        scaleWidget.width = me.width;\n        return scaleWidget;\n    }\n    get scaleWidget() {\n        const me = this;\n        if (!me._scaleWidget) {\n            me._scaleWidget = me.buildScaleWidget();\n        }\n        return me._scaleWidget;\n    }\n    //endregion\n    //region Render\n    renderer({ cellElement, value, scaleWidgetConfig, scaleWidget = this.scaleWidget }) {\n        ObjectHelper.assign(scaleWidget, {\n            scalePoints : value || this.scalePoints,\n            height      : this.grid.rowHeight\n        }, scaleWidgetConfig);\n        scaleWidget.refresh();\n        // Clone the scale widget element since every row is supposed to have\n        // the same scale settings\n        const scaleCloneElement = scaleWidget.element.cloneNode(true);\n        scaleCloneElement.removeAttribute('id');\n        scaleCloneElement.classList.remove('b-hide-offscreen');\n        cellElement.innerHTML = '';\n        cellElement.appendChild(scaleCloneElement);\n    }\n    //endregion\n}\nColumnStore.registerColumnType(ScaleColumn);\nScaleColumn._$name = 'ScaleColumn';", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\n/**\n * @module Scheduler/feature/base/ResourceTimeRangesBase\n */\n/**\n * Abstract base class for ResourceTimeRanges and ResourceNonWorkingTime features.\n * You should not use this class directly.\n *\n * @extends Core/mixin/InstancePlugin\n * @abstract\n */\nexport default class ResourceTimeRangesBase extends InstancePlugin.mixin(AttachToProjectMixin) {\n    //region Config\n    static configurable = {\n        /**\n         * Specify value to use for the tabIndex attribute of range elements\n         * @config {Number}\n         * @category Misc\n         */\n        tabIndex : null,\n        entityName : 'resourceTimeRange'\n    };\n    static get pluginConfig()  {\n        return {\n            chain    : ['getEventsToRender', 'onEventDataGenerated', 'noFeatureElementsInAxis'],\n            override : ['matchScheduleCell', 'resolveResourceRecord']\n        };\n    }\n    // Let Scheduler know if we have ResourceTimeRanges in view or not\n    noFeatureElementsInAxis() {\n        const { timeAxis } = this.client;\n        return !this.needsRefresh && this.store && !this.store.storage.values.some(t => timeAxis.isTimeSpanInAxis(t));\n    }\n    //endregion\n    //region Init\n    doDisable(disable) {\n        if (this.client.isPainted) {\n            this.client.refresh();\n        }\n        super.doDisable(disable);\n    }\n    updateTabIndex() {\n        if (!this.isConfiguring) {\n            this.client.refresh();\n        }\n    }\n    //endregion\n    getEventsToRender(resource, events) {\n        throw new Error('Implement in subclass');\n    }\n    // Called for each event during render, allows manipulation of render data. Adjust any resource time ranges\n    // (chained function from Scheduler)\n    onEventDataGenerated(renderData) {\n        const\n            me                       = this,\n            { client }               = me,\n            { eventRecord, iconCls } = renderData;\n        if (me.shouldInclude(eventRecord)) {\n            if (client.isVertical) {\n                renderData.width = renderData.resourceRecord.columnWidth || client.resourceColumnWidth;\n            }\n            else {\n                renderData.top = 0;\n            }\n            // Flag that we should fill entire row/col\n            renderData.fillSize = true;\n            // Add our own cls\n            renderData.wrapperCls['b-sch-resourcetimerange'] = 1;\n            if (me.rangeCls) {\n                renderData.wrapperCls[me.rangeCls] = 1;\n            }\n            renderData.wrapperCls[`b-sch-color-${eventRecord.timeRangeColor}`] = eventRecord.timeRangeColor;\n            me.renderContent(eventRecord, renderData);\n            renderData.children.push(renderData.eventContent);\n            // Allow configuring tabIndex\n            renderData.tabIndex = me.tabIndex != null ? String(me.tabIndex) : null;\n            // Add icon\n            if (iconCls?.length > 0) {\n                renderData.children.unshift({\n                    tag       : 'i',\n                    className : iconCls.toString()\n                });\n            }\n            // Event data for DOMSync comparison\n            renderData.eventId = me.generateElementId(eventRecord);\n        }\n    }\n    renderContent(eventRecord, renderData) {\n        renderData.eventContent.text = eventRecord.name;\n    }\n    /**\n     * Generates ID from the passed time range record\n     * @param {Scheduler.model.TimeSpan} record\n     * @returns {String} Generated ID for the DOM element\n     * @internal\n     */\n    generateElementId(record) {\n        return record.domId;\n    }\n    resolveResourceTimeRangeRecord(rangeElement) {\n        return rangeElement?.closest(`.${this.rangeCls}`)?.elementData.eventRecord;\n    }\n    getElementFromResourceTimeRangeRecord(record) {\n        // return this.client.foregroundCanvas.querySelector(`[data-event-id=\"${record.domId}\"]`);\n        return this.client.foregroundCanvas.syncIdMap[record.domId];\n    }\n    resolveResourceRecord(event) {\n        const record = this.overridden.resolveResourceRecord(...arguments);\n        return record || this.resolveResourceTimeRangeRecord(event.target || event)?.resource;\n    }\n    shouldInclude(eventRecord) {\n        throw new Error('Implement in subclass');\n    }\n    // Called when a ResourceTimeRangeModel is manipulated, relays to Scheduler#onInternalEventStoreChange which updates to UI\n    onStoreChange(event) {\n        // Edge case for scheduler not using any events, it has to refresh anyway to get rid of ResourceTimeRanges\n        if (event.action === 'removeall' || event.action === 'dataset') {\n            this.needsRefresh = true;\n        }\n        this.client.onInternalEventStoreChange(event);\n        this.needsRefresh = false;\n    }\n    // Override to let scheduler find the time cell from a resource time range element\n    matchScheduleCell(target) {\n        let cell = this.overridden.matchScheduleCell(target);\n        if (!cell && this.enableMouseEvents) {\n            const\n                { client }   = this,\n                rangeElement = target.closest(`.${this.rangeCls}`);\n            cell = rangeElement && client.getCell({\n                record : client.isHorizontal ? rangeElement.elementData.resource : client.store.first,\n                column : client.timeAxisColumn\n            });\n        }\n        return cell;\n    }\n    handleRangeMouseEvent(domEvent) {\n        const\n            me           = this,\n            rangeElement = domEvent.target.closest(`.${me.rangeCls}`);\n        if (rangeElement) {\n            const\n                eventName               = EventHelper.eventNameMap[domEvent.type] ?? StringHelper.capitalize(domEvent.type),\n                resourceTimeRangeRecord = me.resolveResourceTimeRangeRecord(rangeElement);\n            me.client.trigger(me.entityName + eventName, {\n                feature                    : me,\n                [`${me.entityName}Record`] : resourceTimeRangeRecord,\n                resourceRecord             : me.client.resourceStore.getById(resourceTimeRangeRecord.resourceId),\n                domEvent\n            });\n        }\n    }\n    updateEnableMouseEvents(enable) {\n        const\n            me         = this,\n            { client } = me;\n        me.mouseEventsDetacher?.();\n        me.mouseEventsDetacher = null;\n        if (enable) {\n            function attachMouseEvents() {\n                me.mouseEventsDetacher = EventHelper.on({\n                    element     : client.foregroundCanvas,\n                    delegate    : `.${me.rangeCls}`,\n                    mousedown   : 'handleRangeMouseEvent',\n                    mouseup     : 'handleRangeMouseEvent',\n                    click       : 'handleRangeMouseEvent',\n                    dblclick    : 'handleRangeMouseEvent',\n                    contextmenu : 'handleRangeMouseEvent',\n                    mouseover   : 'handleRangeMouseEvent',\n                    mouseout    : 'handleRangeMouseEvent',\n                    thisObj     : me\n                });\n            }\n            client.whenVisible(attachMouseEvents);\n        }\n        client.element.classList.toggle('b-interactive-resourcetimeranges', Boolean(enable));\n    }\n}\n// No feature based styling needed, do not add a cls to Scheduler\nResourceTimeRangesBase.featureClass = '';\nResourceTimeRangesBase._$name = 'ResourceTimeRangesBase';", "import Popup from '../../Core/widget/Popup.js';\n/**\n * @module Scheduler/view/DependencyEditor\n */\n/**\n * A dependency editor popup.\n *\n * @extends Core/widget/Popup\n * @private\n */\nexport default class DependencyEditor extends Popup {\n    static get $name() {\n        return 'DependencyEditor';\n    }\n    static get defaultConfig() {\n        return {\n            items     : [],\n            draggable : {\n                handleSelector : ':not(button,.b-field-inner)' // blacklist buttons and field inners\n            },\n            axisLock : 'flexible'\n        };\n    }\n    processWidgetConfig(widget) {\n        const { dependencyEditFeature } = this;\n        if (widget.ref === 'lagField' && !dependencyEditFeature.showLagField) {\n            return false;\n        }\n        if (widget.ref === 'deleteButton' && !dependencyEditFeature.showDeleteButton) {\n            return false;\n        }\n        return super.processWidgetConfig(widget);\n    }\n    afterShow(...args) {\n        const { deleteButton } = this.widgetMap;\n        // Only show delete button if the dependency record belongs to a store\n        if (deleteButton) {\n            deleteButton.hidden = !this.record.isPartOfStore();\n        }\n        super.afterShow(...args);\n    }\n    onInternalKeyDown(event) {\n        this.trigger('keyDown', { event });\n        super.onInternalKeyDown(event);\n    }\n}\nDependencyEditor._$name = 'DependencyEditor';", "import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport '../../Core/widget/DisplayField.js';\nimport '../../Core/widget/DurationField.js';\nimport DependencyEditor from '../view/DependencyEditor.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport DependencyModel from '../model/DependencyModel.js';\nimport Duration from '../../Core/data/Duration.js';\n/**\n * @module Scheduler/feature/DependencyEdit\n */\n/**\n * Feature that displays a popup containing fields for editing a dependency. Requires the\n * {@link Scheduler.feature.Dependencies} feature to be enabled. Double click a line in the demo below to show the\n * editor.\n *\n * {@inlineexample Scheduler/feature/Dependencies.js}\n *\n * ## Customizing the built-in widgets\n *\n * ```javascript\n *  const scheduler = new Scheduler({\n *      columns : [\n *          { field : 'name', text : 'Name', width : 100 }\n *      ],\n *      features : {\n *          dependencies   : true,\n *          dependencyEdit : {\n *              editorConfig : {\n *                  items : {\n *                      // Custom label for the type field\n *                      typeField : {\n *                          label : 'Kind'\n *                      }\n *                  },\n *\n *                  bbar : {\n *                      items : {\n *                          // Hiding save button\n *                          saveButton : {\n *                              hidden : true\n *                          }\n *                      }\n *                  }\n *              }\n *          }\n *      }\n *  });\n * ```\n *\n * ## Built-in widgets\n *\n * | Widget ref             | Type                              | Weight | Description               |\n * |------------------------|-----------------------------------|--------|---------------------------|\n * | `fromNameField`        | {@link Core.widget.DisplayField}  | 100    | From task name (readonly) |\n * | `toNameField`          | {@link Core.widget.DisplayField}  | 200    | To task name (readonly)   |\n * | `typeField`            | {@link Core.widget.Combo}         | 300    | Edit type                 |\n * | `lagField`             | {@link Core.widget.DurationField} | 400    | Edit lag                  |\n *\n * The built-in buttons are:\n *\n * | Widget ref             | Type                       | Weight | Description                       |\n * |------------------------|----------------------------|--------|-----------------------------------|\n * | `saveButton`           | {@link Core.widget.Button} | 100    | Save button on the bbar           |\n * | `deleteButton`         | {@link Core.widget.Button} | 200    | Delete button on the bbar         |\n * | `cancelButton`         | {@link Core.widget.Button} | 300    | Cancel editing button on the bbar |\n *\n * This feature is **disabled** by default.\n * For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/dependencies\n * @classtype dependencyEdit\n * @feature\n */\nexport default class DependencyEdit extends InstancePlugin {\n    //region Config\n    static get $name() {\n        return 'DependencyEdit';\n    }\n    static get configurable() {\n        return {\n            /**\n             * True to hide this editor if a click is detected outside it (defaults to true)\n             * @config {Boolean}\n             * @default\n             * @category Editor\n             */\n            autoClose : true,\n            /**\n             * True to save and close this panel if ENTER is pressed in one of the input fields inside the panel.\n             * @config {Boolean}\n             * @default\n             * @category Editor\n             */\n            saveAndCloseOnEnter : true,\n            /**\n             * True to show a delete button in the form.\n             * @config {Boolean}\n             * @default\n             * @category Editor widgets\n             */\n            showDeleteButton : true,\n            /**\n             * The event that shall trigger showing the editor. Defaults to `dependencydblclick`, set to empty string or\n             * `null` to disable editing of dependencies.\n             * @config {String}\n             * @default\n             * @category Editor\n             */\n            triggerEvent : 'dependencydblclick',\n            /**\n             * True to show the lag field for the dependency\n             * @config {Boolean}\n             * @default\n             * @category Editor widgets\n             */\n            showLagField : false,\n            dependencyRecord : null,\n            /**\n             * Default editor configuration, used to configure the Popup.\n             * @config {PopupConfig}\n             * @category Editor\n             */\n            editorConfig : {\n                title       : 'L{Edit dependency}',\n                localeClass : this,\n                closable    : true,\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    /**\n                     * Reference to the from name\n                     * @member {Core.widget.DisplayField} fromNameField\n                     * @readonly\n                     */\n                    fromNameField : {\n                        type   : 'display',\n                        weight : 100,\n                        label  : 'L{From}'\n                    },\n                    /**\n                     * Reference to the to name field\n                     * @member {Core.widget.DisplayField} toNameField\n                     * @readonly\n                     */\n                    toNameField : {\n                        type   : 'display',\n                        weight : 200,\n                        label  : 'L{To}'\n                    },\n                    /**\n                     * Reference to the type field\n                     * @member {Core.widget.Combo} typeField\n                     * @readonly\n                     */\n                    typeField : {\n                        type                  : 'combo',\n                        weight                : 300,\n                        label                 : 'L{Type}',\n                        name                  : 'type',\n                        editable              : false,\n                        valueField            : 'id',\n                        displayField          : 'name',\n                        localizeDisplayFields : true,\n                        buildItems            : function() {\n                            const dialog = this.parent;\n                            return Object.keys(DependencyModel.Type).map(type => ({\n                                id        : DependencyModel.Type[type],\n                                name      : dialog.L(type),\n                                localeKey : type\n                            }));\n                        }\n                    },\n                    /**\n                     * Reference to the lag field\n                     * @member {Core.widget.DurationField} lagField\n                     * @readonly\n                     */\n                    lagField : {\n                        type                    : 'duration',\n                        weight                  : 400,\n                        label                   : 'L{Lag}',\n                        name                    : 'lag',\n                        allowNegative           : true,\n                        highlightExternalChange : false\n                    }\n                },\n                bbar : {\n                    defaults : {\n                        localeClass : this\n                    },\n                    items : {\n                        foo : {\n                            type : 'widget',\n                            cls  : 'b-label-filler'\n                        },\n                        /**\n                         * Reference to the save button, if used\n                         * @member {Core.widget.Button} saveButton\n                         * @readonly\n                         */\n                        saveButton : {\n                            color : 'b-green',\n                            text  : 'L{Save}'\n                        },\n                        /**\n                         * Reference to the delete button, if used\n                         * @member {Core.widget.Button} deleteButton\n                         * @readonly\n                         */\n                        deleteButton : {\n                            color : 'b-gray',\n                            text  : 'L{Delete}'\n                        },\n                        /**\n                         * Reference to the cancel button, if used\n                         * @member {Core.widget.Button} cancelButton\n                         * @readonly\n                         */\n                        cancelButton : {\n                            color : 'b-gray',\n                            text  : 'L{Object.Cancel}'\n                        }\n                    }\n                }\n            }\n        };\n    }\n    //endregion\n    //region Init & destroy\n    construct(client, config) {\n        const me = this;\n        client.dependencyEdit = me;\n        super.construct(client, config);\n        if (!client.features.dependencies) {\n            throw new Error('Dependencies feature required when using DependencyEdit');\n        }\n        me.clientListenersDetacher = client.ion({\n            [me.triggerEvent] : me.onActivateEditor,\n            thisObj           : me\n        });\n    }\n    doDestroy() {\n        this.clientListenersDetacher();\n        this.editor?.destroy();\n        super.doDestroy();\n    }\n    //endregion\n    //region Editing\n    changeEditorConfig(config) {\n        const\n            me                         = this,\n            { autoClose, cls, client } = me;\n        return ObjectHelper.assign({\n            owner        : client,\n            align        : 'b-t',\n            id           : `${client.id}-dependency-editor`, \n            autoShow     : false,\n            anchor       : true,\n            scrollAction : 'realign',\n            constrainTo  : globalThis,\n            autoClose,\n            cls\n        }, config);\n    }\n    //endregion\n    //region Save\n    get isValid() {\n        return Object.values(this.editor.widgetMap).every(field => {\n            if (!field.name || field.hidden) {\n                return true;\n            }\n            return field.isValid !== false;\n        });\n    }\n    get values() {\n        const values = {};\n        this.editor.eachWidget(widget => {\n            if (!widget.name || widget.hidden) return;\n            values[widget.name] = widget.value;\n        }, true);\n        return values;\n    }\n    /**\n     * Template method, intended to be overridden. Called before the dependency record has been updated.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record\n     *\n     **/\n    onBeforeSave(dependencyRecord) {}\n    /**\n     * Template method, intended to be overridden. Called after the dependency record has been updated.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record\n     *\n     **/\n    onAfterSave(dependencyRecord) {}\n    /**\n     * Updates record being edited with values from the editor\n     * @private\n     */\n    updateRecord(dependencyRecord) {\n        const { values } = this;\n        // Engine does not understand { magnitude, unit } syntax\n        if (values.lag) {\n            values.lagUnit = values.lag.unit;\n            values.lag = values.lag.magnitude;\n        }\n        // Type replaces fromSide/toSide, if they are used\n        if ('type' in values) {\n            dependencyRecord.fromSide != null && (values.fromSide = null);\n            dependencyRecord.toSide != null && (values.toSide = null);\n        }\n        // Chronograph doesn't filter out undefined fields, it nullifies them instead\n        // https://github.com/bryntum/chronograph/issues/11\n        ObjectHelper.cleanupProperties(values, true);\n        dependencyRecord.set(values);\n    }\n    //endregion\n    //region Events\n    onPopupKeyDown({ event }) {\n        if (event.key === 'Enter' && this.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {\n            // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden\n            event.preventDefault();\n            this.onSaveClick();\n        }\n    }\n    onSaveClick() {\n        if (this.save()) {\n            this.afterSave();\n            this.editor.hide();\n        }\n    }\n    async onDeleteClick() {\n        if (await this.deleteDependency()) {\n            this.afterDelete();\n        }\n        this.editor.hide();\n    }\n    onCancelClick() {\n        this.afterCancel();\n        this.editor.hide();\n    }\n    afterSave() {}\n    afterDelete() {}\n    afterCancel() {}\n    //region Editing\n    // Called from editDependency() to actually show the editor\n    internalShowEditor(dependencyRecord) {\n        const\n            me         = this,\n            { client } = me,\n            editor     = me.getEditor(dependencyRecord);\n        me.loadRecord(dependencyRecord);\n        /**\n         * Fires on the owning Scheduler or Gantt widget when the editor for a dependency is available but before it is shown. Allows\n         * manipulating fields before the widget is shown.\n         * @event beforeDependencyEditShow\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler\n         * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.\n         * @param {Core.widget.Popup} editor The editor popup\n         */\n        client.trigger('beforeDependencyEditShow', {\n            dependencyEdit : me,\n            dependencyRecord,\n            editor\n        });\n        let showPoint = me.lastPointerDownCoordinate;\n        if (!showPoint) {\n            const center = Rectangle.from(client.element).center;\n            showPoint = [center.x - editor.width / 2, center.y - editor.height / 2];\n        }\n        const\n            result   = editor.showBy(showPoint),\n            labelled = [];\n        // All of this measuring code can be removed when we transition to grid layout\n        let labelWidth = 0;\n        // Measure labels\n        editor.eachWidget(widget => {\n            const { labelElement, element } = widget;\n            if (labelElement) {\n                // Has top labels? Don't measure them (material)\n                if (labelElement.getBoundingClientRect().top < element.getBoundingClientRect().top) {\n                    return false;\n                }\n                widget.labelWidth = null;\n                labelWidth = Math.max(labelWidth, labelElement.offsetWidth);\n                labelled.push(widget);\n            }\n        });\n        // Match longest\n        labelled.forEach(widget => widget.labelWidth = labelWidth);\n        return result;\n    }\n    /**\n     * Opens a popup to edit the passed dependency.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency to edit\n     * @return {Promise} A Promise that yields `true` after the editor is shown\n     * or `false` if some application logic vetoed the editing (see `beforeDependencyEdit` in the docs).\n     */\n    async editDependency(dependencyRecord) {\n        const\n            me         = this,\n            { client } = me;\n        if (client.readOnly || dependencyRecord.readOnly ||\n            /**\n             * Fires on the owning Scheduler or Gantt widget before an dependency is displayed in the editor.\n             * This may be listened for to allow an application to take over dependency editing duties. Return `false` to\n             * stop the default editing UI from being shown or a `Promise` yielding `true` or `false` for async vetoing.\n             * @event beforeDependencyEdit\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature\n             * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.\n             * @preventable\n             * @async\n             */\n            await client.trigger('beforeDependencyEdit', { dependencyEdit : me, dependencyRecord }) === false\n        ) {\n            return false;\n        }\n        // wait till the editor is shown\n        await this.internalShowEditor(dependencyRecord);\n        return true;\n    }\n    //endregion\n    //region Save\n    /**\n     * Gets an editor instance. Creates on first call, reuses on consecutive\n     * @internal\n     * @returns {Scheduler.view.DependencyEditor} Editor popup\n     */\n    getEditor() {\n        const me = this;\n        let { editor } = me;\n        if (editor) {\n            return editor;\n        }\n        editor = me.editor = DependencyEditor.new({\n            dependencyEditFeature : me,\n            autoShow              : false,\n            anchor                : true,\n            scrollAction          : 'realign',\n            constrainTo           : globalThis,\n            autoClose             : me.autoClose,\n            cls                   : me.cls,\n            rootElement           : me.client.rootElement,\n            internalListeners     : {\n                keydown : me.onPopupKeyDown,\n                thisObj : me\n            }\n        }, me.editorConfig);\n        if (editor.items.length === 0) {\n            console.warn('Editor configured without any `items`');\n        }\n        // assign widget refs\n        editor.eachWidget(widget => {\n            const ref = widget.ref || widget.id;\n            // don't overwrite if already defined\n            if (ref && !me[ref]) {\n                me[ref] = widget;\n            }\n        });\n        me.saveButton?.ion({ click : 'onSaveClick', thisObj : me });\n        me.deleteButton?.ion({ click : 'onDeleteClick', thisObj : me });\n        me.cancelButton?.ion({ click : 'onCancelClick', thisObj : me });\n        return me.editor;\n    }\n    //endregion\n    //region Delete\n    /**\n     * Sets fields values from record being edited\n     * @private\n     */\n    loadRecord(dependency) {\n        const me = this;\n        me.fromNameField.value = dependency.fromEvent.name;\n        me.toNameField.value = dependency.toEvent.name;\n        if (me.lagField) {\n            me.lagField.value = new Duration(dependency.lag, dependency.lagUnit);\n        }\n        me.editor.record = me.dependencyRecord = dependency;\n    }\n    //endregion\n    //region Stores\n    /**\n     * Saves the changes (applies them to record if valid, if invalid editor stays open)\n     * @private\n     * @fires beforeDependencySave\n     * @fires beforeDependencyAdd\n     * @fires afterDependencySave\n     * @returns {*}\n     */\n    async save() {\n        const\n            me                           = this,\n            { client, dependencyRecord } = me;\n        if (!dependencyRecord || !me.isValid) {\n            return;\n        }\n        const { dependencyStore, values } = me;\n        /**\n         * Fires on the owning Scheduler or Gantt widget before a dependency is saved\n         * @event beforeDependencySave\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler instance\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved\n         * @param {Object} values The new values\n         * @preventable\n         */\n        if (client.trigger('beforeDependencySave', {\n            dependencyRecord,\n            values\n        }) !== false) {\n            me.onBeforeSave(dependencyRecord);\n            me.updateRecord(dependencyRecord);\n            // Check if this is a new record\n            if (dependencyStore && !dependencyRecord.stores.length) {\n                /**\n                 * Fires on the owning Scheduler or Gantt widget before a dependency is added\n                 * @event beforeDependencyAdd\n                 * @on-owner\n                 * @param {Scheduler.view.Scheduler} source The scheduler\n                 * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependency edit feature\n                 * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be added\n                 * @preventable\n                 */\n                if (client.trigger('beforeDependencyAdd', { dependencyRecord, dependencyEdit : me }) === false) {\n                    return;\n                }\n                dependencyStore.add(dependencyRecord);\n            }\n            await client.project?.commitAsync();\n            /**\n             * Fires on the owning Scheduler or Gantt widget after a dependency is successfully saved\n             * @event afterDependencySave\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler instance\n             * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved\n             */\n            client.trigger('afterDependencySave', { dependencyRecord });\n            me.onAfterSave(dependencyRecord);\n        }\n        return dependencyRecord;\n    }\n    /**\n     * Delete dependency being edited\n     * @private\n     * @fires beforeDependencyDelete\n     */\n    async deleteDependency() {\n        const { client, editor, dependencyRecord } = this;\n        /**\n         * Fires on the owning Scheduler or Gantt widget before a dependency is deleted\n         * @event beforeDependencyDelete\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler instance\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record about to be deleted\n         * @preventable\n         */\n        if (client.trigger('beforeDependencyDelete', { dependencyRecord }) !== false) {\n            if (editor.containsFocus) {\n                editor.revertFocus();\n            }\n            client.dependencyStore.remove(dependencyRecord);\n            await client.project?.commitAsync();\n            return true;\n        }\n        return false;\n    }\n    get dependencyStore() {\n        return this.client.dependencyStore;\n    }\n    //endregion\n    //region Events\n    onActivateEditor({ dependency, event }) {\n        if (!this.disabled) {\n            this.lastPointerDownCoordinate = [event.clientX, event.clientY];\n            this.editDependency(dependency);\n        }\n    }\n    //endregion\n}\nDependencyEdit._$name = 'DependencyEdit'; GridFeatureManager.registerFeature(DependencyEdit, false);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\n/**\n * @module Scheduler/feature/ScheduleContext\n */\n/**\n * Allow visually selecting a schedule \"cell\" by clicking, or {@link #config-triggerEvent any other pointer gesture}.\n *\n * This feature is **disabled** by default\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         // Configure as a truthy value to enable the feature\n *         scheduleContext : {\n *             triggerEvent : 'hover',\n *             renderer     : (context, element) => {\n *                 element.innerText = '\uD83D\uDE0E';\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * The contextual details are available in the {@link #property-context} property.\n *\n * **Note that the context is cleared upon change of {@link Scheduler.view.Scheduler#property-viewPreset}\n * such as when zooming in or out.**\n *\n * {@inlineexample Scheduler/feature/ScheduleContext.js}\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype scheduleContext\n * @feature\n */\nexport default class ScheduleContext extends InstancePlugin.mixin(Delayable) {\n    static get $name() {\n        return 'ScheduleContext';\n    }\n    static delayable = {\n        syncContextElement : 'raf'\n    };\n    static configurable = {\n        /**\n         * The pointer event type to use to update the context. May be `'hover'` to highlight the\n         * tick context when moving the mouse across the timeline.\n         * @config {'click'|'hover'|'contextmenu'|'mousedown'}\n         * @default\n         */\n        triggerEvent : 'click',\n        /**\n         * A function (or the name of a function) which may mutate the contents of the context overlay\n         * element which tracks the active resource/tick context.\n         *\n         * @config {String|Function}\n         * @param {TimelineContext} context The context being highlighted.\n         * @param {HTMLElement} element The context highlight element. This will be empty each time.\n         * @returns {void}\n         */\n        renderer : null,\n        /**\n         * The active context.\n         * @member {TimelineContext} timelineContext\n         * @readonly\n         */\n        context : {\n            $config : {\n                // Reject non-changes so that when using mousemove, we only update the context\n                // when it changes.\n                equal(c1, c2) {\n                    return c1?.index === c2?.index &&\n                        c1?.tickParentIndex === c2?.tickParentIndex &&\n                        !((c1?.tickStartDate || 0) - (c2?.tickStartDate || 0));\n                }\n            }\n        }\n    };\n    /**\n     * The contextual information about which cell was clicked on and highlighted.\n     *\n     * When the {@link Scheduler.view.Scheduler#property-viewPreset} is changed (such as when zooming)\n     * the context is cleared and the highlight is removed.\n     *\n     * @member {Object} context\n     * @property {Scheduler.view.TimelineBase} context.source The owning Scheduler\n     * @property {Date} context.date Date at mouse position\n     * @property {Scheduler.model.TimeSpan} context.tick A record which encapsulates the time axis tick clicked on.\n     * @property {Number} context.tickIndex The index of the time axis tick clicked on.\n     * @property {Date} context.tickStartDate The start date of the current time axis tick\n     * @property {Date} context.tickEndDate The end date of the current time axis tick\n     * @property {Grid.row.Row} context.row Clicked row (in horizontal mode only)\n     * @property {Number} context.index Index of clicked resource\n     * @property {Scheduler.model.ResourceModel} context.resourceRecord Resource record\n     * @property {MouseEvent} context.event Browser event\n     */\n    construct(client, config) {\n        super.construct(client, config);\n        const\n            { triggerEvent } = this,\n            listeners        = {\n                datachange              : 'syncContextElement',\n                timeaxisviewmodelupdate : 'onTimeAxisViewModelUpdate',\n                presetchange            : 'clearContext',\n                thisObj                 : this\n            };\n        // If mousemove is our trigger, we cab use the client's timelineContextChange event\n        if (triggerEvent === 'mouseover') {\n            listeners.timelineContextChange = 'onTimelineContextChange';\n        }\n        // Otherwise, we have to listen for the required events on Schedule and events\n        else {\n            // Context menu will be expected to update the context if click or mousedown\n            // is the triggerEvent. Context menu is a mousedown gesture.\n            if (triggerEvent === 'click' || triggerEvent === 'mousedown') {\n                listeners.schedulecontextmenu = 'onScheduleContextGesture';\n            }\n            Object.assign(listeners, {\n                [`schedule${triggerEvent}`] : 'onScheduleContextGesture',\n                [`event${triggerEvent}`]    : 'onScheduleContextGesture',\n                ...listeners\n            });\n        }\n        client.ion(listeners);\n        client.rowManager.ion({\n            rowheight : 'syncContextElement',\n            thisObj   : this\n        });\n    }\n    changeTriggerEvent(triggerEvent) {\n        // Both these things should route through to using the client's timelineContextChange event\n        if (triggerEvent === 'hover' || triggerEvent === 'mousemove') {\n            triggerEvent = 'mouseover';\n        }\n        return triggerEvent;\n    }\n    get element() {\n        return this._element || (this._element = DomHelper.createElement({\n            parent    : this.client.timeAxisSubGridElement,\n            className : 'b-schedule-selected-tick'\n        }));\n    }\n    // Handle the Client's own timelineContextChange event which it maintains on mousemove\n    onTimelineContextChange({ context }) {\n        this.context = context;\n    }\n    // Handle the scheduleclick or eventclick Scheduler events if we re not using mouseover\n    onScheduleContextGesture(context) {\n        this.context = context;\n    }\n    onTimeAxisViewModelUpdate({ source : timeAxisViewModel }) {\n        // Just a mutation of existing tick details, sync the element\n        if (timeAxisViewModel.timeAxis.includes(this.context?.tick)) {\n            this.syncContextElement();\n        }\n        // The tick has gone, we have moved to a new ViewPreset, so clear the context.\n        else {\n            this.clearContext();\n        }\n    }\n    clearContext() {\n        this.context = null;\n    }\n    updateContext(context, oldContext) {\n        this.syncContextElement();\n    }\n    syncContextElement() {\n        if (this.context && this.enabled) {\n            const\n                me  = this,\n                {\n                    client,\n                    element,\n                    context,\n                    renderer\n                }   = me,\n                {\n                    isVertical\n                }   = client,\n                {\n                    style\n                }   = element,\n                row = isVertical ? client.rowManager.rows[0] : client.getRowFor(context.resourceRecord);\n            if (row) {\n                const\n                    {\n                        tickStartDate,\n                        tickEndDate,\n                        resourceRecord\n                    } = context,\n                    // get the position clicked based on dates\n                    renderData = client.currentOrientation.getTimeSpanRenderData({\n                        startDate   : tickStartDate,\n                        endDate     : tickEndDate,\n                        startDateMS : tickStartDate.getTime(),\n                        endDateMS   : tickEndDate.getTime()\n                    }, resourceRecord);\n                let top, width, height;\n                if (isVertical) {\n                    top = renderData.top;\n                    width = renderData.resourceWidth;\n                    height = renderData.height;\n                }\n                else {\n                    top = row.top;\n                    width = renderData.width;\n                    height = row.height;\n                }\n                // Move to current cell\n                style.display = '';\n                style.width = `${width}px`;\n                style.height = `${height}px`;\n                DomHelper.setTranslateXY(element, renderData.left, top);\n                // In case we updated on a datachange action : 'remove' or 'add' event.\n                context.index = row.index;\n                // Undo any contents added by the renderer last time round.\n                element.innerHTML = '';\n                // Show the context and the element to the renderer\n                renderer && me.callback(renderer, me, [context, element]);\n            }\n            // No row for resource might mean it's scrolled out of view or filtered out\n            // so just hide so that the next valid sync can restore it to visibility\n            else {\n                style.display = 'none';\n            }\n        }\n        else {\n            this.element.style.display = 'none';\n        }\n    }\n}\nScheduleContext.featureClass = 'b-scheduler-context';\nScheduleContext._$name = 'ScheduleContext'; GridFeatureManager.registerFeature(ScheduleContext, false, ['Scheduler']);\n", "import AttachToProjectMixin from '../../Scheduler/data/mixin/AttachToProjectMixin.js';\nimport CopyPasteBase from '../../Grid/feature/base/CopyPasteBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport './ScheduleContext.js';\nconst actions = {\n    cut   : 1,\n    copy  : 1,\n    paste : 1\n};\n/**\n * @module Scheduler/feature/EventCopyPaste\n */\n/**\n * Allow using [Ctrl/CMD + C/X] and [Ctrl/CMD + V] to copy/cut and paste events.\n *\n * This feature also adds entries to the {@link Scheduler/feature/EventMenu} for copying & cutting (see example below\n * for how to configure) and to the {@link Scheduler/feature/ScheduleMenu} for pasting.\n *\n * You can configure how a newly pasted record is named using {@link #function-generateNewName}.\n *\n * {@inlineexample Scheduler/feature/EventCopyPaste.js}\n *\n * If you want to highlight the paste location when clicking in the schedule, consider enabling the\n * {@link Scheduler/feature/ScheduleContext} feature.\n *\n * <div class=\"note\">When used with Scheduler Pro, pasting will bypass any constraint set on the event to allow the\n * copy to be assigned the targeted date.</div>\n *\n * This feature is **enabled** by default.\n *\n * ## Customize menu items\n *\n * See {@link Scheduler/feature/EventMenu} and {@link Scheduler/feature/ScheduleMenu} for more info on customizing the\n * menu items supplied by the feature. This snippet illustrates the concept:\n *\n * ```javascript\n * // Custom copy text + remove cut option from event menu:\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 copyEvent : {\n *                     text : 'Copy booking'\n *                 },\n *                 cutEvent  : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ## Keyboard shortcuts\n *\n * The feature has the following default keyboard shortcuts:\n *\n * | Keys       | Action   | Action description                                |\n * |------------|----------|---------------------------------------------------|\n * | `Ctrl`+`C` | *copy*   | Copies selected event(s) into the clipboard.      |\n * | `Ctrl`+`X` | *cut*    | Cuts out selected event(s) into the clipboard.    |\n * | `Ctrl`+`V` | *paste*  | Insert copied or cut event(s) from the clipboard. |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Scheduler/guides/customization/keymap.md).\n *\n * ## Multi assigned events\n *\n * In a Scheduler that uses single assignment, copying and then pasting creates a clone of the event and assigns it\n * to the target resource. Cutting and pasting moves the original event to the target resource.\n *\n * In a Scheduler using multi assignment, the behaviour is slightly more complex. Cutting and pasting reassigns the\n * event to the target, keeping other assignments of the same event intact. The behaviour for copying and pasting is\n * configurable using the {@link #config-copyPasteAction} config. It accepts two values:\n *\n * * `'clone'` - The default, the event is cloned and the clone is assigned to the target resource. Very similar to the\n *   behaviour with single assignment (event count goes up by 1).\n * * `'assign'` - The original event is assigned to the target resource (event count is unaffected).\n *\n * This snippet shows how to reconfigure it:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventCopyPaste : {\n *             copyPasteAction : 'assign'\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">Copying multiple assignments of the same event will always result in all but the first assignment\n * being removed on paste, since paste targets a single resource and an event can only be assigned to a resource once.\n * </div>\n *\n * ## Native/shared clipboard\n *\n * If you have multiple Schedulers (or other Bryntum products) on the same page, they will share clipboard. This makes\n * it possible to copy and paste between different Scheduler instances. It is also possible to use the native Clipboard\n * API if it is available and if you set {@link #config-useNativeClipboard} to `true`.\n *\n * Regardless of native clipboard availability, copy-pasting \"outside\" of the current Scheduler instance will convert\n * the copied events to a string. When pasting, the string will then be parsed back into events. In case of usage of the\n * native Clipboard API, this means it is possible to copy and paste events between completely different applications.\n *\n * To configure the fields that is converted and parsed from the copied string value, please see the\n * {@link #config-eventToStringFields} config.\n *\n * @extends Grid/feature/base/CopyPasteBase\n * @classtype eventCopyPaste\n * @feature\n */\nexport default class EventCopyPaste extends CopyPasteBase.mixin(AttachToProjectMixin) {\n    static $name = 'EventCopyPaste';\n    static pluginConfig = {\n        assign : [\n            'copyEvents',\n            'pasteEvents'\n        ],\n        chain : [\n            'populateEventMenu',\n            'populateScheduleMenu',\n            'onEventDataGenerated'\n        ]\n    };\n    static configurable = {\n        /**\n         * The field to use as the name field when updating the name of copied records\n         * @config {String}\n         * @default\n         */\n        nameField : 'name',\n        /**\n         * How to handle a copy paste operation when the host uses multi assignment. Either:\n         *\n         * - `'clone'`  - The default, clone the copied event, assigning the clone to the target resource.\n         * - `'assign'` - Add an assignment for the existing event to the target resource.\n         *\n         * For single assignment mode, it always uses the `'clone'` behaviour.\n         *\n         * @config {'clone'|'assign'}\n         * @default\n         */\n        copyPasteAction : 'clone',\n        /**\n         * When copying events (or assignments), data will be sent to the clipboard as a tab (`\\t`) and new-line (`\\n`)\n         * separated string with field values for fields present in this config (in specified order). The default\n         * included fields are (in this order):\n         * * name\n         * * startDate\n         * * endDate\n         * * duration\n         * * durationUnit\n         * * allDay\n         * To override, provide your own array of fields:\n         * ```javascript\n         * new Scheduler({\n         *     features : {\n         *         eventCopyPaste : {\n         *             eventToStringFields : [\n         *                'name',\n         *                'startDate',\n         *                'endDate',\n         *                'percentDone'\n         *             ]\n         *         }\n         *     }\n         * });\n         * ```\n         * <div class=\"note\">Please note that this config is both used for **converting** events to a string value and\n         * is also used to **parse** a string value to events.</div>\n         * @config {Array<String>}\n         */\n        eventToStringFields : ['name', 'startDate', 'endDate', 'duration', 'durationUnit', 'allDay']\n    };\n    construct(scheduler, config) {\n        super.construct(scheduler, config);\n        scheduler.ion({\n            eventClick    : 'onEventClick',\n            scheduleClick : 'onScheduleClick',\n            projectChange : () => {\n                this.clearClipboard();\n                this._cellClickedContext = null;\n            },\n            thisObj : this\n        });\n    }\n    // Used in events to separate events from different features from each other\n    entityName = 'event';\n    get scheduler() {\n        return this.client;\n    }\n    attachToEventStore(eventStore) {\n        super.attachToEventStore(eventStore);\n        delete this._eventClickedContext;\n    }\n    onEventDataGenerated(eventData) {\n        const { assignmentRecord } = eventData;\n        // No assignmentRecord for resource time ranges, which we want to ignore anyway\n        if (assignmentRecord) {\n            eventData.cls['b-cut-item'] = assignmentRecord.meta.isCut;\n        }\n    }\n    onEventClick(context) {\n        this._cellClickedContext = null;\n        this._eventClickedContext = context;\n    }\n    onScheduleClick(context) {\n        this._cellClickedContext = context;\n        this._eventClickedContext = null;\n    }\n    isActionAvailable({ event, actionName }) {\n        if (actions[actionName]) {\n            // No action if\n            // 1. there is selected text on the page\n            // 2. cell editing is active\n            // 3. cursor is not in the grid (filter bar etc)\n            // 4. focus is on specialrow\n            return !this.disabled &&\n                globalThis.getSelection().toString().length === 0 &&\n                !this.client.features.cellEdit?.isEditing &&\n                Boolean(event.target.closest('.b-timeaxissubgrid')) &&\n                !this.client.focusedCell?.isSpecialRow;\n        }\n    }\n    async copy() {\n        await this.copyEvents();\n    }\n    async cut() {\n        await this.copyEvents(undefined, true);\n    }\n    async paste() {\n        await this.pasteEvents();\n    }\n    /**\n     * Copy events (when using single assignment mode) or assignments (when using multi assignment mode) to clipboard to\n     * paste later\n     * @fires beforeCopy\n     * @fires copy\n     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} [records] Pass records to copy them,\n     * leave out to copying current selection\n     * @param {Boolean} [isCut] Copies by default, pass `true` to cut instead\n     * @category Edit\n     * @on-owner\n     */\n    async copyEvents(records = this.scheduler.selectedAssignments, isCut = false) {\n        const\n            me            = this,\n            { scheduler } = me;\n        // Relay to original if split\n        if (scheduler.splitFrom) {\n            return scheduler.splitFrom.features.eventCopyPaste.copyEvents(records, isCut);\n        }\n        if (!records?.length) {\n            return;\n        }\n        let assignmentRecords = records.slice(); // Slice to not lose records if selection changes\n        if (records[0].isEventModel) {\n            assignmentRecords = records.map(r => r.assignments).flat();\n        }\n        // Prevent cutting readOnly events\n        if (isCut) {\n            assignmentRecords = assignmentRecords.filter(a => !a.event.readOnly);\n        }\n        const eventRecords = assignmentRecords.map(a => a.event);\n        if (!assignmentRecords.length || scheduler.readOnly) {\n            return;\n        }\n        await me.writeToClipboard({ assignmentRecords, eventRecords }, isCut);\n        /**\n         * Fires on the owning Scheduler after a copy action is performed.\n         * @event copy\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords The event records that were copied\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records that were copied\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other copy events\n         */\n        scheduler.trigger('copy', { assignmentRecords, eventRecords, isCut, entityName : me.entityName });\n        // refresh to call onEventDataGenerated and reapply the cls for records where the cut was canceled\n        scheduler.refreshWithTransition();\n        me._focusedEventOnCopy = me._eventClickedContext;\n    }\n    async beforeCopy({ data : { assignmentRecords, eventRecords }, isCut }) {\n        /**\n         * Fires on the owning Scheduler before a copy action is performed, return `false` to prevent the action\n         * @event beforeCopy\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords The event records about to be copied\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records about to be copied\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other beforeCopy events\n         */\n        return await this.scheduler.trigger('beforeCopy',\n            { assignmentRecords,  eventRecords, isCut, entityName : this.entityName });\n    }\n    // Called from Clipboardable when cutData changes\n    handleCutData({ source }) {\n        const me = this;\n        if (source !== me && me.cutData?.length) {\n            const { assignmentRecords, eventRecords } = me.cutData[0];\n            if (assignmentRecords?.length) {\n                me.scheduler.assignmentStore.remove(assignmentRecords);\n            }\n            if (eventRecords?.length) {\n                me.scheduler.eventStore.remove(eventRecords);\n            }\n        }\n    }\n    /**\n     * Called from Clipboardable after writing a non-string value to the clipboard\n     * @param eventRecords\n     * @returns {string}\n     * @private\n     */\n    stringConverter({ eventRecords }) {\n        const rows = [];\n        for (const event of eventRecords) {\n            rows.push(this.eventToStringFields.map(field => {\n                const value = event[field];\n                if (value instanceof Date) {\n                    return DateHelper.format(value, this.dateFormat);\n                }\n                return value;\n            }).join('\\t'));\n        }\n        return rows.join('\\n');\n    }\n    // Called from Clipboardable for each cut out record\n    setIsCut({ assignmentRecords }, isCut) {\n        assignmentRecords.forEach(assignment => {\n            assignment.meta.isCut = isCut;\n        });\n        // refresh to call onEventDataGenerated and reapply the cls for records where the cut was canceled\n        this.scheduler.refreshWithTransition();\n    }\n    /**\n     * Paste events or assignments to specified date and resource\n     * @fires beforePaste\n     * @fires paste\n     * @param {Date} [date] Date where the events or assignments will be pasted\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] Resource to assign the pasted events or assignments to\n     * @category Edit\n     * @on-owner\n     */\n    async pasteEvents(date, resourceRecord) {\n        const\n            me            = this,\n            { scheduler } = me;\n        // Relay to original if split\n        if (scheduler.splitFrom) {\n            return scheduler.splitFrom.features.eventCopyPaste.pasteEvents(date, resourceRecord);\n        }\n        const\n            {\n                entityName,\n                isCut,\n                _cellClickedContext,\n                _eventClickedContext\n            }  = me,\n            {\n                eventStore,\n                assignmentStore\n            }  = scheduler;\n        if (arguments.length === 0) {\n            if (_cellClickedContext) {\n                date           = _cellClickedContext.date;\n                resourceRecord = _cellClickedContext.resourceRecord;\n            }\n            else if (me._focusedEventOnCopy !== _eventClickedContext) {\n                date           = _eventClickedContext.eventRecord.startDate;\n                resourceRecord = _eventClickedContext.resourceRecord;\n            }\n        }\n        if (resourceRecord) {\n            resourceRecord = resourceRecord.$original;\n        }\n        const clipboardData = await me.readFromClipboard({ resourceRecord, date });\n        if (!clipboardData?.assignmentRecords?.length) {\n            return;\n        }\n        const\n            {\n                assignmentRecords,\n                eventRecords\n            }            = clipboardData;\n        let toFocus      = null;\n        const\n            pastedEvents = new Set(),\n            pastedEventRecords = [];\n        for (const assignmentRecord of assignmentRecords) {\n            let { event }            = assignmentRecord;\n            const\n                targetResourceRecord = resourceRecord || assignmentRecord.resource,\n                targetDate           = date || assignmentRecord.event.startDate;\n            // Pasting targets a specific resource, we cannot have multiple assignments to the same so remove all but\n            // the first (happens when pasting multiple assignments of the same event)\n            if (pastedEvents.has(event)) {\n                if (isCut) {\n                    assignmentRecord.remove();\n                }\n                continue;\n            }\n            pastedEvents.add(event);\n            // Cut always means reassign\n            if (isCut) {\n                assignmentRecord.meta.isCut = false;\n                assignmentRecord.resource   = targetResourceRecord;\n                toFocus                     = assignmentRecord;\n            }\n            // Copy creates a new event in single assignment, or when configured to copy\n            else if (!eventStore.usesResourceIds && (eventStore.usesSingleAssignment || me.copyPasteAction === 'clone')) {\n                event      = event.copy();\n                event.name = me.generateNewName(event);\n                eventStore.add(event);\n                event.assign(targetResourceRecord);\n                toFocus = assignmentStore.last;\n            }\n            // Safeguard against pasting on a resource where the event is already assigned,\n            // a new assignment in multiassign mode will only change the date in such case\n            else if (!event.resources.includes(targetResourceRecord)) {\n                const newAssignmentRecord    = assignmentRecord.copy();\n                newAssignmentRecord.resource = targetResourceRecord;\n                [toFocus]                    = assignmentStore.add(newAssignmentRecord);\n            }\n            event.startDate = targetDate;\n            // Pro specific, to allow event to appear where pasted\n            if (event.constraintDate) {\n                event.constraintDate = null;\n            }\n            pastedEventRecords.push(event);\n        }\n        /**\n         * Fires on the owning Scheduler after a paste action is performed.\n         * @event paste\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords Original events\n         * @param {Scheduler.model.EventModel[]} pastedEventRecords Pasted events\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Pasted assignments\n         * @param {Date} date date Pasted to this date\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other paste events\n         */\n        scheduler.trigger('paste', { assignmentRecords, pastedEventRecords, eventRecords, resourceRecord, date, isCut, entityName });\n        // Focus the last pasted assignment\n        const detacher = scheduler.ion({\n            renderEvent({ assignmentRecord }) {\n                if (assignmentRecord === toFocus) {\n                    scheduler.navigateTo(assignmentRecord, { scrollIntoView : false });\n                    detacher();\n                }\n            }\n        });\n        if (isCut) {\n            await me.clearClipboard();\n        }\n    }\n    // Called from Clipboardable before finishing the internal clipboard read\n    async beforePaste({ data : { assignmentRecords, eventRecords }, resourceRecord, isCut, date }) {\n        const\n            { scheduler } = this,\n            eventData     = {\n                assignmentRecords,\n                eventRecords,\n                resourceRecord : resourceRecord || assignmentRecords[0].resource,\n                date,\n                isCut,\n                entityName     : this.entityName\n            };\n        let reason;\n        // No pasting to readOnly resources\n        if (resourceRecord?.readOnly) {\n            reason = 'resourceReadOnly';\n        }\n        if (!scheduler.allowOverlap) {\n            const pasteWouldResultInOverlap = assignmentRecords.some(assignmentRecord => !scheduler.isDateRangeAvailable(\n                assignmentRecord.event.startDate,\n                assignmentRecord.event.endDate,\n                isCut ? assignmentRecord.event : null,\n                assignmentRecord.resource)\n            );\n            if (pasteWouldResultInOverlap) {\n                reason = 'overlappingEvents';\n            }\n        }\n        /**\n         * Fires on the owning Scheduler if a paste action is not allowed\n         * @event pasteNotAllowed\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n         * @param {Date} date The paste date\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other `pasteNotAllowed` events\n         * @param {'overlappingEvents'|'resourceReadOnly'} reason A string id to use for displaying an error message to the user.\n         */\n        if (reason) {\n            scheduler.trigger('pasteNotAllowed', {\n                ...eventData,\n                reason\n            });\n            return false;\n        }\n        /**\n         * Fires on the owning Scheduler before a paste action is performed, return `false` to prevent the action\n         * @event beforePaste\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords The events about to be pasted\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignments about to be pasted\n         * @param {Date} date The date when the pasted events will be scheduled\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record, the clipboard\n         * event records will be assigned to this resource.\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other beforePaste events\n         */\n        return await this.scheduler.trigger('beforePaste', eventData);\n    }\n    /**\n     * Called from Clipboardable after reading from clipboard, and it is determined that the clipboard data is\n     * \"external\"\n     * @param json\n     * @returns {Object}\n     * @private\n     */\n    stringParser(clipboardData) {\n        const\n            { eventStore, assignmentStore }    = this.scheduler,\n            { modifiedRecords : eventRecords } = this.setFromStringData(clipboardData, true, eventStore, this.eventToStringFields),\n            assignmentRecords                  = [];\n        for (const event of eventRecords) {\n            const assignment = new assignmentStore.modelClass({ eventId : event.id });\n            assignment.event = event;\n            assignmentRecords.push(assignment);\n        }\n        return { eventRecords, assignmentRecords };\n    }\n    populateEventMenu({ assignmentRecord, items }) {\n        const\n            me            = this,\n            { scheduler } = me;\n        if (!scheduler.readOnly) {\n            items.copyEvent = {\n                text        : 'L{copyEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-copy',\n                weight      : 110,\n                onItem      : () => {\n                    const assignments = scheduler.isAssignmentSelected(assignmentRecord) ? scheduler.selectedAssignments : [assignmentRecord];\n                    me.copyEvents(assignments);\n                }\n            };\n            items.cutEvent = {\n                text        : 'L{cutEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-cut',\n                weight      : 120,\n                disabled    : assignmentRecord.event.readOnly,\n                onItem      : () => {\n                    const assignments = scheduler.isAssignmentSelected(assignmentRecord) ? scheduler.selectedAssignments : [assignmentRecord];\n                    me.copyEvents(assignments, true);\n                }\n            };\n        }\n    }\n    populateScheduleMenu({ items, resourceRecord }) {\n        const\n            me            = this,\n            { scheduler } = me;\n        if (!scheduler.readOnly && me.hasClipboardData() !== false) {\n            items.pasteEvent = {\n                text        : 'L{pasteEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-paste',\n                disabled    : scheduler.resourceStore.count === 0 || resourceRecord.readOnly,\n                weight      : 110,\n                onItem      : ({\n                    date, resourceRecord\n                }) => {\n                    me.pasteEvents(date, resourceRecord, scheduler.getRowFor(resourceRecord));\n                }\n            };\n        }\n    }\n    /**\n     * A method used to generate the name for a copy pasted record. By defaults appends \"- 2\", \"- 3\" as a suffix.\n     *\n     * @param {Scheduler.model.EventModel} eventRecord The new eventRecord being pasted\n     * @returns {String}\n     */\n    generateNewName(eventRecord) {\n        const originalName = eventRecord.getValue(this.nameField);\n        let counter = 2;\n        while (this.client.eventStore.findRecord(this.nameField, `${originalName} - ${counter}`)) {\n            counter++;\n        }\n        return `${originalName} - ${counter}`;\n    }\n}\nEventCopyPaste.featureClass = 'b-event-copypaste';\nEventCopyPaste._$name = 'EventCopyPaste'; GridFeatureManager.registerFeature(EventCopyPaste, true, 'Scheduler');\n", "import DragBase from './base/DragBase.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n/**\n * @module Scheduler/feature/EventDrag\n */\n/**\n * Object with information about the drop point for a single dragged event.\n *\n * @typedef {Object} EventDropData\n * @property {Scheduler.model.EventModel} eventRecord The event about to be dropped. Note, that when\n * \"copying\" mode is enabled, this will still be the originally dragged event, not the copy\n * (which will be created only during drag'n'drop finalization).\n * @property {Date} startDate The estimated start date of the event after drop. Note, that actual start date\n * might be different because of the other features, affecting the scheduling, like dependencies and constraints.\n * @property {Date} endDate The estimated end date of the event after drop. Note, that actual end date\n * might be different because of the other features, affecting the scheduling, like dependencies and constraints.\n */\n/**\n * Object with information about the drop point for a dragged assignment.\n *\n * @typedef {Object} AssignmentDropData\n * @property {Scheduler.model.AssignmentModel} assignmentRecord The assignment about to be dropped. Note, that in case\n * if \"copying\" mode is enabled, this will still be the originally dragged assignment, not the copy\n * (which will be created only during drag'n'drop finalization).\n * @property {Scheduler.model.ResourceModel} resourceRecord The new resource for the assignment. Note, that resource\n * might belong to another project (in case of drag and drop between different scheduler instances).\n */\n/**\n * Object with information about the drop points for the dragged events.\n * It is used in the Scheduler's {@link Scheduler.view.Scheduler#event-beforeEventDropFinalize} event.\n *\n * @typedef {Object} DropData\n * @property {Array<EventDropData>} events The array of drop points for every dragged event.\n * @property {Array<AssignmentDropData>} assignments The array of drop points for every dragged assignment.\n */\n/**\n * Allows user to drag and drop events within the scheduler, to change startDate or resource assignment.\n *\n * This feature is **enabled** by default\n *\n * ## Customizing the drag drop tooltip\n *\n * To show custom HTML in the tooltip, please see the {@link #config-tooltipTemplate} config. Example:\n *\n * ```javascript\n * features: {\n *     eventDrag : {\n *         // A minimal start date tooltip\n *         tooltipTemplate : ({ eventRecord, startDate }) => {\n *             return DateHelper.format(startDate, 'HH:mm');\n *         }\n *     }\n * }\n * ```\n *\n * ## Constraining the drag drop area\n *\n * You can constrain how the dragged event is allowed to move by using the following configs\n * * {@link #config-constrainDragToResource} Resource fixed, only allowed to change start date\n * * {@link #config-constrainDragToTimeSlot} Start date is fixed, only move between resources\n * * {@link Scheduler.view.Scheduler#config-getDateConstraints} A method on the Scheduler instance\n *    which lets you define the date range for the dragged event programmatically\n *\n * ```js\n * // Enable dragging + constrain drag to current resource\n * const scheduler = new Scheduler({\n *     features : {\n *         eventDrag : {\n *             constrainDragToResource : true\n *         }\n *     }\n * });\n * ```\n *\n * ## Drag drop events from outside\n *\n * Dragging unplanned events from an external grid is a very popular use case. There are\n * several demos showing you how to do this. Please see the [Drag from grid demo](../examples/dragfromgrid)\n * and study the **Drag from grid guide** to learn more.\n *\n * ## Drag drop events to outside target\n *\n * You can also drag events outside the schedule area by setting {@link #config-constrainDragToTimeline} to `false`. You\n * should also either:\n * * provide a {@link #config-validatorFn} to programmatically define if a drop location is valid or not\n * * configure a {@link #config-externalDropTargetSelector} CSS selector to define where drops are allowed\n *\n * See [this demo](../examples/drag-outside) to see this in action.\n *\n * ## Validating drag drop\n *\n * It is easy to programmatically decide what is a valid drag drop operation. Use the {@link #config-validatorFn}\n * and return either `true` / `false` (optionally a message to show to the user).\n *\n * ```javascript\n * features : {\n *     eventDrag : {\n *        validatorFn({ eventRecords, newResource }) {\n *            const task  = eventRecords[0],\n *                  valid = newResource.role === task.resource.role;\n *\n *            return {\n *                valid   : newResource.role === task.resource.role,\n *                message : valid ? '' : 'Resource role does not match required role for this task'\n *            };\n *        }\n *     }\n * }\n * ```\n *\n * See [this demo](../examples/validation) to see validation in action.\n *\n * If you instead want to do a single validation upon drop, you can listen to {@link #event-beforeEventDropFinalize}\n * and set the `valid` flag on the context object provided.\n *\n * ```javascript\n *   const scheduler = new Scheduler({\n *      listeners : {\n *          beforeEventDropFinalize({ context }) {\n *              const { eventRecords } = context;\n *              // Don't allow dropping events in the past\n *              context.valid = Date.now() <= eventRecords[0].startDate;\n *          }\n *      }\n *  });\n * ```\n *\n * ## Preventing drag of certain events\n *\n * To prevent certain events from being dragged, you have two options. You can set {@link Scheduler.model.EventModel#field-draggable}\n * to `false` in your data, or you can listen for the {@link Scheduler.view.Scheduler#event-beforeEventDrag} event and\n * return `false` to block the drag.\n *\n * ```javascript\n * new Scheduler({\n *    listeners : {\n *        beforeEventDrag({ eventRecord }) {\n *            // Don't allow dragging events that have already started\n *            return Date.now() <= eventRecord.startDate;\n *        }\n *    }\n * })\n * ```\n *\n * {@inlineexample Scheduler/feature/EventDrag.js}\n *\n * @demo Scheduler/basic\n *\n * @extends Scheduler/feature/base/DragBase\n * @classtype eventDrag\n * @feature\n */\nexport default class EventDrag extends DragBase {\n    //region Config\n    static get $name() {\n        return 'EventDrag';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Template used to generate drag tooltip contents.\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventDrag : {\n             *             dragTipTemplate({eventRecord, startText}) {\n             *                 return `${eventRecord.name}: ${startText}`\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             * @config {Function} tooltipTemplate\n             * @param {Object} data Tooltip data\n             * @param {Scheduler.model.EventModel} data.eventRecord\n             * @param {Boolean} data.valid Currently over a valid drop target or not\n             * @param {Date} data.startDate New start date\n             * @param {Date} data.endDate New end date\n             * @returns {String}\n             */\n            /**\n             * Set to true to only allow dragging events within the same resource.\n             * @member {Boolean} constrainDragToResource\n             */\n            /**\n             * Set to true to only allow dragging events within the same resource.\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToResource : false,\n            /**\n             * Set to true to only allow dragging events to different resources, and disallow rescheduling by dragging.\n             * @member {Boolean} constrainDragToTimeSlot\n             */\n            /**\n             * Set to true to only allow dragging events to different resources, and disallow rescheduling by dragging.\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToTimeSlot : false,\n            /**\n             * A CSS selector specifying elements outside the scheduler element which are valid drop targets.\n             * @config {String}\n             */\n            externalDropTargetSelector : null,\n            /**\n             * An empty function by default, but provided so that you can perform custom validation on the item being\n             * dragged. This function is called during the drag and drop process and also after the drop is made.\n             * Return `true` if the new position is valid, `false` to prevent the drag.\n             *\n             * ```javascript\n             * features : {\n             *     eventDrag : {\n             *         validatorFn({ eventRecords, newResource }) {\n             *             const\n             *                 task  = eventRecords[0],\n             *                 valid = newResource.role === task.resource.role;\n             *\n             *             return {\n             *                 valid   : newResource.role === task.resource.role,\n             *                 message : valid ? '' : 'Resource role does not match required role for this task'\n             *             };\n             *         }\n             *     }\n             * }\n             * ```\n             * @param {Object} context A drag drop context object\n             * @param {Date} context.startDate New start date\n             * @param {Date} context.endDate New end date\n             * @param {Scheduler.model.AssignmentModel[]} context.assignmentRecords Assignment records which were dragged\n             * @param {Scheduler.model.EventModel[]} context.eventRecords Event records which were dragged\n             * @param {Scheduler.model.ResourceModel} context.newResource New resource record\n             * @param {Scheduler.model.EventModel} context.targetEventRecord Currently hovering this event record\n             * @param {Event} event The event object\n             * @returns {Boolean|Object} `true` if this validation passes, `false` if it does not.\n             *\n             * Or an object with 2 properties: `valid` -  Boolean `true`/`false` depending on validity,\n             * and `message` - String with a custom error message to display when invalid.\n             * @config {Function}\n             */\n            validatorFn : (context, event) => {},\n            /**\n             * The `this` reference for the validatorFn\n             * @config {Object}\n             */\n            validatorFnThisObj : null,\n            /**\n             * When the host Scheduler is `{@link Scheduler.view.mixin.EventSelection#config-multiEventSelect}: true`\n             * then, there are two modes of dragging *within the same Scheduler*.\n             *\n             * Non unified means that all selected events are dragged by the same number of resource rows.\n             *\n             * Unified means that all selected events are collected together and dragged as one, and are all dropped\n             * on the same targeted resource row at the same targeted time.\n             * @member {Boolean} unifiedDrag\n             */\n            /**\n             * When the host Scheduler is `{@link Scheduler.view.mixin.EventSelection#config-multiEventSelect}: true`\n             * then, there are two modes of dragging *within the same Scheduler*.\n             *\n             * Non unified means that all selected events are dragged by the same number of resource rows.\n             *\n             * Unified means that all selected events are collected together and dragged as one, and are all dropped\n             * on the same targeted resource row at the same targeted time.\n             * @config {Boolean}\n             * @default false\n             */\n            unifiedDrag : null,\n            /**\n             * A hook that allows manipulating the position the drag proxy snaps to. Manipulate the `snapTo` property\n             * to alter snap position.\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventDrag : {\n             *             snapToPosition({ eventRecord, snapTo }) {\n             *                 if (eventRecord.late) {\n             *                     snapTo.x = 400;\n             *                 }\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} context\n             * @param {Scheduler.model.AssignmentModel} context.assignmentRecord Dragged assignment\n             * @param {Scheduler.model.EventModel} context.eventRecord Dragged event\n             * @param {Scheduler.model.ResourceModel} context.resourceRecord Currently over this resource\n             * @param {Date} context.startDate Start date for current position\n             * @param {Date} context.endDate End date for current position\n             * @param {Object} context.snapTo\n             * @param {Number} context.snapTo.x X to snap to\n             * @param {Number} context.snapTo.y Y to snap to\n             * @returns {void}\n             */\n            snapToPosition : null,\n            /**\n             * A modifier key (CTRL, SHIFT, ALT, META) that when pressed will copy an event instead of moving it. Set to\n             * empty string to disable copying\n             * @prp {'CTRL'|'ALT'|'SHIFT'|'META'|''}\n             * @default\n             */\n            copyKey : 'SHIFT',\n            /**\n             * Event can be copied two ways: either by adding new assignment to an existing event ('assignment'), or\n             * by copying the event itself ('event'). 'auto' mode will pick 'event' for a single-assignment mode (when\n             * event has `resourceId` field) and 'assignment' mode otherwise.\n             * @prp {'auto'|'assignment'|'event'}\n             * @default\n             */\n            copyMode : 'auto',\n            /**\n             * Mode of the current drag drop operation.\n             * @member {'move'|'copy'}\n             * @readonly\n             */\n            mode : 'move',\n            capitalizedEventName : null\n        };\n    }\n    afterConstruct() {\n        this.capitalizedEventName = this.capitalizedEventName || this.client.capitalizedEventName;\n        super.afterConstruct(...arguments);\n    }\n    //endregion\n    changeMode(value) {\n        const { dragData, copyMode } = this;\n        // Do not create assignments in case scheduler doesn't use multiple assignments\n        // Do not allow to copy recurring events\n        if (\n            (copyMode === 'event' || copyMode === 'auto' ||\n                copyMode === 'assignment' && !this.scheduler.eventStore.usesSingleAssignment) &&\n            (!dragData || dragData.eventRecords.every(r => !r.isRecurring))\n        ) {\n            return value;\n        }\n    }\n    updateMode(mode) {\n        if (this.dragData) {\n            if (mode === 'copy') {\n                this.setCopying();\n            }\n            else {\n                this.setMoving();\n            }\n            /**\n             * Triggered when drag mode is changed, for example when copy key is\n             * pressed or released while dragging.\n             * @event eventDragModeChange\n             * @param {String} mode Drag mode, could be either 'move', 'copy', or 'auto'\n             * @on-owner\n             */\n            this.client.trigger('eventDragModeChange', { mode });\n        }\n    }\n    setCopying() {\n        const { dragData } = this;\n        if (!dragData) {\n            return;\n        }\n        // Check if proxies are added to the DOM by checking if any of them is\n        if (!dragData.eventBarCopies.some(el => el.isConnected)) {\n            dragData.eventBarCopies.forEach(el => {\n                el.classList.add('b-drag-proxy-copy');\n                // hidden class can be added by the drag feature if we're dragging event outside\n                el.classList.remove('b-hidden');\n                dragData.context.grabbedParent.appendChild(el);\n                // Mark this node as ignored for the DomSync\n                el.retainElement = true;\n            });\n        }\n        else {\n            dragData.eventBarCopies.forEach(el => {\n                el.classList.remove('b-hidden');\n            });\n        }\n    }\n    setMoving() {\n        const { dragData } = this;\n        if (!dragData) {\n            return;\n        }\n        dragData.eventBarCopies.forEach(el => {\n            el.classList.add('b-hidden');\n        });\n    }\n    //region Events\n    /**\n     * This event is fired on the owning Scheduler after the event drag operation completes, but before changing any data.\n     * It allows implementer to use asynchronous validation/finalization by setting `context.async = true`\n     * in the listener, for example, to show a confirmation popup, make async data request etc.\n     * In such case, implementer need to call the `context.finalize()` method manually:\n     *\n     * ```javascript\n     *  scheduler.on('beforeeventdropfinalize', ({ context }) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // `true` to perform the drop, `false` to ignore it\n     *          context.finalize(true);\n     *      }, 1000);\n     *  })\n     * ```\n     *\n     * For synchronous one-time validation, simply set `context.valid` to true or false.\n     * ```javascript\n     *  scheduler.on('beforeeventdropfinalize', ({ context }) => {\n     *      context.valid = false;\n     *  })\n     * ```\n     * @event beforeEventDropFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Object} context\n     * @param {DropData} context.dropData Information about the drop points for dragged events/assignments.\n     * @param {Boolean} context.async Set to `true` to not finalize the drag-drop operation immediately (e.g. to wait for user confirmation)\n     * @param {Scheduler.model.EventModel[]} context.eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} context.assignmentRecords Assignment records being dragged\n     * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target\n     * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target\n     * @param {Boolean} context.valid Set this to `false` to abort the drop immediately.\n     * @param {Function} context.finalize Call this method after an **async** finalization flow, to finalize the drag-drop operation. This method accepts one\n     * argument: pass `true` to update records, or `false` to ignore changes\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler after event drop\n     * @event afterEventDrop\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n     * @param {Scheduler.model.EventModel[]} eventRecords\n     * @param {Boolean} valid\n     * @param {Object} context\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler when an event is dropped\n     * @event eventDrop\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel[]} eventRecords\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n     * @param {HTMLElement} externalDropTarget The HTML element dropped upon, if drop happened on a valid external drop target\n     * @param {Boolean} isCopy\n     * @param {Object} context\n     * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target\n     * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler before event dragging starts. Return `false` to prevent the action.\n     * @event beforeEventDrag\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record the drag starts from\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag starts from\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} event Browser event DEPRECATED (replaced by domEvent)\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler when event dragging starts\n     * @event eventDragStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag starts from\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} event Browser event DEPRECATED (replaced by domEvent)\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler when event is dragged\n     * @event eventDrag\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {Date} startDate Start date for the current location\n     * @param {Date} endDate End date for the current location\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag started from\n     * @param {Scheduler.model.ResourceModel} newResource Resource at the current location\n     * @param {Object} context\n     * @param {Boolean} context.valid Set this to `false` to signal that the current drop position is invalid.\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler after an event drag operation has been aborted\n     * @event eventDragAbort\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler after an event drag operation regardless of the operation being cancelled or not\n     * @event eventDragReset\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     */\n    //endregion\n    //region Data layer\n    // Deprecated. Use this.client instead\n    get scheduler() {\n        return this.client;\n    }\n    //endregion\n    //#region Drag lifecycle\n    onAfterDragStart(event) {\n        const\n            me                        = this,\n            { context : { element } } = event;\n        super.onAfterDragStart(event);\n        me.handleKeyDownOrMove(event.event);\n        me.keyEventDetacher = EventHelper.on({\n            // In case we drag event between scheduler focused event gets moved and focus\n            // moves to the body. We only need to read the key from this event\n            element : DomHelper.getRootElement(element),\n            keydown : me.handleKeyDownOrMove,\n            keyup   : me.handleKeyUp,\n            thisObj : me\n        });\n    }\n    onDragReset(event) {\n        super.onDragReset(event);\n        this.keyEventDetacher?.();\n        this.mode = 'move';\n    }\n    onDrop(event) {\n        // Always remove proxy on drop\n        this.dragData.eventBarCopies?.forEach(el => el.remove());\n        return super.onDrop(event);\n    }\n    //#endregion\n    //region Drag events\n    getDraggableElement(el) {\n        return el?.closest(this.drag.targetSelector);\n    }\n    resolveEventRecord(eventElement, client = this.client) {\n        return client.resolveEventRecord(eventElement);\n    }\n    isElementDraggable(el, event) {\n        const\n            me           = this,\n            { client }   = me,\n            eventElement = me.getDraggableElement(el);\n        if (!eventElement || me.disabled || client.readOnly) {\n            return false;\n        }\n        // displaying something resizable within the event?\n        if (el.matches('[class$=\"-handle\"]')) {\n            return false;\n        }\n        const eventRecord = me.resolveEventRecord(eventElement, client);\n        if (!eventRecord || !eventRecord.isDraggable || eventRecord.readOnly) {\n            return false;\n        }\n        // Hook for features that need to prevent drag\n        const prevented = client[`is${me.capitalizedEventName}ElementDraggable`]?.(\n            eventElement, eventRecord, el, event\n        ) === false;\n        return !prevented;\n    }\n    getTriggerParams(dragData) {\n        const { assignmentRecords, eventRecords, resourceRecord, browserEvent : domEvent } = dragData;\n        return {\n            // `context` is now private, but used in WebSocketHelper\n            context : dragData,\n            eventRecords,\n            resourceRecord,\n            assignmentRecords,\n            event   : domEvent, // Deprecated, remove on  6.0?\n            domEvent\n        };\n    }\n    getGroupedToStoreResources(dragData) {\n        if (dragData.resourcesInStore) {\n            return dragData.resourcesInStore;\n        }\n        const\n            fromScheduler = this.client,\n            fromResourceStore = fromScheduler.isVertical ? fromScheduler.resourceStore : fromScheduler.store;\n        return dragData.resourcesInStore = [...new Set(fromResourceStore.getAllDataRecords().map(r => r.$original))].filter(r => r.isLeaf);\n    }\n    getIndexDiff(dragData) {\n        const\n            me = this,\n            fromScheduler = me.client,\n            toScheduler = me.currentOverClient,\n            isCrossScheduler = fromScheduler !== toScheduler,\n            { isVertical } = toScheduler,\n            // When using TreeGroup in horizontal mode, store != resourceStore. Does not apply for vertical mode.\n            fromResourceStore = fromScheduler.isVertical ? fromScheduler.resourceStore : fromScheduler.store,\n            toResourceStore = isVertical ? toScheduler.resourceStore : toScheduler.store,\n            {\n                resourceRecord : fromResource,\n                newResource : toResource\n            } = dragData;\n        let indexDiff;\n        if (isCrossScheduler) {\n            // The difference in indices via first dragged event will help us find resources for all the rest of the\n            // events accordingly\n            indexDiff = toResourceStore.indexOf(toResource) - fromResourceStore.indexOf(fromResource.$original);\n        }\n        else if (me.constainDragToResource) {\n            indexDiff = 0;\n        }\n        else if (isVertical && toResourceStore.isGrouped) {\n            const resourcesInStore    = me.getGroupedToStoreResources(dragData);\n            indexDiff = resourcesInStore.indexOf(fromResource.$original) - resourcesInStore.indexOf(toResource);\n        }\n        else {\n            indexDiff = fromResourceStore.indexOf(fromResource.$original) - fromResourceStore.indexOf(toResource);\n        }\n        return indexDiff;\n    }\n    getNewResource(dragData, originalResourceRecord, indexDiff) {\n        const\n            me = this,\n            fromScheduler = me.client,\n            toScheduler = me.currentOverClient,\n            isCrossScheduler = fromScheduler !== toScheduler,\n            { isVertical } = toScheduler,\n            // When using TreeGroup in horizontal mode, store != resourceStore. Does not apply for vertical mode.\n            fromResourceStore = fromScheduler.isVertical ? fromScheduler.resourceStore : fromScheduler.store,\n            toResourceStore = isVertical ? toScheduler.resourceStore : toScheduler.store;\n        let { newResource }    = dragData;\n        if (!isCrossScheduler) {\n            // If not dragging events as a unified block, distribute each to a new resource\n            // using the same offset as the dragged event.\n            if (indexDiff !== 0) {\n                let newIndex;\n                if (isVertical && toResourceStore.isGrouped) {\n                    const resourcesInStore    = me.getGroupedToStoreResources(dragData);\n                    newIndex    = Math.max(\n                        Math.min(\n                            resourcesInStore.indexOf(originalResourceRecord) - indexDiff,\n                            resourcesInStore.length - 1\n                        ),\n                        0\n                    );\n                    newResource = resourcesInStore[newIndex];\n                }\n                else {\n                    newIndex = Math.max(\n                        Math.min(\n                            fromResourceStore.indexOf(originalResourceRecord) - indexDiff,\n                            fromResourceStore.count - 1\n                        ),\n                        0\n                    );\n                    newResource = fromResourceStore.getAt(newIndex);\n                    // Exclude group headers, footers, summary row etc\n                    if (newResource.isSpecialRow) {\n                        newResource = fromResourceStore.getNext(newResource, false, true) || fromResourceStore.getPrevious(newResource, false, true);\n                    }\n                }\n                newResource = newResource?.$original;\n            }\n            else {\n                newResource = originalResourceRecord;\n            }\n        }\n        // we have a resource for first dragged event in toResource\n        else {\n            const draggedEventResourceIndex = fromResourceStore.indexOf(originalResourceRecord);\n            newResource                     = toResourceStore.getAt(draggedEventResourceIndex + indexDiff) || newResource;\n        }\n        return newResource;\n    }\n    getDropData(dragData) {\n        const indexDiff = this.getIndexDiff(dragData);\n        return {\n            events : dragData.eventRecords.map(eventRecord => {\n                return {\n                    eventRecord,\n                    ...this.getEventNewStartEndDates(eventRecord, dragData.timeDiff)\n                };\n            }),\n            assignments : dragData.assignmentRecords.map(assignmentRecord => {\n                return {\n                    assignmentRecord,\n                    resourceRecord : this.getNewResource(dragData, assignmentRecord.resource, indexDiff)\n                };\n            })\n        };\n    }\n    triggerBeforeEventDropFinalize(eventType, eventData, client) {\n        eventData.context.dropData = this.getDropData(eventData.context);\n        super.triggerBeforeEventDropFinalize(eventType, eventData, client);\n    }\n    triggerBeforeEventDrag(eventType, event) {\n        return this.client.trigger(eventType, event);\n    }\n    triggerEventDrag(dragData, start) {\n        this.client.trigger('eventDrag', Object.assign(this.getTriggerParams(dragData), {\n            startDate   : dragData.startDate,\n            endDate     : dragData.endDate,\n            newResource : dragData.newResource\n        }));\n    }\n    triggerDragStart(dragData) {\n        this.client.navigator.skipNextClick = true;\n        this.client.trigger('eventDragStart', this.getTriggerParams(dragData));\n    }\n    triggerDragAbort(dragData) {\n        this.client.trigger('eventDragAbort', this.getTriggerParams(dragData));\n    }\n    triggerDragAbortFinalized(dragData) {\n        this.client.trigger('eventDragAbortFinalized', this.getTriggerParams(dragData));\n    }\n    triggerAfterDrop(dragData, valid) {\n        const me = this;\n        me.currentOverClient.trigger('afterEventDrop', Object.assign(me.getTriggerParams(dragData), {\n            valid\n        }));\n        if (!valid) {\n            // Edge cases:\n            // 1. If this drag was a no-op, and underlying data was changed while drag was ongoing (e.g. web socket\n            // push), we need to manually force a view refresh to ensure a correct render state\n            //\n            // or\n            // 2. Events were removed before we dropped at an invalid point\n            const\n                { assignmentStore, eventStore } = me.client,\n                needRefresh                     = me.dragData.initialAssignmentsState.find(({\n                    resource, assignment\n                }, i) => {\n                    return !assignmentStore.includes(assignment) ||\n                        !eventStore.includes(assignment.event) ||\n                        resource.id !== me.dragData.assignmentRecords[i]?.resourceId;\n                });\n            if (needRefresh) {\n                me.client.refresh();\n            }\n        }\n        // Reset the skipNextClick after a potential click event fires. https://github.com/bryntum/support/issues/5135\n        me.client.setTimeout(() => me.client.navigator.skipNextClick = false, 10);\n    }\n    handleKeyDownOrMove(event) {\n        if (this.mode !== 'copy') {\n            if (event.key && EventHelper.specialKeyFromEventKey(event.key) === this.copyKey?.toLowerCase() || event[`${this.copyKey?.toLowerCase()}Key`]) {\n                this.mode = 'copy';\n            }\n        }\n    }\n    handleKeyUp(event) {\n        if (EventHelper.specialKeyFromEventKey(event.key) === this.copyKey.toLowerCase()) {\n            this.mode = 'move';\n        }\n    }\n    //endregion\n    //region Finalization & validation\n    /**\n     * Checks if an event can be dropped on the specified position.\n     * @private\n     * @returns {Boolean} Valid (true) or invalid (false)\n     */\n    isValidDrop(dragData) {\n        const\n            {\n                newResource,\n                resourceRecord,\n                browserEvent\n            }            = dragData,\n            sourceRecord = dragData.draggedEntities[0],\n            { target }   = browserEvent;\n        // Only allowed to drop outside scheduler element if we hit an element matching the externalDropTargetSelector\n        if (!newResource) {\n            return (!this.constrainDragToTimeline && this.externalDropTargetSelector) ? Boolean(target.closest(this.externalDropTargetSelector)) : false;\n        }\n        // Not allowed to drop an event on a group header or a readOnly resource\n        if (newResource.isSpecialRow || newResource.readOnly) {\n            return false;\n        }\n        // Not allowed to assign an event twice to the same resource\n        if (resourceRecord.$original !== newResource) {\n            return !sourceRecord.event.resources.includes(newResource);\n        }\n        return true;\n    }\n    checkDragValidity(dragData, event) {\n        const\n            me        = this,\n            scheduler = me.currentOverClient;\n        let result;\n        // Cannot assign anything to readOnly resources\n        if (dragData.newResource?.readOnly) {\n            return false;\n        }\n        // First make sure there's no overlap, if not run the external validatorFn\n        if (!scheduler.allowOverlap && !scheduler.isDateRangeAvailable(\n            dragData.startDate,\n            dragData.endDate,\n            dragData.draggedEntities[0],\n            dragData.newResource\n        )) {\n            result = {\n                valid   : false,\n                message : me.L('L{eventOverlapsExisting}')\n            };\n        }\n        else {\n            result = me.validatorFn.call(\n                me.validatorFnThisObj || me,\n                dragData,\n                event\n            );\n        }\n        if (!result || result.valid) {\n            // Hook for features to have a say on validity\n            result = scheduler['checkEventDragValidity']?.(dragData, event) ?? result;\n        }\n        return result;\n    }\n    //endregion\n    //region Update records\n    /**\n     * Update events being dragged.\n     * @private\n     * @param context Drag data.\n     */\n    async updateRecords(context) {\n        const\n            me                            = this,\n            fromScheduler                                          = me.client,\n            toScheduler                                            = me.currentOverClient,\n            copyKeyPressed                                         = me.mode === 'copy',\n            { draggedEntities, timeDiff, initialAssignmentsState } = context,\n            originalStartDate                                      = initialAssignmentsState[0].startDate,\n            droppedStartDate                                       = me.adjustStartDate(originalStartDate, timeDiff);\n        let result;\n        if (!context.externalDropTarget) {\n            // Dropping dragged event completely outside the time axis is not allowed\n            if (!toScheduler.timeAxis.timeSpanInAxis(droppedStartDate, DateHelper.add(droppedStartDate, draggedEntities[0].event.durationMS, 'ms'))) {\n                context.valid = false;\n            }\n            if (context.valid) {\n                fromScheduler.eventStore.suspendAutoCommit();\n                toScheduler.eventStore.suspendAutoCommit();\n                result = await me.updateAssignments(fromScheduler, toScheduler, context, copyKeyPressed);\n                fromScheduler.eventStore.resumeAutoCommit();\n                toScheduler.eventStore.resumeAutoCommit();\n            }\n        }\n        // Might be flagged invalid in updateAssignments() above, if drop did not lead to any change\n        // (for example if dropped on non-working-time in Pro)\n        if (context.valid) {\n            // Tell the world there was a successful drop\n            toScheduler.trigger('eventDrop', Object.assign(me.getTriggerParams(context), {\n                isCopy               : copyKeyPressed,\n                copyMode             : me.copyMode,\n                domEvent             : context.browserEvent,\n                targetEventRecord    : context.targetEventRecord,\n                targetResourceRecord : context.newResource,\n                externalDropTarget   : context.externalDropTarget\n            }));\n        }\n        return result;\n    }\n    /**\n     * Update assignments being dragged\n     * @private\n     */\n    async updateAssignments(fromScheduler, toScheduler, context, copy) {\n        // The code is written to emit as few store events as possible\n        const\n            me                  = this,\n            { copyMode }        = me,\n            isCrossScheduler    = (fromScheduler !== toScheduler),\n            { isVertical }      = toScheduler,\n            {\n                assignmentStore : fromAssignmentStore,\n                eventStore      : fromEventStore\n            }                   = fromScheduler,\n            {\n                assignmentStore : toAssignmentStore,\n                eventStore      : toEventStore\n            }                   = toScheduler,\n            // When using TreeGroup in horizontal mode, store != resourceStore. Does not apply for vertical mode.\n            fromResourceStore   = fromScheduler.isVertical ? fromScheduler.resourceStore : fromScheduler.store,\n            {\n                eventRecords,\n                assignmentRecords,\n                timeDiff,\n                initialAssignmentsState,\n                newResource    : toResource\n            }                   = context,\n            { unifiedDrag }     = me,\n            // For an empty target event store, check if it has usesSingleAssignment explicitly set, otherwise use\n            // the value from the source event store\n            useSingleAssignment = (toEventStore.usesSingleAssignment ||\n                (toEventStore.usesSingleAssignment !== false && fromEventStore.usesSingleAssignment)),\n            // this value has clear semantic only for same scheduler case\n            effectiveCopyMode   = copyMode === 'event'\n                ? 'event'\n                : copyMode === 'assignment'\n                    ? 'assignment'\n                    : useSingleAssignment ? 'event' : 'assignment',\n            event1Date          = me.adjustStartDate(assignmentRecords[0].event.startDate, timeDiff),\n            eventsToAdd         = [],\n            eventsToRemove      = [],\n            assignmentsToAdd    = [],\n            assignmentsToRemove = [],\n            eventsToCheck       = [],\n            eventsToBatch       = new Set();\n        fromScheduler.suspendRefresh();\n        toScheduler.suspendRefresh();\n        let updated      = false,\n            updatedEvent = false,\n            indexDiff = me.getIndexDiff(context); // By how many resource rows has the drag moved.\n        if (isVertical) {\n            eventRecords.forEach((draggedEvent, i) => {\n                const eventBar = context.eventBarEls[i];\n                delete draggedEvent.instanceMeta(fromScheduler).hasTemporaryDragElement;\n                // If it was created by a call to scheduler.currentOrientation.addTemporaryDragElement\n                // then release it back to be available to DomSync next time the rendered event block\n                // is synced.\n                if (eventBar.dataset.transient) {\n                    eventBar.remove();\n                }\n            });\n        }\n        const\n            eventBarEls          = context.eventBarEls.slice(),\n            addedEvents          = [],\n            // this map holds references between original assignment and its copy\n            copiedAssignmentsMap = {};\n        // Using for to support await inside\n        for (let i = 0; i < assignmentRecords.length; i++) {\n            const originalAssignment = assignmentRecords[i];\n            // Reassigned when dropped on other scheduler, thus not const\n            let draggedEvent = originalAssignment.event,\n                draggedAssignment;\n            if (copy) {\n                draggedAssignment                           = originalAssignment.copy();\n                copiedAssignmentsMap[originalAssignment.id] = draggedAssignment;\n            }\n            else {\n                draggedAssignment = originalAssignment;\n            }\n            if (!draggedAssignment.isOccurrenceAssignment && (!fromAssignmentStore.includes(originalAssignment) || !fromEventStore.includes(draggedEvent))) {\n                // Event was removed externally during the drag, just remove element from DOM (DomSync already has\n                // tried to clean it up at this point, but could not due to retainElement being set)\n                eventBarEls[i].remove();\n                eventBarEls.splice(i, 1);\n                assignmentRecords.splice(i, 1);\n                i--;\n                continue;\n            }\n            const\n                initialState           = initialAssignmentsState[i],\n                originalEventRecord    = draggedEvent,\n                originalStartDate      = initialState.startDate,\n                // grabbing resource early, since after \".copy()\" the record won't belong to any store\n                // and \".getResources()\" won't work. If it's a move to another scheduler, ensure the\n                // array still has a length. The process function will do an assign as opposed\n                // to a reassignment\n                originalResourceRecord = initialState.resource,\n                // Calculate new startDate (and round it) based on timeDiff up here, might be added to another\n                // event store below in which case it is invalidated. But this is anyway the target date\n                newStartDate           = this.constrainDragToTimeSlot\n                    ? originalStartDate\n                    : (unifiedDrag\n                        ? event1Date\n                        : me.adjustStartDate(originalStartDate, timeDiff));\n            if (fromAssignmentStore !== toAssignmentStore) {\n                // Single assignment from a multi assigned event dragged over, event needs to be copied over\n                // Same if we hold the copy key\n                const keepEvent = originalEventRecord.assignments.length > 1 || copy;\n                let newAssignment;\n                if (copy) {\n                    // In a copy mode dragged assignment is already a copy\n                    newAssignment = draggedAssignment;\n                }\n                else {\n                    newAssignment                              = draggedAssignment.copy();\n                    copiedAssignmentsMap[draggedAssignment.id] = newAssignment;\n                }\n                // Pro Engine does not seem to handle having the event already in place on the copied assignment,\n                // replacing it with id to have events bucket properly set up on commit\n                if (newAssignment.event && !useSingleAssignment) {\n                    newAssignment.event    = newAssignment.event.id;\n                    newAssignment.resource = newAssignment.resource.id;\n                }\n                if (!copy) {\n                    // If we're not copying, remove assignment from source scheduler\n                    assignmentsToRemove.push(draggedAssignment);\n                }\n                // If it was the last assignment, the event should also be removed\n                if (!keepEvent) {\n                    eventsToRemove.push(originalEventRecord);\n                }\n                // If event does not already exist in target scheduler a copy is added\n                // if we're copying the event, we always need to create new record\n                if (\n                    copy && (copyMode === 'event' || (copyMode === 'auto' && toEventStore.usesSingleAssignment)) ||\n                    !toEventStore.getById(originalEventRecord.id)\n                ) {\n                    draggedEvent = toEventStore.createRecord({\n                        ...originalEventRecord.data,\n                        children : originalEventRecord.children?.map(child => child.copy()),\n                        // If we're copying the event (not making new assignment to existing), we need to generate\n                        // phantom id to link event to the assignment record\n                        id       : copy && (copyMode === 'event' || copyMode === 'auto') ? undefined : originalEventRecord.id,\n                        // Engine gets mad if not nulled\n                        calendar : null\n                    });\n                    newAssignment.set({\n                        eventId : draggedEvent.id,\n                        event   : draggedEvent\n                    });\n                    eventsToAdd.push(draggedEvent);\n                }\n                // And add it to the target scheduler\n                if (!useSingleAssignment) {\n                    assignmentsToAdd.push(newAssignment);\n                }\n                draggedAssignment = newAssignment;\n            }\n            let newResource    = toResource,\n                reassignedFrom = null;\n            if (!unifiedDrag) {\n                newResource = me.getNewResource(context, originalResourceRecord, indexDiff) || toResource;\n            }\n            const isCrossResource = draggedAssignment.resourceId !== newResource.$original.id;\n            // Cannot rely on assignment generation to detect update, since it might be a new assignment\n            if (isCrossResource) {\n                reassignedFrom = fromResourceStore.getById(draggedAssignment.resourceId);\n                if (copy && fromAssignmentStore === toAssignmentStore) {\n                    // Scheduler Core patch\n                    // need to completely clear the resource/resourceId on the copied assignment, before setting the new\n                    // otherwise, what happens is that in the `$beforeChange.resource/Id` are still\n                    // stored the resource/Id of the original assignment\n                    // then, when finalizing commit, Core engine performs this:\n                    //     // First silently revert any data change (used by buckets), otherwise it won't be detected by `set()`\n                    //     me.setData(me.$beforeChange)\n                    // and then updates the data to new, which is recorded as UpdateAction in the STM with old/new data\n                    // then, when that update action in STM is undo-ed, the old data is written back to the record\n                    // and newly added assignment is pointing to the old resource\n                    // then, when STM action is redo-ed, a \"duplicate assignment\" exception is thrown\n                    // this is covered with the test:\n                    // Scheduler/tests/features/EventDragCopy.t.js -> Should not remove the original when undo-ing the copy-drag action (\"multi-assignment\")\n                    draggedAssignment.setData({\n                        resource   : null,\n                        resourceId : null\n                    });\n                    // eof Scheduler Core patch\n                    draggedAssignment.resource = newResource;\n                    draggedAssignment.event    = toEventStore.getById(draggedAssignment.eventId);\n                    const shouldCopyEvent = copyMode === 'event' || (fromEventStore.usesSingleAssignment && copyMode === 'auto');\n                    if (shouldCopyEvent) {\n                        draggedEvent = draggedEvent.copy();\n                        // need to clear the `endDate` of the copy\n                        // this is because when we drag the copy to a different position on the timeline\n                        // it will set the new start date and re-calculate end date\n                        // as a result, in STM transaction for this drag-copy there will be \"add\" action\n                        // and \"update\" action and NO COMMIT in the middle\n                        // so when re-doing this transaction the duration change is lost\n                        // this is covered with the test:\n                        // \"Scheduler/tests/features/EventDragCopy.t.js -> Should not remove the original when undo-ing the copy-drag action (usesSingleAssignment)\",\n                        // Before doing it, save a copy of endDate in meta object, considering timeDiff: that's because below it will check if event is in timeAxis.\n                        draggedEvent.meta.endDateCached = me.adjustStartDate(draggedEvent.endDate, timeDiff);\n                        draggedEvent.endDate = null;\n                        draggedAssignment.event = draggedEvent;\n                        if (toEventStore.usesSingleAssignment) {\n                            draggedEvent.resource   = newResource;\n                            draggedEvent.resourceId = newResource.id;\n                        }\n                    }\n                    if (\n                        !toAssignmentStore.find(a => a.eventId === draggedAssignment.eventId && a.resourceId === draggedAssignment.resourceId) &&\n                        !assignmentsToAdd.find(r => r.eventId === draggedAssignment.eventId && r.resourceId === draggedAssignment.resourceId)\n                    ) {\n                        shouldCopyEvent && eventsToAdd.push(draggedEvent);\n                        assignmentsToAdd.push(draggedAssignment);\n                    }\n                }\n                else {\n                    draggedAssignment.resource = newResource;\n                }\n                // Actual events should be batched, not data for new events when dragging between\n                draggedEvent.isEvent && eventsToBatch.add(draggedEvent);\n                updated = true;\n                // When dragging an occurrence, the assignment is only temporary. We have to tag the newResource along\n                // to be picked up by the occurrence -> event conversion\n                if (draggedEvent.isOccurrence) {\n                    draggedEvent.set('newResource', newResource);\n                }\n                if (isCrossScheduler && useSingleAssignment) {\n                    // In single assignment mode, when dragged to another scheduler it will not copy the assignment\n                    // over but instead set the resourceId of the event. To better match expected behaviour\n                    draggedEvent.resourceId = newResource.id;\n                }\n            }\n            else {\n                if (\n                    copy &&\n                    (copyMode === 'event' || (copyMode === 'auto' && fromEventStore.usesSingleAssignment)) &&\n                    !eventsToAdd.includes(draggedEvent)\n                ) {\n                    draggedEvent = draggedEvent.copy();\n                    // see the comment above\n                    draggedEvent.meta.endDateCached = me.adjustStartDate(draggedEvent.endDate, timeDiff);\n                    draggedEvent.endDate = null;\n                    eventsToAdd.push(draggedEvent);\n                    draggedAssignment.event = draggedEvent;\n                    if (toEventStore.usesSingleAssignment) {\n                        draggedEvent.set({\n                            resource   : newResource,\n                            resourceId : newResource.id\n                        });\n                    }\n                    // Always add assignment to the store to allow proper element reuse\n                    assignmentsToAdd.push(draggedAssignment);\n                }\n            }\n            // Same for event\n            if (!eventsToCheck.find(ev => ev.draggedEvent === draggedEvent) && !DateHelper.isEqual(draggedEvent.startDate, newStartDate)) {\n                // only do for non occurence records\n                while (!draggedEvent.isOccurrence && draggedEvent.isBatchUpdating) {\n                    draggedEvent.endBatch(true);\n                }\n                // for same scheduler with multi-assignments, and copyMode === assignment, need to keep the start date\n                // because user intention is to create a new assignment, not re-schedule the event\n                // but only for cross-resource dragging, same resource dragging has semantic of regular drag\n                const shouldKeepStartDate = copy && !isCrossScheduler && !useSingleAssignment && effectiveCopyMode === 'assignment' && isCrossResource;\n                if (!shouldKeepStartDate) {\n                    draggedEvent.startDate = newStartDate;\n                    eventsToCheck.push({ draggedEvent, originalStartDate });\n                }\n                draggedEvent.isEvent && eventsToBatch.add(draggedEvent);\n                updatedEvent = true;\n            }\n            // Hook for features that need to do additional processing on drop (used by NestedEvents)\n            toScheduler.processEventDrop({\n                eventRecord    : draggedEvent,\n                resourceRecord : newResource,\n                element        : i === 0 ? context.context.element : context.context.relatedElements[i - 1],\n                context,\n                toScheduler,\n                reassignedFrom,\n                eventsToAdd,\n                addedEvents,\n                draggedAssignment\n            });\n            // There are two cases to consider when triggering this event - `copy` and `move` mode. In case we are\n            // copying the assignment (we can also copy the event) draggedAssignment will point to the copy of the\n            // original assignment record. Same for draggedEvent. These records are new records which are not yet added\n            // to the store and they contain correct state of the drop - which event is going to be assigned to which\n            // resource on what time.\n            // These records possess no knowledge about original records which they were cloned from. And that might be\n            // useful. Let's say you want to copy assignment (or event) to every row in the way. You need to know start\n            // row and the end row. That information is kept in the `originalAssignment` record. Which might be identical\n            // to the `draggedAssignment` record in `move` mode.\n            toScheduler.trigger('processEventDrop', {\n                originalAssignment,\n                draggedAssignment,\n                context,\n                copyMode,\n                isCopy : copy\n            });\n        }\n        fromAssignmentStore.remove(assignmentsToRemove);\n        fromEventStore.remove(eventsToRemove);\n        toAssignmentStore.add(assignmentsToAdd);\n        // Modify syncIdMap on the FGCanvas to make sure elements get animated nicely to new position\n        if (copy && fromAssignmentStore === toAssignmentStore) {\n            const { syncIdMap } = fromScheduler.foregroundCanvas;\n            Object.entries(copiedAssignmentsMap).forEach(([originalId, cloneRecord]) => {\n                const element = syncIdMap[originalId];\n                delete syncIdMap[originalId];\n                syncIdMap[cloneRecord.id] = element;\n            });\n        }\n        eventsToAdd.length && addedEvents.push(...toEventStore.add(eventsToAdd));\n        addedEvents?.forEach(added => eventsToBatch.add(added));\n        // addedEvents order is the same with [context.element, ..context.relatedElements]\n        // Any added or removed events or assignments => something changed\n        if (assignmentsToRemove.length || eventsToRemove.length || assignmentsToAdd.length || eventsToAdd.length) {\n            updated = true;\n        }\n        // Commit changes to affected projects\n        if (updated || updatedEvent) {\n            // By batching event changes when using single assignment we avoid two updates, without it there will be one\n            // for date change and one when changed assignment updates resourceId on the event\n            useSingleAssignment && eventsToBatch.forEach(eventRecord => eventRecord.beginBatch());\n            await Promise.all([\n                toScheduler.project !== fromScheduler.project ? toScheduler.project.commitAsync() : null,\n                fromScheduler.project.commitAsync()\n            ]);\n            // End batch in engine friendly way, avoiding to have `set()` trigger another round of calculations\n            useSingleAssignment && eventsToBatch.forEach(eventRecord => eventRecord.endBatch(false, true));\n        }\n        if (!updated) {\n            // Engine might have reverted the date change, in which case this should be considered an invalid op\n            updated = eventsToCheck.some(({ draggedEvent, originalStartDate }) =>\n                !DateHelper.isEqual(draggedEvent.startDate, originalStartDate)\n            );\n        }\n        // When not constrained to timeline we are dragging a clone and need to manually do some cleanup if\n        // dropped in view, but only for valid drops\n        if (!me.constrainDragToTimeline && updated) {\n            // go through assignmentRecords again after events has been added to toEventStore (if any)\n            // now we have updated assignment ids and can properly reuse event HTML elements\n            for (let i = 0; i < assignmentRecords.length; i++) {\n                const\n                    assignmentRecord     = copiedAssignmentsMap[assignmentRecords[i].id] || assignmentRecords[i],\n                    originalDraggedEvent = assignmentRecord.event,\n                    // try to get dragged event from addedEvents array, it will be there with updated ids\n                    // if toScheduler is different\n                    draggedEvent         = addedEvents?.find(r => r.id === originalDraggedEvent.id) || originalDraggedEvent,\n                    eventBar             = context.eventBarEls[i],\n                    element              = i === 0 ? context.context.element : context.context.relatedElements[i - 1],\n                    // Determine if in time axis here also, since the records date might be invalidated further below\n                    inTimeAxis           = toScheduler.isInTimeAxis(draggedEvent);\n                // after checking if is in time axis, imeta.endDateCached can be deleted\n                delete draggedEvent.meta.endDateCached;\n                if (!copy) {\n                    // Remove original element properly\n                    DomSync.removeChild(eventBar.parentElement, eventBar);\n                }\n                if (draggedEvent.resource && (isVertical || toScheduler.rowManager.getRowFor(draggedEvent.resource)) && inTimeAxis) {\n                    // Nested events are added to correct parent by the feature\n                    if (!draggedEvent.parent || draggedEvent.parent.isRoot) {\n                        const elRect = Rectangle.from(element, toScheduler.foregroundCanvas, true);\n                        // Ensure that after inserting the dragged element clone into the toScheduler's foregroundCanvas\n                        // it's at the same visual position that it was dragged to.\n                        DomHelper.setTopLeft(element, elRect.y, elRect.x);\n                        // Add element properly, so that DomSync will reuse it on next update\n                        DomSync.addChild(toScheduler.foregroundCanvas, element, draggedEvent.assignments[0].id);\n                        isCrossScheduler && toScheduler.processCrossSchedulerEventDrop({\n                            eventRecord : draggedEvent,\n                            toScheduler\n                        });\n                    }\n                    element.classList.remove('b-sch-event-hover', 'b-active', 'b-drag-proxy', 'b-dragging');\n                    element.retainElement = false;\n                }\n            }\n        }\n        // Resumes self twice if not cross scheduler, but was suspended twice above also so all good\n        toScheduler.resumeRefresh(false);\n        fromScheduler.resumeRefresh(false);\n        if (assignmentRecords.length > 0) {\n            if (!updated) {\n                context.valid = false;\n            }\n            else {\n                // Always force re-render of the bars, to return them to their original position when:\n                // * Fill ticks leading to small date adjustment not actually changing the DOM\n                //   (https://github.com/bryntum/support/issues/630)\n                // * Dragging straight down with multiselection, events in the last resource will still be assigned to\n                //   that resource = no change in the DOM (https://github.com/bryntum/support/issues/6293)\n                eventBarEls.forEach(el => delete el.lastDomConfig);\n                // Not doing full refresh above, to allow for animations\n                toScheduler.refreshWithTransition();\n                if (isCrossScheduler) {\n                    fromScheduler.refreshWithTransition();\n                    toScheduler.selectedEvents = addedEvents;\n                }\n            }\n        }\n    }\n    //endregion\n    //region Drag data\n    getProductDragContext(dragData) {\n        const\n            me                                = this,\n            { currentOverClient : scheduler } = me,\n            target                            = dragData.browserEvent.target,\n            previousResolvedResource          = dragData.newResource || dragData.resourceRecord,\n            previousTargetEventRecord         = dragData.targetEventRecord;\n        let\n            targetEventRecord = scheduler ? me.resolveEventRecord(target, scheduler) : null,\n            newResource, externalDropTarget;\n        // Ignore if over dragged event\n        if (dragData.eventRecords.includes(targetEventRecord)) {\n            targetEventRecord = null;\n        }\n        if (me.constrainDragToResource) {\n            newResource = dragData.resourceRecord;\n        }\n        else if (!me.constrainDragToTimeline) {\n            newResource = me.resolveResource();\n        }\n        else if (scheduler) {\n            newResource = me.resolveResource() || dragData.newResource || dragData.resourceRecord;\n        }\n        const\n            { assignmentRecords, eventRecords } = dragData,\n            isOverNewResource                   = previousResolvedResource !== newResource;\n        let valid = Boolean(newResource && !newResource.isSpecialRow);\n        if (!newResource && me.externalDropTargetSelector) {\n            externalDropTarget = target.closest(me.externalDropTargetSelector);\n            valid              = Boolean(externalDropTarget);\n        }\n        return {\n            valid,\n            externalDropTarget,\n            eventRecords,\n            assignmentRecords,\n            newResource,\n            targetEventRecord,\n            dirty         : isOverNewResource || targetEventRecord !== previousTargetEventRecord,\n            proxyElements : [dragData.context.element, ...dragData.context.relatedElements || []]\n        };\n    }\n    getMinimalDragData(info) {\n        const\n            me                = this,\n            { scheduler }     = me,\n            element           = me.getElementFromContext(info),\n            eventRecord       = me.resolveEventRecord(element, scheduler),\n            resourceRecord    = scheduler.resolveResourceRecord(element),\n            assignmentRecord  = scheduler.resolveAssignmentRecord(element),\n            assignmentRecords = assignmentRecord ? [assignmentRecord] : [];\n        // We multi drag other selected events if the dragged event is already selected, or the ctrl key is pressed\n        if (assignmentRecord && (scheduler.isAssignmentSelected(assignmentRecords[0]) || (me.drag.startEvent.ctrlKey && scheduler.multiEventSelect))) {\n            assignmentRecords.push.apply(assignmentRecords, me.getRelatedRecords(assignmentRecord));\n        }\n        const eventRecords = [...new Set(assignmentRecords.map(assignment => assignment.event))];\n        return {\n            eventRecord,\n            resourceRecord,\n            assignmentRecord,\n            eventRecords,\n            assignmentRecords\n        };\n    }\n    setupProductDragData(info) {\n        const\n            me            = this,\n            { scheduler } = me,\n            element       = me.getElementFromContext(info),\n            {\n                eventRecord,\n                resourceRecord,\n                assignmentRecord,\n                assignmentRecords\n            }             = me.getMinimalDragData(info),\n            eventBarEls   = [];\n        if (me.constrainDragToResource && !resourceRecord) {\n            throw new Error('Resource could not be resolved for event: ' + eventRecord.id);\n        }\n        let dateConstraints;\n        if (me.constrainDragToTimeline) {\n            dateConstraints = me.getDateConstraints?.(resourceRecord, eventRecord);\n            const\n                constrainRectangle = me.constrainRectangle = me.getConstrainingRectangle(dateConstraints, resourceRecord, eventRecord),\n                eventRegion        = Rectangle.from(element, scheduler.timeAxisSubGridElement);\n            super.setupConstraints(\n                constrainRectangle,\n                eventRegion,\n                scheduler.timeAxisViewModel.snapPixelAmount,\n                Boolean(dateConstraints.start)\n            );\n        }\n        // Collecting all elements to drag\n        assignmentRecords.forEach(assignment => {\n            let eventBarEl = scheduler.getElementFromAssignmentRecord(assignment, true);\n            if (!eventBarEl) {\n                eventBarEl = scheduler.currentOrientation.addTemporaryDragElement(assignment.event, assignment.resource);\n            }\n            eventBarEls.push(eventBarEl);\n        });\n        return {\n            record          : assignmentRecord,\n            draggedEntities : assignmentRecords,\n            dateConstraints : dateConstraints?.start ? dateConstraints : null,\n            // Create copies of the elements\n            eventBarCopies  : eventBarEls.map(el => me.createProxy(el)),\n            eventBarEls\n        };\n    }\n    getDateConstraints(resourceRecord, eventRecord) {\n        const\n            { scheduler }           = this,\n            externalDateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord);\n        let minDate, maxDate;\n        if (this.constrainDragToTimeSlot) {\n            minDate = eventRecord.startDate;\n            maxDate = eventRecord.endDate;\n        }\n        else if (externalDateConstraints) {\n            minDate = externalDateConstraints.start;\n            maxDate = externalDateConstraints.end;\n        }\n        return {\n            start : minDate,\n            end   : maxDate\n        };\n    }\n    getConstrainingRectangle(dateRange, resourceRecord, eventRecord) {\n        return this.scheduler.getScheduleRegion(this.constrainDragToResource && resourceRecord, eventRecord, true, dateRange && {\n            start : dateRange.start, end : dateRange.end\n        });\n    }\n    /**\n     * Initializes drag data (dates, constraints, dragged events etc). Called when drag starts.\n     * @private\n     * @param info\n     * @returns {*}\n     */\n    getDragData(info) {\n        const dragData = this.getMinimalDragData(info) || {};\n        return {\n            ...super.getDragData(info),\n            ...dragData,\n            initialAssignmentsState : dragData.assignmentRecords.map(assignment => ({\n                startDate : assignment.event.startDate,\n                resource  : assignment.resource,\n                assignment\n            }))\n        };\n    }\n    /**\n     * Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment about to be dragged\n     * @returns {Scheduler.model.AssignmentModel[]} An array of assignment records to drag together with the original\n     */\n    getRelatedRecords(assignmentRecord) {\n        return this.scheduler.selectedAssignments.filter(selectedRecord => selectedRecord !== assignmentRecord && !selectedRecord.resource.readOnly && selectedRecord.event.isDraggable);\n    }\n    /**\n     * Get correct axis coordinate depending on schedulers mode (horizontal -> x, vertical -> y). Also takes milestone\n     * layout into account.\n     * @private\n     * @param {Scheduler.model.EventModel} eventRecord Record being dragged\n     * @param {HTMLElement} element Element being dragged\n     * @param {Number[]} coord XY coordinates\n     * @returns {Number|Number[]} X,Y or XY\n     */\n    getCoordinate(eventRecord, element, coord) {\n        const scheduler = this.currentOverClient;\n        if (scheduler.isHorizontal) {\n            let x = coord[0];\n            // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events\n            if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {\n                switch (scheduler.milestoneAlign) {\n                    case 'center':\n                        x += element.offsetWidth / 2;\n                        break;\n                    case 'end':\n                        x += element.offsetWidth;\n                        break;\n                }\n            }\n            return x;\n        }\n        else {\n            let y = coord[1];\n            // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events\n            if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {\n                switch (scheduler.milestoneAlign) {\n                    case 'center':\n                        y += element.offsetHeight / 2;\n                        break;\n                    case 'end':\n                        y += element.offsetHeight;\n                        break;\n                }\n            }\n            return y;\n        }\n    }\n    /**\n     * Get resource record occluded by the drag proxy.\n     * @private\n     * @returns {Scheduler.model.ResourceModel}\n     */\n    resolveResource() {\n        const\n            me                 = this,\n            client             = me.currentOverClient,\n            { isHorizontal }   = client,\n            {\n                context,\n                browserEvent,\n                dragProxy\n            }                  = me.dragData,\n            element            = dragProxy || context.element,\n            // Page coords for elementFromPoint\n            pageRect           = Rectangle.from(element, null, true),\n            y                  = (client.isVertical || me.unifiedDrag) ? context.clientY : pageRect.center.y,\n            // Local coords to resolve resource in vertical\n            localRect          = Rectangle.from(element, client.timeAxisSubGridElement, true),\n            { x : lx, y : ly } = localRect.center,\n            eventTarget        = me.getMouseMoveEventTarget(browserEvent);\n        let resource = null;\n        if (client.element.contains(eventTarget)) {\n            // This is benchmarked as the fastest way to find a Grid Row from a viewport Y coordinate\n            // so use it in preference to elementFromPoint (which causes a forced synchronous layout) in horizontal mode.\n            if (isHorizontal) {\n                const row = client.rowManager.getRowAt(y);\n                resource = row && client.store.getAt(row.dataIndex);\n            }\n            else {\n                // In vertical mode, just use the X coordinate to find out which resource we are under.\n                // The method requires that a .b-sch-timeaxis-cell element be passed.\n                // There is only one in vertical mode, so use that.\n                resource = client.resolveResourceRecord(client.timeAxisSubGridElement.querySelector('.b-sch-timeaxis-cell'), [lx, ly]);\n            }\n        }\n        return resource?.$original;\n    }\n    //endregion\n    //region Other stuff\n    adjustStartDate(startDate, timeDiff) {\n        const\n            scheduler = this.currentOverClient;\n        startDate = scheduler.timeAxis.roundDate(new Date(startDate - 0 + timeDiff), scheduler.snapRelativeToEventStartDate ? startDate : false);\n        return this.constrainStartDate(startDate);\n    }\n    getRecordElement(assignmentRecord) {\n        return this.client.getElementFromAssignmentRecord(assignmentRecord, true);\n    }\n    // Used by the Dependencies feature to draw lines to the drag proxy instead of the original event element\n    getProxyElement(assignmentRecord) {\n        const { dragData } = this;\n        if (this.isDragging && dragData.proxyElements?.length) {\n            const index = dragData.assignmentRecords.indexOf(assignmentRecord);\n            if (index >= 0) {\n                return dragData.proxyElements[index];\n            }\n        }\n        return null;\n    }\n    //endregion\n    //#region Salesforce hooks\n    getMouseMoveEventTarget(event) {\n        return event.target;\n    }\n    //#endregion\n}\nEventDrag._$name = 'EventDrag'; GridFeatureManager.registerFeature(EventDrag, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventDrag, false, 'ResourceHistogram');\n", "import DragCreateBase from './base/DragCreateBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n/**\n * @module Scheduler/feature/EventDragCreate\n */\n/**\n * Feature that allows the user to create new events by dragging in empty parts of the scheduler rows.\n *\n * {@inlineexample Scheduler/feature/EventDragCreate.js}\n *\n * This feature is **enabled** by default.\n *\n * <div class=\"note\">Incompatible with the {@link Scheduler.feature.EventDragSelect EventDragSelect} and\n * {@link Scheduler.feature.Pan Pan} features. If either of those features are enabled, this feature has no effect.\n * </div>\n *\n * ## Conditionally preventing drag creation\n *\n * To conditionally prevent drag creation for a certain resource or a certain timespan, you listen for the\n * {@link #event-beforeDragCreate} event, add your custom logic to it and return `false` to prevent the operation\n * from starting. For example to not allow drag creation on the topmost resource:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     listeners : {\n *         beforeDragCreate({ resource }) {\n *             // Prevent drag creating on the topmost resource\n *             if (resource === scheduler.resourceStore.first) {\n *                 return false;\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * @extends Scheduler/feature/base/DragCreateBase\n * @demo Scheduler/basic\n * @classtype eventDragCreate\n * @feature\n */\nexport default class EventDragCreate extends DragCreateBase {\n    //region Config\n    static $name = 'EventDragCreate';\n    static configurable = {\n        /**\n         * Locks the layout during drag create, overriding the default behaviour that uses the same rendering\n         * pathway for drag creation as for already existing events.\n         *\n         * This more closely resembles the behaviour of versions prior to 4.2.0.\n         *\n         * @config {Boolean} lockLayout\n         * @default false\n         */\n        /**\n         * An empty function by default, but provided so that you can perform custom validation on the event being\n         * created. Return `true` if the new event is valid, `false` to prevent an event being created.\n         * @param {Object} context A drag create context\n         * @param {Date} context.startDate Event start date\n         * @param {Date} context.endDate Event end date\n         * @param {Scheduler.model.EventModel} context.record Event record\n         * @param {Scheduler.model.ResourceModel} context.resourceRecord Resource record\n         * @param {Event} event The event object\n         * @returns {Boolean} `true` if this validation passes\n         * @config {Function}\n         */\n        validatorFn : () => true\n    };\n    //endregion\n    //region Events\n    /**\n     * Fires on the owning Scheduler after the new event has been created.\n     * @event dragCreateEnd\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The new `EventModel` record.\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource for the row in which the event is being\n     * created.\n     * @param {MouseEvent} event The ending mouseup event.\n     * @param {HTMLElement} eventElement The DOM element representing the newly created event un the UI.\n     */\n    /**\n     * Fires on the owning Scheduler at the beginning of the drag gesture. Returning `false` from a listener prevents\n     * the drag create operation from starting.\n     *\n     * ```javascript\n     * const scheduler = new Scheduler({\n     *     listeners : {\n     *         beforeDragCreate({ date }) {\n     *             // Prevent drag creating events in the past\n     *             return date >= Date.now();\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * @event beforeDragCreate\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Date} date The datetime associated with the drag start point.\n     */\n    /**\n     * Fires on the owning Scheduler after the drag start has created a new Event record.\n     * @event dragCreateStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the new event.\n     */\n    /**\n     * Fires on the owning Scheduler to allow implementer to prevent immediate finalization by setting\n     * `data.context.async = true` in the listener, to show a confirmation popup etc\n     * ```javascript\n     *  scheduler.on('beforedragcreatefinalize', ({context}) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // async code don't forget to call finalize\n     *          context.finalize();\n     *      }, 1000);\n     *  })\n     * ```\n     * @event beforeDragCreateFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the new Event record\n     * @param {Object} context\n     * @param {Boolean} context.async Set true to handle drag create asynchronously (e.g. to wait for user\n     * confirmation)\n     * @param {Function} context.finalize Call this method to finalize drag create. This method accepts one\n     * argument: pass true to update records, or false, to ignore changes\n     */\n    /**\n     * Fires on the owning Scheduler at the end of the drag create gesture whether or not\n     * a new event was created by the gesture.\n     * @event afterDragCreate\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the created event record\n     */\n    //endregion\n    //region Init\n    get scheduler() {\n        return this.client;\n    }\n    get store() {\n        return this.client.eventStore;\n    }\n    get project() {\n        return this.client.project;\n    }\n    updateLockLayout(lock) {\n        this.dragActiveCls = `b-dragcreating${lock ? ' b-dragcreate-lock' : ''}`;\n    }\n    //endregion\n    //region Scheduler specific implementation\n    handleBeforeDragCreate(drag, eventRecord, event) {\n        const { resourceRecord } = drag;\n        if (this.disabled || resourceRecord.readOnly || !this.scheduler.resourceStore.isAvailable(resourceRecord)) {\n            return false;\n        }\n        const\n            { scheduler }      = this,\n            // For resources with a calendar, ensure the date is inside a working time range\n            isWorkingTime      = !scheduler.isSchedulerPro || eventRecord.ignoreResourceCalendar || resourceRecord.isWorkingTime(drag.mousedownDate),\n            result             = isWorkingTime && scheduler.trigger('beforeDragCreate', {\n                resourceRecord,\n                date : drag.mousedownDate,\n                event\n            });\n        // Save date constraints\n        this.dateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord);\n        return result;\n    }\n    dragStart(drag) {\n        const\n            me               = this,\n            { client }       = me,\n            {\n                eventStore,\n                assignmentStore,\n                enableEventAnimations,\n                enableTransactionalFeatures\n            }                  = client,\n            { resourceRecord } = drag,\n            eventRecord        = me.createEventRecord(drag),\n            resourceRecords    = [resourceRecord];\n        eventRecord.set('duration', DateHelper.diff(eventRecord.startDate, eventRecord.endDate, eventRecord.durationUnit, true));\n        // It's only a provisional event until gesture is completed (possibly longer if an editor dialog is shown after)\n        eventRecord.isCreating = true;\n        // Flag used by rendering to not draw a zero length event being drag created as a milestone\n        eventRecord.meta.isDragCreating = true;\n        // force the transaction canceling in the taskeditor early\n        // this is because we are going to add a new event record to the store, and it has to be out of the\n        // task editor's stm transaction\n        // now there's a re-entrant protection in that method, so hopefully when it will be called by the\n        // editor itself that's ok\n        // `taskEdit === false` in some cases, so can't just use `?.` here\n        client.features.taskEdit && client.features.taskEdit.doCancel();\n        // This presents the event to be scheduled for validation at the proposed mouse/date point\n        // If rejected, we cancel operation\n        if (me.handleBeforeDragCreate(drag, eventRecord, drag.event) === false) {\n            return false;\n        }\n        // This is an async function which will start transaction asynchronously. This workflow expect transaction to\n        // be started ASAP\n        me.captureStm(true);\n        let assignmentRecords = [];\n        if (resourceRecord) {\n            if (eventStore.usesSingleAssignment || !enableTransactionalFeatures) {\n                assignmentRecords = assignmentStore.assignEventToResource(eventRecord, resourceRecord);\n            }\n            else {\n                // Do not add record to the store just yet, otherwise records would get to the STM queue assignment first,\n                // then event, which will break `store.added` bag after undo/redo.\n                assignmentRecords = [assignmentStore.createRecord({\n                    event    : eventRecord,\n                    resource : resourceRecord\n                })];\n            }\n        }\n        // Vetoable beforeEventAdd allows cancel of this operation\n        if (client.trigger('beforeEventAdd', { eventRecord, resourceRecords, assignmentRecords }) === false) {\n            if (eventStore.usesSingleAssignment || !enableTransactionalFeatures) {\n                assignmentStore.remove(assignmentRecords);\n            }\n            return false;\n        }\n        // When configured to lock layout during drag create, set a flag that HorizontalRendering will pick up to\n        // exclude the new event from the layout calculations. It will then be at the topmost position in the \"cell\"\n        if (me.lockLayout) {\n            eventRecord.meta.excludeFromLayout = true;\n        }\n        client.onEventCreated?.(eventRecord);\n        client.enableEventAnimations = false;\n        eventStore.addAsync(eventRecord).then(() => client.enableEventAnimations = enableEventAnimations);\n        if (!eventStore.usesSingleAssignment && enableTransactionalFeatures) {\n            // Add assignment after event only to keep STM transaction sane\n            assignmentStore.add(assignmentRecords[0]);\n        }\n        // Element must be created synchronously, not after the project's normalizing delays.\n        // Overrides the check for isEngineReady in VerticalRendering so that the newly added record\n        // will be rendered when we call refreshRows.\n        client.isCreating = true;\n        client.refreshRows();\n        client.isCreating = false;\n        // Set the element we are dragging\n        drag.itemElement = drag.element = client.getElementFromEventRecord(eventRecord);\n        // If the resource row is very tall, the event may have been rendered outside of the\n        // visible viewport. If so, scroll it into view.\n        if (!DomHelper.isInView(drag.itemElement)) {\n            client.scrollable.scrollIntoView(drag.itemElement, {\n                animate    : true,\n                edgeOffset : client.barMargin\n            });\n        }\n        return super.dragStart(drag);\n    }\n    checkValidity(context, event) {\n        const\n            me         = this,\n            { client } = me;\n        // Nicer for users of validatorFn\n        context.resourceRecord = me.dragging.resourceRecord;\n        return (\n            client.allowOverlap ||\n            client.isDateRangeAvailable(context.startDate, context.endDate, context.eventRecord, context.resourceRecord)\n        ) && me.createValidatorFn.call(me.validatorFnThisObj || me, context, event);\n    }\n    // Determine if resource already has events or not\n    isRowEmpty(resourceRecord) {\n        const events = this.store.getEventsForResource(resourceRecord);\n        return !events || !events.length;\n    }\n    //endregion\n    triggerBeforeFinalize(event) {\n        this.client.trigger(`beforeDragCreateFinalize`, event);\n    }\n    /**\n     * Creates an event by the event object coordinates\n     * @param {Object} drag The Bryntum event object\n     * @private\n     */\n    createEventRecord(drag) {\n        const\n            me          = this,\n            { client }  = me,\n            dimension   = client.isHorizontal ? 'X' : 'Y',\n            {\n                timeAxis,\n                eventStore,\n                weekStartDay\n            }           = client,\n            {\n                event,\n                mousedownDate\n            }           = drag,\n            draggingEnd = me.draggingEnd = event[`page${dimension}`] > drag.startEvent[`page${dimension}`],\n            eventConfig = {\n                name      : eventStore.modelClass.fieldMap.name.defaultValue || me.L('L{Object.newEvent}'),\n                startDate : draggingEnd ? DateHelper.floor(mousedownDate, timeAxis.resolution, null, weekStartDay) : mousedownDate,\n                endDate   : draggingEnd ? mousedownDate : DateHelper.ceil(mousedownDate, timeAxis.resolution, null, weekStartDay)\n            };\n        // if project model has been imported from Gantt, we have to define constraint data directly to correct\n        // auto-scheduling while dragCreate\n        if (client.project.isGanttProjectMixin) {\n            ObjectHelper.assign(eventConfig, {\n                constraintDate : eventConfig.startDate,\n                constraintType : 'startnoearlierthan'\n            });\n        }\n        return eventStore.createRecord(eventConfig);\n    }\n    async internalUpdateRecord(context, eventRecord) {\n        await super.internalUpdateRecord(context, eventRecord);\n        // Toggle isCreating after ending batch, to make sure assignments can become persistable\n        if (!this.client.hasEventEditor) {\n            context.eventRecord.isCreating = false;\n        }\n    }\n    async finalizeDragCreate(context) {\n        const { meta } = context.eventRecord;\n        // Remove the layout lock flag, event will jump into place as part of the finalization\n        meta.excludeFromLayout = false;\n        // Also allow new event to become a milestone now\n        meta.isDragCreating    = false;\n        const transferred = await super.finalizeDragCreate(context);\n        // if STM capture has NOT been transferred to the\n        // event editor, we need to finalize the STM transaction / release the capture\n        if (!transferred) {\n            await this.freeStm(true);\n        }\n        else {\n            // otherwise just freeing our capture\n            this.hasStmCapture = false;\n        }\n        return transferred;\n    }\n    async cancelDragCreate(context) {\n        await super.cancelDragCreate(context);\n        await this.freeStm(false);\n    }\n    getTipHtml(...args) {\n        const\n            html        = super.getTipHtml(...args),\n            { element } = this.tip;\n        element.classList.add('b-sch-dragcreate-tooltip');\n        element.classList.toggle('b-too-narrow', this.dragging.context.tooNarrow);\n        return html;\n    }\n    onAborted(context) {\n        const { eventRecord, resourceRecord } = context;\n        // The product this is being used in may not have resources.\n        this.store.unassignEventFromResource?.(eventRecord, resourceRecord);\n        this.store.remove(eventRecord);\n    }\n}\nEventDragCreate._$name = 'EventDragCreate'; GridFeatureManager.registerFeature(EventDragCreate, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventDragCreate, false, 'ResourceHistogram');\n", "import TooltipBase from './base/TooltipBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport { parseAlign } from '../../Core/helper/util/Rectangle.js';\n/**\n * @module Scheduler/feature/EventTooltip\n */\n// Alignment offsets to clear any dependency terminals depending on whether\n// the tooltip is aligned top/bottom (1) or left/right (2) as parsed from the\n// align string by Rectangle's parseAlign\nconst\n    zeroOffset = [0, 0],\n    depOffset  = [\n        null, [0, 10], [10, 0]\n    ];\n/**\n * Displays a tooltip when hovering events. The template used to render the tooltip can be customized, see {@link #config-template}.\n * Config options are also applied to the tooltip shown, see {@link Core.widget.Tooltip} for available options.\n *\n * ## Showing local data\n * To show a basic \"local\" tooltip (with data available in the Event record) upon hover:\n * ```javascript\n * new Scheduler({\n *   features : {\n *     eventTooltip : {\n *         // Tooltip configs can be used here\n *         align : 'l-r' // Align left to right,\n *         // A custom HTML template\n *         template : data => `<dl>\n *           <dt>Assigned to:</dt>\n *              <dt>Time:</dt>\n *              <dd>\n *                  ${DateHelper.format(data.eventRecord.startDate, 'LT')} - ${DateHelper.format(data.eventRecord.endDate, 'LT')}\n *              </dd>\n *              ${data.eventRecord.get('note') ? `<dt>Note:</dt><dd>${data.eventRecord.note}</dd>` : ''}\n *\n *              ${data.eventRecord.get('image') ? `<dt>Image:</dt><dd><img class=\"image\" src=\"${data.eventRecord.get('image')}\"/></dd>` : ''}\n *          </dl>`\n *     }\n *   }\n * });\n * ```\n *\n * ## Showing remotely loaded data\n * Loading remote data into the event tooltip is easy. Simply use the {@link #config-template} and return a Promise which yields the content to show.\n * ```javascript\n * new Scheduler({\n *   features : {\n *     eventTooltip : {\n *        template : ({ eventRecord }) => AjaxHelper.get(`./fakeServer?name=${eventRecord.name}`).then(response => response.text())\n *     }\n *   }\n * });\n * ```\n *\n * This feature is **enabled** by default\n *\n * By default, the tooltip {@link Core.widget.Widget#config-scrollAction realigns on scroll}\n * meaning that it will stay aligned with its target should a scroll interaction make the target move.\n *\n * If this is causing performance issues in a Scheduler, such as if there are many dozens of events\n * visible, you can configure this feature with `scrollAction: 'hide'`. This feature's configuration is\n * applied to the tooltip, so that will mean that the tooltip will hide if its target is moved by a\n * scroll interaction.\n *\n * ## Keeping tooltip visible after mouse exits target element\n *\n * By default, a Tooltip is transient, and will {@link #function-hide} when the mouse leaves the target element.\n * Configure this feature with {@link #config-autoHide} set to `false` to make the Tooltip stay visible.\n *\n * {@inlineexample Scheduler/feature/EventTooltip.js}\n *\n * @demo Scheduler/basic\n *\n * @extends Scheduler/feature/base/TooltipBase\n * @classtype eventTooltip\n * @feature\n */\nexport default class EventTooltip extends TooltipBase {\n    //region Config\n    static get $name() {\n        return 'EventTooltip';\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * Set this value to `false` to keep Tooltip visible after mouse leaves the target element.\n             * @config {Boolean} autoHide\n             * @default true\n             */\n            /**\n             * A function which receives data about the event and returns a string,\n             * or a Promise yielding a string (for async tooltips), to be displayed in the tooltip.\n             * This method will be called with an object containing the fields below\n             *\n             * @config {Function} template\n             * @param {Scheduler.model.EventModel} data.eventRecord Hovered event record\n             * @param {Date} data.startDate Hovered event start date\n             * @param {Date} data.endDate Hovered event end date\n             * @param {String} data.startText Start text\n             * @param {String} data.endText End text\n             * @param {Core.widget.Tooltip} data.tip Current tooltip instance\n             * @param {String} data.startClockHtml Predefined HTML to show the start time\n             * @param {String} data.endClockHtml Predefined HTML to show the end time\n             * @returns {DomConfig|String|null}\n             *\n             * @category Rendering\n             */\n            template : data => `\n                ${data.eventRecord.name ? StringHelper.xss`<div class=\"b-sch-event-title\">${data.eventRecord.name}</div>` : ''}\n                ${data.startClockHtml}\n                ${data.endClockHtml}`,\n            cls : 'b-sch-event-tooltip',\n            monitorRecordUpdate : true,\n            /**\n             * Defines what to do if document is scrolled while the tooltip is visible.\n             *\n             * Valid values: \u00B4null\u00B4: do nothing, \u00B4hide\u00B4: hide the tooltip or \u00B4realign\u00B4: realign to the target if possible.\n             *\n             * @config {'hide'|'realign'|null}\n             * @default\n             */\n            scrollAction : 'hide'\n        };\n    }\n    /**\n     * The event which the tooltip feature has been activated for.\n     * @member {Scheduler.model.EventModel} eventRecord\n     * @readonly\n     */\n    //endregion\n    construct(client, config) {\n        super.construct(client, config);\n        if (typeof this.align === 'string') {\n            this.align = { align : this.align };\n        }\n    }\n    onInternalPaint({ firstPaint }) {\n        super.onInternalPaint(...arguments);\n        if (firstPaint) {\n            const\n                { dependencies } = this.client.features;\n            if (dependencies) {\n                this.tooltip.ion({\n                    beforeAlign({ source : tooltip, offset = zeroOffset }) {\n                        const\n                            { edgeAligned }   = parseAlign(tooltip.align.align),\n                            depTerminalOffset = (dependencies.disabled  || !dependencies.allowCreate) ? zeroOffset : depOffset[edgeAligned];\n                        // Add the spec's offset to the offset necessitated by dependency terminals\n                        arguments[0].offset = [\n                            offset[0] + depTerminalOffset[0],\n                            offset[1] + depTerminalOffset[1]\n                        ];\n                    }\n                });\n            }\n        }\n    }\n}\nEventTooltip._$name = 'EventTooltip'; GridFeatureManager.registerFeature(EventTooltip, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventTooltip, false, 'ResourceHistogram');\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\n/**\n * @module Scheduler/feature/StickyEvents\n */\nconst zeroMargins = { width : 0, height : 0 };\n/**\n * This feature applies native `position: sticky` to event contents in horizontal mode, keeping the contents in view as\n * long as possible on scroll. For vertical mode it uses a programmatic solution to achieve the same result.\n *\n * Assign `eventRecord.stickyContents = false` to disable stickiness on a per event level (docs for\n * {@link Scheduler/model/EventModel#field-stickyContents}).\n *\n * This feature is **enabled** by default.\n *\n * ### Note\n * If a complex {@link Scheduler.view.Scheduler#config-eventRenderer} is used to create a DOM structure within the\n * `.b-sch-event-content` element, then application CSS will need to be written to cancel the stickiness on the\n * `.b-sch-event-content` element, and make some inner content element(s) sticky.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype stickyEvents\n * @feature\n */\nexport default class StickyEvents extends InstancePlugin {\n    static $name = 'StickyEvents';\n    static type = 'stickyEvents';\n    static pluginConfig = {\n        chain : ['onEventDataGenerated']\n    };\n    construct(scheduler, config) {\n        super.construct(scheduler, config);\n        if (scheduler.isVertical) {\n            this.toUpdate = new Set();\n            scheduler.ion({\n                scroll           : 'onSchedulerScroll',\n                horizontalScroll : 'onHorizontalScroll',\n                thisObj          : this,\n                prio             : 10000\n            });\n        }\n    }\n    onEventDataGenerated(renderData) {\n        if (this.client.isHorizontal) {\n            renderData.wrapperCls['b-disable-sticky'] = renderData.eventRecord.stickyContents === false;\n        }\n        else {\n            this.syncEventContentPosition(renderData, undefined, true);\n            this.updateStyles();\n        }\n    }\n    //region Vertical mode\n    onSchedulerScroll() {\n        if (!this.disabled) {\n            this.verticalSyncAllEventsContentPosition(this.client);\n        }\n    }\n    // Have to sync also on horizontal scroll, since we reuse elements and dom configs\n    onHorizontalScroll({ subGrid }) {\n        if (subGrid === this.client.timeAxisSubGrid) {\n            this.verticalSyncAllEventsContentPosition(this.client);\n        }\n    }\n    updateStyles() {\n        for (const { contentEl, style } of this.toUpdate) {\n            DomHelper.applyStyle(contentEl, style);\n        }\n        this.toUpdate.clear();\n    }\n    verticalSyncAllEventsContentPosition(scheduler) {\n        const { resourceMap } = scheduler.currentOrientation;\n        for (const eventsData of resourceMap.values()) {\n            for (const { renderData, elementConfig } of Object.values(eventsData)) {\n                const args = [renderData];\n                if (elementConfig && renderData.eventRecord.isResourceTimeRange) {\n                    args.push(elementConfig.children[0]);\n                }\n                this.syncEventContentPosition.apply(this, args);\n            }\n        }\n        this.toUpdate.size && this.updateStyles();\n    }\n    syncEventContentPosition(renderData, eventContent = renderData.eventContent, duringGeneration = false) {\n        if (\n            this.disabled ||\n            // Allow client disable stickiness for certain events\n            renderData.eventRecord.stickyContents === false\n        ) {\n            return;\n        }\n        const\n            { client }        = this,\n            {\n                eventRecord,\n                resourceRecord,\n                useEventBuffer,\n                bufferAfterWidth,\n                bufferBeforeWidth,\n                top,\n                height\n            }                 = renderData,\n            scrollPosition    = client.scrollable.y,\n            wrapperEl         = duringGeneration ? null : client.getElementFromEventRecord(eventRecord, resourceRecord, true),\n            contentEl         = wrapperEl && DomSync.getChild(wrapperEl, 'event.content'),\n            meta              = eventRecord.instanceMeta(client),\n            style             = typeof eventContent.style === 'string'\n                ? (eventContent.style = DomHelper.parseStyle(eventContent.style))\n                : eventContent.style || (eventContent.style = {});\n        // Do not process events being dragged\n        if (wrapperEl?.classList.contains('b-dragging')) {\n            return;\n        }\n        let start       = top,\n            contentSize = height,\n            end         = start + contentSize;\n        if (useEventBuffer) {\n            start += bufferBeforeWidth;\n            contentSize = contentSize - bufferBeforeWidth - bufferAfterWidth;\n            end = start + contentSize;\n        }\n        // Only process non-milestones that are partially out of view\n        if (start < scrollPosition && end >= scrollPosition && !eventRecord.isMilestone) {\n            const\n                contentWidth = contentEl?.offsetWidth,\n                justify      = contentEl?.parentNode && DomHelper.getStyleValue(contentEl.parentNode, 'justifyContent'),\n                c            = justify === 'center' ? (renderData.width - contentWidth) / 2 : 0,\n                eventStart   = start,\n                eventEnd     = eventStart + contentSize - 1;\n            // Only process non-milestone events. Milestones have no width.\n            // If there's no offsetWidth, it's still b-released, so we cannot measure it.\n            // If the event starts off the left edge, but its right edge is still visible,\n            // translate the contentEl to compensate. If not, undo any translation.\n            if ((!contentEl || contentWidth) && eventStart < scrollPosition && eventEnd >= scrollPosition) {\n                const\n                    edgeSizes = this.getEventContentMargins(contentEl),\n                    maxOffset = contentEl\n                        ? (contentSize - contentEl.offsetHeight - edgeSizes.height) - c\n                        : Number.MAX_SAFE_INTEGER,\n                    offset = Math.min(scrollPosition - eventStart, maxOffset - 2);\n                style.transform = offset > 0 ? `translateY(${offset}px)` : '';\n                meta.stuck = true;\n            }\n            else {\n                style.transform = '';\n                meta.stuck = false;\n            }\n            if (contentEl) {\n                this.toUpdate.add({\n                    contentEl,\n                    style\n                });\n            }\n        }\n        else if (contentEl && meta.stuck) {\n            style.transform = '';\n            meta.stuck = false;\n            this.toUpdate.add({\n                contentEl,\n                style\n            });\n        }\n    }\n    // Only measure the margins of an event's contentEl once\n    getEventContentMargins(contentEl) {\n        if (contentEl?.classList.contains('b-sch-event-content')) {\n            return DomHelper.getEdgeSize(contentEl, 'margin');\n        }\n        return zeroMargins;\n    }\n    //endregion\n    doDisable() {\n        super.doDisable(...arguments);\n        if (!this.isConfiguring) {\n            this.client.refreshWithTransition();\n        }\n    }\n}\nStickyEvents._$name = 'StickyEvents'; GridFeatureManager.registerFeature(StickyEvents, true, 'Scheduler');\nGridFeatureManager.registerFeature(StickyEvents, false, 'ResourceHistogram');\n", "import AbstractTimeRanges from './AbstractTimeRanges.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport AttachToProjectMixin from '../data/mixin/AttachToProjectMixin.js';\nimport TimeSpan from '../model/TimeSpan.js';\n/**\n * @module Scheduler/feature/TimeRanges\n */\n/**\n * Feature that renders global ranges of time in the timeline. Use this feature to visualize a `range` like a 1 hr lunch\n * or some important point in time (a `line`, i.e. a range with 0 duration). This feature can also show a current time\n * indicator if you set {@link #config-showCurrentTimeLine} to true. To style the rendered elements, use the\n * {@link Scheduler.model.TimeSpan#field-cls cls} field of the `TimeSpan` class.\n *\n * {@inlineexample Scheduler/feature/TimeRanges.js}\n *\n * Each time range is represented by an instances of {@link Scheduler.model.TimeSpan}, held in a simple\n * {@link Core.data.Store}. The feature uses {@link Scheduler/model/ProjectModel#property-timeRangeStore} defined on the\n * project by default. The store's persisting/loading is handled by Crud Manager (if it's used by the component).\n *\n * Note that the feature uses virtualized rendering, only the currently visible ranges are available in the DOM.\n *\n * This feature is **disabled** by default.\n * For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * ## Showing an icon in the time range header\n *\n * You can use Font Awesome icons easily (or set any other icon using CSS) by using the {@link Scheduler.model.TimeSpan#field-iconCls}\n * field. The JSON data below will show a flag icon:\n *\n * ```json\n * {\n *     \"id\"        : 5,\n *     \"iconCls\"   : \"b-fa b-fa-flag\",\n *     \"name\"      : \"v5.0\",\n *     \"startDate\" : \"2019-02-07 15:45\"\n * },\n * ```\n *\n * ## Recurring time ranges\n *\n * The feature supports recurring ranges in case the provided store and models\n * have {@link Scheduler/data/mixin/RecurringTimeSpansMixin} and {@link Scheduler/model/mixin/RecurringTimeSpan}\n * mixins applied:\n *\n * ```javascript\n * // We want to use recurring time ranges so we make a special model extending standard TimeSpan model with\n * // RecurringTimeSpan which adds recurrence support\n * class MyTimeRange extends RecurringTimeSpan(TimeSpan) {}\n *\n * // Define a new store extending standard Store with RecurringTimeSpansMixin mixin to add recurrence support to the\n * // store. This store will contain time ranges.\n * class MyTimeRangeStore extends RecurringTimeSpansMixin(Store) {\n *     static get defaultConfig() {\n *         return {\n *             // use our new MyResourceTimeRange model\n *             modelClass : MyTimeRange\n *         };\n *     }\n * };\n *\n * // Instantiate store for timeRanges using our new classes\n * const timeRangeStore = new MyTimeRangeStore({\n *     data : [{\n *         id             : 1,\n *         resourceId     : 'r1',\n *         startDate      : '2019-01-01T11:00',\n *         endDate        : '2019-01-01T13:00',\n *         name           : 'Lunch',\n *         // this time range should repeat every day\n *         recurrenceRule : 'FREQ=DAILY'\n *     }]\n * });\n *\n * const scheduler = new Scheduler({\n *     ...\n *     features : {\n *         timeRanges : true\n *     },\n *\n *     crudManager : {\n *         // store for \"timeRanges\" feature\n *         timeRangeStore\n *     }\n * });\n * ```\n *\n * @extends Scheduler/feature/AbstractTimeRanges\n * @classtype timeRanges\n * @feature\n * @demo Scheduler/timeranges\n */\nexport default class TimeRanges extends AbstractTimeRanges.mixin(AttachToProjectMixin) {\n    //region Config\n    static get $name() {\n        return 'TimeRanges';\n    }\n    static get defaultConfig() {\n        return {\n            store : true\n        };\n    }\n    static configurable = {\n        /**\n         * Store that holds the time ranges (using the {@link Scheduler.model.TimeSpan} model or subclass thereof).\n         * A store will be automatically created if none is specified.\n         * @config {Core.data.Store|StoreConfig}\n         * @category Misc\n         */\n        store : {\n            modelClass : TimeSpan\n        },\n        /**\n         * The interval (as amount of ms) defining how frequently the current timeline will be updated\n         * @config {Number}\n         * @default\n         * @category Misc\n         */\n        currentTimeLineUpdateInterval : 10000,\n        /**\n         * The date format to show in the header for the current time line (when {@link #config-showCurrentTimeLine} is configured).\n         * See {@link Core.helper.DateHelper} for the possible formats to use.\n         * @config {String}\n         * @default\n         * @category Common\n         */\n        currentDateFormat : 'HH:mm',\n        /**\n         * Show a line indicating current time. Either `true` or `false` or a {@link Scheduler.model.TimeSpan}\n         * configuration object to apply to this special time range (allowing you to provide a custom text):\n         *\n         * ```javascript\n         * showCurrentTimeLine : {\n         *     name : 'Now'\n         * }\n         * ```\n         *\n         * The line carries the CSS class name `b-sch-current-time`, and this may be used to add custom styling to it.\n         *\n         * @prp {Boolean|TimeSpanConfig}\n         * @default\n         * @category Common\n         */\n        showCurrentTimeLine : false\n    };\n    //endregion\n    //region Init & destroy\n    doDestroy() {\n        this.storeDetacher?.();\n        super.doDestroy();\n    }\n    /**\n     * Returns the TimeRanges which occur within the client Scheduler's time axis.\n     * @property {Scheduler.model.TimeSpan[]}\n     */\n    get timeRanges() {\n        const me        = this;\n        if (!me._timeRanges) {\n            const { store } = me;\n            let { records } = store;\n            if (store.recurringEvents) {\n                const {\n                    startDate,\n                    endDate\n                } = me.client.timeAxis;\n                records = records.flatMap(timeSpan => {\n                    // Collect occurrences for the recurring events in the record set\n                    if (timeSpan.isRecurring) {\n                        return timeSpan.getOccurrencesForDateRange(startDate, endDate);\n                    }\n                    return timeSpan;\n                });\n            }\n            if (me.currentTimeLine) {\n                // Avoid polluting store records\n                if (!store.recurringEvents) {\n                    records = records.slice();\n                }\n                records.push(me.currentTimeLine);\n            }\n            me._timeRanges = records;\n        }\n        return me._timeRanges;\n    }\n    //endregion\n    //region Current time line\n    attachToProject(project) {\n        super.attachToProject(project);\n        const me = this;\n        me.projectTimeZoneChangeDetacher?.();\n        if (me.showCurrentTimeLine) {\n            // Update currentTimeLine immediately after a time zone change\n            me.projectTimeZoneChangeDetacher = me.client.project?.ion({ timeZoneChange : () => me.updateCurrentTimeLine() });\n            // Update currentTimeLine if its already created\n            if (me.currentTimeLine) {\n                me.updateCurrentTimeLine();\n            }\n        }\n    }\n    initCurrentTimeLine() {\n        const me = this;\n        if (me.currentTimeLine || !me.showCurrentTimeLine) {\n            return;\n        }\n        const data = typeof me.showCurrentTimeLine === 'object' ? me.showCurrentTimeLine : {};\n        me.currentTimeLine = me.store.modelClass.new({\n            id  : 'currentTime', \n            cls : 'b-sch-current-time'\n        }, data);\n        me.currentTimeInterval = me.setInterval(() => me.updateCurrentTimeLine(), me.currentTimeLineUpdateInterval);\n        me._timeRanges = null;\n        me.updateCurrentTimeLine();\n    }\n    updateCurrentTimeLine() {\n        const\n            me                  = this,\n            { currentTimeLine } = me;\n        currentTimeLine.timeZone = me.project?.timeZone;\n        currentTimeLine.setLocalDate('startDate', new Date());\n        currentTimeLine.endDate = currentTimeLine.startDate;\n        if (!currentTimeLine.originalData.name) {\n            currentTimeLine.name = DateHelper.format(currentTimeLine.startDate, me.currentDateFormat);\n        }\n        me.renderRanges();\n    }\n    hideCurrentTimeLine() {\n        const me = this;\n        if (!me.currentTimeLine) {\n            return;\n        }\n        me.clearInterval(me.currentTimeInterval);\n        me.currentTimeLine = null;\n        me.refresh();\n    }\n    updateShowCurrentTimeLine(show) {\n        if (show) {\n            this.initCurrentTimeLine();\n        }\n        else {\n            this.hideCurrentTimeLine();\n        }\n    }\n    //endregion\n    //region Menu items\n    /**\n     * Adds a menu item to show/hide current time line.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateTimeAxisHeaderMenu({ items }) {\n        items.currentTimeLine = {\n            weight   : 400,\n            text     : this.L('L{showCurrentTimeLine}'),\n            checked  : this.currentTimeLine,\n            onToggle : ({ checked }) => {\n                if (!this.showCurrentTimeLine) {\n                    this.showCurrentTimeLine = checked;\n                }\n                else {\n                    this.updateShowCurrentTimeLine(checked);\n                }\n            }\n        };\n    }\n    //endregion\n    //region Store\n    attachToStore(store) {\n        const me = this;\n        let renderRanges = false;\n        // if we had some store assigned before we need to detach it\n        if (me.storeDetacher) {\n            me.storeDetacher();\n            // then we'll need to render ranges provided by the new store\n            renderRanges = true;\n        }\n        me.storeDetacher = store.ion({\n            change  : 'onStoreChange',\n            refresh : 'onStoreChange',\n            thisObj : me\n        });\n        me._timeRanges = null;\n        // render ranges if needed\n        renderRanges && me.renderRanges();\n    }\n    /**\n     * Returns the {@link Core.data.Store store} used by this feature\n     * @property {Core.data.Store}\n     * @category Misc\n     */\n    get store() {\n        return this.client.project.timeRangeStore;\n    }\n    updateStore(store) {\n        const\n            me          = this,\n            { client }  = me,\n            { project } = client;\n        store = project.timeRangeStore;\n        me.attachToStore(store);\n        // timeRanges can be set on scheduler/gantt, for convenience. Should only be processed by the TimeRanges and not\n        // any subclasses\n        if (client.timeRanges && !client._timeRangesExposed) {\n            store.add(client.timeRanges);\n            delete client.timeRanges;\n        }\n    }\n    // Called by ProjectConsumer after a new store is assigned at runtime\n    attachToTimeRangeStore(store) {\n        this.store = store;\n    }\n    resolveTimeRangeRecord(el) {\n        const id = el.closest(this.baseSelector).dataset.id;\n        if (id === 'currentTime') {\n            return this.currentTimeLine;\n        }\n        return this.store.getById(id);\n    }\n    onStoreChange({ type, action }) {\n        const me = this;\n        // Force re-evaluating of which ranges to consider for render\n        me._timeRanges = null;\n        // https://github.com/bryntum/support/issues/1398 - checking also if scheduler is visible to change elements\n        if (me.disabled || !me.client.isVisible || me.isConfiguring || (type === 'refresh' && action !== 'batch')) {\n            return;\n        }\n        me.client.runWithTransition(() => me.renderRanges(), !me.client.refreshSuspended);\n    }\n    //endregion\n    //region Drag\n    onDragStart(event) {\n        const\n            me                = this,\n            { context }       = event,\n            record            = me.resolveTimeRangeRecord(context.element.closest(me.baseSelector)),\n            rangeBodyEl       = me.getBodyElementByRecord(record);\n        context.relatedElements = [rangeBodyEl];\n        Object.assign(context, {\n            record,\n            rangeBodyEl,\n            originRangeX : DomHelper.getTranslateX(rangeBodyEl),\n            originRangeY : DomHelper.getTranslateY(rangeBodyEl)\n        });\n        super.onDragStart(event);\n        me.showTip(context);\n    }\n    onDrop(event) {\n        const { context } = event;\n        if (!context.valid) {\n            return this.onInvalidDrop({ context });\n        }\n        const\n            me          = this,\n            { client }  = me,\n            { record }  = context,\n            box         = Rectangle.from(context.rangeBodyEl),\n            newStart    = client.getDateFromCoordinate(box.getStart(client.rtl, client.isHorizontal), 'round', false),\n            wasModified = (record.startDate - newStart !== 0);\n        if (wasModified) {\n            record.setStartDate(newStart);\n        }\n        else {\n            me.drag.abort();\n        }\n        me.destroyTip();\n        super.onDrop(event);\n    }\n    //endregion\n    //region Resize\n    onResizeStart({ context }) {\n        const\n            me          = this,\n            record      = me.resolveTimeRangeRecord(context.element.closest(me.baseSelector)),\n            rangeBodyEl = me.getBodyElementByRecord(record);\n        Object.assign(context, {\n            record,\n            rangeBodyEl\n        });\n        me.showTip(context);\n        super.onResizeStart(...arguments);\n    }\n    onResizeDrag({ context }) {\n        const\n            me              = this,\n            { rangeBodyEl } = context,\n            { client }      = me,\n            box             = Rectangle.from(context.element),\n            startPos        = box.getStart(client.rtl, client.isHorizontal),\n            endPos          = box.getEnd(client.rtl, client.isHorizontal),\n            startDate       = client.getDateFromCoordinate(startPos, 'round', false),\n            endDate         = client.getDateFromCoordinate(endPos, 'round', false);\n        if (me.client.isVertical) {\n            if (context.edge === 'top') {\n                DomHelper.setTranslateY(rangeBodyEl, context.newY);\n            }\n            rangeBodyEl.style.height = context.newHeight + 'px';\n        }\n        else {\n            if (context.edge === 'left') {\n                DomHelper.setTranslateX(rangeBodyEl, context.newX);\n            }\n            rangeBodyEl.style.width = context.newWidth + 'px';\n        }\n        me.updateDateIndicator({ startDate, endDate });\n    }\n    onResize({ context }) {\n        if (!context.valid) {\n            return this.onInvalidDrop({ context });\n        }\n        const\n            me          = this,\n            { client }  = me,\n            { rtl }     = client,\n            record      = context.record,\n            box         = Rectangle.from(context.element),\n            startPos    = box.getStart(rtl, client.isHorizontal),\n            endPos      = box.getEnd(rtl, client.isHorizontal),\n            newStart    = client.getDateFromCoordinate(startPos, 'round', false),\n            isStart     = (rtl && context.edge === 'right') || (!rtl && context.edge === 'left') || context.edge === 'top',\n            newEnd      = client.getDateFromCoordinate(endPos, 'round', false),\n            wasModified = (isStart && record.startDate - newStart !== 0) ||\n                (newEnd && record.endDate - newEnd !== 0);\n        if (wasModified && newEnd > newStart) {\n            if (isStart) {\n                // could be that the drag operation placed the range with start/end outside the axis\n                record.setStartDate(newStart, false);\n            }\n            else {\n                record.setEndDate(newEnd, false);\n            }\n        }\n        else {\n            me.onInvalidResize({ context });\n        }\n        me.destroyTip();\n    }\n    onInvalidResize({ context }) {\n        const me = this;\n        me.resize.reset();\n        // Allow DomSync to reapply original state\n        context.rangeBodyEl.parentElement.lastDomConfig = context.rangeBodyEl.lastDomConfig = context.element.lastDomConfig = null;\n        me.renderRanges();\n        me.destroyTip();\n    }\n    //endregion\n}\nTimeRanges._$name = 'TimeRanges'; GridFeatureManager.registerFeature(TimeRanges, false, ['TimelineBase']);\n", "import Base from '../../../Core/Base.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\n/**\n * @module Scheduler/view/mixin/DelayedRecordsRendering\n */\n/**\n * Mixin that implements scheduling/unscheduling a delayed row refresh.\n * @mixin\n * @internal\n */\nexport default Target => class DelayedRecordsRendering extends (Target || Base) {\n    static $name = 'DelayedRecordsRendering';\n    static configurable = {\n        scheduledRecordsRefreshTimeout : 10\n    };\n    static get properties() {\n        return {\n            recordsToRefresh : new Set()\n        };\n    }\n    beforeRenderRow({ record }) {\n        // unscheduler records refresh when corresponding rows are rendered\n        if (this.recordIsReadyForRendering?.(record)) {\n            this.unscheduleRecordRefresh(record);\n        }\n        return super.beforeRenderRow(...arguments);\n    }\n    cleanupScheduledRecord() {\n        const { rowManager, store } = this;\n        for (const record of [...this.recordsToRefresh]) {\n            // Remove the record from to-refresh list if:\n            // - it's not in the view store\n            // - or it's not visible\n            if (!record.stores.includes(store) || !rowManager.getRowById(record)) {\n                this.recordsToRefresh.delete(record);\n            }\n        }\n    }\n    renderScheduledRecords() {\n        const me = this;\n        if (!me.refreshSuspended) {\n            // remove invisible records from the set of scheduled\n            me.cleanupScheduledRecord();\n            const\n                { rowManager } = me,\n                records        = [...me.recordsToRefresh],\n                rows           = records.map(record => rowManager.getRowById(record));\n            if (rows.length) {\n                rowManager.renderRows(rows);\n                /**\n                 * This event fires when records which rendering\n                 * was previously scheduled is finally done.\n                 * @event scheduledRecordsRender\n                 * @param {Grid.view.Grid} source The component.\n                 * @param {Core.data.Model[]} records Rendered records.\n                 * @param {Grid.row.Row[]} rows Rendered rows.\n                 */\n                me.trigger('scheduledRecordsRender', { records, rows });\n            }\n            if (me.recordsToRefresh.size) {\n                me.scheduleRecordRefresh();\n            }\n        }\n        // reschedule this call if view refresh is suspended\n        else {\n            me.scheduleRecordRefresh();\n        }\n    }\n    /**\n     * Cancels scheduled rows refresh.\n     * @param {Core.data.Model|Core.data.Model[]|Boolean} [clearRecords=true] `true` to also clear the list of records\n     * scheduled for refreshing. `false` will result only canceling the scheduled call and keeping intact\n     * the list of records planned for refreshing.\n     */\n    unscheduleRecordRefresh(clearRecords = true) {\n        const me = this;\n        if (clearRecords === true) {\n            me.recordsToRefresh.clear();\n        }\n        else if (clearRecords) {\n            ArrayHelper.asArray(clearRecords).forEach(record => me.recordsToRefresh.delete(record));\n        }\n        if (me.scheduledRecordsRefreshTimer && !me.recordsToRefresh.size) {\n            me.clearTimeout(me.scheduledRecordsRefreshTimer);\n        }\n    }\n    /**\n     * Schedules the provided record row refresh.\n     * @param {Core.data.Model} records Record to refresh the row of.\n     */\n    scheduleRecordRefresh(records) {\n        const me = this;\n        if (records) {\n            ArrayHelper.asArray(records).forEach(record => me.recordsToRefresh.add(record));\n        }\n        me.scheduledRecordsRefreshTimer = me.setTimeout({\n            fn                : 'renderScheduledRecords',\n            delay             : me.scheduledRecordsRefreshTimeout,\n            cancelOutstanding : true\n        });\n    }\n    get widgetClass() {}\n};\n", "import Base from '../../Core/Base.js';\nexport default class TimelineHistogramRendering extends Base {\n    static configurable = {\n        scrollBuffer : 0\n    };\n    construct(client) {\n        super.construct();\n        this.client = client;\n    }\n    init() {}\n    onTimeAxisViewModelUpdate() {\n        const { scrollable } = this.client.timeAxisSubGrid;\n        // scrollLeft is the DOM's concept which is -ve in RTL mode.\n        // scrollX i always the +ve scroll offset from the origin.\n        // Both may be needed for different calculations.\n        this.updateFromHorizontalScroll(scrollable.x);\n    }\n    // Update header range on horizontal scroll\n    updateFromHorizontalScroll(scrollX) {\n        const\n            me            = this,\n            {\n                client,\n                // scrollBuffer is an export only thing\n                scrollBuffer\n            } = me,\n            {\n                timeAxisSubGrid,\n                timeAxis,\n                rtl\n            }             = client,\n            { width }     = timeAxisSubGrid,\n            { totalSize } = client.timeAxisViewModel,\n            start         = scrollX,\n            // If there are few pixels left from the right most position then just render all remaining ticks,\n            // there wouldn't be many. It makes end date reachable with more page zoom levels while not having any poor\n            // implications.\n            // 5px to make TimeViewRangePageZoom test stable in puppeteer.\n            returnEnd     = timeAxisSubGrid.scrollable.maxX !== 0 && Math.abs(timeAxisSubGrid.scrollable.maxX) <= Math.round(start) + 5,\n            startDate     = client.getDateFromCoord({ coord : Math.max(0, start - scrollBuffer), ignoreRTL : true }),\n            endDate       = returnEnd ? timeAxis.endDate : (client.getDateFromCoord({ coord : start + width + scrollBuffer, ignoreRTL : true }) || timeAxis.endDate);\n        if (startDate && !client._viewPresetChanging) {\n            me._visibleDateRange = { startDate, endDate, startMS : startDate.getTime(), endMS : endDate.getTime() };\n            me.viewportCoords  = rtl\n                // RTL starts all the way to the right (and goes in opposite direction)\n                ? { left : totalSize - scrollX - width + scrollBuffer, right : totalSize - scrollX - scrollBuffer }\n                // LTR all the way to the left\n                : { left : scrollX - scrollBuffer, right : scrollX + width + scrollBuffer };\n            // Update timeaxis header making it display the new dates\n            const range = client.timeView.range = { startDate, endDate };\n            client.internalOnVisibleDateRangeChange(range);\n            // If refresh is suspended, someone else is responsible for updating the UI later\n            if (!client.refreshSuspended && client.rowManager.rows.length) {\n                // Gets here too early in Safari for ResourceHistogram. ResizeObserver triggers a scroll before rows are\n                // rendered first time. Could not track down why, bailing out\n                if (client.rowManager.rows[0].id === null) {\n                    return;\n                }\n                // re-render all rows is timeAxis range has been updated\n                if (me._timeAxisStartDate - timeAxis.startDate || me._timeAxisEndDate - timeAxis.endDate) {\n                    me._timeAxisStartDate = timeAxis.startDate;\n                    me._timeAxisEndDate = timeAxis.endDate;\n                    client.rowManager.renderRows(client.rowManager.rows);\n                }\n            }\n        }\n    }\n    onViewportResize() {}\n    refreshRows() {}\n    get visibleDateRange() {\n        return this._visibleDateRange;\n    }\n    translateToPageCoordinate(x) {\n        const\n            { client } = this,\n            { scrollable } = client.timeAxisSubGrid;\n        let result = x + client.timeAxisSubGridElement.getBoundingClientRect().left;\n        if (client.rtl) {\n            result -= scrollable.maxX - Math.abs(client.scrollLeft);\n        }\n        else {\n            result -= client.scrollLeft;\n        }\n        return result;\n    }\n    translateToScheduleCoordinate(x) {\n        const\n            { client } = this,\n            { scrollable } = client.timeAxisSubGrid;\n        let result = x - client.timeAxisSubGridElement.getBoundingClientRect().left - globalThis.scrollX;\n        // Because we use getBoundingClientRect's left, we have to adjust for page scroll.\n        if (client.rtl) {\n            result += scrollable.maxX - Math.abs(client.scrollLeft);\n        }\n        else {\n            result += client.scrollLeft;\n        }\n        return result;\n    }\n    getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {\n        const { client } = this;\n        let coord = xy[0];\n        if (!local) {\n            coord = this.translateToScheduleCoordinate(coord);\n        }\n        coord = client.getRtlX(coord);\n        return client.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);\n    }\n}\nTimelineHistogramRendering._$name = 'TimelineHistogramRendering';", "import Objects from '../../Core/helper/util/Objects.js';\nimport Histogram from '../../Core/widget/graph/Histogram.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport '../../Grid/column/TreeColumn.js';\nimport '../../Grid/feature/Tree.js';\nimport '../column/TimeAxisColumn.js';\nimport '../feature/ColumnLines.js';\nimport DelayedRecordsRendering from './mixin/DelayedRecordsRendering.js';\nimport TimelineBase from './TimelineBase.js';\nimport TimelineHistogramRendering from './TimelineHistogramRendering.js';\n/**\n * @module Scheduler/view/TimelineHistogramBase\n */\nconst\n    histogramWidgetCleanState = {\n        series   : null,\n        topValue : null\n    },\n    emptyFn = () => {};\n/**\n * Histogram renderer parameters.\n *\n * @typedef {Object} HistogramRenderData\n * @property {Object} histogramData Histogram data\n * @property {HistogramConfig} histogramConfig Configuration object for the histogram widget\n * @property {HTMLElement|null} cellElement Cell element, for adding CSS classes, styling etc.\n *        Can be `null` in case of export\n * @property {Core.data.Model} record Record for the row\n * @property {Grid.column.Column} column This column\n * @property {Grid.view.Grid} grid This grid\n * @property {Grid.row.Row} row Row object. Can be null in case of export. Use the\n * {@link Grid.row.Row#function-assignCls row's API} to manipulate CSS class names.\n */\n/**\n * Base class for {@link Scheduler/view/TimelineHistogram} class.\n *\n * @extends Scheduler/view/TimelineBase\n * @abstract\n */\nexport default class TimelineHistogramBase extends TimelineBase.mixin(DelayedRecordsRendering) {\n    //region Config\n    static $name = 'TimelineHistogramBase';\n    static type = 'timelinehistogrambase';\n    static configurable = {\n        timeAxisColumnCellCls : 'b-sch-timeaxis-cell b-timelinehistogram-cell',\n        mode : 'horizontal',\n        rowHeight : 50,\n        /**\n         * Set to `true` if you want to display a tooltip when hovering an allocation bar. You can also pass a\n         * {@link Core/widget/Tooltip#configs} config object.\n         * Please use {@link #config-barTooltipTemplate} function to customize the tooltip contents.\n         * @prp {Boolean|TooltipConfig}\n         */\n        showBarTip : false,\n        barTooltip : null,\n        barTooltipClass : Tooltip,\n        /**\n         * Object enumerating data series for the histogram.\n         * The object keys are treated as the series identifiers and values are objects that\n         * must contain two properties:\n         *  - `type` A String, either `'bar'` or `'outline'`\n         *  - `field` A String, the name of the property to use from the data objects in the {@link #config-data} option.\n         *\n         * ```javascript\n         * histogram = new TimelineHistogram({\n         *     ...\n         *     series : {\n         *         s1 : {\n         *             type  : 'bar',\n         *             field : 's1'\n         *         },\n         *         s2 : {\n         *             type  : 'outline',\n         *             field : 's2'\n         *         }\n         *     },\n         *     store : new Store({\n         *         data : [\n         *             {\n         *                 id            : 'r1',\n         *                 name          : 'Record 1',\n         *                 histogramData : [\n         *                     { s1 : 200, s2 : 100 },\n         *                     { s1 : 150, s2 : 50 },\n         *                     { s1 : 175, s2 : 50 },\n         *                     { s1 : 175, s2 : 75 }\n         *                 ]\n         *             },\n         *             {\n         *                 id            : 'r2',\n         *                 name          : 'Record 2',\n         *                 histogramData : [\n         *                     { s1 : 100, s2 : 100 },\n         *                     { s1 : 150, s2 : 125 },\n         *                     { s1 : 175, s2 : 150 },\n         *                     { s1 : 175, s2 : 75 }\n         *                 ]\n         *             }\n         *         ]\n         *     })\n         * });\n         * ```\n         *\n         * @config {Object<String, HistogramSeries>}\n         */\n        series : null,\n        /**\n         * Record field from which the histogram data will be collected.\n         *\n         * ```javascript\n         * histogram = new TimelineHistogram({\n         *     ...\n         *     series : {\n         *         s1 : {\n         *             type : 'bar'\n         *         }\n         *     },\n         *     dataModelField : 'foo',\n         *     store : new Store({\n         *         data : [\n         *             {\n         *                 id   : 'r1',\n         *                 name : 'Record 1',\n         *                 foo  : [\n         *                     { s1 : 200 },\n         *                     { s1 : 150 },\n         *                     { s1 : 175 },\n         *                     { s1 : 175 }\n         *                 ]\n         *             },\n         *             {\n         *                 id   : 'r2',\n         *                 name : 'Record 2',\n         *                 foo  : [\n         *                     { s1 : 100 },\n         *                     { s1 : 150 },\n         *                     { s1 : 175 },\n         *                     { s1 : 175 }\n         *                 ]\n         *             }\n         *         ]\n         *     })\n         * });\n         * ```\n         *\n         * Alternatively {@link #config-getRecordData} function can be used to build a\n         * record's histogram data dynamically.\n         * @config {String}\n         * @default\n         */\n        dataModelField : 'histogramData',\n        /**\n         * A function, or name of a function which builds histogram data for the provided record.\n         *\n         * See also {@link #config-dataModelField} allowing to load histogram data from a record field.\n         *\n         * @config {Function|String} getRecordData\n         * @param {Core.data.Model} getRecordData.record Record to get histogram data for.\n         * @param {Object} [aggregationContext] Context object passed in case the data is being retrieved\n         * as a part of some parent record data collecting.\n         * @returns {Object} Histogram data.\n         */\n        getRecordData : null,\n        /**\n         * When set to `true` (default) the component reacts on time axis changes\n         * (zooming or changing the displayed time span), clears the histogram data cache of the records\n         * and then refreshes the view.\n         * @config {Boolean}\n         * @default\n         */\n        hardRefreshOnTimeAxisReconfigure : true,\n        /**\n         * A Function which returns a CSS class name to add to a rectangle element.\n         * The following parameters are passed:\n         * @param {HistogramSeries} series The series being rendered\n         * @param {DomConfig} rectConfig The rectangle configuration object\n         * @param {Object} datum The datum being rendered\n         * @param {Number} index The index of the datum being rendered\n         * @param {HistogramRenderData} renderData Current render data giving access to the record, row and cell\n         * being rendered.\n         * @returns {String} CSS classes of the rectangle element\n         * @config {Function}\n         */\n        getRectClass : null,\n        /**\n         * A Function which returns a CSS class name to add to a path element\n         * built for an `outline` type series.\n         * The following parameters are passed:\n         * @param {HistogramSeries} series The series being rendered\n         * @param {Object[]} data The series data\n         * @param {HistogramRenderData} renderData Current render data giving access to the record, row and cell\n         * being rendered.\n         * @returns {String} CSS class name of the path element\n         * @config {Function}\n         */\n        getOutlineClass(series) {\n            return '';\n        },\n        readOnly : true,\n        /**\n         * A Function which returns the tooltip text to display when hovering a bar.\n         * The following parameters are passed:\n         * @param {HistogramSeries} series The series being rendered\n         * @param {DomConfig} rectConfig The rectangle configuration object\n         * @param {Object} datum The datum being rendered\n         * @param {Number} index The index of the datum being rendered\n         * @deprecated Since 5.0.0. Please use {@link #config-barTooltipTemplate}\n         * @config {Function}\n         */\n        getBarTip : null,\n        /**\n         * A Function which returns the tooltip text to display when hovering a bar.\n         * The following parameters are passed:\n         * @param {Object} context The tooltip context info\n         * @param {Object} context.datum The histogram bar being hovered info\n         * @param {Core.widget.Tooltip} context.tip The tooltip instance\n         * @param {HTMLElement} context.element The Element for which the Tooltip is monitoring mouse movement\n         * @param {HTMLElement} context.activeTarget The target element that triggered the show\n         * @param {Event} context.event The raw DOM event\n         * @param {Core.data.Model} data.record The record which value\n         * the hovered bar displays.\n         * @returns {String} Tooltip HTML content\n         * @config {Function}\n         */\n        barTooltipTemplate : null,\n        /**\n         * A Function which returns the text to render inside a bar.\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     series : {\n         *         foo : {\n         *             type  : 'bar',\n         *             field : 'foo'\n         *         }\n         *     },\n         *     getBarText(datum) {\n         *         // display the value in the bar\n         *         return datum.foo;\n         *     },\n         *     ...\n         * })\n         * ```\n         *\n         * **Please note** that the function will be injected into the underlying\n         * {@link Core/widget/graph/Histogram} component that is used under the hood\n         * to render actual charts.\n         * So `this` will refer to the {@link Core/widget/graph/Histogram} instance, not\n         * this class instance.\n         * To access the view please use `this.owner` in the function:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     getBarText(datum) {\n         *         // \"this\" in the method refers core Histogram instance\n         *         // get the view instance\n         *         const timelineHistogram = this.owner;\n         *\n         *         .....\n         *     },\n         *     ...\n         * })\n         * ```\n         * The following parameters are passed:\n         * @param {Object} datum The datum being rendered\n         * @param {Number} index The index of the datum being rendered\n         * @param {HistogramSeries} series The series (provided if histogram widget\n         * {@link Core/widget/graph/Histogram#config-singleTextForAllBars} is `false`)\n         * @param {HistogramRenderData} renderData Current render data giving access to the record, row and cell\n         * being rendered.\n         * @returns {String} Text to render inside the bar\n         * @config {Function}\n         */\n        getBarText : null,\n        getRectConfig : null,\n        getBarTextRenderData : undefined,\n        /**\n         * The class used for building the {@link #property-histogramWidget histogram widget}\n         * @config {Core.widget.graph.Histogram}\n         * @default\n         */\n        histogramWidgetClass : Histogram,\n        /**\n         * The underlying {@link Core/widget/graph/Histogram} component that is used under the hood\n         * to render actual charts.\n         * @member {Core.widget.graph.Histogram} histogramWidget\n         */\n        /**\n         * An instance or a configuration object of the underlying {@link Core/widget/graph/Histogram}\n         * component that is used under the hood to render actual charts.\n         * In case a configuration object is provided the built class is defined with\n         * {@link #config-histogramWidgetClass} config.\n         * @config {Core.widget.graph.Histogram|HistogramConfig}\n         */\n        histogramWidget : {\n            cls                : 'b-hide-offscreen b-timelinehistogram-histogram',\n            omitZeroHeightBars : true,\n            data               : []\n        },\n        fixedRowHeight : true\n    };\n    static get properties() {\n        return {\n            histogramDataByRecord : new Map(),\n            collectingDataFor     : new Map()\n        };\n    }\n    updateGetRecordData(fn) {\n        this._getRecordData = fn ? this.resolveCallback(fn) : null;\n    }\n    updateHardRefreshOnTimeAxisReconfigure(value) {\n        const name = 'hardRefreshOnTimeAxisReconfigure';\n        if (value) {\n            this.timeAxis.ion({\n                name,\n                endReconfigure : 'onTimeAxisEndReconfigure',\n                thisObj        : this\n            });\n        }\n        else {\n            this.detachListeners(name);\n        }\n    }\n    //endregion\n    //region Constructor/Destructor\n    construct(config) {\n        super.construct(config);\n        const me = this;\n        // debounce refreshRows calls\n        me.scheduleRefreshRows = me.createOnFrame(me.refreshRows, [], me, true);\n        me.rowManager.ion({\n            beforeRowHeight : 'onBeforeRowHeight',\n            thisObj         : me\n        });\n    }\n    onDestroy() {\n        this.clearHistogramDataCache();\n        this._histogramWidget?.destroy();\n        this.barTooltip = null;\n    }\n    //endregion\n    //region Internal\n    // Used by shared features to resolve an event or task\n    resolveTimeSpanRecord(element) {}\n    getScheduleMouseEventParams(cellData, event) {\n        const record = this.store.getById(cellData.id);\n        return { record };\n    }\n    get currentOrientation() {\n        if (!this._currentOrientation) {\n            this._currentOrientation = new TimelineHistogramRendering(this);\n        }\n        return this._currentOrientation;\n    }\n    updateSeries(value) {\n        const me = this;\n        me.histogramWidget.series = value;\n        me._series = me.histogramWidget.series;\n        if (me.isPainted && !me.isConfiguring) {\n            me.scheduleRefreshRows();\n        }\n    }\n    getAsyncEventSuffixForStore(store) {\n        // Use xxPreCommit version of events if the store is a part of a project\n        return store.isAbstractPartOfProjectStoreMixin ? 'PreCommit' : '';\n    }\n    /**\n     * Schedules the component rows refresh on the next animation frame. However many time it is\n     * called in one event run, it will only be scheduled to run once.\n     */\n    scheduleRefreshRows() {}\n    getRowHeight() {\n        return this.rowHeight;\n    }\n    onInternalPaint({ firstPaint }) {\n        super.onInternalPaint({ firstPaint });\n        if (firstPaint && this.showBarTip) {\n            this.barTooltip = {};\n        }\n    }\n    updateGetBarTip(value) {\n        // reset barTooltipTemplate if custom getBarTip function is provided\n        if (value) {\n            this.barTooltipTemplate = null;\n        }\n        return value;\n    }\n    changeBarTooltip(tooltip, oldTooltip) {\n        oldTooltip?.destroy();\n        if (tooltip) {\n            return tooltip.isTooltip ? tooltip : this.barTooltipClass.new({\n                forElement  : this.timeAxisSubGridElement,\n                forSelector : '.b-histogram rect',\n                hoverDelay  : 0,\n                trackMouse  : false,\n                cls         : 'b-celltooltip-tip',\n                getHtml     : this.getTipHtml.bind(this)\n            }, this.showBarTip, tooltip);\n        }\n        return null;\n    }\n    async getTipHtml(args) {\n        if (this.showBarTip && this.barTooltipTemplate) {\n            const\n                { activeTarget } = args,\n                index            = parseInt(activeTarget.dataset.index, 10),\n                record           = this.getRecordFromElement(activeTarget),\n                histogramData    = await this.getRecordHistogramData(record);\n            return this.barTooltipTemplate({\n                ...args,\n                datum : this.extractHistogramDataArray(histogramData, record)[index],\n                record,\n                index\n            });\n        }\n    }\n    collectTicksWidth() {\n        const\n            { ticks }     = this.timeAxis,\n            prevDuration  = ticks[0].endDate - ticks[0].startDate,\n            tickDurations = { 0 : prevDuration };\n        let\n            totalDuration = prevDuration,\n            isMonotonous  = true;\n        for (let i = 1, { length } = ticks; i < length; i++) {\n            const\n                tick   = ticks[i],\n                duration = tick.endDate - tick.startDate;\n            // the ticks width is different -> reset isMonotonous flag\n            if (prevDuration !== duration) {\n                isMonotonous = false;\n            }\n            totalDuration    += duration;\n            tickDurations[i] = duration;\n        }\n        // if the ticks widths are not monotonous we need to calculate\n        // each bar width to provide it to the histogram widget later\n        if (!isMonotonous) {\n            const ticksWidth = {};\n            for (let i = 0, { length } = ticks; i < length; i++) {\n                ticksWidth[i] = tickDurations[i] / totalDuration;\n            }\n            this.ticksWidth = ticksWidth;\n        }\n        else {\n            this.ticksWidth = null;\n        }\n    }\n    changeHistogramWidget(widget) {\n        const me = this;\n        if (widget && !widget.isHistogram) {\n            if (me.getBarTextRenderData && !widget.getBarTextRenderData) {\n                widget.getBarTextRenderData = me.getBarTextRenderData;\n            }\n            widget = me.histogramWidgetClass.new({\n                owner           : me,\n                appendTo        : me.element,\n                height          : me.rowHeight,\n                width           : me.timeAxisColumn?.width || 0,\n                getBarTip       : !me.barTooltipTemplate && me.getBarTip || emptyFn,\n                getRectClass    : me.getRectClass || me.getRectClassDefault,\n                getBarText      : me.getBarText || me.getBarTextDefault,\n                getOutlineClass : me.getOutlineClass,\n                getRectConfig   : me.getRectConfig\n            }, widget);\n            widget.suspendRefresh();\n            // bind default getBarText in case it will be called from a custom getBarText()\n            me.getBarTextDefault = me.getBarTextDefault.bind(widget);\n        }\n        return widget;\n    }\n    // Injectable method.\n    getRectClassDefault(series, rectConfig, datum) {}\n    getBarTextDefault(datum, index) {}\n    updateShowBarTip(value) {\n        this.barTooltip = value;\n    }\n    //endregion\n    //region Columns\n    get columns() {\n        return super.columns;\n    }\n    set columns(columns) {\n        const me = this;\n        super.columns = columns;\n        if (!me.isDestroying) {\n            me.timeAxisColumn.renderer = me.histogramRenderer.bind(me);\n            me.timeAxisColumn.cellCls = me.timeAxisColumnCellCls;\n        }\n    }\n    //endregion\n    //region Events\n    onHistogramDataCacheSet({ record, data }) {\n        // schedule record refresh for later\n        this.scheduleRecordRefresh(record);\n    }\n    onTimeAxisEndReconfigure() {\n        if (this.hardRefreshOnTimeAxisReconfigure) {\n            // reset histogram cache\n            this.clearHistogramDataCache();\n            // schedule records refresh (that will re-fetch the histogram data from the server since the cache is empty)\n            this.scheduleRefreshRows();\n        }\n    }\n    onStoreUpdateRecord({ record, changes }) {\n        const me = this;\n        // If we read histogram data from a field and that field got changed\n        // - clear the corresponding record cache\n        if (!me.getRecordData && me.dataModelField && changes[me.dataModelField]) {\n            me.clearHistogramDataCache(record);\n        }\n        return super.onStoreUpdateRecord(...arguments);\n    }\n    onStoreRemove({ records }) {\n        super.onStoreRemove(...arguments);\n        for (const record of records) {\n            this.clearHistogramDataCache(record);\n        }\n    }\n    onBeforeRowHeight({ height }) {\n        if (this._timeAxisColumn) {\n            const widget = this._histogramWidget;\n            if (widget) {\n                widget.height = height;\n                widget.onElementResize(widget.element);\n            }\n        }\n    }\n    onTimeAxisViewModelUpdate() {\n        super.onTimeAxisViewModelUpdate(...arguments);\n        const widget = this._histogramWidget;\n        if (widget) {\n            widget.width = this.timeAxisViewModel.totalSize;\n            widget.onElementResize(widget.element);\n        }\n        this.collectTicksWidth();\n    }\n    //endregion\n    //region Data processing\n    extractHistogramDataArray(histogramData, record) {\n        return histogramData;\n    }\n    processRecordRenderData(renderData) {\n        return renderData;\n    }\n    /**\n     * Clears the histogram data cache for the provided record (if provided).\n     * If the record is not provided clears the cache for all records.\n     * @param {Core.data.Model} [record] Record to clear the cache for.\n     */\n    clearHistogramDataCache(record) {\n        if (record) {\n            this.histogramDataByRecord.delete(record);\n        }\n        else {\n            this.histogramDataByRecord.clear();\n        }\n    }\n    /**\n     * Caches the provided histogram data for the given record.\n     * @param {Core.data.Model} record Record to cache data for.\n     * @param {Object} data Histogram data to cache.\n     */\n    setHistogramDataCache(record, data) {\n        const eventData = { record, data };\n        /**\n         * Fires before the component stores a record's histogram data into the cache.\n         *\n         * A listener can be used to transform the collected data dynamically before\n         * it's cached:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     series : {\n         *         foo : {\n         *             type  : 'bar',\n         *             field : 'f1'\n         *         }\n         *     },\n         *     ...\n         *     listeners : {\n         *         beforeHistogramDataCacheSet(eventData) {\n         *             // completely replace the data for a specific record\n         *             if (eventData.record.id === 123) {\n         *                 eventData.data = [\n         *                     { f1 : 10 },\n         *                     { f1 : 20 },\n         *                     { f1 : 30 },\n         *                     { f1 : 40 },\n         *                     { f1 : 50 },\n         *                     { f1 : 60 }\n         *                 ];\n         *             }\n         *         }\n         *     }\n         * })\n         * ```\n         *\n         * @param {Scheduler.view.TimelineHistogram} source The component instance\n         * @param {Core.data.Model} record Record the histogram data of which is ready.\n         * @param {Object} data The record histogram data.\n         * @event beforeHistogramDataCacheSet\n         */\n        this.trigger('beforeHistogramDataCacheSet', eventData);\n        this.histogramDataByRecord.set(eventData.record, eventData.data);\n        /**\n         * Fires after the component retrieves a record's histogram data and stores\n         * it into the cache.\n         *\n         * Unlike similar {@link #event-beforeHistogramDataCacheSet} event this event is triggered\n         * after the data is put into the cache.\n         *\n         * A listener can be used to transform the collected data dynamically:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     series : {\n         *         bar : {\n         *             type : 'bar',\n         *             field : 'bar'\n         *         },\n         *         halfOfBar : {\n         *             type  : 'outline',\n         *             field : 'half'\n         *         }\n         *     },\n         *     ...\n         *     listeners : {\n         *         histogramDataCacheSet({ data }) {\n         *             // add extra entries to collected data\n         *             data.forEach(entry => {\n         *                 entry.half = entry.bar / 2;\n         *             });\n         *         }\n         *     }\n         * })\n         * ```\n         *\n         * @param {Scheduler.view.TimelineHistogram} source The component instance\n         * @param {Core.data.Model} record Record the histogram data of which is ready.\n         * @param {Object} data The record histogram data.\n         * @event histogramDataCacheSet\n         */\n        this.trigger('histogramDataCacheSet', eventData);\n    }\n    /**\n     * Returns entire histogram data cache if no record provided,\n     * or cached data for the provided record.\n     * @param {Core.data.Model} [record] Record to get the cached data for.\n     * @returns {Object} The provided record cached data or all the records data cache\n     * as a `Map` keyed by records.\n     */\n    getHistogramDataCache(record) {\n        return record ? this.histogramDataByRecord.get(record) : this.histogramDataByRecord;\n    }\n    /**\n     * Returns `true` if there is cached histogram data for the provided record.\n     * @param {Core.data.Model} record Record to check the cache existence for.\n     * @returns {Boolean} `True` if there is a cache for provided record.\n     */\n    hasHistogramDataCache(record) {\n        return this.histogramDataByRecord.has(record);\n    }\n    finalizeDataRetrievingInternal(record, data) {\n        // cleanup collectingDataFor map on data collecting completion\n        this.collectingDataFor.delete(record);\n        // cache record data\n        this.setHistogramDataCache(record, data);\n        // pass data through\n        return data;\n    }\n    finalizeDataRetrieving(record, data) {\n        if (Objects.isPromise(data)) {\n            this.collectingDataFor.set(record, data);\n            return data.then(data => this.finalizeDataRetrievingInternal(record, data));\n        }\n        return this.finalizeDataRetrievingInternal(record, data);\n    }\n    /**\n     * Retrieves the histogram data for the provided record.\n     *\n     * The method first checks if there is cached data for the record and returns it if found.\n     * Otherwise it starts collecting data by calling {@link #config-getRecordData} (if provided)\n     * or by reading it from {@link #config-dataModelField} record field.\n     *\n     * The method can be asynchronous depending on the provided {@link #config-getRecordData} function.\n     * If the function returns a `Promise` then the method will return a wrapping `Promise` in turn that will\n     * resolve with the collected histogram data.\n     *\n     * The method triggers {@link #event-histogramDataCacheSet} event when a record data is ready.\n     *\n     * @param {Core.data.Model} record Record to retrieve the histogram data for.\n     * @returns {Object|Promise} The histogram data for the provided record or a `Promise` that will provide the data\n     * when resolved.\n     */\n    getRecordHistogramData(record) {\n        const\n            me     = this,\n            { getRecordData } = me;\n        let result = me.collectingDataFor.get(record) || me.getHistogramDataCache(record);\n        if (!result && !me.hasHistogramDataCache(record)) {\n            // use \"getRecordData\" function if provided\n            if (getRecordData) {\n                result = getRecordData.handler.call(getRecordData.thisObj, ...arguments);\n            }\n            // or read data from the configured model field\n            else {\n                result = record.get(me.dataModelField);\n            }\n            result = me.finalizeDataRetrieving(record, result);\n        }\n        return result;\n    }\n    recordIsReadyForRendering(record) {\n        return !this.collectingDataFor.has(record);\n    }\n    //endregion\n    //region Render\n    beforeRenderRow(eventData) {\n        const\n            me = this,\n            histogramData = me.getRecordHistogramData(eventData.record);\n        if (!Objects.isPromise(histogramData)) {\n            const data = histogramData ? me.extractHistogramDataArray(histogramData, eventData.record) : [];\n            // bail out if no data\n            if (!data) {\n                return;\n            }\n            // if ticks widths are not monotonous\n            // we provide widths for each bar since in that case the histogram widget\n            // won't be able to calculate them properly\n            if (me.ticksWidth) {\n                for (let i = 0, { length } = data; i < length; i++) {\n                    data[i].width = me.ticksWidth[i];\n                }\n            }\n            const histogramConfig = Objects.merge(\n                // reset topValue by default to enable its auto-detection\n                { topValue : null },\n                me.initialConfig.histogramWidget,\n                {\n                    data,\n                    series : { ...me.series }\n                });\n            eventData = {\n                ...eventData,\n                histogramConfig,\n                histogramData,\n                histogramWidget : me.histogramWidget\n            };\n            /**\n             * Fires before the component renders a row.\n             *\n             * This event is recommended to use instead of generic {@link #event-beforeRenderRow} event since\n             * the component bails out of rendering rows for which histogram data is not ready yet\n             * (happens in case of async data collecting). The generic {@link #event-beforeRenderRow}\n             * is triggered in such cases too while this event is triggered only when the data is ready and the\n             * row is actually about to be rendered.\n             *\n             * Use a listener to adjust histograms rendering dynamically for individual rows:\n             *\n             * ```javascript\n             * new TimelineHistogram({\n             *     ...\n             *     listeners : {\n             *         beforeRenderHistogramRow({ record, histogramConfig }) {\n             *             // display an extra line for some specific record\n             *             if (record.id == 111) {\n             *                 histogramConfig.series.extraLine = {\n             *                     type  : 'outline',\n             *                     field : 'foo'\n             *                 };\n             *             }\n             *         }\n             *     }\n             * })\n             * ```\n             *\n             * @param {Scheduler.view.TimelineHistogram} source The component instance\n             * @param {Core.data.Model} record Record the histogram data of which is ready.\n             * @param {HistogramConfig} histogramConfig Configuration object that will be applied to `histogramWidget`.\n             * @param {Core.widget.graph.Histogram} histogramWidget The underlying widget that is used to render a chart.\n             * @event beforeRenderHistogramRow\n             */\n            me.trigger('beforeRenderHistogramRow', eventData);\n            // We are going to use eventData as stored renderData\n            // so sanitize it from unwanted properties\n            delete eventData.eventName;\n            delete eventData.source;\n            delete eventData.type;\n            delete eventData.oldId;\n            delete eventData.row;\n            delete eventData.recordIndex;\n            me._recordRenderData = me.processRecordRenderData(eventData);\n        }\n        super.beforeRenderRow(...arguments);\n    }\n    applyHistogramWidgetConfig(histogramWidget = this.histogramWidget, histogramConfig) {\n        // reset some parameters (topValue and series) to force recalculations\n        // and apply new configuration after\n        Object.assign(histogramWidget, histogramWidgetCleanState, histogramConfig);\n    }\n    /**\n     * Renders a histogram for a row.\n     * The method applies passed data to the underlying {@link #property-histogramWidget} component.\n     * Then the component renders charts and the method injects them into the corresponding column cell.\n     * @param {HistogramRenderData} renderData Render data\n     * @internal\n     */\n    renderRecordHistogram(renderData) {\n        const\n            me = this,\n            { histogramData, cellElement } = renderData;\n        // reset the cell for rows not having histogram data\n        if (!histogramData) {\n            cellElement.innerHTML = '';\n            return;\n        }\n        /**\n         * Fires before the component renders a histogram in a cell.\n         *\n         * @param {Scheduler.view.TimelineHistogram} source The component instance\n         * @param {Core.data.Model} record Record the histogram data of which is ready.\n         * @param {HistogramConfig} histogramConfig Configuration object that will be applied to `histogramWidget`.\n         * @param {Core.widget.graph.Histogram} histogramWidget The underlying widget that is used to render a chart.\n         * @event beforeRenderRecordHistogram\n         */\n        me.trigger('beforeRenderRecordHistogram', renderData);\n        // sanitize renderData from unwanted properties\n        delete renderData.eventName;\n        delete renderData.type;\n        delete renderData.source;\n        const histogramWidget = renderData.histogramWidget || me.histogramWidget;\n        me.applyHistogramWidgetConfig(histogramWidget, renderData.histogramConfig);\n        histogramWidget.refresh({\n            // tell histogram we want it to pass renderData as an extra argument in nested calls of getBarText and\n            // other configured hooks\n            args : [renderData]\n        });\n        const histogramCloneElement = histogramWidget.element.cloneNode(true);\n        histogramCloneElement.removeAttribute('id');\n        histogramCloneElement.classList.remove('b-hide-offscreen');\n        cellElement.innerHTML = '';\n        cellElement.appendChild(histogramCloneElement);\n    }\n    /**\n     * TimeAxis column renderer used by this view to render row histograms.\n     * It first calls {@link #function-getRecordHistogramData} method to retrieve\n     * the histogram data for the renderer record.\n     * If the record data is ready the method renders the record histogram.\n     * And in case the method returns a `Promise` the renderer just\n     * schedules the record refresh for later and exits.\n     *\n     * @param {HistogramRenderData} renderData Object containing renderer parameters.\n     * @internal\n     */\n    histogramRenderer(renderData) {\n        const\n            me            = this,\n            histogramData = renderData.histogramData || me.getRecordHistogramData(renderData.record);\n        // If the data is ready we just render a histogram\n        // Otherwise we render nothing and the rendering will happen once the data is ready\n        // (which is signalized by histogramDataCacheSet event)\n        if (!Objects.isPromise(histogramData)) {\n            Object.assign(renderData, me._recordRenderData);\n            return me.renderRecordHistogram(...arguments);\n        }\n        return '';\n    }\n    /**\n     * Group feature hook triggered by the feature to render group headers\n     * @param {*} renderData\n     * @internal\n     */\n    buildGroupHeader(renderData) {\n        if (renderData.column === this.timeAxisColumn) {\n            return this.histogramRenderer(renderData);\n        }\n        return this.features.group.buildGroupHeader(renderData);\n    }\n    //endregion\n    get widgetClass() {}\n}\nTimelineHistogramBase.initClass();\nTimelineHistogramBase._$name = 'TimelineHistogramBase';", "import ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\nimport TimelineHistogramBase from '../TimelineHistogramBase.js';\n/**\n * @module Scheduler/view/mixin/TimelineHistogramGrouping\n */\n/**\n * Mixin for {@link Scheduler/view/TimelineHistogram} that provides record grouping support.\n * The class implements API to work with groups and their members and allows to rollup group members data\n * to their parents.\n *\n * The _groups_ here are either group headers built with the {@link Grid/feature/Group} feature or\n * parent nodes built with the {@link Grid/feature/TreeGroup} feature.\n *\n * ## Parent histogram data aggregating\n *\n * The mixin provides a {@link #config-aggregateHistogramDataForGroups} config which enables automatically rolling up\n * child records histogram data to their parents. By default all registered {@link #config-series}' values are\n * just summed up on parents level, but that can be changed by providing `aggregate`\n * config to {@link #config-series}:\n *\n * ```javascript\n * new TimelineHistogram({\n *     series : {\n *         salary : {\n *            type : 'bar',\n *            // show maximum value on the parent level\n *            aggregate : 'max'\n *         }\n *     },\n *     ...\n * })\n * ```\n *\n * Here is the list of supported `aggregate` values:\n *\n * - `sum` or `add` - sum of values in the group (default)\n * - `min` - minimum value in the group\n * - `max` - maximum value in the group\n * - `count` - number of child records in the group\n * - `avg` - average of the child values in the group\n *\n * There are a few hooks allowing customization of the rolling up process:\n * {@link #config-aggregateDataEntry}, {@link #config-getDataEntryForAggregating} and\n * {@link #config-initAggregatedDataEntry}.\n *\n * @extends Scheduler/view/TimelineHistogramBase\n * @mixin\n */\nexport default Target => class TimelineHistogramGrouping extends (Target || TimelineHistogramBase) {\n    static $name = 'TimelineHistogramGrouping';\n    //region Configs\n    static configurable = {\n        /**\n         * When `true` the component will automatically calculate data for group records\n         * based on the groups members data by calling {@link #function-getGroupRecordHistogramData} method.\n         * @config {Boolean}\n         * @category Parent histogram data collecting\n         * @default\n         */\n        aggregateHistogramDataForGroups : true,\n        /**\n         * A function used for aggregating child records histogram data entries to their parent entry.\n         *\n         * It's called for each child entry and is meant to apply the child entry values to the\n         * target parent entry (provided in `aggregated` parameter).\n         * The function must return the resulting aggregated entry that will be passed as `aggregated`\n         * parameter to the next __aggregating__ step.\n         *\n         * Should be provided as a function, or name of a function in the ownership hierarchy which may be called.\n         *\n         * @config {Function|String} aggregateDataEntry\n         * @param {Object} aggregateDataEntry.aggregated Target parent data entry to aggregate the entry into.\n         * @param {Object} aggregateDataEntry.entry Current entry to aggregate into `aggregated`.\n         * @param {Number} aggregateDataEntry.arrayIndex Index of current array (index of the record among other records being aggregated).\n         * @param {Object[]} aggregateDataEntry.entryIndex Index of `entry` in the current array.\n         * @returns {Object} Return value becomes the value of the `aggregated` parameter on the next invocation of this function.\n         * @category Parent histogram data collecting\n         * @default\n         */\n        aggregateDataEntry : null,\n        /**\n         * Function that extracts a record histogram data entry for aggregating.\n         * By default it returns the entry as is. Override the function if you need a more complex way\n         * to retrieve the value for aggregating.\n         *\n         * Should be provided as a function, or name of a function in the ownership hierarchy which may be called.\n         *\n         * @config {Function|String} getDataEntryForAggregating\n         * @param {Object} getDataEntryForAggregating.entry Current data entry.\n         * @returns {Object} Entry to aggregate\n         * @category Parent histogram data collecting\n         * @default\n         */\n        getDataEntryForAggregating : null,\n        /**\n         * A function that initializes a target group record entry.\n         *\n         * Should be provided as a function, or name of a function in the ownership hierarchy which may be called.\n         *\n         * @config {Function|String} initAggregatedDataEntry\n         * @returns {Object} Target aggregated entry\n         * @category Parent histogram data collecting\n         * @default\n         */\n        initAggregatedDataEntry : null,\n        aggregateFunctions : {\n            sum : {\n                aliases : ['add'],\n                entry(seriesId, acc, entry) {\n                    acc[seriesId] = (acc[seriesId] || 0) + entry[seriesId];\n                    return acc;\n                }\n            },\n            min : {\n                entry(seriesId, acc, entry) {\n                    const entryValue = entry[seriesId];\n                    if (entryValue < (acc[seriesId] || Number.MAX_VALUE)) acc[seriesId] = entryValue;\n                    return acc;\n                }\n            },\n            max : {\n                entry(seriesId, acc, entry) {\n                    const entryValue = entry[seriesId];\n                    if (entryValue > (acc[seriesId] || Number.MIN_VALUE)) acc[seriesId] = entryValue;\n                    return acc;\n                }\n            },\n            count : {\n                init(seriesId, entry, entryIndex, aggregationContext) {\n                    entry[seriesId] = aggregationContext.arrays.length;\n                }\n            },\n            avg : {\n                entry(seriesId, acc, entry) {\n                    acc[seriesId] = (acc[seriesId] || 0) + entry[seriesId];\n                    return acc;\n                },\n                finalize(seriesId, data, recordsData, records, aggregationContext) {\n                    const cnt = aggregationContext.arrays.length;\n                    data.forEach(entry => entry[seriesId] /= cnt);\n                }\n            }\n        }\n    };\n    afterConfigure() {\n        const me = this;\n        me.internalAggregateDataEntry = me.internalAggregateDataEntry.bind(this);\n        me.internalInitAggregatedDataEntry = me.internalInitAggregatedDataEntry.bind(this);\n        super.afterConfigure();\n        if (me.features.treeGroup) {\n            me.features.treeGroup.ion({\n                // reset groups cache on store grouping change\n                beforeDataLoad : me.onTreeGroupBeforeDataLoad,\n                thisObj        : me\n            });\n        }\n    }\n    updateAggregateFunctions(value) {\n        for (const [id, fn] of Object.entries(value)) {\n            fn.id = id;\n            if (fn.aliases) {\n                for (const alias of fn.aliases) {\n                    value[alias] = fn;\n                }\n            }\n        }\n    }\n    updateStore(store) {\n        super.updateStore(...arguments);\n        this.detachListeners('store');\n        if (store) {\n            store.ion({\n                name    : 'store',\n                // reset groups cache on store grouping change\n                // Recalculation of group membership is done through sort\n                group   : this.onStoreGroup,\n                sort    : this.onStoreSort,\n                thisObj : this\n            });\n        }\n    }\n    changeAggregateDataEntry(fn) {\n        return this.bindCallback(fn);\n    }\n    changeGetDataEntryForAggregating(fn) {\n        return this.bindCallback(fn);\n    }\n    changeInitAggregatedDataEntry(fn) {\n        return this.bindCallback(fn);\n    }\n    //endregion\n    //region Event listeners\n    onHistogramDataCacheSet({ record, data }) {\n        // schedule record refresh for later\n        super.onHistogramDataCacheSet(...arguments);\n        if (this.aggregateHistogramDataForGroups) {\n            this.scheduleRecordParentsRefresh(record);\n        }\n    }\n    onTreeGroupBeforeDataLoad() {\n        if (this.aggregateHistogramDataForGroups) {\n            // reset groups cache on store grouping change\n            this.resetGeneratedRecordsHistogramDataCache();\n        }\n    }\n    onStoreGroup() {\n        if (this.aggregateHistogramDataForGroups) {\n            // reset groups cache on store grouping change\n            this.resetGeneratedRecordsHistogramDataCache();\n        }\n    }\n    onStoreSort({ source }) {\n        if (this.aggregateHistogramDataForGroups && source.isGrouped) {\n            // reset groups cache on store grouping change\n            this.resetGeneratedRecordsHistogramDataCache();\n        }\n    }\n    //endregion\n    // Override getRecordHistogramData to support data aggregating for parents\n    getRecordHistogramData(record, aggregationContext) {\n        const me = this;\n        let result;\n        // If that's a group record and records aggregating is enabled\n        // collect the aggregated data based on children\n        if (me.aggregateHistogramDataForGroups && me.isGroupRecord(record)) {\n            result = me.collectingDataFor.get(record) || me.getHistogramDataCache(record);\n            if (!result && !me.hasHistogramDataCache(record)) {\n                result = me.getGroupRecordHistogramData(record, aggregationContext);\n                result = me.finalizeDataRetrieving(record, result);\n            }\n        }\n        else {\n            result = super.getRecordHistogramData(...arguments);\n        }\n        return result;\n    }\n    //region ArrayHelper.aggregate default callbacks\n    internalAggregateDataEntry(acc, ...args) {\n        const { aggregateFunctions } = this;\n        // call series aggregate functions\n        for (const { id, aggregate = 'sum' } of Object.values(this.series)) {\n            let fn;\n            if (aggregate !== false && ((fn = aggregateFunctions[aggregate].entry))) {\n                acc = fn(id, acc, ...args);\n            }\n        }\n        return this.aggregateDataEntry ? this.aggregateDataEntry(acc, ...args) : acc;\n    }\n    internalInitAggregatedDataEntry() {\n        const\n            entry = this.initAggregatedDataEntry ? this.initAggregatedDataEntry(...arguments) : {},\n            { aggregateFunctions } = this;\n        // call series aggregate functions\n        for (const { id, aggregate = 'sum' } of Object.values(this.series)) {\n            const fn = aggregateFunctions[aggregate].init;\n            if (fn && aggregate !== false) {\n                fn(id, entry, ...arguments);\n            }\n        }\n        return entry;\n    }\n    //endregion\n    //region Public methods\n    /**\n     * Resets generated records (parents and links) data cache\n     */\n    resetGeneratedRecordsHistogramDataCache() {\n        const { store } = this;\n        for (const record of this.getHistogramDataCache().keys()) {\n            // clear cache for generated parents and links no longer in the store\n            if (record.isGroupHeader || record.generatedParent || (record.isLinked && !store.includes(record))) {\n                this.clearHistogramDataCache(record);\n            }\n        }\n    }\n    setHistogramDataCache(record, data) {\n        super.setHistogramDataCache(record, data);\n        // If that's a link let's update the original record cache too\n        if (record.isLinked) {\n            super.setHistogramDataCache(record.$original, data);\n        }\n        // if that's a record having links - update their caches too\n        else if (record.$links) {\n            const { store } = this;\n            for (const link of record.$links) {\n                // make sure the link belongs to this view store\n                if (store.includes(link)) {\n                    super.setHistogramDataCache(link, data);\n                }\n            }\n        }\n    }\n    // Override method to support links built by TreeGroup feature\n    // so for the links the method will retrieve original records cache\n    getHistogramDataCache(record) {\n        let result = super.getHistogramDataCache(record);\n        // if that's a link - try getting the original record cache\n        if (!result && record.isLinked) {\n            result = super.getHistogramDataCache(record.$original);\n        }\n        return result;\n    }\n    /**\n     * Aggregates the provided group record children histogram data.\n     * If some of the provided records data is not ready yet the method returns a `Promise`\n     * that's resolved once the data is ready and aggregated.\n     *\n     * ```javascript\n     * // get parent record aggregated histogram data\n     * const aggregatedData = await histogram.getGroupRecordHistogramData(record);\n     * ```\n     *\n     * @param {Core.data.Model} record Group record.\n     * @param {Object} [aggregationContext] Optional aggregation context object.\n     * When provided will be used as a shared object passed through while collecting the data.\n     * So can be used for some custom application purposes.\n     * @returns {Object[]|Promise} Either the provided group record histogram data or a `Promise` that\n     * returns the data when resolved.\n     * @category Parent histogram data collecting\n     */\n    getGroupRecordHistogramData(record, aggregationContext = {}) {\n        aggregationContext.parentRecord = record;\n        const result = this.aggregateRecordsHistogramData(this.getGroupChildren(record), aggregationContext);\n        return Objects.isPromise(result) ? result.then(res => res) : result;\n    }\n    /**\n     * Aggregates multiple records histogram data.\n     * If some of the provided records data is not ready yet the method returns a `Promise`\n     * that's resolved once the data is ready and aggregated.\n     *\n     * @param {Core.data.Model[]} records Records to aggregate data of.\n     * @param {Object} [aggregationContext] Optional aggregation context object.\n     * Can be used by to share some data between the aggregation steps.\n     * @returns {Object[]|Promise} Either the provided group record histogram data or a `Promise` that\n     * returns the data when resolved.\n     * @category Parent histogram data collecting\n     */\n    aggregateRecordsHistogramData(records, aggregationContext = {}) {\n        const\n            me = this,\n            recordsData = [],\n            { parentRecord } = aggregationContext;\n        let hasPromise = false;\n        // collect children data\n        for (const child of records) {\n            const childData = me.getRecordHistogramData(child, aggregationContext);\n            hasPromise = hasPromise || Objects.isPromise(childData);\n            childData && recordsData.push(childData);\n        }\n        // If some of children daa is not ready yet\n        if (hasPromise) {\n            // wait till all children data is ready\n            return Promise.all(recordsData).then(values => {\n                // re-apply parentRecord since it could get overridden in above getRecordHistogramData() calls\n                aggregationContext.parentRecord = parentRecord;\n                // filter out empty values\n                values = values.filter(x => x);\n                return me.aggregateHistogramData(values, records, aggregationContext);\n            });\n        }\n        // aggregate collected data\n        return me.aggregateHistogramData(recordsData, records, aggregationContext);\n    }\n    /**\n     * Indicates if the passed record represents a group header built by {@link Grid/feature/Group} feature\n     * or a group built by {@link Grid/feature/TreeGroup} feature.\n     *\n     * @param {Core.data.Model} record The view record\n     * @returns {Boolean} `true` if the record represents a group.\n     * @internal\n     */\n    isGroupRecord(record) {\n        return record.isGroupHeader || (this.isTreeGrouped && record.generatedParent);\n    }\n    /**\n     * For a record representing a group built by {@link Grid/feature/Group} or {@link Grid/feature/TreeGroup}\n     * feature returns the group members.\n     *\n     * @param {Core.data.Model} record A group record\n     * @returns {Core.data.Model[]} Records belonging to the group\n     * @internal\n     */\n    getGroupChildren(record) {\n        return record.groupChildren || record.children;\n    }\n    /**\n     * For a record belonging to a group built by {@link Grid/feature/Group} or {@link Grid/feature/TreeGroup}\n     * feature returns the group header or parent respectively.\n     *\n     * @param {Core.data.Model} record A member record\n     * @returns {Core.data.Model} The record group header or parent record\n     * @internal\n     */\n    getRecordParent(record) {\n        const { groupParent } = record;\n        return groupParent?.get(this.store.id) || (this.isTreeGrouped && record.parent);\n    }\n    /**\n     * Schedules refresh of the provided record's parents.\n     * The method iterates up from the provided record parent to the root node\n     * and schedules the iterated node rows refresh.\n     * @param {Core.data.Model} record Record to refresh parent rows of.\n     * @param {Boolean} [clearCache=true] `true` to reset the scheduled records histogram data cache.\n     * @internal\n     */\n    scheduleRecordParentsRefresh(record, clearCache = true) {\n        const me = this;\n        let groupParent;\n        while ((groupParent = me.getRecordParent(record))) {\n            // reset group cache\n            clearCache && me.clearHistogramDataCache(groupParent);\n            // and scheduler its later refresh\n            me.scheduleRecordRefresh(groupParent);\n            // bubble up\n            record = groupParent;\n        }\n    }\n    //endregion\n    /**\n     * Aggregates collected child records data to its parent.\n     * The method is synchronous and is called when all the child records data is ready.\n     * Override the method if you need to preprocess or postprocess parent records aggregated data:\n     *\n     * ````javascript\n     * class MyHistogramView extends TimelineHistogram({\n     *\n     *     aggregateHistogramData(recordsData, records, aggregationContext) {\n     *         const result = super.aggregateHistogramData(recordsData, records, aggregationContext);\n     *\n     *         // postprocess averageSalary series values collected for a parent record\n     *         result.forEach(entry => {\n     *             entry.averageSalary = entry.averageSalary / records.length;\n     *         });\n     *\n     *         return result;\n     *     }\n     *\n     * });\n     * ```\n     *\n     * @param {Object[]} recordsData Child records histogram data.\n     * @param {Core.data.Model[]} records Child records.\n     * @param {Object} aggregationContext An object containing current shared info on the current aggregation process\n     */\n    aggregateHistogramData(recordsData, records, aggregationContext = {}) {\n        const\n            me = this,\n            { aggregateFunctions } = me;\n        aggregationContext.recordsData = recordsData;\n        aggregationContext.records     = records;\n        const arrays = recordsData.map((histogramData, index) => {\n            return me.extractHistogramDataArray(\n                histogramData,\n                records[index]\n            );\n        });\n        // summarize children histogram data\n        const result = ArrayHelper.aggregate(\n            arrays,\n            me.getDataEntryForAggregating || (entry => entry),\n            me.internalAggregateDataEntry,\n            me.internalInitAggregatedDataEntry,\n            aggregationContext\n        );\n        // call series aggregate functions\n        for (const { id, aggregate = 'sum' } of Object.values(me.series)) {\n            const fn = aggregateFunctions[aggregate].finalize;\n            if (fn && aggregate !== false) {\n                fn(id, result, ...arguments);\n            }\n        }\n        return result;\n    }\n    get widgetClass() {}\n};\n", "import '../../column/ScaleColumn.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/view/mixin/TimelineHistogramScaleColumn\n */\n/**\n * Mixin of {@link Scheduler/view/TimelineHistogram} class that implements\n * {@link Scheduler/column/ScaleColumn} automatic injection and functioning.\n *\n * @mixin\n */\nexport default Target => class TimelineHistogramScaleColumn extends (Target) {\n    static $name = 'TimelineHistogramScaleColumn';\n    //region Config\n    static configurable = {\n        /**\n         * The locked grid scale column reference.\n         * @member {Scheduler.column.ScaleColumn} scaleColumn\n         * @readonly\n         * @category Scale column\n         */\n        /**\n         * An object with configuration for the {@link Scheduler/column/ScaleColumn}.\n         *\n         * Example:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     scaleColumn : {\n         *         width : 50\n         *     },\n         *     ...\n         * });\n         * ```\n         *\n         * Provide `null` to the config to get rid of the column completely:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     // do not add scale column\n         *     scaleColumn : null,\n         *     ...\n         * });\n         * ```\n         *\n         * @config {Object} scaleColumn\n         * @category Scale column\n         */\n        scaleColumn : {},\n        scalePoints : null,\n        scalePointsModelField : 'scalePoints',\n        calculateTopValueByScalePoints : true\n    };\n    updateScalePoints(scalePoints) {\n        const\n            me            = this,\n            topScalePoint = scalePoints[scalePoints.length - 1];\n        if (topScalePoint) {\n            me.scaleUnit = topScalePoint.unit;\n            // Applying new maximum value to the histogram.\n            me.histogramWidget.topValue = me.getTopValueByScalePoints(scalePoints);\n        }\n        // Applying new points to the scale column\n        if (me.scaleColumn) {\n            me.scaleColumn.scalePoints = scalePoints;\n        }\n    }\n    //endregion\n    //region Columns\n    changeColumns(columns, currentStore) {\n        const\n            me = this,\n            scaleColumn = me.getConfig('scaleColumn');\n        // No columns means destroy\n        if (columns && scaleColumn) {\n            const isArray = Array.isArray(columns);\n            let cols = columns;\n            if (!isArray) {\n                cols = columns.data;\n            }\n            let\n                scaleColumnIndex = cols?.length,\n                scaleColumnConfig = scaleColumn;\n            cols.some((col, index) => {\n                if (col.type === 'scale') {\n                    scaleColumnIndex  = index;\n                    scaleColumnConfig = ObjectHelper.assign(col, scaleColumnConfig);\n                    return true;\n                }\n            });\n            // We're going to mutate this array which we do not own, so copy it first.\n            cols = cols.slice();\n            // Fix up the scaleColumn config in place\n            cols[scaleColumnIndex] = {\n                type : 'scale',\n                ...scaleColumnConfig\n            };\n            if (isArray) {\n                columns = cols;\n            }\n            else {\n                columns.data = cols;\n            }\n        }\n        return super.changeColumns(columns, currentStore);\n    }\n    updateColumns(columns, was) {\n        super.updateColumns(columns, was);\n        // Extract the known columns by type. Sorting will have placed them into visual order.\n        if (columns) {\n            this._scaleColumn = this.columns.find(c => c.isScaleColumn);\n        }\n    }\n    onColumnsChanged({ action, changes, record : column, records }) {\n        const { scaleColumn, columns } = this;\n        // If someone replaces the column set (syncing leads to batch), ensure scale is always added\n        if (scaleColumn && (action === 'dataset' || action === 'batch') && !columns.includes(scaleColumn)) {\n            columns.add(scaleColumn, true);\n        }\n        super.onColumnsChanged(...arguments);\n    }\n    //endregion\n    //region Data processing\n    /**\n     * A hook to convert scale point values to histogram ones.\n     * In case they use different units.\n     *\n     * Override this method in a sub-class to implement your custom\n     * application specific conversion.\n     * @param {Number} value Scale point value\n     * @param {String} unit Scale point unit\n     * @internal\n     */\n    convertUnitsToHistogramValue(value, unit) {\n        return value;\n    }\n    /**\n     * A hook to convert histogram values to scale point ones.\n     * In case they use different units.\n     *\n     * Override this method in a sub-class to implement your custom\n     * application specific conversion.\n     * @param {Number} value Scale point value\n     * @param {String} unit Scale point unit\n     * @internal\n     */\n    convertHistogramValueToUnits(value, unit) {\n        return value;\n    }\n    extractHistogramDataArray(histogramData, record) {\n        return histogramData;\n    }\n    getTopValueByScalePoints(scalePoints) {\n        const\n            me              = this,\n            { scaleColumn } = me,\n            lastPoint       = scalePoints[scalePoints.length - 1],\n            { value, unit } = lastPoint;\n        let rawValue = value;\n        if (scaleColumn) {\n            // add padding to top value\n            rawValue *= 1 + (scaleColumn.scaleWidget.scaleMaxPadding || 0);\n        }\n        return me.convertUnitsToHistogramValue(rawValue, unit || me.scaleUnit);\n    }\n    processRecordRenderData(renderData) {\n        renderData = super.processRecordRenderData(...arguments);\n        if (this.scaleColumn) {\n            const\n                me = this,\n                { record, histogramData, histogramConfig = {} } = renderData;\n            let\n                topValue = me.initialConfig.histogramWidget?.topValue,\n                scalePoints = me.scalePoints || record.get(me.scalePointsModelField);\n            if (!topValue) {\n                // if no topValue provided but we have scalePoints\n                if (scalePoints && me.calculateTopValueByScalePoints) {\n                    // calculate topValue based on the max scale point\n                    topValue = me.getTopValueByScalePoints(scalePoints);\n                }\n                // if still no topValue\n                if (!topValue && histogramData) {\n                    const histogramWidget = renderData.histogramWidget || me.histogramWidget;\n                    ObjectHelper.assign(histogramWidget, histogramConfig);\n                    // get top value based on histogramData\n                    topValue = histogramWidget.getDataTopValue(histogramData);\n                    scalePoints = [{\n                        value : me.convertHistogramValueToUnits(topValue, me.scaleUnit),\n                        text  : me.convertHistogramValueToUnits(topValue, me.scaleUnit)\n                    }];\n                    topValue += me.scaleColumn.scaleWidget.scaleMaxPadding * topValue;\n                }\n                renderData.scaleWidgetConfig = { scalePoints };\n                renderData.histogramConfig = { ...histogramConfig, topValue };\n            }\n        }\n        return renderData;\n    }\n    //endregion\n    //region Render\n    /**\n     * Group feature hook triggered by the feature to render group headers\n     * @param {Object} renderData\n     * @internal\n     */\n    buildGroupHeader(renderData) {\n        if (renderData.column === this.scaleColumn) {\n            return this.scaleColumn.renderer(renderData);\n        }\n        return super.buildGroupHeader(...arguments);\n    }\n    beforeRenderCell(renderData) {\n        if (this.scaleColumn && renderData.column === this.scaleColumn) {\n            renderData.histogramData = this.getRecordHistogramData(renderData.record);\n            // If data is read apply prepared render data\n            if (!ObjectHelper.isPromise(renderData.histogramData)) {\n                Object.assign(renderData, this._recordRenderData);\n            }\n        }\n        return super.beforeRenderCell(...arguments);\n    }\n    /**\n     * Renders record scale column content.\n     * @param {Core.data.Model} record Record to render scale for\n     * @param {Object} [renderData]\n     * @category Scale column\n     */\n    renderRecordScale(record, renderData) {\n        if (this.scaleColumn) {\n            const\n                row         = this.getRowFor(record),\n                cellElement = row?.getCell(this.scaleColumn.id);\n            if (cellElement) {\n                row.renderCell(cellElement);\n            }\n        }\n    }\n    get widgetClass() {}\n    //endregion\n};\n", "import '../../Grid/column/TreeColumn.js';\nimport '../../Grid/feature/Tree.js';\nimport '../column/ScaleColumn.js';\nimport '../column/TimeAxisColumn.js';\nimport TimelineHistogramGrouping from './mixin/TimelineHistogramGrouping.js';\nimport '../feature/ColumnLines.js';\nimport '../feature/ScheduleTooltip.js';\nimport TimelineHistogramBase from './TimelineHistogramBase.js';\nimport TimelineHistogramScaleColumn from './mixin/TimelineHistogramScaleColumn.js';\n/**\n * @module Scheduler/view/TimelineHistogram\n */\n/**\n * This view displays histograms for the provided store records.\n *\n * A {@link Scheduler/column/ScaleColumn} is also added automatically.\n *\n * {@inlineexample Scheduler/view/TimelineHistogram.js}\n *\n * To create a standalone histogram, simply configure it with a {@link Core/data/Store} instance:\n *\n * ```javascript\n * const store = new Store({\n *     data : [\n *         {\n *             id            : 'r1',\n *             name          : 'Record 1',\n *             // data used to render a histogram for this record\n *             histogramData : [\n *                 { value1 : 200, value2 : 100 },\n *                 { value1 : 150, value2 : 50 },\n *                 { value1 : 175, value2 : 50 },\n *                 { value1 : 175, value2 : 75 }\n *             ]\n *         },\n *         {\n *             id            : 'r2',\n *             name          : 'Record 2',\n *             // data used to render a histogram for this record\n *             histogramData : [\n *                 { value1 : 100, value2 : 100 },\n *                 { value1 : 150, value2 : 125 },\n *                 { value1 : 175, value2 : 150 },\n *                 { value1 : 175, value2 : 75 }\n *             ]\n *         }\n *     ]\n * });\n *\n * const histogram = new TimelineHistogram({\n *     appendTo  : 'targetDiv',\n *     startDate : new Date(2022, 11, 26),\n *     endDate   : new Date(2022, 11, 30),\n *     store,\n *     // specify series displayed in the histogram\n *     series : {\n *         value1 : {\n *             type  : 'bar',\n *             field : 'value1'\n *         },\n *         value2 : {\n *             type  : 'bar',\n *             field : 'value2'\n *         }\n *     },\n *     columns : [\n *         {\n *             field : 'name',\n *             text  : 'Name'\n *         }\n *     ]\n * });\n * ```\n *\n * ## Providing histogram data\n *\n * There are two basic ways to provide histogram data:\n *\n * - the data can be provided statically in a record field configured as {@link #config-dataModelField}:\n *\n * ```javascript\n * const store = new Store({\n *     data : [\n *         {\n *             id   : 11,\n *             name : 'John Smith',\n *             // data used to render a histogram for this record\n *             hd   : [\n *                 { weight : 200, price : 100 },\n *                 { weight : 150, price : 105 },\n *                 { weight : 175, price : 90 },\n *                 { weight : 175, price : 95 }\n *             ]\n *         }\n *     ]\n * });\n *\n * const histogram = new TimelineHistogram({\n *     dataModelField : 'hd',\n *     series : {\n *         weight : {\n *             type : 'bar'\n *         },\n *         price : {\n *             type : 'outline'\n *         }\n *     },\n *     ...\n * });\n * ```\n * - the data can be collected dynamically with the provided {@link #config-getRecordData} function:\n *\n * ```javascript\n * const histogram = new TimelineHistogram({\n *     dataModelField : 'hd',\n *     series : {\n *         weight : {\n *             type : 'bar'\n *         },\n *         price : {\n *             type : 'outline'\n *         }\n *     },\n *     ...\n *     async getRecordData(record) {\n *         // we get record histogram data from the server\n *         const response = await fetch('https://some.url/to/get/data?' + new URLSearchParams({\n *             // pass the record identifier and the time span we need data for\n *             record    : record.id,\n *             startDate : DateHelper.format(this.startDate),\n *             endDate   : DateHelper.format(this.endDate),\n *         }));\n *         return response.json();\n *     }\n * });\n * ```\n *\n * Please check [\"Timeline histogram\" guide](#Scheduler/guides/timelinehistogram.md) for more details.\n *\n * @features Scheduler/feature/ColumnLines\n * @features Scheduler/feature/GroupSummary\n * @features Scheduler/feature/HeaderZoom\n * @features Scheduler/feature/NonWorkingTime\n * @features Scheduler/feature/Pan\n * @features Scheduler/feature/ResourceMenu\n * @features Scheduler/feature/ResourceTimeRanges\n * @features Scheduler/feature/RowReorder\n * @features Scheduler/feature/ScheduleTooltip\n * @features Scheduler/feature/Split\n * @features Scheduler/feature/Summary\n * @features Scheduler/feature/TimeAxisHeaderMenu\n * @features Scheduler/feature/TimeRanges\n *\n * @extends Scheduler/view/TimelineHistogramBase\n * @mixes Scheduler/view/mixin/TimelineHistogramGrouping\n * @mixes Scheduler/view/mixin/TimelineHistogramScaleColumn\n *\n * @classtype timelinehistogram\n * @widget\n */\nexport default class TimelineHistogram extends TimelineHistogramBase.mixin(\n    TimelineHistogramGrouping,\n    TimelineHistogramScaleColumn\n) {\n    //region Config\n    static $name = 'TimelineHistogram';\n    static type = 'timelinehistogram';\n    /**\n     * Retrieves the histogram data for the provided record.\n     *\n     * The method first checks if there is cached data for the record and returns it if found.\n     * Otherwise it starts collecting data by calling {@link #config-getRecordData} (if provided)\n     * or by reading it from the {@link #config-dataModelField} record field.\n     *\n     * If the provided record represents a group and {@link #config-aggregateHistogramDataForGroups} is enabled\n     * then the group members data is calculated with a {@link #function-getGroupRecordHistogramData} method call.\n     *\n     * The method can be asynchronous depending on the provided {@link #config-getRecordData} function.\n     * If the function returns a `Promise` then the method will return a wrapping `Promise` in turn that will\n     * resolve with the collected histogram data.\n     *\n     * The method triggers the {@link #event-histogramDataCacheSet} event when a record data is ready.\n     *\n     * @param {Core.data.Model} record Record to retrieve the histogram data for.\n     * @param {Object} [aggregationContext] An optional object passed when the method is called when aggregating\n     * a group members histogram data.\n     *\n     * See {@link #function-getGroupRecordHistogramData} and {@link Core/helper/ArrayHelper#function-aggregate-static}\n     * for more details.\n     * @returns {Object|Promise} The histogram data for the provided record or a `Promise` that will provide the data\n     * when resolved.\n     * @function getRecordHistogramData\n     */\n}\nTimelineHistogram.initClass();\nTimelineHistogram._$name = 'TimelineHistogram';"],
  "mappings": "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",
  "names": ["resourceRecord", "_a", "data", "_a"]
}
