{
  "version": 3,
  "sources": ["../../../../Scheduler/lib/Scheduler/column/ResourceInfoColumn.js", "../../../../Scheduler/lib/Scheduler/feature/Labels.js", "../../../../Scheduler/lib/Scheduler/feature/RowReorder.js", "../../../../Scheduler/lib/Scheduler/feature/TimelineSummary.js", "../../../../Scheduler/lib/Scheduler/feature/export/Utils.js", "../../../../Scheduler/lib/Scheduler/feature/export/exporter/SchedulerExporterMixin.js", "../../../../Scheduler/lib/Scheduler/feature/export/exporter/MultiPageExporter.js", "../../../../Scheduler/lib/Scheduler/feature/export/exporter/MultiPageVerticalExporter.js", "../../../../Scheduler/lib/Scheduler/view/export/field/ScheduleRangeCombo.js", "../../../../Scheduler/lib/Scheduler/view/export/SchedulerExportDialog.js", "../../../../Scheduler/lib/Scheduler/feature/export/exporter/SinglePageExporter.js", "../../../../Scheduler/lib/Scheduler/feature/export/PdfExport.js"],
  "sourcesContent": ["import Column from '../../Grid/column/Column.js';\nimport ColumnStore from '../../Grid/data/ColumnStore.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport AvatarRendering from '../../Core/widget/util/AvatarRendering.js';\n/**\n * @module Scheduler/column/ResourceInfoColumn\n */\n/**\n * Displays basic resource information. Defaults to showing an image + name + event count (all configurable).\n *\n * If a resource has no image, you can either provide an icon using `iconCls` in the data (you then need to specify\n * `image === false` in your data) or the resource initials will be shown.\n *\n * Be sure to specify {@link Scheduler.view.mixin.SchedulerEventRendering#config-resourceImagePath} to instruct the\n * column where to look for the images.\n *\n * If an image fails to load or if a resource lacks an image, the resource name initials will be rendered. If the\n * resource has an {@link Scheduler/model/mixin/ResourceModelMixin#field-eventColor} specified, it will be used as the\n * background color of the initials.\n *\n * {@inlineexample Scheduler/column/ResourceInfoColumn.js}\n *\n * @extends Grid/column/Column\n * @classtype resourceInfo\n * @column\n */\nexport default class ResourceInfoColumn extends Column {\n    static get $name() {\n        return 'ResourceInfoColumn';\n    }\n    static get type() {\n        return 'resourceInfo';\n    }\n    static get fields() {\n        return ['showEventCount', 'showRole', 'showMeta', 'showImage', 'validNames', 'autoScaleThreshold', 'useNameAsImageName'];\n    }\n    static get defaults() {\n        return {\n            /** @hideconfigs renderer */\n            /**\n             * Show image. Looks for image name in fields on the resource in the following order: 'imageUrl', 'image',\n             * 'name'. Set `showImage` to a field name to use a custom field. Set `Scheduler.resourceImagePath` to\n             * specify where to load images from. If no extension found, defaults to\n             * {@link Scheduler.view.mixin.SchedulerEventRendering#config-resourceImageExtension}.\n             * @config {Boolean}\n             * @default\n             */\n            showImage : true,\n            /**\n             * Show number of events assigned to the resource below the name.\n             * @config {Boolean}\n             * @default\n             */\n            showEventCount : true,\n            /**\n             * A template string to render any extra information about the resource below the name\n             * @config {Function}\n             * @param {Scheduler.model.ResourceModel} resourceRecord The record representing the current row\n             * @returns {String|null}\n             */\n            showMeta : null,\n            /**\n             * Show resource role below the name. Specify `true` to display data from the `role` field, or specify a field\n             * name to read this value from.\n             * @config {Boolean|String}\n             * @default\n             */\n            showRole : false,\n            /**\n             * Valid image names. Set to `null` to allow all names.\n             * @deprecated This will be removed in 6.0\n             * @config {String[]}\n             */\n            validNames : null,\n            /**\n             * Specify 0 to prevent the column from adapting its content according to the used row height, or specify a\n             * threshold (row height) at which scaling should start.\n             * @config {Number}\n             * @default\n             */\n            autoScaleThreshold : 40,\n            /**\n             * Use the resource name as the image name when no `image` is specified on the resource.\n             * @config {Boolean}\n             * @default\n             */\n            useNameAsImageName : true,\n            field      : 'name',\n            htmlEncode : false,\n            width      : 140,\n            cellCls    : 'b-resourceinfo-cell',\n            editor     : VersionHelper.isTestEnv ? false : 'text'\n        };\n    }\n    construct(...args) {\n        super.construct(...args);\n        this.avatarRendering = new AvatarRendering({\n            element : this.grid.element\n        });\n    }\n    doDestroy() {\n        super.doDestroy();\n        this.avatarRendering.destroy();\n    }\n    getImageURL(imageName) {\n        const\n            resourceImagePath = this.grid.resourceImagePath || '',\n            parts             = resourceImagePath.split('//'),\n            urlPart           = parts.length > 1 ? parts[1] : resourceImagePath,\n            joined            = StringHelper.joinPaths([urlPart || '', imageName || '']);\n        return parts.length > 1 ? parts[0] + '//' + joined : joined;\n    }\n    template(resourceRecord, value) {\n        const me        = this,\n            {\n                showImage,\n                showRole,\n                showMeta,\n                showEventCount,\n                grid\n            }         = me,\n            {\n                timeAxis,\n                resourceImageExtension = '',\n                defaultResourceImageName\n            }         = grid,\n            roleField = typeof showRole === 'string' ? showRole : 'role',\n            count     = showEventCount && resourceRecord.eventStore.getEvents({\n                includeOccurrences : grid.enableRecurringEvents,\n                resourceRecord,\n                startDate          : timeAxis.startDate,\n                endDate            : timeAxis.endDate\n            }).length;\n        let imageUrl;\n        if (showImage && resourceRecord.image !== false) {\n            if (resourceRecord.imageUrl) {\n                imageUrl = resourceRecord.imageUrl;\n            }\n            else {\n                // record.image is supposed to be a file name, located at resourceImagePath\n                const\n                    imageName = typeof showImage === 'string'\n                        ? showImage\n                        : (resourceRecord.image || value && me.useNameAsImageName && (value.toLowerCase() + resourceImageExtension) || defaultResourceImageName) || '';\n                imageUrl = imageName && me.getImageURL(imageName);\n                // Image name should have an extension\n                if (imageUrl && !imageName.includes('.')) {\n                    // If validNames is specified, check that imageName is valid\n                    if (!me.validNames || me.validNames.includes(imageName)) {\n                        imageUrl += resourceImageExtension;\n                    }\n                }\n            }\n        }\n        return {\n            class    : 'b-resource-info',\n            children : [\n                showImage && me.avatarRendering.getResourceAvatar({\n                    resourceRecord,\n                    initials        : resourceRecord.initials,\n                    color           : resourceRecord.eventColor,\n                    iconCls         : resourceRecord.iconCls,\n                    imageUrl,\n                    defaultImageUrl : defaultResourceImageName && this.getImageURL(defaultResourceImageName)\n                }),\n                showRole || showEventCount || showMeta ? {\n                    tag      : 'dl',\n                    children : [\n                        {\n                            tag  : 'dt',\n                            text : value\n                        },\n                        showRole ? {\n                            tag   : 'dd',\n                            class : 'b-resource-role',\n                            text  : resourceRecord.getValue(roleField)\n                        } : null,\n                        showEventCount ? {\n                            tag   : 'dd',\n                            class : 'b-resource-events',\n                            html  : me.L('L{eventCountText}', count)\n                        } : null,\n                        showMeta ? {\n                            tag   : 'dd',\n                            class : 'b-resource-meta',\n                            html  : me.showMeta(resourceRecord)\n                        } : null\n                    ]\n                } : value // This becomes a text node, no HTML encoding needed\n            ]\n        };\n    }\n    defaultRenderer({ grid, record, cellElement, value, isExport }) {\n        let result;\n        if (record.isSpecialRow) {\n            result = '';\n        }\n        else if (isExport) {\n            result = value;\n        }\n        else {\n            if (this.autoScaleThreshold && grid.rowHeight < this.autoScaleThreshold) {\n                cellElement.style.fontSize = (grid.rowHeight / 40) + 'em';\n            }\n            else {\n                cellElement.style.fontSize = '';\n            }\n            result = this.template(record, value);\n        }\n        return result;\n    }\n}\nColumnStore.registerColumnType(ResourceInfoColumn);\nResourceInfoColumn._$name = 'ResourceInfoColumn';", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Editor from '../../Core/widget/Editor.js';\n/**\n * @module Scheduler/feature/Labels\n */\nconst\n    sides       = [\n        'top',\n        'before',\n        'after',\n        'bottom'\n    ],\n    editorAlign = (side, client) => {\n        switch (side) {\n            case 'top' :\n                return 'b-b';\n            case 'after' :\n                return client.rtl ? 'r-r' : 'l-l';\n            case 'right' :\n                return 'l-l';\n            case 'bottom' :\n                return 't-t';\n            case 'before' :\n                return client.rtl ? 'l-l' : 'r-r';\n            case 'left' :\n                return 'r-r';\n        }\n    },\n    topBottom   = {\n        top    : 1,\n        bottom : 1\n    },\n    layoutModes = {\n        estimate : 1,\n        measure  : 1\n    },\n    layoutSides = {\n        before : 1,\n        after  : 1\n    };\n/**\n * Configuration object for a label used by the Labels feature.\n * @typedef {Object} SchedulerLabelConfig\n * @property {String} field The name of a field in one of the associated records, {@link Scheduler.model.EventModel} or\n * {@link Scheduler.model.ResourceModel}. The record from which the field value is drawn will be ascertained by checking\n * for field definitions by the specified name.\n * @property {Function} renderer A function, which when passed an object containing `eventRecord`, `resourceRecord`,\n * `assignmentRecord` and `domConfig` properties, returns the HTML to display as the label\n * @property {Scheduler.model.EventModel} renderer.eventRecord\n * @property {Scheduler.model.ResourceModel} renderer.resourceRecord\n * @property {Scheduler.model.AssignmentModel} renderer.assignmentRecord\n * @property {DomConfig} renderer.domConfig\n * @property {Object} thisObj The `this` reference to use in the `renderer`.\n * @property {InputFieldConfig|Core.widget.Field} editor If the label is to be editable, a field configuration object with a\n * `type` property, or an instantiated Field. **The `field` property is mandatory for editing to work**.\n */\n/**\n * Displays labels at positions {@link #config-top}, {@link #config-right}, {@link #config-bottom} and\n * {@link #config-left}.\n *\n * Text in labels can be set from a field on the {@link Scheduler.model.EventModel} or the\n * {@link Scheduler.model.ResourceModel} or using a custom renderer.\n *\n * Since `top` and `bottom` labels occupy space that would otherwise be used by the event we recommend using bigger\n * rowHeights (>55px for both labels with default styling) and zero barMargins because `top`/`bottom` labels give space\n * around events anyway.\n *\n * To prevent labels from being overlapped by other events, see {@link #config-labelLayoutMode}.\n *\n * This feature is **disabled** by default.\n * It is **not** supported in vertical mode.\n * For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * {@inlineexample Scheduler/feature/Labels.js}\n *\n * @demo Scheduler/labels\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype labels\n * @feature\n */\nexport default class Labels extends InstancePlugin {\n    //region Config\n    static get $name() {\n        return 'Labels';\n    }\n    static get configurable() {\n        return {\n            /**\n             * CSS class to apply to label elements\n             * @config {String}\n             * @default\n             */\n            labelCls : 'b-sch-label',\n            /**\n             * Top label configuration object.\n             * @config {SchedulerLabelConfig}\n             * @default\n             */\n            top : null,\n            /**\n             * Configuration object for the label which appears *after* the event bar in the current writing direction.\n             * @config {SchedulerLabelConfig}\n             * @default\n             */\n            after : null,\n            /**\n             * Right label configuration object.\n             * @config {SchedulerLabelConfig}\n             * @default\n             */\n            right : null,\n            /**\n             * Bottom label configuration object.\n             * @config {SchedulerLabelConfig}\n             * @default\n             */\n            bottom : null,\n            /**\n             * Configuration object for the label which appears *before* the event bar in the current writing direction.\n             * @config {SchedulerLabelConfig}\n             * @default\n             */\n            before : null,\n            /**\n             * Left label configuration object.\n             * @config {SchedulerLabelConfig}\n             * @default\n             */\n            left : null,\n            thisObj : null,\n            /**\n             * What action should be taken when focus moves leaves the cell editor, for example when clicking outside.\n             * May be `'complete'` or `'cancel`'.\n             * @config {'complete'|'cancel'}\n             * @default\n             */\n            blurAction : 'cancel',\n            /**\n             * How to handle labels during event layout. Options are:\n             *\n             * * default - Labels do not affect event layout, events will overlap labels\n             * * estimate - Label width is estimated by multiplying text length with {@link #config-labelCharWidth}\n             * * measure - Label width is determined by measuring the label, precise but slow\n             *\n             * Note that this only applies to the left and right labels, top and bottom labels does not take part in the\n             * event layout process.\n             *\n             * @config {'default'|'estimate'|'measure'}\n             * @default\n             */\n            labelLayoutMode : 'default',\n            /**\n             * Factor representing the average char width in pixels used to determine label width when configured\n             * with `labelLayoutMode: 'estimate'`.\n             * @config {Number}\n             * @default\n             */\n            labelCharWidth : 7\n        };\n    }\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onEventDataGenerated']\n        };\n    }\n    //endregion\n    //region Init & destroy\n    construct(scheduler, config) {\n        const me = this;\n        if (scheduler.isVertical) {\n            throw new Error('Labels feature is not supported in vertical mode');\n        }\n        me.scheduler = scheduler;\n        super.construct(scheduler, config);\n        if (me.top || me.bottom || me.before || me.after) {\n            me.updateHostClasslist();\n            // rowHeight warning, not in use\n            //const labelCount = !!me.topLabel + !!me.bottomLabel;\n            //if (scheduler.rowHeight < 60 - labelCount * 12) console.log('')\n        }\n    }\n    updateHostClasslist() {\n        const\n            { top, bottom } = this,\n            { classList }   = this.scheduler.element;\n        classList.remove('b-labels-topbottom');\n        classList.remove('b-labels-top');\n        classList.remove('b-labels-bottom');\n        // OR is correct. This means that there are labels above OR below.\n        if (top || bottom) {\n            classList.add('b-labels-topbottom');\n            if (top) {\n                classList.add('b-labels-top');\n            }\n            if (bottom) {\n                classList.add('b-labels-bottom');\n            }\n        }\n    }\n    onLabelDblClick(event) {\n        const\n            me        = this,\n            target    = event.target;\n        if (target && !me.scheduler.readOnly) {\n            const\n                { side }          = target.dataset,\n                labelConfig       = me[side],\n                { editor, field } = labelConfig;\n            if (editor) {\n                const eventRecord = this.scheduler.resolveEventRecord(event.target);\n                if (eventRecord.readOnly) {\n                    return;\n                }\n                if (!(editor instanceof Editor)) {\n                    labelConfig.editor = new Editor({\n                        blurAction   : me.blurAction,\n                        inputField   : editor,\n                        scrollAction : 'realign'\n                    });\n                }\n                // Editor removes itself from the DOM after being hidden\n                labelConfig.editor.render(me.scheduler.element);\n                labelConfig.editor.startEdit({\n                    target,\n                    align     : editorAlign(side, me.client),\n                    matchSize : false,\n                    record    : eventRecord,\n                    field\n                });\n                event.stopImmediatePropagation();\n                return false;\n            }\n        }\n    }\n    changeTop(top) {\n        return this.processLabelSpec(top, 'top');\n    }\n    updateTop() {\n        this.updateHostClasslist();\n    }\n    changeAfter(after) {\n        return this.processLabelSpec(after, 'after');\n    }\n    updateAfter() {\n        this.updateHostClasslist();\n    }\n    changeRight(right) {\n        this[this.client.rtl ? 'before' : 'after'] = right;\n    }\n    changeBottom(bottom) {\n        return this.processLabelSpec(bottom, 'bottom');\n    }\n    updateBottom() {\n        this.updateHostClasslist();\n    }\n    changeBefore(before) {\n        return this.processLabelSpec(before, 'before');\n    }\n    updateBefore() {\n        this.updateHostClasslist();\n    }\n    changeLeft(left) {\n        this[this.client.rtl ? 'after' : 'before'] = left;\n    }\n    processLabelSpec(labelSpec, side) {\n        if (typeof labelSpec === 'function') {\n            labelSpec = {\n                renderer : labelSpec\n            };\n        }\n        else if (typeof labelSpec === 'string') {\n            labelSpec = {\n                field : labelSpec\n            };\n        }\n        // Allow us to mutate ownProperties in the labelSpec without mutating outside object\n        else if (labelSpec) {\n            labelSpec = Object.setPrototypeOf({}, labelSpec);\n        }\n        // Clear label\n        else {\n            return null;\n        }\n        const\n            { scheduler }                                = this,\n            { eventStore, resourceStore, taskStore, id } = scheduler,\n            { field, editor }                            = labelSpec;\n        // If there are milestones, and we are changing the available height\n        // either by adding a top/bottom label, or adding a top/bottom label\n        // then during the next dependency refresh, milestone width must be recalculated.\n        if (topBottom[side]) {\n            scheduler.milestoneWidth = null;\n        }\n        if (eventStore && !taskStore) {\n            labelSpec.recordType = 'event';\n        }\n        else {\n            labelSpec.recordType = 'task';\n        }\n        // Find the field definition or property from whichever store and cache the type.\n        if (field) {\n            let\n                fieldDef,\n                fieldFound = false;\n            if (eventStore && !taskStore) {\n                fieldDef = eventStore.modelClass.fieldMap[field];\n                if (fieldDef) {\n                    labelSpec.fieldDef = fieldDef;\n                    labelSpec.recordType = 'event';\n                    fieldFound = true;\n                }\n                // Check if it references a property\n                else if (Reflect.has(eventStore.modelClass.prototype, field)) {\n                    labelSpec.recordType = 'event';\n                    fieldFound = true;\n                }\n            }\n            if (!fieldDef && taskStore) {\n                fieldDef = taskStore.modelClass.fieldMap[field];\n                if (fieldDef) {\n                    labelSpec.fieldDef = fieldDef;\n                    labelSpec.recordType = 'task';\n                    fieldFound = true;\n                }\n                // Check if it references a property\n                else if (Reflect.has(resourceStore.modelClass.prototype, field)) {\n                    labelSpec.recordType = 'task';\n                    fieldFound = true;\n                }\n            }\n            if (!fieldDef && resourceStore) {\n                fieldDef = resourceStore.modelClass.fieldMap[field];\n                if (fieldDef) {\n                    labelSpec.fieldDef = fieldDef;\n                    labelSpec.recordType = 'resource';\n                    fieldFound = true;\n                }\n                // Check if it references a property\n                else if (Reflect.has(resourceStore.modelClass.prototype, field)) {\n                    labelSpec.recordType = 'resource';\n                    fieldFound = true;\n                }\n            }\n            if (editor) {\n                if (typeof editor === 'boolean') {\n                    scheduler.editor = {\n                        type : 'textfield'\n                    };\n                }\n                else if (typeof editor === 'string') {\n                    scheduler.editor = {\n                        type : editor\n                    };\n                }\n                EventHelper.on({\n                    element  : scheduler.timeAxisSubGrid.element,\n                    delegate : '.b-sch-label',\n                    dblclick : 'onLabelDblClick',\n                    thisObj  : this\n                });\n            }\n        }\n        return labelSpec;\n    }\n    doDisable(disable) {\n        super.doDisable(disable);\n        if (this.client.isPainted) {\n            this.client.refresh();\n        }\n    }\n    //endregion\n    generateLabelConfigs(data) {\n        const\n            me      = this,\n            configs = [];\n        // Insert all configured labels\n        for (const side of sides) {\n            if (me[side]) {\n                const\n                    {\n                        field,\n                        fieldDef,\n                        recordType,\n                        renderer,\n                        thisObj\n                    }  = me[side],\n                    domConfig = {\n                        tag       : 'label',\n                        className : {\n                            [me.labelCls]              : 1,\n                            [`${me.labelCls}-${side}`] : 1\n                        },\n                        dataset : {\n                            side,\n                            taskFeature : `label-${side}`\n                        }\n                    };\n                let value;\n                const\n                    eventRecordProperty = `${recordType}Record`,\n                    eventRecord         = data[eventRecordProperty];\n                // If there's a renderer, use that by preference\n                if (renderer) {\n                    value = renderer.call(thisObj || me.thisObj || me, {\n                        [eventRecordProperty] : eventRecord,\n                        resourceRecord        : data.resourceRecord,\n                        assignmentRecord      : data.assignmentRecord,\n                        domConfig\n                    });\n                }\n                else {\n                    value = eventRecord.getValue(field);\n                    // If it's a date, format it according to the Scheduler's defaults\n                    if (fieldDef?.type === 'date' && !renderer) {\n                        value = DateHelper.format(value, me.client.displayDateFormat);\n                    }\n                    else {\n                        value = StringHelper.encodeHtml(value);\n                    }\n                }\n                domConfig.html = value || '\\xa0';\n                configs.push(domConfig);\n            }\n        }\n        return configs;\n    }\n    measureLabels(configs, data) {\n        const\n            me      = this,\n            pxPerMS = me.client.timeAxisViewModel.getSingleUnitInPixels('millisecond');\n        for (const config of configs) {\n            if (layoutSides[config.dataset.side]) {\n                let { html } = config;\n                let length = 0;\n                // Calculate length based on string length\n                if (me.labelLayoutMode === 'estimate') {\n                    // Strip tags before estimating\n                    if (html.includes('<')) {\n                        html = DomHelper.stripTags(html);\n                    }\n                    length = (html.length * me.labelCharWidth) + 18; // 18 = 1.5em, margin from event\n                }\n                // Measure\n                else {\n                    const element = me.labelMeasureElement || (me.labelMeasureElement = DomHelper.createElement({\n                        className : 'b-sch-event-wrap b-measure-label',\n                        parent    : me.client.foregroundCanvas\n                    }));\n                    // Outer DomSync should not remove\n                    element.retainElement = true;\n                    DomSync.sync({\n                        targetElement : element,\n                        domConfig     : {\n                            onlyChildren : true,\n                            children     : [\n                                config\n                            ]\n                        }\n                    });\n                    length = element.firstElementChild.offsetWidth;\n                }\n                // Convert from px to ms\n                const ms = length / pxPerMS;\n                // Adjust values used for event layout (not event position)\n                switch (config.dataset.side) {\n                    case 'before':\n                        data.startMS -= ms;\n                        break;\n                    case 'after':\n                        data.endMS += ms;\n                        break;\n                }\n            }\n        }\n    }\n    onEventDataGenerated(data) {\n        if (!this.disabled && !data.eventRecord?.isResourceTimeRange) {\n            const configs = this.generateLabelConfigs(data);\n            if (layoutModes[this.labelLayoutMode]) {\n                this.measureLabels(configs, data);\n            }\n            data.wrapperChildren.push(...configs);\n        }\n    }\n    updateLabelLayoutMode() {\n        if (!this.isConfiguring) {\n            this.client.refreshWithTransition();\n        }\n    }\n    updateLabelCharWidth() {\n        if (!this.isConfiguring) {\n            this.client.refreshWithTransition();\n        }\n    }\n}\nLabels.featureClass = 'b-sch-labels';\nLabels._$name = 'Labels'; GridFeatureManager.registerFeature(Labels, false, 'Scheduler');\n", "import GridRowReorder from '../../Grid/feature/RowReorder.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport TransactionalFeature from './mixin/TransactionalFeature.js';\n/**\n * @module Scheduler/feature/RowReorder\n */\n/**\n * This feature implements support for project transactions and used by default in Gantt. For general RowReorder feature\n * documentation see {@link Grid.feature.RowReorder}.\n *\n * This feature is **disabled** by default in Scheduler and **enabled** by default in Gantt.\n * For info on enabling it, see {@link Grid/view/mixin/GridFeatures}.\n *\n * @extends Grid/feature/RowReorder\n * @classtype rowReorder\n * @feature\n *\n * @typings Grid.feature.RowReorder -> Grid.feature.GridRowReorder\n */\nexport default class RowReorder extends TransactionalFeature(GridRowReorder) {\n    static $name = 'RowReorder';\n    onDragStart(...args) {\n        super.onDragStart(...args);\n        if (this.client.transactionalFeaturesEnabled) {\n            return this.startFeatureTransaction();\n        }\n    }\n    onDrop(...args) {\n        // Actual reorder will happen in a wrapper function to `tryPropagateWithChanges`, meaning reorder will be a\n        // transaction. This transaction will not even have any changes in it. So we can reject it.\n        this.rejectFeatureTransaction();\n        return super.onDrop(...args);\n    }\n    onAbort(...args) {\n        this.rejectFeatureTransaction();\n        return super.onAbort(...args);\n    }\n}\nRowReorder._$name = 'RowReorder'; GridFeatureManager.registerFeature(RowReorder, false, 'Scheduler');\nGridFeatureManager.registerFeature(RowReorder, true, 'Gantt');\n", "import GridSummary from '../../Grid/feature/Summary.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\n/**\n * @module Scheduler/feature/TimelineSummary\n */\n// noinspection JSClosureCompilerSyntax\n/**\n * Base class, not to be used directly.\n * @extends Grid/feature/Summary\n * @abstract\n */\nexport default class TimelineSummary extends GridSummary {\n    //region Config\n    static get $name() {\n        return 'TimelineSummary';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Show tooltip containing summary values and labels\n             * @config {Boolean}\n             * @default\n             */\n            showTooltip : true\n        };\n    }\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['renderRows', 'updateProject']\n        };\n    }\n    //endregion\n    //region Init\n    construct(client, config) {\n        const me = this;\n        super.construct(client, config);\n        if (!me.summaries) {\n            me.summaries = [{ renderer : me.renderer }];\n        }\n        // Feature might be run from Grid (in docs), should not crash\n        // https://app.assembla.com/spaces/bryntum/tickets/6801/details\n        if (client.isTimelineBase) {\n            me.updateProject(client.project);\n            client.ion({\n                timeAxisViewModelUpdate : me.renderRows,\n                thisObj                 : me\n            });\n        }\n    }\n    //endregion\n    //region Render\n    updateProject(project) {\n        this.detachListeners('summaryProject');\n        project.ion({\n            name      : 'summaryProject',\n            dataReady : 'updateTimelineSummaries',\n            thisObj   : this\n        });\n    }\n    renderRows() {\n        if (this.client.isHorizontal) {\n            this.client.timeAxisSubGrid.footer.element.querySelector('.b-grid-footer').classList.add('b-sch-summarybar');\n        }\n        super.renderRows();\n        if (!this.disabled) {\n            this.render();\n        }\n    }\n    get summaryBarElement() {\n        return this.client.element.querySelector('.b-sch-summarybar');\n    }\n    render() {\n        const\n            me                   = this,\n            { client: timeline } = me,\n            sizeProp             = timeline.isHorizontal ? 'width' : 'height',\n            colCfg               = timeline.timeAxisViewModel.columnConfig,\n            summaryContainer     = me.summaryBarElement;\n        if (summaryContainer) {\n            // if any sum config has a label, init tooltip\n            if (!me._tip && me.showTooltip && me.summaries.some(config => config.label)) {\n                me._tip = new Tooltip({\n                    id             : `${timeline.id}-summary-tip`,\n                    cls            : 'b-timeaxis-summary-tip',\n                    hoverDelay     : 0,\n                    hideDelay      : 100,\n                    forElement     : summaryContainer,\n                    anchorToTarget : true,\n                    trackMouse     : false,\n                    forSelector    : '.b-timeaxis-tick',\n                    getHtml        : ({ activeTarget }) => activeTarget._tipHtml\n                });\n            }\n            summaryContainer.innerHTML = colCfg[colCfg.length - 1].map(col => `<div class=\"b-timeaxis-tick\" style=\"${sizeProp}: ${col.width}px\"></div>`).join('');\n            me.updateTimelineSummaries();\n        }\n    }\n    //endregion\n    /**\n     * Refreshes the summaries\n     */\n    refresh() {\n        super.refresh();\n        this.updateTimelineSummaries();\n    }\n    doDisable(disable) {\n        const { isConfiguring } = this.client;\n        super.doDisable(disable);\n        this.summaryColumn?.toggle(!disable);\n        if (!isConfiguring && !disable) {\n            this.render();\n        }\n    }\n    doDestroy() {\n        this._tip?.destroy();\n        super.doDestroy();\n    }\n}\nTimelineSummary._$name = 'TimelineSummary';", "export const ScheduleRange = {\n    completeview : 'completeview',\n    // completedata : 'completedata',\n    currentview  : 'currentview',\n    daterange    : 'daterange'\n};\n", "import DateHelper from '../../../../Core/helper/DateHelper.js';\nimport Rectangle from '../../../../Core/helper/util/Rectangle.js';\nimport DomHelper from '../../../../Core/helper/DomHelper.js';\nimport DomSync from '../../../../Core/helper/DomSync.js';\nimport { ScheduleRange } from '../Utils.js';\nconst immediatePromise = Promise.resolve();\nexport default base => class SchedulerExporterMixin extends base {\n    async scrollRowIntoView(client, index) {\n        const\n            {\n                rowManager,\n                scrollable\n            }    = client,\n            oldY = scrollable.y;\n        // If it's a valid index to scroll to, then try it.\n        if (index < client.store.count) {\n            // Scroll the requested row to the viewport top\n            scrollable.scrollTo(null, rowManager.calculateTop(index));\n            // If that initiated a scroll, we need to wait for the row to be rendered, so return\n            // a Promise which resolves when that happens.\n            if (scrollable.y !== oldY) {\n                // GridBase adds listener to vertical scroll to update rows. Rows might be or might not be updated,\n                // but at the end of each scroll grid will trigger `scroll` event. So far this is the only scroll event\n                // triggered by the grid itself and it is different from `scroll` event on scrollable.\n                return new Promise(resolve => {\n                    const detacher = client.ion({\n                        scroll({ scrollTop }) {\n                            // future-proof: only react to scroll event with certain argument\n                            if (scrollTop != null && rowManager.getRow(index)) {\n                                detacher();\n                                resolve();\n                            }\n                        }\n                    });\n                });\n            }\n        }\n        // No scroll occurred. Promise must be resolved immediately\n        return immediatePromise;\n    }\n    async scrollToDate(client, date) {\n        let scrollFired = false;\n        const promises    = [];\n        // Time axis is updated on element scroll, which is async event. We need to synchronize this logic.\n        // If element horizontal scroll is changed then sync event is fired. We add listener to that one specific event\n        // and remove it right after scrollToDate sync code, keeping listeners clean. If scrolling occurred, we need\n        // to wait until time header is updated.\n        const detacher = client.timeAxisSubGrid.scrollable.ion({\n            scrollStart({ x }) {\n                if (x != null) {\n                    scrollFired = true;\n                }\n            }\n        });\n        // added `block: start` to do scrolling faster\n        // it moves data to begin of visible area that is longer section for re-render\n        promises.push(client.scrollToDate(date, { block : 'start' }));\n        detacher();\n        if (scrollFired) {\n            // We have to wait for scrollEnd event before moving forward. When exporting large view we might have to scroll\n            // extensively and it might occur that requested scroll position would not be reached because concurrent\n            // scrollEnd events would move scroll back.\n            // scrollEnd is on a 100ms timer *after* the last scroll event fired, so all necessary\n            // updated will have occurred.\n            // Covered by Gantt/tests/feature/export/MultiPageVertical.t.js\n            promises.push(client.timeAxisSubGrid.header.scrollable.await('scrollEnd', { checkLog : false }));\n        }\n        await Promise.all(promises);\n    }\n    cloneElement(element, target, clear) {\n        super.cloneElement(element, target, clear);\n        const clonedEl = this.element.querySelector('.b-schedulerbase');\n        // Remove default animation classes\n        clonedEl?.classList.remove(...['fade-in', 'slide-from-left', 'slide-from-top', 'zoom-in'].map(name => `b-initial-${name}`));\n    }\n    async prepareComponent(config) {\n        const\n            me                     = this,\n            { client }             = config,\n            { currentOrientation } = client,\n            includeTimeline        = client.timeAxisSubGrid.width > 0;\n        switch (config.scheduleRange) {\n            case ScheduleRange.completeview:\n                config.rangeStart = client.startDate;\n                config.rangeEnd   = client.endDate;\n                break;\n            case ScheduleRange.currentview: {\n                const { startDate, endDate } = client.visibleDateRange;\n                config.rangeStart = startDate;\n                config.rangeEnd = endDate;\n                break;\n            }\n        }\n        await client.waitForAnimations();\n        // Disable infinite scroll before export, so it doesn't change time span\n        config.infiniteScroll = client.infiniteScroll;\n        client.infiniteScroll = false;\n        // Don't change timespan if time axis subgrid is not visible\n        if (includeTimeline) {\n            // set new timespan before calling parent to get proper scheduler header/content size\n            client.setTimeSpan(config.rangeStart, config.rangeEnd);\n            if (config.scheduleRange === ScheduleRange.daterange) {\n                // In case time axis is filtered or generated by custom fn we need to adjust passed ranges to actual dates\n                config.rangeStart = client.startDate;\n                config.rangeEnd = client.endDate;\n            }\n            // Access svgCanvas el to create dependency canvas early\n            client.svgCanvas;\n        }\n        // Disable event animations during export\n        me._oldEnableEventAnimations = client.enableEventAnimations;\n        client.enableEventAnimations = false;\n        // Add scroll buffer for the horizontal rendering\n        if (currentOrientation.isHorizontalRendering) {\n            me._oldScrollBuffer = currentOrientation.scrollBuffer;\n            me._oldVerticalBuffer = currentOrientation.verticalBufferSize;\n            currentOrientation.scrollBuffer = 100;\n            currentOrientation.verticalBufferSize = -1;\n        }\n        // Raise flag on the client to render all suggested dependencies\n        client.ignoreViewBox = true;\n        await super.prepareComponent(config);\n        const\n            { exportMeta, element } = me,\n            fgCanvasEl              = element.querySelector('.b-sch-foreground-canvas'),\n            timeAxisEl              = element.querySelector('.b-horizontaltimeaxis');\n        exportMeta.includeTimeline = includeTimeline;\n        if (includeTimeline && config.scheduleRange !== ScheduleRange.completeview) {\n            // If we are exporting subrange of dates we need to change subgrid size accordingly\n            exportMeta.totalWidth -= exportMeta.subGrids.normal.width;\n            exportMeta.totalWidth += exportMeta.subGrids.normal.width = client.timeAxisViewModel.getDistanceBetweenDates(config.rangeStart, config.rangeEnd);\n            const\n                horizontalPages = Math.ceil(exportMeta.totalWidth / exportMeta.pageWidth),\n                totalPages      = horizontalPages * exportMeta.verticalPages;\n            exportMeta.horizontalPages = horizontalPages;\n            exportMeta.totalPages = totalPages;\n            // store left scroll to imitate normal grid/header scroll using margin\n            exportMeta.subGrids.normal.scrollLeft = client.getCoordinateFromDate(config.rangeStart);\n        }\n        exportMeta.timeAxisHeaders = [];\n        exportMeta.timeAxisPlaceholders = [];\n        exportMeta.headersColleted = false;\n        DomHelper.forEachSelector(timeAxisEl, '.b-sch-header-row', headerRow => {\n            exportMeta.timeAxisPlaceholders.push(me.createPlaceholder(headerRow));\n            exportMeta.timeAxisHeaders.push(new Map());\n        });\n        // Add placeholder for events, clear all event elements, but not the entire elements as it contains svg canvas\n        exportMeta.subGrids.normal.eventsPlaceholder = me.createPlaceholder(fgCanvasEl, false);\n        DomHelper.removeEachSelector(fgCanvasEl, '.b-sch-event-wrap,.b-sch-resourcetimerange');\n        DomHelper.removeEachSelector(me.element, '.b-released');\n        exportMeta.eventsBoxes = new Map();\n        exportMeta.client = client;\n        const\n            columnLinesCanvas      = element.querySelector('.b-column-lines-canvas'),\n            timeRangesHeaderCanvas = element.querySelector('.b-sch-timeaxiscolumn .b-sch-timeranges-canvas'),\n            timeRangesBodyCanvas   = element.querySelector('.b-timeaxissubgrid .b-sch-timeranges-canvas');\n        if (client.hasActiveFeature('columnLines') && columnLinesCanvas) {\n            exportMeta.columnLinesPlaceholder = me.createPlaceholder(columnLinesCanvas);\n            exportMeta.columnLines = { lines : new Map(), majorLines : new Map() };\n        }\n        if (client.hasActiveFeature('timeRanges') && timeRangesBodyCanvas) {\n            exportMeta.timeRanges = {};\n            // header is optional\n            if (timeRangesHeaderCanvas) {\n                exportMeta.timeRanges.header = config.enableDirectRendering ? '' : {};\n                exportMeta.timeRangesHeaderPlaceholder = me.createPlaceholder(timeRangesHeaderCanvas);\n            }\n            exportMeta.timeRanges.body = config.enableDirectRendering ? '' : {};\n            exportMeta.timeRangesBodyPlaceholder = me.createPlaceholder(timeRangesBodyCanvas);\n        }\n        if (client.hasActiveFeature('dependencies')) {\n            client.features.dependencies.fillDrawingCache();\n            const svgCanvasEl = element.querySelector(`[id=\"${client.svgCanvas.getAttribute('id')}\"]`);\n            // Same as above, clear only dependency lines, because there might be markers added by user\n            if (svgCanvasEl) {\n                exportMeta.dependencyCanvasEl = svgCanvasEl;\n                exportMeta.dependenciesPlaceholder = me.createPlaceholder(svgCanvasEl, false, {\n                    ns  : 'http://www.w3.org/2000/svg',\n                    tag : 'path'\n                });\n                DomHelper.removeEachSelector(svgCanvasEl, '.b-sch-dependency');\n            }\n        }\n        // We need to scroll component to date to calculate correct start margin\n        if (includeTimeline && !DateHelper.betweenLesser(config.rangeStart, client.startDate, client.endDate)) {\n            await me.scrollToDate(client, config.rangeStart);\n        }\n    }\n    async restoreState(config) {\n        let waitForHorizontalScroll = false;\n        const\n            { client } = config,\n            promises = [];\n        // If scroll will be changed during restoring state (and it will likely be), raise a flag that exporter should\n        // wait for scrollEnd event before releasing control\n        const detacher = client.timeAxisSubGrid.scrollable.ion({\n            scrollStart({ x }) {\n                // HACK: scrollStart might actually fire when scroll is set to existing value\n                if (this.element.scrollLeft !== x) {\n                    waitForHorizontalScroll = true;\n                }\n            }\n        });\n        promises.push(super.restoreState(config));\n        // Scroll start will be fired synchronously\n        detacher();\n        if (waitForHorizontalScroll) {\n            promises.push(client.timeAxisSubGrid.header.scrollable.await('scrollEnd', { checkLog : false }));\n        }\n        await Promise.all(promises);\n    }\n    async restoreComponent(config) {\n        const\n            { client }             = config,\n            { currentOrientation } = client;\n        client.ignoreViewBox = false;\n        client.infiniteScroll = config.infiniteScroll;\n        client.enableEventAnimations = this._oldEnableEventAnimations;\n        if (currentOrientation.isHorizontalRendering) {\n            currentOrientation.scrollBuffer = this._oldScrollBuffer;\n            currentOrientation.verticalBufferSize = this._oldVerticalBuffer;\n        }\n        await super.restoreComponent(config);\n    }\n    async onRowsCollected(rows, config) {\n        const me = this;\n        await super.onRowsCollected(rows, config);\n        // Only collect this data if timeline is visible\n        if (me.exportMeta.includeTimeline) {\n            const\n                { client, enableDirectRendering } = config,\n                { timeView }                      = client,\n                { pageRangeStart, pageRangeEnd }  = me.getCurrentPageDateRange(config);\n            if (enableDirectRendering) {\n                // If first page does not include timeline we don't need to render anything for it\n                if (pageRangeStart && pageRangeEnd) {\n                    me.renderHeaders(config, pageRangeStart, pageRangeEnd);\n                    me.renderLines(config, pageRangeStart, pageRangeEnd);\n                    me.renderRanges(config, pageRangeStart, pageRangeEnd);\n                    me.renderEvents(config, rows, pageRangeStart, pageRangeEnd);\n                }\n            }\n            else {\n                // Exported page may not contain timeline view, in which case we need to fall through\n                if (pageRangeStart) {\n                    let rangeProcessed = false;\n                    await me.scrollToDate(client, pageRangeStart);\n                    // Time axis and events are only rendered for the visible time span\n                    // we need to scroll the view and gather events/timeline elements\n                    // while (timeView.endDate <= config.rangeEnd) {\n                    while (!rangeProcessed) {\n                        me.collectLines(config);\n                        me.collectHeaders(config);\n                        me.collectRanges(config);\n                        me.collectEvents(rows, config);\n                        if (DateHelper.timeSpanContains(timeView.startDate, timeView.endDate, pageRangeStart, pageRangeEnd)) {\n                            rangeProcessed = true;\n                        }\n                        else if (timeView.endDate.getTime() >= pageRangeEnd.getTime()) {\n                            rangeProcessed = true;\n                        }\n                        else {\n                            const endDate = timeView.endDate;\n                            await me.scrollToDate(client, timeView.endDate);\n                            // If timeview end date is same as before scroll it means client is not able to scroll to date\n                            // and will go into infinite loop unless we stop it\n                            if (endDate.getTime() === timeView.endDate.getTime()) {\n                                throw new Error('Could not scroll to date');\n                            }\n                        }\n                    }\n                }\n                await me.scrollToDate(client, config.rangeStart);\n            }\n        }\n    }\n    getCurrentPageDateRange({ rangeStart, rangeEnd, enableDirectRendering, client }) {\n        const\n            me = this,\n            { exportMeta } = me,\n            { horizontalPages, horizontalPosition, pageWidth, subGrids } = exportMeta;\n        let pageRangeStart, pageRangeEnd;\n        // when exporting to multiple pages we only need to scroll sub-range within visible time span\n        if (horizontalPages > 1) {\n            const\n                pageStartX = horizontalPosition * pageWidth,\n                pageEndX   = (horizontalPosition + 1) * pageWidth,\n                // Assuming normal grid is right next to right side of the locked grid\n                // There is also a default splitter\n                normalGridX = subGrids.locked.width + subGrids.locked.splitterWidth;\n            if (pageEndX <= normalGridX) {\n                pageRangeEnd = pageRangeStart = null;\n            }\n            else {\n                const { scrollLeft = 0 } = subGrids.normal;\n                pageRangeStart = client.getDateFromCoordinate(Math.max(pageStartX - normalGridX + scrollLeft, 0));\n                // Extend visible schedule by 20% to cover up possible splitter\n                const multiplier = enableDirectRendering ? 1 : 1.2;\n                pageRangeEnd = client.getDateFromCoordinate((pageEndX - normalGridX + scrollLeft) * multiplier) || rangeEnd;\n            }\n        }\n        else {\n            pageRangeStart = rangeStart;\n            pageRangeEnd   = rangeEnd;\n        }\n        return {\n            pageRangeStart,\n            pageRangeEnd\n        };\n    }\n    prepareExportElement() {\n        const\n            { element, exportMeta }                = this,\n            { id, headerId, footerId, scrollLeft } = exportMeta.subGrids.normal,\n            el                                     = element.querySelector(`[id=\"${id}\"]`);\n        el.querySelectorAll('.b-sch-canvas').forEach(canvasEl => {\n            // Align canvases to last exported row bottom. If no such property exists - remove inline height\n            if (exportMeta.lastExportedRowBottom) {\n                canvasEl.style.height = `${exportMeta.lastExportedRowBottom}px`;\n            }\n            else {\n                canvasEl.style.height = '';\n            }\n            // Simulate horizontal scroll\n            if (scrollLeft) {\n                canvasEl.style.marginLeft = `-${scrollLeft}px`;\n            }\n        });\n        if (scrollLeft) {\n            [headerId, footerId].forEach(id => {\n                const el = element.querySelector(`[id=\"${id}\"] .b-widget-scroller`);\n                if (el) {\n                    el.style.marginLeft = `-${scrollLeft}px`;\n                }\n            });\n        }\n        return super.prepareExportElement();\n    }\n    collectHeaders(config) {\n        const\n            me             = this,\n            { client }     = config,\n            { exportMeta } = me;\n        // We only need to collect headers once, this flag is raised once they are collected along all exported range\n        if (!exportMeta.headersCollected) {\n            const\n                timeAxisEl = client.timeView.element,\n                timeAxisHeaders = exportMeta.timeAxisHeaders;\n            DomHelper.forEachSelector(timeAxisEl, '.b-sch-header-row', (headerRow, index, headerRows) => {\n                const headersMap = timeAxisHeaders[index];\n                DomHelper.forEachSelector(headerRow, '.b-sch-header-timeaxis-cell', el => {\n                    if (!headersMap.has(el.dataset.tickIndex)) {\n                        headersMap.set(el.dataset.tickIndex, el.outerHTML);\n                    }\n                });\n                if (index === headerRows.length - 1 && headersMap.has(String(client.timeAxis.count - 1))) {\n                    exportMeta.headersCollected = true;\n                }\n            });\n        }\n    }\n    collectRanges(config) {\n        const\n            me             = this,\n            { client }     = config,\n            { exportMeta } = me,\n            { timeRanges } = exportMeta;\n        if (!exportMeta.headersCollected && timeRanges) {\n            const\n                { headerCanvas, bodyCanvas } = client.features.timeRanges;\n            if (headerCanvas) {\n                DomHelper.forEachSelector(headerCanvas, '.b-sch-timerange', el => {\n                    timeRanges.header[el.dataset.id] = el.outerHTML;\n                });\n            }\n            DomHelper.forEachSelector(bodyCanvas, '.b-sch-timerange', el => {\n                timeRanges.body[el.dataset.id] = el.outerHTML;\n            });\n        }\n    }\n    collectLines(config) {\n        const\n            me              = this,\n            { client }      = config,\n            { exportMeta }  = me,\n            { columnLines } = exportMeta;\n        if (!exportMeta.headersCollected && columnLines) {\n            client.timeAxisSubGridElement.querySelectorAll('.b-column-line, .b-column-line-major').forEach(lineEl  => {\n                if (lineEl.classList.contains('b-column-line')) {\n                    const lineIndex = Number(lineEl.dataset.line.replace(/line-/, ''));\n                    columnLines.lines.set(lineIndex, lineEl.outerHTML);\n                }\n                else {\n                    const lineIndex = Number(lineEl.dataset.line.replace(/major-/, ''));\n                    columnLines.majorLines.set(lineIndex, lineEl.outerHTML);\n                }\n            });\n        }\n    }\n    collectEvents(rows, config) {\n        const\n            me         = this,\n            addedRows  = rows.length,\n            { client } = config,\n            normalRows = me.exportMeta.subGrids.normal.rows;\n        rows.forEach((row, index) => {\n            const\n                rowConfig = normalRows[normalRows.length - addedRows + index],\n                resource  = client.store.getAt(row.dataIndex),\n                eventsMap = rowConfig[3];\n            resource.events?.forEach(event => {\n                if (event.isScheduled) {\n                    let el = client.getElementFromEventRecord(event, resource);\n                    if (el && (el = el.parentElement) && !eventsMap.has(event.id)) {\n                        eventsMap.set(event.id, [el.outerHTML, Rectangle.from(el, el.offsetParent)]);\n                    }\n                }\n            });\n            resource.timeRanges?.forEach(timeRange => {\n                const\n                    elId = client.features.resourceTimeRanges?.generateElementId(timeRange) || '',\n                    el   = client.foregroundCanvas.syncIdMap[elId];\n                if (el && !eventsMap.has(elId)) {\n                    eventsMap.set(elId, [el.outerHTML, Rectangle.from(el, el.offsetParent)]);\n                }\n            });\n        });\n    }\n    //#region Direct rendering\n    renderHeaders(config, start, end) {\n        const\n            me               = this,\n            { exportMeta }   = me,\n            { client }       = config,\n            timeAxisHeaders  = exportMeta.timeAxisHeaders,\n            // Get the time axis view reference that we will use to build cells for specific time ranges\n            { timeAxisView } = client.timeAxisColumn,\n            domConfig        = timeAxisView.buildCells(start, end),\n            targetElement    = document.createElement('div');\n        DomSync.sync({\n            targetElement,\n            domConfig\n        });\n        DomHelper.forEachSelector(targetElement, '.b-sch-header-row', (headerRow, index) => {\n            const headersMap = timeAxisHeaders[index];\n            DomHelper.forEachSelector(headerRow, '.b-sch-header-timeaxis-cell', el => {\n                if (!headersMap.has(el.dataset.tickIndex)) {\n                    headersMap.set(el.dataset.tickIndex, el.outerHTML);\n                }\n            });\n        });\n    }\n    renderEvents(config, rows, start, end) {\n        const\n            me         = this,\n            { client } = config,\n            normalRows = me.exportMeta.subGrids.normal.rows;\n        rows.forEach((row, index) => {\n            const\n                rowConfig      = normalRows[index],\n                eventsMap      = rowConfig[3],\n                resource       = client.store.getAt(row.dataIndex),\n                resourceLayout = client.currentOrientation.getResourceLayout(resource),\n                left           = client.getCoordinateFromDate(start),\n                right          = client.getCoordinateFromDate(end),\n                eventDOMConfigs = client.currentOrientation.getEventDOMConfigForCurrentView(resourceLayout, row, left, right),\n                targetElement   = document.createElement('div');\n            eventDOMConfigs.forEach(domConfig => {\n                const\n                    { eventId }                  = domConfig.dataset,\n                    { left, top, width, height } = domConfig.style;\n                DomSync.sync({\n                    targetElement,\n                    domConfig\n                });\n                eventsMap.set(eventId, [targetElement.outerHTML, new Rectangle(left, top, width, height)]);\n            });\n        });\n    }\n    renderLines(config, start, end) {\n        const\n            me              = this,\n            { client }      = config,\n            { exportMeta }  = me,\n            { columnLines } = exportMeta;\n        if (columnLines) {\n            const\n                domConfigs    = client.features.columnLines.getColumnLinesDOMConfig(start, end),\n                targetElement = document.createElement('div');\n            DomSync.sync({\n                targetElement,\n                domConfig : {\n                    onlyChildren : true,\n                    children     : domConfigs\n                }\n            });\n            // Put all lines HTML to a single key in the set. That allows us to share code path with legacy export mode\n            columnLines.lines.set(0, targetElement.innerHTML);\n        }\n    }\n    renderRanges(config, start, end) {\n        const\n            me             = this,\n            { client }     = config,\n            { exportMeta } = me,\n            { timeRanges } = exportMeta;\n        if (timeRanges) {\n            const\n                domConfigs    = client.features.timeRanges.getDOMConfig(start, end),\n                targetElement = document.createElement('div');\n            // domConfigs is an array of two elements - first includes time range configs for body, second - for head\n            domConfigs.forEach((children, i) => {\n                DomSync.sync({\n                    targetElement,\n                    domConfig : {\n                        children,\n                        onlyChildren : true\n                    }\n                });\n                // body configs\n                if (i === 0) {\n                    timeRanges.body = targetElement.innerHTML;\n                }\n                // header configs\n                else {\n                    timeRanges.header = targetElement.innerHTML;\n                }\n            });\n        }\n    }\n    //#endregion\n    buildPageHtml(config) {\n        const\n            me = this,\n            {\n                subGrids,\n                timeAxisHeaders,\n                timeAxisPlaceholders,\n                columnLines,\n                columnLinesPlaceholder,\n                timeRanges,\n                timeRangesHeaderPlaceholder,\n                timeRangesBodyPlaceholder\n            }  = me.exportMeta,\n            { enableDirectRendering } = config;\n        // Now when rows are collected, we need to add them to exported grid\n        let html = me.prepareExportElement();\n        Object.values(subGrids).forEach(({ placeHolder, eventsPlaceholder, rows, mergedCellsHtml }) => {\n            const\n                placeHolderText       = placeHolder.outerHTML,\n                // Rows can be repositioned, in which case event related to that row should also be translated\n                { resources, events } = me.positionRows(rows, config);\n            let contentHtml =  resources.join('');\n            if (mergedCellsHtml?.length) {\n                contentHtml += `<div class=\"b-grid-merged-cells-container\">${mergedCellsHtml.join('')}</div>`;\n            }\n            html = html.replace(placeHolderText, contentHtml);\n            if (eventsPlaceholder) {\n                html = html.replace(eventsPlaceholder.outerHTML, events.join(''));\n            }\n        });\n        timeAxisHeaders.forEach((headers, index) => {\n            html = html.replace(timeAxisPlaceholders[index].outerHTML, Array.from(headers.values()).join(''));\n        });\n        if (columnLines) {\n            const lineElements = Array.from(columnLines.lines.values()).concat(Array.from(columnLines.majorLines.values()));\n            html = html.replace(columnLinesPlaceholder.outerHTML, lineElements.join(''));\n            // Lines are collected once for old mode, don't clear them\n            if (enableDirectRendering) {\n                me.exportMeta.columnLines.lines.clear();\n                me.exportMeta.columnLines.majorLines.clear();\n            }\n        }\n        if (timeRanges) {\n            if (enableDirectRendering) {\n                html = html.replace(timeRangesBodyPlaceholder.outerHTML, timeRanges.body);\n                // time ranges header element is optional\n                if (timeRangesHeaderPlaceholder) {\n                    html = html.replace(timeRangesHeaderPlaceholder.outerHTML, timeRanges.header);\n                }\n                me.exportMeta.timeRanges = {};\n            }\n            else {\n                html = html.replace(timeRangesBodyPlaceholder.outerHTML, Object.values(timeRanges.body).join(''));\n                // time ranges header element is optional\n                if (timeRangesHeaderPlaceholder) {\n                    html = html.replace(timeRangesHeaderPlaceholder.outerHTML, Object.values(timeRanges.body).join(''));\n                }\n            }\n        }\n        html = me.buildDependenciesHtml(html);\n        return html;\n    }\n    getEventBox(event) {\n        const\n            me = this,\n            {\n                eventsBoxes,\n                enableDirectRendering\n            } = me.exportMeta;\n        const box = event && eventsBoxes.get(String(event.id));\n        // In scheduler milestone box left edge is aligned with milestone start date. Later element is rotated and\n        // shifted by CSS by 50% of its width. Dependency feature relies on actual element sizes, but pdf export\n        // does not render actual elements. Therefore, we need to adjust the box.\n        if (enableDirectRendering && box && event.isMilestone) {\n            box.translate(-box.width / 2, 0);\n        }\n        return box;\n    }\n    renderDependencies() {\n        const\n            me                = this,\n            {\n                client,\n                eventsBoxes\n            }                 = me.exportMeta,\n            { dependencies }  = client,\n            dependencyFeature = client.features.dependencies,\n            targetElement     = DomHelper.createElement();\n        let draw = false;\n        dependencies.forEach(dependency => {\n            if ((!eventsBoxes.has(String(dependency.from)) &&\n                !eventsBoxes.has(String(dependency.to))) ||\n                !dependencyFeature.isDependencyVisible(dependency)) {\n                return;\n            }\n            const\n                fromBox = me.getEventBox(dependency.fromEvent),\n                toBox   = me.getEventBox(dependency.toEvent);\n            dependencyFeature.drawDependency(dependency, true, { from : fromBox?.clone(), to : toBox?.clone() });\n            draw = true;\n        });\n        // Force dom sync\n        if (draw) {\n            dependencyFeature.domSync(targetElement, true);\n        }\n        return targetElement.innerHTML;\n    }\n    buildDependenciesHtml(html) {\n        const { dependenciesPlaceholder, includeTimeline } = this.exportMeta;\n        if (dependenciesPlaceholder && includeTimeline) {\n            const placeholder = dependenciesPlaceholder.outerHTML;\n            html = html.replace(placeholder, this.renderDependencies());\n        }\n        return html;\n    }\n};\n", "import GridMultiPageExporter from '../../../../Grid/feature/export/exporter/MultiPageExporter.js';\nimport SchedulerExporterMixin from './SchedulerExporterMixin.js';\n/**\n * @module Scheduler/feature/export/exporter/MultiPageExporter\n */\n/**\n * A multiple page exporter. Used by the {@link Scheduler.feature.export.PdfExport} feature to export to multiple pages.\n * You do not need to use this class directly.\n *\n * ### Extending exporter\n *\n * ```javascript\n * class MyMultiPageExporter extends MultiPageExporter {\n *     // type is required for exporter\n *     static get type() {\n *         return 'mymultipageexporter';\n *     }\n *\n *     get stylesheets() {\n *         const stylesheets = super.stylesheets;\n *\n *         stylesheets.forEach(styleNodeOrLinkTag => doSmth(styleNodeOrLinkTag))\n *\n *         return stylesheets;\n *     }\n * }\n *\n * const scheduler = new Scheduler({\n *     features : {\n *         pdfExport : {\n *             // this export feature is configured with only one exporter\n *             exporters : [MyMultiPageExporter]\n *         }\n *     }\n * });\n *\n * // run export with the new exporter\n * scheduler.features.pdfExport.export({ exporter : 'mymultipageexporter' });\n * ```\n *\n * @classtype multipage\n * @extends Grid/feature/export/exporter/MultiPageExporter\n *\n * @typings Grid.feature.export.exporter.MultiPageExporter -> Grid.feature.export.exporter.GridMultiPageExporter\n */\nexport default class MultiPageExporter extends SchedulerExporterMixin(GridMultiPageExporter) {\n    static get $name() {\n        return 'MultiPageExporter';\n    }\n    static get type() {\n        return 'multipage';\n    }\n    async stateNextPage(config) {\n        await super.stateNextPage(config);\n        this.exportMeta.eventsBoxes.clear();\n    }\n    positionRows(rows) {\n        const\n            resources   = [],\n            events      = [];\n        // In case of variable row height row vertical position is not guaranteed to increase\n        // monotonously. Position row manually instead\n        rows.forEach(([html, top, height, eventsHtml]) => {\n            resources.push(html);\n            eventsHtml && Array.from(eventsHtml.entries()).forEach(([key, [html, box, extras = []]]) => {\n                events.push(html + extras.join(''));\n                // Store event box to render dependencies later\n                this.exportMeta.eventsBoxes.set(String(key), box);\n            });\n        });\n        return { resources, events };\n    }\n}\nMultiPageExporter._$name = 'MultiPageExporter';", "import GridMultiPageVerticalExporter from '../../../../Grid/feature/export/exporter/MultiPageVerticalExporter.js';\nimport SchedulerExporterMixin from './SchedulerExporterMixin.js';\nimport { ScheduleRange } from '../Utils.js';\n/**\n * @module Scheduler/feature/export/exporter/MultiPageVerticalExporter\n */\n/**\n * A vertical multiple page exporter. Used by the {@link Scheduler.feature.export.PdfExport} feature to export to\n * multiple pages. Content will be scaled in a horizontal direction to fit the page.\n *\n * You do not need to use this class directly.\n *\n * ### Extending exporter\n *\n * ```javascript\n * class MyMultiPageVerticalExporter extends MultiPageVerticalExporter {\n *     // type is required for exporter\n *     static get type() {\n *         return 'mymultipageverticalexporter';\n *     }\n *\n *     get stylesheets() {\n *         const stylesheets = super.stylesheets;\n *\n *         stylesheets.forEach(styleNodeOrLinkTag => doSmth(styleNodeOrLinkTag))\n *\n *         return stylesheets;\n *     }\n * }\n *\n * const scheduler = new Scheduler({\n *     features : {\n *         pdfExport : {\n *             // this export feature is configured with only one exporter\n *             exporters : [MyMultiPageVerticalExporter]\n *         }\n *     }\n * });\n *\n * // run export with the new exporter\n * scheduler.features.pdfExport.export({ exporter : 'mymultipageverticalexporter' });\n * ```\n *\n * @classtype multipagevertical\n * @extends Grid/feature/export/exporter/MultiPageVerticalExporter\n *\n * @typings Grid.feature.export.exporter.MultiPageVerticalExporter -> Grid.feature.export.exporter.GridMultiPageVerticalExporter\n */\nexport default class MultiPageVerticalExporter extends SchedulerExporterMixin(GridMultiPageVerticalExporter) {\n    static get $name() {\n        return 'MultiPageVerticalExporter';\n    }\n    static get type() {\n        return 'multipagevertical';\n    }\n    async stateNextPage(config) {\n        await super.stateNextPage(config);\n        this.exportMeta.eventsBoxes.clear();\n    }\n    async prepareComponent(config) {\n        await super.prepareComponent(config);\n        // Scheduler exporter mixin can update totalWidth, so we need to adjust pages and scale here again\n        if (config.scheduleRange !== ScheduleRange.completeview) {\n            this.estimateTotalPages(config);\n        }\n    }\n    positionRows(rows) {\n        const\n            resources   = [],\n            events      = [];\n        // In case of variable row height row vertical position is not guaranteed to increase\n        // monotonously. Position row manually instead\n        rows.forEach(([html, , , eventsHtml]) => {\n            resources.push(html);\n            eventsHtml && Array.from(eventsHtml.entries()).forEach(([key, [html, box, extras = []]]) => {\n                events.push(html + extras.join(''));\n                // Store event box to render dependencies later\n                this.exportMeta.eventsBoxes.set(String(key), box);\n            });\n        });\n        return { resources, events };\n    }\n}\nMultiPageVerticalExporter._$name = 'MultiPageVerticalExporter';", "import { ScheduleRange } from '../../../feature/export/Utils.js';\nimport Combo from '../../../../Core/widget/Combo.js';\nexport default class ScheduleRangeCombo extends Combo {\n    static get $name() {\n        return 'ScheduleRangeCombo';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'schedulerangecombo';\n    }\n    static get defaultConfig() {\n        return {\n            editable              : false,\n            localizeDisplayFields : true,\n            displayField          : 'text',\n            buildItems() {\n                return Object.entries(ScheduleRange).map(([id, text]) => ({ value : id, text : 'L{' + text + '}' }));\n            }\n        };\n    }\n}\n// Register this widget type with its Factory\nScheduleRangeCombo.initClass();\nScheduleRangeCombo._$name = 'ScheduleRangeCombo';", "import DateHelper from '../../../Core/helper/DateHelper.js';\nimport GridExportDialog from '../../../Grid/view/export/ExportDialog.js';\nimport { ScheduleRange } from '../../feature/export/Utils.js';\nimport '../../view/export/field/ScheduleRangeCombo.js';\nimport Field from '../../../Core/widget/Field.js';\n/**\n * @module Scheduler/view/export/SchedulerExportDialog\n */\n/**\n * Extends the Grid's {@link Grid.view.export.ExportDialog} and adds a few extra fields specific to the scheduler.\n *\n * ## Default widgets\n *\n * The default widgets of this dialog are:\n *\n * | Widget ref             | Type                                     | Weight | Description                                          |\n * |------------------------|------------------------------------------|--------|----------------------------------------------------- |\n * | `columnsField`         | {@link Core.widget.Combo Combo}          | 100    | Choose columns to export                             |\n * | `scheduleRangeField`   | {@link Core.widget.Combo Combo}          | 150    | Choose date range to export                          |\n * | `rangesContainer`      | {@link Core.widget.Container Container}  | 151    | Container for range fields                           |\n * | \\>`rangeStartField`    | {@link Core.widget.DateField DateField}  | 10     | Choose date range start                              |\n * | \\>`rangeEndField`      | {@link Core.widget.DateField DateField}  | 30     | Choose date range end                                |\n * | `rowsRangeField`       | {@link Core.widget.Combo Combo}          | 200    | Choose which rows to export                          |\n * | `exporterTypeField`    | {@link Core.widget.Combo Combo}          | 300    | Type of the exporter to use                          |\n * | `alignRowsField`       | {@link Core.widget.Checkbox Checkbox}    | 400    | Align row top to the page top on every exported page |\n * | `repeatHeaderField`    | {@link Core.widget.Checkbox Checkbox}    | 500    | Toggle repeating headers on / off                    |\n * | `fileFormatField`      | {@link Core.widget.Combo Combo}          | 600    | Choose file format                                   |\n * | `paperFormatField`     | {@link Core.widget.Combo Combo}          | 700    | Choose paper format                                  |\n * | `orientationField`     | {@link Core.widget.Combo Combo}          | 800    | Choose orientation                                   |\n *\n * The default buttons are:\n *\n * | Widget ref             | Type                                     | Weight | Description                                          |\n * |------------------------|------------------------------------------|--------|------------------------------------------------------|\n * | `exportButton`         | {@link Core.widget.Button Button}        | 100    | Triggers export                                      |\n * | `cancelButton`         | {@link Core.widget.Button Button}        | 200    | Cancel export                                        |\n *\n * *\\> nested items*\n *\n * ## Configuring default widgets\n *\n * Widgets can be customized with {@link Scheduler.feature.export.PdfExport#config-exportDialog} config:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         pdfExport : {\n *             exportDialog : {\n *                 items : {\n *                     // hide the field\n *                     orientationField  : { hidden : true },\n *\n *                     // reorder fields\n *                     exporterTypeField : { weight : 150 },\n *\n *                     // change default format in exporter\n *                     fileFormatField   : { value : 'png' },\n *\n *                     // Configure nested fields\n *                     rangesContainer : {\n *                         items : {\n *                             rangeStartField : { value : new Date() },\n *                             rangeEndField : { value : new Date() }\n *                         }\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n *\n * scheduler.features.pdfExport.showExportDialog();\n * ```\n *\n * ## Using DateTime fields for range start/end\n *\n * This config system is also capable (but not limited to) of changing layout of the container and replacing widget type:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         pdfExport : {\n *             exportDialog : {\n *                 items : {\n *                     rangesContainer : {\n *                         // DateTime fields are longer, so we better lay them out\n *                         // vertically\n *                         layoutStyle : {\n *                             flexDirection : 'column'\n *                         },\n *                         items : {\n *                             rangeStartField : {\n *                                 // Use DateTime widget for ranges\n *                                 type       : 'datetime',\n *\n *                                 // Sync label width with other fields\n *                                 labelWidth : '12em'\n *                             },\n *                             rangeEndField : {\n *                                 type       : 'datetime',\n *                                 labelWidth : '12em'\n *                             },\n *                             // Add a filler widget that would add a margin at the bottom\n *                             filler : {\n *                                 height : '0.6em',\n *                                 weight : 900\n *                             }\n *                         }\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n *\n * ```\n *\n * ## Configuring default columns\n *\n * By default all visible columns are selected in the export dialog. This is managed by\n * {@link #config-autoSelectVisibleColumns} config. To change default selected columns you should disable this config\n * and set field value. Value should be an array of valid column ids (or column instances). This way you can\n * preselect hidden columns:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     columns : [\n *         { id : 'name', text : 'Name', field : 'name' },\n *         { id : 'age', text : 'Age', field : 'age' },\n *         { id : 'city', text : 'City', field : 'city', hidden : true }\n *     ],\n *     features : {\n *         pdfExport : {\n *             exportDialog : {\n *                 autoSelectVisibleColumns : false,\n *                 items : {\n *                     columnsField : { value : ['name', 'city'] }\n *                 }\n *             }\n *         }\n *     }\n * })\n *\n * // This will show export dialog with Name and City columns selected\n * // even though City column is hidden in the UI\n * scheduler.features.pdfExport.showExportDialog();\n * ```\n *\n * ## Adding fields\n *\n * You can add your own fields to the export dialog. To make such field value acessible to the feature it should follow\n * naming pattern - it should have `ref` config ending with `Field`, see other fields for reference - `orientationField`,\n * `columnsField`, etc. Fields not matching this pattern are ignored. When values are collected from the dialog, `Field`\n * part of the widget reference is removed, so `orientationField` becomes `orientation`, `fooField` becomes `foo`, etc.\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             exportDialog : {\n *                 items : {\n *                     // This field gets into export config\n *                     fooField : {\n *                         type : 'text',\n *                         label : 'Foo',\n *                         value : 'FOO'\n *                     },\n *\n *                     // This one does not, because name doesn't end with `Field`\n *                     bar : {\n *                         type : 'text',\n *                         label : 'Bar',\n *                         value : 'BAR'\n *                     },\n *\n *                     // Add a container widget to wrap some fields together\n *                     myContainer : {\n *                         type : 'container',\n *                         items : {\n *                             // This one gets into config too despite the nesting level\n *                             bazField : {\n *                                 type : 'text',\n *                                 label : 'Baz',\n *                                 value : 'BAZ'\n *                             }\n *                         }\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n *\n * // Assuming export dialog is opened and export triggered with default values\n * // you can receive custom field values here\n * grid.on({\n *     beforePdfExport({ config }) {\n *         console.log(config.foo) // 'FOO'\n *         console.log(config.bar) // undefined\n *         console.log(config.baz) // 'BAZ'\n *     }\n * });\n * ```\n *\n * ## Configuring widgets at runtime\n *\n * If you don't know column ids before grid instantiation or you want a flexible config, you can change widget values\n * before dialog pops up:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     columns : [\n *         { id : 'name', text : 'Name', field : 'name' },\n *         { id : 'age', text : 'Age', field : 'age' },\n *         { id : 'city', text : 'City', field : 'city', hidden : true }\n *     ],\n *     features : {\n *         pdfExport : true\n *     }\n * });\n *\n * // Such listener would ignore autoSelectVisibleColumns config. Similar to the snippet\n * // above this will show Name and City columns\n * scheduler.features.pdfExport.exportDialog.on({\n *     beforeShow() {\n *         this.widgetMap.columnsField.value = ['age', 'city']\n *     }\n * });\n * ```\n *\n * @extends Grid/view/export/ExportDialog\n */\nexport default class SchedulerExportDialog extends GridExportDialog {\n    //region Config\n    static get $name() {\n        return 'SchedulerExportDialog';\n    }\n    static get type() {\n        return 'schedulerexportdialog';\n    }\n    static get configurable() {\n        return {\n            defaults : {\n                localeClass : this\n            },\n            items : {\n                scheduleRangeField : {\n                    type   : 'schedulerangecombo',\n                    label  : 'L{Schedule range}',\n                    name   : 'scheduleRange',\n                    value  : 'completeview',\n                    weight : 150,\n                    onChange({ value }) {\n                        this.parent.widgetMap.rangesContainer.hidden = value !== ScheduleRange.daterange;\n                    }\n                },\n                rangesContainer : {\n                    type     : 'container',\n                    flex     : '1 0 100%',\n                    weight   : 151,\n                    hidden   : true,\n                    defaults : {\n                        localeClass : this\n                    },\n                    items : {\n                        filler : {\n                            // Filler widget to align date fields\n                            weight : 0,\n                            type   : 'widget',\n                            style  : 'margin-inline-end: -1em;'\n                        },\n                        rangeStartField : {\n                            type       : 'datefield',\n                            label      : 'L{Export from}',\n                            name       : 'rangeStart',\n                            labelWidth : '3em',\n                            flex       : '1 0 25%',\n                            weight     : 10,\n                            onChange({ value }) {\n                                this.parent.widgetMap.rangeEndField.min = DateHelper.add(value, 1, 'd');\n                            }\n                        },\n                        rangeEndField : {\n                            type       : 'datefield',\n                            label      : 'L{Export to}',\n                            name       : 'rangeEnd',\n                            labelWidth : '1em',\n                            flex       : '1 0 25%',\n                            weight     : 30,\n                            onChange({ value }) {\n                                this.parent.widgetMap.rangeStartField.max = DateHelper.add(value, -1, 'd');\n                            }\n                        }\n                    }\n                }\n            }\n        };\n    }\n    //endregion\n    onLocaleChange() {\n        const\n            labelWidth = this.L('labelWidth');\n        this.width = this.L('L{width}');\n        this.items.forEach(widget => {\n            if (widget instanceof Field) {\n                widget.labelWidth = labelWidth;\n            }\n            else if (widget.ref === 'rangesContainer') {\n                widget.items[0].width = labelWidth;\n            }\n        });\n    }\n    applyInitialValues(config) {\n        super.applyInitialValues(config);\n        const\n            me                   = this,\n            {\n                client,\n                scheduleRange\n            }                    = config,\n            items                = config.items = config.items || {},\n            scheduleRangeField   = items.scheduleRangeField = items.scheduleRangeField || {},\n            rangesContainer      = items.rangesContainer = items.rangesContainer || {},\n            rangesContainerItems = rangesContainer.items = rangesContainer.items || {},\n            filler               = rangesContainerItems.filler = rangesContainerItems.filler || {},\n            rangeStartField      = rangesContainerItems.rangeStartField = rangesContainerItems.rangeStartField || {},\n            rangeEndField        = rangesContainerItems.rangeEndField = rangesContainerItems.rangeEndField || {};\n        filler.width = me.L('labelWidth');\n        scheduleRangeField.value = scheduleRangeField.value || scheduleRange;\n        if (scheduleRangeField.value === ScheduleRange.daterange) {\n            rangesContainer.hidden = false;\n        }\n        const rangeStart = rangeStartField.value = rangeStartField.value || client.startDate;\n        rangeStartField.max = DateHelper.max(client.startDate, DateHelper.add(client.endDate, -1, 'd'));\n        let rangeEnd = rangeEndField.value || client.endDate;\n        // This is the only place where we can validate date range before it gets to export feature\n        if (rangeEnd <= rangeStart) {\n            rangeEnd = DateHelper.add(rangeStart, 1, 'd');\n        }\n        rangeEndField.value = rangeEnd;\n        rangeEndField.min   = DateHelper.min(client.endDate, DateHelper.add(client.startDate, 1, 'd'));\n    }\n}\nSchedulerExportDialog._$name = 'SchedulerExportDialog';", "import GridSinglePageExporter from '../../../../Grid/feature/export/exporter/SinglePageExporter.js';\nimport SchedulerExporterMixin from './SchedulerExporterMixin.js';\n/**\n * @module Scheduler/feature/export/exporter/SinglePageExporter\n */\n/**\n * A single page exporter. Used by the {@link Scheduler.feature.export.PdfExport} feature to export to single page.\n * Content will be scaled in both directions to fit the page.\n *\n * You do not need to use this class directly.\n *\n * ### Extending exporter\n *\n * ```javascript\n * class MySinglePageExporter extends SinglePageExporter {\n *     // type is required for exporter\n *     static get type() {\n *         return 'mysinglepageexporter';\n *     }\n *\n *     get stylesheets() {\n *         const stylesheets = super.stylesheets;\n *\n *         stylesheets.forEach(styleNodeOrLinkTag => doSmth(styleNodeOrLinkTag))\n *\n *         return stylesheets;\n *     }\n * }\n *\n * const scheduler = new Scheduler({\n *     features : {\n *         pdfExport : {\n *             // this export feature is configured with only one exporter\n *             exporters : [MySinglePageExporter]\n *         }\n *     }\n * });\n *\n * // run export with the new exporter\n * scheduler.features.pdfExport.export({ exporter : 'mysinglepageexporter' });\n * ```\n *\n * @classtype singlepage\n * @extends Grid/feature/export/exporter/SinglePageExporter\n *\n * @typings Grid.feature.export.exporter.SinglePageExporter -> Grid.feature.export.exporter.GridSinglePageExporter\n */\nexport default class SinglePageExporter extends SchedulerExporterMixin(GridSinglePageExporter) {\n    static get $name() {\n        return 'SinglePageExporter';\n    }\n    static get type() {\n        return 'singlepage';\n    }\n    // We should not collect dependencies per each page, instead we'd render them once\n    collectDependencies() {}\n    positionRows(rows, config) {\n        const\n            resources   = [],\n            events      = [],\n            translateRe = /translate\\((\\d+.?\\d*)px, (\\d+.?\\d*)px\\)/,\n            topRe       = /top:.+?px/;\n        if (config.enableDirectRendering) {\n            rows.forEach(([html, , , eventsHtml]) => {\n                resources.push(html);\n                eventsHtml && Array.from(eventsHtml.entries()).forEach(([key, [html, box, extras = []]]) => {\n                    // Store event box to render dependencies later\n                    this.exportMeta.eventsBoxes.set(String(key), box);\n                    events.push(html + extras.join(''));\n                });\n            });\n        }\n        else {\n            let currentTop = 0;\n            // In case of variable row height row vertical position is not guaranteed to increase\n            // monotonously. Position row manually instead\n            rows.forEach(([html, top, height, eventsHtml]) => {\n                // Adjust row vertical position by changing `translate` style\n                resources.push(html.replace(translateRe, `translate($1px, ${currentTop}px)`));\n                const rowTopDelta = currentTop - top;\n                eventsHtml && Array.from(eventsHtml.entries()).forEach(([key, [html, box]]) => {\n                    // Fix event vertical position according to the row top\n                    box.translate(0, rowTopDelta);\n                    // Store event box to render dependencies later\n                    this.exportMeta.eventsBoxes.set(String(key), box);\n                    // Adjust event vertical position by replacing `top` style\n                    events.push(html.replace(topRe, `top: ${box.y}px`));\n                });\n                currentTop += height;\n            });\n        }\n        return { resources, events };\n    }\n}\nSinglePageExporter._$name = 'SinglePageExporter';", "import GridPdfExport from '../../../Grid/feature/export/PdfExport.js';\nimport GridFeatureManager from '../../../Grid/feature/GridFeatureManager.js';\nimport SchedulerExportDialog from '../../view/export/SchedulerExportDialog.js';\nimport SinglePageExporter from './exporter/SinglePageExporter.js';\nimport MultiPageExporter from './exporter/MultiPageExporter.js';\nimport MultiPageVerticalExporter from './exporter/MultiPageVerticalExporter.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/feature/export/PdfExport\n */\n/**\n * Generates PDF/PNG files from the Scheduler component.\n *\n * <img src=\"Scheduler/export-dialog.png\" style=\"max-width : 300px\" alt=\"Scheduler Export dialog\">\n *\n * **NOTE:** Server side is required to make export work!\n *\n * Check out PDF Export Server documentation and installation steps [here](https://github.com/bryntum/pdf-export-server#pdf-export-server)\n *\n * When your server is up and running, it listens to requests. The Export feature sends a request to the specified URL\n * with the HTML fragments. The server generates a PDF (or PNG) file and returns a download link (or binary, depending\n * on {@link #config-sendAsBinary} config). Then the Export feature opens the link in a new tab and the file is\n * automatically downloaded by your browser. This is configurable, see {@link #config-openAfterExport} config.\n *\n * The {@link #config-exportServer} URL must be configured. The URL can be localhost if you start the server locally,\n * or your remote server address.\n *\n * ## Usage\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         pdfExport : {\n *             exportServer : 'http://localhost:8080' // Required\n *         }\n *     }\n * })\n *\n * // Opens popup allowing to customize export settings\n * scheduler.features.pdfExport.showExportDialog();\n *\n * // Simple export\n * scheduler.features.pdfExport.export({\n *     // Required, set list of column ids to export\n *     columns : scheduler.columns.map(c => c.id)\n * }).then(result => {\n *     // Response instance and response content in JSON\n *     let { response, responseJSON } = result;\n * });\n * ```\n *\n * Appends configs related to exporting time axis: {@link #config-scheduleRange}, {@link #config-rangeStart},\n * {@link #config-rangeEnd}\n *\n * ## Loading resources\n *\n * If you face a problem with loading resources when exporting, the cause might be that the application and the export server are hosted on different servers.\n * This is due to [Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) (CORS). There are 2 options how to handle this:\n * - Allow cross-origin requests from the server where your export is hosted to the server where your application is hosted;\n * - Copy all resources keeping the folder hierarchy from the server where your application is hosted to the server where your export is hosted\n * and setup paths using {@link Grid.feature.export.PdfExport#config-translateURLsToAbsolute} config and configure the export server to give access to the path:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         pdfExport : {\n *             exportServer : 'http://localhost:8080',\n *             // '/resources' is hardcoded in WebServer implementation\n *             translateURLsToAbsolute : 'http://localhost:8080/resources'\n *         }\n *     }\n * })\n * ```\n *\n * ```javascript\n * // Following path would be served by this address: http://localhost:8080/resources/\n * node ./src/server.js -h 8080 -r web/application/styles\n * ```\n *\n * where `web/application/styles` is a physical root location of the copied resources, for example:\n *\n * <img src=\"Grid/export-server-resources.png\" style=\"max-width : 500px\" alt=\"Export server structure with copied resources\" />\n *\n * This feature is **disabled** by default.\n * For info on enabling it, see {@link Grid/view/mixin/GridFeatures}.\n *\n * @extends Grid/feature/export/PdfExport\n * @classtype pdfExport\n * @feature\n *\n * @typings Grid.feature.export.PdfExport -> Grid.feature.export.GridPdfExport\n */\nexport default class PdfExport extends GridPdfExport {\n    static get $name() {\n        return 'PdfExport';\n    }\n    static get defaultConfig() {\n        return {\n            exporters     : [SinglePageExporter, MultiPageExporter, MultiPageVerticalExporter],\n            dialogClass   : SchedulerExportDialog,\n            /**\n             * Specifies how to export time span.\n             *  * completeview - Complete configured time span, from scheduler start date to end date\n             *  * currentview  - Currently visible time span\n             *  * daterange    - Use specific date range, provided additionally in config. See {@link #config-rangeStart}/\n             *  {@link #config-rangeEnd}\n             * @config {'completeview'|'currentview'|'daterange'}\n             * @default\n             * @category Export file config\n             */\n            scheduleRange : 'completeview',\n            /**\n             * Exported time span range start. Used with `daterange` config of the {@link #config-scheduleRange}\n             * @config {Date}\n             * @category Export file config\n             */\n            rangeStart : null,\n            /**\n             * Returns the instantiated export dialog widget as configured by {@link #config-exportDialog}\n             * @member {Scheduler.view.export.SchedulerExportDialog} exportDialog\n             */\n            /**\n             * A config object to apply to the {@link Scheduler.view.export.SchedulerExportDialog} widget.\n             * @config {SchedulerExportDialogConfig} exportDialog\n             */\n            /**\n             * Exported time span range end. Used with `daterange` config of the {@link #config-scheduleRange}\n             * @config {Date}\n             * @category Export file config\n             */\n            rangeEnd : null\n        };\n    }\n    get defaultExportDialogConfig() {\n        return ObjectHelper.copyProperties(super.defaultExportDialogConfig, this, ['scheduleRange']);\n    }\n    buildExportConfig(config) {\n        config = super.buildExportConfig(config);\n        const {\n            scheduleRange,\n            rangeStart,\n            rangeEnd\n        } = this;\n        // Time axis is filtered from UI, need to append it\n        if (config.columns && !config.columns.find(col => col.type === 'timeAxis')) {\n            config.columns.push(config.client.timeAxisColumn.id);\n        }\n        return ObjectHelper.assign({\n            scheduleRange,\n            rangeStart,\n            rangeEnd\n        }, config);\n    }\n}\nPdfExport._$name = 'PdfExport'; GridFeatureManager.registerFeature(PdfExport, false, 'Scheduler');\n"],
  "mappings": "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",
  "names": ["RowReorder", "id", "el", "_a", "left", "MultiPageExporter", "html", "MultiPageVerticalExporter", "html", "SinglePageExporter", "html", "PdfExport", "SinglePageExporter", "MultiPageExporter", "MultiPageVerticalExporter"]
}
