{
  "version": 3,
  "sources": ["../../../../Grid/lib/Grid/feature/RowReorder.js", "../../../../Grid/lib/Grid/feature/mixin/SummaryFormatter.js", "../../../../Grid/lib/Grid/feature/Summary.js"],
  "sourcesContent": ["/**\n * @module Grid/feature/RowReorder\n */\nimport GridFeatureManager from './GridFeatureManager.js';\nimport DragHelper from '../../Core/helper/DragHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n/**\n * Object with information about a tree position\n * @typedef {Object} RecordPositionContext\n * @property {Core.data.Model} record Tree node\n * @property {Number} parentIndex Index among parents children\n * @property {String|Number} parentId Parent node's id\n */\n/**\n * Allows user to reorder rows by dragging them. To get notified about row reorder listen to `change` event\n * on the grid {@link Core.data.Store store}.\n *\n * This feature is **disabled** by default. For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n * This feature is **enabled** by default for Gantt.\n *\n * {@inlineexample Grid/feature/RowReorder.js}\n *\n * If the grid is set to {@link Grid.view.Grid#config-readOnly}, reordering is disabled. Inside all event listeners you\n * have access a `context` object which has a `record` property (the dragged record).\n *\n * ## Usage when grouping\n * Note that row reordering is not possible in a grid which is grouped using the {@link Grid.feature.TreeGroup}\n * feature because when this is in use, all records presented to the UI are linked records, **not** the\n * real records.\n *\n * Row reordering is also disabled when the store is grouped using the {@link Grid.feature.Group} feature and\n * the \"group by\" field is an array value. In this case records may also be present in more than one group\n * and so some records will be linked records, **not** the real records.\n *\n * ## Validation\n * You can validate the drag drop flow by listening to the `gridrowdrag` event. Inside this listener you have access to\n * the `index` property which is the target drop position. For trees you get access to the `parent` record and `index`,\n * where index means the child index inside the parent.\n *\n * You can also have an async finalization step using the {@link #event-gridRowBeforeDropFinalize}, for showing a\n * confirmation dialog or making a network request to decide if drag operation is valid (see code snippet below)\n *\n * ```javascript\n * features : {\n *     rowReorder : {\n *         showGrip : true\n *     },\n *     listeners : {\n *        gridRowDrag : ({ context }) => {\n *           // Here you have access to context.insertBefore, and additionally context.parent for trees\n *        },\n *\n *        gridRowBeforeDropFinalize : async ({ context }) => {\n *           const result = await MessageDialog.confirm({\n *               title   : 'Please confirm',\n *               message : 'Did you want the row here?'\n *           });\n *\n *           // true to accept the drop or false to reject\n *           return result === MessageDialog.yesButton;\n *        }\n *    }\n * }\n * ```\n *\n * Note, that this feature uses the concept of \"insert before\" when choosing a drop point in the data. So the dropped\n * record's position is *before the visual next record's position*.\n *\n * This may look like a pointless distinction, but consider the case when a Store is filtered. The record *above* the\n * drop point may have several filtered out records below it. When unfiltered, the dropped record will be *below* these\n * because of the \"insert before\" behaviour.\n *\n * ## Behavior with multiple subgrids\n *\n * For grids with multiple subgrids, row reordering is only enabled for the first subgrid.\n *\n * NOTE: This feature cannot be used simultaneously with the `enableTextSelection` config.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/rowreordering\n * @classtype rowReorder\n * @feature\n */\nexport default class RowReorder extends Delayable(InstancePlugin) {\n    //region Events\n    /**\n     * Fired before dragging starts, return false to prevent the drag operation.\n     * @preventable\n     * @event gridRowBeforeDragStart\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {MouseEvent|TouchEvent} event\n     * @on-owner\n     */\n    /**\n     * Fired when dragging starts.\n     * @event gridRowDragStart\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {MouseEvent|TouchEvent} event\n     * @on-owner\n     */\n    /**\n     * Fired while the row is being dragged, in the listener function you have access to `context.insertBefore` a grid /\n     * tree record, and additionally `context.parent` (a TreeNode) for trees. You can signal that the drop position is\n     * valid or invalid by setting `context.valid = false;`\n     * @event gridRowDrag\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid.\n     * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)\n     * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {MouseEvent} event\n     * @on-owner\n     */\n    /**\n     * Fired before the row drop operation is finalized. You can return false to abort the drop operation, or a\n     * Promise yielding `true` / `false` which allows for asynchronous abort (e.g. first show user a confirmation dialog).\n     * @event gridRowBeforeDropFinalize\n     * @preventable\n     * @async\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid\n     * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)\n     * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {RecordPositionContext[]} context.oldPositionContext An array of objects with information about the previous tree position.\n     * Objects contain the `record`, and its original `parentIndex` and `parentId` values\n     * @param {MouseEvent} event\n     * @on-owner\n     */\n    /**\n     * Fired after the row drop operation has completed, regardless of validity\n     * @event gridRowDrop\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {Boolean} context.valid true or false depending on whether the drop position was valid\n     * @param {Core.data.Model} context.insertBefore The record to insert before (`null` if inserting at last position of a parent node)\n     * @param {Core.data.Model} context.parent The parent record of the current drop position (only applicable for trees)\n     * @param {Core.data.Model} context.record [DEPRECATED] The dragged row record\n     * @param {Core.data.Model[]} context.records The dragged row records\n     * @param {RecordPositionContext[]} context.oldPositionContext An array of objects with information about the previous tree position.\n     * Objects contain the record, and its original `parentIndex` and `parentId` values\n     * @param {MouseEvent} event\n     * @on-owner\n     */\n    /**\n     * Fired when a row drag operation is aborted\n     * @event gridRowAbort\n     * @param {Core.helper.DragHelper} source\n     * @param {Object} context\n     * @param {MouseEvent} event\n     * @on-owner\n     */\n    //endregion\n    //region Init\n    static $name = 'RowReorder';\n    static configurable = {\n        /**\n         * Set to `true` to show a grip icon on the left side of each row.\n         * @config {Boolean}\n         */\n        showGrip : null,\n        /**\n         * Set to `true` to only allow reordering by the {@link #config-showGrip} config\n         * @config {Boolean}\n         */\n        gripOnly : null,\n        /**\n         * If hovering over a parent node for this period of a time in a tree, the node will expand\n         * @config {Number}\n         */\n        hoverExpandTimeout : 1000,\n        /**\n         * The amount of milliseconds to wait after a touchstart, before a drag gesture will be allowed to start.\n         * @config {Number}\n         * @default\n         */\n        touchStartDelay : 300,\n        /**\n         * Enables creation of parents by dragging a row and dropping it onto a leaf row. Only works in a Grid with\n         * a tree store.\n         * @config {Boolean}\n         */\n        dropOnLeaf : false,\n        /**\n         * An object used to configure the internal {@link Core.helper.DragHelper} class\n         * @config {DragHelperConfig}\n         */\n        dragHelperConfig : null\n    };\n    static get deprecatedEvents() {\n        return {\n            gridRowBeforeDragStart : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowBeforeDragStart` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowDragStart : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowDragStart` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowDrag : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowDrag` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowBeforeDropFinalize : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowBeforeDropFinalize` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowDrop : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowDrop` event is deprecated, listen on this event on the Grid instead.'\n            },\n            gridRowAbort : {\n                product            : 'Grid',\n                invalidAsOfVersion : '6.0.0',\n                message            : '`gridRowAbort` event is deprecated, listen on this event on the Grid instead.'\n            }\n        };\n    }\n    construct(grid, config) {\n        this.grid = grid;\n        super.construct(...arguments);\n    }\n    doDestroy() {\n        this.dragHelper?.destroy();\n        super.doDestroy();\n    }\n    /**\n     * Initialize drag & drop (called on first paint)\n     * @private\n     */\n    init() {\n        const\n            me       = this,\n            { grid } = me;\n        me.dragHelper = DragHelper.new({\n            name               : 'rowReorder',\n            cloneTarget        : true,\n            dragThreshold      : 10,\n            proxyTopOffset     : 10,\n            targetSelector     : '.b-grid-row',\n            lockX              : true,\n            dragWithin         : grid.bodyContainer,\n            allowDropOutside   : true,\n            scrollManager      : grid.scrollManager,\n            outerElement       : me.targetSubGridElement,\n            touchStartDelay    : me.touchStartDelay,\n            isElementDraggable : me.isElementDraggable.bind(me),\n            monitoringConfig   : {\n                scrollables : [\n                    {\n                        element   : grid.scrollable.element,\n                        direction : 'vertical'\n                    }\n                ]\n            },\n            setXY(element, x, y) {\n                const { context } = this;\n                if (!context.started) {\n                    const\n                        elementRect       = Rectangle.from(context.element, this.dragWithin),\n                        pointerDownOffset = context.startPageY - globalThis.pageYOffset - context.element.getBoundingClientRect().top;\n                    // manually position the row a bit below the cursor\n                    y = elementRect.top + pointerDownOffset + this.proxyTopOffset;\n                }\n                DomHelper.setTranslateXY(element, x, y);\n            },\n            // Since parent nodes can expand after hovering, meaning original drag start position now refers to a different point in the tree\n            ignoreSamePositionDrop : false,\n            createProxy(element) {\n                const\n                    clone     = element.cloneNode(true),\n                    container = document.createElement('div');\n                container.classList.add('b-row-reorder-proxy');\n                clone.removeAttribute('id');\n                // The containing element will be positioned instead, and sized using CSS\n                clone.style.transform = '';\n                clone.style.width = '';\n                container.appendChild(clone);\n                if (grid.selectedRecords.length > 1) {\n                    const clone2 = clone.cloneNode(true);\n                    clone2.classList.add('b-row-dragging-multiple');\n                    container.appendChild(clone2);\n                }\n                DomHelper.removeClsGlobally(container, 'b-selected', 'b-hover', 'b-focused');\n                return container;\n            },\n            internalListeners : {\n                beforedragstart : 'onBeforeDragStart',\n                dragstart       : 'onDragStart',\n                drag            : 'onDrag',\n                drop            : 'onDrop',\n                abort           : 'onAbort',\n                reset           : 'onReset',\n                prio            : 10000, // To ensure our listener is run before the relayed listeners (for the outside world)\n                thisObj         : me\n            }\n        }, me.dragHelperConfig);\n        // Remove in 6.0\n        me.relayEvents(me.dragHelper, ['beforeDragStart', 'dragStart', 'drag', 'abort'], 'gridRow');\n        grid.relayEvents(me.dragHelper, ['beforeDragStart', 'dragStart', 'drag', 'abort'], 'gridRow');\n        me.dropIndicator = DomHelper.createElement({\n            className : 'b-row-drop-indicator'\n        });\n        me.dropOverTargetCls = ['b-row-reordering-target', 'b-hover'];\n    }\n    //endregion\n    //region Plugin config\n    static pluginConfig = {\n        after : ['onInternalPaint']\n    };\n    get targetSubGridElement() {\n        const targetSubGrid = this.grid.regions[0];\n        return this.grid.subGrids[targetSubGrid].element;\n    }\n    //endregion\n    //region Events (drop)\n    isElementDraggable(el, event) {\n        if (!el.closest('.b-grid-cell .b-widget')) {\n            if (this.gripOnly) {\n                const firstCell = el.closest('.b-grid-cell:first-child');\n                // Event is in the first cell. Now check if it's on the handle\n                if (firstCell) {\n                    const\n                        gripperStyle = getComputedStyle(firstCell, ':before'),\n                        offsetX      = this.grid.rtl ? firstCell.getBoundingClientRect().width - event.borderOffsetX : event.borderOffsetX,\n                        onGrip       = offsetX <= parseFloat(gripperStyle.width);\n                    // Prevent drag select if mousedown on grip, would collide with reordering\n                    // (reset by GridSelection)\n                    if (onGrip) {\n                        this.client.preventDragSelect = true;\n                    }\n                    return onGrip;\n                }\n            }\n            else {\n                return true;\n            }\n        }\n    }\n    onBeforeDragStart({ event, source, context }) {\n        const\n            me        = this,\n            { grid }  = me,\n            { group } = grid.features,\n            subGridEl = me.targetSubGridElement;\n        // Only dragging enabled in the leftmost grid section\n        if (event.target.classList.contains('b-rowexpander-shadowroot-container') || me.disabled || grid.readOnly || grid.isTreeGrouped || !subGridEl.contains(context.element)) {\n            return false;\n        }\n        const startRecord = context.startRecord = grid.getRecordFromElement(context.element);\n        // If store is grouped by an array field, then we cannot drag because any record may be\n        // a member of more than one group and without the StoreGroup#move method cannot add the correct new\n        // group value because the \"after\" record it is passed is always an original, never\n        // the linked record dropped upon.\n        if (group?.enabled && Array.isArray(startRecord[grid.features.group.field])) {\n            return false;\n        }\n        // Don't allow starting drag on a readOnly record nor on special rows\n        if (startRecord.readOnly || startRecord.isSpecialRow) {\n            return false;\n        }\n        context.originalRowTop = grid.rowManager.getRowFor(startRecord).top;\n        // Don't select row if checkboxOnly is set\n        if (!grid.selectionMode.checkboxOnly) {\n            if (source.startEvent.pointerType === 'touch') {\n                // Touchstart doesn't focus/navigate on its own, so we do it at the last moment before drag start\n                if (!grid.isSelected(startRecord)) {\n                    grid.selectRow({\n                        record         : startRecord,\n                        addToSelection : false\n                    });\n                }\n            }\n            else if (!grid.isSelected(startRecord) && !event.shiftKey && !event.ctrlKey) {\n                // If record is not selected and shift/ctrl is not pressed then select single row\n                grid.selectRow({\n                    record : startRecord\n                });\n            }\n        }\n        // Read-only records will not be moved\n        const selectedRecords = grid.selectedRecords.filter(r => !r.readOnly);\n        context.records       = [startRecord];\n        // If clicked record is selected, move all selected records\n        if (selectedRecords.includes(startRecord)) {\n            context.records.push(...selectedRecords.filter(r => r !== startRecord));\n            context.records.sort((r1, r2) => grid.store.indexOf(r1) - grid.store.indexOf(r2));\n        }\n        return true;\n    }\n    onDragStart({ context }) {\n        const\n            me                                 = this,\n            { grid }                           = me,\n            { cellEdit, cellMenu, headerMenu } = grid.features;\n        if (cellEdit) {\n            me.cellEditDisabledState = cellEdit.disabled;\n            cellEdit.disabled        = true; // prevent editing from being started through keystroke during row reordering\n        }\n        cellMenu?.hideContextMenu?.(false);\n        headerMenu?.hideContextMenu?.(false);\n        grid.element.classList.add('b-row-reordering');\n        const focusedCell = context.element.querySelector('.b-focused');\n        focusedCell?.classList.remove('b-focused');\n        context.element.firstElementChild.classList.remove('b-selected', 'b-hover');\n        grid.bodyContainer.appendChild(me.dropIndicator);\n    }\n    onDrag({ context, event }) {\n        const\n            me                    = this,\n            { grid }              = me,\n            { store, rowManager } = grid,\n            { clientY }           = event;\n        let valid = true,\n            row   = rowManager.getRowAt(clientY),\n            overRecord,\n            dataIndex,\n            after,\n            over,\n            insertBefore;\n        if (row) {\n            const\n                rowTop        = row.top + grid.scrollable.element.getBoundingClientRect().top - grid.scrollable.y,\n                quarter       = row.height / 4,\n                topQuarter    = rowTop + quarter,\n                middleY       = rowTop + row.height / 2,\n                bottomQuarter = rowTop + quarter * 3;\n            dataIndex  = row.dataIndex;\n            overRecord = store.getAt(dataIndex);\n            // If Tree and pointer is in quarter 2 and 3, add as child of hovered row\n            if (store.tree) {\n                over = (overRecord.isParent || me.dropOnLeaf) && clientY > topQuarter && clientY < bottomQuarter;\n            }\n            else if (store.isGrouped) {\n                over = overRecord.isGroupHeader && overRecord.meta.collapsed;\n            }\n            // Else, drop after row below if mouse is in bottom half of hovered row\n            after = !over && event.clientY >= middleY;\n        }\n        // User dragged below last row or above the top row.\n        else {\n            if (event.pageY < grid._bodyRectangle.y) {\n                dataIndex  = 0;\n                overRecord = store.first;\n                after      = false;\n            }\n            else {\n                dataIndex  = store.count - 1;\n                overRecord = store.last;\n                after      = true;\n            }\n            row = grid.rowManager.getRow(dataIndex);\n        }\n        if (overRecord === me.overRecord && me.after === after && me.over === over) {\n            context.valid = me.reorderValid;\n            // nothing's changed\n            return;\n        }\n        if (me.overRecord !== overRecord) {\n            rowManager.getRowById(me.overRecord)?.removeCls(me.dropOverTargetCls);\n        }\n        me.overRecord = overRecord;\n        me.after      = after;\n        me.over       = over;\n        if (\n            // Hovering the dragged record. This is a no-op.\n            // But still gather the contextual data.\n            overRecord === context.startRecord ||\n            // Not allowed to drop above topmost group header or below a collapsed header\n            (!after && !over && dataIndex === 0 && store.isGrouped) ||\n            // Not allowed to drop after last collapsed group\n            (after && overRecord.isGroupHeader && overRecord.meta.collapsed && store.indexOf(overRecord) === store.count - 1)\n        ) {\n            valid = false;\n        }\n        if (store.tree) {\n            insertBefore = after ? overRecord.nextSibling : overRecord;\n            // For trees, prevent moving a parent into its own hierarchy\n            if (context.records.some(rec => rec.contains(overRecord))) {\n                valid = false;\n            }\n            context.parent = valid && over ? overRecord : overRecord.parent;\n            me.clearTimeout(me.hoverTimer);\n            if (overRecord && overRecord.isParent && !overRecord.isExpanded(store)) {\n                me.hoverTimer = me.setTimeout(() => grid.expand(overRecord), me.hoverExpandTimeout);\n            }\n        }\n        else {\n            insertBefore = after ? store.getAt(dataIndex + 1) : overRecord;\n        }\n        row.toggleCls(me.dropOverTargetCls, valid && over);\n        // If hovering results in same dataIndex, regardless of what row is hovered, and parent has not changed\n        if (!over && dataIndex === store.indexOf(context.startRecord) + (after ? -1 : 1) &&\n            context.parent && context.startRecord.parent === context.parent) {\n            valid = false;\n        }\n        // Provide visual clue to user of the drop position\n        // In FF (in tests) it might not have had time to redraw rows after scroll before getting here\n        row && DomHelper.setTranslateY(me.dropIndicator, Math.max(row.top + (after ? row.element.getBoundingClientRect().height : 0), 1));\n        // Don't show dropIndicator if holding over a row\n        me.dropIndicator.style.visibility = over ? 'hidden' : 'visible';\n        me.dropIndicator.classList.toggle('b-drag-invalid', !valid);\n        // Public property used for validation\n        context.insertBefore = insertBefore;\n        context.valid = me.reorderValid = valid;\n    }\n    /**\n     * Handle drop\n     * @private\n     */\n    async onDrop(event) {\n        const\n            me          = this,\n            { client }  = me,\n            { context } = event;\n        context.valid = context.valid && me.reorderValid;\n        if (context.valid) {\n            context.async = true;\n            if (client.store.tree) {\n                // For tree scenario, add context about previous positions of dragged tree nodes\n                context.oldPositionContext = context.records.map((record) => ({\n                    record,\n                    parentId    : record.parent?.id,\n                    parentIndex : record.parentIndex\n                }));\n            }\n            // Remove for 6.0\n            let result = await me.trigger('gridRowBeforeDropFinalize', event);\n            if (result === false) {\n                context.valid = false;\n            }\n            // Outside world provided us one or more Promises to wait for\n            result = await client.trigger('gridRowBeforeDropFinalize', event);\n            if (result === false) {\n                context.valid = false;\n            }\n            await me.dragHelper.animateProxyTo(me.dropIndicator, { align : 'l0-l0' });\n            await me.finalizeReorder(context);\n        }\n        // already dropped the node, don't have to expand any node hovered anymore\n        // (cancelling expand action after timeout)\n        me.clearTimeout(me.hoverTimer);\n        me.overRecord = me.after = me.over = null;\n        me.trigger('gridRowDrop', event);\n        client.trigger('gridRowDrop', event);\n    }\n    onAbort(event) {\n        this.client.trigger('gridRowDragAbort', event);\n    }\n    async finalizeReorder(context) {\n        const\n            me                     = this,\n            { grid }               = me,\n            { store, focusedCell } = grid;\n        let { records } = context;\n        context.valid = context.valid && !records.some(rec => !store.includes(rec));\n        if (context.valid) {\n            let result;\n            if (store.tree) {\n                // Remove any selected child records of parent nodes\n                records = records.filter(record => !record.parent || record.bubbleWhile(parent => !records.includes(parent), true));\n                result = await context.parent.tryInsertChild(records, me.over ? context.parent.children?.[0] : context.insertBefore);\n                // remove reorder cls from preview parent element dropped\n                grid.rowManager.forEach(r => r.removeCls(me.dropOverTargetCls));\n                // If parent wasn't expanded, expand it if it now has children\n                if (!context.parent.isExpanded() && context.parent.children?.length) {\n                    grid.expand(context.parent);\n                }\n                context.valid = result !== false;\n            }\n            else if (store.isGrouped && me.over) {\n                store.move(records, store.getAt(store.indexOf(context.insertBefore) + 1));\n            }\n            else {\n                // When dragging multiple rows, ensure the insertBefore reference is not one of the selected records\n                if (records.length > 1) {\n                    while (context.insertBefore && records.includes(context.insertBefore)) {\n                        context.insertBefore = store.getNext(context.insertBefore, false, true);\n                    }\n                }\n                store.move(records, context.insertBefore);\n            }\n            if (focusedCell?._rowIndex >= 0) {\n                grid._focusedCell = null;\n                // Refresh focused cell\n                grid.focusCell({\n                    grid,\n                    record   : focusedCell.record,\n                    columnId : focusedCell.columnId\n                });\n            }\n            store.clearSorters();\n        }\n        context.finalize(context.valid);\n        grid.element.classList.remove('b-row-reordering');\n    }\n    /**\n     * Clean up on reset\n     * @private\n     */\n    onReset() {\n        const\n            me       = this,\n            { grid } = me,\n            cellEdit = grid.features.cellEdit;\n        grid.element.classList.remove('b-row-reordering');\n        if (cellEdit) {\n            cellEdit.disabled = me.cellEditDisabledState;\n        }\n        me.dropIndicator.remove();\n        DomHelper.removeClsGlobally(\n            grid.element,\n            ...me.dropOverTargetCls\n        );\n    }\n    //endregion\n    //region Render\n    onInternalPaint({ firstPaint }) {\n        // columns shown, hidden or reordered\n        if (firstPaint) {\n            this.init();\n        }\n    }\n    //endregion\n    updateShowGrip(show) {\n        this.grid.element.classList.toggle('b-row-reorder-with-grip', show);\n    }\n    get isDragging() {\n        return this.dragHelper.isDragging;\n    }\n}\nRowReorder.featureClass = '';\nRowReorder._$name = 'RowReorder'; GridFeatureManager.registerFeature(RowReorder, false);\n", "import Base from '../../../Core/Base.js';\n/**\n * @module Grid/feature/mixin/SummaryFormatter\n */\n/**\n * Mixin for Summary and GroupSummary that handles formatting sums.\n * @mixin\n * @private\n */\nexport default Target => class SummaryFormatter extends (Target || Base) {\n    static get $name() {\n        return 'SummaryFormatter';\n    }\n    /**\n     * Calculates sums and returns as a html table\n     * @param {Grid.column.Column} column Column to calculate sum for\n     * @param {Core.data.Model[]} records Records to include in calculation\n     * @param {String} cls CSS class to apply to summary table\n     * @param {Core.data.Model} groupRecord current group row record\n     * @param {String} groupField Current groups field name\n     * @param {String} groupValue Current groups value\n     * @returns {String} html content\n     */\n    generateHtml(column, records, cls, groupRecord, groupField, groupValue) {\n        const\n            store = this.store,\n            summaries = column.summaries ||\n                  (column.sum ? [{ sum : column.sum, renderer : column.summaryRenderer }] : []);\n        let html = `<div class=\"b-summary-wrap ${cls}\">`;\n        summaries.forEach(config => {\n            let type = config.sum,\n                sum  = null;\n            if (type === true) type = 'sum';\n            switch (type) {\n                case 'sum':\n                case 'add':\n                    sum = store.sum(column.field, records);\n                    break;\n                case 'max':\n                    sum = store.max(column.field, records);\n                    break;\n                case 'min':\n                    sum = store.min(column.field, records);\n                    break;\n                case 'average':\n                case 'avg':\n                    sum = store.average(column.field, records);\n                    break;\n                case 'count':\n                    sum = records.length;\n                    break;\n                case 'countNotEmpty':\n                    sum = records.reduce((sum, record) => {\n                        const value = record.getValue(column.field);\n                        return sum + (value != null ? 1 : 0);\n                    }, 0);\n                    break;\n            }\n            if (typeof type === 'function') {\n                sum = records.reduce(type, 'seed' in config ? config.seed : 0);\n            }\n            if (sum !== null) {\n                const\n                    valueCls  = 'b-grid-summary-value',\n                    // optional label\n                    labelHtml = config.label\n                        ? `<div class=\"b-grid-summary-label\">${config.label}</div>`\n                        : '';\n                // value to display, either using renderer or as is\n                let valueHtml = config.renderer\n                        ? config.renderer({ config, sum })\n                        : sum,\n                    summaryHtml;\n                if (valueHtml == null) {\n                    valueHtml = '';\n                }\n                // no <div>s in html, wrap it (always the case when not using renderer)\n                if (!String(valueHtml).includes('<div>')) {\n                    summaryHtml = labelHtml\n                        // has label, use returned html as value cell\n                        ? `${labelHtml}<div class=\"${valueCls}\">${valueHtml}</div>`\n                        // no label, span entire table\n                        : `<div class=\"${valueCls} b-nolabel\">${valueHtml}</div>`;\n                }\n                // user is in charge of giving correct formatting\n                else {\n                    summaryHtml = valueHtml;\n                }\n                html += summaryHtml;\n            }\n        });\n        return `${html}</div>`;\n    }\n};\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport SummaryFormatter from './mixin/SummaryFormatter.js';\n/**\n * @module Grid/feature/Summary\n */\n/**\n * @typedef {Object} ColumnSummaryConfig\n * @property {'sum'|'add'|'count'|'countNotEmpty'|'average'|Function} sum Summary type, see\n * {@link Grid/column/Column#config-sum} for details\n * @property {Function} renderer Renderer function for summary, see\n * {@link Grid/column/Column#config-summaryRenderer} for details\n * @property {*} seed Initial value when using a function as `sum`\n */\n/**\n * Displays a summary row in the grid footer.\n *\n * {@inlineexample Grid/feature/Summary.js}\n *\n * Specify type of summary on columns, available types are:\n * <dl class=\"wide\">\n * <dt>sum <dd>Sum of all values in the column\n * <dt>add <dd>Alias for sum\n * <dt>count <dd>Number of rows\n * <dt>countNotEmpty <dd>Number of rows containing a value\n * <dt>average <dd>Average of all values in the column\n * <dt>function <dd>A custom function, used with store.reduce. Should take arguments (sum, record)\n * </dl>\n * Columns can also specify a summaryRenderer to format the calculated sum.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ```javascript\n * { text : 'Score', data : 'score', width : 80, sum : 'sum' }\n * { text : 'Rank', data : 'rank', width : 80, sum : 'average', summaryRenderer: ({ sum }) => return 'Average rank ' + sum }\n * ```\n *\n * Also, it is possible to set up multiple summaries as array of summary configs:\n * ```javascript\n * { text : 'Rank', data : 'rank', summaries : [{ sum : 'average', label : 'Average' }, { sum : 'count', label : 'Count' }] }\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/features\n * @classtype summary\n * @feature\n */\nexport default class Summary extends SummaryFormatter(InstancePlugin) {\n    //region Config\n    static get configurable() {\n        return {\n            /**\n             * Set to `true` to sum values of selected row records\n             * @prp {Boolean}\n             */\n            selectedOnly : null,\n            hideFooters : false\n        };\n    }\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['renderRows', 'bindStore']\n        };\n    }\n    //endregion\n    //region Init\n    static get $name() {\n        return 'Summary';\n    }\n    construct(grid, config) {\n        this.grid = grid;\n        super.construct(grid, config);\n        this.bindStore(grid.store);\n        grid.hideFooters = this.hideFooters;\n    }\n    bindStore(store) {\n        this.detachListeners('store');\n        store.ion({\n            name    : 'store',\n            change  : 'onStoreChange',\n            thisObj : this\n        });\n    }\n    get store() {\n        return this.grid.store;\n    }\n    doDestroy() {\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        super.doDisable(disable);\n        const { client } = this;\n        if (disable) {\n            client.element.classList.add('b-summary-disabled');\n        }\n        else {\n            this.updateSummaries();\n            client.element.classList.remove('b-summary-disabled');\n            client.eachSubGrid(subGrid => subGrid.scrollable.syncPartners());\n        }\n    }\n    //endregion\n    //region Render\n    renderRows() {\n        this.updateSummaries();\n    }\n    /**\n     * Updates summaries. Summaries are displayed as tables in footer (styling left out to keep brief):\n     * ```\n     * <table>\n     *     <tr><td colspan=\"2\">0</td></tr> // { sum : 'min' } Only a calculation, span entire table\n     *     <tr><td>Max</td><td>10</td></tr> // { sum : 'max', label: 'Max' } Label + calculation\n     *     <tr><td>Max</td><td>10</td></tr> // { sum : 'sum', label: 'Max' } Label + calculation\n     * </table>\n     * ```\n     * @private\n     */\n    updateSummaries() {\n        const\n            me              = this,\n            { grid, store } = me,\n            cells           = DomHelper.children(grid.element, '.b-grid-footer'),\n            selectedOnly    = me.selectedOnly && grid.selectedRecords.length > 0,\n            records         = (store.isFiltered ? store.storage.values : store.allRecords).filter(r => !r.isSpecialRow && (!selectedOnly || grid.isSelected(r)));\n        // reset seeds, to not have ever increasing sums :)\n        grid.columns.forEach(column => {\n            column.summaries?.forEach(config => {\n                if ('seed' in config) {\n                    if (!('initialSeed' in config)) {\n                        config.initialSeed = config.seed;\n                    }\n                    if (['number', 'string', 'date'].includes(typeof config.initialSeed)) {\n                        config.seed = config.initialSeed;\n                    }\n                    else {\n                        // create shallow copy\n                        config.seed = Object.assign({}, config.initialSeed);\n                    }\n                }\n            });\n        });\n        cells.forEach(cellElement => {\n            // Skip for special columns like checkbox selection\n            if (!cellElement.dataset.column) {\n                return;\n            }\n            const\n                column = grid.columns.get(cellElement.dataset.column),\n                html   = me.generateHtml(column, records, 'b-grid-footer-summary');\n            if (column.summaries ? column.summaries.length : column.sum ? 1 : 0) {\n                // First time, set table\n                if (!cellElement.children.length) {\n                    cellElement.innerHTML = html;\n                }\n                // Following times, sync changes\n                else {\n                    DomHelper.sync(html, cellElement.firstElementChild);\n                }\n            }\n        });\n    }\n    //endregion\n    //region Events\n    /**\n     * Updates summaries on store changes (except record update, handled below)\n     * @private\n     */\n    onStoreChange({ action, changes }) {\n        let shouldUpdate = true;\n        if (this.disabled) {\n            return;\n        }\n        if (action === 'update') {\n            // only update summary when a field that affects summary is changed\n            shouldUpdate = Object.keys(changes).some(field => {\n                const colField = this.grid.columns.get(field);\n                // check existence, since a field not used in a column might have changed\n                return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));\n            });\n        }\n        if (shouldUpdate) {\n            this.updateSummaries();\n        }\n    }\n    //endregion\n    updateSelectedOnly(value) {\n        const me = this;\n        me.detachListeners('selectionChange');\n        if (value) {\n            me.grid.ion({\n                name            : 'selectionChange',\n                selectionChange : me.refresh,\n                thisObj         : me\n            });\n        }\n        me.refresh();\n    }\n    /**\n     * Refreshes the summaries\n     */\n    refresh() {\n        this.updateSummaries();\n    }\n}\nSummary.featureClass = 'b-summary';\nSummary._$name = 'Summary'; GridFeatureManager.registerFeature(Summary);\n"],
  "mappings": "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",
  "names": ["sum"]
}
