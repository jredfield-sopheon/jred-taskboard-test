{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/util/WebSocketManager.js", "../../../../Core/lib/Core/widget/FieldSet.js", "../../../../Core/lib/Core/widget/Radio.js", "../../../../Core/lib/Core/widget/RadioGroup.js", "../../../../Core/lib/Core/widget/Tab.js", "../../../../Core/lib/Core/widget/TabBar.js", "../../../../Core/lib/Core/widget/TabPanel.js"],
  "sourcesContent": ["import Base from '../Base.js';\nimport Events from '../mixin/Events.js';\n/**\n * @module Core/helper/WebSocketManager\n */\n/**\n * This class allows to send and receive messages from websocket server passing responses via events. This helper is\n * meant to be used with a demo websocket server. It sends messages that are JSON strings including \"command\" key and\n * arbitrary data keys. For example:\n *\n * ```javascript\n * // request string to notify other clients that new client is connected\n * \"{ \\\"command\\\": \\\"hello\\\", \\\"userName\\\": \\\"new user\\\" }\"\n *\n * // response message from the websocket server with list of connected users\n * \"{ \\\"command\\\": \\\"users\\\", \\\"users\\\": [\\\"new user\\\"] }\"\n * ```\n *\n * Usage:\n * ```javascript\n * connector = new WebSocketManager({\n *     address     : 'ws://localhost:8080',\n *     userName    : 'Test client',\n *     autoConnect : false\n * });\n *\n * const opened = await connector.open();\n *\n * if (!opened) {\n *     console.log('Could not open connection');\n * }\n *\n * connector.on({\n *     message({ data }) {\n *         console.log(data);\n *     }\n * });\n *\n * // Sends \"{ \\\"command\\\": \\\"hello\\\", \\\"userName\\\": \\\"mark\\\" }\" string to the websocket server\n * // When response arrives helper will log following message: \"{ command: 'users', users: ['mark'] }\"\n * connector.send('hello', { userName : 'mark' });\n * ```\n *\n * @class\n * @extends Core/Base\n * @mixes Core/mixin/Events\n * @private\n */\nexport default class WebSocketManager extends Events(Base) {\n    // This allows to hook into for testing purposes\n    static webSocketImplementation = typeof WebSocket === 'undefined' ? null : WebSocket;\n    static configurable = {\n        /**\n         * WebSocket server address\n         * @config {String}\n         */\n        address : '',\n        /**\n         * User name allowing to identify client\n         * @config {String}\n         */\n        userName : 'User',\n        /**\n         * Connect to websocket server immediately after instantiation\n         * @config {Boolean}\n         */\n        autoConnect : true\n    };\n    construct(config = {}) {\n        const me = this;\n        super.construct(config);\n        me.onWsOpen = me.onWsOpen.bind(me);\n        me.onWsClose = me.onWsClose.bind(me);\n        me.onWsMessage = me.onWsMessage.bind(me);\n        me.onWsError = me.onWsError.bind(me);\n        if (me.autoConnect && me.address) {\n            me.open();\n        }\n    }\n    doDestroy() {\n        const me = this;\n        if (me.connector) {\n            me.detachSocketListeners(me.connector);\n            me.connector.close();\n            me.connector = null;\n        }\n        super.doDestroy();\n    }\n    //#region Websocket state\n    get isConnecting() {\n        return this.connector?.readyState === this.constructor.webSocketImplementation.CONNECTING;\n    }\n    get isOpened() {\n        return this.connector?.readyState === this.constructor.webSocketImplementation.OPEN;\n    }\n    get isClosing() {\n        return this.connector?.readyState === this.constructor.webSocketImplementation.CLOSING;\n    }\n    get isClosed() {\n        return this.connector?.readyState === this.constructor.webSocketImplementation.CLOSED;\n    }\n    //#endregion\n    //#region Websocket init\n    createWebSocketConnector() {\n        const connector = this.connector = new this.constructor.webSocketImplementation(this.address);\n        this.attachSocketListeners(connector);\n    }\n    destroyWebSocketConnector() {\n        this.detachSocketListeners(this.connector);\n        this.connector.close();\n        this.connector = null;\n    }\n    attachSocketListeners(connector) {\n        const me = this;\n        connector.addEventListener('open', me.onWsOpen);\n        connector.addEventListener('close', me.onWsClose);\n        connector.addEventListener('message', me.onWsMessage);\n        connector.addEventListener('error', me.onWsError);\n    }\n    detachSocketListeners(connector) {\n        const me = this;\n        connector.removeEventListener('open', me.onWsOpen);\n        connector.removeEventListener('close', me.onWsClose);\n        connector.removeEventListener('message', me.onWsMessage);\n        connector.removeEventListener('error', me.onWsError);\n    }\n    //#endregion\n    //#region Websocket methods\n    /**\n     * Connect to the server and start listening for messages\n     * @returns {Promise} Returns true if connection was successful and false otherwise\n     */\n    async open() {\n        const me = this;\n        if (me._openPromise) {\n            return me._openPromise;\n        }\n        if (!me.address) {\n            console.warn('Server me.address cannot be empty');\n            return;\n        }\n        if (me.isOpened) {\n            return true;\n        }\n        me.createWebSocketConnector();\n        let detacher;\n        // Wait for `open` or `close` event\n        me._openPromise = new Promise(resolve => {\n            detacher = me.ion({\n                open() {\n                    resolve(true);\n                },\n                error() {\n                    resolve(false);\n                }\n            });\n        }).then(value => {\n            // Detach listeners\n            detacher();\n            // Cleanup the promise\n            me._openPromise = null;\n            // If quit early with a timeout then remove reference to the WebSocket instance\n            if (!value) {\n                me.destroyWebSocketConnector();\n            }\n            return value;\n        }).catch(() => {\n            me._openPromise = null;\n            me.destroyWebSocketConnector();\n        });\n        return me._openPromise;\n    }\n    /**\n     * Close socket and disconnect from the server\n     */\n    close() {\n        if (this.connector) {\n            this.destroyWebSocketConnector();\n            this.trigger('close');\n        }\n    }\n    /**\n     * Send data to the websocket server\n     * @param {String} command\n     * @param {*} data\n     */\n    send(command, data = {}) {\n        this.connector?.send(JSON.stringify({ command, ...data }));\n    }\n    //#endregion\n    //#region websocket event listeners\n    onWsOpen(event) {\n        this.trigger('open', { event });\n    }\n    onWsClose(event) {\n        this.trigger('close', { event });\n    }\n    onWsMessage(message) {\n        try {\n            const data = JSON.parse(message.data);\n            this.trigger('message', { data });\n        }\n        catch (error) {\n            this.trigger('error', { error });\n        }\n    }\n    onWsError(error) {\n        this.trigger('error', { error });\n    }\n    //#endregion\n}\nWebSocketManager._$name = 'WebSocketManager';", "import Panel from './Panel.js';\nimport Labelable from './mixin/Labelable.js';\nimport DomHelper from '../helper/DomHelper.js';\n/**\n * @module Core/widget/FieldSet\n */\n/**\n * The `FieldSet` widget wraps an <code>&lt;fieldset&gt;</code> element. A fieldset is a specially styled\n * {@link Core.widget.Panel} intended to hold form fields.\n *\n * {@inlineexample Core/widget/FieldSet.js vertical}\n *\n * @extends Core/widget/Panel\n * @mixes Core/widget/mixin/Labelable\n * @classtype fieldset\n * @widget\n */\nexport default class FieldSet extends Panel.mixin(Labelable) {\n    //region Config\n    static $name = 'FieldSet';\n    static type = 'fieldset';\n    static get configurable() {\n        return {\n            bodyTag   : 'fieldset',\n            focusable : false,\n            /**\n             * Setting this config to `true` assigns a horizontal box layout (`flex-flow: row`) to the items in this\n             * container, while `false` assigns a vertical box layout (`flex-flow: column`).\n             *\n             * By default, this value is automatically determined based on the {@link #config-label} and\n             * {@link #config-labelPosition} configs.\n             * @config {Boolean}\n             */\n            inline : null,\n            inlineInternal : null,\n            layout : {\n                type       : 'box',\n                horizontal : false\n            }\n        };\n    }\n    static get prototypeProperties() {\n        return {\n            flexRowCls : 'b-hbox',\n            flexColCls : 'b-vbox'\n        };\n    }\n    //endregion\n    //region Composition\n    get bodyConfig() {\n        const\n            result = super.bodyConfig,\n            { className } = result,\n            { inlineInternal: inline, hasLabel, title } = this;\n        delete result.html;\n        className['b-inline'] = inline;\n        className['b-fieldset-has-label'] = hasLabel;\n        if (title) {\n            result.children = {\n                // We render the <legend> element for a11y (not 100% sure it is needed)\n                legendElement : {\n                    tag   : 'legend',\n                    text  : title,\n                    class : {\n                        'b-fieldset-legend' : 1\n                    }\n                }\n            };\n        }\n        return result;\n    }\n    compose() {\n        const { inlineInternal: inline, label, labelCls, labelWidth } = this;\n        return {\n            class : {\n                'b-field' : label,\n                'b-vbox'  : !inline  // override panel\n            },\n            children : {\n                'labelElement > headerElement' : (label || null) && {\n                    tag   : 'label',\n                    html  : label,\n                    class : {\n                        'b-label'       : 1,\n                        'b-align-start' : 1,\n                        [labelCls]      : labelCls\n                    },\n                    style : {\n                        width : DomHelper.unitize('width', labelWidth)[1]\n                    }\n                }\n            }\n        };\n    }\n    //endregion\n    syncInlineInternal() {\n        this.inlineInternal = this.inline ?? (this.label != null && this.labelPosition === 'before');\n    }\n    updateDisabled(value, was) {\n        super.updateDisabled(value, was);\n        // Needs {}'s to avoid a \"return false\" that ends iteration\n        this.eachWidget(item => {\n            item.disabled = value;\n        }, /* deep = */false);\n    }\n    updateInline() {\n        this.syncInlineInternal();\n    }\n    updateInlineInternal(inline) {\n        this.layout.horizontal = inline;\n    }\n    updateLabel() {\n        this.syncInlineInternal();\n    }\n    updateLabelPosition() {\n        this.syncInlineInternal();\n    }\n}\n// Register this widget type with its Factory\nFieldSet.initClass();\nFieldSet._$name = 'FieldSet';", "import Checkbox from './Checkbox.js';\n/**\n * @module Core/widget/Radio\n */\n/**\n * The `Radio` widget wraps an <code>&lt;input type=\"radio\"&gt;</code> element.\n *\n * Color can be specified and you can optionally configure {@link #config-text} to display in a label to the right of\n * the radio button instead of, or in addition to, a standard field {@link #config-label}.\n *\n * {@inlineexample Core/widget/Radio.js vertical}\n *\n * ## Nested Items\n * A radio button can also have a {@link #config-container} of additional {@link Core.widget.Container#config-items}.\n * These items can be displayed immediately following the field's label (which is the default when there is only one\n * item) or below the radio button. This can be controlled using the {@link #config-inline} config.\n *\n * In the demo below notice how additional fields are displayed for the checked radio button:\n *\n * {@inlineexample Core/widget/Radio-items.js vertical}\n *\n * For a simpler way to create a set of radio buttons, see the {@link Core.widget.RadioGroup} widget.\n *\n * @extends Core/widget/Checkbox\n * @classtype radio\n * @classtypealias radiobutton\n * @widget\n */\nexport default class Radio extends Checkbox {\n    //region Config\n    static $name = 'Radio';\n    static type = 'radio';\n    static alias = 'radiobutton';\n    static get configurable() {\n        return {\n            inputType : 'radio',\n            /**\n             * Set this to `true` so that clicking a checked radio button will clear its checked state.\n             * @config {Boolean}\n             * @default false\n             */\n            clearable : null,\n            uncheckedValue : undefined  // won't store to Container#values when unchecked\n        };\n    }\n    //endregion\n    //region Init\n    get textLabelCls() {\n        return super.textLabelCls + ' b-radio-label';\n    }\n    //endregion\n    internalOnClick(info) {\n        if (super.internalOnClick(info) !== false) {\n            if (this.checked && this.clearable) {\n                this.checked = false;\n            }\n        }\n    }\n    updateName(name) {\n        this.toggleGroup = name;\n    }\n    // Empty override to get rid of clear trigger\n    updateClearable() {}\n}\n// Register this widget type with its Factory\nRadio.initClass();\nRadio._$name = 'Radio';", "import ObjectHelper from '../helper/ObjectHelper.js';\nimport FieldSet from './FieldSet.js';\nimport Widget from './Widget.js';\nimport './Radio.js';\nimport './layout/Box.js';\n/**\n * @module Core/widget/RadioGroup\n */\n/**\n * The `RadioGroup` widget contains a set of related `{@link Core/widget/Radio}` button widgets.\n *\n * For example, to present three choices and have the user select one of them:\n *\n * ```javascript\n *  {\n *      type    : 'radiogroup',\n *      title   : 'Resolve Conflict',\n *      name    : 'resolution',\n *      value   : 'A',  // the default choice\n *      options : {\n *          A : 'Keep the original version',\n *          B : 'Use the new version',\n *          C : 'Reconcile individual conflicts'\n *      }\n *  }\n * ```\n *\n * {@inlineexample Core/widget/RadioGroup.js}\n *\n * The {@link #config-name} config is required for this widget and it will be assigned to all radio buttons created by\n * processing the {@link #config-options} config.\n *\n * ## Nested Items\n * Radio buttons can also have a {@link Core.widget.Radio#config-container} of additional\n * {@link Core.widget.Container#config-items}. These items can be displayed immediately following the field's label\n * (which is the default when there is only one item) or below the radio button. This can be controlled using the\n * {@link Core.widget.Radio#config-inline} config.\n *\n * In the demo below notice how additional fields are displayed for the checked radio button:\n *\n * {@inlineexample Core/widget/RadioGroupNested.js vertical}\n *\n * @extends Core/widget/FieldSet\n * @classtype radiogroup\n * @widget\n */\nexport default class RadioGroup extends FieldSet {\n    //region Config\n    static $name = 'RadioGroup';\n    static type = 'radiogroup';\n    static get configurable() {\n        return {\n            defaultType : 'radio',\n            /**\n             * Set this to `true` so that clicking the currently checked radio button will clear the check from all\n             * radio buttons in the group.\n             * @config {Boolean}\n             * @default false\n             */\n            clearable : null,\n            /**\n             * The name by which this widget's {@link #property-value} is accessed using the parent container's\n             * {@link Core.widget.Container#property-values}.\n             *\n             * The config must be provided as it is used to set the {@link Core.widget.Radio#config-name} of the\n             * child {@link Core.widget.Radio radio buttons}.\n             * @config {String}\n             */\n            name : null,\n            /**\n             * The set of radio button options for this radio button group. This is a shorthand for defining these in\n             * the {@link Core.widget.Container#config-items}. The keys of this object hold the radio button's\n             * {@link Core.widget.Radio#config-checkedValue} while the object values are a string for the radio button's\n             * {@link Core.widget.Radio#config-text} or a config object for that radio button.\n             *\n             * The {@link #property-value} of this radio button group will be one of the keys in this object or `null`\n             * if no radio button is checked.\n             *\n             * For example, consider the following configuration:\n             * ```javascript\n             *  {\n             *      type    : 'radiogroup',\n             *      name    : 'resolution',\n             *      value   : 'A',\n             *      options : {\n             *          A : 'Keep the original version',\n             *          B : 'Use the new version',\n             *          C : 'Reconcile individual conflicts'\n             *      }\n             *  }\n             * ```\n             *\n             * The above is equivalent to this configuration below using {@link #config-items}:\n             * ```javascript\n             *  {\n             *      type  : 'radiogroup',\n             *      items : [{\n             *          text         : 'Keep the original version',\n             *          name         : 'resolution',\n             *          ref          : 'resolution_A',\n             *          checked      : true,\n             *          checkedValue : 'A'\n             *      }, {\n             *          text         : 'Use the new version',\n             *          name         : 'resolution',\n             *          ref          : 'resolution_B',\n             *          checkedValue : 'B'\n             *      }, {\n             *          text         : 'Reconcile individual conflicts',\n             *          name         : 'resolution',\n             *          ref          : 'resolution_C',\n             *          checkedValue : 'C'\n             *      }]\n             *  }\n             * ```\n             * @config {Object<String,String|RadioConfig>} options\n             */\n            options : {\n                value : null,\n                $config : {\n                    merge : 'items'\n                }\n            },\n            defaultBindProperty : 'value'\n        };\n    }\n    get existingOptions() {\n        const { name } = this;\n        return this.ensureItems().filter(c => c.name === name);\n    }\n    get refPrefix() {\n        return `${this.name || this.ref || this.id}_`;\n    }\n    get selected() {\n        return this.existingOptions.filter(c => c.input.checked)[0] || null;\n    }\n    /**\n     * This property corresponds to the {@link Core.widget.Radio#config-checkedValue} of the currently\n     * {@link Core.widget.Radio#property-checked} radio button.\n     * @property {String}\n     */\n    get value() {\n        const { selected } = this;\n        return selected ? selected.checkedValue : null;\n    }\n    set value(v) {\n        this.existingOptions.forEach(c => {\n            c.isConfiguring = this.isConfiguring;\n            c.checked = c.checkedValue === v;\n            c.isConfiguring = false;\n        });\n    }\n    ensureItems() {\n        this.getConfig('options');\n        return super.ensureItems();\n    }\n    changeOptions(options, was) {\n        if (!(options && was && ObjectHelper.isDeeplyEqual(was, options))) {\n            return options;\n        }\n    }\n    convertOption(key, option, existing) {\n        const\n            me       = this,\n            { name } = me,\n            ret      = {\n                name,\n                type         : 'radio',\n                value        : key === me.value,\n                ref          : `${me.refPrefix}${key}`,\n                checkedValue : key\n            };\n        if (typeof option === 'string') {\n            ret.text = option;\n        }\n        else {\n            ObjectHelper.assign(ret, option);\n        }\n        return existing ? Widget.reconfigure(existing, ret) : ret;\n    }\n    isOurRadio(item) {\n        // Radio groups could be nested using field containers, so we need isRadio and name equality check:\n        return item.isRadio && item.name === this.name;\n    }\n    isolateFieldChange(field) {\n        // if this is one of our radio buttons, swallow the field change:\n        return this.isOurRadio(field);\n    }\n    onChildAdd(item) {\n        super.onChildAdd(item);\n        if (this.isOurRadio(item)) {\n            item.ion({\n                name         : item.id,\n                beforeChange : 'onRadioItemBeforeChange',\n                change       : 'onRadioItemChange',\n                click        : 'onRadioClick',\n                thisObj      : this\n            });\n        }\n    }\n    onChildRemove(item) {\n        if (this.isOurRadio(item)) {\n            this.detachListeners(item.id);\n        }\n        super.onChildRemove(item);\n    }\n    onRadioClick(ev) {\n        const { source } = ev;\n        if (source.checked && this.clearable && source.clearable == null) {\n            source.checked = false;\n        }\n    }\n    onRadioItemBeforeChange(ev) {\n        if (ev.checked) {\n            const\n                me = this,\n                { lastValue } = me;\n            if (!me.reverting && me.trigger('beforeChange', me.wrapRadioEvent(ev)) === false) {\n                if (lastValue != null && lastValue !== me.value) {\n                    me.reverting = true;\n                    ev.source.uncheckToggleGroupMembers();\n                    me.value = lastValue;\n                    me.lastValue = lastValue;\n                    me.reverting = false;\n                    return false;\n                }\n            }\n        }\n    }\n    onRadioItemChange(ev) {\n        const me = this;\n        if (ev.checked && !me.reverting) {\n            me.triggerFieldChange(me.wrapRadioEvent(ev));\n            me.lastValue = me.value;\n        }\n    }\n    wrapRadioEvent(ev) {\n        return {\n            from       : ev,\n            item       : ev.source,\n            userAction : ev.userAction,\n            lastValue  : this.lastValue,\n            value      : this.value\n        };\n    }\n    updateOptions() {\n        const\n            me                     = this,\n            { options, refPrefix } = me,\n            existingOptions        = me.existingOptions.reduce((m, c) => {\n                m[c.ref.substring(refPrefix.length)] = c;\n                return m;\n            }, {});\n        let index = 0,\n            key, option;\n        if (options) {\n            for (key in options) {\n                option = me.convertOption(key, options[key], existingOptions[key]);\n                delete existingOptions[key];\n                me.insert(option, index++);\n            }\n        }\n        const existing = Object.values(existingOptions);\n        if (existing?.length) {\n            me.remove(existing);\n            existing.forEach(c => c.destroy());\n        }\n    }\n    //endregion\n}\n// Register this widget type with its Factory\nRadioGroup.initClass();\nRadioGroup._$name = 'RadioGroup';", "import DomClassList from '../helper/util/DomClassList.js';\nimport FunctionHelper from '../helper/FunctionHelper.js';\nimport Button from './Button.js';\n/**\n * @module Core/widget/Tab\n */\n/**\n * This widget class is used to present items in a {@link Core.widget.TabPanel} on its {@link Core.widget.TabBar tabBar}.\n * A reference to this widget is stored via the {@link Core.widget.Widget#config-tab} config on the tab panel's items.\n *\n * ```javascript\n * let tabPanel = new TabPanel({\n *  items: [\n *      {\n *          title: 'Settings',\n *          // Tab configs\n *          tab : {\n *              // Show an icon in the tab\n *              icon : 'b-fa b-fa-cog'\n *          },\n *          items: [\n *              ...\n *          ]\n *      }\n *  ]\n * });\n * ```\n *\n * @extends Core/widget/Button\n * @classtype tab\n */\nexport default class Tab extends Button {\n    //region Config\n    static $name = 'Tab';\n    static type = 'tab';\n    static get configurable() {\n        return {\n            /**\n             * This config is set to `true` when this tab represents the `activeTab` of a {@link Core.widget.TabPanel}. It\n             * is managed by the tab panel is not set directly.\n             * @config {Boolean} active\n             * @default false\n             */\n            active : null,\n            /**\n             * This config is set to the ordinal position of this tab in the {@link Core.widget.TabPanel}. It is managed\n             * by the tab panel is not set directly.\n             * @config {Number} index\n             */\n            index : null,\n            /**\n             * This config is set to `true` when this tab represents the first tab of a {@link Core.widget.TabPanel}. It\n             * is managed by the tab panel is not set directly.\n             * @config {Boolean} isFirst\n             */\n            isFirst : null,\n            /**\n             * This config is set to `true` when this tab represents the last tab of a {@link Core.widget.TabPanel}. It\n             * is managed by the tab panel is not set directly.\n             * @config {Boolean} isLast\n             */\n            isLast : null,\n            /**\n             * The {@link Core.widget.Widget} in the {@link Core.widget.TabPanel} corresponding to this tab. This is\n             * managed by the tab panel is not set directly.\n             * @config {Core.widget.Widget} item\n             */\n            item : {\n                value : null,\n                $config : 'nullify'\n            },\n            itemCls : null,\n            /**\n             * The tab panel that owns this tab.\n             * @config {Core.widget.TabPanel} tabPanel\n             */\n            tabPanel : null,\n            /**\n             * The config property on this tab that will be set to the value of the {@link #config-titleSource} property\n             * of this tab's {@link #config-item}.\n             *\n             * By default, the {@link #config-text} property of the tab is set to the {@link Core.widget.Widget#config-title}\n             * property of its {@link #config-item}.\n             * @config {String} titleProperty\n             * @default\n             */\n            titleProperty : 'text',\n            /**\n             * The config property on this tab's {@link #config-item} that is used to set the value of the\n             * {@link #config-titleProperty} of this tab.\n             *\n             * By default, the {@link #config-text} property of the tab is set to the {@link Core.widget.Widget#config-title}\n             * property of its {@link #config-item}.\n             * @config {String} titleSource\n             * @default\n             */\n            titleSource : 'title',\n            role : 'tab'\n        };\n    }\n    compose() {\n        const\n            { active, cls, index, isFirst, isLast } = this,\n            setSize = this.owner.visibleChildCount;\n        return {\n            tabindex : 0,\n            'aria-selected' : active,\n            'aria-setsize'  : setSize,\n            'aria-posinset' : index + 1,\n            class : {\n                'b-tabpanel-tab' : 1,\n                'b-active'       : active,\n                'b-tab-first'    : isFirst,\n                'b-tab-last'     : isLast,\n                ...cls   // cls is a DomClassList\n            },\n            dataset : {\n                index\n            }\n        };\n    }\n    //endregion\n    updateIndex(index) {\n        this.isFirst = !index;\n    }\n    updateItem(item, was) {\n        const me = this;\n        if (was?.tab === me) {\n            was.tab = null;\n        }\n        if (item) {\n            item.tab = me;\n            me[me.titleProperty] = item[me.titleSource];\n            me.itemCls = item.cls;\n            me.ariaElement.setAttribute('aria-controls', item.id);\n            item.role = 'tabpanel';\n        }\n        me.itemChangeDetacher?.();\n        me.itemChangeDetacher = item && FunctionHelper.after(item, 'onConfigChange', 'onItemConfigChange', me, {\n            return : false\n        });\n        me.itemHideDetacher?.();\n        me.itemHideDetacher = item?.ion({\n            beforeChangeHidden   : 'onItemBeforeChangeHidden',\n            beforeHide           : 'onItemBeforeHide',\n            beforeUpdateDisabled : 'onItemBeforeUpdateDisabled',\n            thisObj              : me,\n            prio                 : 1000 // We must know before the layout intercepts and activates a sibling\n        });\n        me.syncMinMax();\n    }\n    updateItemCls(cls, was) {\n        const\n            { element } = this,\n            classList = element && DomClassList.from(element?.classList, /* returnEmpty= */true);\n        if (element) {\n            classList.remove(was).add(cls);\n            element.className = classList.value;\n        }\n    }\n    updateRotate(rotate, was) {\n        if (!rotate !== !was) {\n            this.syncMinMax();\n        }\n    }\n    syncMinMax() {\n        const\n            me = this,\n            { rotate, tabPanel } = me;\n        // We have to read the configs directly since there are getters that read the DOM styles:\n        let { _minWidth : minWidth, _minHeight : minHeight, _maxWidth : maxWidth, _maxHeight : maxHeight } = me;\n        // When a tab rotation changes, we need to pivot the min/max width values with the height values\n        if (tabPanel) {\n            const { tabMinWidth, tabMaxWidth } = tabPanel;\n            if (tabMinWidth != null) {\n                if (rotate) {\n                    // if we were previously not rotated, the tabMinWidth may be effecting our minWidth:\n                    if (minWidth === tabMinWidth) {\n                        minWidth = null;\n                    }\n                    // noinspection JSSuspiciousNameCombination\n                    minHeight = tabMinWidth;\n                }\n                else {\n                    // if we were previously rotated, the tabMinWidth may be effecting our minHeight:\n                    if (minHeight === tabMinWidth) {\n                        minHeight = null;\n                    }\n                    minWidth = tabMinWidth;\n                }\n            }\n            if (tabMaxWidth != null) {\n                if (rotate) {\n                    if (maxWidth === tabMaxWidth) {\n                        maxWidth = null;\n                    }\n                    // noinspection JSSuspiciousNameCombination\n                    maxHeight = tabMaxWidth;\n                }\n                else {\n                    if (maxHeight === tabMaxWidth) {\n                        maxHeight = null;\n                    }\n                    maxWidth = tabMaxWidth;\n                }\n            }\n            me.minWidth = minWidth;\n            me.minHeight = minHeight;\n            me.maxWidth = maxWidth;\n            me.maxHeight = maxHeight;\n        }\n    }\n    onItemBeforeChangeHidden({ source : hidingChild, hidden }) {\n        // If it's a hide/show that is not part of the layout's deactivating/activating, we must hide/show the tab\n        if (!hidingChild.$isDeactivating && !hidingChild.$isActivating) {\n            const { tabPanel } = this;\n            this.hidden = hidden;\n            // if tab to hide is active, let's active previous visible and enabled tab\n            if (hidden && hidingChild === tabPanel.activeItem) {\n                tabPanel.activateAvailableTab(hidingChild);\n            }\n        }\n    }\n    onItemBeforeHide() {\n        // If it's a hide that is not part of the layout's deactivating, we hide the tab\n        if (!this.item.$isDeactivating) {\n            this.hide();\n        }\n    }\n    onItemBeforeUpdateDisabled({ source : disablingChild, disabled }) {\n        const { tabPanel } = this;\n        this.disabled = disabled;\n        // if tab to disable is active, let's active previous visible and enabled tab\n        if (disablingChild === tabPanel.activeItem) {\n            tabPanel.activateAvailableTab(disablingChild);\n        }\n    }\n    onItemConfigChange({ name, value }) {\n        if (name === this.titleSource) {\n            this[this.titleProperty] = value;\n        }\n    }\n}\n// Register this widget type with its Factory\nTab.initClass();\nTab._$name = 'Tab';", "import Toolbar from './Toolbar.js';\nimport ArrayHelper from '../helper/ArrayHelper.js';\nimport './Tab.js';\n/**\n * @module Core/widget/TabBar\n */\nconst isTab = t => t.isTab;\n/**\n * A special toolbar used by {@link Core.widget.TabPanel} to present {@link Core.widget.Tab tabs} for the container's\n * items.\n *\n * The {@link Core.widget.Container#config-items} of a tab bar are typically managed by the tab panel, however,\n * items can be added that do not correspond to items in the tab panel. The {@link Core.widget.Widget#config-weight}\n * config of each tab defaults to 0 or the weight of its corresponding item.\n *\n * @extends Core/widget/Toolbar\n * @classtype tabbar\n */\nexport default class TabBar extends Toolbar {\n    static $name = 'TabBar';\n    static type = 'tabbar';\n    static get configurable() {\n        return {\n            defaultType : 'tab',\n            overflow : 'scroll',\n            role : 'tablist',\n            ignoreParentReadOnly : true\n        };\n    }\n    get firstTab() {\n        return this.tabAt(0);\n    }\n    get lastTab() {\n        return this.tabAt(-1);\n    }\n    get tabCount() {\n        return this._items.countOf(isTab);\n    }\n    get tabs() {\n        return ArrayHelper.from(this._items, isTab);\n    }\n    compose() {\n        return {\n            children : {\n                toolbarContent : {\n                    class : {\n                        'b-tabpanel-tabs' : 1\n                    }\n                }\n            }\n        };\n    }\n    indexOfTab(tab) {\n        return this._items.indexOf(tab, isTab);\n    }\n    onChildAdd(child) {\n        super.onChildAdd(child);\n        if (child.index == null) {\n            this.syncTabs();\n        }\n    }\n    onChildRemove(child) {\n        super.onChildRemove(child);\n        this.syncTabs();\n    }\n    onFocusIn() {\n        const { activeIndex } = this.owner;\n        // It must have a numeric active index set up\n        if (!isNaN(activeIndex)) {\n            this.tabs[activeIndex].focus();\n        }\n    }\n    syncTabs() {\n        const { tabs } = this;\n        for (let i = 0, n = tabs.length; i < n; ++i) {\n            tabs[i].index = i;\n            tabs[i].isFirst = !i;\n            tabs[i].isLast = i === n - 1;\n        }\n    }\n    tabAt(index) {\n        return this._items.find(isTab, index) || null;\n    }\n}\n// Register this widget type with its Factory\nTabBar.initClass();\nTabBar._$name = 'TabBar';", "import ArrayHelper from '../helper/ArrayHelper.js';\nimport ObjectHelper from '../helper/ObjectHelper.js';\nimport Panel from './Panel.js';\nimport Tab from './Tab.js';\nimport './TabBar.js';\nimport './layout/Card.js';\nimport GlobalEvents from '../GlobalEvents.js';\n/**\n * @module Core/widget/TabPanel\n */\nconst isMaximized = w => w.maximized;\n/**\n * A tab panel widget which displays a collection of tabs, each of which can contain other widgets (or simple HTML). This\n * widget has a {@link Core.widget.TabBar tab bar} on top of its contents, and each {@link Core.widget.Tab tab} can be\n * customized using the {@link Core.widget.Tab#config-tab} config.\n *\n * ```javascript\n * let tabPanel = new TabPanel({\n *  items: [\n *      {\n *          title: 'First',\n *          items: [\n *              { type: 'textfield', label: 'Name' },\n *              ...\n *          ]\n *      }, {\n *          title: 'Settings',\n *          tab : {\n *              // Show an icon in the tab\n *              icon : 'b-fa b-fa-cog'\n *          },\n *          items: [\n *              ...\n *          ]\n *      }\n *  ]\n * });\n *```\n *\n * The tab selector buttons are focusable elememts. `Enter` or `Space` activates a tab, and moves\n * focus into the newly visible tab item.\n *\n * {@inlineexample Core/widget/TabPanel.js}\n *\n * @extends Core/widget/Panel\n * @classtype tabpanel\n * @classtypealias tabs\n * @widget\n */\nexport default class TabPanel extends Panel {\n    //region Config\n    static $name = 'TabPanel';\n    static type = 'tabpanel';\n    static alias = 'tabs';\n    static get configurable() {\n        return {\n            /**\n             * The index of the initially active tab.\n             * @member {Number} activeTab\n             */\n            /**\n             * The index of the initially active tab.\n             * @config {Number}\n             * @default\n             */\n            activeTab : 0,\n            /**\n             * Specifies whether to slide tabs in and out of visibility.\n             * @config {Boolean}\n             * @default\n             */\n            animateTabChange : true,\n            /**\n             * Set the height of all tabs to match the tab with the highest content.\n             * @config {Boolean}\n             * @default\n             */\n            autoHeight : false,\n            defaultType : 'container',\n            focusable : false,\n            itemCls : 'b-tabpanel-item',\n            layout : {\n                type : 'card'\n            },\n            // Prevent child panels from displaying a header unless explicitly configured with one\n            suppressChildHeaders : true,\n            tabBar : {\n                type   : 'tabbar',\n                weight : -2000\n            },\n            /**\n             * Min width of a tab title. 0 means no minimum width. This is default.\n             * @config {Number}\n             * @default\n             */\n            tabMinWidth : null,\n            /**\n             * Max width of a tab title. 0 means no maximum width. This is default.\n             * @config {Number}\n             * @default\n             */\n            tabMaxWidth : null\n        };\n    }\n    //endregion\n    //region Init\n    /**\n     * The active tab index. Setting must be done through {@link #property-activeTab}\n     * @property {Number}\n     * @readonly\n     */\n    get activeIndex() {\n        return this.layout.activeIndex;\n    }\n    /**\n     * The active child widget. Setting must be done through {@link #property-activeTab}\n     * @property {Core.widget.Widget}\n     * @readonly\n     */\n    get activeItem() {\n        return this.layout.activeItem;\n    }\n    get activeTabItemIndex() {\n        const { activeTab, items, tabBar } = this;\n        return items.indexOf(tabBar.tabs[activeTab]?.item);\n    }\n    get bodyConfig() {\n        return ObjectHelper.merge({\n            className : {\n                'b-tabpanel-body' : 1\n            }\n        }, super.bodyConfig);\n    }\n    get focusElement() {\n        const activeTab = this.items[this.activeTab || 0];\n        return activeTab?.focusElement || activeTab?.tab?.focusElement;\n    }\n    get tabPanelBody() {\n        return this.bodyElement;\n    }\n    finalizeInit() {\n        super.finalizeInit();\n        const\n            me                    = this,\n            { activeTab, layout } = me,\n            { activeIndex }       = layout,\n            { tabs }              = me.tabBar,\n            activeTabItemIndex    = activeTab >= 0 && activeTab < tabs.length && me.items.indexOf(tabs[activeTab].item);\n        if (tabs.length > 0 && (activeTabItemIndex === false || activeTabItemIndex < 0)) {\n            throw new Error(`Invalid activeTab ${activeTab} (${tabs.length} tabs)`);\n        }\n        if (activeTabItemIndex !== activeIndex) {\n            // Since we are responding to configuration, we need to sync activeIndex to activeTab as if it were the\n            // initial value of activeIndex. This cannot be done (reasonably) during initialization of the card layout\n            // because of the possibility of tabless items, so we wait until the dust settles on the items, the tabBar\n            // and all other configs, but we must do the tab change silently (since the initial active item is set\n            // without such ceremony) and without animation (to avoid the appearance of the initial tab animating in)\n            layout.setActiveItem(activeTabItemIndex, activeIndex, {\n                animation : false,\n                silent    : true\n            });\n        }\n        layout.animateCardChange = me.animateTabChange;\n    }\n    onChildAdd(child) {\n        // The layout will hide inactive new items.\n        // And we must add our beforeHide listener *after* call super.\n        super.onChildAdd(child);\n        if (!this.initialItems) {\n            const\n                me          = this,\n                { tabBar }  = me,\n                config      = me.makeTabConfig(child),\n                // if child.tab === false, config will be null... no tab for this one\n                firstTab    = config && tabBar?.firstTab,\n                // if there are no tabs yet, this will be the first so we can skip all the indexing...\n                tabBarItems = firstTab && tabBar._items,\n                // not all items have tabs but the new child won't have one yet:\n                tabItems    = firstTab && ArrayHelper.from(me._items, it => it.tab || it === child),\n                // non-tabs could be in the tabBar, but the tabs must be contiguous:\n                index       = firstTab ? tabItems.indexOf(child) + tabBarItems.indexOf(firstTab) : 0;\n            if (config && tabBar) {\n                if (firstTab && child.weight == null && index < tabBarItems.count - 1) {\n                    tabBar.insert(config, index);\n                }\n                else {\n                    tabBar.add(config);\n                }\n            }\n        }\n    }\n    onChildRemove(child) {\n        const\n            { tab }   = child,\n            { items } = this;\n        if (tab) {\n            this.tabBar.remove(tab);\n            tab.destroy();\n        }\n        // Removing the active item, then show a sibling if any are left\n        if (child === this.activeItem) {\n            this._activeTab = null;\n            if (items.length) {\n                this.activeTab = items[Math.min(this.activeIndex, items.length - 1)];\n            }\n        }\n        super.onChildRemove(child);\n    }\n    //endregion\n    //region Tabs\n    isDisabledOrHiddenTab(tabIndex) {\n        const\n            { tabs } = this.tabBar,\n            tab      = tabs?.[tabIndex];\n        return tab && (tab.disabled || tab.hidden);\n    }\n    findAvailableTab(item, delta = 1) {\n        const\n            { tabs }  = this.tabBar,\n            tabCount  = tabs.length,\n            itemIndex = Math.max(0, tabs.indexOf(item.tab));\n        if (itemIndex) {\n            delta = -delta;\n        }\n        let activeTab;\n        for (let n = 1; n <= tabCount; ++n) {\n            //  itemIndex=2, tabCount=5:\n            //               n : 1, 2, 3, 4, 5\n            //      delta =  1 : 3, 4, 0, 1, 2\n            //      delta = -1 : 1, 0, 4, 3, 2\n            activeTab = (itemIndex + ((delta < 0) ? tabCount : 0) + n * delta) % tabCount;\n            if (!this.isDisabledOrHiddenTab(activeTab)) {\n                break;\n            }\n        }\n        return activeTab;\n    }\n    activateAvailableTab(item, delta = 1) {\n        this.activeTab = this.findAvailableTab(item, delta);\n    }\n    changeActiveTab(activeTab, oldActiveTab) {\n        const\n            me           = this,\n            {\n                tabBar,\n                layout\n            }            = me,\n            { tabCount } = tabBar;\n        if (activeTab.isWidget || ObjectHelper.isObject(activeTab)) {\n            // Must be a child widget, so add if it's not already in our items.\n            if (me.items.indexOf(activeTab) === -1) {\n                activeTab = me.add(activeTab);\n            }\n            activeTab = tabBar.indexOfTab(activeTab.tab);\n        }\n        else {\n            activeTab = parseInt(activeTab, 10);\n        }\n        if (!me.initialItems && tabCount > 0 && (activeTab < -1 || activeTab >= tabCount)) {\n            throw new Error(`Invalid activeTab ${activeTab} (${tabCount} tabs)`);\n        }\n        if (me.isDisabledOrHiddenTab(activeTab)) {\n            activeTab = me.findAvailableTab(activeTab);\n        }\n        // If we are animating, we must wait until any animation is finished\n        // before we can go ahead and apply the change.\n        if (layout.animateCardChange && layout.cardChangeAnimation) {\n            layout.cardChangeAnimation.then(cardChange => {\n                // If the animation resulted in not where we want, update the activeTab\n                if (cardChange?.activeIndex !== activeTab) {\n                    me._activeTab = activeTab;\n                    me.updateActiveTab(activeTab, oldActiveTab);\n                }\n            });\n        }\n        else {\n            return activeTab;\n        }\n    }\n    async updateActiveTab(activeTab, was) {\n        if (!this.initialItems) {\n            const { activeTabItemIndex, layout } = this;\n            if (activeTabItemIndex > -1) {\n                const\n                    oldActiveItem = this.items[was],\n                    newActiveItem = this.items[activeTabItemIndex];\n                // Avoid no-change\n                if (layout.activeItem !== newActiveItem) {\n                    if (layout.animateCardChange) {\n                        await this.tabSelectionPromise;\n                    }\n                    // Focus the active tab's button in TabPanel first so that focus doesn't leave\n                    // the TabPanel when ths active tab hides.\n                    if (oldActiveItem?.containsFocus) {\n                        oldActiveItem.tab.focus();\n                    }\n                    this.tabSelectionPromise = layout.setActiveItem(newActiveItem)?.promise;\n                }\n            }\n        }\n    }\n    changeTabBar(bar) {\n        this.getConfig('strips');\n        this.strips = {\n            tabBar : bar\n        };\n        return this.strips.tabBar;\n    }\n    makeTabConfig(item) {\n        const\n            { tab } = item,\n            config  = {\n                item,\n                type              : 'tab',\n                tabPanel          : this,\n                disabled          : Boolean(item.disabled),\n                hidden            : item.initialConfig.hidden,\n                weight            : item.weight || 0,\n                internalListeners : {\n                    click   : 'onTabClick',\n                    thisObj : this\n                },\n                localizableProperties : {\n                    // our tabs copy their text from the item's title and so are not directly localized\n                    text : false\n                }\n            };\n        if (tab === false) {\n            return null;\n        }\n        return ObjectHelper.isObject(tab) ? Tab.mergeConfigs(config, tab) : config;\n    }\n    updateItems(items, was) {\n        const\n            me                          = this,\n            { activeTab, initialItems } = me;\n        let index = 0,\n            tabs;\n        super.updateItems(items, was);\n        if (initialItems) {\n            tabs = Array.from(items, it => me.makeTabConfig(it)).filter(it => {\n                if (it) {\n                    it.index = index++;\n                    return true;\n                }\n            });\n            if (index) {\n                tabs[0].isFirst = true;\n                tabs[index - 1].isLast = true;\n                tabs[activeTab].active = true;\n                me.tabBar.add(tabs);\n                me.activeTab = activeTab;  // now we can validate the activeTab value\n            }\n        }\n    }\n    updateTabMinWidth(tabMinWidth) {\n        this.tabBar?.items.forEach(tab => {\n            if (tab.isTab) {\n                tab.minWidth = tabMinWidth;\n            }\n        });\n    }\n    updateTabMaxWidth(tabMaxWidth) {\n        this.tabBar?.items.forEach(tab => {\n            if (tab.isTab) {\n                tab.maxWidth = tabMaxWidth;\n            }\n        });\n    }\n    //endregion\n    //region Auto height\n    updateAutoHeight(autoHeight) {\n        this.detachListeners('themeAutoHeight');\n        autoHeight && GlobalEvents.ion({\n            name    : 'themeAutoHeight',\n            theme   : 'internalOnThemeChange',\n            thisObj : this\n        });\n        this.$measureHeight = autoHeight;\n    }\n    applyAutoHeight() {\n        const\n            me                             = this,\n            { layout, activeTab, element } = me,\n            { animateCardChange }          = layout;\n        // stop animate to change tabs on back stage.\n        layout.animateCardChange = false;\n        // override any previously applied height when measuring\n        me.height = null;\n        // Only actually apply a measured height if we are not inside a maximized widget\n        if (!me.up(isMaximized)) {\n            // get the max height comparing all tabs and apply to the tab\n            const maxContentHeight = me.height = Math.max(...me.items.map(tab => {\n                me.activeTab = tab;\n                return element.clientHeight;\n            })) + 1;\n            me.flex = `1 1 ${maxContentHeight}px`;\n        }\n        // Go back to initial configs\n        me.activeTab = activeTab;\n        layout.animateCardChange = animateCardChange;\n        me.$measureHeight = false;\n    }\n    internalOnThemeChange() {\n        if (this.isVisible) {\n            this.applyAutoHeight();\n        }\n        else {\n            this.$measureHeight = true;\n        }\n    }\n    //endregion\n    //region Events\n    // Called after beforeActiveItemChange has fired and not been vetoed before animation and activeItemChange\n    onBeginActiveItemChange(activeItemChangeEvent) {\n        const\n            tabs                           = this.tabBar.tabs,\n            { activeItem, prevActiveItem } = activeItemChangeEvent;\n        // Our UI changes immediately, our state must be accurate\n        this.activeTab = tabs.indexOf(activeItem?.tab);\n        // Deactivate previous active tab\n        if (prevActiveItem?.tab) {\n            prevActiveItem.tab.active = false;\n        }\n        if (activeItem?.tab) {\n            activeItem.tab.active = true;\n            activeItem.tab.show();\n        }\n    }\n    // Auto called because Card layout triggers the beforeActiveItemChange on its owner\n    onBeforeActiveItemChange(activeItemChangeEvent) {\n        /**\n         * The active tab is about to be changed. Return `false` to prevent this.\n         * @event beforeTabChange\n         * @preventable\n         * @param {Number} activeIndex - The new active index.\n         * @param {Core.widget.Widget} activeItem - The new active child widget.\n         * @param {Number} prevActiveIndex - The previous active index.\n         * @param {Core.widget.Widget} prevActiveItem - The previous active child widget.\n         */\n        return this.trigger('beforeTabChange', activeItemChangeEvent);\n    }\n    // Auto called because Card layout triggers the activeItemChange on its owner\n    onActiveItemChange(activeItemChangeEvent) {\n        /**\n         * The active tab has changed.\n         * @event tabChange\n         * @param {Number} activeIndex - The new active index.\n         * @param {Core.widget.Widget} activeItem - The new active child widget.\n         * @param {Number} prevActiveIndex - The previous active index.\n         * @param {Core.widget.Widget} prevActiveItem - The previous active child widget.\n         */\n        this.trigger('tabChange', activeItemChangeEvent);\n    }\n    onTabClick(event) {\n        this.activeTab = event.source.item;\n    }\n    onInternalPaint() {\n        super.onInternalPaint(...arguments);\n        // Measure tabs on first paint if configured to do so\n        if (this.$measureHeight) {\n            this.applyAutoHeight();\n        }\n    }\n    //endregion\n}\n// Register this widget type with its Factory\nTabPanel.initClass();\nTabPanel._$name = 'TabPanel';"],
  "mappings": "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",
  "names": []
}
