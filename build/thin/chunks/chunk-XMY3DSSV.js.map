{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/mixin/Featureable.js", "../../../../Core/lib/Core/mixin/Fencible.js", "../../../../Core/lib/Core/widget/FilterField.js", "../../../../Core/lib/Core/widget/mixin/Responsive.js"],
  "sourcesContent": ["import Base from '../Base.js';\nimport DynamicObject from '../util/DynamicObject.js';\n/**\n * @module Core/mixin/Featureable\n */\n/**\n * This mixin provides management of a set of features that can be manipulated via the `features` config.\n *\n * The first step in using `Featureable` is to define the family of features using `Factoryable` to declare a base\n * class for features to extend:\n *\n * ```javascript\n *  class SuperWidgetFeature extends InstancePlugin.mixin(Factoryable) {\n *      static get factoryable() {\n *          //\n *      }\n *  }\n * ```\n *\n * The various feature classes extend the `SuperWidgetFeature` base class and call `initClass()` to register themselves:\n *\n * ```javascript\n *  export default class AmazingSuperWidgetFeature extends SuperWidgetFeature {\n *      static get type() {\n *          return 'amazing';\n *      }\n *  }\n *\n *  AmazingSuperWidgetFeature.initClass();\n * ```\n *\n * A class that supports these features via `Featureable` is declared like so:\n *\n * ```javascript\n *  class SuperWidget extends Widget.mixin(Featureable) {\n *      static get featureable() {\n *          return {\n *              factory : SuperWidgetFeature\n *          };\n *      }\n *\n *      static get configurable() {\n *          return {\n *              // Declare the default features. These can be disabled by setting them to a falsy value. Using\n *              // configurable(), the value defined by this class is merged with values defined by derived classes\n *              // and ultimately the instance.\n *              features : {\n *                  amazing : {\n *                      ...\n *                  }\n *              }\n *          };\n *      }\n *  }\n *```\n * @mixin\n * @internal\n */\nexport default Target => class Featureable extends (Target || Base) {\n    static get $name() {\n        return 'Featureable';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Specifies the features to create and associate with the instance. The keys of this object are the names\n             * of features. The values are config objects for those feature instances.\n             *\n             * After construction, this property can be used to access the feature instances and even reconfigure them.\n             *\n             * For example:\n             * ```\n             *  instance.features.amazing = {\n             *      // reconfigure this feature\n             *  }\n             * ```\n             * This can also be done in bulk:\n             * ```\n             *  instance.features = {\n             *      amazing : {\n             *          // reconfigure this feature\n             *      },\n             *      // reconfigure other features\n             *  }\n             * ```\n             * @config {Object}\n             */\n            features : null\n        };\n    }\n    static get declarable() {\n        return [\n            /**\n             * This property getter returns options that control feature management for the derived class. This\n             * property getter must be defined by the class that mixes in `Featureable` in order to initialize the\n             * class properly.\n             * ```\n             *  class SuperWidget extends Widget.mixin(Featureable) {\n             *      static get featureable() {\n             *          return {\n             *              factory : SuperWidgetFeature\n             *          };\n             *      }\n             *      ...\n             *  }\n             * ```\n             * @static\n             * @member {Object} featureable\n             * @property {Core.mixin.Factoryable} featureable.factory The factoryable class (not one of its instances)\n             * that will be used to create feature instances.\n             * @property {String} [featureable.ownerName='client'] The config or property to assign on each feature as\n             * a reference to its creator, the `Featureable` instance.\n             * @internal\n             */\n            'featureable'\n        ];\n    }\n    static setupFeatureable(cls) {\n        const featureable = {\n            ownerName : 'client',\n            ...cls.featureable\n        };\n        featureable.factory.initClass();\n        // Replace the class/static getter with a new one that returns the complete featureable object:\n        Reflect.defineProperty(cls, 'featureable', {\n            get() {\n                return featureable;\n            }\n        });\n    }\n    doDestroy() {\n        const features = this.features;\n        super.doDestroy();\n        for (const name in features) {\n            const feature = features[name];\n            // Feature might be false or destroyed already by Grid (EventList mixes in CalendarMixin which has this mixin)\n            feature.destroy?.();\n        }\n    }\n    /**\n     * Returns `true` if the specified feature is active for this instance and `false` otherwise.\n     * @param {String} name The feature name\n     * @returns {Boolean}\n     */\n    hasFeature(name) {\n        return Boolean(this.features?.[name]);\n    }\n    changeFeatures(features, was) {\n        if (this.isDestroying) {\n            return;\n        }\n        const\n            me = this,\n            { featureable } = me.constructor,\n            manager = me.$features || (me.$features = new DynamicObject({\n                configName : 'features',\n                factory    : featureable.factory,\n                owner      : me,\n                ownerName  : featureable.ownerName\n            }));\n        manager.update(features);\n        if (!was) {\n            // Only return the target once. Further calls are processed above so we need to return undefined to ensure\n            // onConfigChange is called. By returning the same target on 2nd+ call, it passes the === test and won't\n            // trigger onConfigChange.\n            return manager.target;\n        }\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n    getCurrentConfig(options) {\n        const\n            result       = super.getCurrentConfig(options),\n            { features } = result;\n        if (features) {\n            // Replace empty configs with `true`\n            for (const featureName in features) {\n                if (Object.keys(features[featureName]).length === 0) {\n                    features[featureName] = true;\n                }\n            }\n        }\n        return result;\n    }\n};\n", "import ObjectHelper from '../helper/ObjectHelper.js';\nimport StringHelper from '../helper/StringHelper.js';\nimport Base from '../Base.js';\n/**\n * @module Core/mixin/Fencible\n */\nconst\n    { defineProperty } = Object,\n    { hasOwn }         = ObjectHelper,\n    fencibleSymbol     = Symbol('fencible'),\n    NONE               = [],\n    distinct           = array => Array.from(new Set(array)),\n    parseNames         = names => names ? distinct(StringHelper.split(names)) : NONE,\n    fenceMethod = (target, name, options) => {\n        if (options === true) {\n            options = name;\n        }\n        if (!ObjectHelper.isObject(options)) {\n            options = {\n                all : options\n            };\n        }\n        let any = parseNames(options.any);\n        const\n            all      = parseNames(options.all),\n            lock     = options.lock ? parseNames(options.lock) : distinct(all.concat(any)),\n            implName = name + 'Impl',\n            fence    = function(...params) {  // cannot use => since we need to receive \"this\" from the caller\n                const\n                    me = this,\n                    // For static methods we have to be careful to use hasOwn to check the \"point of entry\" (i.e., the\n                    // class reference used to call the method) since \".\" will climb the constructor's __proto__ chain\n                    // to find properties from a super class. This does not happen to instances since we never put our\n                    // fences object on the prototype chain.\n                    fences = hasOwn(me, fencibleSymbol) ? me[fencibleSymbol] : (me[fencibleSymbol] = {}),\n                    isFree = key => !fences[key];\n                if (all.every(isFree) && (!any || any.some(isFree))) {\n                    try {\n                        lock.forEach(key => (fences[key] = (fences[key] || 0) + 1));\n                        return me[implName](...params);\n                    }\n                    finally {\n                        lock.forEach(key => --fences[key]);\n                    }\n                }\n            };\n        any = any.length ? any : null;  // [].some(f) is always false, but [].every(f) is always true\n        !target[implName] && defineProperty(target, implName, {\n            configurable : true,\n            value        : target[name]\n        });\n        defineProperty(target, name, {\n            configurable : true,\n            value        : fence\n        });\n    };\n/**\n * A description of how to protect a method from reentry.\n *\n * A value of `true` is transformed using the key as the `all` value. For example, this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : true\n *      };\n * ```\n *\n * Is equivalent to this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : {\n *              all : ['foo']\n *          }\n *      };\n * ```\n *\n * Strings are split on spaces to produce the `all` array. For example, this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : 'foo bar'\n *      };\n * ```\n *\n * Is equivalent to this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : {\n *              all : ['foo', 'bar']\n *          }\n *      };\n * ```\n *\n * This indicates that `foo()` cannot be reentered if `foo()` or `bar()` are already executing. On entry to `foo()`,\n * both `foo()` and `bar()` will be fenced (prevented from entering).\n *\n * @typedef {Object} MethodFence\n * @property {String|String[]} [all] One or more keys that must all be currently unlocked to allow entry to the fenced\n * method. String values are converted to an array by splitting on spaces.\n * @property {String|String[]} [any] One or more keys of which at least one must be currently unlocked to allow entry\n * to the fenced method. String values are converted to an array by splitting on spaces.\n * @property {String|String[]} [lock] One or more keys that will be locked on entry to the fenced method and released\n * on exit. String values are converted to an array by splitting on spaces. By default, this array includes all keys\n * in `all` and `any`.\n */\n/**\n * This mixin is used to apply reentrancy barriers to methods. For details, see\n * {@link Core.mixin.Fencible#property-fenced-static}.\n * @mixin\n * @internal\n */\nexport default Target => class Fencible extends (Target || Base) {\n    static $name = 'Fencible';\n    static declarable = [\n        /**\n         * This class property returns an object that specifies methods to be wrapped to prevent reentrancy.\n         *\n         * It is used like so:\n         * ```javascript\n         *  class Foo extends Base.mixin(Fencible) {\n         *      static fenced = {\n         *          reentrantMethod : true\n         *      };\n         *\n         *      reentrantMethod() {\n         *          // things() may cause reentrantMethod() to be called...\n         *          // but we won't be allowed to reenter this method since we are already inside it\n         *          this.things();\n         *      }\n         *  }\n         * ```\n         *\n         * This can also be used to protect mutually reentrant method groups:\n         *\n         * ```javascript\n         *  class Foo extends Base.mixin(Fencible) {\n         *      static fenced = {\n         *          foo : 'foobar'\n         *          bar : 'foobar'\n         *      };\n         *\n         *      foo() {\n         *          console.log('foo');\n         *          this.bar();\n         *      }\n         *\n         *      bar() {\n         *          console.log('bar');\n         *          this.foo();\n         *      }\n         *  }\n         *\n         *  instance = new Foo();\n         *  instance.foo();\n         *  >> foo\n         *  instance.bar();\n         *  >> bar\n         * ```\n         *\n         * The value for a fenced method value can be `true`, a string, an array of strings, or a\n         * {@link #typedef-MethodFence} options object.\n         *\n         * Internally these methods are protected by assigning a wrapper function in their place. The original function\n         * is moved to a new named property by appending 'Impl' to the original name. For example, in the above code,\n         * `foo` and `bar` are wrapper functions that apply reentrancy protection and call `fooImpl` and `barImpl`,\n         * respectively. This is important for inheritance and `super` calling because the new name must be used in\n         * order to retain the guard function implementations.\n         *\n         * @static\n         * @member {Object} fenced\n         * @internal\n         */\n        'fenced'\n    ];\n    static setupFenced(cls) {\n        let { fenced } = cls;\n        const\n            statics = fenced.static,\n            pairs = [];\n        if (statics) {\n            fenced = { ...fenced };\n            delete fenced.static;\n            pairs.push([statics, cls]);\n        }\n        pairs.push([fenced, cls.prototype]);\n        for (const [methods, target] of pairs) {\n            for (const methodName in methods) {\n                fenceMethod(target, methodName, methods[methodName]);\n            }\n        }\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import TextField from '../../Core/widget/TextField.js';\n/**\n * @module Core/widget/FilterField\n */\n/**\n * A simple text field for filtering a store.\n *\n * Allows filtering by {@link #config-field field}:\n *\n * ```javascript\n * const filterField = new FilterField({\n *    store : eventStore,\n *    field : 'name'\n * });\n * ```\n *\n * Or by using a {@link #config-filterFunction filter function} for greater control/custom logic:\n *\n * ```javascript\n * const filterField = new FilterField({\n *    store          : eventStore,\n *    filterFunction : (record, value) => record.name.includes(value)\n * });\n * ```\n *\n * @extends Core/widget/TextField\n * @classtype filterfield\n * @widget\n */\nexport default class FilterField extends TextField {\n    static $name = 'FilterField';\n    static type = 'filterfield';\n    static get configurable() {\n        return {\n            /**\n             * The model field name to filter by. Can optionally be replaced by {@link #config-filterFunction}\n             * @config {String}\n             * @category Filtering\n             */\n            field : null,\n            /**\n             * The store to filter.\n             * @config {Core.data.Store}\n             * @category Filtering\n             */\n            store : null,\n            /**\n             * Optional filter function to be called with record and value as parameters for store filtering.\n             * ```javascript\n             * {\n             *     type           : 'filterfield',\n             *     store          : myStore,\n             *     filterFunction : (record, value)  => {\n             *        return record.text.includes(value);\n             *     }\n             * }\n             * ```\n             *\n             * @config {Function}\n             * @param {Core.data.Model} record Record for comparison\n             * @param {String} value Value to compare with\n             * @returns {Boolean} Returns `true` if record matches comparison requirements\n             *\n             * @category Filtering\n             */\n            filterFunction : null,\n            clearable            : true,\n            revertOnEscape       : true,\n            ignoreParentReadOnly : true,\n            keyStrokeChangeDelay : 100,\n            onChange({ value }) {\n                const { store, field, filterFunction } = this;\n                if (store) {\n                    const filterId = `${field || this.id}-Filter`;\n                    if (value.length === 0) {\n                        store.removeFilter(filterId);\n                    }\n                    else {\n                        let filterBy;\n                        if (filterFunction) {\n                            filterBy = record => filterFunction(record, value);\n                        }\n                        else {\n                            // We filter using a RegExp, so quote significant characters\n                            value = value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n                            filterBy = record => record.getValue(field)?.match(new RegExp(value, 'i'));\n                        }\n                        // A filter with an id replaces any previous filter with that id.\n                        // Leave any other filters which may be in use in place.\n                        store.filter({\n                            id : filterId,\n                            filterBy\n                        });\n                    }\n                }\n            }\n        };\n    }\n    updateValue(value, old) {\n        super.updateValue(value, old);\n        // Initial value, apply it\n        if (value && this.isConfiguring) {\n            this.onChange({ value });\n        }\n    }\n};\nFilterField.initClass();\nFilterField._$name = 'FilterField';", "import Base from '../../Base.js';\nimport BrowserHelper from '../../helper/BrowserHelper.js';\nimport FunctionHelper from '../../helper/FunctionHelper.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\nimport Delayable from '../../mixin/Delayable.js';\nimport Fencible from '../../mixin/Fencible.js';\n/**\n * @module Core/widget/mixin/Responsive\n */\nconst\n    EMPTY = [],\n    isStateName = name => name[0] !== '*',\n    pop = (object, key) => {\n        const ret = object[key] || null;\n        delete object[key];\n        return ret;\n    },\n    responsiveRootFn = widget => widget.responsiveRoot,\n    scoring = {\n        number : threshold => ({ width }) => width <= threshold && threshold\n    },\n    splitConfigs = configs => {\n        delete configs.once;\n        return {\n            callback : pop(configs, 'callback'),\n            configs,\n            when     : pop(configs, 'when')\n        };\n    },\n    // We cheat a bit and leave \"once\", \"when\" and \"callback\" in the config object for the merge.\n    splitMergedConfigs = (cls, ...parts) => {\n        const\n            once = parts.flatMap(p => p?.once || EMPTY), // onces are not arrays, so are unchanged; ==> filter().map()\n            configs = cls.mergeConfigs(...parts),\n            ret = splitConfigs(configs);\n        ret.once = once.length ? splitConfigs(cls.mergeConfigs(...once)) : null;\n        return ret;\n    },\n    // Allow responsiveTarget to be a DOM element? (see git history for wrapElement impl)\n    wrapWidget = (widget, handler) => {\n        let triggers,\n            desc = Proxy.revocable(widget, {\n                get(o, name) {\n                    if (triggers) {\n                        triggers[name] = true;\n                    }\n                    return widget[name];\n                }\n            }),\n            detacher = FunctionHelper.after(widget, 'onConfigChange', (ignore, { name }) => {\n                if (triggers?.[name]) {\n                    handler();\n                }\n            }),\n            resizer = widget.ion({\n                resize : () => {\n                    handler();\n                }\n            });\n        widget.monitorResize = true;\n        return {\n            widget,\n            get object() {\n                return desc?.proxy;\n            },\n            destroy() {\n                if (desc) {\n                    desc.revoke();\n                    detacher();\n                    resizer();\n                    desc = detacher = resizer = null;\n                }\n            },\n            reset() {\n                triggers = Object.create(null);\n            }\n        };\n    };\n/**\n * A state definition object used by the {@link Core.widget.mixin.Responsive#config-responsive} config property.\n *\n * ```javascript\n *  {\n *      responsive : {\n *          small : {\n *              // a ResponsiveState object\n *              when : 400,\n *\n *              callback() {\n *                  console.log('Applied small not first time');\n *              },\n *\n *              once : {\n *                  mode : 'full',\n *\n *                  callback() {\n *                      console.log('Applied small first time');\n *                  }\n *              }\n *\n *              // All other properties are configs to apply when\n *              // the state is active\n *              text  : null,\n *              color : 'b-blue'\n *          }\n *      }\n *  }\n * ```\n *\n * See {@link Core.widget.mixin.Responsive} for more details.\n *\n * @typedef ResponsiveState\n * @property {ResponsiveState} once A `ResponsiveState` object applied only one time when a state is first activated. It\n * is not valid to specify a `when` or `once` property on these `ResponsiveState` objects. It is valid to supply a\n * `callback`, and if done, this callback will be called instead of the `callback` on the parent `ResponsiveState`\n * object on first activation.\n * @property {Function|Number} when A two argument function to return the score for the state, or a number for both the\n * width threshold and score. The arguments passed are as follows:\n *  - `widget` The {@link Core.widget.mixin.Responsive#config-responsiveTarget widget} whose properties should determine\n *  the state's score\n *  - `browserHelper` The {@link Core.helper.BrowserHelper} singleton object\n * @property {Function} [callback] An optional callback, called when the state is activated. This function receives an\n * object with the following properties:\n *  - `source` The instance whose state is being activated (typically a {@link Core.widget.Widget})\n *  - `target` The {@link Core.widget.Widget} identified as the {@link Core.widget.mixin.Responsive#config-responsiveTarget}\n *  - `state` The name of the newly active responsive state\n *  - `oldState` The name of the previously active responsive state\n */\n/**\n * A breakpoint definition. Used when defining breakpoints, see {@link #config-breakpoints}.\n *\n * ```javascript\n * {\n *     name    : 'Small',\n *     configs : {\n *         text  : null,\n *         color : 'b-blue'\n *     },\n *     callback() {\n *         console.log('Applied small');\n *     }\n * }\n * ```\n *\n * @typedef Breakpoint\n * @property {String} name Name of the breakpoint\n * @property {Object} [configs] An optional configuration object to apply to the widget when the breakpoint is activated\n * @property {Function} [callback] An optional callback, called when the breakpoint is activated\n * @deprecated 5.0 Breakpoints have been replaced by {@link Core.widget.mixin.Responsive#config-responsive}.\n */\n/**\n * This mixin provides management of a named set of {@link #typedef-ResponsiveState} objects that are conditionally\n * applied in response to the widget's size or other platform details. The names of the {@link #typedef-ResponsiveState}\n * objects are the keys of the {@link #config-responsive} config object. For example:\n *\n * ```javascript\n *  class ResponsiveButton extends Button.mixin(Responsive) {\n *      static configurable = {\n *          responsive : {\n *              small : {\n *                  // this is a ResponsiveState object named \"small\"\n *                  text : 'S'\n *              },\n *              medium : {\n *                  text : 'M'\n *              }\n *              large : {\n *                  text : 'L'\n *              }\n *          }\n *      };\n *  }\n * ```\n *\n * When the conditions are right for the button to be in the `'small'` responsive state, the `text` config will be set\n * to `'S'`.\n *\n * Any desired configs can be present in a {@link #typedef-ResponsiveState} object, however, the `when` and `callback`\n * properties have special meaning to this mixin and are reserved.\n *\n * ## Selecting the Responsive State\n *\n * To determine the current responsive state, the `when` property is consulted for each candidate state.\n *\n * If `when` is a number, it is understood to be a width threshold and, if the widget's `width` is equal or less than\n * that value, the score is that value. For example, a value of 400 would produce a score of 400 if the widget's width\n * were less than or equal to 400. If the widget's width is greater than 400, the state would be skipped.\n *\n * If `when` is a function, it is called with two parameters: a readonly reference to the widget and the\n * {@link Core.helper.BrowserHelper} singleton object. The function should return the numeric score if the state is\n * applicable, or `null` or `false` if the state should be skipped.\n *\n * The state that has the minimum score is selected as the responsive state for the widget.\n *\n * Consider the default responsive states and their `when` values:\n *\n * ```javascript\n *  responsive : {\n *      small : {\n *          when : 400\n *      },\n *\n *      medium : {\n *          when : 800\n *      },\n *\n *      large : {\n *          when : () => Infinity\n *      },\n *\n *      '*' : {}\n *  },\n * ```\n *\n * For example, if the width of the widget is 300: the score for the `small` responsive state is 400, the score for\n * the `medium` responsive state is 800, and the score for `large` is infinity. In effect, the `large` state is always\n * a candidate, but will also always lose to other candidate states. In this case, the `small` state has the minimum\n * score and is selected as the responsive state.\n *\n * If the width of the widget is 600: the `small` state would be skipped, while the `medium` and `large` states would\n * produce the same scores resulting in `medium` being the responsive state.\n *\n * The `when` functions have access to any properties of the widget instance in the first argument, but are also passed\n * the {@link Core.helper.BrowserHelper} singleton as a second argument. This can be used as shown in the following,\n * over-simplified example:\n *\n * ```javascript\n *  class ResponsiveWidget extends Widget.mixin(Responsive) {\n *      static configurable = {\n *          responsive : {\n *              small : {\n *                  when : ({ width }, { isMobileSafari }) => isMobileSafari && width <= 600 && 10\n *                  text : 'iPhone'\n *              },\n *              medium : {\n *                  when : ({ width }, { isMobileSafari }) => isMobileSafari && width <= 1024 && 20\n *                  text : 'iPad'\n *              }\n *              large : {\n *                  text : 'Desktop'\n *              }\n *          }\n *      };\n *  }\n * ```\n *\n * It is best to avoid mixing `when` threshold values and `when` functions as the resulting scores can be confusing.\n * @mixin\n */\nexport default Target => class Responsive extends (Target || Base).mixin(Delayable, Fencible) {\n    static $name = 'Responsive';\n    static configurable = {\n        /**\n         * Specifies the various responsive state objects keyed by their name. Each key (except `'*'`, see below) in\n         * this object is a state name (see {@link #config-responsiveState}) and its corresponding value is the\n         * associated {@link #typedef-ResponsiveState} object.\n         *\n         * Some properties of a `ResponsiveState` object are special, for example `when` and `callback`. All other\n         * properties of the state object are config properties to apply when that state is active.\n         *\n         * The `when` property can be a function that computes the score for the state. The state whose `when` function\n         * returns the lowest score is selected and its non-special properties will be assigned to the instance. If\n         * `when` is a number, it will be converted into a scoring function (see below).\n         *\n         * A `when` function accepts two readonly parameters and returns either a numeric score if the state should be\n         * considered, or `false` or `null` if the state should be ignored (i.e., it does match with the current state).\n         *\n         * The first parameter is a readonly proxy for the {@link #config-responsiveTarget widget} whose size and other\n         * properties determine the state's score. The proxy tracks property access to that widget in order to update\n         * the responsive state should any of those properties change.\n         *\n         * The second argument to a `when` function is the {@link Core.helper.BrowserHelper} singleton. This allows\n         * a `when` function to conveniently test platform and browser information.\n         *\n         * The state whose `when` function returns the lowest score is selected as the new\n         * {@link #config-responsiveState} and its config object (minus the `when` function and other special\n         * properties) is applied to the instance.\n         *\n         * If `when` is a number, it is converted to function. The following two snippets produce the same `when`\n         * scoring:\n         *\n         * ```javascript\n         *      small : {\n         *          when : 400,\n         *          ...\n         *      }\n         * ```\n         *\n         * The above converted to:\n         *\n         * ```javascript\n         *      small : {\n         *          when : ({ width }) => width <= 400 && 400,\n         *          ...\n         *      }\n         * ```\n         * Selecting the lowest score as the winner allows for the simple conversion of width threshold to score value,\n         * such that the state with the smallest matching width is selected.\n         *\n         * If the `responsive` config object has an asterisk key (`'*'`), its value is used as the default set of config\n         * properties to apply all other states. This will be the only config properties to apply if no `when` function\n         * returns a score. In this way, this special state object acts as a default state as well as a set of\n         * default values for other states to share. This state object has no `when` function.\n         *\n         * The default for this config is:\n         * ```javascript\n         *  {\n         *      small : {\n         *          when : 400\n         *      },\n         *\n         *      medium : {\n         *          when : 800\n         *      },\n         *\n         *      large : {\n         *          when : () => Infinity\n         *      },\n         *\n         *      '*' : {}\n         *  }\n         * ```\n         *\n         * A derived class (or instance) can use these states by populating other config properties, define\n         * additional states, and/or adjust the `when` properties to use different size thresholds.\n         *\n         * @config {Object}\n         */\n        responsive : {\n            $config : {\n                lazy : 'paint'\n            },\n            value : null\n        },\n        /**\n         * The defaults for the {@link #config-responsive} config. These are separated so that the act of setting the\n         * {@link #config-responsive} config is what triggers additional processing.\n         * @config {Object}\n         * @internal\n         * @default\n         */\n        responsiveDefaults : {\n            small : {\n                when : 400\n            },\n            medium : {\n                when : 800\n            },\n            large : {\n                when : () => Infinity\n            },\n            '*' : {}\n        },\n        /**\n         * Set to `true` to mark this instance as the default {@link #config-responsiveTarget} for descendants that do\n         * not specify an explicit {@link #config-responsiveTarget} of their own.\n         * @config {Boolean}\n         * @default false\n         */\n        responsiveRoot : null,\n        /**\n         * The name of the active state of the {@link #config-responsive} config. This is assigned internally\n         * and should not be assigned directly.\n         *\n         * @config {String}\n         * @readonly\n         */\n        responsiveState : null,\n        /**\n         * The widget whose size and other properties drive this object's responsive behavior. If this config is not\n         * specified, the closest ancestor that specified {@link #config-responsiveRoot responsiveRoot=true} will be\n         * used. If there is no such ancestor, then the instance using this mixin is used.\n         *\n         * If this value is set to `'@'`, then this instance is used even if there is a {@link #config-responsiveRoot}\n         * ancestor.\n         *\n         * If this config is a string that starts with `'@'`, the text following the first character is the name of the\n         * property on this instance that holds the target to use. For example, `'@owner'` to use the value of the\n         * `owner` property as the responsive target.\n         *\n         * If this config is a string that does not start with `'@'`, that string is passed to\n         * {@link Core.widget.Widget#function-up} to find the closest matching ancestor.\n         *\n         * If another widget is used as the `responsiveTarget` and if this instance does not specify any explicit `when`\n         * properties in its {@link #config-responsive} config, then the `when` definitions of the `responsiveTarget`\n         * will be used for this instance.\n         * @config {String|Core.widget.Widget}\n         */\n        responsiveTarget : {\n            value   : null,\n            $config : {\n                lazy : 'paint'\n            }\n        },\n        responsiveWidget : {\n            value   : null,\n            $config : {\n                nullify : true\n            }\n        },\n        /**\n         * Defines responsive breakpoints, based on max-width or max-height.\n         *\n         * When the widget is resized, the defined breakpoints are queried to find the closest larger or equal\n         * breakpoint for both width and height. If the found breakpoint differs from the currently applied, it is\n         * applied.\n         *\n         * Applying a breakpoint triggers an event that applications can catch to react to the change. It also\n         * optionally applies a set of configs and calls a configured callback.\n         *\n         * ```javascript\n         * breakpoints : {\n         *     width : {\n         *         50 : { name : 'small', configs : { text : 'Small', ... } }\n         *         100 : { name : 'medium', configs : { text : 'Medium', ... } },\n         *         '*' : { name : 'large', configs : { text : 'Large', ... } }\n         *     }\n         * }\n         * ```\n         *\n         * @config {Object}\n         * @param {Object} width Max-width breakpoints, with keys as numerical widths (or '*' for larger widths than the\n         * largest defined one) and the value as a {@link #typedef-Breakpoint breakpoint definition}\n         * @param {Object} height Max-height breakpoints, with keys as numerical heights (or '*' for larger widths than\n         * the largest defined one) and the value as a {@link #typedef-Breakpoint breakpoint definition}\n         * @deprecated 5.0 Use {@link #config-responsive} instead.\n         */\n        breakpoints : null\n    };\n    static delayable = {\n        responsiveUpdate : 'raf'\n    };\n    static fenced = {\n        syncResponsiveWidget : true\n    };\n    static prototypeProperties = {\n        responsiveStateChanges : 0,\n        responsiveUpdateCount  : 0\n    };\n    get isResponsivePending() {\n        return this.responsiveUpdateCount === 0 && this.hasConfig('responsive');\n    }\n    get isResponsiveUpdating() {\n        return this._responsiveUpdating || this.responsiveWidget?._responsiveUpdating;\n    }\n    // responsive\n    updateResponsive(responsive) {\n        const\n            me  = this,\n            cls = me.constructor,\n            { responsiveDefaults } = me,\n            stateNames = Array.from(\n                new Set(ObjectHelper.keys(responsive).concat(ObjectHelper.keys(responsiveDefaults)))).filter(isStateName);\n        let states = null,\n            hasWhen, name, state, when;\n        if (responsive) {\n            states = {\n                '*' : splitMergedConfigs(cls, responsiveDefaults['*'], responsive['*'])\n            };\n            for (name of stateNames) {\n                state = responsive[name];\n                if (state !== null && state !== false) {\n                    // Track whether any state has an explicit \"when\" property\n                    hasWhen = hasWhen || (state && 'when' in state);\n                    states[name] = splitMergedConfigs(cls,\n                        responsiveDefaults['*'], responsiveDefaults[name], responsive['*'], state);\n                    when = states[name].when;\n                    states[name].when = scoring[typeof when]?.(when) || when;  // convert numbers to fns based on width\n                }\n            }\n        }\n        me.$responsiveStates = states;\n        me.$responsiveWhen = hasWhen;\n        me.syncResponsiveWidget();\n    }\n    // responsiveState\n    updateResponsiveState(state, oldState) {\n        const\n            me = this,\n            { $responsiveStates : states } = me,\n            initial = ++me.responsiveStateChanges === 1,\n            classList = me.element?.classList,\n            defaults = states['*'],\n            def = states[state] || defaults,\n            once = initial && (def.once || defaults.once),\n            isStateful = initial && me.isStateful,\n            target = me.responsiveWidget;\n        let config = def.configs,\n            otherConfigs = once?.configs;\n        if (otherConfigs) {\n            // overlay \":once\" configs on normal configs (the mergeConfigs method clones the first parameter before\n            // merging it with other values)\n            config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;\n        }\n        oldState && classList?.remove(`b-responsive-${oldState.toLowerCase()}`);\n        state && classList?.add(`b-responsive-${state.toLowerCase()}`);\n        if (isStateful) {\n            // our responsiveState is munged with the stateId to retrieve state info for this responsiveState (to track\n            // state by small/medium/large/etc). If we don't load the state on each call here we would end up smashing\n            // the values saved in state with those defined by the developer in the responsive config.\n            otherConfigs = me.loadStatefulData();\n            if (otherConfigs) {\n                // if there is stateful data for this responsiveState, it takes priority over our config object\n                config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;\n            }\n            // We don't want responsive changes to configs to trigger state save:\n            me.suspendStateful();\n        }\n        me._responsiveUpdating = true;\n        try {\n            /**\n             * Triggered before a new {@link #config-responsiveState} is applied.\n             * @event beforeResponsiveStateChange\n             * @param {Core.widget.Widget} source The widget whose `responsiveState` is to be changed\n             * @param {String} state The new value for the widget's `responsiveState`\n             * @param {String} oldState The previous value for the widget's `responsiveState`\n             */\n            me.trigger?.('beforeResponsiveStateChange', { state, oldState, target });\n            config && me.setConfig(config);\n            def.callback?.({ source : me, state, oldState, target, initial });\n            once?.callback?.({ source : me, state, oldState, target, initial });\n            /**\n             * Triggered when a new {@link #config-responsiveState} is applied.\n             * @event responsiveStateChange\n             * @param {Core.widget.Widget} source The widget whose `responsiveState` has changed\n             * @param {String} state The new value for the widget's `responsiveState`\n             * @param {String} oldState The previous value for the widget's `responsiveState`\n             */\n            me.trigger?.('responsiveStateChange', { state, oldState, target });\n            // we normally would check for !me.isConstructing or !me.isConfiguring but this event needs to be fired\n            // during that time to allow the app to receive the initial responsive state since it is dynamic (i.e.,\n            // not something the app has configured into the widget)\n        }\n        finally {\n            // Be sure to reset these even if an exception occurs\n            me._responsiveUpdating = false;\n            isStateful && me.resumeStateful();\n        }\n    }\n    // responsiveTarget\n    get responsiveTarget() {\n        return this.responsiveWidget || this._responsiveTarget;\n    }\n    updateResponsiveTarget() {\n        this.syncResponsiveWidget();\n    }\n    // responsiveWidget\n    updateResponsiveWidget(target) {\n        const\n            me = this,\n            // being a delayable raf method effectively auto-bind's our this pointer\n            responsiveUpdate = target && me.responsiveUpdate;\n        me.$responsiveWrapper?.destroy();\n        me.$responsiveWrapper = target && wrapWidget(target, responsiveUpdate);\n        responsiveUpdate?.now();\n    }\n    // Support methods\n    responsiveUpdate() {\n        const\n            me = this,\n            { $responsiveStates : states, $responsiveWrapper : wrapper } = me,\n            responsiveTarget = wrapper?.widget;\n        if (states && wrapper) {\n            let best = null,\n                bestScore = 0,  // 0 doesn't get used (since !best) but data flow warnings arise w/o assignment\n                fromWhen = states,\n                score, state;\n            // If this instance has a responsiveWidget (via responsiveTarget being set to a widget), and that widget\n            // is not this instance, and if this instance did not specify any explicit \"when\" properties in its own\n            // \"responsive\" config, use those of the target\n            if (responsiveTarget && responsiveTarget !== me && !me.$responsiveWhen) {\n                responsiveTarget.getConfig('responsive');  // make sure the config has been evaluated\n                fromWhen = responsiveTarget.$responsiveStates || fromWhen;\n            }\n            wrapper.reset();\n            for (state in states) {\n                if (state !== '*') {\n                    score = fromWhen[state].when(wrapper.object, BrowserHelper);\n                    if (score != null && score !== false && (!best || score < bestScore)) {\n                        best = state;\n                        bestScore = score;\n                    }\n                }\n            }\n            ++me.responsiveUpdateCount; // this unlocks statefulId() getter in State mixin\n            me.responsiveState = best;\n        }\n    }\n    syncResponsiveWidget() {\n        const me = this;\n        let widget = null,\n            responsiveTarget;\n        if (!me.isDestroying && me.responsive) {\n            responsiveTarget = me.responsiveTarget;\n            if (!(widget = responsiveTarget)) {\n                widget = (!me.responsiveRoot && me.up?.(responsiveRootFn)) || me;\n            }\n            else if (typeof responsiveTarget === 'string') {\n                widget = responsiveTarget === '@' ? me : (\n                    responsiveTarget[0] === '@' ? me[responsiveTarget.substring(1)] : me.up(responsiveTarget)\n                );\n                if (!widget) {\n                    throw new Error(`No match for responsiveTarget=\"${responsiveTarget}\"`);\n                }\n            }\n            if (!widget.isWidget) {\n                throw new Error(`${widget.constructor.$$name} is not a widget and cannot be a responsiveTarget`);\n            }\n        }\n        me.responsiveWidget = widget;\n        return widget;\n    }\n    changeBreakpoints(breakpoints) {\n        ObjectHelper.assertObject(breakpoints, 'breakpoints');\n        // Normalize breakpoints\n        if (breakpoints?.width) {\n            Object.keys(breakpoints.width).forEach(key => {\n                breakpoints.width[key].maxWidth = key;\n            });\n        }\n        if (breakpoints?.height) {\n            Object.keys(breakpoints.height).forEach(key => {\n                breakpoints.height[key].maxHeight = key;\n            });\n        }\n        return breakpoints;\n    }\n    updateBreakpoints(breakpoints) {\n        if (breakpoints) {\n            this.monitorResize = true;\n        }\n    }\n    // Get a width/height breakpoint for the supplied dimension\n    getBreakpoint(levels, dimension) {\n        const\n            // Breakpoints as reverse sorted array of numerical widths [NaN for *, 50, 100]\n            ascendingLevels = Object.keys(levels).map(l => parseInt(l)).sort(),\n            // Find first one larger than current width\n            breakpoint     = ascendingLevels.find(bp => dimension <= bp);\n        // Return matched breakpoint or * if available and none matched\n        return levels[breakpoint ?? (levels['*'] && '*')];\n    }\n    // Apply a breakpoints configs, trigger event and call any callback\n    activateBreakpoint(orientation, breakpoint) {\n        const\n            me             = this,\n            prevBreakpoint = me[`current${orientation}Breakpoint`];\n        if (breakpoint !== prevBreakpoint) {\n            me[`current${orientation}Breakpoint`] = breakpoint;\n            me.setConfig(breakpoint.configs);\n            prevBreakpoint && me.element.classList.remove(`b-breakpoint-${prevBreakpoint.name.toLowerCase()}`);\n            me.element.classList.add(`b-breakpoint-${breakpoint.name.toLowerCase()}`);\n            /**\n             * Triggered when a new max-width based breakpoint is applied.\n             * @event responsiveWidthChange\n             * @param {Core.widget.Widget} source The widget\n             * @param {Breakpoint} breakpoint The applied breakpoint\n             * @param {Breakpoint} prevBreakpoint The previously applied breakpoint\n             * @deprecated 5.0 This event is associated with {@link #config-breakpoints} which is deprecated in favor of\n             * {@link #config-responsive}.\n             */\n            /**\n             * Triggered when a new max-height based breakpoint is applied.\n             * @event responsiveHeightChange\n             * @param {Core.widget.Widget} source The widget\n             * @param {Breakpoint} breakpoint The applied breakpoint\n             * @param {Breakpoint} prevBreakpoint The previously applied breakpoint\n             * @deprecated 5.0 This event is associated with {@link #config-breakpoints} which is deprecated in favor of\n             * {@link #config-responsive}.\n             */\n            me.trigger(`responsive${orientation}Change`, { breakpoint, prevBreakpoint });\n            breakpoint.callback?.({ source : me, breakpoint, prevBreakpoint });\n            me.recompose?.();\n        }\n    }\n    // Called on resize to pick and apply a breakpoint, if size changed enough\n    applyResponsiveBreakpoints(width, height) {\n        const\n            me = this,\n            {\n                width  : widths,\n                height : heights\n            }  = me.breakpoints ?? {};\n        if (widths) {\n            const breakpoint = me.getBreakpoint(widths, width);\n            me.activateBreakpoint('Width', breakpoint);\n        }\n        if (heights) {\n            const breakpoint = me.getBreakpoint(heights, height);\n            me.activateBreakpoint('Height', breakpoint);\n        }\n    }\n    onInternalResize(element, width, height, oldWidth, oldHeight) {\n        super.onInternalResize(element, width, height, oldWidth, oldHeight);\n        this.applyResponsiveBreakpoints(width, height);\n    }\n};\n"],
  "mappings": "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",
  "names": ["_a"]
}
