{
  "version": 3,
  "sources": ["../../../../Grid/lib/Grid/column/ColorColumn.js", "../../../../Grid/lib/Grid/feature/GroupSummary.js", "../../../../Grid/lib/Grid/feature/RowResize.js", "../../../../Grid/lib/Grid/feature/Split.js", "../../../../Grid/lib/Grid/util/TableExporter.js", "../../../../Grid/lib/Grid/util/BooleanUnicodeSymbol.js", "../../../../Grid/lib/Grid/feature/experimental/ExcelExporter.js"],
  "sourcesContent": ["import Menu from '../../Core/widget/Menu.js';\nimport Column from './Column.js';\nimport  '../../Core/widget/ColorPicker.js';\nimport ColumnStore from '../data/ColumnStore.js';\n/**\n * @module Grid/column/ColorColumn\n */\n/**\n * A column that displays color values (built-in color classes or CSS colors) as a colored element similar to\n * the {@link Core.widget.ColorField}. When the user clicks the element, a {@link Core.widget.ColorPicker} lets the user\n * select from a range of colors.\n *\n * {@inlineexample Grid/column/ColorColumn.js}\n *\n * ```javascript\n * new Grid({\n *    columns : [\n *       {\n *          type   : 'color',\n *          field  : 'color',\n *          text   : 'Color'\n *       }\n *    ]\n * });\n * ```\n *\n * @extends Grid/column/Column\n * @classtype color\n */\nexport default class ColorColumn extends Column {\n    static $name = 'ColorColumn';\n    static type = 'color';\n    static fields = [\n        { name : 'colorEditorType', defaultValue : 'colorpicker' },\n        /**\n         * Array of CSS color strings to be able to chose from. This will override the\n         * {@link Core.widget.ColorPicker#config-colors pickers default colors}.\n         *\n         * Provide an array of string CSS colors:\n         * ```javascript\n         * new Grid({\n         *    columns : [\n         *       {\n         *          type   : 'color',\n         *          field  : 'color',\n         *          text   : 'Color',\n         *          colors : ['#00FFFF', '#F0FFFF', '#89CFF0', '#0000FF', '#7393B3']\n         *       }\n         *    ]\n         * });\n         * ```\n         * @prp {String[]}\n         */\n        'colors',\n        /**\n         * Adds an option in the picker to set no background color\n         * @prp {Boolean}\n         * @default true\n         */\n        { name : 'addNoColorItem', defaultValue : true }\n    ];\n    static defaults = {\n        align  : 'center',\n        editor : null\n    };\n    construct() {\n        super.construct(...arguments);\n        const\n            me       = this,\n            { grid } = me;\n        me.menu = new Menu({\n            owner             : grid,\n            rootElement       : grid.rootElement,\n            autoShow          : false,\n            align             : 't50-b50',\n            anchor            : true,\n            internalListeners : {\n                hide() {\n                    me.picker.navigator.activeItem = null;\n                    delete me._editingRecord;\n                }\n            },\n            items : [\n                Object.assign({\n                    type           : me.colorEditorType,\n                    ref            : 'list',\n                    addNoColorItem : me.addNoColorItem,\n                    colorSelected({ color }) {\n                        me._editingRecord?.set(me.field, color);\n                        me.menu.hide();\n                    }\n                }, me.colors?.length ? { colors : me.colors } : {})\n            ]\n        });\n    }\n    applyValue(useProp, field, value) {\n        if (!this.isConstructing) {\n            const { picker } = this;\n            if (field === 'colors') {\n                picker.colors = value;\n            }\n            else if (field === 'addNoColorItem') {\n                picker.addNoColorItem = value;\n            }\n        }\n        super.applyValue(...arguments);\n    }\n    get picker() {\n        return this.menu.widgetMap.list;\n    }\n    renderer({ value }) {\n        let colorClass      = 'b-empty',\n            backgroundColor = value;\n        if (value) {\n            const colorClassName = this.picker.getColorClassName(value);\n            if (colorClassName) {\n                colorClass      = colorClassName;\n                backgroundColor = null;\n            }\n            else {\n                colorClass = '';\n            }\n        }\n        return {\n            className : 'b-color-cell-inner ' + colorClass,\n            style     : {\n                backgroundColor\n            },\n            'data-btip' : value\n        };\n    }\n    onCellClick({ grid, record, target }) {\n        if (target.classList.contains('b-color-cell-inner') && !this.readOnly &&\n            !grid.readOnly && !record.isSpecialRow && !record.readOnly\n        ) {\n            const\n                { picker, menu } = this,\n                value            = record.get(this.field);\n            this._editingRecord = record;\n            picker.deselectAll();\n            picker.select(value);\n            picker.refresh();\n            menu.showBy(target);\n        }\n    }\n}\nColumnStore.registerColumnType(ColorColumn);\nColorColumn._$name = 'ColorColumn';", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport SummaryFormatter from './mixin/SummaryFormatter.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n/**\n * @module Grid/feature/GroupSummary\n */\n/**\n * Displays a summary row as a group footer in a grouped grid. Uses same configuration options on columns as\n * {@link Grid.feature.Summary}.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ```javascript\n * features : {\n *     group        : 'city',\n *     groupSummary : true\n * }\n * ```\n *\n * {@inlineexample Grid/feature/GroupSummary.js}\n *\n * @demo Grid/groupsummary\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype groupSummary\n * @feature\n */\nexport default class GroupSummary extends SummaryFormatter(InstancePlugin) {\n    //region Init\n    static get $name() {\n        return 'GroupSummary';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Set to `true` to have group summaries rendered in the group header when a group is collapsed.\n             *\n             * Only applies when {@link #config-target} is `'footer'` (the default).\n             *\n             * @member {Boolean} collapseToHeader\n             */\n            /**\n             * Configure as `true` to have group summaries rendered in the group header when a group is collapsed.\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *    features : {\n             *        groupSummary : {\n             *            collapseToHeader : true\n             *        }\n             *    }\n             * });\n             * ```\n             *\n             * Only applies when {@link #config-target} is `'footer'` (the default).\n             *\n             * @config {Boolean}\n             */\n            collapseToHeader : null,\n            /**\n             * Where to render the group summaries to, either `header` to display them in the group header or `footer`\n             * to display them in the group footer (the default).\n             *\n             * @member {'header'|'footer'} target\n             */\n            /**\n             * Where to render the group summaries to, either `header` to display them in the group header or `footer`\n             * to display them in the group footer (the default).\n             *\n             * ```javascript\n             * const grid = new Grid({\n             *    features : {\n             *        groupSummary : {\n             *            target : 'header'\n             *        }\n             *    }\n             * });\n             * ```\n             *\n             * @config {'header'|'footer'}\n             * @default\n             */\n            target : 'footer'\n        };\n    }\n    construct(grid, config) {\n        this.grid = grid;\n        super.construct(grid, config);\n        if (!grid.features.group) {\n            throw new Error('Requires Group feature to work, please enable');\n        }\n        this.bindStore(grid.store);\n        grid.rowManager.ion({\n            beforeRenderRow : 'onBeforeRenderRow',\n            renderCell      : 'renderCell',\n            // The feature gets to see cells being rendered after the Group feature\n            // because the Group feature injects header content into group header rows\n            // and adds rendering info to the cells renderData which we must comply with.\n            // In particular, it calculates the isFirstColumn flag which it adds to\n            // the cell renderData which we interrogate.\n            prio    : 1000,\n            thisObj : this\n        });\n    }\n    bindStore(store) {\n        this.detachListeners('store');\n        store.ion({\n            name    : 'store',\n            update  : 'onStoreUpdate',\n            // need to run before grids listener, to flag for full refresh\n            prio    : 1,\n            thisObj : this\n        });\n    }\n    get store() {\n        return this.grid.store;\n    }\n    doDisable(disable) {\n        // Toggle footers if needed\n        this.updateTarget(this.target);\n        super.doDisable(disable);\n    }\n    changeTarget(target) {\n        ObjectHelper.assertString(target, 'target');\n        return target;\n    }\n    updateTarget(target) {\n        // Flag that will make the Store insert rows for group footers\n        this.store.useGroupFooters = !this.disabled && target === 'footer';\n        // Refresh groups to show/hide footers\n        if (!this.isConfiguring) {\n            this.store.group();\n        }\n    }\n    changeCollapseToHeader(collapseToHeader) {\n        ObjectHelper.assertBoolean(collapseToHeader, 'collapseToHeader');\n        return collapseToHeader;\n    }\n    updateCollapseToHeader() {\n        if (!this.isConfiguring) {\n            this.store.group();\n        }\n    }\n    //endregion\n    //region Plugin config\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['bindStore']\n        };\n    }\n    //endregion\n    //region Render\n    /**\n     * Called before rendering row contents, used to reset rows no longer used as group summary rows\n     * @private\n     */\n    onBeforeRenderRow({ row, record }) {\n        if (row.isGroupFooter && !('groupFooterFor' in record.meta)) {\n            // not a group row.\n            row.isGroupFooter = false;\n            // force full \"redraw\" when rendering cells\n            row.forceInnerHTML = true;\n        }\n        else if (row.isGroupHeader && !record.meta.collapsed) {\n            // remove any summary elements\n            row.eachElement(this.removeSummaryElements);\n        }\n    }\n    removeSummaryElements(rowEl) {}\n    /**\n     * Called when a cell is rendered, styles the group rows first cell.\n     * @private\n     */\n    renderCell({ column, cellElement, row, record, size, isFirstColumn }) {\n        const\n            me            = this,\n            { meta }      = record,\n            { rowHeight } = me.grid,\n            isGroupHeader = 'groupRowFor' in meta,\n            isGroupFooter = 'groupFooterFor' in meta,\n            targetsHeader = me.target === 'header',\n            rowClasses    = {\n                'b-group-footer'   : 0,\n                'b-header-summary' : 0\n            },\n            isSummaryTarget =\n                // Header cell should have summary content if we are targeting the header or if the group is collapsed\n                // and we are configured with collapseToHeader, excluding the first column which holds the group title\n                (isGroupHeader && (targetsHeader || me.collapseToHeader && meta.collapsed) && !isFirstColumn) ||\n                // Footer cell should have summary content if we are targeting the footer (won't render if collapsed)\n                (isGroupFooter && !targetsHeader);\n        // Needed to restore height when summary is no longer displayed\n        if (isGroupHeader || isGroupFooter) {\n            size.height = isGroupHeader ? (size.height || rowHeight) : rowHeight;\n        }\n        if (me.store.isGrouped && isSummaryTarget && !me.disabled) {\n            // clear cell before add any HTML in it. if the cell contained widgets, they will be properly destroyed.\n            column.clearCell(cellElement);\n            const groupRecord = isGroupHeader ? record : meta.groupRecord;\n            row.isGroupFooter = isGroupFooter;\n            row.isGroupHeader = isGroupHeader;\n            // This is a group footer row, add css\n            if (isGroupFooter) {\n                rowClasses['b-group-footer'] = 1;\n            }\n            // This is a group header row, add css\n            else {\n                rowClasses['b-header-summary'] = 1;\n            }\n            // returns height config or count. config format is { height, count }. where `height is in px and should be\n            // added to value calculated from `count\n            const\n                heightSetting = me.updateSummaryHtml(cellElement, column, groupRecord),\n                count         = typeof heightSetting === 'number' ? heightSetting : heightSetting.count;\n            // number of summaries returned, use to calculate cell height\n            if (count > 1) {\n                size.height += (meta.collapsed && !targetsHeader ? 0 : count * rowHeight * 0.1);\n            }\n            // height config with height specified, added to cell height\n            if (heightSetting.height) {\n                size.height += heightSetting.height;\n            }\n        }\n        // Sync row's classes with its status as a group header or footer.\n        row.assignCls(rowClasses);\n    }\n    updateSummaryHtml(cellElement, column, groupRecord) {\n        const records = groupRecord.groupChildren.slice();\n        // Group footers should not be included in summary calculations\n        if (records[records.length - 1].isGroupFooter) {\n            records.pop();\n        }\n        const html = this.generateHtml(column, records, 'b-grid-group-summary', groupRecord, groupRecord.meta.groupField, groupRecord.meta.groupRowFor);\n        // First time, set table\n        if (!cellElement.children.length) {\n            cellElement.innerHTML = html;\n        }\n        // Following times, sync changes\n        else {\n            DomHelper.sync(html, cellElement.firstElementChild);\n        }\n        // return summary \"count\", used to set row height\n        return column.summaries ? column.summaries.length : column.sum ? 1 : 0;\n    }\n    //endregion\n    //region Events\n    /**\n     * Updates summaries on store changes (except record update, handled below)\n     * @private\n     */\n    onStoreUpdate({ source : store, changes }) {\n        if (!this.disabled && store.isGrouped) {\n            // If a grouping field is among the changes, StoreGroup#onDataChanged will\n            // take care of the update by re-sorting.\n            if (changes && store.groupers.find(grouper => grouper.field in changes)) {\n                return;\n            }\n            // only update summary when a field that affects summary is changed\n            const shouldUpdate = Object.keys(changes).some(field => {\n                const colField = this.grid.columns.get(field);\n                // check existence, since a field not used in a column might have changed\n                return Boolean(colField) && (Boolean(colField.sum) || Boolean(colField.summaries));\n            });\n            if (shouldUpdate) {\n                this.grid.forceFullRefresh = true;\n            }\n        }\n    }\n    //endregion\n    /**\n     * Refreshes the summaries\n     */\n    refresh() {\n        this.grid.columns.visibleColumns.forEach(column => {\n            if (this.hasSummary(column)) {\n                this.grid.refreshColumn(column);\n            }\n        });\n    }\n    hasSummary(column) {\n        return column.sum || column.summaries;\n    }\n}\nGroupSummary.featureClass = 'b-group-summary';\nGroupSummary._$name = 'GroupSummary'; GridFeatureManager.registerFeature(GroupSummary);\n", "import ResizeHelper from '../../Core/helper/ResizeHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n/**\n * @module Grid/feature/RowResize\n */\n/**\n * Enables user to change row height by dragging the bottom row border. After a resize operation, the {@link Grid/data/GridRowModel#field-rowHeight}\n * field of the record is updated (when {@link #config-applyToAllRows} is `false`).\n *\n * Try hovering the bottom row border in the grid below and use drag-drop to change the row height.\n *\n * {@inlineexample Grid/feature/RowResize.js}\n *\n * This feature is **disabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype rowResize\n * @feature\n * @demo Grid/rowheight\n */\nexport default class RowResize extends InstancePlugin {\n    static $name = 'RowResize';\n    static configurable = {\n        /**\n         * Set this to true to modify the global {@link Grid/view/Grid#config-rowHeight} which affects all grid rows.\n         * @prp {Boolean}\n         * @default false\n         */\n        applyToAllRows : null,\n        /**\n         * Set this to a CSS selector to only trigger row resizing in cells for a specific column.\n         * @config {String}\n         * @default\n         */\n        cellSelector : '.b-grid-cell',\n        /**\n         * Minimum height when resizing\n         * @prp {Number}\n         * @default\n         */\n        minHeight : 20,\n        /**\n         * Max height when resizing\n         * @prp {Number}\n         */\n        maxHeight : 0\n    };\n    //region Init\n    construct(grid, config) {\n        const me = this;\n        super.construct(...arguments);\n        me.resizer = new ResizeHelper({\n            name                    : 'rowResize',\n            targetSelector          : '.b-grid-row:not(.b-group-header)',\n            handleContainerSelector : '.b-grid-row',\n            outerElement            : grid.element,\n            direction               : 'vertical',\n            dragThreshold           : 1,\n            handleSize              : Math.min(5, grid.rowHeight * 0.1),\n            internalListeners       : {\n                beforeresizestart : me.onBeforeResizeStart,\n                resizestart       : me.onResizeStart,\n                resizing          : me.onResizing,\n                resize            : me.onResize,\n                cancel            : me.onCancel,\n                thisObj           : me\n            },\n            allowResize(target, event) {\n                return grid.hoveredCell?.matches(me.cellSelector);\n            },\n            overTopHandle(event, target) {\n                if (this.canResize(target, event) && target.dataset.index !== '0') {\n                    const topHandle = Rectangle.from(target);\n                    topHandle.height = this.handleSize;\n                    return topHandle.height > 0 && Math.abs(topHandle.top - EventHelper.getPagePoint(event).top) < this.handleSize;\n                }\n                return false;\n            },\n            internalBeforeStart(context) {\n                const { edge, element } = context;\n                // Grabbing top handle of any row except first is interpreted as grabbing bottom handle of the previous\n                // row\n                if (edge === 'top') {\n                    return {\n                        edge    : 'bottom',\n                        element : element.previousElementSibling\n                    };\n                }\n            },\n            // Prevent selection as a result of mousedown on virtual handle\n            onResizeHandlePointerDown(event) {\n                grid.selectionDisabled = true;\n                if (grid.features.rowReorder) {\n                    me._oldReorderDisabled          = grid.features.rowReorder.disabled;\n                    grid.features.rowReorder.disabled = true;\n                }\n                grid.setTimeout(() => {\n                    grid.selectionDisabled = false;\n                }, 10);\n            }\n        });\n    }\n    doDestroy() {\n        this.resizer?.destroy();\n        super.doDestroy();\n    }\n    //endregion\n    //region Events\n    onBeforeResizeStart() {\n        return !this.disabled;\n    }\n    onResizeStart({ source, context }) {\n        const\n            { client }    = this,\n            applyGlobally = this.applyToAllRows || client.fixedRowHeight;\n        context.record    = client.store.getById(context.element.dataset.id);\n        context.oldHeight = context.record.rowHeight;\n        client.store.suspendAutoCommit();\n        Object.assign(source, {\n            minHeight           : this.minHeight,\n            maxHeight           : this.maxHeight,\n            // Only update live element if applying to all rows\n            skipUpdatingElement : !applyGlobally\n        });\n        client.element.classList.add('b-row-resizing');\n    }\n    onResizing({ context }) {\n        if (!this.applyToAllRows && !this.client.fixedRowHeight && context.valid) {\n            context.record.rowHeight = context.newHeight;\n        }\n    }\n    onResize({ context }) {\n        const { client } = this;\n        if (this.applyToAllRows || client.fixedRowHeight) {\n            client.rowHeight = context.newHeight;\n        }\n        else if (client.selectionMode.multiSelect && client.selectedRecords.includes(context.record)) {\n            client.selectedRecords.forEach(record => record.rowHeight = context.newHeight);\n        }\n        this.cleanup();\n    }\n    /**\n     * Restore row size on cancel (ESC)\n     * @private\n     */\n    onCancel({ context }) {\n        if (!this.applyToAllRows && !this.client.fixedRowHeight) {\n            context.record.rowHeight = context.oldHeight;\n        }\n        this.cleanup();\n    }\n    //endregion\n    cleanup() {\n        const { client } = this;\n        client.element.classList.remove('b-row-resizing');\n        client.store.resumeAutoCommit();\n        if (typeof this._oldReorderDisabled === 'boolean') {\n            client.features.rowReorder.disabled = this._oldReorderDisabled;\n        }\n    }\n}\nRowResize._$name = 'RowResize'; GridFeatureManager.registerFeature(RowResize, false);\n", "import ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport AsyncHelper from '../../Core/helper/AsyncHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Splitter from '../../Core/widget/Splitter.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from './GridFeatureManager.js';\n/**\n * @module Grid/feature/Split\n */\nconst\n    startScrollOptions = Object.freeze({\n        animate : false,\n        block   : 'start'\n    }),\n    endScrollOptions = Object.freeze({\n        animate : false,\n        block   : 'end'\n    }),\n    splitterWidth = 7,\n    // Listeners for these events should not be added to splits\n    ignoreListeners     = {\n        split   : 1,\n        unsplit : 1\n    };\n;\n/**\n * This feature allows splitting the Grid into multiple views, either by using the cell context menu, or\n * programmatically by calling {@link #function-split split()}.\n *\n * {@inlineexample Grid/feature/Split.js}\n *\n * It handles splitting in 3 \"directions\":\n *\n * - `'horizontal'` - Splitting the grid into 2 sub-views, one above the other.\n * - `'vertical'` - Splitting the grid into 2 sub-views, one to the left of the other.\n * - `'both'` - Splitting the grid into 4 sub-views, one in each corner.\n *\n * Or, by supplying a record and/or a column to split by.\n *\n * The first sub-view (top, left or top-left depending on split direction) is the original grid, and the others are\n * clones of the original. The clones share the same store, columns and selection.\n *\n * Sub-views in the same column sync their scrolling horizontally, and sub-views in the same row sync their scrolling\n * vertically.\n *\n * Sub-views are separated by splitters, that can be dragged to resize the views.\n *\n * Splitting a multi-region grid (two regions supported) only includes the region in which the split was performed in\n * the split view.\n *\n * Splitting works best on grids that use fixed column widths, since flexed columns will resize when the grid is split.\n *\n * ## Splitting programmatically\n *\n * The split feature assigns two methods to the owning grid:\n *\n * - {@link #function-split split()} - Splits the grid into sub-views.\n * - {@link #function-unsplit unsplit()} - Re-joins the sub-views into a single grid.\n *\n * Use them to split programmatically in your app.\n *\n * ```javascript\n * // Split horizontally (eg. at the row in the center of the grid)\n * await grid.split({ direction : 'horizontal' });\n *\n * // Split both ways by a specific column and record\n * await grid.split({\n *    atRecord : grid.store.getById(10),\n *    atColumn : grid.columns.get('city')\n * });\n *\n * // Remove splits, returning to a single grid\n * grid.unsplit();\n * ```\n *\n * ## Splitting using the cell context menu\n *\n * The feature also adds a new sub-menu to the cell context menu, allowing the user to split (or un-split) the grid. See\n * the API documentation for the {@link Grid/feature/CellMenu} feature for more information on how to customize the\n * sub-menu.\n *\n * ## Accessing a sub-view\n * The sub-views are accessed by index. The original grid is at index 0, and the others are as shown below.\n * For 'horizontal' splits:\n *\n * <div style=\"font-size: 0.8em\">\n *     <div style=\"border: 1px solid #ccc; border-bottom: 2px solid #999; padding: 1em; width: 13em\">0 - Original</div>\n *     <div style=\"border: 1px solid #ccc; border-top: none; padding: 1em; width: 13em\">1 - Sub-view</div>\n * </div>\n *\n * For 'vertical' splits:\n *\n * <div style=\"display: flex; flex-direction: row;font-size: 0.8em\">\n *     <div style=\"border: 1px solid #ccc; border-right: 2px solid #999; padding: 1em; width: 13em\">0 - Original</div>\n *     <div style=\"border: 1px solid #ccc; border-left: none; padding: 1em; width: 13em\">1 - Sub-view</div>\n * </div>\n *\n * For 'both' splits:\n *\n * <div style=\"display: flex; flex-flow: row wrap; width : 27em;font-size: 0.8em\">\n *     <div style=\"border: 1px solid #ccc; border-right: 2px solid #999; border-bottom: 2px solid #999; padding: 1em; width: 13em\">0 - Original</div>\n *     <div style=\"border: 1px solid #ccc; border-left: none; border-bottom: 2px solid #999; padding: 1em; width: 13em\">1 - Sub-view</div>\n *     <div style=\"border: 1px solid #ccc; border-right: 2px solid #999;border-top: none; padding: 1em; width: 13em\">2 - Sub-view</div>\n *     <div style=\"border: 1px solid #ccc; border-top: none; border-left: none; padding: 1em; width: 13em\">3 - Sub-view</div>\n * </div>\n *\n * The {@link #property-subViews} property returns an array containing all sub-views, including the original. Note that\n * the property is also exposed on the owning Grid. Access a specific sub-view by index (see illustrations above). For\n * example to access the bottom right sub-view in a 'both' split:\n *\n * ```javascript\n * await grid.split({ direction : 'both' });\n * const bottomRight = grid.subViews[3];\n * await bottomRight.scrollRowIntoView(100);\n * ```\n *\n * ## Troubleshooting\n *\n * The splits are inserted into a container element (which has the `.b-split-container` CSS class), replacing the\n * original grid. If it does not render correctly out of the box, you should make sure that any CSS rules you have that\n * apply size to the grid also applies to the container element.\n *\n * For example if you use a CSS flex rule to size the grid:\n *\n * ```css\n * .b-grid {\n *     // Size grid using flex\n *     flex : 3;\n * }\n * ```\n *\n * Then you should also apply the same rule to the container element:\n *\n * ```css\n * .b-grid,\n * .b-split-container {\n *     flex : 3;\n * }\n * ```\n *\n * {@note}\n * Note that configuration changes at runtime, when already split, are not automatically propagated to the sub-views. If\n * you need to change a config at runtime, either first unsplit the grid, or change it on each sub-view individually. A\n * notable exception from this is that enabling / disabling features at runtime is reflected in the sub-views.\n * {/@note}\n *\n * This feature is **disabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype split\n * @feature\n */\nexport default class Split extends InstancePlugin {\n    static $name = 'Split';\n    static featureClass = '';\n    static configurable = {\n        /**\n         * An array of sub-views. The first sub-view is the original grid, and the others are clones of the original.\n         * See the \"Accessing a sub-view\" section above for more information.\n         *\n         * ```javascript\n         * await grid.split('vertical');\n         * const bottom = grid.subViews[1];\n         * await bottom.scrollRowIntoView(100);\n         * ```\n         *\n         * Note that this property is accessible directly on the grid instance.\n         *\n         * @member {Grid.view.Grid[]} subViews\n         * @on-owner\n         * @readonly\n         * @category Common\n         */\n        subViews : [], // Not a config, but still defined in configurable to allow assigning it in pluginConfig,\n        /**\n         * Properties whose changes should be relayed to sub-views at runtime.\n         *\n         * Supply an object with property names as keys, and a truthy value to relay the change, or a falsy value to not\n         * relay it. The object will be merged with the default values.\n         *\n         * By default, these properties are relayed:\n         * * {@link Grid/view/Grid#property-readOnly}\n         * * {@link Grid/view/Grid#property-rowHeight}\n         *\n         * Example of supplying a custom set of properties to relay:\n         * ```javascript\n         * const grid = new Grid({\n         *     features : {\n         *         split : {\n         *             relayProperties : {\n         *                 readOnly : false, // Do not relay readOnly changes\n         *                 myConfig : true   // Relay changes to the myConfig property\n         *             }\n         *         }\n         *     }\n         * }\n         * ```\n         * @config {Object<String,Boolean>}\n         */\n        relayProperties : {\n            value : {\n                readOnly  : 1,\n                rowHeight : 1\n            },\n            $config : {\n                merge : 'merge'\n            }\n        }\n    };\n    static pluginConfig = {\n        chain  : ['populateCellMenu', 'afterConfigChange', 'afterAddListener', 'afterRemoveListener'],\n        assign : ['split', 'unsplit', 'subViews', 'syncSplits']\n    };\n    // Flag used to ignore column changes that arise from syncing columns\n    #ignoreColumnChanges = false;\n    restorers = [];\n    doDestroy() {\n        this.unsplit(true);\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        const me = this;\n        if (!me.isConfiguring) {\n            if (disable) {\n                me._disabledSplitOptions = me._splitOptions;\n                me.unsplit();\n            }\n            else if (me._disabledSplitOptions) {\n                me.split(me._disabledSplitOptions);\n                me._disabledSplitOptions = null;\n            }\n        }\n    }\n    //region Split / unsplit\n    get isSplit() {\n        return Boolean(this.widgets?.length);\n    }\n    getClientConfig(appendTo, order, options, config = {}) {\n        const\n            { client }            = this,\n            { subGrids, regions } = client,\n            columns                = client.columns.records.slice(),\n            subGridConfigs         = ObjectHelper.assign({}, client.subGridConfigs);\n        // Match current sub-grid sizes\n        client.eachSubGrid(subGrid => {\n            const config = subGridConfigs[subGrid.region];\n            if (subGrid.flex) {\n                config.flex = subGrid.flex;\n            }\n            else {\n                config.width = subGrid.element.style.width;\n            }\n        });\n        if (options.atColumn && regions.length > 1 && order > 0) {\n            // Exclude regions to the left of the split\n            const subGridIndex = regions.indexOf(options.atColumn.region);\n            for (let i = 0; i < subGridIndex; i++) {\n                const subGrid = subGrids[regions[i]];\n                ArrayHelper.remove(columns, ...subGrid.columns.records);\n                delete subGridConfigs[regions[i]];\n            }\n        }\n        const clientConfig = ObjectHelper.assign({}, client.initialConfig, {\n            appendTo,\n            insertFirst  : null,\n            insertBefore : null,\n            splitFrom    : client,\n            owner        : client.owner,\n            // Use no toolbar or fake empty toolbar for things to line up nicely\n            tbar         : client.initialConfig.tbar && order === 1 ? {\n                height : client.tbar.height,\n                items  : [' ']\n            } : null,\n            // Share store & selection\n            store                    : client.store,\n            selectedRecordCollection : client.selectedRecordCollection,\n            subGridConfigs,\n            // Cannot directly share columns, since there is a 1-1 mapping between column and it's header\n            columns                  : this.cloneColumns(columns),\n            minHeight                : 0,\n            minWidth                 : 0\n        }, config);\n        // Make sure we use up-to-date values for all properties that should be relayed\n        for (const prop of ObjectHelper.keys(this.relayProperties)) {\n            clientConfig[prop] = client[prop];\n        }\n        // Listeners are removed from initialConfig during initialization, use non-internal current listeners\n        const appListeners = {};\n        for (const name in client.listeners) {\n            if (!ignoreListeners[name]) {\n                const listeners = client.listeners[name].filter(l => !l.$internal);\n                if (listeners.length) {\n                    appListeners[name] = listeners;\n                }\n            }\n        }\n        // Not internalListeners on purpose, these are app listeners\n        clientConfig.listeners = appListeners;\n        // Hide headers for bottom clone in horizontal split\n        if (options.direction === 'horizontal') {\n            clientConfig.hideHeaders = true;\n        }\n        // Hide headers for bottom clones in both split\n        else if (options.direction === 'both' && order !== 1) {\n            clientConfig.hideHeaders = true;\n        }\n        delete clientConfig.data;\n        delete clientConfig.adopt;\n        return clientConfig;\n    }\n    cloneColumns(source) {\n        return source.flatMap(col => {\n            // Do not clone selection column, it will be injected by GridSelection.\n            // Ditto for the row expander column\n            if (col.meta.isSelectionColumn || col.field === 'expanderActionColumn') {\n                return [];\n            }\n            const data = { ...col.data };\n            if (col.children) {\n                data.children = col.children.map(child => ({ ...child.data }));\n            }\n            // RowNumberColumn \"pollutes\" headerRenderer, will create infinite loop if not cleaned up\n            delete data.headerRenderer;\n            delete data.parentId;\n            return data;\n        });\n    }\n    cloneClient(appendTo, order, options, config) {\n        const\n            clientConfig = this.getClientConfig(appendTo, order, options, config),\n            clone        = new this.client.constructor(clientConfig);\n        clone.element.classList.add('b-split-clone');\n        return clone;\n    }\n    // Process options, deducing direction, atRecord, etc.\n    processOptions(options) {\n        const\n            { client }                        = this,\n            { atRecord, atColumn, direction } = options;\n        if (!direction) {\n            // Infer direction from record & column\n            if (atRecord && atColumn) {\n                options.direction = 'both';\n            }\n            else if (atColumn) {\n                options.direction = 'vertical';\n            }\n            else {\n                options.direction = 'horizontal';\n            }\n        }\n        else {\n            // Only given a direction, cut roughly in half\n            if (direction !== 'vertical' && !atRecord && client.store.count) {\n                const\n                    centerY   = client._bodyRectangle.height / 2 + client.scrollable.y,\n                    centerRow = client.rowManager.getRowAt(centerY, true) ?? client.rowManager.rows[Math.ceil(client.rowManager.rows.length / 2)];\n                options.atRecord = client.store.getById(centerRow.id);\n            }\n            if (direction !== 'horizontal' && !atColumn) {\n                const bounds = Rectangle.from(client.element);\n                // Figure out subgrid intersecting center of grid\n                let centerX = bounds.center.x - bounds.x,\n                    subGrid = client.subGrids[client.regions[0]],\n                    i       = 0,\n                    column  = null;\n                while (centerX > subGrid.width) {\n                    centerX -= subGrid.width;\n                    subGrid = client.subGrids[client.regions[++i]];\n                }\n                // We want the center column in view, but iteration below is over all columns\n                centerX += subGrid.scrollable.x;\n                // Figure out column in the subgrid\n                const { visibleColumns } = subGrid.columns;\n                let x = 0, j = 0;\n                while (x < centerX && j < visibleColumns.length) {\n                    column = visibleColumns[j++];\n                    x += column.element.offsetWidth;\n                }\n                options.atColumn = column;\n            }\n        }\n        return options;\n    }\n    // Create element to contain the splits, it \"both\" mode it will hold a top container and a bottom container.\n    // In single mode, it will hold the splits + splitters directly.\n    createSplitContainer({ direction }) {\n        const\n            { client }  = this,\n            { element } = client;\n        return this.splitContainer = DomHelper.createElement({\n            parent    : element.parentElement,\n            className : {\n                'b-split-container'      : 1,\n                [`b-split-${direction}`] : 1,\n                'b-rtl'                  : client.rtl\n            },\n            style : {\n                width  : element.style.width,\n                height : element.style.height\n            },\n            children : [\n                // Split in one dir, use original as first child\n                direction !== 'both' && element,\n                // Split in both directions, make two sub-containers and put original in first\n                direction === 'both' && {\n                    className : 'b-split-top',\n                    children  : [\n                        element\n                    ]\n                },\n                direction === 'both' && {\n                    className : 'b-split-bottom'\n                }\n            ]\n        });\n    }\n    // Make the headers of all splits same height. Since headers shrinkwrap, they might differ depending on which\n    // subgrids was cloned to each split\n    syncHeaderHeights() {\n        let maxHeaderHeight = 0;\n        // Find tallest header\n        for (const split of this.subViews) {\n            split.eachSubGrid(subGrid => {\n                if (subGrid.header.height > maxHeaderHeight) {\n                    maxHeaderHeight = subGrid.header.height;\n                }\n            });\n        }\n        // Apply its height to all headers\n        for (const split of this.subViews) {\n            split.eachSubGrid(subGrid => {\n                subGrid.header.height = maxHeaderHeight;\n            });\n        }\n    }\n    // Clones can be created with correct subgrids, in the original we might instead need to hide some when splitting\n    // in a region that is not the last one (locked for example)\n    toggleOriginalSubGrids(options) {\n        const\n            me          = this,\n            { client }  = me,\n            { regions } = client;\n        // Split at a column with multiple regions\n        if (options.atColumn && regions.length > 1) {\n            const\n                subGridIndex = regions.indexOf(options.atColumn.region),\n                // Always process the original\n                splits = [client];\n            // And the bottom left one in a four way split\n            if (options.direction === 'both') {\n                splits.push(me.subViews[2]);\n            }\n            for (const split of splits) {\n                // Hide regions to the right of the split in the original\n                if (subGridIndex + 1 < regions.length) {\n                    const isOriginal = split === client;\n                    // Leftmost subgrid to keep visible\n                    const subGrid = split.subGrids[regions[subGridIndex]];\n                    // It won't need a splitter when succeeding subgrids are hidden\n                    subGrid.hideSplitter();\n                    isOriginal && me.restorers.push(() => subGrid.showSplitter());\n                    // Force flex to fill space left by hiding succeeding subgrids\n                    if (!subGrid.flex) {\n                        // Don't affect other splits\n                        client.inForEachOther = true;\n                        subGrid.flex = 1;\n                        client.inForEachOther = false;\n                        isOriginal && me.restorers.push(() => {\n                            subGrid.flex = null;\n                            subGrid.width = subGrid._initialWidth;\n                        });\n                    }\n                    // Hide succeeding subgrids\n                    for (let i = subGridIndex + 1; i < regions.length; i++) {\n                        const subGrid = split.subGrids[regions[i]];\n                        subGrid.hide();\n                        isOriginal && me.restorers.push(() => {\n                            subGrid.show();\n                        });\n                    }\n                    // Only one subgrid remains visible, use its width as splits width\n                    if (regions.length === 2) {\n                        split._initialWidth = split.element.style.width;\n                        split._initialFlex = split.flex;\n                        split.width = subGrid._initialWidth;\n                        isOriginal && me.restorers.push(() => {\n                            if (split._initialFlex !== null) {\n                                split.flex = split._initialFlex;\n                            }\n                            else if (split._initialWidth !== null) {\n                                split.width = split._initialWidth;\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * Split the grid into two or four parts.\n     *\n     * - Splits into two when passed `direction : 'vertical'`, `direction : 'horizontal'` or `atColumn` or `atRecord`.\n     * - Splits into four when passed `direction : 'both'` or `atColumn` and `atRecord`.\n     *\n     * ```javascript\n     * // Split horizontally (at the row in the center of the grid)\n     * await grid.split({ direction : 'horizontal' });\n     *\n     * // Split both ways by a specific column and record\n     * await grid.split({\n     *    atRecord : grid.store.getById(10),\n     *    atColumn : grid.columns.get('city')\n     * });\n     * ```\n     *\n     * To return to a single grid, call {@link #function-unsplit}.\n     *\n     * Note that this function is callable directly on the grid instance.\n     *\n     * @param {Object} [options] Split options\n     * @param {'vertical'|'horizontal'|'both'} [options.direction] Split direction, 'vertical', 'horizontal' or 'both'.\n     * Not needed when passing `atColumn` or `atRecord`.\n     * @param {Grid.column.Column} [options.atColumn] Column to split at\n     * @param {Core.data.Model} [options.atRecord] Record to split at\n     * @returns {Promise} Resolves when split is complete, and subviews are scrolled to the correct position.\n     * @async\n     * @on-owner\n     * @category Common\n     */\n    async split(options = {}) {\n        const\n            me         = this,\n            { client } = me;\n        // Can't split a split\n        if (client.splitFrom) {\n            return;\n        }\n        if (me.isSplit) {\n            await me.unsplit(true);\n        }\n        const\n            { rtl }                           = client,\n            { atRecord, atColumn, direction } = me.processOptions(options);\n        let { splitX, remainingWidth } = options,\n            splitY                     = null,\n            remainingHeight            = null;\n        if (atRecord) {\n            await client.scrollRowIntoView(atRecord);\n            const row = client.getRowFor(atRecord);\n            if (!row) {\n                throw new Error(`Could not find row for record ${atRecord.id}`);\n            }\n            splitY = Rectangle.from(row.cells[0], client.element).bottom;\n            remainingHeight = Rectangle.from(client.element).height - splitY;\n        }\n        if (atColumn && !splitX) {\n            splitX = Rectangle.from(atColumn.element, client.element).getEnd(rtl);\n            remainingWidth = Rectangle.from(client.element).width - splitX - DomHelper.scrollBarWidth;\n            if (rtl) {\n                const x = splitX;\n                splitX = remainingWidth + DomHelper.scrollBarWidth;\n                remainingWidth = x - DomHelper.scrollBarWidth;\n            }\n        }\n        const\n            scrollPromises        = [],\n            splitContainer        = me.createSplitContainer(options),\n            { visibleColumns }    = client.columns,\n            nextColumn            = atColumn ? visibleColumns[visibleColumns.indexOf(atColumn) + 1] : null,\n            nextRecord            = atRecord ? client.store.getNext(atRecord) : null;\n        client.eachSubGrid(subGrid => subGrid._initialWidth = subGrid.width);\n        // Commit any changes already in the column store before enabling sync of column changes, to not have them\n        // reapplied on first change later on\n        client.columns.commit();\n        if (direction !== 'both') {\n            const cloneConfig = {\n                flex   : `0 0 ${(splitY != null ? remainingHeight : remainingWidth) - splitterWidth}px`,\n                height : null\n            };\n            // Horizontal or vertical, only needs one splitter and one clone\n            const [, clone] = me.widgets = [\n                new Splitter({ appendTo : splitContainer }),\n                me.cloneClient(splitContainer, direction === 'vertical' ? 1 : 0, options, cloneConfig)\n            ];\n            if (splitX != null) {\n                // It does not like being thrown around in DOM and resized when scrolled, fix up\n                client.renderRows();\n                // Don't bother scrolling here if given a date, Schedulers feature handles that\n                if (!options.atDate) {\n                    scrollPromises.push(client.scrollColumnIntoView(atColumn, endScrollOptions));\n                    nextColumn && scrollPromises.push(clone.scrollColumnIntoView(nextColumn, startScrollOptions));\n                }\n            }\n            if (splitY != null) {\n                // Always have an atRecord to split at\n                scrollPromises.push(clone.scrollRowIntoView(nextRecord, startScrollOptions));\n            }\n            client.element.classList.add('b-split-start');\n            clone.element.classList.add('b-split-end');\n            // Sync scrolling\n            client.scrollable.addPartner(clone.scrollable, {\n                x : direction === 'horizontal',\n                y : direction !== 'horizontal'\n            });\n        }\n        else {\n            const rightConfig = {\n                flex : `0 0 ${remainingWidth - splitterWidth}px`\n            };\n            splitContainer.lastElementChild.style.flex = `0 0 ${remainingHeight - splitterWidth}px`;\n            // Both directions, 3 splitters (one horizontal with full span, two vertical halves) and 3 clones\n            me.widgets = [\n                new Splitter({ insertBefore : splitContainer.lastElementChild }), // Full horizontal\n                me.topSplitter = new Splitter({ appendTo : splitContainer.firstElementChild }), // Top vertical\n                me.cloneClient(splitContainer.firstElementChild, 1, options, rightConfig), // Top right\n                me.cloneClient(splitContainer.lastElementChild, 0, options), // Bottom left\n                me.bottomSplitter = new Splitter({ appendTo : splitContainer.lastElementChild }), // Bottom vertical\n                me.cloneClient(splitContainer.lastElementChild, 2, options, rightConfig) // Bottom right\n            ];\n            const\n                topLeft     = client,\n                topRight    = me.widgets[2],\n                bottomLeft  = me.widgets[3],\n                bottomRight = me.widgets[5];\n            topLeft.element.classList.add('b-split-top-start');\n            topRight.element.classList.add('b-split-top-end');\n            bottomLeft.element.classList.add('b-split-bottom-start');\n            bottomRight.element.classList.add('b-split-bottom-end');\n            if (splitX != null) {\n                // It does not like being thrown around in DOM and resized when scrolled, fix up\n                topLeft.renderRows();\n                bottomLeft.renderRows();\n                // Don't bother scrolling here if given a date, Schedulers feature handles that\n                if (atColumn && !options.atDate) {\n                    scrollPromises.push(client.scrollColumnIntoView(atColumn, endScrollOptions));\n                    nextColumn && scrollPromises.push(topRight.scrollColumnIntoView(nextColumn, startScrollOptions));\n                }\n            }\n            if (splitY != null) {\n                scrollPromises.push(\n                    bottomLeft.scrollRowIntoView(nextRecord, startScrollOptions),\n                    bottomRight.scrollRowIntoView(nextRecord, startScrollOptions)\n                );\n            }\n            // Sync scrolling\n            topLeft.scrollable.addPartner(topRight.scrollable, 'y');\n            topLeft.scrollable.addPartner(bottomLeft.scrollable, 'x');\n            topRight.scrollable.addPartner(bottomRight.scrollable, 'x');\n            bottomLeft.scrollable.addPartner(bottomRight.scrollable, 'y');\n            // Set up vertical splitter sync\n            me.topSplitter.ion({\n                splitterMouseDown : 'onSplitterMouseDown',\n                drag              : 'onSplitterDrag',\n                drop              : 'onSplitterDrop',\n                thisObj           : me\n            });\n            me.bottomSplitter.ion({\n                splitterMouseDown : 'onSplitterMouseDown',\n                drag              : 'onSplitterDrag',\n                drop              : 'onSplitterDrop',\n                thisObj           : me\n            });\n        }\n        me.subViews = [client, ...me.widgets.filter(w => w.isGridBase)];\n        me.toggleOriginalSubGrids(options);\n        me.syncHeaderHeights();\n        me._splitOptions = options;\n        await Promise.all(scrollPromises);\n        // Moving in DOM does not seem to trigger resize, do it manually\n        const bounds = Rectangle.from(client.element);\n        client.onInternalResize(client.element, bounds.width, bounds.height);\n        client.eachSubGrid(subGrid => {\n            const subGridBounds = Rectangle.from(subGrid.element);\n            subGrid.onInternalResize(subGrid.element, subGridBounds.width, subGridBounds.height);\n        });\n        // If scrolled, the original element gets out of sync when moved around in DOM\n        client.scrollable.x += 0.5;\n        client.scrollable.y += 0.5;\n        me.startSyncingColumns();\n        /**\n         * Fires when splitting the Grid.\n         * @event split\n         * @param {Grid.view.GridBase[]} subViews The sub views created by the split\n         * @param {Object} options The options passed to the split call\n         * @param {'horizontal'|'vertical'|'both'} options.direction The direction of the split\n         * @param {Grid.column.Column} options.atColumn The column to split at\n         * @param {Core.data.Model} options.atRecord The record to split at\n         * @on-owner\n         */\n        client.trigger('split', { subViews : me.subViews, options });\n        return me.subViews;\n    }\n    /**\n     * Remove splits, returning to a single grid.\n     *\n     * Note that this function is callable directly on the grid instance.\n     *\n     * @on-owner\n     * @async\n     * @category Common\n     */\n    async unsplit(silent = false) {\n        const\n            me          = this,\n            { client }  = me,\n            { element } = client;\n        if (me.isSplit) {\n            me.stopSyncingColumns();\n            me.widgets?.forEach(split => split.destroy());\n            me.widgets = null;\n            // Safari & FF looses scroll position when moving elements around in DOM,\n            // but reading it here fixes it\n            client.eachSubGrid(subGrid => subGrid.scrollable.x);\n            client.scrollable.y;\n            me.splitContainer.parentElement.appendChild(element);\n            me.splitContainer.remove();\n            me.splitContainer = null;\n            // Reset any size applied by splitter\n            element.style.flexBasis = element.style.flexGrow = '';\n            element.classList.remove('b-split-top-start', 'b-split-start');\n            me.subViews.length = 0;\n            if (!me.isDestroying) {\n                // We have been pretty violent with the DOM, so force a repaint of rows\n                client.renderRows();\n                me.unsplitCleanup();\n                for (const restorer of me.restorers) {\n                    restorer();\n                }\n                me.restorers.length = 0;\n                // Ugly, but FF needs a couple of frames to not lose scroll position if we are splitting again\n                await AsyncHelper.animationFrame();\n                await AsyncHelper.animationFrame();\n                if (me.isDestroyed) {\n                    return;\n                }\n                /**\n                 * Fires when un-splitting the Grid.\n                 * @event unsplit\n                 * @on-owner\n                 */\n                !silent && client.trigger('unsplit');\n                me._splitOptions = null;\n            }\n        }\n    }\n    unsplitCleanup() {}\n    //endregion\n    //region Context menu\n    populateCellMenu({ record, column, items }) {\n        const\n            me            = this,\n            { isSplit }   = me,\n            { splitFrom } = me.client;\n        if (!me.disabled) {\n            items.splitGrid = {\n                text        : 'L{split}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-split-vertical',\n                weight      : 500,\n                separator   : true,\n                hidden      : isSplit || splitFrom,\n                menu        : {\n                    splitHorizontally : {\n                        text        : 'L{horizontally}',\n                        icon        : 'b-icon b-icon-split-horizontal',\n                        localeClass : me,\n                        weight      : 100,\n                        onItem() {\n                            me.split({ atRecord : record });\n                        }\n                    },\n                    splitVertically : {\n                        text        : 'L{vertically}',\n                        icon        : 'b-icon b-icon-split-vertical',\n                        localeClass : me,\n                        weight      : 200,\n                        onItem() {\n                            me.split({ atColumn : column });\n                        }\n                    },\n                    splitBoth : {\n                        text        : 'L{both}',\n                        icon        : 'b-icon b-icon-split-both',\n                        localeClass : me,\n                        weight      : 300,\n                        onItem() {\n                            me.split({ atColumn : column, atRecord : record });\n                        }\n                    }\n                }\n            };\n            items.unsplitGrid = {\n                text        : 'L{unsplit}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-clear',\n                hidden      : !(isSplit || splitFrom),\n                weight      : 400,\n                separator   : true,\n                onItem() {\n                    (splitFrom || me).unsplit();\n                }\n            };\n        }\n    }\n    //endregion\n    //region Syncing columns\n    startSyncingColumns() {\n        for (const subView of this.subViews) {\n            subView.columns.ion({\n                name    : 'columns',\n                change  : 'onColumnsChange',\n                thisObj : this\n            });\n        }\n    }\n    stopSyncingColumns() {\n        this.detachListeners('columns');\n    }\n    onColumnsChange({ source, isMove, action, /*index, */parent, records, changes }) {\n        const me = this;\n        if (!me.#ignoreColumnChanges) {\n            me.#ignoreColumnChanges = true;\n            for (const clone of me.subViews) {\n                const { columns } = clone;\n                if (source !== columns) {\n                    // Special handling for column moved from subgrid not in split to subgrid in split\n                    if (action === 'update' && changes.region && Object.keys(changes).length === 1) {\n                        // Move from non-existing to existing, add\n                        if (!columns.getById(records[0].id)) {\n                            const\n                                [column]     = records,\n                                targetParent = columns.getById(me.$before.parent.id) ?? columns.rootNode,\n                                targetBefore = me.$before.id !== null && columns.getById(me.$before.id);\n                            targetParent.insertChild(column.data, targetBefore);\n                        }\n                        // Vice versa, remove\n                        else {\n                            columns.remove(records[0].id);\n                        }\n                        me.$before = null;\n                    }\n                    else if (!isMove?.[records[0].id] && isMove !== true) {\n                        if (action === 'add') {\n                            // Only add columns that are in a subgrid that is visible in the clone\n                            const relevantColumns = records.filter(column => clone.getSubGridFromColumn(column));\n                            columns.add(me.cloneColumns(relevantColumns));\n                        }\n                        else {\n                            columns.applyChangesFromStore(source);\n                        }\n                    }\n                    // We have to handle move separately, since it does not leave the column store modified (in any\n                    // meaningful way)\n                    else if (action === 'add') {\n                        const\n                            sourceColumn = records[0],\n                            sourceBefore = sourceColumn.nextSibling,\n                            targetColumn = columns.getById(sourceColumn.id); //columns.allRecords.find(r => r.id === sourceColumn.id);\n                        // When splitting a multi-region grid, not all columns are present in all splits. But, it might\n                        // be moved from locked to normal (etc.) in original, but split is not showing source region. In\n                        // that case, we handle it on the region update - and must store details here\n                        if (!targetColumn) {\n                            me.$before = {\n                                id : sourceBefore?.id,\n                                parent\n                            };\n                            me.#ignoreColumnChanges = false;\n                            continue;\n                        }\n                        if (sourceColumn.meta.isSelectionColumn) {\n                            me.#ignoreColumnChanges = false;\n                            continue;\n                        }\n                        const\n                            targetParent = columns.getById(parent.id) ?? columns.rootNode,\n                            targetBefore = sourceBefore && columns.getById(sourceBefore.id);\n                        targetParent.insertChild(targetColumn, targetBefore);\n                    }\n                    columns.commit();\n                }\n            }\n            source.commit();\n            me.#ignoreColumnChanges = false;\n        }\n    }\n    //endregion\n    //region Syncing splitters\n    getOtherSplitter(splitter) {\n        return splitter === this.topSplitter ? this.bottomSplitter : this.topSplitter;\n    }\n    onSplitterMouseDown({ source, event }) {\n        if (!event.handled) {\n            event.handled = true;\n            this.getOtherSplitter(source).onMouseDown(event);\n        }\n    }\n    onSplitterDrag({ source, event }) {\n        if (!event.handled) {\n            event.handled = true;\n            this.getOtherSplitter(source).onMouseMove(event);\n        }\n    }\n    onSplitterDrop({ source, event }) {\n        if (!event.handled) {\n            event.handled = true;\n            this.getOtherSplitter(source).onMouseUp(event);\n        }\n    }\n    //endregion\n    //region Relaying property changes & events\n    // Relay relevant config changes to other splits\n    afterConfigChange({ name, value }) {\n        if (this.isSplit && this.relayProperties[name]) {\n            this.syncSplits(split => {\n                split[name] = value;\n            });\n        }\n    }\n    // Sync listeners added at runtime to other splits\n    afterAddListener(eventName, listener) {\n        if (this.isSplit && !listener.$internal && !ignoreListeners[eventName]) {\n            // Not using `ion()` on purpose, these are app listeners\n            // eslint-disable-next-line bryntum/no-on-in-lib\n            this.syncSplits(split => split.on(eventName, listener));\n        }\n    }\n    afterRemoveListener(eventName, listener) {\n        if (!listener.$internal) {\n            this.syncSplits(split => split.un(eventName, listener));\n        }\n    }\n    //endregion\n    //region Util\n    // Call a fn for all splits except the on this fn is called on\n    forEachOther(fn) {\n        const original = this.client.splitFrom || this.client;\n        if (original.features.split.enabled && !original.inForEachOther) {\n            // Protect against infinite recursion by being called from the fn\n            original.inForEachOther = true;\n            for (const view of original.subViews) {\n                if (view !== this.client) {\n                    fn(view);\n                }\n            }\n            original.inForEachOther = false;\n        }\n    }\n    syncSplits(fn) {\n        this.forEachOther(fn);\n    }\n    //endregion\n}\nSplit._$name = 'Split'; GridFeatureManager.registerFeature(Split, false);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport Base from '../../Core/Base.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n/**\n * @module Grid/util/TableExporter\n */\n/**\n * This class transforms grid component into two arrays: rows and columns. Columns array contains objects with\n * meta information about column: field name, column name, width and type of the rendered value, rows array contains\n * arrays of cell values.\n *\n * ```javascript\n * const exporter = new TableExporter({ target : grid });\n * exporter.export()\n *\n * // Output\n * {\n *     columns : [\n *         { field : 'name',     value : 'First name', type : 'string',  width : 100 },\n *         { field : 'surname',  value : 'Last name',  type : 'string',  width : 100 },\n *         { field : 'age',      value : 'Age',        type : 'number',  width : 50  },\n *         { field : 'married',  value : 'Married',    type : 'boolean', width : 50  },\n *         { field : 'children', value : 'Children',   type : 'object',  width : 100 }\n *     ],\n *     rows : [\n *         ['Michael', 'Scott',   40, false, []],\n *         ['Jim',     'Halpert', 30, true,  [...]]\n *     ]\n * }\n * ```\n *\n * ## How data is exported\n *\n * Exporter iterates over store records and processes each record for each column being exported. Exporter uses same\n * approach to retrieve data as column: reading record field, configured on the column, or calling renderer function\n * if one is provided. This means data can be of any type: primitives or objects. So children array in the above code\n * snippet may contain instances of child record class.\n *\n * ## Column renderers\n *\n * Column renderers are commonly used to style the cell, or even render more HTML into it, like {@link Grid.column.WidgetColumn}\n * does. This is not applicable in case of export. Also, given grid uses virtual rendering (only renders visible rows) and\n * exporter iterates over all records, not just visible ones, we cannot provide all data necessary to the renderer. Some\n * arguments, like cellElement and row, wouldn't exist. Thus, the renderer is called with as much data we have: value,\n * record, column, grid, other {@link Grid.column.Column#config-renderer documented arguments} would be undefined.\n *\n * Exporter adds one more flag for renderer function: isExport. When renderer receives this flag it knows\n * data is being exported and can skip DOM work to return simpler value. Below snippet shows simplified code of the\n * widget column handling export:\n *\n * ```javascript\n * renderer({ isExport }) {\n *     if (isExport) {\n *         return null;\n *     }\n *     else {\n *         // widget rendering routine\n *         ...\n *     }\n * }\n * ```\n *\n * ## Column types\n *\n * Column types are not actually a complete list of JavaScript types (you can get actual type of the cell using typeof) it\n * is a simple and helpful meta information.\n *\n * Available column types are:\n *  * string\n *  * number\n *  * boolean\n *  * date\n *  * object\n *\n * Everything which is not primitive like string/number/bool (or a date) is considered an object. This includes null, undefined,\n * arrays, classes, functions etc.\n *\n * ## Getting column type\n *\n * If existing grid column is used, column type first would be checked with {@link Grid.column.Column#config-exportedType exportedType}\n * config. If exportedType is undefined or column does not exist in grid, type is read from a record field definition.\n * If the field is not defined, object type is used.\n *\n * Configuring exported type:\n *\n * ```javascript\n * new Grid({\n *     columns : [\n *         {\n *             name         : 'Name',\n *             field        : 'name',\n *             exportedType : 'object',\n *             renderer     : ({ value, isExport }) => {\n *                 if (isExport) {\n *                     return { value }; // return value wrapped into object\n *                 }\n *             }\n *     ]\n * })\n * ```\n *\n * @extends Core/Base\n */\nexport default class TableExporter extends Base {\n    static get defaultConfig() {\n        return {\n            /**\n             * Target grid instance to export data from\n             * @config {Grid.view.Grid} target\n             */\n            target : null,\n            /**\n             * Specifies a default column width if no width specified\n             * @config {Number} defaultColumnWidth\n             * @default\n             */\n            defaultColumnWidth : 100,\n            /**\n             * Set to `false` to export dates as they are displayed by Date column formatter\n             * @config {Boolean}\n             * @default\n             */\n            exportDateAsInstance : true,\n            /**\n             * If true and the grid is grouped, shows the grouped value in the first column. True by default.\n             * @config {Boolean} showGroupHeader\n             * @default\n             */\n            showGroupHeader : true,\n            /**\n             * An array of column configuration objects used to specify column widths, header text, and data fields to get the data from.\n             * 'field' config is required. If 'text' is missing, it will read it from the grid column or the 'field' config.\n             * If 'width' is missing, it will try to get it retrieved from the grid column or {@link #config-defaultColumnWidth} config.\n             * If no columns provided the config will be generated from the grid columns.\n             *\n             * For example:\n             * ```javascript\n             * columns : [\n             *     'firstName', // field\n             *     'age', // field\n             *     { text : 'Starts', field : 'start', width : 140 },\n             *     { text : 'Ends', field : 'finish', width : 140 }\n             * ]\n             * ```\n             *\n             * @config {String[]|Object[]} columns\n             * @default\n             */\n            columns : null,\n            /**\n             * When true and tree is being exported, node names are indented with {@link #config-indentationSymbol}\n             * @config {Boolean}\n             * @default\n             */\n            indent : true,\n            /**\n             * This symbol (four spaces by default) is used to indent node names when {@link #config-indent} is true\n             * @config {String}\n             * @default\n             */\n            indentationSymbol : '\\u00A0\\u00A0\\u00A0\\u00A0'\n        };\n    }\n    /**\n     * Exports grid data according to provided config\n     * @param {Object} config\n     * @returns {{ rows : Object[][], columns : Object[] }}\n     */\n    export(config = {}) {\n        const me = this;\n        config = ObjectHelper.assign({}, me.config, config);\n        me.normalizeColumns(config);\n        return me.generateExportData(config);\n    }\n    generateExportData(config) {\n        const\n            me      = this,\n            columns = me.generateColumns(config),\n            rows    = me.generateRows(config);\n        return { rows, columns };\n    }\n    normalizeColumns(config) {\n        // In case columns are provided we need to use normalized config. If those are not provided, we are going\n        // to use real columns, possible invoking renderers (we need to pass column instance to the renderer to\n        // avoid breaking API too much)\n        const columns = config.columns || this.target.columns.visibleColumns.filter(rec => rec.exportable !== false);\n        config.columns = columns.map(col => {\n            if (typeof col === 'string') {\n                return this.target.columns.find(column => column.field === col) || { field : col };\n            }\n            else {\n                return col;\n            }\n        });\n    }\n    generateColumns(config) {\n        return config.columns.map(col => this.processColumn(col, config));\n    }\n    generateRows(config) {\n        const { columns, rows } = config;\n        if (columns.length === 0 || rows?.length === 0) {\n            return [];\n        }\n        const\n            me         = this,\n            { target } = me;\n        return (rows || target.store)\n            // although columns are taken from config, it is convenient to provide them as a separate argument\n            // because that allows to override set of columns to process\n            .map(record => me.processRecord(record, columns, config))\n            // filter out empty rows\n            .filter(cells => cells?.length);\n    }\n    getColumnType(column, store = this.target.store) {\n        let result = column.exportedType || 'object';\n        if (column.exportedType === undefined) {\n            if (column.field) {\n                const fieldDefinition = store.modelClass.getFieldDefinition(column.field);\n                if (fieldDefinition && fieldDefinition.type !== 'auto') {\n                    result = fieldDefinition.type;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Extracts export data from the column instance\n     * @param {Grid.column.Column} column\n     * @param {Object} config\n     * @private\n     * @returns {Object}\n     */\n    processColumn(column, config) {\n        const\n            me                     = this,\n            { target }             = me,\n            { defaultColumnWidth } = config;\n        let { field, text : value, width, minWidth } = column;\n        // If column is not configured with field, field is generated (see Column.js around line 514).\n        // In export we want empty string there\n        if (!(field in target.store.modelClass.fieldMap)) {\n            field = '';\n        }\n        // If name or width is missing try to retrieve them from the grid column and the field, or use default values.\n        if (!value || !width) {\n            const gridColumn = target.columns.find(col => col.field === field);\n            if (!value) {\n                value = gridColumn && gridColumn.text || field;\n            }\n            // null or undefined\n            if (width == null) {\n                width = gridColumn && gridColumn.width || defaultColumnWidth;\n            }\n        }\n        width = Math.max(width || defaultColumnWidth, minWidth || defaultColumnWidth);\n        return { field, value, width, type : me.getColumnType(column) };\n    }\n    /**\n     * Extracts export data from the record instance reading supplied column configs\n     * @param {Core.data.Model|null} record If null is passed, all columns will be filled with empty strings\n     * @param {Grid.column.Column[]} columns\n     * @param {Object} config\n     * @private\n     * @returns {Object[]}\n     */\n    processRecord(record, columns, config) {\n        const\n            { target } = this,\n            {\n                showGroupHeader,\n                indent,\n                indentationSymbol\n            }  = config;\n        let cells;\n        if (!record) {\n            cells = columns.map(() => '');\n        }\n        else if (record.isSpecialRow) {\n            if (showGroupHeader && record.meta.groupRowFor) {\n                cells = columns.map(column => {\n                    return target.features.group.buildGroupHeader({\n                        // Create dummy element to get html from\n                        cellElement : DomHelper.createElement(),\n                        grid        : target,\n                        record,\n                        column\n                    });\n                });\n            }\n        }\n        else {\n            cells = columns.map(column => {\n                let value = record.getValue(column.field);\n                const useRenderer = column.renderer || column.defaultRenderer;\n                if (useRenderer && !(value && column.isDateColumn && config.exportDateAsInstance)) {\n                    value = useRenderer.call(column, {\n                        value,\n                        record,\n                        column,\n                        grid     : target,\n                        isExport : true\n                    });\n                }\n                if (indent && column.tree) {\n                    value = `${indentationSymbol.repeat(record.childLevel)}${value}`;\n                }\n                return value;\n            });\n        }\n        return cells;\n    }\n}\nTableExporter._$name = 'TableExporter';", "export default class BooleanUnicodeSymbol {\n    constructor(value) {\n        this._value = value;\n    }\n    get value() {\n        return this._value;\n    }\n    toString() {\n        return Boolean(this.value) ? '\u2713' : '';\n    }\n}\nBooleanUnicodeSymbol._$name = 'BooleanUnicodeSymbol';", "import GridFeatureManager from '../GridFeatureManager.js';\nimport InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport TableExporter from '../../util/TableExporter.js';\nimport BooleanUnicodeSymbol from '../../util/BooleanUnicodeSymbol.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport BrowserHelper from '../../../Core/helper/BrowserHelper.js';\n/**\n * @module Grid/feature/experimental/ExcelExporter\n */\n/**\n * A feature that allows exporting Grid data to Excel or CSV without involving the server. It uses {@link Grid.util.TableExporter}\n * class as data provider, [zipcelx library](https://www.npmjs.com/package/zipcelx)\n * forked and adjusted to support [column width config](https://github.com/bryntum/zipcelx/tree/column-width-build)\n * and [Microsoft XML specification](https://msdn.microsoft.com/en-us/library/office/documentformat.openxml.spreadsheet.aspx).\n * Zipcelx should be either in global scope (window) or can be provided with {@link #config-zipcelx} config.\n *\n *\n * ```html\n * // Global scope\n * <script src=\"zipcelx.js\"></script>\n * ```\n *\n * ```javascript\n * // importing from package\n * import zipcelx from 'zipcelx';\n *\n * const grid = new Grid({\n *     features : {\n *         excelExporter : {\n *             zipcelx\n *         }\n *     }\n * })\n * ```\n *\n * Here is an example of how to add the feature:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         excelExporter : {\n *             // Choose the date format for date fields\n *             dateFormat : 'YYYY-MM-DD HH:mm',\n *\n *             exporterConfig : {\n *                 // Choose the columns to include in the exported file\n *                 columns : ['name', 'role'],\n *                 // Optional, export only selected rows\n *                 rows    : grid.selectedRecords\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * And how to call it:\n *\n * ```javascript\n * grid.features.excelExporter.export({\n *     filename       : 'Export',\n *     exporterConfig : {\n *         columns : [\n *             { text : 'First Name', field : 'firstName', width : 90 },\n *             { text : 'Age', field : 'age', width : 40 },\n *             { text : 'Starts', field : 'start', width : 140 },\n *             { text : 'Ends', field : 'finish', width : 140 }\n *         ]\n *     }\n * })\n * ```\n *\n * Exporting to CSV is done with the `csv` config:\n *\n * ```javascript\n * grid.features.excelExporter.export({\n *     filename       : 'myfile',\n *     csv            : true\n * })\n * ```\n *\n * This feature is **disabled** by default.\n * For info on enabling it, see {@link Grid/view/mixin/GridFeatures}.\n *\n * {@note}This class requires a 3rd party library to export to XLSX{@/note}\n *\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Grid/exporttoexcel\n * @classtype excelExporter\n * @feature\n */\nexport default class ExcelExporter extends InstancePlugin {\n    static get $name() {\n        return 'ExcelExporter';\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * Name of the exported file\n             * @config {String} filename\n             * @default\n             */\n            filename : null,\n            /**\n             * Defines how dates in a cell will be formatted\n             * @config {String} dateFormat\n             * @default\n             */\n            dateFormat : 'YYYY-MM-DD',\n            /**\n             * Exporter class to use as a data provider. {@link Grid.util.TableExporter} by default.\n             * @config {Grid.util.TableExporter}\n             * @typings {typeof TableExporter}\n             * @default\n             */\n            exporterClass : TableExporter,\n            /**\n             * Configuration object for {@link #config-exporterClass exporter class}.\n             * @config {Object}\n             */\n            exporterConfig : null,\n            /**\n             * Reference to zipcelx library. If not provided, exporter will look in the global scope.\n             * @config {Object}\n             */\n            zipcelx : null,\n            /**\n             * If this config is true, exporter will convert all empty values to ''. Empty values are:\n             * * undefined, null, NaN\n             * * Objects/class instances that do not have toString method defined and are stringified to [object Object]\n             * * functions\n             * @config {Boolean}\n             */\n            convertEmptyValueToEmptyString : true\n        };\n    }\n    processValue(value) {\n        if (\n            value === undefined ||\n            value === null ||\n            Number.isNaN(value) ||\n            typeof value === 'function' ||\n            (typeof value === 'object' && String(value) === '[object Object]')\n        ) {\n            return '';\n        }\n        else {\n            return value;\n        }\n    }\n    generateExportData(config) {\n        const\n            me                = this,\n            { rows, columns } = me.exporter.export(config.exporterConfig);\n        return {\n            rows : rows.map(row => {\n                return row.map((value, index) => {\n                    if (value instanceof Date) {\n                        value = DateHelper.format(value, config.dateFormat);\n                    }\n                    else if (typeof value === 'boolean') {\n                        value = new BooleanUnicodeSymbol(value);\n                    }\n                    if (me.convertEmptyValueToEmptyString) {\n                        value = me.processValue(value);\n                    }\n                    const type = columns[index]?.type === 'number' ? 'number' : 'string';\n                    return { value, type };\n                });\n            }),\n            columns : columns.map(col => {\n                let { field, value, width, type } = col;\n                // when number column is exported with zipcelx, excel warns that sheet is broken and asks for repair\n                // repair works, but having error on open doesn't look acceptable\n                // type = type === 'number' ? 'number' : 'string';\n                type = 'string';\n                return { field, value, width, type };\n            })\n        };\n    }\n    /**\n     * Generate and download an Excel (.xslx), or CSV file (.csv).\n     * @param {Object} config Optional configuration object, which overrides initial settings of the feature/exporter.\n     * @param {String} [config.filename] Name of the exported file\n     * @param {String} [config.dateFormat] Defines how dates in a cell will be formatted\n     * @param {Boolean|Object} [config.csv] Set to true to output as a CSV file, or as an object where you can specify\n     * delimiters.\n     * @param {String} [config.csv.columnDelimiter] The CSV delimiter to separate values on one line, defaults to `,`.\n     * @param {String} [config.csv.lineDelimiter] The CSV delimiter to separate lines, defaults to `\\n`.\n     * @param {String[]|Object[]} [config.columns] An array of column configuration objects\n     * @param {Core.data.Model[]} [config.rows] An array of records to export\n     * @returns {Promise} Promise that resolves when the export is completed\n     */\n    export(config = {}) {\n        const\n            me      = this,\n            zipcelx = me.zipcelx || globalThis.zipcelx;\n        if (!zipcelx) {\n            throw new Error('ExcelExporter: \"zipcelx\" library is required');\n        }\n        if (me.disabled) {\n            return;\n        }\n        config = ObjectHelper.assign({}, me.config, config);\n        if (!config.filename) {\n            config.filename = me.client.$$name;\n        }\n        const\n            { filename }      = config,\n            { rows, columns } = me.generateExportData(config);\n        if (config.csv) {\n            const\n                columnDelimiter = config.csv.columnDelimiter || ',',\n                lineDelimiter   = config.csv.lineDelimiter || '\\n',\n                headers         = columns.map(col => this.processCsvValue(col.value)).join(columnDelimiter) + lineDelimiter,\n                text            = rows.map(rowValues => rowValues.map(obj => this.processCsvValue(obj.value)).join(`${columnDelimiter}`)).join(lineDelimiter),\n                blob            = new Blob([headers + text], { type : 'text/csv' });\n            BrowserHelper.downloadBlob(blob, filename);\n            return Promise.resolve();\n        }\n        return zipcelx({\n            filename,\n            sheet : {\n                data : [columns].concat(rows),\n                cols : columns\n            }\n        });\n    }\n    processCsvValue(text = '') {\n        return `\"${String(text).replace(/\"/g, '\"\"')}\"`;\n    }\n    construct(grid, config) {\n        super.construct(grid, config);\n        if (!this.zipcelx) {\n            if (typeof zipcelx !== 'undefined') {\n                this.zipcelx = globalThis.zipcelx;\n            }\n        }\n    }\n    get exporter() {\n        const me = this;\n        return me._exporter || (me._exporter = me.exporterClass.new({ target : me.client }, me.exporterConfig));\n    }\n}\nExcelExporter._$name = 'ExcelExporter'; GridFeatureManager.registerFeature(ExcelExporter, false, 'Grid');\n"],
  "mappings": "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",
  "names": ["_a", "config", "subGrid", "zipcelx"]
}
