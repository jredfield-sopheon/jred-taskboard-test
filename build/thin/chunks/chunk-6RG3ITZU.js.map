{
  "version": 3,
  "sources": ["../../../../Grid/lib/Grid/feature/export/Utils.js", "../../../../Grid/lib/Grid/view/export/field/ExportRowsCombo.js", "../../../../Grid/lib/Grid/view/export/field/ExportOrientationCombo.js", "../../../../Grid/lib/Grid/view/export/ExportDialog.js", "../../../../Grid/lib/Grid/feature/export/exporter/Exporter.js", "../../../../Grid/lib/Grid/feature/export/exporter/MultiPageExporter.js", "../../../../Grid/lib/Grid/feature/export/exporter/MultiPageVerticalExporter.js", "../../../../Grid/lib/Grid/feature/export/exporter/SinglePageExporter.js", "../../../../Grid/lib/Grid/feature/export/PdfExport.js", "../../../../Grid/lib/Grid/feature/export/mixin/PrintMixin.js"],
  "sourcesContent": ["import BrowserHelper from '../../../Core/helper/BrowserHelper.js';\nexport const RowsRange = {\n    all     : 'all',\n    visible : 'visible'\n};\n// Paper format behaves different between in portrait/landscape mode and in print/export. For the most popular format\n// A3/A4 we pick values which work best both for print and export. Legal and Letter formats do not require any hacks.\nexport const PaperFormat = {\n    A6 : {\n        width  : 4.11,\n        height : 5.81\n    },\n    A5 : {\n        width  : 5.81,\n        height : 8.25\n    },\n    A4 : {\n        width           : 8.25,\n        height          : 11.69,\n        portraitWidth   : 8.3,\n        portraitHeight  : 11.7,\n        landscapeWidth  : 11.7,\n        landscapeHeight : 8.26\n    },\n    A3 : {\n        width           : 11.69,\n        height          : 16.49,\n        portraitWidth   : 11.7,\n        // 16.54 works perfect in print, but in export (puppeteer) it results in extra empty page\n        portraitHeight  : 16.49,\n        landscapeWidth  : 16.54,\n        landscapeHeight : 11.68\n    },\n    Legal : {\n        width  : 8.5,\n        height : 14\n    },\n    Letter : {\n        width  : 8.5,\n        height : 11\n    }\n};\nexport function getPrintPaperSizeAdjustments() {\n    if (BrowserHelper.isFirefox) {\n        return {\n            portraitWidth   : 0,\n            portraitHeight  : 0,\n            landscapeWidth  : 0,\n            landscapeHeight : 0.26\n        };\n    }\n    if (BrowserHelper.isSafari) {\n        return {\n            portraitWidth   : 0,\n            portraitHeight  : 0.1,\n            landscapeWidth  : 0,\n            landscapeHeight : 0.5\n        };\n    }\n    return {\n        portraitWidth   : 0,\n        portraitHeight  : 0,\n        landscapeWidth  : 0,\n        landscapeHeight : 0.25\n    };\n};\nexport const Orientation = {\n    portrait  : 'portrait',\n    landscape : 'landscape'\n};\nexport const FileFormat = {\n    pdf : 'pdf',\n    png : 'png'\n};\nexport const FileMIMEType = {\n    pdf : 'application/pdf',\n    png : 'image/png'\n};\n", "import { RowsRange } from '../../../feature/export/Utils.js';\nimport Combo from '../../../../Core/widget/Combo.js';\nexport default class ExportRowsCombo extends Combo {\n    //region Config\n    static get $name() {\n        return 'ExportRowsCombo';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'exportrowscombo';\n    }\n    static get defaultConfig() {\n        return {\n            editable : false\n        };\n    }\n    //endregion\n    buildItems() {\n        const me = this;\n        return [\n            { id : RowsRange.all, text : me.L('L{all}') },\n            { id : RowsRange.visible, text : me.L('L{visible}') }\n        ];\n    }\n}\n// Register this widget type with its Factory\nExportRowsCombo.initClass();\nExportRowsCombo._$name = 'ExportRowsCombo';", "import { Orientation } from '../../../feature/export/Utils.js';\nimport Combo from '../../../../Core/widget/Combo.js';\nexport default class ExportOrientationCombo extends Combo {\n    //region Config\n    static get $name() {\n        return 'ExportOrientationCombo';\n    }\n    // Factoryable type name\n    static get type() {\n        return 'exportorientationcombo';\n    }\n    static get defaultConfig() {\n        return {\n            editable : false\n        };\n    }\n    //endregion\n    buildItems() {\n        const me = this;\n        return [\n            { id : Orientation.portrait, text : me.L('L{portrait}') },\n            { id : Orientation.landscape, text : me.L('L{landscape}') }\n        ];\n    }\n}\n// Register this widget type with its Factory\nExportOrientationCombo.initClass();\nExportOrientationCombo._$name = 'ExportOrientationCombo';", "import Popup from '../../../Core/widget/Popup.js';\nimport LocaleManager from '../../../Core/localization/LocaleManager.js';\nimport './field/ExportRowsCombo.js';\nimport './field/ExportOrientationCombo.js';\nimport { FileFormat, PaperFormat } from '../../feature/export/Utils.js';\nimport '../../../Core/widget/Checkbox.js';\nimport Field from '../../../Core/widget/Field.js';\nfunction buildComboItems(obj, fn = x => x) {\n    return Object.keys(obj).map(key => ({ id : key, text : fn(key) }));\n}\n/**\n * @module Grid/view/export/ExportDialog\n */\n/**\n * Dialog window used by the {@link Grid/feature/export/PdfExport PDF export feature}. It allows users to select export\n * options like paper format and columns to export. This dialog contains a number of predefined\n * {@link Core/widget/Field fields} which you can access through the popup's {@link #property-widgetMap}.\n *\n * ## Default widgets\n *\n * The default widgets of this dialog are:\n *\n * | Widget ref             | Type                         | Weight | Description                                          |\n * |------------------------|------------------------------|--------|----------------------------------------------------- |\n * | `columnsField`         | {@link Core/widget/Combo}    | 100    | Choose columns to export                             |\n * | `rowsRangeField`       | {@link Core/widget/Combo}    | 200    | Choose which rows to export                          |\n * | `exporterTypeField`    | {@link Core/widget/Combo}    | 300    | Type of the exporter to use                          |\n * | `alignRowsField`       | {@link Core/widget/Checkbox} | 400    | Align row top to the page top on every exported page |\n * | `repeatHeaderField`    | {@link Core/widget/Checkbox} | 500    | Toggle repeating headers on / off                    |\n * | `fileFormatField`      | {@link Core/widget/Combo}    | 600    | Choose file format                                   |\n * | `paperFormatField`     | {@link Core/widget/Combo}    | 700    | Choose paper format                                  |\n * | `orientationField`     | {@link Core/widget/Combo}    | 800    | Choose orientation                                   |\n *\n * The default buttons are:\n *\n * | Widget ref             | Type                       | Weight | Description                                          |\n * |------------------------|----------------------------|--------|------------------------------------------------------|\n * | `exportButton`         | {@link Core/widget/Button} | 100    | Triggers export                                      |\n * | `cancelButton`         | {@link Core/widget/Button} | 200    | Cancel export                                        |\n *\n * Bottom buttons may be customized using `bbar` config passed to `exportDialog`:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             exportDialog : {\n *                 bbar : {\n *                     items : {\n *                         exportButton : { text : 'Go!' }\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n * ## Configuring default widgets\n *\n * Widgets can be customized with {@link Grid/feature/export/PdfExport#config-exportDialog} config:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             exportDialog : {\n *                 items : {\n *                     // hide the field\n *                     orientationField  : { hidden : true },\n *\n *                     // reorder fields\n *                     exporterTypeField : { weight : 150 },\n *\n *                     // change default format in exporter\n *                     fileFormatField   : { value : 'png' }\n *                 }\n *             }\n *         }\n *     }\n * });\n *\n * grid.features.pdfExport.showExportDialog();\n * ```\n *\n * ## Configuring default columns\n *\n * By default all visible columns are selected in the export dialog. This is managed by the\n * {@link #config-autoSelectVisibleColumns} config. To change default selected columns you should disable this config\n * and set field value. Value should be an array of valid column ids (or column instances). This way you can\n * preselect hidden columns:\n *\n * ```javascript\n * const grid = new Grid({\n *     columns : [\n *         { id : 'name', text : 'Name', field : 'name' },\n *         { id : 'age', text : 'Age', field : 'age' },\n *         { id : 'city', text : 'City', field : 'city', hidden : true }\n *     ],\n *     features : {\n *         pdfExport : {\n *             exportDialog : {\n *                 autoSelectVisibleColumns : false,\n *                 items : {\n *                     columnsField : { value : ['name', 'city'] }\n *                 }\n *             }\n *         }\n *     }\n * })\n *\n * // This will show export dialog with Name and City columns selected\n * // even though City column is hidden in the UI\n * grid.features.pdfExport.showExportDialog();\n * ```\n *\n * ## Adding fields\n *\n * You can add your own fields to the export dialog. To make such field value acessible to the feature it should follow\n * a specific naming pattern - it should have `ref` config ending with `Field`, see other fields for reference -\n * `orientationField`, `columnsField`, etc. Fields not matching this pattern are ignored. When values are collected from\n * the dialog, `Field` part of the widget reference is removed, so `orientationField` becomes `orientation`, `fooField`\n * becomes `foo`, etc.\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             exportDialog : {\n *                 items : {\n *                     // This field gets into export config\n *                     fooField : {\n *                         type : 'text',\n *                         label : 'Foo',\n *                         value : 'FOO'\n *                     },\n *\n *                     // This one does not, because name doesn't end with `Field`\n *                     bar : {\n *                         type : 'text',\n *                         label : 'Bar',\n *                         value : 'BAR'\n *                     },\n *\n *                     // Add a container widget to wrap some fields together\n *                     myContainer : {\n *                         type : 'container',\n *                         items : {\n *                             // This one gets into config too despite the nesting level\n *                             bazField : {\n *                                 type : 'text',\n *                                 label : 'Baz',\n *                                 value : 'BAZ'\n *                             }\n *                         }\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n *\n * // Assuming export dialog is opened and export triggered with default values\n * // you can receive custom field values here\n * grid.on({\n *     beforePdfExport({ config }) {\n *         console.log(config.foo) // 'FOO'\n *         console.log(config.bar) // undefined\n *         console.log(config.baz) // 'BAZ'\n *     }\n * });\n * ```\n *\n * ## Configuring widgets at runtime\n *\n * If you don't know column ids before grid instantiation or you want a flexible config, you can change widget values\n * before dialog pops up:\n *\n * ```javascript\n * const grid = new Grid({\n *     columns : [\n *         { id : 'name', text : 'Name', field : 'name' },\n *         { id : 'age', text : 'Age', field : 'age' },\n *         { id : 'city', text : 'City', field : 'city', hidden : true }\n *     ],\n *     features : {\n *         pdfExport : true\n *     }\n * });\n *\n * // Such listener would ignore autoSelectVisibleColumns config. Similar to the snippet\n * // above this will show Name and City columns\n * grid.features.pdfExport.exportDialog.on({\n *     beforeShow() {\n *         this.widgetMap.columnsField.value = ['age', 'city']\n *     }\n * });\n * ```\n *\n * @extends Core/widget/Popup\n */\nexport default class ExportDialog extends Popup {\n    //region Config\n    static get $name() {\n        return 'ExportDialog';\n    }\n    static get type() {\n        return 'exportdialog';\n    }\n    static get configurable() {\n        return {\n            autoShow  : false,\n            autoClose : false,\n            closable  : true,\n            centered  : true,\n            /**\n             * Returns map of values of dialog fields.\n             * @member {Object<String,Object>} values\n             * @readonly\n             */\n            /**\n             * Grid instance to build export dialog for\n             * @config {Grid.view.Grid}\n             */\n            client : null,\n            /**\n             * Set to `false` to not preselect all visible columns when the dialog is shown\n             * @config {Boolean}\n             */\n            autoSelectVisibleColumns : true,\n            /**\n             * Set to `false` to allow using PNG + Multipage config in export dialog\n             * @config {Boolean}\n             */\n            hidePNGMultipageOption : true,\n            /**\n             * When set to `true` labels in the dialog will say `Print` instead of `Export`\n             * @prp {Boolean}\n             */\n            useBrowserPrint : false,\n            title : 'L{exportSettings}',\n            maxHeight : '80%',\n            scrollable : {\n                overflowY : true\n            },\n            defaults : {\n                localeClass : this\n            },\n            items : {\n                columnsField : {\n                    type         : 'combo',\n                    label        : 'L{ExportDialog.columns}',\n                    name         : 'columns',\n                    store        : {},\n                    valueField   : 'id',\n                    displayField : 'text',\n                    multiSelect  : true,\n                    weight       : 100,\n                    maxHeight    : 100\n                },\n                rowsRangeField : {\n                    type   : 'exportrowscombo',\n                    label  : 'L{ExportDialog.rows}',\n                    name   : 'rowsRange',\n                    value  : 'all',\n                    weight : 200\n                },\n                exporterTypeField : {\n                    type         : 'combo',\n                    label        : 'L{ExportDialog.exporterType}',\n                    name         : 'exporterType',\n                    editable     : false,\n                    value        : 'singlepage',\n                    displayField : 'text',\n                    buildItems() {\n                        const dialog = this.parent;\n                        return dialog.exporters.map(exporter => ({\n                            id   : exporter.type,\n                            text : dialog.optionalL(exporter.title, this)\n                        }));\n                    },\n                    onChange({ value }) {\n                        this.owner.widgetMap.alignRowsField.hidden    = value === 'singlepage';\n                        this.owner.widgetMap.repeatHeaderField.hidden = value !== 'multipagevertical';\n                    },\n                    weight : 300\n                },\n                alignRowsField : {\n                    type    : 'checkbox',\n                    label   : 'L{ExportDialog.alignRows}',\n                    name    : 'alignRows',\n                    checked : false,\n                    hidden  : true,\n                    weight  : 400\n                },\n                repeatHeaderField : {\n                    type        : 'checkbox',\n                    label       : 'L{ExportDialog.repeatHeader}',\n                    name        : 'repeatHeader',\n                    localeClass : this,\n                    hidden      : true,\n                    weight      : 500\n                },\n                fileFormatField : {\n                    type        : 'combo',\n                    label       : 'L{ExportDialog.fileFormat}',\n                    name        : 'fileFormat',\n                    localeClass : this,\n                    editable    : false,\n                    value       : 'pdf',\n                    items       : [],\n                    onChange({ value, oldValue }) {\n                        const dialog = this.parent;\n                        if (dialog.hidePNGMultipageOption) {\n                            const\n                                exporterField = dialog.widgetMap.exporterTypeField,\n                                exporter      = exporterField.store.find(r => r.id === 'singlepage');\n                            if (value === FileFormat.png && exporter) {\n                                this._previousDisabled = exporterField.disabled;\n                                exporterField.disabled = true;\n                                this._previousValue = exporterField.value;\n                                exporterField.value = 'singlepage';\n                            }\n                            else if (oldValue === FileFormat.png && this._previousValue) {\n                                exporterField.disabled = this._previousDisabled;\n                                exporterField.value    = this._previousValue;\n                            }\n                        }\n                    },\n                    weight : 600\n                },\n                paperFormatField : {\n                    type     : 'combo',\n                    label    : 'L{ExportDialog.paperFormat}',\n                    name     : 'paperFormat',\n                    editable : false,\n                    value    : 'A4',\n                    items    : [],\n                    weight   : 700\n                },\n                orientationField : {\n                    type   : 'exportorientationcombo',\n                    label  : 'L{ExportDialog.orientation}',\n                    name   : 'orientation',\n                    value  : 'portrait',\n                    weight : 800\n                }\n            },\n            bbar : {\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    exportButton : {\n                        color   : 'b-green',\n                        text    : 'L{ExportDialog.export}',\n                        weight  : 100,\n                        onClick : 'up.onExportClick'\n                    },\n                    cancelButton : {\n                        color   : 'b-gray',\n                        text    : 'L{ExportDialog.cancel}',\n                        weight  : 200,\n                        onClick : 'up.onCancelClick'\n                    }\n                }\n            }\n        };\n    }\n    //endregion\n    construct(config = {}) {\n        const\n            me         = this,\n            { client } = config;\n        if (!client) {\n            throw new Error('`client` config is required');\n        }\n        me.columnsStore = client.columns.chain(column => column.isLeaf && column.exportable, null, { excludeCollapsedRecords : false });\n        me.applyInitialValues(config);\n        super.construct(config);\n        LocaleManager.ion({\n            locale  : 'onLocaleChange',\n            prio    : -1,\n            thisObj : me\n        });\n    }\n    updateUseBrowserPrint(value) {\n        const me = this;\n        me.whenVisible(() => {\n            if (value) {\n                me.widgetMap.exportButton.text = me.L('L{ExportDialog.print}');\n                me.widgetMap.fileFormatField.hidden = true;\n                me.title = me.L('L{printSettings}');\n            }\n            else {\n                me.widgetMap.exportButton.text = me.L('L{ExportDialog.export}');\n                me.widgetMap.fileFormatField.hidden = Boolean(me.widgetMap.fileFormatField.initialConfig.hidden);\n                me.title = me.L('L{exportSettings}');\n            }\n        });\n    }\n    applyInitialValues(config) {\n        const\n            me    = this,\n            items = config.items = config.items || {};\n        config.width               = config.width || me.L('L{width}');\n        config.defaults            = config.defaults || {};\n        config.defaults.labelWidth = config.defaults.labelWidth || me.L('L{ExportDialog.labelWidth}');\n        items.columnsField     = items.columnsField || {};\n        items.fileFormatField  = items.fileFormatField || {};\n        items.paperFormatField = items.paperFormatField || {};\n        items.fileFormatField.items  = buildComboItems(FileFormat, value => value.toUpperCase());\n        items.paperFormatField.items = buildComboItems(PaperFormat);\n        items.columnsField.store = me.columnsStore;\n    }\n    onBeforeShow() {\n        const { columnsField, alignRowsField, exporterTypeField, repeatHeaderField } = this.widgetMap;\n        if (this.autoSelectVisibleColumns) {\n            columnsField.value = this.columnsStore.query(c => !c.hidden);\n        }\n        alignRowsField.hidden    = exporterTypeField.value === 'singlepage';\n        repeatHeaderField.hidden = exporterTypeField.value !== 'multipagevertical';\n        super.onBeforeShow?.(...arguments);\n    }\n    onLocaleChange() {\n        const\n            labelWidth = this.L('L{labelWidth}');\n        this.width = this.L('L{width}');\n        this.eachWidget(widget => {\n            if (widget instanceof Field) {\n                widget.labelWidth = labelWidth;\n            }\n        });\n    }\n    onExportClick() {\n        const values = this.values;\n        /**\n         * Fires when export button is clicked\n         * @event export\n         * @param {Object} values Object containing config for {@link Grid.feature.export.PdfExport#function-export export()} method\n         * @category Export\n         */\n        this.trigger('export', { values });\n    }\n    onCancelClick() {\n        /**\n         * Fires when cancel button is clicked. Popup will hide itself.\n         * @event cancel\n         * @category Export\n         */\n        this.trigger('cancel');\n        this.hide();\n    }\n}\nExportDialog.initClass();\nExportDialog._$name = 'ExportDialog';", "import DomSync from '../../../../Core/helper/DomSync.js';\nimport TemplateHelper from '../../../../Core/helper/TemplateHelper.js';\nimport BrowserHelper from '../../../../Core/helper/BrowserHelper.js';\nimport Base from '../../../../Core/Base.js';\nimport Localizable from '../../../../Core/localization/Localizable.js';\nimport IdHelper from '../../../../Core/helper/IdHelper.js';\nimport DomHelper from '../../../../Core/helper/DomHelper.js';\nimport { getPrintPaperSizeAdjustments, RowsRange } from '../Utils.js';\nimport Events from '../../../../Core/mixin/Events.js';\nimport Delayable from '../../../../Core/mixin/Delayable.js';\n/**\n * @module Grid/feature/export/exporter/Exporter\n */\n/**\n * Base class for all exporters\n * @mixes Core/localization/Localizable\n * @mixes Core/mixin/Events\n */\nexport default class Exporter extends Delayable(Events(Localizable(Base))) {\n    static get defaultConfig() {\n        return {\n            /**\n             * `True` to replace all linked CSS files URLs to absolute before passing HTML to the server.\n             * When passing a string the current origin of the CSS files URLS will be replaced by the passed origin.\n             *\n             * For example: css files pointing to /app.css will be translated from current origin to {translateURLsToAbsolute}/app.css\n             * @config {Boolean|String}\n             * @default\n             */\n            translateURLsToAbsolute : true,\n            /**\n             * When true links are converted to absolute by combining current window location (with replaced origin) with\n             * resource link.\n             * When false links are converted by combining new origin with resource link (for angular)\n             * @config {Boolean}\n             * @default\n             */\n            keepPathName : true,\n            /**\n             * This method accepts all stylesheets (link and style tags) which are supposed to be put on the page. Use this\n             * hook method to filter or modify them.\n             *\n             * ```javascript\n             * new Grid({\n             *     features: {\n             *         pdfExport: {\n             *             // filter out inline styles and bootstrap.css\n             *             filterStyles: styles => styles.filter(item => !/(link|bootstrap.css)/.test(item))\n             *         }\n             *     }\n             * });\n             * ```\n             * @param {String[]} styles\n             * @returns {String[]} List of stylesheets to put on the exported page\n             */\n            filterStyles : styles => styles\n        };\n    }\n    static inchToPx(value) {\n        // 1in = 96px for screens\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/length#Absolute_length_units\n        return value * 96;\n    }\n    /**\n     * Template of an extracted page.\n     * @param {Object} data Data for the page template\n     * @returns {String}\n     */\n    pageTpl(data) {\n        const\n            {\n                title,\n                header,\n                footer,\n                styles,\n                htmlClasses,\n                bodyClasses = [],\n                paperHeight,\n                paperWidth,\n                html,\n                currentPage,\n                isPrint\n            } = data;\n        let { htmlStyle = '', bodyStyle = '' } = data;\n        bodyClasses.push(`b-${this.constructor.type}`);\n        // Other classes needed on outer element.\n        if (DomHelper.scrollBarWidth) {\n            bodyClasses.push('b-visible-scrollbar');\n        }\n        else {\n            bodyClasses.push('b-overlay-scrollbar');\n        }\n        if (BrowserHelper.isChrome) {\n            bodyClasses.push('b-chrome');\n        }\n        else if (BrowserHelper.isSafari) {\n            bodyClasses.push('b-safari');\n        }\n        else if (BrowserHelper.isFirefox) {\n            bodyClasses.push('b-firefox');\n        }\n        htmlStyle = isPrint ? htmlStyle : `${htmlStyle}; width: ${paperWidth}in; height: ${paperHeight}in;`;\n        bodyStyle = isPrint ? `${bodyStyle}; width: ${paperWidth}in;` : `${bodyStyle}; width: ${paperWidth}in; height: ${paperHeight}in;`;\n        return TemplateHelper.tpl`\n            <!DOCTYPE html>\n            <html class=\"${htmlClasses} b-print-root\" style=\"${htmlStyle}\">\n                <head>\n                    <meta content=\"text/html; charset=UTF-8\" http-equiv=\"Content-Type\" />\n                    <title>${title}</title>\n                    ${styles.join('')}\n                </head>\n                <body class=\"b-export ${bodyClasses.join(' ')}\" style=\"${bodyStyle}\">\n                    <div class=\"b-export-content b-page-${currentPage}\">\n                        ${header && `<div class=\"b-export-header\" style=\"width: 100%\">${header}</div>`}\n                        <div class=\"b-export-body\"><div class=\"b-export-viewport\">${html}</div></div>\n                        ${footer && `<div class=\"b-export-footer\" style=\"width: 100%\">${footer}</div>`}\n                    </div>\n                </body>\n            </html>`;\n    }\n    /**\n     * Returns all style-related tags: `<style>` and `<link rel=\"stylesheet\">`\n     * @property {String[]}\n     * @readonly\n     */\n    get stylesheets() {\n        const me = this;\n        if (me._stylesheets) {\n            return me._stylesheets;\n        }\n        const\n            translate       = me.translateURLsToAbsolute,\n            origin          = globalThis.origin,\n            styleSheetNodes = Array.from(document.querySelectorAll('link[rel=\"stylesheet\"], style')),\n            styles          = [];\n        styleSheetNodes.forEach(node => {\n            node = node.cloneNode(true);\n            // put absolute URL to node `href` attribute\n            if (translate && node.href) {\n                let result;\n                if (translate === true) {\n                    result = node.href;\n                }\n                // translate is truthy if we are here, which means it is string now\n                else if (this.keepPathName) {\n                    result = node.href.replace(origin, translate);\n                }\n                else {\n                    result = new URL(node.getAttribute('href'), translate);\n                }\n                node.setAttribute('href', result);\n            }\n            let styleText = node.outerHTML;\n            if (translate && /style/i.test(node.tagName)) {\n                const converter = me.getStyleTagURLConverter(translate);\n                styleText = styleText.replace(/url\\(['\"]?(.+?)['\"]?\\)/g, converter);\n            }\n            styles.push(styleText);\n        });\n        return me._stylesheets = me.filterStyles(styles);\n    }\n    set stylesheets(value) {\n        this._stylesheets = value ? this.filterStyles(value) : value;\n    }\n    getStyleTagURLConverter(translate) {\n        return function(match, url) {\n            let result;\n            try {\n                let base;\n                // Filter out local references, e.g. to svg marker\n                if (/^#/.test(url)) {\n                    result = match;\n                }\n                else {\n                    if (translate === true) {\n                        base = globalThis.location.href;\n                    }\n                    // translate is truthy if we are here, which means it is string now\n                    else if (this.keepPathName) {\n                        base = globalThis.location.href.replace(globalThis.location.origin, translate);\n                    }\n                    else {\n                        base = translate;\n                    }\n                    result = `url('${new URL(url, base).href}')`;\n                }\n            }\n            catch (e) {\n                result = match;\n            }\n            return result;\n        }.bind(this);\n    }\n    saveState({ client }) {\n        this.state = client.state;\n    }\n    async restoreState({ client }) {\n        const\n            promises  = [],\n            detachers = new Set();\n        detachers.add(\n            client.scrollable.ion({\n                scroll() {\n                    promises.push(client.scrollable.await('scrollEnd'));\n                }\n            })\n        );\n        client.eachSubGrid(({ header, scrollable }) => {\n            detachers.add(\n                scrollable.ion({\n                    scroll() {\n                        promises.push(scrollable.await('scrollEnd'));\n                    }\n                })\n            );\n            detachers.add(\n                header.scrollable.ion({\n                    scroll() {\n                        promises.push(header.scrollable.await('scrollEnd'));\n                    }\n                })\n            );\n        });\n        client.state = this.state;\n        await Promise.all(promises);\n        detachers.forEach(fn => fn());\n    }\n    beforeExport() {\n        // Into this element we will put HTML for export\n        this.element = document.createElement('div');\n    }\n    //region DOM helpers\n    cloneElement(element, target = this.element, clear = true) {\n        if (clear) {\n            target.innerHTML = '';\n        }\n        target.appendChild(element.cloneNode(true));\n        DomHelper.removeEachSelector(target, '.b-grid-row,.b-grid-merged-cells-container');\n        const maskEl = target.querySelector('.b-gridbase > .b-mask');\n        if (maskEl) {\n            maskEl.remove();\n        }\n    }\n    createPlaceholder(el, clear = true, config = {}) {\n        if (clear) {\n            el.innerHTML = '';\n        }\n        return DomHelper.createElement(Object.assign({\n            parent : el,\n            id     : IdHelper.generateId('export')\n        }, config));\n    }\n    prepareElement({ client }) {\n        const { tbar, bbar } = client;\n        if (tbar) {\n            this.element.querySelector(`#${tbar.id}`).remove();\n        }\n        if (bbar) {\n            this.element.querySelector(`#${bbar.id}`).remove();\n        }\n    }\n    /**\n     * Appends generated header/footer element to the document body to measure their height\n     * @param html\n     * @returns {Number}\n     * @private\n     */\n    measureElement(html = '') {\n        if (html instanceof HTMLElement) {\n            html = html.outerHTML;\n        }\n        const target = DomHelper.createElement({\n            parent : document.body,\n            style  : {\n                visibility : 'hidden',\n                position   : 'absolute'\n            },\n            // Add html to measure to a div between two other divs to take margin into account\n            html : `<div style=\"height: 1px\"></div>${html}<div style=\"height: 1px\"></div>`\n        });\n        const result = target.offsetHeight - 2;\n        target.remove();\n        return result;\n    }\n    // Converts local urls to absolute\n    prepareHTML(html) {\n        if (html instanceof HTMLElement) {\n            html = html.outerHTML;\n        }\n        const target = DomHelper.createElement({\n            parent : document.body,\n            style  : {\n                visibility : 'hidden',\n                position   : 'absolute'\n            },\n            html\n        });\n        const elements = target.querySelectorAll('img');\n        for (let i = 0, l = elements.length; i < l; i++) {\n            elements[i].setAttribute('src', elements[i].src);\n        }\n        const result = target.innerHTML;\n        target.remove();\n        return result;\n    }\n    getVirtualScrollerHeight(client) {\n        let result = 0;\n        // If overlay scroll is enabled, this will return 0\n        // when disabled, it will report proper virtualScrollers element height\n        client.eachSubGrid(subGrid => {\n            if (subGrid.overflowingHorizontally) {\n                result = DomHelper.scrollBarWidth;\n            }\n        });\n        // If there's a visible scrollbar, need to also take border height into account\n        return result === 0 ? result : (result + 1);\n    }\n    //endregion\n    // Use carefully picked values for portrait/landscape mode and fallback to legacy width/height in case use\n    // has them overridden\n    getPaperWidth(paperFormat, isPortrait) {\n        if ('portraitWidth' in paperFormat) {\n            const prop = isPortrait ? 'portraitWidth' : 'landscapeWidth';\n            return paperFormat[prop] - (this.exportMeta.isPrinting ? getPrintPaperSizeAdjustments()[prop] : 0);\n        }\n        else {\n            return isPortrait ? paperFormat.width : paperFormat.height;\n        }\n    }\n    getPaperHeight(paperFormat, isPortrait) {\n        if ('portraitHeight' in paperFormat) {\n            const prop = isPortrait ? 'portraitHeight' : 'landscapeHeight';\n            return paperFormat[prop] - (this.exportMeta.isPrinting ? getPrintPaperSizeAdjustments()[prop] : 0);\n        }\n        else {\n            return isPortrait ? paperFormat.height : paperFormat.width;\n        }\n    }\n    inchToPx(value) {\n        // 1in = 96px for screens\n        // https://developer.mozilla.org/en-US/docs/Web/CSS/length#Absolute_length_units\n        return value * 96;\n    }\n    getScaleValue(base, value) {\n        return Math.floor((base * 10000 / value)) / 10000;\n    }\n    getVisibleRowsCount(client) {\n        const\n            rowManager        = client.rowManager,\n            // We cannot rely on `visibleRowCount` property, it is a mere estimate\n            firstVisibleIndex = rowManager.rows.indexOf(rowManager.firstVisibleRow),\n            lastVisibleIndex  = rowManager.rows.indexOf(rowManager.lastVisibleRow);\n        let result;\n        // first index could be negative only if there are no rendered rows, in which case we return store count\n        if (firstVisibleIndex !== -1) {\n            // last visible index could be negative if last actually visible row doesn't reach view bottom, i.e.\n            // view is not completely filled with rows\n            if (lastVisibleIndex === -1) {\n                result = client.store.count - firstVisibleIndex;\n            }\n            else {\n                // for a zero-based index we need to add 1 to the result\n                result = lastVisibleIndex - firstVisibleIndex + 1;\n            }\n        }\n        else {\n            result = client.store.count;\n        }\n        return result;\n    }\n    async export(config) {\n        const me = this;\n        let pages;\n        me.beforeExport();\n        me.saveState(config);\n        await me.prepareComponent(config);\n        try {\n            pages = await me.getPages(config);\n        }\n        finally {\n            await me.restoreComponent(config);\n            me.stylesheets = null;\n            // https://app.assembla.com/spaces/bryntum/tickets/9400-scrollrowintoview-promise-is-not-reliable/details\n            // Restoring scroll might trigger rows repaint on next animation frame. We are\n            // waiting for next animation frame in such case. Covered in SinglePage.t.js\n            await new Promise(resolve => me.requestAnimationFrame(resolve));\n            await me.restoreState(config);\n        }\n        return pages;\n    }\n    async getPages(config) {\n        const\n            generator = this.pagesExtractor(config),\n            pages     = [];\n        let step;\n        while ((step = await generator.next()) && !step.done) {\n            pages.push(step.value);\n        }\n        return pages;\n    }\n    // Row buffer has to be adjusted to render complete row set per exported page. See virtual scrolling section in README\n    // for more details\n    adjustRowBuffer(client) {\n        const\n            { contentHeight } = this.exportMeta,\n            { rowManager }    = client;\n        this.oldRowManagerConfig = {\n            prependRowBuffer : rowManager.prependRowBuffer,\n            appendRowBuffer  : rowManager.appendRowBuffer\n        };\n        // render 3 times more rows to get enough to fill exported page\n        const adjustedRowBuffer = Math.ceil(contentHeight / rowManager.rowOffsetHeight);\n        rowManager.prependRowBuffer = adjustedRowBuffer;\n        rowManager.appendRowBuffer = adjustedRowBuffer;\n        client.renderRows();\n        // In case we are at the bottom of the view and we are increasing buffer, rowmanager might return to the top row\n        // In this case we need to force it to render rows at the current scroll position\n        client.rowManager.jumpToPosition(client.scrollable.y);\n    }\n    restoreRowBuffer(client) {\n        client.rowManager.prependRowBuffer = this.oldRowManagerConfig.prependRowBuffer;\n        client.rowManager.appendRowBuffer = this.oldRowManagerConfig.appendRowBuffer;\n        // There is no need to force rendering rows here, those would be updated during applyState call on a grid.\n        // More precisely - during setRowHeight method.\n    }\n    async prepareComponent(config) {\n        const\n            me             = this,\n            {\n                client,\n                columns,\n                rowsRange,\n                keepRegionSizes,\n                enableDirectRendering,\n                useRenderedColumnWidth\n            }              = config,\n            { rowManager } = client,\n            exportMeta     = me.exportMeta = {\n                enableDirectRendering,\n                totalWidth  : 0,\n                totalHeight : 0 - (enableDirectRendering ? 0 : me.getVirtualScrollerHeight(client)),\n                subGrids    : {},\n                isPrinting  : config.useBrowserPrint\n            };\n        client.columns.forEach(column => {\n            if (columns.includes(column.id)) {\n                column.show();\n            }\n            else {\n                column.hide();\n            }\n        });\n        // Wait for animation frame to catch optional resize event which may occur after hiding columns. Scroll\n        // stretcher should be synced before we proceed.\n        // Covered by export/Columns.t\n        await new Promise(resolve => client.requestAnimationFrame(resolve));\n        if (rowManager.rowCount > 0) {\n            if (rowsRange === RowsRange.all) {\n                exportMeta.firstVisibleDataIndex = rowManager.rows[0].dataIndex;\n            }\n            else {\n                exportMeta.firstVisibleDataIndex = rowManager.firstVisibleRow.dataIndex;\n                config.alignRows = true;\n            }\n            if (!enableDirectRendering) {\n                await client.scrollRowIntoView(client.store.getAt(exportMeta.firstVisibleDataIndex), { block : 'start' });\n            }\n        }\n        const { element } = me;\n        // clone whole grid element to the detached container\n        me.cloneElement(client.element);\n        me.prepareElement(config);\n        let fakeRow;\n        // Create fake row, we will use it to render stuff\n        if (enableDirectRendering) {\n            exportMeta.fakeRow = fakeRow = rowManager.rowClass.new({\n                cls       : client.rowCls,\n                rowManager,\n                grid      : client,\n                // use fake indices, they aren't really required\n                index     : -10,\n                dataIndex : -10\n            });\n        }\n        client.eachSubGrid(subGrid => {\n            // Call private listener to create actual DOM nodes\n            if (fakeRow) {\n                subGrid.onAddRow({ rows : [fakeRow], isExport : true });\n                // Trick inline widgets to think they're rendered into component (in fact they are)\n                // This is required to remove `Widget.outerCls` classes from the widget\n                fakeRow.element.dataset.ownerCmp = client.id;\n            }\n            const placeHolder = me.createPlaceholder(element.querySelector(`[id=\"${subGrid.id}\"]`), false);\n            let width;\n            if (keepRegionSizes?.[subGrid.region]) {\n                width = subGrid.element.offsetWidth;\n            }\n            else {\n                const { visibleColumns } = subGrid.columns;\n                if (\n                    // If there is only one visible column...\n                    visibleColumns.length === 1 &&\n                    // ...and it is not a timeaxis column, which should always take as much space as possible\n                    !visibleColumns[0].isTimeAxisColumn &&\n                    // ...and originally in grid there was only one visible column and it is the same one\n                    me.state.columns.filter(c => c.region === subGrid.region && !c.hidden && c.id !== visibleColumns[0].id).length === 0\n                ) {\n                    // ...then use subgrid width instead of column width\n                    // https://github.com/bryntum/support/issues/7695\n                    width = subGrid.element.offsetWidth;\n                }\n                else {\n                    width = subGrid.columns.visibleColumns.reduce((result, column) => {\n                        if (!useRenderedColumnWidth && typeof column.width === 'number') {\n                            result += column.width;\n                        }\n                        else {\n                            result += (client.hideHeaders ? rowManager.rows[0].getCell(column.id) : column.element).offsetWidth;\n                        }\n                        return result;\n                    }, 0);\n                }\n            }\n            exportMeta.totalWidth += width;\n            const splitterWidth = subGrid.splitterElement?.offsetWidth || 0;\n            exportMeta.totalWidth += splitterWidth;\n            exportMeta.subGrids[subGrid.region] = {\n                id       : subGrid.id,\n                headerId : subGrid.header?.id || null,\n                footerId : subGrid.footer?.id || null,\n                rows     : [],\n                splitterWidth,\n                placeHolder,\n                width\n            };\n        });\n    }\n    prepareExportElement() {\n        const\n            me                      = this,\n            { element, exportMeta } = me;\n        // Exporters may change subGrid width, e.g. when specific date range is exported\n        Object.values(exportMeta.subGrids).forEach(({ width, id, headerId, footerId }) => {\n            [id, headerId, footerId].forEach(id => {\n                if (id) {\n                    const childElement = element.querySelector(`[id=\"${id}\"]`);\n                    // SubGrid now always have header & footer, but not always in DOM\n                    if (childElement) {\n                        childElement.style.width = `${width}px`;\n                        childElement.style.flex = '';\n                    }\n                }\n            });\n        });\n        return element.innerHTML;\n    }\n    async restoreComponent(config) {\n        if (this.exportMeta.fakeRow) {\n            this.exportMeta.fakeRow.destroy();\n            delete this.exportMeta.fakeRow;\n        }\n    }\n    async scrollRowIntoView(client, index) {\n        await client.scrollRowIntoView(client.store.getAt(index), { block : 'start' });\n        // #9400 - scrollRowIntoView promise is not reliable\n        await new Promise(resolve => this.requestAnimationFrame(resolve));\n    }\n    collectRow(row) {\n        const\n            subGrids = this.exportMeta.subGrids,\n            re       = /data-owner-cmp=\".+?\"/;\n        Object.entries(row.elements).forEach(([key, value]) => {\n            subGrids[key].rows.push([\n                value.outerHTML.replace(re, ''),\n                row.top,\n                row.offsetHeight,\n                new Map() // This one is used to collect events (or in general additional row content)\n            ]);\n        });\n    }\n    renderMergedCells(config, fromIndex, toIndex, rows) {\n        const\n            me           = this,\n            { client }   = config,\n            { subGrids } = me.exportMeta,\n            // Generate config for merged cells\n            domConfigMap = client.features.mergeCells.buildMergedCellsConfig(fromIndex, toIndex, rows);\n        for (const subGridName in subGrids) {\n            const\n                subGrid = subGrids[subGridName],\n                target  = document.createElement('div');\n            // Render config into temporary element\n            DomSync.sync({\n                targetElement : target,\n                domConfig     : {\n                    children : domConfigMap[subGridName].children\n                }\n            });\n            if (target.childNodes.length) {\n                // mergeCells feature uses dependency injection, so in order to get rendered cell content we\n                // need to get the cell element matching the range\n                target.childNodes.forEach(child => {\n                    const\n                        { syncId } = child.dataset,\n                        range      = client.features.mergeCells.mergedRanges\n                            .find(range => range.cellElement?.parentNode.dataset.syncId === syncId);\n                    if (range) {\n                        // Replace cell content if range is found (it might not be found if there's only one cell)\n                        child.innerHTML = range.cellElement.outerHTML;\n                    }\n                });\n                subGrid.mergedCellsHtml = [target.innerHTML];\n            }\n        }\n    }\n}\n// HACK: terser/obfuscator doesn't yet support async generators, when processing code it converts async generator to regular async\n// function.\n/**\n * Pages generator. Value should be string with exported HTML\n * @param {Object} config\n * @returns {AsyncIterableIterator<{value: String, done: Boolean}>}\n * @private\n */\nExporter.prototype.pagesExtractor = async function * pagesExtractor() {\n    throw new Error('Implement this method in a subclass');\n};\nExporter._$name = 'Exporter';", "import Exporter from './Exporter.js';\nimport { Orientation, PaperFormat, RowsRange } from '../Utils.js';\n/**\n * @module Grid/feature/export/exporter/MultiPageExporter\n */\n/**\n * A multiple page exporter. Used by the {@link Grid.feature.export.PdfExport} feature to export to multiple pages. You\n * do not need to use this class directly.\n *\n * ### Extending exporter\n *\n * ```javascript\n * class MyMultiPageExporter extends MultiPageExporter {\n *     // type is required for exporter\n *     static get type() {\n *         return 'mymultipageexporter';\n *     }\n *\n *     get stylesheets() {\n *         const stylesheets = super.stylesheets;\n *\n *         stylesheets.forEach(styleNodeOrLinkTag => doSmth(styleNodeOrLinkTag))\n *\n *         return stylesheets;\n *     }\n * }\n *\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             // this export feature is configured with only one exporter\n *             exporters : [MyMultiPageExporter]\n *         }\n *     }\n * });\n *\n * // run export with the new exporter\n * grid.features.pdfExport.export({ exporter : 'mymultipageexporter' });\n * ```\n *\n * @classtype multipage\n * @extends Grid/feature/export/exporter/Exporter\n */\nexport default class MultiPageExporter extends Exporter {\n    static get $name() {\n        return 'MultiPageExporter';\n    }\n    static get type() {\n        return 'multipage';\n    }\n    static get title() {\n        // In case locale is missing exporter is still distinguishable\n        return this.L('L{multipage}');\n    }\n    static get exportingPageText() {\n        return 'L{exportingPage}';\n    }\n    //region State management\n    async stateNextPage({ client, rowsRange, enableDirectRendering }) {\n        const { exportMeta } = this;\n        ++exportMeta.currentPage;\n        ++exportMeta.verticalPosition;\n        delete exportMeta.lastExportedRowBottom;\n        // If current vertical position is greater than max vertical pages, switch to next column\n        if (exportMeta.verticalPosition >= exportMeta.verticalPages) {\n            Object.assign(exportMeta, {\n                verticalPosition     : 0,\n                horizontalPosition   : exportMeta.horizontalPosition + 1,\n                currentPageTopMargin : 0,\n                lastTop              : 0,\n                lastRowIndex         : rowsRange === RowsRange.visible ? client.rowManager.firstVisibleRow.dataIndex : 0\n            });\n            delete exportMeta.lastRowDataIndex;\n            if (!enableDirectRendering) {\n                await this.scrollRowIntoView(client, exportMeta.firstVisibleDataIndex, { block : 'start' });\n            }\n        }\n    }\n    //endregion\n    //region Preparation\n    async prepareComponent(config) {\n        await super.prepareComponent(config);\n        const\n            me              = this,\n            { exportMeta }  = me,\n            {\n                client,\n                headerTpl,\n                footerTpl,\n                alignRows,\n                rowsRange,\n                enableDirectRendering\n            }               = config,\n            paperFormat     = PaperFormat[config.paperFormat],\n            isPortrait      = config.orientation === Orientation.portrait,\n            paperWidth      = me.getPaperWidth(paperFormat, isPortrait),\n            paperHeight     = me.getPaperHeight(paperFormat, isPortrait),\n            pageWidth       = me.inchToPx(paperWidth),\n            pageHeight      = me.inchToPx(paperHeight),\n            onlyVisibleRows = rowsRange === RowsRange.visible,\n            horizontalPages = Math.ceil(exportMeta.totalWidth / pageWidth);\n        // To estimate amount of pages correctly we need to know height of the header/footer on every page\n        let contentHeight = pageHeight;\n        if (headerTpl) {\n            contentHeight -= me.measureElement(headerTpl({\n                totalWidth  : exportMeta.totalWidth,\n                totalPages  : -1,\n                currentPage : -1\n            }));\n        }\n        if (footerTpl) {\n            contentHeight -= me.measureElement(footerTpl({\n                totalWidth  : exportMeta.totalWidth,\n                totalPages  : -1,\n                currentPage : -1\n            }));\n        }\n        let totalHeight, verticalPages, totalRows = client.store.count;\n        if (onlyVisibleRows) {\n            totalRows = me.getVisibleRowsCount(client);\n            totalHeight = exportMeta.totalHeight + client.headerHeight + client.footerHeight + client.bodyHeight;\n        }\n        else {\n            totalHeight = exportMeta.totalHeight + client.headerHeight + client.footerHeight + client.scrollable.scrollHeight;\n        }\n        // alignRows config specifies if rows should be always fully visible. E.g. if row doesn't fit on the page, it goes\n        // to the top of the next page\n        if (alignRows && !onlyVisibleRows) {\n            // we need to estimate amount of vertical pages for case when we only put row on the page if it fits\n            // first we need to know how much rows would fit one page, keeping in mind first page also contains header\n            // This estimation is loose, because row height might differ much between pages\n            const\n                rowHeight       = client.rowManager.rowOffsetHeight,\n                rowsOnFirstPage = Math.floor((contentHeight - client.headerHeight) / rowHeight),\n                rowsPerPage     = Math.floor(contentHeight / rowHeight),\n                remainingRows   = totalRows - rowsOnFirstPage;\n            verticalPages = 1 + Math.ceil(remainingRows / rowsPerPage);\n        }\n        else {\n            verticalPages = Math.ceil(totalHeight / contentHeight);\n        }\n        Object.assign(exportMeta, {\n            paperWidth,\n            paperHeight,\n            pageWidth,\n            pageHeight,\n            horizontalPages,\n            verticalPages,\n            totalHeight,\n            contentHeight,\n            totalRows,\n            totalPages           : horizontalPages * verticalPages,\n            currentPage          : 0,\n            verticalPosition     : 0,\n            horizontalPosition   : 0,\n            currentPageTopMargin : 0,\n            lastTop              : 0,\n            lastRowIndex         : onlyVisibleRows ? client.rowManager.firstVisibleRow.dataIndex : 0\n        });\n        if (!enableDirectRendering) {\n            this.adjustRowBuffer(client);\n        }\n    }\n    async restoreComponent(config) {\n        await super.restoreComponent(config);\n        if (!config.enableDirectRendering) {\n            this.restoreRowBuffer(config.client);\n        }\n    }\n    //endregion\n    async collectRows(config) {\n        const\n            me             = this,\n            { exportMeta } = me,\n            {\n                client,\n                alignRows,\n                rowsRange\n            }              = config,\n            {\n                subGrids,\n                currentPageTopMargin,\n                verticalPosition,\n                contentHeight,\n                totalRows,\n                lastRowDataIndex\n            }              = exportMeta,\n            { rowManager } = client,\n            { rows }       = rowManager,\n            onlyVisible    = rowsRange === RowsRange.visible,\n            hasMergeCells  = client.hasActiveFeature('mergeCells');\n        let remainingHeight, index;\n        if (onlyVisible && lastRowDataIndex != null) {\n            if (lastRowDataIndex === rows[rows.length - 1].dataIndex) {\n                index = rows.length - 1;\n            }\n            else {\n                index = rows.findIndex(r => r.dataIndex === lastRowDataIndex);\n            }\n        }\n        else {\n            index = onlyVisible\n                ? rows.findIndex(r => r.bottom > Math.ceil(client.scrollable.y))\n                : rows.findIndex(r => r.bottom + currentPageTopMargin + client.headerHeight > 0);\n        }\n        const\n            firstRowIndex     = index,\n            // This is a portion of the row which is not visible, which means it shouldn't affect remaining height\n            // Don't calculate for the first page\n            overflowingHeight = (onlyVisible || verticalPosition === 0) ? 0 : rows[index].top + currentPageTopMargin + client.headerHeight;\n        // Calculate remaining height to fill with rows\n        // remainingHeight is height of the page content region to fill. When next row is exported, this heights gets\n        // reduced. Since top rows may be partially visible, it would lead to increasing error and eventually to incorrect\n        // exported rows for the page\n        remainingHeight = contentHeight - overflowingHeight;\n        // first exported page container header\n        if (verticalPosition === 0) {\n            remainingHeight -= client.headerHeight;\n        }\n        // data index of the last collected row\n        let lastDataIndex,\n            offset = 0;\n        while (remainingHeight > 0) {\n            const row = rows[index];\n            if (alignRows && remainingHeight < row.offsetHeight) {\n                offset = -remainingHeight;\n                remainingHeight = 0;\n                // If we skip a row save its bottom to meta data in order to align canvases height\n                // properly\n                me.exportMeta.lastExportedRowBottom = rows[index - 1].bottom;\n            }\n            else {\n                me.collectRow(row);\n                remainingHeight -= row.offsetHeight;\n                lastDataIndex = row.dataIndex;\n                // Last row is processed, still need to fill the view\n                if (++index === rows.length && remainingHeight > 0) {\n                    remainingHeight = 0;\n                }\n                else if (onlyVisible && (index - firstRowIndex) === totalRows) {\n                    remainingHeight = 0;\n                }\n            }\n        }\n        // Collect merged cells per subgrid\n        if (hasMergeCells) {\n            for (const subGridName in subGrids) {\n                const\n                    subGrid     = subGrids[subGridName],\n                    mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);\n                subGrid.mergedCellsHtml = [];\n                for (const mergedCell of mergedCells) {\n                    subGrid.mergedCellsHtml.push(mergedCell.outerHTML);\n                }\n            }\n        }\n        const lastRow = rows[index - 1];\n        if (lastRow) {\n            // Calculate exact grid height according to the last exported row\n            exportMeta.exactGridHeight = lastRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;\n            exportMeta.lastRowDataIndex = lastRow.dataIndex + 1;\n        }\n        await me.onRowsCollected(rows.slice(firstRowIndex, index), config);\n        // No scrolling required if we are only exporting currently visible rows\n        if (onlyVisible) {\n            exportMeta.exactGridHeight -= exportMeta.scrollableTopMargin = client.scrollable.y;\n        }\n        else {\n            // With variable row height row manager might relayout rows to fix position, moving them up or down.\n            const detacher = rowManager.ion({ offsetRows : ({ offset : value }) => offset += value });\n            await me.scrollRowIntoView(client, lastDataIndex + 1);\n            detacher();\n        }\n        return offset;\n    }\n    async renderRows(config) {\n        const\n            me              = this,\n            { exportMeta }  = me,\n            {\n                client,\n                alignRows,\n                rowsRange\n            }               = config,\n            {\n                currentPageTopMargin,\n                verticalPosition,\n                contentHeight,\n                totalRows,\n                lastRowIndex,\n                fakeRow\n            }               = exportMeta,\n            { store }       = client,\n            hasMergeCells   = client.hasActiveFeature('mergeCells'),\n            onlyVisibleRows = rowsRange === RowsRange.visible;\n        let index       = lastRowIndex,\n            { lastTop } = exportMeta,\n            remainingHeight;\n        const\n            firstRowIndex     = index,\n            // This is a portion of the row which is not visible, which means it shouldn't affect remaining height\n            // Don't calculate for the first page\n            overflowingHeight = (onlyVisibleRows || verticalPosition === 0) ? 0 : lastTop + currentPageTopMargin + client.headerHeight,\n            rows              = [];\n        // Calculate remaining height to fill with rows\n        // remainingHeight is height of the page content region to fill. When next row is exported, this heights gets\n        // reduced. Since top rows may be partially visible, it would lead to increasing error and eventually to incorrect\n        // exported rows for the page\n        remainingHeight = contentHeight - overflowingHeight;\n        // first exported page contains header\n        if (verticalPosition === 0) {\n            remainingHeight -= client.headerHeight;\n        }\n        // data index of the last collected row\n        let lastDataIndex, previousTop,\n            offset = 0;\n        while (remainingHeight > 0) {\n            fakeRow.render(index, store.getAt(index), true, false, true);\n            if (alignRows && remainingHeight < fakeRow.offsetHeight) {\n                offset = -remainingHeight;\n                remainingHeight = 0;\n                // If we skip a row save its bottom to meta data in order to align canvases height\n                // properly\n                me.exportMeta.lastExportedRowBottom = lastTop;\n            }\n            else {\n                previousTop = lastTop;\n                lastDataIndex = index;\n                lastTop = fakeRow.translate(lastTop);\n                remainingHeight -= fakeRow.offsetHeight;\n                me.collectRow(fakeRow);\n                // Push an object with data required to build merged cell\n                rows.push({\n                    top          : fakeRow.top,\n                    bottom       : fakeRow.bottom,\n                    offsetHeight : fakeRow.offsetHeight,\n                    dataIndex    : fakeRow.dataIndex\n                });\n                // Last row is processed, still need to fill the view\n                if (++index === store.count && remainingHeight > 0) {\n                    remainingHeight = 0;\n                }\n                else if (onlyVisibleRows && (index - firstRowIndex) === totalRows) {\n                    remainingHeight = 0;\n                }\n            }\n        }\n        if (hasMergeCells) {\n            me.renderMergedCells(config, firstRowIndex, index, rows);\n        }\n        // Store next to last row index and top position so we could proceed on the next page.\n        // In fact, when we take full control of row rendering we don't even need to do this. It is only required\n        // to be compatible with current exporters. When we get rid of scrolling, we can just start rendering rows\n        // on each page from 0 (adjusted by overflow of the previous row)\n        exportMeta.lastRowIndex = alignRows ? index : lastDataIndex;\n        exportMeta.lastTop = alignRows ? lastTop : previousTop;\n        if (fakeRow) {\n            // Calculate exact grid height according to the last exported row\n            exportMeta.exactGridHeight = fakeRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;\n        }\n        await me.onRowsCollected(rows, config);\n        return offset;\n    }\n    async buildPage(config) {\n        const\n            me             = this,\n            { exportMeta } = me,\n            {\n                client,\n                headerTpl,\n                footerTpl,\n                enableDirectRendering\n            }              = config,\n            {\n                totalWidth,\n                totalPages,\n                currentPage,\n                subGrids\n            }              = exportMeta;\n        // Rows are stored in shared state object, need to clean it before exporting next page\n        Object.values(subGrids).forEach(subGrid => subGrid.rows = []);\n        // With variable row height total height might change after scroll, update it\n        // to show content completely on the last page\n        if (config.rowsRange === RowsRange.all) {\n            exportMeta.totalHeight = client.height - client.bodyHeight + client.scrollable.scrollHeight - me.getVirtualScrollerHeight(client);\n        }\n        let header, footer;\n        // Measure header and footer height\n        if (headerTpl) {\n            header = me.prepareHTML(headerTpl({\n                totalWidth,\n                totalPages,\n                currentPage\n            }));\n        }\n        if (footerTpl) {\n            footer = me.prepareHTML(footerTpl({\n                totalWidth,\n                totalPages,\n                currentPage\n            }));\n        }\n        let offset;\n        if (enableDirectRendering) {\n            offset = await me.renderRows(config);\n        }\n        else {\n            offset = await me.collectRows(config);\n        }\n        const html = me.buildPageHtml(config);\n        return { html, header, footer, offset };\n    }\n    async onRowsCollected() {}\n    buildPageHtml() {\n        const\n            me           = this,\n            { subGrids } = me.exportMeta;\n        // Now when rows are collected, we need to add them to exported grid\n        let html = me.prepareExportElement();\n        Object.values(subGrids).forEach(({ placeHolder, rows, mergedCellsHtml }) => {\n            const placeHolderText = placeHolder.outerHTML;\n            let contentHtml = rows.reduce((result, row) => {\n                result += row[0];\n                return result;\n            }, '');\n            if (mergedCellsHtml?.length) {\n                contentHtml += `<div class=\"b-grid-merged-cells-container\">${mergedCellsHtml.join('')}</div>`;\n            }\n            html = html.replace(placeHolderText, contentHtml);\n        });\n        return html;\n    }\n    prepareExportElement() {\n        const\n            me = this,\n            { element, exportMeta } = me;\n        if (exportMeta.scrollableTopMargin) {\n            element.querySelector('.b-grid-vertical-scroller').style.marginTop = `-${exportMeta.scrollableTopMargin}px`;\n        }\n        return super.prepareExportElement();\n    }\n}\n// HACK: terser/obfuscator doesn't yet support async generators, when processing code it converts async generator to regular async\n// function.\nMultiPageExporter.prototype.pagesExtractor = async function * pagesExtractor(config) {\n    const\n        me = this,\n        {\n            exportMeta,\n            stylesheets\n        }  = me,\n        {\n            totalWidth,\n            totalPages,\n            paperWidth,\n            paperHeight,\n            realPaperWidth,\n            realPaperHeight,\n            contentHeight\n        }  = exportMeta,\n        isPrint = config.useBrowserPrint;\n    let currentPage;\n    while ((currentPage = exportMeta.currentPage) < totalPages) {\n        me.trigger('exportStep', { text : me.L(MultiPageExporter.exportingPageText, { currentPage, totalPages }), progress : Math.round(((currentPage + 1) / totalPages) * 90) });\n        const { html, header, footer, offset } = await me.buildPage(config);\n        // TotalHeight might change in case of variable row heights\n        // Move exported content in the visible frame\n        const styles = [\n            ...stylesheets,\n            `\n                <style>\n                    .b-page-wrap {\n                        width: ${paperWidth}in;\n                        height: ${paperHeight}in;\n                    }\n                    .b-page-${currentPage} #${config.client.id} {\n                        height: ${exportMeta.exactGridHeight}px !important;\n                        width: ${totalWidth}px !important;\n                    }\n                    .b-page-${currentPage} .b-export-body .b-export-viewport {\n                        transform: translate(${-paperWidth * exportMeta.horizontalPosition}in, ${exportMeta.currentPageTopMargin}px);\n                    }\n                </style>\n            `];\n        // when aligning rows, offset gets accumulated, so we need to take it into account\n        exportMeta.currentPageTopMargin -= contentHeight + offset;\n        await me.stateNextPage(config);\n        yield {\n            html : me.pageTpl({\n                html,\n                header,\n                footer,\n                styles,\n                paperWidth,\n                paperHeight,\n                realPaperWidth,\n                realPaperHeight,\n                currentPage,\n                isPrint\n            })\n        };\n    }\n};\nMultiPageExporter._$name = 'MultiPageExporter';", "import Exporter from './Exporter.js';\nimport { Orientation, PaperFormat, RowsRange } from '../Utils.js';\n/**\n * @module Grid/feature/export/exporter/MultiPageVerticalExporter\n */\n/**\n * A vertical multiple page exporter. Used by the {@link Grid.feature.export.PdfExport} feature to export to multiple\n * pages. Content will be scaled in a horizontal direction to fit the page.\n *\n * You do not need to use this class directly.\n *\n * ### Extending exporter\n *\n * ```javascript\n * class MyMultiPageVerticalExporter extends MultiPageVerticalExporter {\n *     // type is required for exporter\n *     static get type() {\n *         return 'mymultipageverticalexporter';\n *     }\n *\n *     get stylesheets() {\n *         const stylesheets = super.stylesheets;\n *\n *         stylesheets.forEach(styleNodeOrLinkTag => doSmth(styleNodeOrLinkTag))\n *\n *         return stylesheets;\n *     }\n * }\n *\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             // this export feature is configured with only one exporter\n *             exporters : [MyMultiPageVerticalExporter]\n *         }\n *     }\n * });\n *\n * // run export with the new exporter\n * grid.features.pdfExport.export({ exporter : 'mymultipageverticalexporter' });\n * ```\n *\n * @classtype multipagevertical\n * @extends Grid/feature/export/exporter/Exporter\n */\nexport default class MultiPageVerticalExporter extends Exporter {\n    static get $name() {\n        return 'MultiPageVerticalExporter';\n    }\n    static get type() {\n        return 'multipagevertical';\n    }\n    static get title() {\n        // In case locale is missing exporter is still distinguishable\n        return this.L('L{multipagevertical}');\n    }\n    static get exportingPageText() {\n        return 'L{exportingPage}';\n    }\n    //region State management\n    async stateNextPage({ client }) {\n        const\n            { exportMeta } = this,\n            {\n                totalRows,\n                processedRows,\n                totalPages\n            } = exportMeta;\n        ++exportMeta.currentPage;\n        ++exportMeta.verticalPosition;\n        // With variable row heights it is possible that initial pages estimation is wrong. If we're out but there are\n        // more rows to process - continue exporting\n        if (exportMeta.currentPage === totalPages && processedRows.size !== totalRows) {\n            ++exportMeta.totalPages;\n            ++exportMeta.verticalPages;\n        }\n    }\n    //endregion\n    estimateTotalPages(config) {\n        const\n            me             = this,\n            { exportMeta } = me,\n            {\n                client,\n                headerTpl,\n                footerTpl,\n                alignRows,\n                rowsRange,\n                repeatHeader,\n                enableDirectRendering\n            }              = config,\n            {\n                pageWidth,\n                pageHeight,\n                totalWidth\n            }              = exportMeta,\n            scale          = me.getScaleValue(pageWidth, totalWidth);\n        // To estimate amount of pages correctly we need to know height of the header/footer on every page\n        let\n            // bodyHeight does not always report correct value, read it from the DOM element instead, we don't care\n            // about forced reflow at this stage\n            totalHeight   = 0 - me.getVirtualScrollerHeight(client) + client.height - client.bodyElement.offsetHeight + client.scrollable.scrollHeight,\n            // We will be scaling content horizontally, need to adjust content height accordingly\n            contentHeight = pageHeight / scale,\n            totalRows     = client.store.count,\n            initialScroll = 0,\n            rowsHeight    = totalHeight,\n            verticalPages;\n        if (headerTpl) {\n            contentHeight -= me.measureElement(headerTpl({\n                totalWidth,\n                totalPages  : -1,\n                currentPage : -1\n            }));\n        }\n        if (footerTpl) {\n            contentHeight -= me.measureElement(footerTpl({\n                totalWidth,\n                totalPages  : -1,\n                currentPage : -1\n            }));\n        }\n        // If we are repeating header on every page we have smaller contentHeight\n        if (repeatHeader) {\n            contentHeight -= client.headerHeight + client.footerHeight;\n            totalHeight -= client.headerHeight + client.footerHeight;\n        }\n        if (rowsRange === RowsRange.visible) {\n            const\n                rowManager = client.rowManager,\n                firstRow = rowManager.firstVisibleRow,\n                lastRow  = rowManager.lastVisibleRow;\n            // With direct rendering we start rendering from 0, no need to adjust anything\n            if (!enableDirectRendering) {\n                initialScroll = firstRow.top;\n            }\n            totalRows = me.getVisibleRowsCount(client);\n            if (enableDirectRendering) {\n                totalHeight = client.headerHeight + client.footerHeight + lastRow.bottom - firstRow.top;\n                rowsHeight = lastRow.bottom - firstRow.top;\n            }\n            else {\n                rowsHeight = totalHeight = totalHeight - client.scrollable.scrollHeight + lastRow.bottom - firstRow.top;\n            }\n            exportMeta.lastRowIndex = firstRow.dataIndex;\n            exportMeta.finishRowIndex = lastRow.dataIndex;\n        }\n        else {\n            exportMeta.finishRowIndex = client.store.count - 1;\n        }\n        // alignRows config specifies if rows should be always fully visible. E.g. if row doesn't fit on the page, it goes\n        // to the top of the next page\n        if (alignRows && !repeatHeader && rowsRange !== RowsRange.visible) {\n            // we need to estimate amount of vertical pages for case when we only put row on the page if it fits\n            // first we need to know how much rows would fit one page, keeping in mind first page also contains header\n            // This estimation is loose, because row height might differ much between pages\n            const\n                rowHeight       = client.rowManager.rowOffsetHeight,\n                rowsOnFirstPage = Math.floor((contentHeight - client.headerHeight) / rowHeight),\n                rowsPerPage     = Math.floor(contentHeight / rowHeight),\n                remainingRows   = totalRows - rowsOnFirstPage;\n            verticalPages = 1 + Math.ceil(remainingRows / rowsPerPage);\n        }\n        else {\n            verticalPages = Math.ceil(rowsHeight / contentHeight);\n        }\n        Object.assign(exportMeta, {\n            scale,\n            contentHeight,\n            totalRows,\n            totalHeight,\n            verticalPages,\n            initialScroll,\n            horizontalPages : 1,\n            totalPages      : verticalPages\n        });\n    }\n    async prepareComponent(config) {\n        await super.prepareComponent(config);\n        const\n            me              = this,\n            { exportMeta }  = me,\n            { client }      = config,\n            paperFormat     = PaperFormat[config.paperFormat],\n            isPortrait      = config.orientation === Orientation.portrait,\n            paperWidth      = me.getPaperWidth(paperFormat, isPortrait),\n            paperHeight     = me.getPaperHeight(paperFormat, isPortrait),\n            pageWidth       = me.inchToPx(paperWidth),\n            pageHeight      = me.inchToPx(paperHeight),\n            horizontalPages = 1;\n        Object.assign(exportMeta, {\n            paperWidth,\n            paperHeight,\n            realPaperWidth       : me.getPaperWidth(paperFormat, isPortrait),\n            realPaperHeight      : me.getPaperHeight(paperFormat, isPortrait),\n            pageWidth,\n            pageHeight,\n            horizontalPages,\n            currentPage          : 0,\n            verticalPosition     : 0,\n            horizontalPosition   : 0,\n            currentPageTopMargin : 0,\n            lastTop              : 0,\n            lastRowIndex         : 0,\n            processedRows        : new Set()\n        });\n        me.estimateTotalPages(config);\n        if (!config.enableDirectRendering) {\n            me.adjustRowBuffer(client);\n        }\n    }\n    async restoreComponent(config) {\n        await super.restoreComponent(config);\n        if (!config.enableDirectRendering) {\n            this.restoreRowBuffer(config.client);\n        }\n    }\n    async collectRows(config) {\n        const\n            me                 = this,\n            { exportMeta }     = me,\n            {\n                client,\n                alignRows,\n                repeatHeader\n            }                  = config,\n            {\n                subGrids,\n                currentPageTopMargin,\n                verticalPosition,\n                totalRows,\n                contentHeight\n            }                  = exportMeta,\n            // If we are repeating header we've already took header height into account when setting content height\n            clientHeaderHeight = repeatHeader ? 0 : client.headerHeight,\n            { rowManager }     = client,\n            { rows }           = rowManager,\n            onlyVisibleRows    = config.rowsRange === RowsRange.visible,\n            hasMergeCells      = client.hasActiveFeature('mergeCells');\n        let index = onlyVisibleRows\n                ? rows.findIndex(r => r.bottom > client.scrollable.y)\n                : rows.findIndex(r => r.bottom + currentPageTopMargin + clientHeaderHeight > 0),\n            remainingHeight;\n        const\n            firstRowIndex     = index,\n            // This is a portion of the row which is not visible, which means it shouldn't affect remaining height\n            // Don't calculate for the first page\n            overflowingHeight = verticalPosition === 0 ? 0 : rows[index].top + currentPageTopMargin + clientHeaderHeight;\n        // Calculate remaining height to fill with rows\n        // remainingHeight is height of the page content region to fill. When next row is exported, this heights gets\n        // reduced. Since top rows may be partially visible, it would lead to increasing error and eventually to incorrect\n        // exported rows for the page\n        remainingHeight = contentHeight - overflowingHeight;\n        // first exported page container header\n        if (verticalPosition === 0) {\n            remainingHeight -= clientHeaderHeight;\n        }\n        // data index of the last collected row\n        let lastDataIndex,\n            offset = 0;\n        while (remainingHeight > 0) {\n            const row = rows[index];\n            if (alignRows && remainingHeight < row.offsetHeight) {\n                offset = -remainingHeight;\n                remainingHeight = 0;\n            }\n            else {\n                me.collectRow(row);\n                remainingHeight -= row.offsetHeight;\n                // only mark row as processed if it fitted without overflow\n                if (remainingHeight > 0) {\n                    // We cannot use simple counter here because some rows appear on 2 pages. Need to track unique identifier\n                    exportMeta.processedRows.add(row.dataIndex);\n                }\n                lastDataIndex = row.dataIndex;\n                // Last row is processed, still need to fill the view\n                if (++index === rows.length && remainingHeight > 0) {\n                    remainingHeight = 0;\n                }\n                else if (onlyVisibleRows && (index - firstRowIndex) === totalRows) {\n                    remainingHeight = 0;\n                }\n            }\n        }\n        // Collect merged cells per subgrid\n        if (hasMergeCells) {\n            for (const subGridName in subGrids) {\n                const\n                    subGrid     = subGrids[subGridName],\n                    mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);\n                subGrid.mergedCellsHtml = [];\n                for (const mergedCell of mergedCells) {\n                    subGrid.mergedCellsHtml.push(mergedCell.outerHTML);\n                }\n            }\n        }\n        const lastRow = rows[index - 1];\n        if (lastRow) {\n            // Calculate exact grid height according to the last exported row\n            exportMeta.exactGridHeight = lastRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;\n        }\n        await me.onRowsCollected(rows.slice(firstRowIndex, index), config);\n        // No scrolling required if we are only exporting currently visible rows\n        if (onlyVisibleRows) {\n            exportMeta.scrollableTopMargin = client.scrollable.y;\n        }\n        else {\n            // With variable row height row manager might relayout rows to fix position, moving them up or down.\n            const detacher = rowManager.ion({ offsetRows : ({ offset : value }) => offset += value });\n            await me.scrollRowIntoView(client, lastDataIndex + 1);\n            detacher();\n        }\n        return offset;\n    }\n    async renderRows(config) {\n        const\n            me                    = this,\n            { exportMeta }        = me,\n            {\n                client,\n                alignRows,\n                repeatHeader\n            }                     = config,\n            {\n                currentPageTopMargin,\n                verticalPosition,\n                totalRows,\n                contentHeight,\n                lastRowIndex,\n                finishRowIndex,\n                fakeRow\n            }                     = exportMeta,\n            // If we are repeating header we've already took header height into account when setting content height\n            clientHeaderHeight    = repeatHeader ? 0 : client.headerHeight,\n            { store }             = client,\n            hasMergeCells         = client.hasActiveFeature('mergeCells'),\n            onlyVisibleRows       = config.rowsRange === RowsRange.visible;\n        let index       = lastRowIndex,\n            { lastTop } = exportMeta,\n            remainingHeight;\n        const\n            firstRowIndex     = index,\n            // This is a portion of the row which is not visible, which means it shouldn't affect remaining height\n            // Don't calculate for the first page\n            overflowingHeight = verticalPosition === 0 ? 0 : lastTop + currentPageTopMargin + clientHeaderHeight,\n            rows              = [];\n        // Calculate remaining height to fill with rows\n        // remainingHeight is height of the page content region to fill. When next row is exported, this heights gets\n        // reduced. Since top rows may be partially visible, it would lead to increasing error and eventually to incorrect\n        // exported rows for the page\n        remainingHeight = contentHeight - overflowingHeight;\n        // first exported page container header\n        if (verticalPosition === 0) {\n            remainingHeight -= clientHeaderHeight;\n        }\n        // data index of the last collected row\n        let lastDataIndex,\n            nextPageTop,\n            offset = 0;\n        while (remainingHeight > 0) {\n            fakeRow.render(index, store.getAt(index), true, false, true);\n            if (alignRows && remainingHeight < fakeRow.offsetHeight) {\n                offset = -remainingHeight;\n                remainingHeight = 0;\n            }\n            else {\n                nextPageTop = lastTop;\n                lastDataIndex = index;\n                lastTop = fakeRow.translate(lastTop);\n                remainingHeight -= fakeRow.offsetHeight;\n                me.collectRow(fakeRow);\n                // Push an object with data required to build merged cell\n                rows.push({\n                    top          : fakeRow.top,\n                    bottom       : fakeRow.bottom,\n                    offsetHeight : fakeRow.offsetHeight,\n                    dataIndex    : fakeRow.dataIndex\n                });\n                // only mark row as processed if it fitted without overflow\n                if (remainingHeight > 0) {\n                    // We cannot use simple counter here because some rows appear on 2 pages. Need to track unique identifier\n                    exportMeta.processedRows.add(index);\n                }\n                // Last row is processed, still need to fill the view\n                if (index === finishRowIndex) {\n                    remainingHeight = 0;\n                }\n                else if ((++index - firstRowIndex) === totalRows && onlyVisibleRows) {\n                    remainingHeight = 0;\n                }\n            }\n        }\n        if (hasMergeCells) {\n            me.renderMergedCells(config, firstRowIndex, index, rows);\n        }\n        // Store next to last row index and top position so we could proceed on the next page.\n        // In fact, when we take full control of row rendering we don't even need to do this. It is only required\n        // to be compatible with current exporters. When we get rid of scrolling, we can just start rendering rows\n        // on each page from 0 (adjusted by overflow of the previous row)\n        exportMeta.lastRowIndex = lastDataIndex;\n        exportMeta.lastTop = nextPageTop;\n        if (fakeRow) {\n            // Calculate exact grid height according to the last exported row to constrain column lines to the last\n            // row\n            exportMeta.exactGridHeight = fakeRow.bottom + client.footerContainer.offsetHeight + client.headerContainer.offsetHeight;\n        }\n        await me.onRowsCollected(rows, config);\n        return offset;\n    }\n    async buildPage(config) {\n        const\n            me             = this,\n            { exportMeta } = me,\n            {\n                client,\n                headerTpl,\n                footerTpl,\n                enableDirectRendering\n            }              = config,\n            {\n                totalWidth,\n                totalPages,\n                currentPage,\n                subGrids\n            }              = exportMeta;\n        // Rows are stored in shared state object, need to clean it before exporting next page\n        Object.values(subGrids).forEach(subGrid => subGrid.rows = []);\n        // With variable row height total height might change after scroll, update it\n        // to show content completely on the last page\n        if (config.rowsRange === RowsRange.all) {\n            exportMeta.totalHeight = client.headerHeight + client.footerHeight + client.scrollable.scrollHeight;\n            if (!enableDirectRendering) {\n                exportMeta.totalHeight -= me.getVirtualScrollerHeight(client);\n            }\n        }\n        let header, footer, offset;\n        // Measure header and footer height\n        if (headerTpl) {\n            header = me.prepareHTML(headerTpl({\n                totalWidth,\n                totalPages,\n                currentPage\n            }));\n        }\n        if (footerTpl) {\n            footer = me.prepareHTML(footerTpl({\n                totalWidth,\n                totalPages,\n                currentPage\n            }));\n        }\n        if (enableDirectRendering) {\n            offset = await me.renderRows(config);\n        }\n        else {\n            offset = await me.collectRows(config);\n        }\n        const html = me.buildPageHtml(config);\n        return { html, header, footer, offset };\n    }\n    async onRowsCollected() {}\n    buildPageHtml() {\n        const\n            me           = this,\n            { subGrids } = me.exportMeta;\n        // Now when rows are collected, we need to add them to exported grid\n        let html = me.prepareExportElement();\n        Object.values(subGrids).forEach(({ placeHolder, rows, mergedCellsHtml }) => {\n            const placeHolderText = placeHolder.outerHTML;\n            let contentHtml = rows.reduce((result, row) => {\n                result += row[0];\n                return result;\n            }, '');\n            if (mergedCellsHtml?.length) {\n                contentHtml += `<div class=\"b-grid-merged-cells-container\">${mergedCellsHtml.join('')}</div>`;\n            }\n            html = html.replace(placeHolderText, contentHtml);\n        });\n        return html;\n    }\n}\n// HACK: terser/obfuscator doesn't yet support async generators, when processing code it converts async generator to regular async\n// function.\nMultiPageVerticalExporter.prototype.pagesExtractor = async function * pagesExtractor(config) {\n    const\n        me = this,\n        {\n            exportMeta,\n            stylesheets\n        }  = me,\n        {\n            totalWidth,\n            paperWidth,\n            paperHeight,\n            realPaperWidth,\n            realPaperHeight,\n            contentHeight,\n            scale,\n            initialScroll\n        }  = exportMeta,\n        isPrint = config.useBrowserPrint;\n    let\n        { totalPages } = exportMeta,\n        currentPage, style;\n    while ((currentPage = exportMeta.currentPage) < totalPages) {\n        me.trigger('exportStep', {\n            text     : me.L(MultiPageVerticalExporter.exportingPageText, { currentPage, totalPages }),\n            progress : Math.round(((currentPage + 1) / totalPages) * 90)\n        });\n        const { html, header, footer, offset } = await me.buildPage(config);\n        style = `\n            ${\n                isPrint\n                    ? `\n                        .b-page-wrap {\n                            width: ${realPaperWidth}in;\n                            height: ${realPaperHeight}in;\n                        }\n                        .b-print:not(.b-firefox) .b-export-content {\n                            zoom: ${scale};\n                            height: 100%;\n                        }\n                        .b-print.b-firefox .b-export-content {\n                            transform: scale(${scale});\n                            transform-origin: top left;\n                            height: ${100 / scale}%;\n                            width: ${100 / scale}%;\n                        }\n                    `\n                    : `\n                        .b-export .b-page-${currentPage}.b-export-content {\n                            transform: scale(${scale});\n                            transform-origin: top left;\n                            height: ${100 / scale}%;\n                            width: ${100 / scale}%;\n                        }\n                    `\n            }\n        `;\n        if (config.repeatHeader) {\n            const gridHeight = exportMeta.exactGridHeight ? `${exportMeta.exactGridHeight + exportMeta.currentPageTopMargin}px` : '100%';\n            style = `\n                ${style}\n                .b-page-${currentPage} #${config.client.id} {\n                    height: ${gridHeight} !important;\n                    width: ${totalWidth}px !important;\n                }\n                .b-export-body {\n                    height: 100%;\n                    display: flex;\n                }\n                .b-export-viewport {\n                    height: 100%;\n                }\n                .b-page-${currentPage} .b-grid-vertical-scroller {\n                    margin-top: ${exportMeta.currentPageTopMargin - initialScroll}px;\n                }\n            `;\n        }\n        else {\n            const gridHeight = exportMeta.exactGridHeight || (contentHeight - exportMeta.currentPageTopMargin);\n            style = `\n                ${style}\n                .b-page-${currentPage} #${config.client.id} {\n                    height: ${gridHeight}px !important;\n                    width: ${totalWidth}px !important;\n                }\n                .b-export-body {\n                    overflow: hidden;\n                }\n                .b-page-${currentPage} .b-export-body .b-export-viewport {\n                    margin-top: ${exportMeta.currentPageTopMargin}px;\n                }\n                .b-page-${currentPage} .b-grid-vertical-scroller {\n                    margin-top: -${initialScroll}px;\n                }\n            `;\n        }\n        // TotalHeight might change in case of variable row heights\n        // Move exported content in the visible frame\n        const styles = [\n            ...stylesheets,\n            `<style>${style}</style>`\n        ];\n        // when aligning rows, offset gets accumulated, so we need to take it into account\n        exportMeta.currentPageTopMargin -= contentHeight + offset;\n        await me.stateNextPage(config);\n        ({ totalPages } = exportMeta);\n        yield {\n            html : me.pageTpl({\n                html,\n                header,\n                footer,\n                styles,\n                paperWidth,\n                paperHeight,\n                realPaperWidth,\n                realPaperHeight,\n                currentPage,\n                isPrint\n            })\n        };\n    }\n};\nMultiPageVerticalExporter._$name = 'MultiPageVerticalExporter';", "import Exporter from './Exporter.js';\nimport { Orientation, PaperFormat, RowsRange } from '../Utils.js';\n/**\n * @module Grid/feature/export/exporter/SinglePageExporter\n */\n/**\n * A single page exporter. Used by the {@link Grid.feature.export.PdfExport} feature to export to single page. Content\n * will be scaled in both directions to fit the page.\n *\n * You do not need to use this class directly.\n *\n * ### Extending exporter\n *\n * ```javascript\n * class MySinglePageExporter extends SinglePageExporter {\n *     // type is required for exporter\n *     static get type() {\n *         return 'mysinglepageexporter';\n *     }\n *\n *     get stylesheets() {\n *         const stylesheets = super.stylesheets;\n *\n *         stylesheets.forEach(styleNodeOrLinkTag => doSmth(styleNodeOrLinkTag))\n *\n *         return stylesheets;\n *     }\n * }\n *\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             // this export feature is configured with only one exporter\n *             exporters : [MySinglePageExporter]\n *         }\n *     }\n * });\n *\n * // run export with the new exporter\n * grid.features.pdfExport.export({ exporter : 'mysinglepageexporter' });\n * ```\n *\n * @classtype singlepage\n * @extends Grid/feature/export/exporter/Exporter\n */\nexport default class SinglePageExporter extends Exporter {\n    static get $name() {\n        return 'SinglePageExporter';\n    }\n    static get type() {\n        return 'singlepage';\n    }\n    static get title() {\n        // In case locale is missing exporter is still distinguishable\n        return this.localize('L{singlepage}');\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * Set to true to center content horizontally on the page\n             * @config {Boolean}\n             */\n            centerContentHorizontally : false\n        };\n    }\n    async prepareComponent(config) {\n        await super.prepareComponent(config);\n        Object.assign(this.exportMeta, {\n            verticalPages      : 1,\n            horizontalPages    : 1,\n            totalPages         : 1,\n            currentPage        : 0,\n            verticalPosition   : 0,\n            horizontalPosition : 0\n        });\n    }\n    async onRowsCollected() {}\n    positionRows(rows, config) {\n        if (config.enableDirectRendering) {\n            return rows.map(r => r[0]);\n        }\n        else {\n            let currentTop = 0;\n            // In case of variable row height row vertical position is not guaranteed to increase\n            // monotonously. Position row manually instead\n            return rows.map(([html, , height]) => {\n                const result = html.replace(/translate\\(\\d+px, \\d+px\\)/, `translate(0px, ${currentTop}px)`);\n                currentTop += height;\n                return result;\n            });\n        }\n    }\n    async collectRows(config) {\n        const\n            me                    = this,\n            { client }            = config,\n            { rowManager, store } = client,\n            hasMergeCells         = client.hasActiveFeature('mergeCells'),\n            { subGrids }          = me.exportMeta,\n            totalRows             = config.rowsRange === RowsRange.visible && store.count\n                // visibleRowCount is a projection of how much rows will fit the view, which should be\n                // maximum amount of exported rows. and there can be less\n                ? me.getVisibleRowsCount(client)\n                : store.count;\n        let { totalHeight } = me.exportMeta,\n            processedRows   = 0,\n            lastDataIndex   = -1;\n        if (rowManager.rows.length > 0) {\n            if (config.rowsRange === RowsRange.visible) {\n                lastDataIndex = rowManager.firstVisibleRow.dataIndex - 1;\n            }\n            if (hasMergeCells) {\n                for (const subGrid of Object.values(subGrids)) {\n                    subGrid.mergedCellsHtml = [];\n                }\n            }\n            // Collecting rows\n            while (processedRows < totalRows) {\n                const\n                    rows    = rowManager.rows,\n                    lastRow = rows[rows.length - 1],\n                    lastProcessedRowIndex = processedRows;\n                rows.forEach(row => {\n                    // When we are scrolling rows will be duplicated even with disabled buffers (e.g. when we are trying to\n                    // scroll last record into view). So we store last processed row dataIndex (which is always growing\n                    // sequence) and filter all rows with lower/same dataIndex\n                    if (row.dataIndex > lastDataIndex && processedRows < totalRows) {\n                        ++processedRows;\n                        totalHeight += row.offsetHeight;\n                        me.collectRow(row);\n                    }\n                });\n                // Collect merged cells per subgrid\n                if (hasMergeCells) {\n                    for (const subGridName in subGrids) {\n                        const\n                            subGrid     = subGrids[subGridName],\n                            mergedCells = client.subGrids[subGridName].element.querySelectorAll(`.b-grid-merged-cells`);\n                        for (const mergedCell of mergedCells) {\n                            subGrid.mergedCellsHtml.push(mergedCell.outerHTML);\n                        }\n                    }\n                }\n                // Calculate new rows processed in this iteration e.g. to collect events\n                const\n                    firstNewRowIndex = rows.findIndex(r => r.dataIndex === lastDataIndex + 1),\n                    lastNewRowIndex  = firstNewRowIndex + (processedRows - lastProcessedRowIndex);\n                await me.onRowsCollected(rows.slice(firstNewRowIndex, lastNewRowIndex), config);\n                if (processedRows < totalRows) {\n                    lastDataIndex = lastRow.dataIndex;\n                    await me.scrollRowIntoView(client, lastDataIndex + 1);\n                }\n            }\n        }\n        return totalHeight;\n    }\n    async renderRows(config) {\n        const\n            me                    = this,\n            { client, rowsRange } = config,\n            { rowManager, store } = client,\n            hasMergeCells         = client.hasActiveFeature('mergeCells'),\n            onlyVisibleRows       = rowsRange === RowsRange.visible;\n        let { totalHeight } = me.exportMeta;\n        if (store.count) {\n            const\n                { fakeRow }         = me.exportMeta,\n                { firstVisibleRow } = rowManager,\n                fromIndex           = onlyVisibleRows ? firstVisibleRow.dataIndex : 0,\n                toIndex             = onlyVisibleRows ? rowManager.lastVisibleRow.dataIndex : store.count - 1,\n                rows                = [];\n            let top = 0;\n            // Fake row might not have cells if there are no columns\n            if (fakeRow.cells.length) {\n                for (let i = fromIndex; i <= toIndex; i++) {\n                    fakeRow.render(i, store.getAt(i), true, false, true);\n                    top = fakeRow.translate(top);\n                    me.collectRow(fakeRow);\n                    // Push an object with data required to build merged cell\n                    rows.push({\n                        top          : fakeRow.top,\n                        bottom       : fakeRow.bottom,\n                        offsetHeight : fakeRow.offsetHeight,\n                        dataIndex    : fakeRow.dataIndex\n                    });\n                }\n                await me.onRowsCollected(rows, config);\n            }\n            totalHeight += top;\n            if (hasMergeCells) {\n                me.renderMergedCells(config, fromIndex, toIndex, rows);\n            }\n        }\n        return totalHeight;\n    }\n    buildPageHtml(config) {\n        const\n            me           = this,\n            { subGrids } = me.exportMeta;\n        // Now when rows are collected, we need to add them to exported grid\n        let html = me.prepareExportElement();\n        Object.values(subGrids).forEach(({ placeHolder, rows, mergedCellsHtml }) => {\n            const placeHolderText = placeHolder.outerHTML;\n            let contentHtml =  me.positionRows(rows, config).join('');\n            if (mergedCellsHtml?.length) {\n                contentHtml += `<div class=\"b-grid-merged-cells-container\">${mergedCellsHtml.join('')}</div>`;\n            }\n            html = html.replace(placeHolderText, contentHtml);\n        });\n        return html;\n    }\n}\n// HACK: terser/obfuscator doesn't yet support async generators, when processing code it converts async generator to regular async\n// function.\nSinglePageExporter.prototype.pagesExtractor = async function * pagesExtractor(config) {\n    // When we prepared grid we stretched it horizontally, now we need to gather all rows\n    // There are two ways:\n    // 1. set component height to scrollable.scrollHeight value to render all rows at once (maybe a bit more complex\n    // if rows have variable height)\n    // 2. iterate over rows, scrolling new portion into view once in a while\n    // #1 sounds simpler, but that might require too much rendering, let's scroll rows instead\n    const\n        me             = this,\n        { client }     = config,\n        { totalWidth } = me.exportMeta,\n        styles         = me.stylesheets,\n        portrait       = config.orientation === Orientation.portrait,\n        paperFormat    = PaperFormat[config.paperFormat],\n        isPrint        = config.useBrowserPrint,\n        paperWidth     = me.getPaperWidth(paperFormat, portrait),\n        paperHeight    = me.getPaperHeight(paperFormat, portrait),\n        realPaperWidth = me.getPaperWidth(paperFormat, portrait),\n        realPaperHeight = me.getPaperHeight(paperFormat, portrait);\n    let totalHeight, header, footer;\n    if (config.enableDirectRendering) {\n        totalHeight = await me.renderRows(config);\n        totalHeight += client.headerHeight + client.footerHeight;\n    }\n    else {\n        totalHeight = await me.collectRows(config);\n        totalHeight += client.height - client.bodyHeight;\n    }\n    const html = me.buildPageHtml(config);\n    const totalClientHeight = totalHeight;\n    // Measure header and footer height\n    if (config.headerTpl) {\n        header = me.prepareHTML(config.headerTpl({ totalWidth }));\n        const height = me.measureElement(header);\n        totalHeight += height;\n    }\n    if (config.footerTpl) {\n        footer = me.prepareHTML(config.footerTpl({ totalWidth }));\n        const height = me.measureElement(footer);\n        totalHeight += height;\n    }\n    const\n        widthScale  = Math.min(1, me.getScaleValue(me.inchToPx(paperWidth), totalWidth)),\n        heightScale = Math.min(1, me.getScaleValue(me.inchToPx(paperHeight), totalHeight)),\n        scale       = Math.min(widthScale, heightScale);\n    // Now add style to stretch grid vertically\n    styles.push(\n        `<style>\n                #${client.id} {\n                    height: ${totalClientHeight}px !important;\n                    width: ${totalWidth}px !important;\n                }\n                ${\n                    isPrint\n                        ? `\n                            html, body {\n                                overflow: hidden;\n                            }\n                            .b-page-wrap {\n                                width: ${realPaperWidth}in;\n                                height: ${realPaperHeight}in;\n                            }\n                            .b-print:not(.b-firefox) .b-export-content {\n                                zoom: ${scale};\n                                height: 100%;\n                            }\n                            .b-print.b-firefox .b-export-content {\n                                transform: scale(${scale}) ${me.centerContentHorizontally ? 'translateX(-50%)' : ''};\n                                transform-origin: top left;\n                                height: ${scale === 1 ? 'inherit' : 'auto !important'};\n                            }\n                            .b-export-content {\n                                ${me.centerContentHorizontally ? 'left: 50%;' : ''}\n                            }\n                        `\n                        : `\n                            .b-export-content {\n                                ${me.centerContentHorizontally ? 'left: 50%;' : ''}\n                                transform: scale(${scale}) ${me.centerContentHorizontally ? 'translateX(-50%)' : ''};\n                                transform-origin: top left;\n                                height: ${scale === 1 ? 'inherit' : 'auto !important'};\n                            }\n                        `\n                }\n            </style>`\n    );\n    // This is a single page exporter so we only yield one page\n    yield {\n        html : me.pageTpl({\n            html,\n            header,\n            footer,\n            styles,\n            paperWidth,\n            paperHeight,\n            realPaperHeight,\n            realPaperWidth,\n            currentPage : 0,\n            isPrint     : config.useBrowserPrint\n        })\n    };\n};\nSinglePageExporter._$name = 'SinglePageExporter';", "import AjaxHelper from '../../../Core/helper/AjaxHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\nimport InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport MultiPageExporter from './exporter/MultiPageExporter.js';\nimport MultiPageVerticalExporter from './exporter/MultiPageVerticalExporter.js';\nimport SinglePageExporter from './exporter/SinglePageExporter.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport ExportDialog from '../../view/export/ExportDialog.js';\nimport GridFeatureManager from '../GridFeatureManager.js';\nimport Toast from '../../../Core/widget/Toast.js';\nimport { FileMIMEType } from './Utils.js';\n/**\n * @module Grid/feature/export/PdfExport\n */\n/**\n * Generates PDF/PNG files from the Grid component.\n *\n * **NOTE:** Server side is required to make export work!\n *\n * Check out PDF Export Server documentation and installation steps [here](https://github.com/bryntum/pdf-export-server#pdf-export-server)\n *\n * When your server is up and running, it listens to requests. The Export feature sends a request to the specified URL\n * with the HTML fragments. The server generates a PDF (or PNG) file and returns a download link (or binary, depending\n * on {@link #config-sendAsBinary} config). Then the Export feature opens the link in a new tab and the file is\n * automatically downloaded by your browser. This is configurable, see {@link #config-openAfterExport} config.\n *\n * The {@link #config-exportServer} URL must be configured. The URL can be localhost if you start the server locally,\n * or your remote server address.\n *\n * ## Usage\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             exportServer : 'http://localhost:8080' // Required\n *         }\n *     }\n * })\n *\n * // Opens popup allowing to customize export settings\n * grid.features.pdfExport.showExportDialog();\n *\n * // Simple export\n * grid.features.pdfExport.export({\n *     columns : grid.columns.map(c => c.id)\n * }).then(result => {\n *     // Response instance and response content in JSON\n *     let { response } = result;\n * });\n * ```\n *\n * ## Exporters\n *\n * There are three exporters available by default: `singlepage`, `multipage` and `multipagevertical`:\n *  * `singlepage` -  generates single page with content scaled to fit the provided {@link #config-paperFormat}\n *  * `multipage` - generates as many pages as required to fit all requested content, unscaled\n *  * `multipagevertical` - a combination of two above: it scales content horizontally to fit into page width and then\n *  puts overflowing content on vertical pages. Like a scroll.\n *\n * ## Loading resources\n *\n * If you face a problem with loading resources when exporting, the cause might be that the application and the export server are hosted on different servers.\n * This is due to [Cross-Origin Resource Sharing](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) (CORS). There are 2 options how to handle this:\n * - Allow cross-origin requests from the server where your export is hosted to the server where your application is hosted;\n * - Copy all resources keeping the folder hierarchy from the server where your application is hosted to the server where your export is hosted\n * and setup paths using {@link #config-translateURLsToAbsolute} config and configure the export server to give access to the path:\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         pdfExport : {\n *             exportServer : 'http://localhost:8080',\n *             // '/resources' is hardcoded in WebServer implementation\n *             translateURLsToAbsolute : 'http://localhost:8080/resources'\n *         }\n *     }\n * })\n * ```\n *\n * ```javascript\n * // Following path would be served by this address: http://localhost:8080/resources/\n * node ./src/server.js -h 8080 -r web/application/styles\n * ```\n *\n * where `web/application/styles` is a physical root location of the copied resources, for example:\n *\n * <img src=\"Grid/export-server-resources.png\" style=\"max-width : 500px\" alt=\"Export server structure with copied resources\" />\n *\n * This feature is **disabled** by default.\n * For info on enabling it, see {@link Grid/view/mixin/GridFeatures}.\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @demo Grid/export\n * @classtype pdfExport\n * @feature\n */\nexport default class PdfExport extends InstancePlugin {\n    static get $name() {\n        return 'PdfExport';\n    }\n    static get configurable() {\n        return {\n            dialogClass  : ExportDialog,\n            /**\n             * URL of the print server.\n             * @config {String}\n             */\n            exportServer : undefined,\n            /**\n             * Returns the instantiated export dialog widget as configured by {@link #config-exportDialog}\n             * @member {Grid.view.export.ExportDialog} exportDialog\n             */\n            /**\n             * A config object to apply to the {@link Grid.view.export.ExportDialog} widget.\n             * @config {ExportDialogConfig}\n             */\n            exportDialog : {\n                value : true,\n                $config : ['lazy']\n            },\n            /**\n             * Name of the exported file.\n             * @config {String}\n             * @category Export file config\n             */\n            fileName : null,\n            /**\n             * Format of the exported file, either `pdf` or `png`.\n             * @config {'pdf'|'png'}\n             * @default\n             * @category Export file config\n             */\n            fileFormat : 'pdf',\n            /**\n             * Export server will navigate to this url first and then will change page content to whatever client sent.\n             * This option is useful with react dev server, which uses a strict CORS policy.\n             * @config {String}\n             */\n            clientURL : null,\n            /**\n             * Export paper format. Available options are A1...A5, Legal, Letter.\n             * @config {'A1'|'A2'|'A3'|'A4'|'A5'|'Legal'|'Letter'}\n             * @default\n             * @category Export file config\n             */\n            paperFormat : 'A4',\n            /**\n             * Orientation. Options are `portrait` and `landscape`.\n             * @config {'portrait'|'landscape'}\n             * @default\n             * @category Export file config\n             */\n            orientation : 'portrait',\n            /**\n             * Specifies which rows to export. `all` for complete set of rows, `visible` for only rows currently visible.\n             * @config {'all'|'visible'}\n             * @category Export file config\n             * @default\n             */\n            rowsRange : 'all',\n            /**\n             * Set to true to align row top to the page top on every exported page. Only applied to multipage export.\n             * @config {Boolean}\n             * @default\n             */\n            alignRows : false,\n            /**\n             * Set to true to show column headers on every page. This will also set {@link #config-alignRows} to true.\n             * Only applies to MultiPageVertical exporter.\n             * @config {Boolean}\n             * @default\n             */\n            repeatHeader : false,\n            /**\n             * By default, subGrid width is changed to fit all exported columns. To keep certain subGrid size specify it\n             * in the following form:\n             * ```javascript\n             * keepRegionSizes : {\n             *     locked : true\n             * }\n             * ```\n             * @config {Object<String,Boolean>}\n             * @default\n             */\n            keepRegionSizes : null,\n            /**\n             * When exporting large views (hundreds of pages) stringified HTML may exceed browser or server request\n             * length limit. This config allows to specify how many pages to send to server in one request.\n             * @config {Number}\n             * @default\n             * @private\n             */\n            pagesPerRequest : 0,\n            /**\n             * Config for exporter.\n             * @config {Object}\n             * @private\n             */\n            exporterConfig : null,\n            /**\n             * Type of the exporter to use. Should be one of the configured {@link #config-exporters}\n             * @config {'singlepage'|'multipage'|'multipagevertical'|String}\n             * @default\n             */\n            exporterType : 'singlepage',\n            /**\n             * List of exporter classes to use in export feature\n             * @config {Grid.feature.export.exporter.Exporter[]}\n             * @default\n             */\n            exporters : [SinglePageExporter, MultiPageExporter, MultiPageVerticalExporter],\n            /**\n             * `True` to replace all linked CSS files URLs to absolute before passing HTML to the server.\n             * When passing a string the current origin of the CSS files URLS will be replaced by the passed origin.\n             *\n             * For example: css files pointing to /app.css will be translated from current origin to {translateURLsToAbsolute}/app.css\n             * @config {Boolean|String}\n             * @default\n             */\n            translateURLsToAbsolute : true,\n            /**\n             * When true links are converted to absolute by combining current window location (with replaced origin) with\n             * resource link.\n             * When false links are converted by combining new origin with resource link (for angular)\n             * @config {Boolean}\n             * @default\n             */\n            keepPathName : true,\n            /**\n             * When true, page will attempt to download generated file.\n             * @config {Boolean}\n             * @default\n             */\n            openAfterExport : true,\n            /**\n             * Set to true to receive binary file from the server instead of download link.\n             * @config {Boolean}\n             * @default\n             */\n            sendAsBinary : false,\n            /**\n             * False to open in the current tab, true - in a new tab\n             * @config {Boolean}\n             * @default\n             */\n            openInNewTab : false,\n            /**\n             * A template function used to generate a page header. It is passed an object with \u00B4currentPage\u00B4 and `totalPages\u00B4 properties.\n             *\n             * ```javascript\n             * let grid = new Grid({\n             *     appendTo   : 'container',\n             *     features : {\n             *         pdfExport : {\n             *             exportServer : 'http://localhost:8080/',\n             *             headerTpl : ({ currentPage, totalPages }) => `\n             *                 <div class=\"demo-export-header\">\n             *                     <img src=\"coolcorp-logo.png\"/>\n             *                     <dl>\n             *                         <dt>Date: ${DateHelper.format(new Date(), 'll LT')}</dt>\n             *                         <dd>${totalPages ? `Page: ${currentPage + 1}/${totalPages}` : ''}</dd>\n             *                     </dl>\n             *                 </div>`\n             *          }\n             *     }\n             * });\n             * ```\n             * @config {Function}\n             * @param {Object} data Data object\n             * @param {Number} data.currentPage Current page number\n             * @param {Number} data.totalPages Tolal pages count\n             * @returns {String}\n             */\n            headerTpl : null,\n            /**\n             * A template function used to generate a page footer. It is passed an object with \u00B4currentPage\u00B4 and `totalPages\u00B4 properties.\n             *\n             * ```javascript\n             * let grid = new Grid({\n             *      appendTo   : 'container',\n             *      features : {\n             *          pdfExport : {\n             *              exportServer : 'http://localhost:8080/',\n             *              footerTpl    : () => '<div class=\"demo-export-footer\"><h3>\u00A9 2020 CoolCorp Inc</h3></div>'\n             *          }\n             *      }\n             * });\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} data Data object\n             * @param {Number} data.currentPage Current page number\n             * @param {Number} data.totalPages Tolal pages count\n             * @returns {String}\n             */\n            footerTpl : null,\n            /**\n             * An object containing the Fetch options to pass to the export server request. Use this to control if\n             * credentials are sent and other options, read more at\n             * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch).\n             * @config {FetchOptions}\n             */\n            fetchOptions : null,\n            /**\n             * A message to be shown when Export feature is performing export.\n             * @config {String}\n             * @default \"Generating pages...\"\n             */\n            exportMask : 'L{Generating pages}',\n            /**\n             * A message to be shown when export is almost done.\n             * @config {String}\n             * @default \"Waiting for response from server...\"\n             */\n            exportProgressMask : 'L{Waiting for response from server}',\n            /**\n             * Set to `false` to not show Toast message on export error.\n             * @config {Boolean}\n             * @default\n             */\n            showErrorToast : true,\n            localizableProperties : ['exportMask', 'exportProgressMask'],\n            /**\n             * This method accepts all stylesheets (link and style tags) which are supposed to be put on the page. Use\n             * this hook method to filter or modify them.\n             *\n             * ```javascript\n             * new Grid({\n             *     features: {\n             *         pdfExport: {\n             *             // filter out inline styles and bootstrap.css\n             *             filterStyles: styles => styles.filter(item => !/(link|bootstrap.css)/.test(item))\n             *         }\n             *     }\n             * });\n             * ```\n             * @param {String[]} styles\n             * @returns {String[]} List of stylesheets to put on the exported page\n             */\n            filterStyles : styles => styles,\n            /**\n             * Enables direct rendering of the component content which significantly improves performance. To enable\n             * old export mode set this flag to false.\n             * @config {Boolean}\n             * @default\n             */\n            enableDirectRendering : true,\n            /**\n             * This config forces exporter to always use rendered column width. Used by Agenda view in Calendar\n             * @private\n             */\n            useRenderedColumnWidth : false,\n            /**\n             * When true, export feature will use an iframe and browser's default print dialog, which allows to save\n             * as PDF. Content is optimized for chrome/edge to exact page size in the specified orientation and no\n             * margins. If you only see grid header or blank pages, try using different scale value in the print dialog\n             * **NOTE**: Not supported in Safari. Print works, but Safari cannot seem to fit content to one page\n             * correctly.\n             * @config {Boolean}\n             * @default\n             * @private\n             */\n            useBrowserPrint : false\n        };\n    }\n    updateEnableDirectRendering(value) {\n        if (!value) {\n            VersionHelper.deprecate('Grid', '6.0.0', 'Indirect rendering is deprecated');\n        }\n    }\n    doDestroy() {\n        this.exportDialog?.destroy();\n        this.exportersMap.forEach(exporter => exporter.destroy());\n        super.doDestroy();\n    }\n    /**\n     * When export is started from GUI ({@link Grid.view.export.ExportDialog}), export promise can be accessed via\n     * this property.\n     * @property {Promise|null}\n     */\n    get currentExportPromise() {\n        return this._currentExportPromise;\n    }\n    set currentExportPromise(value) {\n        this._currentExportPromise = value;\n    }\n    get exportersMap() {\n        return this._exportersMap || (this._exportersMap = new Map());\n    }\n    getExporter(config = {}) {\n        const\n            me               = this,\n            { exportersMap } = me,\n            { type }         = config;\n        let exporter;\n        if (exportersMap.has(type)) {\n            exporter = exportersMap.get(type);\n            Object.assign(exporter, config);\n        }\n        else {\n            const exporterClass = this.exporters.find(cls => cls.type === type);\n            if (!exporterClass) {\n                throw new Error(`Exporter type ${type} is not found. Make sure you've configured it`);\n            }\n            config = ObjectHelper.clone(config);\n            delete config.type;\n            exporter = new exporterClass(config);\n            exporter.relayAll(me);\n            exportersMap.set(type, exporter);\n        }\n        return exporter;\n    }\n    buildExportConfig(config = {}) {\n        const\n            me = this,\n            {\n                client,\n                exportServer,\n                clientURL,\n                fileFormat,\n                fileName,\n                paperFormat,\n                rowsRange,\n                alignRows,\n                repeatHeader,\n                keepRegionSizes,\n                orientation,\n                translateURLsToAbsolute,\n                keepPathName,\n                sendAsBinary,\n                headerTpl,\n                footerTpl,\n                filterStyles,\n                enableDirectRendering,\n                useRenderedColumnWidth,\n                useBrowserPrint\n            }  = me;\n        if (!config.columns) {\n            config.columns = client.columns.visibleColumns.filter(column => column.exportable).map(column => column.id);\n        }\n        const result = ObjectHelper.assign({\n            client,\n            exportServer,\n            clientURL,\n            fileFormat,\n            paperFormat,\n            rowsRange,\n            alignRows,\n            repeatHeader,\n            keepRegionSizes,\n            orientation,\n            translateURLsToAbsolute,\n            keepPathName,\n            sendAsBinary,\n            headerTpl,\n            footerTpl,\n            enableDirectRendering,\n            useRenderedColumnWidth,\n            useBrowserPrint,\n            exporterType : me.exporterType,\n            fileName     : fileName || client.$$name\n        }, config);\n        // slice columns array to not modify it during export\n        result.columns = config.columns.slice();\n        // Only vertical exporter is supported\n        if (result.exporterType !== 'multipagevertical') {\n            result.repeatHeader = false;\n        }\n        // Align rows by default\n        if (!('alignRows' in config) && config.repeatHeader) {\n            result.alignRows = true;\n        }\n        result.exporterConfig = ObjectHelper.assign({\n            type                    : result.exporterType,\n            translateURLsToAbsolute : result.translateURLsToAbsolute,\n            keepPathName            : result.keepPathName,\n            filterStyles\n        }, result.exporterConfig || {});\n        delete result.exporterType;\n        delete result.translateURLsToAbsolute;\n        delete result.keepPathName;\n        return result;\n    }\n    /**\n     * Starts the export process. Accepts a config object which overrides any default configs.\n     * **NOTE**. Component should not be interacted with when export is in progress\n     *\n     * @param {Object} config\n     * @returns {Promise} Object of the following structure\n     * ```\n     * {\n     *     response // Response instance\n     * }\n     * ```\n     */\n    async export(config = {}) {\n        const\n            me = this,\n            {\n                client,\n                pagesPerRequest\n            }  = me;\n        config = me.buildExportConfig(config);\n        let result;\n        /**\n         * Fires on the owning Grid before export started. Return `false` to cancel the export.\n         * @event beforePdfExport\n         * @preventable\n         * @on-owner\n         * @param {Object} config Export config\n         */\n        if (client.trigger('beforePdfExport', { config }) !== false) {\n            client.isExporting = true;\n            // This mask should be always visible to protect grid from changes even if the mask message is not visible\n            // due to the export dialog which is rendered above the grid's mask. The dialog has its own mask which shares the export message.\n            client.mask(me.exportMask);\n            try {\n                const exporter = me.getExporter(config.exporterConfig);\n                if (pagesPerRequest === 0) {\n                    const pages = await exporter.export(config);\n                    if (me.isDestroying) {\n                        return;\n                    }\n                    // Hide dialog\n                    me.exportDialog?.close();\n                    // We can unmask early\n                    client.unmask();\n                    /**\n                     * Fires when export progress changes\n                     * @event exportStep\n                     * @param {Number} progress Current progress, 0-100\n                     * @param {String} text Optional text to show\n                     */\n                    me.trigger('exportStep', { progress : 90, text : me.exportProgressMask, contentGenerated : true });\n                    if (config.useBrowserPrint) {\n                        await me.doPrint(pages, config);\n                        // We used client side print, return empty object\n                        result = {};\n                    }\n                    else {\n                        const responsePromise = me.receiveExportContent(pages, config);\n                        // Show toast message indicating we're waiting for the server response\n                        me.toast = me.showLoadingToast(responsePromise);\n                        const response = await responsePromise;\n                        result = { response };\n                        await me.processExportContent(response, config);\n                    }\n                }\n            }\n            catch (error) {\n                if (error instanceof Response) {\n                    result = { response : error };\n                }\n                else {\n                    result = { error };\n                }\n                throw error;\n            }\n            finally {\n                if (me.toast && !me.toast.isDestroying) {\n                    // Hide would also destroy the toast\n                    me.toast.hide();\n                }\n                if (!me.isDestroying) {\n                    // Close dialog on exception\n                    me.exportDialog?.close();\n                    client.unmask();\n                    if (me.showErrorToast) {\n                        // Do not show warning if user has cancelled request\n                        if (result.error) {\n                            if (result.error.name !== 'AbortError') {\n                                Toast.show({\n                                    html        : me.L('L{Export failed}'),\n                                    rootElement : me.rootElement\n                                });\n                            }\n                        }\n                        else if (result.response && !result.response.ok) {\n                            Toast.show({\n                                html        : me.L('L{Server error}'),\n                                rootElement : me.rootElement\n                            });\n                        }\n                    }\n                    /**\n                     * Fires on the owning Grid when export has finished\n                     * @event pdfExport\n                     * @on-owner\n                     * @param {Response} [response] Optional response, if received\n                     * @param {Error} [error] Optional error, if exception occurred\n                     */\n                    client.trigger('pdfExport', result);\n                    client.isExporting = false;\n                }\n            }\n        }\n        return result;\n    }\n    /**\n     * Sends request to the export server and returns Response instance. This promise can be cancelled by the user\n     * by clicking on the toast message. When the user clicks on the toast, `abort` method is called on the promise\n     * returned by this method. If you override this method you can implement `abort` method like in the snippet\n     * below to cancel the request.\n     *\n     * ```javascript\n     * class MyPdfExport extends PdfExport {\n     *     receiveExportContent(pages, config) {\n     *         let controller;\n     *\n     *         const promise = new Promise(resolve => {\n     *             controller = new AbortController();\n     *             const signal = controller.signal;\n     *\n     *             fetch(url, { signal })\n     *                 .then(response => resolve(response));\n     *         });\n     *\n     *         // This method will be called when user clicks on the toast message to cancel the request\n     *         promise.abort = () => controller.abort();\n     *\n     *         return promise;\n     *     }\n     * }\n     *\n     * const grid = new Grid({ features: { myPdfExport : {...} } });\n     *\n     * grid.features.myPdfExport.export().catch(e => {\n     *     // In case of aborted request do nothing\n     *     if (e.name !== 'AbortError') {\n     *         // handle other exceptions\n     *     }\n     * });\n     * ```\n     * @param {Object[]} pages Array of exported pages.\n     * @param {String} pages[].html pages HTML of the exported page.\n     * @param {Object} config Export config\n     * @param {String} config.exportServer URL of the export server.\n     * @param {String} config.orientation Page orientation. portrait/landscape.\n     * @param {String} config.paperFormat Paper format as supported by puppeteer. A4/A3/...\n     * @param {String} config.fileFormat File format. PDF/PNG.\n     * @param {String} config.fileName Name to use for the saved file.\n     * @param {String} config.clientURL URL to navigate before export. See {@link #config-clientURL}.\n     * @param {String} config.sendAsBinary Tells server whether to return binary file instead of download link.\n     * @returns {Promise} Returns Response instance\n     */\n    receiveExportContent(pages, config) {\n        return AjaxHelper.fetch(\n            config.exportServer,\n            Object.assign({\n                method      : 'POST',\n                credentials : 'omit',\n                headers     : { 'Content-Type' : 'application/json' },\n                body        : JSON.stringify({\n                    html         : pages,\n                    orientation  : config.orientation,\n                    format       : config.paperFormat,\n                    fileFormat   : config.fileFormat,\n                    fileName     : config.fileName,\n                    clientURL    : config.clientURL,\n                    sendAsBinary : config.sendAsBinary\n                })\n            }, this.fetchOptions)\n        );\n    }\n    /**\n     * Handles output of the {@link #function-receiveExportContent}. Server response can be of two different types depending\n     * on {@link #config-sendAsBinary} config:\n     * - `application/json` In this case JSON response contains url of the file to download\n     * - `application/octet-stream` In this case response contains stream of file binary data\n     *\n     * If {@link #config-openAfterExport} is true, this method will try to download content.\n     * @param {Response} response\n     * @param {Object} config Export config\n     * @param {String} config.exportServer URL of the export server.\n     * @param {String} config.orientation Page orientation. portrait/landscape.\n     * @param {String} config.paperFormat Paper format as supported by puppeteer. A4/A3/...\n     * @param {String} config.fileFormat File format. PDF/PNG.\n     * @param {String} config.fileName Name to use for the saved file.\n     * @param {String} config.clientURL URL to navigate before export. See {@link #config-clientURL}.\n     * @param {String} config.sendAsBinary Tells server whether to return binary file instead of download link. See {@link #config-sendAsBinary}\n     */\n    async processExportContent(response, config) {\n        const me = this;\n        if (response.ok && me.openAfterExport) {\n            // Clone Response to not block response stream\n            response = response.clone();\n            const contentType = response.headers.get('content-type');\n            if (contentType.match(/application\\/octet-stream/)) {\n                const\n                    MIMEType  = FileMIMEType[config.fileFormat],\n                    objectURL = await me.responseBlobToObjectURL(response, MIMEType),\n                    link      = me.getDownloadLink(config.fileName, objectURL);\n                link.click();\n            }\n            else if (contentType.match(/application\\/json/)) {\n                const responseJSON = await response.json();\n                if (responseJSON.success) {\n                    const link = me.getDownloadLink(config.fileName, responseJSON.url);\n                    link.click();\n                }\n                else {\n                    Toast.show({\n                        html        : responseJSON.msg,\n                        rootElement : this.rootElement\n                    });\n                }\n            }\n        }\n    }\n    doPrint(pages) { }\n    /**\n     * Creates object URL from response content with given mimeType\n     * @param {Response} response Response instance\n     * @param {String} mimeType\n     * @returns {Promise} Returns string object URL\n     * @private\n     */\n    async responseBlobToObjectURL(response, mimeType) {\n        const blob = await response.blob();\n        return URL.createObjectURL(blob.slice(0, blob.size, mimeType));\n    }\n    /**\n     * Creates link to download the file.\n     * @param {String} name File name\n     * @param {String} href URL of the resource\n     * @returns {HTMLElement} HTMLAnchorElement\n     * @private\n     */\n    getDownloadLink(name, href) {\n        const link = document.createElement('a');\n        link.download = name;\n        link.href = href;\n        if (this.openInNewTab) {\n            link.target = '_blank';\n        }\n        return link;\n    }\n    get defaultExportDialogConfig() {\n        return ObjectHelper.copyProperties({}, this, [\n            'client',\n            'exporters',\n            'exporterType',\n            'orientation',\n            'fileFormat',\n            'paperFormat',\n            'alignRows',\n            'rowsRange',\n            'repeatHeader',\n            'useBrowserPrint'\n        ]);\n    }\n    changeExportDialog(exportDialog, oldExportDialog) {\n        const me = this;\n        oldExportDialog?.destroy();\n        if (exportDialog) {\n            const config = me.dialogClass.mergeConfigs({\n                rootElement : me.rootElement,\n                client      : me.client,\n                modal       : {\n                    transparent : true\n                },\n                items : {\n                    rowsRangeField : {\n                        value : me.rowsRange\n                    },\n                    exporterTypeField : {\n                        value : me.exporterType\n                    },\n                    orientationField : {\n                        value : me.orientation\n                    },\n                    paperFormatField : {\n                        value : me.paperFormat\n                    },\n                    repeatHeaderField : {\n                        value : me.repeatHeader\n                    },\n                    fileFormatField : {\n                        value : me.fileFormat\n                    },\n                    alignRowsField : {\n                        checked : me.alignRows\n                    }\n                }\n            }, me.defaultExportDialogConfig, exportDialog);\n            exportDialog = me.dialogClass.new(config);\n            exportDialog.ion({\n                export  : me.onExportButtonClick,\n                thisObj : me\n            });\n        }\n        return exportDialog;\n    }\n    /**\n     * Shows {@link Grid.view.export.ExportDialog export dialog}\n     */\n    async showExportDialog() {\n        return this.exportDialog.show();\n    }\n    onExportButtonClick({ values }) {\n        const\n            me         = this,\n            dialogMask = me.exportDialog.mask({\n                progress    : 0,\n                maxProgress : 100,\n                text        : me.exportMask\n            });\n        const detacher = me.ion({\n            exportstep({ progress, text, contentGenerated }) {\n                if (contentGenerated) {\n                    me.exportDialog.unmask();\n                    detacher();\n                }\n                else {\n                    dialogMask.progress = progress;\n                    if (text != null) {\n                        dialogMask.text = text;\n                    }\n                }\n            }\n        });\n        me.currentExportPromise = me.export(values);\n        // Clear current export promise\n        me.currentExportPromise.catch(() => {}).finally(() => {\n            detacher();\n            me.exportDialog?.unmask();\n            me.currentExportPromise = null;\n        });\n    }\n    showLoadingToast(exportPromise) {\n        const toast = Toast.show({\n            timeout      : 0,\n            showProgress : false,\n            rootElement  : this.rootElement,\n            html         : `\n    <span class=\"b-mask-icon b-icon b-icon-spinner\"></span>\n    <span>${this.exportProgressMask}</span>\n    <button class=\"b-button\">${this.L('L{Click to abort}')}</button>`\n        });\n        EventHelper.on({\n            element : toast.element,\n            click() {\n                exportPromise.abort?.();\n            }\n        });\n        return toast;\n    }\n}\nPdfExport._$name = 'PdfExport'; GridFeatureManager.registerFeature(PdfExport, false, 'Grid');\n// Format expected by export server\n// const pageFormat = {\n//     html       : '',\n//     column     : 1,\n//     number     : 1,\n//     row        : 1,\n//     rowsHeight : 1\n// };\n//\n// const format = {\n//     fileFormat  : 'pdf',\n//     format      : 'A4',\n//     orientation : 'portrait',\n//     range       : 'complete',\n//     html        : { array : JSON.stringify(pageFormat) }\n// };\n", "/**\n * @module Grid/feature/export/mixin/PrintMixin\n */\n/**\n * Mixin implementing print functionality to PdfExport feature.\n * @mixin\n */\nexport default Target => class PrintMixin extends Target {\n    static get $name() {\n        return 'PrintMixin';\n    };\n    static get configurable() {\n        return {\n            useBrowserPrint : true,\n            exporterType : 'multipagevertical'\n        };\n    }\n    static get pluginConfig() {\n        return {\n            assign : ['print', 'showPrintDialog']\n        };\n    }\n    /**\n     * Shows the {@link Grid.view.export.ExportDialog print dialog}\n     * @returns {Promise}\n     * @on-owner\n     * @catagory Print\n     */\n    showPrintDialog(config) {\n        return this.showExportDialog(config);\n    }\n    /**\n     * Starts the print process. Accepts a config object which overrides any default configs.\n     * **NOTE** Component should not be interacted with when print is in progress\n     *\n     * @param {Object} config\n     * @returns {Promise} Promise which resolves when printing is done. Optionally it might return an object with an\n     * `error` key in it.\n     * @on-owner\n     * @catagory Print\n     */\n    print(config) {\n        return this.export(config);\n    }\n    /**\n     * This method is called when IFrame is loaded with all the HTML/CSS and is about to be printed. Use it to take\n     * control over the page contents.\n     * @param {HTMLIFrameElement} iframe\n     */\n    async onPrintIFrameLoad(iframe) {}\n    async showBrowserPrintDialog(iframe, resolve) {\n        await this.onPrintIFrameLoad(iframe);\n        // This one is a private event to block print API in tests\n        if (await this.client.trigger('beforeShowPrintDialog', { iframe }) !== false) {\n            const { contentWindow } = iframe;\n            // Clean up iframe after print\n            contentWindow.onafterprint = () => {\n                iframe.remove();\n                resolve();\n            };\n            contentWindow.print();\n        }\n        else {\n            iframe.remove();\n            resolve();\n        }\n    }\n    doPrint(pages) {\n        const me = this;\n        return new Promise((resolve, reject) => {\n            const iframe = document.createElement('iframe');\n            iframe.className = 'b-print-wrapper';\n            // We don't need to see this iframe\n            iframe.style.visibility = 'hidden';\n            iframe.style.height = '0';\n            iframe.onload = () => {\n                const\n                    handle   = iframe.contentWindow,\n                    doc      = handle.document,\n                    { body } = doc,\n                    parser   = new DOMParser();\n                let paperHeight;\n                pages.forEach(({ html }) => {\n                    const\n                        fragment = parser.parseFromString(html, 'text/html'),\n                        node     = doc.adoptNode(fragment.body.firstChild),\n                        pageWrap = doc.createElement('div');\n                    fragment.head.querySelectorAll('style,link[rel=\"stylesheet\"],link[as=\"style\"]').forEach(styleEl => {\n                        const el = doc.adoptNode(styleEl);\n                        doc.head.appendChild(el);\n                    });\n                    pageWrap.classList.add('b-page-wrap');\n                    pageWrap.style.height = fragment.body.parentElement.style.height;\n                    pageWrap.style.width = fragment.body.parentElement.style.width;\n                    paperHeight = parseFloat(fragment.body.parentElement.style.height);\n                    body.appendChild(pageWrap);\n                    pageWrap.appendChild(node);\n                });\n                const { html } = pages[0];\n                // DomParser is Salesforce ignores body classes which are required\n                body.className = html.match(/<body class=\"(.+?)\"/)?.[1] || '';\n                body.classList.add('b-print');\n                body.parentElement.classList.add('b-print-root');\n                body.parentElement.style.height = `${paperHeight * pages.length}in`;\n                Promise.all(Array.from(doc.head.querySelectorAll('link[rel=\"stylesheet\"]')).map(link => {\n                    return new Promise((resolve, reject) => {\n                        link.onload = resolve;\n                        link.onerror = reject;\n                    });\n                }))\n                    // When we added `<link>` elements to the IFrame we may have started loading the font too.\n                    // Normally we do, because our theme uses FontAwesome for icons. This promise will always\n                    // be resolved at some point: https://drafts.csswg.org/css-font-loading/#font-face-set-ready\n                    // So we can be sure that control which we pass to the browser print dialog is not lost.\n                    .then(() => doc.fonts.ready)\n                    .then(() => me.showBrowserPrintDialog(iframe, resolve))\n                    .catch(e => {\n                        console.warn(`Failed to load stylesheets ${e.message ? `: ${e.message}` : ''}`);\n                        reject(me.L('L{PdfExport.Export failed}'));\n                    });\n            };\n            me.client.element.parentElement.appendChild(iframe);\n        });\n    }\n};\n"],
  "mappings": "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",
  "names": ["id", "range", "pagesExtractor", "pagesExtractor", "pagesExtractor", "html", "resolve", "reject"]
}
