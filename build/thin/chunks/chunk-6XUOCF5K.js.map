{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/widget/panel/PanelCollapserOverlay.js"],
  "sourcesContent": ["import Animator from '../../util/Animator.js';\nimport PanelCollapser from './PanelCollapser.js';\nimport Delayable from '../../mixin/Delayable.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\nimport EventHelper from '../../helper/EventHelper.js';\nimport DomHelper from '../../helper/DomHelper.js';\nimport DomClassList from '../../helper/util/DomClassList.js';\n/**\n * @module Core/widget/panel/PanelCollapserOverlay\n */\nconst\n    { dockIsHorz } = PanelCollapser.maps,\n    collapseExposeEdge = {\n        top    : 0,\n        down   : 0,\n        left   : 1,\n        bottom : 2,\n        up     : 2,\n        right  : 3\n    },\n    translateByDir = {\n        up : {\n            from : `translate(0,0)`,\n            to   : 'translate(0,-100%)'\n        },\n        down : {\n            from : `translate(0,0)`,\n            to   : 'translate(0,100%)'\n        },\n        left : {\n            from : `translate(0,0)`,\n            to   : 'translate(-100%,0)'\n        },\n        right : {\n            from : `translate(0,0)`,\n            to   : 'translate(100%,0)'\n        }\n    };\n/**\n * A panel collapse implementation that adds the ability to reveal the collapsed panel as a floating overlay.\n *\n * @extends Core/widget/panel/PanelCollapser\n * @classtype overlay\n * @classtypealias panelcollapseroverlay\n */\nexport default class PanelCollapserOverlay extends PanelCollapser.mixin(Delayable) {\n    static $name = 'PanelCollapserOverlay';\n    static type = 'overlay';\n    static get configurable() {\n        return {\n            /**\n             * The number of milliseconds to wait once the mouse leaves a {@link Core.widget.Panel#config-revealed}\n             * panel before returning to an unrevealed state. Clicking outside the revealed panel will immediately\n             * return the panel to its collapsed state.\n             *\n             * This may be disabled by configuring {@link #config-autoClose} as `null`.\n             *\n             * If this value is negative, the panel will not automatically recollapse due to the mouse leaving, however,\n             * clicks outside the panel will still recollapse it.\n             *\n             * If this value is `null`, the panel will not automatically recollapse for either outside clicks or if\n             * the mouse leaves the panel.\n             * @config {Number}\n             * @default\n             */\n            autoCloseDelay : 1000,\n            /**\n             * By default, clicking outside the revealed overlay hides the revealed overlay.\n             *\n             * If the revealed overlay was shown using the {@link #property-recollapseTool}\n             * then moving the mouse outside of the revealed overlay hides the revealed overlay.\n             *\n             * Configure this as `false` to disable auto hiding, making overlayed\n             * state permanent, and changeable using the {@link #function-toggleReveal} method.\n             * @config {Boolean}\n             * @default\n             */\n            autoClose : true,\n            revealing : {\n                value   : null,\n                $config : null,\n                default : false\n            },\n            /**\n             * The reveal/hide tool which slides the collapsed panel over the top of the UI.\n             * @member {Core.widget.Tool} recollapseTool\n             */\n            /**\n             * The reveal/hide tool which slides the collapsed panel over the top of the UI.\n             *\n             * The `type` of this instance should not be changed but the tool instance can be\n             * configured in other ways via this config property.\n             * @config {ToolConfig|Core.widget.Tool}\n             */\n            recollapseTool : {\n                type       : 'collapsetool',\n                cls        : 'b-recollapse',\n                collapsify : 'overlay',\n                handler() {\n                    // NOTE: As a tool, our this pointer is the Panel so we use it to access the current collapser\n                    this.collapsible?.toggleReveal();\n                }\n            }\n        };\n    }\n    static get delayable() {\n        return {\n            doAutoClose : 0\n        };\n    }\n    doAutoClose() {\n        this.toggleReveal(false);\n    }\n    updateAutoCloseDelay(delay) {\n        const { doAutoClose } = this;\n        if (!(doAutoClose.suspended = delay == null || delay < 0)) {\n            doAutoClose.delay = delay;\n            doAutoClose.immediate = !delay;\n        }\n    }\n    changeRecollapseTool(tool) {\n        const\n            me = this,\n            { panel } = me;\n        if (me.isConfiguring || me.isDestroying || !panel || panel.isDestroying) {\n            return tool;\n        }\n        panel.tools = {\n            recollapse : tool\n        };\n    }\n    beforeCollapse(operation) {\n        if (super.beforeCollapse(operation) === false) {\n            return false;\n        }\n        if (this.panel.revealed) {\n            operation.animation = null;\n        }\n    }\n    applyHeaderDock(collapsed, flush = true) {\n        this.panel?.recompose();\n        super.applyHeaderDock(collapsed, flush);\n    }\n    collapseBegin(operation) {\n        const\n            me = this,\n            { collapseDir, innerElement } = me,\n            { animation } = operation,\n            { collapseTool, panel } = me;\n        me.configuredWidth = panel._lastWidth;\n        me.configuredHeight = panel._lastHeight;\n        me.applyHeaderDock(true);\n        // const innerElementRect = me.lockInnerSize();\n        me.lockInnerSize();\n        collapseTool?.element.classList.add('b-collapsed');\n        if (animation) {\n            panel.element.classList.add('b-collapsing');\n            animation.element = innerElement;\n            animation.transform = translateByDir[collapseDir];\n            operation.animation = Animator.run(animation);\n        }\n    }\n    onComplete(action) {\n        super.onComplete(action);\n        const\n            me          = this,\n            { panel }   = me,\n            { element } = panel;\n        me.autoCloseLeaveDetacher = me.autoCloseLeaveDetacher?.();\n        me.autoCloseClickDetacher = me.autoCloseClickDetacher?.();\n        // The act of hiding the revealed panel (\"unrevealing\") causes a mouseleave event (once the panel slides out\n        // from under the cursor) and that starts the autoClose timer. If the user then reveals the panel again within\n        // the 1sec delay (by default), the autoClose timer will still fire and unreveal the panel.\n        me.doAutoClose.cancel();\n        if (action === 'reveal' && me.autoClose) {\n            // Only listen for mouseleave to close if we contain focus.\n            // If we do not, then we have been revealed using the API from some other\n            // part of the UI, so mouseleave closing would not be appropriate.\n            if (panel.containsFocus) {\n                me.autoCloseLeaveDetacher = EventHelper.on({\n                    element,\n                    mouseenter : ev => {\n                        me.doAutoClose.cancel();\n                    },\n                    mouseleave : ev => {\n                        me.doAutoClose();\n                    }\n                });\n            }\n            me.autoCloseClickDetacher = EventHelper.on({\n                element   : document.body,\n                thisObj   : panel,\n                mousedown : ev => {\n                    // If it's a click outside of the revealed Panel, but *not* on the element which\n                    // was active when the reveal was done (because that's the toggle button)\n                    // then unreveal.\n                    if (!panel.owns(ev) && !me.revealer?.contains(ev.target) && me.autoCloseDelay != null) {\n                        me.doAutoClose.now();\n                    }\n                }\n            });\n        }\n    }\n    expandBegin(operation) {\n        const\n            me = this,\n            { animation } = operation,\n            { collapseDir, collapseTool, innerElement, panel } = me,\n            { element } = panel;\n        element.classList.remove('b-collapsed', 'b-collapsing');\n        me.restoreConfiguredSize();\n        me.lockInnerSize(false);\n        me.lockInnerSize();\n        collapseTool?.element.classList.remove('b-collapsed');\n        if (animation) {\n            element.classList.add('b-collapsed', 'b-expanding');\n            animation.element = innerElement;\n            animation.transform = {\n                from : translateByDir[collapseDir].to,\n                to   : translateByDir[collapseDir].from\n            };\n            operation.animation = Animator.run(animation);\n        }\n    }\n    expandEnd(operation) {\n        super.expandEnd(operation);\n        const { panel } = this;\n        if (operation.completed) {\n            panel.revealed = false;\n        }\n        panel.element.classList.remove('b-expanding');\n    }\n    expandRevert(operation) {\n        super.expandRevert(operation);\n        this.panel.element.classList.add('b-expanding');\n    }\n    get innerElement() {\n        return this.panel.overlayElement;\n    }\n    get innerSizeElement() {\n        return this.panel.element;\n    }\n    get toolsConfig() {\n        const\n            me = this,\n            { direction } = me,\n            config = super.toolsConfig,\n            tool = me.recollapseTool;\n        if (tool) {\n            return {\n                ...config,\n                recollapse : tool && ObjectHelper.assign({\n                    direction : direction.toLowerCase()\n                }, tool)\n            };\n        }\n        return config;\n    }\n    lockInnerSize(lock = true) {\n        const\n            me = this,\n            { panel } = me,\n            panelRect = lock && panel.rectangle(),  // must read this before we call super\n            inset = lock ? [0, 0, 0, 0] : '',\n            // now we can call super:\n            innerRect = super.lockInnerSize(lock);\n        // The panel overlay is visible because we switch to \"overflow:visible\" in collapsed state. By doing this,\n        // however, the header animation undesirably escapes as well. Fortunately, we can use the clip-path to hide\n        // this by only allowing the desired side to escape while all other sides remain clipped. Even more fortunate\n        // for us is that clip-path is expressed as an inset from the normal rectangle of the element (so we don't\n        // need to adjust it if the collapsed panel is resized), and further, unlike CSS path style, clip-path works\n        // for all elements not only absolutely positioned ones.\n        if (lock) {\n            inset[collapseExposeEdge[me.collapseDir]] = `-${panelRect[me.collapseDim] + 10}px`;\n        }\n        panel.element.style.clipPath = lock ? `inset(${inset.join(' ')})` : '';\n        return innerRect;\n    }\n    onOverlayTransitionDone(ev) {\n        const\n            me = this,\n            { panel } = me;\n        if (ev.srcElement === panel.overlayElement && me.revealing) {\n            me.revealing = false;\n            me.onComplete(panel.revealed ? 'reveal' : 'unreveal');\n        }\n    }\n    onRevealerClick() {\n        this.toggleReveal();\n    }\n    /**\n     * Toggles the revealed state of the Panel to match the passed boolean flag.\n     * @param {Boolean} [state]  If not specified, this method toggles current state. Otherwise, pass `true` to reveal\n     * the overlay, or `false` to hide it.\n     */\n    toggleReveal(state) {\n        const\n            { panel }   = this,\n            { element } = panel;\n        if (panel.collapsed) {\n            this.revealer = DomHelper.getActiveElement(element);\n            if (state == null) {\n                state = !panel.revealed;\n            }\n            if (panel.revealed !== state && panel.trigger('beforeToggleReveal', { reveal : state }) !== false) {\n                // This is essentially a hide, so move focus back to whence it came\n                if (!state && element.contains(this.revealer)) {\n                    panel.revertFocus(true);\n                }\n                this.revealing = true;\n                panel.revealed = state;\n            }\n        }\n    }\n    updateRevealing(value) {\n        const\n            me = this,\n            horzDirRe = /left|right/i,\n            { panel } = me,\n            dim = horzDirRe.test(me.collapseDir) ? 'height' : 'width';\n        if (panel) {\n            me.innerElement.style[dim] = '0px';\n            me.innerElement.style[`min-${dim}`] = '100%';\n            panel.element.classList[value ? 'add' : 'remove']('b-panel-overlay-revealing');\n        }\n    }\n    wrapCollapser(key, body) {\n        const\n            me = this,\n            { collapseDir, panel } = me,\n            { expandedHeaderDock, header, uiClassList } = panel,\n            recollapse = panel.tools?.recollapse,\n            [before, after] = me.splitHeaderItems({ as : 'element', dock : me.collapseDock }),\n            horz = dockIsHorz[expandedHeaderDock],\n            title = panel.hasHeader ? (panel.title || header?.title || '\\xA0') : null;\n        if (recollapse) {\n            recollapse.direction = collapseDir;\n        }\n        return [\n            'overlayElement',\n            {\n                class : {\n                    ...uiClassList,\n                    [`b-panel-overlay-header-${expandedHeaderDock}`] : 1,\n                    [`b-panel-overlay-${collapseDir}`]               : 1,\n                    [`b-${horz ? 'h' : 'v'}box`]                     : 1,\n                    'b-panel-overlay'                                : 1,\n                    'b-box-center'                                   : 1\n                },\n                // internalListeners is not correct for element listeners in domConfigs\n                listeners : {  // eslint-disable-line bryntum/no-listeners-in-lib\n                    transitionend    : ev => me.onOverlayTransitionDone(ev),\n                    transitioncancel : ev => me.onOverlayTransitionDone(ev)\n                },\n                children : {\n                    overlayHeaderElement : title && {\n                        tag   : 'header',\n                        class : new DomClassList({\n                            ...uiClassList,\n                            [`b-dock-${expandedHeaderDock}`] : 1,\n                            'b-panel-header'                 : 1,\n                            'b-panel-overlay-header'         : 1\n                        }, header?.cls),\n                        children : [\n                            ...before,\n                            {\n                                reference : 'overlayTitleElement',\n                                html      : title,\n                                class     : {\n                                    ...uiClassList,\n                                    [`b-align-${header?.titleAlign || 'start'}`] : 1,\n                                    'b-header-title'                             : 1\n                                }\n                            },\n                            ...after\n                        ]\n                    },\n                    [key] : body\n                }\n            }\n        ];\n    }\n}\n// Register this widget type with its Factory\nPanelCollapserOverlay.initClass();\nPanelCollapserOverlay._$name = 'PanelCollapserOverlay';"],
  "mappings": "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",
  "names": ["_a"]
}
