{
  "version": 3,
  "sources": ["../../lib/TaskBoard/feature/TaskBoardFeature.js", "../../lib/TaskBoard/feature/ColumnDrag.js", "../../lib/TaskBoard/feature/ColumnHeaderMenu.js", "../../lib/TaskBoard/feature/ColumnToolbars.js", "../../lib/TaskBoard/view/item/TaskItem.js", "../../lib/TaskBoard/feature/SimpleTaskEdit.js", "../../lib/TaskBoard/feature/SwimlaneDrag.js", "../../lib/TaskBoard/feature/TaskDrag.js", "../../lib/TaskBoard/feature/TaskDragSelect.js", "../../lib/TaskBoard/widget/mixin/TaskBoardLinked.js", "../../lib/TaskBoard/widget/base/ColorBoxCombo.js", "../../lib/TaskBoard/widget/ColumnCombo.js", "../../lib/TaskBoard/widget/ResourcesCombo.js", "../../lib/TaskBoard/widget/SwimlaneCombo.js", "../../lib/TaskBoard/widget/TaskColorPicker.js", "../../lib/TaskBoard/widget/TaskColorCombo.js", "../../lib/TaskBoard/widget/TaskEditor.js", "../../lib/TaskBoard/feature/TaskEdit.js", "../../lib/TaskBoard/feature/TaskMenu.js", "../../lib/TaskBoard/feature/TaskTooltip.js", "../../lib/TaskBoard/model/ColumnModel.js", "../../lib/TaskBoard/model/TaskModel.js", "../../lib/TaskBoard/store/TaskStore.js", "../../lib/TaskBoard/model/ProjectModel.js", "../../lib/TaskBoard/model/SwimlaneModel.js", "../../lib/TaskBoard/view/mixin/ExpandCollapse.js", "../../lib/TaskBoard/view/mixin/ResponsiveCards.js", "../../lib/TaskBoard/view/mixin/TaskBoardColumns.js", "../../lib/TaskBoard/view/mixin/TaskBoardDom.js", "../../lib/TaskBoard/view/mixin/TaskBoardDomEvents.js", "../../lib/TaskBoard/view/mixin/TaskBoardScroll.js", "../../lib/TaskBoard/view/mixin/TaskBoardStores.js", "../../lib/TaskBoard/view/mixin/TaskBoardSwimlanes.js", "../../lib/TaskBoard/view/mixin/TaskBoardVirtualization.js", "../../lib/TaskBoard/view/item/TextItem.js", "../../lib/TaskBoard/view/item/ResourceAvatarsItem.js", "../../lib/TaskBoard/view/mixin/TaskItems.js", "../../lib/TaskBoard/view/mixin/TaskNavigation.js", "../../lib/TaskBoard/view/mixin/TaskSelection.js", "../../lib/TaskBoard/view/item/ImageItem.js", "../../lib/TaskBoard/view/item/JsxItem.js", "../../lib/TaskBoard/view/item/ProgressItem.js", "../../lib/TaskBoard/view/item/RatingItem.js", "../../lib/TaskBoard/view/item/SeparatorItem.js", "../../lib/TaskBoard/widget/TagCombo.js", "../../lib/TaskBoard/view/item/TagsItem.js", "../../lib/TaskBoard/view/item/TemplateItem.js", "../../lib/TaskBoard/view/item/TodoListItem.js", "../../lib/TaskBoard/localization/En.js", "../../lib/TaskBoard/view/TaskBoardBase.js", "../../lib/TaskBoard/view/item/TaskMenuItem.js", "../../lib/TaskBoard/view/TaskBoard.js", "../../lib/TaskBoard/widget/ColumnFilterField.js", "../../lib/TaskBoard/widget/ColumnPickerButton.js", "../../lib/TaskBoard/widget/ColumnScrollButton.js", "../../lib/TaskBoard/widget/ProjectCombo.js", "../../lib/TaskBoard/widget/SwimlaneFilterField.js", "../../lib/TaskBoard/widget/SwimlanePickerButton.js", "../../lib/TaskBoard/widget/SwimlaneScrollButton.js", "../../lib/TaskBoard/widget/TaskFilterField.js", "../../lib/TaskBoard/widget/TodoListField.js", "../../lib/TaskBoard/widget/UndoRedo.js", "../../lib/TaskBoard/widget/ZoomSlider.js"],
  "sourcesContent": ["import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Factoryable from '../../Core/mixin/Factoryable.js';\n/**\n * @module TaskBoard/feature/TaskBoardFeature\n */\n/**\n * The abstract base class for TaskBoard features.\n *\n * @extends Core/mixin/InstancePlugin\n * @abstract\n */\nexport default class TaskBoardFeature extends InstancePlugin.mixin(Factoryable) {\n    static factoryable = {};\n    static configurable = {};\n    // This makes all feature config changes after initialization recompose TaskBoard\n    onConfigChange(args) {\n        if (!this.isConfiguring && !this.isDestroying) {\n            this.client.recompose();\n        }\n        super.onConfigChange(args);\n    }\n}\nTaskBoardFeature._$name = 'TaskBoardFeature';", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport Base from '../../Core/Base.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Draggable from '../../Core/mixin/Draggable.js';\nimport Droppable from '../../Core/mixin/Droppable.js';\nimport Events from '../../Core/mixin/Events.js';\n/**\n * @module TaskBoard/feature/ColumnDrag\n */\n/**\n * This feature allows users to drag columns on the TaskBoard to change the column order. Drag is initiated upon\n * mouse down in the column header. Try it out below!\n *\n * {@inlineexample TaskBoard/feature/ColumnDrag.js}\n *\n * Works just as well when using swimlanes:\n *\n * {@inlineexample TaskBoard/feature/ColumnDragSwimlanes.js}\n *\n * ## Drag events\n *\n * The different stages of a drag operation trigger different events, in order of appearance:\n *\n * | Event                           | Description                                                                    |\n * |---------------------------------|--------------------------------------------------------------------------------|\n * | {@link #event-beforeColumnDrag} | Preventable event fired before a drag starts                                   |\n * | {@link #event-columnDragStart}  | Fired when dragging starts                                                     |\n * | {@link #event-columnDrag}       | Fired when movement during a drag will lead to changes                         |\n * | {@link #event-beforeColumnDrop} | Preventable event fired before finalizing a valid drop. Allows async listeners |\n * | {@link #event-columnDrop}       | Fired after finalizing a valid drop                                            |\n * | {@link #event-columnDragAbort}  | Fired when a drag is aborted (ESC, drop out of bounds or by a listener)        |\n * | {@link #event-columnDragEnd}    | Fired when a started drag ends, no matter the outcome                          |\n *\n * This feature is **disabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype columnDrag\n * @feature\n */\nexport default class ColumnDrag extends TaskBoardFeature {\n    static $name = 'ColumnDrag';\n    static type = 'columnDrag';\n    static pluginConfig = {\n        after : ['initialCompose', 'populateColumnHeaderMenu']\n    };\n    initialCompose() {\n        const me = this;\n        // Cannot use configurable since bodyElement is not available yet when feature is pulled in\n        me.draggable = ColumnZone.new({\n            dragRootElement : me.disabled ? null : me.client.bodyWrapElement,\n            dropRootElement : me.client.bodyWrapElement,\n            owner           : me,\n            internalListeners : {\n                beforeDragStart : 'onBeforeDragStart',\n                dragStart       : 'onDragStart',\n                thisObj         : me\n            }\n        }, me.draggable);\n    }\n    doDestroy() {\n        this.draggable?.destroy();\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        super.doDisable(disable);\n        if (this.draggable) {\n            this.draggable.dragRootElement = disable ? null : this.client.bodyWrapElement;\n        }\n    }\n    movePrev(columnRecord) {\n        const { columns } = this.client;\n        columns.move(columnRecord, columns.getPrev(columnRecord));\n    }\n    moveNext(columnRecord) {\n        const\n            { columns } = this.client,\n            beforeIndex = Math.min(columns.indexOf(columnRecord) + 2, columns.count);\n        columns.move(columnRecord, columns.getAt(beforeIndex));\n    }\n    populateColumnHeaderMenu({ items, columnRecord }) {\n        const\n            { client }       = this,\n            { columns, rtl } = client;\n        if (!client.readOnly && !this.disabled) {\n            items.moveColumnLeft = {\n                text     : 'L{TaskBoard.moveColumnLeft}',\n                icon     : 'b-fw-icon b-icon-left',\n                disabled : columnRecord === columns[rtl ? 'last' : 'first'],\n                weight   : 200,\n                onItem   : () => this['move' + (rtl ? 'Next' : 'Prev')](columnRecord)\n            };\n            items.moveColumnRight = {\n                text     : 'L{TaskBoard.moveColumnRight}',\n                icon     : 'b-fw-icon b-icon-right',\n                disabled : columnRecord === columns[rtl ? 'first' : 'last'],\n                weight   : 300,\n                onItem   : () => this['move' + (rtl ? 'Prev' : 'Next')](columnRecord)\n            };\n        }\n    }\n    onBeforeDragStart({ drag, event }) {\n        /**\n         * Fires on the owning TaskBoard before column dragging starts. Return `false` to prevent the action\n         * @event beforeColumnDrag\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.ColumnModel} columnRecord Column to be dragged\n         */\n        return this.client.trigger('beforeColumnDrag', { drag, event, columnRecord : drag.columnRecord });\n    }\n    onDragStart({ drag, event }) {\n        /**\n         * Fires on the owning TaskBoard when column dragging starts\n         * @event columnDragStart\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.ColumnModel} columnRecord Column to be dragged\n         */\n        return this.client.trigger('columnDragStart', { drag, event, columnRecord : drag.columnRecord });\n    }\n}\nColumnDrag.initClass();\nclass ColumnZone extends Base.mixin(Draggable, Droppable, Events) {\n    static get configurable() {\n        return {\n            dragSelector     : '.b-taskboard-column-header, .b-taskboard-column-header *',\n            dragItemSelector : '.b-taskboard-column-header',\n            // Column has multiple parts (header + one element per swimlane), going to add cls manually to them\n            draggingItemCls : null,\n            dragProxy : {\n                type : 'default',\n                async open(drag) {\n                    const\n                        { owner }    = this,\n                        {\n                            itemElement,\n                            startEvent,\n                            columnRecord\n                        }            = drag,\n                        taskBoard    = owner.owner.client,\n                        headerBounds = Rectangle.from(itemElement, owner.dragRootElement),\n                        // Offset from cursor\n                        proxyOffset  = EventHelper.getClientPoint(startEvent).getDelta(headerBounds),\n                        // Drag proxy, positioned over column being dragged\n                        proxy        = DomHelper.createElement({\n                            className : 'b-taskboard-column-drag-proxy',\n                            parent    : owner.dragRootElement,\n                            style     : {\n                                // Using fixed top, only draggable horizontally\n                                top   : headerBounds.y,\n                                // Offset from cursor to be positioned over original column\n                                left  : EventHelper.getClientPoint(startEvent).translate(proxyOffset[0], 0).x,\n                                // Need a fixed width on the proxy, since columns width might be flexed etc\n                                width : itemElement.getBoundingClientRect().width\n                            },\n                            // Don't want it being removed while dragging\n                            retainElement : true\n                        }),\n                        // A column consists of multiple elements, a header and one \"column\" per swimlane (at least one)\n                        elements     = [itemElement, ...taskBoard.getColumnElements(columnRecord)];\n                    // Things we want to access later on drag\n                    Object.assign(drag, {\n                        proxy,\n                        elements,\n                        proxyOffset\n                    });\n                    // Clone all dragged column elements and put them in the proxy\n                    elements.forEach((element, i) => {\n                        const\n                            columnClone = element.cloneNode(true),\n                            bounds      = element.getBoundingClientRect();\n                        // Store size, used to size drop indicator later\n                        element.originalWidth = bounds.width;\n                        element.originalHeight = bounds.height;\n                        // Mimic element structure, swimlane > column (not fully mimicking it for now, should suffice)\n                        if (element.matches('.b-taskboard-column')) {\n                            const\n                                swimlane      = element.closest('.b-taskboard-swimlane'),\n                                header        = DomSync.getChild(swimlane, 'header'),\n                                body          = DomSync.getChild(swimlane, 'body'),\n                                swimlaneClone = swimlane.cloneNode(),\n                                headerClone   = header?.cloneNode(true),\n                                bodyClone     = body.cloneNode();\n                            let height = swimlane.getBoundingClientRect().height;\n                            // Last swimlane has bottom padding that we do not want in proxy\n                            if (i === elements.length - 1) {\n                                const paddingBottom = DomHelper.getStyleValue(element.parentElement, 'padding-bottom');\n                                height -= parseFloat(paddingBottom);\n                            }\n                            // Use fixed height on the swimlanes in the drag proxy, to have it exactly match the board.\n                            // Otherwise it would shrinkwrap\n                            swimlaneClone.style.flex = `0 0 ${height}px`;\n                            headerClone && swimlaneClone.appendChild(headerClone);\n                            bodyClone.appendChild(columnClone);\n                            swimlaneClone.appendChild(bodyClone);\n                            proxy.appendChild(swimlaneClone);\n                        }\n                        // Column header\n                        else {\n                            proxy.appendChild(columnClone);\n                        }\n                        // Hide original column after measuring it above\n                        element.classList.add('b-drag-original');\n                    });\n                },\n                dragMove({ proxy, event, proxyOffset }) {\n                    // Move along x-axis only\n                    const position = EventHelper.getClientPoint(event).translate(proxyOffset[0], 0);\n                    proxy.style.left = `${position.x}px`;\n                }\n            }\n        };\n    }\n    setupDragContext(event) {\n        const\n            result = super.setupDragContext(event),\n            { client } = this.owner;\n        result.scrollManager = client.scrollManager;\n        result.monitoringConfig = {\n            scrollables : [{\n                element   : client.bodyElement,\n                direction : 'horizontal'\n            }]\n        };\n        return result;\n    }\n    // Populate the drag context early, to have something to take decisions on in beforeDragStart listeners\n    startDrag(drag) {\n        drag.columnRecord = this.owner.client.resolveColumnRecord(drag.itemElement);\n        return super.startDrag(drag);\n    }\n    dragStart(drag) {\n        // Even though the size of other columns should not be affected, we might decide to animate in the future.\n        // Suspending responsiveness to not have it kick in if we do...\n        this.owner.client.suspendResponsiveness();\n        drag.wasStarted = true;\n    }\n    dragEnter(drag) {\n        // Only accept columns\n        if (!drag.itemElement.matches(this.dragItemSelector)) {\n            return false;\n        }\n        // Create drop indicators on first enter\n        if (!drag.dropIndicators) {\n            // Need one indicator for each part of the column\n            drag.dropIndicators = drag.elements.map((element, i) => DomHelper.createElement({\n                className   : 'b-taskboard-column-drop-indicator',\n                elementData : {\n                    dropIndicator : true,\n                    // Tag along the element, to be able to return the drop indicator to its position for\n                    // invalid drop targets. NOTE: Currently not used\n                    element\n                },\n                // Use same size as dragged column had originally\n                style : {\n                    width  : element.originalWidth,\n                    height : element.originalHeight\n                }\n            }));\n            this.insertDropIndicators(drag, drag.columnRecord);\n        }\n    }\n    insertDropIndicators(drag, beforeColumnRecord) {\n        // Figure out insertion index among headers, will use same index within swimlanes\n        const\n            { client } = this.owner,\n            insertAt   = client.columns.indexOf(beforeColumnRecord);\n        // Insert all drop indicators\n        drag.dropIndicators.forEach((dropIndicator, i) => {\n            // Header\n            if (i === 0) {\n                // Insert at correct place among column headers\n                const\n                    headerContainer = DomSync.getChild(client.bodyElement, 'header'),\n                    actualHeaders   = [...headerContainer.children];\n                ArrayHelper.remove(actualHeaders, dropIndicator);\n                headerContainer.insertBefore(dropIndicator, actualHeaders[insertAt]);\n            }\n            // Column\n            else {\n                // Insert it at correct place within corresponding swimlane\n                const\n                    // Get corresponding swimlane (default if swimlanes not used)\n                    swimlaneRecord = client.swimlanes?.getAt(i - 1) ?? { domId : 'default' },\n                    swimlaneBody   = DomSync.getChild(client.getSwimlaneElement(swimlaneRecord), 'body'),\n                    actualColumns  = [...swimlaneBody.children];\n                ArrayHelper.remove(actualColumns, dropIndicator);\n                swimlaneBody.insertBefore(dropIndicator, actualColumns[insertAt]);\n            }\n        });\n    }\n    updateValidity(drag, valid) {\n        drag.proxy.classList.toggle('b-invalid', !valid);\n        drag.dropIndicators.forEach(dropIndicator => dropIndicator.classList.toggle('b-invalid', !valid));\n        drag.invalid = !valid;\n    }\n    dragMove(drag) {\n        const\n            { client }          = this.owner,\n            documentRoot        = client.documentRoot,\n            proxyBounds         = Rectangle.from(drag.proxy, undefined, true),\n            // Check element under proxy top center, should get a column header (or a gap)\n            overElement         = documentRoot.elementFromPoint(proxyBounds.center.x, proxyBounds.y),\n            columnHeaderElement = overElement?.closest('.b-taskboard-column-header');\n        if (drag.invalid) {\n            drag.valid = false;\n        }\n        // If we are over the drop indicator or something not a column header, we do nothing\n        if (!overElement?.elementData?.dropIndicator && columnHeaderElement) {\n            const targetBounds = Rectangle.from(columnHeaderElement);\n            // Column that we are going to insert the dragged column before or after\n            let beforeColumn = client.resolveColumnRecord(columnHeaderElement);\n            // If beyond center, insert before next column\n            if (proxyBounds.center.x > targetBounds.center.x) {\n                beforeColumn = client.columns.getNext(beforeColumn);\n            }\n            this.insertDropIndicators(drag, beforeColumn);\n            // Only trigger if order will change\n            const shouldTrigger = drag.beforeColumn !== beforeColumn;\n            drag.beforeColumn = beforeColumn;\n            if (shouldTrigger) {\n                /**\n                 * Fires on the owning TaskBoard when a column is dragged, if the drag leads to a change compared to\n                 * the last columnDrag event.\n                 *\n                 * Returning `false` from a listener will flag the drag as invalid (by default turning the drop\n                 * indicator red)\n                 *\n                 * ```javascript\n                 * const taskBoard = new TaskBoard({\n                 *    listeners : {\n                 *        // Do not allow moving beyond last column\n                 *        columnDrag({ columnRecord, beforeColumn }) {\n                 *           return beforeColumn === null;\n                 *        }\n                 *    }\n                 * });\n                 * ```\n                 *\n                 * @event columnDrag\n                 * @on-owner\n                 * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                 * @param {TaskBoard.model.ColumnModel} columnRecord Column being dragged\n                 * @param {TaskBoard.model.ColumnModel} beforeColumn Insert before this column on drop, `null` if last\n                 */\n                const result = client.trigger('columnDrag', { drag, columnRecord : drag.columnRecord, beforeColumn });\n                this.updateValidity(drag, result !== false);\n            }\n        }\n    }\n    async dragDrop(drag) {\n        // Data part\n        const\n            { client }  = this.owner,\n            { columns } = client,\n            {\n                columnRecord,\n                beforeColumn,\n                elements,\n                dropIndicators,\n                proxy\n            }           = drag;\n        /**\n         * Fires on the owning TaskBoard when dropping a column, before the operation completes. Handles async\n         * listeners, returning `false` from one will abort the operation\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        async beforeColumnDrop({ columnRecord, beforeColumn }) {\n         *            // Show confirmation dialog\n         *            const result = await MessageDialog.confirm({\n         *                title   : 'Verify drop',\n         *                message : `Please confirm moving ${columnRecord.text} before ${beforeColumn.text}?`\n         *            });\n         *\n         *            // Returning false will abort the drop (if user pressed Cancel)\n         *            return result === MessageDialog.okButton;\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event beforeColumnDrop\n         * @preventable\n         * @async\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.ColumnModel} columnRecord Dropped column\n         * @param {TaskBoard.model.ColumnModel} beforeColumn Dropped before this column\n         */\n        if (drag.invalid || await client.trigger('beforeColumnDrop', { drag, columnRecord, beforeColumn }) === false) {\n            drag.valid = false;\n        }\n        else {\n            drag.finalizer = new Promise(resolve => {\n                function commit() {\n                    // Remove proxy & dropIndicator\n                    proxy.remove();\n                    dropIndicators.forEach(dropIndicator => dropIndicator.remove());\n                    // Restore original elements\n                    elements.forEach(element => element.classList.remove('b-drag-original'));\n                    // Update data\n                    client.suspendDomTransition();\n                    beforeColumn !== undefined && columns.move(columnRecord, beforeColumn);\n                    client.resumeDomTransition();\n                    /**\n                     * Fires on the owning TaskBoard when a column is successfully dropped (after the drop transition\n                     * has finished)\n                     * @event columnDrop\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.ColumnModel} columnRecord Dropped column\n                     * @param {TaskBoard.model.ColumnModel} beforeColumn Dropped before this column (`null` if last)\n                     * @param {TaskBoard.model.SwimlaneModel} targetSwimlane Dropped in this swimlane (if used)\n                     */\n                    client.trigger('columnDrop', { drag, columnRecord, beforeColumn });\n                    /**\n                     * Fires on the owning TaskBoard when a previously started drag operation ends, no matter the\n                     * outcome of it (whether valid, invalid or aborted)\n                     *\n                     * @event columnDragEnd\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.ColumnModel} columnRecord Affected column\n                     */\n                    client.trigger('columnDragEnd', { drag, columnRecord, beforeColumn });\n                    client.resumeResponsiveness();\n                    resolve();\n                }\n                // UI part\n                // We are dropping, this cls by default has a transition\n                proxy.classList.add('b-dropping');\n                // Move proxy to drop location, allowing it to transition there\n                DomHelper.alignTo(\n                    proxy,\n                    Rectangle.from(dropIndicators[0], undefined, true)\n                );\n                // Update record after the transition, to prevent too early redraw (which would ruin the transition)\n                if (DomHelper.getPropertyTransitionDuration(proxy, 'transform')) {\n                    EventHelper.onTransitionEnd({\n                        element  : proxy,\n                        property : 'transform',\n                        handler  : commit,\n                        thisObj  : client\n                    });\n                }\n                // Or right away if no transition is used\n                else {\n                    commit();\n                }\n            });\n        }\n    }\n    dragLeave(drag) {\n        // Doing nothing feels ok for now\n    }\n    doAbort(drag) {\n        const\n            { client }                                        = this.owner,\n            { dropIndicators, proxy, columnRecord, elements } = drag;\n        if (proxy) {\n            function finalizeAbort() {\n                // Remove proxy & dropIndicator\n                proxy.remove();\n                dropIndicators.forEach(dropIndicator => dropIndicator.remove());\n                // Restore original elements\n                elements.forEach(element => element.classList.remove('b-drag-original'));\n                client.trigger('columnDragAbortFinalized');\n            }\n            // Emulate a drop on abort, to get transitions\n            proxy.classList.add('b-dropping');\n            // Move drop indicators to where column originated\n            dropIndicators.forEach((dropIndicator, i) => {\n                const original = drag.elements[i];\n                dropIndicator.classList.remove('b-invalid'); // Looks better if not invalid on return to origin\n                original.parentElement.insertBefore(dropIndicator, original);\n            });\n            // Move proxy to original location, allowing it to transition there\n            DomHelper.alignTo(\n                proxy,\n                Rectangle.from(dropIndicators[0], undefined, true)\n            );\n            // Finalize after transition\n            if (DomHelper.getPropertyTransitionDuration(proxy, 'transform')) {\n                EventHelper.onTransitionEnd({\n                    element  : proxy,\n                    property : 'transform',\n                    handler  : finalizeAbort,\n                    thisObj  : client // For timer cleanup\n                });\n            }\n            // Or right away if no transition is used\n            else {\n                finalizeAbort();\n            }\n        }\n        /**\n         * Fires on the owning TaskBoard when a drag operation is aborted (invalid drop or aborted using ESC)\n         *\n         * @event columnDragAbort\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.ColumnModel} columnRecord Dragged column\n         */\n        client.trigger('columnDragAbort', { drag, columnRecord });\n        if (drag.wasStarted) {\n            // Documented in dragDrop()\n            client.trigger('columnDragEnd', { drag, columnRecord });\n        }\n    }\n    dragEnd(drag) {\n        // Move back to original location when drag was aborted\n        if (!drag.valid || drag.aborted) {\n            this.doAbort(drag);\n        }\n    }\n}\nColumnDrag._$name = 'ColumnDrag';", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport ContextMenuBase from '../../Core/feature/base/ContextMenuBase.js';\n/**\n * @module TaskBoard/feature/ColumnHeaderMenu\n */\n/**\n * Adds a menu button (`\u00B7\u00B7\u00B7`) to column headers, clicking it displays a menu. Items are populated by other features\n * and/or application code.\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenu.js}\n *\n * ## Default items\n *\n * These are the default items provided by TaskBoard features:\n *\n * | Reference         | Weight | Feature                              | Description                   |\n * |-------------------|--------|--------------------------------------|-------------------------------|\n * | `addTask `        | 100    | *This feature*                       | Add a new task to this column |\n * | `moveColumnLeft`  | 200    | {@link TaskBoard.feature.ColumnDrag} | Move column one step left     |\n * | `moveColumnRight` | 300    | {@link TaskBoard.feature.ColumnDrag} | Move column one step right    |\n *\n * Default items in the menu can be changed or removed and new items can be added. This is handled using the\n * {@link #config-items} config of the feature.\n *\n * ## Add items\n *\n * Add menu items for all column headers by adding a key (used as menu item {@link Core/widget/Widget#config-ref}) with\n * a {@link Core/widget/MenuItem#configs config object for a menu item} as the value to the {@link #config-items} config:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         columnHeaderMenu : {\n *             items : {\n *                 flagTasks : {\n *                     text : 'Flag task',\n *                     icon : 'b-fa-fw b-fa-flag',\n *                     onItem({ columnRecord }) {\n *                         columnRecord.tasks.forEach(taskRecord => taskRecord.flagged = true);\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenuAdd.js}\n *\n * ## Remove items\n *\n * To remove default items, configure them as `null` in the {@link #config-items} config:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         columnHeaderMenu : {\n *             items : {\n *                 moveColumnLeft  : null,\n *                 moveColumnRight : null\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenuRemove.js}\n *\n * ## Customize items\n *\n * To customize default items, supply a new config object for them in the {@link #config-items} config. It will merge\n * with the default config object:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         columnHeaderMenu : {\n *             items : {\n *                 // Change the text of the \"Add new task\" item\n *                 addTask : {\n *                     text : 'New card'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenuCustomize.js}\n *\n * ## Manipulating items at runtime\n *\n * Manipulate items for all columns or specific columns at runtime by supplying a {@link #config-processItems} function:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         columnHeaderMenu : {\n *             // Process items before menu is shown\n *             processItems({ columnRecord, items }) {\n *                  // Push an extra item for the done column\n *                  if (columnRecord.id === 'done') {\n *                      items.archive = {\n *                          text : 'Archive',\n *                          icon : 'b-fa-fw b-fa-archive',\n *                          onItem({ columnRecord }) {\n *                              columnRecord.tasks.forEach(taskRecord => taskRecord.archived = true);\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show \"Add new task\" for the todo column\n *                  if (columnRecord.id === 'todo') {\n *                      items.addTask = null;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">The `processItems` implementation my be an `async` function which `awaits` a result to\n * mutate the `items` object.</div>\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenuProcessItems.js}\n *\n * This feature is **enabled** by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys           | Action                 | Action description                                     |\n * |----------------|------------------------|--------------------------------------------------------|\n * | `Space`        | *showContextMenuByKey* | Shows context menu for currently focused column header |\n * | `Ctrl`+`Space` | *showContextMenuByKey* | Shows context menu for currently focused column header |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#TaskBoard/guides/customization/keymap.md).\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype columnHeaderMenu\n * @feature\n */\nexport default class ColumnHeaderMenu extends ContextMenuBase {\n    static $name = 'ColumnHeaderMenu';\n    static type = 'columnHeaderMenu';\n    static configurable = {\n        /**\n         * A function called before displaying the menu that allows manipulations of its items.\n         * Returning `false` from this function prevents the menu from being shown.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *   features         : {\n         *       columnHeaderMenu : {\n         *           processItems({ columnRecord, items }) {\n         *              // Push an extra item for the todo column\n         *              if (columnRecord.id === 'todo') {\n         *                  items.finishAll = {\n         *                      text : 'Finish all',\n         *                      icon : 'b-fa-fw b-fa-check'\n         *                      onItem({ columnRecord }) {\n         *                          columnRecord.tasks.forEach(taskRecord => taskRecord.status = 'done');\n         *                      }\n         *                  };\n         *               }\n         *           }\n         *       }\n         *   }\n         * });\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} context An object with information about the menu being shown\n         * @param {TaskBoard.model.ColumnModel} context.columnRecord The column for which the menu will be shown\n         * @param {Object<String,MenuItemConfig|Boolean>} context.items An object containing the\n         *   {@link Core.widget.MenuItem menu item} configs keyed by their id\n         * @param {Event} context.event The DOM event object that triggered the show\n         * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n         * @preventable\n         */\n        processItems : null,\n        /**\n         * This is a preconfigured set of items used to create the default context menu.\n         *\n         * The `items` provided by this feature are listed in the intro section of this class. You can configure\n         * existing items by passing a configuration object to the keyed items.\n         *\n         * To remove existing items, set corresponding keys `null`:\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         columnHeaderMenu : {\n         *             items : {\n         *                 addTask : null\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * See the class description for more examples.\n         *\n         * @config {Object<string,MenuItemConfig|Boolean|null>} items\n         */\n        items : null,\n        menu : {\n            anchor : true\n        },\n        type : 'columnHeader',\n        triggerEvent : false\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>>} keyMap\n         */\n        /**\n         * @hideconfigs type, triggerEvent\n         */\n    };\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n        config.chain.push(...['populateColumnHeaderMenu', 'populateColumnHeader', 'onColumnHeaderClick']);\n        return config;\n    }\n    //region Events\n    /**\n     * This event fires on the owning TaskBoard before the menu is shown for a column header.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event columnHeaderMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<string,MenuItemConfig>} items Menu item configs\n     * @param {TaskBoard.model.ColumnModel} columnRecord The column\n     * @on-owner\n     */\n    /**\n     * This event fires on the owning TaskBoard after the context menu is shown for a column header.\n     * @event cellMenuShow\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<string,MenuItemConfig>} items Menu item configs\n     * @param {TaskBoard.model.ColumnModel} columnRecord The column\n     * @on-owner\n     */\n    /**\n     * This event fires on the owning TaskBoard when an item is selected in the column header menu.\n     * @event cellMenuItem\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {TaskBoard.model.ColumnModel} columnRecord The column\n     * @on-owner\n     */\n    /**\n     * This event fires on the owning TaskBoard when a check item is toggled in the column header menu.\n     * @event cellMenuToggleItem\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {TaskBoard.model.ColumnModel} columnRecord The column\n     * @param {Boolean} checked Checked or not\n     * @on-owner\n     */\n    //endregion\n    //region Type assertions\n    changeItems(items) {\n        ObjectHelper.assertObject(items, 'features.columnHeaderMenu.items');\n        return items;\n    }\n    changeProcessItems(fn) {\n        ObjectHelper.assertFunction(fn, 'features.columnHeaderMenu.processItems');\n        return fn;\n    }\n    //endregion\n    // Inject a \"button\" into column headers\n    populateColumnHeader({ columnHeaderConfig }) {\n        if (!this.disabled) {\n            columnHeaderConfig.children.padder.children.menu = {\n                tag   : 'button',\n                class : {\n                    'b-column-header-button'                : 1,\n                    'b-taskboard-column-header-menu-button' : 1,\n                    'b-fw-icon'                             : 1,\n                    'b-icon-menu-horizontal'                : 1\n                }\n            };\n        }\n    }\n    // Populate menu events with taskboard specifics\n    getDataFromEvent(event) {\n        return ObjectHelper.assign(super.getDataFromEvent(event), event.taskBoardData);\n    }\n    // Add default menu items\n    populateColumnHeaderMenu({ items, columnRecord }) {\n        const { client } = this;\n        if (!client.readOnly) {\n            items.addTask = {\n                text   : 'L{TaskBoard.addTask}',\n                icon   : 'b-fw-icon b-icon-add',\n                weight : 100,\n                onItem() {\n                    client.addTask(columnRecord);\n                }\n            };\n        }\n    }\n    // Detect \"button\" click\n    onColumnHeaderClick(args) {\n        const { event } = args;\n        if (event.target.matches('.b-column-header-button')) {\n            this.showContextMenu(event, { target : event.target, align : 't90-b90' });\n        }\n    }\n    doDisable(disable) {\n        super.doDisable(disable);\n        !this.isConfiguring && this.client.recompose();\n    }\n    get showMenu() {\n        return true;\n    }\n}\n// Register this feature type with its Factory\nTaskBoardFeature.register(ColumnHeaderMenu.type, ColumnHeaderMenu);\nColumnHeaderMenu._$name = 'ColumnHeaderMenu';", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport '../../Core/widget/Toolbar.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardFeature from './TaskBoardFeature.js';\n/**\n * @module TaskBoard/feature/ColumnToolbars\n */\n/**\n * Adds toolbars to the top and/or bottom of each column. By default it adds a bottom toolbar containing a single button\n * for adding events to that column/swimlane:\n *\n * {@inlineexample TaskBoard/feature/ColumnToolbars.js}\n *\n * To add, remove or modify toolbar items for all columns, see {@link #config-topItems} and {@link #config-bottomItems}:\n *\n * {@inlineexample TaskBoard/feature/ColumnToolbarsAdd.js}\n *\n * To have per column/swimlane control over the items, see {@link #config-processItems}:\n *\n * {@inlineexample TaskBoard/feature/ColumnToolbarsProcess.js}\n *\n * In handlers for buttons etc, you can access which column/swimlane the action was taken in on the supplied `source`\n * param, using its `columnRecord` and `swimlaneRecord` properties:\n *\n * ```javascript\n * new TaskBoard({\n *    features : {\n *        columnToolbars : {\n *            topItems : {\n *                clearButton : {\n *                    icon    : 'b-fa-trash',\n *                    onClick({ source }) {\n *                        if (source.columnRecord) {\n *                            ...\n *                        }\n *                    }\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * This feature is **enabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype columnToolbars\n * @feature\n */\nexport default class ColumnToolbars extends TaskBoardFeature {\n    static $name = 'ColumnToolbars';\n    static type = 'columnToolbars';\n    static configurable = {\n        /**\n         * Items to add to the top toolbar, in object format.\n         *\n         *\n         * ```javascript\n         * new TaskBoard({\n         *    features : {\n         *        columnToolbars : {\n         *            topItems : {\n         *                clearButton : {\n         *                    icon    : 'b-fa-trash',\n         *                    onClick : ...\n         *                }\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Object<String,ContainerItemConfig|Boolean|null>}\n         */\n        topItems : null,\n        /**\n         * Items to add to the bottom toolbar, in object format.\n         *\n         * To remove existing items, set corresponding keys to `null`.\n         *\n         * ```javascript\n         * new TaskBoard({\n         *    features : {\n         *        columnToolbars : {\n         *            bottomItems : {\n         *                clearButton : {\n         *                    icon    : 'b-fa-trash',\n         *                    onClick : ...\n         *                }\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Object<String,ContainerItemConfig|Boolean|null>}\n         */\n        bottomItems : {\n            addTask : true\n        },\n        // Predefined items that can be used in topItems and/or bottomItems\n        namedItems : {\n            addTask : {\n                type              : 'button',\n                icon              : 'b-icon-add',\n                tooltip           : 'L{TaskBoard.addTask}',\n                ariaLabel         : 'L{TaskBoard.addTask}',\n                internalListeners : {\n                    click : 'onAddClick'\n                }\n            }\n        },\n        /**\n         * A function called before displaying the toolbar that allows manipulations of its items.\n         * Returning `false` from this function prevents the menu being shown.\n         *\n         * ```javascript\n         * features         : {\n         *    columnToolbars : {\n         *         processItems({ items, location, columnRecord, swimlaneRecord }) {\n         *             // Add or hide existing items here as needed\n         *             items.myAction = {\n         *                 text   : 'Cool action',\n         *                 icon   : 'b-fa-ban',\n         *                 onClick : () => console.log(`Clicked button for ${columnRecord.text}`)\n         *             };\n         *\n         *            if (columnRecord.id === 'done') {\n         *                items.addTask = false\n         *            }\n         *         }\n         *     }\n         * },\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} context An object with information about the toolbar being shown\n         * @param {Object<String,ContainerItemConfig>} context.items An object containing the toolbar item configs keyed by ref\n         * @param {'top'|'bottom'} context.location Toolbar location, \"top\" or \"bottom\"\n         * @param {TaskBoard.model.ColumnModel} context.columnRecord Record representing toolbars column\n         * @param {TaskBoard.model.SwimlaneModel} context.swimlaneRecord Record representing toolbars swimlane\n         * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n         * @preventable\n         */\n        processItems : null\n    };\n    // Holds exising toolbars, keyed by location, column and swimlane\n    columnMap = new Map();\n    static pluginConfig = {\n        chain : ['populateColumn', 'onRemoveColumnElement', 'onRemoveSwimlaneElement']\n    };\n    doDestroy() {\n        for (const [, toolbar] of this.columnMap) {\n            toolbar.destroy();\n        }\n        super.doDestroy();\n    }\n    //region Type assertions\n    changeTopItems(items) {\n        ObjectHelper.assertObject(items, 'features.columnToolbars.topItems');\n        return items;\n    }\n    changeBottomItems(items) {\n        ObjectHelper.assertObject(items, 'features.columnToolbars.bottomItems');\n        return items;\n    }\n    changeProcessItems(fn) {\n        ObjectHelper.assertFunction(fn, 'features.columnToolbars.processItems');\n        return fn;\n    }\n    //endregion\n    //region Toolbars\n    // removeToolbar(location) {\n    //     const columnMap = this.columnMap;\n    //\n    //     for (const [key, toolbar] of columnMap) {\n    //         if (key.startsWith(location)) {\n    //             toolbar.destroy();\n    //             columnMap.delete(toolbar);\n    //         }\n    //     }\n    // }\n    //\n    // changeTopItems(items, old) {\n    //     if (old && !items) {\n    //         this.removeToolbar('top');\n    //     }\n    //\n    //     return items;\n    // }\n    //\n    // changeBottomItems(items, old) {\n    //     if (old && !items) {\n    //         this.removeToolbar('items');\n    //     }\n    //\n    //     return items;\n    // }\n    // Creates or retrieves a toolbar instance for the requested column/swimlane intersection\n    getToolbar(location, columnRecord, swimlaneRecord) {\n        const\n            me                                = this,\n            { columnMap, client, namedItems } = me,\n            items                             = me[`${location}Items`],\n            key                               = `${location}_._${columnRecord.domId}_._${swimlaneRecord?.domId ?? 'default'}`;\n        let toolbar = columnMap.get(key);\n        if (!toolbar) {\n            const clonedItems = {};\n            // items allows configuring out using falsy value, only iterate the truthy ones\n            ObjectHelper.getTruthyKeys(items).map(ref => {\n                const\n                    // Could match a named item, to either be used as is or use reconfigured\n                    namedItem = namedItems[ref],\n                    // Item config or a truthy value to include a named item as is\n                    item      = items[ref];\n                clonedItems[ref] = ObjectHelper.merge(\n                    // Default listeners + decorate with records\n                    {\n                        internalListeners : {\n                            click   : 'onClick',\n                            change  : 'onChange',\n                            thisObj : me\n                        },\n                        columnRecord,\n                        swimlaneRecord\n                    },\n                    // Merge with any matched named item\n                    namedItem,\n                    // And any supplied config\n                    item\n                );\n            });\n            // Allow client code to alter items before adding them to the toolbar\n            if (me.processItems?.({ items : clonedItems, location, columnRecord, swimlaneRecord }) === false) {\n                return null;\n            }\n            // Create toolbar using the processed items\n            toolbar = client.add({\n                type                      : 'toolbar',\n                cls                       : `b-taskboard-column-${location[0]}bar`,\n                overflow                  : null,\n                monitorResize             : false,\n                contentElMutationObserver : false,\n                items                     : clonedItems,\n                dataset                   : {\n                    role          : `${location}-toolbar`,\n                    domTransition : true\n                }\n            });\n            columnMap.set(key, toolbar);\n        }\n        return toolbar.element;\n    }\n    populateColumn({ columnConfig, columnRecord, swimlaneRecord }) {\n        const me = this;\n        if (!me.disabled) {\n            // Add top toolbar, if it has items\n            if (ObjectHelper.getTruthyKeys(me.topItems).length) {\n                DomHelper.merge(columnConfig, {\n                    children : {\n                        'tbar > body' : me.getToolbar('top', columnRecord, swimlaneRecord)\n                    }\n                });\n            }\n            // Add bottom toolbar, if it has items\n            if (ObjectHelper.getTruthyKeys(me.bottomItems).length) {\n                columnConfig.children.bbar = me.getToolbar('bottom', columnRecord, swimlaneRecord);\n            }\n        }\n    }\n    removeColumnToolbar(location, columnId, swimlaneId) {\n        const\n            { columnMap, client } = this,\n            key                   = `${location}_._${columnId}_._${swimlaneId}`,\n            toolbar               = columnMap.get(key);\n        if (toolbar) {\n            client.remove(toolbar);\n            // Toolbar gets removed during a compose, which leads to a race condition with syncOverflowVisibility.\n            // Postpone destroy til after compose to avoid this\n            client.setTimeout(() => toolbar.destroy(), 0);\n            columnMap.delete(key);\n        }\n    }\n    removeColumnToolbars(columnId, swimlaneId) {\n        this.removeColumnToolbar('top', columnId, swimlaneId);\n        this.removeColumnToolbar('bottom', columnId, swimlaneId);\n    }\n    onRemoveColumnElement({ columnId, swimlaneRecord }) {\n        this.removeColumnToolbars(columnId, swimlaneRecord.id ?? 'default');\n    }\n    onRemoveSwimlaneElement({ swimlaneId }) {\n        for (const column of this.client.columns) {\n            this.removeColumnToolbars(column.id, swimlaneId);\n        }\n    }\n    //endregion\n    //region Predefined items events\n    onAddClick({ source }) {\n        this.client.addTask(source.columnRecord, source.swimlaneRecord);\n    }\n    //endregion\n    //region Generic events\n    onChange({ source }) {\n        this.trigger('itemChange', {\n            item           : source,\n            columnRecord   : source.columnRecord,\n            swimlaneRecord : source.swimlaneRecord\n        });\n    }\n    onClick({ source }) {\n        this.trigger('itemClick', {\n            item           : source,\n            columnRecord   : source.columnRecord,\n            swimlaneRecord : source.swimlaneRecord\n        });\n    }\n    //endregion\n}\nColumnToolbars.initClass();\nColumnToolbars._$name = 'ColumnToolbars';", "import Base from '../../../Core/Base.js';\nimport Factoryable from '../../../Core/mixin/Factoryable.js';\n/**\n * @module TaskBoard/view/item/TaskItem\n */\n/**\n * Config options for all TaskItems combined. See respective item classes for more information.\n * @typedef {Object} TaskItemOptions\n * @property {String} type Type of the item\n * @property {String} [field] Field to display in the item. Usually inferred from the key when supplying items\n * @property {String|Object} [style] Style definition in string or object form\n * @property {String} [cls] CSS class to add\n * @property {Number} [order] Flex order, can be used to re-order task items\n * @property {Boolean} [hidden] Specify `true` to hide the task item\n * @property {String|Object} [editor] Widget type or config to use as the editor for this item. Used in the inline task\n * editor. Set to `null` to not use an editor for this item\n * @property {String} [baseUrl] For `type : 'image'` - Url prepended to this items value\n * @property {Function} [template] For `type : 'template'` - Template function used to generate task content\n * @property {Number} [max] For `type : 'progress'` and `type : 'rating'` - Max value\n * @property {String} [textField] For `type : 'todoList'` - Name of a property on a todo item to display as its text\n * @property {String} [checkedField] For `type : 'todoList'` - Name of a property on a todo item to use for the checkbox\n * @property {String} [clsField] For `type : 'todoList'` - Name of a property on a todo item whose value will be added\n * as a CSS class to the todo item\n * @property {Number} [maxAvatars] For `type : 'resourceAvatars'` - Maximum avatars to display by default.\n * @property {Boolean} [overlap] For `type : 'resourceAvatars'` - Specify `true` to slightly overlap avatars for tasks\n * @property {String} [textProperty] For `type : 'tags'` - Property used to display the tag text\n * @property {String} [clsProperty] For `type : 'tags'` - Property used to add a CSS class to each tag\n * @property {String} [separator] For `type : 'tags'` - Property used to split a value string into tags\n */\n/**\n * Abstract base class for task items, lightweight \"widgets\" that can be added to tasks using the\n * {@link TaskBoard/view/TaskBoard#config-headerItems}, {@link TaskBoard/view/TaskBoard#config-bodyItems} and\n * {@link TaskBoard/view/TaskBoard#config-footerItems} configs.\n *\n * @abstract\n */\nexport default class TaskItem extends Base.mixin(Factoryable) {\n    static factoryable = {};\n    static configurable = {\n        /**\n         * Task field whose value item will act on (usually display it). Defaults to use the key in the items object.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    features : {\n         *        taskItems : {\n         *            items : {\n         *                // Will use \"prio\" as its field\n         *                prio  : { type : 'textitem' },\n         *                // Will use \"status\" as its field\n         *                state : { type : 'textitem', field : 'status' }\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {String} field\n         * @category Common\n         */\n        /**\n         * Style definition in string or object form.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    features : {\n         *        taskItems : {\n         *            items : {\n         *                prio  : { type : 'textitem', style : { color : 'red' } }\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {String|Object} style\n         * @category Common\n         */\n        /**\n         * Specify `true` to hide the task item.\n         *\n         * @config {Boolean} hidden\n         * @category Common\n         */\n        /**\n         * Flex order, can be used to re-order task items.\n         *\n         * @config {Number} order\n         * @default 1\n         * @category Common\n         */\n        /**\n         * CSS class to add.\n         *\n         * @config {String} cls\n         * @category Common\n         */\n        /**\n         * Widget type or config to use as the editor for this item. Used in the inline task editor.\n         * Set to `null` to not use an editor for this item.\n         *\n         * @config {String|Object} editor\n         * @default text\n         * @category Common\n         */\n    };\n    static defaultEditor = { type : 'text' };\n    static getEditorConfig({ config, item }) {\n        const editor = config.editor !== null && (config.editor || item.defaultEditor);\n        if (typeof editor === 'string') {\n            return {\n                type : editor\n            };\n        }\n        return editor;\n    }\n}\nTaskItem._$name = 'TaskItem';", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport TaskItem from '../view/item/TaskItem.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Editor from '../../Core/widget/Editor.js';\nconst actions = {\n    editNext     : 1,\n    cancel       : 1,\n    editPrevious : 1,\n    complete     : 1\n};\n/**\n * @module TaskBoard/feature/SimpleTaskEdit\n */\n/**\n * This feature allows inline editing of tasks. Double clicking an item starts editing it:\n *\n * {@inlineexample TaskBoard/feature/SimpleTaskEdit.js}\n *\n * Each {@link TaskBoard.view.item.TaskItem task item} can define an\n * {@link TaskBoard.view.item.TaskItem#config-editor}. To prevent an item from being edited inline, configure it with\n * `editor : null`:\n *\n * {@inlineexample TaskBoard/feature/SimpleTaskEditCustom.js}\n *\n * This feature is **disabled** by default.\n *\n * {@region Keyboard shortcuts}\n * The feature has the following default keyboard shortcuts:\n *\n * | Keys            | Action         | Action description                                                                   |\n * |-----------------|----------------|--------------------------------------------------------------------------------------|\n * | `Enter`         | *editNext*     | In an editor this will accept the change and start editing the next item on that card or the first item on the next card. By default it adds a new task when pressed on the last item of the last card in a column. This behaviour is configurable using the {@link #config-addNewAtEnd} config. |\n * | `Escape`        | *cancel*       | Cancels editing and reverts changes for that item which is currently being edited    |\n * | `Shift`+`Enter` | *editPrevious* | In an editor this will accept the change and start editing the previous item on that card or the last item on the previous card |\n * | `Ctrl`+`Enter`  | *complete*     | Accepts the edit and closes the editor                                               |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#TaskBoard/guides/customization/keymap.md).\n * {@endregion}\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype simpleTaskEdit\n * @feature\n */\nexport default class SimpleTaskEdit extends TaskBoardFeature {\n    static $name = 'SimpleTaskEdit';\n    static type = 'simpleTaskEdit';\n    static configurable = {\n        /**\n         * Pressing `Enter` in last item on last task in a column adds a new task.\n         * @config {Boolean}\n         * @default\n         */\n        addNewAtEnd : true,\n        /**\n         * A configuration object for the {@link Core.widget.Editor} used by this feature. Useful when you want to\n         * validate the value being set by the end user (see {@link Core.widget.Editor#event-beforeComplete}).\n         *\n         * @config {EditorConfig}\n         */\n        editorConfig : {},\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            Enter         : 'editNext',\n            Escape        : 'cancel',\n            'Ctrl+Enter'  : 'complete',\n            'Shift+Enter' : 'editPrevious'\n        }\n    };\n    static pluginConfig = {\n        assign : ['editTask'],\n        before : ['onActivateTask']\n    };\n    //region Type assertions\n    changeAddNewAtEnd(addNewAtEnd) {\n        ObjectHelper.assertBoolean(addNewAtEnd, 'features.simpleTaskEdit.addNewAtEnd');\n        return addNewAtEnd;\n    }\n    //endregion\n    /**\n     * Starts inline editing of the supplied task, optionally for a specific item on its card.\n     * @on-owner\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record to edit\n     * @param {HTMLElement} [element] Card element or card item element to edit. Resolves element from the passed record\n     * if left out.\n     * @returns {Boolean} Returns `true` if editing started, `false` if it did not.\n     */\n    editTask(taskRecord, element) {\n        const\n            me        = this,\n            taskBoard = me.client;\n        // Get element from record if none supplied\n        if (!element) {\n            element = taskBoard.getTaskElement(taskRecord);\n        }\n        const\n            // Get a task item from the element, will yield first task item when given the card element\n            taskItem         = taskBoard.resolveTaskItem(element),\n            itemElement      = taskItem.element,\n            itemEditorConfig = TaskItem.getEditorConfig(taskItem);\n        // Allow disabling editing for an item using `editor : null`\n        if (!itemEditorConfig) {\n            return false;\n        }\n        /**\n         * Fires on the owning TaskBoard before displaying an inline editor. Returning `false` stops the editor from\n         * being shown.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        beforeSimpleTaskEdit({ taskRecord }) {\n         *            // Some condition for which editing should be blocked...\n         *            if (taskRecord.disallowed) {\n         *                return false;\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event beforeSimpleTaskEdit\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source The task board\n         * @param {TaskBoard.feature.SimpleTaskEdit} simpleTaskEdit The simpleTaskEdit feature\n         * @param {TaskBoard.model.TaskModel} taskRecord The record about to be shown in the editor\n         * @param {String} field Field name being edited\n         */\n        // Give clients a shot at preventing editing\n        if (\n            me.disabled || taskRecord.readOnly ||\n            taskBoard.trigger('beforeSimpleTaskEdit', { simpleTaskEdit : me, taskRecord, field : taskItem.config.field }) === false\n        ) {\n            return true;\n        }\n        // Focus the card to ensure focus reverts to it when editor closes\n        element.focus();\n        const editor = me.editor = Editor.new({\n            owner        : taskBoard,\n            appendTo     : itemElement.parentNode,\n            scrollAction : 'realign',\n            cls          : 'b-simple-task-editor',\n            completeKey  : null,\n            cancelKey    : null,\n            inputField   : {\n                autoSelect : true,\n                name       : taskItem.config.field,\n                ...itemEditorConfig\n            },\n            align : {\n                align          : 'c-c',\n                allowTargetOut : false\n            },\n            internalListeners : {\n                complete   : 'onEditorComplete',\n                cancel     : 'onEditorCancel',\n                finishEdit : 'onEditorFinishEdit',\n                thisObj    : me\n            }\n        }, me.editorConfig);\n        // Store active element, to be able to navigate to next/prev later if requested\n        me.currentElement = itemElement;\n        // Add editing cls, will be cleared by recompose\n        itemElement.classList.add('b-editing');\n        // Match editor color to item color\n        const color = DomHelper.getStyleValue(itemElement, 'color');\n        editor.element.style.color = color;\n        editor.inputField.element.style.color = color;\n        // Don't want a recompose removing editor element\n        editor.element.retainElement = true;\n        // Scrolling card into view\n        taskBoard.getTaskElement(taskRecord).scrollIntoView({\n            block : 'nearest'\n        });\n        // And then item being edited. Two steps since first one won't do anything if card is already in view while item\n        // is not\n        itemElement.scrollIntoView({\n            block : 'nearest'\n        });\n        editor.startEdit({\n            target : taskItem.element,\n            record : taskRecord,\n            field  : taskItem.config.field\n        });\n        return true;\n    }\n    // Edit previous task item\n    async editPrevious(event) {\n        const\n            me                 = this,\n            { client, editor } = me,\n            taskRecord         = editor.record,\n            cardElement        = client.getTaskElement(taskRecord),\n            itemElements       = Array.from(cardElement.querySelectorAll('.b-taskboard-taskitem.b-editable')),\n            index              = itemElements.indexOf(me.currentElement) - 1;\n        if (await me.complete(event)) {\n            // More items on the card, edit prev item\n            if (index >= 0) {\n                me.editTask(taskRecord, itemElements[index]);\n            }\n            // No more items\n            else {\n                const prevTaskRecord = client.getPreviousTask(taskRecord, false);\n                // Edit last item of prev card\n                if (prevTaskRecord) {\n                    const\n                        prevCardElement  = client.getTaskElement(prevTaskRecord),\n                        prevItemElements = Array.from(prevCardElement.querySelectorAll('.b-taskboard-taskitem.b-editable'));\n                    me.editTask(prevTaskRecord, prevItemElements[prevItemElements.length - 1]);\n                }\n            }\n        }\n    }\n    // Edit next task item\n    async editNext(event) {\n        const\n            me                 = this,\n            { client, editor } = me,\n            taskRecord         = editor.record,\n            cardElement        = client.getTaskElement(taskRecord),\n            itemElements       = Array.from(cardElement.querySelectorAll('.b-taskboard-taskitem.b-editable')),\n            index              = itemElements.indexOf(me.currentElement) + 1;\n        if (await me.complete(event)) {\n            // More items on the card, edit next item\n            if (index < itemElements.length) {\n                me.editTask(taskRecord, itemElements[index]);\n            }\n            // No more items\n            else {\n                const nextTaskRecord = client.getNextTask(taskRecord, false);\n                // Edit next card\n                if (nextTaskRecord) {\n                    me.editTask(nextTaskRecord);\n                }\n                // Or add a new card\n                else if (me.addNewAtEnd) {\n                    client.addTask(client.getColumn(taskRecord), client.getSwimlane(taskRecord));\n                }\n            }\n        }\n    }\n    complete(event) {\n        return this.editor.completeEdit(null, event);\n    }\n    cancel(event) {\n        this.editor.cancelEdit(event);\n    }\n    // Start editing when activating task (enter/dblclick)\n    onActivateTask({ taskRecord, event }) {\n        if (this.editTask(taskRecord, event.target)) {\n            // Block other actions (TaskEdit)\n            event.preventDefault();\n        }\n    }\n    onEditorComplete({ source }) {\n        /**\n         * Fires on the owning TaskBoard when inline editing of a field has successfully finished.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        simpleTaskEditComplete({ taskRecord, field }) {\n         *            Toast.show(`Finished editing ${field} of ${taskRecord.name}`);\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event simpleTaskEditComplete\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source The task board\n         * @param {TaskBoard.feature.SimpleTaskEdit} simpleTaskEdit The simpleTaskEdit feature\n         * @param {TaskBoard.model.TaskModel} taskRecord Record that was edited\n         * @param {String} field Field name being edited\n         */\n        this.client.trigger('simpleTaskEditComplete', { simpleTaskEdit : this, taskRecord : source.record, field : source.dataField  });\n    }\n    onEditorCancel({ source }) {\n        /**\n         * Fires on the owning TaskBoard when inline editing of a field is cancelled (by pressing ESC).\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        simpleTaskEditCancel({ taskRecord }) {\n         *            Toast.show(`Aborted editing of ${taskRecord.name}`);\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event simpleTaskEditCancel\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source The task board\n         * @param {TaskBoard.feature.SimpleTaskEdit} simpleTaskEdit The simpleTaskEdit feature\n         * @param {TaskBoard.model.TaskModel} taskRecord Record that was edited\n         * @param {String} field Field name being edited\n         */\n        this.client.trigger('simpleTaskEditCancel', { simpleTaskEdit : this, taskRecord : source.record, field : source.dataField  });\n    }\n    onEditorFinishEdit() {\n        // Have to store editor before the timeout, might get replaced by new\n        const\n            me = this,\n            { editor } = me;\n        editor?.setTimeout(() => {\n            // Don't retain the element if we did not start editing something else\n            if (me.editor === editor) {\n                me.currentElement = null;\n                me.editor = null;\n            }\n            editor.destroy();\n        }, 0);\n    }\n    // All keyMap actions require that we are editing\n    isActionAvailable({ actionName }) {\n        if (actions[actionName]) {\n            return Boolean(this.editor);\n        }\n    }\n}\nSimpleTaskEdit.initClass();\nSimpleTaskEdit._$name = 'SimpleTaskEdit';", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport Base from '../../Core/Base.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Draggable from '../../Core/mixin/Draggable.js';\nimport Droppable from '../../Core/mixin/Droppable.js';\n/**\n * @module TaskBoard/feature/SwimlaneDrag\n */\n/**\n * This feature allows users to drag drop swimlanes on the TaskBoard changing their order (by grabbing their header).\n *\n * {@inlineexample TaskBoard/feature/SwimlaneDrag.js}\n *\n * This feature is **disabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype swimlaneDrag\n * @feature\n */\nexport default class SwimlaneDrag extends TaskBoardFeature {\n    static $name = 'SwimlaneDrag';\n    static type = 'swimlaneDrag';\n    static pluginConfig = {\n        after : ['initialCompose']\n    };\n    initialCompose() {\n        const me     = this;\n        // Cannot use configurable since bodyElement is not available yet when feature is pulled in\n        me.draggable = SwimlaneZone.new({\n            dragRootElement : me.disabled ? null : me.client.bodyWrapElement,\n            dropRootElement : me.client.bodyWrapElement,\n            owner           : me\n        }, me.draggable);\n    }\n    doDisable(disable) {\n        super.doDisable(disable);\n        if (this.draggable) {\n            this.draggable.dragRootElement = disable ? null : this.client.bodyWrapElement;\n        }\n    }\n}\nSwimlaneDrag.initClass();\nclass SwimlaneZone extends Base.mixin(Draggable, Droppable) {\n    static get configurable() {\n        return {\n            dragSelector     : '.b-taskboard-swimlane-header, .b-taskboard-swimlane-header *',\n            dragItemSelector : '.b-taskboard-swimlane-header',\n            draggingItemCls : null,\n            dragProxy : {\n                type : 'default',\n                async open(drag) {\n                    const\n                        { owner }       = this,\n                        {\n                            itemElement,\n                            startEvent\n                        }               = drag,\n                        taskBoard       = owner.owner.client,\n                        swimlaneRecord  = taskBoard.resolveSwimlaneRecord(itemElement),\n                        swimlaneElement = taskBoard.getSwimlaneElement(swimlaneRecord),\n                        padding         = DomHelper.getStyleValue(\n                            swimlaneElement.syncIdMap.body,\n                            ['padding-left', 'padding-right']\n                        ),\n                        bounds          = Rectangle.from(swimlaneElement, owner.dragRootElement).deflate(\n                            0,\n                            parseFloat(padding['padding-right']),\n                            0,\n                            parseFloat(padding['padding-left'])\n                        ),\n                        // Offset from cursor\n                        proxyOffset     = EventHelper.getClientPoint(startEvent).getDelta(bounds),\n                        // Drag proxy, positioned over column being dragged\n                        proxy           = DomHelper.createElement({\n                            className : 'b-taskboard-swimlane-drag-proxy',\n                            parent    : owner.dragRootElement,\n                            style     : {\n                                // Using fixed top, only draggable horizontally\n                                top   : EventHelper.getClientPoint(startEvent).translate(0, proxyOffset[1]).y,\n                                // Offset from cursor to be positioned over original column\n                                left  : bounds.x,\n                                // Need a fixed height on the proxy, since columns width might be flexed etc\n                                width : bounds.width\n                            },\n                            // Don't want it being removed while dragging\n                            retainElement : true\n                        });\n                    // Things we want to access later on drag\n                    Object.assign(drag, {\n                        proxy,\n                        swimlaneRecord,\n                        swimlaneElement,\n                        proxyOffset,\n                        // Used to size dropIndicator\n                        bounds\n                    });\n                    // Clone all dragged column elements and put them in the proxy\n                    const swimlaneClone = swimlaneElement.cloneNode(true);\n                    proxy.appendChild(swimlaneClone);\n                },\n                dragMove({ proxy, event, proxyOffset }) {\n                    // Move along y-axis only\n                    const position = EventHelper.getClientPoint(event).translate(0, proxyOffset[1]);\n                    proxy.style.top = `${position.y}px`;\n                }\n            }\n        };\n    }\n    setupDragContext(event) {\n        const\n            result = super.setupDragContext(event),\n            { client } = this.owner;\n        result.scrollManager = client.scrollManager;\n        result.monitoringConfig = {\n            scrollables : [{\n                element   : client.bodyElement,\n                direction : 'vertical'\n            }]\n        };\n        return result;\n    }\n    dragStart(drag) {\n        // Trigger something...\n    }\n    dragEnter(drag) {\n        // Only accept swimlanes\n        if (!drag.itemElement.matches(this.dragItemSelector)) {\n            return false;\n        }\n        // Create drop indicators on first enter\n        if (!drag.dropIndicator) {\n            const { bounds } = drag;\n            // Need one indicator for each part of the column\n            drag.dropIndicator = DomHelper.createElement({\n                className   : 'b-taskboard-swimlane-drop-indicator',\n                elementData : {\n                    dropIndicator : true\n                },\n                // Use same size as dragged column had originally\n                style : {\n                    width  : bounds.width,\n                    height : bounds.height\n                }\n            });\n            this.insertDropIndicator(drag.dropIndicator, drag.swimlaneRecord);\n            drag.swimlaneElement.classList.add('b-drag-original');\n        }\n    }\n    insertDropIndicator(dropIndicator, beforeSwimlaneRecord) {\n        const { client } = this.owner;\n        client.bodyElement.insertBefore(\n            dropIndicator,\n            beforeSwimlaneRecord && client.getSwimlaneElement(beforeSwimlaneRecord)\n        );\n    }\n    async dragMove(drag) {\n        const\n            { client }       = this.owner,\n            { documentRoot } = client,\n            taskBoardBounds  = Rectangle.from(client.element, undefined, true),\n            proxyBounds      = Rectangle.from(drag.proxy, undefined, true),\n            // Check element under proxy left center, should get a swimlane (or a gap)\n            overElement      = proxyBounds.center.y > taskBoardBounds.bottom\n                ? documentRoot.elementFromPoint(proxyBounds.x, proxyBounds.y)\n                : documentRoot.elementFromPoint(proxyBounds.x, proxyBounds.center.y),\n            swimlaneElement  = overElement?.closest('.b-taskboard-swimlane');\n        // If we are over the drop indicator or something not a column header, we do nothing\n        if (!overElement?.elementData?.dropIndicator && swimlaneElement) {\n            const targetBounds = Rectangle.from(swimlaneElement, undefined, true);\n            // Column that we are going to insert the dragged column before or after\n            let beforeSwimlane = client.resolveSwimlaneRecord(swimlaneElement);\n            // If beyond center, insert before next column\n            if (proxyBounds.center.y > targetBounds.center.y) {\n                beforeSwimlane = client.swimlanes.getNext(beforeSwimlane);\n            }\n            this.insertDropIndicator(drag.dropIndicator, beforeSwimlane);\n            drag.beforeSwimlane = beforeSwimlane;\n        }\n    }\n    async dragDrop(drag) {\n        // Data part\n        const\n            { client }    = this.owner,\n            { swimlanes } = client,\n            {\n                swimlaneRecord,\n                beforeSwimlane,\n                swimlaneElement,\n                dropIndicator,\n                proxy\n            }             = drag;\n        function commit() {\n            // Remove proxy & dropIndicator\n            proxy.remove();\n            dropIndicator.remove();\n            // Restore original element\n            swimlaneElement.classList.remove('b-drag-original');\n            // Update data\n            beforeSwimlane !== undefined && swimlanes.move(swimlaneRecord, beforeSwimlane);\n            client.trigger('dropSwimlane', { beforeSwimlane, drag });\n        }\n        // UI part\n        // We are dropping, this cls by default has a transition\n        proxy.classList.add('b-dropping');\n        // Move proxy to drop location, allowing it to transition there\n        DomHelper.alignTo(\n            proxy,\n            Rectangle.from(dropIndicator, undefined, true)\n        );\n        // Update record after the transition, to prevent too early redraw (which would ruin the transition)\n        if (DomHelper.getPropertyTransitionDuration(proxy, 'transform')) {\n            EventHelper.onTransitionEnd({\n                element  : proxy,\n                property : 'transform',\n                handler  : commit,\n                thisObj  : client\n            });\n        }\n        // Or right away if no transition is used\n        else {\n            commit();\n        }\n    }\n    dragLeave(drag) {\n        // Doing nothing feels ok for now\n    }\n}\nSwimlaneDrag._$name = 'SwimlaneDrag';", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport Base from '../../Core/Base.js';\nimport AsyncHelper from '../../Core/helper/AsyncHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Draggable from '../../Core/mixin/Draggable.js';\nimport Droppable from '../../Core/mixin/Droppable.js';\nimport Events from '../../Core/mixin/Events.js';\n/**\n * @module TaskBoard/feature/TaskDrag\n */\nconst\n    cardSelector = '.b-taskboard-card, .b-taskboard-card-drop-indicator',\n    // Index of the specified card/drop indicator (other drop indicators excluded)\n    indexOf      = (element, ignoreOriginal = false) => DomHelper\n        .children(element.parentElement, `.b-taskboard-card${ignoreOriginal ? ':not(.b-drag-original)' : ''}, .b-first-drop-indicator`)\n        .indexOf(element),\n    // Check if any drop indicator has moved in a way that will lead to task changes\n    hasChanged   = dropIndicators => dropIndicators.some((dropIndicator, i) => {\n        return (\n            // Moved to another parent is a change (another column or another swimlane)\n            dropIndicator.parentElement !== dropIndicator.elementData.initialParent ||\n            // Or if first drop indicator has changed index (the others follow it, no need to check)\n            (i === 0 && indexOf(dropIndicator, true) !== dropIndicator.elementData.initialIndex)\n        );\n    });\n/**\n * This feature allows cards on the TaskBoard to be dragged across swimlanes and columns but also vertically in the\n * same column to change the order:\n *\n * {@inlineexample TaskBoard/feature/TaskDrag.js}\n *\n * When a task is dropped, its {@link TaskBoard.view.TaskBoard#config-columnField},\n * {@link TaskBoard.view.TaskBoard#config-swimlaneField} and/or {@link TaskBoard.model.TaskModel#field-weight} fields\n * are updated to reflect the new location.\n *\n * ## Drag events\n *\n * The different stages of a drag operation trigger different events, in order of appearance:\n *\n * | Event                         | Description                                                                    |\n * |-------------------------------|--------------------------------------------------------------------------------|\n * | {@link #event-beforeTaskDrag} | Preventable event fired before a drag starts                                   |\n * | {@link #event-taskDragStart}  | Fired when dragging starts                                                     |\n * | {@link #event-taskDrag}       | Fired when movement during a drag will lead to changes                         |\n * | {@link #event-beforeTaskDrop} | Preventable event fired before finalizing a valid drop. Allows async listeners |\n * | {@link #event-taskDrop}       | Fired after finalizing a valid drop                                            |\n * | {@link #event-taskDragAbort}  | Fired when a drag is aborted (ESC, drop out of bounds or by a listener)        |\n * | {@link #event-taskDragEnd}    | Fired when a started drag ends, no matter the outcome                          |\n *\n * The {@link #event-beforeTaskDrop} is useful for example to request user confirmation for a drop:\n *\n * {@inlineexample TaskBoard/feature/TaskDragEvents.js}\n *\n * This feature is **enabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskDrag\n * @feature\n */\nexport default class TaskDrag extends TaskBoardFeature {\n    static $name = 'TaskDrag';\n    static type = 'taskDrag';\n    static pluginConfig = {\n        after : ['initialCompose']\n    };\n    static configurable = {\n        /**\n         * Specify `true` to enable the old behavior of moving tasks in the store on drop.\n         *\n         * This behaviour was made opt in since it does not play well when sharing data with other components.\n         *\n         * <div class=\"note\">\n         * If you are sorting tasks by a field other than `weight` and want predictable results on drop, you should\n         * enable this config.\n         * </div>\n         *\n         * @config {Boolean}\n         * @default\n         */\n        reorderTaskRecords : false,\n        /**\n         * The number of milliseconds that must elapse after a `touchstart` event before it is considered a drag. If\n         * movement occurs before this time, the drag is aborted. This is to allow touch swipes and scroll gestures.\n         * @config {Number}\n         * @default 300\n         */\n        dragTouchStartDelay : null\n    };\n    initialCompose() {\n        const me = this;\n        // Cannot use configurable since bodyElement is not available yet when feature is pulled in\n        me.draggable = TaskZone.new({\n            dragRootElement                                                      : me.disabled ? null : me.client.bodyWrapElement,\n            dropRootElement                                                      : me.client.bodyWrapElement,\n            owner                                                                : me,\n            [me.dragTouchStartDelay != null ? 'dragTouchStartDelay' : undefined] : me.dragTouchStartDelay,\n            internalListeners                                                    : {\n                beforeDragStart : 'onBeforeDragStart',\n                dragStart       : 'onDragStart',\n                thisObj         : me\n            }\n        }, me.draggable);\n    }\n    doDestroy() {\n        super.doDestroy();\n        this.draggable?.destroy();\n    }\n    doDisable(disable) {\n        super.doDisable(disable);\n        if (this.draggable) {\n            this.draggable.dragRootElement = disable ? null : this.client.bodyWrapElement;\n        }\n    }\n    onBeforeDragStart({ drag, event }) {\n        /**\n         * Fires on the owning TaskBoard before task dragging starts. Return `false` to prevent the action\n         * @event beforeTaskDrag\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Tasks to be dragged\n         * @param {Event} domEvent The mouse event\n         */\n        return this.client.trigger('beforeTaskDrag', { drag, event, domEvent : event, taskRecords : drag.taskRecords });\n    }\n    onDragStart({ drag, event }) {\n        /**\n         * Fires on the owning TaskBoard when task dragging starts\n         * @event taskDragStart\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Tasks to be dragged\n         * @param {Event} domEvent The mouse event\n         */\n        return this.client.trigger('taskDragStart', { drag, event, domEvent : event, taskRecords : drag.taskRecords });\n    }\n}\nTaskDrag.initClass();\nclass TaskZone extends Base.mixin(Draggable, Droppable, Events) {\n    static get configurable() {\n        return {\n            dragSelector       : '.b-taskboard-card:not(.b-readonly)',\n            dragItemSelector   : '.b-taskboard-card:not(.b-readonly)',\n            // Accept drops on anything within the TaskBoard\n            dropTargetSelector : '.b-taskboardbase',\n            // We are going to allow dragging multiple cards, will need to add cls manually to all of them\n            draggingItemCls : null,\n            dragProxy : {\n                type : 'default',\n                async open(drag) {\n                    const\n                        {\n                            itemElement,\n                            startEvent\n                        }          = drag,\n                        taskBoard  = this.owner.owner.client,\n                        columnEl   = itemElement.closest('.b-taskboard-column'),\n                        taskRecord = taskBoard.resolveTaskRecord(itemElement),\n                        proxy      = drag.proxy = DomHelper.createElement({\n                            // Add column classes too to get exact same styles applied\n                            className     : 'b-taskboard-drag-proxy ' + columnEl.className,\n                            role          : 'presentation',\n                            // Don't want it being removed while dragging\n                            retainElement : true\n                        }),\n                        cardClones = [];\n                    let taskRecords;\n                    // If we have selected tasks, drag them only if drag starts from one of the selected\n                    if (taskBoard.selectedTasks.includes(taskRecord)) {\n                        taskRecords = taskBoard.selectedTasks.filter(t => !t.readOnly).sort((a, b) => a.parentIndex - b.parentIndex);\n                    }\n                    // Otherwise (no selection or dragging an unselected) only drag one\n                    else {\n                        taskRecords = [taskRecord];\n                    }\n                    const taskElements = taskRecords.map(r => taskBoard.getTaskElement(r));\n                    Object.assign(drag, {\n                        taskElements,\n                        // Store heights, cannot measure later when original tasks are hidden\n                        taskHeights : new Map(),\n                        // Offset from cursor, ignoring page scroll = client coords\n                        proxyOffset : EventHelper\n                            .getClientPoint(startEvent)\n                            .getDelta(Rectangle.from(itemElement, null, true))\n                    });\n                    // Clone all dragged cards and put them in the proxy\n                    taskElements.forEach(taskElement => {\n                        const\n                            { elementData } = taskElement,\n                            cardClone       = taskElement.cloneNode(true),\n                            bounds          = Rectangle.from(taskElement, itemElement);\n                        // Cards get their width from the column, need to apply the width to the proxy card\n                        cardClone.style.width = bounds.width + 'px';\n                        cardClone.style.height = bounds.height + 'px';\n                        drag.taskHeights.set(taskElement, bounds.height);\n                        // Position cards in the proxy to overlap their originals\n                        cardClone.style.left = bounds.x + 'px';\n                        cardClone.style.top = bounds.y + 'px';\n                        cardClone.taskElement = taskElement;\n                        cardClone.taskRecord = elementData.taskRecord;\n                        cardClone.originalColor = elementData.swimlaneRecord?.color || elementData.columnRecord.color;\n                        proxy.appendChild(cardClone);\n                        cardClones.push(cardClone);\n                    });\n                    // Hide original card after measuring it above (cannot be done in the same loop, others will get\n                    // wrong bounds)\n                    taskElements.forEach(taskElement => taskElement.classList.add('b-drag-original'));\n                    await AsyncHelper.animationFrame();\n                    // Now reposition the cards to their desired position within the proxy, transitioning them there\n                    cardClones.forEach((cardClone, i) => {\n                        if (i > 0) {\n                            cardClone.style.top = (30 + i * 20) + 'px';\n                            cardClone.style.left = (40 + i * 5) + 'px';\n                        }\n                        else {\n                            cardClone.style.top = 0;\n                            cardClone.style.left = 0;\n                        }\n                    });\n                },\n                dragMove({ proxy, event, proxyOffset }) {\n                    const\n                        { dragRootElement } = this.owner,\n                        // Parent coords relative to screen (client)\n                        parentBounds        = dragRootElement.getBoundingClientRect(),\n                        // Place proxy in client coords\n                        position            = EventHelper.getClientPoint(event).translate(\n                            proxyOffset[0] - parentBounds.left + dragRootElement.scrollLeft,\n                            proxyOffset[1] - parentBounds.top + dragRootElement.scrollTop\n                        );\n                    proxy.style.top = position.y + 'px';\n                    proxy.style.left = position.x + 'px';\n                    // Experimental, tilt proxy based on drag amount and direction\n                    // let delta = 0;\n                    //\n                    // if (proxy.lastClientX != null) {\n                    //     delta = event.clientX - proxy.lastClientX;\n                    // }\n                    //\n                    // proxy.lastClientX = event.clientX;\n                    //\n                    // proxy.style.transform = `rotate(${-delta / 10}deg)`;\n                    // proxy.style.transformOrigin = `${-proxyOffset[0]}px ${-proxyOffset[1]}px`;\n                }\n            }\n        };\n    }\n    configureListeners(drag) {\n        const listeners = super.configureListeners(drag);\n        // Listen to the events on the root element\n        listeners.element = this.owner.client.rootElement;\n        return listeners;\n    }\n    setupDragContext(event) {\n        const\n            result     = super.setupDragContext(event),\n            { client } = this.owner;\n        result.scrollManager = client.scrollManager;\n        result.monitoringConfig = {\n            scrollables : [\n                {\n                    element   : '.b-taskboard-column-body',\n                    direction : 'vertical'\n                },\n                {\n                    element   : client.bodyElement,\n                    direction : 'both'\n                }\n            ]\n        };\n        return result;\n    }\n    // Populate the drag context early, to have something to take decisions on in beforeDragStart listeners\n    startDrag(drag) {\n        const\n            { itemElement } = drag,\n            taskBoard       = this.owner.client,\n            taskRecord      = taskBoard.resolveTaskRecord(itemElement);\n        // If we have selected tasks, drag them only if drag starts from one of the selected\n        if (taskBoard.isSelected(taskRecord)) {\n            drag.taskRecords = taskBoard.selectedTasks.slice().sort((a, b) => a.parentIndex - b.parentIndex);\n        }\n        // Otherwise (no selection or dragging an unselected) only drag one\n        else {\n            drag.taskRecords = [taskRecord];\n        }\n        drag.initiatedFrom = taskRecord;\n        return super.startDrag(drag);\n    }\n    dragStart(drag) {\n        const\n            { client }  = this.owner,\n            // Insert dropIndicators next to task that drag was initiated on initially\n            nextSibling = drag.itemElement;\n        // Flag to determine if `taskDragEnd` should be triggered on later abort\n        drag.wasStarted = true;\n        // Initially positioned after task drag is initiated from\n        drag.position = 'after';\n        drag.targetTaskRecord = drag.initiatedFrom;\n        for (const taskRecord of drag.taskRecords) {\n            taskRecord.instanceMeta(client).dragging = true;\n        }\n        // Adding proxy here and not when it is created saves one layout\n        client.bodyWrapElement.appendChild(drag.proxy);\n        // Populate drop indicator with placeholders\n        drag.dropIndicators = drag.taskElements.map((taskElement, i) => {\n            return DomHelper.createElement({\n                className : {\n                    'b-taskboard-card-drop-indicator' : 1,\n                    'b-first-drop-indicator'          : i === 0\n                },\n                style : {\n                    height : drag.taskHeights.get(taskElement)\n                },\n                elementData : {\n                    dropIndicator : true,\n                    // To be able to detect if it has actually moved on drop\n                    initialParent : taskElement.parentElement,\n                    initialIndex  : indexOf(taskElement),\n                    // Tag along the taskElement, to be able to return the drop indicator to its position for\n                    // invalid drop targets\n                    taskElement\n                },\n                retainElement : true,\n                nextSibling\n            });\n        });\n        client.element.classList.add('b-dragging-task');\n    }\n    dragEnter(drag) {\n        // Only accept tasks\n        if (!drag.itemElement.matches(this.dragItemSelector)) {\n            return false;\n        }\n    }\n    // Finds the first visible direct child in a parent element\n    getFirstVisibleChild(parentElement) {\n        for (const element of parentElement.children) {\n            if (element.offsetParent) {\n                return element;\n            }\n        }\n    }\n    // Convenience shortcut to not have to pass custom card selector on each call\n    getCardAt(x, y) {\n        return this.owner.client.getCardAt(x, y, cardSelector);\n    }\n    updateValidity(drag, valid) {\n        drag.proxy.classList.toggle('b-invalid', !valid);\n        drag.dropIndicators.forEach(dropIndicator => dropIndicator.classList.toggle('b-invalid', !valid));\n        drag.invalid = !valid;\n    }\n    dragMove(drag) {\n        const\n            me                                   = this,\n            { client }                           = me.owner,\n            { event : domEvent, dropIndicators } = drag,\n            { clientX, clientY }                 = domEvent,\n            overElement                          = client.documentRoot.elementFromPoint(clientX, clientY),\n            columnElement                        = DomSync.getChild(overElement?.closest('.b-taskboard-column'), 'body.inner');\n        if (drag.invalid) {\n            drag.valid = false;\n        }\n        if (!overElement) {\n            return;\n        }\n        // Over something in a column or the column itself\n        if (columnElement) {\n            const\n                targetSwimlane = client.resolveSwimlaneRecord(overElement),\n                targetColumn   = client.resolveColumnRecord(overElement),\n                tasksPerRow    = targetColumn.tasksPerRow || targetSwimlane?.tasksPerRow || client.tasksPerRow;\n            let\n                cardElement   = overElement.closest(cardSelector),\n                // Should only trigger drag event when move actually affected something\n                shouldTrigger = targetSwimlane !== drag.targetSwimlane || targetColumn !== drag.targetColumn;\n            // Only resolve swimlane/column when over a column, that way target sticks even if mouse is moved outside\n            drag.targetSwimlane = targetSwimlane;\n            drag.targetColumn = targetColumn;\n            // Might be over gap between cards, check if there is card above or below the gap\n            if (!cardElement) {\n                const\n                    { cardGap } = client,\n                    columnRect  = Rectangle.from(columnElement),\n                    topCard     = me.getFirstVisibleChild(columnElement),\n                    top         = topCard?.getBoundingClientRect().top ?? null;\n                if (tasksPerRow === 1) {\n                    // Above top card, use it\n                    if (top !== null && clientY < top) {\n                        cardElement = topCard;\n                    }\n                    else {\n                        const\n                            centerX   = columnRect.center.x,\n                            // Check column center, one gap up\n                            cardAbove = me.getCardAt(centerX, clientY - cardGap),\n                            // And one gap down\n                            cardBelow = me.getCardAt(centerX, clientY + cardGap);\n                        // Pick one of them\n                        cardElement = cardAbove || cardBelow;\n                    }\n                }\n                else {\n                    // Determine which \"inner column\" mouse is over\n                    const\n                        columnContentWidth = client.getColumnWidth(drag.targetColumn),\n                        // Can calculate padding, avoids reading it from DOM\n                        columnPadding      = (columnRect.width - columnContentWidth) / 2,\n                        // Width of an \"inner column\", ignoring gap between cards which does not matter in this case.\n                        // An approximate center fits our purpose\n                        innerColumnWidth   = columnContentWidth / tasksPerRow,\n                        // \"Inner column\" index\n                        index              = Math.floor((clientX - columnRect.left) / innerColumnWidth),\n                        // That columns center\n                        centerX            = columnRect.left + columnPadding + innerColumnWidth * (index + 0.5);\n                    // Above top row, use card below us\n                    if (top !== null && clientY < top) {\n                        cardElement = me.getCardAt(centerX, top);\n                    }\n                    else {\n                        const\n                            centerX    = columnRect.center.x,\n                            // Check column center, one gap left\n                            cardBefore = me.getCardAt(centerX - cardGap, clientY),\n                            // And one gap right\n                            cardAfter  = me.getCardAt(centerX + cardGap, clientY);\n                        // Pick one of them\n                        cardElement = cardBefore || cardAfter;\n                    }\n                }\n            }\n            // If we are over the drop indicator, we do nothing\n            if (!cardElement?.elementData.dropIndicator) {\n                let insertBefore = false;\n                // If we found a card, we should either go above or below it\n                if (cardElement) {\n                    const\n                        cardRect         = Rectangle.from(cardElement),\n                        targetTaskRecord = client.resolveTaskRecord(cardElement);\n                    // Insert before\n                    if (\n                        // If above center with single task per row\n                        (tasksPerRow === 1 && clientY < cardRect.center.y) ||\n                        // Or left of center in multiple tasks per row\n                        (tasksPerRow > 1 && clientX < cardRect.center.x)\n                    ) {\n                        if (drag.position !== 'before') {\n                            shouldTrigger = true;\n                        }\n                        insertBefore = cardElement;\n                        drag.position = 'before';\n                    }\n                    // Insert after\n                    else {\n                        if (drag.position !== 'after') {\n                            shouldTrigger = true;\n                        }\n                        insertBefore = cardElement.nextElementSibling;\n                        drag.position = 'after';\n                    }\n                    if (targetTaskRecord !== drag.targetTaskRecord) {\n                        shouldTrigger = true;\n                    }\n                    drag.targetTaskRecord = targetTaskRecord;\n                }\n                // No card, either empty column or below cards. Either way we append the card to the column\n                else {\n                    if (drag.position !== 'last') {\n                        shouldTrigger = true;\n                    }\n                    drag.position = 'last';\n                    drag.targetTaskRecord = null;\n                }\n                if (!insertBefore?.elementData?.dropIndicator) {\n                    if (insertBefore === false) {\n                        dropIndicators.forEach(dropIndicator => {\n                            columnElement?.appendChild(dropIndicator);\n                        });\n                    }\n                    else {\n                        dropIndicators.forEach(dropIndicator => {\n                            (insertBefore?.parentElement || columnElement).insertBefore(dropIndicator, insertBefore);\n                        });\n                    }\n                    drag.lastCardElement = cardElement;\n                }\n            }\n            // Update dragged cards dataset/color cls in case it is used for styling (as we do in demos)\n            for (const card of drag.proxy.children) {\n                if (!card.taskRecord.eventColor) {\n                    const color = drag.targetSwimlane?.color || drag.targetColumn.color;\n                    if (card.originalColor) {\n                        card.classList.remove(`b-taskboard-color-${card.originalColor}`);\n                    }\n                    if (color) {\n                        card.originalColor = color;\n                        if (DomHelper.isNamedColor(color)) {\n                            card.classList.add(`b-taskboard-color-${color}`);\n                        }\n                        else {\n                            card.style.color = color;\n                        }\n                    }\n                }\n                if (drag.targetSwimlane) {\n                    card.dataset.lane = drag.targetSwimlane.id;\n                }\n                card.dataset.column = drag.targetColumn.id;\n            }\n            if (shouldTrigger) {\n                const\n                    { taskRecords, targetTaskRecord, position } = drag,\n                    /**\n                     * Fires on the owning TaskBoard when tasks are dragged, if the drag leads to any changes compared to\n                     * the last taskDrag event (moved to a new column or changed order within a column).\n                     *\n                     * Returning `false` from a listener will flag the drag as invalid (by default turning the drop\n                     * indicator red)\n                     *\n                     * @event taskDrag\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.TaskModel[]} taskRecords Dragged tasks\n                     * @param {TaskBoard.model.ColumnModel} targetColumn Currently over this column\n                     * @param {TaskBoard.model.SwimlaneModel} targetSwimlane Currently over this swimlane (if used)\n                     * @param {Event} domEvent The mouse event\n                     */\n                    result                                      = client.trigger(\n                        'taskDrag',\n                        { drag, taskRecords, targetSwimlane, targetColumn, targetTaskRecord, position, event : domEvent, domEvent }\n                    );\n                me.updateValidity(drag, result !== false);\n            }\n        }\n    }\n    async dragDrop(drag) {\n        const\n            me         = this,\n            { client } = me.owner,\n            {\n                dropIndicators,\n                taskRecords,\n                targetSwimlane,\n                targetColumn,\n                targetTaskRecord,\n                event : domEvent\n            }          = drag,\n            event      = { drag, domEvent, event : domEvent, taskRecords, targetSwimlane, targetColumn, targetTaskRecord },\n            // Check that drop will lead to changes for at least one dragged task\n            changed    = hasChanged(dropIndicators);\n        /**\n         * Fires on the owning TaskBoard when tasks are dropped, before the operation completes. Handles async\n         * listeners, returning `false` from one will abort the operation\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        async beforeTaskDrop({ taskRecords, targetColumn }) {\n         *            // Show confirmation dialog\n         *            const result = await MessageDialog.confirm({\n         *                title   : 'Verify drop',\n         *                message : `Please confirm moving ${taskRecords.map(t => `\"${t.name}\"`).join(', ')} to ${targetColumn.text}?`\n         *            });\n         *\n         *            // Returning false will abort the drop (if user pressed Cancel)\n         *            return result === MessageDialog.okButton;\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event beforeTaskDrop\n         * @preventable\n         * @async\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Dropped tasks\n         * @param {TaskBoard.model.ColumnModel} targetColumn Dropped on this column\n         * @param {TaskBoard.model.SwimlaneModel} targetSwimlane Dropped in this swimlane (if used)\n         * @param {Event} domEvent The mouse event\n         */\n        if (!changed || !targetColumn || drag.invalid || await client.trigger('beforeTaskDrop', event) === false) {\n            drag.valid = false;\n        }\n        else {\n            drag.finalizer = new Promise(resolve => {\n                // Data part\n                const\n                    {\n                        columnField,\n                        swimlaneField\n                    }               = client,\n                    { taskStore }   = client.project,\n                    {\n                        proxy\n                    }               = drag,\n                    columnRecords   = targetColumn.tasks,\n                    swimlaneRecords = targetSwimlane\n                        ? columnRecords?.filter(task => task[swimlaneField] === targetSwimlane.id)\n                        : columnRecords,\n                    invalid         = !columnRecords;\n                let moveBefore;\n                if (!invalid) {\n                    // Dropped relative to another card?\n                    if (drag.targetTaskRecord) {\n                        // If before it, move to before it in store too\n                        if (drag.position === 'before') {\n                            moveBefore = targetTaskRecord;\n                        }\n                        // If after, move to before the next record\n                        else if (drag.position === 'after') {\n                            const index = swimlaneRecords.indexOf(targetTaskRecord);\n                            moveBefore = swimlaneRecords[index + 1] ?? null;\n                        }\n                    }\n                    // Dropped below all cards or in empty column, move to last in store which guarantees it is last in that column\n                    else if (swimlaneRecords.length) {\n                        moveBefore = null;\n                    }\n                }\n                function commit() {\n                    // Remove proxy & dropIndicators\n                    proxy.remove();\n                    dropIndicators.forEach(dropIndicator => {\n                        const { taskElement } = dropIndicator.elementData;\n                        // Move original element to the new destination\n                        dropIndicator.parentElement.insertBefore(taskElement, dropIndicator);\n                        // Make it available for syncing\n                        dropIndicator.parentElement.syncIdMap[taskElement.elementData.taskId] = taskElement;\n                        // And unflag it\n                        taskElement.classList.remove('b-drag-original');\n                        dropIndicator.remove();\n                    });\n                    client.suspendDomTransition();\n                    // Update data\n                    if (!invalid) {\n                        let newWeight;\n                        // Determine new weight\n                        if (moveBefore) {\n                            const\n                                // Successors, that might need to have their weight updated\n                                tasksBelow = swimlaneRecords.slice(swimlaneRecords.indexOf(moveBefore)),\n                                // Predecessor, we want to squeeze in after it weight-wise\n                                taskAbove = swimlaneRecords[swimlaneRecords.indexOf(moveBefore) - 1];\n                            let weightDiff;\n                            // We have a predecessor, put us between the card we \"replace\" and it to update as few\n                            // weights as possible\n                            if (taskAbove) {\n                                // Between tasks, down to 1 sized gaps\n                                weightDiff = Math.max(1, Math.round((moveBefore.weight - taskAbove.weight) / 2));\n                                newWeight = taskAbove.weight + weightDiff;\n                            }\n                            // First in column, put us between old first task and 0 in weight\n                            else {\n                                newWeight = Math.max(1, Math.round(moveBefore.weight / 2));\n                            }\n                            // Update weight for successors that have colliding weights.\n                            // New weight will be between current and next, to try and avoid having to change\n                            // multiple weights while also leaving gaps for future drops\n                            while (tasksBelow[0]?.weight === newWeight) {\n                                // Place halfway between this and next task\n                                weightDiff = tasksBelow[1]\n                                    ? Math.max(1, Math.round((tasksBelow[1].weight - newWeight) / 2))\n                                    : 50;\n                                newWeight = tasksBelow[0].weight = newWeight + weightDiff;\n                                tasksBelow.shift();\n                            }\n                        }\n                        // Last, add 100 to current lasts weight\n                        else {\n                            newWeight = swimlaneRecords.length\n                                ? swimlaneRecords[swimlaneRecords.length - 1].weight + 100\n                                : 100;\n                        }\n                        taskRecords.forEach(taskRecord => {\n                            const toSet = {\n                                [columnField] : targetColumn.id,\n                                weight        : newWeight\n                            };\n                            if (targetSwimlane) {\n                                toSet[swimlaneField] = targetSwimlane.id;\n                            }\n                            // Optionally reorder the store\n                            if (client.features.taskDrag.reorderTaskRecords && moveBefore !== undefined) {\n                                taskStore.move(taskRecord, moveBefore);\n                            }\n                            taskRecord.set(toSet);\n                        });\n                        // Reapply sorters if we are not reordering tasks and not overriding sort in the store on drop\n                        if (!client.features.taskDrag.reorderTaskRecords && !client.taskSorterFn) {\n                            client.project.taskStore.sort();\n                        }\n                    }\n                    client.resumeDomTransition();\n                    /**\n                     * Fires on the owning TaskBoard when tasks are successfully dropped (after the drop transition has\n                     * finished)\n                     * @event taskDrop\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.TaskModel[]} taskRecords Dropped tasks\n                     * @param {TaskBoard.model.ColumnModel} targetColumn Dropped on this column\n                     * @param {TaskBoard.model.SwimlaneModel} targetSwimlane Dropped in this swimlane (if used)\n                     * @param {Event} domEvent The mouse event\n                     */\n                    client.trigger('taskDrop', { drag, event : domEvent, taskRecords, targetSwimlane, targetColumn, moveBefore, domEvent });\n                    /**\n                     * Fires on the owning TaskBoard when a previously started drag operation ends, no matter the\n                     * outcome of it (whether valid, invalid or aborted)\n                     *\n                     * @event taskDragEnd\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.TaskModel[]} taskRecords Affected tasks\n                     * @param {Event} domEvent The mouse event\n                     */\n                    client.trigger('taskDragEnd', { drag, taskRecords, domEvent });\n                    // Reading element here flushes the recompose\n                    client.element.classList.remove('b-dragging-task');\n                    // Reset flag after recompose to avoid flicker when virtualizing (to not first render outline)\n                    for (const taskRecord of taskRecords) {\n                        taskRecord.instanceMeta(client).dragging = false;\n                    }\n                    resolve();\n                }\n                // UI part\n                const cardClones = Array.from(proxy.children);\n                // Ugly \"hack\" to force the transforms used in the proxy to go away\n                proxy.classList.add('b-pre-dropping');\n                cardClones[0].offsetWidth;\n                // We are dropping, this cls by default has a transition\n                proxy.classList.add('b-dropping');\n                // Move proxy cards to drop locations, allowing them to transition there\n                cardClones.forEach((cardClone, i) => {\n                    const dropClone = dropIndicators[i];\n                    DomHelper.alignTo(\n                        cardClone,\n                        // Ignore page scroll when trying to align element in float root to element in taskboard\n                        Rectangle.from(dropClone, undefined, true)\n                    );\n                });\n                // Update record after the transition, to prevent too early redraw (which would ruin the transition)\n                if (DomHelper.getPropertyTransitionDuration(cardClones[0], 'transform')) {\n                    EventHelper.onTransitionEnd({\n                        element  : cardClones[0],\n                        property : 'transform',\n                        handler  : commit,\n                        thisObj  : client // For timer cleanup\n                    });\n                }\n                // Or right away if no transition is used\n                else {\n                    commit();\n                }\n            });\n        }\n    }\n    dragLeave(drag) {\n        // Move drop indicator to dragged cards origin, to indicate what will happen on invalid drop\n        drag.dropIndicators.forEach(dropIndicator => {\n            const { taskElement } = dropIndicator.elementData;\n            taskElement.parentElement.insertBefore(dropIndicator, taskElement);\n        });\n    }\n    doAbort(drag) {\n        const\n            { client }                             = this.owner,\n            { dropIndicators, proxy, taskRecords } = drag;\n        if (proxy) {\n            const cardClones = Array.from(proxy.children);\n            function finalizeAbort() {\n                // Remove proxy & dropIndicators\n                proxy.remove();\n                dropIndicators.forEach(dropIndicator => {\n                    dropIndicator.elementData.taskElement.classList.remove('b-drag-original');\n                    dropIndicator.remove();\n                });\n                client.element.classList.remove('b-dragging-task');\n                // Rest flag late to avoid flicker when virtualizing (to not first render outline)\n                for (const taskRecord of taskRecords) {\n                    taskRecord.instanceMeta(client).dragging = false;\n                }\n                client.trigger('taskDragAbortFinalized');\n            }\n            // Emulate drop to enable transitions\n            proxy.classList.add('b-dropping');\n            // Move drop indicators to where each task originated\n            dropIndicators.forEach(dropIndicator => {\n                const { taskElement } = dropIndicator.elementData;\n                dropIndicator.classList.remove('b-invalid'); // Looks better this way when returning to origin\n                taskElement.parentElement.insertBefore(dropIndicator, taskElement);\n            });\n            // Move proxy cards to original locations, allowing them to transition there\n            cardClones.forEach((cardClone, i) => {\n                DomHelper.alignTo(\n                    cardClone,\n                    // Ignore page scroll when trying to align element in float root to element in taskboard\n                    Rectangle.from(dropIndicators[i], undefined, true)\n                );\n            });\n            // Finalize after transition\n            if (DomHelper.getPropertyTransitionDuration(cardClones[0], 'transform')) {\n                EventHelper.onTransitionEnd({\n                    element  : cardClones[0],\n                    property : 'transform',\n                    handler  : finalizeAbort,\n                    thisObj  : client // For timer cleanup\n                });\n            }\n            // Or right away if no transition is used\n            else {\n                finalizeAbort();\n            }\n        }\n        /**\n         * Fires on the owning TaskBoard when a drag operation is aborted (invalid drop or aborted using ESC)\n         *\n         * @event taskDragAbort\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Dragged tasks\n         */\n        client.trigger('taskDragAbort', { drag, taskRecords });\n        if (drag.wasStarted) {\n            // Documented in dragDrop()\n            client.trigger('taskDragEnd', { drag, taskRecords });\n        }\n    }\n    dragEnd(drag) {\n        // Move all cards back to their original location when drag was aborted\n        // (ignore abort before drag was started, which might occur with touch dragging, since start is delayed)\n        if ((drag.started || drag.wasStarted) && (!drag.valid || drag.aborted)) {\n            this.doAbort(drag);\n        }\n    }\n}\nTaskDrag._$name = 'TaskDrag';", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport TaskBoardFeature from './TaskBoardFeature.js';\n/**\n * @module TaskBoard/feature/TaskDragSelect\n */\n/**\n * Enables users to click and drag to select cards on the TaskBoard (marquee selection).\n *\n * {@inlineexample TaskBoard/feature/TaskDragSelect.js}\n *\n * This feature is **enabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskDragSelect\n * @feature\n */\nexport default class TaskDragSelect extends TaskBoardFeature {\n    static $name =  'TaskDragSelect';\n    static type = 'taskDragSelect';\n    static configurable = {\n        /**\n         * The amount of pixels to move pointer/mouse before it counts as a drag select operation.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    features : {\n         *        taskDragSelect : {\n         *            dragThreshold : 10\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Number}\n         * @default\n         */\n        dragThreshold : 5\n    };\n    state = 'idle';\n    static pluginConfig = {\n        chain : ['onColumnMouseDown', 'onMouseMove']\n    };\n    //region Type assertions\n    changeDragThreshold(threshold) {\n        ObjectHelper.assertNumber(threshold, 'features.taskDragSelect.dragThreshold');\n        return threshold;\n    }\n    //endregion\n    initializeDragSelect(event) {\n        const\n            me         = this,\n            { client } = me;\n        me.bounds = Rectangle.from(client.bodyElement, /* ignorePageScroll = */ true);\n        me.element = DomHelper.createElement({\n            tag       : 'div',\n            className : 'b-dragselect-rect'\n        }, { returnAll : true })[0];\n        client.floatRoot.appendChild(me.element);\n        client.element.classList.add('b-dragselecting');\n        const cardElements = Array.from(client.element.querySelectorAll('.b-taskboard-card:not(.b-dragging-item)'));\n        // Since the dragselect element is in the floatRoot, we want to use viewport-based coordinates, so we pass\n        // ignorePageScroll=true when calling Rectangle.from():\n        me.cardRectangles = cardElements.flatMap(el => {\n            // Previously we could get here with the drag proxy among elements, that case is now prevented by the\n            // selector above, but safeguarding against similar cases in the future here\n            const record = client.resolveTaskRecord(el);\n            return record\n                ? {\n                    rectangle : Rectangle.from(el, /* ignorePageScroll = */ true),\n                    record\n                } : [];\n        });\n        if (!event.ctrlKey) {\n            client.deselectAll();\n        }\n        // No key processing during drag selection\n        client.navigateable = false;\n        me.state = 'selecting';\n    }\n    // Select cards intersected by the selection marquee\n    updateSelection() {\n        const { cardRectangles, rectangle, client } = this;\n        for (let i = 0, len = cardRectangles.length; i < len; i++) {\n            const\n                cardData     = cardRectangles[i],\n                shouldSelect = rectangle.intersect(cardData.rectangle, true);\n            if (shouldSelect && !cardData.selected) {\n                cardData.selected = true;\n                client.selectTask(cardData.record, true);\n            }\n            else if (!shouldSelect && cardData.selected) {\n                cardData.selected = false;\n                client.deselectTask(cardData.record);\n            }\n        }\n    }\n    //region Listeners\n    onColumnMouseDown({ event }) {\n        const me = this;\n        if (!me.disabled && event.button === 0) {\n            me.state = 'considering';\n            me.startX = event.clientX;\n            me.startY = event.clientY;\n            me.mouseUpDetacher = EventHelper.on({\n                element : document,\n                mouseup : 'onMouseUp',\n                thisObj : me\n            });\n        }\n    }\n    onMouseMove({ event }) {\n        const\n            me                   = this,\n            { startX, startY }   = me,\n            { clientX, clientY } = event;\n        if (me.state === 'considering') {\n            const\n                deltaX = Math.abs(clientX - startX),\n                deltaY = Math.abs(clientY - startY);\n            if (deltaX > me.dragThreshold || deltaY > me.dragThreshold) {\n                me.initializeDragSelect(event);\n            }\n        }\n        if (me.state === 'selecting') {\n            const\n                { element, bounds } = me,\n                x                   = Math.max(clientX, bounds.left),\n                y                   = Math.max(clientY, bounds.top),\n                left                = Math.min(startX, x),\n                top                 = Math.min(startY, y),\n                width               = Math.abs(startX - x),\n                height              = Math.abs(startY - y),\n                rect                = new Rectangle(left, top, width, height).constrainTo(bounds);\n            DomHelper.setTranslateXY(element, rect.left, rect.top);\n            element.style.width  = rect.width + 'px';\n            element.style.height = rect.height + 'px';\n            me.rectangle = rect;\n            me.updateSelection();\n        }\n    }\n    onMouseUp() {\n        const\n            me                = this,\n            { client, state } = me;\n        // Cards are selected during mouse move, no need to change selection here\n        if (state === 'selecting') {\n            me.element?.remove();\n            client.element.classList.remove('b-dragselecting');\n            // Navigator will react to the 'click' event which clears selection, bypass this with a short timeout\n            client.setTimeout(() => client.navigateable = true, 100);\n        }\n        if (state === 'selecting' || state === 'considering') {\n            me.state = 'idle';\n            me.startX = me.startY = me.rectangle = me.bounds = null;\n        }\n        me.mouseUpDetacher?.();\n    }\n    //endregion\n}\nTaskDragSelect.initClass();\nTaskDragSelect._$name = 'TaskDragSelect';", "import Base from '../../../Core/Base.js';\nimport Widget from '../../../Core/widget/Widget.js';\n/**\n * @module TaskBoard/widget/mixin/TaskBoardLinked\n */\n/**\n * Mixin that simplifies linking a widget to a {@link TaskBoard.view.TaskBoard}.\n *\n * @mixin\n */\nexport default Target => class TaskBoardLinked extends (Target || Base) {\n    static $name = 'TaskBoardLinked';\n    static configurable = {\n        /**\n         * Auto detected when used within a TaskBoard. If you add the widget elsewhere, it will try to find an instance\n         * of TaskBoard on page. If that fails you have to supply this config to connect it to a TaskBoard manually.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({});\n         *\n         * const picker = new ColumnPickerButton({\n         *    taskBoard // Link it to the taskBoard instance created above\n         * });\n         * ```\n         *\n         * @config {TaskBoard.view.TaskBoard}\n         * @category Common\n         */\n        taskBoard : null\n    };\n    get taskBoard() {\n        return this._taskBoard || this.up(widget => widget.isTaskBoardBase) || Widget.query(widget => widget.isTaskBoardBase);\n    }\n    changeTaskBoard(taskBoard) {\n        if (taskBoard && !taskBoard.isTaskBoard) {\n            throw new Error(`The taskBoard config only accepts an instance of TaskBoard or a subclass thereof`);\n        }\n        return taskBoard;\n    }\n};\n", "import DomHelper from '../../../Core/helper/DomHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport Combo from '../../../Core/widget/Combo.js';\nimport TaskBoardLinked from '../mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/base/ColorBoxCombo\n */\n/**\n * Abstract base class with functionality shared between {@link TaskBoard.widget.ColumnCombo} and\n * {@link TaskBoard.widget.SwimlaneCombo}.\n *\n * @extends Core/widget/Combo\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @abstract\n */\nexport default class ColorBoxCombo extends Combo.mixin(TaskBoardLinked) {\n    static $name = 'ColorBoxCombo';\n    static type = 'colorboxcombo';\n    static configurable = {\n        displayField      : 'text',\n        valueField        : 'id',\n        editable          : false,\n        showBoxForNoColor : false,\n        listItemTpl({ text, color }) {\n            let html = StringHelper.encodeHtml(text);\n            if (color) {\n                if (DomHelper.isNamedColor(color)) {\n                    html = `<div class=\"b-colorbox b-taskboard-color-${color}\"></div>` + html;\n                }\n                else {\n                    html = `<div class=\"b-colorbox\" style=\"color : ${color}\"></div>` + html;\n                }\n            }\n            return html;\n        },\n        picker : {\n            cls : 'b-colorbox-picker'\n        }\n    };\n    afterConstruct() {\n        if (!this.showBoxForNoColor && !this.value) {\n            this.element.classList.add('b-colorless');\n        }\n    }\n    syncInputFieldValue(...args) {\n        const\n            me        = this,\n            { color } = me.record || {};\n        let className = 'b-colorbox';\n        if (color) {\n            if (DomHelper.isNamedColor(color)) {\n                className += ` b-taskboard-color-${color}`;\n            }\n            else {\n                me.colorBox.style.color = color;\n            }\n        }\n        me.colorBox.className = className;\n        if (!me.showBoxForNoColor) {\n            me.element.classList.toggle('b-colorless', !color);\n        }\n        super.syncInputFieldValue(...args);\n    }\n    get innerElements() {\n        return [\n            {\n                reference : 'colorBox',\n                className : 'b-colorbox'\n            },\n            ...super.innerElements\n        ];\n    }\n}\nColorBoxCombo._$name = 'ColorBoxCombo';", "import ColorBoxCombo from './base/ColorBoxCombo.js';\n/**\n * @module TaskBoard/widget/ColumnCombo\n */\n/**\n * A combo populated with the {@link TaskBoard.view.TaskBoard#property-columns} of a {@link TaskBoard.view.TaskBoard}.\n * If a column has a {@link TaskBoard.model.ColumnModel#field-color} defined, that color will be displayed in the combo\n * and its picker.\n *\n * Used in {@link TaskBoard.widget.TaskEditor} to pick which column a task belongs to (\"Status\" below):\n *\n * {@inlineexample TaskBoard/widget/ColumnCombo.js}\n *\n * @extends TaskBoard/widget/base/ColorBoxCombo\n * @classtype columncombo\n * @inputfield\n */\nexport default class ColumnCombo extends ColorBoxCombo {\n    static $name = 'ColumnCombo';\n    static type = 'columncombo';\n    changeStore() {\n        return this.taskBoard.columns.chain();\n    }\n}\nColumnCombo.initClass();\nColumnCombo._$name = 'ColumnCombo';", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Combo from '../../Core/widget/Combo.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\nimport AvatarRendering from '../../Core/widget/util/AvatarRendering.js';\n/**\n * @module TaskBoard/widget/ResourcesCombo\n */\n/**\n * A combo populated with the resources of a {@link TaskBoard.view.TaskBoard taskboard\u00B4s}\n * {@link Scheduler.data.ResourceStore resource store}.\n *\n * Used in {@link TaskBoard.widget.TaskEditor} to assign resources to a task. Double-click a task to try it:\n *\n * {@inlineexample TaskBoard/widget/ResourcesCombo.js}\n *\n * @extends Core/widget/Combo\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype resourcescombo\n * @inputfield\n */\nexport default class ResourcesCombo extends Combo.mixin(TaskBoardLinked) {\n    static $name = 'ResourcesCombo';\n    static type = 'resourcescombo';\n    static configurable = {\n        displayField : 'name',\n        valueField   : 'id',\n        multiSelect  : true,\n        editable     : false,\n        listItemTpl(resourceRecord) {\n            const { avatarRendering, taskBoard } = this.owner;\n            return DomHelper.createElement(avatarRendering.getResourceAvatar({\n                resourceRecord,\n                initials : resourceRecord.initials,\n                color    : resourceRecord.color,\n                iconCls  : resourceRecord.iconCls,\n                imageUrl : resourceRecord.image === false ? null : (resourceRecord.imageUrl || ((taskBoard.resourceImagePath || '') + (resourceRecord.image || '')))\n            })).outerHTML + StringHelper.encodeHtml(resourceRecord.name);\n        },\n        picker : {\n            cls : 'b-resources-picker'\n        },\n        chipView : {\n            scrollable : null,\n            itemTpl(resourceRecord) {\n                const { avatarRendering, taskBoard } = this.owner;\n                return DomHelper.createElement(avatarRendering.getResourceAvatar({\n                    resourceRecord,\n                    initials : resourceRecord.initials,\n                    color    : resourceRecord.color,\n                    iconCls  : resourceRecord.iconCls,\n                    imageUrl : resourceRecord.image === false ? null : (resourceRecord.imageUrl || ((taskBoard.resourceImagePath || '') + (resourceRecord.image || ''))),\n                    dataset  : {\n                        btip : StringHelper.encodeHtml(resourceRecord.name)\n                    }\n                })).outerHTML;\n            }\n        },\n        avatarRendering : {\n            value   : true,\n            $config : 'nullify'\n        }\n    };\n    get innerElements() {\n        // See if we have an uningested truthy multiSelect configuration, or we have already set it.\n        if (this.peekConfig('multiSelect') || this._multiSelect) {\n            return super.innerElements;\n        }\n        // Add element that we can render an avatar into when not using a chipview\n        return [\n            { reference : 'avatarContainer' },\n            this.inputElement\n        ];\n    }\n    syncInputFieldValue(...args) {\n        const me = this;\n        // No chipview when not multi selecting, render single avatar\n        if (!me.multiSelect) {\n            const resourceRecord = me.record;\n            if (resourceRecord) {\n                DomSync.sync({\n                    targetElement : me.avatarContainer,\n                    domConfig     : {\n                        className : 'b-resourcescombo-avatar-container',\n                        children  : [\n                            me.avatarRendering.getResourceAvatar({\n                                resourceRecord,\n                                initials : resourceRecord.initials,\n                                color    : resourceRecord.color,\n                                iconCls  : resourceRecord.iconCls,\n                                imageUrl : resourceRecord.image === false ? null : (resourceRecord.imageUrl || ((me.taskBoard.resourceImagePath || '') + (resourceRecord.image || ''))),\n                                dataset  : {\n                                    btip : StringHelper.encodeHtml(resourceRecord.name)\n                                }\n                            })\n                        ]\n                    }\n                });\n            }\n        }\n        super.syncInputFieldValue(...args);\n    }\n    changeStore() {\n        return this.taskBoard.project.resourceStore.chain();\n    }\n    changeAvatarRendering(value, old) {\n        old?.destroy();\n        if (value) {\n            return new AvatarRendering({\n                element : this.element\n            });\n        }\n    }\n}\nResourcesCombo.initClass();\nResourcesCombo._$name = 'ResourcesCombo';", "import ColorBoxCombo from './base/ColorBoxCombo.js';\n/**\n * @module TaskBoard/widget/SwimlaneCombo\n */\n/**\n * A combo populated with the {@link TaskBoard.view.TaskBoard#property-swimlanes} of a {@link TaskBoard.view.TaskBoard}.\n * If a swimlane has a {@link TaskBoard.model.SwimlaneModel#field-color} defined, that color will be displayed in the\n * combo and its picker.\n *\n * Used in {@link TaskBoard.widget.TaskEditor} to pick which swimlane a task belongs to (\"Prio\" below):\n *\n * {@inlineexample TaskBoard/widget/ColumnCombo.js}\n *\n * @extends TaskBoard/widget/base/ColorBoxCombo\n * @classtype swimlanecombo\n * @inputfield\n */\nexport default class SwimlaneCombo extends ColorBoxCombo {\n    static $name = 'SwimlaneCombo';\n    static type = 'swimlanecombo';\n    changeStore() {\n        return this.taskBoard.swimlanes.chain();\n    }\n}\nSwimlaneCombo.initClass();\nSwimlaneCombo._$name = 'SwimlaneCombo';", "import ColorPicker from '../../Core/widget/ColorPicker.js';\n/**\n * @module TaskBoard/widget/TaskColorPicker\n */\n/**\n * A color picker that displays a list of available task colors which the user can select by using mouse or keyboard.\n * See {@link TaskBoard.model.TaskModel#field-eventColor} for default available colors.\n *\n * {@inlineexample TaskBoard/widget/TaskColorPicker.js}\n *\n * ```javascript\n * new TaskColorPicker({\n *    appendTo : 'container',\n *    width    : '10em',\n *    onColorSelected() {\n *        console.log(...arguments);\n *    }\n * });\n * ```\n *\n * @extends Core/widget/ColorPicker\n * @classtype colorpicker\n */\nexport default class TaskColorPicker extends ColorPicker {\n    static $name = 'TaskColorPicker';\n    static type = 'taskcolorpicker';\n    static configurable = {\n        // These are the colors available by default for TaskBoard\n        colorClasses : [\n            { color : 'red', text : 'Red' },\n            { color : 'pink', text : 'Pink' },\n            { color : 'purple', text : 'Purple' },\n            { color : 'deep-purple', text : 'Deep purple' },\n            { color : 'indigo', text : 'Indigo' },\n            { color : 'blue', text : 'Blue' },\n            { color : 'light-blue', text : 'Light blue' },\n            { color : 'cyan', text : 'Cyan' },\n            { color : 'teal', text : 'Teal' },\n            { color : 'green', text : 'Green' },\n            { color : 'light-green', text : 'Light green' },\n            { color : 'lime', text : 'Lime' },\n            { color : 'yellow', text : 'Yellow' },\n            { color : 'amber', text : 'Amber' },\n            { color : 'orange', text : 'Orange' },\n            { color : 'deep-orange', text : 'Deep orange' }\n        ],\n        colorClassPrefix : 'b-taskboard-background-color-',\n        /**\n         * @hideconfigs colors\n         */\n        colors : null\n    };\n}\nTaskColorPicker.initClass();\nTaskColorPicker._$name = 'TaskColorPicker';", "import ColorField from '../../Core/widget/ColorField.js';\nimport './TaskColorPicker.js';\n/**\n * @module TaskBoard/widget/TaskColorCombo\n */\n/**\n * A combo populated with predefined colors usable by a task, see {@link TaskBoard.model.TaskModel#field-eventColor}.\n *\n * Used in {@link TaskBoard.widget.TaskEditor} to pick a color for a task. Double click a task to try it:\n *\n * {@inlineexample TaskBoard/widget/TaskColorCombo.js}\n *\n * @extends Core/widget/ColorField\n * @classtype taskcolorcombo\n * @inputfield\n */\nexport default class TaskColorCombo extends ColorField {\n    static $name = 'TaskColorCombo';\n    static type = 'taskcolorcombo';\n    static configurable = {\n        picker : {\n            type : 'taskcolorpicker'\n        },\n        name      : 'eventColor',\n        clearable : true\n    };\n}\nTaskColorCombo.initClass();\nTaskColorCombo._$name = 'TaskColorCombo';", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Popup from '../../Core/widget/Popup.js';\nimport '../../Core/widget/TextAreaField.js';\nimport '../../Core/widget/TextField.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\nimport './ColumnCombo.js';\nimport './ResourcesCombo.js';\nimport './SwimlaneCombo.js';\nimport './TaskColorCombo.js';\n/**\n * @module TaskBoard/widget/TaskEditor\n */\n/**\n * Popup used to edit tasks. Normally displayed using the {@link TaskBoard.feature.TaskEdit TaskEdit feature}.\n *\n * By default, the editor live updates the task being edited. If you prefer to use buttons to save/cancel the edit,\n * set {@link #config-autoUpdateRecord} to `false`.\n *\n * ## Items\n *\n * By default, it displays the following items:\n *\n * | Ref         | Type                                                   | Weight | Comment                                                                   |\n * |-------------|--------------------------------------------------------|--------|---------------------------------------------------------------------------|\n * | name        | {@link Core.widget.TextField text}                     | 100    | Task {@link TaskBoard.model.TaskModel#field-name}                         |\n * | description | {@link Core.widget.TextAreaField textarea}             | 200    | Task {@link TaskBoard.model.TaskModel#field-description}                  |\n * | resources   | {@link TaskBoard.widget.ResourcesCombo resourcescombo} | 300    | Assigned resources                                                        |\n * | color       | {@link TaskBoard.widget.TaskColorCombo taskcolorcombo} | 400    | Task {@link TaskBoard.model.TaskModel#field-eventColor}                   |\n * | column      | {@link TaskBoard.widget.ColumnCombo columncombo}       | 500    | Bound to configured {@link TaskBoard.view.TaskBoard#config-columnField}   |\n * | swimlane    | {@link TaskBoard.widget.SwimlaneCombo swimlanecombo}   | 600    | Bound to configured {@link TaskBoard.view.TaskBoard#config-swimlaneField} |\n *\n * If configured with `autoUpdateRecord: false` it also displays a bottom toolbar with the following items:\n *\n * | Ref          | Type                              | Weight | Comment          |\n * |--------------|-----------------------------------|--------|------------------|\n * | saveButton   | {@link Core.widget.Button button} | 100    | Save             |\n * | cancelButton | {@link Core.widget.Button button} | 200    | Cancel           |\n *\n * ## Customization\n *\n * Popup and its items can be customized through the feature (see {@link TaskBoard.feature.TaskEdit} fore more info):\n *\n * {@inlineexample TaskBoard/widget/TaskEditorCustomized.js}\n *\n * Or by subclassing and instructing the feature to display the new editor:\n *\n * {@inlineexample TaskBoard/widget/TaskEditorSubclassed.js}\n *\n * @extends Core/widget/Popup\n * @classtype taskboardtaskeditor\n */\nexport default class TaskEditor extends Popup.mixin(TaskBoardLinked) {\n    static $name = 'TaskEditor';\n    static type = 'taskboardtaskeditor';\n    static configurable = {\n        /**\n         * Center the editor in browser viewport space. Defaults to true for desktop browsers using a pointer device\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        centered : true,\n        /**\n         * Show an opaque mask below the editor when shown.\n         *\n         * Clicking the mask closes the editor.\n         *\n         * @config {Boolean}\n         * @default true\n         * @category Common\n         */\n        modal : { closeOnMaskTap : true },\n        /**\n         * Shows a tool used to close the editor in the header.\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        closable : true,\n        /**\n         * By default the editor automatically updates the edited task when a field is changed. Set this to `false`\n         * to show Save / Cancel buttons and take manual control of the updating.\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        autoUpdateRecord : true,\n        /**\n         * Update fields if the {@link #config-record} changes\n         * @config {Boolean}\n         */\n        autoUpdateFields : true,\n        /**\n         * True to save and close the editor if ENTER is pressed.\n         * (The save part only applies when configured with `autoUpdateRecord : false`)\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        saveAndCloseOnEnter : true,\n        draggable : {\n            handleSelector : '.b-panel-header'\n        },\n        autoShow : false,\n        anchor : true,\n        closeAction : 'destroy',\n        scrollAction : 'realign',\n        title : 'L{TaskBoard.editTask}',\n        defaults : {\n            labelWidth : '30%'\n        },\n        width : '30em',\n        items : {\n            name        : { type : 'text', label : 'L{TaskBoard.name}', weight : 100 },\n            description : { type : 'textarea', label : 'L{TaskBoard.description}', height : '5em', weight : 200 },\n            resources   : { type : 'resourcescombo', label : 'L{TaskBoard.resources}', weight : 300 },\n            color       : { type : 'taskcolorcombo', label : 'L{TaskBoard.color}', name : 'eventColor', weight : 400 },\n            column      : { type : 'columncombo', weight : 500 },\n            swimlane    : { type : 'swimlanecombo', weight : 600 }\n        },\n        bbar : {\n            hidden : true,\n            items  : {\n                saveButton   : { text : 'L{TaskBoard.save}', onClick : 'up.onSaveClick', weight : 100 },\n                cancelButton : { text : 'L{TaskBoard.cancel}', onClick : 'up.onCancelClick', weight : 200 }\n            }\n        },\n        // We want to maximize on phones and tablets\n        maximizeOnMobile : true\n    };\n    changeItems(items, old) {\n        const\n            { taskBoard }                   = this,\n            { column, swimlane, resources } = items;\n        if (taskBoard) {\n            // Hook column field up to correct record field\n            if (column) {\n                if (!column.name) {\n                    column.name = taskBoard.columnField;\n                }\n                if (!column.label) {\n                    column.label = StringHelper.capitalize(taskBoard.columnField);\n                }\n            }\n            if (swimlane) {\n                // Take the swimlane field out if not using swimlanes\n                if (!taskBoard.swimlaneField || !taskBoard.swimlanes) {\n                    items.swimlane = null;\n                }\n                // Otherwise hook it up with correct record field\n                else {\n                    if (!swimlane.name) {\n                        swimlane.name = taskBoard.swimlaneField;\n                    }\n                    if (!swimlane.label) {\n                        swimlane.label = StringHelper.capitalize(taskBoard.swimlaneField);\n                    }\n                }\n            }\n            // Remove resources field if there are no resources\n            if (!taskBoard.project.resourceStore.count) {\n                items.resources = null;\n            }\n            // Prevent multi selection if using single assignment mode\n            if (taskBoard.project.eventStore.usesSingleAssignment && resources) {\n                resources.multiSelect = false;\n            }\n        }\n        else {\n            items.column = items.swimlane = items.resources = null;\n        }\n        return super.changeItems(items, old);\n    }\n    processItemsObject(items, namedItems, result) {\n        // Use ref as name if not explicitly set\n        for (const ref in items) {\n            const item = items[ref];\n            if (item && !('name' in item)) {\n                item.name = ref;\n            }\n        }\n        return super.processItemsObject(items, namedItems, result);\n    }\n    updateAutoUpdateRecord(autoUpdate) {\n        this.bbar.hidden = autoUpdate;\n    }\n    updateRecord(record) {\n        super.updateRecord(record);\n        if (record) {\n            // Tag along task id, mainly for tests\n            this.element.dataset.taskId = record.id;\n        }\n    }\n    onSaveClick() {\n        const\n            me                       = this,\n            { record, owner }        = me,\n            { resources, ...values } = me.values;\n        if (me.isValid) {\n            /**\n             * Fires on the owning TaskBoard when user clicks `Save`, before changes are saved.\n             * Returning `false` from a listener prevents saving and keeps the editor open.\n             * @event beforeSave\n             * @on-owner\n             * @preventable\n             * @param {TaskBoard.view.TaskBoard} source The taskboard\n             * @param {TaskBoard.widget.TaskEditor} editor The editor\n             * @param {TaskBoard.model.TaskModel} record The task record\n             * @param {Object} values The task editor field values\n             */\n            if (owner?.trigger('beforeSave', { record, values : me.values, editor : me }) === false) {\n                return;\n            }\n            /**\n             * Fires on the owning TaskBoard when user clicks `Save`, after changes are saved.\n             * @event save\n             * @on-owner\n             * @param {TaskBoard.view.TaskBoard} source The taskboard\n             * @param {TaskBoard.widget.TaskEditor} editor The editor\n             * @param {TaskBoard.model.TaskModel} record The task record\n             * @param {Object} values The task editor field values\n             */\n            owner?.trigger('save', { record, values : me.values, editor : me });\n            // Close first to avoid focus restoring issues if the edit element gets removed by the operations below\n            me.close();\n            record.set(values);\n            if (resources) {\n                // Does not work when passed through set, handle it separately\n                record.resources = resources;\n            }\n        }\n    }\n    onCancelClick() {\n        const me = this;\n        /**\n         * Fires on the owning TaskBoard when user clicks 'Cancel'.\n         * Returning `false` from a listener prevents canceling and keeps the editor open.\n         * @event beforeCancel\n         * @preventable\n         * @param {TaskBoard.view.TaskBoard} source The taskboard\n         * @param {TaskBoard.widget.TaskEditor} editor The editor\n         */\n        if (me.owner?.trigger('beforeCancel', { editor : me }) === false) {\n            return;\n        }\n        /**\n         * Fires on the owning TaskBoard when user clicks 'Cancel', after the editor closed.\n         * @event cancel\n         * @preventable\n         * @param {TaskBoard.view.TaskBoard} source The taskboard\n         * @param {TaskBoard.widget.TaskEditor} editor The editor\n         */\n        me.owner?.trigger('cancel', { editor : me });\n        me.close();\n    }\n    onInternalKeyDown(event) {\n        const me = this;\n        if (me.saveAndCloseOnEnter && !me.readOnly && event.key === 'Enter') {\n            // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden\n            event.preventDefault();\n            if (me.autoUpdateRecord) {\n                if (me.isValid) {\n                    // Blur to get a change event before closing, to be sure record is up to date\n                    event.target.blur();\n                    me.close();\n                }\n            }\n            else {\n                me.onSaveClick();\n            }\n        }\n        super.onInternalKeyDown(event);\n    }\n}\nTaskEditor.initClass();\nTaskEditor._$name = 'TaskEditor';", "import Widget from '../../Core/widget/Widget.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport TaskBoardFeature from './TaskBoardFeature.js';\nimport Scroller from '../../Core/helper/util/Scroller.js';\nimport '../widget/TaskEditor.js';\n// Ensure SlideToggle is present so that type : 'checkbox' can be switched out on mobile\nimport '../../Core/widget/SlideToggle.js';\n/**\n * @module TaskBoard/feature/TaskEdit\n */\n/**\n * This features allows the user to edit tasks in a popup editor that can either be shown centered on screen (the\n * default, double click a task to show the editor):\n *\n * {@inlineexample TaskBoard/feature/TaskEdit.js}\n *\n * Or anchored to a task:\n *\n * {@inlineexample TaskBoard/feature/TaskEditAnchored.js}\n *\n * ## Default items\n *\n * By default it displays the following items:\n *\n * | Ref           | Type                                                   | Weight | Comment                                                                   |\n * |---------------|--------------------------------------------------------|--------|---------------------------------------------------------------------------|\n * | `name`        | {@link Core.widget.TextField text}                     | 100    | Task {@link TaskBoard.model.TaskModel#field-name}                         |\n * | `description` | {@link Core.widget.TextAreaField textarea}             | 200    | Task {@link TaskBoard.model.TaskModel#field-description}                  |\n * | `resources`*  | {@link TaskBoard.widget.ResourcesCombo resourcescombo} | 300    | Assigned resources                                                        |\n * | `color`       | {@link TaskBoard.widget.TaskColorCombo taskcolorcombo} | 400    | Task {@link TaskBoard.model.TaskModel#field-eventColor}                   |\n * | `column`      | {@link TaskBoard.widget.ColumnCombo columncombo}       | 500    | Bound to configured {@link TaskBoard.view.TaskBoard#config-columnField}   |\n * | `swimlane`*   | {@link TaskBoard.widget.SwimlaneCombo swimlanecombo}   | 600    | Bound to configured {@link TaskBoard.view.TaskBoard#config-swimlaneField} |\n * <sup>*</sup> Only shown when using resources / swimlanes respectively\n *\n * You can modify or remove the default items and add new custom items to the editor either at config time by using the\n * {@link #config-items items config} or at runtime by using the {@link #config-processItems processItems config}.\n *\n * ## Customize when configuring\n *\n * The {@link #config-items items config} accepts an object keyed by item ref (as listed in the table above). This\n * object will be merged with default items and the end result will determine which items are shown and how they are\n * configured.\n *\n * ### To remove a default item\n *\n * Set a ref to `null` to remove the item from the editor:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            items : {\n *                // Remove the color field\n *                color : null\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskEditRemove.js}\n *\n * ### To modify a default item\n *\n * Supply an object with the configs you want to change for a ref to modify the corresponding field:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            items : {\n *                // Change label of the description field and move it to the bottom\n *                description : {\n *                    label : 'Comment',\n *                    weight : 700\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskEditModify.js}\n *\n * ### To add a custom item\n *\n * Supply a config object for the new item, using a ref that is not used by any default item:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            items : {\n *                // Change label of the description field and move it to the bottom\n *                deadline : {\n *                    type   : 'date',\n *                    label  : 'Deadline',\n *                    weight : 300,\n *                    name   : 'deadline' // Bound field. If it matches the ref (key) for the field, it can be left out\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskEditAdd.js}\n *\n * ## Customize at runtime\n *\n * By supplying a function to {@link #config-processItems} you gain runtime control over which items are shown and how\n * they are configured:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            processItems({ taskRecord, items }) {\n *                // Hide description for tasks that are done\n *                if (taskRecord.status === 'done') {\n *                    items.description = null;\n *                }\n *\n *                // Modify the label for the name field\n *                items.name.label = 'Title';\n *\n *                // Add a custom item for high prio tasks\n *                if (taskRecord.prio === 'high') {\n *                    items.severity = { type : 'number', name : 'severity', label : 'Severity' }\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * You can also use `processItems` to prevent the editor from being shown for certain tasks, by returning `false` from\n * the function.\n *\n * {@inlineexample TaskBoard/feature/TaskEditProcessItems.js}\n *\n * ## Customizing other aspects of the editor\n *\n * By supplying an {@link #config-editorConfig} you can customize other aspects of the editor, such as its size, how\n * it is anchored, its title etc.\n *\n * {@inlineexample TaskBoard/feature/TaskEditEditorConfig.js}\n *\n * This feature is **enabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskEdit\n * @feature\n */\nexport default class TaskEdit extends TaskBoardFeature {\n    static $name = 'TaskEdit';\n    static type = 'taskEdit';\n    static configurable = {\n        /**\n         * Type of widget to use as the editor. Should point to a subclass of {@link TaskBoard.widget.TaskEditor} or\n         * a widget mimicking its API.\n         * @config {String}\n         * @default\n         * @category Customization\n         */\n        editorType : 'taskboardtaskeditor',\n        /**\n         * Config object merged with the default configuration of the editor (by default a\n         * {@link TaskBoard.widget.TaskEditor}).\n         *\n         * Can be used to configure any aspect of the editor:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskEdit : {\n         *             editorConfig : {\n         *                 modal    : false,\n         *                 centered : false\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         * To customize the items in the editor, using {@link #config-items} is preferable.\n         * @config {TaskEditorConfig}\n         * @category Customization\n         */\n        editorConfig : {},\n        /**\n         * Items definition passed on to the configured editor (by default a {@link TaskBoard.widget.TaskEditor}).\n         *\n         * Can be used to add new items or modify and remove predefined items. To remove, supply `null` as the value.\n         *\n         * @config {Object<String,ContainerItemConfig|Boolean|null>}\n         * @category Customization\n         */\n        items : {},\n        /**\n         * A function called before displaying the editor that allows manipulation of its items.\n         * Returning `false` from this function prevents the editor from being shown.\n         *\n         * ```javascript\n         * features         : {\n         *    taskEdit : {\n         *         processItems({ items, taskRecord, columnRecord, swimlaneRecord }) {\n         *             // Manipulate existing items here as needed\n         *             items.name.label = taskRecord.type === 'task' ? 'Task' : 'Issue';\n         *\n         *            // Remove column field when editing tasks that are done\n         *            if (columnRecord.id === 'done') {\n         *                items.column = false\n         *            }\n         *         }\n         *     }\n         * },\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} context An object with information about the editor being shown\n         * @param {Object<String,ContainerItemConfig>} context.items An object containing the editor item configs keyed by ref\n         * @param {TaskBoard.model.TaskModel} context.taskRecord Record representing task being edited\n         * @param {TaskBoard.model.ColumnModel} context.columnRecord Record representing tasks column\n         * @param {TaskBoard.model.SwimlaneModel} context.swimlaneRecord Record representing tasks swimlane\n         * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n         * @preventable\n         */\n        processItems : null\n        // /**\n        //  * The event that shall trigger showing the editor. Defaults to `eventdblclick`, set to `` or null to disable editing of existing events.\n        //  * @config {String}\n        //  * @default\n        //  * @category Editor\n        //  */\n        // triggerEvent : 'eventdblclick',\n        // /**\n        //  * Specify `true` to put the editor in read only mode.\n        //  * @config {Boolean}\n        //  * @default false\n        //  */\n        // readOnly : null,\n    };\n    editor = null;\n    static pluginConfig = {\n        assign : ['editTask'],\n        chain  : ['onActivateTask', 'populateTaskMenu']\n    };\n    doDestroy() {\n        this.editor?.destroy();\n    }\n    //region Type assertions\n    changeEditorConfig(editorConfig) {\n        ObjectHelper.assertObject(editorConfig, 'features.taskEdit.editorConfig');\n        return editorConfig;\n    }\n    changeEditorType(editorType) {\n        ObjectHelper.assertString(editorType, 'features.taskEdit.editorType');\n        return editorType;\n    }\n    changeItems(items) {\n        ObjectHelper.assertObject(items, 'features.taskEdit.items');\n        return items;\n    }\n    changeProcessItems(processItems) {\n        ObjectHelper.assertFunction(processItems, 'features.taskEdit.processItems');\n        return processItems;\n    }\n    //endregion\n    /**\n     * Edit the supplied task in the task editor.\n     *\n     * ```javascript\n     * taskBoard.editTask(taskStore.first);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord Task to edit\n     * @param {HTMLElement} [element] Optionally an element to align to, by default it tries to resolve one from the\n     * supplied task when the editor is configured to not be centered.\n     * @on-owner\n     * @category Common\n     */\n    async editTask(taskRecord, element = null) {\n        const\n            me             = this,\n            { client }     = me,\n            columnRecord   = client.getColumn(taskRecord),\n            swimlaneRecord = client.swimlaneField && client.swimlanes?.getById(taskRecord.getValue(client.swimlaneField));\n        if (me.disabled) {\n            return;\n        }\n        /**\n         * Fires on the owning TaskBoard before a task is displayed in an editor.\n         *\n         * Returning `false` or a promise that resolves to `false` stops the default editing UI from being shown.\n         *\n         * ```javascript\n         * taskBoard.on({\n         *     beforeTaskEdit({ taskRecord }) {\n         *         return await userCanEdit(taskRecord);\n         *     }\n         * }\n         * ```\n         *\n         * @event beforeTaskEdit\n         * @param {TaskBoard.view.TaskBoard} source The owning TaskBoard\n         * @param {TaskBoard.model.TaskModel} taskRecord The record about to be shown in the task editor\n         * @on-owner\n         * @preventable\n         * @async\n         */\n        if (await client.trigger('beforeTaskEdit', { taskRecord }) === false) {\n            return;\n        }\n        if (me.isEditing) {\n            me.cancelEdit();\n        }\n        const\n            editorClass   = Widget.resolveType(me.editorType),\n            // Combine items defined on the feature with those defined on the editor\n            combinedItems = editorClass.mergeConfigs(editorClass.$meta.config.items, me.items),\n            // Allow user supplied fn to process the items, returning false will abort edit\n            processResult = me.processItems?.({ items : combinedItems, taskRecord, columnRecord, swimlaneRecord });\n        if (processResult === false) {\n            return;\n        }\n        const editor = me.editor = editorClass.new({\n            items    : combinedItems,\n            owner    : client,\n            readOnly : taskRecord.readOnly\n        }, me.editorConfig);\n        /**\n         * Fires on the owning TaskBoard when the editor for a task is available, but before it is populated with data\n         * and shown. Allows manipulating fields etc.\n         *\n         * ```javascript\n         * taskBoard.on({\n         *     beforeTaskEditShow({ taskRecord, editor }) {\n         *         editor.title = `Editing \"${taskRecord.name}\"`;\n         *     }\n         * }\n         * ```\n         *\n         * @event beforeTaskEditShow\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source The owning TaskBoard\n         * @param {TaskBoard.model.TaskModel} taskRecord The record about to be shown in the task editor\n         * @param {TaskBoard.widget.TaskEditor} editor The editor\n         */\n        client.trigger('beforeTaskEditShow', { taskRecord, editor });\n        editor.record = taskRecord;\n        if (editor.centered || !BrowserHelper.isHoverableDevice) {\n            editor.show();\n        }\n        else {\n            Scroller.scrollIntoView(element ?? client.getTaskElement(taskRecord));\n            editor.showBy(element ?? client.getTaskElement(taskRecord));\n        }\n        editor.isVisible && editor.ion({\n            hide    : me.onEditorHide,\n            thisObj : me\n        });\n    }\n    cancelEdit() {\n    }\n    onActivateTask({ taskRecord, event }) {\n        if (!event.defaultPrevented) {\n            this.editTask(taskRecord);\n        }\n    }\n    populateTaskMenu({ items, taskRecord }) {\n        if (!this.client.readOnly && !this.disabled) {\n            items.editTask = {\n                text     : 'L{TaskBoard.editTask}',\n                icon     : 'b-fw-icon b-icon-edit',\n                weight   : 100,\n                onItem   : () => this.editTask(taskRecord),\n                disabled : taskRecord.readOnly\n            };\n        }\n    }\n    onEditorHide() {\n        this.client.getTaskElement(this.editor.record)?.focus();\n    }\n}\nTaskEdit.initClass();\nTaskEdit._$name = 'TaskEdit';", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport ContextMenuBase from '../../Core/feature/base/ContextMenuBase.js';\nimport AvatarRendering from '../../Core/widget/util/AvatarRendering.js';\n/**\n * @module TaskBoard/feature/TaskMenu\n */\n/**\n * Displays a context menu for tasks. Items are populated by other features and/or application code.\n *\n * {@inlineexample TaskBoard/feature/TaskMenu.js}\n *\n * You can optionally also use a {@link TaskBoard/view/item/TaskMenuItem} button to display the menu.\n *\n * ## Default items\n *\n * These are the default items provided by TaskBoard features:\n *\n * | Reference    | Weight | Feature                            | Description                                      |\n * |--------------|--------|------------------------------------|--------------------------------------------------|\n * | `editTask`   | 100    | {@link TaskBoard.feature.TaskEdit} | Open task editor. Hidden when read-only          |\n * | `resources`  | 200    | *This feature*                     | Assign/unassign resources. Hidden when read-only |\n * | `column`     | 300    | *This feature*                     | Move to column. Hidden when read-only            |\n * | `swimlane`   | 400    | *This feature*                     | Move to swimlane. Hidden when read-only          |\n * | `removeTask` | 500    | *This feature*                     | Remove task. Hidden when read-only               |\n *\n * Default items in the menu can be changed or removed and new items can be added. This is handled using the\n * {@link #config-items} config of the feature.\n *\n * ## Add items\n *\n * Add menu items for all tasks by adding a key (used as menu item {@link Core/widget/Widget#config-ref}) with a\n * {@link Core/widget/MenuItem#configs config object for a menu item} as the value to the {@link #config-items} config:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         taskMenu : {\n *             items : {\n *                 flagTask : {\n *                     text : 'Flag task',\n *                     icon : 'b-fa-fw b-fa-flag',\n *                     onItem({ taskRecord }) {\n *                         taskRecord.flagged = true;\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskMenuAdd.js}\n *\n * ## Remove items\n *\n * To remove default items, configure them as `null` in the {@link #config-items} config:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         taskMenu : {\n *             items : {\n *                 removeTask : null,\n *                 resources : null\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskMenuRemove.js}\n *\n * ## Customize items\n *\n * To customize default items, supply a new config object for them in the {@link #config-items} config. It will merge\n * with the default config object:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         taskMenu : {\n *             items : {\n *                 removeTask : {\n *                     text : 'Delete card'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskMenuCustomize.js}\n *\n * ## Manipulating items at runtime\n *\n * Manipulate items for all tasks or specific tasks at runtime by supplying a {@link #config-processItems} function:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         taskMenu : {\n *             // Process items before menu is shown\n *             processItems({ taskRecord, items }) {\n *                  // Push an extra item for done tasks\n *                  if (taskRecord.status === 'done') {\n *                      items.archive = {\n *                          text : 'Archive',\n *                          icon : 'b-fa-fw b-fa-archive'\n *                          onItem({ taskRecord }) {\n *                              taskRecord.archived = true;\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show menu for low prio tasks\n *                  if (taskRecord.prio === 'low') {\n *                      return false;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">The `processItems` implementation my be an `async` function which `awaits` a result to\n * mutate the `items` object.</div>\n *\n * {@inlineexample TaskBoard/feature/TaskMenuProcessItems.js}\n *\n * This feature is **enabled** by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys           | Action                 | Action description                               |\n * |----------------|------------------------|--------------------------------------------------|\n * | `Space`        | *showContextMenuByKey* | Shows context menu for currently focused task    |\n * | `Ctrl`+`Space` | *showContextMenuByKey* | Shows context menu for currently focused task    |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#TaskBoard/guides/customization/keymap.md).\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskMenu\n * @feature\n */\nexport default class TaskMenu extends ContextMenuBase {\n    static $name = 'TaskMenu';\n    static type = 'taskMenu';\n    static configurable = {\n        /**\n         * A function called before displaying the menu that allows manipulations of its items.\n         * Returning `false` from this function prevents the menu from being shown.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *   features         : {\n         *       taskMenu : {\n         *           processItems({ taskRecord, items }) {\n         *              // Add a custom menu item for tasks with progress greater than 90\n         *              if (taskRecord.progress > 90) {\n         *                  items.close = {\n         *                      text : 'Close',\n         *                      icon : 'b-fa-fw b-fa-check',\n         *                      onItem({ taskRecord }) {\n         *                          taskRecord.done = true;\n         *                      }\n         *                  }\n         *              }\n         *           }\n         *       }\n         *   }\n         * });\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} context An object with information about the menu being shown\n         * @param {TaskBoard.model.TaskModel} context.taskRecord The task for which the menu will be shown\n         * @param {Object<string,MenuItemConfig|Boolean>} context.items An object containing the\n         *   {@link Core.widget.MenuItem menu item} configs keyed by their id\n         * @param {Event} context.event The DOM event object that triggered the show\n         * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n         * @preventable\n         */\n        processItems : null,\n        /**\n         * This is a preconfigured set of items used to create the default context menu.\n         *\n         * The `items` provided by this feature are listed in the intro section of this class. You can configure\n         * existing items by passing a configuration object to the keyed items.\n         *\n         * To remove existing items, set corresponding keys to `null`:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskMenu : {\n         *             items : {\n         *                 editTask : null\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * See the feature config in the above example for details.\n         *\n         * @config {Object<string,MenuItemConfig|Boolean|null>} items\n         */\n        items : null,\n        type : 'task',\n        /**\n         * The mouse / touch gesture which should show this context menu (e.g. 'taskClick' or 'taskContextMenu').\n         * Set to `false` to never trigger it from UI.\n         * @default\n         * @config {String|Boolean}\n         */\n        triggerEvent : 'taskContextMenu',\n        /**\n         * Show avatars/initials in the resource picker menu\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskMenu : {\n         *             showAvatars : false\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @default true\n         */\n        showAvatars : {\n            value   : true,\n            $config : 'nullify'\n        },\n        menu : {\n            align  : 't90-b90',\n            anchor : true\n        }\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<string,string>} keyMap\n         */\n        /**\n         * @hideconfigs type\n         */\n    };\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n        config.chain.push('populateTaskMenu');\n        return config;\n    }\n    //region Type assertions\n    changeItems(items) {\n        ObjectHelper.assertObject(items, 'features.taskMenu.items');\n        return items;\n    }\n    changeProcessItems(processItems) {\n        ObjectHelper.assertFunction(processItems, 'features.taskMenu.processItems');\n        return processItems;\n    }\n    //endregion\n    //region Events\n    /**\n     * This event fires on the owning TaskBoard before the context menu is shown for a task.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event taskMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<string,MenuItemConfig>} items Menu item configs\n     * @param {TaskBoard.model.TaskModel} taskRecord The task\n     * @on-owner\n     */\n    /**\n     * This event fires on the owning TaskBoard after the context menu is shown for a task.\n     * @event taskMenuShow\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<string,MenuItemConfig>} items Menu item configs\n     * @param {TaskBoard.model.TaskModel} taskRecord The task\n     * @on-owner\n     */\n    /**\n     * This event fires on the owning TaskBoard when an item is selected in the task context menu.\n     * @event taskMenuItem\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {TaskBoard.model.TaskModel} taskRecord The task\n     * @on-owner\n     */\n    /**\n     * This event fires on the owning TaskBoard when a check item is toggled in the task context menu.\n     * @event taskMenuToggleItem\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {TaskBoard.model.TaskModel} taskRecord The task\n     * @param {Boolean} checked Checked or not\n     * @on-owner\n     */\n    //endregion\n    updateTriggerEvent(triggerEvent) {\n        this.detachListeners('triggerEvent');\n        if (triggerEvent) {\n            this.client.ion({\n                name           : 'triggerEvent',\n                [triggerEvent] : 'onTriggerEvent',\n                thisObj        : this\n            });\n        }\n    }\n    doDisable(disable) {\n        super.doDisable(disable);\n        !this.isConfiguring && this.client.recompose();\n    }\n    onTriggerEvent({ event }) {\n        this.internalShowContextMenu(event);\n    }\n    /**\n     * Show the context menu for a specific task, aligned to its card. Optionally aligned to an element in the card, using the supplied CSS selector.\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord Task to show the menu for\n     * @param {String} [selector] CSS selector, to align to a specific element in the task's card\n     */\n    showMenuFor(taskRecord, selector = '.b-taskboard-task-menu') {\n        const\n            targetElement = this.client.getTaskElement(taskRecord),\n            buttonElement = targetElement.querySelector(selector),\n            eventParams   = { taskRecord, columnRecord : this.client.getColumn(taskRecord), targetElement };\n        let alignSpec = null;\n        if (buttonElement) {\n            eventParams.targetElement = buttonElement;\n            alignSpec = {\n                target : buttonElement\n            };\n        }\n        this.showContextMenu(eventParams, alignSpec);\n    }\n    showContextMenu(eventParams, ...args) {\n        if (!this.client.isSelected(eventParams.taskRecord)) {\n            this.client.selectTask(eventParams.taskRecord);\n        }\n        super.showContextMenu(eventParams, ...args);\n    }\n    getDataFromEvent(event) {\n        return ObjectHelper.assign(super.getDataFromEvent(event), event.taskBoardData);\n    }\n    populateTaskMenu({ items, taskRecord }) {\n        const { client, disabled } = this;\n        if (!client.readOnly && !disabled) {\n            const\n                { columnField, swimlaneField, selectedTasks } = client,\n                { resourceStore, eventStore }                 = client.project,\n                isSelected                                    = selectedTasks.includes(taskRecord);\n            items.column = {\n                text     : `L{TaskBoard.changeColumn} ${columnField}`,\n                icon     : 'b-fw-icon b-icon-move-left-right',\n                weight   : 300,\n                disabled : taskRecord.readOnly,\n                menu     : client.columns.map(col => ({\n                    ref         : col.id,\n                    text        : StringHelper.encodeHtml(col.text),\n                    cls         : 'b-column-menu-item',\n                    isColumn    : true,\n                    checked     : taskRecord.getValue(columnField) === col.id,\n                    // Close menu when task is moved to a new column, looks weird to keep it open\n                    closeParent : true\n                })),\n                onItem({ item }) {\n                    if (item.isColumn) {\n                        taskRecord.setValue(columnField, item.ref);\n                        item.parent.items.forEach(sibling => {\n                            if (sibling !== item) {\n                                sibling.checked = false;\n                            }\n                        });\n                    }\n                }\n            };\n            if (client.swimlanes?.count && swimlaneField) {\n                items.swimlane = {\n                    text     : StringHelper.xss`L{TaskBoard.changeSwimlane} ${swimlaneField}`,\n                    icon     : 'b-fw-icon b-icon-move-up-down',\n                    weight   : 400,\n                    disabled : taskRecord.readOnly,\n                    menu     : client.swimlanes.map(lane => ({\n                        ref         : lane.id,\n                        text        : StringHelper.encodeHtml(lane.text),\n                        isSwimlane  : true,\n                        checked     : taskRecord.getValue(swimlaneField) === lane.id,\n                        // Close menu when task is moved to a new swimlane, looks weird to keep it open\n                        closeParent : true\n                    })),\n                    onItem({ item }) {\n                        if (item.isSwimlane) {\n                            taskRecord.setValue(swimlaneField, item.ref);\n                            item.parent.items.forEach(sibling => {\n                                if (sibling !== item) {\n                                    sibling.checked = false;\n                                }\n                            });\n                        }\n                    }\n                };\n            }\n            if (resourceStore.count) {\n                items.resources = {\n                    text     : 'L{TaskBoard.resources}',\n                    icon     : 'b-fw-icon b-icon-user',\n                    weight   : 200,\n                    disabled : taskRecord.readOnly,\n                    menu     : resourceStore.map(resource => {\n                        const avatar = this.avatarRendering?.getResourceAvatar({\n                            resourceRecord : resource,\n                            initials       : resource.initials,\n                            color          : resource.color,\n                            iconCls        : resource.iconCls,\n                            imageUrl       : resource.imageUrl || ((client.resourceImagePath || '') + (resource.image || ''))\n                        });\n                        return {\n                            ref  : resource.id,\n                            cls  : 'b-resource-menu-item',\n                            text : avatar ? {\n                                className : 'b-resource-menu-item-inner',\n                                children  : [\n                                    avatar,\n                                    StringHelper.encodeHtml(resource.name)\n                                ]\n                            } : StringHelper.encodeHtml(resource.name),\n                            resource,\n                            checked     : taskRecord.resources.includes(resource),\n                            // Only allow single pick in single assignment mode\n                            toggleGroup : eventStore.usesSingleAssignment ? 'single' : null\n                        };\n                    }\n                    ),\n                    onItem({ item }) {\n                        if (item.resource) {\n                            taskRecord[item.checked ? 'assign' : 'unassign'](item.resource);\n                        }\n                    }\n                };\n            }\n            items.removeTask = {\n                text     : isSelected && selectedTasks.length > 1 ? 'L{TaskBoard.removeTasks}' : 'L{TaskBoard.removeTask}',\n                icon     : 'b-fw-icon b-icon-trash',\n                cls      : 'b-separator',\n                weight   : 500,\n                disabled : taskRecord.readOnly,\n                onItem   : () => client.removeTask(isSelected ? selectedTasks : taskRecord)\n            };\n        }\n    }\n    get showMenu() {\n        return true;\n    }\n    updateShowAvatars(value) {\n        this.avatarRendering?.destroy();\n        if (value) {\n            this.avatarRendering = new AvatarRendering({\n                element : this.client.element\n            });\n        }\n    }\n}\n// Register this feature type with its Factory\nTaskBoardFeature.register(TaskMenu.type, TaskMenu);\nTaskMenu._$name = 'TaskMenu';", "import ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport TaskBoardFeature from './TaskBoardFeature.js';\n/**\n * @module TaskBoard/feature/TaskTooltip\n */\n/**\n * Displays a tooltip when hovering a task. By default the tooltip displays:\n *\n * * task name\n * * task column\n * * task swimlane (if using swimlanes)\n * * names of assigned resources (if any)\n *\n * {@inlineexample TaskBoard/feature/TaskTooltip.js}\n *\n * To customize the contents, supply your own {@link #config-template}:\n *\n * {@inlineexample TaskBoard/feature/TaskTooltipTemplate.js}\n *\n * This feature is **disabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskTooltip\n * @feature\n */\nexport default class TaskTooltip extends TaskBoardFeature {\n    static $name = 'TaskTooltip';\n    static type = 'taskTooltip';\n    static configurable = {\n        /**\n         * Tooltip config object used to override the defaults, see {@link Core.widget.Tooltip#configs} for available\n         * configs.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskTooltip : {\n         *             tooltip : {\n         *                 hoverDelay : 100,\n         *                 hideDelay  : 500\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {TooltipConfig}\n         */\n        tooltip : {\n            value : {},\n            // Lazy, pulled in on render to have element available\n            $config : ['lazy', 'nullify']\n        },\n        /**\n         * Function used to populate the tooltip, supply your own to override the default contents of the tooltip.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskTooltip : {\n         *             template({ taskRecord }) {\n         *                 return `<b>${taskRecord.name}</b>`\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @param {Object} tipData\n         * @param {TaskBoard.model.TaskModel} tipData.taskRecord Hovered task\n         * @param {TaskBoard.model.ColumnModel} tipData.columnRecord The task's column\n         * @param {TaskBoard.model.SwimlaneModel} tipData.swimlaneRecord The task's swimlane (if used)\n         * @returns {String|DomConfig} Return an HTML string or a DOM config object\n         * @config {Function}\n         */\n        template : null\n    };\n    static pluginConfig = {\n        chain : ['render']\n    };\n    //region Type assertions\n    changeTemplate(template) {\n        ObjectHelper.assertFunction(template, 'features.taskTooltip.template');\n        return template;\n    }\n    //endregion\n    doDisable(disable) {\n        super.doDisable(disable);\n        if (this._tooltip) {\n            this.tooltip.disabled = disable;\n        }\n    }\n    changeTooltip(tooltip, oldTooltip) {\n        const\n            me         = this,\n            { client } = me;\n        ObjectHelper.assertObject(tooltip, 'features.taskTooltip.tooltip');\n        oldTooltip?.destroy();\n        if (tooltip) {\n            return new Tooltip(ObjectHelper.assign({\n                axisLock       : 'flexible',\n                cls            : 'b-taskboard-tooltip',\n                forSelector    : '.b-taskboardbase:not(.b-draghelper-active) .b-taskboard-card',\n                scrollAction   : 'realign',\n                forElement     : client.element,\n                showOnHover    : true,\n                hoverDelay     : 0,\n                hideDelay      : 100,\n                anchorToTarget : true,\n                allowOver      : Boolean(me.config.items || me.config.tools),\n                getHtml        : me.getTipHtml.bind(me),\n                disabled       : me.disabled,\n                textContent    : false\n            }, tooltip));\n        }\n    }\n    getTipHtml({ tip, activeTarget }) {\n        const\n            { client }     = this,\n            taskRecord     = client.resolveTaskRecord(activeTarget),\n            columnRecord   = client.resolveColumnRecord(activeTarget),\n            swimlaneRecord = client.resolveSwimlaneRecord(activeTarget);\n        if (this.template) {\n            return this.template({ tip, taskRecord, columnRecord, swimlaneRecord, activeTarget });\n        }\n        const children = [\n            {\n                class : 'b-taskboard-tooltip-title',\n                text  : taskRecord.name\n            },\n            {\n                class : 'b-taskboard-tooltip-label',\n                text  : StringHelper.capitalize(client.columnField)\n            },\n            {\n                class : 'b-taskboard-tooltip-value',\n                text  : columnRecord.text\n            }\n        ];\n        if (swimlaneRecord) {\n            children.push(\n                {\n                    class : 'b-taskboard-tooltip-label',\n                    text  : StringHelper.capitalize(client.swimlaneField)\n                },\n                {\n                    class : 'b-taskboard-tooltip-value',\n                    text  : swimlaneRecord.text\n                }\n            );\n        }\n        if (taskRecord.resources.length) {\n            children.push(\n                {\n                    class : 'b-taskboard-tooltip-label',\n                    text  : this.L('L{TaskBoard.resources}')\n                },\n                {\n                    class : 'b-taskboard-tooltip-value',\n                    text  : taskRecord.resources.map(resourceRecord => resourceRecord.name).join(', ')\n                }\n            );\n        }\n        return {\n            children\n        };\n    }\n    render() {\n        // Element is now available, pull in tooltip to have it correctly wired up\n        this.getConfig('tooltip');\n    }\n}\nTaskTooltip.initClass();\nTaskTooltip._$name = 'TaskTooltip';", "import Model from '../../Core/data/Model.js';\n/**\n * @module TaskBoard/model/ColumnModel\n */\n/**\n * Represents a single column on a TaskBoard.\n *\n * When creating a TaskBoard, you supply an initial set of columns. These columns are either defined as plain strings,\n * ColumnModel data objects or ColumnModel records (or a mix thereof). When using strings, the string will be used as is\n * as the column's id and capitalized as its text.\n *\n * ```javascript\n * const doneColumn = new ColumnModel({\n *     id   : 'done',\n *     text : 'Done'\n * });\n *\n * const taskBoard = new TaskBoard({\n *     columns : [\n *         // String, equal to passing { id : 'todo', text : 'Todo' }\n *         'todo',\n *         // Data object, in this case with a fixed width and not collapsible from the UI\n *         { id : 'doing', text : 'Doing', width : 200, collapsible : false }\n *         // Record, not commonly used since it is easier to supply the data object directly\n *         doneColumn\n *     ]\n * });\n * ```\n *\n * @extends Core/data/Model\n * @uninherit Core/data/mixin/TreeNode\n */\nexport default class ColumnModel extends Model {\n    static $name = 'ColumnModel';\n    static fields = [\n        /**\n         * This column's unique id, used to match a task to a column (which field on a task to match is specified using\n         * then {@link TaskBoard.view.TaskBoardBase#config-columnField} config on TaskBoard).\n         * @field {String|Number} id\n         */\n        /**\n         * Text displayed in the column header.\n         * @field {String} text\n         */\n        'text',\n        /**\n         * A tooltip string to show when hovering the column header\n         * @field {String} tooltip\n         */\n        'tooltip',\n        /**\n         * Color, named colors are applied as a `b-taskboard-color-{color}` (for example `b-taskboard-color-red`) CSS\n         * class to the column. Colors specified as hex, `rgb()` etc. are applied as `style.color` to the column.\n         *\n         * By default it does not visually affect the UI, but it applies a color to the column that applications can\n         * leverage using `currentColor` to style it in the desired way.\n         *\n         * Using named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     columns : [\n         *         { id : 'todo', text : 'Todo', color : 'orange', tooltip : 'These are items to be done' }\n         *     ]\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-column b-taskboard-color-orange\">\n         * ```\n         *\n         * Which can the be used for example like:\n         *\n         * ```css\n         * .b-taskboard-column-header {\n         *     border-left : 5px solid currentColor; // where currentColor is the color defined by b-taskboard-color-orange\n         * }\n         * ```\n         *\n         * Using non-named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     columns : [\n         *         { id : 'todo', text : 'Todo', color : 'hsl(229deg 66% 42%)' }\n         *     ]\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-column\" style=\"color: hsl(229deg 66% 42%)\">\n         * ```\n         *\n         * Predefined named colors (actual color might vary by theme):\n         * <div class=\"b-colorbox b-inline b-taskboard-color-red\"></div>red,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-pink\"></div>pink,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-purple\"></div>purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-purple\"></div>deep-purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-indigo\"></div>indigo,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-blue\"></div>blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-blue\"></div>light-blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-cyan\"></div>cyan,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-teal\"></div>teal,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-green\"></div>green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-green\"></div>light-green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-lime\"></div>lime,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-yellow\"></div>yellow,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-amber\"></div>amber,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-orange\"></div>orange,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-orange\"></div>deep-orange\n         *\n         * @field {String} color\n         */\n        { name : 'color', type : 'string' },\n        /**\n         * Number of tasks per row to display in this column. Leave blank to use the setting from the\n         * {@link TaskBoard.view.TaskBoardBase#config-tasksPerRow} config on TaskBoard.\n         * @field {Number} tasksPerRow\n         */\n        'tasksPerRow',\n        /**\n         * Allow collapsing this column\n         * @field {Boolean} collapsible=true\n         */\n        { name : 'collapsible', type : 'boolean', defaultValue : true },\n        /**\n         * Collapsed (`true`) or expanded (`false`)\n         *\n         * To expand or collapse, use {@link #function-expand} and  {@link #function-collapse} functions.\n         *\n         * @field {Boolean} collapsed\n         * @readonly\n         */\n        { name : 'collapsed', type : 'boolean' },\n        /**\n         * Set to `true` to hide the column, `false` to show it again.\n         * @field {Boolean} hidden\n         */\n        { name : 'hidden', type : 'boolean' },\n        /**\n         * Column width in px.\n         * @field {Number} width\n         */\n        { name : 'width', type : 'number' },\n        /**\n         * Column flex, affects width.\n         * @field {Number} flex\n         */\n        { name : 'flex', type : 'number' },\n        /**\n         * Column min-width in px. To override the default min-width specified in CSS.\n         * @field {Number} minWidth\n         */\n        { name : 'minWidth', type : 'number' }\n    ];\n    /**\n     * Get the tasks in this column in visual order.\n     * @property {TaskBoard.model.TaskModel[]}\n     * @readonly\n     */\n    get tasks() {\n        return this.taskBoard.getColumnTasks(this, true);\n    }\n    get taskBoard() {\n        return this.firstStore.taskBoard;\n    }\n    /**\n     * Collapse this column.\n     *\n     * Uses a transition by default, await the call to be certain that it has finished.\n     *\n     * @category Expand/collapse\n     * @returns {Promise} A promise which is resolved when the column is collapsed\n     */\n    async collapse() {\n        return this.taskBoard.collapse(this);\n    }\n    /**\n     * Expand this column.\n     *\n     * Uses a transition by default, await the call to be certain that it has finished.\n     *\n     * @category Expand/collapse\n     * @returns {Promise} A promise which is resolved when the column is expanded\n     */\n    async expand() {\n        return this.taskBoard.expand(this);\n    }\n}\nColumnModel._$name = 'ColumnModel';", "import EventModel from '../../Scheduler/model/EventModel.js';\n/**\n * @module TaskBoard/model/TaskModel\n */\n/**\n * Represents a single task on your TaskBoard, usually added to a {@link TaskBoard/store/TaskStore}.\n *\n * ## Customizing Task fields\n *\n * The TaskModel has a few predefined fields as seen under Fields below. If you want to add new fields or change\n * existing fields, you can do that by subclassing this class:\n *\n * ```javascript\n * class MyTask extends TaskModel {\n *\n *     static get fields() {\n *         return [\n *            // Add a new field\n *            { name: 'myField', type : 'number', defaultValue : 0 }\n *         ];\n *     }\n *\n *     ...\n * }\n *\n * // Instances of your class now has getters / setters defined for your field\n * const task = new MyTask();\n * console.log(task.myField); // => 0\n * ```\n *\n * If you want to use other names for any predefined field in your data, you can reconfigure them as seen below:\n *\n * ```javascript\n * class MyTask extends TaskModel {\n *\n *     static get fields() {\n *         return [\n *            // Remap status -> state\n *            { name: 'status', dataSource : 'state' }\n *         ];\n *     }\n *\n *     ...\n * }\n * ```\n *\n * ## Configuring the Project to use a custom task model\n *\n * Here's how you configure the {@link TaskBoard/model/ProjectModel Project} to use a certain Model class:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     // Configure the project to use our custom task model and to load data remotely\n *     project : {\n *         taskModelClass : MyTask,\n *\n *         autoLoad  : true\n *         transport : {\n *             load : {\n *                 url : 'data/data.json'\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ## Read-only tasks\n *\n * A task can be flagged as read-only using the {@link #field-readOnly} field. This protects it from being edited in the\n * UI, but has no effect on the data layer.\n *\n * {@inlineexample TaskBoard/model/TaskModelReadOnly.js}\n *\n * Please refer to {@link Core/data/Model} for additional details.\n *\n * @extends Scheduler/model/EventModel\n */\nexport default class TaskModel extends EventModel {\n    static $name = 'TaskModel';\n    static fields = [\n        /**\n         * Task status, for example for linking to a column on the TaskBoard.\n         *\n         * @field {String} status\n         */\n        'status',\n        /**\n         * Task priority, for example for linking to a swimlane on the TaskBoard.\n         *\n         * @field {String|Number} prio\n         */\n        'prio',\n        /**\n         * Task description, by default shown in tasks body.\n         *\n         * @field {String} description\n         */\n        'description',\n        /**\n         * Color, named colors are applied as a `b-taskboard-color-{color}` (for example `b-taskboard-color-red`) CSS\n         * class to the tasks card. Colors specified as hex, `rgb()` etc. are applied as `style.color` to the card.\n         *\n         * If no color is specified, any color defined on the {@link TaskBoard/model/ColumnModel#field-color column} or\n         * {@link TaskBoard/model/SwimlaneModel#field-color swimlane} will apply instead.\n         *\n         * By default it does not visually affect the UI, but it applies a color to the task that applications can\n         * leverage using `currentColor` to style it in the desired way.\n         *\n         * Using named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     project {\n         *         tasksData : [\n         *             { id : 1, name : 'Important task', eventColor : 'red' }\n         *         ]\n         *     }\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-card b-taskboard-color-red\">\n         * ```\n         *\n         * Which can the be used for example like:\n         *\n         * ```css\n         * .b-taskboard-card {\n         *     // currentColor is the color defined by b-red\n         *     border-left : 5px solid currentColor;\n         * }\n         * ```\n         *\n         * Using non-named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     project {\n         *         tasksData : [\n         *             { id : 1, name : 'Important task', eventColor : '#ff0000' }\n         *         ]\n         *     }\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-card\" style=\"color: #ff0000\">\n         * ```\n         *\n         * Predefined named colors (actual color might vary by theme):\n         * <div class=\"b-colorbox b-inline b-taskboard-color-red\"></div>red,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-pink\"></div>pink,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-purple\"></div>purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-purple\"></div>deep-purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-indigo\"></div>indigo,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-blue\"></div>blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-blue\"></div>light-blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-cyan\"></div>cyan,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-teal\"></div>teal,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-green\"></div>green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-green\"></div>light-green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-lime\"></div>lime,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-yellow\"></div>yellow,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-amber\"></div>amber,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-orange\"></div>orange,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-orange\"></div>deep-orange,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-gray\"></div>gray,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-gray\"></div>light-gray\n         *\n         * @field {'red'|'pink'|'purple'|'deep-purple'|'indigo'|'blue'|'light-blue'|'cyan'|'teal'|'green'|'light-green'|'lime'|'yellow'|'amber'|'orange'|'deep-orange'|'gray'|'light-gray'|String|null} eventColor\n         */\n        'eventColor',\n        /**\n         * Task weight, used by default to determine its index in a column. Higher weights are displayed further down.\n         *\n         * The weight is applied as a default sorter to the {@link TaskBoard/store/TaskStore}.\n         *\n         * When no weights are defined, task order is determined by store order.\n         *\n         * @field {Number} weight\n         */\n        { name : 'weight', type : 'number' },\n        /**\n         * Set to `true` to make the task read-only, preventing it from being edited in the UI.\n         *\n         * See the class description above for a live demo.\n         *\n         * @field {Boolean} readOnly\n         */\n        { name : 'readOnly', type : 'boolean' }\n    ];\n}\nTaskModel._$name = 'TaskModel';", "import EventStore from '../../Scheduler/data/EventStore.js';\nimport TaskModel from '../model/TaskModel.js';\n/**\n * @module TaskBoard/data/TaskStore\n */\n/**\n * Store that holds the tasks of a TaskBoard. By default configured to use {@link TaskBoard.model.TaskModel} for its\n * records.\n *\n * Loaded and handled as a part of a {@link TaskBoard.model.ProjectModel project}. For example using inline data:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         // Data to load into the TaskStore\n *         tasksData : [\n *             { id : 1, name : 'Some task', status : 'todo', prio : 'low' }\n *         ]\n *     }\n * }\n * ```\n *\n * When loaded using the {@link Scheduler.data.mixin.ProjectCrudManager CrudManager} functionality of the project, it\n * is populated from the `'tasks'` property in the\n * response:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         transport : {\n *             load : {\n *                 url : 'load.php'\n *             }\n *         },\n *\n *         autoLoad : true\n *     }\n * }\n * ```\n *\n * Expected response format to populate the TaskStore:\n *\n * ```json\n * {\n *     \"success\"     : true,\n *     \"tasks\"       : {\n *         \"rows\" : [\n *             {\n *                 \"id\"     : 1,\n *                 \"name\"   : \"Important task\",\n *                 \"status\" : \"todo\",\n *                 \"prio\"   : \"high\"\n *             },\n *             ...\n *         ]\n *     }\n * }\n * ```\n *\n * @extends Scheduler/data/EventStore\n */\nexport default class TaskStore extends EventStore {\n    static configurable = {\n        autoAssignWeight : true,\n        storeId : 'tasks',\n        /**\n         * Class used to represent records, defaults to {@link TaskBoard.model.TaskModel}\n         * @config {TaskBoard.model.TaskModel}\n         * @typings {typeof TaskModel}\n         * @category Common\n         */\n        modelClass : TaskModel,\n        /**\n         * Configure with `true` to also remove the event when removing the last assignment from the linked\n         * AssignmentStore.\n         *\n         * Defaults to `false` for TaskBoard since it is unexpected that a tasks disappears when unassigning the last\n         * resource from it.\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        removeUnassignedEvent : false,\n        /**\n         * Initial sorters, format is `[{ field: 'name', ascending: false }, ...]`.\n         *\n         * By default the TaskStore is sorted by `weight`, tasks with higher weights are displayed further down.\n         *\n         * @config {Sorter[]|String[]}\n         * @category Common\n         */\n        sorters : [\n            { field : 'weight', ascending : true }\n        ]\n    };\n    afterLoadData() {\n        const { records } = this;\n        if (this.autoAssignWeight && !records.some(r => r.weight != null)) {\n            for (let i = 0; i < records.length; i++) {\n                records[i].setData('weight', (i + 1) * 100);\n            }\n        }\n    }\n}\nTaskStore._$name = 'TaskStore';", "import SchedulerProjectModel from '../../Scheduler/model/ProjectModel.js';\nimport ProjectCrudManager from '../../Scheduler/data/mixin/ProjectCrudManager.js';\nimport TaskStore from '../store/TaskStore.js';\nimport TaskModel from './TaskModel.js';\n/**\n * @module TaskBoard/model/ProjectModel\n */\n/**\n * This class represents a global project of your TaskBoard - a central place for all data.\n *\n * It holds and links the stores usually used by TaskBoard:\n *\n * - {@link TaskBoard.store.TaskStore}\n * - {@link Scheduler.data.ResourceStore}\n * - {@link Scheduler.data.AssignmentStore}\n *\n * ## Loading remote data\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         // Project configuration\n *     }\n * });\n * ```\n *\n * ## Loading inline data\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         // Project configuration\n *     }\n * });\n * ```\n *\n * ## Getting modifications\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         // Project configuration\n *     }\n * });\n * ```\n *\n * ## Built-in StateTrackingManager\n *\n * The project also has a built-in {@link Core.data.stm.StateTrackingManager StateTrackingManager} (STM for short), that\n * handles undo/redo for the project stores (additional stores can also be added). You can enable it to track all\n * project store changes:\n *\n * ```javascript\n * // Turn on auto recording when you create your TaskBoard:\n * const taskBoard = new TaskBoard({\n *     project : {\n *         stm : {\n *             autoRecord : true\n *         }\n *     }\n * });\n *\n * // Undo a transaction\n * project.stm.undo();\n *\n * // Redo\n * project.stm.redo();\n * ```\n *\n * @extends Scheduler/model/ProjectModel\n * @mixes Scheduler/data/mixin/ProjectCrudManager\n *\n * @typings Scheduler.model.ProjectModel -> Scheduler.model.SchedulerProjectModel\n */\nexport default class ProjectModel extends SchedulerProjectModel.mixin(ProjectCrudManager) {\n    static configurable = {\n        /**\n         * Get/set {@link #property-taskStore} data.\n         *\n         * Always returns an array of {@link TaskBoard.model.TaskModel} but also accepts an array of\n         * its configuration objects as input.\n         *\n         * @member {TaskBoard.model.TaskModel[]} tasks\n         * @accepts {TaskBoard.model.TaskModel[]|TaskModelConfig[]}\n         * @category Inline data\n         */\n        /**\n         * The initial data, to fill the {@link #property-taskStore} with. Should be an array of\n         * {@link TaskBoard.model.TaskModel} or its configuration objects.\n         *\n         * @config {TaskBoard.model.TaskModel[]|TaskModelConfig[]} tasks\n         * @category Inline data\n         */\n        /**\n         * The initial data, to fill the {@link #property-taskStore} with.\n         * Should be an array of {@link TaskBoard.model.TaskModel} instances or its configuration objects.\n         *\n         * @config {TaskBoard.model.TaskModel[]|TaskModelConfig[]} tasksData\n         * @category Legacy inline data\n         */\n        /**\n         * The {@link TaskBoard.store.TaskStore store} holding the tasks information.\n         *\n         * See also {@link TaskBoard.model.TaskModel}\n         *\n         * @member {TaskBoard.store.TaskStore} taskStore\n         * @category Models & Stores\n         */\n        /**\n         * An {@link TaskBoard.store.TaskStore} instance or a config object.\n         * @config {TaskStoreConfig|TaskBoard.store.TaskStore} taskStore\n         * @category Models & Stores\n         */\n        /**\n         * @hideconfigs timeRanges\n         *              timeRangeStore,\n         *              timeRangesData,\n         *              timeRangeStoreClass,\n         *              resourceTimeRanges,\n         *              resourceTimeRangeStore,\n         *              resourceTimeRangesData,\n         *              resourceTimeRangeStoreClass,\n         *              eventStoreClass,\n         *              eventModelClass\n         */\n        /**\n         * @hideproperties timeRangeStore,\n         *                 resourceTimeRangeStore\n         */\n        eventStoreClass : TaskStore,\n        eventModelClass : TaskModel,\n        /**\n         * The constructor to create a task store instance with.\n         * Should be a class, subclassing the {@link TaskBoard.store.TaskStore}.\n         * @config {TaskBoard.store.TaskStore}\n         * @typings {typeof TaskStore}\n         * @category Models & Stores\n         */\n        taskStoreClass : TaskStore,\n        /**\n         * The constructor of the task model class, to be used in the project.\n         * Will be set as the {@link Core.data.Store#config-modelClass modelClass}\n         * property of the {@link #property-taskStore}.\n         * @config {TaskBoard.model.TaskModel}\n         * @typings {typeof TaskModel}\n         * @category Models & Stores\n         */\n        taskModelClass : TaskModel\n    };\n    construct(config) {\n        if (config.tasks) {\n            config.eventsData = config.tasks;\n        }\n        if (config.tasksData) {\n            config.eventsData = config.tasksData;\n        }\n        if (config.taskStore) {\n            config.eventStore = config.taskStore;\n        }\n        if (config.taskModelClass) {\n            config.eventModelClass = config.taskModelClass;\n        }\n        if (config.taskStoreClass) {\n            config.eventStoreClass = config.taskStoreClass;\n        }\n        super.construct(config);\n        const me = this;\n        me.addPrioritizedStore(me.assignmentStore);\n        me.addPrioritizedStore(me.resourceStore);\n        me.addPrioritizedStore(me.taskStore);\n    }\n    get taskStore() {\n        return this.eventStore;\n    }\n    set taskStore(store) {\n        this.eventStore = store;\n    }\n    get tasksData() {\n        return this.eventsData;\n    }\n    set tasksData(data) {\n        this.eventsData = data;\n    }\n    get tasks() {\n        return this.eventsData;\n    }\n    set tasks(data) {\n        this.events = data;\n    }\n    /**\n     * Returns the data from the records of the projects stores, in a format that can be consumed by `loadInlineData()`.\n     *\n     * Used by JSON.stringify to correctly convert this project to json.\n     *\n     * ```javascript\n     * const project = new ProjectModel({\n     *     tasksData       : [...],\n     *     resourcesData   : [...],\n     *     assignmentsData : [...]\n     * });\n     *\n     * const json = project.toJSON();\n     *\n     * // Result:\n     * {\n     *     taskData : [...],\n     *     resourcesData : [...],\n     *     assignmentsData : [...]\n     * }\n     * ```\n     *\n     * Output can be consumed by `loadInlineData()`:\n     *\n     * ```javascript\n     * const json = project.toJSON();\n     *\n     * // Plug it back in later\n     * project.loadInlineData(json);\n     * ```\n     *\n     * @returns {Object}\n     * @category JSON\n     */\n    toJSON() {\n        const\n            { taskStore, assignmentStore, resourceStore } = this,\n            result = {\n                tasksData : taskStore.toJSON()\n            };\n        if (assignmentStore?.count) {\n            result.assignmentsData = assignmentStore.toJSON();\n        }\n        if (resourceStore?.count) {\n            result.resourcesData = resourceStore.toJSON();\n        }\n        return result;\n    }\n}\nProjectModel._$name = 'ProjectModel';", "import Model from '../../Core/data/Model.js';\n/**\n * @module TaskBoard/model/SwimlaneModel\n */\n/**\n * Represents a single swimlane on a TaskBoard.\n *\n * When creating a TaskBoard, you can optionally supply an initial set of swimlanes. These are either defined as plain\n * strings, SwimlaneModel data objects or SwimlaneModel records (or a mix thereof). When using strings, the string will\n * be used as is as the swimlane's id and capitalized as its text.\n *\n * ```javascript\n * const highPrio = new SwimlaneModel({\n *     id   : 'high',\n *     text : 'High prio'\n * });\n *\n * const taskBoard = new TaskBoard({\n *     swimlanes : [\n *         // String, equal to passing { id : 'low', text : 'Low' }\n *         'low',\n *         // Data object, in this case with a fixed height and not collapsible from the UI\n *         { id : 'medium', text : 'Medium', height : 200, collapsible : false }\n *         // Record, not commonly used since it is easier to supply the data object directly\n *         highPrio\n *     ]\n * });\n * ```\n *\n * @extends Core/data/Model\n * @uninherit Core/data/mixin/TreeNode\n */\nexport default class SwimlaneModel extends Model {\n    static $name = 'SwimlaneModel';\n    static fields = [\n        /**\n         * The swimlane's unique id, used to match a task to a swimlane (which field on a task to match is specified\n         * using then {@link TaskBoard.view.TaskBoardBase#config-swimlaneField} config on TaskBoard).\n         * @field {String|Number} id\n         */\n        /**\n         * Text displayed in the swimlane header.\n         * @field {String} text\n         */\n        { name : 'text', type : 'string' },\n        /**\n         * Color, named colors are applied as a `b-taskboard-color-{color}` (for example `b-taskboard-color-red`) CSS\n         * class to the swimlane. Colors specified as hex, `rgb()` etc. are applied as `style.color` to the swilane.\n         *\n         * By default it does not visually affect the UI, but it applies a color to the swimlane that applications can\n         * leverage using `currentColor` to style it in the desired way.\n         *\n         * Using named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     swimlanes : [\n         *         { id : 'high', text : 'High', color : 'red' }\n         *     ]\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-swimlane b-taskboard-color-red\">\n         * ```\n         *\n         * Which can the be used for example like:\n         *\n         * ```css\n         * .b-taskboard-swimlane-header {\n         *     border-left : 5px solid currentColor; // where currentColor is the color defined by b-red\n         * }\n         * ```\n         *\n         * Using non-named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     swimlanes : [\n         *         { id : 'high', text : 'High', color : 'hsl(229deg 66% 42%)' }\n         *     ]\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-swimlane\" style=\"color: hsl(229deg 66% 42%)\">\n         * ```\n         *\n         * Predefined named colors (actual color might vary by theme):\n         * <div class=\"b-colorbox b-inline b-taskboard-color-red\"></div>red,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-pink\"></div>pink,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-purple\"></div>purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-purple\"></div>deep-purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-indigo\"></div>indigo,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-blue\"></div>blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-blue\"></div>light-blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-cyan\"></div>cyan,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-teal\"></div>teal,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-green\"></div>green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-green\"></div>light-green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-lime\"></div>lime,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-yellow\"></div>yellow,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-amber\"></div>amber,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-orange\"></div>orange,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-orange\"></div>deep-orange\n         *\n         * @field {String} color\n         */\n        { name : 'color', type : 'string' },\n        /**\n         * Allow collapsing this swimlane\n         * @field {Boolean} collapsible=true\n         */\n        { name : 'collapsible', type : 'boolean', defaultValue : true },\n        /**\n         * Collapsed (true) or expanded (False).\n         *\n         * To expand or collapse, use TaskBoards {@link TaskBoard.view.mixin.ExpandCollapse#function-expand} and\n         * {@link TaskBoard.view.mixin.ExpandCollapse#function-collapse} functions.\n         *\n         * @field {Boolean} collapsed\n         * @readonly\n         */\n        { name : 'collapsed', type : 'boolean' },\n        /**\n        * Set to `true` to hide the swimlane, `false` to show it again.\n        * @field {Boolean} hidden\n        */\n        { name : 'hidden', type : 'boolean' },\n        /**\n         * Swimlane height in px.\n         * @field {Number} height\n         */\n        { name : 'height', type : 'number' },\n        /**\n         * Swimlane flex, affects height.\n         * @field {Number} flex\n         */\n        { name : 'flex', type : 'number' },\n        /**\n         * Number of tasks per row to display in this swimlane. Leave blank to use the setting from the\n         * {@link TaskBoard.view.TaskBoardBase#config-tasksPerRow} config on TaskBoard.\n         * @field {Number} tasksPerRow\n         */\n        'tasksPerRow'\n    ];\n    get taskBoard() {\n        return this.firstStore.taskBoard;\n    }\n    /**\n     * Collapse this swimlane.\n     *\n     * Uses a transition by default, await the call to be certain that it has finished.\n     *\n     * @category Expand/collapse\n     * @returns {Promise} A promise which is resolved when the column is collapsed\n     */\n    async collapse() {\n        this.taskBoard.collapse(this);\n    }\n    /**\n     * Expand this swimlane.\n     *\n     * Uses a transition by default, await the call to be certain that it has finished.\n     *\n     * @category Expand/collapse\n     * @returns {Promise} A promise which is resolved when the column is expanded\n     */\n    async expand() {\n        return this.taskBoard.expand(this);\n    }\n    /**\n     * Get tasks in this swimlane.\n     * @property {TaskBoard.model.TaskModel[]}\n     * @readonly\n     */\n    get tasks() {\n        return [...(this.taskBoard.getSwimlaneTasks(this) || [])];\n    }\n}\nSwimlaneModel._$name = 'SwimlaneModel';", "import Base from '../../../Core/Base.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n/**\n * @module TaskBoard/view/mixin/ExpandCollapse\n */\n/**\n * Mixin that handles expanding and collapsing swimlanes and columns on the TaskBoard.\n *\n * {@inlineexample TaskBoard/view/mixin/ExpandCollapse.js}\n *\n * Users can expand and collapse using the UI. To do it programmatically, see:\n *\n * * {@link #function-collapse collapse()}\n * * {@link #function-expand expand()}\n * * {@link #function-toggleCollapse toggleCollapse()}\n *\n * Each of them accepts a column or a swimlane to expand/collapse. For example\n *\n * ```javascript\n * taskBoard.collapse(taskBoard.columns.todo);\n * taskBoard.expand(taskBoard.swimlanes.high);\n * ```\n *\n * For convenience, the functions are also callable directly on columns/swimlanes:\n *\n * ```javascript\n * taskBoard.columns.todo.expand();\n * taskBoard.swimlanes.high.collapse();\n * ```\n *\n * Expanding/collapsing is by default transitioned, `await` the calls to be certain that the UI is up to date:\n *\n * ```javascript\n * await taskBoard.collapse(taskBoard.columns.todo);\n * await taskBoard.columns.todo.expand();\n * ```\n *\n * @mixin\n */\nexport default Target => class ExpandCollapse extends (Target || Base) {\n    //region Config\n    static $name = 'ExpandCollapse';\n    static configurable = {\n        /**\n         * Show an icon to expand/collapse columns and swimlanes in their headers.\n         *\n         * Programmatic expand/collapse works independently of this setting, it only affects the UI.\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        showCollapseInHeader : true,\n        /**\n         * Specify `true` to hide the column title instead of rotating it on collapse.\n         *\n         * Used by default with swimlanes, since the title will overlap the swimlane header otherwise.\n         *\n         * @config {Boolean}\n         * @default\n         * @category Misc\n         */\n        collapseTitle : false,\n        /**\n         * By default, a tooltip showing `Expand XX`/`Collapse XX` is shown when hovering the expand/collapse icon for\n         * a column or swimlane. To disable the tooltip, set this to `false`.\n         * @prp {Boolean}\n         * @default\n         * @category Misc\n         */\n        showCollapseTooltip : true\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions\n    changeShowCollapseInHeader(showCollapseInHeader) {\n        ObjectHelper.assertBoolean(showCollapseInHeader, 'showCollapseInHeader');\n        return showCollapseInHeader;\n    }\n    //endregion\n    //region Events\n    /**\n     * Triggered when a column is expanded.\n     *\n     * @event columnExpand\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record\n     */\n    /**\n     * Triggered when a column is collapsed.\n     *\n     * @event columnCollapse\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record\n     */\n    /**\n     * Triggered when the column collapsed state is toggled.\n     *\n     * @event columnToggle\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record\n     * @param {Boolean} collapse `true` if the column is being collapsed.\n     */\n    /**\n     * Triggered when a swimlane is expanded.\n     *\n     * @event swimlaneExpand\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record\n     */\n    /**\n     * Triggered when a swimlane is collapsed.\n     *\n     * @event swimlaneCollapse\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record\n     */\n    /**\n     * Triggered when the swimlane collapsed state is toggled.\n     *\n     * @event swimlaneToggle\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record\n     * @param {Boolean} collapse `true` if the column is being collapsed.\n     */\n    //endregion\n    //region Toggling\n    /**\n     * Collapse a swimlane or column.\n     *\n     * Await the call to be certain that the collapse transition has ended.\n     *\n     * ```javascript\n     * await taskBoard.collapse(taskBoard.columns.first);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|TaskBoard.model.ColumnModel} record Swimlane or column\n     * @category Expand & collapse\n     */\n    async collapse(record) {\n        return this.toggleCollapse(record, true);\n    }\n    /**\n     * Expand a swimlane or column.\n     *\n     * Await the call to be certain that the expand transition has ended.\n     *\n     * ```javascript\n     * await taskBoard.expand(taskBoard.columns.first);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|TaskBoard.model.ColumnModel} record Swimlane or column\n     * @category Expand & collapse\n     */\n    async expand(record) {\n        return this.toggleCollapse(record, false);\n    }\n    /**\n     * Expand or collapse a swimlane or column.\n     *\n     * Await the call to be certain that the expand/collapse transition has ended.\n     *\n     * ```javascript\n     * // Toggle\n     * await taskBoard.toggleCollapse(taskBoard.columns.first);\n     * // Force collapse\n     * await taskBoard.toggleCollapse(taskBoard.columns.first, true);\n     * // Force expand\n     * await taskBoard.toggleCollapse(taskBoard.columns.first, false);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|TaskBoard.model.ColumnModel} record Swimlane or column\n     * @param {Boolean} [collapse] Specify to force a certain state, leave out to toggle\n     * @category Expand & collapse\n     * @fires columnCollapse\n     * @fires columnExpand\n     * @fires columnToggle\n     * @fires swimlaneCollapse\n     * @fires swimlaneExpand\n     * @fires swimlaneToggle\n     */\n    async toggleCollapse(record, collapse = !record.collapsed) {\n        if (record.isSwimlaneModel) {\n            await this.toggleSwimlaneCollapse(record, collapse);\n        }\n        else {\n            await this.toggleColumnCollapse(record, collapse);\n        }\n    }\n    async toggleSwimlaneCollapse(swimlaneRecord, collapse = !swimlaneRecord.collapsed) {\n        return new Promise(resolve => {\n            const\n                me              = this,\n                swimlaneElement = me.getSwimlaneElement(swimlaneRecord),\n                swimlaneBody    = DomSync.getChild(swimlaneElement, 'body');\n            // Set a height on collapse, to transition down from -> 0\n            if (collapse) {\n                swimlaneBody.style.height = `${swimlaneBody.getBoundingClientRect().height}px`;\n            }\n            EventHelper.onTransitionEnd({\n                element  : swimlaneBody,\n                property : 'height',\n                handler() {\n                    if (collapse) {\n                        // Removing static height on swimlane element on collapse\n                        swimlaneElement.style.height = '';\n                    }\n                    else {\n                        // Remove that height on expand, after it has transitioned from 0 to it\n                        swimlaneBody.style.height = '';\n                        // Setting static height on swimlane element on expand\n                        swimlaneElement.style.height = `${swimlaneRecord.height}px`;\n                    }\n                    swimlaneElement.classList.remove(collapse ? 'b-collapsing' : 'b-expanding');\n                    // Make sure UI is up to date when promise is resolved\n                    me.recompose.flush();\n                    resolve();\n                },\n                thisObj : me\n            });\n            swimlaneElement.classList.add(collapse ? 'b-collapsing' : 'b-expanding');\n            me.suspendDomTransition();\n            // This will trigger the recompose\n            swimlaneRecord.collapsed = collapse;\n            me.trigger(`swimlane${collapse ? 'Collapse' : 'Expand'}`, { swimlaneRecord });\n            me.trigger('swimlaneToggle', { swimlaneRecord, collapse });\n            me.resumeDomTransition();\n        });\n    }\n    async toggleColumnCollapse(columnRecord, collapse = !columnRecord.collapsed) {\n        return new Promise(resolve => {\n            const\n                me               = this,\n                { documentRoot } = me,\n                columnElements   = me.getColumnElements(columnRecord),\n                headerElement    = DomSync.getChild(me.bodyElement, `header.${columnRecord.domId}`),\n                // For columns that already has a width specified we won't need to measure and apply current width\n                hasFixedWidth    = columnRecord.width && !columnRecord.flex,\n                cardElements     = documentRoot.querySelectorAll(`.b-taskboard-card[data-column=\"${columnRecord.domId}\"]`),\n                cardWidth        = `${cardElements[0]?.getBoundingClientRect().width}px`,\n                columnWidth      = `${columnElements[0]?.getBoundingClientRect().width}px`;\n            // Fix card widths on collapse, to not have their contents reflow during the collapse\n            cardElements.forEach(card => {\n                if (collapse) {\n                    card.style.width = cardWidth;\n                }\n            });\n            columnElements.unshift(headerElement);\n            columnElements.forEach(element => {\n                // Set a width on collapse, to transition down from -> 0\n                if (collapse) {\n                    if (!hasFixedWidth) {\n                        element.style.width = columnWidth;\n                    }\n                    element.classList.add('b-collapsing');\n                }\n                // Add cls to keep flex away a bit longer on expand\n                else {\n                    element.classList.add('b-expanding');\n                }\n            });\n            EventHelper.onTransitionEnd({\n                element  : headerElement,\n                property : 'width',\n                handler() {\n                    // Unfix card widths when fully expanded again\n                    cardElements.forEach(card => {\n                        if (!collapse) {\n                            card.style.width = '';\n                        }\n                    });\n                    // Remove that width on expand, after it has transitioned from 0 to it\n                    columnElements.forEach(element => {\n                        if (!collapse) {\n                            // Restore width and flex from css\n                            if (!hasFixedWidth) {\n                                element.style.width = '';\n                            }\n                            element.classList.remove('b-expanding');\n                        }\n                        else {\n                            element.classList.remove('b-collapsing');\n                        }\n                    });\n                    // Make sure UI is up to date when promise is resolved\n                    me.recompose.flush();\n                    // Scroller is not aware of that expanding/collapsing might change overflow state, inform it...\n                    me.scrollable.syncOverflowState();\n                    resolve();\n                },\n                thisObj : me\n            });\n            // Force browser to reevaluate, for transition to trigger\n            headerElement.offsetWidth;\n            me.suspendDomTransition();\n            // This will trigger the recompose\n            columnRecord.collapsed = collapse;\n            me.trigger(`column${collapse ? 'Collapse' : 'Expand'}`, { columnRecord });\n            me.trigger('columnToggle', { columnRecord, collapse });\n            me.resumeDomTransition();\n        });\n    }\n    //endregion\n    //region Rendering\n    // Inject expander icon + expand/collapsed state cls in column headers\n    populateColumnHeader(args) {\n        super.populateColumnHeader?.(args);\n        const\n            { showCollapseInHeader, collapseTitle, hasSwimlanes, showCollapseTooltip } = this,\n            { columnRecord, columnHeaderConfig }                                       = args,\n            { text, collapsed, collapsible }                                           = columnRecord;\n        DomHelper.merge(columnHeaderConfig, {\n            class : {\n                'b-collapsed'    : collapsed,\n                'b-rotate-title' : collapsed && !collapseTitle && !hasSwimlanes\n            },\n            style : {\n                minWidth : collapsed ? null : columnRecord.minWidth\n            },\n            children : {\n                padder : {\n                    children : {\n                        expander : showCollapseInHeader && collapsible && {\n                            tag   : 'button',\n                            class : {\n                                'b-taskboard-column-expander' : 1,\n                                'b-fw-icon'                   : 1,\n                                'b-icon-expand-column'        : 1\n                            },\n                            dataset : {\n                                btip : showCollapseTooltip\n                                    ? StringHelper.xss`${this.L(collapsed ? 'L{TaskBoard.expand}' : 'L{TaskBoard.collapse}', text)}`\n                                    : null\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    // Inject expand/collapsed state cls in columns\n    populateColumn(args) {\n        super.populateColumn?.(args);\n        const\n            { columnRecord, columnConfig } = args,\n            { collapsed }                  = columnRecord;\n        columnConfig.class['b-collapsed'] = collapsed;\n        if (collapsed) {\n            columnConfig.style.minWidth = null;\n        }\n    }\n    // Inject expander icon + expand/collapsed state cls in swimlanes\n    populateSwimlane(args) {\n        super.populateColumn?.(args);\n        const { swimlaneRecord, swimlaneConfig } = args;\n        if (swimlaneRecord) {\n            const\n                { showCollapseInHeader, showCollapseTooltip } = this,\n                { text, collapsed, collapsible }              = swimlaneRecord;\n            DomHelper.merge(swimlaneConfig, {\n                class : {\n                    'b-collapsed'   : collapsed,\n                    'b-collapsible' : collapsible\n                },\n                children : {\n                    header : {\n                        children : {\n                            title : {\n                                children : {\n                                    // Before text\n                                    'expander > text' : showCollapseInHeader && collapsible && {\n                                        tag   : 'button',\n                                        class : {\n                                            'b-taskboard-swimlane-expander' : 1,\n                                            'b-icon'                        : 1,\n                                            'b-icon-expand-row'             : 1\n                                        },\n                                        dataset : {\n                                            btip : showCollapseTooltip\n                                                ? StringHelper.xss`${this.L(collapsed ? 'L{TaskBoard.expand}' : 'L{TaskBoard.collapse}', text)}`\n                                                : null\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    body : {\n                        [collapsed ? 'inert' : null] : true\n                    }\n                }\n            });\n        }\n    }\n    //endregion\n    //region Listeners\n    onColumnHeaderClick({ event, columnRecord }) {\n        if (event.target.matches('.b-taskboard-column-expander') || columnRecord.collapsed) {\n            this.toggleCollapse(columnRecord);\n        }\n    }\n    onColumnClick({ columnRecord }) {\n        if (columnRecord.collapsed) {\n            this.toggleCollapse(columnRecord);\n        }\n    }\n    onSwimlaneHeaderClick({ swimlaneRecord }) {\n        this.toggleCollapse(swimlaneRecord);\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module TaskBoard/view/mixin/ResponsiveCards\n */\n/**\n * An object that describes a card size level.\n *\n * @typedef {Object} CardSize\n * @property {String} name Level name, applied to the columns element as CSS class `b-[name]-cards`\n * @property {Number} maxWidth Express in px. This level applies above the previous levels maxWidth and up to this value\n * @property {Number} maxAvatars Max number of resource avatars to render, when that feature is used\n * @property {Object<String,TaskItemOptions>} headerItems A config object for items in a card's header, merges with\n * {@link TaskBoard.view.TaskBoard#config-headerItems} to determine items for this card size\n * @property {Object<String,TaskItemOptions>} bodyItems A config object for items in a card's header, merges with\n * {@link TaskBoard.view.TaskBoard#config-bodyItems} to determine items for this card size\n * @property {Object<String,TaskItemOptions>} footerItems A config object for items in a card's header, merges with\n * {@link TaskBoard.view.TaskBoard#config-footerItems} to determine items for this card size\n */\n/**\n * Mixin that allows responsive card behaviours.\n *\n * {@inlineexample TaskBoard/view/mixin/ResponsiveCards.js}\n *\n * It monitors column sizes using a ResizeObserver. When a columns width changes, it calculates the width of the cards\n * in that column based on the columns width and the configured number of tasks per row (see\n * {@link TaskBoard.view.TaskBoard#config-tasksPerRow}).\n *\n * The card width is then used to pick a {@link #config-cardSizes}, which applies CSS and might also affect task items.\n *\n * By default the following levels are defined:\n *\n * | Width | Name   | Cls            | Avatars | Items                       |\n * |-------|--------|----------------|---------|-----------------------------|\n * | < 50  | micro  | b-micro-cards  | 1       | Only resource avatars shown |\n * | < 75  | tiny   | b-tiny-cards   | 1       |                             |\n * | < 175 | small  | b-small-cards  | 1       |                             |\n * | < 300 | medium | b-medium-cards | 3       |                             |\n * | > 300 | large  | b-large-cards  | 7       |                             |\n *\n * If for example cards in a column are above 50px and below 75px wide, that column will have the `b-tiny-cards` CSS\n * class applied to its element. Use it to style the cards in a suitable way for your application, perhaps by applying\n * a smaller font size, hiding images etc.\n *\n * @mixin\n */\nexport default Target => class ResponsiveCards extends (Target || Base) {\n    //region Config\n    static $name = 'ResponsiveCards';\n    static configurable = {\n        /**\n         * An array of {@link CardSize} objects to use as responsive levels based on card widths.\n         *\n         * By default, the following levels are defined:\n         *\n         * | Width | Name   | Cls            | Avatars | Items                       |\n         * |-------|--------|----------------|---------|-----------------------------|\n         * | < 50  | micro  | b-micro-cards  | 1       | Only resource avatars shown |\n         * | < 75  | tiny   | b-tiny-cards   | 1       | Body text hidden            |\n         * | < 175 | small  | b-small-cards  | 2       | Body text hidden            |\n         * | < 300 | medium | b-medium-cards | 3       |                             |\n         * | > 300 | large  | b-large-cards  | 7       |                             |\n         *\n         * @config {CardSize}\n         * @category Common\n         */\n        cardSizes : [\n            {\n                maxWidth    : 50,\n                name        : 'micro',\n                maxAvatars  : 1,\n                headerItems : {\n                    text : null\n                },\n                bodyItems : {\n                    text : null\n                }\n            },\n            {\n                maxWidth   : 75,\n                name       : 'tiny',\n                maxAvatars : 1,\n                bodyItems  : {\n                    text : null\n                }\n            },\n            {\n                maxWidth   : 175,\n                name       : 'small',\n                maxAvatars : 2,\n                bodyItems  : {\n                    text : null\n                }\n            },\n            { maxWidth : 250, name : 'medium', maxAvatars : 3 },\n            { name : 'large', maxAvatars : 7 }\n        ],\n        resizeObserver : {\n            value   : true,\n            $config : ['nullify']\n        }\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions\n    changeCardSizes(cardSizes) {\n        ObjectHelper.assertArray(cardSizes, 'cardSizes');\n        return cardSizes;\n    }\n    //endregion\n    //region Suspend/resume responsiveness\n    responsivenessSuspended = 0;\n    suspendResponsiveness() {\n        this.responsivenessSuspended++;\n    }\n    resumeResponsiveness() {\n        this.responsivenessSuspended--;\n    }\n    //endregion\n    //region Calculate card size\n    // Get a card size entity, very similar to a responsive level in Grid\n    getCardSize(columnRecord, swimlaneRecord) {\n        const\n            me            = this,\n            { cardSizes } = me,\n            perRow        = me.getTasksPerRow(columnRecord, swimlaneRecord),\n            columnWidth   = me.getColumnWidth(columnRecord),\n            // Three cards on a row shares the column width with 2 gaps.\n            // Column padding is not measured and thus not part of calc\n            // |               |\n            // | \u2588 gap \u2588 gap \u2588 |\n            // |               |\n            cardWidth     = (columnWidth - me.cardGap * (perRow - 1)) / perRow;\n        return cardSizes?.find(size => cardWidth < size.maxWidth) || cardSizes?.[cardSizes.length - 1];\n    }\n    // Get the last reported width for a column, set by the ResizeObserver\n    getColumnWidth(columnRecord) {\n        return columnRecord.instanceMeta(this).width;\n    }\n    // Number of tasks per row to render for the requested column / swimlane intersection.\n    // Prio order is columns config, swimlanes config and lastly taskboards config\n    getTasksPerRow(columnRecord, swimlaneRecord) {\n        return columnRecord.tasksPerRow || swimlaneRecord?.tasksPerRow || this.tasksPerRow;\n    }\n    //endregion\n    //region ResizeObserver\n    // ResizeObserver callback for column size changes\n    onChildResize(entries) {\n        const me = this;\n        if (me.recompose.suspended || me.responsivenessSuspended) {\n            return;\n        }\n        // If any columns width changed enough for it to change card size level (medium -> large etc) we need to\n        // recompose to allow UI to react\n        let shouldRecompose = false;\n        for (const entry of entries) {\n            const { target, contentRect } = entry;\n            // Only care about width\n            if (target.observedWidth !== contentRect.width) {\n                const\n                    columnRecord   = me.resolveColumnRecord(target),\n                    // We are observing the headers, but need to calculate card size per column / swimlane intersection\n                    columnElements = columnRecord && me.columns.includes(columnRecord) && me.getColumnElements(columnRecord);\n                // Bail out when collapsing or hiding the column or if we did not get any record, which can happen\n                // during recompose when switching column set\n                if (!columnRecord || columnRecord.collapsed || columnRecord.hidden || !columnElements) {\n                    return;\n                }\n                // Cache width on element and column record (for easy lookup later)\n                columnRecord.instanceMeta(me).width = target.observedWidth = contentRect.width;\n                for (const columnElement of columnElements) {\n                    const\n                        swimlaneRecord = me.resolveSwimlaneRecord(columnElement),\n                        cardSize       = me.getCardSize(columnRecord, swimlaneRecord);\n                    // Was the size change enough to take us to a new card size level?\n                    if (cardSize && columnElement.elementData.cardSize !== cardSize.name) {\n                        shouldRecompose = true;\n                    }\n                }\n            }\n        }\n        if (shouldRecompose) {\n            me.recompose.now();\n            me.scrollable.syncOverflowState();\n        }\n    }\n    // ResizeObserver used to monitor column size, observing set up in domSyncCallback\n    changeResizeObserver(observer, oldObserver) {\n        oldObserver?.disconnect();\n        // Resize observer could be set to null for FireFox testing\n        return this.isDestroying || !ResizeObserver ? null : new ResizeObserver(this.onChildResize.bind(this));\n    }\n    //endregion\n    //region Rendering\n    populateColumn(args) {\n        super.populateColumn?.(args);\n        const\n            { columnRecord, swimlaneRecord, columnConfig } = args,\n            // Tag cardSize along with args, to be reachable from renderer\n            cardSize = args.cardSize                       = this.getCardSize(columnRecord, swimlaneRecord);\n        if (cardSize) {\n            columnConfig.class[`b-${cardSize.name}-cards`] = cardSize;\n            columnConfig.elementData.cardSize = cardSize.name;\n        }\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport Store from '../../../Core/data/Store.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport ColumnModel from '../../model/ColumnModel.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardColumns\n */\nconst transitionChangeActions = {\n    remove : 1,\n    move   : 1,\n    update : 1,\n    filter : 1\n};\n/**\n * Mixin that handles columns for the TaskBoard.\n *\n * @mixin\n */\nexport default Target => class TaskBoardColumns extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardColumns';\n    static configurable = {\n        /**\n         * Store containing the TaskBoard columns.\n         *\n         * @member {Core.data.Store} columns\n         * @category Common\n         */\n        /**\n         * Store containing the TaskBoard columns. A tasks {@link #config-columnField} is matched against the `id` of a\n         * column to determine in which column it is displayed.\n         *\n         * Accepts an array of column records/objects/strings, a store instance, a store id or a store config object\n         * used to create a new store.\n         *\n         * When supplying an array, a store configured with {Core.data.mixin.StoreProxy#config-objectify} is\n         * automatically created. Using that config allows for a nicer interaction syntax with the columns:\n         *\n         * ```javascript\n         * // Without objectify:\n         * taskBoard.columns.getById('done').text = 'Finished';\n         *\n         * // With objectify:\n         * taskBoard.columns.done.text = 'Finished';\n         * ```\n         *\n         * When supplying strings, the raw string will be used as the columns `id` and a capitalized version of it is\n         * used as the columns text:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *    columns : [\n         *        'doing',\n         *        'done'\n         *    ]\n         * });\n         * ```\n         *\n         * Is equivalent to:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *    columns : [\n         *        { id : 'doing', text : 'Doing' },\n         *        { id : 'done', text : 'Done' }\n         *    ]\n         * });\n         * ```\n         *\n         * @config {TaskBoard.model.ColumnModel[]|ColumnModelConfig[]|String[]|Core.data.Store|String|StoreConfig}\n         * @category Common\n         */\n        columns : {},\n        /**\n         * Set to `true` to auto generate columns when {@link #config-columns} is undefined.\n         *\n         * A column will be created for each distinct value of {@link #config-columnField} on the tasks. The columns\n         * will be sorted in alphabetical order. The following snippet will yield two columns, Q1 and Q2:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    columnField : 'quarter',\n         *\n         *    autoGenerateColumns : true,\n         *\n         *    project : {\n         *        tasksData : [\n         *            { id : 1, name : 'Inform tenants', quarter : 'Q1' },\n         *            { id : 2, name : 'Renovate roofs', quarter : 'Q2' }\n         *        ]\n         *    }\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @category Advanced\n         */\n        autoGenerateColumns : false,\n        /**\n         * Field on a task record used to determine which column the task belongs to.\n         *\n         * ```javascript\n         * taskBoard.columnField = 'category';\n         * ```\n         *\n         * @member {String} columnField\n         * @category Common\n         */\n        /**\n         * Field on a task record used to determine which column the task belongs to.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    columnField : 'status',\n         *\n         *    columns : [\n         *        'todo',\n         *        'done'\n         *    ],\n         *\n         *    project : {\n         *        tasksData : [\n         *            // Linked using the status field, to the done column\n         *            { id : 1, name : 'Fun task', status : 'done' }\n         *        ]\n         *    }\n         * });\n         * ```\n         *\n         * @config {String}\n         * @category Common\n         */\n        columnField : null\n    };\n    static properties = {\n        shouldAutoGenerateColumns : false\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions\n    changeAutoGenerateColumns(autoGenerateColumns) {\n        ObjectHelper.assertBoolean(autoGenerateColumns, 'autoGenerateColumns');\n        return autoGenerateColumns;\n    }\n    changeColumnField(columnField) {\n        ObjectHelper.assertString(columnField, 'columnField');\n        return columnField;\n    }\n    //endregion\n    //region Config - columnField\n    updateColumnField(field, old) {\n        if (old) {\n            const { storage } = this.project.taskStore;\n            if (old !== this.swimlaneField) {\n                storage.removeIndex(old);\n            }\n            storage.addIndex({ property : field, unique : false });\n        }\n        this.shouldAutoGenerateColumns = field && this.autoGenerateColumns;\n    }\n    //endregion\n    //region Config - columns\n    changeColumns(columns) {\n        return Store.from(columns, { objectify : true, modelClass : ColumnModel }, column => {\n            if (typeof column === 'string') {\n                return { id : column, text : StringHelper.capitalize(column) };\n            }\n            return column;\n        });\n    }\n    updateColumns(columns) {\n        this.detachListeners('columns');\n        if (columns) {\n            // Link to us to be able to retrieve tasks in visual order\n            // $store is the store instance of an objectified store\n            (columns.$store || columns).taskBoard = this;\n            columns.ion({\n                change  : 'onColumnsChange',\n                refresh : 'onColumnsChange',\n                thisObj : this\n            });\n        }\n    }\n    get columns() {\n        const\n            me            = this,\n            { taskStore } = me.project;\n        // If there are no columns defined but we have a column field configured and we have tasks loaded, generate\n        // columns from the tasks\n        if (me.shouldAutoGenerateColumns && taskStore.count) {\n            me.columns = taskStore.getDistinctValues(me.columnField).sort();\n            me.shouldAutoGenerateColumns = false;\n        }\n        return me._columns;\n    }\n    onColumnsChange({ action }) {\n        // CRUD invalidates column/swimlane intersection index\n        if (action === 'add' || action === 'remove' || action === 'removeAll' || action === 'update') {\n            this.project.taskStore.storage.invalidateIndices();\n        }\n        if (transitionChangeActions[action]) {\n            const options = {};\n            if (action === 'update' || action === 'remove') {\n                options.addTransition = { width : 1, opacity : 1 };\n                options.removeTransition = { width : 1, opacity : 1 };\n            }\n            this.recomposeWithDomTransition(options);\n        }\n        else {\n            this.recompose();\n        }\n    }\n    //endregion\n    //region Data\n    getColumnTasks(columnRecord, inVisualOrder = false) {\n        const\n            me            = this,\n            { taskStore } = me.project,\n            set           = taskStore.storage.findItem(me.columnField, columnRecord.id),\n            tasks         = set ? [...set] : [];\n        if (inVisualOrder && set) {\n            if (me.swimlanes) {\n                const\n                    { swimlaneField } = me,\n                    swimlanes         = me.swimlanes.map(r => r.id);\n                tasks.sort((a, b) => {\n                    // First sort by swimlane\n                    const swimlaneDelta = swimlanes.indexOf(a[swimlaneField]) - swimlanes.indexOf(b[swimlaneField]);\n                    if (swimlaneDelta !== 0) {\n                        return swimlaneDelta;\n                    }\n                    // And within a swimlane sort by weight order\n                    if (a.weight != null || b.weight != null) {\n                        return a.weight - b.weight;\n                    }\n                    // Fall back to store order\n                    return taskStore.indexOf(a) - taskStore.indexOf(b);\n                });\n                // Only include tasks for available swimlanes, if used\n                if (swimlanes.length && swimlaneField) {\n                    return tasks.filter(task => swimlanes.includes(task[swimlaneField]));\n                }\n            }\n            else {\n                // Sort by weight within column\n                tasks.sort((a, b) => a.weight - b.weight);\n            }\n        }\n        return tasks;\n    }\n    getColumn(taskRecord) {\n        return this.columns.getById(taskRecord.getValue(this.columnField));\n    }\n    // Next task in the same column as supplied task\n    getNextTask(taskRecord, wrap = true) {\n        const\n            columnRecord = this.getColumn(taskRecord),\n            columnTasks  = columnRecord.tasks;\n        let nextTaskIndex = columnTasks.indexOf(taskRecord) + 1;\n        if (nextTaskIndex === columnTasks.length) {\n            if (wrap) {\n                nextTaskIndex = 0;\n            }\n            else {\n                return null;\n            }\n        }\n        return columnTasks[nextTaskIndex];\n    }\n    // Prev task in the same column as supplied task\n    getPreviousTask(taskRecord, wrap = true) {\n        const\n            columnRecord = this.getColumn(taskRecord),\n            columnTasks  = columnRecord.tasks;\n        let prevTaskIndex = columnTasks.indexOf(taskRecord) - 1;\n        if (prevTaskIndex < 0) {\n            if (wrap) {\n                prevTaskIndex = columnTasks.length - 1;\n            }\n            else {\n                return null;\n            }\n        }\n        return columnTasks[prevTaskIndex];\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardDom\n */\n/**\n * Mixin that handles resolving elements from records and vice versa.\n *\n * ```javascript\n * // Resolve task record from an element\n * const task = taskBoard.resolveTaskRecord(someElement);\n *\n * // Get tasks element\n * const element = taskBoard.getTaskElement(taskBoard.taskStore.first);\n * ```\n *\n * @mixin\n */\nexport default Target => class TaskBoardDom extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardDom';\n    get widgetClass() {}\n    //endregion\n    //region Resolve record from element\n    /**\n     * Retrieves a task record corresponding to the supplied element. Has to be a `.b-taskboard-card` element or\n     * descendant thereof.\n     *\n     * ```javascript\n     * const taskRecord = taskBoard.resolveTaskRecord(taskElement);\n     * ```\n     *\n     * @param {HTMLElement} element\n     * @returns {TaskBoard.model.TaskModel}\n     * @category DOM\n     */\n    resolveTaskRecord(element) {\n        element = element.closest('.b-taskboard-card');\n        // If element is a drop indicator, it wont have elementData\n        return element && this.project.taskStore.getById(element.elementData?.taskId);\n    }\n    /**\n     * Retrieves a column record resolved from the supplied element. Has to be a `.b-taskboard-column` element or\n     * descendant thereof (such as a card).\n     *\n     * ```javascript\n     * const columnRecord = taskBoard.resolveColumnRecord(taskElement);\n     * ```\n     *\n     * @param {HTMLElement} element\n     * @returns {TaskBoard.model.ColumnModel}\n     * @category DOM\n     */\n    resolveColumnRecord(element) {\n        element = element.closest('.b-taskboard-column, .b-taskboard-column-header');\n        // Headers are b-taskboard-column but without elementData, for now\n        return element && this.columns.getById(element.elementData?.columnId);\n    }\n    /**\n     * Retrieves a swimlane record resolved from the supplied element. Has to be a `.b-taskboard-swimlane` element or\n     * descendant thereof.\n     *\n     * ```javascript\n     * const swimlaneRecord = taskBoard.resolveSwimlaneRecord(taskElement);\n     * ```\n     *\n     * @param {HTMLElement} element\n     * @returns {TaskBoard.model.SwimlaneModel}\n     * @category DOM\n     */\n    resolveSwimlaneRecord(element) {\n        element = element.closest('.b-taskboard-swimlane');\n        return element && this.swimlanes?.getById(element.elementData.laneId);\n    }\n    //endregion\n    //region Get element from record\n    /**\n     * Retrieves the task element (card) corresponding to the supplied task record.\n     *\n     * ```javascript\n     * const cardElement = taskBoard.getTaskElement(taskRecord);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getTaskElement(taskRecord) {\n        const taskColumnElement = this.getTaskColumnElement(taskRecord);\n        return taskColumnElement && DomSync.getChild(taskColumnElement, `body.inner.${taskRecord.domId}`);\n    }\n    /**\n     * Retrieves the element for the column that holds the supplied task record.\n     *\n     * ```javascript\n     * const columnElement = taskBoard.getColumnElement(taskRecord);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getTaskColumnElement(taskRecord) {\n        const columnRecord = this.columns.getById(taskRecord.getValue(this.columnField));\n        return columnRecord && DomSync.getChild(this.getTaskSwimlaneElement(taskRecord), `body.${columnRecord.domId}`);\n    }\n    /**\n     * Retrieves the element for the swimlane that holds the supplied task record.\n     *\n     * ```javascript\n     * const swimlaneElement = taskBoard.getTaskSwimlaneElement(taskRecord);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getTaskSwimlaneElement(taskRecord) {\n        // When not using swimlanes, we still create one called 'default'\n        const laneId = this.swimlanes?.count\n            ? this.swimlanes.getById(taskRecord.getValue(this.swimlaneField))?.domId\n            : 'default';\n        return DomSync.getChild(this.bodyElement, laneId);\n    }\n    /**\n     * Retrieves the element for the supplied swimlane.\n     *\n     * ```javascript\n     * const swimlaneElement = taskBoard.getSwimlaneElement(taskBoard.swimlanes.first);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getSwimlaneElement(swimlaneRecord) {\n        // Get a swimlane element, does not query DOM and is thus cheap\n        return DomSync.getChild(this.bodyElement, swimlaneRecord.domId);\n    }\n    /**\n     * Retrieves the element for the supplied swimlane / column intersection.\n     *\n     * ```javascript\n     * const element = taskBoard.getSwimlaneColumnElement(taskBoard.swimlanes.first, taskBoard.columns.last);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord\n     * @param {TaskBoard.model.ColumnModel} columnRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getSwimlaneColumnElement(swimlaneRecord, columnRecord) {\n        // Called with a swimlaneRecord (public API)\n        if (swimlaneRecord) {\n            // Get the column element for specified column / swimlane intersection, does not query DOM and is thus cheap\n            return DomSync.getChild(this.getSwimlaneElement(swimlaneRecord), `body.${columnRecord.domId}`);\n        }\n        // Called without, happens internally when not using swimlanes - to have simpler code paths\n        else {\n            return this.getColumnElement(columnRecord);\n        }\n    }\n    /**\n     * Retrieves the element for the supplied column.\n     *\n     * Only applicable when not using swimlanes. If you are using swimlanes, see {@link #function-getColumnElements}.\n     *\n     * @param {TaskBoard.model.ColumnModel} columnRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getColumnElement(columnRecord) {\n        return this.getColumnElements(columnRecord)?.[0];\n    }\n    /**\n     * Retrieves the elements for the supplied column. When using swimlanes, a column has one element per swimlane.\n     *\n     * @param {TaskBoard.model.ColumnModel} columnRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getColumnElements(columnRecord) {\n        // A column can span multiple swimlanes, it will have one element per swimlane.\n        // If we have multiple swimlanes, iterate them and retrieve column elements.\n        // This approach avoids querying DOM and is thus cheap\n        if (this.swimlanes?.count) {\n            return this.swimlanes.reduce((result, lane) => {\n                if (!lane.hidden) {\n                    result.push(this.getSwimlaneColumnElement(lane, columnRecord));\n                }\n                return result;\n            }, []);\n        }\n        // No swimlanes, still return as array for consistency\n        return [this.getSwimlaneColumnElement({ domId : 'default' }, columnRecord)];\n    }\n    /**\n     * Retrieves the header element for the supplied column.\n     *\n     * @param {TaskBoard.model.ColumnModel} columnRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getColumnHeaderElement(columnRecord) {\n        return DomSync.getChild(this.bodyElement, `header.${columnRecord.domId}`);\n    }\n    //endregion\n    //region Position based\n    /**\n     * Get the card element at (x, y)\n     * @param {Number} x\n     * @param {Number} y\n     * @param {String} cardSelector\n     * @returns {HTMLElement}\n     * @internal\n     */\n    getCardAt(x, y, cardSelector = '.b-taskboard-card') {\n        return this.documentRoot.elementFromPoint(x, y)?.closest(cardSelector);\n    }\n    //endregion\n    //region Cached measurements\n    cacheCSSVar(name, defaultValue) {\n        const me = this;\n        let size = me[`_${name}`];\n        if (size == null) {\n            const value = me.css[name];\n            size  = DomHelper.measureSize(value || defaultValue, me.element);\n            if (value) {\n                me[`_${name}`] = size;\n            }\n        }\n        return size;\n    }\n    // Cached card gap\n    get cardGap() {\n        return this.cacheCSSVar('cardGap', '1em');\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardDomEvents\n */\n/**\n * Mixin that handles dom events (click etc) for the TaskBoard and its columns and cards.\n *\n * {@inlineexample TaskBoard/view/mixin/TaskBoardDomEvents.js}\n *\n * Snippet showing two ways to add listeners:\n *\n * ```javascript\n * // Listener defined as part of config\n * const taskBoard = new TaskBoard({\n *     listeners : {\n *        taskClick({ taskRecord }) {\n *            Toast.show(`Clicked on ${taskRecord.name}`);\n *        }\n *     }\n * });\n *\n * // Listener added at runtime\n * taskBoard.on('taskDblClick', ({ taskRecord }) => { ... });\n * ```\n *\n * @mixin\n */\nexport default Target => class TaskBoardDomEvents extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardDomEvents';\n    static configurable = {\n        /**\n         * The name of the event that should activate a task and trigger editing (if an editing feature is active).\n         * Available options are: 'taskClick', 'taskDblClick' or null (disable)\n         * @default\n         * @config {'taskClick'|'taskDblClick'|null}\n         * @category Advanced\n         */\n        activateTaskEvent : 'taskDblClick',\n        domEvents : {\n            click       : 'click',\n            dblclick    : 'dblClick',\n            mouseup     : 'mouseUp',\n            mousedown   : 'mouseDown',\n            mousemove   : 'mouseMove',\n            mouseover   : 'mouseOver',\n            mouseout    : 'mouseOut',\n            keydown     : 'keyDown',\n            contextmenu : 'contextMenu'\n        },\n        domListeners : {}\n    };\n    #hoveredCardElement = null;\n    get widgetClass() {}\n    //endregion\n    //region Events\n    /**\n     * Triggered when a card is clicked.\n     *\n     * ```javascript\n     * taskBoard.on('taskClick', ({ taskRecord }) => {\n     *    Toast.show(`Clicked on ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event taskClick\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when a card is double clicked\n     *\n     * ```javascript\n     * taskBoard.on('taskDblClick', ({ taskRecord }) => {\n     *    Toast.show(`Double clicked on ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event taskDblClick\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when the mouse enters a card\n     *\n     * ```javascript\n     * taskBoard.on('taskMouseEnter', ({ taskRecord }) => {\n     *    Toast.show(`Mouse entered ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event taskMouseEnter\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when the mouse leaves a card\n     *\n     * ```javascript\n     * taskBoard.on('taskMouseLeave', ({ taskRecord }) => {\n     *    Toast.show(`Mouse left ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event taskMouseLeave\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when a task is \"activated\" by pressing `Enter` or double clicking it.\n     *\n     * By default this leads to the task editor being shown.\n     *\n     * ```javascript\n     * taskBoard.on('activateTask', ({ taskRecord }) => {\n     *    Toast.show(`Activated ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event activateTask\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when a task is rendered.\n     *\n     * This happens on initial render, when a task is added or when the task element is updated.\n     *\n     * Listening to this event allows you to manipulate the tasks element directly after it has been updated. Please\n     * note that we strongly recommend using a `taskRenderer` to manipulate the DomConfig used to update the task for\n     * most scenarios.\n     *\n     * If you listen for this event and manipulate the element in some way, you should also listen for\n     * `removeTaskElement` and revert/clean up the changes there.\n     *\n     * @event renderTask\n     * @param {TaskBoard.view.TaskBoard} source TaskBoard instance\n     * @param {TaskBoard.model.TaskModel} taskRecord Task being rendered\n     * @param {Boolean} isRefresh `true` if the element was updated, `false` if it was added\n     * @param {HTMLElement} element Tasks element\n     */\n    /**\n     * Triggered when all tasks in the task board are rendered\n     * @event renderTasks\n     * @param {TaskBoard.view.TaskBoard} source TaskBoard instance\n     * @param {TaskBoard.model.TaskModel[]} taskRecords Tasks being rendered\n     */\n    /**\n     * Triggered when a tasks element is removed.\n     *\n     * This happens when a task is removed or when it is move to another swimlane / column (in which case a `renderTask`\n     * event is triggered for the new element).\n     *\n     * If you used listener for `renderTask` to alter the element of tasks, you should also listen for this event to\n     * clean that modification up.\n     *\n     * @event removeTaskElement\n     * @param {TaskBoard.view.TaskBoard} source TaskBoard instance\n     * @param {String|Number} taskId Id of the task (not the record itself since it might be removed)\n     * @param {HTMLElement} element Tasks element\n     */\n    /**\n     * Triggered when a swimlane header is clicked.\n     *\n     * ```javascript\n     * taskBoard.on('swimlaneHeaderClick', ({ swimlaneRecord }) => {\n     *    Toast.show(`Clicked on ${swimlaneRecord.text}`);\n     * });\n     * ```\n     *\n     * @event swimlaneHeaderClick\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when a swimlane header is double-clicked.\n     *\n     * ```javascript\n     * taskBoard.on('swimlaneHeaderDblClick', ({ swimlaneRecord }) => {\n     *    Toast.show(`Double-clicked on ${swimlaneRecord.text}`);\n     * });\n     * ```\n     *\n     * @event swimlaneHeaderDblClick\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when a swimlane header is right-clicked.\n     *\n     * ```javascript\n     * taskBoard.on('swimlaneHeaderContextMenu', ({ swimlaneRecord }) => {\n     *    Toast.show(`Right-clicked on ${swimlaneRecord.text}`);\n     * });\n     * ```\n     *\n     * @event swimlaneHeaderContextMenu\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record\n     * @param {MouseEvent} event Browser event\n     */\n    //endregion\n    //region Triggering\n    // Sets the domListeners up, all relayed to triggerDomEvent()\n    changeDomListeners(domListeners) {\n        if (domListeners) {\n            for (const eventName in this.domEvents) {\n                domListeners[eventName] = 'triggerDomEvent';\n            }\n        }\n        return domListeners;\n    }\n    // Resolve records from the passed event\n    resolveEvent(event) {\n        const\n            { target }     = event,\n            taskRecord     = this.resolveTaskRecord(target),\n            columnRecord   = this.resolveColumnRecord(target),\n            swimlaneRecord = this.resolveSwimlaneRecord(target);\n        return { taskRecord, columnRecord, swimlaneRecord, event };\n    }\n    // \"Re-trigger\" a dom event as one of ours, populated with records and prefixed with either 'task'  or 'column'\n    // depending on event target\n    triggerDomEvent(event) {\n        const\n            me         = this,\n            args       = me.resolveEvent(event),\n            name       = me.domEvents[event.type],\n            { target } = event;\n        // Bail out for fields on a card, or if we are scrolling (_element to not trigger a recompose)\n        if (me.isScrolling || target.closest('.b-widget') !== me._element) {\n            return;\n        }\n        // Decorate the event for easy access later\n        event.taskBoardData = args;\n        let result;\n        // Trigger taskDblClick or columnDblClick, depending on what was resolved\n        if (args.taskRecord) {\n            const eventName = `task${StringHelper.capitalize(name)}`;\n            result = me.trigger(eventName, args);\n            if (eventName === me.activateTaskEvent && !event.defaultPrevented) {\n                me.trigger('activateTask', { taskRecord : args.taskRecord, event });\n            }\n        }\n        else if (args.columnRecord) {\n            if (target.closest('.b-taskboard-column-header')) {\n                result = me.trigger(`columnHeader${StringHelper.capitalize(name)}`, args);\n            }\n            else {\n                result = me.trigger(`column${StringHelper.capitalize(name)}`, args);\n            }\n        }\n        else if (args.swimlaneRecord) {\n            if (target.closest('.b-taskboard-swimlane-header')) {\n                result = me.trigger(`swimlaneHeader${StringHelper.capitalize(name)}`, args);\n            }\n            else {\n                result = me.trigger(`swimlane${StringHelper.capitalize(name)}`, args);\n            }\n        }\n        // Allow returning false from taskClick, onTaskClick etc. to prevent triggering 'click'\n        if (result === false) {\n            return;\n        }\n        me.trigger(name, args);\n        // Conjure up mouseEnter and mouseLeave events from mouseOver/mouseOut\n        if ((name === 'mouseOver' || name === 'mouseOut') && args.taskRecord) {\n            const cardElement = target.closest('.b-taskboard-card');\n            if (name === 'mouseOver' && cardElement !== me.#hoveredCardElement) {\n                me.#hoveredCardElement = cardElement;\n                me.trigger('taskMouseEnter', args);\n            }\n            if (name === 'mouseOut' && !cardElement.contains(event.relatedTarget)) {\n                me.#hoveredCardElement = null;\n                me.trigger('taskMouseLeave', args);\n            }\n        }\n    }\n    // Called as DomSync syncs elements\n    domSyncCallback({ action, domConfig, lastDomConfig, targetElement : element, syncId, jsx }) {\n        const\n            me              = this,\n            { elementType } = domConfig?.elementData ?? {},\n            isRefresh       = action === 'reuseOwnElement',\n            { reactComponent } = this;\n        if (jsx && this.processTaskItemContent) {\n            this.processTaskItemContent({\n                jsx,\n                targetElement : element,\n                reactComponent,\n                domConfig\n            });\n            return;\n        }\n        // Safeguard against other non dom synced elements being cleaned up\n        if (domConfig) {\n            // Card element synced\n            if (elementType === 'task') {\n                const\n                    { taskId } = domConfig.elementData,\n                    taskRecord = me.project.taskStore.getById(taskId);\n                if (action === 'newElement') {\n                    me.cardIntersectionObserver?.observe(element);\n                }\n                if (action === 'newElement' || action === 'reuseOwnElement') {\n                    (!me.isVirtualized || taskRecord.instanceMeta(me).intersects) && me.trigger('renderTask', { taskRecord, element, isRefresh });\n                }\n                else if (action === 'removeElement') {\n                    me.cardIntersectionObserver?.unobserve(element);\n                    me.trigger('removeTaskElement', { taskId, element });\n                }\n            }\n            // Column\n            else if (elementType === 'column') {\n                const\n                    { columnId, laneId } = domConfig.elementData,\n                    columnRecord         = me.columns.getById(columnId),\n                    swimlaneRecord       = laneId != null && me.swimlanes?.getById(laneId);\n                if (action === 'newElement' || action === 'reuseOwnElement') {\n                    me.trigger('renderColumn', { columnRecord, swimlaneRecord, element, isRefresh });\n                }\n                else if (action === 'removeElement') {\n                    me.trigger('removeColumnElement', { columnId, swimlaneRecord, element });\n                }\n            }\n            // Swimlane\n            else if (elementType === 'swimlane') {\n                const\n                    { laneId }     = domConfig.elementData,\n                    swimlaneRecord = laneId != null && laneId !== 'default' && me.swimlanes?.getById(laneId);\n                // Using swimlanes is optional\n                if (laneId !== 'default') {\n                    if (action === 'newElement' || action === 'reuseOwnElement') {\n                        me.trigger('renderSwimlane', { swimlaneRecord, element, isRefresh });\n                    }\n                    else if (action === 'removeElement') {\n                        me.trigger('removeSwimlaneElement', { swimlaneId : laneId, element });\n                    }\n                }\n            }\n            // Column header padder, for resize monitoring\n            else if (domConfig.class?.['b-taskboard-column-header-padder'] && me.resizeObserver) {\n                if (action === 'newElement') {\n                    if (!element.isResizeObserved) {\n                        me.resizeObserver.observe(element);\n                        element.isResizeObserved = true;\n                    }\n                }\n                if (action === 'removeElement') {\n                    if (element.isResizeObserved) {\n                        me.resizeObserver.unobserve(element);\n                        delete element.isResizeObserved;\n                    }\n                }\n            }\n        }\n    }\n    //endregion\n    //region Chainable handlers\n    onClick() {}\n    onMouseMove() {}\n    onMouseUp() {}\n    onTaskMouseDown() {}\n    onTaskClick() {}\n    onTaskDblClick() {}\n    onTaskContextMenu() {}\n    onColumnMouseDown() {}\n    onColumnHeaderClick(...args) {\n        super.onColumnHeaderClick(...args);\n    }\n    onSwimlaneHeaderClick(...args) {\n        super.onSwimlaneHeaderClick(...args);\n    }\n    onActivateTask() {}\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\nimport Scroller from '../../../Core/helper/util/Scroller.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardScroll\n */\n/**\n * Mixin that handles scrolling to tasks, columns and swimlanes.\n *\n * {@inlineexample TaskBoard/view/mixin/TaskBoardScroll.js}\n *\n * @mixin\n */\nexport default Target => class TaskBoardScroll extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardScroll';\n    static configurable = {\n        /**\n         * Default scroll options, see the options for {@link Core.helper.util.Scroller#function-scrollIntoView}\n         *\n         * Defaults to:\n         *\n         * ```javascript\n         * scrollOptions : {\n         *     animate   : true,\n         *     block     : 'nearest',\n         *     highlight : true\n         * }\n         * ```\n         *\n         * Can be overridden per call for all scroll functions.\n         *\n         * @config {BryntumScrollOptions}\n         * @category Advanced\n         */\n        scrollOptions : {\n            animate   : true,\n            block     : 'nearest',\n            highlight : true\n        },\n        testConfig : {\n            scrollOptions : {\n                animate : false,\n                block   : 'nearest'\n            }\n        }\n    };\n    get widgetClass() {}\n    static delayable = {\n        onScrollEnd : VersionHelper.isTestEnv ? 300 : 100\n    };\n    //endregion\n    //region Scroll tracking\n    onInternalPaint({ firstPaint }) {\n        if (firstPaint) {\n            const me = this;\n            EventHelper.on({\n                element : me.element,\n                scroll() {\n                    me.isScrolling = true;\n                    me.onScrollEnd();\n                },\n                capture : true,\n                thisObj : me\n            });\n        }\n    }\n    onScrollEnd() {\n        this.isScrolling = false;\n        if (this.recomposeOnScrollEnd) {\n            this.recompose();\n            this.recomposeOnScrollEnd = false;\n        }\n    }\n    //endregion\n    //region Type assertions\n    changeScrollOptions(scrollOptions) {\n        ObjectHelper.assertObject(scrollOptions, 'scrollOptions');\n        return scrollOptions;\n    }\n    //endregion\n    //region Scroll to\n    /**\n     * Scroll specified swimlane into view.\n     *\n     * ```javascript\n     * taskBoard.scrollToSwimlane('high');\n     * taskBoard.scrollToSwimlane(taskBoard.swimlanes.last);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|Number|String} swimlaneOrId Swimlane or its id\n     * @param {BryntumScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}\n     * @category Scrolling\n     */\n    async scrollToSwimlane(swimlaneOrId, options = this.scrollOptions) {\n        const\n            swimlane        = this.swimlanes.getById(swimlaneOrId),\n            swimlaneElement = swimlane && this.getSwimlaneElement(swimlane);\n        if (swimlaneElement) {\n            options = ObjectHelper.assign({\n                x       : false,\n                animate : options?.animate || options?.behavior === 'smooth'\n            }, options);\n            return Scroller.scrollIntoView(swimlaneElement, options, this.rtl);\n        }\n    }\n    /**\n     * Scroll specified column into view.\n     *\n     * ```javascript\n     * taskBoard.scrollToColumn('backlog');\n     * taskBoard.scrollToColumn(taskBoard.columns.first);\n     * ```\n     *\n     * @param {TaskBoard.model.ColumnModel|Number|String} columnOrId Column or its id\n     * @param {BryntumScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}\n     * @category Scrolling\n     */\n    async scrollToColumn(columnOrId, options = this.scrollOptions) {\n        const\n            column        = this.columns.getById(columnOrId),\n            columnElement = column && this.getColumnHeaderElement(column);\n        if (columnElement) {\n            // Only scroll in the X axis.\n            options = ObjectHelper.assign({\n                animate : options?.animate || options?.behavior === 'smooth',\n                y       : false\n            }, options);\n            return Scroller.scrollIntoView(columnElement, options, this.rtl);\n        }\n    }\n    /**\n     * Scroll to the intersection between specified swimlane and column.\n     *\n     * ```javascript\n     * taskBoard.scrollToIntersection('high', 'done');\n     * taskBoard.scrollToIntersection(taskBoard.swimlanes.low, taskBoard.columns.todo);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|Number|String} swimlaneOrId Swimlane or its id\n     * @param {TaskBoard.model.ColumnModel|Number|String} columnOrId Column or its id\n     * @param {BryntumScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}\n     * @category Scrolling\n     */\n    async scrollToIntersection(swimlaneOrId, columnOrId, options = this.scrollOptions) {\n        const\n            swimlane = this.swimlanes.getById(swimlaneOrId),\n            column   = this.columns.getById(columnOrId),\n            target   = swimlane && column && this.getSwimlaneColumnElement(swimlane, column);\n        if (target) {\n            options = ObjectHelper.assign({\n                animate    : options?.animate || options?.behavior === 'smooth',\n                edgeOffset : 10\n            }, options);\n            return Scroller.scrollIntoView(target, options, this.rtl);\n        }\n    }\n    /**\n     * Scroll the specified task into view.\n     *\n     * ```javascript\n     * taskBoard.scrollToTask(10);\n     * taskBoard.scrollToTask(taskStore.first);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel|Number|String} taskOrId\n     * @param {BryntumScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}\n     * @category Scrolling\n     */\n    async scrollToTask(taskOrId, options = this.scrollOptions) {\n        const\n            me          = this,\n            taskRecord  = me.project.taskStore.getById(taskOrId),\n            taskElement = taskRecord && me.getTaskElement(taskRecord);\n        if (taskElement) {\n            const edgeOffset = { start : 10, end : 10, top : 10, bottom : 10 };\n            // Make sure we don't end up under column or swimlane headers when using sticky headers\n            if (me.stickyHeaders) {\n                if (me.hasSwimlanes) {\n                    edgeOffset.top += me.getTaskSwimlaneElement(taskRecord).syncIdMap.header.offsetHeight;\n                }\n                edgeOffset.top += me.bodyElement.syncIdMap.header.offsetHeight;\n            }\n            if (me.isVirtualized && !me.getTaskHeight) {\n                // Rely on native scrolling for cards at an unknown position, due to unknown heights of cards above it.\n                // Native scrolling is able to somewhat compensate for changing heights during the scroll (seems to\n                // always scroll it slightly intersecting the view, no matter which settings)\n                taskElement.scrollIntoView();\n                // Wait until the task is rendered\n                await new Promise((resolve, reject) => {\n                    const detach = me.ion({\n                        renderTask({ taskRecord : renderedTaskRecord }) {\n                            if (renderedTaskRecord === taskRecord) {\n                                detach();\n                                resolve();\n                            }\n                        },\n                        expires : {\n                            delay : 200,\n                            alt   : reject\n                        }\n                    });\n                });\n            }\n            options = ObjectHelper.assign({\n                animate : options?.animate || options?.behavior === 'smooth',\n                edgeOffset\n            }, options);\n            return Scroller.scrollIntoView(taskElement, options, me.rtl);\n        }\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport ProjectModel from '../../model/ProjectModel.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardStores\n */\n/**\n * Mixin that handles TaskBoards stores, managed by a {@link TaskBoard.model.ProjectModel project}.\n *\n * @mixin\n */\nexport default Target => class TaskBoardStores extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardStores';\n    static configurable = {\n        projectModelClass : ProjectModel,\n        /**\n         * The {@link TaskBoard.model.ProjectModel} instance, containing the data visualized by the TaskBoard.\n         * @member {TaskBoard.model.ProjectModel} project\n         * @accepts {TaskBoard.model.ProjectModel|ProjectModelConfig} project\n         * @category Common\n         */\n        /**\n         * A {@link TaskBoard.model.ProjectModel#configs project config object} or an instance that holds all stores and\n         * data used by the TaskBoard.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     project : {\n         *         // Use a custom task model\n         *         taskModelClass : MyTaskModel,\n         *\n         *         // Supply inline data\n         *         tasksData : [\n         *             { id : 1, name: 'Task 1', ... },\n         *             ...\n         *         ]\n         * });\n         * ```\n         *\n         * Project has built-in crud manager functionality to handle syncing with a backend:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     project : {\n         *         transport : {\n         *             load : {\n         *                 url : 'data/data.json'\n         *             }\n         *     },\n         *     autoLoad : true\n         * });\n         *\n         * Also has built-in state tracking manager functionality to handle undo/redo:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     stm : {\n         *         autoRecord : true,\n         *         disabled   : false\n         *     }\n         * });\n         *\n         * @config {TaskBoard.model.ProjectModel|ProjectModelConfig}\n         * @category Data\n         */\n        project : {},\n        /**\n         * Inline {@link Scheduler.model.AssignmentModel assignments}, will be loaded into an internally created\n         * {@link Scheduler.data.AssignmentStore}  as a part of a {@link TaskBoard.model.ProjectModel project}.\n         * @prp {Scheduler.model.AssignmentModel[]|Object[]} assignments\n         * @category Data\n         */\n        assignments : null,\n        /**\n         * Inline {@link Scheduler.model.ResourceModel resources}, will be loaded into an internally created\n         * {@link Scheduler.data.ResourceStore} as a part of a {@link TaskBoard.model.ProjectModel project}.\n         * @prp {Scheduler.model.ResourceModel[]|Object[]} resources\n         * @category Data\n         */\n        resources : null,\n        /**\n         * Inline {@link TaskBoard.model.TaskModel tasks}, will be loaded into an internally created\n         * {@link TaskBoard.store.TaskStore} as a part of a {@link TaskBoard.model.ProjectModel project}.\n         * @prp {TaskBoard.model.TaskModel[]|Object[]} tasks\n         * @category Data\n         */\n        tasks : null,\n        /**\n         * Default values to apply to task records created by task boards features (such as the column header menu and\n         * the column toolbar)\n         *\n         * @config {TaskModelConfig}\n         * @category Data\n         */\n        newTaskDefaults : {},\n        loadMaskDefaults : {\n            useTransition : true,\n            showDelay     : 100\n        },\n        /**\n         * TaskBoard does not use a sync mask by default. If you want one, see\n         * {@link Core.mixin.LoadMaskable#config-syncMask} for configuration options.\n         *\n         * @config {String|Object|null}\n         * @default null\n         * @category Masking\n         */\n        syncMask : null\n    };\n    get widgetClass() {}\n    //endregion\n    //#region Inline data\n    get assignments() {\n        return this.project.assignmentStore.records;\n    }\n    updateAssignments(records) {\n        this.project.assignmentStore.data = records;\n    }\n    get resources() {\n        return this.project.resourceStore.records;\n    }\n    updateResources(records) {\n        this.project.resourceStore.data = records;\n    }\n    get tasks() {\n        return this.project.taskStore.records;\n    }\n    updateTasks(records) {\n        this.project.taskStore.data = records;\n    }\n    //#endregion\n    //region Type assertions\n    changeNewTaskDefaults(newTaskDefaults) {\n        ObjectHelper.assertObject(newTaskDefaults, 'newTaskDefaults');\n        return newTaskDefaults;\n    }\n    //endregion\n    //region Project\n    changeProject(project) {\n        if (project && !project.isModel) {\n            project = this.projectModelClass.new(project);\n        }\n        this.attachToProject(project);\n        return project;\n    }\n    attachToProject(project) {\n        const me = this;\n        // Enable masking with CrudManagerView\n        me.bindCrudManager(project);\n        if (project) {\n            const { taskStore } = project;\n            // Set up indices for the configured columnField & optional swimlaneField, for faster lookups\n            if (taskStore) {\n                const { storage } = taskStore;\n                storage.addIndex({ property : me.columnField, unique : false });\n                if (me.swimlaneField) {\n                    storage.addIndex({ property : me.swimlaneField, unique : false });\n                }\n                // For quicker lookup of tasks in a swimlane/column intersection\n                Reflect.defineProperty(taskStore.$master.modelClass.prototype, 'columnSwimlaneIntersection', {\n                    get() {\n                        return this.buildIndexKey({\n                            [me.columnField]   : this[me.columnField],\n                            [me.swimlaneField] : this[me.swimlaneField]\n                        });\n                    }\n                });\n                taskStore.$master.modelClass.prototype.buildIndexKey = function(data) {\n                    return `${data[me.columnField]}-/-${(me.swimlanes?.count && data[me.swimlaneField]) || 'default'}`;\n                };\n                storage.addIndex({ property : 'columnSwimlaneIntersection', unique : false, dependentOn : { [me.swimlaneField] : true, [me.columnField] : true } });\n            }\n            // Setup store listeners, mostly just recompose\n            me.attachToProjectStore(project.taskStore, {\n                change          : 'onTaskStoreChange',\n                changePreCommit : 'onTaskStoreEarlyChange',\n                refresh         : 'onTaskStoreRefresh'\n            });\n            me.attachToProjectStore(project.assignmentStore);\n            me.attachToProjectStore(project.resourceStore);\n        }\n    }\n    // Most store changes leads to a recompose, with exception of some TaskStore changes that are transitioned\n    attachToProjectStore(store, listenersConfig = {}) {\n        this.detachListeners(store.$name);\n        store?.ion({\n            name    : store.$name,\n            change  : 'recompose',\n            refresh : 'recompose',\n            thisObj : this,\n            ...listenersConfig\n        });\n    }\n    //endregion\n    //region Listeners\n    onTaskStoreEarlyChange({ action }) {\n        if (action === 'add') {\n            this.recomposeWithDomTransition({\n                addTransition : {\n                    height  : 1,\n                    opacity : 1\n                }\n            });\n        }\n    }\n    onTaskStoreChange({ action, changes }) {\n        const { columnField, swimlaneField } = this;\n        // Task removal and column/swimlane changes are transitioned\n        if (\n            action === 'remove' ||\n            action === 'filter' ||\n            (action === 'update' && (changes[columnField] || (swimlaneField && changes[swimlaneField])))\n        ) {\n            this.recomposeWithDomTransition({\n                removeTransition : {\n                    height  : 1,\n                    opacity : 1\n                }\n            });\n        }\n        else {\n            this.recompose();\n        }\n    }\n    onTaskStoreRefresh({ action }) {\n        if (action === 'sort') {\n            // Ignore sort if we override it anyway\n            !this.taskSorterFn && this.recomposeWithDomTransition();\n        }\n        else {\n            this.recompose();\n        }\n    }\n    //endregion\n    //region Utility\n    /**\n     * Add a new task to the specified column / swimlane intersection (swimlane is optional), scroll it into view and\n     * start editing it (if an editing feature is enabled).\n     *\n     * By default the task is created using the data defined in the {@link #config-newTaskDefaults} combined with values\n     * for the `columnField`, the `swimlaneField` and a generated `weight` to place it last. To override these or to\n     * supply your own values for any field, pass the `taskData` argument.\n     *\n     * If project is configured to auto sync changes to backend, the sync request will be awaited before editing starts.\n     *\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column to add the task to\n     * @param {TaskBoard.model.ColumnModel} [swimlaneRecord] Swimlane to add the task to\n     * @param {Object} [taskData] Data for the new task\n     * @category Common\n     */\n    async addTask(columnRecord, swimlaneRecord = null, taskData = {}) {\n        const\n            me         = this,\n            {\n                swimlaneField,\n                swimlanes,\n                project\n            }          = me,\n            columnBody = me.getColumnElement(columnRecord).syncIdMap.body,\n            lastCard   = columnBody.lastElementChild,\n            data       = {\n                [me.columnField] : columnRecord.id,\n                name             : me.L('L{TaskBoard.newTaskName}'),\n                weight           : (project.taskStore.max('weight') ?? 0) + 100,\n                ...me.newTaskDefaults,\n                ...taskData\n            };\n        let suspended = false;\n        if (swimlaneField) {\n            if (swimlaneRecord) {\n                data[swimlaneField] = swimlaneRecord.id;\n            }\n            else if (swimlanes?.count) {\n                data[swimlaneField] = swimlanes.first.id;\n            }\n        }\n        // If add is likely to cause a scroll, opt out of add transition and only animated the scroll\n        if (lastCard && lastCard.offsetTop + lastCard.offsetHeight > columnBody.clientHeight - 100) {\n            me.suspendDomTransition();\n            suspended = true;\n        }\n        const\n            // A sync will be scheduled on the add below if using autoSync, catch that\n            synced       = project.autoSync && project.await('sync', false),\n            [taskRecord] = project.taskStore.add(data);\n        // To have new tasks element available when trying to scroll to it\n        me.recompose.now();\n        // Await transition used when adding tasks, to be certain task is at correct pos\n        if (me.useDomTransition && !me.domTransitionSuspended) {\n            await me.await('transitionedRecompose', false);\n        }\n        if (me.isDestroyed) {\n            return;\n        }\n        // Await scroll to make sure inline editing works as expected\n        await me.scrollToTask(taskRecord, ObjectHelper.assign({}, me.scrollOptions, { highlight : false, block : 'nearest' }));\n        if (me.isDestroyed) {\n            return;\n        }\n        // Await any autoSync that we caught above\n        if (synced) {\n            await synced;\n            if (me.isDestroyed) {\n                return;\n            }\n            // Sync likely assigned a new id, make sure we are using that in DOM right away\n            me.recompose.now();\n        }\n        suspended && me.resumeDomTransition();\n        if (me.features.simpleTaskEdit) {\n            me.editTask(taskRecord);\n        }\n        return taskRecord;\n    }\n    /**\n     * Removes one or more tasks from the linked task store (and thus the TaskBoard).\n     *\n     * First fires a `'beforeTaskRemove'` event, which is preventable and async. Return `false` or a promise that\n     * resolves to `false` from a listener to prevent the operation.\n     *\n     * ```javascript\n     * taskBoard.on({\n     *     async beforeRemoveTask() {\n     *         const result = await askForConfirmation();\n     *         return result;\n     *     }\n     * });\n     *\n     * taskBoard.remove(myTask);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel|TaskBoard.model.TaskModel[]} taskRecord A single task or an array thereof to\n     * remove from the task store.\n     * @returns {Boolean} Returns `true` if the tasks were removed, `false` if the operation was prevented.\n     * @category Common\n     */\n    async removeTask(taskRecord) {\n        const taskRecords = ArrayHelper.asArray(taskRecord);\n        /**\n         * Triggered when one or more tasks are to be removed by a call to `removeTask()`.\n         *\n         * The UI routes through `removeTask()` (currently only the task menu offers task removal), this event can be\n         * used to add a confirmation flow or similar to those actions.\n         *\n         * Return `false` or a promise that resolves to `false` in a listener to prevent removal.\n         *\n         * ```javascript\n         * taskBoard.on({\n         *     async beforeRemoveTask() {\n         *         const result = await askForConfirmation();\n         *         return result;\n         *     }\n         * });\n         * ```\n         *\n         * @event beforeTaskRemove\n         * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Task records to be removed\n         * @preventable\n         * @async\n         */\n        if (await this.trigger('beforeTaskRemove', { taskRecords }) !== false) {\n            this.project.taskStore.remove(taskRecords);\n            return true;\n        }\n        return false;\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport Store from '../../../Core/data/Store.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport SwimlaneModel from '../../model/SwimlaneModel.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardSwimlanes\n */\n/**\n * Mixin that handles swimlanes for the TaskBoard.\n *\n * @mixin\n */\nexport default Target => class TaskBoardSwimlanes extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardSwimlanes';\n    static configurable = {\n        /**\n         * Store containing the TaskBoard swimlanes.\n         *\n         * @member {Core.data.Store} swimlanes\n         * @category Common\n         */\n        /**\n         * Store containing the TaskBoard swimlanes. A tasks {@link #config-swimlaneField} is matched against the `id`\n         * of a swimlane to determine in which swimlane it is displayed.\n         *\n         * Accepts an array of swimlane records/objects, a store instance, a store id or a store config object used to\n         * create a new store.\n         *\n         * When supplying an array, a store configured with {@link Core.data.mixin.StoreProxy#config-objectify} is\n         * automatically created. Using that config allows for a nicer interaction syntax with the swimlanes:\n         *\n         * ```javascript\n         * // Without objectify:\n         * taskBoard.swimlanes.getById('highprio').text = 'Important!';\n         *\n         * // With objectify:\n         * taskBoard.swimlanes.done.text = 'Finished';\n         * ```\n         *\n         * When supplying strings, the raw string will be used as the swimlanes `id` and a capitalized version of it is\n         * used as the swimlanes text:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *    swimlanes : [\n         *        'high',\n         *        'low'\n         *    ]\n         * });\n         * ```\n         *\n         * Is equivalent to:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *    swimlanes : [\n         *        { id : 'high', text : 'High' },\n         *        { id : 'low', text : 'Low' }\n         *    ]\n         * });\n         * ```\n         *\n         * @config {TaskBoard.model.SwimlaneModel[]|SwimlaneModelConfig[]|Core.data.Store|String|StoreConfig}\n         * @category Common\n         */\n        swimlanes : {},\n        /**\n         * Set to `true` to auto generate swimlanes when {@link #config-swimlanes} is undefined.\n         *\n         * A swimlane will be created for each distinct value of {@link #config-swimlaneField} on the tasks. The\n         * swimlanes will be sorted in alphabetical order. The following snippet will yield two swimlanes, Q1 and Q2:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    swimlaneField : 'quarter',\n         *\n         *    autoGenerateSwimlanes : true,\n         *\n         *    project : {\n         *        tasksData : [\n         *            { id : 1, name : 'Inform tenants', quarter : 'Q1' },\n         *            { id : 2, name : 'Renovate roofs', quarter : 'Q2' }\n         *        ]\n         *    }\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @category Advanced\n         */\n        autoGenerateSwimlanes : false,\n        /**\n         * Field on a task record used to determine which swimlane the task belongs to.\n         *\n         * ```javascript\n         * taskBoard.swimlaneField = 'category';\n         * ```\n         *\n         * @member {String} swimlaneField\n         * @category Common\n         */\n        /**\n         * Field on a task record used to determine which swimlane the task belongs to.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    // Use the \"prio\" field of tasks to determie which swimlane a task belongs to\n         *    swimlaneField : 'prio',\n         *\n         *    swimlanes : [\n         *        'high',\n         *        'low'\n         *    ],\n         *\n         *    project : {\n         *        tasksData : [\n         *            // Linked using the prio field, to the high swimlane\n         *            { id : 1, name : 'Fun task', prio : 'high' }\n         *        ]\n         *    }\n         * });\n         * ```\n         *\n         * @config {String}\n         * @category Common\n         */\n        swimlaneField : null\n    };\n    static properties = {\n        shouldAutoGenerateSwimlanes : false\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions\n    changeAutoGenerateSwimlanes(autoGenerateSwimlanes) {\n        ObjectHelper.assertBoolean(autoGenerateSwimlanes, 'autoGenerateSwimlanes');\n        return autoGenerateSwimlanes;\n    }\n    changeSwimlaneField(swimlaneField) {\n        ObjectHelper.assertString(swimlaneField, 'swimlaneField');\n        return swimlaneField;\n    }\n    //endregion\n    //region Config - swimlaneField\n    updateSwimlaneField(field, old) {\n        if (!this.isConfiguring) {\n            const { storage } = this.project.taskStore;\n            if (old && old !== this.columnField) {\n                storage.removeIndex(old);\n            }\n            storage.addIndex({ property : field, unique : false });\n        }\n        this.shouldAutoGenerateSwimlanes = field && this.autoGenerateSwimlanes;\n    }\n    //endregion\n    //region Config - swimlanes\n    changeSwimlanes(swimlanes) {\n        return Store.from(swimlanes, { objectify : true, modelClass : SwimlaneModel }, lane => {\n            if (typeof lane === 'string') {\n                return { id : lane, text : StringHelper.capitalize(lane) };\n            }\n            return lane;\n        });\n    }\n    updateSwimlanes(swimlanes) {\n        this.detachListeners('swimlanes');\n        if (swimlanes) {\n            // Link to us to be able to retrieve tasks in visual order\n            // $store is the store instance of an objectified store\n            (swimlanes.$store || swimlanes).taskBoard = this;\n            swimlanes.ion({\n                change  : 'onSwimlanesChange',\n                refresh : 'onSwimlanesChange',\n                thisObj : this\n            });\n        }\n    }\n    get swimlanes() {\n        const\n            me            = this,\n            { taskStore } = me.project;\n        // If there are no swimlanes defined but we have a swimlane field configured and we have tasks loaded, generate\n        // swimlanes from the tasks\n        if (me.shouldAutoGenerateSwimlanes && taskStore.count) {\n            me.swimlanes = taskStore.getDistinctValues(me.swimlaneField).sort();\n            me.shouldAutoGenerateSwimlanes = false;\n        }\n        return me._swimlanes;\n    }\n    onSwimlanesChange({ action }) {\n        // CRUD invalidates column/swimlane intersection index\n        if (action === 'add' || action === 'remove' || action === 'removeAll' || action === 'update') {\n            this.project.taskStore.storage.invalidateIndices();\n        }\n        if (action === 'remove' ||  action === 'update' || action === 'filter') {\n            const options = {};\n            if (action === 'update') {\n                options.addTransition = { height : 1, opacity : 1 };\n                options.removeTransition = { height : 1, opacity : 1 };\n            }\n            this.recomposeWithDomTransition(options);\n            return;\n        }\n        this.recompose();\n    }\n    //endregion\n    //region Data\n    get hasSwimlanes() {\n        return Boolean(this.swimlaneField && this.swimlanes?.count);\n    }\n    getSwimlaneTasks(swimlaneRecord) {\n        return this.project.taskStore.storage.findItem(this.swimlaneField, swimlaneRecord.id);\n    }\n    getSwimlane(taskRecord) {\n        return this.swimlaneField && this.swimlanes?.getById(taskRecord.getValue(this.swimlaneField));\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardVirtualization\n */\n/**\n * Mixin that handles partial virtualization for the TaskBoard.\n * See class docs for {@link TaskBoard/view/TaskBoard} for more information.\n *\n * @mixin\n */\nexport default Target => class TaskBoardVirtualization extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardVirtualization';\n    static configurable = {\n        /**\n         * The function is called for each task as part of the render loop, and is expected to return the height in\n         * pixels for the task. Using this function is only recommended when using partial virtualized rendering, see\n         * the {@link #config-virtualize} setting.\n         *\n         * How the height is determined is up to the application, it could for example return a fixed value:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *     getTaskHeight() {\n         *         return 150;\n         *     }\n         * }\n         * ```\n         *\n         * Or get the height from data:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *     getTaskHeight(taskRecord) {\n         *         return taskRecord.myTaskHeight;\n         *     }\n         * }\n         * ```\n         *\n         * Or use some custom application logic:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *     getTaskHeight(taskRecord) {\n         *         if (taskRecord.isCollapsed) {\n         *             return 20;\n         *         }\n         *\n         *         return taskRecord.myTaskHeight;\n         *     }\n         * }\n         * ```\n         *\n         * @prp {Function}\n         * @param {TaskBoard.model.TaskModel} taskRecord The task record\n         * @return {Number} The height of the task in pixels\n         * @category Advanced\n         */\n        getTaskHeight : null,\n        /**\n         * By turning on this setting you enable partial virtualized rendering for the board, which reduces initial\n         * rendering time and makes interaction less sluggish when using thousands of tasks. The tradeoff is that\n         * scrolling in most cases will be slower.\n         *\n         * For a nice UX, it is strongly recommended to also implement a {@link #config-getTaskHeight} function. Without\n         * it, the height of tasks out of view will be unknown and the behaviour when scrolling will be less than ideal.\n         *\n         * <div class=\"note\">Note that for normal datasets (depending on machine, but roughly <1000 tasks) performance\n         * might be better without partial virtualized rendering, since it adds some overhead.</div>\n         *\n         * <div class=\"note\">Also note that as part of the optimizations for partial virtualized rendering, the inner\n         * element in columns that contain cards is absolutely positioned. This leads to column not being able to\n         * automatically shrink wrap the cards, you will have to set a height on the swimlane (or task board if not\n         * using swimlanes) to size things correctly.</div>\n         *\n         * @prp {Boolean}\n         */\n        virtualize : {\n            value   : null,\n            $config : 'nullify'\n        },\n        /**\n         * Whether to draw cards on scroll, or only when scrolling ends.\n         *\n         * Only applies when using partial virtualized rendering (see {@link #config-getTaskHeight}).\n         *\n         * Setting this to `false` will boost scroll performance, but cards scrolled into view will be empty outlines\n         * until scrolling ends.\n         *\n         * @prp {Boolean}\n         */\n        drawOnScroll : true\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions and changers/updaters\n    changeVirtualize(virtualize) {\n        ObjectHelper.assertBoolean(virtualize, 'virtualize');\n        return virtualize;\n    }\n    updateVirtualize(virtualize) {\n        const me = this;\n        me.cardIntersectionObserver?.disconnect();\n        me.cardIntersectionObserver = null;\n        if (virtualize) {\n            // Observes cards coming into / out of view.\n            // Elements to observe are added from TaskBoardDomEvents#domSyncCallback\n            me.cardIntersectionObserver = new IntersectionObserver(entries => {\n                for (const entry of entries) {\n                    me.onCardIntersection(entry.target, entry.isIntersecting, entry);\n                }\n            });\n        }\n        // Allow toggling at runtime (mainly for bigdataset demo)\n        if (!this.isConfiguring && !this.isDestroying) {\n            this.refreshVirtualizedCards();\n        }\n    }\n    refreshVirtualizedCards() {\n        const me = this;\n        me.recompose.now();\n        if (me.cardIntersectionObserver) {\n            for (const taskElement of me.element.querySelectorAll('.b-taskboard-card')) {\n                me.cardIntersectionObserver.observe(taskElement);\n            }\n        }\n    }\n    changeGetTaskHeight(getTaskHeight) {\n        getTaskHeight && ObjectHelper.assertFunction(getTaskHeight, 'getTaskHeight');\n        return getTaskHeight;\n    }\n    updateGetTaskHeight(fn) {\n        // Allow toggling at runtime (mainly for bigdataset demo)\n        if (!this.isConfiguring && !this.isDestroying) {\n            this.refreshVirtualizedCards();\n        }\n    }\n    //endregion\n    compose(domConfig) {\n        domConfig.class['b-virtualized'] = this.isVirtualized;\n        return super.compose(domConfig);\n    }\n    get isVirtualized() {\n        return Boolean(this.cardIntersectionObserver);\n    }\n    // Flag cards as in view or out of view when their elements are intersecting the viewport (or not anymore)\n    onCardIntersection(cardElement, isIntersecting, entry) {\n        const\n            me              = this,\n            { taskRecord }  = cardElement.elementData,\n            instanceMeta    = taskRecord.instanceMeta(me),\n            wasIntersecting = instanceMeta.intersects;\n        if (wasIntersecting !== isIntersecting) {\n            instanceMeta.intersects = isIntersecting;\n            if (!isIntersecting && wasIntersecting) {\n                instanceMeta.lastHeight = entry.boundingClientRect.height;\n            }\n            // Recompose affected column right away if not scrolling, or if configured to draw on scroll\n            if (!me.isScrolling || me.drawOnScroll) {\n                me.queueColumnRecompose(me.getColumn(taskRecord), me.getSwimlane(taskRecord));\n            }\n            // Always do a full recompose when scrolling ends, to have all lastDomConfigs up to date\n            if (me.isScrolling) {\n                me.recomposeOnScrollEnd = true;\n            }\n        }\n    }\n    //region Rendering\n    // Creates a DOM config for the outline of a single card\n    renderCardOutline(taskRecord, columnRecord, swimlaneRecord) {\n        const\n            me                    = this,\n            { id, domId, weight } = taskRecord;\n        return {\n            id    : `${me.id}-card-${domId}`,\n            class : {\n                'b-taskboard-card' : true,\n                'b-out-of-view'    : true\n            },\n            tabIndex : 0,\n            dataset  : {\n                task          : domId,\n                column        : columnRecord.id,\n                lane          : swimlaneRecord?.id,\n                weight,\n                domTransition : true\n            },\n            elementData : {\n                elementType : 'task',\n                taskId      : id,\n                taskRecord,\n                columnRecord,\n                swimlaneRecord\n            },\n            style : {\n                height : me.getTaskHeight?.(taskRecord) || taskRecord.instanceMeta(me).lastHeight\n            }\n        };\n    }\n    // Overrides renderCard in TaskBoardBase, rendering outlines for cards out of view\n    renderCard(taskRecord, columnRecord, swimlaneRecord) {\n        const\n            { isVirtualized } = this,\n            meta              = taskRecord.instanceMeta(this);\n        // Render outlines for cards out of view when using virtualization\n        if (isVirtualized && !meta.dragging && !meta.intersects && !this.isSelected(taskRecord)) {\n            return this.renderCardOutline(taskRecord, columnRecord, swimlaneRecord);\n        }\n    }\n    //endregion\n};\n", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/TextItem\n */\n/**\n * Item that displays the value of the configured {@link #config-field} in a XSS safe way.\n *\n * {@inlineexample TaskBoard/view/item/TextItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype text\n */\nexport default class TextItem extends TaskItem {\n    static $name = 'TextItem';\n    static type = 'text';\n    static render({ domConfig, value, taskRecord, config }) {\n        // Special handling when bound to id\n        if (config.field === 'id' && taskRecord.hasGeneratedId) {\n            domConfig.class['b-generated-id'] = 1;\n            domConfig.text = '\u273B';\n        }\n        else {\n            domConfig.text = taskRecord.getFieldDefinition(config.field).print(value);\n        }\n    }\n}\nTextItem.initClass();\nTextItem._$name = 'TextItem';", "import TaskItem from './TaskItem.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport AvatarRendering from '../../../Core/widget/util/AvatarRendering.js';\n/**\n * @module TaskBoard/view/item/ResourceAvatarsItem\n */\n/**\n * Item displaying avatars or initials for a tasks assigned resources.\n *\n * {@inlineexample TaskBoard/view/item/ResourceAvatarsItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype resourceAvatars\n */\nexport default class ResourceAvatarsItem extends TaskItem {\n    static $name = 'ResourceAvatarsItem';\n    static type = 'resourceAvatars';\n    /**\n     * Maximum avatars to display by default. The last avatar will render an overflow indicator if the task has more\n     * resources assigned.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *     headerItems : {\n     *         resources : {\n     *             type       : 'resourceAvatars',\n     *             maxAvatars : 5\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * Overridden by card size based settings, see {@link TaskBoard.view.mixin.ResponsiveCards}.\n     *\n     * @config {Number} maxAvatars\n     * @default 7\n     * @category Common\n     */\n    /**\n     * Specify `true` to slightly overlap avatars for tasks that have multiple resources assigned. By default, they are\n     * displayed side by side.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *     headerItems : {\n     *         resources : {\n     *             overlap : true\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * @config {Boolean} overlap\n     */\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * Defaults to use a {@link TaskBoard.widget.ResourcesCombo}.\n     *\n     * @config {String|Object} editor\n     * @default resourcescombo\n     * @category Common\n     */\n    static defaultEditor = { type : 'resourcescombo', pickerWidth : '13em' };\n    static render({ taskBoard, domConfig, config, taskRecord, cardSize }) {\n        const\n            maxAvatars            = cardSize?.maxAvatars ?? config.maxAvatars ?? 7,\n            { resourceImagePath } = taskBoard,\n            { resources }         = taskRecord,\n            hasOverflow           = resources.length > maxAvatars,\n            overflowCount         = resources.length - maxAvatars + 1,\n            lastResource          = resources[maxAvatars];\n        let { avatarRendering } = taskBoard;\n        if (!avatarRendering) {\n            avatarRendering = taskBoard.avatarRendering = new AvatarRendering({\n                element     : taskBoard.element,\n                colorPrefix : 'b-taskboard-background-color-'\n            });\n        }\n        if (!taskBoard.project.resourceStore.count) {\n            return false;\n        }\n        ObjectHelper.merge(domConfig, {\n            class : {\n                'b-overlap' : config.overlap\n            },\n            children : [\n                // \"Normal\" avatars\n                ...resources\n                    // Want a stable order for resource to not move around on changes\n                    .sort((a, b) => a.name.localeCompare(b.name))\n                    .slice(0, maxAvatars - (hasOverflow ? 1 : 0)) // -1 for the overflow indicator\n                    .map((resource, i) => ({\n                        class : {\n                            'b-taskboard-resource-avatar-wrap' : 1\n                        },\n                        dataset : {\n                            resourceId : resource.id\n                        },\n                        children : [\n                            avatarRendering.getResourceAvatar({\n                                resourceRecord : resource,\n                                imageUrl       : resource.image === false ? null : (resource.imageUrl || resource.image && ((resourceImagePath || '') + resource.image)),\n                                initials       : resource.initials,\n                                color          : resource.eventColor,\n                                dataset        : {\n                                    btip : StringHelper.encodeHtml(resource.name)\n                                }\n                            })\n                        ]\n                    })),\n                // Overflow indicating avatar\n                hasOverflow && {\n                    class : {\n                        'b-taskboard-resource-avatar-overflow' : 1\n                    },\n                    dataset : {\n                        resourceId : '$overflow',\n                        btip       : resources.slice(-overflowCount).map(r => StringHelper.encodeHtml(r.name)).join(', '),\n                        count      : overflowCount\n                    },\n                    children : [\n                        avatarRendering.getResourceAvatar({\n                            resourceRecord : lastResource,\n                            imageUrl       : lastResource.image === false ? null : (lastResource.imageUrl || lastResource.image && (resourceImagePath + lastResource.image)),\n                            initials       : lastResource.initials\n                        })\n                    ]\n                }\n            ],\n            syncOptions : {\n                syncIdField : 'resourceId'\n            }\n        });\n    }\n    static onClick({ source : taskBoard, taskRecord, event }) {\n        const element = event.target.closest('.b-resource-avatar, .b-taskboard-resource-avatar-overflow');\n        if (element) {\n            if (element.matches('.b-resource-avatar')) {\n                const resourceRecord = taskBoard.project.resourceStore.getById(element.dataset.resourceId);\n                taskBoard.trigger('resourceAvatarClick', { resourceRecord, taskRecord, element, event });\n            }\n            else {\n                taskBoard.trigger('resourceAvatarOverflowClick', { taskRecord, element, event });\n            }\n            return false;\n        }\n    }\n}\nResourceAvatarsItem.initClass();\nResourceAvatarsItem._$name = 'ResourceAvatarsItem';", "import Base from '../../../Core/Base.js';\nimport TaskItem from '../item/TaskItem.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n// Items used by default\nimport '../item/TextItem.js';\nimport '../item/ResourceAvatarsItem.js';\n/**\n * @module TaskBoard/view/mixin/TaskItems\n */\nconst\n    fieldLess        = {\n        resourceAvatars : 1,\n        separator       : 1,\n        taskMenu        : 1\n    },\n    taskItemSelector = '.b-taskboard-taskitem',\n    afterRe          = /\\s*<\\s*/,\n    beforeRe         = /\\s*>\\s*/;\n/**\n * Mixin that allows adding multiple predefined items (sort of like task widgets) to tasks:\n *\n * {@inlineexample TaskBoard/view/mixin/TaskItems.js}\n *\n * You can pick from the following item types:\n *\n * * {@link TaskBoard/view/item/ImageItem image}\n * * {@link TaskBoard/view/item/JsxItem jsx}\n * * {@link TaskBoard/view/item/ProgressItem progress}\n * * {@link TaskBoard/view/item/RatingItem rating}\n * * {@link TaskBoard/view/item/ResourceAvatarsItem resourceAvatars}\n * * {@link TaskBoard/view/item/SeparatorItem separator}\n * * {@link TaskBoard/view/item/TagsItem tags}\n * * {@link TaskBoard/view/item/TemplateItem template}\n * * {@link TaskBoard/view/item/TextItem text}\n * * {@link TaskBoard/view/item/TodoListItem todoList}\n *\n * All of which are included in this demo:\n *\n * {@inlineexample TaskBoard/view/mixin/TaskItemsAll.js}\n *\n * ## Configuring which items to use\n *\n * Task cards are divided into three sections, header, body and footer. Each section can hold items. The following items\n * are defined by default:\n *\n * | Section     | Key             | Type                                                            | Bound to           |\n * |-------------|-----------------|-----------------------------------------------------------------|--------------------|\n * | headerItems | text            | {@link TaskBoard/view/item/TextItem text}                       | name               |\n * | bodyItems   | text            | {@link TaskBoard/view/item/TextItem text}                       | description        |\n * | footerItems | resourceAvatars | {@link TaskBoard/view/item/ResourceAvatarsItem resourceAvatars} | assigned resources |\n *\n * Add items to tasks by supplying the {@link #config-bodyItems bodyItems config} (the other sections work the same):\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     bodyItems : {\n *         // Will use \"prio\" as its field\n *         prio  : { type : 'text' },\n *         // Will use \"status\" as its field\n *         state : { type : 'text', field : 'status' }\n *     }\n * });\n * ```\n *\n * The items you supply are merged with the predefined items (as listed in the table above).\n *\n * The only always required config for new items is `type`, which determines what kind of task item to use. Which other\n * configs you can use depends on the item type.\n *\n * By default, the key in the `items` object will be used to link the item to a field on a task. You can override the\n * default by using the `field` config. Note that, in most cases, if the value of the backing field is `null` or\n * `undefined`, the item will not be rendered.\n *\n * To rearrange items, specify the {@link TaskBoard/view/item/TaskItem#config-order} config of each item. Applied as\n * flex order.\n *\n * You can also add items to a tasks header and footer, using {@link #config-headerItems} and\n * {@link #config-footerItems}.\n *\n * ## Manipulating items per task\n *\n * You can manipulate which items are shown for a task by supplying a {@link #config-processItems} function. It will be\n * called during rendering for each task and in it you can manipulate the passed `bodyItems` object. Set a property of\n * it to `null` to remove that item for that task:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     bodyItems : {\n *         progress  : { type : 'progress' }\n *     },\n *\n *     processItems({ taskRecord, bodyItems }) {\n *         if (taskRecord.status === 'done') {\n *             bodyItems.progress = null;\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/view/mixin/TaskItemsProcessItems.js}\n *\n * @mixin\n */\nexport default Target => class TaskItems extends (Target || Base) {\n    //region Config\n    static $name = 'TaskItems';\n    static configurable = {\n        /**\n         * Items in card header.\n         *\n         * As an object keyed by field names, values are {@link TaskBoard/view/item/TaskItem#configs TaskItem configs}.\n         *\n         * Reassigning this property merges the supplied object with the configured items:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    headerItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         *\n         * taskBoard.headerItems = {\n         *     status : { hidden : true },\n         *     tags   : { type : 'tags' }\n         * };\n         *\n         * // Results in:\n         * //\n         * // headerItems = {\n         * //     status : { type : 'text', hidden: true }\n         * //     tags   : { type : 'tags' }\n         * // }\n         * }\n         * ```\n         *\n         * @member {Object<String,TaskItemOptions>} headerItems\n         * @category Task content\n         */\n        /**\n         * Items to add to each card's header.\n         *\n         * Supplied keys are used to bind to a field on the {@link TaskBoard/model/TaskModel task record}, supplied\n         * values are used to configure the {@link TaskBoard/view/item/TaskItem#configs items}.\n         *\n         * You are always required to supply a `type`, see the docs for each item type for more information on available\n         * configs.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    headerItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         * ```\n         *\n         * For more information, see the {@link #class-description class description} above.\n         *\n         * @config {Object<String,TaskItemOptions>}\n         * @category Task content\n         */\n        headerItems : {\n            value : {\n                text : { type : 'text', field : 'name' }\n            },\n            $config : {\n                merge : 'items'\n            }\n        },\n        /**\n         * Items to add to each card's body.\n         *\n         * As an object keyed by field names, values are {@link TaskBoard/view/item/TaskItem#configs TaskItem configs}.\n         *\n         * Reassigning this property merges the supplied object with the configured items:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    bodyItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         *\n         * taskBoard.bodyItems = {\n         *     status : { hidden : true },\n         *     tags   : { type : 'tags' }\n         * };\n         *\n         * // Results in:\n         * //\n         * // bodyItems = {\n         * //     status : { type : 'text', hidden: true }\n         * //     tags   : { type : 'tags' }\n         * // }\n         * }\n         * ```\n         *\n         * @member {Object<String,TaskItemOptions>} bodyItems\n         * @category Task content\n         */\n        /**\n         * Items to add to each card's body.\n         *\n         * Supplied keys are used to bind to a field on the {@link TaskBoard/model/TaskModel task record}, supplied\n         * values are used to configure the {@link TaskBoard/view/item/TaskItem#configs items}.\n         *\n         * You are always required to supply a `type`, see the docs for each item type for more information on available\n         * configs.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    bodyItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         * ```\n         *\n         * For more information, see the {@link #class-description class description} above.\n         *\n         * @config {Object<String,TaskItemOptions>}\n         * @category Task content\n         */\n        bodyItems : {\n            value : {\n                text : { type : 'text', field : 'description' }\n            },\n            $config : {\n                merge : 'items'\n            }\n        },\n        /**\n         * Items in card footer.\n         *\n         * As an object keyed by field names, values are {@link TaskBoard/view/item/TaskItem#configs TaskItem configs}.\n         *\n         * Reassigning this property merges the supplied object with the configured items:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    footerItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         *\n         * taskBoard.footerItems = {\n         *     status : { hidden : true },\n         *     tags   : { type : 'tags' }\n         * };\n         *\n         * // Results in:\n         * //\n         * // footerItems = {\n         * //     status : { type : 'text', hidden: true }\n         * //     tags   : { type : 'tags' }\n         * // }\n         * }\n         * ```\n         *\n         * @member {Object<String,TaskItemOptions>} footerItems\n         * @category Task content\n         */\n        /**\n         * Items to add to each card's footer.\n         *\n         * Supplied keys are used to bind to a field on the {@link TaskBoard/model/TaskModel task record}, supplied\n         * values are used to configure the {@link TaskBoard/view/item/TaskItem#configs items}.\n         *\n         * You are always required to supply a `type`, see the docs for each item type for more information on available\n         * configs.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    footerItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         * ```\n         *\n         * For more information, see the {@link #class-description class description} above.\n         *\n         * @config {Object<String,TaskItemOptions>}\n         * @category Task content\n         */\n        footerItems : {\n            value : {\n                resourceAvatars : { type : 'resourceAvatars', field : 'resources' }\n            },\n            $config : {\n                merge : 'items'\n            }\n        },\n        /**\n         * A function called on each render before adding items to a tasks card, allowing runtime manipulation of them.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     processItems({ bodyItems, taskRecord }) {\n         *        // Remove the progress item for done tasks\n         *        if (taskRecord.status === 'done') {\n         *            bodyItems.progress = null;\n         *        }\n         *     }\n         * });\n         * ```\n         *\n         * NOTE: The function is only intended for manipulating the passed items, you should not update the passed\n         * `taskRecord` in it since updating records triggers another round of rendering.\n         *\n         * @config {Function}\n         * @param {Object} context\n         * @param {Object<String,TaskItemOptions>} context.headerItems Item config objects for the task header, keyed by ref\n         * @param {Object<String,TaskItemOptions>} context.bodyItems Item config objects for the task body, keyed by ref\n         * @param {Object<String,TaskItemOptions>} context.footerItems Item config objects for the task footer, keyed by ref\n         * @param {TaskBoard.model.TaskModel} context.taskRecord Record representing task to be rendered\n         * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n         * @category Task content\n         */\n        processItems : null\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions\n    changeProcessItems(processItems) {\n        ObjectHelper.assertFunction(processItems, 'processItems');\n        return processItems;\n    }\n    //endregion\n    // region Configuring items\n    mergeItems(items, old) {\n        if (old && items) {\n            items = ObjectHelper.mergeItems(old, items);\n        }\n        return items;\n    }\n    // Needed to allow reconfiguring on the fly (for responsive)\n    changeHeaderItems(items, old) {\n        ObjectHelper.assertObject(items, 'headerItems');\n        return this.mergeItems(items, old);\n    }\n    // Needed to allow reconfiguring on the fly (for responsive)\n    changeBodyItems(items, old) {\n        ObjectHelper.assertObject(items, 'bodyItems');\n        return this.mergeItems(items, old);\n    }\n    // Needed to allow reconfiguring on the fly (for responsive)\n    changeFooterItems(items, old) {\n        ObjectHelper.assertObject(items, 'footerItems');\n        return this.mergeItems(items, old);\n    }\n    //endregion\n    //region Rendering\n    // Render items to header, body or footer of the supplied task\n    renderItems(taskRecord, items, target, cardSize) {\n        for (const key in items) {\n            const config = items[key];\n            if (config && !config.hidden) {\n                // Defaults to use the key as the field, but allows overriding it using the field config\n                if (!('field' in config)) {\n                    if (key.includes('>')) {\n                        [config.field] = key.split(beforeRe);\n                    }\n                    else if (key.includes('<')) {\n                        [, config.field] = key.split(afterRe);\n                    }\n                    else {\n                        config.field = key;\n                    }\n                }\n                const\n                    { field } = config,\n                    value     = taskRecord.getValue(field);\n                // Most fields render nothing if they have no value, some are excluded from that logic (separator etc)\n                if (value != null || fieldLess[config.type] || config.renderNull) {\n                    const\n                        // TaskItem implements factoryable, we are not using instances but rather static items to avoid\n                        // creating one instance per card. Thus we only use the lookup functionality of factoryable\n                        item      = TaskItem.resolveType(config.type),\n                        typeCls   = `b-taskboard-${StringHelper.hyphenate(config.type)}`,\n                        // Base DomConfig, shared by all task items\n                        domConfig = {\n                            class : {\n                                'b-taskboard-taskitem' : 1,\n                                [typeCls]              : 1,\n                                [config.cls]           : config.cls,\n                                'b-editable'           : !taskRecord.readOnly && item.getEditorConfig({ config, item })\n                            },\n                            dataset : {\n                                role : `item-${field}`,\n                                field,\n                                ref  : key\n                            },\n                            elementData : {\n                                item,\n                                taskRecord,\n                                config\n                            },\n                            style : {\n                                order : config.order,\n                                style : config.style\n                            }\n                        },\n                        // Call items (static) renderer, further populating the DomConfig from above\n                        result    = item.render({ taskBoard : this, domConfig, value, config, taskRecord, cardSize });\n                    // Returning false from an items renderer prevents it from being shown\n                    if (result !== false) {\n                        target.children[key] = domConfig;\n                    }\n                }\n            }\n        }\n    }\n    // Hook into card rendering\n    populateCard(args) {\n        super.populateCard?.(args);\n        const\n            me                                   = this,\n            { processItems }                     = me,\n            { taskRecord, cardConfig, cardSize } = args,\n            {\n                headerItems : sizeHeaderItems,\n                bodyItems   : sizeBodyItems,\n                footerItems : sizeFooterItems\n            }                                    = cardSize || {},\n            { header, body, footer }             = cardConfig.children;\n        let { headerItems, bodyItems, footerItems } = me;\n        // Items are shared between all cards, clone before processing to only affect the set for this card\n        if (sizeHeaderItems || processItems) {\n            headerItems = ObjectHelper.clone(headerItems);\n        }\n        if (sizeBodyItems || processItems) {\n            bodyItems = ObjectHelper.clone(bodyItems);\n        }\n        if (sizeFooterItems || processItems) {\n            footerItems = ObjectHelper.clone(footerItems);\n        }\n        // Apply any card size specific items\n        sizeHeaderItems && ObjectHelper.merge(headerItems, sizeHeaderItems);\n        sizeBodyItems && ObjectHelper.merge(bodyItems, sizeBodyItems);\n        sizeFooterItems && ObjectHelper.merge(footerItems, sizeFooterItems);\n        // Allow app a shot at processing the items before they are shown. Can be used to add or remove items and\n        // manipulate configs\n        processItems?.({ headerItems, bodyItems, footerItems, taskRecord, cardSize });\n        // Render items into card header, body and footer\n        me.renderItems(taskRecord, headerItems, header, cardSize);\n        me.renderItems(taskRecord, bodyItems, body, cardSize);\n        me.renderItems(taskRecord, footerItems, footer, cardSize);\n    }\n    //endregion\n    //region Listeners\n    resolveTaskItem(element) {\n        // First look up, if inside an item. Then looks down, in case given a card or similar\n        const taskItemElement = element.closest(taskItemSelector) || element.querySelector(`:scope > * > ${taskItemSelector}, :scope > ${taskItemSelector}`);\n        if (taskItemElement) {\n            return {\n                ...taskItemElement.elementData,\n                element : taskItemElement\n            };\n        }\n        return null;\n    }\n    // Relay clicks to items\n    onTaskClick(args) {\n        const taskItem = this.resolveTaskItem(args.event.target);\n        if (taskItem) {\n            const { config, item  } = taskItem;\n            item.onClick?.({\n                config,\n                ...args\n            });\n        }\n        super.onTaskClick(args);\n    }\n    // Relay double clicks to items\n    onTaskDblClick(args) {\n        const taskItem = this.resolveTaskItem(args.event.target);\n        if (taskItem) {\n            const { config, item  } = taskItem;\n            item.onDblClick?.({\n                config,\n                ...args\n            });\n        }\n        super.onTaskDblClick(args);\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\n/**\n * @module TaskBoard/view/mixin/TaskNavigation\n */\nconst navigationActions = ['navigateDown', 'navigateLeft', 'navigateUp', 'navigateRight', 'activate'];\n/**\n * Mixin that handles keyboard navigation for the TaskBoard.\n *\n * See {@link TaskBoard.view.TaskBoard#keyboard-shortcuts} for information on keyboard navigation.\n *\n * @mixin\n */\nexport default Target => class TaskNavigation extends (Target || Base) {\n    //region Config\n    static $name = 'TaskNavigation';\n    static configurable = {\n        // Documented on TaskBoard\n        keyMap : {\n            ArrowDown  : 'navigateDown',\n            ArrowLeft  : 'navigateLeft',\n            ArrowUp    : 'navigateUp',\n            ArrowRight : 'navigateRight',\n            Enter      : 'activate'\n        },\n        navigateable : true,\n        /**\n         * Configure with `true` to change the default behaviour of keyboard navigation from moving focus to selecting\n         * tasks:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     selectOnNavigation : true\n         * });\n         * ```\n         *\n         * @config {Boolean|String}\n         * @default\n         * @category Selection\n         */\n        selectOnNavigation : false\n    };\n    get widgetClass() {}\n    //endregion\n    //region Utility\n    getTaskNear(x, y) {\n        const\n            { documentRoot } = this,\n            gap              = DomHelper.measureSize(\n                this.css.cardGap || '1em',\n                this.bodyElement.querySelector('.b-taskboard-swimlane-body .b-taskboard-column')\n            );\n        let task = documentRoot.elementFromPoint(x, y)?.closest('.b-taskboard-card');\n        // Nothing there, might have hit a gap, look up\n        if (!task) {\n            task = documentRoot.elementFromPoint(x, y - gap)?.closest('.b-taskboard-card');\n        }\n        // Still nothing, look down\n        if (!task) {\n            task = documentRoot.elementFromPoint(x, y + gap)?.closest('.b-taskboard-card');\n        }\n        return task;\n    }\n    //endregion\n    //region Navigation\n    focusAndOptionallySelect(taskElement, forceSelect) {\n        if (taskElement) {\n            const\n                me                   = this,\n                currentlyFocusedTask = me.resolveTaskRecord(document.activeElement);\n            // If a task is focused but not selected and we navigate away from it holding SPACE we want that task to\n            // become selected in addition to the newly focused task\n            if (forceSelect && currentlyFocusedTask && !me.isSelected(currentlyFocusedTask)) {\n                me.selectTask(currentlyFocusedTask, true);\n            }\n            // When configured with `selectOnNavigation : true` we should move the selection. If user holds SHIFT we\n            // should always extend it\n            if (me.selectOnNavigation || forceSelect) {\n                const taskToFocus = me.resolveTaskRecord(taskElement);\n                // Newly focused task is not selected, always select it (optionally extending the selection)\n                if (!me.isSelected(taskToFocus)) {\n                    me.selectTask(taskToFocus, forceSelect);\n                }\n                // Newly focused task already selected, deselect current if SHIFT is pressed (to allow extending and\n                // shrinking selection holding SHIFT)\n                else if (forceSelect) {\n                    me.deselectTask(currentlyFocusedTask);\n                }\n            }\n            // Always move focus\n            taskElement.focus();\n        }\n    }\n    // To task at same Y in next column\n    navigateNext(keyEvent, select) {\n        const\n            me                                           = this,\n            { taskRecord, swimlaneRecord, columnRecord } = keyEvent.taskBoardData,\n            taskElement                                  = me.getTaskElement(taskRecord);\n        let\n            found = null,\n            nextColumnRecord = columnRecord;\n        do {\n            nextColumnRecord = me.columns.getNext(nextColumnRecord, true);\n            if (!nextColumnRecord.hidden) {\n                const\n                    nextColumnElement = me.getSwimlaneColumnElement(swimlaneRecord, nextColumnRecord),\n                    x                 = Rectangle.from(nextColumnElement, null, true).center.x,\n                    y                 = Rectangle.from(taskElement, null, true).center.y;\n                found = me.getTaskNear(x, y);\n            }\n        }\n        while (!found && nextColumnRecord !== columnRecord);\n        me.focusAndOptionallySelect(found, select);\n    }\n    // To task at same Y in prev column\n    navigatePrev(keyEvent, select) {\n        const\n            me                                           = this,\n            { taskRecord, swimlaneRecord, columnRecord } = keyEvent.taskBoardData,\n            taskElement                                  = me.getTaskElement(taskRecord);\n        let\n            found = null,\n            prevColumnRecord = columnRecord;\n        do {\n            prevColumnRecord = me.columns.getPrev(prevColumnRecord, true);\n            if (!prevColumnRecord.hidden) {\n                const\n                    prevColumnElement = me.getSwimlaneColumnElement(swimlaneRecord, prevColumnRecord),\n                    x                 = Rectangle.from(prevColumnElement, null, true).center.x,\n                    y                 = Rectangle.from(taskElement, null, true).center.y;\n                found = me.getTaskNear(x, y);\n            }\n        }\n        while (!found && prevColumnRecord !== columnRecord);\n        me.focusAndOptionallySelect(found, select);\n    }\n    // Right navigates to next column for LTR and previous for RTL\n    navigateRight(event, select = false) {\n        this['navigate' + (this.rtl ? 'Prev' : 'Next')](event, select);\n    }\n    // Left navigates to previous column for LTR and next for RTL\n    navigateLeft(event, select = false) {\n        this['navigate' + (this.rtl ? 'Next' : 'Prev')](event, select);\n    }\n    // Find next task in same column (might be in next swimlane)\n    navigateDown(keyEvent, select = false) {\n        const\n            { taskRecord } = keyEvent.taskBoardData,\n            nextTask       = this.getNextTask(taskRecord, true);\n        this.focusAndOptionallySelect(this.getTaskElement(nextTask), select);\n    }\n    // Find prev task in same column (might be in prev swimlane)\n    navigateUp(keyEvent, select = false) {\n        const\n            { taskRecord } = keyEvent.taskBoardData,\n            prevTask       = this.getPreviousTask(taskRecord, true);\n        this.focusAndOptionallySelect(this.getTaskElement(prevTask), select);\n    }\n    // Activate (show editor)\n    activate(event) {\n        const { taskRecord } = this.resolveEvent(event);\n        // Only care about ENTER on a task\n        taskRecord && this.trigger('activateTask', { taskRecord, event });\n    }\n    isActionAvailable({ action, event }) {\n        const taskBoardData = this.resolveEvent(event);\n        event.taskBoardData = taskBoardData;\n        // Block activating if a task item has focus (eg. a button in the card)\n        if (action === 'activate' && taskBoardData.taskRecord && event.target !== this.getTaskElement(taskBoardData.taskRecord)) {\n            return false;\n        }\n        return Boolean((this.navigateable || !navigationActions.includes(action)) && taskBoardData?.taskRecord);\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module TaskBoard/view/mixin/TaskSelection\n */\n/**\n * Mixin that handles card selection for the TaskBoard.\n *\n * By default tasks can be selected using mouse clicks and the keyboard. To enable marquee selection, see\n * {@link TaskBoard.feature.TaskDragSelect}.\n *\n * ## Mouse selection\n *\n * Select and deselect cards using the mouse, using a modifier key to do multi selection:\n *\n * * Click on a card to focus and select it, deselecting any previously selected card.\n * * `CMD`/`CTRL` + click on a card to add or remove it from the selection.\n *\n * See {@link TaskBoard.view.TaskBoard#keyboard-shortcuts} for more information on selecting cards using the keyboard.\n *\n * @mixin\n */\nexport default Target => class TaskSelection extends (Target || Base) {\n    //region Config\n    static $name = 'TaskSelection';\n    static configurable = {\n        /**\n         * Selected tasks.\n         * @prp {TaskBoard.model.TaskModel[]} selectedTasks\n         * @category Common\n         */\n        selectedTasks : [],\n        /**\n         * A template method (empty by default) allowing you to control if a task can be selected or not.\n         *\n         * ```javascript\n         * new TaskBoard({\n         *     isTaskSelectable(taskRecord) {\n         *         return taskRecord.status !== 'done';\n         *     }\n         * })\n         * ```\n         *\n         * @param {TaskBoard.model.TaskModel} taskRecord The task record\n         * @returns {Boolean} `true` if the task can be selected, otherwise `false`\n         * @prp {Function}\n         * @category Selection\n         */\n        isTaskSelectable : null,\n        keyMap : {\n            ' '                : 'keyboardSelect',\n            'Ctrl+ '           : 'keyboardToggleSelect',\n            'Shift+ArrowDown'  : 'selectDown',\n            'Shift+ArrowLeft'  : 'selectLeft',\n            'Shift+ArrowUp'    : 'selectUp',\n            'Shift+ArrowRight' : 'selectRight'\n        }\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions\n    changeSelectedTasks(selectedTasks) {\n        ObjectHelper.assertArray(selectedTasks, 'selectedTasks');\n        return selectedTasks.filter(task => this.isTaskSelectable?.(task) !== false);\n    }\n    //endregion\n    //region Programmatic selection\n    toggleTaskSelection(taskRecord, add = false, forceSelect = null) {\n        const me = this;\n        // Toggle\n        if (forceSelect == null) {\n            if (me.isSelected(taskRecord)) {\n                // Clicked on a selected task without modifier key, select only it\n                if (!add) {\n                    me.selectTask(taskRecord, false);\n                }\n                // Using modifier key, deselect instead\n                else {\n                    me.deselectTask(taskRecord);\n                }\n            }\n            else {\n                me.selectTask(taskRecord, add);\n            }\n        }\n        // Force select\n        else if (forceSelect) {\n            me.selectTask(taskRecord, add);\n        }\n        // Force deselect\n        else {\n            me.deselectTask(taskRecord);\n        }\n    }\n    /**\n     * Select the supplied task, deselecting any previously selected by default.\n     * @param {TaskBoard.model.TaskModel} taskRecord Task to select\n     * @param {Boolean} [add] Specify `true` to add to selection instead of replacing it\n     * @category Selection\n     */\n    selectTask(taskRecord, add = false) {\n        const\n            { selectedTasks } = this,\n            event             = {\n                action : 'select',\n                select : [taskRecord]\n            };\n        // Abort if not selectable\n        if (this.isTaskSelectable?.(taskRecord) === false) {\n            return;\n        }\n        if (!add) {\n            event.deselect = selectedTasks.slice();\n            selectedTasks.length = 0;\n        }\n        ArrayHelper.include(selectedTasks, taskRecord);\n        this.triggerSelectionChange(event);\n        this.recompose();\n    }\n    /**\n     * Deselect the supplied task.\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @category Selection\n     */\n    deselectTask(taskRecord) {\n        ArrayHelper.remove(this.selectedTasks, taskRecord);\n        this.triggerSelectionChange({\n            action   : 'deselect',\n            deselect : [taskRecord]\n        });\n        this.recompose();\n    }\n    /**\n     * Deselect all tasks.\n     * @category Selection\n     */\n    deselectAll() {\n        const { selectedTasks } = this;\n        if (selectedTasks.length) {\n            const deselect = selectedTasks.slice();\n            selectedTasks.length = 0;\n            this.triggerSelectionChange({\n                action : 'deselect',\n                deselect\n            });\n            this.recompose();\n        }\n    }\n    /**\n     * Check if the supplied task is selected or not\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @returns {Boolean} Returns `true` if it is selected, `false` if not\n     * @category Selection\n     */\n    isSelected(taskRecord) {\n        return this.selectedTasks.includes(taskRecord);\n    }\n    triggerSelectionChange(event) {\n        /**\n         * Triggered when task selection changes.\n         *\n         * @event selectionChange\n         * @param {TaskBoard.view.TaskBoard} source TaskBoard instance\n         * @param {'select'|'deselect'} action Either 'select' or 'deselect', depending on operation\n         * @param {TaskBoard.model.TaskModel[]} selection All currently selected tasks\n         * @param {TaskBoard.model.TaskModel[]} select Tasks selected by the operation\n         * @param {TaskBoard.model.TaskModel[]} deselect Tasks deselected by the operation\n         */\n        this.trigger('selectionChange', Object.assign({\n            selection : this.selectedTasks,\n            select    : [],\n            deselect  : []\n        }, event));\n    }\n    //endregion\n    //region Listeners\n    onTaskClick(bryntumEvent) {\n        super.onTaskClick(bryntumEvent);\n        const { event, taskRecord } = bryntumEvent;\n        if (!event.defaultPrevented) {\n            this.toggleTaskSelection(taskRecord, event.ctrlKey);\n        }\n    }\n    keyboardSelect(keyEvent) {\n        if (!DomHelper.isEditable(keyEvent.target)) {\n            const { taskRecord } = this.resolveEvent(keyEvent);\n            if (taskRecord) {\n                this.toggleTaskSelection(taskRecord, false);\n                return true;\n            }\n        }\n        return false;\n    }\n    keyboardToggleSelect(keyEvent) {\n        const { taskRecord } = this.resolveEvent(keyEvent);\n        if (taskRecord) {\n            this.toggleTaskSelection(taskRecord, true);\n        }\n    }\n    onClick(event) {\n        super.onClick(event);\n        if (!event.taskRecord && this.navigateable) {\n            this.deselectAll();\n        }\n    }\n    selectUp(event) {\n        this.navigateUp(event, true);\n    }\n    selectDown(event) {\n        this.navigateDown(event, true);\n    }\n    selectLeft(event) {\n        this.navigateLeft(event, true);\n    }\n    selectRight(event) {\n        this.navigateRight(event, true);\n    }\n    //endregion\n    //region Rendering\n    populateCard(args) {\n        super.populateCard?.(args);\n        const { taskRecord, cardConfig } = args;\n        cardConfig.class['b-selected'] = this.isSelected(taskRecord);\n    }\n    populateBody(args) {\n        super.populateBody?.(args);\n        const { bodyConfig } = args;\n        bodyConfig.class['b-has-selection'] = Boolean(this.selectedTasks.length);\n    }\n    //endregion\n};\n", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/ImageItem\n */\n/**\n * Item displaying an image.\n *\n * Loaded from the configured {@link #config-field}, optionally prepended with a {@link #config-baseUrl}.\n *\n * {@inlineexample TaskBoard/view/item/ImageItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype image\n */\nexport default class ImageItem extends TaskItem {\n    static $name = 'ImageItem';\n    static type = 'image';\n    /**\n     * Url prepended to this items value.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *        picture : { type : 'image', baseUrl : 'images/' }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [\n     *            { id : 1, name : 'Task #1', picture : 'photo.jpg' },\n     *            { id : 2, name : 'Task #2', picture : 'image.jpg' }\n     *        ]\n     *    }\n     * });\n     *\n     * // Card for task #1 will render image \"images/photo.jpg\"\n     * // Card for task #2 will render image \"images/image.jpg\"\n     * ```\n     *\n     * @config {String} baseUrl\n     * @category Common\n     */\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * ImageItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n    static defaultEditor = null;\n    static render({ domConfig, value, config }) {\n        // Skip drawing when `image === false` or not assigned\n        if (value) {\n            Object.assign(domConfig, {\n                tag       : 'img',\n                src       : (config.baseUrl || '') + value,\n                draggable : false\n            });\n        }\n    }\n}\nImageItem.initClass();\nImageItem._$name = 'ImageItem';", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/JsxItem\n */\n/**\n * Item displaying content generated by a React (JSX) component\n *\n * {@note}JsxItem can only be used in React applications.{/@note}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype jsx\n */\nexport default class JsxItem extends TaskItem {\n    static $name = 'JsxItem';\n    static type = 'jsx';\n    /**\n     * Function used to generate JSX item content.\n     *\n     * Return a React Element (JSX) from the function:\n     *\n     * ```javascript\n     * import MyJsxItem from './MyJsxItem.js';\n     *\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *        prio : {\n     *          type : 'jsx',\n     *          jsx  : ({ taskRecord }) => <MyJsxItem taskRecord={taskRecord} />\n     *        }\n     *    }\n     * });\n     * ```\n     *\n     * @config {Function} jsx\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {JsxItemConfig} config Item config\n     * @param {Object} value Value of the configured field\n     * @returns React Element (JSX)\n     * @category Common\n     */\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * JsxItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n    static defaultEditor = null;\n    static render({ domConfig, config, taskRecord, value }) {\n        domConfig.retainChildren = true;\n        domConfig.children = [config.jsx({ value, taskRecord, config })];\n    }\n}\nJsxItem.initClass();\nJsxItem._$name = 'JsxItem';", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/ProgressItem\n */\n/**\n * Item displaying a progress bar.\n *\n * Progress is determined by the value of the configured {@link #config-field}. A max value (defaults to 100) can be\n * configured using the {@link #config-max} config.\n *\n * {@inlineexample TaskBoard/view/item/ProgressItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype progress\n */\nexport default class ProgressItem extends TaskItem {\n    static $name = 'ProgressItem';\n    static type = 'progress';\n    static configurable = {\n        /**\n         * Max value, at which the bar is full.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    bodyItems : {\n         *        progress : { type : 'progress', max : 10 }\n         *    },\n         *\n         *    project : {\n         *        tasksData : [\n         *            { id : 1, name : 'Task #1', progress : 9 }\n         *        ]\n         *    }\n         * });\n         *\n         * // Task #1 bar is 9/10 filled\n         * ```\n         *\n         * @config {Number} max\n         * @default 100\n         * @category Common\n         */\n    };\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * ProgressItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n    static defaultEditor = null;\n    static render({ domConfig, value, config }) {\n        const percent = Math.round(100 * value / (config.max || 100)) + '%';\n        domConfig.children = [\n            {\n                class   : 'b-taskboard-progress-outline',\n                dataset : {\n                    percent\n                },\n                children : [\n                    {\n                        class : 'b-taskboard-progress-progress',\n                        style : {\n                            width : percent\n                        },\n                        dataset : {\n                            percent\n                        }\n                    }\n                ]\n            }\n        ];\n        domConfig.dataset.percent = domConfig.dataset.btip = percent;\n    }\n}\nProgressItem.initClass();\nProgressItem._$name = 'ProgressItem';", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/RatingItem\n */\n/**\n * Item displaying a star rating.\n *\n * Rating is determined by the value of the configured {@link #config-field}. A max rating can be configured using the\n * {@link #config-max} config.\n *\n * {@inlineexample TaskBoard/view/item/RatingItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype rating\n */\nexport default class RatingItem extends TaskItem {\n    static $name = 'RatingItem';\n    static type = 'rating';\n    /**\n     * Max rating.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *       grade : { type : 'ratingitem', max : 5 }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [\n     *            { id : 1, name : 'Task #1', grade : 3 }\n     *        ]\n     *    }\n     * });\n     *\n     * // Card for task #1 will render 3 full stars and 2 faded,\n     * // for a total of 5 stars\n     * ```\n     *\n     * @config {Number} max\n     * @category Common\n     */\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * RatingItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n    static defaultEditor = null;\n    static render({ domConfig, value, config }) {\n        const { max = value } = config;\n        domConfig.children = [];\n        for (let i = 0; i < max; i++) {\n            domConfig.children.push({\n                tag   : 'i',\n                class : {\n                    'b-icon b-icon-star' : 1,\n                    'b-filled'           : i < value\n                }\n            });\n        }\n    }\n}\nRatingItem.initClass();\nRatingItem._$name = 'RatingItem';", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/SeparatorItem\n */\n/**\n * Item displaying a horizontal divider.\n *\n * {@inlineexample TaskBoard/view/item/SeparatorItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype separator\n */\nexport default class SeparatorItem extends TaskItem {\n    static $name = 'SeparatorItem';\n    static type = 'separator';\n    /**\n     * @hideconfigs editor\n     */\n    static defaultEditor = null;\n    static render({ domConfig }) {\n        domConfig.tag = 'hr';\n    }\n}\nSeparatorItem.initClass();\nSeparatorItem._$name = 'SeparatorItem';", "import Combo from '../../Core/widget/Combo.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/TagCombo\n */\n/**\n * A combo for picking tags. Works well to edit fields displayed by a {@link TaskBoard/view/item/TagsItem}, if data\n * uses strings to represent tags:\n *\n * {@inlineexample TaskBoard/widget/TagCombo.js}\n *\n * Consumes and outputs and array of strings, or if configured with a {@link #config-separator} a single string.\n *\n * If not seeded with any items/store, it tries to extract tags from the task store by collecting distinct values for\n * the field it is linked to (by {@link #config-name}).\n *\n * @extends Core/widget/Combo\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype tagcombo\n * @inputfield\n */\nexport default class TagCombo extends Combo.mixin(TaskBoardLinked) {\n    static $name = 'TagCombo';\n    static type = 'tagcombo';\n    static configurable = {\n        multiSelect : true,\n        editable    : false,\n        /**\n         * Separator used to split a string into tags. Required if data format uses a single string to represent tags.\n         * @config {String}\n         * @default\n         */\n        separator : ',',\n        picker : {\n            cls : 'b-tag-picker'\n        },\n        chipView : {\n            closable : false\n        }\n    };\n    afterConfigure() {\n        const me = this;\n        // Populate with tags from the task store\n        if (!me.store?.count && me.taskBoard && me.name) {\n            const\n                { name, separator } = me,\n                tags                = [];\n            me.taskBoard.project.taskStore.forEach(task => {\n                const taskTags = task[name];\n                if (taskTags) {\n                    if (typeof taskTags === 'string') {\n                        tags.push(...taskTags.split(separator));\n                    }\n                    else {\n                        tags.push(...taskTags);\n                    }\n                }\n            });\n            me.items = [...new Set(tags)].sort();\n        }\n    }\n    changeValue(value, old) {\n        this.$expectsString = false;\n        if (this.separator && typeof value === 'string') {\n            value = value.split(this.separator);\n            this.$expectsString = true;\n        }\n        super.changeValue(value, old);\n    }\n    get value() {\n        const value = super.value;\n        if (this.$expectsString) {\n            return value.join(this.separator);\n        }\n        return value;\n    }\n    set value(value) {\n        super.value = value;\n    }\n}\nTagCombo.initClass();\nTagCombo._$name = 'TagCombo';", "import TaskItem from './TaskItem.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport '../../widget/TagCombo.js';\n/**\n * @module TaskBoard/view/item/TagsItem\n */\n/**\n * Item displaying tags, either from string split into tags, an array of strings or by plucking a value from an array of\n * objects.\n *\n * Using a string, split into tags using the configured {@link #config-separator}:\n *\n * {@inlineexample TaskBoard/view/item/TagsItem.js}\n *\n * Using an array of strings, each entry is turned into a tag:\n *\n * {@inlineexample TaskBoard/view/item/TagsItemStringArray.js}\n *\n * Using an array of objects, gives you the most control over the tags. Requires configuring a\n * {@link #config-textProperty} and optionally a {@link #config-clsProperty}:\n *\n * {@inlineexample TaskBoard/view/item/TagsItemObjectArray.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype tags\n */\nexport default class TagsItem extends TaskItem {\n    static $name = 'TagsItem';\n    static type = 'tags';\n    /**\n     * Property used to determine the text for the tag. It is plucked from an array of objects that is used as the value\n     * for this item.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *       tags : { type : 'TagsItem', textProperty : 'title' }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [{\n     *            id : 1,\n     *            name : 'Issue #1',\n     *            tags : [\n     *                { title : 'bug', color : 'orange' },\n     *                { title : 'important', color : 'red' }\n     *            ]\n     *        }]\n     *    }\n     * });\n     *\n     * // Card for Issue #1 will render 2 tags, 'bug' and 'important'\n     * ```\n     *\n     * @config {String} textProperty\n     * @category Common\n     */\n    /**\n     * Property used to add a CSS class to each tag. It is plucked from an array of objects that is used as the value\n     * for this item.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *       tags : { type : 'TagsItem', clsProperty : 'color' }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [{\n     *            id : 1,\n     *            name : 'Issue #1',\n     *            tags : [\n     *                { title : 'bug', color : 'orange' },\n     *                { title : 'important', color : 'red' }\n     *            ]\n     *        }]\n     *    }\n     * });\n     *\n     * // Card for Issue #1 will render 2 tags, one with cls 'orange' and one with cls 'red'\n     * ```\n     *\n     * @config {String} clsProperty\n     * @category Common\n     */\n    /**\n     * Property used to split a value string into tags.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *       tags : { type : 'TagsItem', separator : ';' }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [{\n     *            id : 1,\n     *            name : 'Issue #1',\n     *            tags : 'bug;important'\n     *        }]\n     *    }\n     * });\n     *\n     * // Card for Issue #1 will render 2 tags, 'bug' and 'important'\n     * ```\n     *\n     * @config {String} separator\n     * @default ,\n     * @category Common\n     */\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * Defaults to use a {@link TaskBoard.widget.TagCombo}.\n     *\n     * @config {String|Object} editor\n     * @default tagcombo\n     * @category Common\n     */\n    static defaultEditor = { type : 'tagcombo', pickerWidth : '10em' };\n    static render({ domConfig, value, config }) {\n        let tags;\n        if (value) {\n            if (typeof value === 'string') {\n                tags = value.split(config.separator || ',').map(str => ({ text : str }));\n            }\n            else if (Array.isArray(value)) {\n                tags = value.map(entry => {\n                    if (typeof entry === 'string') {\n                        return { text : entry };\n                    }\n                    else {\n                        return {\n                            text : config.textProperty && entry[config.textProperty],\n                            cls  : config.clsProperty && entry[config.clsProperty]\n                        };\n                    }\n                });\n            }\n            if (tags) {\n                domConfig.children = tags.map(tag => {\n                    const cls = ('cls' in tag) ? tag.cls : DomHelper.makeValidId(tag.text, '-').toLowerCase();\n                    return {\n                        class : {\n                            'b-taskboard-tags-tag' : 1,\n                            [cls]                  : Boolean(cls)\n                        },\n                        text : tag.text\n                    };\n                });\n            }\n        }\n    }\n}\nTagsItem.initClass();\nTagsItem._$name = 'TagsItem';", "import ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/TemplateItem\n */\n/**\n * Item displaying content generated by a template function, see {@link #config-template}\n *\n * {@inlineexample TaskBoard/view/item/TemplateItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype template\n */\nexport default class TemplateItem extends TaskItem {\n    static $name = 'TemplateItem';\n    static type = 'template';\n    /**\n     * Template function used to generate task content.\n     *\n     * Return an HTML string or a DomConfig object from the function:\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *        prio : {\n     *          type     : 'template',\n     *          template : ({ taskRecord }) => `<i class=\"b-fa b-fa-tarffic-light\"></i> ${taskRecord.prio}`\n     *        }\n     *    }\n     * });\n     * ```\n     *\n     * @config {Function} template\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TemplateItemConfig} config Item config\n     * @param {Object} value Value of the configured field\n     * @returns {String|DomConfig|DomConfig[]} HTML string, DomConfig or DomConfig array\n     * @category Common\n     */\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * TemplateItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n    /**\n     * Specify as `true` to render the template item even if the backing field's value is `null` or `undefined`. Useful\n     * for example to display some custom string for null values (\"Empty\", \"Unset\" etc).\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    footerItems : {\n     *        category : {\n     *          type       : 'template',\n     *          renderNull : true,\n     *          template   : ({ value }) => value ? value : 'Empty'\n     *        }\n     *    }\n     * });\n     * ```\n     *\n     * @config {Boolean} renderNull\n     * @default false\n     * @category Common\n     */\n    static defaultEditor = null;\n    static render({ domConfig, value, config, taskRecord }) {\n        const html = config.template({ taskRecord, config, value });\n        if (typeof html === 'string') {\n            domConfig.html = html;\n        }\n        else if (ObjectHelper.isObject(html)) {\n            ObjectHelper.merge(domConfig, html);\n        }\n        else if (Array.isArray(html)) {\n            domConfig.children = html;\n        }\n    }\n}\nTemplateItem.initClass();\nTemplateItem._$name = 'TemplateItem';", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/TodoListItem\n */\n/**\n * Item displaying a list of todo items with associated checkboxes. It allows users to toggle the checkbox for each item\n * on the card to indicate if that item is completed or not. By adding a {@link TaskBoard/widget/TodoListField} to the\n * task editor users can also add, edit and remove todo items.\n *\n * {@inlineexample TaskBoard/view/item/TodoListItem.js}\n *\n * It consumes an array of objects representing todo items. For this item to work as indented, that array has to be\n * supplied by a task field using `type : 'array'`. It is also important to configure the {@link #config-textField} and\n * {@link #config-checkedField} to match properties of the objects in that array. This snippet illustrates a possible\n * setup:\n *\n * ```javascript\n * // Custom task model with a todo field of array type\n * class MyTask extends TaskModel {\n *     static fields = [\n *        { name : 'todo', type : 'array' }\n *     ];\n * }\n *\n * const taskBoard = new TaskBoard({\n *    project : {\n *        // Use the custom task model defined above\n *        taskModelClass : MyTask,\n *\n *        tasksData : [\n *            {\n *              id : 1,\n *              name : 'Order software',\n *              // The custom field, accepts an array\n *              todo : [\n *                  { title : 'Sketchup Pro', done : false },\n *                  { title : 'AutoCAD LT', done : true },\n *                  { title : 'Inventor', done : false }\n *              ]\n *            }\n *        ]\n *    },\n *\n *    bodyItems : {\n *        todo : {\n *            // Add a todo list item to card body\n *            type         : 'todoList',\n *            // Map text to the \"title\" field\n *            textField    : 'text',\n *            // Map checkbox to the \"done\" field\n *            checkedField : 'done'\n *        }\n *    }\n * });\n * ```\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype todoList\n */\nexport default class TodoListItem extends TaskItem {\n    static $name = 'TodoListItem';\n    static type = 'todoList';\n    /**\n     * Name of a property on a todo item to display as its text.\n     *\n     * @config {String} textField\n     * @category Common\n     * @default text\n     */\n    /**\n     * Name of a property on a todo item to use for the checkbox. The property is expected to be a boolean.\n     *\n     * @config {String} checkedField\n     * @category Common\n     * @default checked\n     */\n    /**\n     * Name of a property on a todo item whose value will be added as a CSS class to the todo item.\n     *\n     * @config {String} clsField\n     * @category Common\n     * @default cls\n     */\n    // private for now:\n    // checkedIcon\n    // uncheckedIcon\n    /**\n     * @hideconfigs editor\n     */\n    static defaultEditor = null;\n    static render({ domConfig, value, config, taskRecord }) {\n        if (value) {\n            const {\n                textField = 'text',\n                checkedField = 'checked',\n                clsField = 'cls',\n                checkedIcon = 'b-icon b-icon-checked',\n                uncheckedIcon = 'b-icon b-icon-unchecked'\n            } = config;\n            if (this.firstRender !== false) {\n                const dataField = taskRecord.getFieldDefinition(config.field);\n                if (!dataField.isArrayDataField) {\n                    throw new Error('TodoListItem has to be mapped to a field with `type : \"array\"`');\n                }\n            }\n            domConfig.children = value.map((todo, index) => ({\n                class : {\n                    'b-taskboard-todolist-todo' : 1,\n                    [todo[clsField]]            : todo[clsField],\n                    'b-checked'                 : todo[checkedField]\n                },\n                children : {\n                    icon : {\n                        tag   : 'i',\n                        class : todo[checkedField] ? checkedIcon : uncheckedIcon\n                    },\n                    text : {\n                        tag  : 'span',\n                        text : todo[textField]\n                    }\n                },\n                elementData : {\n                    index\n                }\n            }));\n            this.firstRender = false;\n        }\n    }\n    static onClick({ source : taskBoard, taskRecord, event, config }) {\n        const element = event.target.closest('.b-taskboard-todolist-todo');\n        if (element && !taskRecord.readOnly) {\n            const\n                { checkedField = 'checked', field } = config,\n                { index }                           = element.elementData,\n                // array fields has to be assigned a new array to detect a change, hence the slice\n                clone                               = taskRecord.getValue(field).slice(),\n                todo                                = clone[index];\n            // Toggle the mapped fields value\n            todo[checkedField] = !todo[checkedField];\n            // Assign the cloned array to the task record\n            taskRecord.setValue(field, clone);\n            taskBoard.trigger('todoToggle', { taskRecord, todo, checked : todo[checkedField], element, event });\n            // Don't want the click to select the task, feels a bit awkward when it does\n            event.preventDefault();\n        }\n    }\n    // Prevent editor from opening when dbl clicking a todo item\n    static onDblClick({ event }) {\n        event.preventDefault();\n    }\n}\nTodoListItem.initClass();\nTodoListItem._$name = 'TodoListItem';", "import LocaleHelper from '../../Core/localization/LocaleHelper.js';\nimport '../../Core/localization/En.js';\nconst locale = {\n    localeName : 'En',\n    localeDesc : 'English (US)',\n    localeCode : 'en-US',\n    GridBase : {\n        loadFailedMessage : 'Data loading failed!',\n        syncFailedMessage : 'Data synchronization failed!'\n    },\n    CrudManagerView : {\n        serverResponseLabel : 'Server response:'\n    },\n    TaskBoard : {\n        column           : 'column',\n        columns          : 'columns',\n        Columns          : 'Columns',\n        swimlane         : 'swimlane',\n        swimlanes        : 'swimlanes',\n        Swimlanes        : 'Swimlanes',\n        task             : 'task',\n        tasks            : 'tasks',\n        addTask          : 'Add L{TaskBoard.task}',\n        cancel           : 'Cancel',\n        changeColumn     : 'Change L{TaskBoard.column}',\n        changeSwimlane   : 'Change L{TaskBoard.swimlane}',\n        collapse         : text => `Collapse ${text}`,\n        color            : 'Color',\n        description      : 'Description',\n        editTask         : 'Edit L{TaskBoard.task}',\n        expand           : text => `Expand ${text}`,\n        filterColumns    : 'Filter L{TaskBoard.columns}',\n        filterSwimlanes  : 'Filter L{TaskBoard.swimlanes}',\n        filterTasks      : 'Filter L{TaskBoard.tasks}',\n        moveColumnLeft   : 'Move L{TaskBoard.column} left',\n        moveColumnRight  : 'Move L{TaskBoard.column} right',\n        name             : 'Name',\n        newTaskName      : 'New L{TaskBoard.task}',\n        removeTask       : 'Remove L{TaskBoard.task}',\n        removeTasks      : 'Remove L{TaskBoard.tasks}',\n        resources        : 'Resources',\n        save             : 'Save',\n        scrollToColumn   : 'Scroll to L{TaskBoard.column}',\n        scrollToSwimlane : 'Scroll to L{TaskBoard.swimlane}',\n        zoom             : 'Zoom'\n    },\n    TodoListField : {\n        add     : 'Add',\n        newTodo : 'New todo'\n    },\n    UndoRedo : {\n        UndoLastAction : 'Undo',\n        RedoLastAction : 'Redo'\n    }\n};\nexport default LocaleHelper.publishLocale(locale);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport Featureable from '../../Core/mixin/Featureable.js';\nimport Pluggable from '../../Core/mixin/Pluggable.js';\nimport State from '../../Core/mixin/State.js';\nimport ScrollManager from '../../Core/util/ScrollManager.js';\nimport Responsive from '../../Core/widget/mixin/Responsive.js';\nimport Styleable from '../../Core/widget/mixin/Styleable.js';\nimport Panel from '../../Core/widget/Panel.js';\nimport CrudManagerView from '../../Scheduler/crud/mixin/CrudManagerView.js';\nimport TaskBoardFeature from '../feature/TaskBoardFeature.js';\nimport ExpandCollapse from './mixin/ExpandCollapse.js';\nimport ResponsiveCards from './mixin/ResponsiveCards.js';\nimport TaskBoardColumns from './mixin/TaskBoardColumns.js';\nimport TaskBoardDom from './mixin/TaskBoardDom.js';\nimport TaskBoardDomEvents from './mixin/TaskBoardDomEvents.js';\nimport TaskBoardScroll from './mixin/TaskBoardScroll.js';\nimport TaskBoardStores from './mixin/TaskBoardStores.js';\nimport TaskBoardSwimlanes from './mixin/TaskBoardSwimlanes.js';\nimport TaskBoardVirtualization from './mixin/TaskBoardVirtualization.js';\nimport TaskItems from './mixin/TaskItems.js';\nimport TaskNavigation from './mixin/TaskNavigation.js';\nimport TaskSelection from './mixin/TaskSelection.js';\nimport '../localization/En.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\n/**\n * @module TaskBoard/view/TaskBoardBase\n */\nconst weightSorter = (a, b) => a.weight - b.weight;\n/**\n * A thin base class for {@link TaskBoard.view.TaskBoard}. Does not include any features by default, allowing smaller\n * custom-built bundles if used in place of {@link TaskBoard.view.TaskBoard}.\n *\n * **NOTE:** In most scenarios you probably want to use TaskBoard instead of TaskBoardBase.\n *\n * @extends Core/widget/Panel\n *\n * @mixes Core/mixin/Pluggable\n * @mixes Core/mixin/State\n * @mixes Core/widget/mixin/Responsive\n * @mixes Core/widget/mixin/Styleable\n * @mixes Scheduler/crud/mixin/CrudManagerView\n * @mixes TaskBoard/view/mixin/ExpandCollapse\n * @mixes TaskBoard/view/mixin/ResponsiveCards\n * @mixes TaskBoard/view/mixin/TaskBoardColumns\n * @mixes TaskBoard/view/mixin/TaskBoardDom\n * @mixes TaskBoard/view/mixin/TaskBoardDomEvents\n * @mixes TaskBoard/view/mixin/TaskBoardScroll\n * @mixes TaskBoard/view/mixin/TaskBoardStores\n * @mixes TaskBoard/view/mixin/TaskBoardSwimlanes\n * @mixes TaskBoard/view/mixin/TaskBoardVirtualization\n * @mixes TaskBoard/view/mixin/TaskItems\n * @mixes TaskBoard/view/mixin/TaskNavigation\n * @mixes TaskBoard/view/mixin/TaskSelection\n *\n * @features TaskBoard/feature/ColumnDrag\n * @features TaskBoard/feature/ColumnHeaderMenu\n * @features TaskBoard/feature/ColumnToolbars\n * @features TaskBoard/feature/SimpleTaskEdit\n * @features TaskBoard/feature/SwimlaneDrag\n * @features TaskBoard/feature/TaskDrag\n * @features TaskBoard/feature/TaskDragSelect\n * @features TaskBoard/feature/TaskEdit\n * @features TaskBoard/feature/TaskMenu\n * @features TaskBoard/feature/TaskTooltip\n * @widget\n */\nexport default class TaskBoardBase extends Panel.mixin(\n    Pluggable,\n    State,\n    Featureable,\n    Styleable,\n    CrudManagerView,\n    ExpandCollapse,\n    Responsive,\n    ResponsiveCards,\n    TaskBoardColumns,\n    TaskBoardDom,\n    TaskBoardDomEvents,\n    TaskBoardScroll,\n    TaskBoardStores,\n    TaskBoardSwimlanes,\n    TaskBoardVirtualization,\n    TaskItems,\n    TaskNavigation,\n    TaskSelection\n) {\n    //region Config\n    static $name = 'TaskBoardBase';\n    static type = 'taskboardbase';\n    static featureable = {\n        factory : TaskBoardFeature\n    };\n    static configurable = {\n        /** @hideconfigs autoUpdateRecord, defaultFocus, trapFocus, showTooltipWhenDisabled */\n        /** @hideproperties firstItem, lastItem, cellInfo, visibleChildCount */\n        /** @hidefunctions getAt */\n        layout : 'vbox',\n        /**\n         * An object containing Feature configuration objects (or `true` if no configuration is required)\n         * keyed by the Feature class name in all lowercase.\n         * @config {Object}\n         * @category Common\n         */\n        features : true,\n        /**\n         * An empty function by default, but provided so that you can override it. This function is called each time\n         * a task is rendered into the task board. It allows you to manipulate the DOM config object used for the card\n         * before it is synced to DOM, thus giving you control over styling and contents.\n         *\n         * NOTE: The function is intended for formatting, you should not update records in it since updating records\n         * triggers another round of rendering.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    taskRenderer({ taskRecord, cardConfig }) {\n         *        // Add an icon to all tasks header\n         *        cardConfig.children.header.children.icon = {\n         *            tag   : 'i',\n         *            class : 'b-fa b-fa-beer'\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * For more information, see the [Customize task contents guide](#TaskBoard/guides/customization/taskcontents.md).\n         *\n         * @config {Function}\n         * @param {Object} detail An object containing the information needed to render a task.\n         * @param {TaskBoard.model.TaskModel} detail.taskRecord The task record.\n         * @param {TaskBoard.model.ColumnModel} detail.columnRecord The column the task will be displayed in.\n         * @param {TaskBoard.model.SwimlaneModel} detail.swimlaneRecord The swimlane the task will be displayed in.\n         * @param {DomConfig} detail.cardConfig DOM config object for the cards element\n         * @returns {void}\n         * @category Task content\n         */\n        taskRenderer : null,\n        /**\n         * An empty function by default, but provided so that you can override it. This function is called each time\n         * a swimlane is rendered into the task board. It allows you to manipulate the DOM config object used for the\n         * swimlane before it is synced to DOM, thus giving you control over styling and contents.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    swimlaneRenderer({ swimlaneRecord, swimlaneConfig }) {\n         *        // Add an icon to all swimlane headers\n         *        swimlaneConfig.children.header.children.icon = {\n         *            tag   : 'i',\n         *            class : 'b-fa b-fa-dog'\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} detail An object containing the information needed to render a swimlane.\n         * @param {TaskBoard.model.SwimlaneModel} detail.swimlaneRecord The swimlane.\n         * @param {DomConfig} detail.swimlaneConfig DOM config object for the swimlane\n         * @returns {void}\n         * @category Advanced\n         */\n        swimlaneRenderer : null,\n        /**\n         * Controls how many cards are rendered to a row in each column. Can be controlled on a per column basis by\n         * setting {@link TaskBoard.model.ColumnModel#field-tasksPerRow}\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   tasksPerRow : 3\n         * });\n         * ```\n         *\n         * @config {Number}\n         * @category Common\n         */\n        tasksPerRow : 1,\n        /**\n         * Setting this will cause cards to expand to share the available width if there are fewer than\n         * {@link #config-tasksPerRow}.\n         *\n         * By default, the {@link #config-tasksPerRow} always applies, and if it is 3, then a single\n         * card in a column will be 33% of the available width.\n         *\n         * To have fewer cards than the {@link #config-tasksPerRow} evenly share available column width,\n         * configure this as `true`;\n         * @prp {Boolean}\n         * @category Common\n         */\n        stretchCards : null,\n        /**\n         * Show task count for a column in its header, appended after the title\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   showCountInHeader : false\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        showCountInHeader : true,\n        /**\n         * Makes column and swimlane headers sticky\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   stickyHeaders : true\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        stickyHeaders : false,\n        /**\n         * Experimental, animate actions that cannot be animated using CSS transitions. Currently includes:\n         * * Programmatically moving tasks\n         * * Moving tasks using the task editor\n         * * Adding tasks\n         * * Removing tasks\n         * * Sorting tasks\n         * * Hiding/showing/filtering columns\n         * * Hiding/showing/filtering swimlanes\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   useDomTransition : true\n         * });\n         * ```\n         * **NOTE**: This flag is not supported for Lightning Web Components\n         * @config {Boolean}\n         * @category Experimental\n         */\n        useDomTransition : false,\n        /**\n         * Path to load resource images from. Used by the for example the resource picker in the task editor and by the\n         * ResourceAvatars task item. Set this to display miniature images for each resource using their `image` field.\n         *\n         * **NOTE**: The path should end with a `/`:\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   resourceImagePath : 'images/resources/'\n         * });\n         * ```\n         *\n         * @config {String}\n         * @category Common\n         */\n        resourceImagePath : null,\n        /**\n         * CSS variable prefix, appended to the keys used in {@link #config-css}.\n         *\n         * Normally you do not need to change this value.\n         *\n         * @default\n         * @config {String}\n         * @category CSS\n         */\n        cssVarPrefix : 'taskboard',\n        /**\n         * Configuration values for the {@link Core.util.ScrollManager} class. It is used to manage column/body\n         * scrolling during task, column or swimlane drag.\n         * ```javascript\n         * new TaskBoard({\n         *     scrollManager : {\n         *         zoneWidth   : 100, // increase zone size\n         *         scrollSpeed : 3    // and scroll speed\n         *     }\n         * })\n         * ```\n         * @config {ScrollManagerConfig}\n         * @category Scrolling\n         */\n        scrollManager : {\n            value : {},\n            $config : ['nullify', 'lazy']\n        },\n        /**\n         * Allows sorting tasks in the UI independent of how they are sorted in the task store.\n         *\n         * Specify `true` to force sorting tasks by {@link TaskBoard/model/TaskModel#field-weight}.\n         *\n         * Supply a [sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n         * function to force a custom sort order.\n         *\n         * This is likely something you will want to use if combining TaskBoard with other products, sharing the\n         * project. Without this, sorting tasks in for example Gantt will also rearrange the cards on the board.\n         *\n         * As described above it accepts either a boolean or a Function, but it always returns a sorter function.\n         *\n         * @prp {Function} taskSorterFn\n         * @accepts {Boolean|Function}\n         * @config {Function}\n         * @param {TaskBoard.model.TaskModel} first The first task to compare\n         * @param {TaskBoard.model.TaskModel} second The second task to compare\n         * @returns {Number} Return `1` if first task is greater than second task, `-1` if the opposite is true or `0`\n         * if they are equal\n         * @category Advanced\n         */\n        taskSorterFn : null,\n        /**\n         * See {@link TaskBoard.view.TaskBoard#keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>} keyMap\n         * @category Common\n         */\n        contentElMutationObserver : false,\n        textContent : false,\n        // We can scroll in both axes.\n        // Scrollable also syncs the b-horizontal-overflow and b-vertical-overflow classes\n        // to allow styles to depend upon overflow state.\n        scrollable : true\n    };\n    isInitiallyComposed    = false;\n    domTransitionSuspended = 0;\n    columnRecomposeQueue   = new Map();\n    static delayable = {\n        recomposeColumns : 'raf'\n    };\n    //endregion\n    //region Overrides\n    onPaintOverride() {\n        // Internal procedure used for paint method overrides\n        // Not used in onInternalPaint() because it may be chained on instance and Override won't be applied\n    }\n    onInternalPaint(...args) {\n        if (this.onPaintOverride()) {\n            return;\n        }\n        super.onInternalPaint(...args);\n    }\n    //endregion\n    //region Type assertions and changers/updaters\n    changeResourceImagePath(resourceImagePath) {\n        ObjectHelper.assertString(resourceImagePath, 'resourceImagePath');\n        return resourceImagePath;\n    }\n    changeUseDomTransition(useDomTransition) {\n        ObjectHelper.assertBoolean(useDomTransition, 'useDomTransition');\n        return useDomTransition;\n    }\n    changeStickyHeaders(stickyHeaders) {\n        ObjectHelper.assertBoolean(stickyHeaders, 'stickyHeaders');\n        return stickyHeaders;\n    }\n    changeScrollManager(scrollManager, oldScrollManager) {\n        oldScrollManager?.destroy();\n        if (scrollManager) {\n            return ScrollManager.new({\n                element : this.element,\n                owner   : this\n            }, scrollManager);\n        }\n        return null;\n    }\n    changeShowCountInHeader(showCountInHeader) {\n        ObjectHelper.assertBoolean(showCountInHeader, 'showCountInHeader');\n        return showCountInHeader;\n    }\n    changeTasksPerRow(tasksPerRow) {\n        ObjectHelper.assertNumber(tasksPerRow, 'tasksPerRow');\n        return tasksPerRow;\n    }\n    changeSwimlaneRenderer(swimlaneRenderer) {\n        ObjectHelper.assertFunction(swimlaneRenderer, 'swimlaneRenderer');\n        return swimlaneRenderer;\n    }\n    changeTaskRenderer(taskRenderer) {\n        ObjectHelper.assertFunction(taskRenderer, 'taskRenderer');\n        return taskRenderer;\n    }\n    changeTaskSorterFn(fn) {\n        if (fn === true) {\n            return weightSorter;\n        }\n        fn && ObjectHelper.assertFunction(fn, 'taskSorterFn');\n        return fn;\n    }\n    //endregion\n    //region Recompose columns\n    // Queue a column for recomposition on next frame\n    queueColumnRecompose(columnRecord, swimlaneRecord) {\n        this.columnRecomposeQueue.set(`${columnRecord.id}.-.${swimlaneRecord?.id}`, { columnRecord, swimlaneRecord });\n        this.recomposeColumns();\n    }\n    // RAF function to recompose all queued columns\n    recomposeColumns() {\n        for (const [, { columnRecord, swimlaneRecord }] of this.columnRecomposeQueue) {\n            this.recomposeColumn(columnRecord, swimlaneRecord);\n        }\n        this.columnRecomposeQueue.clear();\n    }\n    // Recompose a single column / swimlane intersection\n    recomposeColumn(columnRecord, swimlaneRecord) {\n        const\n            element   = this.getSwimlaneColumnElement(swimlaneRecord, columnRecord),\n            domConfig = DomHelper.normalizeChildren(this.renderColumn(swimlaneRecord, columnRecord));\n        domConfig.onlyChildren = true;\n        DomSync.sync({\n            targetElement : element,\n            domConfig,\n            callback      : this.domSyncCallback,\n            syncOptions   : {\n                syncIdField      : 'column',\n                releaseThreshold : 0\n            }\n        });\n    }\n    //endregion\n    //region Render\n    // Creates a DOM config for a single card, calling any configured taskRenderer() in the process\n    renderCard(taskRecord, columnRecord, swimlaneRecord) {\n        // Allow mixins to fully control card rendering (used by TaskBoardVirtualization)\n        const overriddenCard = super.renderCard(taskRecord, columnRecord, swimlaneRecord);\n        if (overriddenCard) {\n            return overriddenCard;\n        }\n        const\n            me                                = this,\n            { id, domId, eventColor, weight } = taskRecord,\n            color                             = eventColor || swimlaneRecord?.color || columnRecord.color,\n            namedColor                        = DomHelper.isNamedColor(color) ? color : null,\n            cardSize                          = me.getCardSize(columnRecord, swimlaneRecord),\n            cardConfig                        = {\n                id    : `${me.id}-card-${domId}`,\n                class : {\n                    'b-taskboard-card'                  : true,\n                    [`b-taskboard-color-${namedColor}`] : namedColor,\n                    'b-readonly'                        : taskRecord.readOnly,\n                    ...taskRecord.cls\n                },\n                tabIndex : 0,\n                dataset  : {\n                    task          : domId,\n                    column        : columnRecord.id,\n                    lane          : swimlaneRecord?.id,\n                    weight,\n                    domTransition : true\n                },\n                style : {\n                    color  : namedColor ? null : color,\n                    height : me.getTaskHeight?.(taskRecord) ?? null\n                },\n                elementData : {\n                    elementType : 'task',\n                    taskId      : id,\n                    taskRecord,\n                    columnRecord,\n                    swimlaneRecord\n                },\n                children : {\n                    header : {\n                        tag   : 'header',\n                        class : {\n                            'b-taskboard-card-header' : 1\n                        },\n                        children    : {},\n                        syncOptions : {\n                            syncIdField : 'role'\n                        }\n                    },\n                    body : {\n                        tag   : 'section',\n                        class : {\n                            'b-taskboard-card-body' : 1\n                        },\n                        children    : {},\n                        syncOptions : {\n                            syncIdField : 'role'\n                        }\n                    },\n                    footer : {\n                        tag   : 'footer',\n                        class : {\n                            'b-taskboard-card-footer' : 1\n                        },\n                        children    : {},\n                        syncOptions : {\n                            syncIdField : 'role'\n                        }\n                    }\n                }\n            },\n            { children }             = cardConfig,\n            { header, body, footer } = children;\n        // Chained by features\n        me.populateCard({\n            taskRecord,\n            columnRecord,\n            swimlaneRecord,\n            cardConfig,\n            cardSize\n        });\n        // Supplied by app\n        me.taskRenderer?.({\n            taskRecord,\n            columnRecord,\n            swimlaneRecord,\n            cardConfig,\n            cardSize\n        });\n        // Remove unused parts of the card\n        if (header.html == null && header.text == null && (!header.children || Object.keys(header.children).length === 0)) {\n            children.header = null;\n        }\n        if (body.html == null && body.text == null && (!body.children || Object.keys(body.children).length === 0)) {\n            children.body = null;\n        }\n        if (footer.html == null && footer.text == null && (!footer.children || Object.keys(footer.children).length === 0)) {\n            children.footer = null;\n        }\n        return cardConfig;\n    }\n    renderColumnHeader(columnRecord) {\n        const\n            me                 = this,\n            { text, id, domId, width, flex, minWidth, color, tooltip } = columnRecord,\n            namedColor         = DomHelper.isNamedColor(color) ? color : null,\n            columnHeaderConfig = {\n                id    : `${me.id}-column-header-${domId}`,\n                class : {\n                    'b-taskboard-column-header'         : 1,\n                    'b-fixed-width'                     : width && !flex,\n                    [`b-taskboard-color-${namedColor}`] : namedColor,\n                    'b-last'                            : columnRecord === this.columns.last\n                },\n                style : {\n                    color : namedColor ? null : color,\n                    width,\n                    flex,\n                    minWidth\n                },\n                children : {\n                    padder : {\n                        class : {\n                            'b-taskboard-column-header-padder' : 1\n                        },\n                        children : {\n                            title : {\n                                class : {\n                                    'b-taskboard-column-title' : 1\n                                },\n                                dataset : {\n                                    btip : tooltip\n                                },\n                                children : [\n                                    {\n                                        tag   : 'span',\n                                        class : 'b-column-title-text',\n                                        text\n                                    },\n                                    me.showCountInHeader && {\n                                        tag   : 'span',\n                                        class : {\n                                            'b-taskboard-column-count' : 1\n                                        },\n                                        html : `(${me.getColumnTasks(columnRecord)?.length ?? 0})`\n                                    }\n                                ]\n                            }\n                        }\n                    }\n                },\n                dataset : {\n                    column        : domId,\n                    domTransition : true\n                },\n                elementData : {\n                    elementType : 'columnHeader',\n                    columnId    : id\n                }\n            };\n        Tooltip.showOverflow = true;\n        // Chained by features\n        me.populateColumnHeader({\n            columnRecord,\n            columnHeaderConfig\n        });\n        // Supplied by app\n        me.columnHeaderRenderer?.({\n            columnRecord,\n            columnHeaderConfig\n        });\n        return columnHeaderConfig;\n    }\n    renderColumn(swimlaneRecord, columnRecord) {\n        const\n            me            = this,\n            {\n                taskSorterFn,\n                stretchCards,\n                columnField,\n                swimlaneField\n            }             = me,\n            {\n                width,\n                flex,\n                id,\n                domId,\n                minWidth,\n                color\n            }             = columnRecord,\n            { taskStore } = me.project,\n            // Tasks in this column / swimlane intersection. Fetched using an index for better performance, except when\n            // using a tree store, since only the expended tasks are indexed then (only those are in storage)\n            tasks         = taskStore.isTree\n                ? taskStore.query(r =>\n                    r[columnField] === id &&\n                    (!swimlaneField || !swimlaneRecord || r[swimlaneField] === swimlaneRecord.id) // Might have no lanes\n                )\n                : Array.from(taskStore.storage.findItem(\n                    'columnSwimlaneIntersection',\n                    `${columnRecord.id}-/-${swimlaneRecord?.id ?? 'default'}`\n                ) || []),\n            perRow       = me.getTasksPerRow(columnRecord, swimlaneRecord),\n            elementId    = `${me.id}-column-${swimlaneRecord?.domId ?? 'default'}-${domId}`,\n            namedColor   = DomHelper.isNamedColor(color) ? color : null,\n            columnConfig = {\n                id    : elementId,\n                class : {\n                    'b-taskboard-column'                                 : 1,\n                    'b-fixed-width'                                      : width && !flex,\n                    [`b-${perRow}-task${perRow > 1 ? 's' : ''}-per-row`] : 1,\n                    'b-inline'                                           : perRow > 1,\n                    [`b-taskboard-color-${namedColor}`]                  : namedColor,\n                    'b-last'                                             : columnRecord === this.columns.last\n                },\n                style : {\n                    color : namedColor ? null : color,\n                    width,\n                    flex,\n                    minWidth\n                },\n                dataset : {\n                    column        : domId,\n                    lane          : swimlaneRecord?.id,\n                    domTransition : true\n                },\n                elementData : {\n                    elementType : 'column',\n                    columnId    : id,\n                    laneId      : swimlaneRecord?.id\n                },\n                // Cards\n                children : {\n                    body : {\n                        id    : `${elementId}-body`,\n                        class : {\n                            'b-taskboard-column-body' : 1\n                        },\n                        dataset : {\n                            role          : 'body',\n                            domTransition : true\n                        },\n                        children : [\n                            {\n                                class : {\n                                    'b-taskboard-column-body-inner' : 1\n                                },\n                                style : {\n                                    'grid-template-columns' : `repeat(${stretchCards ? Math.min(perRow, tasks.length) : perRow}, 1fr)`\n                                },\n                                dataset : {\n                                    role          : 'inner',\n                                    domTransition : true\n                                },\n                                children : (() => {\n                                    // Optionally force sort order\n                                    if (taskSorterFn) {\n                                        tasks.sort(taskSorterFn);\n                                    }\n                                    // Otherwise match store order, Set is unordered\n                                    else {\n                                        tasks.sort((a, b) => taskStore.indexOf(a) - taskStore.indexOf(b));\n                                    }\n                                    return tasks.map(taskRecord => me.renderCard(taskRecord, columnRecord, swimlaneRecord));\n                                })(),\n                                syncOptions : {\n                                    syncIdField      : 'task',\n                                    releaseThreshold : me.isVirtualized ? 1000 : 0\n                                }\n                            }\n                        ],\n                        syncOptions : {\n                            syncIdField : 'role'\n                        }\n                    }\n                },\n                syncOptions : {\n                    syncIdField : 'role'\n                }\n            };\n        // Chained by features\n        me.populateColumn({\n            columnRecord,\n            swimlaneRecord,\n            columnConfig\n        });\n        // Supplied by app\n        me.columnRenderer?.({\n            columnRecord,\n            swimlaneRecord,\n            columnConfig\n        });\n        return columnConfig;\n    }\n    renderSwimlane(swimlaneRecord) {\n        const\n            me                             = this,\n            { showCountInHeader, columns } = me,\n            {\n                id = 'default',\n                domId = 'default',\n                text,\n                height,\n                flex,\n                color\n            }                              = swimlaneRecord || {},\n            elementId                      = `${me.id}-swimlane-${domId}`,\n            namedColor                     = DomHelper.isNamedColor(color) ? color : null,\n            swimlaneConfig                 = {\n                id    : elementId,\n                class : {\n                    'b-taskboard-swimlane'              : 1,\n                    'b-fixed-height'                    : height && !flex,\n                    'b-last'                            : !swimlaneRecord || swimlaneRecord === me.swimlanes.last,\n                    [`b-taskboard-color-${namedColor}`] : namedColor\n                },\n                style : {\n                    color : namedColor ? null : color,\n                    height,\n                    flex\n                },\n                dataset : {\n                    lane          : domId,\n                    domTransition : true\n                },\n                elementData : {\n                    elementType : 'swimlane',\n                    laneId      : id\n                },\n                children : {\n                    // If a lane is defined, it has a header\n                    header : swimlaneRecord && {\n                        id    : `${elementId}-header`,\n                        tag   : 'header',\n                        class : {\n                            'b-taskboard-swimlane-header' : 1\n                        },\n                        dataset : {\n                            role          : 'header',\n                            domTransition : 'preserve-padding'\n                        },\n                        children : {\n                            title : {\n                                class : {\n                                    'b-taskboard-swimlane-title' : 1\n                                },\n                                children : {\n                                    text,\n                                    count : showCountInHeader && {\n                                        tag   : 'span',\n                                        class : {\n                                            'b-taskboard-swimlane-count' : 1\n                                        },\n                                        text : `(${me.getSwimlaneTasks(swimlaneRecord)?.size ?? 0})`\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    // Lane or no lane, there is always a body to contain columns\n                    body : {\n                        id    : `${elementId}-body`,\n                        class : {\n                            'b-taskboard-swimlane-body' : 1\n                        },\n                        dataset : {\n                            role          : 'body',\n                            domTransition : true\n                        },\n                        // Columns within the lane\n                        children : columns.map(column =>\n                            !column.hidden && me.renderColumn(swimlaneRecord, column)\n                        ),\n                        syncOptions : {\n                            syncIdField      : 'column',\n                            releaseThreshold : 0\n                        }\n                    }\n                },\n                syncOptions : {\n                    syncIdField : 'role'\n                }\n            };\n        me.populateSwimlane({\n            swimlaneRecord,\n            swimlaneConfig\n        });\n        // Supplied by app\n        me.swimlaneRenderer?.({\n            swimlaneRecord,\n            swimlaneConfig\n        });\n        return swimlaneConfig;\n    }\n    // Creates a DOM config for the entire TaskBoard, rendered to panels body\n    get bodyConfig() {\n        const\n            me = this,\n            // Pull in configs that affect rendering, even if not used here to prime them\n            {\n                /* eslint-disable no-unused-vars */\n                stickyHeaders,\n                showCountInHeader,\n                columns,\n                columnField,\n                swimlaneField,\n                tasksPerRow,\n                headerItems,\n                bodyItems,\n                footerItems,\n                selectedTasks,\n                showCollapseInHeader,\n                showCollapseTooltip,\n                taskSorterFn,\n                stretchCards\n                /* eslint-enable no-unused-vars */\n            }  = me;\n        // On first compose, supply a minimal body to have element ready when features inject their contents on next\n        // compose. Allows us to avoid using hacks to pull features in early\n        if (!me.rendered) {\n            // Queue up another recompose after the minimal bootstrap, to render columns while loading\n            me.setTimeout(() => me.recompose(), 0);\n            return {\n                // Required by panel, it expects a bodyElement reference\n                reference : 'bodyElement',\n                // Listeners are only set up on first sync, has to go here (not internalListeners no purpose, these are\n                // EventHelper listeners)\n                // eslint-disable-next-line bryntum/no-listeners-in-lib\n                listeners : ObjectHelper.assign({ thisObj : me }, me.domListeners)\n            };\n        }\n        // We get here on second compose, features are now pulled in and we have an outer element ready\n        const bodyConfig = {\n            // Save some processing by not cloning the config, it is regenerated on every compose anyway\n            skipClone : true,\n            reference : 'bodyElement',\n            class     : {\n                'b-taskboard-body' : 1,\n                'b-sticky-headers' : stickyHeaders\n            },\n            children : [\n                // Column headers\n                {\n                    tag   : 'header',\n                    id    : `${me.id}-column-headers`,\n                    class : {\n                        'b-taskboard-column-headers' : 1\n                    },\n                    children : columns.map(column => !column.hidden && me.renderColumnHeader(column)),\n                    dataset  : {\n                        lane          : 'header',\n                        domTransition : true\n                    },\n                    syncOptions : {\n                        syncIdField : 'column'\n                    }\n                }\n            ],\n            syncOptions : {\n                syncIdField      : 'lane',\n                releaseThreshold : 0,\n                ignoreRefs       : 'children' // References in \"children\" should not be hoisted to the panel\n            }\n        };\n        let { swimlanes } = me;\n        // There is always a swimlane\n        if (!swimlanes?.count) {\n            swimlanes = [null];\n        }\n        // Swimlanes\n        for (const lane of swimlanes) {\n            if (!lane?.hidden) {\n                bodyConfig.children.push(me.renderSwimlane(lane));\n            }\n        }\n        me.populateBody({\n            bodyConfig\n        });\n        me.isComposed = true;\n        return bodyConfig;\n    }\n    // For chaining, to decorate dom config\n    populateCard(args) {\n        super.populateCard?.(args);\n    }\n    populateColumn(args) {\n        super.populateColumn?.(args);\n    }\n    populateColumnHeader(args) {\n        super.populateColumnHeader?.(args);\n    }\n    populateSwimlane(args) {\n        super.populateSwimlane?.(args);\n    }\n    populateBody(args) {\n        super.populateBody?.(args);\n    }\n    afterRecompose() {\n        super.afterRecompose();\n        const me = this;\n        if (!me.isInitiallyComposed && me.isComposed) {\n            me.isInitiallyComposed = true;\n            me.initialCompose();\n        }\n        if (me.project.taskStore.count > 0) {\n            me.trigger('renderTasks', { taskRecords : me.project.taskStore.allRecords });\n        }\n        me.transitionRecompose = null;\n    }\n    // For chaining, replaces render() since we don't do full compose on render\n    initialCompose() {\n        this.trigger('initialCompose');\n    }\n    // For chaining, to react to element changes\n    onRenderColumn() {}\n    onRemoveColumnElement() {}\n    onRenderSwimlane() {}\n    onRemoveSwimlaneElement() {}\n    //endregion\n    //region Transition - experimental\n    // Prevent dom transitions until resumed\n    suspendDomTransition() {\n        this.domTransitionSuspended++;\n    }\n    // Resume dom transitions\n    resumeDomTransition() {\n        this.domTransitionSuspended--;\n    }\n    // Recompose transitioning dom\n    recomposeWithDomTransition(options) {\n        const me = this;\n        if (me.useDomTransition && !me.domTransitionSuspended) {\n            me.transitionRecompose = {\n                selector : '[data-dom-transition]',\n                duration : 300,\n                element  : me._bodyElement, // _ needed to not flush recompose if we are dirty\n                ...options\n            };\n        }\n        // Transitioned recompose takes a bit of time, if we are requested to recompose again while it is ongoing,\n        // we queue up another recompose to run after the transition is done\n        if (me.recompose.suspended) {\n            me._recomposeQueued = true;\n        }\n        else {\n            me.recompose();\n        }\n    }\n    resumeRecompose() {\n        super.resumeRecompose();\n        // Kick of another recompose if needed, see comment in recomposeWithDomTransition() above\n        if (this._recomposeQueued) {\n            this._recomposeQueued = null;\n            this.recompose();\n        }\n    }\n    //endregion\n    //region Extract configs\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs for the task board, with special handling for columns\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n        if (result.columns) {\n            delete result.columns.modelClass;\n        }\n        return result;\n    }\n    //endregion\n    // Expected by CrudManagerView\n    refresh() {\n        this.recompose();\n    }\n}\nTaskBoardBase.initClass();\nVersionHelper.setVersion('taskboard', '5.6.2');\nTaskBoardBase._$name = 'TaskBoardBase';", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/TaskMenuItem\n */\n/**\n * Item that adds a `\u00B7\u00B7\u00B7` button hooked up to display the {@link TaskBoard/feature/TaskMenu} on click.\n *\n * Requires the {@link TaskBoard/feature/TaskMenu} to work as intended.\n *\n * {@inlineexample TaskBoard/view/item/TaskMenuItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype taskMenu\n */\nexport default class TaskMenuItem extends TaskItem {\n    static $name = 'TaskMenuItem';\n    static type = 'taskMenu';\n    /**\n     * @hideconfigs editor\n     */\n    static defaultEditor = null;\n    static render({ taskBoard, domConfig }) {\n        if (!taskBoard.features.taskMenu || taskBoard.features.taskMenu.disabled) {\n            return false;\n        }\n        domConfig.tag = 'button';\n        domConfig.class['b-icon b-icon-menu-horizontal'] = 1;\n    }\n    static onClick({ source : taskBoard, event }) {\n        taskBoard.features.taskMenu?.showContextMenu(event, { target : event.target });\n    }\n}\nTaskMenuItem.initClass();\nTaskMenuItem._$name = 'TaskMenuItem';", "import TaskBoardBase from './TaskBoardBase.js';\nimport '../feature/ColumnHeaderMenu.js';\nimport '../feature/ColumnToolbars.js';\nimport '../feature/TaskDrag.js';\nimport '../feature/TaskDragSelect.js';\nimport '../feature/TaskEdit.js';\nimport '../feature/TaskMenu.js';\nimport './item/ImageItem.js';\nimport './item/JsxItem.js';\nimport './item/ProgressItem.js';\nimport './item/RatingItem.js';\nimport './item/ResourceAvatarsItem.js';\nimport './item/SeparatorItem.js';\nimport './item/TagsItem.js';\nimport './item/TaskMenuItem.js';\nimport './item/TemplateItem.js';\nimport './item/TodoListItem.js';\n/**\n * @module TaskBoard/view/TaskBoard\n */\n/**\n * A kanban board widget that allows you to visualize and mange tasks.\n *\n * {@inlineexample TaskBoard/view/TaskBoardBasic.js}\n *\n * ## Datalayer\n *\n * TaskBoards datalayer is based on Schedulers. It consumes a {@link TaskBoard.model.ProjectModel project} that holds\n * stores that in turn holds records. The stores used by default are:\n *\n * * {@link TaskBoard.store.TaskStore} - Store holding tasks, which are instances of {@link TaskBoard.model.TaskModel}\n * * {@link Scheduler.store.ResourceStore} - Holds resources, see {@link Scheduler.model.ResourceModel}\n * * {@link Scheduler.store.AssignmentStore} - Holds assignments, links between resources and tasks, see {@link Scheduler.model.AssignmentModel}\n *\n * Data can be supplied inline or loaded using the projects {@link Scheduler.data.mixin.ProjectCrudManager CrudManager}\n * capabilities. Example using inline data:\n *\n * {@frameworktabs}\n * {@js}\n *\n * ```javascript\n * new TaskBoard({\n *     project : {\n *         tasksData : [\n *             { id : 1, name : 'Try TaskBoard' }\n *         ]\n *     }\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     const project = useRef();\n *\n *     const [tasks] = useState([\n *          { id : 1, name : 'Try TaskBoard' }\n *     ]);\n *\n *     return (\n *         <>\n *             <BryntumProjectModel ref={project} tasks={tasks} />\n *             <BryntumTaskBoard project={project} />\n *         </>\n *     )\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n * ```html\n * <bryntum-project-model ref=\"project\" :tasks=\"tasks\" />\n * <bryntum-task-board :project=\"project\" />\n * ```\n *\n * ```javascript\n * export default {\n *    setup() {\n *      return {\n *         tasks : reactive([\n *             { id : 1, name : 'Try TaskBoard' }\n *         ])\n *      };\n *    }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n *\n * ```html\n * <bryntum-project-model #project [tasks]=\"tasks\"></bryntum-project-model>\n * <bryntum-task-board [project]=\"project\"></bryntum-task-board>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *     tasks = [\n *         { id : 1, name : 'Try TaskBoard' }\n *     ]\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * And using CrudManager to load remote data:\n *\n * {@frameworktabs}\n * {@js}\n *\n * ```javascript\n * new TaskBoard({\n *     project : {\n *         loadUrl : 'data/load.php',\n *         autoLoad : true\n *     }\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     const project = useRef();\n *\n *     return (\n *         <>\n *             <BryntumProjectModel ref={project} loadUrl=\"data/load.php\" />\n *             <BryntumTaskBoard project={project} />\n *         </>\n *     )\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n * ```html\n * <bryntum-project-model ref=\"project\" :load-url=\"loadUrl\" />\n * <bryntum-task-board :project=\"project\" />\n * ```\n *\n * ```javascript\n * export default {\n *    setup() {\n *      return {\n *         loadUrl : 'data/load.php'\n *      };\n *    }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n *\n * ```html\n * <bryntum-project-model #project [loadUrl]=\"loadUrl\"></bryntum-project-model>\n * <bryntum-task-board [project]=\"project\"></bryntum-task-board>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *     loadUrl = 'data/load.php'\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * ## Columns\n *\n * The tasks are displayed in columns. Which column a task belongs to is determined by the tasks value for the\n * configured {@link #config-columnField}. Columns can be defined as strings or as {@link TaskBoard.model.ColumnModel}\n * data objects, supplied to the {@link #config-columns columns config}. This snippet illustrates it:\n *\n * {@frameworktabs}\n * {@js}\n *\n * ```javascript\n * new TaskBoard({\n *     // The status field of tasks will be used to link a task to a column\n *     columnField : 'status',\n *\n *     // Columns as strings or objects\n *     columns : [\n *         'todo', // Will be displayed as Todo\n *         { id : 'done', text : 'Done!' }\n *     ],\n *\n *     // TaskBoard data\n *     project : {\n *         tasksData : [\n *             // Since we use the \"status\" field to determine column,\n *             // this task will belong to the \"done\" column\n *             { id : 1, name : 'Create mockup', status : 'done' },\n *             // And this one to \"todo\"\n *             { id : 2, name : 'Write docs', status : 'todo' }\n *         ]\n *     }\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     const project = useRef();\n *\n *     // TaskBoard data\n *     const [tasks] = useState([\n *         // Since we use the \"status\" field to determine column,\n *         // this task will belong to the \"done\" column\n *         { id : 1, name : 'Create mockup', status : 'done' },\n *        // And this one to \"todo\"\n *        { id : 2, name : 'Write docs', status : 'todo' }\n *     ]);\n *\n *     // Columns as strings or objects\n *     const columns = [\n *        'todo', // Will be displayed as Todo\n *         { id : 'done', text : 'Done!' }\n *     ];\n *\n *     // The status field of tasks will be used to link a task to a column\n *     const columnField = 'status';\n *\n *     return (\n *         <>\n *             <BryntumProjectModel ref={project} tasks={tasks} />\n *             <BryntumTaskBoard\n *                 project={project}\n *                 columns={columns}\n *                 columnField={columnField}\n *                 />\n *         </>\n *     )\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n * ```html\n * <bryntum-project-model ref=\"project\" :tasks=\"tasks\" />\n * <bryntum-task-board\n *     :project=\"project\"\n *     :columns=\"columns\"\n *     :columnField=\"columnField\"\n *     />\n * ```\n *\n * ```javascript\n * export default {\n *     setup() {\n *         return {\n *             // TaskBoard data\n *             tasks : reactive([\n *                 // Since we use the \"status\" field to determine column,\n *                 // this task will belong to the \"done\" column\n *                 { id : 1, name : 'Create mockup', status : 'done' },\n *                 // And this one to \"todo\"\n *                 { id : 2, name : 'Write docs', status : 'todo' }\n *             ]),\n *\n *             // Columns as strings or objects\n *             columns : [\n *                 'todo', // Will be displayed as Todo\n *                 { id : 'done', text : 'Done!' }\n *             ],\n *\n *             // The status field of tasks will be used to link a task to a column\n *             columnField : 'status'\n *         };\n *     }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n *\n * ```html\n * <bryntum-project-model #project [tasks]=\"tasks\"></bryntum-project-model>\n * <bryntum-task-board\n *     [project]=\"project\"\n *     [columns]=\"columns\"\n *     [columnField]=\"columnField\"\n *     >\n * </bryntum-task-board>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *     // TaskBoard data\n *     tasks = reactive([\n *         // Since we use the \"status\" field to determine column,\n *         // this task will belong to the \"done\" column\n *         { id : 1, name : 'Create mockup', status : 'done' },\n *         // And this one to \"todo\"\n *         { id : 2, name : 'Write docs', status : 'todo' }\n *     ])\n *\n *     // Columns as strings or objects\n *     columns = [\n *         'todo', // Will be displayed as Todo\n *         { id : 'done', text : 'Done!' }\n *     ]\n *\n *     // The status field of tasks will be used to link a task to a column\n *     columnField = 'status'\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * The supplied columns are loaded into an internal store, named {@link #property-columns}. You can use it at runtime\n * to access, add, remove and filter columns.\n *\n * ## Swimlanes\n *\n * The TaskBoard can optionally be divided into horizontal swimlanes.\n *\n * {@inlineexample TaskBoard/view/TaskBoardSwimlanes.js}\n *\n * They are defined and populated in a very similar manner to columns:\n *\n * {@frameworktabs}\n * {@js}\n *\n * ```javascript\n * new TaskBoard({\n *     // The prio field of tasks will be used to link a task to a swimlane\n *     swimlaneField : 'prio',\n *\n *     // Swimlanes as strings or objects\n *     swimlanes : [\n *         'low', // Will be displayed as Low\n *         { id : 'high', text : 'High!' }\n *     ],\n *\n *     // TaskBoard data\n *     project : {\n *         tasksData : [\n *             // Since we use the \"prio\" field to determine swimlane,\n *             // this task will belong to the \"high\" lane\n *             { id : 1, name : 'Create mockup', status : 'done', prio : 'high' },\n *\n *             // And this one to \"low\"\n *             { id : 2, name : 'Write docs', status : 'todo', prio : 'low' }\n *         ]\n *     }\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     const project = useRef();\n *\n *     // TaskBoard data\n *     const [tasks] = useState([\n *         // Since we use the \"prio\" field to determine swimlane,\n *         // this task will belong to the \"high\" lane\n *         { id : 1, name : 'Create mockup', status : 'done', prio : 'high' },\n *\n *         // And this one to \"low\"\n *         { id : 2, name : 'Write docs', status : 'todo', prio : 'low' }\n *     ]);\n *\n *     // Swimlanes as strings or objects\n *     const swimlanes = [\n *        'low', // Will be displayed as Low\n *         { id : 'high', text : 'High!' }\n *     ];\n *\n *     // The prio field of tasks will be used to link a task to a swimlane\n *     const swimlaneField = 'prio';\n *\n *     return (\n *         <>\n *             <BryntumProjectModel ref={project} tasks={tasks} />\n *             <BryntumTaskBoard\n *                 project={project}\n *                 swimlanes={swimlanes}\n *                 swimlaneField={swimlaneField}\n *                 />\n *         </>\n *     )\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n * ```html\n * <bryntum-project-model ref=\"project\" :tasks=\"tasks\" />\n * <bryntum-task-board\n *     :project=\"project\"\n *     :swimlanes=\"swimlanes\"\n *     :swimlaneField=\"swimlaneField\"\n *     />\n * ```\n *\n * ```javascript\n * export default {\n *     setup() {\n *         return {\n *             // TaskBoard data\n *             tasks : reactive([\n *                 // Since we use the \"prio\" field to determine swimlane,\n *                 // this task will belong to the \"high\" lane\n *                 { id : 1, name : 'Create mockup', status : 'done', prio : 'high' },\n *\n *                 // And this one to \"low\"\n *                 { id : 2, name : 'Write docs', status : 'todo', prio : 'low' }\n *             ]),\n *\n *             // Swimlanes as strings or objects\n *             swimlane : [\n *                 'low', // Will be displayed as Low\n *                 { id : 'high', text : 'High!' }\n *             ],\n *\n *             // The prio field of tasks will be used to link a task to a swimlane\n *             swimlanenField : 'prio'\n *         };\n *     }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n *\n * ```html\n * <bryntum-project-model #project [tasks]=\"tasks\"></bryntum-project-model>\n * <bryntum-task-board\n *     [project]=\"project\"\n *     [swimlanes]=\"swimlanes\"\n *     [swimlaneField]=\"swimlaneField\"\n *     >\n * </bryntum-task-board>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *     // TaskBoard data\n *     tasks = [\n *         // Since we use the \"prio\" field to determine swimlane,\n *         // this task will belong to the \"high\" lane\n *         { id : 1, name : 'Create mockup', status : 'done', prio : 'high' },\n *\n *         // And this one to \"low\"\n *         { id : 2, name : 'Write docs', status : 'todo', prio : 'low' }\n *     ]\n *\n *     // Swimlanes as strings or objects\n *     swimlanes = [\n *         'low', // Will be displayed as Low\n *         { id : 'high', text : 'High!' }\n *     ]\n *\n *     // The prio field of tasks will be used to link a task to a swimlane\n *     swimlaneField = 'prio'\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * ## Task order\n *\n * The order of tasks in a column is determined by their order in the task store. By default the store is sorted by\n * {@link TaskBoard/model/TaskModel#field-weight}. Changing store sorting will rearrange the tasks:\n *\n * ```javascript\n * // Rearrange tasks by name\n * taskBoard.project.taskStore.sort('name');\n * ```\n *\n * When loading tasks that has no weights specified a generated weight (index * 100) will be silently assigned.\n *\n * Dragging and dropping tasks changes their weight and resorts the store. Note that if you want to sort by something\n * other than weight and still want a task to stay where it is dropped you will have to opt out of the default\n * behaviour by configuring {@link TaskBoard/feature/TaskDrag#config-reorderTaskRecords} as `true`.\n *\n * If you programmatically change a weight you have to manually sort the store for the task to move:\n *\n * ```javascript\n * // Programmatic change of weight requires resorting manually\n * taskBoard.project.taskStore.first.weight = 1000;\n * taskBoard.project.taskStore.sort();\n * ```\n *\n * ## Sharing a project\n *\n * When consuming a project from a different product (for example Gantt), you will likely want the cards on the board\n * to have a stable order no matter how data is sorted in the other product. This can be achieved by configuring a\n * {@link #config-taskSorterFn}, which is then applied on the UI layer to resort tasks before rendering their cards.\n * You can use it to enforce sorting by weight:\n *\n * ```javascript\n * // Shortcut to always enforce sorting by weight\n * const taskBoard = new TaskBoard({\n *    taskSorterFn : true\n * });\n * ```\n *\n * Or supply a custom [Array sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n * function:\n *\n * ```javascript\n * // Custom sorting fn\n * const taskBoard = new TaskBoard({\n *    taskSorterFn(a, b) {\n *        return a.name.localeCompare(b.name);\n *    }\n * });\n * ```\n *\n * <div class=\"note\">\n * When consuming a non-TaskBoard project no weights will be assigned by default, make sure your data has weights if\n * you want stable task ordering.\n * </div>\n *\n * ## Customizing task content\n *\n * Task contents can be easily customized using {@link TaskBoard/view/mixin/TaskItems task items}, lightweight\n * \"widgets\" that can be added to a tasks header, body and footer.\n *\n * For more control over what gets rendered into a task, you can supply a {@link #config-taskRenderer} function. It is\n * called prior to updating the DOM for each task, allowing you to directly manipulate what ends up there.\n *\n * For more information see:\n *\n * * [Styling guide](#TaskBoard/guides/customization/styling.md)\n * * [Customize task contents guide](#TaskBoard/guides/customization/taskcontents.md)\n *\n * ## Large data sets\n *\n * Having a large number of cards rendered to DOM simultaneously can lead to poor performance. To address this issue,\n * TaskBoard supports partial virtualized rendering. This means that only the cards that are visible in the viewport\n * are fully rendered, cards outside the viewport are only outlined.\n *\n * When enabled, the board displays faster and is more responsive with big data sets, but it also means that scrolling\n * is more costly since cards coming into view has to be rendered. And since it is not fully virtualized, the board will\n * still be slow with very large data sets.\n *\n * <div class=\"note\">A Kanban board is best suited for using with a smaller set of tasks (hundreds rather than\n * thousands). Before enabling partial virtualized rendering we strongly recommend you consider restructuring the\n * application. Could it for example filter the tasks based on user, project or similar to work on a subset?</div>\n *\n * To enable partial virtualized rendering, the height of all tasks must be known. To communicate this to the TaskBoard,\n * implement a {@link #config-getTaskHeight getTaskHeight()} function. See its documentation for more information and\n * snippets.\n *\n * <div class=\"note\">Note that as part of the optimizations for partial virtualized rendering, the inner element in\n * columns that contain cards is absolutely positioned. This leads to column not being able to automatically shrink wrap\n * the cards, you will have to set a height on the swimlane (or task board if not using swimlanes) to size things\n * correctly.</div>\n *\n * {@region Keyboard shortcuts}\n * TaskBoard has the following default keyboard shortcuts:\n * <div class=\"compact\">\n *\n * | Keys                 | Action                 | Action description                                                         |\n * |----------------------|------------------------|----------------------------------------------------------------------------|\n * | `ArrowDown`          | *navigateDown*         | Moves focus to task below currently focused element                        |\n * | `ArrowLeft`          | *navigateLeft*         | Moves focus to task to the left of currently focused element               |\n * | `ArrowUp`            | *navigateUp*           | Moves focus to task above currently focused element                        |\n * | `ArrowRight`         | *navigateRight*        | Moves focus to task to the right of currently focused element              |\n * | `Enter`              | *activate*             | Show the Task Editor for currently focused task                            |\n * | `Space`              | *keyboardSelect*       | This selects or deselects the focused card (deselecting all others)        |\n * | `Ctrl`+`Space`       | *keyboardToggleSelect* | This selects or deselects the focused card, preserving any other selection |\n * | `Shift`+`ArrowDown`  | *selectDown*           | Hold `Shift` when keyboard navigating to extend selection                  |\n * | `Shift`+`ArrowLeft`  | *selectLeft*           | Hold `Shift` when keyboard navigating to extend selection                  |\n * | `Shift`+`ArrowUp`    | *selectUp*             | Hold `Shift` when keyboard navigating to extend selection                  |\n * | `Shift`+`ArrowRight` | *selectRight*          | Hold `Shift` when keyboard navigating to extend selection                  |\n *\n * </div>\n *\n * <div class=\"note\" style=\"font-size:0.9em\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * If you prefer for selection to always move with the arrow keys, see\n * {@link TaskBoard.view.mixin.TaskNavigation#config-selectOnNavigation}.\n *\n * The following TaskBoard features has their own keyboard shortcuts. Follow the links for details.\n * * {@link TaskBoard.feature.ColumnHeaderMenu#keyboard-shortcuts ColumnHeaderMenu}\n * * {@link TaskBoard.feature.SimpleTaskEdit#keyboard-shortcuts SimpleTaskEdit}\n * * {@link TaskBoard.feature.TaskMenu#keyboard-shortcuts TaskMenu}\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#TaskBoard/guides/customization/keymap.md).\n * {@endregion}\n *\n * ## Find out more\n *\n * * {@link TaskBoard.view.mixin.ExpandCollapse Expanding and collapsing columns and swimlanes}\n * * {@link TaskBoard.view.mixin.ResponsiveCards Responsive behaviour for cards}\n * * {@link TaskBoard.view.mixin.TaskBoardDom Resolving elements <-> records}\n * * {@link TaskBoard.view.mixin.TaskBoardDomEvents Handling card events}\n * * {@link TaskBoard.view.mixin.TaskBoardScroll Scrolling to tasks, columns and swimlanes}\n * * {@link TaskBoard.view.mixin.TaskItems Add content to task cards}\n * * {@link TaskBoard.view.mixin.TaskNavigation Keyboard navigation}\n * * {@link TaskBoard.view.mixin.TaskSelection Selection tasks using mouse and keyboard}\n *\n * @extends TaskBoard/view/TaskBoardBase\n * @classtype taskboard\n * @widget\n */\nexport default class TaskBoard extends TaskBoardBase {\n    static $name = 'TaskBoard';\n    static type = 'taskboard';\n    static configurable = {\n        //region Hidden members\n        /**\n         * @hideconfigs crudManager, crudManagerClass, contentElementCls, htmlCls, defaults, hideWhenEmpty, itemCls, items, layout, layoutStyle, lazyItems, namedItems, textContent, content, html, defaultBindProperty, monitorResize, ripple, tooltip, tag, textAlign, preventTooltipOnTouch\n         */\n        /**\n         * @hideproperties $name, isSettingValues, isValid, items, layout, record, values, content, contentElement, focusElement, html, overflowElement, layoutStyle, tooltip, scrollable\n         */\n        /**\n         * @hidefunctions attachTooltip, isOfTypeName, mixin, optionalL, callback, resolveCallback, add, getWidgetById, insert, processWidgetConfig, remove, removeAll, construct, doDestroy, updateLocalization, compose, eachAncestor, eachWidget, query, queryAll, L\n         */\n        /**\n         * @event beforeSetRecord\n         * @hide\n         */\n        //endregion\n        features : {\n            columnHeaderMenu : true,\n            columnToolbars   : true,\n            taskDrag         : true,\n            taskDragSelect   : true,\n            taskEdit         : true,\n            taskMenu         : true\n        }\n    };\n}\nTaskBoard.initClass();\nTaskBoard._$name = 'TaskBoard';", "import FilterField from '../../Core/widget/FilterField.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/ColumnFilterField\n */\n/**\n * A field that filters the columns of a linked {@link TaskBoard.view.TaskBoard} when typing into it.\n *\n * {@inlineexample TaskBoard/widget/ColumnFilterField.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'columnfilterfield' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new ColumnFilterField({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/FilterField\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype columnfilterfield\n * @widget\n */\nexport default class ColumnFilterField extends FilterField.mixin(TaskBoardLinked) {\n    static $name = 'ColumnFilterField';\n    static type = 'columnfilterfield';\n    static configurable = {\n        /**\n         * @hideconfigs store, filterFunction\n         */\n        store : 'this.taskBoard.columns',\n        /**\n         * The ColumnModel field name to filter by, defaults to `'text'`.\n         * @config {String}\n         * @default\n         * @category Common\n         */\n        field : 'text',\n        /**\n         * Label, defaults to a localized version of `'Filter columns'`.\n         *\n         * Content is determined by the `TaskBoard.filterColumns` key in the applied locale.\n         *\n         * @config {String}\n         * @category Label\n         */\n        label : 'L{TaskBoard.filterColumns}',\n        width : '20em',\n        triggers : {\n            filter : {\n                cls   : 'b-icon b-icon-filter',\n                align : 'start'\n            }\n        }\n    };\n}\nColumnFilterField.initClass();\nColumnFilterField._$name = 'ColumnFilterField';", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Button from '../../Core/widget/Button.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/ColumnPickerButton\n */\n/**\n * A button with a menu allowing the user to toggle which columns are shown on the {@link TaskBoard.view.TaskBoard}.\n *\n * {@inlineexample TaskBoard/widget/ColumnPickerButton.js}\n *\n * Click to display a menu populated with the columns held in {@link TaskBoard.view.TaskBoard#property-columns}.\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'columnpickerbutton' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new ColumnPickerButton({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/Button\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype columnpickerbutton\n * @widget\n */\nexport default class ColumnPickerButton extends Button.mixin(TaskBoardLinked) {\n    static $name = 'ColumnPickerButton';\n    static type = 'columnpickerbutton';\n    static configurable = {\n        text        : 'L{TaskBoard.Columns}',\n        icon        : 'b-icon-picker',\n        pressedIcon : 'b-icon-picker-rotated',\n        iconAlign   : 'end',\n        menuIcon    : null,\n        // items null needed to not be considered an object holding menu items\n        menu        : { items : null }\n    };\n    onToggleColumn({ item }) {\n        item.column.hidden = !item.checked;\n    }\n    // Populate menu before each show to make sure it is up to date\n    onMenuBeforeShow(info) {\n        super.onMenuBeforeShow(info);\n        info.source.items = this.taskBoard.columns.map(column => ({\n            ref     : column.id,\n            text    : StringHelper.encodeHtml(column.text),\n            checked : !column.hidden,\n            column,\n            onItem  : 'up.onToggleColumn'\n        }));\n    }\n}\nColumnPickerButton.initClass();\nColumnPickerButton._$name = 'ColumnPickerButton';", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Button from '../../Core/widget/Button.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/ColumnScrollButton\n */\n/**\n * A button with a menu allowing the user to pick a column to scroll to.\n *\n * {@inlineexample TaskBoard/widget/ColumnScrollButton.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'columnscrollbutton' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new ColumnScrollButton({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/Button\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype columnScrollButton\n * @widget\n */\nexport default class ColumnScrollButton extends Button.mixin(TaskBoardLinked) {\n    static $name = 'ColumnScrollButton';\n    static type = 'columnscrollbutton';\n    static configurable = {\n        text        : 'L{TaskBoard.scrollToColumn}',\n        icon        : 'b-icon-picker',\n        pressedIcon : 'b-icon-picker-rotated',\n        iconAlign   : 'end',\n        menuIcon    : null,\n        menu        : []\n    };\n    onClickColumn({ item }) {\n        this.setTimeout(() => this.taskBoard?.scrollToColumn(item.column), 100);\n    }\n    changeMenu(menu) {\n        // Nullified on destroy\n        if (menu) {\n            menu = this.taskBoard.columns.map(column => ({\n                ref    : column.id,\n                text   : StringHelper.encodeHtml(column.text),\n                column,\n                onItem : 'up.onClickColumn'\n            }));\n        }\n        return super.changeMenu(menu);\n    }\n}\nColumnScrollButton.initClass();\nColumnScrollButton._$name = 'ColumnScrollButton';", "import SchedulerProjectCombo from '../../Scheduler/widget/ProjectCombo.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/ProjectCombo\n */\n/**\n * Combo that allows picking a dataset to use for a {@link TaskBoard.model.ProjectModel}. Each item holds a title and\n * a load url to reconfigure the project with.\n *\n * {@inlineexample TaskBoard/widget/ProjectCombo.js}\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         {\n *             type : 'taskboardprojectcombo',\n *             items : [\n *                 { title : 'Important project', url : 'data/load.php?id=1' },\n *                 { title : 'Another project', url : 'data/load.php?id=2' }\n *             ]\n *         }\n *     ],\n *\n *     project : {\n *         transport : {\n *             load : {\n *                 url : 'data/load.php?id=1'\n *             }\n *         },\n *\n *         autoLoad : true\n *     }\n * });\n * ```\n *\n * @extends Scheduler/widget/ProjectCombo\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype taskboardprojectcombo\n * @widget\n *\n * @typings Scheduler.widget.ProjectCombo -> Scheduler.widget.SchedulerProjectCombo\n */\nexport default class ProjectCombo extends SchedulerProjectCombo.mixin(TaskBoardLinked) {\n    static $name = 'ProjectCombo';\n    static type = 'taskboardprojectcombo';\n    static configurable = {\n        /**\n         * Project to reconfigure when picking an item. Resolved automatically if a TaskBoard is configured or detected.\n         * @config {TaskBoard.model.ProjectModel}\n         * @category Common\n         */\n        project : null\n    };\n    updateTaskBoard(taskBoard) {\n        if (taskBoard) {\n            this.project = taskBoard.project;\n        }\n    }\n    afterConfigure() {\n        // Force linking to project if TaskBoard is auto detected\n        if (!this._taskBoard) {\n            this.updateTaskBoard(this.taskBoard);\n        }\n    }\n}\n// Register this widget type with its Factory\nProjectCombo.initClass();\nProjectCombo._$name = 'ProjectCombo';", "import FilterField from '../../Core/widget/FilterField.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/SwimlaneFilterField\n */\n/**\n * A field that filters the swimlanes of a linked {@link TaskBoard.view.TaskBoard} when typing into it.\n *\n * {@inlineexample TaskBoard/widget/SwimlaneFilterField.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'swimlanefilterfield' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new SwimlaneFilterField({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/FilterField\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype swimlanefilterfield\n * @widget\n */\nexport default class SwimlaneFilterField extends FilterField.mixin(TaskBoardLinked) {\n    static $name = 'SwimlaneFilterField';\n    static type = 'swimlanefilterfield';\n    static configurable = {\n        store : 'this.taskBoard.swimlanes',\n        field : 'text',\n        label : 'L{TaskBoard.filterSwimlanes}',\n        width : '20em',\n        triggers : {\n            filter : {\n                cls   : 'b-icon b-icon-filter',\n                align : 'start'\n            }\n        }\n    };\n}\nSwimlaneFilterField.initClass();\nSwimlaneFilterField._$name = 'SwimlaneFilterField';", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Button from '../../Core/widget/Button.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/SwimlanePickerButton\n */\n/**\n * A button with a menu allowing the user to toggle which swimlanes are shown on the {@link TaskBoard.view.TaskBoard}.\n *\n * {@inlineexample TaskBoard/widget/SwimlanePickerButton.js}\n *\n * Click to display a menu populated with the swimlanes held in {@link TaskBoard.view.TaskBoard#property-swimlanes}.\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'swimlanepickerbutton' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new SwimlanePickerButton({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/Button\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype swimlanepickerbutton\n * @widget\n */\nexport default class SwimlanePickerButton extends Button.mixin(TaskBoardLinked) {\n    static $name = 'SwimlanePickerButton';\n    static type = 'swimlanepickerbutton';\n    static configurable = {\n        text        : 'L{TaskBoard.Swimlanes}',\n        icon        : 'b-icon-picker',\n        pressedIcon : 'b-icon-picker-rotated',\n        iconAlign   : 'end',\n        menuIcon    : null,\n        // items null needed to not be considered an object holding menu items\n        menu        : { items : null }\n    };\n    onToggleSwimlane({ item }) {\n        item.swimlane.hidden = !item.checked;\n    }\n    // Populate menu before each show to make sure it is up to date\n    onMenuBeforeShow(info) {\n        super.onMenuBeforeShow(info);\n        info.source.items = this.taskBoard.swimlanes.map(swimlane => ({\n            ref     : swimlane.id,\n            text    : StringHelper.encodeHtml(swimlane.text),\n            checked : !swimlane.hidden,\n            swimlane,\n            onItem  : 'up.onToggleSwimlane'\n        }));\n    }\n}\nSwimlanePickerButton.initClass();\nSwimlanePickerButton._$name = 'SwimlanePickerButton';", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Button from '../../Core/widget/Button.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/SwimlaneScrollButton\n */\n/**\n * A button with a menu allowing the user to pick a swimlane to scroll to.\n *\n * {@inlineexample TaskBoard/widget/SwimlaneScrollButton.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'swimlanescrollbutton' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new SwimlaneScrollButton({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/Button\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype swimlaneScrollButton\n * @widget\n */\nexport default class SwimlaneScrollButton extends Button.mixin(TaskBoardLinked) {\n    static $name = 'SwimlaneScrollButton';\n    static type = 'swimlanescrollbutton';\n    static configurable = {\n        text        : 'L{TaskBoard.scrollToSwimlane}',\n        icon        : 'b-icon-picker',\n        pressedIcon : 'b-icon-picker-rotated',\n        iconAlign   : 'end',\n        menuIcon    : null,\n        menu        : []\n    };\n    onClickSwimlane({ item }) {\n        this.setTimeout(() => this.taskBoard?.scrollToSwimlane(item.swimlane), 100);\n    }\n    changeMenu(menu) {\n        // Nullified on destroy\n        if (menu) {\n            menu = this.taskBoard.swimlanes.map(swimlane => ({\n                ref    : swimlane.id,\n                text   : StringHelper.encodeHtml(swimlane.text),\n                swimlane,\n                onItem : 'up.onClickSwimlane'\n            }));\n        }\n        return super.changeMenu(menu);\n    }\n}\nSwimlaneScrollButton.initClass();\nSwimlaneScrollButton._$name = 'SwimlaneScrollButton';", "import FilterField from '../../Core/widget/FilterField.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/TaskFilterField\n */\n/**\n * A field that filters the tasks of a linked {@link TaskBoard.view.TaskBoard} when typing into it.\n *\n * {@inlineexample TaskBoard/widget/TaskFilterField.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'taskfilterfield' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new TaskFilterField({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/FilterField\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype taskfilterfield\n * @widget\n */\nexport default class TaskFilterField extends FilterField.mixin(TaskBoardLinked) {\n    static $name = 'TaskFilterField';\n    static type = 'taskfilterfield';\n    static configurable = {\n        store : 'this.taskBoard.project.taskStore',\n        field : 'name',\n        label : 'L{TaskBoard.filterTasks}',\n        width : '20em',\n        triggers : {\n            filter : {\n                cls   : 'b-icon b-icon-filter',\n                align : 'start'\n            }\n        }\n    };\n}\nTaskFilterField.initClass();\nTaskFilterField._$name = 'TaskFilterField';", "import ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Editor from '../../Core/widget/Editor.js';\nimport Field from '../../Core/widget/Field.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport '../../Core/widget/List.js';\nimport '../../Core/widget/Button.js';\n/**\n * @module TaskBoard/widget/TodoListField\n */\n/**\n * A field that displays, and also lets users edit, a list of todo items. Each item has a checkbox to mark if the item\n * is completed or not and a button to edit its text/remove it. Designed to be used in the task editor, to work in\n * tandem with the {@link TaskBoard.view.item.TodoListItem}.\n *\n * {@inlineexample TaskBoard/widget/TodoListField.js}\n *\n * To hook it up, add it to the task editors items and link it to a field on your task model declared with\n * `type : 'array'`. The fields data is expected to be an array of objects. Configure {@link #config-textField} and\n * {@link #config-checkedField} to match the names used by the objects in your array.\n *\n * This snippet illustrates basic usage:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            items : {\n *                todo : {\n *                    type         : 'todolist',\n *                    label        : 'Todo',\n *                    field        : 'todo',\n *                    // \"title\" property will be used as the todo item text\n *                    textField    : 'title',\n *                    // \"done\" property will drive the checkbox\n *                    checkedField : 'done'\n *                }\n *            }\n *        }\n *    },\n *\n *    project : {\n *        taskStore : {\n *            fields : [ { name : 'todo', type : 'array' } ]\n *        }\n *\n *        tasksData : [\n *            {\n *                id   : 1,\n *                name : 'Important task',\n *                todo : [\n *                    { title : 'Fix this', done : true },\n *                    { title : 'Fix that', done : false }\n *                ]\n *            }\n *        ]\n *    }\n * });\n * ```\n *\n * @extends Core/widget/Field\n * @classtype todolistfield\n * @classtypealias todolist\n * @inputfield\n */\nexport default class TodoListField extends Field {\n    static $name = 'TodoListField';\n    static type = 'todolistfield';\n    static alias = 'todolist';\n    static configurable = {\n        /**\n         * Name of a property on a todo item to display as its text.\n         *\n         * @config {String}\n         * @category Common\n         * @default\n         */\n        textField : 'text',\n        /**\n         * Name of a property on a todo item to use for the checkbox. The property is expected to be a boolean.\n         *\n         * @config {String}\n         * @category Common\n         * @default\n         */\n        checkedField : 'checked',\n        /**\n         * Configure as `false` to hide the per item edit button and the add item button. Users can still check/uncheck\n         * items.\n         *\n         * @config {Boolean}\n         * @default\n         */\n        editableItems : true,\n        list : {\n            type : 'list',\n            multiSelect : true,\n            store : {\n                fields : []\n            },\n            itemIconTpl() {\n                return `<i class=\"b-todo-checkbox b-icon\"></i>`;\n            }\n        },\n        addButton : {\n            type : 'button',\n            cls  : 'b-todo-add',\n            icon : 'b-icon-add',\n            text : 'L{TodoListField.add}'\n        },\n        role : null\n    };\n    compose() {\n        const { editableItems } = this;\n        return {\n            class : {\n                'b-editable' : editableItems\n            }\n        };\n    }\n    changeList(list) {\n        return Widget.create(ObjectHelper.assign({\n            // List does not support remapping out of the box\n            itemTpl : record => StringHelper.xss`<div class=\"b-todo-text\">${record.getValue(this.textField)}</div><i class='b-todo-edit b-icon b-icon-edit' data-noselect></i>`\n        }, list));\n    }\n    updateList(list) {\n        // Detect click on edit icon\n        list.ion({\n            item    : 'onItemClick',\n            thisObj : this\n        });\n        // Detect check/uncheck\n        list.ion({\n            selectionChange : 'onSelectionChange',\n            thisObj         : this\n        });\n    }\n    changeAddButton(button) {\n        const result = Widget.create(button);\n        this.ariaElement = result.element;\n        return result;\n    }\n    updateAddButton(button) {\n        button.ion({\n            click   : 'onAddClick',\n            thisObj : this\n        });\n    }\n    get childItems() {\n        return [this.list, this.addButton];\n    }\n    get inputElement() {\n        return this.list.element;\n    }\n    get innerElements() {\n        return super.innerElements.concat(this.addButton.element);\n    }\n    changeValue(value) {\n        value = value || [];\n        let autoUpdate = false;\n        // Auto update original array if we are used in an auto updating container\n        this.eachAncestor(a => {\n            if (a.autoUpdateRecord) {\n                autoUpdate = true;\n                return false;\n            }\n        });\n        // Original value (or a clone thereof if we are not live updating) is kept up to date on later modifications\n        this.originalValue = autoUpdate ? value : ObjectHelper.clone(value);\n        if (value) {\n            // Clone original value as our value, to not pollute the original value\n            value = ObjectHelper.clone(value);\n            value.forEach((v, i) => {\n                // id required by list\n                v.id = i + 1;\n                // map back to original value\n                v.originalIndex = i;\n            });\n        }\n        return value;\n    }\n    updateValue(value) {\n        if (value) {\n            const me = this;\n            // Populate the list with our value clone\n            me.list.items = value;\n            // Selection is used to check/uncheck items. Set flag to prevent updating original at this stage\n            me.isSettingValue = true;\n            me.list.selected.values = value.filter(v => v[me.checkedField]);\n            me.isSettingValue = false;\n        }\n    }\n    get value() {\n        // Always return a new array, required to flag array data field as modified / for UI to update\n        return this.originalValue.slice();\n    }\n    set value(value) {\n        super.value = value;\n    }\n    // Cant be invalid currently\n    get isValid() {\n        return true;\n    }\n    // Edit a todo item, using overlaid editor\n    editItem(record, element) {\n        const\n            me     = this,\n            // Always creating a new editor, destroyed when editing finishes\n            editor = new Editor({\n                appendTo   : me.element,\n                owner      : me,\n                cls        : 'b-todo-editor',\n                inputField : {\n                    type     : 'text',\n                    triggers : {\n                        remove : {\n                            cls : 'b-todo-remove b-icon-trash',\n                            handler() {\n                                me.removeItem(record);\n                                editor.cancelEdit();\n                            }\n                        }\n                    }\n                },\n                // Above modal\n                style             : 'z-index : 20000',\n                internalListeners : {\n                    complete({ value }) {\n                        me.originalValue[record.originalIndex][me.textField] = value;\n                        me.triggerFieldChange({ value : me.value, userAction : true });\n                    },\n                    finishEdit() {\n                        editor.destroy();\n                    },\n                    thisObj : me\n                }\n            });\n        // Start editing using configured field mapping\n        editor.startEdit({\n            target : element,\n            record,\n            field  : me.textField\n        });\n    }\n    // Remove a todo item, updating both the list and the original value\n    removeItem(record) {\n        const\n            me                = this,\n            { originalIndex } = record;\n        // Move following items up one notch to match position in originalValue after the splice below\n        me.list.store.forEach(r => {\n            if (r.parentIndex > record.parentIndex) {\n                r.originalIndex--;\n            }\n        });\n        me.list.store.remove(record);\n        me.originalValue.splice(originalIndex, 1);\n        me.triggerFieldChange({ value : me.value, userAction : true });\n    }\n    // Lists selection model is used to check/uncheck todo items. React on changes here\n    onSelectionChange() {\n        const\n            me       = this,\n            { list } = me;\n        if (!me.isSettingValue) {\n            me.originalValue.forEach((v, i) => {\n                const listRecord = list.store.getAt(i);\n                // Selection might change as a reaction to an item being removed = no listRecord\n                if (listRecord) {\n                    v[me.checkedField] = list.selected.includes(listRecord);\n                }\n            });\n            me.triggerFieldChange({ value : me.value, userAction : true });\n        }\n    }\n    // Clicked on a list item, react if it is on the edit icon\n    onItemClick({ record, event }) {\n        if (event.target.matches('.b-todo-edit')) {\n            this.editItem(record, event.target.closest('.b-list-item'));\n        }\n    }\n    // Clicked the add button, add to original value and then plug it back in to not have to care about syncing it with\n    // lists store\n    onAddClick() {\n        const me = this;\n        me.originalValue.push({\n            [me.textField]    : me.L('L{newTodo}'),\n            [me.checkedField] : false\n        });\n        me.value = me.originalValue;\n        me.triggerFieldChange({ value : me.value, userAction : true });\n    }\n}\nTodoListField.initClass();\nTodoListField._$name = 'TodoListField';", "import UndoRedoBase from '../../Core/widget/base/UndoRedoBase.js';\nimport '../../Core/widget/Combo.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/UndoRedo\n */\n/**\n * A widget encapsulating undo/redo functionality for the {@link TaskBoard.model.ProjectModel project} of a TaskBoard.\n *\n * To make use of this, the project must be configured with a\n * {@link Scheduler.model.mixin.ProjectModelMixin#config-stm State Tracking Manager}.\n *\n * If inserted into a TaskBoard (such as into a `tbar`, or `bbar`), the project of the that TaskBoard will be used.\n *\n * If this widget is to be used \"standalone\" (rendered into the DOM outside of a TaskBoard), this must be configured\n * with a reference the TaskBoard.\n *\n * There are three child widgets encapsulated which may be referenced through the {@link Core.widget.Container#property-widgetMap}:\n *\n * - `undoBtn` - The button which operates the undo operation\n * - `transactionsCombo` - A combobox into which is pushed the list of transactions,\n * - `redoBtn` - The button which operates the redo operation\n *\n * The transactionsCombo may be configured away if only the buttons are required:\n *\n * ```javascript\n * {\n *     type      : 'undoredo',\n *     items     : {\n *         transactionsCombo : null\n *     }\n * }\n * ```\n *\n * The example below illustrated how to embed an `undoredo` widget in the top toolbar of a TaskBoard:\n *\n * {@inlineexample TaskBoard/widget/UndoRedo.js}\n *\n * @demo TaskBoard/undo-redo\n *\n * @extends Core/widget/base/UndoRedoBase\n * @classtype taskboardundoredo\n * @widget\n */\nexport default class UndoRedo extends UndoRedoBase.mixin(TaskBoardLinked) {\n    static $name = 'UndoRedo';\n    static type = 'taskboardundoredo';\n    construct() {\n        super.construct(...arguments);\n        this.stm = this.taskBoard.project.stm;\n    }\n}\nUndoRedo.initClass();\nUndoRedo._$name = 'UndoRedo';", "import Slider from '../../Core/widget/Slider.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/ZoomSlider\n */\n/**\n * A slider that controls the {@link TaskBoard/view/TaskBoardBase#config-tasksPerRow} config of TaskBoard.\n *\n * {@inlineexample TaskBoard/widget/ZoomSlider.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'zoomslider' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new ZoomSlider({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/Slider\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype zoomslider\n * @widget\n */\nexport default class ZoomSlider extends Slider.mixin(TaskBoardLinked) {\n    static $name = 'ZoomSlider';\n    static type = 'zoomslider';\n    static configurable = {\n        text : 'L{TaskBoard.zoom}',\n        max   : 10,\n        min   : 1,\n        // Override default to avoid hitting updater, value set in afterConstruct\n        value : null,\n        showValue : false\n    };\n    calculateValue(input) {\n        return this.max - input + 1;\n    }\n    afterConstruct() {\n        this.value = this.calculateValue(this.taskBoard.tasksPerRow);\n    }\n    onInput({ value }) {\n        this.taskBoard.tasksPerRow = this.calculateValue(value);\n    }\n    updateValue(value) {\n        super.updateValue(value);\n        this.onInput({ value });\n    }\n    getTooltipHtml(value) {\n        const tasksPerRow = this.calculateValue(value);\n        return `${tasksPerRow} card${tasksPerRow === 1 ? '' : 's'} per row`;\n    }\n}\nZoomSlider.initClass();\nZoomSlider._$name = 'ZoomSlider';"],
  "mappings": "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",
  "names": ["centerX", "_a", "_a", "ProjectModel", "_a", "_a", "_a", "cardSelector", "_a", "_a", "ProjectModel", "_a", "_a", "_a", "_a", "_a", "ProjectCombo"]
}
