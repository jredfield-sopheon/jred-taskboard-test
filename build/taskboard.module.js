/*!
 *
 * Bryntum TaskBoard 5.6.2
 *
 * Copyright(c) 2023 Bryntum AB
 * https://bryntum.com/contact
 * https://bryntum.com/license
 *
 */
var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};

// ../Core/lib/Core/helper/BrowserHelper.js
var _a;
var BrowserHelper = class {
  static cacheFlags(platform = navigator.platform, userAgent = navigator.userAgent) {
    const me = this;
    me._isLinux = Boolean(platform.match(/Linux/));
    me._isMac = Boolean(platform.match(/Mac/));
    me._isWindows = Boolean(platform.match(/Win32/));
    me._isMobile = Boolean(userAgent.match(/Mobile|Opera Mini|Opera Mobi|Puffin/) || typeof globalThis.orientation === "number");
    me._isWebkit = Boolean(userAgent.match(/WebKit/) && !userAgent.match(/Edg/));
    me._firefoxVersion = me.getVersion(userAgent, /Firefox\/(\d+)\./);
    me._isFirefox = me._firefoxVersion > 0;
    me._chromeVersion = me.getVersion(userAgent, /Chrom(?:e|ium)\/(\d+)\./);
    me._isChrome = me._chromeVersion > 0;
    me._isSafari = Boolean(userAgent.match(/Safari/)) && !me._isChrome;
    me._isMobileSafari = Boolean(userAgent.match(/Mobile.*Safari/));
    me._safariVersion = me.getVersion(userAgent, /Version\/(.*).Safari/);
    me._isAndroid = Boolean(userAgent.match(/Android/g));
  }
  //endregion
  //region Device
  /**
   * Yields `true` if the current browser supports CSS style `overflow:clip`.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get supportsOverflowClip() {
    if (this._supportsOverflowClip == null) {
      const div = document.createElement("div");
      div.style.overflow = "clip";
      div.style.display = "none";
      document.documentElement.appendChild(div);
      this._supportsOverflowClip = div.ownerDocument.defaultView.getComputedStyle(div).getPropertyValue("overflow") === "clip";
      div.remove();
    }
    return this._supportsOverflowClip;
  }
  /**
   * Yields `true` if the current browser supports CSS style `position:sticky`.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get supportsSticky() {
    return true;
  }
  /**
   * Returns matched version for userAgent.
   * @param {String} versionRe version match regular expression
   * @returns {Number} matched version
   * @readonly
   * @internal
   */
  static getVersion(userAgent, versionRe) {
    const match = userAgent.match(versionRe);
    return match ? parseFloat(match[1]) : 0;
  }
  /**
   * Determines if the user is using a touch device.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  static get isTouchDevice() {
    if (this._isTouchDevice === void 0) {
      this._isTouchDevice = globalThis.matchMedia("(pointer:coarse)").matches;
    }
    return this._isTouchDevice;
  }
  // Reports true by default for our tests
  static get isHoverableDevice() {
    if (this._isHoverableDevice === void 0) {
      this._isHoverableDevice = globalThis.matchMedia("(any-hover: hover)").matches;
    }
    return this._isHoverableDevice;
  }
  //endregion
  //region Platform
  static get isBrowserEnv() {
    return typeof window !== "undefined";
  }
  /**
   * Checks if platform is Mac.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isMac() {
    return this._isMac;
  }
  /**
   * Checks if platform is Windows.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isWindows() {
    return this._isWindows;
  }
  /**
   * Checks if platform is Linux.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isLinux() {
    return this._isLinux;
  }
  /**
   * Checks if platform is Android.
   * @property {Boolean}
   * @readonly
   * @category Platform
   */
  static get isAndroid() {
    return this._isAndroid;
  }
  //endregion
  //region Browser
  /**
   * Checks if browser is Webkit.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isWebkit() {
    return this._isWebkit;
  }
  /**
   * Checks if browser is Chrome or Chromium based browser.
   * Returns truthy value for Edge Chromium.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isChrome() {
    return this._isChrome;
  }
  /**
   * Returns the major Chrome version or 0 for other browsers.
   * @property {Number}
   * @readonly
   * @category Browser
   */
  static get chromeVersion() {
    return this._chromeVersion;
  }
  /**
   * Checks if browser is Firefox.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isFirefox() {
    return this._isFirefox;
  }
  /**
   * Returns the major Firefox version or 0 for other browsers.
   * @property {Number}
   * @readonly
   * @category Browser
   */
  static get firefoxVersion() {
    return this._firefoxVersion;
  }
  /**
   * Checks if browser is Safari.
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isSafari() {
    return this._isSafari;
  }
  static get safariVersion() {
    return this._safariVersion;
  }
  /**
   * Checks if browser is mobile Safari
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isMobileSafari() {
    return this._isMobileSafari;
  }
  /**
   * Checks if the active device is a mobile device
   * @property {Boolean}
   * @readonly
   * @category Browser
   */
  static get isMobile() {
    return this._isMobile;
  }
  static get platform() {
    const me = this;
    return me._isLinux ? "linux" : me._isMac ? "mac" : me._isWindows ? "windows" : me._isAndroid ? "android" : me._isMobileSafari ? "ios" : null;
  }
  /**
   * Returns `true` if the browser supports passive event listeners.
   * @property {Boolean}
   * @internal
   * @deprecated Since 5.0. All modern browsers now support passive event listeners.
   * @category Browser
   */
  static get supportsPassive() {
    return true;
  }
  // Only works in secure contexts
  static get supportsRandomUUID() {
    if (this._supportsRandomUUID === void 0) {
      try {
        this._supportsRandomUUID = Boolean(globalThis.crypto.randomUUID().length > 0);
      } catch (e) {
        this._supportsRandomUUID = false;
      }
    }
    return this._supportsRandomUUID;
  }
  //endregion
  //region Storage
  // https://developer.mozilla.org/en-US/docs/Web/API/Web_Storage_API/Using_the_Web_Storage_API
  static get storageAvailable() {
    let storage, x;
    try {
      storage = localStorage;
      x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return true;
    } catch (e) {
      return e instanceof DOMException && // everything except Firefox
      (e.code === 22 || // Firefox
      e.code === 1014 || // test name field too, because code might not be present
      // everything except Firefox
      e.name === "QuotaExceededError" || // Firefox
      e.name === "NS_ERROR_DOM_QUOTA_REACHED") && // acknowledge QuotaExceededError only if there's something already stored
      storage.length !== 0;
    }
  }
  static setLocalStorageItem(key, value) {
    this.storageAvailable && localStorage.setItem(key, value);
  }
  static getLocalStorageItem(key) {
    return this.storageAvailable && localStorage.getItem(key);
  }
  static removeLocalStorageItem(key) {
    this.storageAvailable && localStorage.removeItem(key);
  }
  //endregion
  //region Helpers
  /**
   * Returns parameter value from search string by parameter name.
   * @param {String} paramName search parameter name
   * @param {String} [defaultValue] default value if parameter not found
   * @param {String} [search] search string. Defaults to `document.location.search`
   * @returns {String} search parameter string value
   * @category Helper
   */
  static searchParam(paramName, defaultValue2 = null, search = document.location.search) {
    const re = new RegExp(`[?&]${paramName}=?([^&]*)`), match = search.match(re);
    return match && match[1] || defaultValue2;
  }
  /**
   * Returns cookie by name.
   * @param {String} name cookie name
   * @returns {String} cookie string value
   * @category Helper
   */
  static getCookie(name) {
    const nameEq = encodeURIComponent(name) + "=", cookieItems = document.cookie.split(";");
    for (let i = 0; i < cookieItems.length; i++) {
      let c = cookieItems[i];
      while (c.charAt(0) === " ") {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEq) === 0) {
        return decodeURIComponent(c.substring(nameEq.length, c.length));
      }
    }
    return "";
  }
  /**
   * Triggers a download of a file with the specified name / URL.
   * @param {String} filename The filename of the file to be downloaded
   * @param {String} [url] The URL where the file is to be downloaded from
   * @internal
   * @category Download
   */
  static download(filename, url) {
    const a = document.createElement("a");
    a.download = filename;
    a.href = url || filename;
    a.style.cssText = "display:none";
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
  }
  /**
   * Triggers a download of a Blob with the specified name.
   * @param {Blob} blob The Blob to be downloaded
   * @param {String} filename The filename of the file to be downloaded
   * @internal
   * @category Download
   */
  static downloadBlob(blob, filename) {
    const url = globalThis.URL.createObjectURL(blob);
    this.download(filename, url);
    globalThis.URL.revokeObjectURL(url);
  }
  static get queryString() {
    var _a2;
    const params = new URL(globalThis.location.href).searchParams;
    return (_a2 = Object.fromEntries) == null ? void 0 : _a2.call(Object, params.entries());
  }
  // Used by docs fiddle
  static copyToClipboard(code) {
    let success2 = true;
    const textArea = document.createElement("textarea");
    textArea.value = code;
    textArea.style.height = textArea.style.width = 0;
    document.body.appendChild(textArea);
    textArea.select();
    try {
      document.execCommand("copy");
    } catch (e) {
      success2 = false;
    }
    textArea.remove();
    return success2;
  }
  static isBryntumOnline(searchStrings) {
    searchStrings = Array.isArray(searchStrings) ? searchStrings : [searchStrings];
    return Boolean(/^(www\.)?bryntum\.com/.test(globalThis.location.host) || (searchStrings == null ? void 0 : searchStrings.some((str) => this.queryString[str] != null)));
  }
  /**
   * Returns truthy value if page contains Content Security Policy meta tag or globalThis.bryntum.CSP is truthy value
   * @returns {Boolean}
   * @internal
   **/
  static get isCSP() {
    const { bryntum, document: document2 } = globalThis;
    if (bryntum.CSP == null) {
      bryntum.CSP = Boolean(document2.querySelector('meta[http-equiv="Content-Security-Policy"]'));
    }
    return bryntum.CSP;
  }
  //endregion
};
__publicField(BrowserHelper, "supportsPointerEvents", Boolean(globalThis.PointerEvent || globalThis.MSPointerEvent));
// Locker Service does not allow to instantiate PointerEvents. LWS apparently does, however.
// https://github.com/bryntum/support/issues/5578
__publicField(BrowserHelper, "supportsPointerEventConstructor", typeof PointerEvent !== "undefined");
__publicField(BrowserHelper, "PointerEventConstructor", globalThis.PointerEvent || globalThis.CustomEvent);
//region Init
/**
 * Yields `true` if the platform running is a phone (screen width or height <= 414 CSS pixels)
 * @property {Boolean}
 * @readonly
 * @static
 * @category Platform
 */
__publicField(BrowserHelper, "isPhone", (_a = globalThis.matchMedia) == null ? void 0 : _a.call(globalThis, "(max-height:414px) or (max-width:414px)").matches);
if (BrowserHelper.isBrowserEnv) {
  BrowserHelper.cacheFlags();
}
BrowserHelper._$name = "BrowserHelper";

// ../Core/lib/Core/helper/StringHelper.js
var charsToEncode;
var entitiesToDecode;
var htmlEncodeRe;
var htmlDecodeRe;
var camelLettersRe = /([a-z])([A-Z])/g;
var crlfRe = /[\n\r]/g;
var escapeRegExpRe = /[.*+?^${}()|[\]\\]/g;
var htmlRe = /[&<]/;
var idRe = /(^[^a-z]+[^\w]+)/gi;
var whiteSpaceRe = /\s+/;
var domIdRe = /^[^a-z]+|[^\w:.-]+/gi;
var htmlDecoder = (m, captured) => entitiesToDecode[captured.toLowerCase()] || String.fromCharCode(parseInt(captured.substr(2), 10));
var htmlEncoder = (m, captured) => charsToEncode[captured];
var hyphenateCamelLetters = (all, g1, g2) => {
  return `${g1}-${g2.toLowerCase()}`;
};
var separateCamelLetters = (all, g1, g2) => {
  return `${g1} ${g2.toLowerCase()}`;
};
var replaceNonIdChar = (c) => {
  if (c) {
    return `_x${[...c].map((ch) => ch.charCodeAt(0).toString(16)).join("")}`;
  }
  return "__blank__";
};
var hyphenateCache = {};
var separatedCache = {};
var ancestors = [];
var circularReplacer = function(key, value) {
  if (value && typeof value === "object") {
    while (ancestors.length && ancestors[ancestors.length - 1] !== this) {
      ancestors.pop();
    }
    if (ancestors.includes(value)) {
      return "[Circular]";
    }
    ancestors.push(value);
  }
  return value;
};
var _StringHelper = class _StringHelper {
  //region Transform
  /**
   * Capitalizes the first letter of a string, "myString" -> "MyString".
   * @param {String} string The string to capitalize
   * @returns {String} The capitalized string or the value of `string` if falsy.
   * @category String formatting
   */
  static capitalize(string2) {
    return string2 && string2[0].toUpperCase() + string2.substr(1);
  }
  /**
   * Makes the first letter of a string lowercase, "MyString" -> "myString".
   * @param {String} string The string to un-capitalize.
   * @returns {String} The un-capitalized string or the value of `string` if falsy.
   * @category String formatting
   */
  static uncapitalize(string2) {
    return string2 && string2[0].toLowerCase() + string2.substr(1);
  }
  /**
   * Converts the passed camelCased string to a hyphen-separated string. eg "minWidth" -> "min-width"
   * @param {String} string The string to convert.
   * @returns {String} The string with adjoining lower and upper case letters
   * separated by hyphens and converted to lower case.
   * @category String formatting
   * @internal
   */
  static hyphenate(string2) {
    const cached = hyphenateCache[string2];
    if (cached) {
      return cached;
    }
    return hyphenateCache[string2] = string2.replace(camelLettersRe, hyphenateCamelLetters);
  }
  /**
   * Converts the passed camelCased string to a capitalized, space-separated string. eg "startDate" -> "Start date".
   * @param {String} string The string to convert.
   * @returns {String} The string with spaces separating words.
   * @category String formatting
   * @internal
   */
  static separate(string2) {
    const cached = separatedCache[string2];
    if (cached) {
      return cached;
    }
    return separatedCache[string2] = this.capitalize(string2.replace(camelLettersRe, separateCamelLetters));
  }
  /**
   * Creates an alphanumeric identifier from any passed string. Encodes spaces and non-alpha characters.
   * @param {String} inString The string from which to strip non-identifier characters.
   * @returns {String}
   * @category Misc
   * @internal
   */
  static createId(inString) {
    return String(inString).replace(idRe, replaceNonIdChar);
  }
  static makeValidDomId(id, replaceValue = "") {
    if (id == null) {
      return null;
    }
    return String(id).replace(domIdRe, replaceValue);
  }
  //endregion
  //region Html
  /**
   * Escapes special RegExp characters.
   * @param {String} string String to escape
   * @privateparam {String} [flags] Optional flags
   * @returns {String} Escaped string
   */
  static escapeRegExp(string2, flags) {
    let ret = string2.replace(escapeRegExpRe, "\\$&");
    if (flags !== void 0) {
      ret = new RegExp(ret, flags);
    }
    return ret;
  }
  /**
   * This method decodes HTML entities and returns the original HTML.
   *
   * See also {@link #function-encodeHtml-static}.
   * @param {String} str
   * @returns {String}
   * @category HTML
   */
  static decodeHtml(str) {
    return str && String(str).replace(htmlDecodeRe, htmlDecoder);
  }
  /**
   * This method encodes HTML entities and returns a string that can be placed in the document and produce the
   * original text rather than be interpreted as HTML. Using this method with user-entered values prevents those
   * values from executing as HTML (i.e., a cross-site scripting or "XSS" security issue).
   *
   * See also {@link #function-decodeHtml-static}.
   * @param {String|Number} str
   * @returns {String}
   * @category HTML
   */
  static encodeHtml(str = "") {
    return str && String(str).replace(htmlEncodeRe, htmlEncoder);
  }
  /**
   * This method is similar to {@link #function-encodeHtml-static} except that `\n` and `\r` characters in the
   * given `str` are replaced by `<br>` tags _after_ first being encoded by {@link #function-encodeHtml-static}.
   * @param {String} str
   * @returns {String}
   * @category HTML
   * @internal
   */
  static encodeHtmlBR(str) {
    var _a2;
    return (_a2 = _StringHelper.encodeHtml(str)) == null ? void 0 : _a2.replace(crlfRe, "<br>");
  }
  /**
   * Returns `true` if the provided `text` contains special HTML characters.
   * @param {String} text
   * @returns {Boolean}
   * @category HTML
   * @internal
   */
  static isHtml(text) {
    return typeof text === "string" && htmlRe.test(text || "");
  }
  /**
   * Initializes HTML entities used by {@link #function-encodeHtml-static} and {@link #function-decodeHtml-static}.
   * @param {Object} [mappings] An object whose keys are characters that should be encoded and values are the HTML
   * entity for the character.
   * @private
   */
  static initHtmlEntities(mappings) {
    mappings = mappings || {
      "&": "&amp;",
      ">": "&gt;",
      "<": "&lt;",
      '"': "&quot;",
      "'": "&#39;"
    };
    const chars = Object.keys(mappings);
    charsToEncode = mappings;
    entitiesToDecode = chars.reduce((prev, val) => {
      prev[mappings[val]] = val;
      return prev;
    }, {});
    htmlEncodeRe = new RegExp(`([${chars.map((c) => "[-]".includes(c) ? "\\" + c : c).join("")}])`, "g");
    htmlDecodeRe = new RegExp(`(${Object.values(mappings).join("|")}|&#[0-9]+;)`, "ig");
  }
  //endregion
  //region JSON
  /**
   * Parses JSON inside a try-catch block. Returns null if the string could not be parsed.
   *
   * @param {String} string String to parse
   * @returns {Object} Resulting object or `null` if parse failed
   * @category JSON
   */
  static safeJsonParse(string2) {
    let parsed = null;
    try {
      parsed = JSON.parse(string2);
    } catch (e) {
    }
    return parsed;
  }
  /**
   * Stringifies an object inside a try-catch block. Returns null if an exception is encountered.
   *
   * See [JSON.stringify on MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify)
   * for more information on the arguments.
   *
   * @param {Object} object The object to stringify
   * @param {Function|'circular'|String[]|Number[]} [replacer] A function or array of string/number used to determine
   * properties to include in the JSON string. Also accepts the string 'circular' to use a built-in replacer handling
   * circular references, by replacing them with `'[Circular]'`.
   * See [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Cyclic_object_value) for more
   * information.
   * @param {String|Number} [space] Number of spaces to indent or string used as whitespace
   * @returns {String} Resulting object or null if stringify failed
   * @category JSON
   */
  static safeJsonStringify(object, replacer = null, space = null) {
    let result = null;
    try {
      if (replacer === "circular") {
        ancestors.length = 0;
        replacer = circularReplacer;
      }
      result = JSON.stringify(object, replacer, space);
    } catch (e) {
    }
    return result;
  }
  //endregion
  //region Split & join
  /**
   * Joins all given paths together using the separator as a delimiter and normalizes the resulting path.
   * @param paths {Array} array of paths to join
   * @param pathSeparator [{String}] path separator. Default value is '/'
   * @returns {String}
   * @category Misc
   * @internal
   */
  static joinPaths(paths, pathSeparator = "/") {
    return paths.join(pathSeparator).replace(new RegExp("\\" + pathSeparator + "+", "g"), pathSeparator);
  }
  /**
   * Returns the provided string split on whitespace. If the string is empty or consists of only whitespace, the
   * returned array will be empty. If `str` is not a string, it is simply returned. This allows `null` or already
   * split strings (arrays) to be passed through.
   *
   * For example:
   * ```
   *  console.log(StringHelper.split(' abc def xyz   '));
   *  > ['abc', 'def', 'xyz']
   *  console.log(StringHelper.split(''));
   *  > []
   * ```
   * Compare to the standard `split()` method:
   * ```
   *  console.log(' abc def xyz   '.split(/\s+/));
   *  > ['', 'abc', 'def', 'xyz', '']
   *  console.log(''.split(/\s+/));
   *  > ['']
   * ```
   * @param {String} str
   * @param {String|RegExp} delimiter
   * @returns {String[]}
   * @category Misc
   * @internal
   */
  static split(str, delimiter = whiteSpaceRe) {
    let ret = str;
    if (typeof ret === "string") {
      ret = str.trim();
      ret = ret ? ret.split(delimiter) : [];
    }
    return ret;
  }
  //endregion
  //region XSS
  /**
   * This is a tagged template function that performs HTML encoding on replacement values to avoid XSS (Cross-Site
   * Scripting) attacks.
   *
   * For example:
   *
   * ```javascript
   *  eventRenderer(eventRecord) {
   *      return StringHelper.xss`<span class="${eventRecord.attrib}">${eventRecord.name}</span>`;
   *  }
   * ```
   *
   * @param {TemplateStringsArray} strings The template string array
   * @param {...any} values The interpolated values in the template string
   * @returns {String} The encoded string
   * See {@link Core.helper.StringHelper#function-encodeHtml-static}.
   */
  static xss(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + _StringHelper.encodeHtml(values[i]);
    }
    return buf.join("");
  }
  /**
   * This is a tagged template function that performs HTML encoding on replacement values to avoid XSS (Cross-Site
   * Scripting) attacks. Unlike {@link Core.helper.StringHelper#function-xss-static}, this method converts `\n` and
   * `\r` characters into `<br>` tags.
   *
   * For example:
   *
   * ```javascript
   *  eventRenderer(eventRecord) {
   *      return StringHelper.xssBR`<span class="${eventRecord.attrib}">${eventRecord.name}</span>`;
   *  }
   * ```
   *
   * See {@link Core.helper.StringHelper#function-encodeHtmlBR-static}.
   * @internal
   */
  static xssBR(strings, ...values) {
    const buf = [];
    let i = values.length;
    buf[i] = strings[i];
    while (i-- > 0) {
      buf[i] = strings[i] + _StringHelper.encodeHtmlBR(values[i]);
    }
    return buf.join("");
  }
  //endregion
  //region JavaScript string
  /**
   * Converts a value to a JavaScript string (not JSON).
   *
   * For example a date to `"new Date(y, m, d)"`, an array to `"[...]"` etc.
   *
   * @param {*} value
   * @param {Object} [options]
   * @returns {String}
   * @internal
   */
  static toJavaScriptValue(value, options) {
    const type = Objects.typeOf(value);
    if (type === "boolean" || type === "string" || type === "number" || value === null) {
      return _StringHelper.safeJsonStringify(value);
    }
    if (value === globalThis) {
      return "window";
    }
    if (type === "date") {
      return `new Date(${value.getFullYear()}, ${value.getMonth()}, ${value.getDate()}, ${value.getHours()}, ${value.getMinutes()}, ${value.getSeconds()}, ${value.getMilliseconds()})`;
    }
    if (type === "array") {
      return `[${value.map((v) => _StringHelper.toJavaScriptValue(v, options))}]`;
    }
    if (type === "object" || type === "instance") {
      return this.toJavaScriptString(value, options);
    }
    if (type === "function") {
      let contents = value.toString();
      if (contents.match(/^async (\w+?)\(/)) {
        contents = contents.replace(/^async (\w+?)\(/, "async function(");
      } else if (!contents.startsWith("async(") && contents.match(/^(\w+?)\(/)) {
        contents = contents.replace(/^(\w+?)\(/, "function(");
      }
      return contents;
    }
    if (type === "class") {
      if (value.toJavaScriptValue) {
        return value.toJavaScriptValue(options);
      }
      return Object.prototype.hasOwnProperty.call(value, "$name") ? value.$name : value.name;
    }
  }
  /**
   * Converts an object into a JavaScript string (not JSON).
   *
   * For example `{ a: 1, b: [2, 3] }` -> `"'{ a: 1, b: [2, 3] }'"`
   *
   * @param {Object} obj
   * @param {Object} [options]
   * @returns {String}
   * @internal
   */
  static toJavaScriptString(obj, options = {}) {
    var _a2;
    const level = (_a2 = options.level) != null ? _a2 : 0, intendSize = 2;
    return "{\n" + Object.keys(obj).map(
      (key) => (
        // All properties in an object are indented one step further than the object itself
        " ".repeat((level + 1) * intendSize) + (key.match(/[- *]/) ? `"${key}"` : key) + `: ${_StringHelper.toJavaScriptValue(obj[key], { ...options, level: level + 1 })}`
      )
    ).join(",\n") + // Closing brace is indented to same level as the object
    "\n" + " ".repeat(level * intendSize) + "}";
  }
  /**
   * Escapes " and \ in CSS attribute selectors, e.g. [data-id="somevalue"]
   *
   * Usage:
   * ```javascript
   * document.querySelector(StringHelper.cssAttributeQuery('data-id', 'id with & \\ chars'))
   * ```
   *
   * @param {String} attr
   * @param {String|Number} value
   * @returns {String}
   */
  static encodeAttributeSelector(attr, value) {
    return `[${attr}="${String(value).replace(/["\\]/g, "\\$&")}"]`;
  }
  /**
   * Generates a UUID. Uses `Crypto.randomUUID()` if available, otherwise generates a random UUID using
   * `Crypto.getRandomValues()`.
   *
   * @returns {String}
   */
  static generateUUID() {
    var _a2;
    if (BrowserHelper.supportsRandomUUID) {
      return globalThis.crypto.randomUUID();
    }
    if ((_a2 = globalThis.crypto) == null ? void 0 : _a2.getRandomValues) {
      return ("10000000-1000-4000-8000" + -1e11).replace(
        /[018]/g,
        (c) => (c ^ globalThis.crypto.getRandomValues(new Uint8Array(1))[0] & 15 >> c / 4).toString(16)
      );
    }
    return `${Date.now()}-${++_StringHelper.fakeNodeUUIDIndex}`;
  }
  //endregion
};
//endregion
//region UUID
__publicField(_StringHelper, "fakeNodeUUIDIndex", 0);
var StringHelper = _StringHelper;
StringHelper.initHtmlEntities();
StringHelper._$name = "StringHelper";

// ../Core/lib/Core/helper/util/Objects.js
var { hasOwnProperty: hasOwnProperty2, toString } = Object.prototype;
var { isFrozen } = Object;
var afterRe = /\s*<\s*/;
var beforeRe = /\s*>\s*/;
var blendOptions = {};
var typeCache = {};
var emptyObject = Object.freeze({});
var Objects = class _Objects {
  static assign(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          dest[key] = source[key];
        }
      }
    }
    return dest;
  }
  static assignIf(dest, ...sources) {
    for (let source, key, i = 0; i < sources.length; i++) {
      source = sources[i];
      if (source) {
        for (key in source) {
          if (!(key in dest) || dest[key] === void 0) {
            dest[key] = source[key];
          }
        }
      }
    }
    return dest;
  }
  static blend(dest, source, options) {
    options = options || blendOptions;
    dest = dest || {};
    const { clone = _Objects.clone, merge = _Objects.blend } = options;
    if (Array.isArray(source)) {
      if (source.length > 1) {
        source.forEach((s) => {
          dest = _Objects.blend(dest, s, options);
        });
        return dest;
      }
      source = source[0];
    }
    if (source) {
      let destValue, key, value;
      for (key in source) {
        value = source[key];
        if (value && _Objects.isObject(value)) {
          destValue = dest[key];
          options.key = key;
          if (destValue && _Objects.isObject(destValue)) {
            if (isFrozen(destValue)) {
              dest[key] = destValue = clone(destValue, options);
            }
            value = merge(destValue, value, options);
          } else {
            value = isFrozen(value) ? value : clone(value, options);
          }
        }
        dest[key] = value;
      }
    }
    return dest;
  }
  static clone(value, handler) {
    let cloned = value, key;
    if (value && typeof value === "object") {
      const options = handler && typeof handler === "object" && handler;
      if (options) {
        handler = null;
      }
      if (_Objects.isObject(value)) {
        if (value.skipClone) {
          cloned = value;
        } else {
          cloned = {};
          for (key in value) {
            cloned[key] = _Objects.clone(value[key]);
          }
        }
      } else if (Array.isArray(value)) {
        cloned = [];
        for (key = value.length; key-- > 0; ) {
          cloned[key] = _Objects.clone(value[key]);
        }
      } else if (_Objects.isDate(value)) {
        cloned = new Date(value.getTime());
      } else if (handler) {
        cloned = handler(value);
      }
    }
    return cloned;
  }
  static createTruthyKeys(source) {
    const keys = StringHelper.split(source), result = keys && {};
    if (keys) {
      for (const key of keys) {
        if (key) {
          result[key] = true;
        }
      }
    }
    return result;
  }
  /**
   * Returns value for a given path in the object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {*} Value associated with passed key
   */
  static getPath(object, path) {
    return path.split(".").reduce((result, key) => {
      return (result || emptyObject)[key];
    }, object);
  }
  /**
   * Returns value for a given path in the object, placing a passed default value in at the
   * leaf property and filling in undefined properties all the way down.
   * @param {Object} object Object to get path value for.
   * @param {String|Number|String[]|Number[]} path Dot-separated path, e.g. 'firstChild.childObject.someKey',
   * or the key path as an array, e.g. ['firstChild', 'childObject', 'someKey'].
   * @param {*} [defaultValue] Optionally the value to put in as the `someKey` property.
   * @returns {*} Value at the leaf position of the path.
   */
  static getPathDefault(object, path, defaultValue2) {
    const keys = Array.isArray(path) ? path : typeof path === "string" ? path.split(".") : [path], length = keys.length - 1;
    return keys.reduce((result, key, index) => {
      if (defaultValue2 && !(key in result)) {
        result[key] = index === length ? defaultValue2 : {};
      }
      return (result || emptyObject)[key];
    }, object);
  }
  /**
   * Determines if the specified path exists
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {Boolean}
   */
  static hasPath(object, path) {
    return path.split(".").every((key) => {
      if (object && key in object) {
        object = object[key];
        return true;
      }
      return false;
    });
  }
  static getTruthyKeys(source) {
    const keys = [];
    for (const key in source) {
      if (source[key]) {
        keys.push(key);
      }
    }
    return keys;
  }
  static getTruthyValues(source) {
    const values = [];
    for (const key in source) {
      if (source[key]) {
        values.push(source[key]);
      }
    }
    return values;
  }
  static isClass(object) {
    var _a2;
    if (typeof object === "function" && ((_a2 = object.prototype) == null ? void 0 : _a2.constructor) === object) {
      return true;
    }
    return false;
  }
  static isDate(object) {
    return Boolean(object == null ? void 0 : object.getUTCDate) && _Objects.typeOf(object) === "date";
  }
  /**
   * Check if passed object is a Promise or contains `then` method.
   * Used to fix problems with detecting promises in code with `instance of Promise` when
   * Promise class is replaced with any other implementation like `ZoneAwarePromise` in Angular.
   * Related to these issues:
   * https://github.com/bryntum/support/issues/791
   * https://github.com/bryntum/support/issues/2990
   *
   * @param {Object} object object to check
   * @returns {Boolean} truthy value if object is a Promise
   * @internal
   */
  static isPromise(object) {
    if (Promise && Promise.resolve) {
      return Promise.resolve(object) === object || typeof (object == null ? void 0 : object.then) === "function";
    }
    throw new Error("Promise not supported in your environment");
  }
  static isEmpty(object) {
    if (object && typeof object === "object") {
      for (const p in object) {
        return false;
      }
    }
    return true;
  }
  static isObject(value) {
    const C = value == null ? void 0 : value.constructor;
    return Boolean(
      C ? (
        // An in-frame instance of Object
        C === Object || // Detect cross-frame objects, but exclude instance of custom classes named Object. typeOf(value) is
        // "object" even for instances of a class and typeOf(C) is "function" for all constructors. We'll have
        // to settle for relying on the fact that getPrototypeOf(Object.prototype) === null.
        // NOTE: this issue does come up in Scheduler unit tests at least.
        C.getPrototypeOf && C.prototype && !Object.getPrototypeOf(C.prototype)
      ) : value && typeof value === "object"
    );
  }
  static isInstantiated(object) {
    return object ? typeof object === "object" && !_Objects.isObject(object) : false;
  }
  static merge(dest, ...sources) {
    return _Objects.blend(dest, sources);
  }
  /**
   * Merges two "items" objects. An items object is a simple object whose keys act as identifiers and whose values
   * are "item" objects. An item can be any object type. This method is used to merge such objects while maintaining
   * their property order. Special key syntax is used to allow a source object to insert a key before or after a key
   * in the `dest` object.
   *
   * For example:
   * ```javascript
   *  let dest = {
   *      foo : {},
   *      bar : {},
   *      fiz : {}
   *  }
   *
   *  console.log(Object.keys(dest));
   *  > ["foo", "bar", "fiz"]
   *
   *  dest = mergeItems(dest, {
   *      'zip > bar' : {}    // insert "zip" before "bar"
   *      'bar < zap' : {}    // insert "zap" after "bar"
   *  });
   *
   *  console.log(Object.keys(dest));
   *  > ["foo", "zip", "bar", "zap", "fiz"]
   * ```
   *
   * @param {Object} dest The destination object.
   * @param {Object|Object[]} src The source object or array of source objects to merge into `dest`.
   * @param {Object} [options] The function to use to merge items.
   * @param {Function} [options.merge] The function to use to merge items.
   * @returns {Object} The merged object. This will be the `dest` object.
   * @internal
   */
  static mergeItems(dest, src, options) {
    options = options || blendOptions;
    let anchor, delta, index, indexMap, key, shuffle, srcVal;
    const { merge = _Objects.blend } = options;
    dest = dest || {};
    if (Array.isArray(src)) {
      src.forEach((s) => {
        dest = _Objects.mergeItems(dest, s, options);
      });
    } else if (src) {
      for (key in src) {
        srcVal = src[key];
        anchor = null;
        if (key.includes(">")) {
          [key, anchor] = key.split(beforeRe);
          delta = 0;
        } else if (key.includes("<")) {
          [anchor, key] = key.split(afterRe);
          delta = 1;
        }
        if (key in dest) {
          if (srcVal && dest[key] && merge) {
            options.key = key;
            srcVal = merge(dest[key], srcVal, options);
          }
          dest[key] = srcVal;
        } else if (!anchor) {
          dest[key] = srcVal;
          indexMap == null ? void 0 : indexMap.set(key, indexMap.size);
        } else {
          if (!indexMap) {
            indexMap = /* @__PURE__ */ new Map();
            index = 0;
            for (const k in dest) {
              indexMap.set(k, index++);
            }
          }
          index = indexMap.get(anchor);
          dest[key] = srcVal;
          if (index == null && delta) {
            index = indexMap.size;
          } else {
            shuffle = shuffle || [];
            index = (index || 0) + delta;
            for (const item of indexMap) {
              const [k, v] = item;
              if (index <= v) {
                shuffle && (shuffle[indexMap.size - v - 1] = k);
                indexMap.set(k, v + 1);
              }
            }
            if (shuffle) {
              while (shuffle.length) {
                const k = shuffle.pop(), v = dest[k];
                delete dest[k];
                dest[k] = v;
              }
            }
          }
          indexMap.set(key, index);
        }
      }
    }
    return dest;
  }
  /**
   * Sets value for a given path in the object
   * @param {Object} object Target object
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @param {*} value Value for a given path
   * @returns {Object} Returns passed object
   */
  static setPath(object, path, value) {
    path.split(".").reduce((result, key, index, array) => {
      const isLast = index === array.length - 1;
      if (isLast) {
        return result[key] = value;
      } else if (!(result[key] instanceof Object)) {
        result[key] = {};
      }
      return result[key];
    }, object);
    return object;
  }
  static typeOf(value) {
    let trueType, type;
    if (value === null) {
      type = "null";
    } else if (value !== value) {
      type = "nan";
    } else {
      type = typeof value;
      if (type === "object") {
        if (value.isBase) {
          type = "instance";
        } else if (Array.isArray(value)) {
          type = "array";
        } else if (!(type = typeCache[trueType = toString.call(value)])) {
          typeCache[trueType] = type = trueType.slice(8, -1).toLowerCase();
        }
      } else if (type === "function" && value.isBase) {
        type = "class";
      }
    }
    return type;
  }
};
Object.defineProperty(Objects, "hasOwn", {
  // When available, this avoids an extra layer of function call around it:
  value: Object.hasOwn || ((object, property) => hasOwnProperty2.call(object, property))
});
Objects._$name = "Objects";

// ../Core/lib/Core/helper/VersionHelper.js
var VersionHelper = class _VersionHelper {
  /**
   * Set version for specified product
   * @private
   * @param {String} product
   * @param {String} version
   */
  static setVersion(product, version) {
    product = product.toLowerCase();
    VH[product] = {
      version,
      isNewerThan(otherVersion) {
        return _VersionHelper.semanticCompareVersion(otherVersion, version, "<");
      },
      isOlderThan(otherVersion) {
        return _VersionHelper.semanticCompareVersion(otherVersion, version, ">");
      }
    };
    let bundleFor = "";
    if (typeof productName !== "undefined") {
      bundleFor = productName;
    }
    const globalKey = `${bundleFor}.${product}${version.replace(/\./g, "-")}`;
    if (BrowserHelper.isBrowserEnv && !globalThis.bryntum.silenceBundleException) {
      if (globalThis.bryntum[globalKey] === true) {
        if (this.isTestEnv) {
          globalThis.BUNDLE_EXCEPTION = true;
        } else {
          let errorProduct = bundleFor || product;
          if (errorProduct === "core") {
            errorProduct = "grid";
          }
          let capitalized = StringHelper.capitalize(errorProduct);
          if (errorProduct === "schedulerpro") {
            capitalized = "SchedulerPro";
          }
          throw new Error(
            `The Bryntum ${capitalized} bundle was loaded multiple times by the application.

Common reasons you are getting this error includes:

* Imports point to different types of the bundle (e.g. *.module.js and *.umd.js)
* Imports point to both sources and bundle
* Imports do not use the shortest relative path, JS treats them as different files
* Cache busters differ between imports, JS treats ${errorProduct}.module.js?1 and ${errorProduct}.module.js?2 as different files
* Imports missing file type, verify they all end in .js

See https://bryntum.com/products/${errorProduct}/docs/guide/${capitalized}/gettingstarted/es6bundle#troubleshooting for more information

`
          );
        }
      } else {
        globalThis.bryntum[globalKey] = true;
      }
    }
  }
  /**
   * Get (previously set) version for specified product
   * @private
   * @param {String} product
   */
  static getVersion(product) {
    product = product.toLowerCase();
    if (!VH[product]) {
      throw new Error("No version specified! Please check that you import VersionHelper correctly into the class from where you call `deprecate` function.");
    }
    return VH[product].version;
  }
  /**
   * Checks the version1 against the passed version2 using the comparison operator.
   * Supports `rc`, `beta`, `alpha` release states. Eg. `1.2.3-alpha-1`.
   * State which is not listed above means some version below `alpha`.
   * @param {String} version1 The version to test against
   * @param {String} version2 The version to test against
   * @param {String} [comparison] The comparison operator, `<=`, `<`, `=`, `>` or `>=`.
   * @returns {Boolean} `true` if the test passes.
   * @internal
   */
  static semanticCompareVersion(version1, version2, comparison = "=") {
    version1 = version1 || "";
    version2 = version2 || "";
    const version1Arr = version1.split(/[-.]/), version2Arr = version2.split(/[-.]/), isLower = comparison.includes("<"), normalizeArr = (arr, maxLength) => {
      const states = ["rc", "beta", "alpha"], result = arr.map((v) => {
        if (states.includes(v)) {
          return -states.indexOf(v) - 2;
        }
        const res = Number.parseInt(v);
        return Number.isNaN(res) ? -states.length : res;
      });
      while (result.length < maxLength) {
        result.push(-1);
      }
      return result;
    }, compareArr = () => {
      const maxLength = Math.max(version1Arr.length, version2Arr.length), arr1 = normalizeArr(version1Arr, maxLength), arr2 = normalizeArr(version2Arr, maxLength);
      for (let i = 0; i < maxLength; i++) {
        if (arr1[i] !== arr2[i]) {
          return isLower ? arr1[i] < arr2[i] : arr1[i] > arr2[i];
        }
      }
      return true;
    };
    switch (comparison) {
      case "=":
        return version1 === version2;
      case "<=":
      case ">=":
        return version1 === version2 || compareArr();
      case "<":
      case ">":
        return version1 !== version2 && compareArr();
    }
    return false;
  }
  /**
   * Checks the passed product against the passed version using the passed test.
   * @param {String} product The name of the product to test the version of
   * @param {String} version The version to test against
   * @param {String} operator The test operator, `<=`, `<`, `=`, `>` or `>=`.
   * @returns {Boolean} `true` if the test passes.
   * @internal
   */
  static checkVersion(product, version, operator) {
    return _VersionHelper.semanticCompareVersion(VH.getVersion(product), version, operator);
  }
  /**
   * Based on a comparison of current product version and the passed version this method either outputs a console.warn
   * or throws an error.
   * @param {String} product The name of the product
   * @param {String} invalidAsOfVersion The version where the offending code is invalid (when any compatibility layer
   * is actually removed).
   * @param {String} message Required! A helpful warning message to show to the developer using a deprecated API.
   * @internal
   */
  static deprecate(product, invalidAsOfVersion, message) {
    const justWarn = VH.checkVersion(product, invalidAsOfVersion, "<");
    if (justWarn) {
      console.warn(`Deprecation warning: You are using a deprecated API which will change in v${invalidAsOfVersion}. ${message}`);
    } else {
      throw new Error(`Deprecated API use. ${message}`);
    }
  }
  /**
   * Returns truthy value if environment is in testing mode
   * @returns {Boolean}
   * @internal
   **/
  static get isTestEnv() {
    var _a2, _b, _c;
    const isTestEnv = Boolean((_a2 = globalThis.bryntum) == null ? void 0 : _a2.isTestEnv);
    try {
      return isTestEnv || Boolean((_c = (_b = globalThis.parent) == null ? void 0 : _b.bryntum) == null ? void 0 : _c.isTestEnv);
    } catch (e) {
      return isTestEnv;
    }
  }
  static get isDebug() {
    let result = false;
    return result;
  }
};
var VH = VersionHelper;
if (BrowserHelper.isBrowserEnv) {
  if (VH.isTestEnv) {
    BrowserHelper._isHoverableDevice = true;
  }
  globalThis.bryntum = Object.assign(globalThis.bryntum || {}, {
    getVersion: VH.getVersion.bind(VH),
    checkVersion: VH.checkVersion.bind(VH),
    deprecate: VH.deprecate.bind(VH),
    license: "%LICENSE%"
  });
}
VersionHelper._$name = "VersionHelper";

// ../Core/lib/Core/Config.js
var { defineProperty, getOwnPropertyDescriptor } = Reflect;
var { hasOwnProperty: hasOwnProperty3, toString: toString2 } = Object.prototype;
var instancePropertiesSymbol = Symbol("instanceProperties");
var configuringSymbol = Symbol("configuring");
var lazyConfigValues = Symbol("lazyConfigValues");
var DATE_TYPE = toString2.call(/* @__PURE__ */ new Date());
var whitespace = /\s+/;
var createClsProps = (result, cls) => {
  result[cls] = 1;
  return result;
};
var Config = class _Config {
  /**
   * Returns the `Config` instance for the given `name` and `options`.
   * @param {String} name The name of the config (e.g., 'text' for the text config).
   * @param {Object} [options] Config behavior options.
   * @returns {Core.Config}
   * @internal
   */
  static get(name, options) {
    const { cache } = this, baseCfg = cache[name] || (cache[name] = new _Config(name));
    let cfg = baseCfg, key;
    if (options) {
      key = _Config.makeCacheKey(name, options);
      if (!(cfg = key && cache[key])) {
        cfg = baseCfg.extend(options);
        if (key) {
          cache[key] = cfg;
        }
      }
    }
    return cfg;
  }
  constructor(name) {
    const me = this, cap = name[0].toUpperCase() + name.substr(1);
    me.base = me;
    me.name = name;
    me.field = "_" + name;
    me.capName = cap;
    me.changer = "change" + cap;
    me.initializing = "initializing" + cap;
    me.updater = "update" + cap;
  }
  /**
   * The descriptor to use with `Reflect.defineProperty()` for defining this config's getter and setter.
   * @property {Object}
   * @private
   */
  get descriptor() {
    let descriptor = this._descriptor;
    if (!descriptor || !hasOwnProperty3.call(this, "_descriptor")) {
      this._descriptor = descriptor = this.makeDescriptor();
    }
    return descriptor;
  }
  /**
   * The descriptor to use with `Reflect.defineProperty()` for defining this config's initter.
   * @property {Object}
   * @private
   */
  get initDescriptor() {
    let descriptor = this._initDescriptor;
    if (!descriptor || !hasOwnProperty3.call(this, "_initDescriptor")) {
      this._initDescriptor = descriptor = this.makeInitter();
    }
    return descriptor;
  }
  /**
   * This method compares two values for semantic equality. By default, this is based on the `===` operator. This
   * is often overridden for configs that accept `Date` or array values.
   * @param {*} value1
   * @param {*} value2
   * @returns {Boolean}
   * @internal
   */
  equal(value1, value2) {
    return value1 === value2;
  }
  /**
   * Extends this config with a given additional set of options. These objects are just prototype extensions of this
   * instance.
   * @param {Object} options
   * @returns {Core.Config}
   * @internal
   */
  extend(options) {
    const cfg = Object.assign(Object.create(this), options), { equal: equal2, merge } = options, { equalityMethods } = _Config;
    if (typeof equal2 === "string") {
      if (equal2.endsWith("[]")) {
        cfg.equal = _Config.makeArrayEquals(equalityMethods[equal2.substr(0, equal2.length - 2)]);
      } else {
        cfg.equal = equalityMethods[equal2];
      }
    }
    if (typeof merge === "string") {
      cfg.merge = _Config.mergeMethods[merge];
    }
    return cfg;
  }
  /**
   * Defines the property on a given target object via `Reflect.defineProperty()`. If the object has its own getter,
   * it will be preserved. It is invalid to define a setter.
   * @param {Object} target
   * @internal
   */
  define(target) {
    const existing = getOwnPropertyDescriptor(target, this.name);
    let descriptor = this.descriptor;
    if (existing && existing.get) {
      descriptor = Object.assign({}, descriptor);
      descriptor.get = existing.get;
    }
    defineProperty(target, this.name, descriptor);
  }
  /**
   * Defines the property initter on the `target`. This is a property getter/setter that propagates the configured
   * value when the property is read.
   * @param {Object} target
   * @param {*} value
   * @internal
   */
  defineInitter(target, value) {
    const { name } = this, properties = target[instancePropertiesSymbol];
    let lazyValues, prop;
    if (!properties[name] && /* assign */
    (prop = getOwnPropertyDescriptor(target, name)) && !("value" in prop)) {
      properties[name] = prop;
    }
    defineProperty(target, name, this.initDescriptor);
    if (this.lazy) {
      lazyValues = target[lazyConfigValues] || (target[lazyConfigValues] = /* @__PURE__ */ new Map());
      lazyValues.set(name, value);
    }
  }
  /**
   * Returns an equality function for arrays of a base type, for example `'date'`.
   * @param {Function} [fn] The function to use to compare array elements. By default, operator `===` is used.
   * @returns {Function}
   * @private
   */
  static makeArrayEquals(fn2) {
    return (value1, value2) => {
      let i, equal2 = value1 && value2 && value1.length === (i = value2.length);
      if (equal2 && Array.isArray(value1) && Array.isArray(value2)) {
        if (fn2) {
          while (equal2 && i-- > 0) {
            equal2 = fn2(value1[i], value2[i]);
          }
        } else {
          while (equal2 && i-- > 0) {
            equal2 = value1[i] === value2[i];
          }
        }
      } else {
        equal2 = fn2 ? fn2(value1, value2) : value1 === value2;
      }
      return equal2;
    };
  }
  /**
   * Returns the key to use in the Config `cache`.
   * @param {String} name The name of the config property.
   * @param {Object} options The config property options.
   * @returns {String}
   * @private
   */
  static makeCacheKey(name, options) {
    const keys = Object.keys(options).sort();
    for (let key, type, value, i = keys.length; i-- > 0; ) {
      value = options[key = keys[i]];
      if (value == null && value === false) {
        keys.splice(i, 1);
      } else {
        type = typeof value;
        if (type === "function") {
          return null;
        }
        if (type === "string") {
          keys[i] = `${key}:"${value}"`;
        } else if (type === "number") {
          keys[i] = `${key}:${value}`;
        }
      }
    }
    return keys.length ? `${name}>${keys.join("|")}` : name;
  }
  /**
   * Creates and returns a property descriptor for this config suitable to be passed to `Reflect.defineProperty()`.
   * @returns {Object}
   * @private
   */
  makeDescriptor() {
    const config = this, { base, field, changer, updater, name } = config;
    if (base !== config && base.equal === config.equal) {
      return base.descriptor;
    }
    return {
      get() {
        var _a2;
        (_a2 = this.configObserver) == null ? void 0 : _a2.get(name, this);
        return this[field];
      },
      set(value) {
        var _a2, _b;
        const me = this;
        let was = me[field], applied, newValue;
        if (typeof value === "string") {
          let resolvedValue = value;
          if (value.startsWith("up.")) {
            resolvedValue = (_a2 = me.owner) == null ? void 0 : _a2.resolveProperty(value.substr(3));
          } else if (value.startsWith("this.")) {
            resolvedValue = me.resolveProperty(value.substr(5));
          }
          if (resolvedValue !== void 0 && typeof resolvedValue !== "function") {
            value = resolvedValue;
          }
        }
        if (me[changer]) {
          applied = (newValue = me[changer](value, was)) === void 0;
          if (!applied) {
            value = newValue;
            was = me[field];
          }
        }
        if (!applied && !(config.equal === equal ? was === value : config.equal(was, value))) {
          me[field] = value;
          applied = true;
          (_b = me[updater]) == null ? void 0 : _b.call(me, value, was);
        }
        if (applied && !me.isDestroyed && !me.onConfigChange.$nullFn) {
          me.onConfigChange({ name, value, was, config });
        }
      }
    };
  }
  /**
   * Creates and returns a property descriptor for this config's initter suitable to pass to
   * `Reflect.defineProperty()`.
   * @returns {Object}
   * @private
   */
  makeInitter() {
    const config = this;
    if (config !== config.base) {
      if (config.lazy) {
        return config.makeLazyInitter();
      }
      return config.base.initDescriptor;
    }
    return config.makeBasicInitter();
  }
  makeBasicInitter() {
    const config = this, { initializing, name } = config;
    return {
      configurable: true,
      get() {
        const me = this;
        config.removeInitter(me);
        me[initializing] = true;
        me[name] = me[configuringSymbol][name];
        me[initializing] = false;
        me.configDone[name] = true;
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        this.configDone[name] = true;
        this[name] = value;
      }
    };
  }
  makeLazyInitter() {
    const config = this, { initializing, name } = config;
    return {
      configurable: true,
      get() {
        const me = this, value = me[lazyConfigValues].get(name);
        config.removeInitter(me);
        if (!me.isDestroying) {
          me[initializing] = true;
          me[name] = value;
          me[initializing] = false;
        }
        return me[name];
      },
      set(value) {
        config.removeInitter(this);
        this[name] = value;
      }
    };
  }
  /**
   * Removes the property initter and restores the instance to its original form.
   * @param {Object} instance
   * @private
   */
  removeInitter(instance) {
    const { name } = this, instanceProperty = instance[instancePropertiesSymbol][name], lazyValues = instance[lazyConfigValues];
    if (instanceProperty) {
      defineProperty(instance, name, instanceProperty);
    } else {
      delete instance[name];
    }
    if ((lazyValues == null ? void 0 : lazyValues.delete(name)) && !lazyValues.size) {
      delete instance[lazyConfigValues];
    }
  }
  setDefault(cls, value) {
    defineProperty(cls.prototype, this.field, {
      configurable: true,
      writable: true,
      // or else "this._value = x" will fail
      value
    });
  }
  /**
   * This method combines (merges) two config values. This is called in two cases:
   *
   *  - When a derived class specifies the value of a config defined in a super class.
   *  - When a value is specified in the instance config object.
   *
   * @param {*} newValue In the case of derived classes, this is the config value of the derived class. In the case
   * of the instance config, this is the instance config value.
   * @param {*} currentValue In the case of derived classes, this is the config value of the super class. In the case
   * of the instance config, this is the class config value.
   * @param {Object} metaNew The class meta object from which the `newValue` is coming. This parameter is `null` if
   * the `newValue` is from an instance configuration.
   * @param {Object} metaCurrent The class meta object from which the `currentValue` is coming. This parameter is
   * `null` if the `currentValue` is not from a class configuration.
   * @returns {*}
   * @internal
   */
  merge(newValue, currentValue) {
    if (currentValue && newValue && Objects.isObject(newValue)) {
      if (currentValue.isBase) {
        return currentValue.setConfig(newValue);
      }
      if (Objects.isObject(currentValue)) {
        newValue = Objects.merge(Objects.clone(currentValue), newValue);
      }
    }
    return newValue;
  }
};
var { prototype } = Config;
var { equal } = prototype;
Config.symbols = {
  configuring: configuringSymbol,
  instanceProperties: instancePropertiesSymbol,
  lazyConfigs: lazyConfigValues
};
Config.cache = /* @__PURE__ */ Object.create(null);
Config.equalityMethods = {
  array: Config.makeArrayEquals(),
  date(value1, value2) {
    if (value1 === value2) {
      return true;
    }
    if (value1 && value2 && toString2.call(value1) === DATE_TYPE && toString2.call(value2) === DATE_TYPE) {
      return value1.getTime() === value2.getTime();
    }
    return false;
  },
  strict: Config.equal = equal
};
Config.mergeMethods = {
  distinct(newValue, oldValue) {
    let ret = oldValue ? oldValue.slice() : [];
    if (newValue != null) {
      if (Objects.isObject(newValue)) {
        if (oldValue === void 0) {
          ret = newValue;
        } else {
          let key, index;
          for (key in newValue) {
            index = ret.indexOf(key);
            if (newValue[key]) {
              if (index < 0) {
                ret.push(key);
              }
            } else if (index > -1) {
              ret.splice(index, 1);
            }
          }
        }
      } else if (Array.isArray(newValue)) {
        newValue.forEach((v) => !ret.includes(v) && ret.push(v));
      } else if (!ret.includes(newValue)) {
        ret.push(newValue);
      }
    }
    return ret;
  },
  merge: Config.merge = prototype.merge,
  classList(newValue, oldValue) {
    if (typeof newValue === "string") {
      if (!newValue.length) {
        return oldValue;
      }
      newValue = newValue.split(whitespace);
    }
    if (Array.isArray(newValue)) {
      newValue = newValue.reduce(createClsProps, {});
    }
    return Config.merge(newValue, oldValue);
  },
  objects(newValue, oldValue) {
    return newValue === true ? oldValue || {} : Config.merge(newValue, oldValue);
  },
  replace(newValue) {
    return newValue;
  },
  items(newValue, oldValue, metaNew, metaCurrent) {
    if (metaCurrent) {
      return Objects.mergeItems(oldValue, newValue, {
        merge: (oldValue2, newValue2) => prototype.merge(newValue2, oldValue2)
      });
    }
    return prototype.merge(newValue, oldValue);
  }
};
Object.assign(prototype, {
  _descriptor: null,
  _initDescriptor: null,
  /**
   * A function that compares values for equality. This test is used to determine if the `update` method should be
   * called when the setter is invoked.
   *
   * To handle `Date` values:
   * ```
   *  class Foo extends Base {
   *      static get configurable() {
   *          return {
   *              date : {
   *                  $config : {
   *                      equal : 'date'
   *                  },
   *
   *                  value : null
   *              }
   *          }
   *      }
   *
   *      updateDate(date) {
   *          // date has changed
   *      }
   *  }
   * ```
   *
   * Also useful for some configs:
   * ```
   *  class Foo extends Base {
   *      static get configurable() {
   *          return {
   *              bar : {
   *                  $config : {
   *                      equal : ObjectHelper.isEqual
   *                  },
   *
   *                  value : null
   *              }
   *          }
   *      }
   *
   *      updateBar(value) {
   *          // value has changed
   *      }
   *  }
   * ```
   * @config {Function} equal
   * @internal
   */
  /**
   * Indicates that this config property should not automatically initialize during construction. When this property
   * is set to `true`, initialization is triggered by the first use of the config property's getter.
   *
   * This property can alternatively be set to a string, in which case it can be initialized as a group using the
   * {@link Core.Base#function-triggerConfigs} method which will initialize all lazy configs with the same value for
   * this property. Note: the config will still initialize on first use if that occurs prior to the call to
   * `triggerConfigs`.
   * @config {Boolean|String}
   * @default
   * @internal
   */
  lazy: false,
  /**
   * Indicates that this config property should automatically be set to `null` on destroy.
   * @config {Boolean}
   * @default
   * @internal
   */
  nullify: false,
  /**
   * Indicates that this config participates in rendering. This has does not affect the behavior of the property
   * directly, but allows classes that perform rendering to detect which config changes will affect the rendered
   * result.
   * @config {Boolean}
   * @default
   * @internal
   */
  render: false
});
Config._$name = "Config";

// ../Core/lib/Core/Base.js
var MetaClass = class {
  constructor(options) {
    options && Object.assign(this, options);
  }
  getInherited(name, create = true) {
    var _a2;
    let ret = this[name];
    if (!(name in this)) {
      ret = (_a2 = this.super) == null ? void 0 : _a2.getInherited(name, create);
      if (ret || create) {
        this[name] = ret = Object.create(ret || null);
      }
    }
    return ret;
  }
};
var { getPrototypeOf } = Object;
var { hasOwn } = Objects;
var { defineProperty: defineProperty2 } = Reflect;
var metaSymbol = Symbol("classMetaData");
var mixinTagSymbol = Symbol("mixinTag");
var originalConfigSymbol = Symbol("originalConfig");
var createdAtSymbol = Symbol("createdAt");
var configuringSymbol2 = Config.symbols.configuring;
var instancePropertiesSymbol2 = Config.symbols.instanceProperties;
var lazyConfigsSymbol = Config.symbols.lazyConfigs;
var defaultConfigOptions = { merge: "replace", simple: true };
var emptyFn = () => {
};
var newMeta = (o) => new MetaClass(o);
var setupNames = {
  /* foo : 'setupFoo' */
};
var emptyObject2 = Object.freeze({});
var emptyArray = Object.freeze([]);
var Base = class _Base {
  static get isBase() {
    return true;
  }
  get isBase() {
    return true;
  }
  // defaultConfig & properties made private to not spam all other classes
  /**
   * A class property getter to add additional, special class properties.
   *
   * For example, a class adds a `declarable` class property like so:
   * ```
   *  class Something extends Base {
   *      static get declarable() {
   *          return ['extra'];
   *      }
   *
   *      static setupExtra(cls, meta) {
   *          // use cls.extra
   *      }
   *  }
   * ```
   * A derived class can then specify this property like so:
   * ```
   *  class Derived extends Something {
   *      static get extra() {
   *          // return extra information
   *      }
   *  }
   * ```
   * When the `Derived` class is initialized, the `setupExtra()` method is called and `Derived` is passed as the
   * argument. It is also the `this` pointer, but the parameter is minifiable. The second argument passed is the
   * `$meta` object for the class.
   *
   * Classes are initialized at the first occurrence of the following:
   *
   * - An instance is created
   * - The class `$meta` property is accessed
   *
   * @member {String[]} declarable
   * @static
   * @category Configuration
   * @internal
   */
  static get declarable() {
    return [
      "declarable",
      /**
       * A class property getter for the configuration properties of the class, which can be overridden by
       * configurations passed at construction time.
       *
       * Unlike a normal `static` property, this property is only ever used for the class that defines it (as in,
       * `hasOwnProperty`). It is retrieved for all classes in a class hierarchy, to gather their configs
       * individually and then combine them with those of derived classes.
       *
       * For example, a `Label` might declare a `text` config like so:
       * ```javascript
       *  class Label extends Base {
       *      static get configurable() {
       *          return {
       *              text : null
       *          };
       *      }
       *  }
       * ```
       * The `text` config is automatically inherited by classes derived from Label. By implementing
       * `get configurable()`, derived classes can change the default value of inherited configs, or define new
       * configs, or both.
       *
       * When a config property is declared in this way, the class author can also implement either of two
       * special methods that will be called when the config property is assigned a new value:
       *
       *  - `changeText()`
       *  - `updateText()`
       *
       * In the example above, the `Label` class could implement a `changeText()` method, an `updateText()`
       * method, or both. The generated property setter ensures these methods will be called when the `text`
       * property is assigned.
       *
       * The generated setter (for `text` in this example) performs the following steps:
       *
       *  - If the class defines a `changeText()` method, call it passing the new value and the current value:
       *    `changeText(newText, oldText)`.<br>
       *    Then:
       *    * If `changeText()` exits without returning a value (i.e., `undefined`), exit and do nothing
       *      further. The assumption is that the changer method has done all that is required.
       *    * Otherwise, the return value of `changeText()` replaces the incoming value passed to the setter.
       *  - If the new value (or the value returned by `changeText()`) is `!==` to the current value:
       *    * Update the stored config value in `this._text`.
       *    * If the class defines an `updateText()` method, call it passing the new value and the previous value.
       *      `updateText(newText, oldText)`
       *
       * #### Resolving a value from an owner
       * By specifying a value starting with `'up.'` for a config, the config system will resolve that value by
       * examining the ownership hierarchy. It will walk up the hierarchy looking for a property matching the name
       * (or dot separated path) after 'up.'. If one is found, the value will be read and used as the initial
       * value.
       *
       * ```javascript
       * class Parent extends Base {
       *     static get configurable() {
       *         return [
       *           'importantValue'
       *         ]
       *     }
       * }
       *
       * class Child extends Base {
       *     static get configurable() {
       *         return [
       *           'value'
       *         ]
       *     }
       * }
       *
       * const parent = new Parent({
       *     importantValue : 123
       * });
       *
       * const child = new Child({
       *     owner : parent,
       *     // Will be resolved from the owner
       *     value : 'up.importantValue'
       * });
       *
       * console.log(child.value); // logs 123
       * ```
       * Please note that this is for now a one way one time binding, the value will only be read initially and
       * not kept up to date on later changes.
       *
       * #### Value Merging
       * When a config property value is an object, the value declared by the base class is merged with values
       * declared by derived classes and the value passed to the constructor.
       * ```javascript
       *  class Example extends Base {
       *      static get configurable() {
       *          return {
       *              config : {
       *                  foo : 1,
       *                  bar : 2
       *              }
       *          };
       *      }
       *  }
       *
       *  class Example2 extends Example {
       *      static get configurable() {
       *          return {
       *              config : {
       *                  bar : 42,
       *                  zip : 'abc'
       *              }
       *          };
       *      }
       *  }
       *
       *  let ex = new Example2({
       *      config : {
       *          zip : 'xyz'
       *      }
       *  });
       * ```
       * The result of the merge would set `config` to:
       * ```javascript
       *  ex.foo = {
       *      foo : 1,    // from Example
       *      bar : 42,   // from Example2
       *      zip : 'xyz' // from constructor
       *  }
       * ```
       *
       * #### Config Options
       * Some config properties require additional options such as declarative information about the config that
       * may be useful to automate some operation. Consider a `Button`. It could declare that its `text` config
       * affects the rendered HTML by applying a `render` property to the config definition. Its base class could
       * then examine the config definition to find this property.
       *
       * To support this, config options ca be declared like so:
       * ```javascript
       *  class Button extends Widget {
       *      static get configurable() {
       *          return {
       *              text : {
       *                  value   : null,
       *                  $config : {
       *                      render : true
       *                  }
       *              }
       *          };
       *      }
       *  }
       * ```
       * The `$config` property can alternatively be just the names of the options that should be enabled (set
       * to `true`).
       *
       * For example, the following is equivalent to the above:
       * ```javascript
       *  class Button extends Widget {
       *      static get configurable() {
       *          return {
       *              text : {
       *                  value   : null,
       *                  $config : 'render'
       *              }
       *          };
       *  }
       * ```
       *
       * #### Default Value
       * It is common to set a config to a `null` value to take advantage of internal optimizations for `null`
       * values. In most cases the fact that this produces `undefined` as the actual initial value of the config
       * is acceptable. When this is not acceptable, a config can be declared like so:
       * ```javascript
       *  class Widget {
       *      static get configurable() {
       *          return {
       *              disabled : {
       *                  $config : null,
       *                  value   : null,
       *                  default : false
       *              }
       *          };
       *  }
       * ```
       * The `default` property above determines the value of the config while still gaining the benefits of
       * minimal processing due to the `null` value of the `value` property.
       * @member {Object} configurable
       * @static
       * @category Configuration
       * @internal
       */
      "configurable",
      /**
       * A class property getter for the default configuration of the class, which can be overridden by
       * configurations passed at construction time.
       *
       * Unlike a normal `static` property, this property is only ever used for the class that defines it (as in,
       * `hasOwnProperty`). It is retrieved for all classes in a class hierarchy, to gather their configs
       * individually and then combine them with those of derived classes.
       *
       * For example, a `Store` might declare its `url` config like so:
       * ```
       *  class Store extends Base {
       *      static get defaultConfig() {
       *          return {
       *              url : null
       *          };
       *      }
       *  }
       * ```
       * The `url` config is automatically inherited by classes derived from Store. By implementing
       * `get defaultConfig()`, derived classes can change the default value of inherited configs, or define new
       * configs, or both. When defining new configs, however, `configurable` is preferred.
       *
       * Config properties introduced to a class by this declaration do not participate in value merging and do
       * not get a generated setter. Config properties introduced by a base class using `configurable` can be
       * set to a different value using `defaultConfig` and in doing so, the values will be merged as appropriate
       * for `configurable`.
       *
       * @member {Object} defaultConfig
       * @static
       * @category Configuration
       * @internal
       */
      "defaultConfig",
      /**
       * A class property getter for the default values of internal properties for this class.
       * @member {Object} properties
       * @static
       * @category Configuration
       * @internal
       */
      "properties",
      /**
       * A class property getter for properties that will be applied to the class prototype.
       * @member {Object} prototypeProperties
       * @static
       * @category Configuration
       * @internal
       */
      "prototypeProperties"
    ];
  }
  /**
   * Base constructor, passes arguments to {@link #function-construct}.
   * @param {...Object} [args] Usually called with a config object, but accepts any params
   * @function constructor
   * @category Lifecycle
   * @advanced
   */
  constructor(...args) {
    const me = this, C = me.constructor;
    if (me.$meta.class !== C) {
      emptyFn(C.$meta);
    }
    me.construct(...args);
    me.afterConstruct();
    me.isConstructing = false;
  }
  /**
   * Factory version of the Base constructor. Merges all arguments to create a config object that is passed along to
   * the constructor.
   * @param {...Object} [configs] Allows passing multiple config objects
   * @returns {Core.Base} New instance
   * @private
   */
  static new(...configs) {
    configs = configs.filter((c) => c);
    return new this(configs.length > 1 ? this.mergeConfigs(...configs) : configs[0]);
  }
  /**
   * Base implementation applies configuration.
   *
   * Subclasses need only implement this if they have to initialize instance specific
   * properties required by the class. Often a `construct` method is
   * unnecessary. All initialization of incoming configuration properties can be
   * done in a `set propName` implementation.
   * @param {...Object} [args] Usually called with a config object, but accepts any params
   * @category Lifecycle
   * @advanced
   */
  construct(...args) {
    if (args[0] !== null) {
      this.configure(...args);
    }
    this.afterConfigure();
  }
  /**
   * Destroys the provided objects by calling their {@link #function-destroy} method.
   * Skips empty values or objects that are already destroyed.
   *
   * ```javascript
   * Base.destroy(myButton, toolbar1, helloWorldMessageBox);
   * ```
   * @param {...Object} [args] Objects to be destroyed
   * @category Lifecycle
   * @advanced
   */
  static destroy(...args) {
    const shredder = (object) => {
      if (object == null ? void 0 : object.destroy) {
        object.destroy();
      } else if (Array.isArray(object)) {
        object.forEach(shredder);
      }
    };
    shredder(args);
  }
  /**
   * Destroys this object.
   *
   * {@advanced}
   * This is primarily accomplished by calling {@link #function-doDestroy}, however, prior to
   * calling `doDestroy`, {@link #property-isDestroying} is set to `true`. After {@link #function-doDestroy} returns,
   * {@link #property-isDestroyed} is set to `true`.
   *
   * Do not override this method in subclasses. To provide class-specific cleanup, implement {@link #function-doDestroy}
   * instead.
   * {/@advanced}
   *
   * @category Lifecycle
   */
  destroy() {
    const me = this, { id } = me;
    me.isDestroying = true;
    me.destroy = emptyFn;
    me.doDestroy();
    Object.setPrototypeOf(me, null);
    for (const key in me) {
      if (key !== "destroy" && key !== "isDestroying") {
        delete me[key];
      }
    }
    delete me[originalConfigSymbol];
    me.isDestroyed = true;
    me.id = id;
  }
  /**
   * This method is required to help `unused` getters to survive production build process. Some tools, like angular,
   * will remove `unused` code in production build, making our side-effected getters behind, breaking code heavily.
   * @internal
   * @param getter Getter to evaluate
   */
  _thisIsAUsedExpression(getter) {
  }
  static get $$name() {
    return hasOwn(this, "$name") && this.$name || // _$name is filled by webpack for every class (cls._$name = '...')
    hasOwn(this, "_$name") && this._$name || this.name;
  }
  get $$name() {
    return this.constructor.$$name;
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call super.startConfigure.
   *
   * This is called by the Base class before setting configuration properties, but after
   * the active initial getters have been set, so all configurations are available.
   *
   * This method allows all classes in the hierarchy to force some configs to be evaluated before others.
   * @internal
   * @category Lifecycle
   * @params {Object} config The configuration object use to set the initial state.
   */
  startConfigure(config) {
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call super.finishConfigure.
   *
   * This is called by the Base class before exiting the {@link #function-configure} method.
   *
   * At this point, all configs have been applied, but the `isConfiguring` property is still set.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * into the config phase.
   * @internal
   * @category Lifecycle
   * @params {Object} config The configuration object use to set the initial state.
   */
  finishConfigure(config) {
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call `super.afterConfigure`. This is called by the Base class after the {@link #function-configure} method has been
   * called. At this point, all configs have been applied.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * either before or after the super.afterConstruct();
   * @internal
   * @category Lifecycle
   */
  afterConfigure() {
  }
  /**
   * Base implementation so that all subclasses and mixins may safely call super.afterConstruct.
   *
   * This is called by the Base class after the {@link #function-construct} method has been
   * called.
   *
   * At this point, all configs have been applied.
   *
   * This method allows all classes in the hierarchy to inject functionality
   * either before or after the super.afterConstruct();
   * @internal
   * @function afterConstructor
   * @category Lifecycle
   */
  afterConstruct() {
  }
  /**
   * Provides a way of calling callbacks which may have been specified as the _name_ of a function
   * and optionally adds scope resolution.
   *
   * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`
   * then the function is resolved in this object. This is useful when configuring listeners
   * at the class level.
   *
   * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried
   * using the `owner` property until an object with the named function is present, then the
   * named function is called upon that object.
   *
   * If a named function is not found, an error is thrown. If the function should be only called when present,
   * and may not be present, add a `?` as a suffix.
   *
   * @param {String|Function} fn The function to call, or the name of the function to call.
   * @param {Object} thisObject The `this` object of the function.
   * @param {Object[]} args The argument list to pass.
   * @category Misc
   * @advanced
   */
  callback(fn2, thisObject, args = emptyArray) {
    const { handler, thisObj } = this.resolveCallback(fn2, thisObject === "this" ? this : thisObject) || emptyObject2;
    return handler == null ? void 0 : handler.apply(thisObj, args);
  }
  resolveProperty(propertyPath) {
    let thisObj = this;
    while (thisObj) {
      if (Objects.hasPath(thisObj, propertyPath)) {
        return Objects.getPath(thisObj, propertyPath);
      }
      thisObj = thisObj.owner;
    }
    return void 0;
  }
  /**
   * Provides a way of locating callbacks which may have been specified as the _name_ of a function
   * and optionally adds scope resolution.
   *
   * For example, if the callback is specified as a string, then if it is prefixed with `'this.'`
   * then the function is resolved in this object. This is useful when configuring listeners
   * at the class level.
   *
   * If the callback name is prefixed with `'up.'` then the ownership hierarchy is queried
   * using the `owner` property until an object with the named function is present, then the
   * named function is called upon that object.
   * @param {String|Function} handler The function to call, or the name of the function to call.
   * @param {Object} thisObj The `this` object of the function.
   * @param {Boolean} [enforceCallability = true] Pass `false` if the function may not exist, and a null return value is acceptable.
   * @returns {Object} `{ handler, thisObj }`
   * @category Misc
   * @advanced
   */
  resolveCallback(handler, thisObj = this, enforceCallability = true) {
    if (handler == null ? void 0 : handler.substring) {
      if (handler.endsWith("?")) {
        enforceCallability = false;
        handler = handler.substring(0, handler.length - 1);
      }
      if (handler.startsWith("up.")) {
        handler = handler.substring(3);
        for (thisObj = this.owner; thisObj && !thisObj[handler]; thisObj = thisObj.owner)
          ;
        if (!thisObj) {
          return;
        }
      } else if (handler.startsWith("this.")) {
        handler = handler.substring(5);
        thisObj = this;
      }
      if (!thisObj || !(thisObj instanceof Object)) {
        return;
      }
      handler = thisObj[handler];
    }
    if (typeof handler === "function") {
      return { handler, thisObj };
    }
    if (enforceCallability) {
      throw new Error(`No method named ${handler} on ${thisObj.$$name || "thisObj object"}`);
    }
  }
  bindCallback(inHandler, inThisObj = this) {
    if (inHandler) {
      const { handler, thisObj } = this.resolveCallback(inHandler, inThisObj);
      if (handler) {
        return handler.bind(thisObj);
      }
    }
  }
  /**
   * Delays the execution of the passed function by the passed time quantum, or if the time is omitted
   * or not a number, delays until the next animation frame. Note that this will use
   * {@link Core.mixin.Delayable#function-setTimeout} || {@link Core.mixin.Delayable#function-requestAnimationFrame}
   * if this class mixes in `Delayable`, otherwise it uses the global methods. The function will
   * be called using `this` object as its execution scope.
   * @param {Function} fn The function to call on a delay.
   * @param {Number} [delay] The number of milliseconds to delay.
   * @param {String} [name] The name of delay
   * @returns {Number} The created timeout id.
   * @private
   */
  delay(fn2, delay2, name = fn2.name || fn2) {
    fn2 = this.setTimeout ? fn2 : fn2.bind(this);
    const invoker = this.setTimeout ? this : globalThis;
    return invoker[typeof delay2 === "number" ? "setTimeout" : "requestAnimationFrame"](fn2, delay2, name);
  }
  /**
   * Classes implement this method to provide custom cleanup logic before calling `super.doDestroy()`. The general
   * pattern is as follows:
   *
   * ```javascript
   *  class Foo extends Base {
   *      doDestroy() {
   *          // perform custom cleanup
   *
   *          super.doDestroy();
   *      }
   *  }
   * ```
   *
   * This method is called by {@link #function-destroy} which also prevents multiple calls from reaching `doDestroy`.
   * Prior to calling `doDestroy`, {@link #property-isDestroying} is set to `true`. Upon return, the object is fully
   * destructed and {@link #property-isDestroyed} is set to `true`.
   *
   * Do not call this method directly. Instead call {@link #function-destroy}.
   * @category Lifecycle
   * @advanced
   */
  doDestroy() {
    const me = this, { nullify } = me.$meta;
    if (nullify) {
      for (let i = 0; i < nullify.length; ++i) {
        if (me[nullify[i].field] != null) {
          me[nullify[i].name] = null;
        }
      }
    }
  }
  /**
   * Destroys the named properties if they have been initialized, and if they have a `destroy` method.
   * Deletes the property from this object. For example:
   *
   *      this.destroyProperties('store', 'resourceStore', 'eventStore', 'dependencyStore', 'assignmentStore');
   *
   * @param {String} properties The names of the properties to destroy.
   * @internal
   * @category Lifecycle
   */
  destroyProperties(...properties) {
    var _a2, _b;
    const me = this;
    let key;
    for (key of properties) {
      if (key in me && (!me[configuringSymbol2] || !me[configuringSymbol2][key])) {
        (_b = (_a2 = me[key]) == null ? void 0 : _a2.destroy) == null ? void 0 : _b.call(_a2);
        delete me[key];
      }
    }
  }
  /**
   * Called by the Base constructor to apply configs to this instance. This must not be called.
   * @param {Object} config The configuration object from which instance properties are initialized.
   * @private
   * @category Lifecycle
   */
  configure(config = {}) {
    const me = this, meta = me.$meta, { beforeConfigure } = config, configs = meta.configs, fullConfig = me.getDefaultConfiguration();
    let cfg, key, value;
    me.initialConfig = config;
    me.isConfiguring = true;
    Object.assign(me, me.getProperties());
    for (key in config) {
      value = config[key];
      cfg = configs[key];
      fullConfig[key] = cfg ? cfg.merge(value, fullConfig[key], null, meta) : value;
    }
    if (beforeConfigure) {
      delete fullConfig.beforeConfigure;
      beforeConfigure(me, fullConfig);
    }
    me.setConfig(me[originalConfigSymbol] = fullConfig, true);
    me.isConfiguring = false;
  }
  /**
   * Returns the value of the specified config property. This is a method to allow
   * property getters to be explicitly called in a way that does not get optimized out.
   *
   * The following triggers the getter call, but optimizers will remove it:
   *
   *      inst.foo;   // also raises "expression has no side-effects" warning
   *
   * Instead, do the following to trigger a getter:
   *
   *      inst.getConfig('foo');
   *
   * @param {String} name
   * @internal
   * @category Configuration
   */
  getConfig(name) {
    return this[name];
  }
  /**
   * Sets configuration options this object with all the properties passed in the parameter object.
   * Timing is taken care of. If the setter of one config is called first, and references
   * the value of another config which has not yet been set, that config will be set just
   * in time, and the *new* value will be used.
   * @param {Object} config An object containing configurations to change.
   * @category Lifecycle
   * @advanced
   */
  setConfig(config, isConstructing) {
    var _a2;
    const me = this, wasConfiguring = me[configuringSymbol2], configDone = wasConfiguring ? me.configDone : me.configDone = {}, configs = me.$meta.configs, pendingLazy = me[lazyConfigsSymbol];
    let cfg, key;
    me[instancePropertiesSymbol2] = {};
    me[configuringSymbol2] = wasConfiguring ? Object.setPrototypeOf(Object.assign({}, config), wasConfiguring) : config;
    for (key in config) {
      if (config[key] != null || hasOwn(config, key)) {
        cfg = configs[key] || Config.get(key);
        if (!(pendingLazy == null ? void 0 : pendingLazy.has(key))) {
          cfg.defineInitter(me, config[key]);
        }
        if (!isConstructing) {
          configDone[key] = false;
        }
      } else {
        configDone[key] = true;
      }
    }
    if (isConstructing) {
      me.startConfigure(config);
    }
    for (key in config) {
      if (!configDone[key] && !(isConstructing && ((_a2 = configs[key]) == null ? void 0 : _a2.lazy))) {
        me[key] = config[key];
      }
    }
    if (wasConfiguring) {
      me[configuringSymbol2] = wasConfiguring;
    } else {
      delete me[configuringSymbol2];
    }
    if (isConstructing) {
      me.finishConfigure(config);
    }
    return me;
  }
  /**
   * Returns `true` if this instance has a non-null value for the specified config. This will not activate a lazy
   * config.
   *
   * @param {String} name The name of the config property.
   * @returns {Boolean}
   * @internal
   */
  hasConfig(name) {
    var _a2;
    const me = this, config = me[configuringSymbol2];
    return Boolean(
      me["_" + name] != null || // value has been assigned to backing property
      ((_a2 = me[lazyConfigsSymbol]) == null ? void 0 : _a2.get(name)) != null || // a lazy value is pending
      // config value has not been assigned but will be
      !me.configDone[name] && config && (config[name] != null || hasOwn(config, name))
    );
  }
  /**
   * Returns the value of an uningested config *without* ingesting the config or transforming
   * it from its raw value using its `changeXxxxx` method.
   *
   * @param {String} name The name of the config property.
   * @returns {*} The raw incoming config value.
   * @internal
   */
  peekConfig(name) {
    const me = this, lazyConfig = me[lazyConfigsSymbol], config = me[configuringSymbol2];
    if (lazyConfig == null ? void 0 : lazyConfig.has(name)) {
      return lazyConfig.get(name);
    }
    if (config && name in config) {
      if (me.configDone[name]) {
        return me[name];
      }
      if (config[name] != null || hasOwn(config, name)) {
        return config[name];
      }
    }
  }
  /**
   * Ensures that the specified config is initialized if it is needed. If there is a config value specified, and it
   * was initialized by this call, this method returns `true`. If there was a config value specified, and it was
   * already initialized, this method returns `false`. If there was no value specified for the given config, this
   * method returns `null`.
   *
   * This is not the same as just reading the property, because some property getters exist that do not actually just
   * read the config value back, but instead produce some result. Reading such properties to incidentally trigger a
   * possible config initializer can lead to incorrect results. For example, the Combo items config.
   *
   * @param {String} name The name of the config property.
   * @returns {Boolean}
   * @internal
   */
  triggerConfig(name) {
    const me = this, { configDone } = me, lazyConfig = me[lazyConfigsSymbol], config = me[configuringSymbol2], triggered = (lazyConfig == null ? void 0 : lazyConfig.has(name)) || config && (config[name] != null || hasOwn(config, name)) ? !configDone[name] : null;
    if (triggered) {
      me.getConfig(name);
    }
    return triggered;
  }
  /**
   * This call will activate any pending {@link Core.Config#config-lazy} configs that were assigned a string value
   * equal to the `group` parameter.
   *
   * @param {String} group The config property group as defined by a matching {@link Core.Config#config-lazy} value.
   * @returns {String[]} The names of any configs triggered by this call or `null` if no configs were triggered.
   * @internal
   */
  triggerConfigs(group) {
    const me = this, configs = me.$meta.configs, lazyConfigs = me[lazyConfigsSymbol], triggered = lazyConfigs ? [...lazyConfigs.keys()].filter((k) => configs[k].lazy === group) : emptyArray;
    for (const key of triggered) {
      me.triggerConfig(key);
    }
    return triggered.length ? triggered : null;
  }
  onConfigChange() {
  }
  // declared above because lint/IDE get angry about not declaring the args...
  /**
   * This method is called when any config changes.
   * @param {Object} info Object containing information regarding the config change.
   * @param {String} info.name The name of the config that changed.
   * @param {*} info.value The new value of the config.
   * @param {*} info.was The previous value of the config.
   * @param {Core.Config} info.config The `Config` object for the changed config property.
   * @method onConfigChange
   * @internal
   * @category Configuration
   */
  /**
   * Returns a *copy* of the full configuration which was used to configure this object.
   * @property {Object}
   * @category Lifecycle
   * @readonly
   * @advanced
   */
  get config() {
    const result = {}, myConfig = this[originalConfigSymbol];
    for (const key in myConfig) {
      result[key] = myConfig[key];
    }
    return result;
  }
  // region Extract config
  static processConfigValue(currentValue, options) {
    if (currentValue === globalThis) {
      return globalThis;
    } else if (Array.isArray(currentValue)) {
      return currentValue.map((v) => _Base.processConfigValue(v, options));
    } else if (currentValue instanceof _Base) {
      if (options.visited.has(currentValue)) {
        return;
      }
      return currentValue.getCurrentConfig(options);
    } else if (currentValue instanceof HTMLElement || currentValue instanceof DocumentFragment) {
      return null;
    } else if (Objects.isObject(currentValue)) {
      const result = {};
      for (const key in currentValue) {
        if (key !== "owner") {
          result[key] = _Base.processConfigValue(currentValue[key], options);
        }
      }
      return result;
    }
    return currentValue;
  }
  // Recursively get the value of a config. Only intended to be called by getCurrentConfig()
  getConfigValue(name, options) {
    var _a2;
    const me = this, lazyConfigs = me[lazyConfigsSymbol];
    if (!((_a2 = me.$meta.configs[name]) == null ? void 0 : _a2.lazy)) {
      return _Base.processConfigValue(me[name], options);
    }
    if (lazyConfigs == null ? void 0 : lazyConfigs.has(name)) {
      return _Base.processConfigValue(lazyConfigs.get(name), options);
    }
  }
  // Allows removing / adding configs before values are extracted
  preProcessCurrentConfigs() {
  }
  // Extract the current values for all initially used configs, in a format that can be used to create a new instance.
  // Not intended to be called by any other code than getConfigString()
  getCurrentConfig(options = {}) {
    const me = this, configs = options.configs === "all" ? me.config : Objects.clone(me.initialConfig), visited = options.visited || (options.visited = /* @__PURE__ */ new Set()), depth = options.depth || (options.depth = 0), result = {};
    if (visited.has(me)) {
      return void 0;
    }
    visited.add(me);
    this.preProcessCurrentConfigs(configs);
    for (const name in configs) {
      const value = me.getConfigValue(name, { ...options, depth: depth + 1 });
      if (value !== void 0) {
        result[name] = value;
      }
    }
    return result;
  }
  // Extract the current values for all initially used configs and convert them to a JavaScript string
  getConfigString(options = {}) {
    return StringHelper.toJavaScriptString(this.getCurrentConfig(options));
  }
  // Experimental helper function, extracts the currently used configs and wraps them as an app, returning code as a
  // string.
  //
  // This function is intended to simplify creating test cases for issue reporting on Bryntum's support forum.
  //
  getTestCase(options = {}) {
    const Product = this.isGantt ? "Gantt" : this.isSchedulerPro ? "SchedulerPro" : this.isCalendar ? "Calendar" : this.isScheduler ? "Scheduler" : this.isGrid ? "Grid" : this.isTaskBoard ? "TaskBoard" : null;
    if (Product) {
      const product = Product.toLowerCase(), bundlePath = `../../build/${product}.module.js`;
      let preamble, postamble;
      if (options.import === "static") {
        preamble = `import * as module from "${bundlePath}";Object.assign(window, module);`;
        postamble = "";
      } else {
        preamble = `import("${bundlePath}").then(module => { Object.assign(window, module);
`;
        postamble = "});";
      }
      const version = VersionHelper.getVersion(product);
      if (version) {
        preamble += `
console.log('${Product} ${version}');
`;
      }
      return `${preamble}      
const ${product} = new ${Product}(${this.getConfigString(options)});
${postamble}`;
    }
  }
  /**
   * Experimental helper function, extracts the currently used configs and wraps them as an app, downloading the
   * resulting JS file.
   *
   * This function is intended to simplify creating test cases for issue reporting on Bryntum's support forum.
   * @category Misc
   */
  downloadTestCase(options = {}) {
    options.output = "return";
    const app = this.getTestCase(options);
    BrowserHelper.download(`app.js`, "data:application/javascript;charset=utf-8," + escape(app));
  }
  //endregion
  /**
   * Registers this class type with its Factory
   * @category Misc
   * @advanced
   */
  static initClass() {
    return this.$meta.class;
  }
  /**
   * The class's {@link #property-$meta-static meta} object.
   * @member {Object} $meta
   * @internal
   * @category Misc
   */
  /**
   * An object owned by this class that does not share properties with its super class.
   *
   * This object may contain other properties which are added as needed and are not documented here.
   *
   * @property {Object} $meta The class meta object.
   * @property {Function} $meta.class The class constructor that owns the meta object.
   * @property {Object} $meta.super The `$meta` object for the super class. This is `null` for `Base`.
   * @property {Object} $meta.config The object holding the default configuration values for this class.
   * @property {Object} $meta.configs An object keyed by config name that holds the defined configs for the class.
   * The value of each property is a {@link Core/Config} instance.
   * @property {Boolean} $meta.forkConfigs This will be `true` if the default configuration values for this class
   * (in the `config` property of the meta object) must be forked to avoid object sharing, or if the object can be
   * passed to `Object.create()` for efficiency.
   * @property {Function[]} $meta.hierarchy The array of classes in the ancestry of this class. This will start with
   * `Base` at index 0 and ends with this class.
   * @property {Function[]} $meta.properties The array of classes that define a "static get properties()" getter.
   * @internal
   * @static
   * @category Misc
   */
  static get $meta() {
    const me = this;
    let meta = me[metaSymbol];
    if (!hasOwn(me, metaSymbol)) {
      me[metaSymbol] = meta = newMeta();
      meta.class = me;
      me.setupClass(meta);
    }
    return meta;
  }
  /**
   * This optional class method is called when a class is mixed in using the {@link #function-mixin-static mixin()}
   * method.
   * @internal
   */
  static onClassMixedIn() {
  }
  /**
   * Returns the merge of the `baseConfig` and `config` config objects based on the configs defined by this class.
   * @param {Object} baseConfig The base config or defaults.
   * @param {...Object} configs One or more config objects that takes priority over `baseConfig`.
   * @returns {Object}
   * @internal
   */
  static mergeConfigs(baseConfig, ...configs) {
    const classConfigs = this.$meta.configs, result = Objects.clone(baseConfig) || {};
    let config, i, key, value;
    for (i = 0; i < configs.length; ++i) {
      config = configs[i];
      if (config) {
        for (key in config) {
          value = config[key];
          if (classConfigs[key]) {
            value = classConfigs[key].merge(value, result[key]);
          } else if (result[key] && value) {
            value = Config.merge(value, result[key]);
          }
          result[key] = value;
        }
      }
    }
    return result;
  }
  /**
   * Applies one or more `mixins` to this class and returns the produced class constructor.
   *
   * For example, instead of writing this:
   * ```
   *  class A extends Delayable(Events(Localizable(Base))) {
   *      // ...
   *  }
   * ```
   *
   * Using this method, one would write this:
   * ```
   *  class A extends Base.mixin(Localizable, Events, Delayable) {
   *      // ...
   *  }
   * ```
   * If one of the mixins specified has already been mixed into the class, it will be ignored and not mixed in a
   * second time.
   * @param {...Function} mixins
   * @returns {Function}
   * @category Misc
   * @advanced
   */
  static mixin(...mixins) {
    let C = this, i;
    for (i = 0; i < mixins.length; ++i) {
      const mixin2 = mixins[i], tag = mixin2[mixinTagSymbol] || (mixin2[mixinTagSymbol] = Symbol("mixinTag"));
      if (C[tag]) {
        continue;
      }
      C = mixin2(C);
      C[tag] = true;
      if (hasOwn(C, "onClassMixedIn")) {
        C.onClassMixedIn();
      }
    }
    return C;
  }
  /**
   * This method is called only once for any class. This can occur when the first instance is created or when the
   * `$meta` object is first requested.
   * @param {Object} meta The `$meta` object for the class.
   * @internal
   * @category Misc
   */
  static setupClass(meta) {
    var _a2;
    const cls = meta.class, base = getPrototypeOf(cls).$meta, name = cls.$$name, names = base.names, proto4 = cls.prototype;
    defineProperty2(proto4, "$meta", {
      value: meta
    });
    Object.assign(meta, {
      super: base,
      config: Object.create(base.config),
      configs: Object.create(base.configs),
      declarables: base.declarables,
      forkConfigs: base.forkConfigs,
      hierarchy: Object.freeze([...base.hierarchy, cls]),
      names: names.includes(name) ? names : Object.freeze([...names, name]),
      properties: base.properties,
      nullify: (_a2 = base.nullify) == null ? void 0 : _a2.slice()
    });
    if (names !== meta.names) {
      const isName = `is${name}`, defineIsProperty = (obj) => {
        if (!hasOwn(obj, isName)) {
          defineProperty2(obj, isName, {
            get() {
              return true;
            }
          });
        }
      };
      defineIsProperty(proto4);
      defineIsProperty(cls);
    }
    for (let decl, setupName, i = 0; i < meta.declarables.length; ++i) {
      decl = meta.declarables[i];
      if (hasOwn(cls, decl)) {
        setupName = setupNames[decl] || (setupNames[decl] = `setup${StringHelper.capitalize(decl)}`);
        cls[setupName](cls, meta);
      }
    }
  }
  /**
   * This method is called as part of `setupClass()`. It will process the `configurable()` return object and the
   * `defaultConfig` return object.
   * @param {Object} meta The `meta` object for this class.
   * @param {Object} configs The config definition object.
   * @param {Boolean} simple `true` when processing `defaultConfig` and `false` when processing `configurable`.
   * @private
   * @category Configuration
   */
  static setupConfigs(meta, configs, simple) {
    const classConfigValues = meta.config, classConfigs = meta.configs, cls = meta.class, superMeta = meta.super;
    let { nullify } = meta, cfg, defaultValue2, options, setDefault, value, wasNullify;
    for (const name in configs) {
      value = configs[name];
      if (simple) {
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, defaultConfigOptions);
        } else {
          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
      } else {
        defaultValue2 = options = setDefault = void 0;
        if (value && typeof value === "object" && "$config" in value) {
          options = value.$config;
          if (options && !Objects.isObject(options)) {
            options = Objects.createTruthyKeys(options);
          }
          setDefault = "default" in value;
          defaultValue2 = setDefault ? value.default : defaultValue2;
          value = value.value;
        }
        if (!(cfg = classConfigs[name])) {
          cfg = Config.get(name, options);
          cfg.define(cls.prototype);
          setDefault = !(cfg.field in cls.prototype);
          wasNullify = false;
        } else {
          wasNullify = cfg.nullify;
          if (options) {
            cfg = cfg.extend(options);
          }
          value = cfg.merge(value, classConfigValues[name], meta, superMeta);
        }
        if (setDefault) {
          cfg.setDefault(cls, defaultValue2);
        }
        if (cfg.nullify && !wasNullify) {
          (nullify || (nullify = meta.nullify || (meta.nullify = []))).push(cfg);
        }
      }
      if (value && (Objects.isObject(value) || Array.isArray(value)) && !Object.isFrozen(value)) {
        meta.forkConfigs = true;
      }
      classConfigs[name] = cfg;
      classConfigValues[name] = value;
    }
  }
  static setupConfigurable(cls, meta) {
    cls.setupConfigs(meta, cls.configurable, false);
  }
  static setupDefaultConfig(cls, meta) {
    cls.setupConfigs(meta, cls.defaultConfig, true);
  }
  static setupDeclarable(cls, meta) {
    const declarable = cls.declarable;
    let all = meta.declarables, forked, i;
    for (i = 0; i < declarable.length; ++i) {
      if (!all.includes(declarable[i])) {
        if (!forked) {
          meta.declarables = forked = all = all.slice();
        }
        all.push(declarable[i]);
      }
    }
  }
  static setupProperties(cls, meta) {
    meta.properties = meta.super.properties.slice();
    meta.properties.push(cls);
    Object.freeze(meta.properties);
  }
  static setupPrototypeProperties(cls) {
    Object.assign(cls.prototype, cls.prototypeProperties);
  }
  /**
   * Gets the full {@link #property-defaultConfig-static} block for this object's entire inheritance chain
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  getDefaultConfiguration() {
    return this.constructor.getDefaultConfiguration();
  }
  /**
   * Gets the full {@link #property-defaultConfig-static} block for the entire inheritance chain for this class
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  static getDefaultConfiguration() {
    const meta = this.$meta, config = meta.forkConfigs ? _Base.fork(meta.config) : Object.create(meta.config);
    if (VersionHelper.isTestEnv && BrowserHelper.isBrowserEnv && config.testConfig && globalThis.__applyTestConfigs) {
      for (const o in config.testConfig) {
        config[o] = config.testConfig[o];
      }
    }
    return config;
  }
  static fork(obj) {
    let ret = obj, key, value;
    if (obj && Objects.isObject(obj) && !Object.isFrozen(obj)) {
      ret = Object.create(obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (Objects.isObject(value)) {
            ret[key] = _Base.fork(value);
          } else if (Array.isArray(value)) {
            ret[key] = value.slice();
          }
        }
      }
    }
    return ret;
  }
  /**
   * Gets the full {@link #property-properties-static} block for this class's entire inheritance chain
   * all the way up to but not including {@link Core.Base}
   * @returns {Object} All default config values for this class.
   * @private
   * @category Configuration
   */
  getProperties() {
    const hierarchy = this.$meta.properties, result = {};
    for (let i = 0; i < hierarchy.length; i++) {
      Object.assign(result, hierarchy[i].properties);
    }
    return result;
  }
  static get superclass() {
    return getPrototypeOf(this);
  }
  /**
   * Used by the Widget and GridFeatureManager class internally. Returns the class hierarchy of this object
   * starting from the `topClass` class (which defaults to `Base`).
   *
   * For example `classHierarchy(Widget)` on a Combo would yield `[Widget, Field, TextField, PickerField, Combo]`
   * @param {Function} [topClass] The topmost class constructor to start from.
   * @returns {Function[]} The class hierarchy of this instance.
   * @private
   * @category Configuration
   */
  classHierarchy(topClass) {
    const hierarchy = this.$meta.hierarchy, index = topClass ? hierarchy.indexOf(topClass) : 0;
    return index > 0 ? hierarchy.slice(index) : hierarchy;
  }
  /**
   * Checks if an obj is of type using object's $$name property and doing string comparison of the property with the
   * type parameter.
   *
   * @param {String} type
   * @returns {Boolean}
   * @category Misc
   * @advanced
   */
  static isOfTypeName(type) {
    return this.$meta.names.includes(type);
  }
  /**
   * Removes all event listeners that were registered with the given `name`.
   * @param {String|Symbol} name The name of the event listeners to be removed.
   * @category Events
   * @advanced
   */
  detachListeners(name) {
    let detachers = this.$detachers;
    detachers = detachers == null ? void 0 : detachers[name];
    if (detachers) {
      while (detachers.length) {
        detachers.pop()();
      }
    }
  }
  /**
   * Tracks a detacher function for the specified listener name.
   * @param {String} name The name assigned to the associated listeners.
   * @param {Function} detacher The detacher function.
   * @private
   */
  trackDetacher(name, detacher2) {
    const detachers = this.$detachers || (this.$detachers = {}), bucket = detachers[name] || (detachers[name] = []);
    bucket.push(detacher2);
  }
  /**
   * Removes all detacher functions for the specified `Events` object. This is called
   * by the `removeAllListeners` method on that object which is typically called by its
   * `destroy` invocation.
   * @param {Core.mixin.Events} eventer The `Events` instance to untrack.
   * @private
   */
  untrackDetachers(eventer) {
    const detachers = this.$detachers;
    if (detachers) {
      for (const name in detachers) {
        const bucket = detachers[name];
        for (let i = bucket.length; i-- > 0; ) {
          if (bucket[i].eventer === eventer) {
            bucket.splice(i, 1);
          }
        }
      }
    }
  }
};
var proto = Base.prototype;
proto.onConfigChange.$nullFn = emptyFn.$nullFn = true;
Base[metaSymbol] = proto.$meta = newMeta({
  class: Base,
  config: Object.freeze({}),
  configs: /* @__PURE__ */ Object.create(null),
  declarables: Base.declarable,
  forkConfigs: false,
  hierarchy: Object.freeze([Base]),
  names: Object.freeze(["Base"]),
  nullify: null,
  properties: Object.freeze([]),
  super: null
});
Object.assign(proto, {
  $detachers: null,
  configObserver: null,
  /**
   * This property is set to `true` before the `constructor` returns.
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   * @advanced
   */
  isConstructing: true,
  /**
   * This property is set to `true` by {@link #function-destroy} after destruction.
   *
   * It is also one of the few properties that remains on the object after returning from `destroy()`. This property
   * is often checked in code paths that may encounter a destroyed object (like some event handlers) or in the
   * destruction path during cleanup.
   *
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   */
  isDestroyed: false,
  /**
   * This property is set to `true` on entry to the {@link #function-destroy} method. It remains on the objects after
   * returning from `destroy()`. If {@link #property-isDestroyed} is `true`, this property will also be `true`, so
   * there is no need to test for both (for example, `comp.isDestroying || comp.isDestroyed`).
   * @member {Boolean}
   * @readonly
   * @category Lifecycle
   * @advanced
   */
  isDestroying: false
});
Base.emptyFn = emptyFn;
VersionHelper.setVersion("core", "5.6.2");
Base._$name = "Base";

// ../Core/lib/Core/helper/ArrayHelper.js
var ArrayHelper = class _ArrayHelper {
  static clean(array) {
    return array.reduce((res, item) => {
      if (item !== null && item !== void 0 && !(Array.isArray(item) && item.length === 0) && item !== "")
        res.push(item);
      return res;
    }, []);
  }
  /**
   * Similar to [`Array.from()`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from)
   * this method creates an array from an `iterable` object. Where `Array.from()` accepts a mapper function as the
   * second argument, this method accepts a `filter` function as its second argument. If a mapper function is also
   * needed, it can be passed as the third argument. Unlike `Array.from()`, if this method is passed `null`, it will
   * return an empty array.
   * @param {Array} iterable The iterable object to convert (must support `for-of` loop iteration).
   * @param {Function} [filter] A function to apply to each item of the `iterable` which must return a truthy value
   * to include that item in the resulting array.
   * @param {Function} [map] A function to apply to each item of the `iterable` that returns the actual value to put
   * into the returned array. If a `filter` is also supplied, this method is only called for those items that pass
   * the filter test.
   * @returns {Array}
   */
  static from(iterable, filter2, map2) {
    const array = [];
    if (iterable) {
      for (const it of iterable) {
        if (!filter2 || filter2(it)) {
          array.push(map2 ? map2(it) : it);
        }
      }
    }
    return array;
  }
  /**
   * Remove one or more items from an array
   * @param {Array} array Array to remove from
   * @param {Object[]|Set} items One or more items to remove, or one Set containing items to remove
   * @returns {Boolean} Returns true if any item was removed
   */
  static remove(array, ...items2) {
    let index, item, removed = false;
    items2 = items2[0] instanceof Set ? [...items2[0]] : items2;
    for (let i = 0; i < items2.length; i++) {
      item = items2[i];
      if ((index = array.indexOf(item)) !== -1) {
        array.splice(index, 1);
        removed = true;
      }
    }
    return removed;
  }
  /**
   * Calculates the insertion index of a passed object into the passed Array according
   * to the passed comparator function. Note that the passed Array *MUST* already be ordered.
   * @param {Object} item The item to calculate the insertion index for.
   * @param {Array} array The array into which the item is to be inserted.
   * @param {Function} comparatorFn The comparison function. Must return -1 or 0 or 1.
   * @param {Object} comparatorFn.lhs The left object to compare.
   * @param {Object} comparatorFn.rhs The right object to compare.
   * @param {Number} index The possible correct index to try first before a binary
   * search is instigated.
   * @internal
   */
  static findInsertionIndex(item, array, comparatorFn = this.lexicalCompare, index) {
    const len = array.length;
    let beforeCheck, afterCheck;
    if (index < len) {
      beforeCheck = index > 0 ? comparatorFn(array[index - 1], item) : 0;
      afterCheck = index < len - 1 ? comparatorFn(item, array[index]) : 0;
      if (beforeCheck < 1 && afterCheck < 1) {
        return index;
      }
    }
    return this.binarySearch(array, item, comparatorFn);
  }
  /**
   * Similar to the native `Array.find()` call, but this finds the *last* element in the array for which
   * the passed function returns a truthy value.
   * @param {Object[]} array The array to find in.
   * @param {Function} fn The testing function.
   * @param {Object} [thisObj] The scope (`this` reference) in which to call the function.
   */
  static findLast(array, fn2, thisObj) {
    for (let { length } = array, i = length - 1; i >= 0; i--) {
      if (fn2.call(thisObj, array[i], i, array)) {
        return array[i];
      }
    }
  }
  /**
   * This method returns the index that a given item would be inserted into the
   * given (sorted) `array`. Note that the given `item` may or may not be in the
   * array. This method will return the index of where the item *should* be.
   *
   * For example:
   *
   *      var array = [ 'A', 'D', 'G', 'K', 'O', 'R', 'X' ];
   *      var index = ArrayHelper.binarySearch(array, 'E');
   *
   *      console.log('index: ' + index);
   *      // logs "index: 2"
   *
   *      array.splice(index, 0, 'E');
   *
   *      console.log('array : ' + array.join(''));
   *      // logs "array: ADEGKORX"
   *
   * @param {Object[]} array The array to search.
   * @param {Object} item The item that you want to insert into the `array`.
   * @param {Number} [begin=0] The first index in the `array` to consider.
   * @param {Number} [end=array.length] The index that marks the end of the range
   * to consider. The item at this index is *not* considered.
   * @param {Function} [compareFn] The comparison function that matches the sort
   * order of the `array`. The default `compareFn` compares items using less-than
   * and greater-than operators.
   * @returns {Number} The index for the given item in the given array based on
   * the passed `compareFn`.
   */
  static binarySearch(array, item, begin = 0, end = array.length, compareFn = this.lexicalCompare) {
    const length = array.length;
    let middle, comparison;
    if (begin instanceof Function) {
      compareFn = begin;
      begin = 0;
    } else if (end instanceof Function) {
      compareFn = end;
      end = length;
    }
    --end;
    while (begin <= end) {
      middle = begin + end >> 1;
      comparison = compareFn(item, array[middle]);
      if (comparison >= 0) {
        begin = middle + 1;
      } else if (comparison < 0) {
        end = middle - 1;
      }
    }
    return begin;
  }
  magnitudeCompare(lhs, rhs) {
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  lexicalCompare(lhs, rhs) {
    lhs = String(lhs);
    rhs = String(rhs);
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }
  /**
   * Similar to Array.prototype.fill(), but constructs a new array with the specified item count and fills it with
   * clones of the supplied item.
   * @param {Number} count Number of entries to create
   * @param {Object|Array} itemOrArray Item or array of items to clone (uses object spread to create shallow clone)
   * @param {Function} [fn] An optional function that is called for each item added, to allow processing
   * @returns {Array} A new populated array
   */
  static fill(count, itemOrArray = {}, fn2 = null) {
    const result = [], items2 = Array.isArray(itemOrArray) ? itemOrArray : [itemOrArray];
    for (let i = 0; i < count; i++) {
      for (const item of items2) {
        const processedItem = Object.assign({}, item);
        if (fn2) {
          fn2(processedItem, i);
        }
        result.push(processedItem);
      }
    }
    return result;
  }
  /**
   * Populates an array with the return value from `fn`.
   * @param {Number} count Number of entries to create
   * @param {Function} fn A function that is called `count` times, return value is added to array
   * @param {Number} fn.index Current index in the array
   * @privateparam {Boolean} [oneBased] Add 1 to the index before calling the fn (making it 1 based)
   * @returns {Array} A new populated array
   */
  static populate(count, fn2, oneBased = false) {
    const items2 = [];
    for (let i = 0; i < count; i++) {
      items2.push(fn2(i + (oneBased ? 1 : 0)));
    }
    return items2;
  }
  /**
   * Pushes `item` on to the `array` if not already included
   * @param {Array}  array Array to push to
   * @param {...Object} items Item(s) to push if not already included
   */
  static include(array, ...items2) {
    for (const item of items2) {
      if (!array.includes(item)) {
        array.push(item);
      }
    }
  }
  /**
   * Returns a new array with the unique items from the supplied array.
   * @param {Array} array Input array
   * @returns {Array} New array with unique items
   */
  static unique(array) {
    return [...new Set(array)];
  }
  // Kept for future reference : Wanted to create an indexer on Stores.
  static allowNegative(array) {
    return new Proxy(array, {
      get(target, name, receiver) {
        if (typeof name !== "string") {
          return Reflect.get(target, name, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.get(target, name, receiver);
        }
        return target[index < 0 ? target.length + index : index];
      },
      set(target, name, value, receiver) {
        if (typeof name !== "string") {
          return Reflect.set(target, name, value, receiver);
        }
        const index = Number(name);
        if (Number.isNaN(index)) {
          return Reflect.set(target, name, value, receiver);
        }
        target[index < 0 ? target.length + index : index] = value;
        return true;
      }
    });
  }
  static delta(a, b, useRelativeNaming = false) {
    if (!b) {
      return useRelativeNaming ? { toAdd: a, toRemove: [], toKeep: [] } : { onlyInA: a, onlyInB: [], inBoth: [] };
    }
    const onlyInA = [], onlyInB = [], inBoth = /* @__PURE__ */ new Set(), bSet = new Set(b);
    for (let i = 0; i < a.length; i++) {
      const item = a[i];
      if (bSet.has(item)) {
        inBoth.add(item);
      } else {
        onlyInA.push(item);
      }
    }
    for (let i = 0; i < b.length; i++) {
      const item = b[i];
      if (!inBoth.has(item)) {
        onlyInB.push(item);
      }
    }
    if (useRelativeNaming) {
      return { toAdd: onlyInA, toRemove: onlyInB, toKeep: inBoth };
    }
    return { onlyInA, onlyInB, inBoth: [...inBoth] };
  }
  /**
   * Returns the passed object wrapped in an array. Special handling of the following cases:
   * * Passing an array returns it as is
   * * Passing a `Set` returns it converted to an Array
   * * Passing `null`/`undefined` returns the passed value
   *
   * ```javascript
   * const records = ArrayHelper.asArray(record);
   *
   * // { id : 1 } -> [{ id : 1 }]
   * // [{ id : 1 }] -> [{ id : 1 }]
   * ```
   *
   * @param {*} arrayOrObject
   * @returns {Array|null}
   * @internal
   */
  static asArray(arrayOrObject) {
    if (arrayOrObject == null) {
      return arrayOrObject;
    }
    if (arrayOrObject instanceof Set) {
      return Array.from(arrayOrObject);
    }
    return Array.isArray(arrayOrObject) ? arrayOrObject : [arrayOrObject];
  }
  /**
   * Identity function that returns its input.
   * @param {*} Any value
   * @returns {*} The input value
   * @internal
   */
  static identity(x) {
    return x;
  }
  /**
   * Transform an array into a key:value dictionary using the specified
   * key and value getters. Does not group values, so only one result will
   * appear in the output for a given key.
   *
   * ```javascript
   * const input = [{
   *     id: '1',
   *     other: 'one'
   * },{
   *     id: '2',
   *     other: 'two'
   * }];
   *
   * keyBy(input, rec => rec.id)
   *
   * // {
   * //    '1': { id: '1', other: 'one' },
   * //    '2': { id: '2', other: 'two' }
   * // }
   * ```
   *
   * @param {Array} array Array from which to build dictionary
   * @param {Function|String} getKey Function to produce the key for a given array entry, or a string property name to read
   * @param {Function} getValue Optional function to transform array elements. Defaults to returning the element itself
   * @returns {Object} A key->value dictionary with keys as returned by `getKey` and values returned by `getValue`
   * @internal
   */
  static keyBy(array, keyGetter, valueGetter = _ArrayHelper.identity) {
    const getKey = typeof keyGetter === "string" ? (o) => o == null ? void 0 : o[keyGetter] : keyGetter, getValue = typeof valueGetter === "string" ? (o) => o == null ? void 0 : o[valueGetter] : valueGetter;
    return array.reduce((dict, next) => {
      dict[getKey(next)] = getValue(next);
      return dict;
    }, {});
  }
  /**
   * Combines provided arrays of by aggregating their element values.
   * For example the below code sums up numeric elements of the arrays:
   *
   * ```javascript
   * ArrayHelper.aggregate(
   *     [
   *         [0,   1,  2, 33]
   *         [10,  1, -1],
   *         [100, 1, -1]
   *     ],
   *     entry => entry || 0, // "|| 0" here to make it work for different array sizes
   *     (aggregated, entry) => aggregated + entry, // aggregate by summing up
   *     () => 0 //initial value is zero
   * );
   *
   * // returns [111, 3, 0, 33] array
   * ```
   *
   * @param {Array[]} arrays Array to combine
   * @param {Function} getEntryValueFn Function that extracts an array entry for aggregating.
   * @param {Function} aggregatorFn A function to execute for each element in the arrays. It's purpose is to
   * aggregate the element value to the corresponding entry of the resulting array.
   * The function's return value becomes the value of the `aggregated` parameter on the next invocation of
   * `aggregatorFn`.
   * The function is called with the following arguments:
   *
   * @param {Object} aggregatorFn.aggregated Resulting array entry value. On the first call
   * `getInitialValueFn` result.
   * @param {Object} aggregatorFn.entry Current entry to aggregate into `aggregated`.
   * @param {Number} aggregatorFn.arrayIndex Index of current array (in the provided `arrays`).
   * @param {Object[]} aggregatorFn.entryIndex Index of the current entry.
   * @param {Object} aggregationContext A shared object providing extra aggregation call context.
   * @param {Function} getInitialValueFn Function that returns an initial value for the combined array entries.
   * @param {Object} [aggregationContext] Optional object that is passed to all of the above functions that can
   * be used for keeping some additional parameters used when aggregating.
   * Out of the box the object will contain `arrays` and `targetArray` properties containing
   * input and resulting arrays respectively.
   */
  static aggregate(arrays, getEntryValueFn, aggregatorFn, getInitialValueFn, aggregationContext = {}) {
    const rowLength = arrays.length, columnLength = arrays[0].length, result = [];
    aggregationContext.targetArray = result;
    aggregationContext.arrays = arrays;
    for (let colIndex = 0; colIndex < columnLength; colIndex++) {
      aggregationContext.entryIndex = colIndex;
      result.push(getInitialValueFn(colIndex, aggregationContext));
    }
    for (let rowIndex = 0; rowIndex < rowLength; rowIndex++) {
      const row = arrays[rowIndex];
      aggregationContext.rowIndex = rowIndex;
      for (let colIndex = 0; colIndex < columnLength; colIndex++) {
        aggregationContext.entryIndex = colIndex;
        const entryValue = getEntryValueFn(row[colIndex], aggregationContext);
        result[colIndex] = aggregatorFn(result[colIndex], entryValue, rowIndex, colIndex, aggregationContext);
      }
    }
    return result;
  }
  /**
   * Group an array by keys (either the values in a specified property name, or the results of a string-generating function accepting
   * an array entry as input), returning an Object with those keys, whose values are arrays containing the array entries that
   * produced that key.
   *
   * ```javascript
   * const input = [{
   *     id: 1,
   *     color: 'red'
   * },{
   *     id: 2,
   *     color: 'green'
   * },{
   *     id: 3,
   *     color: 'green'
   * }];
   *
   * groupBy(input, 'color')
   *
   * // {
   * //    'red': [ { id: '1', color: 'red' } ],
   * //    'green': [ { id: '2', color: 'green' }, { id: '3', color: 'green' } ]
   * // }
   *
   * groupBy(input, rec => rec.color?.substr(0, 1))
   *
   * // {
   * //    'r': [ { id: '1', color: 'red' } ],
   * //    'g': [ { id: '2', color: 'green' }, { id: '3', color: 'green' } ]
   * // }
   * ```
   *
   * @param {Object} array Array from which to build dictionary
   * @param {Function|String} getGroupKey Function to produce the key for a given array entry, or a string property name to read
   * @returns {Object} A key->value[] dictionary with keys as returned by `getKey` and arrays of matching items in original order as values
   * @internal
   */
  static groupBy(array, groupKeyGetter) {
    const getKey = typeof groupKeyGetter === "string" ? (o) => o == null ? void 0 : o[groupKeyGetter] : groupKeyGetter;
    return array.reduce((grouped, value) => {
      const key = getKey(value);
      (grouped[key] = grouped[key] || []).push(value);
      return grouped;
    }, {});
  }
};
ArrayHelper._$name = "ArrayHelper";

// ../Core/lib/Core/helper/FunctionHelper.js
var commaSepRe = /,\s*/;
var decompiledSym = Symbol("decompiled");
var fnRe1 = /^\s*(async\s+)?([a-z_]\w*)\s*=>([\s\S]+)$/i;
var fnRe2 = /^\s*(async\s*)?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)\s+=>([\s\S]+)$/i;
var fnRe3 = /^(\s*async)?(?:\s*function)?(?:\s*([a-z_]\w*))?\s*\(((?:[a-z_]\w*(?:, [a-z_]\w*)*)?)\)([\s\S]+)$/i;
var { hasOwnProperty: hasOwnProperty4 } = Object.prototype;
var FunctionHelper = class _FunctionHelper {
  /**
   * Inserts a function after the specified `method` is called on an `object`. To remove this hook, invoke the
   * function returned by this method.
   * ```
   *  class A {
   *      method() {
   *          console.log('method');
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.after(instance, 'method', () => { console.log('after') });
   *
   *  instance.method();
   *  > method
   *  > after
   *
   *  detach();
   *  instance.method();
   *  > method
   * ```
   * The value returned by the original method is passed as the first argument to `fn` followed by all the arguments
   * passed by the caller.
   *
   * If `fn` returns a value (not `undefined`), that value is returned from the method call instead of the value
   * returned by the original method.
   * ```
   *  class A {
   *      method(x) {
   *          console.log('method', x);
   *          return x * 2
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.after(instance, 'method', (ret, x) => {
   *      console.log('after', ret, x);
   *      return x / 2;
   *  });
   *
   *  console.log(instance.method(50));
   *  > method 50
   *  > after 100 50
   *  > 25
   *
   *  detach();
   *  console.log(instance.method(50));
   *  > method 50
   *  > 100
   * ```
   *
   * @param {Object} object The object to hook.
   * @param {String} method The name of the method on `object` to hook.
   * @param {Function|String} fn The function or method name (on `thisObj`) to call after `method`.
   * @param {Object} [thisObj] The `this` pointer value for calling `fn`.
   * @param {Object} [options] Additional options
   * @param {Boolean} [options.return=true] Specify `false` to not include the return value of the hooked method as
   * the first argument to `fn`.
   * @returns {Function} The function to call to remove the hook.
   */
  static after(object, method, fn2, thisObj, options) {
    const named = typeof fn2 === "string", withReturn = (options == null ? void 0 : options.return) !== false, hook = (...args) => {
      const origResult = hook.$nextHook.call(object, ...args), hookResult = (thisObj == null ? void 0 : thisObj.isDestroyed) ? void 0 : withReturn ? named ? thisObj[fn2](origResult, ...args) : fn2.call(thisObj, origResult, ...args) : named ? thisObj[fn2](...args) : fn2.call(thisObj, ...args);
      return hookResult === void 0 ? origResult : hookResult;
    };
    return _FunctionHelper.hookMethod(object, method, hook);
  }
  /**
   * Inserts a function before the specified `method` is called on an `object`. To remove this hook, invoke the
   * function returned by this method.
   * ```
   *  class A {
   *      method() {
   *          console.log('method');
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.before(instance, 'method', () => { console.log('before') });
   *
   *  instance.method();
   *  > before
   *  > method
   *
   *  detach();
   *  instance.method();
   *  > method
   * ```
   * If `fn` returns `false`, the original method is not invoked and `false` is returned to the caller.
   * ```
   *  class A {
   *      method(x) {
   *          console.log('method', x);
   *          return x * 2;
   *      }
   *  }
   *
   *  let instance = new A();
   *
   *  let detach = FunctionHelper.before(instance, 'method', x => {
   *      console.log('before', x);
   *      return false;
   *  });
   *
   *  console.log(instance.method(50));
   *  > before 50
   *  > false
   *
   *  detach();
   *  console.log(instance.method(50));
   *  > method 50
   *  > 100
   * ```
   *
   * @param {Object} object The object to hook.
   * @param {String} method The name of the method on `object` to hook.
   * @param {Function|String} fn The function or method name (on `thisObj`) to call before `method`.
   * @param {Object} [thisObj] The `this` pointer value for calling `fn`.
   * @returns {Function} The function to call to remove the hook.
   */
  static before(object, method, fn2, thisObj) {
    const named = typeof fn2 === "string", hook = (...args) => {
      const ret = (thisObj == null ? void 0 : thisObj.isDestroyed) ? 0 : named ? thisObj[fn2](...args) : fn2.call(thisObj, ...args);
      return ret === false ? ret : hook.$nextHook.call(object, ...args);
    };
    return _FunctionHelper.hookMethod(object, method, hook);
  }
  static curry(func) {
    return function curried(...args) {
      if (args.length >= func.length) {
        return func.apply(this, args);
      } else {
        return function(...args2) {
          return curried.apply(this, args.concat(args2));
        };
      }
    };
  }
  static bindAll(obj) {
    for (const key in obj) {
      if (typeof obj[key] === "function") {
        obj[key] = obj[key].bind(obj);
      }
    }
  }
  /**
   * Returns a function which calls the passed `interceptor` function first, and the passed `original` after
   * as long as the `interceptor` does not return `false`.
   * @param {Function} original The function to call second.
   * @param {Function} interceptor The function to call first.
   * @param {Object} [thisObj] The `this` reference when the functions are called.
   * @returns {Function} A function which yields the return value from the `original` function **if it was called**, else `false`.
   */
  static createInterceptor(original, interceptor, thisObj) {
    return function(...args) {
      const theThis = thisObj || this;
      if (interceptor.call(theThis, ...args) !== false) {
        return original.call(theThis, ...args);
      }
      return false;
    };
  }
  /**
   * Returns a function which calls the passed `sequence` function after calling
   * the passed `original`.
   * @param {Function} original The function to call first.
   * @param {Function} sequence The function to call second.
   * @param {Object} [thisObj] The `this` reference when the functions are called.
   * @returns {Function} A function which yields the value returned from the sequence if it returned a value, else the return
   * value from the original function.
   */
  static createSequence(original, sequence, thisObj) {
    return (...args) => {
      const origResult = original.call(thisObj, ...args), sequenceResult = sequence.call(thisObj, ...args);
      return sequenceResult === void 0 ? origResult : sequenceResult;
    };
  }
  /**
   * Create a "debounced" function which will call on the "leading edge" of a timer period.
   * When first invoked will call immediately, but invocations after that inside its buffer
   * period will be rejected, and *one* invocation will be made after the buffer period has expired.
   *
   * This is useful for responding immediately to a first mousemove, but from then on, only
   * calling the action function on a regular timer while the mouse continues to move.
   *
   * @param {Function} fn The function to call.
   * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Array} [extraArgs] The argument list to append to those passed to the function.
   * @param {Function} [alt] A function to call when the invocation is rejected due to buffer time not having expired.
   * @returns {Function} A function which calls the passed `fn` only if at least the passed `buffer`
   * milliseconds has elapsed since its last invocation.
   */
  static createThrottled(fn2, buffer, thisObj, extraArgs, alt2) {
    let lastCallTime = -Number.MAX_VALUE, callArgs, timerId;
    const invoke = () => {
      timerId = 0;
      lastCallTime = performance.now();
      callArgs.push.apply(callArgs, extraArgs);
      fn2.apply(thisObj, callArgs);
    }, result = function(...args) {
      const elapsed = performance.now() - lastCallTime;
      callArgs = args;
      if (elapsed >= buffer) {
        clearTimeout(timerId);
        invoke();
      } else {
        if (!timerId) {
          timerId = setTimeout(invoke, buffer - elapsed);
        }
        if (alt2) {
          callArgs.push.apply(callArgs, extraArgs);
          alt2.apply(thisObj, callArgs);
        }
      }
    };
    result.cancel = () => clearTimeout(timerId);
    return result;
  }
  /**
   * Create a "debounced" function which will call on the "trailing edge" of a timer period.
   * When first invoked will wait until the buffer period has expired to call the function, and
   * more calls within that time will restart the timer.
   *
   * This is useful for responding to keystrokes, but deferring action until the user pauses typing.
   *
   * @param {Function} fn The function to call.
   * @param {Number} buffer The milliseconds to wait after each execution before another execution takes place.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Array} [args] The argument list to append to those passed to the function.
   * @returns {Function} A function which calls the passed `fn` when at least the passed `buffer`
   * milliseconds has elapsed since its last invocation.
   */
  static createBuffered(fn2, buffer, thisObj, args) {
    let callArgs, timerId;
    const invoke = () => {
      timerId = 0;
      result.isPending = false;
      callArgs.push.apply(callArgs, args);
      fn2.apply(thisObj, callArgs);
    }, result = function(...args2) {
      callArgs = args2;
      if (timerId) {
        clearTimeout(timerId);
      }
      result.isPending = true;
      timerId = setTimeout(invoke, buffer);
    };
    result.cancel = () => {
      result.isPending = false;
      clearTimeout(timerId);
    };
    return result;
  }
  static decompile(fn2) {
    if (!(decompiledSym in fn2)) {
      const code = fn2.toString();
      let m = fnRe1.exec(code), args, body, name, decompiled, t;
      if (m) {
        args = [m[2]];
        body = m[3];
      } else if (m = fnRe2.exec(code)) {
        t = m[2].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[3];
      } else if (m = fnRe3.exec(code)) {
        name = m[2];
        t = m[3].trim();
        args = t ? t.split(commaSepRe) : [];
        body = m[4];
      }
      body = body == null ? void 0 : body.trim();
      fn2[decompiledSym] = decompiled = m && {
        args,
        async: Boolean(m[1]),
        body: (body == null ? void 0 : body.startsWith("{")) ? body.substring(1, body.length - 1).trim() : body
      };
      if (name) {
        decompiled.name = name;
      }
    }
    return fn2[decompiledSym];
  }
  static hookMethod(object, method, hook) {
    hook.$nextHook = object[method];
    object[method] = hook;
    return () => {
      var _a2;
      if (hasOwnProperty4.call(object, method)) {
        let f = object[method], next;
        if (f === hook) {
          if (((_a2 = Object.getPrototypeOf(object)) == null ? void 0 : _a2[method]) === hook.$nextHook) {
            delete object[method];
          } else {
            object[method] = hook.$nextHook;
          }
        } else {
          for (; next = f == null ? void 0 : f.$nextHook; f = next) {
            if (next === hook) {
              f.$nextHook = hook.$nextHook;
              break;
            }
          }
        }
      }
    };
  }
  /**
   * Protects the specified `method` on a given `object` such that calling it will not throw exceptions.
   * @param {Object} object The object whose method is to be protected.
   * @param {String} method The name of the method to protect.
   * @param {Function} [handler] An optional function to call for any thrown exceptions.
   * @internal
   */
  static noThrow(object, method, handler) {
    const fn2 = object[method];
    object[method] = (...args) => {
      try {
        return fn2.apply(object, args);
      } catch (e) {
        return handler == null ? void 0 : handler(e);
      }
    };
  }
  static returnTrue() {
    return true;
  }
  static animate(duration, fn2, thisObj, easing = "linear") {
    let cancel = false;
    const result = new Promise((resolve) => {
      const start = performance.now(), iterate = () => {
        const progress = Math.min((performance.now() - start) / duration, 1), delayable = thisObj && thisObj.setTimeout ? thisObj : globalThis;
        if (!cancel) {
          if (fn2.call(thisObj, this.easingFunctions[easing](progress)) === false) {
            resolve();
          }
        }
        if (cancel || progress === 1) {
          delayable.requestAnimationFrame(() => resolve());
        } else {
          delayable.requestAnimationFrame(iterate);
        }
      };
      iterate();
    });
    result.cancel = () => {
      cancel = true;
      result.cancelled = true;
      return false;
    };
    return result;
  }
};
var half = 0.5;
var e1 = 1.70158;
var e2 = 7.5625;
var e3 = 1.525;
var e4 = 2 / 2.75;
var e5 = 2.25 / 2.75;
var e6 = 1 / 2.75;
var e7 = 1.5 / 2.75;
var e8 = 2.5 / 2.75;
var e9 = 2.625 / 2.75;
var e10 = 0.75;
var e11 = 0.9375;
var e12 = 0.984375;
var s1 = 1.70158;
var s2 = 1.70158;
FunctionHelper.easingFunctions = {
  linear: (t) => t,
  easeInQuad: (t) => Math.pow(t, 2),
  easeOutQuad: (t) => -(Math.pow(t - 1, 2) - 1),
  easeInOutQuad: (t) => (t /= half) < 1 ? half * Math.pow(t, 2) : -half * ((t -= 2) * t - 2),
  easeInCubic: (t) => Math.pow(t, 3),
  easeOutCubic: (t) => Math.pow(t - 1, 3) + 1,
  easeInOutCubic: (t) => (t /= half) < 1 ? half * Math.pow(t, 3) : half * (Math.pow(t - 2, 3) + 2),
  easeInQuart: (t) => Math.pow(t, 4),
  easeOutQuart: (t) => -(Math.pow(t - 1, 4) - 1),
  easeInOutQuart: (t) => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeInQuint: (t) => Math.pow(t, 5),
  easeOutQuint: (t) => Math.pow(t - 1, 5) + 1,
  easeInOutQuint: (t) => (t /= half) < 1 ? half * Math.pow(t, 5) : half * (Math.pow(t - 2, 5) + 2),
  easeInSine: (t) => -Math.cos(t * (Math.PI / 2)) + 1,
  easeOutSine: (t) => Math.sin(t * (Math.PI / 2)),
  easeInOutSine: (t) => -half * (Math.cos(Math.PI * t) - 1),
  easeInExpo: (t) => t === 0 ? 0 : Math.pow(2, 10 * (t - 1)),
  easeOutExpo: (t) => t === 1 ? 1 : -Math.pow(2, -10 * t) + 1,
  easeInOutExpo: (t) => t === 0 ? 0 : t === 1 ? 1 : (t /= half) < 1 ? half * Math.pow(2, 10 * (t - 1)) : half * (-Math.pow(2, -10 * --t) + 2),
  easeInCirc: (t) => -(Math.sqrt(1 - t * t) - 1),
  easeOutCirc: (t) => Math.sqrt(1 - Math.pow(t - 1, 2)),
  easeInOutCirc: (t) => (t /= half) < 1 ? -half * (Math.sqrt(1 - t * t) - 1) : half * (Math.sqrt(1 - (t -= 2) * t) + 1),
  easeOutBounce: (t) => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  easeInBack: (t) => t * t * ((e1 + 1) * t - e1),
  easeOutBack: (t) => (t = t - 1) * t * ((e1 + 1) * t + e1) + 1,
  easeInOutBack: (t) => {
    let v1 = s1;
    return (t /= half) < 1 ? half * (t * t * (((v1 *= e3) + 1) * t - v1)) : half * ((t -= 2) * t * (((v1 *= e3) + 1) * t + v1) + 2);
  },
  elastic: (t) => -1 * Math.pow(4, -8 * t) * Math.sin((t * 6 - 1) * (2 * Math.PI) / 2) + 1,
  swingFromTo: (t) => {
    let v2 = s2;
    return (t /= half) < 1 ? half * (t * t * (((v2 *= e3) + 1) * t - v2)) : half * ((t -= 2) * t * (((v2 *= e3) + 1) * t + v2) + 2);
  },
  swingFrom: (t) => t * t * ((e1 + 1) * t - e1),
  swingTo: (t) => (t -= 1) * t * ((e1 + 1) * t + e1) + 1,
  bounce: (t) => t < e6 ? e2 * t * t : t < e4 ? e2 * (t -= e7) * t + e10 : t < e8 ? e2 * (t -= e5) * t + e11 : e2 * (t -= e9) * t + e12,
  bouncePast: (t) => t < e6 ? e2 * t * t : t < e4 ? 2 - (e2 * (t -= e7) * t + e10) : t < e8 ? 2 - (e2 * (t -= e5) * t + e11) : 2 - (e2 * (t -= e9) * t + e12),
  easeFromTo: (t) => (t /= half) < 1 ? half * Math.pow(t, 4) : -half * ((t -= 2) * Math.pow(t, 3) - 2),
  easeFrom: (t) => Math.pow(t, 4),
  easeTo: (t) => Math.pow(t, 0.25)
};
FunctionHelper._$name = "FunctionHelper";

// ../Core/lib/Core/mixin/Events.js
var { isArray } = Array;
var { hasOwnProperty: hasOwnProperty5 } = Object.prototype;
var specialProperties = {
  thisObj: 1,
  detachable: 1,
  once: 1,
  detacher: 1,
  prio: 1,
  args: 1,
  expires: 1,
  buffer: 1,
  throttle: 1,
  name: 1,
  $internal: 1
};
var priorityComparator = (a, b) => b.prio - a.prio;
var Events_default = (Target) => class Events extends (Target || Base) {
  constructor() {
    super(...arguments);
    __publicField(this, "eventsSuspended", null);
  }
  static get $name() {
    return "Events";
  }
  //region Events
  /**
   * Fires before an object is destroyed.
   * @event beforeDestroy
   * @param {Core.Base} source The Object that is being destroyed.
   */
  /**
   * Fires when an object is destroyed.
   * @event destroy
   * @param {Core.Base} source The Object that is being destroyed.
   */
  /**
   * Fires when any other event is fired from the object.
   *
   * **Note**: `catchAll` is fired for both public and private events. Please rely on the public events only.
   * @event catchAll
   * @param {Object} event The Object that contains event details
   * @param {String} event.type The type of the event which is caught by the listener
   * @typings event -> {{[key: string]: any, type: string}}
   */
  //endregion
  static get declarable() {
    return [
      /**
       * The list of deprecated events as an object, where `key` is an event name which is deprecated and
       * `value` is an object which contains values for
       * {@link Core.helper.VersionHelper#function-deprecate-static VersionHelper}:
       * - product {String} The name of the product;
       * - invalidAsOfVersion {String} The version where the offending code is invalid (when any compatibility
       *   layer is actually removed);
       * - message {String} Warning message to show to the developer using a deprecated API;
       *
       * For example:
       *
       * ```javascript
       * return {
       *     click : {
       *         product            : 'Grid',
       *         invalidAsOfVersion : '1.0.0',
       *         message            : 'click is deprecated!'
       *     }
       * }
       * ```
       *
       * @name deprecatedEvents
       * @returns {Object}
       * @static
       * @internal
       */
      "deprecatedEvents"
    ];
  }
  static setupDeprecatedEvents(cls, meta) {
    const all = meta.getInherited("deprecatedEvents"), add = cls.deprecatedEvents;
    for (const eventName in add) {
      all[eventName.toLowerCase()] = all[eventName] = add[eventName];
    }
  }
  //region Config
  static get configurable() {
    return {
      /**
       * Set to true to call onXXX method names (e.g. `onShow`, `onClick`), as an easy way to listen for events.
       *
       * ```javascript
       * const container = new Container({
       *     callOnFunctions : true
       *
       *     onHide() {
       *          // Do something when the 'hide' event is fired
       *     }
       * });
       * ```
       *
       * @config {Boolean} callOnFunctions
       * @category Misc
       * @default false
       */
      /**
       * The listener set for this object.
       *
       * An object whose property names are the names of events to handle, or options which modifiy
       * __how__ the handlers are called.
       *
       * See {@link #function-addListener} for details about the options.
       *
       * Listeners can be specified in target class config and they will be merged with any listeners specified in
       * the instantiation config. Class listeners will be fired first:
       *
       * ```javascript
       * class MyStore extends Store({
       *     static get configurable() {
       *         return {
       *             listeners : {
       *                 myCustomEvent() {
       *                 },
       *                 load : {
       *                     prio : 10000,
       *                     fn() { // this load listener handles things first }
       *                 }
       *             }
       *         }
       *     }
       * });
       *
       * let store = new MyStore({
       *   listeners: {
       *     load: () => { // This load listener runs after the class's },
       *     ...
       *   }
       * });
       * ```
       *
       * ### Handlers as function name
       *
       * Object event handlers may be specified as a function __name__. If a string is specified, it is the name
       * of the function in the `thisObj` object.
       *
       * If the string begins with `up.`, this object's ownership hierarchy
       * (if present) is scanned for an object which implements that function name:
       *
       * ```javascript
       * new Popup({
       *     tbar : {
       *         items : {
       *             myCombo : {
       *                 type      : 'combo',
       *                 editable  : false,
       *                 label     : 'Type',
       *                 listeners : {
       *                     // Look in owner chain for this function name
       *                     change : 'up.onFilterChange'
       *                 },
       *                 items     : [
       *                     'Event',
       *                     'Task',
       *                     'Appointment'
       *                 ]
       *             }
       *         }
       *     },
       *     items : {
       *         ...
       *     },
       *     onFilterChange({ value }) {
       *         // Handle event type selection here
       *     }
       * });
       *```
       *
       * @config {Object}
       * @category Common
       */
      listeners: {
        value: null,
        $config: {
          merge(newValue, currentValue) {
            if (newValue !== null) {
              if (!newValue) {
                return currentValue;
              }
              if (currentValue) {
                newValue = newValue ? [newValue] : [];
                newValue.push[isArray(currentValue) ? "apply" : "call"](newValue, currentValue);
              }
            }
            return newValue;
          }
        }
      },
      /**
       * Internal listeners, that cannot be removed by the user.
       * @config {Object}
       * @internal
       */
      internalListeners: null,
      /**
       * An object where property names with a truthy value indicate which events should bubble up the ownership
       * hierarchy when triggered.
       *
       * ```javascript
       * const container = new Container({
       *     items : [
       *        { type : 'text', bubbleEvents : { change : true }}
       *     ],
       *
       *     listeners : {
       *         change() {
       *             // Will catch change event from the text field
       *         }
       *     }
       * });
       * ```
       *
       * @config {Object}
       * @category Misc
       */
      bubbleEvents: null
    };
  }
  destroy() {
    this.trigger("beforeDestroy");
    super.destroy();
  }
  //endregion
  //region Init
  construct(config, ...args) {
    if (this.configuredListeners = config == null ? void 0 : config.listeners) {
      config = Objects.assign({}, config);
      delete config.listeners;
    }
    super.construct(config, ...args);
    this.processConfiguredListeners();
  }
  processConfiguredListeners() {
    if (this.configuredListeners) {
      const me = this, { isConfiguring } = me;
      me.isConfiguring = false;
      me.listeners = me.configuredListeners;
      me.configuredListeners = null;
      me.isConfiguring = isConfiguring;
    }
  }
  /**
   * Auto detaches listeners registered from start, if set as detachable
   * @internal
   */
  doDestroy() {
    this.trigger("destroy");
    this.removeAllListeners(false);
    super.doDestroy();
  }
  static setupClass(meta) {
    super.setupClass(meta);
    Events.prototype.onListen.$nullFn = true;
    Events.prototype.onUnlisten.$nullFn = true;
  }
  //endregion
  //region Listeners
  /**
   * Adds an event listener. This method accepts parameters in the following format:
   *
   * ```javascript
   *  myObject.addListener({
   *      thisObj    : this,          // The this reference for the handlers
   *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,
   *      otherevent : {
   *          fn      : 'handlerFnName',
   *          once    : true          // Just this handler is auto-removed on fire
   *      },
   *      yetanother  : {
   *          fn      : 'yetAnotherHandler',
   *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler
   *      },
   *      prio        : 100           // Higher prio listeners are called before lower
   *  });
   * ```
   *
   * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.
   * When it is destroyed, those listeners are removed.
   *
   * The `config` parameter allows supplying options for the listener(s), for available options see {@link #typedef-BryntumListenerConfig}.
   *
   * A simpler signature may be used when only adding a listener for one event and no extra options
   * (such as `once` or `delay`) are required:
   *
   * ```javascript
   * myObject.addListener('click', myController.handleClicks, myController);
   * ```
   *
   * The args in this simple case are `eventName`, `handler` and `thisObj`
   *
   * @param {BryntumListenerConfig|String} config An object containing listener definitions, or the event name to listen for
   * @param {Object|Function} [thisObj] Default `this` reference for all listeners in the config object, or the handler
   * function to call if providing a string as the first arg.
   * @param {Object} [oldThisObj] The `this` reference if the old signature starting with a string event name is used..
   * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners
   */
  addListener(config, thisObj, oldThisObj) {
    var _a2;
    if (isArray(config)) {
      for (let i = 0, { length } = config; i < length; i++) {
        this.addListener(config[i], thisObj);
      }
      return;
    }
    const me = this, deprecatedEvents = me.$meta.getInherited("deprecatedEvents");
    if (typeof config === "string") {
      return me.addListener({
        [config]: thisObj,
        detachable: thisObj.detachable !== false,
        thisObj: oldThisObj
      });
    } else {
      thisObj = config.thisObj = config.thisObj !== void 0 ? config.thisObj : thisObj;
      for (const key in config) {
        if (!specialProperties[key] && config[key] != null) {
          const eventName = key.toLowerCase(), deprecatedEvent = deprecatedEvents == null ? void 0 : deprecatedEvents[eventName], events = me.eventListeners || (me.eventListeners = {}), specs = ArrayHelper.asArray(config[key]);
          if (deprecatedEvent) {
            const { product, invalidAsOfVersion, message } = deprecatedEvent;
            VersionHelper.deprecate(product, invalidAsOfVersion, message);
          }
          for (const listenerSpec of specs) {
            const expires = listenerSpec.expires || config.expires, listener = {
              fn: typeof listenerSpec === "object" ? listenerSpec.fn : listenerSpec,
              thisObj: listenerSpec.thisObj !== void 0 ? listenerSpec.thisObj : thisObj,
              args: listenerSpec.args || config.args,
              prio: listenerSpec.prio !== void 0 ? listenerSpec.prio : config.prio !== void 0 ? config.prio : 0,
              once: listenerSpec.once !== void 0 ? listenerSpec.once : config.once !== void 0 ? config.once : false,
              buffer: listenerSpec.buffer || config.buffer,
              throttle: listenerSpec.throttle || config.throttle,
              $internal: config.$internal,
              catchAll: key === "catchAll"
            };
            if (expires) {
              const { alt: alt2 } = expires, delay2 = alt2 ? expires.delay : expires, name2 = config.name || key, fn2 = () => {
                me.un(eventName, listener);
                if (alt2 && !listener.called) {
                  me.callback(alt2, thisObj);
                }
              };
              if (me.isDelayable) {
                me.setTimeout({
                  fn: fn2,
                  name: name2,
                  cancelOutstanding: true,
                  delay: delay2
                });
              } else {
                globalThis.setTimeout(fn2, delay2);
              }
            }
            let listeners = events[eventName] || (events[eventName] = []);
            if (listeners.$firing) {
              events[eventName] = listeners = listeners.slice();
            }
            listeners.splice(
              ArrayHelper.findInsertionIndex(listener, listeners, priorityComparator, listeners.length),
              0,
              listener
            );
            if (!me.onListen.$nullFn && listeners.length < 2) {
              me.onListen(eventName);
            }
            (_a2 = me.afterAddListener) == null ? void 0 : _a2.call(me, eventName, listener);
          }
        }
      }
      if (config.relayAll) {
        me.relayAll(config.relayAll);
      }
      if (thisObj && thisObj !== me) {
        me.attachAutoDetacher(config, thisObj);
      }
      const detachable = config.detachable !== false, name = config.name, destroy = config.expires || detachable || name ? () => {
        if (!me.isDestroyed) {
          me.removeListener(config, thisObj);
        }
      } : null;
      if (destroy) {
        destroy.eventer = me;
        destroy.listenerName = name;
        if (name && (thisObj == null ? void 0 : thisObj.trackDetacher)) {
          thisObj.trackDetacher(name, destroy);
        }
        if (config.expires) {
          me.delay(destroy, isNaN(config.expires) ? config.expires.delay : config.expires, name);
        }
        if (detachable) {
          return destroy;
        }
      }
    }
  }
  /**
   * Alias for {@link #function-addListener}. Adds an event listener. This method accepts parameters in the following format:
   *
   * ```javascript
   *  myObject.on({
   *      thisObj    : this,          // The this reference for the handlers
   *      eventname2 : 'functionName' // Resolved at invocation time using the thisObj,
   *      otherevent : {
   *          fn      : 'handlerFnName',
   *          once    : true          // Just this handler is auto-removed on fire
   *      },
   *      yetanother  : {
   *          fn      : 'yetAnotherHandler',
   *          args    : [ currentState1, currentState2 ] // Capture info to be passed to handler
   *      },
   *      prio        : 100           // Higher prio listeners are called before lower
   *  });
   * ```
   *
   * When listeners have a `thisObj` option, they are linked to the lifecycle of that object.
   * When it is destroyed, those listeners are removed.
   *
   * The `config` parameter allows supplying options for the listener(s), for available options see {@link #typedef-BryntumListenerConfig}.
   *
   * A simpler signature may be used when only adding a listener for one event and no extra options
   * (such as `once` or `delay`) are required:
   *
   * ```javascript
   * myObject.on('click', myController.handleClicks, myController);
   * ```
   *
   * The args in this simple case are `eventName`, `handler` and `thisObj`
   *
   * @param {BryntumListenerConfig|String} config An object containing listener definitions, or the event name to listen for
   * @param {Object|Function} [thisObj] Default `this` reference for all listeners in the config object, or the handler
   * function to call if providing a string as the first arg.
   * @param {Object} [oldThisObj] The `this` reference if the old signature starting with a string event name is used..
   * @returns {Function} Returns a detacher function unless configured with `detachable: false`. Call detacher to remove listeners
   */
  on(config, thisObj, oldThisObj) {
    return this.addListener(config, thisObj, oldThisObj);
  }
  /**
   * Internal convenience method for adding an internal listener, that cannot be removed by the user.
   *
   * Alias for `on({ $internal : true, ... })`. Only supports single argument form.
   *
   * @internal
   */
  ion(config) {
    config.$internal = true;
    return this.on(config);
  }
  /**
   * Shorthand for {@link #function-removeListener}
   * @param {Object|String} config A config object or the event name
   * @param {Object|Function} [thisObj] `this` reference for all listeners, or the listener function
   * @param {Object} [oldThisObj] `this` The `this` object for the legacy way of adding listeners
   */
  un(...args) {
    this.removeListener(...args);
  }
  updateInternalListeners(internalListeners, oldInternalListeners) {
    oldInternalListeners == null ? void 0 : oldInternalListeners.detach();
    if (internalListeners) {
      internalListeners.detach = this.ion(internalListeners);
    }
  }
  get listeners() {
    return this.eventListeners;
  }
  changeListeners(listeners) {
    if (this.isConfiguring) {
      this.getConfig("internalListeners");
      if (listeners) {
        this.on(listeners, this);
      }
    } else {
      if (Array.isArray(listeners)) {
        for (let i = 0, l = listeners[0], { length } = listeners; i < length; l = listeners[++i]) {
          if (!("thisObj" in l)) {
            listeners[i] = Objects.assign({ thisObj: this }, l);
          }
        }
      } else if (listeners && !("thisObj" in listeners)) {
        listeners = Objects.assign({ thisObj: this }, listeners);
      }
      return listeners;
    }
  }
  updateListeners(listeners, oldListeners) {
    oldListeners && this.un(oldListeners);
    listeners && this.on(listeners);
  }
  /**
   * Removes an event listener. Same API signature as {@link #function-addListener}
   * @param {Object|String} config A config object or the event name
   * @param {Object|Function} thisObj `this` reference for all listeners, or the listener function
   * @param {Object} oldThisObj `this` The `this` object for the legacy way of adding listeners
   */
  removeListener(config, thisObj = config.thisObj, oldThisObj) {
    const me = this;
    if (typeof config === "string") {
      return me.removeListener({ [config]: thisObj }, oldThisObj);
    }
    Object.entries(config).forEach(([eventName, listenerToRemove]) => {
      var _a2;
      if (!specialProperties[eventName] && listenerToRemove != null) {
        eventName = eventName.toLowerCase();
        const { eventListeners } = me, index = me.findListener(eventName, listenerToRemove, thisObj);
        if (index >= 0) {
          let listeners = eventListeners[eventName];
          (_a2 = me.afterRemoveListener) == null ? void 0 : _a2.call(me, eventName, listeners[index]);
          if (listeners.length > 1) {
            if (listeners.$firing) {
              eventListeners[eventName] = listeners = listeners.slice();
            }
            listeners.splice(index, 1);
          } else {
            delete eventListeners[eventName];
            if (!me.onUnlisten.$nullFn) {
              me.onUnlisten(eventName);
            }
          }
        }
      }
    });
    if (config.thisObj && !config.thisObj.isDestroyed) {
      me.detachAutoDetacher(config);
    }
  }
  /**
   * Finds the index of a particular listener to the named event. Returns `-1` if the passed
   * function/thisObj listener is not present.
   * @param {String} eventName The name of an event to find a listener for.
   * @param {String|Function} listenerToFind The handler function to find.
   * @param {Object} defaultThisObj The `thisObj` for the required listener.
   * @internal
   */
  findListener(eventName, listenerToFind, defaultThisObj) {
    var _a2;
    const eventListeners = (_a2 = this.eventListeners) == null ? void 0 : _a2[eventName], fn2 = listenerToFind.fn || listenerToFind, thisObj = listenerToFind.thisObj || defaultThisObj;
    if (eventListeners) {
      for (let listenerEntry, i = 0, { length } = eventListeners; i < length; i++) {
        listenerEntry = eventListeners[i];
        if (listenerEntry.fn === fn2 && listenerEntry.thisObj === thisObj) {
          return i;
        }
      }
    }
    return -1;
  }
  /**
   * Check if any listener is registered for the specified eventName
   * @param {String} eventName
   * @returns {Boolean} `true` if listener is registered, otherwise `false`
   * @advanced
   */
  hasListener(eventName) {
    var _a2;
    return Boolean((_a2 = this.eventListeners) == null ? void 0 : _a2[eventName == null ? void 0 : eventName.toLowerCase()]);
  }
  /**
   * Relays all events through another object that also implements Events mixin. Adds a prefix to the event name
   * before relaying, for example add -> storeAdd
   * ```
   * // Relay all events from store through grid, will make it possible to listen for store events prefixed on grid:
   * 'storeLoad', 'storeChange', 'storeRemoveAll' etc.
   * store.relayAll(grid, 'store');
   *
   * grid.on('storeLoad', () => console.log('Store loaded');
   * ```
   * @param {Core.mixin.Events} through Object to relay the events through, needs to mix Events mixin in
   * @param {String} prefix Prefix to add to event name
   * @param {Boolean} [transformCase] Specify false to prevent making first letter of event name uppercase
   * @advanced
   */
  relayAll(through, prefix, transformCase = true) {
    if (!this.relayAllTargets) {
      this.relayAllTargets = [];
    }
    const { relayAllTargets } = this;
    through.ion({
      beforeDestroy: ({ source }) => {
        if (source === through) {
          const configs = relayAllTargets.filter((r) => r.through === through);
          configs.forEach((config) => ArrayHelper.remove(relayAllTargets, config));
        }
      }
    });
    relayAllTargets.push({ through, prefix, transformCase });
  }
  /**
   * Removes all listeners registered to this object by the application.
   */
  removeAllListeners(preserveInternal = true) {
    var _a2;
    const listeners = this.eventListeners;
    let i, thisObj;
    for (const event in listeners) {
      const bucket = listeners[event];
      for (i = bucket.length; i-- > 0; ) {
        const cfg = bucket[i];
        if (!cfg.$internal || !preserveInternal) {
          this.removeListener(event, cfg);
          thisObj = cfg.thisObj;
          (_a2 = thisObj == null ? void 0 : thisObj.untrackDetachers) == null ? void 0 : _a2.call(thisObj, this);
        }
      }
    }
  }
  relayEvents(source, eventNames, prefix = "") {
    const listenerConfig = { detachable: true, thisObj: this };
    eventNames.forEach((eventName) => {
      listenerConfig[eventName] = (event, ...params) => {
        return this.trigger(prefix + eventName, event, ...params);
      };
    });
    return source.on(listenerConfig);
  }
  /**
   * This method is called when the first listener for an event is added.
   * @param {String} eventName
   * @internal
   */
  onListen() {
  }
  /**
   * This method is called when the last listener for an event is removed.
   * @param {String} eventName
   * @internal
   */
  onUnlisten() {
  }
  destructorInterceptor() {
    const { autoDetachers, target, oldDestructor } = this;
    for (let i = 0; i < autoDetachers.length; i++) {
      const { dispatcher, config } = autoDetachers[i];
      if (!dispatcher.isDestroyed) {
        dispatcher.removeListener(config, target);
      }
    }
    oldDestructor.call(target);
  }
  /**
   * Internal function used to hook destroy() calls when using thisObj
   * @private
   */
  attachAutoDetacher(config, thisObj) {
    const target = config.thisObj || thisObj, destructorName = "doDestroy" in target ? "doDestroy" : "destroy";
    if (destructorName in target) {
      let { $autoDetachers } = target;
      if (!$autoDetachers) {
        target.$autoDetachers = $autoDetachers = [];
      }
      if (!target.$oldDestructor) {
        target.$oldDestructor = target[destructorName];
        target[destructorName] = this.destructorInterceptor.bind({
          autoDetachers: $autoDetachers,
          oldDestructor: target.$oldDestructor,
          target
        });
      }
      $autoDetachers.push({ config, dispatcher: this });
    } else {
      target[destructorName] = () => {
        this.removeListener(config);
      };
    }
  }
  /**
   * Internal function used restore hooked destroy() calls when using thisObj
   * @private
   */
  detachAutoDetacher(config) {
    const target = config.thisObj;
    if (target.$oldDestructor && !target.isDestroying) {
      ArrayHelper.remove(
        target.$autoDetachers,
        target.$autoDetachers.find((detacher2) => detacher2.config === config && detacher2.dispatcher === this)
      );
      if (!target.$autoDetachers.length) {
        target["doDestroy" in target ? "doDestroy" : "destroy"] = target.$oldDestructor;
        target.$oldDestructor = null;
      }
    }
  }
  /**
   * Internal function used to run a callback function after an event is triggered
   * @private
   */
  once(eventName, callback) {
    return this.on({
      [eventName]: () => this.callback(callback),
      once: true
    });
  }
  //endregion
  //region Promise based workflow
  // experimental, used in tests to support async/await workflow
  await(eventName, options = { checkLog: true, resetLog: true, args: null }) {
    const me = this;
    if (options === false) {
      options = { checkLog: false };
    }
    const { args } = options;
    return new Promise((resolve) => {
      var _a2;
      if (options.checkLog && ((_a2 = me._triggered) == null ? void 0 : _a2[eventName])) {
        resolve();
        if (options.resetLog) {
          me.clearLog(eventName);
        }
      }
      if (args) {
        const detacher2 = me.on({
          [eventName]: (...params) => {
            const argsOk = typeof args === "function" ? args(...params) : Object.keys(args).every((key) => {
              return key in params[0] && params[0][key] === args[key];
            });
            if (argsOk) {
              resolve(...params);
              if (options.resetLog) {
                me.clearLog(eventName);
              }
              detacher2();
            }
          },
          prio: -1e4
          // Let others do their stuff first
        });
      } else {
        me.on({
          [eventName]: (...params) => {
            resolve(...params);
            if (options.resetLog) {
              me.clearLog(eventName);
            }
          },
          prio: -1e4,
          // Let others do their stuff first
          once: true
          // promises can only be resolved once anyway
        });
      }
    });
  }
  clearLog(eventName) {
    if (this._triggered) {
      if (eventName) {
        delete this._triggered[eventName];
      } else {
        this._triggered = {};
      }
    }
  }
  //endregion
  //region Trigger
  /**
   * Triggers an event, calling all registered listeners with the supplied arguments. Returning false from any listener
   * makes function return false.
   * @param {String} eventName Event name for which to trigger listeners
   * @param {Object} [param] Single parameter passed on to listeners, source property will be added to it (this)
   * @param {Boolean} [param.bubbles] Pass as `true` to indicate that the event will bubble up the widget
   * ownership hierarchy. For example up a `Menu`->`parent` Menu tree, or a `Field`->`Container` tree.
   * @typings param -> {{bubbles?: boolean, [key: string]: any}}
   * @returns {Boolean|Promise} Returns false if any listener returned `false`, or a `Promise` yielding
   * `true` / `false` based on what is returned from the async listener functions, otherwise `true`
   * @async
   * @advanced
   */
  trigger(eventName, param) {
    var _a2, _b, _c, _d;
    const me = this, name = eventName.toLowerCase(), {
      eventsSuspended,
      relayAllTargets,
      callOnFunctions
    } = me;
    let listeners = (_a2 = me.eventListeners) == null ? void 0 : _a2[name], handlerPromises;
    if (!me._triggered) {
      me._triggered = {};
    }
    me._triggered[eventName] = true;
    if (eventsSuspended) {
      if (eventsSuspended.shouldQueue) {
        eventsSuspended.queue.push(arguments);
      }
      return true;
    }
    if ((_b = me.eventListeners) == null ? void 0 : _b.catchall) {
      (listeners = listeners ? listeners.slice() : []).push(...me.eventListeners.catchall);
      listeners.sort(priorityComparator);
    }
    if (!listeners && !relayAllTargets && !callOnFunctions) {
      return true;
    }
    if (param) {
      if (!("source" in param)) {
        if (Object.isExtensible(param)) {
          param.source = me;
        } else {
          param = Object.setPrototypeOf({
            source: me
          }, param);
        }
      }
    } else {
      param = {
        source: me
      };
    }
    if (param.type !== name) {
      if (param.constructor !== Object) {
        Reflect.defineProperty(param, "type", { get: () => name });
      } else {
        param.type = name;
      }
    }
    param.eventName = eventName;
    if (!("bubbles" in param) && ((_c = me.bubbleEvents) == null ? void 0 : _c[eventName])) {
      param.bubbles = me.bubbleEvents[eventName];
    }
    if (callOnFunctions) {
      const fnName = "on" + StringHelper.capitalize(eventName);
      if (fnName in me) {
        const result = me[fnName] ? me.callback(me[fnName], me, [param]) : true;
        let inhibit;
        if (Objects.isPromise(result)) {
          (handlerPromises || (handlerPromises = [])).push(result);
        } else {
          inhibit = result === false || inhibit;
        }
        if (!me.isDestroyed && hasOwnProperty5.call(me, fnName) && !((_d = me.pluginFunctionChain) == null ? void 0 : _d[fnName])) {
          const myProto = Object.getPrototypeOf(me);
          if (fnName in myProto) {
            const result2 = myProto[fnName].call(me, param);
            if (Objects.isPromise(result2)) {
              (handlerPromises || (handlerPromises = [])).push(result2);
            } else {
              inhibit = result2 === false || inhibit;
            }
            if (me.isDestroyed) {
              return;
            }
          }
        }
        if (inhibit) {
          return false;
        }
      }
    }
    let ret;
    if (listeners) {
      let i = 0, internalAbort = false;
      listeners.$firing = true;
      for (i; i < listeners.length && !me.isDestroyed && !internalAbort; i++) {
        const listener = listeners[i];
        if (ret === false && !listener.$internal) {
          continue;
        }
        let handler, thisObj = listener.thisObj;
        if (!thisObj || !thisObj.isDestroyed) {
          listener.called = true;
          if (listener.once) {
            me.removeListener(name, listener);
          }
          if (typeof listener.fn === "string") {
            if (thisObj) {
              handler = thisObj[listener.fn];
            }
            if (!handler) {
              const result2 = me.resolveCallback(listener.fn);
              handler = result2.handler;
              thisObj = result2.thisObj;
            }
          } else {
            handler = listener.fn;
          }
          if (listener.buffer) {
            if (!listener.bufferFn) {
              const buffer = Number(listener.buffer);
              if (typeof buffer !== "number" || isNaN(buffer)) {
                throw new Error(`Incorrect type for buffer, got "${buffer}" (expected a Number)`);
              }
              listener.bufferFn = FunctionHelper.createBuffered(handler, buffer, thisObj, listener.args);
            }
            handler = listener.bufferFn;
          }
          if (listener.throttle) {
            const throttle = Number(listener.throttle);
            if (typeof throttle !== "number" || isNaN(throttle)) {
              throw new Error(`Incorrect type for throttle, got "${throttle}" (expected a Number)`);
            }
            if (!listener.throttledFn) {
              listener.throttledFn = FunctionHelper.createThrottled(handler, throttle, thisObj, listener.args);
            }
            handler = listener.throttledFn;
          }
          const result = handler.call(thisObj || me, ...listener.args || [], param);
          if (ret !== false) {
            ret = result;
          }
          if (listener.$internal && result === false) {
            internalAbort = true;
          }
          if (Objects.isPromise(result)) {
            result.$internal = listener.$internal;
            (handlerPromises || (handlerPromises = [])).push(result);
          }
        }
      }
      listeners.$firing = false;
      if (internalAbort) {
        return false;
      }
    }
    relayAllTargets == null ? void 0 : relayAllTargets.forEach((config) => {
      let name2 = eventName;
      if (config.transformCase) {
        name2 = StringHelper.capitalize(name2);
      }
      if (config.prefix) {
        name2 = config.prefix + name2;
      }
      if (config.through.trigger(name2, param) === false) {
        return false;
      }
    });
    if (param.bubbles && me.owner && !me.owner.isDestroyed) {
      return me.owner.trigger(eventName, param);
    }
    handlerPromises = handlerPromises == null ? void 0 : handlerPromises.filter((p) => ret !== false || p.$internal);
    if (handlerPromises == null ? void 0 : handlerPromises.length) {
      return new Promise((resolve) => {
        Promise.all(handlerPromises).then((promiseResults) => {
          const finalResult = !promiseResults.some((result) => result === false);
          resolve(finalResult);
        });
      });
    }
    return ret !== false;
  }
  /**
   * Prevents events from being triggered until {@link #function-resumeEvents()} is called. Optionally queues events that are triggered while
   * suspended. Multiple calls stack to require matching calls to `resumeEvents()` before actually resuming.
   * @param {Boolean} queue Specify true to queue events triggered while suspended
   * @advanced
   */
  suspendEvents(queue = false) {
    const eventsSuspended = this.eventsSuspended || (this.eventsSuspended = { shouldQueue: queue, queue: [], count: 0 });
    eventsSuspended.count++;
  }
  /**
   * Resume event triggering after a call to {@link #function-suspendEvents()}. If any triggered events were queued they will be triggered.
   * @returns {Boolean} `true` if events have been resumed (multiple calls to suspend require an equal number of resume calls to resume).
   * @advanced
   */
  resumeEvents() {
    const suspended = this.eventsSuspended;
    if (suspended) {
      if (--suspended.count === 0) {
        this.eventsSuspended = null;
        if (suspended.shouldQueue) {
          for (const queued of suspended.queue) {
            this.trigger(...queued);
          }
        }
      }
    }
    return !Boolean(this.eventsSuspended);
  }
  //endregion
};

// ../Core/lib/Core/helper/AsyncHelper.js
var AsyncHelper = class {
  /**
   * Returns a promise that resolves on next animation frame.
   * ```
   *  async method() {
   *      // do work
   *      await AsyncHelper.animationFrame();
   *      // do more work
   *  }
   * ```
   * @async
   */
  static animationFrame() {
    return new Promise((resolve) => {
      requestAnimationFrame(resolve);
    });
  }
  /**
   * Returns a promise that resolves after a specified number of milliseconds.
   * ```
   *  async method() {
   *      await AsyncHelper.sleep(10);
   *      // ...
   *  }
   * ```
   * @param {Number} millis The number of milliseconds to sleep.
   * @async
   */
  static sleep(millis) {
    return new Promise((resolve) => {
      setTimeout(() => {
        resolve();
      }, millis);
    });
  }
  /**
   * Returns a promise that resolves as soon as possible, allowing the browser to minimally process other messages.
   * This is the shortest possible delay the browser offers, so be aware that it does not necessarily allow the
   * browser to paint or reflow if used in a long loop. It does, however, allow other async methods to execute.
   * ```
   *  async method() {
   *      await AsyncHelper.yield();
   *      // ...
   *  }
   * ```
   * @async
   */
  static yield() {
    return Promise.resolve();
  }
};
AsyncHelper._$name = "AsyncHelper";

// ../Core/lib/Core/helper/AjaxHelper.js
var paramValueRegExp = /^(\w+)=(.*)$/;
var parseParams = function(paramString) {
  const result = {}, params = paramString.split("&");
  for (const nameValuePair of params) {
    const [match, name, value] = paramValueRegExp.exec(nameValuePair), decodedName = decodeURIComponent(name), decodedValue = decodeURIComponent(value);
    if (match) {
      let paramValue = result[decodedName];
      if (paramValue) {
        if (!Array.isArray(paramValue)) {
          paramValue = result[decodedName] = [paramValue];
        }
        paramValue.push(decodedValue);
      } else {
        result[decodedName] = decodedValue;
      }
    }
  }
  return result;
};
var _AjaxHelper = class _AjaxHelper {
  /**
   * Make a request (using GET) to the specified url.
   * @param {String} url URL to `GET` from
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static get(url, options) {
    return this.fetch(url, options);
  }
  /**
   * POST data to the specified URL.
   * @param {String} url URL to `POST` to
   * @param {String|Object|FormData} payload The data to post. If an object is supplied, it will be stringified
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static post(url, payload, options = {}) {
    if (!(payload instanceof FormData) && !(typeof payload === "string")) {
      payload = JSON.stringify(payload);
      options.headers = options.headers || {};
      options.headers["Content-Type"] = options.headers["Content-Type"] || "application/json";
    }
    return this.fetch(url, Object.assign({
      method: "POST",
      body: payload
    }, options));
  }
  /**
   * Fetch the specified resource using the `fetch` API.
   * @param {String} url URL to fetch from
   * @param {FetchOptions} [options] The options for the `fetch` API
   * @returns {Promise} The fetch Promise, which can be aborted by calling a special `abort` method
   * @async
   */
  static fetch(url, options) {
    let controller;
    options = Objects.merge({}, _AjaxHelper.DEFAULT_FETCH_OPTIONS, options);
    if (typeof AbortController !== "undefined") {
      controller = options.abortController = new AbortController();
      options.signal = controller.signal;
    }
    if (!("credentials" in options)) {
      options.credentials = "include";
    }
    if (options.queryParams) {
      const params = Object.entries(options.queryParams);
      if (params.length) {
        let paramsAdded = false;
        if (options.headers && options.addQueryParamsToBody === true) {
          const contentType = new Headers(options.headers).get("Content-Type");
          let bodyClass;
          switch (contentType) {
            case "application/x-www-form-urlencoded":
              bodyClass = URLSearchParams;
              break;
            case "multipart/form-data":
              bodyClass = FormData;
              break;
          }
          if (bodyClass) {
            const body = options.body || (options.body = new bodyClass());
            if (body instanceof bodyClass) {
              params.forEach(([key, value]) => body.set(key, value));
              paramsAdded = true;
            }
          }
        }
        if (!paramsAdded) {
          url += (url.includes("?") ? "&" : "?") + params.map(
            ([param, value]) => `${param}=${encodeURIComponent(value)}`
          ).join("&");
        }
      }
    }
    const promise = new Promise((resolve, reject) => {
      fetch(url, options).then(
        (response) => {
          if (options.parseJson) {
            response.json().then((json) => {
              response.parsedJson = json;
              resolve(response);
            }).catch((error) => {
              response.parsedJson = null;
              response.error = error;
              reject(response);
            });
          } else {
            resolve(response);
          }
        }
      ).catch((error) => {
        error.stack = promise.stack;
        reject(error);
      });
    });
    promise.stack = new Error().stack;
    promise.abort = function() {
      controller == null ? void 0 : controller.abort();
    };
    return promise;
  }
  /**
   * Registers the passed URL to return the passed mocked up Fetch Response object to the
   * AjaxHelper's promise resolve function.
   * @param {String} url The url to return mock data for
   * @param {Object|Function} response A mocked up Fetch Response object which must contain
   * at least a `responseText` property, or a function to which the `url` and a `params` object
   * and the `Fetch` `options` object is passed which returns that.
   * @param {String} response.responseText The data to return.
   * @param {Boolean} [response.synchronous] resolve the Promise immediately
   * @param {Number} [response.delay=100] resolve the Promise after this number of milliseconds.
   */
  static mockUrl(url, response) {
    const me = this;
    (me.mockAjaxMap || (me.mockAjaxMap = {}))[url] = response;
    if (!_AjaxHelper.originalFetch) {
      _AjaxHelper.originalFetch = _AjaxHelper.fetch;
      _AjaxHelper.fetch = me.mockAjaxFetch.bind(me);
    }
  }
  static async mockAjaxFetch(url, options) {
    const urlAndParams = url.split("?");
    let result = this.mockAjaxMap[urlAndParams[0]], parsedJson = null;
    if (result) {
      if (typeof result === "function") {
        result = await result(urlAndParams[0], urlAndParams[1] && parseParams(urlAndParams[1]), options);
      }
      try {
        parsedJson = (options == null ? void 0 : options.parseJson) && JSON.parse(result.responseText);
      } catch (error) {
        parsedJson = null;
        result.error = error;
      }
      result = Object.assign({
        status: 200,
        ok: true,
        headers: new Headers(),
        statusText: "OK",
        url,
        parsedJson,
        text: () => new Promise((resolve) => {
          resolve(result.responseText);
        }),
        json: () => new Promise((resolve) => {
          resolve(parsedJson);
        })
      }, result);
      return new Promise(function(resolve, reject) {
        if (result.synchronous) {
          resolve(result);
        } else {
          setTimeout(function() {
            resolve(result);
          }, "delay" in result ? result.delay : 100);
        }
      });
    } else {
      return _AjaxHelper.originalFetch(url, options);
    }
  }
};
/**
 * Sets default options for {@link #function-fetch-static AjaxHelper#fetch()} calls. Please see
 * {@link #typedef-FetchOptions} and
 * [fetch API](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/fetch) for details.
 *
 * ```javascript
 * // default content-type for all requests will be "application/json"
 * AjaxHelper.DEFAULT_FETCH_OPTIONS = {
 *     headers : {
 *         'content-type' : 'application/json'
 *     }
 * };
 * ```
 * @member {FetchOptions} DEFAULT_FETCH_OPTIONS
 * @static
 */
__publicField(_AjaxHelper, "DEFAULT_FETCH_OPTIONS", {});
var AjaxHelper = _AjaxHelper;
AjaxHelper._$name = "AjaxHelper";

// ../Core/lib/Core/localization/LocaleHelper.js
var global = typeof self !== "undefined" ? self : typeof globalThis !== "undefined" ? globalThis : null;
var _LocaleHelper = class _LocaleHelper {
  /**
   * Merges all properties of provided locale objects into new locale object.
   * Locales are merged in order they provided and locales which go later replace
   * same properties of previous locales.
   * @param {...Object} locales Locales to merge
   * @returns {Object} Merged locale
   */
  static mergeLocales(...locales) {
    const result = {};
    locales.forEach((locale4) => {
      Object.keys(locale4).forEach((key) => {
        if (typeof locale4[key] === "object") {
          result[key] = { ...result[key], ...locale4[key] };
        } else {
          result[key] = locale4[key];
        }
      });
    });
    return result;
  }
  /**
   * Removes all properties from `locale` that are present in the provided `toTrim`.
   * @param {Object} locale Locale to process
   * @param {Object} toTrim Object enumerating properties that should be removed.
   * When `false` throws exceptions in such cases.
   */
  static trimLocale(locale4, toTrim) {
    const remove = (key, subKey) => {
      if (locale4[key]) {
        if (subKey) {
          if (locale4[key][subKey]) {
            delete locale4[key][subKey];
          }
        } else {
          delete locale4[key];
        }
      }
    };
    Object.keys(toTrim).forEach((key) => {
      if (Object.keys(toTrim[key]).length > 0) {
        Object.keys(toTrim[key]).forEach((subKey) => remove(key, subKey));
      } else {
        remove(key);
      }
    });
  }
  /**
   * Normalizes locale object to {@link Locale} type.
   *
   * Supported configs:
   *
   * ```javascript
   * LocaleHelper.normalizeLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * });
   * ```
   *
   * and for backward compatibility
   *
   * ```javascript
   * LocaleHelper.normalizeLocale('En', {
   *     name : 'En',
   *     desc : 'English (US)',
   *     code : 'en-US',
   *     locale : {
   *         ... (localization key:value pairs)
   *     }
   * });
   * ```
   * @param {String|Object} nameOrConfig String name of locale or locale object
   * @param {Object} [config] Locale object
   * @returns {Locale} Locale object
   * @internal
   */
  static normalizeLocale(nameOrConfig, config) {
    if (!nameOrConfig) {
      throw new Error(`"nameOrConfig" parameter can not be empty`);
    }
    if (typeof nameOrConfig === "string") {
      if (!config) {
        throw new Error(`"config" parameter can not be empty`);
      }
      if (config.locale) {
        config.name = nameOrConfig || config.name;
      } else {
        config.localeName = nameOrConfig;
      }
    } else {
      config = nameOrConfig;
    }
    let locale4 = {};
    if (config.name || config.locale) {
      locale4 = Object.assign({
        localeName: config.name
      }, config.locale);
      config.desc && (locale4.localeDesc = config.desc);
      config.code && (locale4.localeCode = config.code);
      config.path && (locale4.localePath = config.path);
    } else {
      if (!config.localeName) {
        throw new Error(`"config" parameter doesn't have "localeName" property`);
      }
      locale4 = Object.assign({}, config);
    }
    for (const key of ["name", "desc", "code", "path"]) {
      if (locale4[key]) {
        delete locale4[key];
      }
    }
    if (!locale4.localeName) {
      throw new Error(`Locale name can not be empty`);
    }
    return locale4;
  }
  /**
   * Get/set currently published locales.
   * Returns an object with locales.
   *
   * Example:
   *
   * ```javascript
   * const englishLocale = LocaleHelper.locales.En;
   * ```
   *
   * `englishLocale` contains {@link Locale} object.
   *
   * @readonly
   * @member {Locales} locales
   * @static
   */
  static get locales() {
    return global.bryntum.locales || {};
  }
  static set locales(locales) {
    global.bryntum.locales = locales;
  }
  /**
   * Get/set current locale name. Defaults to "En"
   * @member {String} localeName
   * @static
   */
  static get localeName() {
    return global.bryntum.locale || "En";
  }
  static set localeName(localeName) {
    global.bryntum.locale = localeName || _LocaleHelper.localeName;
  }
  /**
   * Get current locale config specified by {@link ##property-localeName-static}.
   * If no current locale specified, returns default `En` locale or first published locale
   * or empty locale object if no published locales found.
   * @readonly
   * @member {Locales} locale
   * @static
   */
  static get locale() {
    return _LocaleHelper.localeName && this.locales[_LocaleHelper.localeName] || this.locales.En || Object.values(this.locales)[0] || { localeName: "", localeDesc: "", localeCoode: "" };
  }
  /**
   * Publishes a locale to make it available for applying.
   * Published locales are available in {@link ##property-locales-static}.
   *
   * Recommended usage:
   *
   * ```javascript
   * LocaleHelper.publishLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * });
   * ```
   *
   * for backward compatibility (prior to `5.3.0` version):
   *
   * ```javascript
   * LocaleHelper.publishLocale('En', {
   *     name : 'En',
   *     desc : 'English (US)',
   *     code : 'en-US',
   *     locale : {
   *         ... (localization key:value pairs)
   *     }
   * });
   * ```
   *
   * Publishing a locale will automatically merge it's localization keys with existing locale matching by locale name,
   * replacing existing one with new. To replace existing locale entirely pass `true` to optional `config` parameter.
   *
   * Example:
   *
   * ```javascript
   * LocaleHelper.publishLocale({
   *     localeName : 'En',
   *     localeDesc : 'English (US)',
   *     localeCode : 'en-US',
   *     ... (localization key:value pairs)
   * }, true);
   * ```
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object
   * @param {Locale|Boolean} [config] Locale object.
   * Not used if locale object is passed as first method parameter.
   * Path `true` value and locale object as first method parameter to publish locale without merging with existing one.
   * @returns {Locale} Locale object
   */
  static publishLocale(nameOrConfig, config) {
    const { locales } = global.bryntum, locale4 = _LocaleHelper.normalizeLocale(nameOrConfig, config), { localeName } = locale4;
    if (!locales[localeName] || config === true) {
      locales[localeName] = locale4;
    } else {
      locales[localeName] = this.mergeLocales(locales[localeName] || {}, locale4 || {});
    }
    return locales[localeName];
  }
};
__publicField(_LocaleHelper, "skipLocaleIntegrityCheck", false);
var LocaleHelper = _LocaleHelper;
global.bryntum = global.bryntum || {};
global.bryntum.locales = global.bryntum.locales || {};
LocaleHelper._$name = "LocaleHelper";

// ../Core/lib/Core/localization/LocaleManager.js
var LocaleManager = class extends Events_default(Base) {
  static get defaultConfig() {
    return {
      // Enable strict locale checking by default for tests
      throwOnMissingLocale: VersionHelper.isTestEnv
    };
  }
  construct(...args) {
    var _a2;
    const me = this;
    super.construct(...args);
    if (BrowserHelper.isBrowserEnv) {
      const scriptTag = document.querySelector("script[data-default-locale]");
      if (scriptTag) {
        me.applyLocale(scriptTag.dataset.defaultLocale);
      } else if ((_a2 = me.locale) == null ? void 0 : _a2.localeName) {
        me.applyLocale(me.locale.localeName);
      }
    }
  }
  /**
   * Get/set currently registered locales.
   * Alias for {@link Core.localization.LocaleHelper#property-locales-static LocaleHelper.locales}.
   * @readonly
   * @member {Locales} locales
   */
  get locales() {
    return LocaleHelper.locales;
  }
  set locales(locales) {
    LocaleHelper.locales = locales;
  }
  /**
   * Get/set currently used locale.
   * Setter calls {@link #function-applyLocale}.
   * @member {Locales} locale
   * @accepts {String|Locale}
   */
  set locale(nameOrConfig) {
    this.applyLocale(nameOrConfig);
  }
  get locale() {
    return LocaleHelper.locale;
  }
  /**
   * Publishes a locale to make it available for applying.
   * @deprecated Since 5.3.0. Use {@link Core.localization.LocaleHelper#function-publishLocale-static LocaleHelper.publishLocale} instead.
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object.
   * @param {Locale} [config] Locale object. Not used if object is passed as first method parameter
   * @returns {Locale} published locale object is passed as first method parameter
   * @function registerLocale
   */
  registerLocale(nameOrConfig, config) {
    VersionHelper.deprecate("Core", "6.0.0", "LocaleManager.registerLocale deprecated, use LocaleHelper.publishLocale instead");
    LocaleHelper.publishLocale(nameOrConfig, config);
  }
  /**
   * Extends locale specified by name to add additional translations and applies it.
   * @deprecated Since 5.3.0. Use {@link ##function-applyLocale} instead.
   *
   * @param {String} name Name of locale (for example `En` or `SvSE`).
   * @param {Locale} config Locale object
   * @returns {Locale|Promise} locale object or Promise which resolves with locale object after it was loaded
   * @function extendLocale
   */
  extendLocale(name, config) {
    VersionHelper.deprecate("Core", "6.0.0", "LocaleManager.extendLocale deprecated, use LocaleManager.applyLocale instead");
    const locale4 = LocaleHelper.publishLocale(name, config);
    return this.applyLocale(locale4, true);
  }
  /**
   * Applies a locale by string name or publishes new locale configuration with
   * {@link Core.localization.LocaleHelper#function-publishLocale-static} and applies it.
   * If locale is specified by string name, like 'En', it must be published before applying it.
   *
   * @param {String|Locale} nameOrConfig String name of locale (for example `En` or `SvSE`) or locale object
   * @param {Locale|Boolean} [config] Locale object. Pass `true` to reapply locale which is passed as first method parameter.
   * @returns {Locale|Promise} locale object or Promise which resolves with locale object after it was loaded
   * @fires locale
   * @async
   * @function applyLocale
   */
  applyLocale(nameOrConfig, config, ignoreError = false) {
    const me = this;
    let localeConfig;
    if (typeof nameOrConfig === "string") {
      if (typeof config !== "object") {
        localeConfig = me.locales[nameOrConfig];
        if (!localeConfig) {
          if (ignoreError) {
            return true;
          }
          throw new Error(`Locale "${nameOrConfig}" is not published. Publish with LocaleHelper.publishLocale() before applying.`);
        }
      } else {
        localeConfig = LocaleHelper.publishLocale(nameOrConfig, config);
      }
    } else {
      localeConfig = LocaleHelper.publishLocale(nameOrConfig);
    }
    if (me.locale.localeName && me.locale.localeName === localeConfig.localeName && config !== true) {
      return me.locale;
    }
    LocaleHelper.localeName = localeConfig.localeName;
    const triggerLocaleEvent = () => {
      me.trigger("locale", localeConfig);
    };
    if (localeConfig.localePath) {
      return new Promise((resolve, reject) => {
        me.loadLocale(localeConfig.localePath).then((response) => {
          response.text().then((text) => {
            const parseLocale = new Function(text);
            parseLocale();
            if (BrowserHelper.isBrowserEnv) {
              localeConfig = me.locales[localeConfig.localeName];
              if (localeConfig) {
                delete localeConfig.localePath;
              }
            }
            triggerLocaleEvent();
            resolve(localeConfig);
          });
        }).catch((response) => reject(response));
      });
    }
    triggerLocaleEvent();
    return localeConfig;
  }
  /**
   * Loads a locale using AjaxHelper {@link Core.helper.AjaxHelper#function-get-static} request.
   * @private
   * @param {String} path Path to locale file
   * @async
   */
  loadLocale(path) {
    return AjaxHelper.get(path);
  }
  /**
   * Specifies if {@link Core.localization.Localizable#function-L-static Localizable.L()} function would throw error if no localization found at runtime.
   *
   * @member {Boolean} throwOnMissingLocale
   * @default false
   */
  set throwOnMissingLocale(value) {
    this._throwOnMissingLocale = value;
  }
  get throwOnMissingLocale() {
    return this._throwOnMissingLocale;
  }
};
var LocaleManagerSingleton = new LocaleManager();
var LocaleManager_default = LocaleManagerSingleton;

// ../Core/lib/Core/localization/Localizable.js
var ObjectProto = Object.getPrototypeOf(Object);
var localeRe = /L{.*?}/g;
var capturelocaleRe = /L{(.*?)}/g;
var classMatchRe = /((.*?)\.)?(.+)/g;
var escape2 = (txt) => txt.replace(/{(\d+)}/gm, "[[$1]]");
var unescape = (txt) => txt.replace(/\[\[(\d+)]]/gm, "{$1}");
var emptyObject3 = Object.freeze(/* @__PURE__ */ Object.create(null));
var Localizable_default = (Target) => class Localizable extends (Target || Base) {
  static get $name() {
    return "Localizable";
  }
  static get configurable() {
    return {
      /**
       * A class translations of which are used for translating this entity.
       * This is often used when translations of an item are defined on its container class.
       * For example:
       *
       * ```js
       * // Toolbar class that has some predefined items
       * class MyToolbar extends Toolbar {
       *
       *     static get $name() {
       *         return 'MyToolbar';
       *     }
       *
       *     static get defaultConfig() {
       *         return {
       *             // this specifies default configs for the items
       *             defaults : {
       *                 // will tell items to use the toolbar locale
       *                 localeClass : this
       *             },
       *
       *             items : [
       *                 // The toolbar has 2 buttons and translation for their texts will be searched in
       *                 // the toolbar locales
       *                 { text : 'Agree' },
       *                 { text : 'Disagree' }
       *             ]
       *         };
       *     }
       *
       *    ...
       * }
       * ```
       * So if one makes a locale for the `MyToolbar` class that will include `Agree` and `Disagree` string translations:
       * ```js
       *     ...
       *     MyToolbar : {
       *         Agree    : 'Yes, I agree',
       *         Disagree : 'No, I do not agree'
       *     }
       * ```
       * They will be used for the toolbar buttons and the button captions will say `Yes, I agree` and `No, I do not agree`.
       *
       * @config {Core.Base}
       * @typings {typeof Base}
       * @category Misc
       * @advanced
       */
      localeClass: null,
      /**
       * Set to `false` to disable localization of this object.
       * @config {Boolean}
       * @default true
       * @category Misc
       * @advanced
       */
      localizable: null,
      /**
       * List of properties which values should be translated automatically upon a locale applying.
       * In case there is a need to localize not typical value (not a String value or a field with re-defined setter/getter),
       * you could use 'localeKey' meta configuration.
       * Example:
       * ```js
       *  static get configurable() {
       *     return {
       *          localizableProperties : ['width'],
       *
       *          width : {
       *              value   : '54em', // default value here
       *              $config : {
       *                  localeKey : 'L{editorWidth}' // name of the property that will be used in localization file
       *              }
       *          }
       *      };
       *  }
       * ```
       * @config {String[]}
       * @category Misc
       * @advanced
       */
      localizableProperties: {
        value: [],
        $config: {
          merge: "distinct"
        }
      }
    };
  }
  static clsName(cls) {
    var _a2, _b;
    return typeof cls === "string" ? cls : cls === ObjectProto ? "Object" : cls.$$name || cls.name || ((_a2 = cls.prototype) == null ? void 0 : _a2.$$name) || ((_b = cls.prototype) == null ? void 0 : _b.name);
  }
  static parseLocaleString(text) {
    const matches = [];
    let m;
    if (text == null ? void 0 : text.includes("L{")) {
      text = escape2(text);
      capturelocaleRe.lastIndex = 0;
      while ((m = capturelocaleRe.exec(text)) != null) {
        classMatchRe.lastIndex = 0;
        const classMatch = classMatchRe.exec(m[1]);
        matches.push({
          match: unescape(m[0]),
          localeKey: unescape(classMatch[3]),
          localeClass: classMatch[2]
        });
      }
    }
    return matches.length > 0 ? matches : [{
      match: text,
      localeKey: text,
      localeClass: void 0
    }];
  }
  construct(config = {}, ...args) {
    super.construct(config, ...args);
    LocaleManager_default.ion({ locale: "updateLocalization", thisObj: this });
    this.updateLocalization();
  }
  get localeClass() {
    return this._localeClass || null;
  }
  localizeProperty(property) {
    var _a2, _b, _c;
    const me = this, currentValue = Objects.getPath(me, property), localeKey = ((_a2 = me.$meta.configs[property]) == null ? void 0 : _a2.localeKey) || ((_c = (_b = me.fieldMap) == null ? void 0 : _b[property]) == null ? void 0 : _c.defaultValue);
    let localizedValue;
    if (localeKey) {
      localizedValue = Localizable.localize(localeKey, me, me.localeClass || me);
      if (localizedValue && !(property in (me.initialConfig || emptyObject3))) {
        Objects.setPath(me.isColumn ? me.data : me, property, localizedValue);
      }
    } else if (typeof currentValue === "string") {
      me.originalLocales = me.originalLocales || {};
      localizedValue = Objects.getPath(me.originalLocales, property);
      if (localizedValue === void 0) {
        Objects.setPath(me.originalLocales, property, currentValue);
        localizedValue = currentValue;
      }
      if (localizedValue) {
        Objects.setPath(me, property, localizedValue = me.optionalL(localizedValue, me));
      }
    }
    return localizedValue || currentValue;
  }
  /**
   * Method that is triggered when applying a locale to the instance
   * (happens on the instance construction steps and when switching to another locale).
   *
   * The method can be overridden to dynamically translate the instance when locale is switched.
   * When overriding the method please make sure you call `super.updateLocalization()`.
   * @category Misc
   * @advanced
   */
  updateLocalization() {
    var _a2, _b;
    if (this.localizable !== false) {
      (_a2 = this.localizableProperties) == null ? void 0 : _a2.forEach(this.localizeProperty, this);
      (_b = this.trigger) == null ? void 0 : _b.call(this, "localized");
    }
  }
  static getTranslation(text, templateData, localeCls) {
    const locale4 = LocaleManager_default.locale;
    let result = null, clsName, cls;
    if (locale4) {
      for (const { match, localeKey, localeClass } of this.parseLocaleString(text)) {
        const translate = (clsName2) => {
          var _a2;
          const translation = (_a2 = locale4[clsName2]) == null ? void 0 : _a2[localeKey];
          if (translation) {
            if (typeof translation === "function") {
              result = templateData != null ? translation(templateData) : translation;
            } else if (typeof translation === "object" || text === match) {
              result = translation;
            } else {
              result = (result || text).replace(match, translation);
            }
            if (typeof translation === "string" && translation.includes("L{")) {
              result = this.getTranslation(translation, templateData, localeCls);
            }
          }
          return translation;
        };
        let success2 = false;
        for (cls = localeCls; cls && (clsName = Localizable.clsName(cls)); cls = Object.getPrototypeOf(cls)) {
          if (success2 = translate(clsName)) {
            break;
          } else if (typeof cls === "string") {
            break;
          }
        }
        if (!success2 && localeClass) {
          translate(localeClass);
        }
      }
    }
    return result;
  }
  /**
   * Get localized string, returns `null` if no localized string found.
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @internal
   */
  static localize(text, templateData = void 0, ...localeClasses) {
    if ((localeClasses == null ? void 0 : localeClasses.length) === 0) {
      localeClasses = [this];
    }
    let translation = null;
    localeClasses.some((cls) => {
      translation = Localizable.getTranslation(text, templateData, cls);
      return translation != null;
    });
    return translation;
  }
  /**
   * Get localized string, returns value of `text` if no localized string found.
   *
   * If {@link Core.localization.LocaleManager#property-throwOnMissingLocale LocaleManager.throwOnMissingLocale}
   * is `true` then calls to `L()` will throw `Localization is not found for 'text' in 'ClassName'` exception when no
   * localization is found.
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @static
   * @returns {String}
   * @advanced
   */
  static L(text, templateData = void 0, ...localeClasses) {
    if ((localeClasses == null ? void 0 : localeClasses.length) === 0) {
      localeClasses = [this];
    }
    const translation = this.localize(text, templateData, ...localeClasses);
    if (translation == null && LocaleManager_default.throwOnMissingLocale && text.includes("L{")) {
      throw new Error(`Localization is not found for '${text}' in '${localeClasses.map((cls) => Localizable.clsName(cls)).join(", ")}'. ${LocaleManager_default.locale.localeName ? `Locale : ${LocaleManager_default.locale.localeName}` : ""}`);
    }
    return translation != null ? translation : text;
  }
  /**
   * Convenience function that can be called directly on the class that mixes Localizable in
   *
   * ```javascript
   * button.text = grid.L('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @category Misc
   * @advanced
   */
  L(text, templateData) {
    const { localeClass, constructor } = this;
    if (localeClass && Localizable.clsName(localeClass) !== Localizable.clsName(constructor)) {
      return Localizable.L(text, templateData, localeClass, constructor);
    } else {
      return Localizable.L(text, templateData, constructor);
    }
  }
  /**
   * Convenience function to get an optional translation. The difference compared to `L()` is that it won't throw
   * an error when the translation is missing even if configured with `throwOnMissingLocale`
   *
   * ```javascript
   * button.text = grid.optionalL('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @returns {String}
   * @static
   * @category Misc
   * @advanced
   */
  static optionalL(text, templateData = void 0, ...localeClasses) {
    const shouldThrow = LocaleManager_default.throwOnMissingLocale;
    LocaleManager_default.throwOnMissingLocale = shouldThrow && localeRe.test(text);
    if ((localeClasses == null ? void 0 : localeClasses.length) === 0) {
      localeClasses = [this];
    }
    const result = Localizable.L(text, templateData, ...localeClasses);
    LocaleManager_default.throwOnMissingLocale = shouldThrow;
    return result;
  }
  /**
   * Convenience function to get an optional translation. The difference compared to `L()` is that it won't throw
   * an error when the translation is missing even if configured with `throwOnMissingLocale`
   *
   * ```javascript
   * button.text = grid.optionalL('L{group}');
   * ```
   *
   * @param {String} text String key
   * @param {Object} [templateData] Data to supply to template if localized string is a function
   * @param {Boolean} [preventThrow] Prevent throwing error even if localized text matches `L{foo}`
   * @returns {String}
   * @category Misc
   * @internal
   */
  optionalL(text, templateData = this, preventThrow = false) {
    const shouldThrow = LocaleManager_default.throwOnMissingLocale;
    LocaleManager_default.throwOnMissingLocale = shouldThrow && localeRe.test(text) && !preventThrow;
    const result = this.L(text, templateData);
    LocaleManager_default.throwOnMissingLocale = shouldThrow;
    return result;
  }
  /**
   * Get the global LocaleManager
   * @property {Core.localization.LocaleManager}
   * @typings {typeof LocaleManager}
   * @category Misc
   * @readonly
   * @advanced
   */
  get localeManager() {
    return LocaleManager_default;
  }
  /**
   * Get the global LocaleHelper
   * @property {Core.localization.LocaleHelper}
   * @typings {typeof LocaleHelper}
   * @category Misc
   * @readonly
   * @advanced
   */
  get localeHelper() {
    return LocaleHelper;
  }
};

// ../Core/lib/Core/localization/En.js
var locale = {
  localeName: "En",
  localeDesc: "English (US)",
  localeCode: "en-US",
  Object: {
    Yes: "Yes",
    No: "No",
    Cancel: "Cancel",
    Ok: "OK",
    Week: "Week",
    None: "None"
  },
  ColorPicker: {
    noColor: "No color"
  },
  Combo: {
    noResults: "No results",
    recordNotCommitted: "Record could not be added",
    addNewValue: (value) => `Add ${value}`
  },
  FilePicker: {
    file: "File"
  },
  Field: {
    badInput: "Invalid field value",
    patternMismatch: "Value should match a specific pattern",
    rangeOverflow: (value) => `Value must be less than or equal to ${value.max}`,
    rangeUnderflow: (value) => `Value must be greater than or equal to ${value.min}`,
    stepMismatch: "Value should fit the step",
    tooLong: "Value should be shorter",
    tooShort: "Value should be longer",
    typeMismatch: "Value is required to be in a special format",
    valueMissing: "This field is required",
    invalidValue: "Invalid field value",
    minimumValueViolation: "Minimum value violation",
    maximumValueViolation: "Maximum value violation",
    fieldRequired: "This field is required",
    validateFilter: "Value must be selected from the list"
  },
  DateField: {
    invalidDate: "Invalid date input"
  },
  DatePicker: {
    gotoPrevYear: "Go to previous year",
    gotoPrevMonth: "Go to previous month",
    gotoNextMonth: "Go to next month",
    gotoNextYear: "Go to next year"
  },
  NumberFormat: {
    locale: "en-US",
    currency: "USD"
  },
  DurationField: {
    invalidUnit: "Invalid unit"
  },
  TimeField: {
    invalidTime: "Invalid time input"
  },
  TimePicker: {
    hour: "Hour",
    minute: "Minute",
    second: "Second"
  },
  List: {
    loading: "Loading...",
    selectAll: "Select All"
  },
  GridBase: {
    loadMask: "Loading...",
    syncMask: "Saving changes, please wait..."
  },
  PagingToolbar: {
    firstPage: "Go to first page",
    prevPage: "Go to previous page",
    page: "Page",
    nextPage: "Go to next page",
    lastPage: "Go to last page",
    reload: "Reload current page",
    noRecords: "No records to display",
    pageCountTemplate: (data) => `of ${data.lastPage}`,
    summaryTemplate: (data) => `Displaying records ${data.start} - ${data.end} of ${data.allCount}`
  },
  PanelCollapser: {
    Collapse: "Collapse",
    Expand: "Expand"
  },
  Popup: {
    close: "Close"
  },
  UndoRedo: {
    Undo: "Undo",
    Redo: "Redo",
    UndoLastAction: "Undo last action",
    RedoLastAction: "Redo last undone action",
    NoActions: "No items in the undo queue"
  },
  FieldFilterPicker: {
    equals: "equals",
    doesNotEqual: "does not equal",
    isEmpty: "empty",
    isNotEmpty: "not empty",
    contains: "contains",
    doesNotContain: "does not contain",
    startsWith: "starts with",
    endsWith: "ends with",
    isOneOf: "one of",
    isNotOneOf: "not one of",
    isGreaterThan: "greater than",
    isLessThan: "less than",
    isGreaterThanOrEqualTo: "greater or equals",
    isLessThanOrEqualTo: "less or equals",
    isBetween: "between",
    isNotBetween: "not between",
    isBefore: "before",
    isAfter: "after",
    isToday: "today",
    isTomorrow: "tomorrow",
    isYesterday: "yesterday",
    isThisWeek: "this week",
    isNextWeek: "next week",
    isLastWeek: "last week",
    isThisMonth: "this month",
    isNextMonth: "next month",
    isLastMonth: "last month",
    isThisYear: "this year",
    isNextYear: "next year",
    isLastYear: "last year",
    isYearToDate: "year to date",
    isTrue: "true",
    isFalse: "false",
    selectAProperty: "Select property",
    selectAnOperator: "Select operator",
    caseSensitive: "Case-sensitive",
    and: "and",
    dateFormat: "D/M/YY",
    selectValue: "Select value",
    selectOneOrMoreValues: "Select value(s)",
    enterAValue: "Enter value",
    enterANumber: "Enter number",
    selectADate: "Select date",
    selectATime: "Select time"
  },
  FieldFilterPickerGroup: {
    addFilter: "Add filter"
  },
  DateHelper: {
    locale: "en-US",
    weekStartDay: 0,
    nonWorkingDays: {
      0: true,
      6: true
    },
    weekends: {
      0: true,
      6: true
    },
    unitNames: [
      { single: "millisecond", plural: "ms", abbrev: "ms" },
      { single: "second", plural: "seconds", abbrev: "s" },
      { single: "minute", plural: "minutes", abbrev: "min" },
      { single: "hour", plural: "hours", abbrev: "h" },
      { single: "day", plural: "days", abbrev: "d" },
      { single: "week", plural: "weeks", abbrev: "w" },
      { single: "month", plural: "months", abbrev: "mon" },
      { single: "quarter", plural: "quarters", abbrev: "q" },
      { single: "year", plural: "years", abbrev: "yr" },
      { single: "decade", plural: "decades", abbrev: "dec" }
    ],
    unitAbbreviations: [
      ["mil"],
      ["s", "sec"],
      ["m", "min"],
      ["h", "hr"],
      ["d"],
      ["w", "wk"],
      ["mo", "mon", "mnt"],
      ["q", "quar", "qrt"],
      ["y", "yr"],
      ["dec"]
    ],
    parsers: {
      L: "MM/DD/YYYY",
      LT: "HH:mm A",
      LTS: "HH:mm:ss A"
    },
    ordinalSuffix: (number) => {
      const hasSpecialCase = ["11", "12", "13"].find((n) => number.endsWith(n));
      let suffix = "th";
      if (!hasSpecialCase) {
        const lastDigit = number[number.length - 1];
        suffix = { 1: "st", 2: "nd", 3: "rd" }[lastDigit] || "th";
      }
      return number + suffix;
    }
  }
};
var En_default = LocaleHelper.publishLocale(locale);

// ../Core/lib/Core/helper/DateHelper.js
var { toString: toString3 } = Object.prototype;
var DATE_TYPE2 = toString3.call(/* @__PURE__ */ new Date());
var tempDate = /* @__PURE__ */ new Date();
var MS_PER_HOUR = 1e3 * 60 * 60;
var defaultValue = (value, defValue) => isNaN(value) || value == null ? defValue : value;
var rangeFormatPartRe = /([ES]){([^}]+)}/g;
var enOrdinalSuffix = (number) => {
  const hasSpecialCase = ["11", "12", "13"].find((n) => number.endsWith(n));
  let suffix = "th";
  if (!hasSpecialCase) {
    const lastDigit = number[number.length - 1];
    suffix = { 1: "st", 2: "nd", 3: "rd" }[lastDigit] || "th";
  }
  return number + suffix;
};
var useIntlFormat = (name, options, date) => {
  const formatter = intlFormatterCache[name] || (intlFormatterCache[name] = new Intl.DateTimeFormat(locale2, options));
  return formatter.format(date);
};
var formatTime = (name, options, date, isShort = false) => {
  let strTime = useIntlFormat(name, options, date);
  if (/am|pm/i.test(strTime)) {
    strTime = strTime.replace(/^0/, "");
    if (isShort) {
      strTime = strTime.replace(/:00/, "");
    }
  }
  return strTime;
};
var getDayDiff = (end, start) => Math.floor((end.getTime() - start.getTime() - (end.getTimezoneOffset() - start.getTimezoneOffset()) * validConversions.minute.millisecond) / validConversions.day.millisecond) + 1;
var normalizeDay = (day2) => day2 >= 0 ? day2 : day2 + 7;
var msRegExp = /([^\w])(S+)/gm;
var msReplacer = (match, g1) => g1 + "SSS";
var splitRegExp = /[:.\-/\s]/;
var locale2 = "en-US";
var ordinalSuffix = enOrdinalSuffix;
var formatCache = {};
var formatRedirects = {};
var intlFormatterCache = {};
var parserCache = {};
var redirectFormat = (format2) => {
  const intlConfig = intlFormatConfigs[format2];
  if (!intlConfig) {
    throw new Error("Only international formats should be used here");
  }
  if (formatRedirects[format2] !== void 0) {
    return formatRedirects[format2];
  }
  const intl = new Intl.DateTimeFormat(locale2, intlConfig), fmt = intl.formatToParts(new Date(2001, 1, 2, 3, 4, 5, 6)).map((part) => {
    const type = part.type, intlCfg = intlConfig[type];
    if (type === "literal") {
      return part.value.replace(/,/g, "");
    } else if (type === "day") {
      return intlCfg === "numeric" ? "D" : "DD";
    } else if (type === "month") {
      return intlCfg === "short" ? "MMM" : intlCfg === "long" ? "MMMM" : intlCfg === "numeric" ? "M" : "MM";
    } else if (type === "year") {
      return intlCfg === "numeric" ? "YYYY" : "YY";
    }
  }).join("");
  return formatRedirects[format2] = fmt;
};
var DEFAULT_YEAR = 2020;
var DEFAULT_MONTH = 0;
var DEFAULT_DAY = 1;
var intlFormatConfigs = {
  l: { year: "numeric", month: "numeric", day: "numeric" },
  ll: { year: "numeric", month: "short", day: "numeric" }
};
var formats = {
  // 1, 2, ... 11, 12
  M: (date) => date.getMonth() + 1,
  //date.toLocaleDateString(locale, { month : 'numeric' }),
  // 1st, 2nd, 3rd, 4th, ... 11th, 12th
  Mo: (date) => ordinalSuffix(formats.M(date).toString()),
  // 01, 02, ...
  MM: (date) => (date.getMonth() + 1).toString().padStart(2, "0"),
  //date.toLocaleDateString(locale, { month : '2-digit' }),
  // Jan, Feb, ...
  MMM: (date) => useIntlFormat("MMM", { month: "short" }, date),
  // January, February, ...
  MMMM: (date) => useIntlFormat("MMMM", { month: "long" }, date),
  // 1, 2, ...
  Q: (date) => Math.ceil((date.getMonth() + 1) / 3),
  // 1st, 2nd, ...
  Qo: (date) => ordinalSuffix(formats.Q(date).toString()),
  // 1, 2, ...
  D: (date) => date.getDate(),
  //date.toLocaleDateString(locale, { day : 'numeric' }),
  // 1st, 2nd, ...
  Do: (date) => ordinalSuffix(formats.D(date).toString()),
  // 01, 02, ...
  DD: (date) => date.getDate().toString().padStart(2, "0"),
  //date.toLocaleDateString(locale, { day : '2-digit' }),
  // 1, 2, ..., 365, 365
  DDD: (date) => Math.ceil(
    (new Date(date.getFullYear(), date.getMonth(), date.getDate(), 12, 0, 0) - new Date(date.getFullYear(), 0, 0, 12, 0, 0)) / validConversions.day.millisecond
  ),
  // 1st, 2nd, ...
  DDDo: (date) => ordinalSuffix(formats.DDD(date).toString()),
  // 001, 002, ...
  DDDD: (date) => formats.DDD(date).toString().padStart(3, "0"),
  // 0, 1, ..., 6
  d: (date) => date.getDay(),
  // 0th, 1st, ...
  do: (date) => ordinalSuffix(date.getDay().toString()),
  // S, M, ...
  d1: (date) => useIntlFormat("d1", { weekday: "narrow" }, date).substr(0, 1),
  // Su, Mo, ...
  dd: (date) => formats.ddd(date).substring(0, 2),
  // Sun, Mon, ...
  ddd: (date) => useIntlFormat("ddd", { weekday: "short" }, date),
  // Sunday, Monday, ...
  dddd: (date) => useIntlFormat("dddd", { weekday: "long" }, date),
  u: (date) => {
    const formatter = intlFormatterCache.u || (intlFormatterCache.u = new Intl.DateTimeFormat("en-GB", {
      timeZone: "UTC",
      year: "numeric",
      month: "2-digit",
      day: "2-digit"
    })), parts = formatter.formatToParts(date);
    return `${parts[4].value}${parts[2].value}${parts[0].value}Z`;
  },
  uu: (date) => {
    const formatter = intlFormatterCache.uu || (intlFormatterCache.uu = new Intl.DateTimeFormat("en-GB", {
      timeZone: "UTC",
      hour12: false,
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit"
    })), parts = formatter.formatToParts(date);
    return `${parts[4].value}${parts[2].value}${parts[0].value}T${parts[6].value}${parts[8].value}${parts[10].value}Z`;
  },
  e: (date) => date.getDay(),
  E: (date) => date.getDay() + 1,
  // ISO week, 1, 2, ...
  W: (date) => DateHelper.getWeekNumber(date)[1],
  Wo: (date) => ordinalSuffix(formats.W(date).toString()),
  WW: (date) => formats.W(date).toString().padStart(2, "0"),
  // ISO week, 1, 2, ... with localized 'Week ' prefix
  Wp: (date) => `${DateHelper.localize("L{Week}")} ${formats.W(date)}`,
  WWp: (date) => `${DateHelper.localize("L{Week}")} ${formats.WW(date)}`,
  Wp0: (date) => `${DateHelper.localize("L{Week}")[0]}${formats.W(date)}`,
  WWp0: (date) => `${DateHelper.localize("L{Week}")[0]}${formats.WW(date)}`,
  // 1979, 2018
  Y: (date) => date.getFullYear(),
  //date.toLocaleDateString(locale, { year : 'numeric' }),
  // 79, 18
  YY: (date) => (date.getFullYear() % 100).toString().padStart(2, "0"),
  //date.toLocaleDateString(locale, { year : '2-digit' }),
  // 1979, 2018
  YYYY: (date) => date.getFullYear(),
  //date.toLocaleDateString(locale, { year : 'numeric' }),
  // AM, PM
  A: (date) => date.getHours() < 12 ? "AM" : "PM",
  a: (date) => date.getHours() < 12 ? "am" : "pm",
  // 0, 1, ... 23
  H: (date) => date.getHours(),
  // 00, 01, ...
  HH: (date) => date.getHours().toString().padStart(2, "0"),
  // 1, 2, ... 12
  h: (date) => date.getHours() % 12 || 12,
  // 01, 02, ...
  hh: (date) => formats.h(date).toString().padStart(2, "0"),
  // 1, 2, ... 24
  k: (date) => date.getHours() || 24,
  // 01, 02, ...
  kk: (date) => formats.k(date).toString().padStart(2, "0"),
  // Locale specific (0 -> 24 or 1 AM -> 12 PM)
  K: (date) => formatTime("K", { hour: "numeric" }, date),
  // Locale specific (00 -> 24 or 1 AM -> 12 PM)
  KK: (date) => formatTime("KK", { hour: "2-digit" }, date),
  // 0, 1, ... 59
  m: (date) => date.getMinutes(),
  //date.toLocaleTimeString(locale, { minute : 'numeric' }),
  // 00, 01, ...
  mm: (date) => formats.m(date).toString().padStart(2, "0"),
  // 0, 1, ... 59
  s: (date) => date.getSeconds(),
  //date.toLocaleTimeString(locale, { second : 'numeric' }),
  // 00, 01, ...
  ss: (date) => formats.s(date).toString().padStart(2, "0"),
  // 0, 1, ... 9 which are 000, 100, 200 ... 900 in milliseconds
  S: (date) => Math.floor(date.getMilliseconds() / 100).toString(),
  // 00, 01, ... 99 which are 000, 010, 020 ... 990 in milliseconds
  SS: (date) => Math.floor(date.getMilliseconds() / 10).toString().padStart(2, "0"),
  // 000, 001, ... 999 in milliseconds
  SSS: (date) => date.getMilliseconds().toString().padStart(3, "0"),
  z: (date) => useIntlFormat("z", { timeZoneName: "short" }, date),
  zz: (date) => useIntlFormat("zz", { timeZoneName: "long" }, date),
  Z: (date) => DH.getGMTOffset(date),
  LT: (date) => formatTime("LT", { hour: "2-digit", minute: "2-digit" }, date),
  // if minutes is 0, doesn't show it
  LST: (date) => formatTime("LST", { hour: "numeric", minute: "2-digit" }, date, true),
  LTS: (date) => formatTime("LTS", { hour: "2-digit", minute: "2-digit", second: "2-digit" }, date),
  L: (date) => useIntlFormat("L", { year: "numeric", month: "2-digit", day: "2-digit" }, date),
  l: (date) => useIntlFormat("l", intlFormatConfigs.l, date),
  LL: (date) => useIntlFormat("LL", { year: "numeric", month: "long", day: "numeric" }, date),
  ll: (date) => useIntlFormat("ll", intlFormatConfigs.ll, date),
  LLL: (date) => useIntlFormat("LLL", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  }, date),
  lll: (date) => useIntlFormat("lll", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit"
  }, date),
  LLLL: (date) => useIntlFormat("LLLL", {
    year: "numeric",
    month: "long",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    weekday: "long"
  }, date),
  llll: (date) => useIntlFormat("llll", {
    year: "numeric",
    month: "short",
    day: "numeric",
    hour: "numeric",
    minute: "2-digit",
    weekday: "short"
  }, date)
};
var formatKeys = Object.keys(formats).sort((a, b) => b.length - a.length);
var formatRegexp = `^(?:${formatKeys.join("|")})`;
var emptyFn2 = () => ({});
var isNumber = (str) => numberRegex.test(str);
var parseMilliseconds = (str) => isNumber(str) && { milliseconds: parseInt(str.padEnd(3, "0").substring(0, 3)) };
var parsers = {
  YYYY: (str) => {
    const year = parseInt(str);
    return { year: year >= 1e3 && year <= 9999 ? year : NaN };
  },
  Y: (str) => ({ year: parseInt(str) }),
  YY: (str) => {
    const year = parseInt(str);
    return { year: year + (year > 1968 ? 1900 : 2e3) };
  },
  M: (str) => ({ month: parseInt(str) - 1 }),
  MM: (str) => ({ month: parseInt(str) - 1 }),
  Mo: (str) => ({ month: parseInt(str) - 1 }),
  MMM: (str) => {
    const month2 = (str || "").toLowerCase();
    for (const [name, entry] of Object.entries(DateHelper._monthShortNamesIndex)) {
      if (month2.startsWith(name)) {
        return { month: entry.value };
      }
    }
  },
  MMMM: (str) => {
    const month2 = (str || "").toLowerCase();
    for (const [name, entry] of Object.entries(DateHelper._monthNamesIndex)) {
      if (month2.startsWith(name)) {
        return { month: entry.value };
      }
    }
  },
  DD: (str) => ({ date: parseInt(str) }),
  D: (str) => ({ date: parseInt(str) }),
  Do: (str) => ({ date: parseInt(str) }),
  DDD: emptyFn2,
  DDDo: emptyFn2,
  DDDD: emptyFn2,
  d: emptyFn2,
  do: emptyFn2,
  d1: emptyFn2,
  dd: emptyFn2,
  ddd: emptyFn2,
  dddd: emptyFn2,
  Q: emptyFn2,
  Qo: emptyFn2,
  W: emptyFn2,
  Wo: emptyFn2,
  WW: emptyFn2,
  e: emptyFn2,
  E: emptyFn2,
  HH: (str) => ({ hours: parseInt(str) }),
  hh: (str) => ({ hours: parseInt(str) }),
  mm: (str) => ({ minutes: parseInt(str) }),
  H: (str) => ({ hours: parseInt(str) }),
  m: (str) => ({ minutes: parseInt(str) }),
  ss: (str) => ({ seconds: parseInt(str) }),
  s: (str) => ({ seconds: parseInt(str) }),
  S: parseMilliseconds,
  SS: parseMilliseconds,
  SSS: parseMilliseconds,
  A: (str) => ({ amPm: str.toLowerCase() }),
  a: (str) => ({ amPm: str.toLowerCase() }),
  L: "MM/DD/YYYY",
  LT: "HH:mm A",
  LTS: "HH:mm:ss A",
  l: { type: "dynamic", parser: () => redirectFormat("l") },
  ll: { type: "dynamic", parser: () => redirectFormat("ll") },
  // Can either be Z (=UTC, 0) or +-HH:MM
  Z: (str) => {
    if (!str || !timeZoneRegEx.test(str) && str !== "Z") {
      return null;
    }
    let timeZone = 0;
    if (str !== "Z") {
      const matches = timeZoneRegEx.exec(str);
      if (matches) {
        const sign = matches[1] === "+" ? 1 : -1, hours = parseInt(matches[2]) || 0, minutes = parseInt(matches[3]) || 0;
        timeZone = sign * (hours * 60 + minutes);
      } else {
        timeZone = -1 * (/* @__PURE__ */ new Date()).getTimezoneOffset();
      }
    }
    return { timeZone };
  }
};
var parserKeys = Object.keys(parsers).sort((a, b) => b.length - a.length);
var parserRegexp = new RegExp(`(${parserKeys.join("|")})`);
var localeStrRegExp = new RegExp("^(LL|LLL|lll|LLLL|llll)$");
var validConversions = {
  // The units below assume:
  // 30 days in a month, 91 days for a quarter and 365 for a year
  // 52 weeks per year, 4 per month, 13 per quarter
  // 3652 days per decade (assuming two of the years will be leap with 366 days)
  decade: {
    decade: 1,
    year: 10,
    quarter: 40,
    month: 120,
    week: 520,
    day: 3652,
    hour: 24 * 3652,
    minute: 1440 * 3652,
    second: 86400 * 3652,
    millisecond: 864e5 * 3652
  },
  year: {
    decade: 0.1,
    year: 1,
    quarter: 4,
    month: 12,
    week: 52,
    day: 365,
    hour: 24 * 365,
    minute: 1440 * 365,
    second: 86400 * 365,
    millisecond: 864e5 * 365
  },
  quarter: {
    decade: 1 / 40,
    year: 1 / 4,
    quarter: 1,
    month: 3,
    week: 4,
    day: 91,
    hour: 24 * 91,
    minute: 1440 * 91,
    second: 86400 * 91,
    millisecond: 864e5 * 91
  },
  month: {
    decade: 1 / 120,
    year: 1 / 12,
    quarter: 1 / 3,
    month: 1,
    week: 4,
    day: -30,
    hour: -24 * 30,
    minute: -1440 * 30,
    second: -86400 * 30,
    millisecond: -864e5 * 30
  },
  week: {
    decade: -1 / 520,
    year: -1 / 52,
    quarter: -1 / 13,
    month: -1 / 4,
    day: 7,
    hour: 168,
    minute: 10080,
    second: 604800,
    millisecond: 6048e5
  },
  day: {
    decade: -1 / 3652,
    year: -1 / 365,
    quarter: -1 / 91,
    month: -1 / 30,
    week: 1 / 7,
    hour: 24,
    minute: 1440,
    second: 86400,
    millisecond: 864e5
  },
  hour: {
    decade: -1 / (3652 * 24),
    year: -1 / (365 * 24),
    quarter: -1 / (91 * 24),
    month: -1 / (30 * 24),
    week: 1 / 168,
    day: 1 / 24,
    minute: 60,
    second: 3600,
    millisecond: 36e5
  },
  minute: {
    decade: -1 / (3652 * 1440),
    year: -1 / (365 * 1440),
    quarter: -1 / (91 * 1440),
    month: -1 / (30 * 1440),
    week: 1 / 10080,
    day: 1 / 1440,
    hour: 1 / 60,
    second: 60,
    millisecond: 6e4
  },
  second: {
    decade: -1 / (3652 * 86400),
    year: -1 / (365 * 86400),
    quarter: -1 / (91 * 86400),
    month: -1 / (30 * 86400),
    week: 1 / 604800,
    day: 1 / 86400,
    hour: 1 / 3600,
    minute: 1 / 60,
    millisecond: 1e3
  },
  millisecond: {
    decade: -1 / (3652 * 864e5),
    year: -1 / (365 * 864e5),
    quarter: -1 / (91 * 864e5),
    month: -1 / (30 * 864e5),
    week: 1 / 6048e5,
    day: 1 / 864e5,
    hour: 1 / 36e5,
    minute: 1 / 6e4,
    second: 1 / 1e3
  }
};
var normalizedUnits = {
  ms: "millisecond",
  milliseconds: "millisecond",
  s: "second",
  seconds: "second",
  m: "minute",
  mi: "minute",
  min: "minute",
  minutes: "minute",
  h: "hour",
  hours: "hour",
  d: "day",
  days: "day",
  w: "week",
  weeks: "week",
  M: "month",
  mo: "month",
  mon: "month",
  months: "month",
  q: "quarter",
  quarters: "quarter",
  y: "year",
  years: "year",
  dec: "decade",
  decades: "decade"
};
var withDecimalsDurationRegex = /^\s*([-+]?\d+(?:[.,]\d*)?|[-+]?(?:[.,]\d+))\s*([^\s]+)?/i;
var noDecimalsDurationRegex = /^\s*([-+]?\d+)(?![.,])\s*([^\s]+)?/i;
var canonicalUnitNames = [
  "millisecond",
  "second",
  "minute",
  "hour",
  "day",
  "week",
  "month",
  "quarter",
  "year",
  "decade"
];
var canonicalUnitAbbreviations = [
  ["mil"],
  ["s", "sec"],
  ["m", "min"],
  ["h", "hr"],
  ["d"],
  ["w", "wk"],
  ["mo", "mon", "mnt"],
  ["q", "quar", "qrt"],
  ["y", "yr"],
  ["dec"]
];
var deltaUnits = [
  "decade",
  "year",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
var dateProperties = [
  "milliseconds",
  "seconds",
  "minutes",
  "hours",
  "date",
  "month",
  "year"
];
var parseNumber = (n) => {
  const result = parseFloat(n);
  return isNaN(result) ? null : result;
};
var numberRegex = /^[0-9]+$/;
var timeZoneRegEx = /([+-])(\d\d):*(\d\d)*$/;
var unitMagnitudes = {
  millisecond: 0,
  second: 1,
  minute: 2,
  hour: 3,
  day: 4,
  week: 5,
  month: 6,
  quarter: 7,
  year: 8,
  decade: 9
};
var snapFns = {
  round(number, step = 1) {
    return Math.round(number / step) * step;
  },
  floor(number, step = 1) {
    return Math.floor(number / step) * step;
  },
  ceil(number, step = 1) {
    return Math.ceil(number / step) * step;
  }
};
var keyCache = {};
var _DateHelper = class _DateHelper extends Localizable_default() {
  static get $name() {
    return "DateHelper";
  }
  //region Parse & format
  /**
   * Get/set the default format used by `format()` and `parse()`. Defaults to `'YYYY-MM-DDTHH:mm:ssZ'`
   * (~ISO 8601 Date and time, `'1962-06-17T09:21:34Z'`).
   * @member {String}
   */
  static set defaultFormat(format2) {
    DH._defaultFormat = format2;
  }
  static get defaultFormat() {
    return DH._defaultFormat || "YYYY-MM-DDTHH:mm:ssZ";
  }
  /**
   * Get/set the default format used by `parse()`. Defaults to `'YYYY-MM-DDTHH:mm:ss.SSSZ'` or {@link #property-defaultFormat-static}
   * (~ISO 8601 Date and time, `'1962-06-17T09:21:34.123Z'`).
   * @member {String}
   */
  static set defaultParseFormat(parseFormat) {
    this._defaultParseFormat = parseFormat;
  }
  static get defaultParseFormat() {
    return this._defaultParseFormat || this._defaultFormat || "YYYY-MM-DDTHH:mm:ss.SSSZ";
  }
  static buildParser(format2) {
    const parts = format2.split(parserRegexp), parser = [];
    if (parts.length === 1 || localeStrRegExp.test(format2)) {
      return [];
    } else {
      parts.reduce((prev, curr, index, array) => {
        if (index !== 0 || curr !== "") {
          if (parserRegexp.test(curr)) {
            const localeParsers = this.localize("L{parsers}") || {}, fn2 = localeParsers[curr] || parsers[curr];
            if (curr === "Z" && index < array.length - 2) {
              throw new Error(`Invalid format ${format2} TimeZone (Z) must be last token`);
            }
            const parserObj = typeof fn2 === "function" || typeof fn2 === "string" ? fn2 : fn2.parser();
            if (typeof parserObj === "string") {
              const nestedParsers = DH.buildParser(parserObj), lastItem = nestedParsers.pop();
              delete lastItem.last;
              parser.push(...nestedParsers);
              prev = lastItem;
            } else {
              prev.pattern = curr;
              prev.fn = parserObj;
            }
          } else {
            prev.splitter = curr;
            parser.push(prev);
            prev = {};
          }
        } else if (Object.prototype.hasOwnProperty.call(prev, "pattern")) {
          parser.push(prev);
        }
        return prev;
      }, {});
    }
    parser[parser.length - 1].last = true;
    return parser;
  }
  /**
   * A utility function to create a sortable string key for the passed date or ms timestamp using the `'YYYY-MM-DD'`
   * format.
   * @param {Number|Date} ms The Date instance or ms timestamp to generate a key for
   * @returns {String} Date/timestamp as a string with `'YYYY-M-D'` format
   * @internal
   */
  static makeKey(ms) {
    if (ms.length === 10) {
      return ms;
    }
    if (ms.getTime) {
      ms = ms.getTime();
    }
    const cached = keyCache[Math.trunc(ms / MS_PER_HOUR)];
    if (cached) {
      return cached;
    }
    tempDate.setTime(ms);
    const month2 = tempDate.getMonth() + 1, date = tempDate.getDate();
    return keyCache[Math.trunc(ms / MS_PER_HOUR)] = `${tempDate.getFullYear()}-${month2 < 10 ? "0" + month2 : month2}-${date < 10 ? "0" + date : date}`;
  }
  /**
   * A utility function to parse a sortable string to a date using the `'YYYY-MM-DD'` format.
   * @param {String} key The string to return a date for
   * @returns {Date} new Date instance
   * @internal
   */
  static parseKey(key) {
    return DH.parse(key, "YYYY-MM-DD");
  }
  /**
   * Returns a date created from the supplied string using the specified format. Will try to create even if format
   * is left out, by first using the default format (see {@link #property-defaultFormat-static}, by default
   * `YYYY-MM-DDTHH:mm:ssZ`) and then using `new Date(dateString)`.
   * Supported tokens:
   *
   * | Unit        | Token | Description                       |
   * |-------------|-------|-----------------------------------|
   * | Year        | YYYY  | 2018                              |
   * |             | YY    | < 68 -> 2000, > 68 -> 1900        |
   * | Month       | MM    | 01 - 12                           |
   * | Date        | DD    | 01 - 31                           |
   * | Hour        | HH    | 00 - 23 or 1 - 12                 |
   * | Minute      | mm    | 00 - 59                           |
   * | Second      | ss    | 00 - 59                           |
   * | Millisecond | S     | 0 - 9 [000, 100, 200 .. 900 ]     |
   * |             | SS    | 00 - 99 [000, 010, 020 .. 990 ]   |
   * |             | SSS   | 000 - 999 [000, 001, 002 .. 999 ] |
   * | AM/PM       | A     | AM or PM                          |
   * |             | a     | am or pm                          |
   * | TimeZone    | Z     | Z for UTC or +-HH:mm              |
   * | Predefined  | L     | Long date, MM/DD/YYYY             |
   * |             | LT    | Long time, HH:mm A                |
   *
   * Predefined formats and functions used to parse tokens can be localized, see for example the swedish locale SvSE.js
   *
   * NOTE: If no date parameters are provided then `Jan 01 2020` is used as a default date
   *
   * @param {String} dateString Date string
   * @param {String} [format] Date format (or {@link #property-defaultParseFormat-static} if left out)
   * @returns {Date} new Date instance parsed from the string
   * @category Parse & format
   */
  static parse(dateString, format2 = DH.defaultParseFormat, strict = false) {
    if (dateString instanceof Date) {
      return dateString;
    }
    if (typeof dateString !== "string" || !dateString) {
      return null;
    }
    const config = {
      year: null,
      month: null,
      date: null,
      hours: null,
      minutes: null,
      seconds: null,
      milliseconds: null
    };
    format2 = format2.replace(msRegExp, msReplacer);
    let parser = parserCache[format2], result;
    if (!parser) {
      parser = parserCache[format2] = DH.buildParser(format2);
    }
    if (dateString.includes("\u202F")) {
      dateString = dateString.replace(/\s/g, " ");
    }
    parser.reduce((dateString2, parser2) => {
      var _a2;
      if (parser2.last) {
        Object.assign(config, parser2.fn(dateString2));
      } else {
        let splitAt;
        if (parser2.splitter === "T" && dateString2.indexOf("T") === -1) {
          splitAt = dateString2.indexOf(" ");
        } else {
          const timeZoneIndex = dateString2.indexOf("+");
          let { splitter } = parser2;
          if (!strict && splitRegExp.test(splitter)) {
            splitter = splitRegExp;
          }
          splitAt = parser2.splitter !== "" ? dateString2.search(typeof splitter === "string" ? StringHelper.escapeRegExp(splitter) : splitter) : ((_a2 = parser2.pattern) == null ? void 0 : _a2.length) || -1;
          if (timeZoneIndex > -1 && splitAt > timeZoneIndex) {
            splitAt = -1;
          }
        }
        let part, rest;
        if (splitAt === -1 || parser2.pattern === "SSS" && dateString2.match(/^\d+Z$/)) {
          const chunks = dateString2.split(/([Z\-+])/);
          if (chunks.length === 1) {
            part = dateString2;
            rest = "";
          } else {
            part = chunks[0];
            rest = `${chunks[1]}${chunks[2]}`;
          }
        } else {
          part = dateString2.substring(0, splitAt) || dateString2;
          rest = dateString2.substring(splitAt + parser2.splitter.length);
        }
        if (parser2.fn) {
          const res = parser2.fn(part);
          if (res) {
            Object.assign(config, res);
          } else {
            rest = part + rest;
          }
        }
        return rest;
      }
    }, dateString);
    if (config.year && !config.date) {
      config.date = 1;
    }
    if (config.date > 31 || config.month > 12) {
      return null;
    }
    const date = DH.create(config, strict);
    if (date) {
      result = date;
    } else if (!strict) {
      result = new Date(dateString);
    }
    return result;
  }
  /**
   * Creates a date from a date definition object. The object can have the following properties:
   * - year
   * - month
   * - date (day in month)
   * - hours
   * - minutes
   * - seconds
   * - milliseconds
   * - amPm : 'am' or 'pm', implies 12-hour clock
   * - timeZone : offset from UTC in minutes
   * @param {Object} definition
   * @param {Number} definition.year
   * @param {Number} [definition.month]
   * @param {Number} [definition.date]
   * @param {Number} [definition.hours]
   * @param {Number} [definition.minutes]
   * @param {Number} [definition.seconds]
   * @param {Number} [definition.milliseconds]
   * @param {Number} [definition.amPm]
   * @param {Number} [definition.timeZone]
   * @returns {Date} new Date instance
   * @category Parse & format
   */
  static create(definition, strict = false) {
    const def = { ...definition };
    let invalid = isNaN(def.year) || strict && (isNaN(def.month) || isNaN(def.date)), useUTC = false;
    if (!invalid) {
      let allNull = true;
      dateProperties.forEach((property) => {
        if (!(property in def) || isNaN(def[property])) {
          def[property] = 0;
        }
        allNull = allNull && def[property] === null;
      });
      invalid = allNull;
    }
    if (invalid) {
      return null;
    }
    if (def.amPm === "am") {
      def.hours = def.hours % 12;
    } else if (def.amPm === "pm") {
      def.hours = def.hours % 12 + 12;
    }
    if ("timeZone" in def) {
      useUTC = true;
      def.minutes -= def.timeZone;
    }
    if (strict && (def.year == null || def.month == null || def.date == null)) {
      return null;
    }
    const args = [
      defaultValue(def.year, DEFAULT_YEAR),
      defaultValue(def.month, DEFAULT_MONTH),
      defaultValue(def.date, DEFAULT_DAY),
      def.hours,
      def.minutes,
      def.seconds,
      def.milliseconds
    ];
    return useUTC ? new Date(Date.UTC(...args)) : new Date(...args);
  }
  static toUTC(date) {
    return new Date(Date.UTC(
      date.getUTCFullYear(),
      date.getUTCMonth(),
      date.getUTCDate(),
      date.getUTCHours(),
      date.getUTCMinutes(),
      date.getUTCSeconds(),
      date.getUTCMilliseconds()
    ));
  }
  /**
   * Converts a date to string with the specified format. Formats heavily inspired by https://momentjs.com.
   * Available formats (input used for output below is `new Date(2018,8,9,18,7,8,145)`):
   *
   * | Unit                  | Token | Description & output                  |
   * |-----------------------|-------|---------------------------------------|
   * | Year                  | YYYY  | 2018                                  |
   * |                       | YY    | 18                                    |
   * |                       | Y     | 2018                                  |
   * | Quarter               | Q     | 3                                     |
   * |                       | Qo    | 3rd                                   |
   * | Month                 | MMMM  | September                             |
   * |                       | MMM   | Sep                                   |
   * |                       | MM    | 09                                    |
   * |                       | Mo    | 9th                                   |
   * |                       | M     | 9                                     |
   * | Week (iso)            | WW    | 37 (2 digit, zero padded)             |
   * |                       | Wo    | 37th                                  |
   * |                       | W     | 37                                    |
   * |                       | WWp   | Week 37 (localized prefix, zero pad)  |
   * |                       | Wp    | Week 37 (localized prefix)            |
   * |                       | WWp0  | W37 (localized prefix)                |
   * |                       | Wp0   | W37 (localized prefix)                |
   * | Date                  | DDDD  | Day of year, 3 digits                 |
   * |                       | DDDo  | Day of year, ordinal                  |
   * |                       | DDD   | Day of year                           |
   * |                       | DD    | 09                                    |
   * |                       | Do    | 9th                                   |
   * |                       | D     | 9                                     |
   * | Weekday               | dddd  | Sunday                                |
   * |                       | ddd   | Sun                                   |
   * |                       | dd    | Su                                    |
   * |                       | d1    | S                                     |
   * |                       | do    | 0th                                   |
   * |                       | d     | 0                                     |
   * | Hour                  | HH    | 18 (00 - 23)                          |
   * |                       | H     | 18 (0 - 23)                           |
   * |                       | hh    | 06 (00 - 12)                          |
   * |                       | h     | 6 (0 - 12)                            |
   * |                       | KK    | 19 (01 - 24)                          |
   * |                       | K     | 19 (1 - 24)                           |
   * |                       | kk    | 06 or 18, locale determines           |
   * |                       | k     | 6 or 18, locale determines            |
   * | Minute                | mm    | 07                                    |
   * |                       | m     | 7                                     |
   * | Second                | ss    | 08                                    |
   * |                       | s     | 8                                     |
   * | Millisecond           | S     | 1 (100ms)                             |
   * |                       | SS    | 14 (140ms)                            |
   * |                       | SSS   | 145 (145ms)                           |
   * | AM/PM                 | A     | AM or PM                              |
   * |                       | a     | am or pm                              |
   * | Predefined            | LT    | H: 2-digit (2d), m: 2d                |
   * | (uses browser locale) | LTS   | H: 2d, m: 2d, s : 2d                  |
   * |                       | LST   | Depends on 12 or 24 hour clock        |
   * |                       |       | 12h, H : 1d, m : 0 or 2d              |
   * |                       |       | 24h, H : 2d, m : 2d                   |
   * |                       | L     | Y: numeric (n), M : 2d, D : 2d        |
   * |                       | l     | Y: n, M : n, D : n                    |
   * |                       | LL    | Y: n, M : long (l), D : n             |
   * |                       | ll    | Y: n, M : short (s), D : n            |
   * |                       | LLL   | Y: n, M : l, D : n, H: n, m: 2d       |
   * |                       | lll   | Y: n, M : s, D : n, H: n, m: 2d       |
   * |                       | LLLL  | Y: n, M : l, D : n, H: n, m: 2d, d: l |
   * |                       | llll  | Y: n, M : s, D : n, H: n, m: 2d, d: s |
   *
   * Some examples:
   *
   * ```javascript
   * DateHelper.format(new Date(2019, 7, 16), 'dddd') -> Friday
   * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'HH:mm') --> 14:27
   * DateHelper.format(new Date(2019, 7, 16, 14, 27), 'L HH') --> 2019-07-16 14
   * ```
   *
   * Arbitrary text can be embedded in the format string by wrapping it with {}:
   *
   * ```javascript
   * DateHelper.format(new Date(2019, 7, 16), '{It is }dddd{, yay!}') -> It is Friday, yay!
   * ```
   *
   * @param {Date} date Date
   * @param {String} [format] Desired format (uses `defaultFormat` if left out)
   * @returns {String} Formatted string
   * @category Parse & format
   */
  static format(date, format2 = DH.defaultFormat) {
    if (!date || isNaN(date)) {
      return null;
    }
    let formatter = formatCache[format2], output = "";
    if (!formatter) {
      formatter = formatCache[format2] = [];
      for (let i = 0; i < format2.length; i++) {
        const formatMatch = format2.slice(i).match(formatRegexp), predefined = formatMatch == null ? void 0 : formatMatch[0];
        if (predefined) {
          const localeFormats = this.localize("L{formats}") || {}, fn2 = localeFormats[predefined] || formats[predefined];
          formatter.push(fn2);
          i += predefined.length - 1;
        } else if (format2[i] === "{") {
          const index = format2.indexOf("}", i + 1);
          if (index === -1) {
            formatter.push(format2.substr(i + 1));
            i = format2.length;
          } else {
            formatter.push(format2.substring(i + 1, index));
            i = index;
          }
        } else {
          formatter.push(format2[i]);
        }
      }
    }
    formatter.forEach((step) => {
      if (typeof step === "string") {
        output += step;
      } else {
        output += step(date);
      }
    });
    return output;
  }
  /**
   * Formats a range of `dates` using the specified `format`. Because two dates are involved, the `format` specifier
   * uses the tokens `S{}` and `E{}`. The text contained between the `{}` is the {@link #function-format-static format}
   * for the start date or end date, respectively. Text not inside these tokens is retained verbatim.
   *
   * For example:
   *
   * ```javascript
   *  DateHelper.formatRange(dates, 'S{DD MMM YYYY} - E{DD MMM YYYY}');
   * ```
   *
   * The above will format `dates[0]` based on the `S{DD MMM YYYY}` segment and `dates[1] using `E{DD MMM YYYY}`. The
   * `' - '` between these will remain between the two formatted dates.
   *
   * @param {Date[]} dates An array of start date and end date (`[startDate, endDate]`)
   * @param {String} format The format specifier
   * @returns {String}
   */
  static formatRange(dates, format2) {
    return format2.replace(
      rangeFormatPartRe,
      (s, which, fmt) => _DateHelper.format(dates[which === "S" ? 0 : 1], fmt)
    );
  }
  /**
   * Converts the specified amount of desired unit into milliseconds. Can be called by only specifying a unit as the
   * first argument, it then uses `amount = 1`.
   *
   * For example:
   *
   * ```javascript
   * asMilliseconds('hour') == asMilliseconds(1, 'hour')
   * ```
   *
   * @param {Number|String} amount Amount, what of is decided by specifying unit (also takes a unit which implies an amount of 1)
   * @param {String} [unit] Time unit (s, hour, months etc.)
   * @returns {Number}
   * @category Parse & format
   */
  static asMilliseconds(amount, unit = null) {
    if (typeof amount === "string") {
      unit = amount;
      amount = 1;
    }
    return DH.as("millisecond", amount, unit);
  }
  /**
   * Converts the passed Date to an accurate number of months passed since the epoch start.
   * @param {Date} time The Date to find the month value of
   * @returns {Number} The number of months since the system time epoch start. May be a fractional value
   */
  static asMonths(time) {
    const monthLength = DH.as("ms", DH.daysInMonth(time), "day"), fraction = (time.valueOf() - DH.startOf(time, "month").valueOf()) / monthLength;
    return time.getYear() * 12 + time.getMonth() + fraction;
  }
  static monthsToDate(months) {
    const intMonths = Math.floor(months), fraction = months - intMonths, result = new Date(0, intMonths), msInMonth = DH.as("ms", DH.daysInMonth(result), "days");
    result.setTime(result.getTime() + fraction * msInMonth);
    return result;
  }
  /**
   * Converts a millisecond time delta to a human-readable form. For example `1000 * 60 * 60 * 50`
   * milliseconds would be rendered as `'2 days, 2 hours'`.
   * @param {Number} delta The millisecond delta value
   * @param {Object} [options] Formatting options
   * @param {Boolean} [options.abbrev] Pass `true` to use abbreviated unit names, eg `'2d, 2h'` for the above example
   * @param {String} [options.precision] The minimum precision unit
   * @param {String} [options.separator] The separator to use
   * @param {Boolean} [options.asString] Pass `false` to return the result as an array, eg ['2d', '2h'] for the above example
   * @returns {String} Formatted string
   * @category Parse & format
   */
  static formatDelta(delta, options) {
    let abbrev, unitName;
    if (typeof options === "boolean") {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
    }
    const deltaObj = this.getDelta(delta, options), result = [], sep = (options == null ? void 0 : options.separator) || (abbrev ? "" : " ");
    for (unitName in deltaObj) {
      result.push(`${deltaObj[unitName]}${sep}${unitName}`);
    }
    return (options == null ? void 0 : options.asString) === false ? result : result.join(", ");
  }
  /**
   * Converts a millisecond time delta to an object structure. For example `1000 * 60 * 60 * 50`
   * milliseconds the result would be as:
   *
   * ```javascript
   * {
   *     day  : 2,
   *     hour : 2
   * }
   *```
   *
   * @param {Number} delta The millisecond delta value
   * @param {Object} [options] Formatting options
   * @param {Boolean} [options.abbrev] Pass `true` to use abbreviated unit names, eg `{ d: 2, h: 2 }` for the above example
   * @param {String} [options.precision] The minimum precision unit
   * @param {Boolean} [options.ignoreLocale] Pass true to return unlocalized unit name. Requires `abbrev` to be false
   * @param {String} [options.maxUnit] Name of the maximum unit in the output. e.g. if you pass `day` then you'll get
   * `{ h: 25 }` instead of `{ d: 1, h: 1 }`
   * @returns {Object} The object with the values for each unit
   */
  static getDelta(delta, options) {
    let abbrev, d, done, precision, unitName, maxUnit, ignoreLocale;
    if (typeof options === "boolean") {
      abbrev = options;
    } else if (options) {
      abbrev = options.abbrev;
      precision = DH.normalizeUnit(options.precision);
      maxUnit = options.maxUnit;
      ignoreLocale = !abbrev && options.ignoreLocale;
    }
    const result = {}, getUnit = abbrev ? DH.getShortNameOfUnit : DH.getLocalizedNameOfUnit;
    const units = maxUnit ? deltaUnits.slice(deltaUnits.indexOf(maxUnit)) : deltaUnits;
    for (unitName of units) {
      d = DH.as(unitName, delta);
      done = precision === unitName;
      d = Math[done ? "round" : "floor"](d);
      if (d || done && !result.length) {
        result[ignoreLocale ? unitName : getUnit.call(DH, unitName, d !== 1)] = d;
        delta -= DH.as("ms", d, unitName);
      }
      if (done || !delta) {
        break;
      }
    }
    return result;
  }
  /**
   * Converts the specified amount of one unit (`fromUnit`) into an amount of another unit (`toUnit`).
   * @param {String} toUnit The name of units to convert to, eg: `'ms'`
   * @param {Number|String} amount The time to convert. Either the magnitude number form or a duration string such as '2d'
   * @param {String} [fromUnit='ms'] If the amount was passed as a number, the units to use to convert from
   * @returns {Number}
   * @category Parse & format
   */
  static as(toUnit, amount, fromUnit = "ms") {
    if (typeof amount === "string") {
      amount = DH.parseDuration(amount);
    }
    if (typeof amount === "object") {
      fromUnit = amount.unit;
      amount = amount.magnitude;
    }
    if (toUnit === fromUnit) {
      return amount;
    }
    toUnit = DH.normalizeUnit(toUnit);
    fromUnit = DH.normalizeUnit(fromUnit);
    if (toUnit === fromUnit) {
      return amount;
    } else if (unitMagnitudes[fromUnit] > unitMagnitudes[toUnit]) {
      return amount * Math.abs(validConversions[fromUnit][toUnit]);
    } else {
      return amount / Math.abs(validConversions[toUnit][fromUnit]);
    }
  }
  static formatContainsHourInfo(format2) {
    const stripEscapeRe = /(\\.)/g, hourInfoRe = /([HhKkmSsAa]|LT|L{3,}|l{3,})/;
    return hourInfoRe.test(format2.replace(stripEscapeRe, ""));
  }
  /**
   * Returns `true` for 24-hour format.
   * @param {String} format Date format
   * @returns {Boolean} `true` for 24-hour format
   * @category Parse & format
   */
  static is24HourFormat(format2) {
    return DH.format(DH.getTime(13, 0, 0), format2).includes("13");
  }
  //endregion
  //region Manipulate
  /**
   * Add days, hours etc. to a date. Always clones the date, original will be left unaffected.
   * @param {Date|String} date Original date
   * @param {Number|String|Core.data.Duration|DurationConfig} amount Amount of days, hours etc. or a string representation of a duration
   * as accepted by {@link #function-parseDuration-static} or an object with `{ magnitude, unit }` properties
   * @param {String} [unit='ms'] Unit for amount
   * @privateparam {Boolean} [clone=true] Pass `false` to affect the original
   * @returns {Date} New calculated date
   * @category Manipulate
   */
  static add(date, amount, unit = "ms", clone = true) {
    let d;
    if (typeof date === "string") {
      d = DH.parse(date);
    } else if (clone) {
      d = new Date(date.getTime());
    } else {
      d = date;
    }
    if (typeof amount === "string") {
      const duration = _DateHelper.parseDuration(amount);
      amount = duration.magnitude;
      unit = duration.unit;
    } else if (amount && typeof amount === "object") {
      unit = amount.unit;
      amount = amount.magnitude;
    }
    if (!unit || amount === 0) {
      return d;
    }
    unit = DH.normalizeUnit(unit);
    switch (unit) {
      case "millisecond":
        d.setTime(d.getTime() + amount);
        break;
      case "second":
        d.setTime(d.getTime() + amount * 1e3);
        break;
      case "minute":
        d.setTime(d.getTime() + amount * 6e4);
        break;
      case "hour":
        d.setTime(d.getTime() + amount * 36e5);
        break;
      case "day":
        if (amount % 1 === 0) {
          d.setDate(d.getDate() + amount);
          if (d.getHours() === 23 && date.getHours() === 0) {
            d.setHours(d.getHours() + 1);
          }
        } else {
          d.setTime(d.getTime() + amount * 864e5);
        }
        break;
      case "week":
        d.setDate(d.getDate() + amount * 7);
        break;
      case "month": {
        let day2 = d.getDate();
        if (day2 > 28) {
          day2 = Math.min(day2, DH.getLastDateOfMonth(DH.add(DH.getFirstDateOfMonth(d), amount, "month")).getDate());
        }
        d.setDate(day2);
        d.setMonth(d.getMonth() + amount);
        break;
      }
      case "quarter":
        DH.add(d, amount * 3, "month", false);
        break;
      case "year":
        d.setFullYear(d.getFullYear() + amount);
        break;
      case "decade":
        d.setFullYear(d.getFullYear() + amount * 10);
        break;
    }
    return d;
  }
  /**
   * Calculates the difference between two dates, in the specified unit.
   * @param {Date} start First date
   * @param {Date} end Second date
   * @param {String} [unit='ms'] Unit to calculate difference in
   * @param {Boolean} [fractional=true] Specify false to round result
   * @returns {Number} Difference in the specified unit
   * @category Manipulate
   */
  static diff(start, end, unit = "ms", fractional = true) {
    unit = DH.normalizeUnit(unit);
    if (!start || !end)
      return 0;
    let amount;
    switch (unit) {
      case "year":
        amount = DH.diff(start, end, "month") / 12;
        break;
      case "quarter":
        amount = DH.diff(start, end, "month") / 3;
        break;
      case "month":
        amount = (end.getFullYear() - start.getFullYear()) * 12 + (end.getMonth() - start.getMonth());
        if (amount === 0 && fractional) {
          amount = DH.diff(start, end, "day", fractional) / DH.daysInMonth(start);
        }
        break;
      case "week":
        amount = DH.diff(start, end, "day") / 7;
        break;
      case "day": {
        const dstDiff = start.getTimezoneOffset() - end.getTimezoneOffset();
        amount = (end - start + dstDiff * 60 * 1e3) / 864e5;
        break;
      }
      case "hour":
        amount = (end - start) / 36e5;
        break;
      case "minute":
        amount = (end - start) / 6e4;
        break;
      case "second":
        amount = (end - start) / 1e3;
        break;
      case "millisecond":
        amount = end - start;
        break;
    }
    return fractional ? amount : Math.round(amount);
  }
  /**
   * Sets the date to the start of the specified unit, by default returning a clone of the date instead of changing it
   * in place.
   * @param {Date} date Original date
   * @param {String} [unit='day'] Start of this unit, `'day'`, `'month'` etc
   * @param {Boolean} [clone=true] Manipulate a copy of the date
   * @param {Number} [weekStartDay] The first day of week, `0-6` (Sunday-Saturday). Defaults to the {@link #property-weekStartDay-static}
   * @returns {Date} Manipulated date
   * @category Manipulate
   */
  static startOf(date, unit = "day", clone = true, weekStartDay = DH.weekStartDay) {
    if (!date) {
      return null;
    }
    unit = DH.normalizeUnit(unit);
    if (clone) {
      date = DH.clone(date);
    }
    switch (unit) {
      case "year":
        date.setMonth(0, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "quarter":
        date.setMonth((DH.get(date, "quarter") - 1) * 3, 1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "month":
        date.setDate(1);
        date.setHours(0, 0, 0, 0);
        return date;
      case "week": {
        const delta = date.getDay() - weekStartDay;
        date.setDate(date.getDate() - delta);
        date.setHours(0, 0, 0, 0);
        return date;
      }
      case "day":
        date.setHours(0, 0, 0, 0);
        return date;
      case "hour":
        date.getMinutes() > 0 && date.setMinutes(0);
      case "minute":
        date.getSeconds() > 0 && date.setSeconds(0);
      case "second":
        date.getMilliseconds() > 0 && date.setMilliseconds(0);
      case "millisecond":
        return date;
    }
  }
  /**
   * Returns the end point of the passed date, that is 00:00:00 of the day after the passed date.
   * @param {Date} date The date to return the end point of
   * @returns {Date} Manipulated date
   */
  static endOf(date) {
    return new Date(date.getFullYear(), date.getMonth(), date.getDate() + 1);
  }
  /**
   * Creates a clone of the specified date
   * @param {Date} date Original date
   * @returns {Date} Cloned date
   * @category Manipulate
   */
  static clone(date) {
    return new Date(date.getTime());
  }
  /**
   * Removes time from a date (same as calling {@link #function-startOf-static startOf(date)}).
   * @param {Date} date Date to remove time from
   * @param {Boolean} [clone=true] Manipulate a copy of the date
   * @returns {Date} Manipulated date
   * @category Manipulate
   */
  static clearTime(date, clone = true) {
    if (!date) {
      return null;
    }
    if (clone) {
      date = new Date(date.getTime());
    }
    date.setHours(0, 0, 0, 0);
    return date;
  }
  static midnight(date, inclusive) {
    let ret = DH.clearTime(date);
    if (inclusive && ret < date) {
      ret = DH.add(ret, 1, "d");
    }
    return ret;
  }
  /**
   * Returns the elapsed milliseconds from the start of the specified date.
   * @param {Date} date Date to remove date from
   * @param {String} [unit='ms'] The time unit to return
   * @returns {Number} The elapsed milliseconds from the start of the specified date
   * @category Manipulate
   */
  static getTimeOfDay(date, unit = "ms") {
    const t = date.getHours() * validConversions.hour.millisecond + date.getMinutes() * validConversions.minute.millisecond + date.getSeconds() * validConversions.second.millisecond + date.getMilliseconds();
    return unit === "ms" ? t : DH.as(unit, t, "ms");
  }
  /**
   * Sets a part of a date (in place).
   * @param {Date} date Date to manipulate
   * @param {String|Object} unit Part of date to set, for example `'minute'`. Or an object like `{ second: 1, minute: 1 }`
   * @param {Number} amount Value to set
   * @returns {Date} Passed date instance modified according to the arguments
   * @category Manipulate
   */
  static set(date, unit, amount) {
    if (!unit) {
      return date;
    }
    if (typeof unit === "string") {
      switch (DH.normalizeUnit(unit)) {
        case "millisecond":
          if (amount !== 0 || date.getMilliseconds() > 0) {
            date.setMilliseconds(amount);
          }
          break;
        case "second":
          if (amount !== 0 || date.getSeconds() > 0) {
            date.setSeconds(amount);
          }
          break;
        case "minute":
          if (amount !== 0 || date.getMinutes() > 0) {
            date.setMinutes(amount);
          }
          break;
        case "hour":
          date.setHours(amount);
          break;
        case "day":
        case "date":
          date.setDate(amount);
          break;
        case "week":
          throw new Error("week not implemented");
        case "month":
          date.setMonth(amount);
          break;
        case "quarter":
          date.setDate(1);
          date.setMonth((amount - 1) * 3);
          break;
        case "year":
          date.setFullYear(amount);
          break;
      }
    } else {
      Object.entries(unit).sort((a, b) => unitMagnitudes[a[0]] - unitMagnitudes[b[0]]).forEach(([unit2, amount2]) => {
        DH.set(date, unit2, amount2);
      });
    }
    return date;
  }
  static setDateToMidday(date, clone = true) {
    return DH.set(DH.clearTime(date, clone), "hour", 12);
  }
  /**
   * Constrains the date within a min and a max date.
   * @param {Date} date The date to constrain
   * @param {Date} [min] Min date
   * @param {Date} [max] Max date
   * @returns {Date} The constrained date
   * @category Manipulate
   */
  static constrain(date, min2, max) {
    if (min2 != null) {
      date = DH.max(date, min2);
    }
    return max == null ? date : DH.min(date, max);
  }
  /**
   * Returns time with default year, month, and day (Jan 1, 2020).
   * @param {Number|Date} hours Hours value or the full date to extract the time of
   * @param {Number} [minutes=0] Minutes value
   * @param {Number} [seconds=0] Seconds value
   * @param {Number} [ms=0] Milliseconds value
   * @returns {Date} A new default date with the time extracted from the given date or from the time values provided individually
   * @category Manipulate
   */
  static getTime(hours, minutes = 0, seconds = 0, ms = 0) {
    if (hours instanceof Date) {
      ms = hours.getMilliseconds();
      seconds = hours.getSeconds();
      minutes = hours.getMinutes();
      hours = hours.getHours();
    }
    return new Date(DEFAULT_YEAR, DEFAULT_MONTH, DEFAULT_DAY, hours, minutes, seconds, ms);
  }
  /**
   * Copies hours, minutes, seconds, milliseconds from one date to another.
   *
   * @param {Date} targetDate The target date
   * @param {Date} sourceDate The source date
   * @returns {Date} The adjusted target date
   * @category Manipulate
   * @static
   */
  static copyTimeValues(targetDate, sourceDate) {
    targetDate.setHours(sourceDate.getHours());
    targetDate.setMinutes(sourceDate.getMinutes());
    targetDate.setSeconds(sourceDate.getSeconds());
    targetDate.setMilliseconds(sourceDate.getMilliseconds());
    return targetDate;
  }
  //endregion
  //region Comparison
  static get isDSTEnabled() {
    const year = (/* @__PURE__ */ new Date()).getFullYear(), jan = new Date(year, 0, 1), jul = new Date(year, 6, 1);
    return jan.getTimezoneOffset() !== jul.getTimezoneOffset();
  }
  static isDST(date) {
    const year = date.getFullYear(), jan = new Date(year, 0, 1), jul = new Date(year, 6, 1);
    return date.getTimezoneOffset() < Math.max(jan.getTimezoneOffset(), jul.getTimezoneOffset());
  }
  /**
   * Determines if a date precedes another.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Boolean} `true` if first precedes second, otherwise false
   * @category Comparison
   */
  static isBefore(first, second) {
    return first < second;
  }
  /**
   * Determines if a date succeeds another.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Boolean} `true` if first succeeds second, otherwise false
   * @category Comparison
   */
  static isAfter(first, second) {
    return first > second;
  }
  /**
   * Checks if two dates are equal.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @param {String} [unit] Unit to calculate difference in. If not given, the comparison will be done up to a millisecond
   * @returns {Boolean} `true` if the dates are equal
   * @category Comparison
   */
  static isEqual(first, second, unit = null) {
    if (unit === null) {
      return first && second && first.getTime() === second.getTime();
    }
    return DH.startOf(first, unit) - DH.startOf(second, unit) === 0;
  }
  /**
   * Compares two dates using the specified precision.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @param {String} [unit] Unit to calculate difference in. If not given, the comparison will be done up to a millisecond
   * @returns {Number} `0` = equal, `-1` = first before second, `1` = first after second
   * @category Comparison
   */
  static compare(first, second, unit = null) {
    if (unit) {
      first = DH.startOf(first, unit);
      second = DH.startOf(second, unit);
    }
    if (first < second)
      return -1;
    if (first > second)
      return 1;
    return 0;
  }
  /**
   * Coerces the passed Date between the passed minimum and maximum values.
   * @param {Date} date The date to clamp between the `min` and `max`
   * @param {Date} min The minimum Date
   * @param {Date} max The maximum Date
   * @returns {Date} If the passed `date` is valid, a *new* Date object which is clamped between the `min` and `max`
   */
  static clamp(date, min2, max) {
    if (!isNaN(date)) {
      if (min2 != null) {
        date = Math.max(date, min2);
      }
      if (max != null) {
        date = Math.min(date, max);
      }
      return new Date(date);
    }
  }
  static isSameDate(first, second) {
    return DH.compare(first, second, "d") === 0;
  }
  static isSameTime(first, second) {
    return first.getHours() === second.getHours() && first.getMinutes() === second.getMinutes() && first.getSeconds() === second.getSeconds() && first.getMilliseconds() === second.getMilliseconds();
  }
  /**
   * Checks if date is the start of specified unit.
   * @param {Date} date Date
   * @param {String} unit Time unit
   * @returns {Boolean} `true` if date is the start of specified unit
   * @category Comparison
   */
  static isStartOf(date, unit) {
    return DH.isEqual(date, DH.startOf(date, unit));
  }
  /**
   * Checks if this date is `>= start` and `< end`.
   * @param {Date} date The source date
   * @param {Date} start Start date
   * @param {Date} end End date
   * @returns {Boolean} `true` if this date falls on or between the given start and end dates
   * @category Comparison
   */
  static betweenLesser(date, start, end) {
    return start.getTime() <= date.getTime() && date.getTime() < end.getTime();
  }
  /**
   * Checks if this date is `>= start` and `<= end`.
   * @param {Date} date The source date
   * @param {Date} start Start date
   * @param {Date} end End date
   * @returns {Boolean} `true` if this date falls on or between the given start and end dates
   * @category Comparison
   */
  static betweenLesserEqual(date, start, end) {
    return start.getTime() <= date.getTime() && date.getTime() <= end.getTime();
  }
  /**
   * Returns `true` if dates intersect.
   * @param {Date} date1Start Start date of first span
   * @param {Date} date1End End date of first span
   * @param {Date} date2Start Start date of second span
   * @param {Date} date2End End date of second span
   * @returns {Boolean} Returns `true` if dates intersect
   * @category Comparison
   */
  static intersectSpans(date1Start, date1End, date2Start, date2End) {
    return DH.betweenLesser(date1Start, date2Start, date2End) || DH.betweenLesser(date2Start, date1Start, date1End);
  }
  /**
   * Compare two units. Returns `1` if first param is a greater unit than second param, `-1` if the opposite is true or `0` if they're equal.
   * @param {String} unit1 The 1st unit
   * @param {String} unit2 The 2nd unit
   * @returns {Number} Returns `1` if first param is a greater unit than second param, `-1` if the opposite is true or `0` if they're equal
   * @category Comparison
   */
  static compareUnits(unit1, unit2) {
    return Math.sign(unitMagnitudes[DH.normalizeUnit(unit1)] - unitMagnitudes[DH.normalizeUnit(unit2)]);
  }
  /**
   * Returns `true` if the first time span completely 'covers' the second time span.
   *
   * ```javascript
   * DateHelper.timeSpanContains(
   *     new Date(2010, 1, 2),
   *     new Date(2010, 1, 5),
   *     new Date(2010, 1, 3),
   *     new Date(2010, 1, 4)
   * ) ==> true
   * DateHelper.timeSpanContains(
   *   new Date(2010, 1, 2),
   *   new Date(2010, 1, 5),
   *   new Date(2010, 1, 3),
   *   new Date(2010, 1, 6)
   * ) ==> false
   * ```
   *
   * @param {Date} spanStart The start date for initial time span
   * @param {Date} spanEnd The end date for initial time span
   * @param {Date} otherSpanStart The start date for the 2nd time span
   * @param {Date} otherSpanEnd The end date for the 2nd time span
   * @returns {Boolean} `true` if the first time span completely 'covers' the second time span
   * @category Comparison
   */
  static timeSpanContains(spanStart, spanEnd, otherSpanStart, otherSpanEnd) {
    return otherSpanStart - spanStart >= 0 && spanEnd - otherSpanEnd >= 0;
  }
  //endregion
  //region Query
  /**
   * Get the first day of week, 0-6 (Sunday-Saturday).
   * This is determined by the current locale's `DateHelper.weekStartDay` parameter.
   * @property {Number}
   * @readonly
   */
  static get weekStartDay() {
    if (DH._weekStartDay == null) {
      DH._weekStartDay = this.localize("L{weekStartDay}") || 0;
    }
    return DH._weekStartDay;
  }
  /**
   * Get non-working days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
   * This is determined by the current locale's `DateHelper.nonWorkingDays` parameter.
   *
   * For example:
   * ```javascript
   * {
   *     0 : true, // Sunday
   *     6 : true  // Saturday
   * }
   * ```
   *
   * @property {Object<Number,Boolean>}
   * @readonly
   */
  static get nonWorkingDays() {
    return { ...this.localize("L{nonWorkingDays}") };
  }
  /**
   * Get non-working days as an array of day indices, 0-6 (Sunday-Saturday).
   * This is determined by the current locale's `DateHelper.nonWorkingDays` parameter.
   *
   * For example:
   *
   * ```javascript
   * [ 0, 6 ] // Sunday & Saturday
   * ```
   *
   * @property {Number[]}
   * @readonly
   * @internal
   */
  static get nonWorkingDaysAsArray() {
    return Object.keys(this.nonWorkingDays).map(Number);
  }
  /**
   * Get weekend days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
   * Weekends are days which are declared as weekend days by the selected country and defined by the current locale's
   * `DateHelper.weekends` parameter.
   * To get non-working days see {@link #property-nonWorkingDays-static}.
   *
   * For example:
   * ```javascript
   * {
   *     0 : true, // Sunday
   *     6 : true  // Saturday
   * }
   * ```
   * @property {Object<Number,Boolean>}
   * @readonly
   * @internal
   */
  static get weekends() {
    return { ...this.localize("L{weekends}") };
  }
  /**
   * Get the specified part of a date.
   * @param {Date} date
   * @param {String} unit Part of date, hour, minute etc.
   * @returns {Number} The requested part of the specified date
   * @category Query
   */
  static get(date, unit) {
    switch (DH.normalizeUnit(unit)) {
      case "millisecond":
        return date.getMilliseconds();
      case "second":
        return date.getSeconds();
      case "minute":
        return date.getMinutes();
      case "hour":
        return date.getHours();
      case "date":
      case "day":
        return date.getDate();
      case "week":
        return formats.W(date);
      case "month":
        return date.getMonth();
      case "quarter":
        return Math.floor(date.getMonth() / 3) + 1;
      case "year":
        return date.getFullYear();
    }
    return null;
  }
  /**
   * Get number of days in the current year for the supplied date.
   * @param {Date} date Date to check
   * @returns {Number} Days in year
   * @category Query
   * @internal
   */
  static daysInYear(date) {
    const fullYear = date.getFullYear(), duration = new Date(fullYear + 1, 0, 1) - new Date(fullYear, 0, 1);
    return this.as("day", duration);
  }
  /**
   * Get number of days in the current month for the supplied date.
   * @param {Date} date Date which month should be checked
   * @returns {Number} Days in month
   * @category Query
   */
  static daysInMonth(date) {
    return 32 - new Date(date.getFullYear(), date.getMonth(), 32).getDate();
  }
  /**
   * Get number of hours in the current day for the supplied date.
   * @param {Date} date Date to check
   * @returns {Number} Hours in day
   * @category Query
   * @internal
   */
  static hoursInDay(date) {
    const fullYear = date.getFullYear(), month2 = date.getMonth(), day2 = date.getDate(), duration = new Date(fullYear, month2, day2 + 1) - new Date(fullYear, month2, day2);
    return this.as("hour", duration);
  }
  /**
   * Converts unit related to the date to actual amount of milliseconds in it. Takes into account leap years and
   * different duration of months.
   * @param {Date} date Date
   * @param {String} unit Time unit
   * @returns {Number} Returns amount of milliseconds
   * @internal
   */
  static getNormalizedUnitDuration(date, unit) {
    let result;
    switch (unit) {
      case "month":
        result = DH.asMilliseconds(DH.daysInMonth(date), "day");
        break;
      case "year":
        result = DH.asMilliseconds(DH.daysInYear(date), "day");
        break;
      case "day":
        result = DH.asMilliseconds(DH.hoursInDay(date), "hour");
        break;
      default:
        result = DH.asMilliseconds(unit);
    }
    return result;
  }
  /**
   * Get the first date of the month for the supplied date.
   * @param {Date} date Date
   * @returns {Date} New Date instance
   * @category Query
   */
  static getFirstDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth(), 1);
  }
  /**
   * Get the last date of the month for the supplied date.
   * @param {Date} date Date
   * @returns {Date} New Date instance
   * @category Query
   */
  static getLastDateOfMonth(date) {
    return new Date(date.getFullYear(), date.getMonth() + 1, 0);
  }
  /**
   * Get the earliest of two dates.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Date} Earliest date
   * @category Query
   */
  static min(first, second) {
    return first.getTime() < second.getTime() ? first : second;
  }
  /**
   * Get the latest of two dates.
   * @param {Date} first First date
   * @param {Date} second Second date
   * @returns {Date} Latest date
   * @category Query
   */
  static max(first, second) {
    return first.getTime() > second.getTime() ? first : second;
  }
  /**
   * Get an incremented date. Incrementation based on specified unit and optional amount.
   * @param {Date} date Date
   * @param {String} unit Time unit
   * @param {Number} [increment=1] Increment amount
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   * @category Query
   */
  static getNext(date, unit, increment = 1, weekStartDay = DH.weekStartDay) {
    if (unit === "week") {
      const dt = DH.clone(date), day2 = dt.getDay();
      DH.startOf(dt, "day", false);
      DH.add(dt, weekStartDay - day2 + 7 * (increment - (weekStartDay <= day2 ? 0 : 1)), "day", false);
      if (dt.getDay() !== weekStartDay) {
        DH.add(dt, 1, "hour");
      }
      return dt;
    }
    return DH.startOf(DH.add(date, increment, unit), unit, false);
  }
  /**
   * Checks if date object is valid.
   *
   * For example:
   *
   * ```javascript
   * date = new Date('foo')
   * date instanceof Date // true
   * date.toString() // Invalid Date
   * isNaN(date) // true
   * DateHelper.isValidDate(date) // false
   *
   * date = new Date()
   * date instanceof Date // true
   * date.toString() // Mon Jan 13 2020 18:27:38 GMT+0300 (GMT+03:00)
   * isNaN(date) // false
   * DateHelper.isValidDate(date) // true
   * ```
   *
   * @param {Date} date Date
   * @returns {Boolean} `true` if date object is valid
   */
  static isValidDate(date) {
    return DH.isDate(date) && !isNaN(date);
  }
  /**
   * Checks if value is a date object. Allows to recognize date object even from another context,
   * like the top frame when used in an iframe.
   *
   * @param {*} value Value to check
   * @returns {Boolean} `true` if value is a date object
   */
  static isDate(value) {
    return value && toString3.call(value) === DATE_TYPE2;
  }
  /**
   * Get the start of the next day.
   * @param {Date} date Date
   * @param {Boolean} [clone=false] Clone date
   * @param {Boolean} [noNeedToClearTime=false] Flag to not clear time from the result
   * @returns {Date} Passed Date or new Date instance, depending on the `clone` flag
   * @category Query
   */
  static getStartOfNextDay(date, clone = false, noNeedToClearTime = false) {
    let nextDay = DH.add(noNeedToClearTime ? date : DH.clearTime(date, clone), 1, "day");
    if (nextDay.getDate() === date.getDate()) {
      const offsetNextDay = DH.add(DH.clearTime(date, clone), 2, "day").getTimezoneOffset(), offsetDate = date.getTimezoneOffset();
      nextDay = DH.add(nextDay, offsetDate - offsetNextDay, "minute");
    }
    return nextDay;
  }
  /**
   * Get the end of previous day.
   * @param {Date} date Date
   * @param {Boolean} [noNeedToClearTime=false] Flag to not clear time from the result
   * @returns {Date} New Date instance
   * @category Query
   */
  static getEndOfPreviousDay(date, noNeedToClearTime = false) {
    const dateOnly = noNeedToClearTime ? date : DH.clearTime(date, true);
    if (dateOnly - date) {
      return dateOnly;
    } else {
      return DH.add(dateOnly, -1, "day");
    }
  }
  /**
   * Returns a string describing the specified week. For example, `'39, September 2020'` or `'40, Sep - Oct 2020'`.
   * @param {Date} startDate Start date
   * @param {Date} [endDate] End date
   * @returns {String} String describing the specified week
   * @internal
   */
  static getWeekDescription(startDate, endDate = startDate) {
    const monthDesc = startDate.getMonth() === endDate.getMonth() ? _DateHelper.format(startDate, "MMMM") : `${_DateHelper.format(startDate, "MMM")} - ${_DateHelper.format(endDate, "MMM")}`, week = _DateHelper.getWeekNumber(startDate);
    return `${week[1]}, ${monthDesc} ${week[0]}`;
  }
  /**
   * Get week number for the date.
   * @param {Date} date The date
   * @param {Number} [weekStartDay] The first day of week, 0-6 (Sunday-Saturday). Defaults to the {@link #property-weekStartDay-static}
   * @returns {Number[]} year and week number
   * @category Query
   */
  static getWeekNumber(date, weekStartDay = _DateHelper.weekStartDay) {
    const jan01 = new Date(date.getFullYear(), 0, 1), dec31 = new Date(date.getFullYear(), 11, 31), firstDay = normalizeDay(jan01.getDay() - weekStartDay), lastDay = normalizeDay(dec31.getDay() - weekStartDay), dayNumber = getDayDiff(date, jan01);
    let weekNumber;
    if (firstDay < 4) {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7) + 1;
    } else {
      weekNumber = Math.floor((dayNumber + firstDay - 1) / 7);
    }
    if (weekNumber) {
      let year = date.getFullYear();
      if (weekNumber === 53 && lastDay < 3) {
        year++;
        weekNumber = 1;
      }
      return [year, weekNumber];
    }
    const lastWeekOfLastYear = _DateHelper.getWeekNumber(new Date(date.getFullYear() - 1, 11, 31))[1];
    return [date.getFullYear() - 1, lastWeekOfLastYear];
  }
  //endregion
  //region Unit helpers
  /**
   * Turns `(10, 'day')` into `'10 days'` etc.
   * @param {Number} count Amount of unit
   * @param {String} unit Unit, will be normalized (days, d -> day etc.)
   * @returns {String} Amount formatted to string
   * @category Unit helpers
   */
  static formatCount(count, unit) {
    unit = DH.normalizeUnit(unit);
    if (count !== 1)
      unit += "s";
    return count + " " + unit;
  }
  /**
   * Get the ratio between two units ( year, month -> 1/12 ).
   * @param {String} baseUnit Base time unit
   * @param {String} unit Time unit
   * @param {Boolean} [acceptEstimate=false] If `true`, process negative values of validConversions
   * @returns {Number} Ratio
   * @category Unit helpers
   */
  static getUnitToBaseUnitRatio(baseUnit, unit, acceptEstimate = false) {
    baseUnit = DH.normalizeUnit(baseUnit);
    unit = DH.normalizeUnit(unit);
    if (baseUnit === unit)
      return 1;
    if (validConversions[baseUnit] && validConversions[baseUnit][unit] && (acceptEstimate || validConversions[baseUnit][unit] > 0)) {
      return 1 / DH.as(unit, 1, baseUnit);
    }
    if (validConversions[unit] && validConversions[unit][baseUnit] && (acceptEstimate || validConversions[unit][baseUnit] > 0)) {
      return DH.as(baseUnit, 1, unit);
    }
    return -1;
  }
  /**
   * Returns a localized abbreviated form of the name of the duration unit.
   * For example in the `EN` locale, for `'qrt'` it will return `'q'`.
   * @param {String} unit Duration unit
   * @returns {String} Localized abbreviated form of the name of the duration unit
   * @category Unit helpers
   */
  static getShortNameOfUnit(unit) {
    unit = DH.parseTimeUnit(unit);
    return DH.unitLookup[unit].abbrev;
  }
  /**
   * Returns a localized full name of the duration unit.
   *
   * For example in the `EN` locale, for `'d'` it will return either
   * `'day'` or `'days'`, depending on the `plural` argument
   *
   * Preserves casing of first letter.
   *
   * @static
   * @param {String} unit Time unit
   * @param {Boolean} [plural=false] Whether to return a plural name or singular
   * @returns {String} Localized full name of the duration unit
   * @category Unit helpers
   */
  static getLocalizedNameOfUnit(unit, plural = false) {
    const capitalize = unit.charAt(0) === unit.charAt(0).toUpperCase();
    unit = DH.normalizeUnit(unit);
    unit = DH.parseTimeUnit(unit);
    unit = DH.unitLookup[unit][plural ? "plural" : "single"];
    if (capitalize) {
      unit = StringHelper.capitalize(unit);
    }
    return unit;
  }
  /**
   * Normalizes a unit for easier usage in conditionals. For example `'year'`, `'years'`, `'y'` -> `'year'`.
   * @param {String} unit Time unit
   * @returns {String} Normalized unit name
   * @category Unit helpers
   */
  static normalizeUnit(unit) {
    if (!unit) {
      return null;
    }
    const unitLower = unit.toLowerCase();
    if (unitLower === "date") {
      return unitLower;
    }
    return canonicalUnitNames.includes(unitLower) ? unitLower : normalizedUnits[unit] || normalizedUnits[unitLower];
  }
  static getUnitByName(name) {
    return DH.normalizeUnit(name) || DH.normalizeUnit(DH.parseTimeUnit(name));
  }
  /**
   * Returns a duration of the timeframe in the given unit.
   * @param {Date} start The start date of the timeframe
   * @param {Date} end The end date of the timeframe
   * @param {String} unit Duration unit
   * @privateparam {Boolean} [doNotRound]
   * @returns {Number} The duration in the units
   * @category Unit helpers
   * @ignore
   */
  static getDurationInUnit(start, end, unit, doNotRound) {
    return DH.diff(start, end, unit, doNotRound);
  }
  /**
   * Checks if two date units align.
   * @private
   * @param {String} majorUnit Major time unit
   * @param {String} minorUnit Minor time unit
   * @returns {Boolean} `true` if two date units align
   * @category Unit helpers
   */
  static doesUnitsAlign(majorUnit, minorUnit) {
    return !(majorUnit !== minorUnit && minorUnit === "week");
  }
  static getSmallerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH.normalizeUnit(unit)] - 1] || null;
  }
  static getLargerUnit(unit) {
    return canonicalUnitNames[unitMagnitudes[DH.normalizeUnit(unit)] + 1] || null;
  }
  /**
   *
   * Rounds the passed Date value to the nearest `increment` value.
   *
   * Optionally may round relative to a certain base time point.
   *
   * For example `DH.round(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would round to 9:45 because that's the nearest integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when rounding to weeks. The configured {@link #property-weekStartDay-static}
   * dictates what the base of a week is.
   *
   * @param {Date} time The time to round
   * @param {String|Number} increment A millisecond value by which to round the time
   * May be specified in string form eg: `'15 minutes'`
   * @param {Date} [base] The start from which to apply the rounding
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static round(time, increment, base, weekStartDay) {
    return DH.snap("round", time, increment, base, weekStartDay);
  }
  /**
   *
   * Floor the passed Date value to the nearest `increment` value.
   *
   * Optionally may floor relative to a certain base time point.
   *
   * For example `DH.floor(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would floor to 9:15 because that's the closest lower integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when flooring to weeks. The configured {@link #property-weekStartDay-static}
   * dictates what the base of a week is.
   *
   * @param {Date} time The time to floor
   * @param {String|Number|DurationConfig|Object} increment A numeric millisecond value by which to floor the time.
   * or a duration in string form eg `'30 min'` or object form : `{unit: 'minute', magnitude: 30}`
   * or `{unit: 'minute', increment: 30}`
   * @param {Date} [base] The start from which to apply the flooring
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static floor(time, increment, base, weekStartDay) {
    return DH.snap("floor", time, increment, base, weekStartDay);
  }
  /**
   *
   * Ceils the passed Date value to the nearest `increment` value.
   *
   * Optionally may ceil relative to a certain base time point.
   *
   * For example `DH.ceil(new Date('2020-01-01T09:35'), '30 min', new Date('2020-01-01T09:15'))`
   * would ceil to 9:45 because that's the closest higher integer number of 30 minute increments
   * from the base.
   *
   * Note that `base` is ignored when ceiling to weeks. Use weekStartDay argument which default to the configured
   * {@link #property-weekStartDay-static} dictates what the base of a week is
   *
   * @param {Date} time The time to ceil
   * @param {String|Number|DurationConfig|Object} increment A numeric millisecond value by which to ceil the time
   * or a duration in string form eg `'30 min'` or object form : `{unit: 'minute', magnitude: 30}`
   * or `{unit: 'minute', increment: 30}`
   * @param {Date} [base] The start from which to apply the ceiling
   * @param {Number} [weekStartDay] Will default to what is set in locale
   * @returns {Date} New Date instance
   */
  static ceil(time, increment, base, weekStartDay) {
    return DH.snap("ceil", time, increment, base, weekStartDay);
  }
  /**
   * Implementation for round, floor and ceil.
   * @internal
   */
  static snap(operation, time, increment, base, weekStartDay = DH.weekStartDay) {
    const snapFn = snapFns[operation];
    if (typeof increment === "string") {
      increment = DH.parseDuration(increment);
    }
    if (Objects.isObject(increment)) {
      const magnitude = increment.magnitude || increment.increment;
      switch (increment.unit) {
        case "week": {
          if (!base) {
            const weekDay = time.getDay();
            base = DH.add(
              DH.clearTime(time),
              weekDay >= weekStartDay ? weekStartDay - weekDay : -(weekDay - weekStartDay + 7),
              "day"
            );
          }
          return DH[operation](time, `${magnitude * 7} days`, base);
        }
        case "month": {
          time = DH.asMonths(time);
          let resultMonths;
          if (base) {
            base = DH.asMonths(base);
            resultMonths = base + snapFn(time - base, magnitude);
          } else {
            resultMonths = snapFn(time, magnitude);
          }
          return DH.monthsToDate(resultMonths);
        }
        case "quarter":
          return DH[operation](time, `${magnitude * 3} months`, base);
        case "year":
          return DH[operation](time, `${magnitude * 12} months`, base);
        case "decade":
          return DH[operation](time, `${magnitude * 10} years`, base);
      }
      increment = DH.as("ms", magnitude, increment.unit);
    }
    const timeUtcOffset = time.getTimezoneOffset() * 1e3 * 60;
    if (base) {
      const baseUtcOffset = base.getTimezoneOffset() * 1e3 * 60, diff = time - base + baseUtcOffset - timeUtcOffset, snappedDate = new Date(base.getTime() + snapFn(diff, increment)), dstChange = baseUtcOffset - snappedDate.getTimezoneOffset() * 1e3 * 60;
      if (dstChange) {
        DH.add(snappedDate, -dstChange, "ms", false);
      }
      return new Date(snappedDate);
    } else {
      return new Date(snapFn(time.valueOf() - timeUtcOffset, increment) + timeUtcOffset);
    }
  }
  //endregion
  //region Date picker format
  /**
   * Parses a typed duration value according to locale rules.
   *
   * The value is taken to be a string consisting of the numeric magnitude and the units:
   * - The numeric magnitude can be either an integer or a float value. Both `','` and `'.'` are valid decimal separators.
   * - The units may be a recognised unit abbreviation of this locale or the full local unit name.
   *
   * For example:
   * `'2d'`, `'2 d'`, `'2 day'`, `'2 days'` will be turned into `{ magnitude : 2, unit : 'day' }`
   * `'2.5d'`, `'2,5 d'`, `'2.5 day'`, `'2,5 days'` will be turned into `{ magnitude : 2.5, unit : 'day' }`
   *
   * **NOTE:** Doesn't work with complex values like `'2 days, 2 hours'`
   *
   * @param {String} value The value to parse
   * @param {Boolean} [allowDecimals=true] Decimals are allowed in the magnitude
   * @param {String} [defaultUnit] Default unit to use if only magnitude passed
   * @returns {DurationConfig} If successfully parsed, the result contains two properties, `magnitude` being a number, and
   * `unit` being the canonical unit name, *NOT* a localized name. If parsing was unsuccessful, `null` is returned
   * @category Parse & format
   */
  static parseDuration(value, allowDecimals = true, defaultUnit) {
    var _a2;
    const durationRegEx = allowDecimals ? withDecimalsDurationRegex : noDecimalsDurationRegex, match = durationRegEx.exec(value);
    if (value == null || !match) {
      return null;
    }
    const magnitude = parseNumber((_a2 = match[1]) == null ? void 0 : _a2.replace(",", ".")), unit = DH.parseTimeUnit(match[2]) || defaultUnit;
    if (!unit) {
      return null;
    }
    return {
      magnitude,
      unit
    };
  }
  /**
   * Parses a typed unit name, for example `'ms'` or `'hr'` or `'yr'` into the
   * canonical form of the unit name which may be passed to {@link #function-add-static}
   * or {@link #function-diff-static}.
   * @param {*} unitName Time unit name
   * @category Parse & format
   */
  static parseTimeUnit(unitName) {
    const unitMatch = unitName == null ? null : DH.durationRegEx.exec(unitName.toLowerCase());
    if (!unitMatch) {
      return null;
    }
    for (let unitOrdinal = 0; unitOrdinal < canonicalUnitNames.length; unitOrdinal++) {
      if (unitMatch[unitOrdinal + 1]) {
        return canonicalUnitNames[unitOrdinal];
      }
    }
  }
  //endregion
  //region Internal
  static getGMTOffset(date = /* @__PURE__ */ new Date()) {
    if (!date) {
      return;
    }
    const offsetInMinutes = date.getTimezoneOffset();
    if (!offsetInMinutes)
      return "Z";
    return (offsetInMinutes > 0 ? "-" : "+") + Math.abs(Math.trunc(offsetInMinutes / 60)).toString().padStart(2, "0") + ":" + Math.abs(offsetInMinutes % 60).toString().padStart(2, "0");
  }
  static fillDayNames() {
    const tempDate2 = /* @__PURE__ */ new Date("2000-01-01T12:00:00"), dayNames = DH._dayNames || [], dayShortNames = DH._dayShortNames || [];
    dayNames.length = 0;
    dayShortNames.length = 0;
    for (let day2 = 2; day2 < 9; day2++) {
      tempDate2.setDate(day2);
      dayNames.push(DH.format(tempDate2, "dddd"));
      dayShortNames.push(DH.format(tempDate2, "ddd"));
    }
    DH._dayNames = dayNames;
    DH._dayShortNames = dayShortNames;
  }
  static getDayNames() {
    return DH._dayNames;
  }
  static getDayName(day2) {
    return DH._dayNames[day2];
  }
  static getDayShortNames() {
    return DH._dayShortNames;
  }
  static getDayShortName(day2) {
    return DH._dayShortNames[day2];
  }
  static fillMonthNames() {
    const tempDate2 = /* @__PURE__ */ new Date("2000-01-15T12:00:00"), monthNames = DH._monthNames || [], monthShortNames = DH._monthShortNames || [], monthNamesIndex = {}, monthShortNamesIndex = {};
    monthNames.length = 0;
    monthShortNames.length = 0;
    for (let month2 = 0; month2 < 12; month2++) {
      tempDate2.setMonth(month2);
      const monthName = DH.format(tempDate2, "MMMM");
      monthNames.push(monthName);
      const monthShortName = DH.format(tempDate2, "MMM");
      monthShortNames.push(monthShortName);
      monthNamesIndex[monthName.toLowerCase()] = { name: monthName, value: month2 };
      monthShortNamesIndex[monthShortName.toLowerCase()] = { name: monthShortName, value: month2 };
    }
    DH._monthNames = monthNames;
    DH._monthShortNames = monthShortNames;
    DH._monthNamesIndex = monthNamesIndex;
    DH._monthShortNamesIndex = monthShortNamesIndex;
  }
  static getMonthShortNames() {
    return DH._monthShortNames;
  }
  static getMonthShortName(month2) {
    return DH._monthShortNames[month2];
  }
  static getMonthNames() {
    return DH._monthNames;
  }
  static getMonthName(month2) {
    return DH._monthNames[month2];
  }
  static set locale(name) {
    locale2 = name;
    intlFormatterCache = {};
    formatCache = {};
    formatRedirects = {};
  }
  static get locale() {
    return locale2;
  }
  static setupDurationRegEx(unitNames = [], unitAbbreviations = []) {
    const me = this, unitLookup = {};
    let unitAbbrRegEx = "";
    for (let i = 0; i < unitAbbreviations.length; i++) {
      const abbreviations = unitAbbreviations[i], unitNamesCfg = unitNames[i];
      unitNamesCfg.canonicalUnitName = canonicalUnitNames[i];
      unitLookup[unitNamesCfg.single] = unitLookup[unitNamesCfg.single.toUpperCase()] = unitLookup[unitNamesCfg.canonicalUnitName] = unitLookup[unitNamesCfg.canonicalUnitName.toUpperCase()] = unitNamesCfg;
      unitAbbrRegEx += `${i ? "|" : ""}(`;
      for (let j = 0; j < abbreviations.length; j++) {
        unitAbbrRegEx += `${abbreviations[j]}|`;
      }
      locale2 = me.localize("L{locale}") || "en-US";
      if (locale2 !== "en-US") {
        const canonicalAbbreviations = canonicalUnitAbbreviations[i];
        for (let j = 0; j < canonicalAbbreviations.length; j++) {
          unitAbbrRegEx += `${canonicalAbbreviations[j]}|`;
        }
      }
      unitAbbrRegEx += `${unitNamesCfg.single}|${unitNamesCfg.plural}|${unitNamesCfg.canonicalUnitName}|${unitNamesCfg.canonicalUnitName}s)`;
    }
    me.unitLookup = unitLookup;
    me.durationRegEx = new RegExp(`^(?:${unitAbbrRegEx})$`);
  }
  static applyLocale() {
    const me = this, unitAbbreviations = me.localize("L{unitAbbreviations}") || [], unitNames = me.unitNames = me.localize("L{unitNames}");
    if (unitNames === "unitNames") {
      return;
    }
    locale2 = me.localize("L{locale}") || "en-US";
    if (locale2 === "en-US") {
      ordinalSuffix = enOrdinalSuffix;
    } else {
      ordinalSuffix = me.localize("L{ordinalSuffix}") || ordinalSuffix;
    }
    formatCache = {};
    formatRedirects = {};
    parserCache = {};
    intlFormatterCache = {};
    DH._weekStartDay = null;
    DH.setupDurationRegEx(unitNames, unitAbbreviations);
    DH.fillDayNames();
    DH.fillMonthNames();
  }
  //endregion
};
__publicField(_DateHelper, "MS_PER_DAY", MS_PER_HOUR * 24);
var DateHelper = _DateHelper;
var DH = DateHelper;
DH.useIntlFormat = useIntlFormat;
LocaleManager_default.ion({
  locale: "applyLocale",
  prio: 1e3,
  thisObj: DH
});
if (LocaleManager_default.locale) {
  DH.applyLocale();
}
DateHelper._$name = "DateHelper";

// ../Core/lib/Core/helper/ObjectHelper.js
var { hasOwn: hasOwn2 } = Objects;
var toFixedFix = 1.005.toFixed(2) === "1.01" ? null : function(number, fractionDigits) {
  const split2 = number.toString().split("."), newNumber = +(!split2[1] ? split2[0] : split2.join(".") + "1");
  return number.toFixed.call(newNumber, fractionDigits);
};
var ObjectHelper = class _ObjectHelper extends Objects {
  // These methods are inherited from Objects (an internal class) but need to be documented here for public use.
  // This is primarily because static methods, while inherited by JavaScript classes, are not displayed in derived
  // classes in the docs.
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`. Unlike `Object.assign`, this copy
   * also includes inherited properties.
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method assign
   * @static
   */
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`, only including properties that does
   * not already exist on `dest`. Unlike `Object.assign`, this copy also includes inherited properties.
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method assignIf
   * @static
   */
  /**
   * Creates a deep copy of the `value`. Simple objects ({@link #function-isObject-static}, arrays and `Date` objects
   * are cloned. The enumerable properties of simple objects and the elements of arrays are cloned recursively.
   * @param {*} value The value to clone.
   * @param {Function} [handler] An optional function to call for values of types other than simple object, array or
   * `Date`. This function should return the clone of the `value` passed to it. It is only called for truthy values
   * whose `typeof` equals `'object'`.
   * @param {*} handler.value The value to clone.
   * @returns {*} The cloned value.
   * @method clone
   * @static
   */
  /**
   * Converts a list of names (either a space separated string or an array), into an object with those properties
   * assigned truthy values. The converse of {@link #function-getTruthyKeys-static}.
   * @param {String|String[]} source The list of names to convert to object form.
   * @method createTruthyKeys
   * @static
   */
  /**
   * Gathers the names of properties which have truthy values into an array.
   *
   * This is useful when gathering CSS class names for complex element production.
   * Instead of appending to an array or string which may already contain the
   * name, and instead of contending with space separation and concatenation
   * and conditional execution, just set the properties of an object:
   *
   *     cls = {
   *         [this.selectedCls] : this.isSelected(thing),
   *         [this.dirtyCls] : this.isDirty(thing)
   *     };
   *
   * @param {Object} source Source of keys to gather into an array.
   * @returns {String[]} The keys which had a truthy value.
   * @method getTruthyKeys
   * @static
   */
  /**
   * Gathers the values of properties which are truthy into an array.
   * @param {Object} source Source of values to gather into an array.
   * @returns {String[]} The truthy values from the passed object.
   * @method getTruthyValues
   * @static
   */
  /**
   * Tests whether a passed object has any enumerable properties.
   * @param {Object} object
   * @returns {Boolean} `true` if the passed object has no enumerable properties.
   * @method isEmpty
   * @static
   */
  /**
   * Returns `true` if the `value` is a simple `Object`.
   * @param {Object} value
   * @returns {Boolean} `true` if the `value` is a simple `Object`.
   * @method isObject
   * @static
   */
  /**
   * Copies all enumerable properties from the supplied source objects to `dest`, recursing when the properties of
   * both the source and `dest` are objects.
   * ```
   *  const o = {
   *      a : 1,
   *      b : {
   *          c : 2
   *      }
   *  };
   *  const o2 = {
   *      b : {
   *          d : 3
   *      }
   *  }
   *
   *  console.log(merge(o, o2));
   *
   *  > { a : 1, b : { c : 2, d : 3 } }
   * ```
   * @param {Object} dest The destination object.
   * @param {...Object} sources The source objects.
   * @returns {Object} The `dest` object.
   * @method merge
   * @static
   */
  /**
   * Returns the specific type of the given `value`. Unlike the `typeof` operator, this function returns the text
   * from the `Object.prototype.toString` result allowing `Date`, `Array`, `RegExp`, and others to be differentiated.
   * ```
   *  console.log(typeOf(null));
   *  > null
   *
   *  console.log(typeOf({}));
   *  > object
   *
   *  console.log(typeOf([]));
   *  > array
   *
   *  console.log(typeOf(new Date()));
   *  > date
   *
   *  console.log(typeOf(NaN));
   *  > nan
   *
   *  console.log(typeOf(/a/));
   *  > regexp
   * ```
   * @param {*} value
   * @returns {String}
   * @method typeOf
   * @static
   */
  /**
   * Returns value for a given path in the object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {*} Value associated with passed key
   * @method getPath
   * @static
   */
  /**
   * Sets value for a given path in the object
   * @param {Object} object Target object
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @param {*} value Value for a given path
   * @returns {Object} Returns passed object
   * @method setPath
   * @static
   */
  /**
   * Creates a new object where key is a property in array item (`ref` by default) or index in the array and value is array item.
   *
   * From:
   * ```
   * [
   *     {
   *          text : 'foo',
   *          ref : 'fooItem'
   *     },
   *     {
   *          text : 'bar'
   *     }
   * ]
   * ```
   *
   * To:
   * ```
   * {
   *     fooItem : {
   *         text : 'foo',
   *         ref  : 'fooItem'
   *     },
   *     1 : {
   *         text : 'bar'
   *     }
   * }
   * ```
   *
   * @param {Object[]} arrayOfItems Array to transform.
   * @param {String} [prop] Property to read the key from. `ref` by default.
   * @returns {Object} namedItems
   */
  static transformArrayToNamedObject(arrayOfItems, prop = "ref") {
    const namedItems = {};
    arrayOfItems.forEach((item, index) => {
      const key = item[prop] != null && item[prop].toString().length ? item[prop] : index;
      namedItems[key] = item;
    });
    return namedItems;
  }
  /**
   * Creates a new array from object values and saves key in a property (`ref` by default) of each item.
   *
   * From:
   * ```
   * {
   *     fooItem : {
   *         text : 'foo'
   *     },
   *     1 : {
   *         text : 'bar'
   *     },
   *     barItem : false // will be ignored
   * }
   * ```
   *
   * To:
   * ```
   * [
   *     {
   *          text : 'foo',
   *          ref : 'fooItem'
   *     },
   *     {
   *          text : 'bar',
   *          ref : 1
   *     }
   * ]
   * ```
   *
   * @param {Object} namedItems Object to transform.
   * @param {String} [prop] Property to save the key to. `ref` by default.
   * @returns {Object[]} arrayOfItems
   */
  static transformNamedObjectToArray(namedItems, prop = "ref") {
    return Object.keys(namedItems).filter((key) => namedItems[key]).map((key) => {
      const item = namedItems[key];
      item[prop] = key;
      return item;
    });
  }
  /**
   * Checks if two values are equal. Basically === but special handling of dates.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {*} true if values are equal, otherwise false
   */
  static isEqual(a, b, useIsDeeply = false) {
    if (a === null && b !== null || a === void 0 && b !== void 0 || b === null && a !== null || b === void 0 && a !== void 0) {
      return false;
    }
    if (a == null && b == null) {
      return true;
    }
    if (a === b) {
      return true;
    }
    const typeA = typeof a, typeB = typeof b;
    if (typeA === typeB) {
      switch (typeA) {
        case "number":
        case "string":
        case "boolean":
          return a === b;
      }
      switch (true) {
        case (a instanceof Date && b instanceof Date):
          return a.getTime() === b.getTime();
        case (Array.isArray(a) && Array.isArray(b)):
          return a.length === b.length ? a.every((v, idx) => OH.isEqual(v, b[idx], useIsDeeply)) : false;
        case (typeA === "object" && a.constructor.prototype === b.constructor.prototype):
          return useIsDeeply ? OH.isDeeplyEqual(a, b, useIsDeeply) : StringHelper.safeJsonStringify(a, "circular") === StringHelper.safeJsonStringify(b, "circular");
      }
    }
    return String(a) === String(b);
  }
  /**
   * Checks if two objects are deeply equal
   * @param {Object} a
   * @param {Object} b
   * @param {Object} [options] Additional comparison options
   * @param {Object} [options.ignore] Map of property names to ignore when comparing
   * @param {Function} [options.shouldEvaluate] Function used to evaluate if a property should be compared or not.
   * Return false to prevent comparison
   * @param {Function} [options.evaluate] Function used to evaluate equality. Return `true`/`false` as evaluation
   * result or anything else to let `isEqual` handle the comparison
   * @returns {Boolean}
   */
  static isDeeplyEqual(a, b, options = {}) {
    if (a === b) {
      return true;
    }
    if (!a || !b) {
      return false;
    }
    const aKeys = OH.keys(a, options.ignore), bKeys = OH.keys(b, options.ignore);
    if (aKeys.length !== bKeys.length) {
      return false;
    }
    for (let i = 0; i < aKeys.length; i++) {
      const aKey = aKeys[i], bKey = bKeys[i];
      if (aKey !== bKey) {
        return false;
      }
      const aVal = a[aKey], bVal = b[bKey];
      if (options.shouldEvaluate) {
        if (options.shouldEvaluate(
          aKey,
          {
            value: aVal,
            object: a
          },
          {
            value: bVal,
            object: b
          }
        ) === false) {
          continue;
        }
      }
      if (options.evaluate) {
        const result = options.evaluate(aKey, {
          value: aVal,
          object: a
        }, {
          value: bVal,
          object: b
        });
        if (result === false) {
          return false;
        }
        if (result === true) {
          continue;
        }
      }
      if (!OH.isEqual(aVal, bVal, options)) {
        return false;
      }
    }
    return true;
  }
  /**
   * Checks if value B is partially equal to value A.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if values are partially equal, false otherwise
   */
  static isPartial(a, b) {
    a = String(a).toLowerCase();
    b = String(b).toLowerCase();
    return a.indexOf(b) !== -1;
  }
  /**
   * Checks if value a is smaller than value b.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if a < b
   */
  static isLessThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isBefore(a, b);
    }
    return a < b;
  }
  /**
   * Checks if value a is bigger than value b.
   * @param {*} a First value
   * @param {*} b Second value
   * @returns {Boolean} true if a > b
   */
  static isMoreThan(a, b) {
    if (a instanceof Date && b instanceof Date) {
      return DateHelper.isAfter(a, b);
    }
    return a > b;
  }
  /**
   * Used by the Base class to make deep copies of defaultConfig blocks
   * @private
   */
  static fork(obj) {
    let ret, key, value;
    if (obj && obj.constructor === Object) {
      ret = Object.setPrototypeOf({}, obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (value.constructor === Object) {
            ret[key] = OH.fork(value);
          } else if (value instanceof Array) {
            ret[key] = value.slice();
          }
        }
      }
    } else {
      ret = obj;
    }
    return ret;
  }
  /**
   * Copies the named properties from the `source` parameter into the `dest` parameter.
   * @param {Object} dest The destination into which properties are copied.
   * @param {Object} source The source from which properties are copied.
   * @param {String[]} props The list of property names.
   * @returns {Object} The `dest` object.
   */
  static copyProperties(dest, source, props) {
    let prop, i;
    for (i = 0; i < props.length; i++) {
      prop = props[i];
      if (prop in source) {
        dest[prop] = source[prop];
      }
    }
    return dest;
  }
  /**
   * Copies the named properties from the `source` parameter into the `dest` parameter
   * unless the property already exists in the `dest`.
   * @param {Object} dest The destination into which properties are copied.
   * @param {Object} source The source from which properties are copied.
   * @param {String[]} props The list of property names.
   * @returns {Object} The `dest` object.
   */
  static copyPropertiesIf(dest, source, props) {
    if (source) {
      for (const prop of props) {
        if (!(prop in dest) && prop in source) {
          dest[prop] = source[prop];
        }
      }
    }
    return dest;
  }
  /**
   * Returns an array containing the keys and values of all enumerable properties from every prototype level for the
   * object. If `object` is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve entries.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @returns {Array}
   * @internal
   */
  static entries(object, ignore) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore == null ? void 0 : ignore[p])) {
          result.push([p, object[p]]);
        }
      }
    }
    return result;
  }
  /**
   * Populates an `object` with the provided `entries`.
   * @param {Array} entries The key/value pairs (2-element arrays).
   * @param {Object} [object={}] The object onto which to add `entries`.
   * @returns {Object} The passed `object` (by default, a newly created object).
   * @internal
   */
  static fromEntries(entries, object) {
    object = object || {};
    if (entries) {
      for (let i = 0; i < entries.length; ++i) {
        object[entries[i][0]] = entries[i][1];
      }
    }
    return object;
  }
  /**
   * Returns an array containing all enumerable property names from every prototype level for the object. If `object`
   * is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve property names.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @param {Function} [mapper] Optional function to call for each non-ignored item. If provided, the result of this
   * function is stored in the returned array. It is called with the array element as the first parameter, and the
   * index in the result array as the second argument (0 for the first, non-ignored element, 1 for the second and so
   * on).
   * @returns {String[]}
   */
  static keys(object, ignore, mapper) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore == null ? void 0 : ignore[p])) {
          result.push(mapper ? mapper(p, index) : p);
          ++index;
        }
      }
    }
    return result;
  }
  /**
   * Returns an array containing the values of all enumerable properties from every prototype level for the object.
   * If `object` is `null`, this method returns an empty array.
   * @param {Object} object Object from which to retrieve values.
   * @param {Object|Function} [ignore] Optional object of names to ignore or a function accepting the name and value
   * which returns `true` to ignore the item.
   * @param {Function} [mapper] Optional function to call for each non-ignored item. If provided, the result of this
   * function is stored in the returned array. It is called with the array element as the first parameter, and the
   * index in the result array as the second argument (0 for the first, non-ignored element, 1 for the second and so
   * on).
   * @returns {Array}
   * @internal
   */
  static values(object, ignore, mapper) {
    const result = [], call = typeof ignore === "function";
    if (object) {
      let index = 0;
      for (const p in object) {
        if (call ? !ignore(p, object[p]) : !(ignore == null ? void 0 : ignore[p])) {
          result.push(mapper ? mapper(object[p], index) : object[p]);
          ++index;
        }
      }
    }
    return result;
  }
  //region Path
  /**
   * Checks if a given path exists in an object
   * @param {Object} object Object to check path on
   * @param {String} path Dot-separated path, e.g. 'object.childObject.someKey'
   * @returns {Boolean} Returns `true` if path exists or `false` if it does not
   */
  static pathExists(object, path) {
    const properties = path.split(".");
    return properties.every((property) => {
      if (!object || !(property in object)) {
        return false;
      }
      object = object[property];
      return true;
    });
  }
  /**
   * Creates a simple single level key-value object from complex deep object.
   * @param {Object} object Object to extract path and values from
   * @returns {Object} Key-value object where key is a path to the corresponding value
   * @internal
   *
   * ```javascript
   * // converts deep object
   * {
   *     foo : {
   *         bar : {
   *             test : 1
   *         }
   *     }
   * }
   * // into a single level object
   * {
   *     'foo.bar.test' : 1
   * }
   * ```
   */
  static pathifyKeys(object, fieldDataSourceMap) {
    const result = {};
    for (const key in object) {
      if (hasOwn2(object, key)) {
        const field = fieldDataSourceMap == null ? void 0 : fieldDataSourceMap[key];
        const usesPathKeys = (field == null ? void 0 : field.type) === "object" || (field == null ? void 0 : field.complexMapping) || !Boolean(fieldDataSourceMap);
        if (usesPathKeys && Array.isArray(object[key])) {
          result[key] = object[key].slice();
        } else if (usesPathKeys && object[key] instanceof Object) {
          const paths = this.pathifyKeys(object[key]);
          for (const path in paths) {
            result[`${key}.${path}`] = paths[path];
          }
        } else {
          result[key] = object[key];
        }
      }
    }
    return result;
  }
  /**
   * Removes value for a given path in the object. Doesn't cleanup empty objects.
   * @param {Object} object
   * @param {String} path Dot-separated path, e.g. `obj.child.someKey`
   * @internal
   */
  static deletePath(object, path) {
    path.split(".").reduce((result, key, index, array) => {
      if (result == null) {
        return null;
      }
      if (hasOwn2(result, key)) {
        if (index === array.length - 1) {
          delete result[key];
        } else {
          return result[key];
        }
      }
    }, object);
  }
  //endregion
  static coerce(from, to) {
    const fromType = Objects.typeOf(from), toType = Objects.typeOf(to), isString = typeof from === "string";
    if (fromType !== toType) {
      switch (toType) {
        case "string":
          return String(from);
        case "number":
          return Number(from);
        case "boolean":
          return isString && (!from || from === "false" || from === "0") ? false : Boolean(from);
        case "null":
          return isString && (!from || from === "null") ? null : false;
        case "undefined":
          return isString && (!from || from === "undefined") ? void 0 : false;
        case "date":
          return isString && isNaN(from) ? DateHelper.parse(from) : Date(Number(from));
      }
    }
    return from;
  }
  static wrapProperty(object, propertyName, newGetter, newSetter, deep = true) {
    const newProperty = {};
    let proto4 = Object.getPrototypeOf(object), existingProperty = Object.getOwnPropertyDescriptor(proto4, propertyName);
    while (!existingProperty && proto4 && deep) {
      proto4 = Object.getPrototypeOf(proto4);
      if (proto4) {
        existingProperty = Object.getOwnPropertyDescriptor(proto4, propertyName);
      }
    }
    if (existingProperty) {
      if (existingProperty.set) {
        newProperty.set = (v) => {
          existingProperty.set.call(object, v);
          newSetter && newSetter.call(object, existingProperty.get.call(object));
        };
      } else {
        newProperty.set = newSetter;
      }
      if (existingProperty.get) {
        newProperty.get = () => {
          let result = existingProperty.get.call(object);
          if (newGetter) {
            result = newGetter.call(object, result);
          }
          return result;
        };
      } else {
        newProperty.get = newGetter;
      }
    } else {
      newProperty.set = (v) => {
        object[`_${propertyName}`] = v;
        newSetter && newSetter.call(object, v);
      };
      newProperty.get = () => {
        let result = object[`_${propertyName}`];
        if (newGetter) {
          result = newGetter.call(object, result);
        }
        return result;
      };
    }
    Object.defineProperty(object, propertyName, newProperty);
  }
  /**
   * Intercepts access to a `property` of a given `object`.
   *
   * ```javascript
   *      ObjectHelper.hookProperty(object, 'prop', class {
   *          get value() {
   *              return super.value;
   *          }
   *          set value(v) {
   *              super.value = v;
   *          }
   *      });
   * ```
   * The use of `super` allows the hook's getter and setter to invoke the object's existing get/set.
   *
   * @param {Object} object
   * @param {String} property
   * @param {Function} hook A `class` defining a `value` property getter and/or setter.
   * @returns {Function} A function that removes the hook when called.
   * @internal
   */
  static hookProperty(object, property, hook) {
    const desc = _ObjectHelper.getPropertyDescriptor(hook.prototype, "value"), existingDesc = _ObjectHelper.getPropertyDescriptor(object, property), fieldName = `_${property}`, base = class {
      get value() {
        return existingDesc ? existingDesc.get.call(this) : this[fieldName];
      }
      set value(v) {
        if (existingDesc) {
          existingDesc.set.call(this, v);
        } else {
          this[fieldName] = v;
        }
      }
    }, baseDesc = _ObjectHelper.getPropertyDescriptor(base.prototype, "value");
    Object.setPrototypeOf(hook.prototype, base.prototype);
    Object.defineProperty(object, property, {
      configurable: true,
      get: desc.get || baseDesc.get,
      set: desc.set || baseDesc.set
    });
    return () => delete object[property];
  }
  /**
   * Finds a property descriptor for the passed object from all inheritance levels.
   * @param {Object} object The Object whose property to find.
   * @param {String} propertyName The name of the property to find.
   * @returns {Object} An ECMA property descriptor is the property was found, otherwise `null`
   */
  static getPropertyDescriptor(object, propertyName) {
    let result = null;
    for (let o = object; o && !result && !hasOwn2(o, "isBase"); o = Object.getPrototypeOf(o)) {
      result = Object.getOwnPropertyDescriptor(o, propertyName);
    }
    return result;
  }
  /**
   * Changes the passed object and removes all null and undefined properties from it
   * @param {Object} object Target object
   * @param {Boolean} [keepNull] Pass true to only remove undefined properties
   * @returns {Object} Passed object
   */
  static cleanupProperties(object, keepNull = false) {
    Object.entries(object).forEach(([key, value]) => {
      if (keepNull) {
        value === void 0 && delete object[key];
      } else {
        value == null && delete object[key];
      }
    });
    return object;
  }
  /**
   * Changes the passed object and removes all properties from it.
   * Used while mutating when need to keep reference to the object but replace its properties.
   * @param {Object} object Target object
   * @returns {Object} Passed object
   */
  static removeAllProperties(obj) {
    Object.keys(obj).forEach((key) => delete obj[key]);
    return obj;
  }
  //region Assert type
  /**
   * Checks that the supplied value is of the specified type.Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} type Expected type
   * @param {String} name Name of the value, used in error message
   * @param {Boolean} [allowNull] Accept `null` without throwing
   */
  static assertType(value, type, name) {
    const valueType = Objects.typeOf(value);
    if (value != null && valueType !== type) {
      throw new Error(`Incorrect type "${valueType}" for ${name}, expected "${type}"`);
    }
  }
  /**
   * Checks that the supplied value is a plain object. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertObject(value, name) {
    OH.assertType(value, "object", name);
  }
  /**
   * Checks that the supplied value is an instance of a Bryntum class. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertInstance(value, name) {
    OH.assertType(value, "instance", name);
  }
  /**
   * Checks that the supplied value is a Bryntum class. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertClass(value, name) {
    OH.assertType(value, "class", name);
  }
  /**
   * Checks that the supplied value is a function. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertFunction(value, name) {
    if (typeof value !== "function" || value.isBase || value.$$name) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a function)`);
    }
  }
  /**
   * Checks that the supplied value is a number. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertNumber(value, name) {
    const asNumber = Number(value);
    if (typeof value !== "number" || isNaN(asNumber)) {
      throw new Error(`Incorrect type for ${name}, got "${value}" (expected a Number)`);
    }
  }
  /**
   * Checks that the supplied value is a boolean. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertBoolean(value, name) {
    OH.assertType(value, "boolean", name);
  }
  /**
   * Checks that the supplied value is a string. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertString(value, name) {
    OH.assertType(value, "string", name);
  }
  /**
   * Checks that the supplied value is an array. Throws if it is not
   * @param {Object} value Value to check type of
   * @param {String} name Name of the value, used in error message
   */
  static assertArray(value, name) {
    OH.assertType(value, "array", name);
  }
  //endregion
  /**
   * Number.toFixed(), with polyfill for browsers that needs it
   * @param {Number} number
   * @param {Number} digits
   * @returns {String} A fixed point string representation of the passed number.
   */
  static toFixed(number, digits) {
    if (toFixedFix) {
      return toFixedFix(number, digits);
    }
    return number.toFixed(digits);
  }
  /**
   * Round the passed number to closest passed step value.
   * @param {Number} number The number to round.
   * @param {Number} [step] The step value to round to.
   * @returns {Number} The number rounded to the closest step.
   */
  static roundTo(number, step = 1) {
    return Math.round(number / step) * step;
  }
  /**
   * Round the passed number to the passed number of decimals.
   * @param {Number} number The number to round.
   * @param {Number} digits The number of decimal places to round to.
   * @returns {Number} The number rounded to the passed number of decimal places.
   */
  static round(number, digits) {
    if (digits == null) {
      return number;
    }
    const factor = 10 ** digits;
    return Math.round(number * factor) / factor;
  }
  /**
   * Returns a non-null entry from a Map for a given key path. This enables a specified defaultValue to be added "just
   * in time" which is returned if the key is not already present.
   * @param {Map} map The Map to find the key in (and potentially add to).
   * @param {String|Number|String[]|Number[]} path Dot-separated path, e.g. 'firstChild.childObject.someKey',
   * or the key path as an array, e.g. ['firstChild', 'childObject', 'someKey'].
   * @param {Object} [defaultValue] Optionally the value to insert if the key is not found.
   */
  static getMapPath(map2, path, defaultValue2) {
    const keyPath = Array.isArray(path) ? path : typeof path === "string" ? path.split(".") : [path], simpleKey = keyPath.length === 1, topKey = keyPath[0], topValue = map2.has(topKey) ? map2.get(topKey) : map2.set(topKey, simpleKey ? defaultValue2 : {}).get(topKey);
    if (simpleKey) {
      return topValue;
    }
    return OH.getPathDefault(topValue, keyPath.slice(1), defaultValue2);
  }
};
var OH = ObjectHelper;
ObjectHelper._$name = "ObjectHelper";

// ../Core/lib/Core/helper/util/Rectangle.js
var zeroBased;
var allBorders = ["border-top-width", "border-right-width", "border-bottom-width", "border-left-width"];
var allMargins = ["margin-top", "margin-right", "margin-bottom", "margin-left"];
var allPaddings = ["padding-top", "padding-right", "padding-bottom", "padding-left"];
var borderNames = {
  t: "border-top-width",
  r: "border-right-width",
  b: "border-bottom-width",
  l: "border-left-width"
};
var paddingNames = {
  t: "padding-top",
  r: "padding-right",
  b: "padding-bottom",
  l: "padding-left"
};
var alignSpecRe = /^([trblc])(\d*)-([trblc])(\d*)$/i;
var alignPointRe = /^([trblc])(\d*)$/i;
var edgeNames = [
  "top",
  "right",
  "bottom",
  "left"
];
var edgeIndices = {
  t: 0,
  r: 1,
  b: 2,
  l: 3
};
var defaultAlignments = [
  "b-t",
  "l-r",
  "t-b",
  "r-l"
];
var edgeAligments = {
  bt: 1,
  tb: 1,
  lr: 2,
  rl: 2
};
var zeroOffsets = Object.freeze([0, 0]);
var matchDimensions = ["width", "height"];
var parseEdges = (top, right = top, bottom = top, left = right) => {
  return Array.isArray(top) ? parseEdges.apply(null, top) : [top, right, bottom, left];
};
var emptyArray2 = Object.freeze([]);
function parseAlign(alignSpec, rtl) {
  const parts = alignSpecRe.exec(alignSpec), myEdge = parts[1], targetEdge = parts[3], mO = parseInt(parts[2] || 50), tO = parseInt(parts[4] || 50), myOffset = rtl && !(edgeIndices[myEdge] & 1) ? 100 - mO : mO, targetOffset = rtl && !(edgeIndices[targetEdge] & 1) ? 100 - tO : tO, edgeAligned = edgeAligments[myEdge + targetEdge];
  return {
    myAlignmentPoint: myEdge + myOffset,
    // l0
    myEdge,
    // l
    myOffset,
    // 0
    targetAlignmentPoint: targetEdge + targetOffset,
    // r0
    targetEdge,
    // r
    targetOffset,
    // 0
    startZone: edgeIndices[targetEdge],
    // 1 - start trying zone 1 in TRBL order
    edgeAligned
    // Edge-to-edge align requested
  };
}
function flipAlign(align) {
  return `${edgeNames[(edgeIndices[align.myEdge] + 2) % 4][0]}${align.myOffset}-${edgeNames[(edgeIndices[align.targetEdge] + 2) % 4][0]}${align.targetOffset}`;
}
function createOffsets(offset) {
  if (offset == null) {
    return zeroOffsets;
  } else if (typeof offset === "number") {
    return [offset, offset];
  }
  return offset;
}
var Rectangle = class _Rectangle {
  /**
   * Constructs a Rectangle
   * @param {Number} x The X coordinate
   * @param {Number} y The Y coordinate
   * @param {Number} width The width
   * @param {Number} height The height
   */
  constructor(x, y, width, height) {
    // Class does not extend Base, so we need to define this
    __publicField(this, "isRectangle", true);
    ObjectHelper.assertNumber(x, "Rectangle.x");
    ObjectHelper.assertNumber(y, "Rectangle.y");
    ObjectHelper.assertNumber(width, "Rectangle.width");
    ObjectHelper.assertNumber(height, "Rectangle.height");
    const me = this;
    if (width < 0) {
      x += width;
      width = -width;
    }
    if (height < 0) {
      y += height;
      height = -height;
    }
    me._x = x;
    me._y = y;
    me._width = width;
    me._height = height;
  }
  /**
   * Returns the Rectangle in document based coordinates of the passed element.
   *
   * *Note:* If the element passed is the `document` or `window` the `window`'s
   * rectangle is returned which is always at `[0, 0]` and encompasses the
   * browser's entire document viewport.
   * @param {HTMLElement|Core.widget.Widget|Core.widget.Mask} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll=false] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static from(element, relativeTo, ignorePageScroll) {
    if (typeof element === "string") {
      element = document.querySelector(element);
    } else if ((element == null ? void 0 : element.nodeType) === Node.DOCUMENT_FRAGMENT_NODE) {
      element = element.host || element.ownerDocument;
    }
    if (typeof relativeTo === "string") {
      relativeTo = document.querySelector(relativeTo);
    }
    if (element == null || element.isRectangle) {
      return element;
    }
    element = element.element || element;
    if (ignorePageScroll === void 0 && typeof relativeTo === "boolean") {
      ignorePageScroll = relativeTo;
      relativeTo = null;
    }
    if (!(relativeTo == null ? void 0 : relativeTo.isRectangle)) {
      if (relativeTo) {
        let { scrollLeft, scrollTop } = relativeTo;
        if (BrowserHelper.isSafari && relativeTo === document.body) {
          scrollLeft = scrollTop = 0;
        }
        relativeTo = _Rectangle.from(relativeTo).translate(-scrollLeft, -scrollTop);
      } else {
        if (!zeroBased) {
          zeroBased = new _Rectangle(0, 0, 0, 0);
        }
        relativeTo = zeroBased;
      }
    }
    const isViewport = element === document || element === globalThis, isSFViewport = element === document.body && document.body.offsetHeight === 0, sfElRect = isSFViewport && element.getBoundingClientRect(), viewRect = isSFViewport ? new _Rectangle(sfElRect.left, sfElRect.top, sfElRect.width, document.body.parentElement.scrollHeight) : isViewport ? new _Rectangle(0, 0, globalThis.innerWidth, globalThis.innerHeight) : element.getBoundingClientRect(), scrollOffset = ignorePageScroll || isViewport ? [0, 0] : [globalThis.pageXOffset, globalThis.pageYOffset];
    return new _Rectangle(
      viewRect.left + scrollOffset[0] - relativeTo.x,
      viewRect.top + scrollOffset[1] - relativeTo.y,
      viewRect.width,
      viewRect.height
    );
  }
  /**
   * Returns the Rectangle in viewport coordinates of the passed element.
   *
   * *Note:* If the element passed is the `document` or `window` the `window`'s rectangle is returned which is always
   * at `[0, 0]` and encompasses the browser's entire document viewport.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @returns {Core.helper.util.Rectangle} The Rectangle in viewport based coordinates. Relative to the _relativeTo_
   * parameter if provided.
   */
  static fromScreen(element, relativeTo) {
    return _Rectangle.from(
      element,
      relativeTo,
      /* ignorePageScroll = */
      true
    );
  }
  /**
   * Returns the inner Rectangle (within border) in document based coordinates of the passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static inner(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders);
      result.x += parseFloat(borders[borderNames.l]);
      result.y += parseFloat(borders[borderNames.t]);
      result.right -= parseFloat(borders[borderNames.r]);
      result.bottom -= parseFloat(borders[borderNames.b]);
    }
    return result;
  }
  /**
   * Returns the content Rectangle (within border and padding) in document based coordinates of the passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static content(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const borders = DomHelper.getStyleValue(element, allBorders), padding = DomHelper.getStyleValue(element, allPaddings);
      result.x += parseFloat(borders[borderNames.l]) + parseFloat(padding[paddingNames.l]);
      result.y += parseFloat(borders[borderNames.t]) + parseFloat(padding[paddingNames.t]);
      result.right -= parseFloat(borders[borderNames.r]) + parseFloat(padding[paddingNames.r]);
      result.bottom -= parseFloat(borders[borderNames.b]) + parseFloat(padding[paddingNames.b]);
    }
    return result;
  }
  /**
   * Returns the client Rectangle (within border and padding and scrollbars) in document based coordinates of the
   * passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @param {Boolean} [clipStickies] Return the Rectangle *within* any sticky elements docked at the element edges.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates. Relative to the _relativeTo_ parameter if passed.
   */
  static client(element, relativeTo, ignorePageScroll = false, clipStickies) {
    const result = this.content(element, relativeTo, ignorePageScroll), scrollbarWidth = DomHelper.scrollBarWidth, stickies = clipStickies ? [...element.children].filter((e) => DomHelper.getStyleValue(e, "position") === "sticky") : emptyArray2;
    ;
    let padding;
    if (scrollbarWidth && !element.classList.contains("b-hide-scroll")) {
      if (element.scrollHeight > element.clientHeight && DomHelper.getStyleValue(element, "overflow-y") !== "hidden") {
        padding = parseFloat(DomHelper.getStyleValue(element, "padding-right"));
        result.right += padding - Math.max(padding, scrollbarWidth);
      }
      if (element.scrollWidth > element.clientWidth && DomHelper.getStyleValue(element, "overflow-x") !== "hidden") {
        padding = parseFloat(DomHelper.getStyleValue(element, "padding-bottom"));
        result.bottom += padding - Math.max(padding, scrollbarWidth);
      }
    }
    for (let i = 0, { length } = stickies; i < length; i++) {
      const e = stickies[i], r = this.fromScreen(e);
      if (parseFloat(DomHelper.getStyleValue(e, "left")) === 0) {
        result.x += r.width;
      } else if (parseFloat(DomHelper.getStyleValue(e, "right")) === 0) {
        result.right -= r.width;
      } else if (parseFloat(DomHelper.getStyleValue(e, "top")) === 0) {
        result.y += r.height;
      } else if (parseFloat(DomHelper.getStyleValue(e, "bottom")) === 0) {
        result.bottom -= r.height;
      }
    }
    return result;
  }
  /**
   * Returns the outer Rectangle (including margin) in document based coordinates of the passed element.
   * @param {HTMLElement} element The element to calculate the Rectangle for.
   * @param {HTMLElement} [relativeTo] Optionally, a parent element in whose space to calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle} The Rectangle in document based (or, optionally viewport based) coordinates.
   * Relative to the _relativeTo_ parameter if passed.
   * @internal
   */
  static outer(element, relativeTo, ignorePageScroll = false) {
    const result = this.from(element, relativeTo, ignorePageScroll);
    if (document.body.contains(element)) {
      const margin = DomHelper.getStyleValue(element, allMargins);
      result.x -= parseFloat(margin["margin-left"]);
      result.y -= parseFloat(margin["margin-top"]);
      result.right += parseFloat(margin["margin-right"]);
      result.bottom += parseFloat(margin["margin-bottom"]);
    }
    return result;
  }
  /**
   * Returns a new rectangle created as the union of all supplied rectangles.
   * @param {Core.helper.util.Rectangle[]} rectangles
   * @returns {Core.helper.util.Rectangle}
   */
  static union(...rectangles) {
    let { x, y, right, bottom } = rectangles[0], current;
    if (rectangles.length > 1) {
      for (let i = 1; i < rectangles.length; i++) {
        current = rectangles[i];
        if (current.x < x) {
          x = current.x;
        }
        if (current.y < y) {
          y = current.y;
        }
        if (current.right > right) {
          right = current.right;
        }
        if (current.bottom > bottom) {
          bottom = current.bottom;
        }
      }
    }
    return new _Rectangle(x, y, right - x, bottom - y);
  }
  /**
   * Rounds this Rectangle to the pixel resolution of the current display or to the nearest
   * passed unit which defaults to the current display's [`devicePixelRatio`](https://developer.mozilla.org/en-US/docs/Web/API/Window/devicePixelRatio).
   * @param {Number} [devicePixelRatio] device pixel ratio which defaults to `window.devicePixelRatio`
   */
  roundPx(devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const me = this;
    me._x = DomHelper.roundPx(me._x, devicePixelRatio);
    me._y = DomHelper.roundPx(me._y, devicePixelRatio);
    me._width = DomHelper.roundPx(me._width, devicePixelRatio);
    me._height = DomHelper.roundPx(me._height, devicePixelRatio);
    return me;
  }
  // This class doesn't extend Base and extending doesn't seem to be
  // the way to go. Instead we duplicate smallest piece of logic here
  static get $$name() {
    return hasOwnProperty.call(this, "$name") && this.$name || // _$name is filled by webpack for every class (cls._$name = '...')
    hasOwnProperty.call(this, "_$name") && this._$name || this.name;
  }
  get $$name() {
    return this.constructor.$$name;
  }
  /**
   * Creates a copy of this Rectangle.
   */
  clone() {
    const me = this, result = new _Rectangle(me.x, me.y, me.width, me.height);
    result.isAlignRectangle = me.isAlignRectangle;
    result.minHeight = me.minHeight;
    result.minWidth = me.minWidth;
    return result;
  }
  /**
   * Returns `true` if this Rectangle wholly contains the passed rectangle.
   *
   * Note that a {@link Core.helper.util.Rectangle.Point} may be passed.
   * @param {Core.helper.util.Rectangle} other The Rectangle to test for containment within this Rectangle
   * @returns {Boolean} `true` if the other Rectangle is wholly contained within this Rectangle
   */
  contains(other) {
    const me = this;
    if (other.isRectangle) {
      return other._x >= me._x && other._y >= me._y && other.right <= me.right && other.bottom <= me.bottom;
    } else {
      return false;
    }
  }
  /**
   * Checks if this Rectangle intersects the passed Rectangle
   * @param {Core.helper.util.Rectangle} other The Rectangle to intersect with this.
   * @param {Boolean} [useBoolean] Specify `true` to return a boolean value instead of constructing a new Rectangle
   * @param {Boolean} [allowZeroDimensions] `true` to consider zero-width or zero-hight rectangles as intersecting if coordinates indicate the intersection
   * @returns {Core.helper.util.Rectangle|Boolean} Returns the intersection Rectangle or `false` if there is no intersection.
   */
  intersect(other, useBoolean = false, allowZeroDimensions = false) {
    const me = this, y = Math.max(me.y, other.y), r = Math.min(me.right, other.right), b = Math.min(me.bottom, other.bottom), x = Math.max(me.x, other.x), intersect = allowZeroDimensions ? b >= y && r >= x : b > y && r > x;
    if (intersect) {
      return useBoolean ? true : new _Rectangle(x, y, r - x, b - y);
    } else {
      return false;
    }
  }
  equals(other, round2 = false) {
    const processor = round2 ? (x) => Math.round(x) : (x) => x;
    return other.isRectangle && processor(other.x) === processor(this.x) && processor(other.y) === processor(this.y) && processor(other.width) === processor(this.width) && processor(other.height) === processor(this.height);
  }
  /**
   * Translates this Rectangle by the passed vector. Size is maintained.
   * @param {Number} x The X translation vector.
   * @param {Number} y The Y translation vector.
   * @returns {Core.helper.util.Rectangle} This Rectangle;
   */
  translate(x, y) {
    this._x += x || 0;
    this._y += y || 0;
    return this;
  }
  /**
   * Moves this Rectangle to the passed `x`, `y` position. Size is maintained.
   * @param {Number} x The new X position.
   * @param {Number} y The new Y position.
   * @returns {Core.helper.util.Rectangle}  This Rectangle;
   */
  moveTo(x, y) {
    if (x != null) {
      this._x = x;
    }
    if (y != null) {
      this._y = y;
    }
    return this;
  }
  /**
   * Returns the vector which would translate this Rectangle (or Point) to the same position as the other Rectangle (or point)
   * @param {Core.helper.util.Rectangle|Core.helper.util.Rectangle.Point} other The Rectangle or Point to calculate the delta to.
   * @returns {Array} Returns a vector using format `[deltaX, deltaY]`
   * @internal
   */
  getDelta(other) {
    return [other.x - this.x, other.y - this.y];
  }
  /**
   * The center point of this rectangle.
   * @property {Core.helper.util.Rectangle.Point}
   */
  get center() {
    const result = new Point(this.x + this.width / 2, this.y + this.height / 2, 0, 0);
    result.target = this.target;
    return result;
  }
  /**
   * Get/sets the X coordinate of the Rectangle. Note that this does *not* translate the
   * Rectangle. The requested {@link #property-width} will change.
   * @property {Number}
   */
  set x(x) {
    const xDelta = x - this._x;
    this._x = x;
    this._width -= xDelta;
  }
  get x() {
    return this._x;
  }
  get start() {
    return this.left;
  }
  /**
   * Alias for x. To match DOMRect.
   * @property {Number}
   */
  set left(x) {
    this.x = x;
  }
  get left() {
    return this.x;
  }
  /**
   * Alias for y. To match DOMRect.
   * @property {Number}
   */
  set top(y) {
    this.y = y;
  }
  get top() {
    return this.y;
  }
  /**
   * Get/sets the Y coordinate of the Rectangle. Note that this does *not* translate the
   * Rectangle. The requested {@link #property-height} will change.
   * @property {Number}
   */
  set y(y) {
    const yDelta = y - this._y;
    this._y = y;
    this._height -= yDelta;
  }
  get y() {
    return this._y;
  }
  /**
   * Get/sets the width of the Rectangle. Note that the requested {@link #property-right} will change.
   * @property {Number}
   */
  set width(width) {
    this._width = width;
  }
  get width() {
    return this._width;
  }
  /**
   * Get/sets the height of the Rectangle. Note that the requested {@link #property-bottom} will change.
   * @property {Number}
   */
  set height(height) {
    this._height = height;
  }
  get height() {
    return this._height;
  }
  /**
   * Get/sets the right edge of the Rectangle. Note that the requested {@link #property-width} will change.
   *
   * The right edge value is exclusive of the calculated rectangle width. So x=0 and right=10
   * means a width of 10.
   * @property {Number}
   */
  set right(right) {
    this._width = right - this._x;
  }
  get right() {
    return this._x + this._width;
  }
  get end() {
    return this.right;
  }
  /**
   * Get/sets the bottom edge of the Rectangle. Note that the requested {@link #property-height} will change.
   *
   * The bottom edge value is exclusive of the calculated rectangle height. So y=0 and bottom=10
   * means a height of 10.
   * @property {Number}
   */
  set bottom(bottom) {
    this._height = bottom - this._y;
  }
  get bottom() {
    return this._y + this._height;
  }
  getStart(rtl, horizontal = true) {
    if (horizontal) {
      return rtl ? this.right : this.left;
    }
    return this.top;
  }
  getEnd(rtl, horizontal = true) {
    if (horizontal) {
      return rtl ? this.left : this.right;
    }
    return this.bottom;
  }
  get area() {
    return this.width * this.height;
  }
  set minWidth(minWidth) {
    const me = this;
    if (isNaN(minWidth)) {
      me._minWidth = null;
    } else {
      me._minWidth = Number(minWidth);
      if (!me.isAlignRectangle) {
        me.width = Math.max(me.width, me._minWidth);
      }
    }
  }
  get minWidth() {
    return this._minWidth;
  }
  set minHeight(minHeight) {
    const me = this;
    if (isNaN(minHeight)) {
      me._minHeight = null;
    } else {
      me._minHeight = Number(minHeight);
      if (!me.isAlignRectangle) {
        me.height = Math.max(me.height, me._minHeight);
      }
    }
  }
  get minHeight() {
    return this._minHeight;
  }
  /**
   * Modifies the bounds of this Rectangle by the specified deltas.
   * @param {Number} x How much to *add* to the x position.
   * @param {Number} y  How much to *add* to the y position.
   * @param {Number} width  How much to add to the width.
   * @param {Number} height  How much to add to the height.
   * @returns {Core.helper.util.Rectangle} This Rectangle
   */
  adjust(x, y, width, height) {
    const me = this;
    me.x += x;
    me.y += y;
    me.width += width;
    me.height += height;
    return me;
  }
  /**
   * Modifies the bounds of this rectangle by expanding them by the specified amount in all directions.
   * The parameters are read the same way as CSS margin values.
   *
   * - If one value is passed, all edges are inflated by that value.
   * - If two values are passed they are top/bottom inflation and left/right inflation.
   * - If four values are passed, that's top, right, bottom, left.
   * @param {Number} amount How much to inflate, or the top value if more than one values passed.
   * @param {Number} right How much to inflate the right side, or both left and right is only two values passed.
   * @param {Number} bottom How much to inflate the bottom side.
   * @param {Number} left How much to inflate the left side.
   * @returns {Core.helper.util.Rectangle} This Rectangle
   * @internal
   */
  inflate(top, right = top, bottom = top, left = right) {
    if (Array.isArray(top)) {
      [top, right, bottom, left] = parseEdges(top);
    }
    return this.adjust(-left, -top, right, bottom);
  }
  /**
   * Modifies the bounds of this rectangle by reducing them by the specified amount in all directions.
   * The parameters are read the same way as CSS margin values.
   *
   * - If one value is passed, all edges are deflated by that value.
   * - If two values are passed they are top/bottom deflation and left/right deflation.
   * - If four values are passed, that's top, right, bottom, left.
   * @param {Number} amount How much to deflate, or the top value if more than one values passed.
   * @param {Number} right How much to deflate the right side, or both left and right is only two values passed.
   * @param {Number} bottom How much to deflate the bottom side.
   * @param {Number} left How much to deflate the left side.
   * @returns {Core.helper.util.Rectangle} This Rectangle
   * @internal
   */
  deflate(top, right = top, bottom = top, left = right) {
    if (Array.isArray(top)) {
      [top, right, bottom, left] = parseEdges(top);
    }
    return this.adjust(left, top, -right, -bottom);
  }
  /**
   * Attempts constrain this Rectangle into the passed Rectangle. If the `strict` parameter is `true`
   * then this method will return `false` if constraint could not be achieved.
   *
   * If this Rectangle has a `minHeight` or `minWidth` property, size will be adjusted while attempting to constrain.
   *
   * Right and bottom are adjusted first leaving the top and bottom sides to "win" in the case that this Rectangle overflows
   * the constrainTo Rectangle.
   * @param {Core.helper.util.Rectangle} constrainTo The Rectangle to constrain this Rectangle into if possible.
   * @param {Boolean} strict Pass `true` to return false, and leave this Rectangle unchanged if constraint
   * could not be achieved.
   * @returns {Core.helper.util.Rectangle|Boolean} This Rectangle. If `strict` is true, and constraining was not successful, `false`.
   */
  constrainTo(constrainTo, strict) {
    const me = this, originalHeight = me.height, originalY = me.y, minWidth = me.minWidth || me.width, minHeight = me.minHeight || me.height;
    if (me.height >= constrainTo.height) {
      if (strict && minHeight > constrainTo.height) {
        return false;
      }
      me._y = constrainTo.y;
      me.height = constrainTo.height;
    }
    if (me.width >= constrainTo.width) {
      if (strict && minWidth > constrainTo.width) {
        me.y = originalY;
        me.height = originalHeight;
        return false;
      }
      me._x = constrainTo.x;
      me.width = constrainTo.width;
    }
    me.translate.apply(me, me.constrainVector = [
      Math.min(constrainTo.right - me.right, 0),
      Math.min(constrainTo.bottom - me.bottom, 0)
    ]);
    me.translate(Math.max(constrainTo.x - me.x, 0), Math.max(constrainTo.y - me.y, 0));
    return me;
  }
  /**
   * Returns a cloned version of this Rectangle aligned to a target Rectangle, or element or {@link Core.widget.Widget}.
   * @param {Object} spec Alignment specification.
   * @param {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} spec.target The Widget or element or Rectangle to align to.
   * @param {Number[]} [spec.anchorSize] The `[width, height]` of the anchor pointer when in `top` position. The
   * width is the baseline length, and the height is the height of the arrow. If passed, the anchor position
   * will be calculated to be at the centre of the overlap of the two aligned edges and returned in the `anchor`
   * property of the resulting Rectangle:
   *
   *     {
   *         edge: 'top',         // or 'right' or 'bottom' or 'left'
   *         x/y: offset          // dimension to translate and value to translate by.
   *     }
   *
   * @param {Object} [spec.anchorPosition] an `{ x: n, y: n }` anchor translation to be used *if the requested alignment
   * succeeds without violating constraints*. If a fallback alignment is used, the anchor will be centered in the
   * overlap of the aligned edges as usual.
   * @param {Boolean} [spec.overlap] True to allow this to overlap the target.
   * @param {String} spec.align The edge alignment specification string, specifying two points to bring together.
   *
   * Each point is described by an edge initial (`t` for top edge, `b` for bottom edge etc) followed
   * by a percentage along that edge.
   *
   * So the form would be `[trblc][n]-[trblc][n].` The `n` is the percentage offset along that edge
   * which defines the alignment point. This is not valid for alignment point `c` which means the center point.
   *
   * For example `t0-b0' would align this Rectangle's top left corner with the bottom left corner of the `target`.
   * @param {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle} [spec.constrainTo] The Widget or Element or Rectangle to constrain to.
   * If the requested alignment cannot be constrained (it will first shrink the resulting Rectangle according
   * to the `minWidth` and `minHeight` properties of this rectangle), then it will try aligning at other edges
   * (honouring the `axisLock` option), and pick the fallback alignment which results in the shortest translation.
   * @param {Boolean} [spec.axisLock] Specify as a truthy value to fall back to aligning against the opposite
   * edge first if the requested alignment cannot be constrained into the `constrainTo` option. If specified
   * as `'flexible'`, then fallback will continue searching for solutions on the remaining two sides.
   * @param {Boolean} [spec.matchSize] When aligning edge-to-edge, match the length of the aligned-to
   * edge of the target. This is only honored when `axisLock` is enabled and alignment succeeds on the requested axis.
   * If __not__ aligning edge-to-edge, `matchSize` matches both dimensions of the target.
   * @param {Number|Number[]} [spec.offset] The 'x' and 'y' offset values to create an extra margin round the target
   * to offset the aligned widget further from the target. May be configured as -ve to move the aligned widget
   * towards the target - for example producing the effect of the anchor pointer piercing the target.
   * @param {Number|Number[]} [spec.constrainPadding] The amount of pixels to pad from the `constrainTo` target,
   * either a single value, or an array of values in CSS edge order.
   * @param {Boolean} [spec.rtl] Pass as true if this is being used in an RTL environment, and aligning 0% to
   * 100% along a horizontal edge must proceed from right to left.
   * @returns {Core.helper.util.Rectangle} A new Rectangle aligned as requested if possible, but if the requested position violates
   * the `constrainTo` Rectangle, the shortest translation from the requested position which obeys constraints will be used.
   */
  alignTo(spec) {
    let result = this.clone(), {
      target,
      constrainTo,
      constrainPadding
    } = spec, calculatedAnchorPosition, zone, resultZone, constrainingToViewport;
    if (target && !target.isRectangle) {
      target = _Rectangle.from(target.element ? target.element : target);
    }
    if (constrainTo) {
      if (!constrainTo.isRectangle) {
        constrainingToViewport = constrainTo === globalThis || constrainTo === document;
        const ignorePageScroll = "ignorePageScroll" in spec ? spec.ignorePageScroll : !constrainingToViewport;
        constrainTo = _Rectangle.from(constrainTo.element ? constrainTo.element : constrainTo, null, ignorePageScroll);
      }
      if (constrainPadding) {
        constrainPadding = parseEdges(constrainPadding);
        constrainPadding[0] = Math.min(constrainPadding[0], target.top);
        constrainPadding[1] = Math.min(constrainPadding[1], constrainTo.right - target.right);
        constrainPadding[2] = Math.min(constrainPadding[2], constrainTo.bottom - target.bottom);
        constrainPadding[3] = Math.min(constrainPadding[3], target.left);
        constrainTo = constrainTo.deflate.apply(constrainTo.clone(), constrainPadding);
      }
    }
    const me = this, targetOffsets = createOffsets(spec.offset), {
      align,
      axisLock,
      anchorSize,
      anchorPosition,
      matchSize,
      position,
      rtl
    } = spec, alignSpec = parseAlign(align, rtl), targetConstrainRect = constrainTo && constrainTo.clone(), constraintZones = [], zoneOrder = [{
      zone: zone = alignSpec.startZone,
      align
    }], matchDimension = matchSize && matchDimensions[alignSpec.startZone & 1], originalSize = me[matchDimension];
    if (matchDimension && axisLock) {
      result[matchDimension] = target[matchDimension];
    } else if (!alignSpec.edgeAligned && matchSize) {
      result.width = target.width;
      result.height = target.height;
    }
    if (constrainTo) {
      result.constrainTo(constrainTo);
    }
    if (constrainTo && alignSpec.startZone != null) {
      if (axisLock) {
        zoneOrder.push({
          zone: zone = (zone + 2) % 4,
          align: flipAlign(alignSpec)
        });
        if (axisLock === "flexible") {
          zoneOrder.push({
            zone: zone = (alignSpec.startZone + 1) % 4,
            align: defaultAlignments[zone]
          });
          zoneOrder.push({
            zone: zone = (zone + 2) % 4,
            align: defaultAlignments[zone]
          });
        }
      } else {
        for (let i = 1; i < 4; i++) {
          zoneOrder.push({
            zone: zone = (zone + 1) % 4,
            align: defaultAlignments[zone]
          });
        }
      }
    }
    if (anchorPosition) {
      const pos = alignSpec.startZone & 1 ? "y" : "x";
      calculatedAnchorPosition = {
        [pos]: anchorPosition[pos],
        edge: edgeNames[(alignSpec.startZone + 2) % 4]
      };
    }
    if (targetConstrainRect && target) {
      targetConstrainRect.adjust(-target.width, -target.height, target.width, target.height);
      target.constrainTo(targetConstrainRect);
    }
    result.minWidth = me.minWidth;
    result.minHeight = me.minHeight;
    if (position) {
      result.moveTo(position.x, position.y);
      result.translate.apply(result, targetOffsets);
      if (constrainTo) {
        result.constrainTo(constrainTo);
      }
    } else {
      const centerAligned = alignSpec.myEdge === "c" || alignSpec.targetEdge === "c", offsets = anchorSize && !centerAligned ? [anchorSize[1] + targetOffsets[0], anchorSize[1] + targetOffsets[1]] : targetOffsets, targetPoint = target.getAlignmentPoint(alignSpec.targetAlignmentPoint, offsets), myPoint = result.getAlignmentPoint(alignSpec.myAlignmentPoint);
      result.translate(targetPoint[0] - myPoint[0], targetPoint[1] - myPoint[1]);
      let overlap = result.intersect(target, true);
      if (overlap) {
        if (constrainTo) {
          result.constrainTo(constrainTo);
        }
        resultZone = alignSpec.startZone;
        result.translate(...offsets);
      } else if (constrainTo && !constrainTo.contains(result)) {
        const requestedResult = result.clone(), solutions = [];
        let zone2, largestZone;
        calculatedAnchorPosition = null;
        constraintZones[0] = zone2 = constrainTo.clone();
        zone2.bottom = target.y - offsets[1];
        constraintZones[1] = zone2 = constrainTo.clone();
        zone2.x = target.right + offsets[0];
        constraintZones[2] = zone2 = constrainTo.clone();
        zone2.y = target.bottom + offsets[1];
        constraintZones[3] = zone2 = constrainTo.clone();
        zone2.right = target.x - offsets[0];
        for (let i = 0; i < zoneOrder.length; i++) {
          if (matchDimension && i == 2) {
            result[matchDimension] = originalSize;
          }
          zone2 = constraintZones[resultZone = zoneOrder[i].zone];
          result = result.alignTo({
            target,
            offsets,
            align: zoneOrder[i].align
          });
          if (result.constrainTo(zone2, true)) {
            solutions.push({
              result,
              zone: resultZone
            });
            if (!largestZone || result.width < me.width || result.height < me.height) {
              result.align = zoneOrder[i].align;
              break;
            }
          }
          if (!largestZone || zone2.area > largestZone.area) {
            const r = result.clone();
            switch (resultZone) {
              case 0:
                r.moveTo(null, zone2.bottom - r.height);
                break;
              case 1:
                r.moveTo(zone2.left);
                break;
              case 2:
                r.moveTo(null, zone2.top);
                break;
              case 3:
                r.moveTo(zone2.right - r.width);
                break;
            }
            largestZone = {
              area: zone2.area,
              result: r,
              zone: resultZone
            };
          }
        }
        if (solutions.length) {
          if (solutions.length > 1 && !axisLock) {
            solutions.sort((s12, s22) => {
              const s1TranslationDistance = Math.sqrt((requestedResult.x - s12.result.x) ** 2 + (requestedResult.y - s12.result.y) ** 2), s2TranslationDistance = Math.sqrt((requestedResult.x - s22.result.x) ** 2 + (requestedResult.y - s22.result.y) ** 2);
              return s1TranslationDistance - s2TranslationDistance;
            });
          }
          result = solutions[0].result;
          resultZone = solutions[0].zone;
        } else {
          result = largestZone.result;
          resultZone = largestZone.zone;
          if (constrainingToViewport) {
            result.constrainTo(constrainTo);
          }
        }
      } else {
        resultZone = alignSpec.startZone;
      }
      result.zone = resultZone;
      result.overlap = overlap = result.intersect(target, true);
      if (anchorSize && !overlap) {
        if (!calculatedAnchorPosition) {
          const isLeftOrRight = resultZone & 1, start = isLeftOrRight ? "y" : "x", end = isLeftOrRight ? "bottom" : "right", startValue = Math.max(target[start], result[start]), endValue = Math.min(target[end], result[end]);
          let anchorStart = startValue + (endValue - startValue) / 2 - anchorSize[0] / 2;
          const anchorEnd = anchorStart + anchorSize[0];
          if (anchorEnd > result[end]) {
            anchorStart -= anchorEnd - result[end];
          }
          if (anchorStart < result[start]) {
            anchorStart += result[start] - anchorStart;
          }
          calculatedAnchorPosition = {
            [start]: anchorStart - result[start],
            edge: edgeNames[(resultZone + 2) % 4]
          };
        }
        result.anchor = calculatedAnchorPosition;
      }
    }
    return result;
  }
  /**
   * Returns the `[x, y]` position of the specified anchor point of this Rectangle in <edge><offset> format.
   * for example passing "t50" will return the centre point of the top edge, passing "r0" will return the start
   * position of the right edge (the top right corner).
   *
   * Note that the offset defaults to 50, so "t" means the centre of the top edge.
   * @param {String} alignmentPoint The alignment point to calculate. Must match the RegExp `[trbl]\d*`
   * @param {Number[]} margins The `[x, y]` margins to add from the left/right, top/bottom edge.
   * @internal
   */
  getAlignmentPoint(alignmentPoint, margins = zeroOffsets) {
    const me = this, parts = alignPointRe.exec(alignmentPoint), edge = parts[1].toLowerCase(), edgeOffset = Math.min(Math.max(parseInt(parts[2] || 50), 0), 100) / 100;
    switch (edge) {
      case "t":
        return [me.x + me.width * edgeOffset, me.y - margins[1]];
      case "r":
        return [me.right + margins[0], me.y + me.height * edgeOffset];
      case "b":
        return [me.x + me.width * edgeOffset, me.bottom + margins[1]];
      case "l":
        return [me.x - margins[0], me.y + me.height * edgeOffset];
      case "c": {
        return [me.x + me.width / 2, me.y + me.height / 2];
      }
    }
  }
  /**
   * Highlights this Rectangle using the highlighting effect of {@link Core.helper.DomHelper}
   * on a transient element which encapsulates the region's area.
   */
  highlight() {
    const me = this, highlightElement = DomHelper.createElement({
      parent: document.body,
      style: `position:absolute;z-index:9999999;pointer-events:none;
                            left:${me.x}px;top:${me.y}px;width:${me.width}px;height:${me.height}px`
    });
    return DomHelper.highlight(highlightElement).then(() => highlightElement.remove());
  }
  /**
   * Visualizes this Rectangle by adding a DOM element which encapsulates the region's area into the provided parent element.
   * @param {DomConfig} config Element config object
   * @returns {Element} The highlight element
   * @internal
   */
  visualize(config, asDomConfig) {
    const me = this, domConfig = ObjectHelper.merge({
      style: {
        left: `${me.x}px`,
        top: `${me.y}px`,
        width: `${me.width}px`,
        height: `${me.height}px`,
        pointerEvents: "none",
        // If this visualization is provided a CSS class, let outside handle position + z-index
        ...config.class ? {} : { position: "absolute", "z-index": 9999999 }
      }
    }, config);
    return asDomConfig ? domConfig : DomHelper.createElement(domConfig);
  }
  toString(delimiter = ",") {
    return [`${this.top}px`, `${this.right}px`, `${this.bottom}px`, `${this.left}px`].join(delimiter);
  }
};
var Point = class extends Rectangle {
  /**
   * Creates a new Point encapsulating the event's page position.
   * @param {Event} event
   * @returns {Core.helper.util.Rectangle}
   * @typings ignore
   */
  static from(event) {
    const touchPoints = event.changedTouches, x = touchPoints ? touchPoints[0].screenX : event.screenX, y = touchPoints ? touchPoints[0].screenY : event.pageY;
    return new this.constructor(x, y);
  }
  /**
   * Constructs a Point
   * @param x The X coordinate
   * @param y The Y coordinate
   */
  constructor(x, y) {
    super(x, y, 0, 0);
  }
  /**
   * Coerces this Point to be within the passed Rectangle. Translates it into the bounds.
   * @param {Core.helper.util.Rectangle} into The Rectangle into which to coerce this Point.
   */
  constrain(into) {
    this.x = Math.min(Math.max(this.x, into.x), into.right - 1);
    this.y = Math.min(Math.max(this.y, into.y), into.bottom - 1);
    return this;
  }
  toArray() {
    return [this.x, this.y];
  }
};
Rectangle._$name = "Rectangle";

// ../Core/lib/Core/helper/util/DomClassList.js
var valueSymbol = Symbol("value");
var lengthSymbol = Symbol("length");
var DomClassList = class _DomClassList {
  static change(cls, add, remove, as = "string") {
    remove = _DomClassList.normalize(remove, "object");
    const after = _DomClassList.normalize(cls, "array").filter((c) => !remove[c]);
    if (add) {
      add = _DomClassList.normalize(add, "array");
      for (let i = 0; i < add.length; ++i) {
        if (!after.includes(add[i])) {
          after.push(add[i]);
        }
      }
    }
    return _DomClassList.normalize(after, as);
  }
  static from(classes, returnEmpty) {
    if (classes) {
      if (classes.isDomClassList) {
        returnEmpty = returnEmpty != null ? returnEmpty : true;
      } else {
        returnEmpty = returnEmpty != null ? returnEmpty : Objects.isObject(classes) && !Objects.isEmpty(classes);
        classes = new _DomClassList(classes);
      }
      if (!classes.value && !returnEmpty) {
        classes = null;
      }
    }
    return classes || (returnEmpty ? new _DomClassList() : null);
  }
  /**
   * Converts a class name of any understood type to a desired form.
   * @param {String|String[]|Object|Set|Map|HTMLElement} cls
   * @param {String} as Pass `'object'` to return an object with the class names as its keys (all keys will have a
   * value of `true`), or pass `'array'` to return an array of class names, or pass `'string'` (the default) to
   * return a space-separated string of class names.
   * @returns {String|String[]|Object}
   * @internal
   */
  static normalize(cls, as = "string") {
    cls = cls || "";
    const type = typeof cls, asArray = as === "array", asObject = as === "object", asString = !asArray && !asObject;
    let isString = type === "string", c, i, ret;
    if (type === "object") {
      if (cls.nodeType === Element.ELEMENT_NODE && typeof cls.getAttribute === "function") {
        cls = cls.getAttribute("class") || "";
        isString = true;
      } else if (cls == null ? void 0 : cls.isDomClassList) {
        cls = cls.values;
      } else if (cls instanceof DOMTokenList) {
        cls = Array.from(cls);
      } else if (cls instanceof Map) {
        cls = Array.from(cls.keys()).filter((k) => cls.get(k));
      } else if (cls instanceof Set) {
        cls = Array.from(cls);
      } else if (!Array.isArray(cls)) {
        cls = Objects.getTruthyKeys(cls);
      }
    }
    if (isString) {
      cls = [...new Set(StringHelper.split(cls))];
    }
    for (i = cls.length; i-- > 0; ) {
      c = cls[i];
      if (!c.length) {
        cls.splice(i, 1);
      } else if (c.includes(" ")) {
        cls.splice(i, 1, ...StringHelper.split(c));
      }
    }
    if (asArray) {
      ret = cls;
    } else if (asString) {
      ret = cls.join(" ");
    } else {
      ret = /* @__PURE__ */ Object.create(null);
      for (i = 0; i < cls.length; ++i) {
        ret[cls[i]] = true;
      }
    }
    return ret;
  }
  /**
   * Initializes a new DomClassList.
   * @param {...String|Object} classes The CSS classes as strings or objects.
   * @function constructor
   */
  constructor(...classes) {
    this.process(1, classes);
  }
  /**
   * Clears all class names from this DomClassList instance.
   * @returns {Core.helper.util.DomClassList} this DomClassList.
   */
  clear() {
    for (const key in this) {
      this[key] = false;
    }
    return this;
  }
  /**
   * Sets this DomClassList instance to represent the classes passed as either strings or objects.
   * @returns {Core.helper.util.DomClassList} this DomClassList.
   */
  set(...classes) {
    return this.clear().process(1, classes);
  }
  // To gain some speed in DomHelper.sync(), faster than instanceof etc
  get isDomClassList() {
    return true;
  }
  /**
   * Returns a clone of this DomClassList with all the same keys set.
   * @returns {Core.helper.util.DomClassList} A clone of this DomClassList.
   */
  clone() {
    return new _DomClassList(this);
  }
  /**
   * Returns a Boolean value, indicating whether this ClassList has the specified CSS class name.
   * @param {String} className CSS class name to check
   * @returns {Boolean} true if this ClassList contains the passed CSS class name, false otherwise
   */
  contains(className) {
    if (typeof className === "string" && className) {
      return Boolean(this[className]);
    }
    return false;
  }
  // An instance of this class may be assigned directly to an element's className
  // it will be coerced to a string value using this method.
  toString() {
    return this.length ? `${this.value} ` : "";
  }
  toJSON() {
    return this.toString();
  }
  /**
   * Analogous to string.trim, returns the string value of this `DomClassList` with no trailing space.
   * @returns {String} A concatenated string value of all the class names in this `DomClassList`
   * separated by spaces.
   */
  trim() {
    return this.value;
  }
  /**
   * Compares this DomClassList to another DomClassList (or class name string of space separated classes).
   * If the same class names (regardless of order) are present, the two are considered equal.
   *
   * So `new DomClassList('foo bar bletch').isEqual('bletch bar foo')` would return `true`
   * @param {Core.helper.util.DomClassList|String} other The `DomClassList` or string of classes to compare to.
   * @returns {Boolean} `true` if the two contain the same class names.
   */
  isEqual(other) {
    const otherClasses = _DomClassList.normalize(other, "array"), len = otherClasses.length;
    if (this.length === len) {
      for (let i = 0; i < len; i++) {
        if (!this[otherClasses[i]]) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  /**
   * Get/set string value.
   * Class names separated with space.
   * @property {String}
   */
  get value() {
    let value = this[valueSymbol], keys;
    if (value == null) {
      keys = Objects.getTruthyKeys(this);
      this[lengthSymbol] = keys.length;
      this[valueSymbol] = value = keys.join(" ");
    }
    return value;
  }
  set value(value) {
    const me = this, keys = Object.keys(me), len = keys.length;
    for (let i = 0; i < len; i++) {
      delete me[keys[i]];
    }
    if (value) {
      me.process(1, [value]);
    } else {
      delete me[valueSymbol];
    }
  }
  /**
   * Returns string values as an array.
   * @readonly
   * @property {String[]}
   */
  get values() {
    return Objects.getTruthyKeys(this);
  }
  get length() {
    return this.value ? this[lengthSymbol] : 0;
  }
  process(value, classes) {
    for (let cls, k, i = 0; i < classes.length; i++) {
      if (classes[i]) {
        cls = classes[i];
        if (cls.isDomClassList || Objects.isObject(cls)) {
          for (k in cls) {
            this[k] = value ? cls[k] : !cls[k];
          }
        } else {
          cls = _DomClassList.normalize(classes[i], "array");
          for (k = 0; k < cls.length; ++k) {
            this[cls[k]] = value;
          }
        }
      }
    }
    delete this[valueSymbol];
    return this;
  }
  /**
   * Adds/removes class names according to the passed object's properties.
   *
   * Properties with truthy values are added.
   * Properties with falsy values are removed.
   * @param {Object} classList Object containing properties to set/clear
   */
  assign(classList) {
    for (const cls in classList) {
      if (!this[cls] !== !classList[cls]) {
        this[cls] = classList[cls];
        delete this[valueSymbol];
      }
    }
    return this;
  }
  /**
   * Adds/removes this objects classes to the passed `classList` or element.
   *
   * Properties with truthy values are added.
   * Properties with falsy values are removed.
   * @param {HTMLElement|DOMTokenList} element The element or the element's `classList` to be updated.
   */
  assignTo(element) {
    const classList = element.nodeType === Element.ELEMENT_NODE ? element.classList : element, temp = _DomClassList.from(classList);
    temp.add(this);
    classList.value = temp.value;
  }
  /**
   * Add CSS class(es)
   * ```
   * myClassList.add('bold', 'small');
   * ```javascript
   * @param {String|String[]|Object} classes CSS classes to add
   */
  add(...classes) {
    return this.process(1, classes);
  }
  /**
   * Remove CSS class(es)
   * ```javascript
   * myClassList.remove('bold', 'small');
   * ```
   * @param {String} classes CSS classes to remove
   */
  remove(...classes) {
    return this.process(0, classes);
  }
  /**
   * Toggles the passed CSS class name.
   *
   * If the `force` parameter is passed, `true` means add the class name, `false` means remove it.
   *
   * ```javascript
   * myClassList.toggle('bold', isImportant);
   * ```
   * @param {String} className CSS class to toggle
   * @param {Boolean} [force] `true` to add the class, `false` to remove it.
   * @returns {Boolean} `true` if the operation changed the value.
   */
  toggle(className, flag = Boolean(!this[className])) {
    flag = Boolean(flag);
    if (Boolean(this[className]) !== flag) {
      this[className] = flag;
      delete this[valueSymbol];
      return true;
    }
  }
  /**
   * Analogous to the `String#split` method, but with no delimiter
   * parameter. This method returns an array containing the individual
   * CSS class names set.
   * @returns {String[]} The individual class names in this `DomClassList`
   */
  split() {
    return Objects.getTruthyKeys(this);
  }
  forEach(fn2) {
    return Objects.getTruthyKeys(this).forEach(fn2);
  }
};
DomClassList.prototype[valueSymbol] = null;
DomClassList._$name = "DomClassList";

// ../Core/lib/Core/helper/EventHelper.js
var touchProperties = [
  "clientX",
  "clientY",
  "pageX",
  "pageY",
  "screenX",
  "screenY"
];
var isOption = {
  element: 1,
  thisObj: 1,
  once: 1,
  delegate: 1,
  delay: 1,
  capture: 1,
  passive: 1,
  throttled: 1,
  autoDetach: 1,
  expires: 1,
  block: 1
};
var configurable = true;
var returnTrueProp = {
  configurable,
  value: true
};
var normalizedKeyNames = {
  Spacebar: "Space",
  Del: "Delete",
  Esc: "Escape",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown"
};
var specialKeys = {
  Control: "ctrl",
  Alt: "alt",
  Shift: "shift"
};
var specialKeyRe = /^(ctrl|shift|alt|meta)$/;
var eventProps = [
  "altKey",
  "bubbles",
  "button",
  "buttons",
  "cancelBubble",
  "cancelable",
  "clientX",
  "clientY",
  "ctrlKey",
  "layerX",
  "layerY",
  "metaKey",
  "pageX",
  "pageY",
  "returnValue",
  "screenX",
  "screenY",
  "shiftKey"
];
var _EventHelper = class _EventHelper {
  static normalizeEvent(event) {
    return ObjectHelper.copyPropertiesIf(event, event.changedTouches[0] || event.touches[0], touchProperties);
  }
  /**
   * For use when synthesizing events from native DOM events. Copies valid properties from the passed
   * event into the destination object;
   * @param {Object} dest Destination object
   * @param {Event} event The event whose properties to copy
   * @returns {Object} An event construction object.
   * @internal
   */
  static copyEvent(dest, event) {
    return ObjectHelper.copyProperties(dest, event, eventProps);
  }
  /**
   * Returns the `[x, y]` coordinates of the event in the viewport coordinate system.
   * @param {Event} event The event
   * @returns {Number[]} The coordinate.
   */
  static getXY(event) {
    if (event.touches) {
      event = event.touches[0];
    }
    return [event.clientX, event.clientY];
  }
  /**
   * Returns the pixel distance between two mouse/touch/pointer events.
   * @param {Event} event1 The first event.
   * @param {Event} event2 The second event.
   * @returns {Number} The distance in pixels between the two events.
   */
  static getDistanceBetween(event1, event2) {
    const xy1 = EH.getXY(event1), xy2 = EH.getXY(event2);
    return Math.sqrt(Math.pow(xy1[0] - xy2[0], 2) + Math.pow(xy1[1] - xy2[1], 2));
  }
  /**
   * Returns a {@link Core.helper.util.Rectangle.Point} which encapsulates the `pageX/Y` position of the event.
   * May be used in {@link Core.helper.util.Rectangle} events.
   * @param {Event} event A browser mouse/touch/pointer event.
   * @returns {Core.helper.util.Rectangle.Point} The page point.
   */
  static getPagePoint(event) {
    return new Point(event.pageX, event.pageY);
  }
  /**
   * Returns a {@link Core.helper.util.Rectangle.Point} which encapsulates the `clientX/Y` position of the event.
   * May be used in {@link Core.helper.util.Rectangle} events.
   * @param {Event} event A browser mouse/touch/pointer event.
   * @returns {Core.helper.util.Rectangle.Point} The page point.
   */
  static getClientPoint(event) {
    return new Point(event.clientX, event.clientY);
  }
  /**
   * Add a listener or listeners to an element
   * The `options` parameter allows supplying options for the listener(s), for available options see {@link #typedef-ElementListenerConfig}.
   *
   * @param {HTMLElement} element The element to add a listener/listeners to.
   * @param {String|Object} eventName Either a string, being the name of the event to listen for,
   * or an options object containing event names and options as keys. See the options parameter
   * for details, or the {@link #function-on-static} method for details.
   * @param {Function} [handler] If the second parameter is a string event name, this is the handler function.
   * @param {ElementListenerConfig} [options] If the second parameter is a string event name, this is the options.
   * @returns {Function} A detacher function which removes all the listeners when called.
   */
  static addListener(element, eventName, handler, options) {
    if (element.nodeType) {
      if (typeof eventName === "string") {
        options = Object.assign({
          element,
          [eventName]: handler
        }, options);
      } else {
        options = Object.assign({
          element
        }, eventName);
      }
    } else {
      options = element;
    }
    return EH.on(options);
  }
  /**
   * Adds a listener or listeners to an element.
   * all property names other than the options listed below are taken to be event names,
   * and the values as handler specs.
   *
   * A handler spec is usually a function reference or the name of a function in the `thisObj`
   * option.
   *
   * But a handler spec may also be an options object containing a `handler` property which is
   * the function or function name, and local options, including `element` and `thisObj`
   * which override the top level options.
   *
   * The `options` parameter allows supplying options for the listener(s), for available options see {@link #typedef-ElementListenerConfig}.
   *
   *  Usage example
   *
   * ```javascript
   * construct(config) {
   *     super.construct(config);
   *
   *     // Add auto detaching event handlers to this Widget's reference elements
   *     EventHelper.on({
   *         element : this.iconElement,
   *         click   : '_handleIconClick',
   *         thisObj : this,
   *         contextmenu : {
   *             element : document,
   *             handler : '_handleDocumentContextMenu'
   *         }
   *     });
   * }
   *```
   *
   * The `click` handler on the `iconElement` calls `this._handleIconClick`.
   *
   * The `contextmenu` handler is added to the `document` element, but the `thisObj`
   * is defaulted in from the top `options` and calls `this._handleDocumentContextMenu`.
   *
   * Note that on touch devices, `dblclick` and `contextmenu` events are synthesized.
   * Synthesized events contain a `browserEvent` property containing the final triggering
   * event of the gesture. For example a synthesized `dblclick` event would contain a
   * `browserEvent` property which is the last `touchend` event. A synthetic `contextmenu`
   * event will contain a `browserEvent` property which the longstanding `touchstart` event.
   *
   * @param {ElementListenerConfig} options The full listener specification.
   * @returns {Function} A detacher function which removes all the listeners when called.
   */
  static on(options) {
    const element = options.element, thisObj = options.thisObj, handlerDetails = [];
    for (const eventName in options) {
      if (!isOption[eventName]) {
        let handlerSpec = options[eventName];
        if (typeof handlerSpec !== "object") {
          handlerSpec = {
            handler: handlerSpec
          };
        }
        const targetElement = handlerSpec.element || element;
        handlerDetails.push(EH.addElementListener(targetElement, eventName, handlerSpec, options));
      }
    }
    const detacher2 = () => {
      for (let handlerSpec, i = 0; i < handlerDetails.length; i++) {
        handlerSpec = handlerDetails[i];
        EH.removeEventListener(handlerSpec[0], handlerSpec[1], handlerSpec[2]);
      }
      handlerDetails.length = 0;
    };
    if (thisObj && options.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, detacher2, thisObj);
    }
    return detacher2;
  }
  /**
   * Used internally to add a single event handler to an element.
   * @param {HTMLElement} element The element to add the handler to.
   * @param {String} eventName The name of the event to add a handler for.
   * @param {Function|String|Object} handlerSpec Either a function to call, or
   * the name of a function to call in the `thisObj`, or an object containing
   * the handler local options.
   * @param {Function|String} [handlerSpec.handler] Either a function to call, or
   * the name of a function to call in the `thisObj`.
   * @param {HTMLElement} [handlerSpec.element] Optionally a local element for the listener.
   * @param {Object} [handlerSpec.thisObj] A local `this` specification for the handler.
   * @param {Object} defaults The `options` parameter from the {@link #function-addListener-static} call.
   * @private
   */
  static addElementListener(element, eventName, handlerSpec, defaults) {
    const handler = EH.createHandler(element, eventName, handlerSpec, defaults), { spec } = handler, expires = handlerSpec.expires || defaults.expires, options = spec.capture != null || spec.passive != null ? {
      capture: spec.capture,
      passive: spec.passive
    } : void 0;
    element.addEventListener(eventName, handler, options);
    if (expires) {
      const thisObj = handlerSpec.thisObj || defaults.thisObj, delayable = (thisObj == null ? void 0 : thisObj.isDelayable) ? thisObj : globalThis, { alt: alt2 } = expires, delay2 = alt2 ? expires.delay : expires, { spec: spec2 } = handler;
      spec2.expires = expires;
      spec2.timerId = delayable[typeof delay2 === "number" ? "setTimeout" : "requestAnimationFrame"](() => {
        spec2.timerId = null;
        EH.removeEventListener(element, eventName, handler);
        if (alt2 && !handler.called) {
          (typeof alt2 === "string" ? thisObj[alt2] : alt2).call(thisObj);
        }
      }, delay2, `listener-timer-${performance.now()}`);
    }
    return [element, eventName, handler, options];
  }
  // composedPath throws in salesforce
  // https://github.com/bryntum/support/issues/4432
  static getComposedPathTarget(event) {
    return event.composedPath()[0] || event.path[0];
  }
  static fixEvent(event) {
    var _a2, _b, _c;
    if (event.fixed) {
      return event;
    }
    const { type, target } = event;
    if (((target == null ? void 0 : target.shadowRoot) || ((_b = (_a2 = target == null ? void 0 : target.getRootNode) == null ? void 0 : _a2.call(target)) == null ? void 0 : _b.host)) && event.composedPath) {
      const targetElement = this.getComposedPathTarget(event), originalTarget = target;
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
      Object.defineProperty(event, "originalTarget", {
        value: originalTarget,
        configurable
      });
    }
    Object.defineProperty(event, "fixed", returnTrueProp);
    if (type.startsWith("key")) {
      const normalizedKeyName = normalizedKeyNames[event.key];
      if (normalizedKeyName) {
        Object.defineProperty(event, "key", {
          value: normalizedKeyName,
          configurable
        });
      }
      if (event.key === " " && !event.code) {
        Object.defineProperty(event, "code", {
          value: "Space",
          configurable
        });
      }
    }
    if (event.metaKey && !event.ctrlKey) {
      Object.defineProperty(event, "ctrlKey", returnTrueProp);
    }
    if (target && "offsetX" in event) {
      if (!Object.getOwnPropertyDescriptor(event, "borderOffsetX")) {
        Object.defineProperty(event, "borderOffsetX", {
          get: () => {
            return event.offsetX + (BrowserHelper.isSafari ? 0 : parseInt(target.ownerDocument.defaultView.getComputedStyle(target).getPropertyValue("border-left-width")));
          }
        });
      }
      if (!Object.getOwnPropertyDescriptor(event, "borderOffsetY")) {
        Object.defineProperty(event, "borderOffsetY", {
          get: () => {
            return event.offsetY + (BrowserHelper.isSafari ? 0 : parseInt(target.ownerDocument.defaultView.getComputedStyle(target).getPropertyValue("border-top-width")));
          }
        });
      }
    }
    if ((target == null ? void 0 : target.nodeType) === Element.DOCUMENT_NODE && "clientX" in event) {
      const targetElement = DomHelper.elementFromPoint(event.clientX, event.clientY);
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
    }
    if ((target == null ? void 0 : target.nodeType) === Element.TEXT_NODE) {
      const targetElement = event.target.parentElement;
      Object.defineProperty(event, "target", {
        value: targetElement,
        configurable
      });
    }
    if (((_c = event.relatedTarget) == null ? void 0 : _c.nodeType) === Element.TEXT_NODE) {
      const relatedTargetElement = event.target.parentElement;
      Object.defineProperty(event, "relatedTarget", {
        value: relatedTargetElement,
        configurable
      });
    }
    if (type.startsWith("touch") && event.touches.length) {
      this.normalizeEvent(event);
    }
    return event;
  }
  static createHandler(element, eventName, handlerSpec, defaults) {
    const delay2 = handlerSpec.delay || defaults.delay, throttled = handlerSpec.throttled || defaults.throttled, block = handlerSpec.block || defaults.block, once = "once" in handlerSpec ? handlerSpec.once : defaults.once, capture = "capture" in handlerSpec ? handlerSpec.capture : defaults.capture, passive = "passive" in handlerSpec ? handlerSpec.passive : defaults.passive, delegate = "delegate" in handlerSpec ? handlerSpec.delegate : defaults.delegate, wrappedFn = handlerSpec.handler, expires = handlerSpec.expires, thisObj = handlerSpec.thisObj || defaults.thisObj, { rtlSource = thisObj } = thisObj || {};
    let handler = (event, ...args) => {
      if (EH.playingDemo && event.isTrusted) {
        return;
      }
      if (thisObj == null ? void 0 : thisObj.isDestroyed) {
        return;
      }
      event = EH.fixEvent(event, rtlSource == null ? void 0 : rtlSource.rtl);
      handler.called = true;
      (typeof wrappedFn === "string" ? thisObj[wrappedFn] : wrappedFn).call(thisObj, event, ...args);
      delete event.target;
      delete event.relatedTarget;
      delete event.originalarget;
      delete event.key;
      delete event.code;
      delete event.ctrlKey;
      delete event.fixed;
    };
    if (block) {
      const wrappedFn2 = handler;
      let lastCallTime, lastTarget;
      handler = (e, ...args) => {
        const now2 = performance.now();
        if (!lastCallTime || e.target !== lastTarget || now2 - lastCallTime > block) {
          lastTarget = e.target;
          lastCallTime = now2;
          wrappedFn2(e, ...args);
        }
      };
    }
    if (delay2 != null) {
      const wrappedFn2 = handler, delayable = (thisObj == null ? void 0 : thisObj.setTimeout) ? thisObj : globalThis;
      handler = (...args) => {
        delayable.setTimeout(() => {
          wrappedFn2(...args);
        }, delay2);
      };
    }
    if (throttled != null) {
      let alt2, buffer = throttled;
      if (throttled.buffer) {
        alt2 = (e) => {
          return throttled.alt.call(EH, EH.fixEvent(e, rtlSource == null ? void 0 : rtlSource.rtl));
        };
        buffer = throttled.buffer;
      }
      if (thisObj == null ? void 0 : thisObj.isDelayable) {
        handler = thisObj.throttle(handler, {
          delay: buffer,
          throttled: alt2
        });
      } else {
        handler = FunctionHelper.createThrottled(handler, buffer, thisObj, null, alt2);
      }
    }
    if (once) {
      const wrappedFn2 = handler;
      handler = (...args) => {
        EH.removeEventListener(element, eventName, handler);
        wrappedFn2(...args);
      };
    }
    if (delegate) {
      const wrappedFn2 = handler;
      handler = (event, ...args) => {
        var _a2;
        event = EH.fixEvent(event, rtlSource == null ? void 0 : rtlSource.rtl);
        const delegatedTarget = ((_a2 = event.target.closest) == null ? void 0 : _a2.call) && event.target.closest(delegate);
        if (!delegatedTarget) {
          return;
        }
        Object.defineProperty(event, "currentTarget", {
          get: () => delegatedTarget,
          configurable: true
        });
        wrappedFn2(event, ...args);
      };
    }
    if (handlerSpec.thisObj && handlerSpec.autoDetach !== false) {
      thisObj.doDestroy = FunctionHelper.createInterceptor(thisObj.doDestroy, () => EH.removeEventListener(element, eventName, handler), thisObj);
    }
    handler.spec = {
      delay: delay2,
      throttled,
      block,
      once,
      thisObj,
      capture,
      expires,
      passive,
      delegate
    };
    return handler;
  }
  static removeEventListener(element, eventName, handler) {
    const { expires, timerId, thisObj, capture } = handler.spec;
    if ((expires == null ? void 0 : expires.alt) && timerId) {
      const delayable = (thisObj == null ? void 0 : thisObj.isDelayable) ? thisObj : globalThis;
      delayable[typeof expires.delay === "number" ? "clearTimeout" : "cancelAnimationFrame"](timerId);
    }
    element.removeEventListener(eventName, handler, capture);
  }
  /**
   * Calls a callback when the described animation completes.
   *
   * @param {Object} detail
   * @param {HTMLElement} detail.element The element which is being animated.
   * @param {String|RegExp} [detail.animationName] The name of the animation to wait for.
   * @param {String} [detail.property] If no `animationName` specified, the CSS property
   * which is being animated.
   * @param {Function} detail.handler The function to call on animation end.
   * @param {Number} [detail.duration] Optional fallback time to wait until calling the callback.
   * @param {Object} [detail.thisObj] The `this` reference to call the callback with.
   * @param {Array} [detail.args] Optional arguments to call the callback with.
   * @param {Core.mixin.Delayable} [detail.timerSource] A Delayable to provide the fallback timeout.
   * @param {Boolean} [detail.runOnDestroy] If `timerSource` is a {@link Core.mixin.Delayable},
   * `true` to invoke the callback if it is destroyed during the animation.
   * @returns {Function} a function which detaches the animation end listener.
   */
  static onTransitionEnd({
    element,
    animationName,
    property,
    handler,
    mode = animationName ? "animation" : "transition",
    duration = DomHelper[`get${mode === "transition" ? "Property" : ""}${StringHelper.capitalize(mode)}Duration`](element, property),
    thisObj = globalThis,
    args = [],
    timerSource,
    runOnDestroy
  }) {
    let timerId;
    timerSource = timerSource || (thisObj.isDelayable ? thisObj : globalThis);
    const callbackArgs = [element, property, ...args], doCallback = () => {
      detacher2();
      if (!thisObj.isDestroyed) {
        if (thisObj.callback) {
          thisObj.callback(handler, thisObj, callbackArgs);
        } else {
          handler.apply(thisObj, callbackArgs);
        }
      }
    }, detacher2 = EH.on({
      element,
      [`${mode}end`]({ animationName: endedAnimation, propertyName, target }) {
        var _a2;
        if (target === element) {
          if (propertyName === property || (endedAnimation == null ? void 0 : endedAnimation.match(animationName))) {
            if (timerId) {
              (_a2 = timerSource.clearTimeout) == null ? void 0 : _a2.call(timerSource, timerId);
              timerId = null;
            }
            doCallback();
          }
        }
      }
    });
    if (duration != null) {
      timerId = timerSource.setTimeout(doCallback, duration + 50, "onTransitionEnd", runOnDestroy);
    }
    return detacher2;
  }
  /**
   * Waits for the described animation completes.
   *
   * @param {Object} config
   * @param {HTMLElement} config.element The element which is being animated.
   * @param {String|RegExp} [config.animationName] The name of the animation to wait for.
   * @param {String} [config.property] If no `animationName` specified, the CSS property
   * which is being animated.
   * @param {Number} [config.duration] Optional fallback time to wait until calling the callback.
   * @param {Core.mixin.Delayable} [config.timerSource] A Delayable to provide the fallback timeout.
   * @param {Boolean} [config.runOnDestroy] If `timerSource` is a {@link Core.mixin.Delayable},
   * `true` to invoke the callback if it is destroyed during the animation.
   * @async
   */
  static async waitForTransitionEnd(config) {
    return new Promise((resolve) => {
      config.handler = resolve;
      _EventHelper.onTransitionEnd(config);
    });
  }
  /**
   * Private function to wrap the passed function. The returned wrapper function to be used as
   * a `touchend` handler which will call the passed function passing a fabricated `dblclick`
   * event if there is a `click` within 300ms.
   * @param {Element} element element
   * @param {String|Function} handler The handler to call.
   * @param {Object} thisObj The owner of the function.
   * @private
   */
  static createDblClickWrapper(element, handler, thisObj) {
    let startId, secondListenerDetacher, tapholdTimer;
    return () => {
      if (!secondListenerDetacher) {
        secondListenerDetacher = EH.on({
          element,
          // We only get here if a touchstart arrives within 300ms of a click
          touchstart: (secondStart) => {
            startId = secondStart.changedTouches[0].identifier;
            secondStart.preventDefault();
          },
          touchend: (secondClick) => {
            if (secondClick.changedTouches[0].identifier === startId) {
              secondClick.preventDefault();
              clearTimeout(tapholdTimer);
              startId = secondListenerDetacher = null;
              const targetRect = Rectangle.from(secondClick.changedTouches[0].target, null, true), offsetX = secondClick.changedTouches[0].pageX - targetRect.x, offsetY = secondClick.changedTouches[0].pageY - targetRect.y, dblclickEventConfig = Object.assign({
                browserEvent: secondClick
              }, secondClick), dblclickEvent = new MouseEvent("dblclick", dblclickEventConfig);
              Object.defineProperties(dblclickEvent, {
                target: { value: secondClick.target },
                offsetX: { value: offsetX },
                offsetY: { value: offsetY }
              });
              if (typeof handler === "string") {
                handler = thisObj[handler];
              }
              handler.call(thisObj, dblclickEvent);
            }
          },
          once: true
        });
        tapholdTimer = setTimeout(() => {
          secondListenerDetacher();
          startId = secondListenerDetacher = null;
        }, EH.dblClickTime);
      }
    };
  }
  /**
   * Handles various inputs to figure out the name of the special key of the event.
   *
   * ```javascript
   * EventHelper.toSpecialKey('ctrl') // 'ctrlKey'
   * EventHelper.toSpecialKey(true)   // 'ctrlKey', default for PC (Cmd for Mac)
   * EventHelper.toSpecialKey(false)  // false
   * EventHelper.toSpecialKey('foo')  // false
   * ```
   *
   * @param {*} value User input value to process.
   * @param {String} defaultValue Default value to fall back to if `true` value is passed.
   * @returns {Boolean|String} Returns `false` if provided value cannot be converted to special key and special key
   * name otherwise.
   * @internal
   */
  static toSpecialKey(value, defaultValue2 = BrowserHelper.isMac ? "metaKey" : "ctrlKey") {
    let result = false;
    if (value === true) {
      result = defaultValue2;
    } else if (typeof value === "string") {
      value = value.toLowerCase();
      if (value.match(specialKeyRe)) {
        result = `${value}Key`;
      }
    }
    return result;
  }
  /**
   * If keyup event is triggered when special key is pressed, we don't get special key value from properties like
   * `ctrlKey`. Instead we need to read `event.key`. That property uses full name and we use abbreviations, so we
   * need to convert the key.
   * @param {String} code
   * @returns {String}
   * @internal
   */
  static specialKeyFromEventKey(code) {
    return specialKeys[code] || "no-special-key";
  }
};
/**
 * DOM event to trigger name mapping.
 * @internal
 */
__publicField(_EventHelper, "eventNameMap", {
  mousedown: "MouseDown",
  mouseup: "MouseUp",
  click: "Click",
  dblclick: "DblClick",
  contextmenu: "ContextMenu",
  mouseenter: "MouseEnter",
  mouseleave: "MouseLeave",
  mousemove: "MouseMove",
  mouseover: "MouseOver",
  mouseout: "MouseOut",
  keyup: "KeyUp",
  keydown: "KeyDown",
  keypress: "KeyPress"
});
var EventHelper = _EventHelper;
var EH = EventHelper;
EH.longPressTime = 700;
EH.dblClickTime = 300;
if (BrowserHelper.isTouchDevice) {
  EH.on({
    element: document,
    touchmove: (event) => {
      if (event.target.closest(".b-dragging")) {
        event.preventDefault();
      }
    },
    passive: false,
    capture: true
  });
}
EventHelper._$name = "EventHelper";

// ../Core/lib/Core/helper/DomHelper.js
var DEFAULT_FONT_SIZE = 14;
var t0t0 = { align: "t0-t0" };
var ELEMENT_NODE = Node.ELEMENT_NODE;
var TEXT_NODE = Node.TEXT_NODE;
var { isObject } = ObjectHelper;
var numberRe = /[+-]?\d*\.?\d+[eE]?-?\d*/g;
var numberReSrc = numberRe.source;
var translateMatrix2dRe = new RegExp(`matrix\\((?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(?:${numberReSrc}),\\s?(${numberReSrc}),\\s?(${numberReSrc})`);
var translateMatrix3dRe = new RegExp(`matrix3d\\((?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(?:-?\\d*),\\s?(-?\\d*),\\s?(-?\\d*)`);
var translateMatrixRe = new RegExp(`(?:${translateMatrix2dRe.source})|(?:${translateMatrix3dRe.source})`);
var pxTtranslateXRe = new RegExp(`translate(3d|X)?\\((${numberReSrc})px(?:,\\s?(${numberReSrc})px)?`);
var pxTtranslateYRe = new RegExp(`translate(3d|Y)?\\((${numberReSrc})px(?:,\\s?(${numberReSrc})px)?`);
var whiteSpaceRe2 = /\s+/;
var semicolonRe = /\s*;\s*/;
var colonRe = /\s*:\s*/;
var digitsRe = /^-?((\d+(\.\d*)?)|(\.?\d+))$/;
var elementPropKey = "$bryntum";
var elementCreateExpandos = {
  elementData: "",
  for: "htmlFor",
  retainElement: ""
};
var elementCreateProperties = {
  // these two are handled by being in elementCreateExpands:
  // elementData  : 1,
  // for          : 1,
  tag: 1,
  html: 1,
  text: 1,
  children: 1,
  tooltip: 1,
  style: 1,
  dataset: 1,
  parent: 1,
  nextSibling: 1,
  ns: 1,
  reference: 1,
  class: 1,
  className: 1,
  unmatched: 1,
  // Used by syncId approach
  onlyChildren: 1,
  // Used by sync to not touch the target element itself,
  listeners: 1,
  // eslint-disable-line bryntum/no-listeners-in-lib
  compareHtml: 1,
  // Sync
  syncOptions: 1,
  // Sync
  keepChildren: 1
  // Sync
};
var styleIgnoreProperties = {
  length: 1,
  parentRule: 1,
  style: 1
};
var nativeEditableTags = {
  INPUT: 1,
  TEXTAREA: 1
};
var nativeFocusableTags = {
  BUTTON: 1,
  IFRAME: 1,
  EMBED: 1,
  INPUT: 1,
  OBJECT: 1,
  SELECT: 1,
  TEXTAREA: 1,
  BODY: 1
};
var win = globalThis;
var doc = document;
var emptyObject4 = Object.freeze({});
var arraySlice = Array.prototype.slice;
var immediatePromise = Promise.resolve();
var fontProps = [
  "font-size",
  "font-size-adjust",
  "font-style",
  "font-weight",
  "font-family",
  "font-kerning",
  "font-stretch",
  "line-height",
  "text-transform",
  "text-decoration",
  "letter-spacing",
  "word-break"
];
var isHiddenWidget = (e) => e._hidden;
var parentNode = (el) => el.parentNode || el.host;
var mergeChildren = (dest, src, options) => {
  if (options.key === "children") {
    return ObjectHelper.mergeItems(dest, src, options);
  }
  return ObjectHelper.blend(dest, src, options);
};
var isVisible = (e) => {
  const style = e.ownerDocument.defaultView.getComputedStyle(e);
  return style.getPropertyValue("display") !== "none" && style.getPropertyValue("visibility") !== "hidden";
};
var hasLayout = (el) => el && (el === doc.body || Boolean(el.offsetParent) || (el.ownerDocument.defaultView && ("offsetParent" in el && DomHelper.getStyleValue(el, "position") !== "fixed") ? el.offsetParent : hasLayout(el.parentNode)));
var elementOrConfigToElement = (elementOrConfig) => {
  if (elementOrConfig instanceof Node) {
    return elementOrConfig;
  }
  if (typeof elementOrConfig === "string") {
    return DH2.createElementFromTemplate(elementOrConfig);
  }
  return DH2.createElement(elementOrConfig);
};
var canonicalStyles = /* @__PURE__ */ Object.create(null);
var canonicalizeStyle = (name, hasUnit) => {
  const entry = canonicalStyles[name] || [StringHelper.hyphenate(name), hasUnit];
  if (!canonicalStyles[name]) {
    canonicalStyles[entry[0]] = canonicalStyles[name] = entry;
  }
  return entry;
};
var getOffsetParent = (node) => node.ownerSVGElement ? node.ownerSVGElement.parentNode : node.offsetParent;
var slideInAnimationName = /b-slide-in-from-\w+/;
[
  "top",
  "right",
  "bottom",
  "left",
  "width",
  "height",
  "maxWidth",
  "maxHeight",
  "minWidth",
  "minHeight",
  "borderSpacing",
  "borderWidth",
  "borderTopWidth",
  "borderRightWidth",
  "borderBottomWidth",
  "borderLeftWidth",
  "marginTop",
  "marginRight",
  "marginBottom",
  "marginLeft",
  "paddingTop",
  "paddingRight",
  "paddingBottom",
  "paddingLeft",
  "fontSize",
  "letterSpacing",
  "lineHeight",
  "outlineWidth",
  "textIndent",
  "wordSpacing"
].forEach((name) => canonicalizeStyle(name, true));
var scrollBarWidth = null;
var idCounter = 0;
var themeInfo = null;
var templateElement;
var htmlParser;
var scrollBarMeasureElement;
var DomHelper = class _DomHelper {
  /**
   * Animates the specified element to slide it into view within the visible viewport
   * of its parentElement from the direction of movement.
   *
   * So in a left-to-right Widget, `direction` 1 means it slides in from the right
   * and `direction` -1 means it slides in from the left. RTL reverses the movement.
   *
   * See the forward/backward navigations in {@link Core.widget.DatePicker} for an example
   * of this in action.
   *
   * If "next" should arrive from below and "previous" should arrive from above, add the
   * class `b-slide-vertical` to the element.
   * @param {HTMLElement} element The element to slide in.
   * @param {Number} direction
   * * `1` to slide in from the "next" direction.
   * * `-1` to slide in from the "previous" direction.
   *
   * If the element is inside an RTL widget the directions are reversed.
   * @async
   */
  static async slideIn(element, direction = 1) {
    const cls = `b-slide-in-${direction > 0 ? "next" : "previous"}`, {
      classList,
      parentNode: { classList: pClassList }
    } = element;
    pClassList.add(".b-sliding-child-element");
    classList.add(cls);
    await EventHelper.waitForTransitionEnd({
      element,
      animationName: slideInAnimationName
    });
    classList.remove(cls);
    pClassList.remove(".b-sliding-child-element");
  }
  /**
   * Returns `true` if the passed element is focusable either programmatically or through pointer gestures.
   * @param {HTMLElement} element The element to test.
   * @returns {Boolean} Returns `true` if the passed element is focusable
   */
  static isFocusable(element, skipAccessibilityCheck = false) {
    if (!skipAccessibilityCheck) {
      if (!DH2.isVisible(element) || DH2.Widget.fromElement(element, isHiddenWidget)) {
        return false;
      }
    }
    const nodeName = element.nodeName;
    return nativeFocusableTags[nodeName] || (nodeName === "A" || nodeName === "LINK") && !!element.href || element.getAttribute("tabIndex") != null || element.contentEditable === "true";
  }
  /**
   * Returns `true` if the passed element accepts keystrokes to edit its contents.
   * @returns {Boolean} Returns `true` if the passed element is editable.
   */
  static isEditable(element) {
    return element.isContentEditable || nativeEditableTags[element.nodeName];
  }
  /**
   * Returns the rectangle of the element which is currently visible in the browser viewport, i.e. user can find it on
   * screen, or `false` if it is scrolled out of view.
   * @param {HTMLElement} target The element to test.
   * @param {Boolean} [whole=false] Whether to check that whole element is visible, not just part of it.
   * If this is passed as true, the result will be a boolean, `true` or `false`.
   * @privateparam {Core.widget.Widget} [caller] the Widget aligning to the target.
   * @returns {Core.helper.util.Rectangle|Boolean} Returns the rectangle of the element which is currently visible in
   * the browser viewport, or `false` if it is out of view.
   */
  static isInView(target, whole = false, caller) {
    if (!hasLayout(target)) {
      return false;
    }
    const positioned = (caller == null ? void 0 : caller.positioned) && _DomHelper.getStyleValue(caller.element, "position") !== "fixed", docRect = Rectangle.from(globalThis), method = whole ? "contains" : "intersect", cOp = positioned && caller.element.offsetParent, cOpR = positioned && Rectangle.from(cOp);
    docRect.height = doc.scrollingElement.scrollHeight;
    if (target === doc.body) {
      return docRect;
    }
    const result = this.getViewportIntersection(target, docRect, method);
    if (result && positioned) {
      result.translate(doc.scrollingElement.scrollLeft, doc.scrollingElement.scrollTop);
    }
    return positioned && result ? result.translate(-cOpR.x + cOp.scrollLeft, -cOpR.y + cOp.scrollTop) : result;
  }
  /**
   * This method goes up the DOM tree checking that all ancestors are visible in the viewport
   * @param {HTMLElement} target Starting html element
   * @param {Core.helper.util.Rectangle} docRect Window rectangle
   * @param {'contains'|'intersect'} method 'contains' or 'intersect'
   * @returns {Core.helper.util.Rectangle}
   */
  static getViewportIntersection(target, docRect, method) {
    const { parentNode: parentNode2 } = target, { parentElement } = parentNode2.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? target.getRootNode().host : target, peStyle = parentElement.ownerDocument.defaultView.getComputedStyle(parentElement), parentScroll = peStyle.overflowX !== "visible" || peStyle.overflowY !== "visible", offsetParent = getOffsetParent(target);
    let result = Rectangle.from(target, null, true);
    for (let viewport = parentScroll ? target.parentNode : offsetParent; result && viewport !== doc.documentElement; viewport = viewport.parentNode) {
      if (viewport.nodeType === Node.DOCUMENT_FRAGMENT_NODE && viewport.host) {
        viewport = viewport.host.parentNode;
      }
      const isTop = viewport === doc.body, style = viewport.ownerDocument.defaultView.getComputedStyle(viewport);
      if (style.display === "contents") {
        continue;
      }
      if (isTop || style.overflow !== "visible") {
        const viewportRect = isTop ? docRect : Rectangle.client(viewport, null, true, true);
        result = viewportRect[method](result, false, true);
      }
    }
    return result;
  }
  /**
   * Returns `true` if the passed element is deeply visible. Meaning it is not hidden using `display`
   * or `visibility` and no ancestor node is hidden.
   * @param {HTMLElement} element The element to test.
   * @returns {Boolean} `true` if deeply visible.
   */
  static isVisible(element) {
    const document2 = element.ownerDocument;
    for (; element; element = parentNode(element)) {
      if (element === document2) {
        return true;
      }
      if (element.nodeType === element.ELEMENT_NODE && !isVisible(element)) {
        return false;
      }
    }
    return false;
  }
  /**
   * Returns true if DOM Event instance is passed. It is handy to override to support Locker Service.
   * @param event
   * @internal
   * @returns {Boolean}
   */
  static isDOMEvent(event) {
    return event instanceof Event;
  }
  /**
   * Merges specified source DOM config objects into a `dest` object.
   * @param {DomConfig} dest The destination DOM config object.
   * @param {...DomConfig} sources The DOM config objects to merge into `dest`.
   * @returns {DomConfig} The `dest` object.
   * @internal
   */
  static merge(dest, ...sources) {
    return ObjectHelper.blend(dest, sources, { merge: mergeChildren });
  }
  /**
   * Updates in-place a DOM config object whose `children` property may be an object instead of the typical array.
   * The keys of such objects become the `reference` property upon conversion.
   *
   * @param {DomConfig} domConfig
   * @param {Function} [namedChildren] A function to call for each named child element.
   * @privateparam {Boolean} [ignoreRefs] Not meant to be manually set, used when recursing.
   * @returns {DomConfig} Returns the altered DOM config
   * @internal
   */
  static normalizeChildren(domConfig, namedChildren, ignoreRefs) {
    var _a2;
    let children = domConfig == null ? void 0 : domConfig.children, child, i, name, kids, ref;
    if ((_a2 = domConfig == null ? void 0 : domConfig.syncOptions) == null ? void 0 : _a2.ignoreRefs) {
      ignoreRefs = true;
    }
    if (children && !(domConfig instanceof Node)) {
      if (Array.isArray(children)) {
        for (i = 0; i < children.length; ++i) {
          DH2.normalizeChildren(children[i], namedChildren, ignoreRefs);
        }
      } else {
        kids = children;
        domConfig.children = children = [];
        for (name in kids) {
          child = kids[name];
          if (child == null ? void 0 : child.isWidget) {
            child = child.element;
          }
          ref = !name.startsWith("$") && !DH2.isElement(child);
          ref && (namedChildren == null ? void 0 : namedChildren(
            name,
            /* hoist = */
            !ignoreRefs
          ));
          if (child) {
            if (!(child instanceof Node)) {
              if (child.reference === false) {
                delete child.reference;
              } else if (ref && typeof child !== "string") {
                child.reference = name;
              }
              DH2.normalizeChildren(child, namedChildren, ignoreRefs);
            }
            children.push(child);
          }
        }
      }
    }
    return domConfig;
  }
  static roundPx(px, devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const multiplier = 1 / devicePixelRatio;
    return Math.round(px / multiplier) * multiplier;
  }
  // For use when we are dividing a DOM element into even parts. The resulting value
  // must be floored to prevent overflow. But only floored to the device's resolution,
  // so raw Math.floor will not work - it would leave empty space in hi resolution screens.
  static floorPx(px, devicePixelRatio = globalThis.devicePixelRatio || 1) {
    const multiplier = 1 / devicePixelRatio;
    return Math.floor(px * multiplier) / multiplier;
  }
  /**
   * Returns true if element has opened shadow root
   * @param {HTMLElement} element Element to check
   * @returns {Boolean}
   */
  static isCustomElement(element) {
    return Boolean(element == null ? void 0 : element.shadowRoot);
  }
  /**
   * Resolves element from point, checking shadow DOM if required
   * @param {Number} x
   * @param {Number} y
   * @returns {HTMLElement}
   */
  static elementFromPoint(x, y) {
    let el = document.elementFromPoint(x, y);
    if (DH2.isCustomElement(el)) {
      el = el.shadowRoot.elementFromPoint(x, y) || el;
    }
    return el;
  }
  /**
   * Resolves child element from point __in the passed element's coordinate space__.
   * @param {HTMLElement} parent The element to find the occupying element in.
   * @param {Number|Core.helper.util.Rectangle.Point} x Either the `X` part of a point, or the point to find.
   * @param {Number} [y] The `Y` part of the point.
   * @returns {HTMLElement}
   * @internal
   */
  static childFromPoint(el, x, y, parent = el) {
    const p = y == null ? x : new Rectangle(x, y, 0, 0);
    let result = null;
    Array.from(el.children).reverse().some((el2) => {
      if (Rectangle.from(el2, parent).contains(p)) {
        result = el2.children.length && DH2.childFromPoint(el2, p, null, parent) || el2;
        return true;
      }
    });
    return result;
  }
  /**
   * Converts a name/value pair of a style name and its value into the canonical (hyphenated) name of the style
   * property and a value with the `defaultUnit` suffix appended if no unit is already present in the `value`.
   *
   * For example:
   * ```javascript
   *  const [property, value] = DomHelper.unitize('marginLeft', 50);
   *  console.log(property, value);
   * ```
   *
   * ```
   *  > margin-left 50px
   * ```
   * @param {String} name
   * @param {String|Number} value
   * @param {String} [defaultUnit]
   * @returns {String[]}
   * @internal
   */
  static unitize(name, value, defaultUnit = "px") {
    const [trueName, hasUnits] = canonicalizeStyle(name);
    if (value != null) {
      value = String(value);
      value = hasUnits && digitsRe.test(value) ? value + defaultUnit : value;
    }
    return [trueName, value];
  }
  /**
   * Returns active element checking shadow dom too
   * @readonly
   * @property {HTMLElement}
   */
  static get activeElement() {
    let el = document.activeElement;
    while (el.shadowRoot) {
      el = el.shadowRoot.activeElement;
    }
    return el;
  }
  // returns active element for DOM tree / shadow DOM tree to which element belongs
  static getActiveElement(element) {
    if (element == null ? void 0 : element.isWidget) {
      element = element.element;
    }
    let el = ((element == null ? void 0 : element.getRootNode()) || document).activeElement;
    while (el == null ? void 0 : el.shadowRoot) {
      el = el.shadowRoot.activeElement;
    }
    return el;
  }
  // Returns the visible root (either document.body or a web component shadow root)
  static getRootElement(element) {
    var _a2;
    const root = (_a2 = element.getRootNode) == null ? void 0 : _a2.call(element), { nodeType } = root;
    return nodeType === Node.DOCUMENT_NODE ? root.body : nodeType === Node.DOCUMENT_FRAGMENT_NODE ? root : element.ownerDocument.contains(element) ? element.ownerDocument.body : null;
  }
  // Returns the topmost HTMLElement inside the current context (either document.body or a direct child of a web component shadow root)
  static getOutermostElement(element) {
    var _a2;
    const root = (_a2 = element.getRootNode) == null ? void 0 : _a2.call(element);
    if (root == null ? void 0 : root.body) {
      return root == null ? void 0 : root.body;
    }
    while (element.parentNode !== root && element.parentNode) {
      element = element.parentNode;
    }
    return element;
  }
  static isValidFloatRootParent(target) {
    return target === document.body || target.constructor.name === "ShadowRoot";
  }
  /**
   * Returns the `id` of the passed element. Generates a unique `id` if the element does not have one.
   * @param {HTMLElement} element The element to return the `id` of.
   */
  static getId(element) {
    return element.id || (element.id = "b-element-" + ++idCounter);
  }
  /**
   * Returns common widget/node ancestor for from/to arguments
   * @param {Core.widget.Widget|HTMLElement} from
   * @param {Core.widget.Widget|HTMLElement} to
   * @returns {Core.widget.Widget|HTMLElement}
   * @internal
   */
  static getCommonAncestor(from, to) {
    var _a2, _b;
    if (from === to) {
      return from;
    }
    while (from && !(((_a2 = from[from.isWidget ? "owns" : "contains"]) == null ? void 0 : _a2.call(from, to)) || from === to)) {
      from = ((_b = from.owner) == null ? void 0 : _b.isWidget) && from.owner !== from ? from.owner : from.parentNode;
    }
    return from;
  }
  //region Internal
  /**
   * Internal convenience fn to allow specifying either an element or a CSS selector to retrieve one
   * @private
   * @param {String|HTMLElement} elementOrSelector element or selector to lookup in DOM
   * @returns {HTMLElement}
   */
  static getElement(elementOrSelector) {
    if (elementOrSelector instanceof Element) {
      return elementOrSelector;
    }
    return doc.querySelector(elementOrSelector);
  }
  /**
   * Sets attributes passed as object to given element
   * @param {String|Element} elementOrSelector
   * @param {Object} attributes
   * @internal
   */
  static setAttributes(elementOrSelector, attributes) {
    const element = DH2.getElement(elementOrSelector);
    if (element && attributes) {
      for (const key in attributes) {
        if (attributes[key] == null) {
          element.removeAttribute(key);
        } else {
          element.setAttribute(key, attributes[key]);
        }
      }
    }
  }
  /**
   * Sets a CSS [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length) style value.
   * @param {String|HTMLElement} element The element to set the style in, or, if just the result is required,
   * the style magnitude to return with units added. If a nullish value is passed, an empty string
   * is returned.
   * @param {String} [style] The name of a style property which specifies a [length](https://developer.mozilla.org/en-US/docs/Web/CSS/length)
   * @param {Number|String} [value] The magnitude. If a number is used, the value will be set in `px` units.
   * @returns {String} The style value string.
   */
  static setLength(element, style, value) {
    if (arguments.length === 1) {
      value = typeof element === "number" ? `${element}px` : element != null ? element : "";
    } else {
      element = DH2.getElement(element);
      value = element.style[style] = typeof value === "number" ? `${value}px` : value != null ? value : "";
    }
    return value;
  }
  /**
   * Returns string percentified and rounded value for setting element's height, width etc.
   * @param {String|Number} value percent value
   * @param {Number} digits number of decimal digits for rounding
   * @returns {string} percentified value or empty string if value can not be parsed
   * @internal
   */
  static percentify(value, digits = 2) {
    const mult = Math.pow(10, digits);
    return value == null || value === "" || isNaN(value) ? "" : `${Math.round(value * mult) / mult}%`;
  }
  //endregion
  //region Children, going down...
  /**
   * Gets the first direct child of `element` that matches `selector`.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {HTMLElement}
   * @category Query children
   */
  static getChild(element, selector) {
    return element.querySelector(":scope>" + selector);
  }
  /**
   * Checks if `element` has any child that matches `selector`.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {Boolean} true if any child matches selector
   * @category Query children
   */
  static hasChild(element, selector) {
    return DH2.getChild(element, selector) != null;
  }
  /**
   * Returns all child elements (not necessarily direct children) that matches `selector`.
   *
   * If `selector` starts with `'>'` or `'# '`, then all components of the `selector` must match inside of `element`.
   * The scope selector, `:scope` is prepended to the selector (and if `#` was used, it is removed).
   *
   * These are equivalent:
   *
   *      DomHelper.children(el, '# .foo .bar');
   *
   *      el.querySelectorAll(':scope .foo .bar');
   *
   * These are also equivalent:
   *
   *      DomHelper.children(el, '> .foo .bar');
   *
   *      el.querySelectorAll(':scope > .foo .bar');
   *
   * @param {HTMLElement} element The parent element
   * @param {String} selector The CSS selector
   * @returns {HTMLElement[]} Matched elements, somewhere below `element`
   * @category Query children
   */
  static children(element, selector) {
    if (selector[0] === ">" || selector.startsWith("# ")) {
      if (selector[0] === "#") {
        selector = selector.substr(2);
      }
      selector = ":scope " + selector;
    }
    return Array.from(element.querySelectorAll(selector));
  }
  // Salesforce doesn't yet support childElementCount. So we relace all native usages with this wrapper and
  // override it for salesforce environment.
  // https://github.com/bryntum/support/issues/3008
  static getChildElementCount(element) {
    return element.childElementCount;
  }
  /**
   * Looks at the specified `element` and all of its children for the one that first matches `selector`.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @returns {HTMLElement} Matched element, either element or an element below it
   * @category Query children
   */
  static down(element, selector) {
    if (!element) {
      return null;
    }
    if (element.matches && element.matches(selector)) {
      return element;
    }
    selector = ":scope " + selector;
    return element.querySelector(selector);
  }
  /**
   * Checks if childElement is a descendant of parentElement (contained in it or a sub element)
   * @param {HTMLElement} parentElement Parent element
   * @param {HTMLElement} childElement Child element, at any level below parent (includes nested shadow roots)
   * @returns {Boolean}
   * @category Query children
   */
  static isDescendant(parentElement, childElement) {
    const parentRoot = DH2.getRootElement(parentElement), childRoot = DH2.getRootElement(childElement);
    if (childRoot && parentRoot !== childRoot && childRoot.host) {
      return DH2.isDescendant(parentRoot, childRoot.host);
    }
    return parentElement.contains(childElement);
  }
  /**
   * Returns the specified element of the given `event`. If the `event` is an `Element`, it is returned. Otherwise,
   * the `eventName` argument is used to retrieve the desired element property from `event` (this defaults to the
   * `'target'` property).
   * @param {Event|Element} event
   * @param {String} [elementName]
   * @returns {Element}
   */
  static getEventElement(event, elementName = "target") {
    return !event || DH2.isElement(event) ? event : event[elementName];
  }
  /**
   * Returns `true` if the provided value is _likely_ a DOM element. If the element can be assured to be from the
   * same document, `instanceof Element` is more reliable.
   * @param {*} value
   * @returns {Boolean}
   */
  static isElement(value) {
    return (value == null ? void 0 : value.nodeType) === document.ELEMENT_NODE && DH2.isNode(value);
  }
  /**
   * Returns `true` if the provided element is an instance of React Element.
   * All React elements require an additional $$typeof: Symbol.for('react.element') field declared on the object for security reasons.
   * The object which React.createElement() return has $$typeof property equals to Symbol.for('react.element')
   *
   * Sources:
   * https://reactjs.org/blog/2015/12/18/react-components-elements-and-instances.html
   * https://github.com/facebook/react/pull/4832
   *
   * @param {*} element
   * @returns {Boolean}
   * @internal
   */
  static isReactElement(element) {
    return (element == null ? void 0 : element.$$typeof) === Symbol.for("react.element");
  }
  /**
   * Returns `true` if the provided value is _likely_ a DOM node. If the node can be assured to be from the same
   * document, `instanceof Node` is more reliable.
   * @param {*} value
   * @returns {Boolean}
   */
  static isNode(value) {
    return Boolean(value) && typeof value.nodeType === "number" && !isObject(value);
  }
  /**
   * Iterates over each result returned from `element.querySelectorAll(selector)`. Can also be called with only two
   * arguments, in which case the first argument is used as selector and document is used as the element.
   * @param {HTMLElement} element Parent element
   * @param {String} selector CSS selector
   * @param {Function} fn Function called for each found element
   * @category Query children
   */
  static forEachSelector(element, selector, fn2) {
    if (typeof element === "string") {
      throw new Error("DomHelper.forEachSelector must provide a root element context (for shadow root scenario)");
    }
    DH2.children(element, selector).forEach(fn2);
  }
  /**
   * Iterates over the direct child elements of the specified element.
   * @param {HTMLElement} element Parent element
   * @param {Function} fn Function called for each child element
   * @category Query children
   */
  static forEachChild(element, fn2) {
    Array.from(element.children).forEach(fn2);
  }
  /**
   * Removes each element returned from `element.querySelectorAll(selector)`.
   * @param {HTMLElement} element
   * @param {String} selector
   * @category Query children
   */
  static removeEachSelector(element, selector) {
    DH2.forEachSelector(element, selector, (child) => child.remove());
  }
  static removeClsGlobally(element, ...classes) {
    classes.forEach((cls) => DH2.forEachSelector(element, "." + cls, (child) => child.classList.remove(cls)));
  }
  //endregion
  //region Parents, going up...
  /**
   * Looks at the specified element and all of its parents for the one that first matches selector.
   * @deprecated Since 5.3.9, use native `element.closest()` instead
   * @param {HTMLElement} element Element
   * @param {String} selector CSS selector
   * @returns {HTMLElement} Matched element, either the passed in element or an element above it
   * @category Query parents
   */
  static up(element, selector) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.up() deprecated, use native `element.closest()` instead");
    return element.closest(selector);
  }
  static getAncestor(element, possibleAncestorParents, outerElement = null) {
    let found = false, ancestor, parent = element;
    possibleAncestorParents = ArrayHelper.asArray(possibleAncestorParents);
    while (parent = parent.parentElement) {
      if (possibleAncestorParents.includes(parent)) {
        found = true;
        break;
      }
      if (outerElement && parent === outerElement)
        break;
      ancestor = parent;
    }
    if (!found)
      return null;
    return ancestor || element;
  }
  /**
   * Retrieves all parents to the specified element.
   * @param {HTMLElement} element Element
   * @returns {HTMLElement[]} All parent elements, bottom up
   * @category Query parents
   */
  static getParents(element) {
    const parents = [];
    while (element.parentElement) {
      parents.push(element.parentElement);
      element = element.parentElement;
    }
    return parents;
  }
  //endregion
  //region Creation
  /**
   * Converts the passed id to an id valid for usage as id on a DOM element.
   * @param {String} id
   * @returns {String}
   */
  static makeValidId(id, replaceValue = "") {
    return StringHelper.makeValidDomId(id, replaceValue);
  }
  /**
   * Creates an Element, accepts a {@link #typedef-DomConfig} object. Example usage:
   *
   * ```javascript
   * DomHelper.createElement({
   *   tag         : 'table', // defaults to 'div'
   *   className   : 'nacho',
   *   html        : 'I am a nacho',
   *   children    : [ { tag: 'tr', ... }, myDomElement ],
   *   parent      : myExistingElement // Or its id
   *   style       : 'font-weight: bold;color: red',
   *   dataset     : { index: 0, size: 10 },
   *   tooltip     : 'Yay!',
   *   ns          : 'http://www.w3.org/1999/xhtml'
   * });
   * ```
   *
   * @param {DomConfig} config Element config object
   * @param {Object} [options] An object specifying creation options. If this is a boolean value, it is
   * understood to be the `returnAll` option.
   * @param {Boolean} [options.ignoreRefs] Pass `true` to ignore element references.
   * @param {Boolean} [options.returnAll] Specify true to return all elements & child elements created as an array.
   * @privateparam {HTMLElement} [options.replaceElement] Pass element which will be replaced with a created one
   * @returns {HTMLElement|HTMLElement[]|Object<String,HTMLElement>} Single element or array of elements `returnAll` was set to true.
   * If any elements had a `reference` property, this will be an object containing a reference to
   * all those elements, keyed by the reference name.
   * @category Creation
   */
  static createElement(config = {}, options) {
    var _a2, _b;
    let returnAll = options, element, i, ignoreChildRefs, ignoreRefOption, ignoreRefs, key, name, value, refOwner, refs, syncIdField;
    if (typeof returnAll === "boolean") {
      throw new Error("Clean up");
    } else if (options) {
      ignoreRefs = options.ignoreRefs;
      refOwner = options.refOwner;
      refs = options.refs;
      returnAll = options.returnAll;
      syncIdField = options.syncIdField;
      if (ignoreRefs) {
        ignoreChildRefs = true;
        ignoreRefs = ignoreRefs !== "children";
      }
    }
    if (typeof config.parent === "string") {
      config.parent = document.getElementById(config.parent);
    }
    const parent = config.parent || config.nextSibling && config.nextSibling.parentNode, { dataset, html, reference, syncOptions, text } = config;
    if (syncOptions) {
      syncIdField = syncOptions.syncIdField || syncIdField;
      ignoreRefOption = syncOptions.ignoreRefs;
      if (ignoreRefOption) {
        ignoreChildRefs = true;
        ignoreRefs = ignoreRefOption !== "children";
        options = {
          ...options,
          ignoreRefs: true
        };
      }
    }
    if (ignoreRefs) {
      refOwner = null;
    }
    if (config.ns) {
      element = doc.createElementNS(config.ns, config.tag || "svg");
    } else {
      element = doc.createElement(config.tag || "div");
    }
    if (text != null) {
      DH2.setInnerText(element, text);
    } else if (html != null) {
      if (html instanceof DocumentFragment) {
        element.appendChild(html);
      } else {
        element.innerHTML = html;
      }
    }
    if (config.tooltip) {
      DH2.Widget.attachTooltip(element, config.tooltip);
    }
    if (config.style) {
      DH2.applyStyle(element, config.style);
    }
    if (dataset) {
      for (name in dataset) {
        value = dataset[name];
        if (value != null) {
          element.dataset[name] = value;
        }
      }
    }
    if (parent) {
      this.addChild(parent, element, config.nextSibling);
    }
    if (refOwner) {
      element.$refOwnerId = refOwner.id;
    }
    if (reference && !ignoreRefs) {
      if (refOwner) {
        element.$reference = reference;
        refOwner.attachRef(reference, element, config);
      } else {
        if (!refs) {
          options = Object.assign({}, options);
          options.refs = refs = {};
        }
        refs[reference] = element;
        element.setAttribute("data-reference", reference);
      }
    }
    const className = config.className || config.class, keys = Object.keys(config);
    if (className) {
      element.setAttribute("class", DomClassList.normalize(className));
    }
    for (i = 0; i < keys.length; ++i) {
      name = keys[i];
      value = config[name];
      if ((key = elementCreateExpandos[name]) != null) {
        element[key || name] = value;
      } else if (!elementCreateProperties[name] && name && value != null) {
        element.setAttribute(name, value);
      }
    }
    if (!config["aria-hidden"] && !config.role && !config.tabIndex && !_DomHelper.isFocusable(element, true) && !element.htmlFor) {
      element.setAttribute("role", "presentation");
    }
    (_b = options == null ? void 0 : options.callback) == null ? void 0 : _b.call(options, {
      action: "newElement",
      domConfig: config,
      targetElement: element,
      syncId: refOwner ? reference : options.syncIdField && ((_a2 = config.dataset) == null ? void 0 : _a2[options.syncIdField])
    });
    if (returnAll === true) {
      options.returnAll = returnAll = [element];
    } else if (Array.isArray(returnAll)) {
      returnAll.push(element);
    }
    if (config.children) {
      if (syncIdField) {
        element.syncIdMap = {};
      }
      config.children.forEach((child) => {
        var _a3, _b2, _c;
        if (child) {
          if (typeof child === "string") {
            const textNode = document.createTextNode(child);
            if (refOwner) {
              textNode.$refOwnerId = refOwner.id;
            }
            element.appendChild(textNode);
          } else if (isNaN(child.nodeType)) {
            child.parent = element;
            if (!child.ns && config.ns) {
              child.ns = config.ns;
            }
            const childElement = DH2.createElement(child, {
              ...options,
              ignoreRefs: (_b2 = (_a3 = config.syncOptions) == null ? void 0 : _a3.ignoreRef) != null ? _b2 : ignoreChildRefs
            }), syncId = (_c = child.dataset) == null ? void 0 : _c[syncIdField];
            if (syncId != null) {
              element.syncIdMap[syncId] = childElement;
            }
            delete child.parent;
          } else {
            element.appendChild(child);
          }
        }
      });
    }
    element.lastDomConfig = config;
    const result = refs || returnAll || element;
    if (config.replaceElement) {
      config.replaceElement.replaceWith(result);
    }
    return result;
  }
  /**
   * Create element(s) from a template (html string). Note that
   * `textNode`s are discarded unless the `raw` option is passed
   * as `true`.
   *
   * If the template has a single root element, then the single element will be returned
   * unless the `array` option is passed as `true`.
   *
   * If there are multiple elements, then an Array will be returned.
   *
   * @param {String} template The HTML string from which to create DOM content
   * @param {Object} [options] An object containing properties to modify how the DOM is created and returned.
   * @param {Boolean} [options.array] `true` to return an array even if there's only one resulting element.
   * @param {Boolean} [options.raw] Return all child nodes, including text nodes.
   * @param {Boolean} [options.fragment] Return a DocumentFragment.
   * @private
   */
  static createElementFromTemplate(template, options = emptyObject4) {
    const { array, raw, fragment } = options;
    let result;
    if (DH2.supportsTemplate) {
      (templateElement || (templateElement = doc.createElement("template"))).innerHTML = template;
      result = templateElement.content;
      if (fragment) {
        return result.cloneNode(true);
      }
    } else {
      result = (htmlParser || (htmlParser = new DOMParser())).parseFromString(template, "text/html").body;
      if (fragment) {
        const nodes = result.childNodes;
        result = document.createDocumentFragment();
        while (nodes.length) {
          result.appendChild(nodes[0]);
        }
        return result;
      }
    }
    if (raw) {
      result = result.childNodes;
    } else {
      result = result.children;
    }
    return result.length === 1 && !array ? result[0] : arraySlice.call(result);
  }
  /**
   * Dispatches a MouseEvent of the passed type to the element at the visible centre of the passed element.
   * @param {HTMLElement} targetElement The element whose center receives the mouse event.
   * @param {String} [type=contextmenu] The mouse event type to dispatch.
   * @internal
   */
  static triggerMouseEvent(targetElement, type = "contextmenu") {
    const isInView = this.isInView(targetElement), targetRect = isInView || Rectangle.from(targetElement), targetPoint = targetRect.center, contextmenuEvent = new MouseEvent(type, {
      clientX: targetPoint.x,
      clientY: targetPoint.y,
      bubbles: true
    });
    targetElement.dispatchEvent(contextmenuEvent);
  }
  /**
   * Inserts an `element` at first position in `into`.
   * @param {HTMLElement} into Parent element
   * @param {HTMLElement} element Element to insert, or an element config passed on to createElement()
   * @returns {HTMLElement}
   * @category Creation
   */
  static insertFirst(into, element) {
    if (element && element.nodeType !== ELEMENT_NODE && element.tag) {
      element = DH2.createElement(element);
    }
    return into.insertBefore(element, into.firstElementChild);
  }
  /**
   * Inserts a `element` before `beforeElement` in `into`.
   * @param {HTMLElement} into Parent element
   * @param {HTMLElement} element Element to insert, or an element config passed on to createElement()
   * @param {HTMLElement} beforeElement Element before which passed element should be inserted
   * @returns {HTMLElement}
   * @category Creation
   */
  static insertBefore(into, element, beforeElement) {
    if (element && element.nodeType !== ELEMENT_NODE && element.tag) {
      element = DH2.createElement(element);
    }
    return beforeElement ? into.insertBefore(element, beforeElement) : DH2.insertFirst(into, element);
  }
  static insertAt(parentElement, newElement, index) {
    const siblings = Array.from(parentElement.children);
    if (index >= siblings.length) {
      return DH2.append(parentElement, newElement);
    }
    const beforeElement = siblings[index];
    return DH2.insertBefore(parentElement, newElement, beforeElement);
  }
  /**
   * Appends element to parentElement.
   * @param {HTMLElement} parentElement Parent element
   * @param {HTMLElement|DomConfig|String} elementOrConfig Element to insert, or an element config passed on to
   * `createElement()`, or an html string passed to `createElementFromTemplate()`
   * @returns {HTMLElement}
   * @category Creation
   */
  static append(parentElement, elementOrConfig) {
    if (elementOrConfig.forEach) {
      if (Array.isArray(elementOrConfig)) {
        elementOrConfig = elementOrConfig.map((elementOrConfig2) => elementOrConfigToElement(elementOrConfig2));
      }
      if (parentElement.append) {
        parentElement.append(...elementOrConfig);
      } else {
        const docFrag = document.createDocumentFragment();
        elementOrConfig.forEach(function(child) {
          docFrag.appendChild(child);
        });
        parentElement.appendChild(docFrag);
      }
      return elementOrConfig;
    } else {
      return parentElement.appendChild(elementOrConfigToElement(elementOrConfig));
    }
  }
  //endregion
  //region Get position
  /**
   * Returns the element's `transform translateX` value in pixels.
   * @param {HTMLElement} element
   * @returns {Number} X transform
   * @category Position, get
   */
  static getTranslateX(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateXRe.exec(transformStyle);
    if (matches) {
      return parseFloat(matches[2]);
    } else {
      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(DH2.getStyleValue(element, "transform"));
      return matches ? parseFloat(matches[1] || matches[3]) : 0;
    }
  }
  /**
   * Returns the element's `transform translateY` value in pixels.
   * @param {HTMLElement} element
   * @returns {Number} Y coordinate
   * @category Position, get
   */
  static getTranslateY(element) {
    const transformStyle = element.style.transform;
    let matches = pxTtranslateYRe.exec(transformStyle);
    if (matches) {
      const y = parseFloat(matches[matches[1] === "Y" ? 2 : 3]);
      return isNaN(y) ? 0 : y;
    } else {
      matches = translateMatrixRe.exec(transformStyle) || translateMatrixRe.exec(DH2.getStyleValue(element, "transform"));
      return matches ? parseFloat(matches[2] || matches[4]) : 0;
    }
  }
  /**
   * Gets both X and Y coordinates as an array [x, y]
   * @param {HTMLElement} element
   * @returns {Number[]} [x, y]
   * @category Position, get
   */
  static getTranslateXY(element) {
    return [DH2.getTranslateX(element), DH2.getTranslateY(element)];
  }
  /**
   * Get elements X offset within a containing element
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number} X offset
   * @category Position, get
   */
  static getOffsetX(element, container = null) {
    return container ? element.getBoundingClientRect().left - container.getBoundingClientRect().left : element.offsetLeft;
  }
  /**
   * Get elements Y offset within a containing element
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number} Y offset
   * @category Position, get
   */
  static getOffsetY(element, container = null) {
    return container ? element.getBoundingClientRect().top - container.getBoundingClientRect().top : element.offsetTop;
  }
  /**
   * Gets elements X and Y offset within containing element as an array [x, y]
   * @param {HTMLElement} element
   * @param {HTMLElement} container
   * @returns {Number[]} [x, y]
   * @category Position, get
   */
  static getOffsetXY(element, container = null) {
    return [DH2.getOffsetX(element, container), DH2.getOffsetY(element, container)];
  }
  /**
   * Focus element without scrolling the element into view.
   * @param {HTMLElement} element
   */
  static focusWithoutScrolling(element) {
    function resetScroll(scrollHierarchy) {
      scrollHierarchy.forEach(({ element: element2, scrollLeft, scrollTop }) => {
        if (element2.scrollLeft !== scrollLeft) {
          element2.scrollLeft = scrollLeft;
        }
        if (element2.scrollTop !== scrollTop) {
          element2.scrollTop = scrollTop;
        }
      });
    }
    const preventScrollSupported = !BrowserHelper.isSafari;
    if (preventScrollSupported) {
      element.focus({ preventScroll: true });
    } else {
      const parents = DH2.getParents(element), scrollHierarchy = parents.map((parent) => ({
        element: parent,
        scrollLeft: parent.scrollLeft,
        scrollTop: parent.scrollTop
      }));
      element.focus();
      setTimeout(() => resetScroll(scrollHierarchy), 0);
    }
  }
  /**
   * Get elements X position on page
   * @param {HTMLElement} element
   * @returns {Number}
   * @category Position, get
   */
  static getPageX(element) {
    return element.getBoundingClientRect().left + win.pageXOffset;
  }
  /**
   * Get elements Y position on page
   * @param {HTMLElement} element
   * @returns {Number}
   * @category Position, get
   */
  static getPageY(element) {
    return element.getBoundingClientRect().top + win.pageYOffset;
  }
  /**
   * Returns extremal (min/max) size (height/width) of the element in pixels
   * @param {HTMLElement} element
   * @param {String} style minWidth/minHeight/maxWidth/maxHeight
   * @returns {Number}
   * @internal
   */
  static getExtremalSizePX(element, style) {
    const prop = StringHelper.hyphenate(style), measure = prop.split("-")[1];
    let value = DH2.getStyleValue(element, prop);
    if (/%/.test(value)) {
      if (element.parentElement) {
        value = parseInt(DH2.getStyleValue(element.parentElement, measure), 10);
      } else {
        value = NaN;
      }
    } else {
      value = parseInt(value, 10);
    }
    return value;
  }
  //endregion
  //region Set position
  /**
   * Set element's `scale`.
   * @param {HTMLElement} element
   * @param {Number} scaleX The value by which the element should be scaled in the X axis (0 to 1)
   * @param {Number} [scaleY] The value by which the element should be scaled in the Y axis (0 to 1).
   * Defaults to `scaleX`
   * @category Position, set
   * @internal
   */
  static setScale(element, scaleX, scaleY = scaleX) {
    const t = DH2.getStyleValue(element, "transform").split(/,\s*/);
    if (t.length > 1) {
      if (t[0].startsWith("matrix3d")) {
        t[0] = `matrix3d(${scaleX}`;
        t[5] = scaleY;
      } else {
        t[0] = `matrix(${scaleX}`;
        t[3] = scaleY;
      }
      element.style.transform = t.join(",");
    } else {
      element.style.transform = `scale(${scaleX}, ${scaleY})`;
    }
  }
  /**
   * Set element's `X` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} x The value by which the element should be translated from its default position.
   * @category Position, set
   */
  static setTranslateX(element, x) {
    const t = DH2.getStyleValue(element, "transform").split(/,\s*/);
    x = DH2.roundPx(x);
    if (t.length > 1) {
      t[t[0].startsWith("matrix3d") ? 12 : 4] = x;
      element.style.transform = t.join(",");
    } else {
      element.style.transform = `translateX(${x}px)`;
    }
  }
  /**
   * Set element's `Y` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} y  The value by which the element should be translated from its default position.
   * @category Position, set
   */
  static setTranslateY(element, y) {
    const t = DH2.getStyleValue(element, "transform").split(/,\s*/);
    y = DH2.roundPx(y);
    if (t.length > 1) {
      t[t[0].startsWith("matrix3d") ? 13 : 5] = y;
      element.style.transform = t.join(",") + ")";
    } else {
      element.style.transform = `translateY(${y}px)`;
    }
  }
  /**
   * Set element's style `top`.
   * @param {HTMLElement} element
   * @param {Number|String} y The top position. If numeric, `'px'` is used as the unit.
   * @category Position, set
   */
  static setTop(element, y) {
    DH2.setLength(element, "top", y);
  }
  /**
   * Set element's style `left`.
   * @param {HTMLElement} element
   * @param {Number|String} x The top position. If numeric, `'px'` is used as the unit.
   * @category Position, set
   */
  static setLeft(element, x) {
    DH2.setLength(element, "left", x);
  }
  static setTopLeft(element, y, x) {
    DH2.setLength(element, "top", y);
    DH2.setLength(element, "left", x);
  }
  static setRect(element, { x, y, width, height }) {
    DH2.setTopLeft(element, y, x);
    DH2.setLength(element, "width", width);
    DH2.setLength(element, "height", height);
  }
  /**
   * Set elements `X` and `Y` translation in pixels.
   * @param {HTMLElement} element
   * @param {Number} [x] The `X translation.
   * @param {Number} [y] The `Y translation.
   * @category Position, set
   */
  static setTranslateXY(element, x, y) {
    if (x == null) {
      return DH2.setTranslateY(element, y);
    }
    if (y == null) {
      return DH2.setTranslateX(element, x);
    }
    x = DH2.roundPx(x);
    y = DH2.roundPx(y);
    const t = DH2.getStyleValue(element, "transform").split(/,\s*/), is3d = t[0].startsWith("matrix3d");
    if (t.length > 1) {
      t[is3d ? 12 : 4] = x;
      t[is3d ? 13 : 5] = y;
      element.style.transform = t.join(",") + ")";
    } else {
      element.style.transform = `translate(${x}px, ${y}px)`;
    }
  }
  /**
   * Increase `X` translation
   * @param {HTMLElement} element
   * @param {Number} x The number of pixels by which to increase the element's `X` translation.
   * @category Position, set
   */
  static addTranslateX(element, x) {
    DH2.setTranslateX(element, DH2.getTranslateX(element) + x);
  }
  /**
   * Increase `Y` position
   * @param {HTMLElement} element
   * @param {Number} y The number of pixels by which to increase the element's `Y` translation.
   * @category Position, set
   */
  static addTranslateY(element, y) {
    DH2.setTranslateY(element, DH2.getTranslateY(element) + y);
  }
  /**
   * Increase X position
   * @param {HTMLElement} element
   * @param {Number} x
   * @category Position, set
   */
  static addLeft(element, x) {
    DH2.setLeft(element, DH2.getOffsetX(element) + x);
  }
  /**
   * Increase Y position
   * @param {HTMLElement} element
   * @param {Number} y
   * @category Position, set
   */
  static addTop(element, y) {
    DH2.setTop(element, DH2.getOffsetY(element) + y);
  }
  /**
   * Align the passed element with the passed target according to the align spec.
   * @param {HTMLElement} element The element to align.
   * @param {HTMLElement|Core.helper.util.Rectangle} target The target element or rectangle to align to
   * @param {AlignSpec} [alignSpec] See {@link Core.helper.util.Rectangle#function-alignTo} Defaults to `{ align : 't0-t0' }`
   * @param {Boolean} [round] Round the calculated Rectangles (for example if dealing with scrolling which
   * is integer based).
   */
  static alignTo(element, target, alignSpec = t0t0, round2) {
    target = target instanceof Rectangle ? target : Rectangle.from(target, true);
    const elXY = DH2.getTranslateXY(element), elRect = Rectangle.from(element, true);
    if (round2) {
      elRect.roundPx();
      target.roundPx();
    }
    const targetRect = elRect.alignTo(Object.assign(alignSpec, {
      target
    }));
    DH2.setTranslateXY(element, elXY[0] + targetRect.x - elRect.x, elXY[1] + targetRect.y - elRect.y);
  }
  //endregion
  //region Styles & CSS
  /**
   * Returns a style value or values for the passed element.
   * @param {HTMLElement} element The element to read styles from
   * @param {String|String[]} propName The property or properties to read
   * @param {Boolean} [inline=false] Pass as `true` to read the element's inline style.
   * Note that this could return inaccurate results if CSS rules apply to this element.
   * @returns {String|Object} The value or an object containing the values keyed by the requested property name.
   * @category CSS
   */
  static getStyleValue(element, propName, inline, pseudo) {
    const styles = inline ? element.style : element.ownerDocument.defaultView.getComputedStyle(element, pseudo);
    if (Array.isArray(propName)) {
      const result = {};
      for (const prop of propName) {
        result[prop] = styles.getPropertyValue(StringHelper.hyphenate(prop));
      }
      return result;
    }
    return styles.getPropertyValue(StringHelper.hyphenate(propName));
  }
  /**
   * Returns an object with the parse style values for the top, right, bottom, and left
   * components of the given edge style.
   *
   * The return value is an object with `top`, `right`, `bottom`, and `left` properties
   * for the respective components of the edge style, as well as `width` (the sum of
   * `left` and `right`) and `height` (the sum of `top` and `bottom`).
   *
   * @param {HTMLElement} element
   * @param {String} edgeStyle The element's desired edge style such as 'padding', 'margin',
   * or 'border'.
   * @param {String} [edges='trbl'] A string with one character codes for each edge. Only
   * those edges will be populated in the returned object. By default, all edges will be
   * populated.
   * @returns {Object}
   */
  static getEdgeSize(element, edgeStyle, edges) {
    const suffix = edgeStyle === "border" ? "-width" : "", ret = {
      raw: {}
    };
    for (const edge of ["top", "right", "bottom", "left"]) {
      if (!edges || edges.includes(edge[0])) {
        ret[edge] = parseFloat(
          ret.raw[edge] = DH2.getStyleValue(element, `${edgeStyle}-${edge}${suffix}`)
        );
      }
    }
    ret.width = (ret.left || 0) + (ret.right || 0);
    ret.height = (ret.top || 0) + (ret.bottom || 0);
    return ret;
  }
  /**
   * Splits a style string up into object form. For example `'font-weight:bold;font-size:150%'`
   * would convert to
   *
   * ```javascript
   * {
   *     font-weight : 'bold',
   *     font-size : '150%'
   * }
   * ```
   * @param {String} style A DOM style string
   * @returns {Object} the style declaration in object form.
   */
  static parseStyle(style) {
    if (typeof style === "string") {
      const styles = style.split(semicolonRe);
      style = {};
      for (let i = 0, { length } = styles; i < length; i++) {
        const propVal = styles[i].split(colonRe);
        style[propVal[0]] = propVal[1];
      }
    }
    return style || {};
  }
  /**
   * Applies specified style to the passed element. Style can be an object or a string.
   * @param {HTMLElement} element Target element
   * @param {String|Object} style Style to apply, 'border: 1px solid black' or { border: '1px solid black' }
   * @param {Boolean} [overwrite] Specify `true` to replace style instead of applying changes
   * @category CSS
   */
  static applyStyle(element, style, overwrite = false) {
    if (typeof style === "string") {
      if (overwrite) {
        if (style.length || element.style.cssText.length) {
          element.style.cssText = style;
        }
      } else {
        element.style.cssText += style;
      }
    } else if (style) {
      if (overwrite) {
        element.style.cssText = "";
      }
      if (style.style && typeof style.style !== "string") {
        style = ObjectHelper.assign({}, style, style.style);
      }
      let key, value;
      for (key in style) {
        if (!styleIgnoreProperties[key]) {
          [key, value] = DH2.unitize(key, style[key]);
          if (value == null) {
            element.style.removeProperty(key);
          } else {
            element.style.setProperty(key, value);
          }
        }
      }
      if (typeof style.style === "string") {
        element.style.cssText += style.style;
      }
    }
  }
  static getCSSText(style) {
    if (typeof style === "string") {
      return style;
    }
    let cssText = "";
    for (const key in style) {
      if (!styleIgnoreProperties[key]) {
        cssText += `${StringHelper.hyphenate(key)}:${style[key]};`;
      }
    }
    return cssText;
  }
  /**
   * Add multiple classes to elements classList.
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @deprecated Since 5.0. Use {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList/add add} method
   * for {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/classList Element.classlist}
   * @category CSS
   */
  static addClasses(element, classes) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.addClasses should be replaced by native classList.add");
    element.classList.add(...classes);
  }
  /**
   * Remove multiple classes from elements classList.
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @deprecated Since 5.0. Use {@link https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList/remove remove} method
   * for {@link https://developer.mozilla.org/en-US/docs/Web/API/Element/classList Element.classlist}
   * @category CSS
   */
  static removeClasses(element, classes) {
    VersionHelper.deprecate("Core", "6.0.0", "DomHelper.removeClasses should be replaced by native classList.remove");
    element.classList.remove(...classes);
  }
  /**
   * Toggle multiple classes in elements classList. Helper for toggling multiple classes at once.
   * @param {HTMLElement} element
   * @param {String[]} classes
   * @param {Boolean} [force] Specify true to add classes, false to remove. Leave blank to toggle
   * @category CSS
   */
  static toggleClasses(element, classes, force = null) {
    classes = ArrayHelper.asArray(classes);
    if (force === true) {
      element.classList.add(...classes);
    } else if (force === false) {
      element.classList.remove(...classes);
    } else {
      classes.forEach((cls) => element.classList.toggle(cls));
    }
  }
  /**
   * Adds a CSS class to an element during the specified duration
   * @param {HTMLElement} element Target element
   * @param {String} cls CSS class to add temporarily
   * @param {Number} duration Duration in ms, 0 means cls will not be applied
   * @param {Core.mixin.Delayable} delayable The delayable to tie the setTimeout call to
   * @privateparam {String} name Timer name
   * @typings delayable -> {typeof Delayable}
   * @category CSS
   */
  static addTemporaryClass(element, cls, duration, delayable = globalThis, name = cls) {
    if (duration > 0) {
      element.classList.add(cls);
      delayable.setTimeout({
        fn: (cls2) => element.classList.remove(cls2),
        delay: duration,
        name,
        args: [cls],
        cancelOutstanding: true
      });
    }
  }
  /**
   * Reads computed style from the element and returns transition duration for a given property in milliseconds
   * @param {HTMLElement} element Target DOM element
   * @param {String} property Animated property name
   * @returns {Number} Duration in ms
   * @internal
   */
  static getPropertyTransitionDuration(element, property) {
    const style = globalThis.getComputedStyle(element), properties = style.transitionProperty.split(", "), durations = style.transitionDuration.split(", "), index = properties.indexOf(StringHelper.hyphenate(property));
    let result;
    if (index !== -1) {
      result = parseFloat(durations[index]) * 1e3;
    }
    return result;
  }
  /**
   * Reads computed style from the element and returns the animation duration for any
   * attached animation in milliseconds
   * @param {HTMLElement} element Target DOM element
   * @returns {Number} Duration in ms
   * @internal
   */
  static getAnimationDuration(element) {
    return parseFloat(DH2.getStyleValue(element, "animation-duration")) * 1e3;
  }
  //endregion
  //region Effects
  /**
   * Highlights the passed element or Rectangle according to the theme's highlighting rules.
   * Usually an animated framing effect.
   *
   * The framing effect is achieved by adding the CSS class `b-fx-highlight` which references
   * a `keyframes` animation named `b-fx-highlight-animation`. You may override the animation
   * name referenced, or the animation itself in your own CSS.
   *
   * @param {HTMLElement|Core.helper.util.Rectangle} element The element or Rectangle to highlight.
   */
  static highlight(element, delayable = globalThis) {
    if (element instanceof Rectangle) {
      return element.highlight();
    }
    return new Promise((resolve) => {
      delayable.setTimeout(() => {
        element.classList.add("b-fx-highlight");
        delayable.setTimeout(() => {
          element.classList.remove("b-fx-highlight");
          resolve();
        }, 1e3);
      }, 0);
    });
  }
  //endregion
  //region Measuring / Scrollbar
  /**
   * Measures the scrollbar width using a hidden div. Caches result
   * @property {Number}
   * @readonly
   */
  static get scrollBarWidth() {
    if (scrollBarWidth === null) {
      const element = scrollBarMeasureElement || (scrollBarMeasureElement = DH2.createElement({
        parent: doc.documentElement,
        className: "b-scrollbar-measure-element",
        style: "position:absolute;top:-9999em;height:100px;overflow-y:scroll"
      }));
      if (element.parentNode !== doc.documentElement) {
        doc.documentElement.appendChild(element);
      }
      scrollBarWidth = element.offsetWidth;
    }
    return scrollBarWidth;
  }
  static get scrollBarPadElement() {
    return {
      className: "b-yscroll-pad",
      children: [{
        className: "b-yscroll-pad-sizer"
      }]
    };
  }
  /**
   * Resets DomHelper.scrollBarWidth cache, triggering a new measurement next time it is read
   */
  static resetScrollBarWidth() {
    scrollBarWidth = null;
  }
  /**
   * Measures the text width using a hidden div
   * @param {String} text
   * @param {HTMLElement} sourceElement
   * @returns {Number} width
   * @category Measure
   */
  static measureText(text, sourceElement, useHTML = false, parentElement = void 0) {
    const offScreenDiv = DH2.getMeasureElement(sourceElement, parentElement);
    offScreenDiv[useHTML ? "innerHTML" : "innerText"] = text;
    const result = offScreenDiv.clientWidth;
    offScreenDiv.className = "";
    return result;
  }
  /**
   * Measures a relative size, such as a size specified in `em` units for the passed element.
   * @param {String} size The CSS size value to measure.
   * @param {HTMLElement} sourceElement
   * @param {Boolean} [round] Pass true to return exact width, not rounded value
   * @returns {Number} size The size in pixels of the passed relative measurement.
   * @category Measure
   */
  static measureSize(size, sourceElement, round2 = true) {
    if (!size) {
      return 0;
    }
    if (typeof size === "number") {
      return size;
    }
    if (!size.length) {
      return 0;
    }
    if (/^\d+(px)?$/.test(size)) {
      return parseInt(size);
    }
    if (sourceElement) {
      const offScreenDiv = DH2.getMeasureElement(sourceElement);
      offScreenDiv.innerHTML = "";
      offScreenDiv.style.width = DH2.setLength(size);
      const result = round2 ? offScreenDiv.offsetWidth : offScreenDiv.getBoundingClientRect().width;
      offScreenDiv.style.width = offScreenDiv.className = "";
      return result;
    }
    if (/^\d+em$/.test(size)) {
      return parseInt(size) * DEFAULT_FONT_SIZE;
    }
    return isNaN(size) ? 0 : parseInt(size);
  }
  // parentElement allows measurement to happen inside a specific element, allowing scoped css rules to match
  static getMeasureElement(sourceElement, parentElement = doc.body) {
    const sourceElementStyle = win.getComputedStyle(sourceElement), offScreenDiv = parentElement.offScreenDiv = parentElement.offScreenDiv || DH2.createElement({
      parent: parentElement,
      style: "position:fixed;top:-10000px;left:-10000px;visibility:hidden;contain:strict",
      className: "b-measure-element",
      children: [{
        style: "white-space:nowrap;display:inline-block;will-change:contents;width:auto;contain:none"
      }]
    }, { returnAll: true })[1];
    fontProps.forEach((prop) => {
      if (offScreenDiv.style[prop] !== sourceElementStyle[prop]) {
        offScreenDiv.style[prop] = sourceElementStyle[prop];
      }
    });
    offScreenDiv.className = sourceElement.className;
    if (offScreenDiv.parentElement.parentElement !== parentElement) {
      parentElement.appendChild(offScreenDiv.parentElement);
    }
    return offScreenDiv;
  }
  /**
   * Strips the tags from a html string, returning text content.
   *
   * ```javascript
   * DomHelper.stripTags('<div class="custom"><b>Bold</b><i>Italic</i></div>'); // -> BoldItalic
   * ```
   *
   * @internal
   * @param {String} htmlString HTML string
   * @returns {String} Text content
   */
  static stripTags(htmlString) {
    const parser = DH2.$domParser || (DH2.$domParser = new DOMParser()), doc2 = parser.parseFromString(htmlString, "text/html");
    return doc2.body.textContent;
  }
  //endregion
  //region Sync
  /**
   * Sync one source element attributes, children etc. to a target element. Source element can be specified as a html
   * string or an actual HTMLElement.
   *
   * NOTE: This function is superseded by {@link Core/helper/DomSync#function-sync-static DomSync.sync()}, which works
   * with DOM configs. For most usecases, use it instead.
   *
   * @param {String|HTMLElement} sourceElement Source "element" to copy from
   * @param {HTMLElement} targetElement Target element to apply to, can also be specified as part of the config object
   * @returns {HTMLElement} Returns the updated targetElement (which is also updated in place)
   */
  static sync(sourceElement, targetElement) {
    if (typeof sourceElement === "string") {
      if (sourceElement === "") {
        targetElement.innerHTML = "";
        return;
      } else {
        sourceElement = DH2.createElementFromTemplate(sourceElement);
      }
    }
    DH2.performSync(sourceElement, targetElement);
    return targetElement;
  }
  // Internal helper used for recursive syncing
  static performSync(sourceElement, targetElement) {
    if (sourceElement.outerHTML !== targetElement.outerHTML) {
      DH2.syncAttributes(sourceElement, targetElement);
      DH2.syncContent(sourceElement, targetElement);
      DH2.syncChildren(sourceElement, targetElement);
      return true;
    }
    return false;
  }
  // Attributes as map { attr : value, ... }, either from an html element or from a config
  static getSyncAttributes(element) {
    const attributes = {}, names = [];
    for (let i = 0; i < element.attributes.length; i++) {
      const attr = element.attributes[i];
      if (attr.specified) {
        const name = attr.name.toLowerCase();
        attributes[name] = attr.value;
        names.push(name);
      }
    }
    return { attributes, names };
  }
  /**
   * Syncs attributes from sourceElement to targetElement.
   * @private
   * @param {HTMLElement} sourceElement
   * @param {HTMLElement} targetElement
   */
  static syncAttributes(sourceElement, targetElement) {
    const {
      attributes: sourceAttributes,
      names: sourceNames
    } = DH2.getSyncAttributes(sourceElement), {
      attributes: targetAttributes,
      names: targetNames
    } = DH2.getSyncAttributes(targetElement), hasDataset = sourceNames.includes("dataset"), toAdd = sourceNames.filter((attr) => !targetNames.includes(attr)), toRemove = targetNames.filter((attr) => !sourceNames.includes(attr) && (!hasDataset || !attr.startsWith("data-"))), toSync = sourceNames.filter((attr) => targetNames.includes(attr));
    if (toAdd.length > 0) {
      for (let i = 0; i < toAdd.length; i++) {
        const attr = toAdd[i];
        if (attr === "style") {
          DH2.applyStyle(targetElement, sourceAttributes.style, true);
        } else if (attr === "dataset") {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        } else {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
    if (toRemove.length > 0) {
      for (let i = 0; i < toRemove.length; i++) {
        targetElement.removeAttribute(toRemove[i]);
      }
    }
    if (toSync.length > 0) {
      for (let i = 0; i < toSync.length; i++) {
        const attr = toSync[i];
        if (attr === "style") {
          DH2.applyStyle(targetElement, sourceAttributes.style, true);
        } else if (attr === "dataset") {
          Object.assign(targetElement.dataset, sourceAttributes.dataset);
        } else if (attr === "class" && (sourceAttributes.class.isDomClassList || typeof sourceAttributes.class === "object")) {
          let classList;
          if (sourceAttributes.class.isDomClassList) {
            classList = sourceAttributes.class;
          } else {
            classList = new DomClassList(sourceAttributes.class);
          }
          if (!classList.isEqual(targetAttributes.class)) {
            targetElement.setAttribute("class", classList);
          }
        } else if (targetAttributes[attr] !== sourceAttributes[attr]) {
          targetElement.setAttribute(attr, sourceAttributes[attr]);
        }
      }
    }
  }
  /**
   * Sync content (innerText) from sourceElement to targetElement
   * @private
   * @param {HTMLElement} sourceElement
   * @param {HTMLElement} targetElement
   */
  static syncContent(sourceElement, targetElement) {
    if (DH2.getChildElementCount(sourceElement) === 0) {
      targetElement.innerText = sourceElement.innerText;
    }
  }
  static setInnerText(targetElement, text) {
    const { firstChild } = targetElement;
    if ((firstChild == null ? void 0 : firstChild.nodeType) === Element.TEXT_NODE) {
      firstChild.data = text;
    } else {
      targetElement.textContent = text;
    }
  }
  /**
   * Sync traversing children
   * @private
   * @param {HTMLElement} sourceElement Source element
   * @param {HTMLElement} targetElement Target element
   */
  static syncChildren(sourceElement, targetElement) {
    const me = this, sourceNodes = arraySlice.call(sourceElement.childNodes), targetNodes = arraySlice.call(targetElement.childNodes);
    while (sourceNodes.length) {
      const sourceNode = sourceNodes.shift(), targetNode = targetNodes.shift();
      if (sourceNode && sourceNode.nodeType !== TEXT_NODE && sourceNode.nodeType !== ELEMENT_NODE) {
        throw new Error(`Source node type ${sourceNode.nodeType} not supported by DomHelper.sync()`);
      }
      if (targetNode && targetNode.nodeType !== TEXT_NODE && targetNode.nodeType !== ELEMENT_NODE) {
        throw new Error(`Target node type ${targetNode.nodeType} not supported by DomHelper.sync()`);
      }
      if (!targetNode) {
        targetElement.appendChild(sourceNode);
      } else {
        if (sourceNode.nodeType === targetNode.nodeType) {
          if (sourceNode.nodeType === TEXT_NODE) {
            targetNode.data = sourceNode.data;
          } else {
            if (sourceNode.tagName === targetNode.tagName) {
              me.performSync(sourceNode, targetNode);
            } else {
              targetElement.insertBefore(sourceNode, targetNode);
              targetNode.remove();
            }
          }
        } else if (sourceNode.nodeType === TEXT_NODE && targetNode.nodeType === ELEMENT_NODE) {
          targetElement.innerText = sourceNode.data.trim();
        } else {
          const logElement = sourceNode.parentElement || sourceNode;
          throw new Error(`Currently no support for transforming nodeType.
${logElement.outerHTML}`);
        }
      }
    }
    targetNodes.forEach((targetNode) => {
      targetNode.remove();
    });
  }
  /**
   * Replaces the passed element's `className` with the class names
   * passed in either Array or String format or Object.
   *
   * This method compares the existing class set with the incoming class set and
   * avoids mutating the element's class name set if possible.
   *
   * This can avoid browser style invalidations.
   * @param {HTMLElement} element The element whose class list to synchronize.
   * @param {String[]|String|Object} newClasses The incoming class names to set on the element.
   * @returns {Boolean} `true` if the DOM class list was changed.
   * @category CSS
   */
  static syncClassList(element, newClasses) {
    const { classList } = element, isString = typeof newClasses === "string", newClsArray = isString ? newClasses.split(whiteSpaceRe2) : DomClassList.normalize(newClasses, "array"), classCount = newClsArray.length;
    let changed = classList.length !== classCount, i;
    for (i = 0; !changed && i < classCount; i++) {
      changed = !classList.contains(newClsArray[i]);
    }
    if (changed) {
      element.className = isString ? newClasses : newClsArray.join(" ");
    }
    return changed;
  }
  /**
   * Applies the key state of the passed object or DomClassList to the passed element.
   *
   * Properties with a falsy value mean that property name is *removed* as a class name.
   *
   * Properties with a truthy value mean that property name is *added* as a class name.
   *
   * This is different from {@link #function-syncClassList-static}. That sets the `className` of the element to the
   * sum of all its truthy keys, regardless of what the pre-existing value of the `className` was, and ignoring falsy
   * keys.
   *
   * This _selectively_ updates the classes in the `className`. If there is a truthy key, the name is added. If there
   * is a falsy key, the name is removed.
   * @param {HTMLElement} element The element to apply the class list to .
   * @param {Object|Core.helper.util.DomClassList} classes The classes to add or remove.
   * @returns {Boolean} `true` if the DOM class list was changed.
   * @category CSS
   */
  static updateClassList(element, classes) {
    const { classList } = element;
    let cls, add, changed = false;
    for (cls in classes) {
      add = Boolean(classes[cls]);
      if (classList.contains(cls) !== add) {
        classList[add ? "add" : "remove"](cls);
        changed = true;
      }
    }
    return changed;
  }
  /**
   * Changes the theme to the passed theme name if possible.
   *
   * Theme names are case insensitive. The `href` used is all lower case.
   *
   * To use this method, the `<link rel="stylesheet">` _must_ use the default,
   * Bryntum-supplied CSS files where the `href` end with `<themeName>.css`, so that
   * it can be found in the document, and switched out for a new link with
   * the a modified `href`. The new `href` will use the same path, just
   * with the `themeName` portion substituted for the new name.
   *
   * If no `<link>` with that name pattern can be found, an error will be thrown.
   *
   * If you use this method, you  must ensure that the theme files are
   * all accessible on your server.
   *
   * Because this is an asynchronous operation, a `Promise` is returned.
   * The theme change event is passed to the success function. If the
   * theme was not changed, because the theme name passed is the current theme,
   * nothing is passed to the success function.
   *
   * The theme change event contains two properties:
   *
   *  - `prev` The previous Theme name.
   *  - `theme` The new Theme name.
   *
   * @param {String} newThemeName the name of the theme that should be applied
   * @privateparam {String} [defaultTheme] Optional, the name of the theme that should be used in case of fail
   * @returns {Promise} A promise who's success callback receives the theme change
   * event if the theme in fact changed. If the theme `href` could not be loaded,
   * the failure callback is called, passing the error event caught.
   * @async
   */
  static setTheme(newThemeName, defaultTheme) {
    newThemeName = newThemeName.toLowerCase();
    const { head } = document, oldThemeName = DH2.getThemeInfo(defaultTheme).name.toLowerCase();
    let oldThemeLinks = head.querySelectorAll("[data-bryntum-theme]:not([data-loading])"), loaded = 0;
    if (oldThemeName === newThemeName) {
      return immediatePromise;
    }
    DH2.removeEachSelector(head, "#bryntum-theme[data-loading],link[data-bryntum-theme][data-loading]");
    const themeEvent = {
      theme: newThemeName,
      prev: oldThemeName
    };
    function replaceTheme(oldThemeLink, resolve, reject) {
      const newThemeLink = _DomHelper.createElement({
        tag: "link",
        rel: "stylesheet",
        dataset: {
          loading: true,
          bryntumTheme: true
        },
        href: oldThemeLink.href.replace(oldThemeName, newThemeName),
        nextSibling: oldThemeLink
      });
      newThemeLink.addEventListener("load", () => {
        delete newThemeLink.dataset.loading;
        themeInfo = null;
        if (++loaded === oldThemeLinks.length) {
          oldThemeLinks.forEach((link) => link.remove());
          GlobalEvents_default.trigger("theme", themeEvent);
          resolve(themeEvent);
        }
      });
      newThemeLink.addEventListener("error", (e) => {
        delete newThemeLink.dataset.loading;
        reject(e);
      });
    }
    if (oldThemeLinks.length) {
      return new Promise((resolve, reject) => {
        oldThemeLinks.forEach((oldThemeLink, i) => {
          replaceTheme(oldThemeLink, resolve, reject, i === oldThemeLinks.length - 1);
        });
      });
    } else {
      const oldThemeLink = head.querySelector("#bryntum-theme:not([data-loading])") || head.querySelector(`[href*="${oldThemeName}.css"]:not([data-loading])`);
      if (!(oldThemeLink == null ? void 0 : oldThemeLink.href.includes(`${oldThemeName}.css`))) {
        throw new Error(`Theme link for ${oldThemeName} not found`);
      }
      oldThemeLinks = [oldThemeLink];
      return new Promise((resolve, reject) => replaceTheme(oldThemeLink, resolve, reject));
    }
  }
  /**
   * A theme information object about the current theme.
   *
   * Currently, this has only one property:
   *
   *   - `name` The current theme name.
   * @property {Object}
   * @readonly
   */
  static get themeInfo() {
    return _DomHelper.getThemeInfo();
  }
  /**
   * A theme information object about the current theme.
   *
   * Currently this has only one property:
   *
   *   - `name` The current theme name.
   * @param {String} defaultTheme the name of the theme used as backup value in case of fail
   * @param {HTMLElement} contextElement The element for which to find the theme. If using a
   * web component, the theme will be encapsulated in the web component's encapsulated style
   * so a context element is required. If no web components are in use, this may be omitted and
   * `document.body` will be used.
   * @returns {Object} info, currently it contains only one property - 'name'.
   * @private
   */
  static getThemeInfo(defaultTheme) {
    if (!themeInfo) {
      const testDiv = DH2.createElement({
        parent: document.body,
        className: "b-theme-info"
      }), themeData = DH2.getStyleValue(testDiv, "content", false, ":before");
      if (themeData) {
        try {
          themeInfo = JSON.parse(themeData.replace(/^["']|["']$|\\/g, ""));
        } catch (e) {
          themeInfo = null;
        }
      }
      themeInfo = themeInfo || (defaultTheme ? { name: defaultTheme } : null);
      testDiv.remove();
    }
    return themeInfo;
  }
  //endregion
  //region Transition
  static async transition({
    element: outerElement,
    selector = "[data-dom-transition]",
    duration,
    action,
    thisObj = this,
    addTransition = {},
    removeTransition = {}
  }) {
    const scrollers = /* @__PURE__ */ new Set(), beforeElements = Array.from(outerElement.querySelectorAll(selector)), beforeMap = new Map(beforeElements.map((element) => {
      let depth = 0, parent = element.parentElement;
      while (parent && parent !== outerElement) {
        depth++;
        parent = parent.parentElement;
      }
      element.$depth = depth;
      if (element.scrollHeight > element.offsetHeight && getComputedStyle(element).overflow === "auto") {
        element.$scrollTop = element.scrollTop;
        scrollers.add(element);
      }
      const { parentElement } = element, globalBounds = Rectangle.from(element, outerElement), localBounds = Rectangle.from(element, parentElement), style = getComputedStyle(parentElement), borderLeftWidth = parseFloat(style.borderLeftWidth);
      if (borderLeftWidth) {
        globalBounds.left -= borderLeftWidth;
        localBounds.left -= borderLeftWidth;
      }
      return [
        element.id,
        { element, globalBounds, localBounds, depth, parentElement }
      ];
    }));
    action.call(thisObj);
    const afterElements = Array.from(outerElement.querySelectorAll(selector)), afterMap = new Map(afterElements.map((element) => {
      const globalBounds = Rectangle.from(element, outerElement), localBounds = Rectangle.from(element, element.parentElement), style = globalThis.getComputedStyle(element.parentElement), borderLeftWidth = parseFloat(style.borderLeftWidth);
      if (borderLeftWidth) {
        globalBounds.left -= borderLeftWidth;
        localBounds.left -= borderLeftWidth;
      }
      return [
        element.id,
        { element, globalBounds, localBounds }
      ];
    })), styleProps = ["position", "top", "left", "width", "height", "padding", "margin", "zIndex", "minWidth", "minHeight", "opacity", "overflow"];
    for (const [id, before] of beforeMap) {
      const after = afterMap.get(id);
      if (after) {
        const { element } = after, { style, parentElement } = element, zIndex = parseInt(DH2.getStyleValue(element, "zIndex")), {
          globalBounds,
          localBounds,
          depth,
          parentElement: beforeParent
        } = before, parentChanged = beforeParent !== parentElement;
        ObjectHelper.copyProperties(element.$initial = { parentElement }, style, styleProps);
        let bounds;
        if (parentChanged) {
          after.bounds = after.globalBounds;
          bounds = globalBounds;
          outerElement.appendChild(element);
        } else {
          after.bounds = after.localBounds;
          bounds = localBounds;
          beforeParent.appendChild(element);
        }
        let overflow = "hidden";
        if (scrollers.has(element)) {
          element.$scrollPlaceholder = DH2.createElement({
            parent: element,
            style: {
              height: element.scrollHeight
            }
          });
          overflow = "auto";
        }
        const targetStyle = {
          position: "absolute",
          top: `${bounds.top}px`,
          left: `${bounds.left}px`,
          width: `${bounds.width}px`,
          height: `${bounds.height}px`,
          minWidth: 0,
          minHeight: 0,
          margin: 0,
          zIndex: depth + (zIndex || 0),
          overflow
        };
        if (element.dataset.domTransition !== "preserve-padding") {
          targetStyle.padding = 0;
        }
        Object.assign(style, targetStyle);
        after.processed = true;
      } else {
        const { element, localBounds: bounds, depth, parentElement } = before;
        element.$initial = { removed: true };
        Object.assign(element.style, {
          position: "absolute",
          top: `${bounds.top}px`,
          left: `${bounds.left}px`,
          width: `${bounds.width}px`,
          height: `${bounds.height}px`,
          minWidth: 0,
          minHeight: 0,
          padding: 0,
          margin: 0,
          zIndex: depth,
          overflow: "hidden"
          // Looks weird with content sticking out if height is transitioned
        });
        parentElement.appendChild(element);
        afterMap.set(id, { element, bounds, removed: true, processed: true });
        afterElements.push(element);
      }
    }
    for (const [, after] of afterMap) {
      if (!after.processed) {
        const { element } = after, { style, parentElement } = element, bounds = after.bounds = after.localBounds;
        element.classList.add("b-dom-transition-adding");
        ObjectHelper.copyProperties(element.$initial = { parentElement }, style, styleProps);
        Object.assign(style, {
          position: "absolute",
          top: addTransition.top ? 0 : `${bounds.top}px`,
          left: addTransition.left ? 0 : `${bounds.left}px`,
          width: addTransition.width ? 0 : `${bounds.width}px`,
          height: addTransition.height ? 0 : `${bounds.height}px`,
          opacity: addTransition.opacity ? 0 : null,
          zIndex: parentElement.$depth + 1,
          overflow: "hidden"
          // Looks weird with content sticking out if height is transitioned
        });
      }
    }
    for (const element of scrollers) {
      element.scrollTop = element.$scrollTop;
    }
    outerElement.classList.add("b-dom-transition");
    outerElement.firstElementChild.offsetWidth;
    for (const [, { element, bounds: afterBounds, removed }] of afterMap) {
      if (removed) {
        Object.assign(element.style, {
          top: removeTransition.top ? 0 : `${afterBounds.top}px`,
          left: removeTransition.left ? 0 : `${afterBounds.left}px`,
          width: removeTransition.width ? 0 : `${afterBounds.width}px`,
          height: removeTransition.height ? 0 : `${afterBounds.height}px`,
          opacity: removeTransition.opacity ? 0 : element.$initial.opacity
        });
      } else {
        Object.assign(element.style, {
          top: `${afterBounds.top}px`,
          left: `${afterBounds.left}px`,
          width: `${afterBounds.width}px`,
          height: `${afterBounds.height}px`,
          opacity: element.$initial.opacity
        });
      }
    }
    await AsyncHelper.sleep(duration);
    outerElement.classList.remove("b-dom-transition");
    for (const element of afterElements) {
      if (element.$initial) {
        if (element.$initial.removed) {
          element.remove();
        } else {
          ObjectHelper.copyProperties(element.style, element.$initial, styleProps);
          if (element.$scrollPlaceholder) {
            element.$scrollPlaceholder.remove();
            delete element.$scrollPlaceholder;
          }
          element.classList.remove("b-dom-transition-adding");
          element.$initial.parentElement.appendChild(element);
        }
      }
    }
    for (const element of scrollers) {
      element.scrollTop = element.$scrollTop;
      delete element.$scrollTop;
    }
  }
  //endregion
  static async loadScript(url) {
    return new Promise((resolve, reject) => {
      const script = document.createElement("script");
      script.src = url;
      script.onload = resolve;
      script.onerror = reject;
      document.head.appendChild(script);
    });
  }
  static isNamedColor(color) {
    return color && !/^(#|hsl|rgb|hwb|lab|lch|oklab|oklch)/.test(color);
  }
  static createColorStyle(color) {
    return (color == null ? void 0 : color.length) ? this.isNamedColor(color) ? `var(--cal-color-${color})` : color : "";
  }
  //#region Salesforce hooks
  // Wrap NodeFilter to support salesforce
  static get NodeFilter() {
    return NodeFilter;
  }
  static addChild(parent, child, sibling) {
    parent.insertBefore(child, sibling);
  }
  static cloneStylesIntoShadowRoot(shadowRoot, removeExisting) {
    return new Promise((resolve, reject) => {
      if (removeExisting) {
        shadowRoot.querySelectorAll('style, link[rel="stylesheet"]').forEach((el) => el.remove());
      }
      const links = document.querySelectorAll('link[rel="stylesheet"]');
      let loadCount = 0;
      links.forEach((node) => {
        const clone = node.cloneNode();
        clone.addEventListener("load", () => {
          loadCount += 1;
          if (loadCount === links.length) {
            resolve();
          }
        });
        clone.addEventListener("error", (e) => {
          reject(clone.href);
        });
        shadowRoot.appendChild(clone);
      });
      document.querySelectorAll("style").forEach((node) => {
        const clone = node.cloneNode();
        clone.innerText = node.innerText;
        shadowRoot.appendChild(clone);
      });
      if (!links.length) {
        resolve();
      }
    });
  }
  //#endregion
};
var DH2 = DomHelper;
var clearTouchTimer;
var clearTouchEvent = () => DH2.isTouchEvent = false;
var setTouchEvent = () => {
  DH2.isTouchEvent = true;
  clearTimeout(clearTouchTimer);
  clearTouchTimer = setTimeout(clearTouchEvent, 400);
};
doc.addEventListener("touchstart", setTouchEvent, true);
doc.addEventListener("touchend", setTouchEvent, true);
DH2.canonicalStyles = canonicalStyles;
DH2.supportsTemplate = "content" in doc.createElement("template");
DH2.elementPropKey = elementPropKey;
DH2.numberRe = numberRe;
if (!("children" in Node.prototype)) {
  const elementFilter = (node) => node.nodeType === node.ELEMENT_NODE;
  Object.defineProperty(Node.prototype, "children", {
    get: function() {
      return Array.prototype.filter.call(this.childNodes, elementFilter);
    }
  });
}
if (!Element.prototype.matches) {
  Element.prototype.matches = Element.prototype.matchesSelector || Element.prototype.mozMatchesSelector || Element.prototype.msMatchesSelector || Element.prototype.oMatchesSelector || Element.prototype.webkitMatchesSelector || function(s) {
    const matches = (this.document || this.ownerDocument).querySelectorAll(s);
    let i = matches.length;
    while (--i >= 0 && matches.item(i) !== this) {
    }
    return i > -1;
  };
}
if (win.Element && !Element.prototype.closest) {
  Node.prototype.closest = Element.prototype.closest = function(s) {
    let el = this;
    if (!doc.documentElement.contains(el))
      return null;
    do {
      if (el.matches(s))
        return el;
      el = el.parentElement || el.parentNode;
    } while (el !== null && el.nodeType === el.ELEMENT_NODE);
    return null;
  };
} else {
  Node.prototype.closest = function(selector) {
    var _a2;
    return (_a2 = this.parentNode) == null ? void 0 : _a2.closest(selector);
  };
}
(function(arr) {
  arr.forEach(function(item) {
    if (Object.prototype.hasOwnProperty.call(item, "remove")) {
      return;
    }
    Object.defineProperty(item, "remove", {
      configurable: true,
      enumerable: true,
      writable: true,
      value: function remove() {
        this.parentNode && this.parentNode.removeChild(this);
      }
    });
  });
})([Element.prototype, CharacterData.prototype, DocumentType.prototype]);
globalThis.addEventListener("resize", () => scrollBarWidth = null);
DomHelper._$name = "DomHelper";

// ../Core/lib/Core/GlobalEvents.js
var longpressMoveThreshold = 5;
var isFloatingWidget = (w) => w.floating;
var longPressCancelEvents = {
  touchend: 1,
  pointerup: 1
};
var ignoreModifierKeys = {
  Meta: 1,
  Control: 1,
  Alt: 1
};
var GlobalEvents = new class GlobalEventsHandler extends Base.mixin(Events_default) {
  suspendFocusEvents() {
    focusEventsSuspended = true;
  }
  resumeFocusEvents() {
    focusEventsSuspended = false;
  }
  setupFocusListenersOnce(rootElement, EventHelper2) {
    if (rootElement && !GlobalEvents.observedElements.has(rootElement)) {
      GlobalEvents.setupFocusListeners(rootElement, EventHelper2);
      GlobalEvents.observedElements.add(rootElement);
    }
  }
  detachFocusListeners(rootElement) {
    if (rootElement.$globalEventsDetacher) {
      rootElement.$globalEventsDetacher();
      rootElement.$globalEventsDetacher = null;
      GlobalEvents.observedElements.delete(rootElement);
    }
  }
  // This is imported by EventHelper and that makes the call to set up the listeners
  // `detach` argument is required to not setup more listeners than we need to. In case of salesforce we include floatroot
  // inside the webcomponent element and thus don't need default listeners on document. In regular webcomponents demo we
  // don't need to do it, because with multiple components on one page that would force us to make more complex lookups.
  setupFocusListeners(element = document, EventHelper2, detach = false) {
    const listeners = {
      element,
      touchstart(touchstart) {
        if (!globaltouchStart && touchstart.changedTouches.length === 1) {
          globaltouchStart = touchstart.changedTouches[0];
          if (!BrowserHelper.isAndroid) {
            const onMoveOrPointerUp = ({
              clientX,
              clientY,
              type
            }) => {
              if (longPressCancelEvents[type] || Math.max(Math.abs(clientX - globaltouchStart.clientX), Math.abs(clientY - globaltouchStart.clientY)) > longpressMoveThreshold) {
                contextMenuTouchId = null;
                touchMoveRemover();
                clearTimeout(tapholdTimer);
              }
            }, touchMoveRemover = EventHelper2.on({
              element: document,
              touchmove: onMoveOrPointerUp,
              touchend: onMoveOrPointerUp,
              pointermove: onMoveOrPointerUp,
              pointerup: onMoveOrPointerUp,
              capture: true
            }), tapholdTimer = setTimeout(() => {
              contextMenuTouchId = globaltouchStart.identifier;
              touchMoveRemover();
              touchstart.target.dispatchEvent(new MouseEvent("contextmenu", EventHelper2.copyEvent({}, touchstart)));
            }, EventHelper2.longPressTime);
          }
        } else {
          globaltouchStart = null;
        }
      },
      // Just this one has to be passive: false so that we are allowed to preventDefault
      // if we are part of a contextmenu longpress emulation. Otherwise the gesture will
      // proceed to cause a mousedown event.
      touchend: {
        handler: (event) => {
          if (globaltouchStart) {
            if (event.changedTouches[0].identifier === contextMenuTouchId) {
              event.stopImmediatePropagation();
              if (event.cancelable !== false) {
                event.preventDefault();
              }
            } else if (event.changedTouches.length === 1 && event.changedTouches[0].identifier === globaltouchStart.identifier) {
              GlobalEvents.trigger("globaltap", { event });
            }
            globaltouchStart = null;
          }
        },
        passive: false
      },
      mousedown: {
        handler: (event) => {
          lastInteractionType = "mouse";
          if (!globaltouchStart) {
            GlobalEvents.trigger("globaltap", { event });
          }
          currentMouseDown = event;
          const hasModifierKey = event.ctrlKey || event.altKey || event.shiftKey || event.metaKey;
          if (!currentKeyDown && hasModifierKey) {
            currentKeyDown = new KeyboardEvent("keydown", {
              key: event.ctrlKey ? "Control" : event.shiftKey ? "Shift" : event.altKey ? "Alt" : "Meta",
              ctrlKey: event.ctrlKey,
              altKey: event.altKey,
              shiftKey: event.shiftKey,
              metaKey: event.metaKey
            });
          } else if (currentKeyDown && !hasModifierKey) {
            currentKeyDown = null;
          }
        },
        passive: false
      },
      mouseup() {
        currentMouseDown = null;
      },
      pointerdown: {
        passive: false,
        handler: (event) => {
          var _a2;
          currentPointerDown = event;
          DomHelper.usingKeyboard = false;
          (_a2 = element.classList) == null ? void 0 : _a2.remove("b-using-keyboard");
          if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            DomHelper.removeClsGlobally(element, "b-using-keyboard");
          }
        }
      },
      pointerup: {
        passive: false,
        handler: (event) => {
          if ((currentPointerDown == null ? void 0 : currentPointerDown.pointerId) === event.pointerId) {
            currentPointerDown = null;
          }
        }
      },
      keydown(ev) {
        lastInteractionType = "key";
        currentKeyDown = ev;
        currentOverElement = ev.target;
        if (!ignoreModifierKeys[ev.key]) {
          DomHelper.usingKeyboard = true;
          if (element.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
            for (const node of element.children) {
              if (node.matches(".b-outer")) {
                node.classList.add("b-using-keyboard");
              }
            }
          } else {
            element.classList.add("b-using-keyboard");
          }
        }
      },
      mouseenter(ev) {
        currentOverElement = ev.target;
      },
      keypress() {
        lastInteractionType = "key";
      },
      keyup() {
        currentKeyDown = null;
      },
      focusin(focusin) {
        var _a2, _b, _c;
        const { Widget: Widget2 } = GlobalEvents;
        if (((_a2 = focusin.target) == null ? void 0 : _a2.shadowRoot) || ((_b = focusin.target) == null ? void 0 : _b._shadowRoot)) {
          return;
        }
        Widget2.resetFloatRootScroll();
        if (focusEventsSuspended) {
          return;
        }
        const fromElement = !focusin.relatedTarget ? null : focusin.relatedTarget instanceof HTMLElement ? focusin.relatedTarget : document.body, toElement = focusin.target || document.body, fromWidget = Widget2.fromElement(fromElement), toWidget = Widget2.fromElement(toElement), commonAncestor = DomHelper.getCommonAncestor(fromWidget, toWidget), backwards = !!(fromElement && toElement.compareDocumentPosition(fromElement) & 4), topVisibleModal = Widget2.query(isTopVisibleModal);
        let currentFocus = null;
        if (toElement && toElement !== document.body) {
          currentFocus = DomHelper.getActiveElement(toElement);
        } else {
          currentFocus = DomHelper.getActiveElement(document);
        }
        if (topVisibleModal && !topVisibleModal._isRevertingFocus) {
          if (!toWidget || !topVisibleModal.owns(toWidget) && !(topVisibleModal.element.compareDocumentPosition(toWidget.element) & 4 && toWidget.up(isFloatingWidget))) {
            return topVisibleModal.focus();
          }
        }
        let event = createWidgetEvent("focusout", fromElement, focusin.target, fromWidget, toWidget, backwards);
        for (let target = fromWidget, owner; target && target !== commonAncestor; target = owner) {
          owner = target.owner;
          if (!target.isDestroying && target.onFocusOut) {
            target.onFocusOut(event);
            if (focusin.target && currentFocus !== DomHelper.getActiveElement(focusin.target)) {
              return;
            }
          }
        }
        if (commonAncestor && focusin.target === commonAncestor.element) {
          if (!commonAncestor.isDestroying && DomHelper.getActiveElement(commonAncestor) === toElement && commonAncestor.focusElement && commonAncestor.focusElement !== commonAncestor.element) {
            if (!commonAncestor.element.contains(currentFocus) || commonAncestor.focusDescendant) {
              commonAncestor.setTimeout(() => {
                var _a3;
                return (_a3 = commonAncestor.focus) == null ? void 0 : _a3.call(commonAncestor);
              }, 0);
            }
          }
        } else {
          event = createWidgetEvent("focusin", toElement, fromElement, fromWidget, toWidget, backwards);
          for (let target = toWidget; target && target !== commonAncestor; target = target.owner) {
            if (!target.isDestroying) {
              (_c = target.onFocusIn) == null ? void 0 : _c.call(target, event);
            }
          }
        }
        const commonAncestorEl = DomHelper.getCommonAncestor((fromElement == null ? void 0 : fromElement.nodeType) === Element.ELEMENT_NODE ? fromElement : null, toElement) || toElement.parentNode;
        if (commonAncestorEl) {
          event = createWidgetEvent("focusmove", toElement, fromElement, fromWidget, toWidget, backwards, { bubbles: true });
          commonAncestorEl.dispatchEvent(event);
        }
      },
      focusout(focusout) {
        if (focusEventsSuspended) {
          return;
        }
        if (!focusout.relatedTarget || !GlobalEvents.Widget.fromElement(focusout.relatedTarget)) {
          const target = focusout.relatedTarget && focusout.relatedTarget instanceof HTMLElement ? focusout.relatedTarget : null;
          listeners.focusin({
            target,
            relatedTarget: focusout.target
          });
          currentKeyDown = currentMouseDown = null;
        }
      },
      // This will clear keydown and mousedown status on window blur
      blur: {
        element: globalThis,
        handler(event) {
          if (event.target === globalThis) {
            currentKeyDown = null;
            currentMouseDown = null;
          }
        }
      },
      capture: true,
      passive: true
    };
    detach && (detacher == null ? void 0 : detacher());
    detacher = this.detachEvents = element.$globalEventsDetacher = EventHelper2.on(listeners);
  }
  get lastInteractionType() {
    return lastInteractionType;
  }
  get shiftKeyDown() {
    return currentKeyDown == null ? void 0 : currentKeyDown.shiftKey;
  }
  get ctrlKeyDown() {
    return (currentKeyDown == null ? void 0 : currentKeyDown.ctrlKey) || (currentKeyDown == null ? void 0 : currentKeyDown.metaKey);
  }
  get altKeyDown() {
    return currentKeyDown == null ? void 0 : currentKeyDown.altKey;
  }
  get currentOverElement() {
    return currentOverElement;
  }
  isKeyDown(key) {
    return !key ? Boolean(currentKeyDown) : (currentKeyDown == null ? void 0 : currentKeyDown.key) === key || currentKeyDown[(key == null ? void 0 : key.toLowerCase()) + "Key"] === true;
  }
  isMouseDown(button = 0) {
    return (currentMouseDown == null ? void 0 : currentMouseDown.button) === button;
  }
  get currentMouseDown() {
    return currentMouseDown;
  }
  get currentPointerDown() {
    return currentPointerDown;
  }
  get currentTouch() {
    return globaltouchStart;
  }
  get currentKeyDown() {
    return currentKeyDown;
  }
}();
var isTopVisibleModal = (w) => w.isVisible && w.isTopModal;
GlobalEvents.observedElements = /* @__PURE__ */ new Set();
var globaltouchStart;
var contextMenuTouchId;
var focusEventsSuspended = false;
var lastInteractionType;
var currentKeyDown;
var currentMouseDown;
var currentPointerDown;
var currentOverElement;
var detacher;
function createWidgetEvent(eventName, target, relatedTarget, fromWidget, toWidget, backwards, options) {
  const result = new CustomEvent(eventName, options);
  Object.defineProperty(result, "_target", {
    get() {
      return target;
    }
  });
  Object.defineProperty(result, "relatedTarget", {
    get() {
      return relatedTarget;
    }
  });
  result.fromWidget = fromWidget;
  result.toWidget = toWidget;
  result.backwards = backwards;
  return result;
}
var GlobalEvents_default = GlobalEvents;

// ../Core/lib/Core/mixin/InstancePlugin.js
function getDescriptor(me, fnName) {
  const property = ObjectHelper.getPropertyDescriptor(me, fnName);
  return property && (property.get || property.set) ? property : null;
}
var InstancePlugin = class extends Base.mixin(Events_default, Localizable_default) {
  //region Config
  static get configurable() {
    return {
      clientListeners: null,
      /**
       * The plugin/feature `disabled` state.
       *
       * For a feature that is **off** by default that you want to enable later during runtime,
       * configure it with `disabled : true`.
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : {
       *              disabled : true // on and disabled, can be enabled later
       *          }
       *      }
       * });
       *
       * // enable the feature
       * grid.features.featureName.disabled = false;
       * ```
       *
       * If the feature is **disabled** by default, and you want to include and enable the feature, configure it as `true`:
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : true // on and enabled, can be disabled later
       *      }
       * });
       *
       * // disable the feature
       * grid.features.featureName.disabled = true;
       * ```
       *
       * If the feature is **on** by default, but you want to turn it **off**, configure it as `false`:
       * ```javascript
       * const grid = new Grid({
       *      features : {
       *          featureName : false // turned off, not included at all
       *      }
       * });
       * ```
       *
       * If the feature is **enabled** by default and you have no need of reconfiguring it,
       * you can omit the feature configuration.
       *
       * @prp {Boolean}
       * @default
       * @category Common
       */
      disabled: false,
      /**
       * The Widget which was passed into the constructor,
       * which is the Widget we are providing extra services for.
       * @member {Core.widget.Widget} client
       * @readonly
       * @category Misc
       * @advanced
       */
      /**
       * The widget which this plugin is to attach to.
       * @config {Core.widget.Widget}
       * @category Misc
       * @advanced
       */
      client: null,
      /**
       * @hideconfigs bubbleEvents, callOnFunctions
       */
      /**
       * @hidefunctions downloadTestCase, destroy
       */
      /**
       * @hideproperties isDestroyed
       */
      /**
       * @hideevents destroy, beforeDestroy
       */
      // The plugins can define their own keyMap which will then be merged with their client's keyMap.
      keyMap: null
    };
  }
  //endregion
  updateClient(client) {
    if (!this.owner) {
      this.owner = client;
    }
  }
  /**
   * This will merge a feature's (subclass of InstancePlugin) keyMap with it's client's keyMap.
   * @private
   */
  updateKeyMap(keyMap) {
    const { client } = this;
    client.keyMap = client.mergeKeyMaps(client.keyMap, keyMap, StringHelper.uncapitalize(this.constructor.$name));
  }
  //region Init
  /**
   * Call from another instance to add plugins to it.
   *
   * ```javascript
   * InstancePlugin.initPlugins(this, Search, Stripe);
   * ```
   *
   * @param plugInto Instance to mix into (usually this)
   * @param plugins Classes to plug in
   * @internal
   */
  static initPlugins(plugInto, ...plugins) {
    const property = plugInto.plugins || (plugInto.plugins = {});
    for (const PluginClass of plugins) {
      property[PluginClass.$$name] = new PluginClass(plugInto);
    }
  }
  /**
   * Simple wrapper for {@link #property-disabled} to make optional chaining simple:
   *
   * ```javascript
   * grid.features.myFeature?.enabled // returns true when feature exists and is enabled
   * ```
   * @returns {Boolean}
   * @internal
   */
  get enabled() {
    return !this.disabled;
  }
  // We can act as an owner of a widget, so must be able to participate in focus reversion
  getFocusRevertTarget() {
    var _a2;
    return (_a2 = this.client) == null ? void 0 : _a2.getFocusRevertTarget();
  }
  construct(...args) {
    const me = this;
    let [plugInto, config] = args, listeners;
    if (args.length === 1) {
      if (ObjectHelper.isObject(plugInto)) {
        config = plugInto;
        plugInto = config.client;
      }
    } else {
      config = ObjectHelper.assign({}, config);
      delete config.client;
    }
    me.client = plugInto;
    super.construct(config);
    me.applyPluginConfig(plugInto);
    listeners = me.clientListeners;
    if (listeners) {
      listeners = ObjectHelper.assign({}, listeners);
      listeners.thisObj = me;
      plugInto.ion(listeners);
    }
  }
  /**
   * Applies config as found in plugInto.pluginConfig, or published all if no config found.
   * @private
   * @param plugInto Target instance to plug into
   */
  applyPluginConfig(plugInto) {
    const me = this, config = me.pluginConfig || me.constructor.pluginConfig;
    if (config) {
      const { assign: assign2, chain, after, before, override } = config;
      assign2 && me.applyAssign(plugInto, assign2);
      (chain || after) && me.applyChain(plugInto, chain || after);
      before && me.applyChain(plugInto, before, false);
      override && me.applyOverride(plugInto, override);
    }
  }
  /**
   * Applies assigning for specified functions.
   * @private
   * @param plugInto
   * @param fnNames
   */
  applyAssign(plugInto, fnNames) {
    fnNames.forEach((fnName) => this.assign(plugInto, fnName));
  }
  /**
   * Applies chaining for specified functions.
   * @private
   * @param plugInto
   * @param functions
   * @param after
   */
  applyChain(plugInto, functions, after = true) {
    if (Array.isArray(functions)) {
      for (const fnName of functions) {
        this.chain(plugInto, fnName, fnName, after);
      }
    } else {
      for (const intoName in functions) {
        this.chain(plugInto, intoName, functions[intoName], after);
      }
    }
  }
  /**
   * Applies override for specified functions.
   * @private
   * @param plugInto
   * @param fnNames
   */
  applyOverride(plugInto, fnNames) {
    const me = this;
    if (!me.overridden) {
      me.overridden = {};
    }
    fnNames.forEach((fnName) => {
      if (!me[fnName]) {
        throw new Error(`Trying to chain fn ${plugInto.$$name}#${fnName}, but plugin fn ${me.$$name}#${fnName} does not exist`);
      }
      if (typeof plugInto[fnName] === "function") {
        me.overridden[fnName] = plugInto[fnName].bind(plugInto);
      }
      plugInto[fnName] = me[fnName].bind(me);
    });
  }
  /**
   * Assigns specified functions.
   * @private
   * @param plugInto
   * @param fnName
   */
  assign(plugInto, fnName) {
    const me = this, property = getDescriptor(me, fnName);
    if (property) {
      Object.defineProperty(plugInto, fnName, {
        configurable: true,
        enumerable: true,
        get: property.get && property.get.bind(me),
        set: property.set && property.set.bind(me)
      });
    } else {
      plugInto[fnName] = me[fnName].bind(me);
    }
  }
  //endregion
  //region Chaining
  /**
   * Chains functions. When the function is called on the target class all functions in the chain will be called in
   * the order they were added.
   * @private
   * @param plugInto
   * @param intoName
   * @param hookName
   * @param after
   */
  chain(plugInto, intoName, hookName, after = true) {
    let prio = 0;
    if (typeof intoName === "object") {
      intoName = intoName.fn;
    }
    if (typeof hookName === "object") {
      prio = hookName.prio || 0;
      hookName = hookName.fn;
    }
    const me = this, chains = plugInto.pluginFunctionChain || (plugInto.pluginFunctionChain = {}), hookFn = me[hookName] && me[hookName].bind(me), functionChainRunner = me.functionChainRunner;
    if (!hookFn) {
      throw new Error(`Trying to chain fn ${plugInto.$$name}#${hookName}, but plugin fn ${me.$$name}#${hookName} does not exist`);
    }
    if (!chains[intoName]) {
      let intoFn = plugInto[intoName];
      if (intoFn) {
        intoFn = intoFn.bind(plugInto);
        intoFn.$this = plugInto;
        intoFn.$prio = 0;
      }
      chains[intoName] = intoFn ? [intoFn] : [];
      plugInto[intoName] = (...params) => functionChainRunner(chains[intoName], params);
    }
    hookFn.$this = me;
    hookFn.$prio = prio;
    chains[intoName][after ? "push" : "unshift"](hookFn);
    chains[intoName].$sorted = false;
  }
  /**
   * Used to run multiple plugged in functions with the same name, see chain above. Returning false from a
   * function will abort chain.
   * @private
   * @param {Array} chain
   * @param {Array} params
   * @returns {*} value returned from last function in chain (or false if any returns false)
   */
  functionChainRunner(chain, params) {
    let fn2, i, returnValue;
    if (!chain.$sorted) {
      chain.sort((a, b) => b.$prio - a.$prio);
      chain.$sorted = true;
    }
    for (i = 0; i < chain.length; i++) {
      fn2 = chain[i];
      if (!fn2.$this.isDestroyed) {
        returnValue = fn2(...params);
        if (returnValue === false) {
          break;
        }
      }
    }
    return returnValue;
  }
  //endregion
  /**
   * Called when disabling/enabling the plugin/feature, not intended to be called directly. To enable or disable a
   * plugin/feature, see {@link #property-disabled}.
   *
   * By default removes the cls of the plugin from its client. Override in subclasses to take any other actions necessary.
   * @category Misc
   * @advanced
   */
  doDisable(disable) {
    var _a2, _b, _c, _d;
    const me = this, { constructor } = me, cls = "featureClass" in constructor ? constructor.featureClass : `b-${constructor.$$name.toLowerCase()}`, key = StringHelper.uncapitalize(constructor.$$name);
    if (cls) {
      (_b = (_a2 = me.client) == null ? void 0 : _a2._element) == null ? void 0 : _b.classList[disable ? "remove" : "add"](cls);
    }
    if (!me.isConfiguring) {
      if (disable) {
        me.trigger("disable");
      } else {
        me.trigger("enable");
      }
      (_d = (_c = me.client).syncSplits) == null ? void 0 : _d.call(_c, (other) => {
        const otherFeature = other.features[key];
        if (otherFeature) {
          otherFeature.disabled = disable;
        }
      });
    }
  }
  updateDisabled(disabled) {
    this.doDisable(disabled);
  }
  throwOverrideIsMissing(data) {
    throw new Error(`Trying to override fn ${data.plugIntoName}#${data.fnName}, but plugin fn ${data.pluginName}#${data.fnName} does not exist`);
  }
  // Convenience method to read the rootElement from the owner widget
  get rootElement() {
    return this.client.rootElement;
  }
};
__publicField(InstancePlugin, "$name", "InstancePlugin");
InstancePlugin._$name = "InstancePlugin";

// ../Core/lib/Core/mixin/Pluggable.js
var Pluggable_default = (Target) => class Pluggable extends (Target || Base) {
  static get $name() {
    return "Pluggable";
  }
  /**
   * Specify plugins (an array of classes) in config
   * @config {Function[]} plugins
   * @category Misc
   * @advanced
   */
  /**
   * Map of applied plugins
   * @property {Object<String,Core.mixin.InstancePlugin>}
   * @readonly
   * @category Misc
   * @advanced
   */
  get plugins() {
    if (!this._plugins) {
      this._plugins = {};
    }
    return this._plugins;
  }
  set plugins(plugins) {
    if (plugins) {
      if (!Array.isArray(plugins))
        plugins = [plugins];
      InstancePlugin.initPlugins(this, ...plugins);
    }
    this.initPlugins();
  }
  /**
   * Template method which may be implemented in subclasses to initialize any plugins.
   * This method is empty in the `Pluggable` base class.
   * @internal
   */
  initPlugins() {
  }
  /**
   * Adds plugins to an instance.
   * @param {Function[]} plugins The plugins to add
   * @category Misc
   * @advanced
   */
  addPlugins(...plugins) {
    InstancePlugin.initPlugins(this, ...plugins);
  }
  /**
   * Checks if instance has plugin.
   * @param {String|Function} pluginClassOrName Plugin or name to check for
   * @returns {Boolean}
   * @category Misc
   * @advanced
   */
  hasPlugin(pluginClassOrName) {
    return this.getPlugin(pluginClassOrName) != null;
  }
  /**
   * Get a plugin instance.
   * @param {String|Function} pluginClassOrName
   * @returns {Core.mixin.InstancePlugin}
   * @category Misc
   * @advanced
   */
  getPlugin(pluginClassOrName) {
    var _a2;
    if (typeof pluginClassOrName === "function") {
      pluginClassOrName = pluginClassOrName.$$name;
    }
    return (_a2 = this.plugins) == null ? void 0 : _a2[pluginClassOrName];
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement thus.
  get widgetClass() {
  }
};

// ../Core/lib/Core/mixin/Delayable.js
var { defineProperty: defineProperty3 } = Reflect;
var performance2;
if (BrowserHelper.isBrowserEnv) {
  performance2 = globalThis.performance;
} else {
  performance2 = {
    now() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
  };
}
var globalDelays = null;
if (VersionHelper.isTestEnv) {
  const bryntum = globalThis.bryntum || (globalThis.bryntum = {});
  globalDelays = bryntum.globalDelays = {
    timeouts: /* @__PURE__ */ new Map(),
    intervals: /* @__PURE__ */ new Map(),
    animationFrames: /* @__PURE__ */ new Map(),
    idleCallbacks: /* @__PURE__ */ new Map(),
    isEmpty(includeIntervals = false) {
      return globalDelays.timeouts.size + globalDelays.animationFrames.size + globalDelays.idleCallbacks.size + (includeIntervals ? globalDelays.intervals.size : 0) === 0;
    },
    /**
     * Returns filtered delays array
     * @param {Object} options
     * @param {String[]} [options.ignoreTimeouts] array of delays names to ignore
     * @param {Number} [options.maxDelay] maximum delay in milliseconds. Timeouts with bigger delay will be filtered out
     * @param {Boolean} [options.includeIntervals] include intervals
     * @returns {Object[]} array of filtered delays
     * @internal
     */
    getFiltered({ ignoreTimeouts = [], maxDelay = 5e3, includeIntervals = false }) {
      const result = [], scopes = ["timeouts", "animationFrames", "idleCallbacks"];
      if (includeIntervals) {
        scopes.push("intervals");
      }
      for (const scope of scopes) {
        const map2 = globalDelays[scope];
        for (const [, entry] of map2.entries()) {
          if (!ignoreTimeouts.includes(entry.name) && (!Number.isInteger(entry.delay) || entry.delay < maxDelay)) {
            result.push(entry);
          }
        }
      }
      return result;
    }
  };
}
var makeInvoker = (me, fn2, wrapFn, options) => {
  const named = typeof fn2 === "string", appendArgs = (options == null ? void 0 : options.appendArgs) || [], invoker = () => {
    wrapFn.timerId = null;
    wrapFn.lastCallTime = performance2.now();
    const args = wrapFn.args;
    wrapFn.args = null;
    if (named) {
      me[fn2](...args, ...appendArgs);
    } else {
      fn2.call(me, ...args, ...appendArgs);
    }
    wrapFn.called = true;
    ++wrapFn.calls;
  };
  if (options) {
    me = options.thisObj || me;
  }
  wrapFn.lastCallTime = -9e9;
  wrapFn.calls = 0;
  wrapFn.invoker = invoker;
  invoker.wrapFn = wrapFn;
  return invoker;
};
var decorateWrapFn = (me, wrapFn, cancelFn = "clearTimeout") => {
  wrapFn.cancel = () => {
    if (wrapFn.isPending) {
      me[cancelFn](wrapFn.timerId);
      wrapFn.args = wrapFn.timerId = null;
    }
  };
  wrapFn.flush = () => {
    if (wrapFn.isPending) {
      me[cancelFn](wrapFn.timerId);
      wrapFn.timerId = null;
      wrapFn.invoker();
    }
  };
  wrapFn.now = (...args) => {
    wrapFn.cancel();
    wrapFn.args = args;
    wrapFn.invoker();
  };
  wrapFn.resume = (all) => {
    const n = wrapFn.suspended;
    wrapFn.suspended = all || n < 1 ? 0 : n - 1;
  };
  wrapFn.suspend = () => {
    ++wrapFn.suspended;
  };
  wrapFn.immediate = false;
  wrapFn.suspended = 0;
  wrapFn.timerId = null;
  defineProperty3(wrapFn, "isPending", {
    get() {
      return wrapFn.timerId !== null;
    }
  });
  return wrapFn;
};
var Delayable_default = (Target) => class Delayable extends (Target || Base) {
  static get $name() {
    return "Delayable";
  }
  static get declarable() {
    return [
      /**
       * This class property returns an object that specifies methods to wrap with configurable timer behaviors.
       *
       * It is used like so:
       * ```javascript
       *  class Foo extends Base.mixin(Delayable) {
       *      static get delayable() {
       *          return {
       *              expensiveMethod : 500
       *          };
       *      }
       *
       *      expensiveMethod() {
       *          this.things();
       *          this.moreThings();
       *          this.evenMoreThings();
       *      }
       *  }
       * ```
       * With the above in place, consider:
       * ```javascript
       *  let instance = new Foo();
       *
       *  instance.expensiveMethod();
       * ```
       * Instead of the above code immediately calling the `expensiveMethod()`, it will start a timer that will
       * invoke the method 500ms later. Because `expensiveMethod()` is an instance method, each instance of `Foo`
       * will have its own timer.
       *
       * NOTE: Only instance methods are currently supported (i.e., only non-`static` methods).
       *
       * #### Options
       * The value of each key configures how the method will be scheduled. If the value is a number, it is
       * promoted to a config object of `type='buffer'` as in the following:
       * ```javascript
       *  class Foo extends Base.mixin(Delayable) {
       *      static get delayable() {
       *          return {
       *              expensiveMethod : {
       *                  type  : 'buffer',
       *                  delay : 500
       *              }
       *          };
       *      }
       *  }
       * ```
       * The `type` property of the config object must be one of three values. Other options can be provided
       * depending on the `type`:
       *
       *  - `buffer`<br>
       *    Other options:
       *     - `delay` (Number) : The number of milliseconds to wait before calling the underlying method. A
       *       value of 0 is equivalent to setting `immediate: true`.
       *     - `immediate` (Boolean) : Set to `true` to call immediately (effectively disabling the buffer).
       *  - `raf` (short for "request animation frame")<br>
       *  - `idle` (short for "request idle callback") __Not available on Safari__ <br>
       *    Other options:
       *     - `cancelOutstanding` (Boolean) : Set to `true` to cancel any pending animation frame requests and
       *       schedule a new one on each call.
       *     - `immediate` (Boolean) : Set to `true` to call immediately.
       *  - `throttle`<br>
       *    Other options:
       *     - `delay` (Number) : The number of milliseconds to wait after each execution before another
       *       execution takes place. A value of 0 is equivalent to setting `immediate: true`.
       *     - `immediate` (Boolean) : Set to `true` to call immediately (effectively disabling the throttle).
       *
       * While `immediate: true` can be specified at the class level, it is more typical to set it on the
       * instance's method as described below.
       *
       * #### Delayable Method API
       * Delayable methods have a consistent API to manage their scheduling. This API is added to the methods
       * themselves.
       *
       * For example:
       * ```javascript
       *  let instance = new Foo();
       *
       *  instance.expensiveMethod();         // schedule a call in 500ms
       *  instance.expensiveMethod.isPending; // true
       *  instance.expensiveMethod.cancel();
       *  instance.expensiveMethod.flush();
       *  instance.expensiveMethod.now();
       *
       *  instance.expensiveMethod.delay = 10;
       *  instance.expensiveMethod();         // schedule a call in 10ms
       * ```
       *
       * ##### `isPending` (Boolean, readonly)
       * This boolean property will be `true` if a call has been scheduled, and false otherwise.
       *
       * ##### `cancel()`
       * Cancels a pending call if one has been scheduled. Otherwise this method does nothing.
       *
       * ##### `flush()`
       * Cancels the timer and causes the pending call to execute immediately. If there is no pending call, this
       * method does nothing.
       *
       * ##### `now()`
       * Cancels the timer (if one is pending) and executes the method immediately. If there is no pending call,
       * this method will still call the underlying method.
       *
       * @static
       * @member {Object<String,'raf'|Number|DelayableConfig>} delayable
       * @internal
       */
      "delayable"
    ];
  }
  doDestroy() {
    const me = this;
    super.doDestroy();
    if (me.timeoutIds) {
      me.timeoutIds.forEach((fn2, id) => {
        if (typeof fn2 === "function") {
          fn2();
        }
        clearTimeout(id);
        globalDelays == null ? void 0 : globalDelays.timeouts.delete(id);
      });
      me.timeoutIds = null;
    }
    if (me.timeoutMap) {
      me.timeoutMap.forEach((name, id) => clearTimeout(id));
      me.timeoutMap = null;
    }
    if (me.intervalIds) {
      me.intervalIds.forEach((id) => {
        clearInterval(id);
        globalDelays == null ? void 0 : globalDelays.intervals.delete(id);
      });
      me.intervalIds = null;
    }
    if (me.animationFrameIds) {
      me.animationFrameIds.forEach((id) => {
        cancelAnimationFrame(id);
        globalDelays == null ? void 0 : globalDelays.animationFrames.delete(id);
      });
      me.animationFrameIds = null;
    }
    if (me.idleCallbackIds) {
      me.idleCallbackIds.forEach((id) => {
        cancelIdleCallback(id);
        globalDelays == null ? void 0 : globalDelays.idleCallbacks.delete(id);
      });
      me.idleCallbackIds = null;
    }
  }
  /**
   * Check if a named timeout is active
   * @param name
   * @internal
   */
  hasTimeout(name) {
    var _a2;
    return Boolean((_a2 = this.timeoutMap) == null ? void 0 : _a2.has(name));
  }
  /**
   * Same as native setTimeout, but will be cleared automatically on destroy. If a propertyName is supplied it will
   * be used to store the timeout id.
   * @param {Object} timeoutSpec An object containing the details about that function, and the time delay.
   * @param {Function|String} timeoutSpec.fn The function to call, or name of function in this object to call. Used as the `name` parameter if a string.
   * @param {Number} timeoutSpec.delay The milliseconds to delay the call by.
   * @param {Object[]} timeoutSpec.args The arguments to pass.
   * @param {String} [timeoutSpec.name] The name under which to register the timer. Defaults to `fn.name`.
   * @param {Boolean} [timeoutSpec.runOnDestroy] Pass `true` if this function should be executed if the Delayable instance is destroyed while function is scheduled.
   * @param {Boolean} [timeoutSpec.cancelOutstanding] Pass `true` to cancel any outstanding invocation of the passed function.
   * @returns {Number}
   * @internal
   */
  setTimeout({ fn: fn2, delay: delay2, name, runOnDestroy, cancelOutstanding, args }) {
    if (arguments.length > 1 || typeof arguments[0] === "function") {
      [fn2, delay2, name, runOnDestroy] = arguments;
    }
    if (typeof fn2 === "string") {
      name = fn2;
    } else if (!name) {
      name = fn2.name || fn2;
    }
    if (cancelOutstanding) {
      this.clearTimeout(name);
    }
    const me = this, timeoutIds = me.timeoutIds || (me.timeoutIds = /* @__PURE__ */ new Map()), timeoutMap = me.timeoutMap || (me.timeoutMap = /* @__PURE__ */ new Map()), timeoutId = setTimeout(() => {
      if (typeof fn2 === "string") {
        fn2 = me[name];
      }
      timeoutIds == null ? void 0 : timeoutIds.delete(timeoutId);
      timeoutMap == null ? void 0 : timeoutMap.delete(name);
      globalDelays == null ? void 0 : globalDelays.timeouts.delete(timeoutId);
      fn2.apply(me, args);
    }, delay2);
    timeoutIds.set(timeoutId, runOnDestroy ? fn2 : true);
    globalDelays == null ? void 0 : globalDelays.timeouts.set(timeoutId, {
      fn: fn2,
      delay: delay2,
      name
      /*, stack : new Error().stack*/
    });
    if (name) {
      timeoutMap.set(name, timeoutId);
    }
    return timeoutId;
  }
  /**
   * clearTimeout wrapper, either call with timeout id as normal clearTimeout or with timeout name (if you specified
   * a name to setTimeout())
   * property to null.
   * @param {Number|String} idOrName timeout id or name
   * @internal
   */
  clearTimeout(idOrName) {
    var _a2;
    let id = idOrName;
    if (typeof id === "string") {
      if (this.timeoutMap) {
        id = this.timeoutMap.get(idOrName);
        this.timeoutMap.delete(idOrName);
      } else {
        return;
      }
    }
    clearTimeout(id);
    (_a2 = this.timeoutIds) == null ? void 0 : _a2.delete(id);
    globalDelays == null ? void 0 : globalDelays.timeouts.delete(id);
  }
  /**
   * clearInterval wrapper
   * @param {Number} id
   * @internal
   */
  clearInterval(id) {
    var _a2;
    clearInterval(id);
    (_a2 = this.intervalIds) == null ? void 0 : _a2.delete(id);
    globalDelays == null ? void 0 : globalDelays.intervals.delete(id);
  }
  /**
   * Same as native setInterval, but will be cleared automatically on destroy
   * @param {Function} fn callback method
   * @param {Number} delay delay in milliseconds
   * @param {String} name delay name for debugging
   * @returns {Number}
   * @internal
   */
  setInterval(fn2, delay2, name) {
    const intervalId = setInterval(fn2, delay2);
    (this.intervalIds || (this.intervalIds = /* @__PURE__ */ new Set())).add(intervalId);
    globalDelays == null ? void 0 : globalDelays.intervals.set(intervalId, { fn: fn2, delay: delay2, name });
    return intervalId;
  }
  /**
   * Relays to native requestAnimationFrame and adds to tracking to have call automatically canceled on destroy.
   * @param {Function} fn
   * @param {Object[]} [extraArgs] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @returns {Number}
   * @internal
   */
  requestAnimationFrame(fn2, extraArgs = [], thisObj = this) {
    const animationFrameIds = this.animationFrameIds || (this.animationFrameIds = /* @__PURE__ */ new Set()), frameId = requestAnimationFrame(() => {
      globalDelays == null ? void 0 : globalDelays.animationFrames.delete(frameId);
      animationFrameIds.delete(frameId) && fn2.apply(thisObj, extraArgs);
    });
    animationFrameIds.add(frameId);
    globalDelays == null ? void 0 : globalDelays.animationFrames.set(frameId, { fn: fn2, extraArgs, thisObj });
    return frameId;
  }
  /**
   * Relays to native requestIdleCallback and adds to tracking to have call automatically canceled on destroy.
   * @param {Function} fn
   * @param {Object[]} [extraArgs] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @returns {Number}
   * @internal
   */
  requestIdleCallback(fn2, extraArgs = [], thisObj = this) {
    const idleCallbackIds = this.idleCallbackIds || (this.idleCallbackIds = /* @__PURE__ */ new Set()), frameId = requestIdleCallback(() => {
      globalDelays == null ? void 0 : globalDelays.idleCallbacks.delete(frameId);
      idleCallbackIds.delete(frameId) && fn2.apply(thisObj, extraArgs);
    });
    idleCallbackIds.add(frameId);
    globalDelays == null ? void 0 : globalDelays.idleCallbacks.set(frameId, { fn: fn2, extraArgs, thisObj });
    return frameId;
  }
  /**
   * Creates a function which will execute once, on the next animation frame. However many time it is
   * called in one event run, it will only be scheduled to run once.
   * @param {Function|String} fn The function to call, or name of function in this object to call.
   * @param {Object[]} [args] The argument list to append to those passed to the function.
   * @param {Object} [thisObj] `this` reference for the function.
   * @param {Boolean} [cancelOutstanding] Cancel any outstanding queued invocation upon call.
   * @internal
   */
  createOnFrame(fn2, args = [], thisObj = this, cancelOutstanding) {
    let rafId;
    const result = (...callArgs) => {
      if (rafId != null && cancelOutstanding) {
        this.cancelAnimationFrame(rafId);
        rafId = null;
      }
      if (rafId == null) {
        rafId = this.requestAnimationFrame(() => {
          if (typeof fn2 === "string") {
            fn2 = thisObj[fn2];
          }
          rafId = null;
          callArgs.push(...args);
          fn2.apply(thisObj, callArgs);
        });
      }
    };
    result.cancel = () => this.cancelAnimationFrame(rafId);
    return result;
  }
  /**
   * Relays to native cancelAnimationFrame and removes from tracking.
   * @param {Number} handle
   * @internal
   */
  cancelAnimationFrame(handle) {
    var _a2;
    cancelAnimationFrame(handle);
    (_a2 = this.animationFrameIds) == null ? void 0 : _a2.delete(handle);
    globalDelays == null ? void 0 : globalDelays.animationFrames.delete(handle);
  }
  /**
   * Relays to native cancelIdleCallback and removes from tracking.
   * @param {Number} handle
   * @internal
   */
  cancelIdleCallback(handle) {
    var _a2;
    cancelIdleCallback(handle);
    (_a2 = this.idleCallbackIds) == null ? void 0 : _a2.delete(handle);
    globalDelays == null ? void 0 : globalDelays.idleCallbacks.delete(handle);
  }
  async nextAnimationFrame() {
    return new Promise((resolve) => this.requestAnimationFrame(resolve));
  }
  /**
   * Wraps a function with another function that delays it specified amount of time, repeated calls to the wrapper
   * resets delay.
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Object|Number} options The delay in milliseconds or an options object.
   * @param {Number} options.delay The delay in milliseconds.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Object} [options.thisObj] The `this` reference for the function.
   * @returns {Function} Wrapped function to call.
   * @internal
   */
  buffer(fn2, options) {
    let delay2 = options;
    if (options && typeof options !== "number") {
      delay2 = options.delay;
    } else {
      options = null;
    }
    const bufferWrapFn = (...params) => {
      if (bufferWrapFn.suspended) {
        return;
      }
      const { delay: delay3 } = bufferWrapFn;
      bufferWrapFn.cancel();
      bufferWrapFn.called = false;
      bufferWrapFn.args = params;
      if (bufferWrapFn.immediate || !delay3) {
        invoker();
      } else {
        bufferWrapFn.timerId = this.setTimeout(invoker, delay3);
      }
    }, invoker = makeInvoker(this, fn2, bufferWrapFn, options);
    bufferWrapFn.delay = delay2;
    return decorateWrapFn(this, bufferWrapFn);
  }
  /**
   * Returns a function that when called will schedule a call to `fn` on the next animation frame.
   *
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Boolean|Object} [options] An options object or the `cancelOutstanding` boolean property of it.
   * @param {Boolean} [options.cancelOutstanding] Pass `true` to cancel any pending animation frame requests and
   * schedule a new one on each call to the returned function.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Object} [options.thisObj] The `this` reference for the function.
   * @returns {Function}
   * @internal
   */
  raf(fn2, options) {
    let cancelOutstanding = options;
    if (options && typeof options !== "boolean") {
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const rafWrapFn = (...params) => {
      if (rafWrapFn.suspended) {
        return;
      }
      if (rafWrapFn.cancelOutstanding) {
        rafWrapFn.cancel();
      }
      rafWrapFn.called = false;
      rafWrapFn.args = params;
      if (rafWrapFn.immediate) {
        invoker();
      } else if (!rafWrapFn.isPending) {
        rafWrapFn.timerId = this.requestAnimationFrame(invoker);
      }
    }, invoker = makeInvoker(this, fn2, rafWrapFn, options);
    rafWrapFn.cancelOutstanding = cancelOutstanding;
    return decorateWrapFn(this, rafWrapFn, "cancelAnimationFrame");
  }
  idle(fn2, options) {
    let cancelOutstanding = options;
    if (options && typeof options !== "boolean") {
      cancelOutstanding = options.cancelOutstanding;
    } else {
      options = null;
    }
    const idleWrapFn = (...params) => {
      if (idleWrapFn.suspended) {
        return;
      }
      if (idleWrapFn.cancelOutstanding) {
        idleWrapFn.cancel();
      }
      idleWrapFn.called = false;
      idleWrapFn.args = params;
      if (idleWrapFn.immediate) {
        invoker();
      } else if (!idleWrapFn.isPending) {
        idleWrapFn.timerId = this.requestIdleCallback(invoker);
      }
    }, invoker = makeInvoker(this, fn2, idleWrapFn, options);
    idleWrapFn.cancelOutstanding = cancelOutstanding;
    this.setTimeout(() => this.idleCallbackIds.delete(idleWrapFn.timerId) && idleWrapFn.now(), 100);
    return decorateWrapFn(this, idleWrapFn, "cancelIdleCallback");
  }
  /**
   * Create a "debounced" function which will call on the "leading edge" of a timer period.
   * When first invoked will call immediately, but invocations after that inside its buffer
   * period will be rejected, and *one* invocation will be made after the buffer period has expired.
   *
   * This is useful for responding immediately to a first mousemove, but from then on, only
   * calling the action function on a regular timer while the mouse continues to move.
   *
   * @param {Function|String} fn The function to call. If this is a string, it is looked up as a method on `this`
   * instance (or `options.thisObj` instead, if provided).
   * @param {Number|Object} options The milliseconds to wait after each execution before another execution takes place
   * or a object containing options.
   * @param {Object} [options.thisObj] `this` reference for the function.
   * @param {Array} [options.appendArgs] The argument list to append to those passed to the function.
   * @param {Function|String} [options.throttled] A function to call when the invocation is delayed due to buffer
   * time not having expired. If this is a string, it is looked up as a method on `this` instance (or `options.thisObj`
   * instead, if provided). When called, the same arguments are passed as would have been passed to `fn`, including
   * any `options.appendArgs`.
   * @internal
   */
  throttle(fn2, options) {
    let delay2 = options, throttled;
    if (options && typeof options !== "number") {
      delay2 = options.delay;
      throttled = options.throttled;
    } else {
      options = null;
    }
    const me = this, throttleWrapFn = (...args) => {
      if (throttleWrapFn.suspended) {
        return;
      }
      const { delay: delay3 } = throttleWrapFn, elapsed = performance2.now() - throttleWrapFn.lastCallTime;
      throttleWrapFn.args = args;
      if (throttleWrapFn.immediate || elapsed >= delay3) {
        me.clearTimeout(throttleWrapFn.timerId);
        invoker();
      } else {
        if (!throttleWrapFn.isPending) {
          throttleWrapFn.timerId = me.setTimeout(invoker, delay3 - elapsed);
          throttleWrapFn.called = false;
        }
        if (throttled) {
          throttled.wrapFn.args = args;
          throttled();
        }
      }
    }, invoker = makeInvoker(me, fn2, throttleWrapFn, options);
    throttleWrapFn.delay = delay2;
    if (throttled) {
      throttled = makeInvoker(me, throttled, () => {
      }, options);
    }
    return decorateWrapFn(me, throttleWrapFn);
  }
  static setupDelayable(cls) {
    cls.setupDelayableMethods(cls.delayable);
  }
  /**
   * This method initializes the `delayable` methods on this class.
   * @param {Object} delayable The `delayable` property.
   * @param {Function} [cls] This parameter will be used internally to process static methods.
   * @private
   */
  static setupDelayableMethods(delayable, cls = null) {
    const me = this, statics = delayable.static, target = cls || me.prototype;
    if (statics) {
      delete delayable.static;
    }
    for (const name in delayable) {
      let options = delayable[name];
      const implName = name + "Now", type = typeof options;
      if (!target[implName]) {
        target[implName] = target[name];
      }
      if (type === "number") {
        options = {
          type: "buffer",
          delay: options
        };
      } else if (type === "string") {
        options = {
          type: options
        };
      }
      defineProperty3(target, name, {
        get() {
          const value = this[options.type]((...params) => {
            this[implName](...params);
          }, options);
          defineProperty3(this, name, { value });
          return value;
        }
      });
    }
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement thus.
  get widgetClass() {
  }
};

// ../Core/lib/Core/state/StateStorage.js
var StateStorage = class {
  /**
   * Returns an object with all stored keys and their values as its properties
   * @member {Object}
   */
  get data() {
    return /* @__PURE__ */ Object.create(null);
  }
  /**
   * Returns the stored keys as set by {@link #function-setItem}
   * @member {String[]}
   */
  get keys() {
    return [];
  }
  /**
   * Remove all stored keys
   */
  clear() {
  }
  /**
   * Returns key value as set by {@link #function-setItem}
   * @param {String} key
   * @returns {*}
   */
  getItem(key) {
    return null;
  }
  /**
   * Removes the specified key
   * @param {String} key
   */
  removeItem(key) {
  }
  /**
   * Sets the specified key to the given value
   * @param {String} key
   * @param {*} value The item value
   */
  setItem(key, value) {
  }
};
StateStorage._$name = "StateStorage";

// ../Core/lib/Core/state/StateProvider.js
var Local = class extends StateStorage {
  constructor(stateProvider) {
    super();
    this.prefix = stateProvider.prefix || "";
  }
  get isLocal() {
    return true;
  }
  get data() {
    const data = empty(), keys = this.keys;
    for (const key of keys) {
      data[key] = this.getItem(key);
    }
    return data;
  }
  get keys() {
    return getKeys(this.prefix, this.prefix.length);
  }
  clear() {
    const keys = getKeys(this.prefix);
    for (const key of keys) {
      localStorage.removeItem(key);
    }
  }
  getItem(key) {
    const value = localStorage.getItem(this.prefix + key);
    return value === null ? value : JSON.parse(value);
  }
  removeItem(key) {
    return localStorage.removeItem(this.prefix + key);
  }
  setItem(key, value) {
    return localStorage.setItem(this.prefix + key, JSON.stringify(value));
  }
};
var Memory = class extends StateStorage {
  constructor() {
    super();
    this.clear();
  }
  get isMemory() {
    return true;
  }
  get data() {
    return ObjectHelper.clone(this._data);
  }
  get keys() {
    return Object.keys(this._data);
  }
  clear() {
    this._data = empty();
  }
  getItem(key) {
    return key in this._data ? this._data[key] : null;
  }
  removeItem(key) {
    delete this._data[key];
  }
  setItem(key, value) {
    this._data[key] = value;
  }
};
var empty = () => /* @__PURE__ */ Object.create(null);
var getKeys = (prefix, pos = 0) => {
  const keys = [], count = localStorage.length;
  for (let key, i = 0; i < count; ++i) {
    key = localStorage.key(i);
    key.startsWith(prefix) && keys.push(key.slice(pos));
  }
  return keys;
};
var nullStorage = new StateStorage();
var storageTypes = {
  local: Local,
  memory: Memory
};
var StateProvider = class _StateProvider extends Base.mixin(Delayable_default, Events_default) {
  static get $name() {
    return "StateProvider";
  }
  static get configurable() {
    return {
      /**
       * The key prefix applied when using the `'local'` {@link #config-storage} type.
       * @config {String}
       * @default
       */
      prefix: "bryntum-state:",
      /**
       * Storage instance
       * @member {Core.state.StateStorage} storage
       */
      /**
       * One of the following storage types:
       *  - `local` : Stores data in the browser's `localStorage` using the {@link #config-prefix}.
       *  - `memory` : Stores data in the provider's memory.
       *
       * @config {'local'|'memory'|Core.state.StateStorage}
       * @default
       */
      storage: "local"
    };
  }
  static get delayable() {
    return {
      writeStatefuls: 50
    };
  }
  /**
   * The default {@link Core.mixin.State#config-stateProvider} for stateful objects.
   * @property {Core.state.StateProvider}
   */
  static get instance() {
    return this._instance;
  }
  static set instance(inst) {
    if (inst == null) {
      inst = nullProvider;
    } else {
      if (typeof inst === "string" || ObjectHelper.isClass(inst) || inst instanceof StateStorage) {
        inst = {
          storage: inst
        };
      }
      if (ObjectHelper.isObject(inst)) {
        inst = new _StateProvider(inst);
      }
    }
    this._instance = inst;
  }
  /**
   * Initializes the default `StateProvider` instance for the page. This method can be passed an instance or one of
   * the following type aliases:
   *
   *  - `'local'` : use `localStorage` to store application state (most common)
   *  - `'memory'` : holds application state in the `StateProvider` instance (used when state is saved to a server)
   *
   * Once the `StateProvider` is initialized, components that use {@link Core.mixin.State} and assign components a
   * {@link Core.mixin.State#config-stateId} will use this default provider to automatically save and restore their
   * state.
   *
   * @param {'local'|'memory'|Core.state.StateProvider} inst The state provider storage type ('local' or 'memory') or
   * the `StateProvider` instance.
   * @returns {Core.state.StateProvider}
   */
  static setup(inst) {
    this.instance = inst;
    return this.instance;
  }
  doDestroy() {
    self.writeStatefuls.flush();
    super.doDestroy();
  }
  /**
   * On read, this property returns all state data stored in the provider. On write, this property _adds_ all the
   * given values to the state provider's data. To replace the data, call {@link #function-clear} before assigning
   * this property. This is used to bulk populate this `StateProvider` with data for stateful components.
   * @member {Object}
   */
  get data() {
    return this.storage.data;
  }
  set data(data) {
    if (!data) {
      this.clear();
    } else {
      for (const key in data) {
        this.setValue(key, data[key]);
      }
    }
  }
  /**
   * Clears all state date
   * @returns {Core.state.StateProvider} this instance
   */
  clear() {
    this.storage.clear();
    return this;
  }
  changeStorage(storage) {
    if (storage == null) {
      storage = nullStorage;
    } else {
      if (typeof storage === "string") {
        if (!storageTypes[storage]) {
          throw new Error(`Invalid storage type "${storage}" (expected one of: "${Object.keys(storageTypes).join('", "')}")`);
        }
        storage = storageTypes[storage];
      }
      if (ObjectHelper.isClass(storage)) {
        storage = new storage(this);
      }
    }
    return storage;
  }
  /**
   * This method is called to schedule saving the given `stateful` object.
   * @param {Core.mixin.State} stateful The stateful object to save.
   * @param {Object} [options] An object of options that affect the state saving process.
   * @param {String} [options.id] The key for the saved state.
   * @param {Boolean} [options.immediate] Pass `true` to save the data synchronously instead of on a delay.
   * @internal
   */
  saveStateful(stateful, options) {
    (this.pendingSaves || (this.pendingSaves = [])).push([stateful, options]);
    this.writeStatefuls();
  }
  /**
   * A delayable method that flushes pending stateful objects.
   * @private
   */
  writeStatefuls() {
    const me = this, { pendingSaves } = me, n = pendingSaves == null ? void 0 : pendingSaves.length, stateIds = [], saved = [];
    me.pendingSaves = null;
    if (n) {
      for (let options, stateful, stateId, i = 0; i < n; ++i) {
        [stateful, options] = pendingSaves[i];
        if (!stateful.isDestroying && stateful.isSaveStatePending) {
          stateId = stateful.saveState({
            ...options,
            immediate: true
          });
          if (stateId) {
            stateIds.push(stateId);
            saved.push(stateful);
          }
        }
      }
      if (stateIds.length) {
        me.trigger("save", {
          stateIds,
          saved
        });
      }
    }
  }
  /**
   * Returns the stored state given its `key`.
   * @param {String} key The identifier of the state to return.
   * @returns {Object}
   */
  getValue(key) {
    this.writeStatefuls.flush();
    return this.storage.getItem(key);
  }
  /**
   * Stores the given state `value` under the specified `key`.
   * @param {String} key The identifier of the state value.
   * @param {Object} value The state value to set.
   * @returns {Core.state.StateProvider} this instance
   */
  setValue(key, value) {
    const me = this, { storage } = me, was = me.getValue(key);
    if (value != null) {
      storage.setItem(key, value);
      me.trigger("set", { key, value, was });
    } else if (was !== null) {
      storage.removeItem(key);
      me.trigger("remove", { key, was });
    }
    return me;
  }
};
var nullProvider = new StateProvider({
  storage: nullStorage
});
StateProvider._instance = nullProvider;
StateProvider._$name = "StateProvider";

// ../Core/lib/Core/mixin/State.js
var primitiveRe = /boolean|number|string/;
var State_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    afterConstruct() {
      super.afterConstruct();
      this.loadState();
    }
    finalizeInit() {
      this.loadState();
      super.finalizeInit();
    }
    /**
     * Returns `true` if this instance implements the {@link Core.mixin.State} interface.
     * @property {Boolean}
     * @readonly
     * @advanced
     */
    get isStateful() {
      return true;
    }
    /**
     * Returns `true` if this instance is ready to participate in state activities.
     * @property {Boolean}
     * @readonly
     * @internal
     */
    get isStatefulActive() {
      return !this.statefulSuspended && !this.isResponsivePending && !this.isResponsiveUpdating;
    }
    // state
    /**
     * Gets or sets a component's state
     * @property {Object}
     * @category State
     */
    get state() {
      return this._state = this.getState();
    }
    set state(state) {
      this._state = state;
      if (state) {
        this.applyState(state);
      }
    }
    // statefulEvents
    updateStatefulEvents(events) {
      var _a3;
      const me = this, listeners = {
        name: "statefulEvents",
        thisObj: me
      };
      me.detachListeners(listeners.name);
      if (events) {
        if (typeof events === "string") {
          events = StringHelper.split(events);
        } else if (!Array.isArray(events)) {
          events = ObjectHelper.getTruthyKeys(events);
        }
        if (events.length) {
          for (const event of events) {
            listeners[event] = "onStatefulEvent";
          }
          (_a3 = me.ion) == null ? void 0 : _a3.call(me, listeners);
        }
      }
    }
    // statefulId
    /**
     * Returns the state key to use for this instance. This will be either the {@link #config-stateId} or the
     * {@link Core.widget.Widget#config-id} (if explicitly specified and {@link #config-stateful} is not `false`).
     * @property {String}
     * @category State
     * @internal
     */
    get statefulId() {
      const me = this, { responsiveState } = me;
      let statefulId = me.stateId;
      if (statefulId == null && me.hasGeneratedId === false && me.stateful !== false) {
        statefulId = me.id;
      }
      if (statefulId && responsiveState) {
        statefulId = `${statefulId}[${responsiveState}]`;
      }
      return statefulId;
    }
    // statefulness
    /**
     * Returns an object whose truthy keys are the config properties to include in this object's {@link #property-state}.
     * @property {Object}
     * @category State
     * @readonly
     * @private
     */
    get statefulness() {
      const { stateful } = this;
      return Array.isArray(stateful) ? ObjectHelper.createTruthyKeys(stateful) : stateful;
    }
    // stateProvider
    get stateProvider() {
      return this._stateProvider || StateProvider.instance;
    }
    //---------------------------------------------------------------------------------------------------------------
    // Methods
    /**
     * Applies the given `state` to this instance.
     *
     * This method is not called directly, but is called when the {@link #property-state} property is assigned a value.
     *
     * This method is implemented by derived classes that have complex state which exceeds the simple list of config
     * properties provided by {@link #config-stateful}. In these cases, the `super` method can be called to handle any
     * config properties that are part of the complex state. The default implementation of this method will only assign
     * those config properties listed in {@link #config-stateful} from the provided `state` object.
     *
     * @param {Object} state The state object to apply to this instance.
     * @category State
     * @advanced
     */
    applyState(state) {
      state = this.pruneState(state);
      if (state) {
        this.setConfig(state);
      }
    }
    /**
     * Returns this object's state information.
     *
     * This method is not called directly, but is called to return the value of the {@link #property-state} property.
     *
     * This method is implemented by derived classes that have complex state which exceeds the simple list of config
     * properties provided by {@link #config-stateful}. In these cases, the `super` method can be called to gather the
     * config properties that are part of the complex state. The default implementation of this method will only copy
     * those config properties listed in {@link #config-stateful} to the returned `state` object.
     *
     * @returns {Object}
     * @category State
     * @advanced
     */
    getState() {
      const me = this, {
        initialConfig,
        statefulness,
        isConstructing: defaultState
      } = me, { configs } = me.$meta, source = defaultState ? Object.setPrototypeOf(initialConfig, me.$meta.config) : me;
      let state = null, key, value;
      if (statefulness) {
        state = {};
        for (key in statefulness) {
          if (statefulness[key]) {
            value = source[key];
            if (value == null ? void 0 : value.isStateful) {
              value = value.state;
            } else if (!defaultState) {
              if (ObjectHelper.isDate(value)) {
                value = DateHelper.format(value, "YYYY-MM-DDTHH:mm:ssZ");
              }
              if (configs[key].equal(value, initialConfig == null ? void 0 : initialConfig[key]) || !primitiveRe.test(typeof value)) {
                continue;
              }
            }
            state[key] = value;
          }
        }
      }
      return state;
    }
    /**
     * Loads this object's state from its {@link #config-stateProvider} and applies it to its {@link #property-state}.
     *
     * This method only acts upon its first invocation for a given instance (unless `true` is passed for the `reload`
     * parameter). This allows for flexibility in the timing of that call during the early stages of the instances'
     * lifecycle. To reload the state after this time, manually assign the desired value to the {@link #property-state}
     * property or call this method and pass `reload` as `true`.
     *
     * This method is called automatically during construction when a {@link #config-stateId} or (in some cases) an
     * explicit {@link Core.widget.Widget#config-id} is provided.
     *
     * @param {String} [stateId] An overriding key to use instead of this object's {@link #config-stateId}.
     * @param {Boolean} [reload=false] Pass `true` to load the state even if previously loaded.
     * @category State
     */
    loadState(stateId, reload) {
      if (typeof stateId === "boolean") {
        reload = stateId;
        stateId = null;
      }
      const me = this, { statefulLoaded } = me;
      if (me.isStatefulActive && (reload || !statefulLoaded)) {
        const state = me.loadStatefulData(stateId || (stateId = me.statefulId));
        if (!statefulLoaded && stateId) {
          me.defaultState = me.state;
          me.statefulLoaded = true;
        }
        if (state) {
          me.state = state;
        }
      }
    }
    loadStatefulData(stateId) {
      var _a3;
      stateId = this.isStatefulActive ? stateId || this.statefulId : null;
      return stateId && ((_a3 = this.stateProvider) == null ? void 0 : _a3.getValue(stateId));
    }
    resetDefaultState() {
      if (this.defaultState) {
        this.state = this.defaultState;
      }
    }
    resumeStateful(full = false) {
      this.statefulSuspended = full ? 0 : Math.max(this.statefulSuspended - 1, 0);
    }
    /**
     * Saves this object's state to its {@link #config-stateProvider}.
     *
     * When a {@link #config-stateId} or (in some cases) an explicit {@link Core.widget.Widget#config-id} is provided,
     * this method will be called automatically any time a config property listed in {@link #config-stateful} changes or
     * when a {@link #config-statefulEvents stateful event} is fired.
     *
     * Derived classes are responsible for calling this method whenever the persistent {@link #property-state} of the
     * object changes.
     *
     * @param {Object|String} [options] Options that affect the state saving process or, if a string, the state `id`.
     * @param {String} [options.id] The state id for the saved state (overrides {@link #config-stateId}).
     * @param {Boolean} [options.immediate] Pass `true` to save the data synchronously instead of on a delay.
     * @category State
     */
    saveState(options) {
      if (typeof options === "string") {
        options = {
          id: options
        };
      } else {
        options = options || {};
      }
      const me = this, { stateProvider } = me, statefulId = options.id || me.isStatefulActive && me.statefulId;
      if (statefulId && stateProvider) {
        if (options.immediate) {
          me.isSaveStatePending = false;
          stateProvider.setValue(statefulId, me.state);
        } else if (!me.isSaveStatePending) {
          me.isSaveStatePending = true;
          stateProvider.saveStateful(me, options);
        }
        return statefulId;
      }
    }
    suspendStateful() {
      ++this.statefulSuspended;
    }
    //---------------------------------------------------------------------------------------------------------------
    // Private / Internal
    onConfigChange({ name, value, was, config }) {
      super.onConfigChange({ name, value, was, config });
      if (!this.isConstructing && this.isStatefulActive && this.statefulId) {
        const { stateful } = this;
        if (Array.isArray(stateful) ? stateful.includes(name) : stateful == null ? void 0 : stateful[name]) {
          this.saveState();
        }
      }
    }
    onStatefulEvent() {
      if (!this.isConstructing) {
        this.saveState();
      }
    }
    /**
     * Returns an object that copies the {@link #config-stateful} config properties from the provided `state` object.
     *
     * @param {Object} state A state object from which to copy stateful configs.
     * @returns {Object}
     * @category State
     * @private
     */
    pruneState(state) {
      const { statefulness } = this;
      if (statefulness) {
        const pruned = {};
        for (const key in state) {
          if (statefulness[key]) {
            pruned[key] = state[key];
          }
        }
        state = pruned;
      }
      return state;
    }
    //---------------------------------------------------------------------------------------------------------------
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {
    }
  }, __publicField(_a2, "$name", "State"), __publicField(_a2, "configurable", {
    /**
     * This value can be one of the following:
     *
     * - `false` to not use an explicitly assigned {@link Core.widget.Widget#config-id} as the component's
     * {@link #config-stateId} (this is only necessary when there is a {@link #config-stateProvider}).
     * - An array of strings naming the config properties to save in the component's {@link #property-state}
     * object.
     * - An object whose truthy keys are the config properties to save in the component's {@link #property-state}
     * object.
     *
     * These last two uses of the `stateful` config property do not apply to components that have a complex
     * state, as described in the {@link Core.mixin.State State mixin documentation}.
     *
     * This config property is typically set by derived classes to a value including any config property that
     * the user can affect via the user interface. For example, the {@link Core.widget.Panel#config-collapsed}
     * config property is listed for a {@link Core.widget.Panel} since the user can toggle this config property
     * using the {@link Core.widget.panel.PanelCollapser#config-tool collapse tool}.
     *
     * @config {Boolean|Object|String[]}
     * @category State
     */
    stateful: {
      value: null,
      $config: {
        merge: "classList"
      }
    },
    /**
     * The events that, when fired by this component, should trigger it to save its state by calling
     * {@link #function-saveState}.
     *
     * ```javascript
     *  class MyStatefulComponent extends Base.mixin(State) {
     *      static get configurable() {
     *          return {
     *              statefulEvents : [ 'change', 'resize' ]
     *          };
     *      }
     *  }
     * ```
     * In the above example, {@link #function-saveState} will be called any time an instance of this class
     * fires the `change` or `resize` event.
     *
     * This config is typically set by derived classes as a way to ensure {@link #function-saveState} is called
     * whenever their persistent state changes.
     *
     * @config {Object|String[]}
     * @category State
     * @default
     */
    statefulEvents: {
      $config: {
        merge: "classList"
      },
      value: ["stateChange"]
    },
    /**
     * The key to use when saving this object's state in the {@link #config-stateProvider}. If this config is
     * not assigned, and {@link #config-stateful} is not set to `false`, the {@link Core.widget.Widget#config-id}
     * (if explicitly specified) will be used as the `stateId`.
     *
     * If neither of these is given, the {@link #function-loadState} and {@link #function-saveState} methods
     * will need to be called directly to make use of the `stateProvider`.
     *
     * For single page applications (SPA's), or multi-page applications (MPA's) that have common, stateful
     * components on multiple pages, the `stateId` should be unique across all stateful components (similar to DOM
     * element id's). MPA's that want each page to be isolated can more easily achieve that isolation using the
     * {@link Core.state.StateProvider#config-prefix}.
     *
     * @config {String}
     * @category State
     */
    stateId: null,
    /**
     * The `StateProvider` to use to save and restore this object's {@link #property-state}. By default, `state`
     * will be saved using the {@link Core.state.StateProvider#property-instance-static default state provider}.
     *
     * This config is useful for multi-page applications that have a set of common components that want to share
     * state across pages, as well as other components that want their state to be isolated. One of these groups
     * of stateful components could be assigned an explicit `stateProvider` while the other group could use the
     * default state provider.
     *
     * @config {Core.state.StateProvider}
     * @category State
     */
    stateProvider: null
  }), __publicField(_a2, "prototypeProperties", {
    statefulLoaded: false,
    statefulSuspended: 0
  }), _a2;
};

// ../Core/lib/Core/mixin/Identifiable.js
var idCounts = ObjectHelper.getPathDefault(globalThis, "bryntum.idCounts", /* @__PURE__ */ Object.create(null));
var idTypes = {
  string: 1,
  number: 1
};
var Identifiable_default = (Target) => class Identifiable extends (Target || Base) {
  static get $name() {
    return "Identifiable";
  }
  static get declarable() {
    return [
      "identifiable"
    ];
  }
  static get configurable() {
    return {
      /**
       * The id of this object.  If not specified one will be generated. Also used for lookups through the
       * static `getById` of the class which mixes this in. An example being {@link Core.widget.Widget}.
       *
       * For a {@link Core.widget.Widget Widget}, this is assigned as the `id` of the DOM
       * {@link Core.widget.Widget#config-element element} and must be unique across all elements
       * in the page's `document`.
       * @config {String}
       * @category Common
       */
      id: ""
    };
  }
  static setupIdentifiable(cls, meta) {
    const { identifiable } = cls;
    identifiable.idMap = /* @__PURE__ */ Object.create(null);
    Reflect.defineProperty(cls, "identifiable", {
      get() {
        return identifiable;
      }
    });
  }
  doDestroy() {
    this.constructor.unregisterInstance(this);
    super.doDestroy();
  }
  changeId(id) {
    return (this.hasGeneratedId = !id) ? this.generateAutoId() : id;
  }
  updateId(id, oldId) {
    const me = this, C = me.constructor;
    oldId && C.unregisterInstance(me, oldId);
    if (!me.hasGeneratedId || C.identifiable.registerGeneratedId !== false) {
      C.registerInstance(me, id);
    }
  }
  /**
   * This method generates an id for this instance.
   * @returns {String}
   * @internal
   */
  generateAutoId() {
    return this.constructor.generateId(`b-${this.$$name.toLowerCase()}-`);
  }
  static get all() {
    return Object.values(this.identifiable.idMap);
  }
  /**
   * Generate a new id, using an internal counter and a prefix.
   * @param {String} prefix Id prefix
   * @returns {String} Generated id
   */
  static generateId(prefix = "generatedId") {
    return prefix + (idCounts[prefix] = (idCounts[prefix] || 0) + 1);
  }
  static registerInstance(instance, instanceId = instance.id) {
    const { idMap } = this.identifiable;
    if (instanceId in idMap && !this.disableThrow) {
      throw new Error("Id " + instanceId + " already in use");
    }
    idMap[instanceId] = instance;
  }
  /**
   * Unregister Identifiable instance, normally done on destruction
   * @param {Object} instance Object to unregister
   * @param {String} id The id of the instance to unregister.
   */
  static unregisterInstance(instance, id = instance.id) {
    const { idMap } = this.identifiable;
    if (idTypes[typeof instance]) {
      delete idMap[instance];
    } else if (idMap[id] === instance) {
      delete idMap[id];
    }
  }
  static getById(id) {
    const idMap = this.identifiable.idMap;
    if (idMap) {
      return idMap[id];
    }
  }
  static get registeredInstances() {
    const idMap = this.identifiable.idMap;
    return idMap ? Object.values(idMap) : [];
  }
};

// ../Core/lib/Core/data/stm/mixin/ModelStm.js
var STM_PROP = Symbol("STM_PROP");
var unrecordedFields = {
  // This field's value is a by product of node insertion and must not be recorded here.
  // It's the node insertion operation which is recorded by STM.
  parentIndex: 1
};
var ModelStm_default = (Target) => class ModelStm extends (Target || Base) {
  static get $name() {
    return "ModelStm";
  }
  static get defaultConfig() {
    return {
      stm: null
    };
  }
  joinStore(store) {
    if (!this.stm) {
      this.stm = store.stm;
    }
  }
  unjoinStore(store, isReplacing = false) {
    var _a2;
    if (this.stm === store.stm) {
      this.stm = null;
    }
    (_a2 = super.unjoinStore) == null ? void 0 : _a2.call(this, store, isReplacing);
  }
  /**
   * Reference to STM manager, if used
   * @member {Core.data.stm.StateTrackingManager}
   * @category Misc
   */
  get stm() {
    return this[STM_PROP];
  }
  set stm(stm) {
    this[STM_PROP] = stm;
  }
  // Hook for chronograph entity field accessors, for example; task.duration = 123.
  // Triggers before setting the value.
  beforeChronoFieldSet(fieldName, value) {
    var _a2;
    const me = this;
    if (!me.inSetting && ((_a2 = me.stm) == null ? void 0 : _a2.enabled) && !unrecordedFields[fieldName] && !me.constructor.nonPersistableFields[fieldName]) {
      if (me.getFieldDefinition(fieldName)) {
        return { [fieldName]: { value, oldValue: me[fieldName] } };
      }
    }
    return null;
  }
  // Hook for chronograph entity field accessors, for example; task.duration = 123
  // Triggers after setting the value.
  afterChronoFieldSet(fieldName, value, wasSet) {
    wasSet && this.afterSet(fieldName, value, false, false, wasSet, true);
  }
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    const store = this.firstStore;
    return !(this.constructor.nonPersistableFields[fieldName] || oldValue == null && newValue == null || oldValue === newValue || oldValue instanceof Date && newValue instanceof Date && oldValue.getTime() === newValue.getTime() || fieldName === "id" || fieldName === "$PhantomId" || fieldName === "parentId" && store && store.oldIdMap[oldValue] === store.getById(newValue));
  }
  /**
   * Overridden to store initial data of the changed fields and to notify STM
   * manager about the change action if anything has been changed in result.
   *
   * The method is called from within {@link Core/data/Model#function-set} method.
   *
   * @private
   */
  afterSet(field, value, silent, fromRelationUpdate, wasSet, isChronoFieldSet) {
    const { stm } = this, nonPersistableFields = this.constructor.nonPersistableFields;
    if ((stm == null ? void 0 : stm.isBase) && stm.enabled && !unrecordedFields[field] && !nonPersistableFields[field]) {
      if (wasSet) {
        let shouldRecord;
        const [newData, oldData] = Object.keys(wasSet).reduce(
          (data, fieldName) => {
            const { value: value2, oldValue } = wasSet[fieldName];
            if (this.shouldRecordFieldChange(fieldName, oldValue, value2)) {
              shouldRecord = true;
              data[0][fieldName] = value2;
              data[1][fieldName] = oldValue;
            }
            return data;
          },
          [{}, {}]
        );
        if (shouldRecord) {
          stm.onModelUpdate(this, newData, oldData, isChronoFieldSet);
        }
      }
    }
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to obtain inserted
   * records initial parents and parent index, to be able to restore the state back upon undo.
   *
   * @param {Core.data.Model[]} childRecords
   * @returns {Array} Array of results from this call and any of super calls if any.
   *               This result is consumed by {@link #function-afterInsertChild} which pops
   *               from the result array to take only results of this method call and leave
   *               results from super calls untouched.
   *
   * @private
   */
  beforeInsertChild(childRecords) {
    var _a2;
    const preResult = ((_a2 = super.beforeInsertChild) == null ? void 0 : _a2.call(this, childRecords)) || [], { stm } = this;
    if (stm == null ? void 0 : stm.enabled) {
      preResult.push(
        childRecords.reduce((result, childRecord) => {
          if (childRecord.root === this.root) {
            result.set(childRecord, {
              parent: childRecord.parent,
              index: childRecord.parent ? childRecord.parentIndex : void 0
            });
          }
          return result;
        }, /* @__PURE__ */ new Map())
      );
    }
    return preResult;
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-insertChild} to notify {@link Core/data/stm/StateTrackingManager}
   * about children insertion. Provides it with all necessary context information collected
   * in {@link #function-beforeInsertChild} required to undo/redo the action.
   *
   * @private
   */
  afterInsertChild(index, childRecords, beforeResult, inserted) {
    var _a2;
    const { stm } = this;
    if (stm == null ? void 0 : stm.enabled) {
      const context = beforeResult.pop();
      if (inserted) {
        stm.onModelInsertChild(this, index, inserted, context);
      }
    }
    (_a2 = super.afterInsertChild) == null ? void 0 : _a2.call(this, index, childRecords, beforeResult, inserted);
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to obtain removed
   * records initial parent index, to be able to restore the state back upon undo.
   *
   * @param {Core.data.Model[]} childRecords
   * @param {Boolean} isMove
   * @returns {Array} Array of results from this call and any of super calls if any.
   *               This result is consumed by {@link #function-afterRemoveChild} which pops
   *               from the result array to take only results of this method call and leave
   *               results from super calls untouched.
   *
   * @private
   */
  beforeRemoveChild(childRecords, isMove) {
    const preResult = super.beforeRemoveChild ? super.beforeRemoveChild(childRecords, isMove) : [], { stm } = this;
    if ((stm == null ? void 0 : stm.enabled) && !isMove) {
      preResult.push(
        childRecords.reduce((result, childRecord) => {
          result.set(childRecord, { parentIndex: childRecord.parentIndex, orderedParentIndex: childRecord.orderedParentIndex });
          return result;
        }, /* @__PURE__ */ new Map())
      );
    }
    return preResult;
  }
  /**
   * Called from {@link Core/data/mixin/TreeNode#function-removeChild} to notify {@link Core/data/stm/StateTrackingManager}
   * about children removing. Provides it with all necessary context information collected
   * in {@link #function-beforeRemoveChild} required to undo/redo the action.
   *
   * @private
   */
  afterRemoveChild(childRecords, beforeResult, isMove) {
    var _a2;
    const { stm } = this;
    if ((stm == null ? void 0 : stm.enabled) && !isMove) {
      const context = beforeResult.pop();
      if (childRecords && childRecords.length) {
        stm.onModelRemoveChild(this, childRecords, context);
      }
    }
    (_a2 = super.afterRemoveChild) == null ? void 0 : _a2.call(this, childRecords, beforeResult, isMove);
  }
};

// ../Core/lib/Core/data/mixin/TreeNode.js
var defaultTraverseOptions = {
  includeFilteredOutRecords: false
};
var fixTraverseOptions = (options) => {
  options = options || false;
  if (typeof options === "boolean") {
    options = {
      includeFilteredOutRecords: options
    };
  }
  return options || defaultTraverseOptions;
};
var TreeNode_default = (Target) => class TreeNode extends (Target || Base) {
  static get $name() {
    return "TreeNode";
  }
  /**
   * This static configuration option allows you to control whether an empty parent task should be converted into a
   * leaf. Enable/disable it for a whole class:
   *
   * ```javascript
   * Model.convertEmptyParentToLeaf = false;
   * ```
   *
   * By specifying `true`, all empty parents will be considered leafs. Can also be assigned a configuration object
   * with the following Boolean properties to customize the behaviour:
   *
   * ```javascript
   * Model.convertEmptyParentToLeaf = {
   *     onLoad   : false,
   *     onRemove : true
   * }
   * ```
   *
   * @member {Boolean|{ onLoad : Boolean, onRemove : Boolean }} convertEmptyParentToLeaf
   * @property {Boolean} onLoad Apply the transformation on load to any parents without children (`children : []`)
   * @property {Boolean} onRemove Apply the transformation when all children have been removed from a parent
   * @default false
   * @static
   * @category Parent & children
   * */
  static set convertEmptyParentToLeaf(value) {
    if (value === true) {
      value = {
        onLoad: true,
        onRemove: true
      };
    } else if (value === false) {
      value = {
        onLoad: false,
        onRemove: false
      };
    }
    this._convertEmptyParentToLeaf = value;
  }
  constructor(...args) {
    super(...args);
    if (this.children) {
      this.orderedChildren = this.orderedChildren || [];
    }
  }
  static get convertEmptyParentToLeaf() {
    return this._convertEmptyParentToLeaf || { onLoad: false, onRemove: false };
  }
  /**
   * This is a read-only property providing access to the parent node.
   * @member {Core.data.Model} parent
   * @readonly
   * @category Parent & children
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which record id is the parent of the record.
   * @readonly
   * @field {String|Number|null} parentId
   * @category Tree
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which position the node takes in the parent's children array.
   * This index is set on load and gets updated automatically after row reordering, sorting, etc.
   * To save the order, need to persist the field on the server and when data is fetched to be loaded,
   * need to sort by this field.
   * @readonly
   * @field {Number} parentIndex
   * @category Tree
   */
  /**
   * This is a read-only field provided in server synchronization packets to specify
   * which position the node takes in the parent's ordered children array.
   * This index is set on load and gets updated on reordering nodes in tree. Sorting and filtering
   * have no effect on it.
   * @readonly
   * @field {Number} orderedParentIndex
   * @category Tree
   */
  ingestChildren(childRecord, stores = this.stores) {
    const { inProcessChildren, constructor: MyClass } = this, store = stores[0];
    if (childRecord === true) {
      if (inProcessChildren) {
        return true;
      }
      return [];
    }
    if (childRecord) {
      childRecord = ArrayHelper.asArray(childRecord);
      const len = childRecord.length, result = [];
      for (let i = 0, child; i < len; i++) {
        child = childRecord[i];
        child = child.isModel ? child : store ? store.createRecord(child, false, true) : new MyClass(child, null, null, true);
        child = store ? store.processRecord(child) : child;
        result.push(child);
      }
      if (this.children === true && store) {
        const sorter = store.createSorterFn(store.sorters);
        result.sort(sorter);
      }
      return result;
    }
  }
  /**
   * Child nodes. To allow loading children on demand, specify `children : true` in your data. Omit the field for leaf
   * tasks.
   *
   * Note, if the tree store loads data from a remote origin, make sure {@link Core/data/AjaxStore#config-readUrl}
   * is specified, and optionally {@link Core/data/AjaxStore#config-parentIdParamName} is set, otherwise
   * {@link Core/data/Store#function-loadChildren} has to be implemented.
   * @field {Boolean|Object[]|Core.data.Model[]} children
   * @readonly
   * @category Parent & children
   */
  /**
   * Array of tree nodes without any filter applied. On first filter, will take order from sorted `children`, but
   * is not thereafter kept in sorted order, so order should not be relied upon.
   * @member {Core.data.Model[]|null} unfilteredChildren
   * @category Parent & children
   * @private
   */
  /**
   * Array of children unaffected by sorting and filtering, keeps original tree structure
   * @member {Core.data.Model[]|null} orderedChildren
   * @category Parent & children
   * @private
   */
  /**
   * Called during creation to also turn any children into Models joined to the same stores as this model
   * @internal
   * @category Parent & children
   */
  processChildren(stores = this.stores) {
    const me = this, { meta } = me;
    me.inProcessChildren = true;
    const children = me.ingestChildren(me.data[me.constructor.childrenField], stores);
    if (children) {
      const { convertEmptyParentToLeaf } = me.constructor, shouldConvert = convertEmptyParentToLeaf === true || convertEmptyParentToLeaf.onLoad;
      if (shouldConvert ? children.length : Array.isArray(children)) {
        meta.isLeaf = false;
        if (me.children === true) {
          me.children = [];
        } else if (children.length === 0) {
          me.children = children;
          return;
        }
        me.insertChild(children);
      } else if (children === true) {
        meta.isLeaf = false;
        me.children = true;
      } else if (!me.isRoot) {
        meta.isLeaf = me.constructor.convertEmptyParentToLeaf.onLoad;
      }
    }
    me.inProcessChildren = false;
  }
  /**
   * This method returns `true` if this record has all expanded ancestors and is therefore
   * eligible for inclusion in a UI.
   * @param {Core.data.Store} [store] Optional store, defaults to nodes first store
   * @returns {Boolean}
   * @readonly
   * @category Parent & children
   * @returns {Boolean}
   */
  ancestorsExpanded(store = this.firstStore) {
    const { parent } = this;
    return !parent || parent.isExpanded(store) && parent.ancestorsExpanded(store);
  }
  /**
   * Used by stores to assess the record's collapsed/expanded state in that store.
   * @param {Core.data.Store} store
   * @category Parent & children
   * @returns {Boolean}
   */
  isExpanded(store = this.firstStore) {
    const mapMeta = this.instanceMeta(store.id);
    if (!Object.prototype.hasOwnProperty.call(mapMeta, "collapsed")) {
      mapMeta.collapsed = !this.expanded;
    }
    return !mapMeta.collapsed;
  }
  // A read-only property. It provides the initial state upon load
  // The UI's expanded/collapsed state is in the store's meta map.
  get expanded() {
    return this.data.expanded;
  }
  /**
   * Depth in the tree at which this node exists. First visual level of nodes are at level 0, their direct children at
   * level 1 and so on.
   * @property {Number}
   * @readonly
   * @category Parent & children
   */
  get childLevel() {
    let node = this, ret = -1;
    while (node && !node.isRoot) {
      ++ret;
      node = node.parent;
    }
    return ret;
  }
  /**
   * Is a leaf node in a tree structure?
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isLeaf() {
    return this.meta.isLeaf !== false && !this.isRoot;
  }
  /**
   * Returns `true` if this node is the root of the tree
   * @member {Boolean} isRoot
   * @readonly
   * @category Parent & children
   */
  /**
   * Is a parent node in a tree structure?
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isParent() {
    return !this.isLeaf;
  }
  /**
   * Returns true for parent nodes with children loaded (there might still be no children)
   * @property {Boolean}
   * @readonly
   * @category Parent & children
   */
  get isLoaded() {
    return this.isParent && Array.isArray(this.children);
  }
  /**
   * Count all children (including sub-children) for a node (in its `firstStore)
   * @member {Number}
   * @category Parent & children
   */
  get descendantCount() {
    return this.getDescendantCount();
  }
  /**
   * Count visible (expanded) children (including sub-children) for a node (in its `firstStore`)
   * @member {Number}
   * @category Parent & children
   */
  get visibleDescendantCount() {
    return this.getDescendantCount(true);
  }
  /**
   * Count visible (expanded)/all children for this node, optionally specifying for which store.
   * @param {Boolean} [onlyVisible] Specify `true` to only count visible (expanded) children.
   * @param {Core.data.Store} [store] A Store to which this node belongs
   * @returns {Number}
   * @category Parent & children
   */
  getDescendantCount(onlyVisible = false, store = this.firstStore) {
    const { children } = this;
    if (!children || !Array.isArray(children) || onlyVisible && !this.isExpanded(store)) {
      return 0;
    }
    return children.reduce((count, child) => count + child.getDescendantCount(onlyVisible), children.length);
  }
  /**
   * Retrieve all children, not including filtered out nodes (by traversing sub nodes)
   * @property {Core.data.Model[]}
   * @category Parent & children
   */
  get allChildren() {
    return this.getAllChildren(false);
  }
  /**
   * Retrieve all children, including filtered out nodes (by traversing sub nodes)
   * @property {Core.data.Model[]}
   * @private
   * @category Parent & children
   */
  get allUnfilteredChildren() {
    return this.getAllChildren(true);
  }
  getAllChildren(unfiltered = false) {
    const { [unfiltered ? "unfilteredChildren" : "children"]: children } = this;
    if (!children || children === true) {
      return [];
    }
    return children.reduce((all, child) => {
      all.push(child);
      all.push.apply(all, unfiltered ? child.allUnfilteredChildren : child.allChildren);
      return all;
    }, []);
  }
  /**
   * Get the first child of this node
   * @property {Core.data.Model}
   * @readonly
   * @category Parent & children
   */
  get firstChild() {
    const { children } = this;
    return (children == null ? void 0 : children.length) && children[0] || null;
  }
  /**
   * Get the last child of this node
   * @property {Core.data.Model}
   * @readonly
   * @category Parent & children
   */
  get lastChild() {
    const { children } = this;
    return (children == null ? void 0 : children.length) && children[children.length - 1] || null;
  }
  /**
   * Get the previous sibling of this node
   * @member {Core.data.Model} previousSibling
   * @readonly
   * @category Parent & children
   */
  /**
   * Get the next sibling of this node
   * @member {Core.data.Model} nextSibling
   * @readonly
   * @category Parent & children
   */
  /**
   * Returns count of all preceding sibling nodes (including their children).
   * @property {Number}
   * @category Parent & children
   */
  get previousSiblingsTotalCount() {
    let task = this.previousSibling, count = this.parentIndex;
    while (task) {
      count += task.descendantCount;
      task = task.previousSibling;
    }
    return count;
  }
  // This pair of accessors should never return undefined. This is required by `add task below` logic, which is trying
  // to get a task from the ordered tree, before which insert should happen. In the `addToChildren` logic there is a
  // distinction between `null` and `undefined`. `undefined` falls back to reference task in a visual tree, `null`
  // is meant to point out we should insert to the end of the ordered children list. This is really required for
  // `nextOrderedSibling`, another accessor is modified to keep behavior consistent.
  // https://github.com/bryntum/support/issues/7323
  get previousOrderedSibling() {
    var _a2, _b;
    return (_b = (_a2 = this.parent) == null ? void 0 : _a2.orderedChildren[this.orderedParentIndex - 1]) != null ? _b : null;
  }
  get nextOrderedSibling() {
    var _a2, _b;
    return (_b = (_a2 = this.parent) == null ? void 0 : _a2.orderedChildren[this.orderedParentIndex + 1]) != null ? _b : null;
  }
  get root() {
    var _a2;
    return ((_a2 = this.parent) == null ? void 0 : _a2.root) || this;
  }
  /**
   * Reading this property returns the id of the parent node, if this record is a child of a node.
   *
   * Setting this property appends this record to the record with the passed id **in the same store that this record
   * is already in**.
   *
   * Note that setting this property is **only valid if this record is already part of a tree store**.
   *
   * This is not intended for general use. This is for when a server responds to a record mutation and the server
   * decides to move a record to a new parent. If a `parentId` property is passed in the response data for a record,
   * that record will be moved.
   *
   * @property {Number|String|null}
   * @category Parent & children
   */
  get parentId() {
    return this.parent && !this.parent.isAutoRoot ? this.parent.id : null;
  }
  set parentId(parentId) {
    const me = this, { parent } = me, newParent = parentId === null ? me.firstStore.rootNode : me.firstStore.getById(parentId);
    if (!(newParent === parent || !parent && !newParent)) {
      if (me.isBatchUpdating) {
        me.meta.batchChanges.parentId = parentId;
      } else {
        if (newParent) {
          newParent.appendChild(me);
        } else {
          me.parent.removeChild(me);
        }
      }
    }
  }
  static set parentIdField(parentIdField) {
    this._parentIdField = parentIdField;
    Object.defineProperty(this.prototype, parentIdField, {
      set: function(parentId) {
        this.parentId = parentId;
      },
      get: function() {
        return this.parentId;
      }
    });
  }
  static get parentIdField() {
    return this._parentIdField || "parentId";
  }
  getChildren(options) {
    let result;
    if (options.includeFilteredOutRecords) {
      result = this.unfilteredChildren || this.children;
    } else if (options.useOrderedTree) {
      result = this.orderedChildren;
    } else {
      result = this.children;
    }
    return result;
  }
  /**
   * Traverses all child nodes recursively calling the passed function
   * on a target node **before** iterating the child nodes.
   * @param {Function} fn The function to call
   * @param {Boolean} [skipSelf=false] True to ignore self
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.useOrderedTree] True to traverse unsorted/unfiltered tree
   * @category Parent & children
   */
  traverse(fn2, skipSelf, options) {
    options = fixTraverseOptions(options);
    const me = this, children = me.getChildren(options);
    if (!skipSelf) {
      fn2.call(me, me);
    }
    for (let i = 0, l = children == null ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn2, false, options);
    }
  }
  /**
   * Traverses all child nodes recursively calling the passed function
   * on child nodes of a target **before** calling it on the node.
   * @param {Function} fn The function to call
   * @param {Boolean} [skipSelf=false] True to skip this node in the traversal
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @category Parent & children
   */
  traverseBefore(fn2, skipSelf, options) {
    options = fixTraverseOptions(options);
    const me = this, children = me.getChildren(options);
    for (let i = 0, l = children == null ? void 0 : children.length; i < l; i++) {
      children[i].traverse(fn2, false, options);
    }
    if (!skipSelf) {
      fn2.call(me, me);
    }
  }
  /**
   * Traverses child nodes recursively while fn returns true
   * @param {Function} fn
   * @param {Boolean} [skipSelf=false] True to skip this node in the traversal
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or an options object
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @category Parent & children
   * @returns {Boolean}
   */
  traverseWhile(fn2, skipSelf, options) {
    options = fixTraverseOptions(options);
    const me = this;
    let goOn = skipSelf || fn2.call(me, me) !== false;
    if (goOn) {
      const children = me.getChildren(options);
      if (children == null ? void 0 : children.length) {
        goOn = children.every((child) => child.traverseWhile(fn2, false, options));
      }
    }
    return goOn;
  }
  /**
   * Bubbles up from this node, calling the specified function with each node.
   *
   * @param {Function} fn The function to call for each node
   * @param {Boolean} [skipSelf] True to skip this node in the traversal
   * @category Parent & children
   */
  bubble(fn2, skipSelf = false) {
    let me = this;
    if (!skipSelf) {
      fn2.call(me, me);
    }
    while (me.parent) {
      me = me.parent;
      fn2.call(me, me);
    }
  }
  /**
   * Bubbles up from this node, calling the specified function with each node,
   * while the function returns true.
   *
   * @param {Function} fn The function to call for each node
   * @param {Boolean} [skipSelf] True to skip this node in the traversal
   * @category Parent & children
   * @returns {Boolean}
   */
  bubbleWhile(fn2, skipSelf = false) {
    let me = this, goOn = true;
    if (!skipSelf) {
      goOn = fn2.call(me, me);
    }
    while (goOn && me.parent) {
      me = me.parent;
      goOn = fn2.call(me, me);
    }
    return goOn;
  }
  /**
   * Checks if this model contains another model as one of it's descendants
   *
   * @param {Core.data.Model|String|Number} childOrId child node or id
   * @param {Boolean} [skipSelf=false] True to ignore self in the traversal
   * @category Parent & children
   * @returns {Boolean}
   */
  contains(childOrId, skipSelf = false) {
    if (childOrId && typeof childOrId === "object") {
      childOrId = childOrId.id;
    }
    return !this.traverseWhile((node) => node.id != childOrId, skipSelf);
  }
  getTopParent(all) {
    let result;
    if (all) {
      result = [];
      this.bubbleWhile((t) => {
        result.push(t);
        return t.parent && !t.parent.isRoot;
      });
    } else {
      result = null;
      this.bubbleWhile((t) => {
        result = t;
        return t.parent && !t.parent.isRoot;
      });
    }
    return result;
  }
  /**
   * Append a child record(s) to any current children.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} childRecord Array of records/data or a single
   * record/data to append
   * @param {Boolean} [silent] Pass `true` to not trigger events during append
   * @returns {Core.data.Model|Core.data.Model[]|null}
   * @category Parent & children
   */
  appendChild(childRecord, silent = false, options = {}) {
    return this.insertChild(childRecord, null, silent, options);
  }
  /**
   * Insert a child record(s) before an existing child record.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} childRecord Array of records/data or a single
   * record/data to insert
   * @param {Core.data.Model} [before] Optional record to insert before, leave out to append to the end
   * @param {Boolean} [silent] Pass `true` to not trigger events during append
   * @returns {Core.data.Model|Core.data.Model[]|null}
   * @category Parent & children
   */
  insertChild(childRecord, before = null, silent = false, options = {}) {
    var _a2, _b, _c, _d, _e, _f, _g;
    const me = this, returnArray = Array.isArray(childRecord);
    childRecord = ArrayHelper.asArray(childRecord);
    if (typeof before === "number") {
      before = (_b = (_a2 = me.children) == null ? void 0 : _a2[before]) != null ? _b : null;
    }
    if (!silent && !me.stores.every((s) => s.trigger("beforeAdd", {
      records: childRecord,
      parent: me
    }) !== false)) {
      return null;
    }
    childRecord = me.ingestChildren(childRecord);
    const index = (_e = (_d = before == null ? void 0 : before.parentIndex) != null ? _d : (_c = me.children) == null ? void 0 : _c.length) != null ? _e : 0, preResult = (_f = me.beforeInsertChild) == null ? void 0 : _f.call(me, childRecord), inserted = me.internalAppendInsert(childRecord, before, silent, options);
    if (inserted.length) {
      me.convertToParent(silent);
    }
    (_g = me.afterInsertChild) == null ? void 0 : _g.call(me, index, childRecord, preResult, inserted);
    return returnArray || !inserted ? inserted : inserted[0];
  }
  /**
   * Converts a leaf node to a parent node, assigning an empty array as its children
   * @param {Boolean} [silent] Pass `true` to not trigger any event
   * @category Parent & children
   */
  convertToParent(silent = false) {
    const me = this, wasLeaf = me.isLeaf;
    me.meta.isLeaf = false;
    if (!me.children) {
      me.children = [];
    }
    if (wasLeaf && !me.root.isLoading && !silent) {
      me.signalNodeChanged({
        isLeaf: {
          value: false,
          oldValue: true
        }
      });
    }
  }
  signalNodeChanged(changes, stores = this.stores) {
    stores.forEach((s) => {
      s.trigger("update", { record: this, records: [this], changes });
      s.trigger("change", { action: "update", record: this, records: [this], changes });
    });
  }
  tryInsertChild() {
    return this.insertChild(...arguments);
  }
  internalAppendInsert(recordsToInsert, beforeRecord, silent, options) {
    const me = this, { stores, root, children } = me, { firstStore: rootStore } = root, { parentIdField } = me.constructor, parentId = me.id;
    let isNoop, start, i, newRecordsCloned, oldParentIndices, isMove;
    if (!root.isLoading && rootStore) {
      isMove = {};
      oldParentIndices = [];
      for (i = 0; i < recordsToInsert.length; i++) {
        const newRecord = recordsToInsert[i];
        isMove[newRecord.id] = newRecord.root === root;
        oldParentIndices[i] = newRecord.parentIndex;
      }
    }
    if (beforeRecord && beforeRecord.parent !== me) {
      beforeRecord = null;
    }
    if (children) {
      const insertAt = beforeRecord ? beforeRecord.parentIndex : children.length;
      if (children[start = insertAt] === recordsToInsert[0] || children[start = insertAt - 1] === recordsToInsert[0]) {
        for (isNoop = true, i = 0; isNoop && i < recordsToInsert.length; i++) {
          if (recordsToInsert[i] !== children[start + i]) {
            isNoop = false;
          }
        }
      }
    }
    if (isNoop) {
      return recordsToInsert;
    }
    for (i = 0; i < recordsToInsert.length; i++) {
      const newRecord = recordsToInsert[i], oldParent = newRecord.parent;
      if (rootStore && !root.isLoading) {
        newRecord.traverse((r) => {
          if (r.root === root) {
            isMove[r.id] = true;
          }
        });
      }
      if ((oldParent == null ? void 0 : oldParent.removeChild(newRecord, isMove == null ? void 0 : isMove[newRecord.id], silent, { isInserting: true, ...options })) === false) {
        if (!newRecordsCloned) {
          recordsToInsert = recordsToInsert.slice();
          newRecordsCloned = true;
        }
        recordsToInsert.splice(i--, 1);
      } else {
        newRecord.parent = me;
        newRecord.data[parentIdField] = parentId;
        const { meta } = newRecord;
        if (meta.modified[parentIdField] === parentId && !oldParent) {
          meta.oldParentId = parentId;
        }
        if (oldParent) {
          meta.oldParentId = oldParent.id;
        }
      }
    }
    if (recordsToInsert.length) {
      if (!Array.isArray(children)) {
        me.children = [];
      }
      if (!Array.isArray(me.orderedChildren)) {
        me.orderedChildren = [];
      }
      const insertAt = me.addToChildren(beforeRecord, recordsToInsert, options);
      stores.forEach((store) => {
        if (!store.isChained) {
          recordsToInsert.forEach((record) => {
            record.joinStore(store);
          });
          store.onNodeAddChild(me, recordsToInsert, insertAt, isMove, silent);
          recordsToInsert.forEach((record, i2) => {
            if (record.meta.oldParentId != null && !(me.inProcessChildren || me.isLoading)) {
              const toSet = {
                [parentIdField]: parentId,
                [me.getDataSource("parentIndex")]: record.parentIndex
              }, wasSet = {}, { modified, oldParentId } = record.meta, oldParentIndex = oldParentIndices[i2];
              delete record.meta.oldParentId;
              if (me.id !== oldParentId) {
                wasSet[parentIdField] = {
                  value: parentId,
                  oldValue: oldParentId
                };
              }
              if (record.parentIndex !== oldParentIndex) {
                wasSet.parentIndex = {
                  value: record.parentIndex,
                  oldValue: oldParentIndex
                };
              }
              if (modified[parentIdField] === me.id) {
                Reflect.deleteProperty(modified, parentIdField);
              } else if (!(parentIdField in modified)) {
                modified[parentIdField] = oldParentId;
              }
              if (isMove[record.id]) {
                const oldParent = store.getById(oldParentId);
                if (oldParent.isLeaf && !silent) {
                  oldParent.signalNodeChanged({
                    isLeaf: {
                      value: true,
                      oldValue: false
                    }
                  }, [store]);
                }
              }
              record.afterChange(toSet, wasSet);
            }
            record.traverse((node) => {
              if (!node.ignoreBag && !node.isLinked) {
                store.updateModifiedBagForRecord(node);
              }
            });
          });
        }
      });
    }
    return recordsToInsert;
  }
  /**
   * Remove a child record. Only direct children of this node can be removed, others are ignored.
   * @param {Core.data.Model|Core.data.Model[]} childRecords The record(s) to remove.
   * @param {Boolean} [isMove] Pass `true` if the record is being moved within the same store.
   * @param {Boolean} [silent] Pass `true` to not trigger events during remove.
   * @privateparam {Object} [options]
   * @privateparam {Object} [options.isInserting] `true` is passed when removal is part of record inserting (acted on by
   * ModelLink)
   * @returns {Core.data.Model[]} All records (including nested children) removed
   * @category Parent & children
   */
  removeChild(childRecords, isMove = false, silent = false, options = {}) {
    var _a2, _b;
    const me = this, allRemovedRecords = [], wasLeaf = me.isLeaf, {
      children,
      stores
    } = me;
    childRecords = ArrayHelper.asArray(childRecords);
    childRecords = childRecords.filter((r) => r.parent === me);
    if (!silent) {
      for (const store of stores) {
        if (!store.isChained && store.trigger("beforeRemove", {
          parent: me,
          records: childRecords,
          isMove
        }) === false) {
          return false;
        }
      }
    }
    const preResult = (_a2 = me.beforeRemoveChild) == null ? void 0 : _a2.call(me, childRecords, isMove);
    for (const childRecord of childRecords) {
      const { parentIdField } = childRecord.constructor, { modified } = childRecord.meta, oldParentId = childRecord.parent ? childRecord.parent.id : null;
      if (!(parentIdField in modified) && !childRecord.isLinked) {
        modified[parentIdField] = oldParentId;
      }
      const index = me.removeFromChildren(childRecord, options);
      stores.forEach((store) => {
        if (!store.isChained) {
          const { isRemoving } = store;
          store.isRemoving = true;
          allRemovedRecords.push(...store.onNodeRemoveChild(me, [childRecord], index, { isMove, silent }));
          store.isRemoving = isRemoving;
        }
      });
      if (!isMove) {
        childRecord.parent = childRecord.parentIndex = childRecord.unfilteredIndex = childRecord.nextSibling = childRecord.previousSibling = null;
        childRecord.data[parentIdField] = null;
      }
    }
    if ((me.unfilteredChildren || children).length === 0 && me.constructor.convertEmptyParentToLeaf.onRemove && !me.isRoot) {
      me.meta.isLeaf = true;
    }
    if (me.isLeaf !== wasLeaf && !silent && !isMove) {
      me.signalNodeChanged({
        isLeaf: {
          value: true,
          oldValue: false
        }
      });
    }
    (_b = me.afterRemoveChild) == null ? void 0 : _b.call(me, childRecords, preResult, isMove);
    return allRemovedRecords;
  }
  clearParentId() {
    const me = this;
    Reflect.deleteProperty(me.data, me.parentIdField);
    Reflect.deleteProperty(me.originalData, me.parentIdField);
    if (me.meta.modified) {
      Reflect.deleteProperty(me.meta.modified, me.parentIdField);
    }
  }
  /**
   * Replaces all child nodes with the new node set.
   * @param {Core.data.Model|Core.data.Model[]} childRecords The new child record set.
   * @returns {Core.data.Model[]}
   * @category Parent & children
   */
  replaceChildren(newChildren) {
    this.clearChildren();
    this.data[this.constructor.childrenField] = newChildren;
    this.processChildren();
    return this.children;
  }
  /**
   * Removes all child nodes from this node.
   * @param {Boolean} [silent=false] Pass `true` to not fire Store events during the remove.
   * @returns {Core.data.Model[]}
   * @category Parent & children
   */
  clearChildren(silent = false) {
    const me = this, { stores } = me, children = me.unfilteredChildren || me.children;
    me.children = [];
    me.orderedChildren = [];
    if (children && children !== true) {
      stores.forEach((store) => {
        if (!store.isChained) {
          store.onNodeRemoveChild(me, children, 0, { unfiltered: true, silent });
        }
      });
      if (me.unfilteredChildren) {
        me.unfilteredChildren = [];
      }
    }
  }
  /**
   * Removes all records from the rootNode
   * @private
   */
  clear() {
    var _a2;
    const me = this, { stores } = me, children = (_a2 = me.children) == null ? void 0 : _a2.slice();
    if (!me.isRoot || !children) {
      return;
    }
    for (const store of stores) {
      if (!store.isChained) {
        if (store.trigger("beforeRemove", {
          parent: me,
          records: children,
          isMove: false,
          removingAll: true
        }) === false) {
          return false;
        }
      }
    }
    me.children.length = 0;
    if (me.unfilteredChildren) {
      me.unfilteredChildren.length = 0;
    }
    stores.forEach((store) => {
      children.forEach((child) => {
        if (child.stores.includes(store)) {
          child.unjoinStore(store);
        }
        child.parent = child.parentIndex = child.nextSibling = child.previousSibling = null;
      });
      store.storage.suspendEvents();
      store.storage.clear();
      store.storage.resumeEvents();
      store.added.clear();
      store.modified.clear();
      store.trigger("removeAll");
      store.trigger("change", { action: "removeall" });
    });
  }
  updateChildrenIndices(children, indexName, silent = false) {
    let previousSibling = null;
    for (let i = 0; i < children.length; i++) {
      const child = children[i], oldValue = child[indexName];
      if (indexName === "parentIndex" || indexName === "orderedParentIndex") {
        if (oldValue === void 0 || silent) {
          child.setData(indexName, i);
        } else if (oldValue !== i) {
          child.set(indexName, i, true);
        }
      } else {
        child[indexName] = i;
      }
      if (indexName === "parentIndex") {
        child.previousSibling = previousSibling;
        if (previousSibling) {
          previousSibling.nextSibling = child;
        }
        if (i === children.length - 1) {
          child.nextSibling = null;
        }
        previousSibling = child;
      }
    }
  }
  addToChildren(beforeRecord, newRecords, options = {}) {
    var _a2;
    const me = this, configs = [
      [me.children, "parentIndex", beforeRecord],
      [me.unfilteredChildren, "unfilteredIndex", beforeRecord],
      [
        me.orderedChildren,
        "orderedParentIndex",
        // Distinguish null and undefined here. `null` means add to the end of the ordered tree
        (options == null ? void 0 : options.orderedBeforeNode) === void 0 ? (options == null ? void 0 : options.orderedParentIndex) !== void 0 ? me.orderedChildren[options == null ? void 0 : options.orderedParentIndex] : beforeRecord : options == null ? void 0 : options.orderedBeforeNode
      ]
    ];
    for (const config of configs) {
      const [children, indexName, beforeRecord2] = config;
      if (children) {
        const index = beforeRecord2 ? indexName === "orderedParentIndex" ? children.indexOf(beforeRecord2) : beforeRecord2[indexName] : children.length;
        config.push(index);
        children.splice(index, 0, ...newRecords);
        if (!((_a2 = options == null ? void 0 : options[indexName]) == null ? void 0 : _a2.skip)) {
          me.updateChildrenIndices(children, indexName);
        }
      }
    }
    return configs[0][3];
  }
  removeFromChildren(childRecord, options) {
    var _a2;
    const configs = [
      [this.children, "parentIndex"],
      [this.unfilteredChildren, "unfilteredIndex"],
      [this.orderedChildren, "orderedParentIndex"]
    ];
    for (const config of configs) {
      const [children, indexName] = config;
      if (children) {
        const index = children.indexOf(childRecord);
        config.push(index);
        if (index > -1) {
          children.splice(index, 1);
          if (!((_a2 = options == null ? void 0 : options[indexName]) == null ? void 0 : _a2.skip)) {
            this.updateChildrenIndices(children, indexName);
          }
        }
      }
    }
    return configs[0][2];
  }
  /**
   * Iterates orderedChildren array to apply sorting order according to `orderedParentIndex`.
   * Normally sorting is not required because order is maintained on append/insert. But is useful
   * when pasting number of records to restore their original order.
   * @param {Boolean} [deep=true] True to dive into children. False to sort own children.
   * @param {Boolean} [usePreviousOrder=false] Enable to use previous value of `orderedParentIndex`.
   * @returns {Set} Returns Set of moved nodes which require WBS update
   * @private
   */
  sortOrderedChildren(deep = true, usePreviousOrder = false) {
    const movedNodes = [];
    if (!this.isLeaf) {
      this.orderedChildren.sort((a, b) => {
        var _a2, _b;
        if (usePreviousOrder) {
          const aPrevIndex = (_a2 = a.meta.modified.orderedParentIndex) != null ? _a2 : a.orderedParentIndex, bPrevIndex = (_b = b.meta.modified.orderedParentIndex) != null ? _b : b.orderedParentIndex, result = aPrevIndex - bPrevIndex;
          if (result !== 0) {
            movedNodes.push(a);
            movedNodes.push(b);
          }
          return result;
        } else {
          return a.orderedParentIndex - b.orderedParentIndex;
        }
      });
      if (deep) {
        this.orderedChildren.forEach((child) => {
          movedNodes.push(...child.sortOrderedChildren(deep, usePreviousOrder));
        });
      }
      this.updateChildrenIndices(this.orderedChildren, "orderedParentIndex", true);
    }
    return new Set(movedNodes);
  }
  sortVisibleChildren(deep = true, sorterFn) {
    const me = this;
    if (!me.isLeaf) {
      me.children.sort(sorterFn);
      if (deep) {
        me.orderedChildren.forEach((child) => child.sortVisibleChildren(deep, sorterFn));
      }
      me.updateChildrenIndices(me.children, "parentIndex", true);
    }
  }
  sortUnfilteredChildren(deep = true, sorterFn) {
    const me = this;
    if (!me.isLeaf && me.unfilteredChildren) {
      me.unfilteredChildren.sort(sorterFn);
      if (deep) {
        me.orderedChildren.forEach((child) => child.sortUnfilteredChildren(deep, sorterFn));
      }
      me.updateChildrenIndices(me.unfilteredChildren, "unfilteredIndex", true);
    }
  }
  unjoinStore(store, isReplacing = false) {
    var _a2;
    const me = this;
    if (me.unfilteredChildren) {
      me.children = me.unfilteredChildren.slice();
      me.unfilteredChildren = null;
    }
    (_a2 = super.unjoinStore) == null ? void 0 : _a2.call(this, store, isReplacing);
  }
};

// ../Core/lib/Core/data/mixin/ModelLink.js
var propertyOverrides = {
  id: 1,
  stores: 1,
  parentIndex: 1,
  parent: 1,
  previousSibling: 1,
  nextSibling: 1,
  unfilteredIndex: 1
};
var proxyConfig = {
  get(target, prop) {
    if (prop === "proxyMeta") {
      return this.proxyMeta;
    }
    if (prop === "constructor") {
      return target.constructor;
    }
    if (prop === "setData") {
      return this.setDataOverride;
    }
    if (prop === "set") {
      return this.setOverride;
    }
    if (propertyOverrides[prop]) {
      return this.proxyMeta.data[prop];
    }
    return Reflect.get(target, prop, this.proxyRecord);
  },
  set(target, prop, value) {
    if (propertyOverrides[prop]) {
      this.proxyMeta.data[prop] = value;
    } else {
      target[prop] = value;
    }
    return true;
  },
  // Override setData & set to reroute parentIndex updates
  setDataOverride(toSet, value) {
    if (toSet === "parentIndex") {
      this.proxyMeta.data.parentIndex = value;
    } else {
      this.proxyMeta.originalRecord.setData(toSet, value);
    }
  },
  setOverride(field, value, ...args) {
    if (field === "parentIndex") {
      this.proxyMeta.data.parentIndex = value;
    } else {
      this.proxyMeta.originalRecord.set(field, value, ...args);
    }
  }
};
var ModelLink_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    /**
     * Creates a proxy record (using native Proxy) linked to this record (the original). The proxy records shares most
     * data with the original, except for its `id` (which is always generated), and ordering fields such as
     * `parentIndex` and `parentId` etc.
     *
     * Any change to the proxy record will be reflected on the original, and vice versa. A proxy record is not meant to
     * be persisted, only the original record should be persisted. Thus, proxy records are not added to stores change
     * tracking (added, modified and removed records).
     *
     * Removing the original record removes all proxies.
     *
     * Creating a proxy record allows a Store to seemingly contain the record multiple times, something that is
     * otherwise not possible. It also allows a record to be used in both a tree store and in a flat store.
     *
     * <div class="note">Note that not all UI features support linked records</div>
     *
     * @returns {Proxy} Proxy record linked to the original record
     * @typings {typeof Proxy}
     * @category Misc
     */
    link() {
      if (this.isLinked) {
        return this.$original.link();
      }
      const me = this, useConfig = {
        ...proxyConfig,
        // Data not shared with the original record
        proxyMeta: {
          originalRecord: me,
          data: {
            id: `${me.id}_link_${StringHelper.generateUUID()}`,
            stores: []
          }
        }
      }, proxyRecord = new Proxy(me, useConfig);
      useConfig.proxyRecord = proxyRecord;
      (me.meta.linkedRecords || (me.meta.linkedRecords = [])).push(proxyRecord);
      return proxyRecord;
    }
    /**
     * Is this record linked to another record?
     * @member {Boolean}
     * @readonly
     * @category Misc
     */
    get isLinked() {
      var _a3;
      return Boolean((_a3 = this.proxyMeta) == null ? void 0 : _a3.originalRecord);
    }
    /**
     * Are other records linked to this record?
     * @member {Boolean}
     * @readonly
     * @category Misc
     */
    get hasLinks() {
      return Boolean(!this.proxyMeta && this.$links.length);
    }
    // Logic to remove a link shared between removing in a flat store and a tree store
    removeLink(link, records = null, silent = false) {
      if (link.hasLinks) {
        for (const linked of link.$links.slice()) {
          if (records) {
            ArrayHelper.include(records, linked);
          } else {
            linked.remove(silent);
          }
        }
      } else if (link.isLinked) {
        ArrayHelper.remove(link.$original.$links, link);
      }
    }
    // Overrides beforeRemove in Model, to remove all linked records when original record is removed.
    beforeRemove(records) {
      this.removeLink(this, records);
    }
    // Overrides removeChild in TreeNode, to remove the original node and all linked nodes when either a linked or
    // original node is removed.
    removeChild(childRecords, isMove, silent, options) {
      if (!(options == null ? void 0 : options.isInserting)) {
        childRecords = ArrayHelper.asArray(childRecords);
        for (const child of childRecords) {
          this.removeLink(child, null, silent);
        }
      }
      return super.removeChild(childRecords, isMove, silent, options);
    }
    // Convenience getter for code keying by id that needs to work with both link and original
    get $originalId() {
      return this.$original.id;
    }
    // Convenience getter to retrieve linked records
    get $links() {
      var _a3;
      return (_a3 = this.meta.linkedRecords) != null ? _a3 : [];
    }
  }, __publicField(_a2, "$name", "ModelLink"), __publicField(_a2, "isModel", true), _a2;
};

// ../Core/lib/Core/mixin/Factoryable.js
var { defineProperty: defineProperty4 } = Reflect;
var ownerSymbol = Symbol("owner");
var typeSplitRe = /[\s,]+/;
var Factoryable_default = (Target) => class Factoryable extends (Target || Base) {
  static get $name() {
    return "Factoryable";
  }
  static get declarable() {
    return [
      /**
       * This property getter returns options that control the factory process. This property getter must be
       * defined by the class that mixes in `Factoryable` in order to initialize the factory properly.
       * ```
       *  static get factoryable() {
       *      return {
       *          defaultType : 'default'
       *      };
       *  }
       * ```
       * If there are no special options to provide, this method can return nothing (`undefined`):
       * ```
       *  static get factoryable() {
       *      // initialize the factory with all default options
       *  }
       * ```
       * @static
       * @member {Object} factoryable
       * @property {Boolean} [factoryable.caseless=true] Specify `false` to use case-sensitive type names. The
       * default is to ignore case.
       * @property {String} [factoryable.defaultType=null] The default type to create when a config object has
       * no `typeKey` property.
       * @property {Function|Function[]} [factoryable.extends] One or more classes that mix in `Factoryable` to
       * use for resolving type names when a type name is not found in this factory.
       * @property {String} [factoryable.typeKey='type'] The name of the property in a config object that holds
       * the type name.
       * @internal
       */
      "factoryable",
      /**
       * One or more additional type name aliases for this class. This can be useful for renaming and maintaining
       * a previous type name.
       * ```
       *  class Fit extends Layout {
       *      static type = 'fit';
       *
       *      static alias = 'fill';
       *  }
       * ```
       * @static
       * @member {String|String[]} alias
       * @internal
       */
      "alias",
      /**
       * The (canonical) type name for this class by which instances can be created using the static
       * {@link #function-create-static create()} method.
       * @static
       * @member {String} type
       */
      "type"
    ];
  }
  /**
   * Registers a class (`cls`) associated with the given `type`.
   * @param {String|String[]} type A string, array of strings or a comma-separated string containing the type names
   * for the specified `cls` class.
   * @param {Function} cls The class (constructor function)
   * @param {Boolean} [replace] Pass `true` to overwrite existing registered types. Otherwise, this method will throw
   * an exception if the `type` is already registered with this factory.
   * @internal
   */
  static register(type, cls, replace = globalThis.__BRYNTUM_EXAMPLE) {
    const { factoryable } = this.initClass(), { caseless, registry: registry2 } = factoryable, types = StringHelper.split(type, typeSplitRe);
    for (let lower, name, i = 0; i < types.length; ++i) {
      name = types[i];
      lower = caseless ? name.toLowerCase() : name;
      if (!replace && lower in registry2) {
        throw new Error(`Type "${name}" already registered with ${factoryable.class.name} factory`);
      }
      registry2[name] = registry2[lower] = cls.initClass();
    }
  }
  /**
   * Returns `true` if the passed instance is of the passed type or of a derived class.
   * @param {Object} instance The object to test.
   * @param {String} type The type to test against
   */
  static isA(instance, type) {
    return this.isType(instance, type, true);
  }
  /**
   * Returns `true` if the passed instance is of the passed type.
   * @param {Object} instance The object to test.
   * @param {String} type The type to test against
   * @param {Boolean} [deep] Pass `true` to return `true` if the class is a subclass of the passed type.
   */
  static isType(instance, type, deep) {
    const { factoryable } = this, { caseless, registry: registry2 } = factoryable, typeCls = registry2[caseless ? type.toLowerCase() : type];
    if (typeCls) {
      if (deep) {
        return instance instanceof typeCls;
      }
      return instance.constructor === typeCls;
    }
    return false;
  }
  static setupAlias(cls) {
    cls.register(cls.alias, cls);
  }
  static setupFactoryable(cls, meta) {
    const superClass = meta.super.class;
    let { factoryable } = cls;
    factoryable = {
      caseless: true,
      defaultType: null,
      extends: superClass.factoryable ? [superClass] : null,
      typeKey: "type",
      ...factoryable
    };
    factoryable.class = cls;
    factoryable.registry = /* @__PURE__ */ Object.create(null);
    if (factoryable.extends && !Array.isArray(factoryable.extends)) {
      factoryable.extends = [factoryable.extends];
    }
    defineProperty4(cls, "factoryable", {
      get() {
        return factoryable;
      }
    });
  }
  static setupType(cls, meta) {
    const { type } = cls;
    cls.register(type, cls, meta.replaceType);
    defineProperty4(cls.prototype, "type", {
      value: type
    });
  }
  /**
   * Creates an instance from this factory, given the type name or a config object.
   * @param {String|Object} config The type name string or config object.
   * @param {String|Function|Object} [options] Creation options (for details see {@link #function-reconfigure-static}).
   * @returns {Object}
   */
  static create(config, options) {
    return this.reconfigure(null, config, options);
  }
  /**
   * Reconfigures an optional existing instance based on the provided config and returns the correctly configured
   * instance. This will be the `existingInstance` if the `config` does not specify a different type.
   *
   * If `config` is `null` (or simply falsy), this method will destroy the `existingInstance` (if any) and return
   * `null`.
   *
   * If there is no `existingInstance`, the config must specify a type. That is, it must be a string (the type name)
   * or an object containing a `type` property, the `defaultType` must be provided or the factory itself must have
   * a `defaultType` specified (see {@link #property-factoryable-static}).
   *
   * When an `existingInstance` is provided and a type is specified, the instance will be reconfigured via `setConfig`
   * if it is of that type. Otherwise, the `existingInstance` is destroyed (if it is owned by the `options.owner`)
   * and a new instance of the correct type is created.
   *
   * @param {Object} existingInstance The instance to reconfigure. This can be `null`.
   *
   * @param {String|Object} config The type name string or config object.
   *
   * @param {String|Function|Object} [options] Additional options to control the reconfiguration process. If this
   * value is a string or a class constructor, it treated as `options.type`. If this value is a class instance, it
   * is used as the `options.owner`. If this is a function, it is treated as `options.setup`. NOTE: functions declared
   * using the `function` keyword are equivalent to class constructors. Use an arrow function or a class method to
   * avoid this when a `setup` function is intended.
   *
   * @param {String|Function} [options.type] The default type to use if the `config` object does not specify a type.
   *
   * @param {Object} [options.owner] The owner of any created instances. If the `existingInstance` is being replaced,
   * this value determines if the instance will be destroyed.
   *
   * @param {Object} [options.defaults] A config object of default values to use when creating a new instance.
   *
   * @param {Function|String} [options.setup] A function or the name of a method (on the `options.owner`) to call
   * prior to creating a new instance. It is passed the config object that will be used to create the instance. If a
   * truthy value is returned, that value is passed to the constructor instead of the provided config object.
   *
   * @param {Function|String} [options.transform] A function or the name of a method (on the `options.owner`) to call
   * with the raw config object prior to processing and the value it returns replaces the raw value. This function is
   * used to transform strings or arrays (for example) into proper config objects.
   *
   * @param {Function|String} [options.cleanup] A function or the name of a method (on the `options.owner`) to call
   * prior to destroying the `existingInstance`. The `existingInstance` is passed as the sole argument.
   *
   * @returns {Object} The reconfigured instance (either `existingInstance` or a new instance of the desired type)
   */
  static reconfigure(existingInstance, config, options) {
    const me = this, { factoryable } = me, { typeKey } = factoryable;
    let defaultType = options, cleanup, defaults, mergeType, owner, prepared, setup, t, transform, type;
    if (options && !ObjectHelper.isClass(options)) {
      defaultType = null;
      t = typeof options;
      if (t === "function") {
        setup = options;
      } else if (t === "string") {
        defaultType = options;
      } else if (ObjectHelper.isObject(options)) {
        cleanup = options.cleanup;
        defaults = options.defaults;
        owner = options.owner;
        setup = options.setup;
        defaultType = options.type;
        transform = options.transform;
      } else {
        owner = options;
      }
    }
    if (transform) {
      config = typeof transform === "string" ? owner[transform](config) : transform(config);
    }
    type = config;
    if (typeof type === "string") {
      config = {};
    } else if (config) {
      if (config === true) {
        config = {};
      }
      if (!ObjectHelper.isObject(config)) {
        if (owner && config !== existingInstance && (existingInstance == null ? void 0 : existingInstance[ownerSymbol]) === owner) {
          typeof cleanup === "string" ? owner[cleanup](existingInstance) : cleanup == null ? void 0 : cleanup(existingInstance);
          existingInstance.destroy();
        }
        return config;
      }
      type = config[typeKey];
    }
    type = type && me.resolveType(type);
    if (existingInstance) {
      if (config && (!type || existingInstance.constructor === type)) {
        if (typeKey in config) {
          config = ObjectHelper.assign({}, config);
          delete config[typeKey];
        }
        existingInstance.setConfig(config);
        return existingInstance;
      }
      if (owner && existingInstance[ownerSymbol] === owner) {
        typeof cleanup === "string" ? owner[cleanup](existingInstance) : cleanup == null ? void 0 : cleanup(existingInstance);
        existingInstance.destroy();
      }
    }
    if (config) {
      if (defaults) {
        if (!(mergeType = type)) {
          if (!(mergeType = defaults[typeKey] || defaultType || factoryable.defaultType)) {
            throw new Error(`No default mergeType defined for ${factoryable.class.name} factory`);
          }
          mergeType = me.resolveType(mergeType);
        }
        if (mergeType) {
          config = mergeType.mergeConfigs(defaults, config);
        }
      }
      if (setup) {
        prepared = typeof setup === "string" ? owner[setup](config, type, defaults) : setup(config, type, defaults);
        if (prepared === null) {
          return prepared;
        }
        config = prepared || config;
      }
      if (!type) {
        if (!(type = config[typeKey] || defaultType || factoryable.defaultType)) {
          throw new Error(`No default type defined for ${factoryable.class.name} factory`);
        }
        type = me.resolveType(type);
      }
      if (defaults && !mergeType) {
        config = type.mergeConfigs(defaults, config);
      }
      if (typeKey in config) {
        config = ObjectHelper.assign({}, config);
        delete config[typeKey];
      }
      config = new type(config);
      if (owner) {
        config[ownerSymbol] = owner;
      }
    }
    return config || null;
  }
  /**
   * This method returns the constructor of the class registered for the given type name.
   * @param {String} type The type name to look up.
   * @param {Boolean} [optional] Pass `true` to return `null` if `type` is not found instead of throwing an exception.
   * @returns {Function}
   */
  static resolveType(type, optional) {
    if (typeof type !== "string") {
      return type;
    }
    const { factoryable } = this, bases = factoryable.extends;
    let result = factoryable.registry[factoryable.caseless ? type.toLowerCase() : type], i;
    for (i = 0; !result && bases && i < bases.length; ++i) {
      result = bases[i].resolveType(
        type,
        /* optional = */
        true
      );
    }
    if (!result && !optional) {
      throw new Error(`Invalid type name "${type}" passed to ${factoryable.class.name} factory`);
    }
    return result;
  }
};

// ../Core/lib/Core/data/field/DataField.js
var { getOwnPropertyDescriptor: getOwnPropertyDescriptor2 } = Reflect;
var DataField = class extends Base.mixin(Factoryable_default) {
  static get $name() {
    return "DataField";
  }
  static get type() {
    return "auto";
  }
  static get factoryable() {
    return {
      defaultType: "auto"
    };
  }
  static get prototypeProperties() {
    return {
      /**
       * The name of the field.
       * @config {String} name
       */
      /**
       * The label text for a form item generated for this field. This is also used to create
       * a column header for a {@link #config-column} for this field.
       * @config {String} label
       */
      /**
       * A column config object for a column to display this field in a grid. For simple, atomic
       * data types, such as `date`, `string`, `boolean`, `number` and `integer`, this is optional
       * and the appropriate column type can be inferred.
       *
       * This also provides default values for column configuration if a configured column definition
       * for a grid lacks a property.
       *
       * For complex fields, such as identifiers which link to other records, a more capable
       * column type may be specified, for example a `type : `number'` field may be configured
       * with
       *
       * ```javascript
       * column : 'percent'
       * ```
       * or
       * ```javascript
       * column : {
       *     type : 'percent',
       *     width : 100
       * }
       * ```
       * if it represents a percentage value and needs appropriate rendering and editing.
       * @config {String|Object} column
       */
      /**
       * A config object for a widget to edit this field in a form. For simple, atomic
       * data types, such as `date`, `string`, `boolean`, `number` and `integer`, this is optional
       * and the appropriate input widget type can be inferred.
       *
       * For complex fields, such as identifiers which link to other records, a more capable
       * widget may be specified.
       * @config {String|InputFieldConfig} editor
       * @private
       */
      /**
       * A function that compares two values and returns a value < 0 if the first is less than the second, or 0
       * if the values are equal, or a value > 0 if the first is greater than the second.
       * @config {Function}
       * @param {Core.data.Model} value1
       * @param {Core.data.Model} value2
       * @returns {Number}
       * @default
       */
      compare: null,
      /**
       * A function that compares two objects or records using the `compare` function on the properties of each
       * objects based on the `name` of this field.
       * @config {Function}
       * @param {Core.data.Model} value1
       * @param {Core.data.Model} value2
       * @returns {Number}
       * @default
       * @internal
       */
      compareItems: null,
      /**
       * The property in a record's data object that contains the field's value.
       * Defaults to the field's `name`.
       * @config {String}
       */
      dataSource: null,
      /**
       * The default value to assign to this field in a record if no value is provided.
       * @config {*} defaultValue
       */
      /**
       * Setting to `true` will ensure this field is included in any update/insert request payload
       * when a Store / Project / CrudManager performs a request.
       * @config {Boolean}
       * @default
       */
      alwaysWrite: false,
      /**
       * Setting to `false` indicates that `null` is not a valid value.
       * @config {Boolean}
       * @default
       */
      nullable: true,
      /**
       * The value to return from {@link #function-print} for a `null` or `undefined` value.
       * @config {String}
       * @default
       */
      nullText: null,
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {*}
       * @default
       */
      nullValue: void 0,
      /**
       * Set to `false` to exclude this field when saving records to a server.
       * @config {Boolean}
       * @default
       */
      persist: true,
      /**
       * Set to `true` for the field's set accessor to ignore attempts to set this field.
       * @config {Boolean}
       * @default
       */
      readOnly: false,
      /**
       * By default, defined {@link Core.data.Model} fields may be used to create a grid column
       * suitable for displaying that field in a grid cell. Some fields may not be suitable for
       * features which automatically generate columns for view. These fields are created using
       * `internal : true`. Some examples are the `expanded` and `rowHeight` fields which are used
       * internally.
       * @config {Boolean}
       * @default
       */
      internal: false,
      useProp: null
    };
  }
  /**
   * The class that first defined this field. Derived classes that override a field do not change this property.
   * @member {Core.data.Model} definedBy
   * @private
   * @readonly
   */
  /**
   * The class that most specifically defined this field. Derived classes that override a field set this property to
   * themselves.
   * @member {Core.data.Model} owner
   * @private
   * @readonly
   */
  // NOTE: Since we create lots of instances, they have no life cycle (they are not destroyed) and are readonly after
  // creation, this class does not use configurable.
  construct(config) {
    const me = this;
    if (config) {
      me.name = config.name;
      Object.assign(me, config);
    }
    if (me.compare) {
      me.compareItems = (itemA, itemB) => me.compare(itemA == null ? void 0 : itemA[me.name], itemB == null ? void 0 : itemB[me.name]);
    }
  }
  /**
   * This method transforms a data value into the desired form for storage in the record's data object.
   *
   * ```javascript
   * export default class Task extends TaskModel {
   *    static get fields() {
   *        return [
   *            {
   *                name    : 'status',
   *                convert : (value, data) => {
   *                    if (value >= 100) {
   *                        return 'done';
   *                    }
   *                    else if (value > 0) {
   *                        return 'started';
   *                    }
   *                }
   *            }
   *        ];
   *    }
   * }
   * ```
   *
   * @method convert
   * @param {*} value The value to convert for storage in a record.
   * @param {Object} data The raw record data object
   * @returns {*} The converted value.
   */
  /**
   * This method transforms a data value into the desired form for transmitting to a server.
   * @method serialize
   * @param {*} value The value to serialize
   * @param {Core.data.Model} record The record that contains the value being serialized.
   * @returns {*} The serialized value.
   */
  /**
   * This optional method is called when setting a data value on a record.
   * @method set
   * @param {*} value The value to set
   * @param {Object} data The records future or current data object to set value to
   * @param {Core.data.Model} record The record that owns or will own the data object
   * @internal
   */
  /**
   * This optional method is called when a record using this field is created.
   * @method init
   * @param {Core.data.Model} record The record being created
   * @internal
   */
  /**
   * Create getter and setter functions for the specified field name under the specified key.
   * @internal
   */
  defineAccessor(target, force) {
    const { name, dataSource } = this;
    if (!force && name in target && target.$meta.hierarchy.some((current) => {
      var _a2;
      return ((_a2 = getOwnPropertyDescriptor2(current.prototype, name)) == null ? void 0 : _a2.enumerable) === false;
    })) {
      return;
    }
    Reflect.defineProperty(target, name, {
      configurable: true,
      // To allow removing it later
      enumerable: true,
      // no arrow functions here, need `this` to change to instance
      get: this.complexMapping ? function() {
        return this.complexGet(name, dataSource);
      } : function() {
        if (this.batching && name in this.meta.batchChanges) {
          return this.meta.batchChanges[name];
        }
        return dataSource in this.data ? this.data[dataSource] : this.data[name];
      },
      // no arrow functions here, need `this` to change to instance
      set(value) {
        const field = this.$meta.fields.map[name];
        if (!(field && field.readOnly)) {
          this.set(name, value);
        }
      }
    });
  }
  /**
   * Compares two values for this field and returns `true` if they are equal, and `false` if not.
   * @param {*} first The first value to compare for equality.
   * @param {*} second The second value to compare for equality.
   * @returns {Boolean} `true` if `first` and `second` are equal.
   */
  isEqual(first, second) {
    return ObjectHelper.isEqual(first, second);
  }
  /**
   * Returns the given field value as a `String`. If `value` is `null` or `undefined`, the value specified by
   * {@link #config-nullText} is returned.
   * @param {*} value The value to convert to a string.
   * @returns {String}
   */
  print(value) {
    return value == null ? this.nullText : this.printValue(value);
  }
  /**
   * Returns the given, non-null field value as a `String`.
   * @param {*} value The value to convert to a string (will not be `null` or `undefined`).
   * @returns {String}
   * @protected
   */
  printValue(value) {
    return String(value);
  }
};
DataField._$name = "DataField";

// ../Core/lib/Core/data/field/ArrayDataField.js
var ArrayDataField = class extends DataField {
  isEqual(a, b) {
    return a === b;
  }
  getAt(record, index) {
    return record.get(this.name)[index];
  }
};
__publicField(ArrayDataField, "$name", "ArrayDataField");
__publicField(ArrayDataField, "type", "array");
ArrayDataField.initClass();
ArrayDataField._$name = "ArrayDataField";

// ../Core/lib/Core/data/field/BooleanDataField.js
var BooleanDataField = class extends DataField {
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Boolean}
       * @default
       */
      nullValue: false
    };
  }
  isEqual(first, second) {
    if (first == null && second == null) {
      return true;
    }
    return super.isEqual(first, second);
  }
  convert(value) {
    var _a2;
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    if (((_a2 = value.toLowerCase) == null ? void 0 : _a2.call(value)) === "false") {
      return false;
    }
    return Boolean(value);
  }
};
__publicField(BooleanDataField, "$name", "BooleanDataField");
__publicField(BooleanDataField, "type", "boolean");
__publicField(BooleanDataField, "alias", "bool");
BooleanDataField.initClass();
BooleanDataField._$name = "BooleanDataField";

// ../Core/lib/Core/data/field/DateDataField.js
var DateDataField = class extends DataField {
  static get $name() {
    return "DateDataField";
  }
  static get type() {
    return "date";
  }
  static get prototypeProperties() {
    return {
      /**
       * The format of the date field.
       *
       * See {@link Core.helper.DateHelper DateHelper} for details.
       * @config {String} format
       * @default DateHelper.defaultFormat
       */
      format: null
    };
  }
  convert(value) {
    if (value == null) {
      if (!this.nullable) {
        value = this.nullValue;
      }
    } else if (value === "now") {
      value = /* @__PURE__ */ new Date();
    } else if (!(value instanceof Date)) {
      value = DateHelper.parse(value, this.format || DateHelper.defaultParseFormat);
      if (!value || isNaN(value)) {
        value = void 0;
      }
    }
    return value;
  }
  serialize(value) {
    if (value instanceof Date) {
      value = DateHelper.format(value, this.format || DateHelper.defaultFormat);
    }
    return value;
  }
  printValue(value) {
    return DateHelper.format(value, this.format || DateHelper.defaultFormat);
  }
};
DateDataField.initClass();
DateDataField._$name = "DateDataField";

// ../Core/lib/Core/data/field/StringDataField.js
var StringDataField = class extends DataField {
  static get $name() {
    return "StringDataField";
  }
  static get type() {
    return "string";
  }
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {String}
       * @default
       */
      nullValue: ""
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : String(value);
  }
};
StringDataField.initClass();
StringDataField._$name = "StringDataField";

// ../Core/lib/Core/data/field/DurationUnitDataField.js
var DurationUnitDataField = class extends StringDataField {
  static get $name() {
    return "DurationUnitDataField";
  }
  static get type() {
    return "durationunit";
  }
  isEqual(first, second) {
    return DateHelper.compareUnits(first, second) === 0;
  }
};
DurationUnitDataField.initClass();
DurationUnitDataField._$name = "DurationUnitDataField";

// ../Core/lib/Core/data/field/IntegerDataField.js
var IntegerDataField = class extends DataField {
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Number}
       * @default
       */
      nullValue: 0,
      /**
       * The `Math` method to use to ensure fractional component is removed.
       * @config {'round'|'floor'|'ceil'}
       * @default
       */
      rounding: "round"
    };
  }
  convert(value) {
    return value == null ? this.nullable ? value : this.nullValue : Math[this.rounding](Number(value));
  }
};
__publicField(IntegerDataField, "$name", "IntegerDataField");
__publicField(IntegerDataField, "type", "integer");
__publicField(IntegerDataField, "alias", "int");
IntegerDataField.initClass();
IntegerDataField._$name = "IntegerDataField";

// ../Core/lib/Core/data/field/ModelDataField.js
var ModelDataField = class extends DataField {
  static get $name() {
    return "ModelDataField";
  }
  static get type() {
    return "model";
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
  isEqual(first, second) {
    return first && second && second instanceof first.constructor && second.id == first.id;
  }
};
__publicField(ModelDataField, "configurable", {
  /**
   * Class used to contain data values in this field; should be a subclass of {@link Core.data.Model}.
   * Defining this configuration is necessary for some functionality (like filter editing) to identify the
   * type of data held by the field without data present.
   *
   * @config {Core.data.Model}
   * @typings {typeof Model}
   * @category Common
   */
  modelClass: null
});
ModelDataField.initClass();
ModelDataField._$name = "ModelDataField";

// ../Core/lib/Core/data/field/NumberDataField.js
var NumberDataField = class extends DataField {
  static get prototypeProperties() {
    return {
      /**
       * The value to replace `null` when the field is not `nullable`.
       * @config {Number}
       * @default
       */
      nullValue: 0,
      /**
       * The numeric precision of this field. Values are rounded to the specified number of digits. If `null`,
       * the default, no rounding is performed.
       * @config {Number}
       * @default
       */
      precision: null
    };
  }
  isEqual(first, second) {
    return isNaN(Number(first)) && isNaN(Number(second)) || super.isEqual(first, second);
  }
  convert(value) {
    if (value == null) {
      return this.nullable ? value : this.nullValue;
    }
    value = Number(value);
    if (isNaN(value)) {
      return;
    }
    let scale = this.precision;
    if (scale) {
      scale = 10 ** scale;
      value = Math.round(value * scale) / scale;
    } else if (scale === 0) {
      value = Math.round(value);
    }
    return value;
  }
};
__publicField(NumberDataField, "$name", "NumberDataField");
__publicField(NumberDataField, "type", "number");
__publicField(NumberDataField, "alias", "float");
NumberDataField.initClass();
NumberDataField._$name = "NumberDataField";

// ../Core/lib/Core/data/field/ObjectDataField.js
var ObjectDataField = class extends DataField {
  static get $name() {
    return "ObjectDataField";
  }
  static get type() {
    return "object";
  }
  static get prototypeProperties() {
    return {
      complexMapping: true
    };
  }
};
ObjectDataField.initClass();
ObjectDataField._$name = "ObjectDataField";

// ../Core/lib/Core/data/field/StoreDataField.js
var isIdAutoGenerated = (id) => typeof id === "string" && id.startsWith("_generated");
var StoreDataField = class extends DataField {
  /**
   * Store class to use when creating the store.
   *
   * ```javascript
   * class TodoStore extends Store {
   *     ...
   * }
   *
   * const task = new Store({
   *     static fields = [
   *         { type : 'store', name: 'todoItems', storeClass : TodoStore }
   *     ]
   * });
   * ```
   *
   * @config {Class} storeClass
   * @typings {typeof Store}
   */
  /**
   * Model class to use for the store (can also be configured as usual on the store class, this config is for
   * convenience).
   *
   * ```javascript
   * class TodoItem extends Model {
   *   ...
   * }
   *
   * const task = new Store({
   *     static fields = [
   *         { type : 'store', name: 'todoItems', storeClass : Store, modelClass : TodoItem }
   *     ]
   * });
   * ```
   *
   * @config {Class} modelClass
   * @typings {typeof Model}
   */
  /**
   * Optional store configuration object to apply when creating the store.
   *
   * ```javascript
   * const task = new Store({
   *     static fields = [
   *         {
   *             type       : 'store',
   *             name       : 'todoItems',
   *             storeClass : Store
   *             store      : {
   *                  syncDataOnLoad : false
   *             }
   *         }
   *     ]
   * });
   * ```
   *
   * @config {StoreConfig} store
   */
  // Initializer, called when creating a record. Sets up the store and populates it with any initial data
  init(data, record) {
    var _a2;
    const me = this, storeName = `${me.name}Store`, config = { skipStack: true, syncDataOnLoad: true };
    if (me.store) {
      ObjectHelper.assign(config, me.store);
    }
    if (me.modelClass) {
      config.modelClass = me.modelClass;
    }
    (_a2 = record[`init${StringHelper.capitalize(storeName)}`]) == null ? void 0 : _a2.call(record, config);
    if (!config.storeClass && !me.storeClass) {
      throw new Error(`Field '${me.name}' with type 'store' must have a storeClass configured`);
    }
    const store = record.meta[storeName] = new (config.storeClass || me.storeClass)(config);
    if (me.complexMapping) {
      ObjectHelper.setPath(data, me.dataSource, store);
    } else {
      data[me.dataSource] = store;
    }
    store.verifyNoGeneratedIds = false;
    store.usesId = !store.count || !store.every((record2) => record2.hasGeneratedId);
    store.$currentValue = me.getValue(store);
    store.ion({
      change: ({ action }) => {
        const value = me.getValue(store);
        if (!store.$isSettingStoreFieldData) {
          const oldPreserveCurrentDataset = store.$preserveCurrentDataset;
          store.$preserveCurrentDataset = me.subStore && (action === "update" || action === "remove" || action === "add");
          me.$isUpdatingRecord = true;
          record.set(me.name, value);
          me.$isUpdatingRecord = false;
          store.$preserveCurrentDataset = oldPreserveCurrentDataset;
        }
        store.$currentValue = value;
      }
    });
  }
  // Called when setting a new value to the field on a record
  set(value, data, record) {
    var _a2, _b;
    const me = this, storeName = `${me.name}Store`, { [storeName]: store } = record.meta;
    if (!store) {
      record.meta.initableValues.set(me, value);
      return false;
    }
    if (store.$isSettingStoreFieldData) {
      return;
    }
    store.$isSettingStoreFieldData = true;
    value = (_b = (_a2 = record[`process${StringHelper.capitalize(storeName)}Data`]) == null ? void 0 : _a2.call(record, value, record)) != null ? _b : value;
    if (!store.$preserveCurrentDataset) {
      store.data = value;
    }
    store.$isSettingStoreFieldData = false;
    store.usesId = !store.count || !store.every((record2) => record2.hasGeneratedId);
  }
  serialize(value, record) {
    const store = record.meta[`${this.name}Store`];
    return this.$isUpdatingRecord ? this.getValue(store) : store.$currentValue;
  }
  // Extract persistable values, optionally including id depending on if ids are used
  getValue(store) {
    return store.allRecords.map((r) => {
      const data = r.persistableData;
      if (!store.usesId) {
        delete data.id;
      }
      return data;
    });
  }
  isEqual(a, b) {
    if (a == null && b == null) {
      return true;
    } else if (a == null && b != null || a != null && b == null) {
      return false;
    } else {
      if (a.isStore && b.isStore) {
        return ObjectHelper.isDeeplyEqual(a.$currentValue, b.$currentValue);
      } else if (a.isStore && b.isStore || !a.isStore && !b.isStore) {
        return ObjectHelper.isEqual(a, b, true);
      } else {
        const store = a.isStore ? a : b, modelClass = store.modelClass, fields = modelClass.$meta.fields.defs, storeEntries = a.isStore ? a.$currentValue : b.$currentValue, arrayEntries = a.isStore ? b : a;
        if (storeEntries.length !== arrayEntries.length) {
          return false;
        } else {
          for (let i = 0; i < fields.length; i++) {
            const field = fields[i];
            if (!field.persist) {
              continue;
            }
            for (let k = 0; k < storeEntries.length; k++) {
              const storeValue = storeEntries[k][field.dataSource];
              const arrayValue = arrayEntries[k][field.dataSource];
              if (storeValue !== void 0 && arrayValue === void 0) {
                if (field.dataSource === modelClass.idField && isIdAutoGenerated(storeValue)) {
                  continue;
                }
                if (field.defaultValue !== void 0 && ObjectHelper.isEqual(field.defaultValue, storeValue, true)) {
                  continue;
                }
              }
              if (!ObjectHelper.isEqual(storeValue, arrayValue, true)) {
                return false;
              }
            }
          }
          return true;
        }
      }
    }
  }
  // Cloned value to be able to restore it later using STM
  getOldValue(record) {
    const store = record.meta[`${this.name}Store`];
    return store ? ObjectHelper.clone(store.$currentValue) : null;
  }
  getAt(record, index) {
    const store = record.meta[`${this.name}Store`];
    return store == null ? void 0 : store.getAt(index);
  }
};
__publicField(StoreDataField, "$name", "StoreDataField");
__publicField(StoreDataField, "type", "store");
StoreDataField.initClass();
StoreDataField._$name = "StoreDataField";

// ../Core/lib/Core/data/Model.js
var nestedRe = new RegExp(/^(.*?)\.(.*)/);
var arrayRe = /(.*)\[(.*)]\.?(.*)/;
var { defineProperty: defineProperty5 } = Reflect;
var { hasOwn: hasOwn3 } = ObjectHelper;
var _undefined = void 0;
var internalProps = {
  children: 1,
  data: 1,
  meta: 1
};
var abbreviationFields = [
  "name",
  "title",
  "text",
  "label",
  "description"
];
var fieldDataTypes = {
  boolean: 1,
  number: 1,
  date: 1,
  object: 1
};
var fieldsOrder = {
  parentId: 1,
  $PhantomId: 2,
  id: 3
};
var _Model = class _Model extends Base.mixin(ModelStm_default, TreeNode_default, ModelLink_default) {
  static get $name() {
    return "Model";
  }
  static get declarable() {
    return [
      /**
       * Array of defined fields for this model class. Subclasses add new fields by implementing this static
       * getter:
       *
       * ```javascript
       * // Model defining two fields
       * class Person extends Model {
       *     static get fields() {
       *         return [
       *             { name : 'username', defaultValue : 'New person' },
       *             { name : 'birthdate', type : 'date' }
       *         ];
       *     }
       * }
       *
       * // Subclass overriding one of the fields
       * class Bot extends Person {
       *     static get fields() {
       *         return [
       *             // Default value of 'username' field is overridden, any other setting from the parents
       *             // definition is preserved
       *             { name : 'username', defaultValue : 'Bot' }
       *         ];
       *     }
       * }
       * ```
       *
       * Fields in a subclass are merged with those from the parent class, making it easy to override mappings,
       * formats etc.
       *
       * @member {Array<String|ModelFieldConfig|Core.data.field.DataField>} fields
       * @readonly
       * @static
       * @category Fields
       */
      "fields"
    ];
  }
  static get fields() {
    return [
      // The index of this item in its parent (respects filtering)
      {
        name: "parentIndex",
        type: "number",
        persist: false,
        internal: true
      },
      // The index of this item in its parent ghost (non-sortable) children array
      {
        name: "orderedParentIndex",
        type: "number",
        persist: false,
        internal: true
      },
      /**
       * Flag the record as read-only on the UI level, preventing the end user from manipulating it using editing
       * features such as cell editing and event dragging.
       *
       * Does not prevent altering the record programmatically, it can still be manipulated by application code.
       *
       * For more info, see the "Read-only records" section above.
       *
       * @field {Boolean} readOnly
       * @category Common
       */
      {
        name: "readOnly",
        type: "boolean"
      },
      /**
       * Start expanded or not (only valid for tree data)
       * @readonly
       * @field {Boolean} expanded
       * @category Tree
       */
      {
        name: "expanded",
        internal: true
      },
      /**
       * Only used when the store is grouped. This field references the owning group record(s), kept in a map
       * keyed by store id.
       * @internal
       * @field {Map} groupParent
       */
      {
        name: "groupParent",
        persist: false,
        internal: true
      }
    ];
  }
  /**
   * Template static getter which is supposed to be overridden to define default field values for the Model class.
   * Overrides `defaultValue` config specified by the {@link #property-fields-static} getter.
   * Returns a named object where key is a field name and value is a default value for the field.
   *
   * NOTE: This is a legacy way of defining default values, we recommend using {@link #property-fields-static} moving
   * forward.
   *
   * ```javascript
   * class Person extends Model {
   *     static get fields() {
   *         return [
   *             { name : 'username', defaultValue : 'New person' }
   *         ];
   *     }
   * }
   *
   * class Bot extends Person {
   *     static get defaults() {
   *         return {
   *             username : 'Bot' // default value of 'username' field is overridden
   *         };
   *     }
   * }
   * ```
   *
   * @member {Object} defaults
   * @static
   * @category Fields
   */
  /**
   * The data source for the id field which provides the ID of instances of this Model.
   * @property {String}
   * @category Fields
   */
  static set idField(idField) {
    this._assignedIdField = true;
    this._idField = idField;
  }
  static get idField() {
    return this._idField;
  }
  /**
   * The name of the data field which holds children of this Model when used in a tree structure
   * ```javascript
   * MyModel.childrenField = 'kids';
   * const parent = new MyModel({
   *     name : 'Dad',
   *     kids : [
   *         { name : 'Daughter' },
   *         { name : 'Son' }
   *     ]
   * });
   * ```
   * @property {String}
   * @category Fields
   */
  static set childrenField(childrenField) {
    this._childrenField = childrenField;
  }
  static get childrenField() {
    if (!this._childrenField) {
      const dataField = this.fieldMap.children;
      this._childrenField = (dataField == null ? void 0 : dataField.dataSource) || "children";
    }
    return this._childrenField;
  }
  /**
   * Returns index path to this node. This is the index of each node in the node path
   * starting from the topmost parent. (only relevant when its part of a tree store).
   * @returns {Number[]} The index of each node in the path from the topmost parent to this node.
   * @category Parent & children
   * @private
   */
  get indexPath() {
    const indices = [];
    let node = this, depth = node.childLevel;
    for (node = this; node && !node.isRoot; node = node.parent) {
      indices[depth--] = node.parentIndex + 1;
    }
    return indices;
  }
  /**
   * Unique identifier for the record. Might be mapped to another dataSource using idField, but always exposed as
   * record.id. Will get a generated value if none is specified in records data.
   *
   * {@note}Note that generated ids are meant to be temporary (phantom ids), they should not be serialized
   * but instead replaced by the backend on commit{/@note}
   *
   * @field {String|Number} id
   * @category Common
   */
  //region Init
  /**
   * Constructs a new record from the supplied data config.
   * @param {Object} [config] Raw model config
   * @param {Core.data.Store} [store] Data store
   * @param {Object} [meta] Meta data
   * @privateparam {Boolean} [skipExpose] Skip exposing properties from data
   * @privateparam {Boolean} [forceUseRaw] Force using raw data, used by copy to not clone data twice
   * @function constructor
   * @category Lifecycle
   */
  construct(config = {}, store = null, meta = null, skipExpose = false, forceUseRaw = false, rawData = false) {
    var _a2, _b;
    const me = this, stores = (_a2 = ArrayHelper.asArray(store)) != null ? _a2 : [], { constructor, fieldMap } = me;
    let configs = null;
    store = stores[0];
    me.meta = {
      modified: {},
      ...constructor.metaConfig,
      ...meta
    };
    if (constructor.applyConfigs) {
      configs = {};
      if (!me.useRawData || !me.useRawData.enabled) {
        config = { ...config };
      }
      const defaultConfig = me.getDefaultConfiguration();
      if (constructor.autoExposeFields) {
        for (const key in defaultConfig) {
          if (key in config) {
            if (config[key] !== void 0) {
              configs[key] = config[key];
            }
            delete config[key];
          }
        }
      } else {
        for (const key in config) {
          if (!(key in constructor.fieldMap)) {
            if (config[key] === void 0) {
              configs[key] = defaultConfig[key];
            } else {
              configs[key] = config[key];
            }
            delete config[key];
          }
        }
      }
    }
    super.construct(configs);
    if (!skipExpose) {
      constructor.exposeProperties(config, rawData);
    }
    if (!hasOwn3(constructor, "idFieldProcessed")) {
      let overriddenIdField = me.meta.idField;
      if (!overriddenIdField) {
        if (constructor._assignedIdField) {
          overriddenIdField = constructor.idField;
        } else if (store) {
          overriddenIdField = store.idField;
        }
      }
      if (overriddenIdField && overriddenIdField !== fieldMap.id.dataSource) {
        constructor.addField({
          name: "id",
          dataSource: overriddenIdField,
          internal: true
        });
      }
      constructor._idField = fieldMap.id.dataSource;
      constructor.idFieldProcessed = true;
    }
    me._internalId = _Model._internalIdCounter++;
    me.stores = [];
    me.unjoinedStores = [];
    if (!me.originalData) {
      me.originalData = config;
    }
    me.data = constructor.processData(config, false, store, me, forceUseRaw);
    ((_b = me.meta.initableValues) == null ? void 0 : _b.size) && me.assignInitables();
    if (me.id == null) {
      me.setData("id", me.generateId(store));
    }
    if (me.data[constructor.childrenField]) {
      me.processChildren(stores);
    }
    me.generation = 0;
  }
  /**
   * Set this property to `true` when adding a record on a conditional basis, that is, it is yet
   * to be confirmed as an addition.
   *
   * When this is set, the {@link #property-isPersistable} value of the record is **false**, and upon being
   * added to a Store it will *not* be eligible to be synced with the server as an added record.
   *
   * Subsequently, *clearing* this property means this record will become persistable and eligible
   * for syncing as an added record.
   * @property {Boolean}
   * @category Editing
   */
  set isCreating(isCreating) {
    const me = this;
    if (Boolean(me.meta.isCreating) !== isCreating) {
      me.meta.isCreating = isCreating;
      me.stores.forEach((s) => {
        s.onIsCreatingToggle(me, isCreating);
      });
    }
  }
  get isCreating() {
    return Boolean(this.meta.isCreating);
  }
  /**
   * Compares this Model instance to the passed instance. If they are of the same type, and all fields
   * (except, obviously, `id`) are equal, this returns `true`.
   * @param {Core.data.Model} other The record to compare this record with.
   * @returns {Boolean} `true` if the other is of the same class and has all fields equal.
   * @category Misc
   */
  equals(other) {
    if (other instanceof this.constructor) {
      for (let fields = this.$meta.fields.defs, i = 0, { length } = fields; i < length; i++) {
        const field = fields[i], { name } = field;
        if (name !== "id" && !field.isEqual(this.getValue(name), other.getValue(name))) {
          return false;
        }
      }
      return true;
    }
    return false;
  }
  get subclass() {
    return new this.constructor(Object.setPrototypeOf({
      id: _undefined
    }, this.data), this.stores[0], null, true);
  }
  /**
   * Processes raw data, converting values and setting defaults.
   * @private
   * @param {Object} data Raw data
   * @param {Boolean} [ignoreDefaults] Ignore setting default values, used when updating
   * @returns {Object} Processed data
   * @category Fields
   */
  static processData(data, ignoreDefaults = false, store, record, forceUseRaw) {
    const { fieldMap, fieldDataSourceMap, defaultValues } = this, { useRawData = { enabled: false } } = store || {}, processed = forceUseRaw || useRawData.enabled ? data : ObjectHelper.clone(data);
    let fieldName;
    ignoreDefaults = ignoreDefaults || useRawData.disableDefaultValue || forceUseRaw;
    if (!ignoreDefaults) {
      for (fieldName in defaultValues) {
        const field = fieldDataSourceMap[fieldName];
        let defaultValue2 = defaultValues[fieldName];
        if (Array.isArray(defaultValue2)) {
          defaultValue2 = defaultValue2.slice();
        }
        if (field == null ? void 0 : field.complexMapping) {
          if (ObjectHelper.getPath(processed, fieldName) === _undefined) {
            ObjectHelper.setPath(processed, fieldName, defaultValue2);
          }
        } else if (processed[fieldName] === _undefined) {
          processed[fieldName] = defaultValue2;
        }
      }
    }
    if (!useRawData.disableTypeConversion && !forceUseRaw) {
      for (fieldName in fieldMap) {
        const field = fieldMap[fieldName], { name, dataSource } = field, hasSource = dataSource !== name, complex = field.complexMapping, sourceExists = hasSource && (complex ? ObjectHelper.pathExists(data, dataSource) : dataSource in data), useNameForValue = name in data && (!hasSource || !sourceExists), convert = !useRawData.disableTypeConversion && field.convert;
        if (useNameForValue || convert) {
          if (!ignoreDefaults || useNameForValue || sourceExists) {
            const value = useNameForValue ? processed[name] : complex ? ObjectHelper.getPath(processed, dataSource) : processed[dataSource], converted = convert ? field.convert(value, data, record) : value;
            if (complex) {
              ObjectHelper.setPath(processed, dataSource, converted);
            } else {
              processed[dataSource] = converted;
            }
            if (hasSource) {
              delete processed[name];
            }
          }
        }
      }
    }
    this.$meta.fields.initable.length && this.initInitables(record, processed);
    return processed;
  }
  static setupClass(meta) {
    super.setupClass(meta);
    if (!meta.fields) {
      this.setupFields(this, meta);
    }
  }
  static setupFields(cls, meta) {
    var _a2, _b, _c, _d, _e;
    const classFields = hasOwn3(cls, "fields") && cls.fields, base = meta.super.fields, fieldsInfo = meta.fields = {
      defs: (_a2 = base == null ? void 0 : base.defs.slice()) != null ? _a2 : [],
      // Set to true when an instance's data object is run through exposeProperties
      exposedData: false,
      // These objects are all keyed by field name:
      defaults: base ? { ...base.defaults } : {},
      // value=field.defaultValue
      exposed: Object.create((_b = base == null ? void 0 : base.exposed) != null ? _b : null),
      // value=true if we've done defineProperty
      ordinals: Object.create((_c = base == null ? void 0 : base.ordinals) != null ? _c : null),
      // value=index in the defs array
      map: Object.create((_d = base == null ? void 0 : base.map) != null ? _d : null),
      // value=definition object
      sources: Object.create((_e = base == null ? void 0 : base.sources) != null ? _e : null)
      // value=source definition object
    };
    if (hasOwn3(cls, "defaults")) {
      Object.assign(fieldsInfo.defaults, cls.defaults);
    }
    if (hasOwn3(cls, "idField")) {
      cls.addField({
        name: "id",
        dataSource: cls.idField,
        internal: true
      });
      fieldsInfo.exposed[cls.idField] = true;
    }
    if (classFields == null ? void 0 : classFields.length) {
      classFields.map(cls.addField, cls);
    }
    fieldsInfo.initable = fieldsInfo.defs.filter((field) => field.init);
    cls.exposeRelations();
  }
  static get defaultValues() {
    return this.$meta.fields.defaults;
  }
  /**
   * An array containing all the _defined_ fields for this Model class. This will include all superclass's
   * defined fields.
   * @property {Core.data.field.DataField[]}
   * @static
   * @readonly
   * @category Fields
   */
  static get allFields() {
    return this.$meta.fields.defs;
  }
  /**
   * Same as {@link #property-allFields-static}.
   * @property {Core.data.field.DataField[]}
   * @readonly
   * @category Fields
   */
  get allFields() {
    return this.$meta.fields.defs;
  }
  /**
   * An object containing all the _defined_ fields for this Model class. This will include all superclass's
   * defined fields through its prototype chain. So be aware that `Object.keys` and `Object.entries` will only
   * access this class's defined fields.
   * @property {Object<String,Core.data.field.DataField>}
   * @static
   * @readonly
   * @category Fields
   */
  static get fieldMap() {
    return this.$meta.fields.map;
  }
  /**
   * Same as {@link #property-fieldMap-static}.
   * @property {Object<String,Core.data.field.DataField>}
   * @readonly
   * @category Fields
   */
  get fieldMap() {
    return this.$meta.fields.map;
  }
  static get fieldDataSourceMap() {
    return this.$meta.fields.sources;
  }
  /**
   * Makes getters and setters for fields (from definitions and data). Called once when class is defined and once when
   * data is loaded first time.
   * @internal
   * @param {Object} [data] Raw data
   * @param {Boolean} [raw=true] True if data is raw (contains data sources), False if data contains field names
   * @category Fields
   */
  static exposeProperties(data, raw = true) {
    const me = this, fieldsInfo = me.$meta.fields, fieldMapProperty = raw ? "exposed" : "map";
    if (data && me.autoExposeFields && !fieldsInfo.exposedData) {
      let dataProperty, fieldDef, type;
      for (dataProperty in data) {
        if (!fieldsInfo[fieldMapProperty][dataProperty] && dataProperty !== me.childrenField) {
          type = ObjectHelper.typeOf(data[dataProperty]);
          fieldDef = {
            name: dataProperty,
            dataSource: dataProperty,
            fromData: true
          };
          if (fieldDataTypes[type]) {
            fieldDef.type = type;
          }
          me.addField(fieldDef);
        }
      }
      fieldsInfo.exposedData = true;
    }
    me.exposeRelations();
  }
  /**
   * Add a field definition in addition to those predefined in `fields`.
   * @param {String|ModelFieldConfig} fieldDef A field name or definition
   * @category Fields
   */
  static addField(fieldDef) {
    if (fieldDef == null) {
      return;
    }
    if (typeof fieldDef === "string") {
      fieldDef = {
        name: fieldDef
      };
    }
    const me = this.initClass(), fieldsInfo = me.$meta.fields, { ordinals } = fieldsInfo, propertiesExposed = fieldsInfo.exposed, { name } = fieldDef, existing = fieldsInfo.map[name], dataSource = fieldDef.dataSource || (fieldDef.dataSource = name);
    let field, key;
    if (!existing || fieldDef.type && fieldDef.type !== existing.type) {
      field = DataField.create(fieldDef);
      field.definedBy = existing ? existing.definedBy : me;
      field.ordinal = existing ? existing.ordinal : ordinals[name] = fieldsInfo.defs.length;
    } else {
      field = Object.create(existing);
      for (key in fieldDef) {
        if (key !== "type") {
          field[key] = fieldDef[key];
        }
      }
    }
    field.owner = me;
    fieldsInfo.defs[field.ordinal] = field;
    fieldsInfo.map[name] = field;
    if (!fieldsInfo.sources[dataSource]) {
      fieldsInfo.sources[dataSource] = field;
    }
    if (dataSource.includes(".")) {
      field.complexMapping = true;
    }
    if (field.complexMapping) {
      propertiesExposed[dataSource.split(".")[0]] = true;
    } else {
      propertiesExposed[dataSource] = true;
    }
    if ("defaultValue" in field) {
      fieldsInfo.defaults[dataSource] = field.defaultValue;
    }
    if (!internalProps[name]) {
      field.defineAccessor(me.prototype);
    }
    me._nonPersistableFields = null;
    me._alwaysWriteFields = null;
    return field;
  }
  /**
   * Remove a field definition by name.
   * @param {String} fieldName Field name
   * @category Fields
   */
  static removeField(fieldName) {
    const me = this.initClass(), fieldsInfo = me.$meta.fields, definition = fieldsInfo.map[fieldName], { ordinals } = fieldsInfo, index = ordinals[fieldName];
    if (definition) {
      fieldsInfo.defs.splice(index, 1);
      delete ordinals[fieldName];
      delete fieldsInfo.defaults[fieldName];
      delete fieldsInfo.exposed[fieldName];
      delete fieldsInfo.map[fieldName];
      delete fieldsInfo.sources[definition.dataSource];
      for (const name in ordinals) {
        if (ordinals[name] > index) {
          --ordinals[name];
        }
      }
      delete me.prototype[fieldName];
    }
  }
  /**
   * Makes getters and setters for related records. Populates a Model#relation array with the relations, to allow it
   * to be modified later when assigning stores.
   * @internal
   * @category Relations
   */
  static exposeRelations() {
    const me = this;
    if (hasOwn3(me, "exposedRelations")) {
      return;
    }
    if (me.relations) {
      me.exposedRelations = [];
      for (const relationName in me.relations) {
        const relation = me.relations[relationName];
        relation.relationName = relationName;
        me.exposedRelations.push(relation);
        if (!Reflect.ownKeys(me.prototype).includes(relationName)) {
          defineProperty5(me.prototype, relationName, {
            enumerable: true,
            get: function() {
              return this.getForeign(relationName);
            },
            set: function(value) {
              this.setForeign(relationName, value, relation);
            }
          });
        }
      }
    }
  }
  //endregion
  //region Initable fields
  // Initializes any fields using a data type that has an init method, and caches the value to assign to that field to
  // be able to assign it after all others. That allows the initter to reference the records other data if needed
  // (baselines use that to reference the task to get default values)
  static initInitables(record, processedData) {
    const laterValues = record.meta.initableValues = /* @__PURE__ */ new Map();
    for (const field of this.$meta.fields.initable) {
      const value = ObjectHelper.getPath(processedData, field.dataSource);
      value !== void 0 && laterValues.set(field, value);
      !field.lazy && field.init(processedData, record);
    }
  }
  // Assigns values to the fields that were initialized earlier (see initInitables above)
  assignInitables() {
    const { initableValues } = this.meta;
    for (const [field, value] of initableValues) {
      if (field.set(value, this.data, this) !== false) {
        initableValues.delete(field);
      }
    }
  }
  //endregion
  //region Fields
  /**
   * Flag checked from Store when loading data that determines if fields found in first records should be exposed in
   * same way as predefined fields.
   *
   * {@note}Note that we for all but the most basic use cases recommend explicitly defining the fields.
   * Having them auto exposed can lead to unexpected behavior, if the first record is not complete (fields missing,
   * null etc).
   * {/@note}
   *
   * @property {Boolean}
   * @category Fields
   */
  static get autoExposeFields() {
    return true;
  }
  /**
   * This function forces correct field order. Correct order is parentId before id. If we process id field before
   * parentId, idMap won't be updated and changing parent node will lead to duplicated records in storage
   * @param {String} a
   * @param {String} b
   * @returns {number}
   * @private
   */
  static fieldSorter(a, b) {
    return (fieldsOrder[a] || 100) - (fieldsOrder[b] || 100);
  }
  /**
   * Convenience getter to get field definitions from class.
   * @property {Core.data.field.DataField[]}
   * @readonly
   * @category Fields
   */
  get fields() {
    return this.$meta.fields.defs;
  }
  /**
   * Convenience function to get the definition for a field from class.
   * @param {String} fieldName Field name
   * @returns {Core.data.field.DataField}
   * @category Fields
   */
  getFieldDefinition(fieldName) {
    return this.constructor.getFieldDefinition(fieldName);
  }
  getFieldDefinitionFromDataSource(dataSource) {
    return this.$meta.fields.sources[dataSource];
  }
  /**
   * Get the names of all fields in data.
   * @property {String[]}
   * @readonly
   * @category Fields
   */
  get fieldNames() {
    return Object.keys(this.data);
  }
  /**
   * Get the definition for a field by name.
   * @param {String} fieldName Field name
   * @returns {Core.data.field.DataField} Field definition or null if none found
   * @category Fields
   */
  static getFieldDefinition(fieldName) {
    var _a2, _b;
    const field = this.fieldMap[fieldName];
    if (!field) {
      if (fieldName.includes("[")) {
        const [, arrayFieldName, , path] = fieldName.match(arrayRe), arrayField = arrayFieldName.includes(".") ? this.getFieldDefinition(arrayFieldName) : this.fieldMap[arrayFieldName];
        if (arrayField == null ? void 0 : arrayField.isStoreDataField) {
          return (_a2 = arrayField.modelClass) == null ? void 0 : _a2.getFieldDefinition(path);
        }
      } else if (fieldName.includes(".")) {
        const [localFieldName, path] = fieldName.split(".", 2), modelField = this.fieldMap[localFieldName];
        if (modelField.isModelDataField && modelField.modelClass) {
          return (_b = modelField.modelClass) == null ? void 0 : _b.getFieldDefinition(path);
        }
      }
    }
    return field;
  }
  /**
   * Returns dataSource configuration for a given field name
   * @param {String} fieldName
   * @returns {String} Field `dataSource` mapping
   * @internal
   */
  static getFieldDataSource(fieldName) {
    var _a2;
    return ((_a2 = this.getFieldDefinition(fieldName)) == null ? void 0 : _a2.dataSource) || fieldName;
  }
  /**
   * Get the data source used by specified field. Returns the fieldName if no data source specified.
   * @param {String} fieldName Field name
   * @returns {String}
   * @category Fields
   */
  getDataSource(fieldName) {
    const def = this.constructor.getFieldDefinition(fieldName);
    return (def == null ? void 0 : def.dataSource) || (def == null ? void 0 : def.name);
  }
  /**
   * Processes input to a field, converting to expected type.
   * @param {String} fieldName Field name
   * @param {*} value Value to process
   * @returns {*} Converted value
   * @category Fields
   */
  static processField(fieldName, value, record) {
    const field = this.fieldMap[fieldName];
    return (field == null ? void 0 : field.convert) ? field.convert(value, this.data, record) : value;
  }
  //endregion
  //region Relations
  /**
   * Initializes model relations. Called from store when adding a record.
   * @private
   * @category Relations
   */
  initRelations() {
    const me = this, relations = me.constructor.exposedRelations;
    if (!relations) {
      return;
    }
    me.stores.forEach((store) => {
      var _a2;
      if (!store.modelRelations) {
        store.initRelations();
      }
      const relatedRecords = [];
      (_a2 = store.modelRelations) == null ? void 0 : _a2.forEach((config) => {
        relatedRecords.push({ related: me.initRelation(config), config });
      });
      store.updateRecordRelationCache(me, relatedRecords);
    });
  }
  /**
   * Initializes/updates a single relation.
   * @param config Relation config
   * @returns {Core.data.Model} Related record
   * @private
   * @category Relations
   */
  initRelation(config) {
    const me = this, foreignId = me.get(config.foreignKey), foreign = foreignId !== _undefined && typeof config.foreignStore !== "string" && config.foreignStore.getById(foreignId), relationCache = me.meta.relationCache || (me.meta.relationCache = {});
    relationCache[config.relationName] = foreign || (foreignId != null ? { id: foreignId, placeHolder: true } : null);
    return foreign;
  }
  removeRelation(config) {
    const { relationName, foreignKey, nullFieldOnRemove } = config;
    if (this.meta.relationCache[relationName]) {
      delete this.meta.relationCache[relationName];
      if (nullFieldOnRemove) {
        this.setData(foreignKey, null);
      }
    }
  }
  getForeign(name) {
    var _a2;
    return (_a2 = this.meta.relationCache) == null ? void 0 : _a2[name];
  }
  setForeign(name, value, config) {
    const id = _Model.asId(value);
    return this.set(config.foreignKey, id);
  }
  /**
   * Get a relation config by name, from the first store.
   * @param {String} name
   * @returns {Object}
   * @private
   * @category Relations
   */
  getRelationConfig(name) {
    var _a2, _b;
    return (_b = (_a2 = this.firstStore) == null ? void 0 : _a2.modelRelations) == null ? void 0 : _b.find((r) => r.foreignKey === name);
  }
  //endregion
  //region Get/set values, data handling
  flatGet(fieldName, dataSource) {
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return dataSource in this.data ? this.data[dataSource] : this.data[fieldName];
  }
  complexGet(fieldName, dataSource) {
    if (this.batching && fieldName in this.meta.batchChanges) {
      return this.meta.batchChanges[fieldName];
    }
    return ObjectHelper.getPath(this.data, dataSource);
  }
  /**
   * Get value for specified field name. You can also use the generated getters if loading through a Store.
   * If model is currently in batch operation this will return updated batch values which are not applied to Model
   * until endBatch() is called.
   * @param {String} fieldName Field name to get value from
   * @returns {*} Fields value
   * @category Fields
   */
  get(fieldName) {
    if (!fieldName) {
      return;
    }
    const me = this, field = me.fieldMap[fieldName];
    if (!field) {
      if (fieldName.includes("[")) {
        const [, arrayFieldName, index, path] = fieldName.match(arrayRe);
        const arrayField = me.fieldMap[arrayFieldName];
        if (arrayField == null ? void 0 : arrayField.getAt) {
          me._thisIsAUsedExpression(me[arrayFieldName]);
          const subRecord = arrayField.getAt(me, index);
          if (subRecord && path) {
            if (subRecord.isModel) {
              return subRecord.getValue(path);
            }
            return subRecord[path];
          }
          return subRecord;
        }
        return null;
      }
      if (fieldName.includes(".")) {
        if (!ObjectHelper.hasPath(me.data, fieldName)) {
          return ObjectHelper.getPath(me, fieldName);
        }
        return me.complexGet(fieldName, fieldName);
      }
    }
    if (field == null ? void 0 : field.complexMapping) {
      return me.complexGet(fieldName, field.dataSource);
    }
    return me.flatGet(fieldName, (field == null ? void 0 : field.dataSource) || fieldName);
  }
  // Used to get field values, replaces `record[fieldName]` in internal code to allow relations etc.
  getValue(fieldName) {
    if (!fieldName) {
      return;
    }
    if (fieldName in this) {
      return this[fieldName];
    }
    return this.get(fieldName);
  }
  // Used to set field values, replacing `record[fieldName] = value` to handle dot notation
  setValue(fieldName, value) {
    if (fieldName in this) {
      this[fieldName] = value;
    } else {
      this.set(fieldName, value);
    }
  }
  /**
   * Internal function used to update a records underlying data block (record.data) while still respecting field
   * mappings. Needed in cases where a field needs setting without triggering any associated behaviour and it has a
   * dataSource with a different name.
   *
   * For example:
   * ```javascript
   * // startDate mapped to data.beginDate
   * { name : 'startDate', dataSource : 'beginDate' }
   *
   * // Some parts of our code needs to update the data block without triggering any of the behaviour associated with
   * // calling set. This would then not update "beginDate":
   * record.data.startDate = xx;
   *
   * // But this would
   * record.setData('startDate', xx);
   * ```
   * @internal
   * @category Editing
   */
  setData(toSet, value) {
    var _a2, _b;
    const { data, fieldMap } = this;
    if (typeof toSet === "string") {
      const field = fieldMap[toSet], dataSource = (_a2 = field == null ? void 0 : field.dataSource) != null ? _a2 : toSet;
      if (field == null ? void 0 : field.set) {
        field.set(value, this.data, this);
      } else if (field == null ? void 0 : field.complexMapping) {
        ObjectHelper.setPath(data, dataSource, value);
      } else {
        data[dataSource] = value;
      }
    } else {
      const keys = Object.keys(toSet);
      for (let i = 0; i < keys.length; i++) {
        const fieldName = keys[i], field = fieldMap[fieldName], dataSource = (_b = field == null ? void 0 : field.dataSource) != null ? _b : fieldName;
        if (field == null ? void 0 : field.set) {
          field.set(value, this.data, this);
        } else if (dataSource) {
          if (field == null ? void 0 : field.complexMapping) {
            ObjectHelper.setPath(data, dataSource, toSet[fieldName]);
          } else {
            data[dataSource] = toSet[fieldName];
          }
        }
      }
    }
  }
  /**
   * Returns raw data from the encapsulated data object for the passed field name
   * @param {String} fieldName The field to get data for.
   * @returns {*} The raw data value for the field.
   * @category Editing
   */
  getData(fieldName) {
    var _a2;
    const field = this.fieldMap[fieldName], dataSource = (_a2 = field == null ? void 0 : field.dataSource) != null ? _a2 : fieldName;
    if (dataSource) {
      if (field == null ? void 0 : field.complexMapping) {
        return ObjectHelper.getPath(this.data, dataSource);
      }
      return this.data[dataSource];
    }
  }
  /**
   * Silently updates record's id with no flagging the property as modified.
   * Triggers onModelChange event for changed id.
   * @param {String|Number} value id value
   * @private
   */
  syncId(value) {
    const oldValue = this.id;
    if (oldValue !== value) {
      this.setData("id", value);
      const data = { id: { value, oldValue } };
      this.afterChange(data, data);
    }
  }
  /**
   * Set value for the specified field. You can also use the generated setters if loading through a Store.
   *
   * Setting a single field, supplying name and value:
   *
   * ```javascript
   * record.set('name', 'Clark');
   * ```
   *
   * Setting multiple fields, supplying an object:
   *
   * ```javascript
   * record.set({
   *     name : 'Clark',
   *     city : 'Metropolis'
   * });
   * ```
   *
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} [value] Value to set
   * @param {Boolean} [silent] Set to true to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [validOnly] If set to `true` it will ignore setting a `undefined` value, allowing conversion functions to invalidate a data input
   * @privateparam {Boolean} [triggerBeforeUpdate]
   * @fires Store#idChange
   * @fires Store#update
   * @fires Store#change
   * @category Editing
   */
  set(field, value, silent = false, fromRelationUpdate = false, skipAccessors = false, validOnly = false, triggerBeforeUpdate = true) {
    var _a2;
    const me = this;
    if (me.isBatchUpdating) {
      me.inBatchSet(field, value, silent || me.$silenceBatch);
      return null;
    } else {
      const wasSet = me.inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly, triggerBeforeUpdate);
      (_a2 = me.afterSet) == null ? void 0 : _a2.call(me, field, value, silent, fromRelationUpdate, wasSet);
      return wasSet;
    }
  }
  fieldToKeys(field, value) {
    if (typeof field !== "string") {
      return ObjectHelper.assign({}, field);
    }
    return {
      [field]: value
    };
  }
  inBatchSet(field, value, silent) {
    const me = this, {
      meta,
      constructor,
      fieldMap
    } = me, wasSet = {};
    let cmp, changed = false;
    if (typeof field !== "string") {
      Object.keys(me.fieldToKeys(field, value)).forEach((key) => {
        cmp = fieldMap[key] || ObjectHelper;
        value = constructor.processField(key, field[key], me);
        if (!cmp.isEqual(meta.batchChanges[key], value)) {
          wasSet[key] = {
            value,
            oldValue: me.get(key)
          };
          meta.batchChanges[key] = value;
          changed = true;
        }
      });
    } else {
      cmp = fieldMap[field] || ObjectHelper;
      if (!cmp.isEqual(meta.batchChanges[field], value)) {
        wasSet[field] = {
          value,
          oldValue: me.get(field)
        };
        meta.batchChanges[field] = value;
        changed = true;
      }
    }
    if (changed) {
      me.generation++;
      if (!silent) {
        const event = {
          action: "update",
          record: me,
          records: [me],
          changes: wasSet
        };
        me.stores.forEach((store) => {
          store.trigger("batchedUpdate", { ...event });
        });
        me.forEachLinked(
          (store, record) => store.trigger("batchedUpdate", { ...event, record, records: [record] })
        );
      }
    }
  }
  inSet(fieldNameOrObject, value, silent, fromRelationUpdate, skipAccessors = false, validOnly = false, triggerBeforeUpdate = true) {
    var _a2, _b, _c;
    const me = this, {
      data,
      meta,
      fieldMap,
      constructor
    } = me, {
      prototype: myProto,
      childrenField,
      relations
    } = constructor, wasSet = {}, toSet = me.fieldToKeys(fieldNameOrObject, value), keys = Object.keys(toSet).sort(constructor.fieldSorter);
    let changed = false;
    if (!silent && triggerBeforeUpdate && !me.triggerBeforeUpdate(toSet)) {
      return null;
    }
    me.inSetting = true;
    for (let i = 0; i < keys.length; i++) {
      const key = keys[i];
      if (key === childrenField) {
        continue;
      }
      if (key.includes("[")) {
        const [, arrayFieldName, index, path] = key.match(arrayRe), field2 = me.fieldMap[arrayFieldName];
        if (field2 == null ? void 0 : field2.getAt) {
          const subRecord = field2.getAt(me, index);
          if (subRecord.isModel) {
            subRecord.set(path, toSet[key]);
          } else {
            ObjectHelper.setPath(subRecord, path, toSet[key]);
          }
          continue;
        }
      }
      const complexKey = key.includes(".");
      if (relations && complexKey) {
        const [, relationName, prop] = key.match(nestedRe);
        if (relations[relationName]) {
          me[relationName].set(prop, toSet[key]);
          continue;
        }
      }
      const field = fieldMap[key], cmp = field || ObjectHelper, readOnly = field == null ? void 0 : field.readOnly, mapping = (_a2 = field == null ? void 0 : field.dataSource) != null ? _a2 : key, useProp = !skipAccessors && !field && key in myProto || (field == null ? void 0 : field.useProp), oldValue = useProp ? me[mapping] : (field == null ? void 0 : field.complexMapping) || complexKey ? ObjectHelper.getPath(data, mapping) : data[mapping], value2 = constructor.processField(key, toSet[key], me), val = toSet[key] = { value: value2 }, relation = me.getRelationConfig(key), isEqual2 = (v1, v2) => cmp.isEqual(v1, v2) || v1 == null && v2 == null;
      if (!readOnly && !isEqual2(oldValue, value2) && (!validOnly || value2 !== void 0)) {
        me.generation++;
        val.oldValue = (_c = (_b = field == null ? void 0 : field.getOldValue) == null ? void 0 : _b.call(field, me)) != null ? _c : oldValue;
        changed = true;
        if (key in meta.modified && isEqual2(meta.modified[key], value2)) {
          Reflect.deleteProperty(meta.modified, key);
          if (me.isReverting) {
            me.data[mapping] = value2;
          }
        } else if (!me.ignoreBag) {
          if (!(key in meta.modified)) {
            me.storeFieldChange(key, oldValue);
          }
          if (val.oldValue === _undefined) {
            Reflect.deleteProperty(val, "oldValue");
          }
        }
        wasSet[key] = val;
        me.applyValue(useProp, mapping, value2, skipAccessors, field);
        if (relation && !fromRelationUpdate) {
          me.initRelation(relation);
          me.stores.forEach((store) => store.cacheRelatedRecord(me, value2, relation.relationName, val.oldValue));
        }
      }
    }
    if (changed) {
      me.afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    me.inSetting = false;
    return changed ? wasSet : null;
  }
  // Provided as a hook for Engine to do what needs to be done which ever way a field value is changed
  applyValue(useProp, key, value, skipAccessors, field) {
    var _a2;
    const me = this;
    if (((field == null ? void 0 : field.dataSource) || key) === me.constructor.idField) {
      me.$isPhantom = false;
    }
    if (((field == null ? void 0 : field.dataSource) || key) === me.constructor.parentIdField) {
      if (!(((_a2 = me.parent) == null ? void 0 : _a2.isRoot) && (value == null || !me.firstStore.getById(value)))) {
        (me.firstStore.getById(value) || me.firstStore.rootNode).insertChild(me, null, false, {
          orderedParentIndex: { skip: true }
        });
      }
    } else if (useProp) {
      me[(field == null ? void 0 : field.name) || key] = value;
    } else if (field == null ? void 0 : field.set) {
      field.set(value, me.data, me);
    } else {
      let complexMapping = field == null ? void 0 : field.complexMapping;
      if (!field && key.includes(".")) {
        const nestedName = key.split(".")[0];
        field = me.constructor.fieldMap[nestedName];
        complexMapping = (field == null ? void 0 : field.complexMapping) || (field == null ? void 0 : field.type) === "object";
      }
      if (complexMapping) {
        ObjectHelper.setPath(me.data, key, value);
      } else {
        me.data[key] = value;
      }
    }
  }
  // skipAccessors argument is used in the engine override
  afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
    for (const store of this.stores) {
      store.onModelChange(this, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    this.forEachLinked(
      (store, record) => store.onModelChange(record, toSet, wasSet, silent, fromRelationUpdate, skipAccessors)
    );
  }
  // Run fn for each store on each linked record
  forEachLinked(fn2) {
    for (const linked of this.$links) {
      for (const store of linked.stores) {
        fn2(store, linked);
      }
    }
  }
  /**
   * This yields `true` if this record is eligible for syncing with the server.
   * It can yield `false` if the record is in the middle of a {@link #property-isBatchUpdating batched update},
   * or if it is a {@link #property-isCreating tentative record} yet to be confirmed as a new addition.
   * @property {Boolean}
   * @readonly
   */
  get isPersistable() {
    return !this.isBatchUpdating && !this.isCreating;
  }
  /**
   * True if this model has any uncommitted changes.
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isModified() {
    return Boolean(this.meta.modified && Object.keys(this.meta.modified).length > 0);
  }
  get hasPersistableChanges() {
    return this.isPersistable && !ObjectHelper.isEmpty(this.rawModificationData);
  }
  /**
   * Returns true if this model has uncommitted changes for the provided field.
   * @param {String} fieldName Field name
   * @returns {Boolean} True if the field is changed
   * @category Editing
   */
  isFieldModified(fieldName) {
    return this.isModified && fieldName in this.meta.modified;
  }
  /**
   * Returns field value that should be persisted, or `undefined` if field is configured with `persist: false`.
   * @param {String|Core.data.field.DataField} nameOrField Name of the field to get value for, or its field definition
   * @private
   * @category Fields
   */
  getFieldPersistentValue(nameOrField) {
    const field = typeof nameOrField === "string" ? this.getFieldDefinition(nameOrField) : nameOrField, name = (field == null ? void 0 : field.name) || nameOrField;
    let result;
    if (!field || field.persist) {
      result = this.getValue(name);
      if (field == null ? void 0 : field.serialize) {
        result = field.serialize(result, this);
      }
    }
    return result;
  }
  /**
   * Get a map of the modified fields in form of an object. The field *names* are used as the property names
   * in the returned object.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modifications() {
    const data = this.rawModifications;
    if (data && Object.keys(data).length) {
      data[this.constructor.idField] = this.id;
    }
    return data;
  }
  get rawModifications() {
    const me = this, data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach((key) => {
      const value = me.getFieldPersistentValue(key);
      if (value !== _undefined) {
        data[key] = value;
        keySet = true;
      }
    });
    return keySet ? data : null;
  }
  /**
   * Get a map of the modified fields in form of an object. The fields {@link Core.data.field.DataField#config-dataSource}
   * is used as the property name in the returned object. The records id is always included.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modificationData() {
    const data = this.rawModificationData;
    if (data && Object.keys(data).length) {
      ObjectHelper.setPath(data, this.constructor.idField, this.id);
    }
    return data;
  }
  /**
   * Returns a map of the modified persistable fields
   * @internal
   * @property {Object}
   * @category Editing
   */
  get rawModificationData() {
    const me = this, { fieldMap } = me.constructor, data = {};
    if (!me.isModified) {
      return null;
    }
    let keySet = false;
    Object.keys(me.meta.modified).forEach((fieldName) => {
      let field = fieldMap[fieldName], dataSource = field == null ? void 0 : field.dataSource;
      if (fieldName.includes(".")) {
        const topLevelFieldName = fieldName.match(nestedRe)[1];
        field = fieldMap[topLevelFieldName];
        dataSource = fieldName;
      }
      if (field == null ? void 0 : field.persist) {
        const value = me.getFieldPersistentValue(fieldName);
        if (value !== _undefined) {
          ObjectHelper.setPath(data, dataSource, value);
          keySet = true;
        }
      }
    });
    return keySet ? data : null;
  }
  /**
   * Get a map of the modified data fields along with any {@link Core/data/field/DataField#config-alwaysWrite} fields,
   * in form of an object. The fields *dataSource* is used as the property name in the returned object.
   * Used internally by AjaxStore / CrudManager when sending updates.
   * @property {Object}
   * @readonly
   * @category Editing
   */
  get modificationDataToWrite() {
    const alwaysWriteFields = this.constructor.alwaysWriteFields, recordData = this.modificationData;
    alwaysWriteFields.forEach((fieldName) => {
      recordData[this.getFieldDefinition(fieldName).dataSource] = this.getFieldPersistentValue(fieldName);
    });
    return recordData;
  }
  /**
   * Returns data for **all** {@link Core.data.field.DataField#config-persist persistable} fields in form of an
   * object, using dataSource if present.
   * @property {Object}
   * @internal
   * @readonly
   * @category Editing
   */
  get persistableData() {
    const me = this, data = {};
    me.fields.forEach((field) => {
      const value = me.getFieldPersistentValue(field);
      if (value !== _undefined) {
        if (field == null ? void 0 : field.complexMapping) {
          ObjectHelper.setPath(data, field.dataSource, value);
        } else {
          data[field.dataSource] = value;
        }
      }
    });
    return data;
  }
  get dataByFieldName() {
    const { data } = this;
    return this.fields.reduce((result, field) => {
      if (ObjectHelper.hasPath(data, field.dataSource)) {
        result[field.name] = data[field.dataSource];
      }
      return result;
    }, {});
  }
  /**
   * True if this models changes are currently being committed.
   * @property {Boolean}
   * @category Editing
   */
  get isCommitting() {
    return Boolean(this.meta.committing);
  }
  /**
   * Clear stored changes, used on commit. Does not revert changes.
   * @param {Boolean} [includeDescendants] Supply `false` to not clear node descendants
   * @privateparam {Boolean} [removeFromStoreChanges] Update related stores modified collection or not
   * @privateparam {Object|null} [changes] Set of changes to clear on the record
   * @category Editing
   */
  clearChanges(includeDescendants = true, removeFromStoreChanges = true, changes = null) {
    const me = this, { meta } = me;
    if (changes) {
      for (const key in changes) {
        delete meta.modified[key];
      }
    } else {
      meta.modified = {};
    }
    const noChanges = ObjectHelper.isEmpty(meta.modified);
    meta.committing = false;
    if (removeFromStoreChanges) {
      me.stores.forEach((store) => {
        noChanges && store.modified.remove(me);
        store.added.remove(me);
        if (includeDescendants) {
          const descendants = store.collectDescendants(me).all;
          store.added.remove(descendants);
          noChanges && store.modified.remove(descendants);
        }
      });
    }
  }
  storeFieldChange(key, oldValue) {
    this.meta.modified[key] = oldValue;
  }
  /**
   * Reverts changes in this back to their original values.
   * @privateparam {Boolean} [silent] Specify `true` to not trigger events.
   * @category Editing
   */
  revertChanges(silent = false) {
    this.isReverting = true;
    this.set(this.meta.modified, _undefined, silent);
    this.isReverting = false;
  }
  setByDataSource(rawChanges) {
    var _a2;
    const me = this, {
      fieldDataSourceMap
    } = me.constructor, rawChangesSimplePaths = ObjectHelper.pathifyKeys(rawChanges, fieldDataSourceMap), changes = {};
    for (const dataSource in rawChangesSimplePaths) {
      const field = fieldDataSourceMap[dataSource], propName = (_a2 = field == null ? void 0 : field.name) != null ? _a2 : dataSource;
      changes[propName] = rawChangesSimplePaths[dataSource];
    }
    return me.set(changes);
  }
  applyChangeset(rawChanges, phantomIdField = "$PhantomId", remote = true) {
    var _a2;
    const me = this, modelClass = me.constructor, {
      idField,
      fieldDataSourceMap
    } = modelClass, rawChangesSimplePaths = ObjectHelper.pathifyKeys(rawChanges, fieldDataSourceMap), ownChangesSimplePaths = ObjectHelper.pathifyKeys(me.modificationData), changes = {}, idChanged = phantomIdField in rawChanges && !(idField in rawChanges);
    if (!idChanged && phantomIdField in rawChangesSimplePaths) {
      delete rawChangesSimplePaths[phantomIdField];
    }
    for (const dataSource in rawChangesSimplePaths) {
      const field = fieldDataSourceMap[dataSource], propName = (_a2 = field == null ? void 0 : field.name) != null ? _a2 : dataSource;
      if (remote || ((field == null ? void 0 : field.name) === idField ? idChanged : rawChangesSimplePaths[dataSource] === ownChangesSimplePaths[dataSource])) {
        changes[propName] = rawChangesSimplePaths[dataSource];
      }
    }
    const wasSet = me.set(changes);
    me.clearChanges(false, true, remote ? null : changes);
    return wasSet ? Object.entries(wasSet).reduce((result, [field, change]) => {
      result[field] = change.value;
      return result;
    }, {}) : {};
  }
  //endregion
  //region Id
  /**
   * Gets the records internalId. It is assigned during creation, guaranteed to be globally unique among models.
   * @property {Number}
   * @category Identification
   */
  get internalId() {
    return this._internalId;
  }
  /**
   * Returns true if the record is new and has not been persisted (and received a proper id).
   * @property {Boolean}
   * @readonly
   * @category Identification
   */
  get isPhantom() {
    return this.id === "" || this.id == null || this.hasGeneratedId || Boolean(this.$isPhantom);
  }
  get isModel() {
    return true;
  }
  /**
   * Checks if record has a generated id.
   *
   * New records are assigned a generated id based on a UUID (starting with `_generated`), which is intended to be
   * temporary and should be replaced by the backend on commit.
   *
   * @property {Boolean}
   * @category Identification
   */
  get hasGeneratedId() {
    return typeof this.id === "string" && this.id.startsWith("_generated");
  }
  static generateId(text = this.$$name) {
    return `_generated${text}_${StringHelper.generateUUID()}`;
  }
  /**
   * Generates an id for a new record (a phantom id), based on a UUID (starting with `_generated`).
   *
   * Generated ids are intended to be temporary and should be replaced by the backend on commit.
   *
   * @category Identification
   * @returns {String}
   */
  generateId() {
    return this.constructor.generateId();
  }
  /**
   * Gets the id of specified model or model data object, or the value if passed string/number.
   * @param {Core.data.Model|String|Number} model
   * @returns {String|Number} id
   * @category Identification
   */
  static asId(model) {
    return (model == null ? void 0 : model.isModel) ? model.id : ObjectHelper.isObject(model) ? model[this.fieldMap.id.dataSource] : model;
  }
  //endregion
  //region JSON
  /**
   * Get the records data as a json string.
   *
   * ```javascript
   * const record = new Model({
   *     title    : 'Hello',
   *     children : [
   *         ...
   *     ]
   * });
   *
   * const jsonString = record.json;
   *
   * //jsonString:
   * '{"title":"Hello","children":[...]}'
   * ```
   *
   * @member {String}
   * @category JSON
   */
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  /**
   * Used by `JSON.stringify()` to correctly convert this record to json.
   *
   * In most cases no point in calling it directly.
   *
   * ```
   * // This will call `toJSON()`
   * const json = JSON.stringify(record);
   * ```
   *
   * If called manually, the resulting object is a clone of `record.data` + the data of any children:
   *
   * ```
   * const record = new Model({
   *     title    : 'Hello',
   *     children : [
   *         ...
   *     ]
   * });
   *
   * const jsonObject = record.toJSON();
   *
   * // jsonObject:
   * {
   *     title : 'Hello',
   *     children : [
   *         ...
   *     ]
   * }
   * ```
   *
   * @returns {Object}
   * @category JSON
   */
  toJSON() {
    const { children, unfilteredChildren } = this, jsonData = this.persistableData;
    if (unfilteredChildren || children) {
      jsonData[this.constructor.childrenField] = (unfilteredChildren || children).map((c) => c.toJSON());
    }
    return jsonData;
  }
  /**
   * Represent the record as a string, by default as a JSON string. Tries to use an abbreviated version of the
   * object's data, using id + name/title/text/label/description. If no such field exists, the full data is used.
   *
   * ```javascript
   * const record = new Model({ id : 1, name : 'Steve Rogers', alias : 'Captain America' });
   * console.log(record.toString()); // logs { "id" : 1, "name" : "Steve Rogers" }
   * ```
   *
   * @returns {String}
   * @category JSON
   */
  toString() {
    const me = this, nameField = abbreviationFields.find((field) => field in me.constructor.fieldMap), data = nameField ? { [me.constructor.idField]: me.id, [nameField]: me[nameField] } : me.data;
    return StringHelper.safeJsonStringify(data);
  }
  //endregion
  //region Batch
  /**
   * True if this Model is currently batching its changes.
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isBatchUpdating() {
    return Boolean(this.batching);
  }
  /**
   * Returns `true` if this Model currently has outstanding batched changes for the specified field name.
   * @param {String} fieldName The field name to check for batched updates on.
   * @returns {Boolean}
   * @category Editing
   */
  hasBatchedChange(fieldName) {
    var _a2, _b;
    return (_b = (_a2 = this.meta) == null ? void 0 : _a2.batchChanges) == null ? void 0 : _b[fieldName];
  }
  /**
   * Begin a batch, which stores changes and commits them when the batch ends.
   * Prevents events from being fired during batch.
   *
   * ```javascript
   * record.beginBatch();
   * record.name = 'Mr Smith';
   * record.team = 'Golden Knights';
   * record.endBatch();
   * ```
   *
   * Please note that you can also set multiple fields in a single call using {@link #function-set}, which in many
   * cases can replace using a batch:
   *
   * ```javascript
   * record.set({
   *   name : 'Mr Smith',
   *   team : 'Golden Knights'
   * });
   * ```
   * @category Editing
   * @privateparam {Boolean} silentUpdates Suppress firing the `batchUpdatedEvent`
   */
  beginBatch(silentUpdates = false) {
    const me = this;
    if (!me.batching) {
      me.batching = 0;
      me.meta.batchChanges = {};
    }
    if (silentUpdates) {
      me.$silenceBatch = (me.$silenceBatch || 0) + 1;
    }
    me.batching++;
  }
  /**
   * End a batch, triggering events if data has changed.
   * @param {Boolean} [silent] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [silent=false] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @privateparam {Boolean} [triggerBeforeUpdate=true]
   * @category Editing
  */
  endBatch(silent = false, skipAccessors = false, triggerBeforeUpdate = true) {
    const me = this, { parentIdField } = me.constructor;
    if (!me.batching) {
      return;
    }
    me.batching--;
    me.$silenceBatch && me.$silenceBatch--;
    if (me.batching > 0) {
      return;
    }
    if (!ObjectHelper.isEmpty(me.meta.batchChanges)) {
      let { batchChanges } = me.meta;
      me.meta.batchChanges = null;
      if (batchChanges[parentIdField]) {
        batchChanges = { ...batchChanges };
        me.parentId = batchChanges[parentIdField];
        delete batchChanges[parentIdField];
      }
      me.set(batchChanges, _undefined, silent, false, skipAccessors, void 0, triggerBeforeUpdate);
    }
  }
  /**
   * Cancels current batch operation. Any changes during the batch are discarded.
   * @category Editing
   */
  cancelBatch() {
    if (this.batching) {
      const me = this, { batchChanges } = me.meta, wasSet = {};
      me.batching = null;
      me.meta.batchChanges = null;
      me.generation++;
      if (!me.$silenceBatch) {
        Object.entries(batchChanges).forEach(([key, oldValue]) => {
          wasSet[key] = {
            oldValue,
            value: me[key]
          };
        });
        const event = {
          action: "update",
          record: me,
          records: [me],
          changes: wasSet
        };
        me.stores.forEach((store) => {
          store.trigger("batchedUpdate", { ...event });
        });
        me.forEachLinked((store, record) => {
          store.trigger("batchedUpdate", { ...event, record, records: [record] });
        });
      }
      me.$silenceBatch && me.$silenceBatch--;
    }
  }
  //endregion
  //region Events
  /**
   * Triggers beforeUpdate event for each store and checks if changes can be made from event return value.
   * @param {Object} changes Data changes
   * @returns {Boolean} returns true if data changes are accepted
   * @private
   */
  triggerBeforeUpdate(changes) {
    var _a2;
    return !((_a2 = this.stores) == null ? void 0 : _a2.some((s) => s.trigger("beforeUpdate", { record: this, changes }) === false));
  }
  //endregion
  //region Additional functionality
  /**
   * Makes a copy of this model, assigning the specified id or a generated id and also allowing you to pass field values to
   * the created copy.
   *
   * ```
   * const record = new Model({ name : 'Super model', hairColor : 'Brown' });
   * const clone = record.copy({ name : 'Super model clone' });
   * ```
   * @param {Number|String|Object} [newId] The id for the copied instance, or any field values to apply
   * (overriding the values from the source record). If no id provided, one will be auto-generated
   * @param {Boolean} [deep] True to also clone children
   * @returns {Core.data.Model} Copy of this model
   * @category Editing
   */
  copy(newId = null, deep) {
    const me = this, data = ObjectHelper.clone(me.data), idField = me.constructor.idField, useDeep = ObjectHelper.isObject(deep) ? deep.deep : deep;
    let id;
    if (newId && typeof newId === "object") {
      id = newId[idField];
      Object.assign(data, newId);
    } else {
      id = newId;
    }
    if (useDeep && me.children) {
      data.children = me.children.map((child) => child.copy(void 0, deep));
    } else {
      delete data.children;
      delete data.expanded;
    }
    if (me.$meta.fields.initable.length > 0) {
      const json = me.toJSON();
      for (const field of me.$meta.fields.initable) {
        data[field.name] = json[field.name];
      }
    }
    if (newId !== false) {
      data[idField] = id || me.generateId(me.firstStore);
    }
    const copy = new me.constructor(data, null, null, false, true);
    copy.originalInternalId = me.internalId;
    return copy;
  }
  // Copies data using the real field names to trigger setters
  copyData(fromRecord, raw, silent) {
    const propertiesAndValues = {};
    fromRecord.allFields.forEach(({ name: fieldName }) => {
      if (fieldName !== fromRecord.constructor.idField) {
        propertiesAndValues[fieldName] = raw ? fromRecord.get(fieldName) : fromRecord.getValue(fieldName);
      }
    });
    this.set(propertiesAndValues, null, silent);
  }
  /**
   * Removes this record from all stores (and in a tree structure, also from its parent if it has one).
   * @param {Boolean} [silent] Specify `true` to not trigger events. If event is recurring, occurrences won't be updated automatically.
   * @category Editing
   */
  remove(silent = false) {
    const me = this, { parent, stores } = me;
    if (parent) {
      parent.removeChild(me);
    } else if (stores.length && !me.isSpecialRow) {
      const storesCopy = stores.slice();
      storesCopy.forEach((s) => s.remove(me, silent, false, true));
    }
  }
  // Called by stores before removing the record from the store. Returning false prevents the removal (overridden in
  // ModelLink.js)
  beforeRemove(stores, records) {
    return super.beforeRemove(stores, records);
  }
  //endregion
  //region Validation
  /**
   * Check if record has valid data. Default implementation returns true, override in your model to do actual validation.
   * @property {Boolean}
   * @category Editing
   */
  get isValid() {
    return true;
  }
  //endregion
  //region Store
  /**
   * Get the first store that this model is assigned to.
   * @property {Core.data.Store}
   * @readonly
   * @category Misc
   */
  get firstStore() {
    return this.stores.length > 0 && this.stores[0];
  }
  /**
   * Joins this record and any children to specified store, if not already joined.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @category Misc
   */
  joinStore(store) {
    var _a2;
    const me = this, { stores } = me;
    if (!stores.includes(store)) {
      const { unjoinedStores } = me;
      super.joinStore(store);
      store.register(me);
      stores.push(store);
      if (unjoinedStores.includes(store)) {
        unjoinedStores.splice(unjoinedStores.indexOf(store), 1);
      }
      me.isLoaded && me.children.forEach((child) => child.joinStore(store));
      me.initRelations();
      if (store.tree && !me.isRoot && !((_a2 = store.stm) == null ? void 0 : _a2.isRestoring)) {
        me.instanceMeta(store.id).collapsed = !me.expanded;
      }
    }
  }
  /**
   * Unjoins this record and any children from specified store, if already joined.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @param {Boolean} [isReplacing] `true` if this record is being replaced
   * @category Misc
   */
  unjoinStore(store, isReplacing = false) {
    var _a2, _b, _c;
    const me = this, { stores, unjoinedStores } = me;
    if (stores.includes(store)) {
      if (!store.isDestroying) {
        store.unregister(me);
        unjoinedStores.push(store);
      }
      (_b = (_a2 = me.unfilteredChildren || me.children) == null ? void 0 : _a2.forEach) == null ? void 0 : _b.call(_a2, (child) => child.unjoinStore(store, isReplacing));
      stores.splice(stores.indexOf(store), 1);
      (_c = super.unjoinStore) == null ? void 0 : _c.call(this, store, isReplacing);
      store.uncacheRelatedRecord(me);
    }
  }
  /**
   * Returns true if this record is contained in the specified store, or in any store if store param is omitted.
   * @internal
   * @param {Core.data.Store} store Store to join
   * @returns {Boolean}
   * @category Misc
   */
  isPartOfStore(store) {
    if (store) {
      return store.includes(this);
    }
    return this.stores.length > 0;
  }
  /**
   * Returns true if this record is not part of any store.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  get isRemoved() {
    return !this.isPartOfStore();
  }
  //endregion
  //region Per instance meta
  /**
   * Used to set per external instance meta data. For example useful when using a record in multiple grids to store some state
   * per grid.
   * @param {String|Object} instanceOrId External instance id or the instance itself, if it has id property
   * @private
   * @category Misc
   */
  instanceMeta(instanceOrId) {
    var _a2;
    const { meta } = this, id = instanceOrId.id || instanceOrId;
    return ((_a2 = meta.map) == null ? void 0 : _a2[id]) || this.setInstanceMeta(id, {});
  }
  setInstanceMeta(instanceOrId, value) {
    const { meta } = this, id = instanceOrId.id || instanceOrId;
    if (!meta.map) {
      meta.map = {};
    }
    return meta.map[id] = value;
  }
  /**
   * When called on a group header row returns list of records in that group. Returns `undefined` otherwise.
   * @member {Core.data.Model[]|undefined} groupChildren
   * @category Grouping
   * @readonly
   */
  /**
   * Returns true for a group header record
   * @member {Boolean}
   * @category Grouping
   * @readonly
   */
  get isGroupHeader() {
    return "groupRowFor" in this.meta;
  }
  get isGroupFooter() {
    return "groupFooterFor" in this.meta;
  }
  get isSpecialRow() {
    var _a2;
    return Boolean((_a2 = this.meta) == null ? void 0 : _a2.specialRow);
  }
  get $original() {
    return this.isLinked ? this.proxyMeta.originalRecord : this;
  }
  //endregion
  static get nonPersistableFields() {
    const me = this;
    if (!me._nonPersistableFields) {
      me._nonPersistableFields = {};
      me.allFields.forEach((field) => {
        if (!field.persist || field.calculated) {
          me._nonPersistableFields[field.name] = 1;
        }
      });
    }
    return me._nonPersistableFields;
  }
  static get alwaysWriteFields() {
    const me = this;
    if (!me._alwaysWriteFields) {
      me._alwaysWriteFields = [];
      me.allFields.forEach((field) => {
        if (field.alwaysWrite) {
          me._alwaysWriteFields.push(field.name);
        }
      });
    }
    return me._alwaysWriteFields;
  }
  // Id with spaces and dots replaced by -, for safe usage as an id in DOM
  get domId() {
    return typeof this.id === "string" ? this.id.replace(/[ .]/g, "-") : this.id;
  }
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  // Convert custom modelClass to string, keeping custom fields
  static toJavaScriptValue(options) {
    const { names } = this.$meta, className = names[names.length - 2], superName = names[names.length - 3];
    return `class ${className} extends ${superName} { static fields = ${StringHelper.toJavaScriptValue(this.fields, options)}; }`;
  }
  // Get fields current values
  getCurrentConfig(options) {
    const { data, children } = this, { defaultValues, applyConfigs } = this.constructor, result = applyConfigs ? super.getCurrentConfig(options) : {};
    if (result) {
      for (const field of this.fields) {
        if (field.persist) {
          const value = ObjectHelper.getPath(data, field.dataSource);
          if (!field.isEqual(value, defaultValues[field.name])) {
            ObjectHelper.setPath(result, field.dataSource, Base.processConfigValue(value, options));
          }
        }
      }
      if (children) {
        if (Array.isArray(children)) {
          result.children = [];
          for (const child of children) {
            result.children.push(child.getCurrentConfig(options));
          }
        } else {
          result.children = children;
        }
      }
      if (this.hasGeneratedId) {
        delete result.id;
      }
      delete result.parentId;
      delete result.parentIndex;
    }
    return result;
  }
  //endregion
};
/**
 * Override in a subclass of Model to define relations to records in other stores.
 *
 * Always defined on the "one" side, not the "many" side.
 *
 * Expects an object where keys are relation names and values are {@link #typedef-RelationConfig relation configs}.
 *
 * This snippet will define a relation called `team`, allowing access to the foreign record via `player.team`. It
 * will point to a record in the `teamStore` (must be available as `record.firstStore.teamStore)` with an id
 * matching the players `teamId` field. The team record in turn, will have a field called `players` which is a
 * collection of all players in the team.
 *
 * ```javascript
 * class Player extends Model {
 *     static relations = {
 *         // Define a relation between a player and a team
 *         team : {
 *             foreignKey            : 'teamId',
 *             foreignStore          : 'teamStore',
 *             relatedCollectionName : 'players'
 *         }
 *     }
 * }
 *
 * const teamStore = new Store({
 *     data : [
 *         { id : 1, name : 'Brynas' },
 *         { id : 2, name : 'Leksand' }
 *     ]
 * });
 *
 * const playerStore = new Store({
 *     modelClass : Player,
 *     // Matches foreignStore, allowing records of playerStore to find the related store
 *     teamStore,
 *     data       : [
 *         // teamId is specified as foreignKey, will be used to match the team
 *         { id : 1, name : 'Nicklas Backstrom', teamId : 1  },
 *         { id : 2, name : 'Elias Lindholm',   teamId : 1  },
 *         { id : 3, name : 'Filip Forsberg',  teamId : 2  }
 *     ],
 * }
 *
 * playerStore.first.team.name // > Brynas
 * playerStore.last.team.name // > Leksand
 * teamStore.first.players // > [nick, elias]
 * teamStore.last.players // > [filip]
 * ```
 *
 * To access the related record from the many side, use dot notation for the field name. For example in a Grid
 * column:
 *
 * ```javascript
 * const grid = new Grid({
 *    store : playerStore,
 *    columns : [
 *        { field : 'name', text : 'Name' },
 *        { field : 'team.name', text : 'Team' }
 *    ]
 * });
 * ```
 *
 * @member {Object<String,RelationConfig>} relations
 * @static
 */
__publicField(_Model, "relations", null);
var Model = _Model;
Model._idField = "id";
Model._internalIdCounter = 1;
Model._assignedIdField = false;
Model.exposeProperties();
Model._$name = "Model";

// ../Core/lib/Core/data/Duration.js
var Duration = class _Duration {
  /**
   * Duration constructor.
   * @param {Number|String} magnitude Duration magnitude value or a duration + magnitude string ('2h', '4d')
   * @param {String} [unit] Duration unit value
   */
  constructor(magnitude, unit) {
    if (typeof magnitude === "number" || magnitude === null) {
      this._magnitude = magnitude;
      this._unit = unit;
    } else {
      if (typeof magnitude === "string") {
        Object.assign(this, DateHelper.parseDuration(magnitude));
      }
      if (typeof magnitude === "object") {
        Object.assign(this, magnitude);
      }
    }
  }
  /**
   * Get/Set numeric magnitude `value`.
   * @property {Number}
   */
  get magnitude() {
    return this._magnitude;
  }
  set magnitude(value) {
    this._magnitude = typeof value === "number" && value;
  }
  /**
   * Get/Set duration unit to use with the current magnitude value.
   * Valid values are:
   * - "millisecond" - Milliseconds
   * - "second" - Seconds
   * - "minute" - Minutes
   * - "hour" - Hours
   * - "day" - Days
   * - "week" - Weeks
   * - "month" - Months
   * - "quarter" - Quarters
   * - "year"- Years
   *
   * @member {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}
   */
  get unit() {
    return this._unit;
  }
  set unit(value) {
    this._unit = DateHelper.parseTimeUnit(value);
  }
  get isValid() {
    return this._magnitude != null && Boolean(DateHelper.normalizeUnit(this._unit));
  }
  /**
   * The `milliseconds` property is a read only property which returns the number of milliseconds in this Duration
   * @property {Number}
   * @readonly
   */
  get milliseconds() {
    return this.isValid ? Math.round(DateHelper.asMilliseconds(this._magnitude, this._unit)) : 0;
  }
  /**
   * Returns truthy value if this Duration equals the passed value.
   * @param {Core.data.Duration} value
   * @returns {Boolean}
   */
  isEqual(value) {
    return Boolean(value) && this._magnitude != null && value._magnitude != null && this.milliseconds === value.milliseconds;
  }
  toString(useAbbreviation) {
    const me = this, abbreviationFn = useAbbreviation ? "getShortNameOfUnit" : "getLocalizedNameOfUnit";
    return me.isValid ? `${me._magnitude} ${DateHelper[abbreviationFn](me._unit, me._magnitude !== 1)}` : "";
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    return this.milliseconds;
  }
  diff(otherDuration) {
    return new _Duration({
      unit: this.unit,
      magnitude: DateHelper.as(this.unit, this.milliseconds - otherDuration.milliseconds)
    });
  }
};
Duration._$name = "Duration";

// ../Core/lib/Core/util/CollectionFilter.js
var nestedValueReducer = (object, path) => object == null ? void 0 : object[path];
var relativeDateUnitRegExp = /^is(this|next|last)(week|month|year)$/i;
var relativeDateOperators = [
  "isToday",
  "isTomorrow",
  "isYesterday",
  "isThisWeek",
  "isNextWeek",
  "isLastWeek",
  "isThisMonth",
  "isNextMonth",
  "isLastMonth",
  "isThisYear",
  "isNextYear",
  "isLastYear",
  "isYearToDate"
];
var _CollectionFilter = class _CollectionFilter extends Base.mixin(Identifiable_default) {
  static get defaultConfig() {
    return {
      /**
       * The value against which to compare the {@link #config-property} of candidate objects.
       * @config {*}
       */
      value: null,
      /**
       * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
       * May be:
       * `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`,
       * `'startsWith'`, `'endsWith'`, `'isIncludedIn'`, `'includes'`, `'doesNotInclude'`,
       * `'empty'`, `'notEmpty'`, `'between'`, `'notBetween'`, `'sameDay'`,
       * `'isToday'`, `'isTomorrow'`, `'isYesterday'`, `'isThisWeek'`, `'isLastWeek'`, `'isNextWeek'`, `'isThisMonth'`,
       * `'isLastMonth'`, `'isNextMonth'`, `'isThisYear'`, `'isLastYear'`, `'isNextYear'`, `'isYearToDate`',
       * `'isTrue'`, `'isFalse'`
       * @config {'='|'!='|'>'|'>='|'<'|'<='|'*'|'startsWith'|'endsWith'|'isIncludedIn'|'isNotIncludedIn'|'includes'|'doesNotInclude'|'empty'|'notEmpty'|'between'|'notBetween'|'sameDay'|'isToday'|'isTomorrow'|'isYesterday'|'isThisWeek'|'isLastWeek'|'isNextWeek'|'isThisMonth'|'isLastMonth'|'isNextMonth'|'isThisYear'|'isLastYear'|'isNextYear'|'isYearToDate'|'isTrue'|'isFalse'}
       */
      operator: null,
      /**
       * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
       * accepts a candidate object and returns `true` or `false`
       * @config {Function}
       * @param {*} data Data object for filtering
       * @returns {Boolean}
       */
      filterBy: null,
      /**
       * A function which accepts a value extracted from a candidate object using the {@link #config-property} name, and
       * returns the value which the filter should use to compare against its {@link #config-value}.
       * @config {Function}
       * @param {*} value
       * @returns {*}
       */
      convert: null,
      /**
       * Configure as `false` to have string comparisons case insensitive.
       * @config {Boolean}
       * @default
       */
      caseSensitive: true,
      /**
       * The `id` of this Filter for when used by a {@link Core.util.Collection} Collection.
       * By default the `id` is the {@link #config-property} value.
       * @config {String}
       */
      id: null,
      // Type is required to process the Date value in State API. Store doesn't always know about field type to
      // process filter value, when it applies it from the state, e.g. when you don't declare model field as `date`
      // type but provide a Date instance there. When DateColumn is used to shows this field, it could add date
      // filters to the store. When store is applying state it cannot just infer type, because model doesn't
      // declare it. Only column knows. So to properly process the Date instance for the filter State API would
      // have to process the field additionally, checking model field type and column type. So it is simpler to
      // make Filter to put this information. That way when filter is instantiated by the store, it can gracefully
      // handle value processing, converting date string to the Date instance.
      // Date is the only known value type so far which requires this processing.
      type: null,
      /**
       * Setting the `internal` config on a filter means that it is a fixed part of your store's operation.
       *
       * {@link Core.data.Store#function-clearFilters} does not remove `internal` filters. If you add an
       * `internal` filter, you must explicitly remove it if it is no longer required.
       *
       * Grid features which offer column-based filtering do *not* ingest existing store filters on
       * their data field if the filter is `internal`
       * @config {Boolean}
       * @default false
       */
      internal: null,
      /**
       * When `true`, the filter will not be applied.
       * @config {Boolean}
       * @default
       */
      disabled: false
    };
  }
  static get configurable() {
    return {
      /**
       * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
       * @member {String} property
       */
      /**
       * The name of a property of candidate objects which yields the value to compare against this CollectionFilter's {@link #config-value}.
       * @config {String}
       */
      property: null
    };
  }
  construct(config) {
    if (typeof config === "function") {
      config = {
        filterBy: config
      };
    }
    if (!config.type) {
      if (DateHelper.isDate(config.value) || Array.isArray(config.value) && config.value.every(DateHelper.isDate)) {
        config.type = "date";
      } else if (config.value instanceof Duration) {
        config.type = "duration";
      }
    } else {
      if (config.type === "date" && config.value != null && !Array.isArray(config.value)) {
        config.value = new Date(config.value);
      } else if (config.type === "duration" && config.value != null && !Array.isArray(config.value)) {
        config.value = new Duration(config.value);
      }
    }
    super.construct(config);
  }
  /**
   * When in a Collection (A Collection holds its Filters in a Collection), we need an id.
   * @property {String}
   * @private
   */
  get id() {
    if (!this._id) {
      if (this.internal) {
        this._id = _CollectionFilter.generateId(`b-internal-${this.property}-filter-`);
      } else {
        this._id = this.property || _CollectionFilter.generateId("b-filter-");
      }
    }
    return this._id;
  }
  set id(id) {
    this._id = id;
  }
  onChange(propertyChanged) {
    var _a2;
    const me = this;
    if (!me.isConfiguring && ((_a2 = me.owner) == null ? void 0 : _a2.onFilterChanged) && !me.owner.isConfiguring) {
      me.owner.onFilterChanged(me, propertyChanged);
    }
  }
  get filterBy() {
    return this._filterBy || this.defaultFilterBy;
  }
  /**
   * May be used in place of the {@link #config-property}, {@link #config-value} and {@link #config-property} configs. A function which
   * accepts a candidate object and returns `true` or `false`
   * @type {Function}
   * @param {*} data Data object for filtering
   * @returns {Boolean} Returns `true` for data valid for including
   */
  set filterBy(filterBy) {
    this._filterBy = filterBy;
  }
  defaultFilterBy(candidate) {
    const me = this;
    let candidateValue;
    if (candidate.isModel) {
      candidateValue = candidate.getValue(me.property);
    } else if (me._propertyItems.length > 1) {
      candidateValue = me._propertyItems.reduce(nestedValueReducer, candidate);
    } else {
      candidateValue = candidate[me.property];
    }
    return me[me.operator](me.convert(candidateValue));
  }
  updateProperty(property) {
    this._propertyItems = property.split(".");
    this.onChange("property");
  }
  /**
   * The value against which to compare the {@link #config-property} of candidate objects.
   * @type {*}
   */
  set value(value) {
    const me = this;
    me._value = value;
    if (Array.isArray(value) && ({ date: 1, duration: 1 }[me.type] || value.length > 0 && typeof value[0] === "string")) {
      me._filterValue = value.map((v) => me.convert(v));
    } else if (!me.caseSensitive && Array.isArray(value) && value.length > 0 && typeof value[0] === "string") {
      me._filterValue = value.map((s) => s == null ? void 0 : s.toLowerCase());
    } else if (!me.caseSensitive && typeof value === "string") {
      me._filterValue = value.toLowerCase();
    } else {
      me._filterValue = me.convert(value);
    }
    me.onChange("value");
  }
  get value() {
    return this._value;
  }
  get filterValue() {
    return this._filterValue;
  }
  /**
   * The operator to use when comparing a candidate object's {@link #config-property} with this CollectionFilter's {@link #config-value}.
   * May be:
   * `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`,
   * `'startsWith'`, `'endsWith'`, `'isIncludedIn'`, `'includes'`, `'doesNotInclude'`,
   * `'empty'`, `'notEmpty'`, `'between'`, `'notBetween'`,
   * `'isToday'`, `'isTomorrow'`, `'isYesterday'`, `'isThisWeek'`, `'isLastWeek'`, `'isNextWeek'`, `'isThisMonth'`,
   * `'isLastMonth'`, `'isNextMonth'`, `'isThisYear'`, `'isLastYear'`, `'isNextYear'`, `'isYearToDate`',
   * `'isTrue'`, `'isFalse'`
   * @type {'='|'!='|'>'|'>='|'<'|'<='|'*'|'startsWith'|'endsWith'|'isIncludedIn'|'isNotIncludedIn'|'includes'|'doesNotInclude'|'empty'|'notEmpty'|'between'|'notBetween'|'isToday'|'isTomorrow'|'isYesterday'|'isThisWeek'|'isLastWeek'|'isNextWeek'|'isThisMonth'|'isLastMonth'|'isNextMonth'|'isThisYear'|'isLastYear'|'isNextYear'|'isYearToDate'|'isTrue'|'isFalse'}
   */
  set operator(operator) {
    this._operator = operator;
    this.onChange("operator");
  }
  get operator() {
    const me = this;
    if (me._operator) {
      return me._operator;
    }
    if (Array.isArray(me.filterValue)) {
      return "isIncludedIn";
    }
    return typeof me.filterValue === "string" ? "*" : "=";
  }
  convert(value) {
    var _a2;
    if (this.operator !== "sameTime" && !(typeof this.filterValue === "string" && value instanceof Date)) {
      if (this.operator === "sameDay") {
        value = DateHelper.clearTime(value);
      }
      value = (_a2 = value == null ? void 0 : value.valueOf()) != null ? _a2 : value;
    }
    value = !this.caseSensitive && typeof value === "string" ? value.toLowerCase() : value;
    return value;
  }
  filter(candidate) {
    return this.filterBy(candidate);
  }
  startsWith(v) {
    return String(v).startsWith(this.filterValue);
  }
  endsWith(v) {
    return String(v).endsWith(this.filterValue);
  }
  isIncludedIn(v) {
    return this.filterValue.length === 0 || this.filterValue.includes(v);
  }
  isNotIncludedIn(v) {
    return !this.isIncludedIn(v);
  }
  includes(v) {
    return this.filterValue.length === 0 || String(v).includes(this.filterValue);
  }
  doesNotInclude(v) {
    return !this.includes(v);
  }
  sameTime(v) {
    return DateHelper.isSameTime(v, this.filterValue);
  }
  sameDay(v) {
    return v === this.filterValue;
  }
  "="(v) {
    return ObjectHelper.isEqual(v, this.filterValue);
  }
  "!="(v) {
    return !ObjectHelper.isEqual(v, this.filterValue);
  }
  ">"(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue);
  }
  ">="(v) {
    return ObjectHelper.isMoreThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  "<"(v) {
    return ObjectHelper.isLessThan(v, this.filterValue);
  }
  "<="(v) {
    return ObjectHelper.isLessThan(v, this.filterValue) || ObjectHelper.isEqual(v, this.filterValue);
  }
  "*"(v) {
    return ObjectHelper.isPartial(v, this.filterValue);
  }
  between(v) {
    const [start, end] = this._filterValue;
    return (ObjectHelper.isMoreThan(v, start) || ObjectHelper.isEqual(v, start)) && (ObjectHelper.isLessThan(v, end) || ObjectHelper.isEqual(v, end));
  }
  notBetween(v) {
    return !this.between(v);
  }
  empty(v) {
    return v === void 0 || v === null || String(v).length === 0;
  }
  notEmpty(v) {
    return !this.empty(v);
  }
  isToday(v) {
    return this.between(v);
  }
  isTomorrow(v) {
    return this.between(v);
  }
  isYesterday(v) {
    return this.between(v);
  }
  isThisWeek(v) {
    return this.between(v);
  }
  isNextWeek(v) {
    return this.between(v);
  }
  isLastWeek(v) {
    return this.between(v);
  }
  isThisMonth(v) {
    return this.between(v);
  }
  isNextMonth(v) {
    return this.between(v);
  }
  isLastMonth(v) {
    return this.between(v);
  }
  isThisYear(v) {
    return this.between(v);
  }
  isNextYear(v) {
    return this.between(v);
  }
  isLastYear(v) {
    return this.between(v);
  }
  isYearToDate(v) {
    return this.between(v);
  }
  isTrue(v) {
    return v === true;
  }
  isFalse(v) {
    return v === false;
  }
  // Fill in actual dates relative to now
  setRelativeDateValues() {
    this._filterValue = _CollectionFilter.getRelativeDateRange(this._operator).map((date) => date.valueOf());
  }
  static getRelativeDateRange(relativeExpr, now2 = /* @__PURE__ */ new Date()) {
    let todayStart, tomorrowStart, parts, oneTimeUnit, unitStart, which, timeUnit;
    switch (relativeExpr) {
      case "isYearToDate":
        return [DateHelper.floor(now2, "1 year"), now2];
      case "isToday":
        todayStart = DateHelper.floor(now2, "1 day");
        return [todayStart, DateHelper.add(todayStart, 1, "day")];
      case "isYesterday":
        todayStart = DateHelper.floor(now2, "1 day");
        return [DateHelper.add(todayStart, -1, "day"), todayStart];
      case "isTomorrow":
        tomorrowStart = DateHelper.getStartOfNextDay(now2);
        return [tomorrowStart, DateHelper.add(tomorrowStart, 1, "day")];
      case "isThisWeek":
      case "isNextWeek":
      case "isLastWeek":
      case "isThisMonth":
      case "isNextMonth":
      case "isLastMonth":
      case "isThisYear":
      case "isNextYear":
      case "isLastYear":
        parts = relativeExpr.toLowerCase().match(relativeDateUnitRegExp);
        if (!parts) {
          throw new Error(`Unrecognized relative date expression: ${relativeExpr}`);
        }
        [, which, timeUnit] = parts;
        oneTimeUnit = `1 ${timeUnit}`;
        unitStart = DateHelper.floor(now2, oneTimeUnit);
        if (which === "next") {
          unitStart = DateHelper.add(unitStart, 1, timeUnit);
        } else if (which === "last") {
          unitStart = DateHelper.add(unitStart, -1, timeUnit);
        }
        return [unitStart, DateHelper.add(unitStart, 1, timeUnit)];
    }
  }
  // Accepts an array or a Collection
  static generateFiltersFunction(filters) {
    if (!filters || !filters.length && !filters.count) {
      return FunctionHelper.returnTrue;
    }
    for (const filter2 of filters) {
      if (filter2.type === "date" && relativeDateOperators.includes(filter2._operator)) {
        filter2.setRelativeDateValues();
      }
    }
    return function(candidate) {
      let match = true;
      for (const filter2 of filters) {
        if (!filter2.disabled) {
          match = filter2.filter(candidate);
        }
        if (!match) {
          break;
        }
      }
      return match;
    };
  }
};
__publicField(_CollectionFilter, "$name", "CollectionFilter");
var CollectionFilter = _CollectionFilter;
CollectionFilter._$name = "CollectionFilter";

// ../Core/lib/Core/helper/IdHelper.js
var idCounts2 = ObjectHelper.getPathDefault(globalThis, "bryntum.idCounts", /* @__PURE__ */ Object.create(null));
var IdHelper = class {
  /**
   * Generate a new id, using IdHelpers internal counter and a prefix
   * @param {String} prefix Id prefix
   * @returns {String} Generated id
   */
  static generateId(prefix = "generatedId") {
    return prefix + (idCounts2[prefix] = (idCounts2[prefix] || 0) + 1);
  }
};
IdHelper._$name = "IdHelper";

// ../Core/lib/Core/util/CollectionSorter.js
var CollectionSorter = class extends Base {
  static get defaultConfig() {
    return {
      /**
       * The name of a property of collection objects which yields the value to sort by.
       * @config {String}
       */
      property: null,
      /**
       * The direction to sort in, `'ASC'` or `'DESC'`
       * @config {'ASC'|'DESC'}
       * @default
       */
      direction: "ASC",
      /**
       * A function which takes the place of using {@link #config-property} and {@link #config-direction}.
       * The function is passed two objects from the collection to compare and must return the comparison result.
       * @config {Function}
       * @param {*} first The first value to compare
       * @param {*} second The second value to compare
       * @returns {Number}  Returns `1` if first value is greater than second value, `-1` if the opposite is true or `0` if they're equal
       */
      sortFn: null,
      /**
       * When using {@link #config-property}, this may be specified as a function which takes the raw
       * property value and returns the value to actually sort by.
       * @config {Function}
       * @param {*} value
       * @returns {*}
       */
      convert: null,
      /**
       * The `id` of this Sorter for when used by a {@link Core.util.Collection} Collection.
       * By default the `id` is the {@link #config-property} value.
       * @config {String}
       */
      id: null,
      /**
       * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
       * a locale string or a locale config to enable.
       *
       * Enabling this has big negative impact on sorting performance. For more info on `localeCompare()`, see
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
       *
       * ```javascript
       * collection.addSorter({ field: 'name', useLocaleSort : 'sv-SE' });
       * ```
       *
       * @config {Boolean|String|Object}
       * @default false
       */
      useLocaleSort: null
    };
  }
  construct(config) {
    if (typeof config === "function") {
      config = {
        sortFn: config
      };
    }
    super.construct(config);
  }
  /**
   * When in a Collection (A Collection holds its Sorters in a Collection), we need an id.
   * @property {String}
   * @private
   */
  get id() {
    return this._id || (this._id = this.property || IdHelper.generateId("b-sorter"));
  }
  set id(id) {
    this._id = id;
  }
  set sortFn(sortFn) {
    this._sortFn = sortFn;
  }
  get sortFn() {
    if (this._sortFn) {
      return this._sortFn;
    }
    return this.defaultSortFn;
  }
  /**
   * Default sortFn used when no sortFn specified. Uses the {@link #config-property},
   * {@link #config-direction}, and {@link #config-convert}.
   * @private
  */
  defaultSortFn(lhs, rhs) {
    const me = this, { convert, property, useLocaleSort } = me, multiplier = me.direction.toLowerCase() === "desc" ? -1 : 1;
    lhs = lhs[property];
    rhs = rhs[property];
    if (convert) {
      lhs = convert(lhs);
      rhs = convert(rhs);
    }
    if (useLocaleSort && lhs != null && rhs != null && typeof lhs === "string") {
      if (useLocaleSort === true) {
        return String(lhs).localeCompare(rhs);
      }
      if (typeof useLocaleSort === "string") {
        return String(lhs).localeCompare(rhs, useLocaleSort);
      }
      if (typeof useLocaleSort === "object") {
        return String(lhs).localeCompare(rhs, useLocaleSort.locale, useLocaleSort);
      }
    }
    return (lhs > rhs ? 1 : lhs < rhs ? -1 : 0) * multiplier;
  }
  static generateSortFunction(sorters, tieBreaker) {
    const items2 = sorters.isCollection ? sorters.values : sorters, n = items2.length;
    return (lhs, rhs) => {
      let comp, i;
      for (i = 0; i < n; ++i) {
        comp = items2[i].sortFn(lhs, rhs);
        if (comp) {
          return comp;
        }
      }
      return tieBreaker ? tieBreaker(lhs, rhs) : 0;
    };
  }
};
CollectionSorter._$name = "CollectionSorter";

// ../Core/lib/Core/util/Collection.js
var return0 = () => 0;
var reverseNumericSortFn = (a, b) => b - a;
var filteredIndicesProperty = Symbol("filteredIndicesProperty");
var emptyArray3 = Object.freeze([]);
var sortEvent = Object.freeze({
  action: "sort",
  added: emptyArray3,
  removed: emptyArray3,
  replaced: emptyArray3
});
var filterEvent = Object.freeze({
  action: "filter",
  added: emptyArray3,
  removed: emptyArray3,
  replaced: emptyArray3
});
var keyTypes = {
  string: 1,
  number: 1
};
function addItemToIndex(item, index, key, detectDuplicates) {
  if (index.unique !== false) {
    index.set(key, item);
    if (detectDuplicates) {
      index.count++;
    }
  } else {
    let set = index.get(key);
    if (!set) {
      set = /* @__PURE__ */ new Set();
      index.set(key, set);
    }
    set.add(item);
  }
}
function removeItemFromIndex(item, index, key) {
  if (index.unique !== false) {
    index.delete(key);
  } else if (index.has(key)) {
    index.get(key).delete(item);
    if (!index.get(key).size) {
      index.delete(key);
    }
  }
}
function doRebuildIndices(values, indices, keyProps, indexCount, ignoreDetectDuplicates = false) {
  for (let i = 0; i < values.length; i++) {
    const item = values[i];
    for (let j = 0; j < indexCount; j++) {
      const keyProp = keyProps[j], key = item[keyProp], index = indices[keyProp];
      addItemToIndex(item, index, key, !ignoreDetectDuplicates && index.onDuplicate);
    }
  }
}
var Collection = class _Collection extends Base.mixin(Events_default) {
  constructor() {
    super(...arguments);
    __publicField(this, "_sortFunction", null);
    __publicField(this, "_addedValues", null);
  }
  //region Config
  static get configurable() {
    return {
      /**
       * Specify the name of the property of added objects which provides the lookup key
       * @config {String}
       * @default
       */
      idProperty: "id",
      /**
       * Specify the names or index configs of properties which are to be indexed for fast lookup.
       *
       * Index configs use the format `{ property : string, unique : boolean }`. Unique indices stores one index
       * per entry, non-unique stores a `Set`. If left out, `unique` defaults to `true`
       *
       * @config {String[]|Object[]}
       * @property {String} property Property to index by
       * @property {Boolean} [unique=true] `true` for unique keys (~primary keys), `false` for non-unique keys
       * (~foreign keys)
       */
      extraKeys: null,
      /**
       * Automatically apply filters on item add.
       * @config {Boolean}
       * @default
       */
      autoFilter: true,
      /**
       * Automatically apply sorters on item add.
       * @config {Boolean}
       * @default
       */
      autoSort: true,
      /**
       * A {@link Core.util.CollectionSorter Sorter}, or Sorter config object, or
       * an array of these, to use to sort this Collection.
       * @config {CollectionSorterConfig[]}
       * @default
       */
      sorters: {
        $config: ["lazy"],
        value: []
      }
    };
  }
  get isCollection() {
    return true;
  }
  //endregion
  //region Init & destroy
  construct(config) {
    this.generation = 0;
    this._values = [];
    super.construct(config);
  }
  doDestroy() {
    var _a2;
    super.doDestroy();
    const me = this;
    me._values.length = 0;
    if (me.isFiltered) {
      me._filteredValues.length = 0;
      me.filters.destroy();
    }
    (_a2 = me._sorters) == null ? void 0 : _a2.destroy();
  }
  //endregion
  //region "CRUD"
  /**
   * Clears this collection.
   */
  clear() {
    const me = this, removed = me._values.slice();
    if (me.totalCount) {
      me._values.length = 0;
      if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
      me._indicesInvalid = true;
      me.generation++;
      me.trigger("change", {
        action: "clear",
        removed
      });
    }
  }
  /**
   * Compares the content of this Collection with the content of the passed Collection or
   * with the passed array. Order insensitive. This returns `true` if the two objects passed
   * contain the same set of items.
   * @param {Core.util.Collection|Array} other The Collection or array to compare with.
   * @param {Function} [map] Optionally a function to convert the items into a comparable object
   * to compare. For example `item => item.id` could be used to compare the ids of the
   * constituent items.
   * @returns {Boolean} `true` if the two objects passed have the same content.
   */
  equals(other, map2) {
    if (other.isCollection) {
      other = other.values;
    }
    if (other.length === this.count) {
      let { values } = this;
      if (map2) {
        other = other.map(map2);
        values = values.map(map2);
      }
      return ArrayHelper.delta(other, values).inBoth.length === this.count;
    }
    return false;
  }
  /**
   * Replaces the internal `values` array with the passed `values`, or `filteredValues` array with the passed `filteredValues`.
   * If `filteredValues` are not passed explicitly, but storage is filtered, decides internally `values` or `filteredValues` should
   * be replaced by passed `values`.
   *
   * Note that this takes ownership of the array, and the array must not be mutated by outside code.
   *
   * This is an internal utility method, not designed for use by application code.
   *
   * @param {Object} params Values and parameters to replace
   * @param {Object[]} params.values The new `values` array
   * @param {Object[]} [params.filteredValues] The new `filteredValues` array. Applicable only when storage is filtered.
   * @param {Boolean} [params.silent=false] If true, `change` event will not be fired
   * @param {Boolean} [params.isNewDataset=false] If true, `values` is a new dataset
   * @fires change
   * @internal
   */
  replaceValues({ values, filteredValues, silent = false, isNewDataset = false }) {
    const me = this;
    let replacedValues, replacedFilteredValues;
    if (me.isFiltered && !isNewDataset) {
      const filteredPassed = Boolean(filteredValues);
      if (!filteredPassed) {
        filteredValues = values.slice();
        values = null;
      } else if (values) {
        replacedValues = me._values;
        me._values = values.slice();
      }
      replacedFilteredValues = me._filteredValues;
      me._filteredValues = filteredValues.slice();
    } else {
      replacedValues = me._values;
      me._values = values.slice();
      filteredValues = null;
      if (me.isFiltered && isNewDataset && me.autoFilter) {
        me._filterFunction = null;
        me._filteredValues = me._values.filter(me.filterFunction);
      } else if (me._filteredValues) {
        me._filteredValues.length = 0;
      }
    }
    me._indicesInvalid = true;
    me._addedValues = void 0;
    me.generation++;
    if (!silent) {
      me.trigger("change", {
        action: "replaceValues",
        replacedValues,
        replacedFilteredValues,
        values,
        filteredValues
      });
    }
  }
  set values(values) {
    this.invalidateIndices();
    this.splice(0, this._values.length, values);
  }
  /**
   * The set of values of this Collection. If this Collection {@link #property-isFiltered},
   * this yields the filtered data set.
   *
   * Setting this property replaces the data set.
   * @property {Object[]}
   */
  get values() {
    return this.isFiltered ? this._filteredValues : this._values;
  }
  /**
   * The set of filtered values of this Collection (those matching the current filters).
   * @property {Object[]}
   * @private
   */
  get filteredValues() {
    return this._filteredValues;
  }
  /**
   * Iterator that allows you to do `for (const item of collection)`
   */
  [Symbol.iterator]() {
    return this.values[Symbol.iterator]();
  }
  /**
   * Executes the passed function for each item in this Collection, passing in the item,
   * ths index, and the full item array.
   * @param {Function} fn The function to execute.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to include all items, bypassing filters.
   */
  forEach(fn2, ignoreFilters = false) {
    (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).forEach(fn2);
  }
  /**
   * Extracts ths content of this Collection into an array based upon the passed
   * value extraction function.
   * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to process an item even if it is filtered out.
   * @returns {Object[]} An array of values extracted from this Collection.
   */
  map(fn2, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).map(fn2);
  }
  /**
   * Returns an accumulated value based on the passed function similar to `Array.reduce`.
   * @param {Function} fn A function, which, when passed an accumulator value and an item, returns the new accumulator value.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to process an item even if it is filtered out.
   * @param {*} [accumulator=[]] The initial value of the accumulator.
   * @returns {*} the final accumulator value.
   */
  reduce(fn2, ignoreFilters = false, accumulator = []) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).reduce(fn2, accumulator);
  }
  /**
   * Returns the first item in this Collection which elicits a *truthy* return value from the passed function.
   * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to include filtered out items.
   * @returns {Object} The matched item, or `undefined`.
   */
  find(fn2, ignoreFilters = false) {
    return (this.isFiltered && !ignoreFilters ? this._filteredValues : this._values).find(fn2);
  }
  get first() {
    return this.values[0];
  }
  get last() {
    return this.values[this.count - 1];
  }
  /**
   * The set of all values of this Collection regardless of filters applied.
   * @readonly
   * @property {Object[]}
   */
  get allValues() {
    return this._values;
  }
  /**
   * The set of values added to this Collection since the last sort or replaceValues operation.
   * @private
   * @readonly
   * @property {Object[]}
   */
  get addedValues() {
    return this._addedValues;
  }
  /**
   * This method ensures that every item in this Collection is replaced by the matched by
   * `id` item in the other Collection.
   *
   * By default, any items in this Collection which are __not__ in the other Collection are removed.
   *
   * If the second parameter is passed as `false`, then items which are not in the other
   * Collection are not removed.
   *
   * This can be used for example when updating a selected record Collection when a new
   * Store or new store dataset arrives. The selected Collection must reference the latest
   * versions of the selected record `id`s
   * @param {Core.util.Collection} other The Collection whose items to match.
   */
  match(other, allowRemove = true) {
    const me = this, { _values } = me, toRemove = [];
    me.forEach((item) => {
      const newInstance = other.get(item.id, true);
      if (newInstance) {
        const index = me.indexOf(item, true), oldInstance = _values[index];
        _values[index] = newInstance;
        me.removeFromIndices(oldInstance);
        me.addToIndices(newInstance);
      } else if (allowRemove) {
        toRemove.push(item);
      }
    });
    if (toRemove.length) {
      me.remove(toRemove);
    }
    if (me.isFiltered) {
      me._filteredValues = me._values.filter(me.filterFunction);
    }
    return toRemove;
  }
  /**
   * Adds items to this Collection. Multiple new items may be passed.
   *
   * By default, new items are appended to the existing values.
   *
   * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
   *
   * Any {@link #property-filters} {@link #property-filters} present are re-run.
   *
   * *Note that if application functionality requires add and remove, the
   * {@link #function-splice} operation is preferred as it performs both
   * operations in an atomic manner*
   * @param  {...Object} items The item(s) to add.
   */
  add(...items2) {
    if (items2.length === 1) {
      this.splice(this._values.length, null, ...items2);
    } else {
      this.splice(this._values.length, null, items2);
    }
  }
  /**
   * Removes items from this Collection. Multiple items may be passed.
   *
   * Any {@link #property-sorters} {@link #property-sorters} present are re-run.
   *
   * Any {@link #property-filters} {@link #property-filters} present are re-run.
   *
   * *Note that if application functionality requires add and remove, the
   * {@link #function-splice} operation is preferred as it performs both
   * operations in an atomic manner*
   * @param  {...Object} items The item(s) to remove.
   */
  remove(...items2) {
    if (items2.length === 1) {
      this.splice(0, ...items2);
    } else {
      this.splice(0, items2);
    }
  }
  /**
   * Moves an individual item, or a block of items to another location.
   * @param {Object|Object[]} items The item/items to move.
   * @param {Object} [beforeItem] the item to insert the first item before. If omitted, the `item`
   * is moved to the end of the Collection.
   * @returns {Number} The new index of the `item`.
   */
  move(items2, beforeItem) {
    items2 = ArrayHelper.asArray(items2);
    while (items2.length && items2[0] === beforeItem) {
      items2.shift();
    }
    if (!items2.length) {
      return;
    }
    const me = this, { _values } = me, itemIndex = me.indexOf(items2[0], true);
    if (items2.length === 1 && _values[itemIndex + 1] === beforeItem) {
      return;
    }
    me.suspendEvents();
    me.remove(items2);
    me.resumeEvents();
    const beforeIndex = beforeItem ? me.indexOf(beforeItem, true) : _values.length;
    if (beforeIndex === -1) {
      throw new Error("Collection move beforeItem parameter must be present in Collection");
    }
    _values.splice(beforeIndex, 0, ...items2);
    me._indicesInvalid = 1;
    me.trigger("change", {
      action: "move",
      items: items2,
      from: itemIndex,
      to: beforeIndex
    });
    return beforeIndex;
  }
  /**
   * The core data set mutation method. Removes and adds at the same time. Analogous
   * to the `Array` `splice` method.
   *
   * Note that if items that are specified for removal are also in the `toAdd` array,
   * then those items are *not* removed then appended. They remain in the same position
   * relative to all remaining items.
   *
   * @param {Number} index Index at which to remove a block of items. Only valid if the
   * second, `toRemove` argument is a number.
   * @param {Object[]|Number} [toRemove] Either the number of items to remove starting
   * at the passed `index`, or an array of items to remove (If an array is passed, the `index` is ignored).
   * @param  {Object[]|Object} [toAdd] An item, or an array of items to add.
   */
  splice(index = 0, toRemove, ...toAdd) {
    const me = this, idProperty = me.idProperty, values = me._values, newIds = {}, removed = [], replaced = [], oldCount = me.totalCount;
    let added, mutated;
    if ((toAdd == null ? void 0 : toAdd.length) === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    if (me.trigger("beforeSplice", { index, toRemove, toAdd }) === false) {
      return;
    }
    if (toAdd) {
      if (oldCount && toAdd.length) {
        const idIndex = me.indices[idProperty];
        added = [];
        for (let i = 0; i < toAdd.length; i++) {
          const newItem = toAdd[i], id = newItem[idProperty], existingItem = idIndex.get(id), existingIndex = existingItem ? values.indexOf(existingItem) : -1;
          newIds[id] = true;
          if (existingIndex !== -1) {
            if (values[existingIndex] !== newItem) {
              replaced.push([values[existingIndex], newItem]);
              values[existingIndex] = newItem;
            }
          } else {
            added.push(newItem);
          }
        }
      } else {
        added = toAdd;
      }
    }
    if (toRemove) {
      if (typeof toRemove === "number") {
        toRemove = Math.min(toRemove, values.length - index);
        for (let removeIndex = index; toRemove; --toRemove) {
          const id = values[removeIndex][idProperty];
          if (newIds[id]) {
            index++;
            removeIndex++;
          } else {
            removed.push(values[removeIndex]);
            values.splice(removeIndex, 1);
            mutated = true;
          }
        }
      } else {
        let contiguous = added.length === 0, lastIdx;
        toRemove = ArrayHelper.asArray(toRemove);
        const removeIndices = toRemove.reduce((result, item) => {
          const isNumeric = typeof item === "number", idx = isNumeric ? item : me.indexOf(item, true);
          if (contiguous && (lastIdx != null && idx !== lastIdx + 1 || isNumeric)) {
            contiguous = false;
          }
          if (idx >= 0 && idx < oldCount) {
            result.push(idx);
          }
          lastIdx = idx;
          return result;
        }, []).sort(reverseNumericSortFn);
        if (contiguous) {
          if (removeIndices.length) {
            removed.push.apply(removed, toRemove);
            values.splice(removeIndices[removeIndices.length - 1], removeIndices.length);
            mutated = true;
          }
        } else {
          for (let i = 0; i < removeIndices.length; i++) {
            const removeIndex = removeIndices[i];
            if (removeIndex !== -1) {
              const id = values[removeIndex][idProperty];
              if (!newIds[id]) {
                removed.unshift(values[removeIndex]);
                values.splice(removeIndex, 1);
                mutated = true;
              }
            }
          }
        }
      }
      if (removed.length && !me._indicesInvalid) {
        removed.forEach(me.removeFromIndices, me);
      }
    }
    if (added.length) {
      values.splice(Math.min(index, values.length), 0, ...added);
      mutated = true;
      if (!me._indicesInvalid) {
        added.forEach(me.addToIndices, me);
      }
      if (!me._addedValues) {
        me._addedValues = /* @__PURE__ */ new Set();
      }
      for (const value of added) {
        me._addedValues.add(value);
      }
    }
    if (removed.length && me._addedValues) {
      for (const value of removed) {
        me._addedValues.delete(value);
      }
    }
    if (replaced.length && !me._indicesInvalid) {
      replaced.forEach((rep) => {
        me.removeFromIndices(rep[0]);
        me.addToIndices(rep[1]);
      });
    }
    if (mutated || replaced.length) {
      if (me.isSorted) {
        me.onSortersChanged();
      } else if (me.isFiltered) {
        if (me.autoFilter) {
          me.onFiltersChanged({ action: "splice", oldCount: 1 });
        } else {
          me._filteredValues.splice(Math.min(index, me._filteredValues.length), 0, ...added);
        }
      }
      me.generation++;
      me.trigger("change", {
        action: "splice",
        removed,
        added,
        replaced,
        oldCount
      });
    } else {
      me.trigger("noChange", {
        index,
        toRemove,
        toAdd
      });
    }
  }
  /**
   * Change the id of an existing member by mutating its {@link #config-idProperty}.
   * @param {String|Number|Object} item The item or id of the item to change.
   * @param {String|Number} newId The id to set in the existing member.
   */
  changeId(item, newId) {
    const me = this, { idProperty } = me, oldId = keyTypes[typeof item] ? item : item[idProperty], member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      me.removeIndexEntry(item, idProperty, oldId);
      me.addIndexEntry(item, idProperty, newId);
      member[idProperty] = newId;
    }
  }
  /**
   * Returns the item with the passed `id`. By default, filtered are honoured, and
   * if the item with the requested `id` is filtered out, nothing will be returned.
   *
   * To return the item even if it has been filtered out, pass the second parameter as `true`.
   * @param {*} id The `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
   * @returns {Object} The found item, or `undefined`.
   */
  get(id, ignoreFilters = false) {
    return this.getBy(this.idProperty, id, ignoreFilters);
  }
  getAt(index, ignoreFilters = false) {
    if (this.isFiltered && !ignoreFilters) {
      return this._filteredValues[index];
    } else {
      return this._values[index];
    }
  }
  /**
   * Returns the item with passed property name equal to the passed value. By default,
   * filtered are honoured, and if the item with the requested `id` is filtered out,
   * nothing will be returned.
   *
   * To return the item even if it has been filtered out, pass the third parameter as `true`.
   * @param {String} propertyName The property to test.
   * @param {*} value The value to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return an item even if it is filtered out.
   * @returns {Object} The found item, or `undefined`.
   */
  getBy(propertyName, value, ignoreFilters = false) {
    return this.findItem(propertyName, value, this.isFiltered && ignoreFilters);
  }
  /**
   * The number of items in this collection. Note that this honours filtering.
   * See {@link #property-totalCount};
   * @property {Number}
   * @readonly
   */
  get count() {
    return this.values.length;
  }
  /**
   * The number of items in this collection regardless of filtering.
   * @property {Number}
   * @readonly
   */
  get totalCount() {
    return this._values.length;
  }
  /**
   * The property name used to extract item `id`s from added objects.
   * @member {String} idProperty
   */
  updateIdProperty(idProperty) {
    this.addIndex({ property: idProperty, unique: true });
  }
  //endregion
  //region Sorting
  /**
   * The Collection of {@link Core.util.CollectionSorter Sorters} for this Collection.
   * @member {Core.util.Collection} sorters
   */
  changeSorters(sorters) {
    return new _Collection({
      values: ArrayHelper.asArray(sorters),
      internalListeners: {
        change: "onSortersChanged",
        thisObj: this
      }
    });
  }
  /**
   * Adds a Sorter to the Collection of Sorters which are operating on this Collection.
   *
   * A Sorter may be specified as an instantiated {@link Core.util.CollectionSorter}, or a config object for a
   * CollectionSorter of the form
   *
   *     {
   *         property  : 'age',
   *         direction : 'desc'
   *     }
   *
   * Note that by default, a Sorter *replaces* a Sorter with the same `property` to make
   * it easy to change existing Sorters. A Sorter's `id` is its `property` by default. You
   * can avoid this and add multiple Sorters for one property by configuring Sorters with `id`s.
   *
   * A Sorter may also be specified as a function which compares two objects eg:
   *
   *     (lhs, rhs) => lhs.customerDetails.age - rhs.customerDetails.age
   *
   * @param {CollectionSorterConfig} sorter A Sorter configuration object to add to the Collection
   * of Sorters operating on this Collection.
   * @returns {Core.util.CollectionSorter} The resulting Sorter to make it easy to remove Sorters.
   */
  addSorter(sorter) {
    const result = sorter instanceof CollectionSorter ? sorter : new CollectionSorter(sorter);
    this.sorters.add(result);
    return result;
  }
  /**
   * A flag which is `true` if this Collection has active {@link #property-sorters}.
   * @property {Boolean}
   * @readonly
   */
  get isSorted() {
    var _a2;
    return Boolean((_a2 = this._sorters) == null ? void 0 : _a2.count);
  }
  onSortersChanged() {
    const me = this;
    me._sortFunction = null;
    me._addedValues = null;
    me._values.sort(me.sortFunction);
    me.trigger("change", sortEvent);
  }
  /**
   * A sorter function which encapsulates the {@link Core.util.CollectionSorter Sorters} for this Collection.
   * @property {Function}
   * @param {*} first First value to compare
   * @param {*} second Second value to compare
   * @returns {Number} Returns `1` if first value is a greater unit than second value, `-1` if the opposite is true or `0` if they're equal
   * @readonly
   */
  get sortFunction() {
    if (!this._sortFunction) {
      if (this.isSorted) {
        this._sortFunction = CollectionSorter.generateSortFunction(this.sorters.values);
      } else {
        this._sortFunction = return0;
      }
    }
    return this._sortFunction;
  }
  //endregion
  //region Filtering
  /**
   * The Collection of {@link Core.util.CollectionFilter Filters} for this Collection.
   * @property {Core.util.Collection}
   * @readonly
   */
  get filters() {
    if (!this._filters) {
      this._filters = new _Collection({
        internalListeners: {
          change: "onFiltersChanged",
          thisObj: this
        }
      });
    }
    return this._filters;
  }
  /**
   * Adds a Filter to the Collection of Filters which are operating on this Collection.
   *
   * A Filter may be an specified as an instantiated {@link Core.util.CollectionFilter
   * CollectionFilter}, or a config object for a CollectionFilter of the form
   *
   *     {
   *         property : 'age',
   *         operator : '>=',
   *         value    : 21
   *     }
   *
   * Note that by default, a Filter *replaces* a Filter with the same `property` to make
   * it easy to change existing Filters. A Filter's `id` is its `property` by default. You
   * can avoid this and add multiple Filters for one property by configuring Filters with `id`s.
   *
   * A Filter may also be specified as a function which filters candidate objects eg:
   *
   *     candidate => candidate.customerDetails.age >= 21
   *
   * @param {CollectionFilterConfig|Core.util.CollectionFilter} filter A Filter or Filter configuration object to add
   * to the Collection of Filters operating on this Collection.
   * @returns {Core.util.CollectionFilter} The resulting Filter to make it easy to remove Filters.
   */
  addFilter(filter2) {
    const result = filter2 instanceof CollectionFilter ? filter2 : new CollectionFilter(filter2);
    this.filters.add(result);
    return result;
  }
  removeFilter(filter2) {
    const { filters } = this;
    if (!filter2.isCollectionFilter) {
      filter2 = filters.get(filter2);
    }
    filters.remove(filter2);
  }
  clearFilters() {
    this.filters.clear();
  }
  /**
   * A flag which is `true` if this Collection has active {@link #property-filters}.
   * @property {Boolean}
   * @readonly
   */
  get isFiltered() {
    return Boolean(this._filters && this._filters.count);
  }
  onFiltersChanged({ action, removed: gone, oldCount }) {
    const me = this, oldDataset = oldCount || action === "clear" && gone.length ? me._filteredValues : me._values;
    me._filterFunction = null;
    me._filteredValues = me._values.filter(me.filterFunction);
    me._indicesInvalid = true;
    const {
      toAdd: added,
      toRemove: removed
    } = ArrayHelper.delta(me._filteredValues, oldDataset, true);
    me.trigger("change", { ...filterEvent, added, removed });
  }
  /**
   * A filter function which encapsulates the {@link Core.util.CollectionFilter Filters}
   * for this Collection.
   * @property {Function}
   * @param {*} value Value to compare
   * @returns {Boolean} Returns `true` for value valid for including
   * @readonly
   */
  get filterFunction() {
    if (!this._filterFunction) {
      if (this.isFiltered) {
        this._filterFunction = CollectionFilter.generateFiltersFunction(this.filters.values);
      } else {
        this._filterFunction = FunctionHelper.returnTrue;
      }
    }
    return this._filterFunction;
  }
  //endregion
  //region Indexing
  changeExtraKeys(extraKeys) {
    const keys = ArrayHelper.asArray(extraKeys);
    return keys.map((config) => {
      if (typeof config === "string") {
        return { property: config, unique: true };
      }
      return config;
    });
  }
  updateExtraKeys(extraKeys) {
    for (let i = 0; i < extraKeys.length; i++) {
      this.addIndex(extraKeys[i]);
    }
  }
  /**
   * Adds a lookup index for the passed property name or index config. The index is built lazily when an index is
   * searched
   * @internal
   * @param {Object} indexConfig An index config
   * @param {String} indexConfig.property The property name to add an index for
   * @param {Boolean} [indexConfig.unique] Specify `false` to allow multiple entries of the same index, turning
   *   entries into sets
   * @param {Object} [indexConfig.dependentOn] The properties that make the key
   */
  addIndex(indexConfig) {
    const me = this;
    if (indexConfig) {
      (me._indices || (me._indices = {}))[indexConfig.property] = /* @__PURE__ */ new Map();
      Object.assign(me._indices[indexConfig.property], indexConfig);
      me.invalidateIndices();
      if (indexConfig.dependentOn) {
        me.hasCompositeIndex = true;
      }
    }
  }
  /**
   * Return the index of the item with the specified key having the specified value.
   *
   * By default, filtering is taken into account and this returns the index in the filtered dataset if present. To
   * bypass this, pass the third parameter as `true`.
   *
   * Only useful for indices configured with `unique: true`.
   *
   * @param {String} propertyName The name of the property to test.
   * @param {*} value The value to test for.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in
   * the original data set if the item is filtered out.
   * @returns {Number} The index of the item or `-1` if not found for unique indices
   */
  findIndex(propertyName, value, ignoreFilters = false) {
    const item = this.findItem(propertyName, value, ignoreFilters);
    if (!item) {
      return -1;
    }
    const values = this.isFiltered && !ignoreFilters ? this._filteredValues : this._values;
    return values.indexOf(item);
  }
  /**
   * Return the item with the specified key having the specified value.
   *
   * By default, filtering is taken into account. To bypass this, pass the third parameter as `true`.
   *
   * For indices configured with `unique: false`, a Set of items will be returned.
   *
   * @param {String} propertyName The name of the property to test.
   * @param {*} value The value to test for.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to return the index in
   * the original data set if the item is filtered out.
   * @returns {Object|Set} The found item or Set of items or null
   */
  findItem(propertyName, value, ignoreFilters = false) {
    var _a2;
    const me = this, { isFiltered } = me, index = isFiltered && !ignoreFilters ? me.indices[filteredIndicesProperty][propertyName] : me.indices[propertyName];
    if (index) {
      const item = (_a2 = index.get(value)) != null ? _a2 : typeof value === "string" && value.length && !isNaN(value) && index.get(Number(value)) || null;
      if (item != null) {
        return item;
      }
    } else {
      const values = isFiltered && !ignoreFilters ? me._filteredValues : me._values, count = values.length;
      for (let i = 0; i < count; i++) {
        const item = values[i];
        if (item[propertyName] == value) {
          return item;
        }
      }
    }
    return null;
  }
  removeIndex(propertyName) {
    delete this._indices[propertyName];
    this.hasCompositeIndex = Object.values(this.indices).some((index) => index.dependentOn);
  }
  /**
   * Returns the index of the item with the same `id` as the passed item.
   *
   * By default, filtering is honoured, so if the item in question has been added, but is currently filtered out of
   * visibility, `-1` will be returned.
   *
   * To find the index in the master, unfiltered dataset, pass the second parameter as `true`;
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
   * @returns {Number} The index of the item, or `-1` if not found.
   */
  indexOf(item, ignoreFilters = false) {
    return this.findIndex(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters);
  }
  /**
   * Returns `true` if this Collection includes an item with the same `id` as the passed item.
   *
   * By default, filtering is honoured, so if the item in question has been added,
   * but is currently filtered out of visibility, `false` will be returned.
   *
   * To query inclusion in the master, unfiltered dataset, pass the second parameter as `true`;
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @param {Boolean} [ignoreFilters=false] Pass `true` to find the index in the master, unfiltered data set.
   * @returns {Boolean} True if the passed item is found.
   */
  includes(item, ignoreFilters = false) {
    if (Array.isArray(item)) {
      return item.some((item2) => this.includes(item2));
    }
    return Boolean(this.findItem(this.idProperty, keyTypes[typeof item] ? item : item[this.idProperty], ignoreFilters));
  }
  get indices() {
    if (this._indicesInvalid) {
      this.rebuildIndices();
    }
    return this._indices;
  }
  invalidateIndices() {
    this._indicesInvalid = true;
  }
  /**
   * Called when the Collection is mutated and the indices have been flagged as invalid.
   *
   * Rebuilds the indices object to allow lookup by keys.
   * @internal
   */
  rebuildIndices() {
    const me = this, isFiltered = me.isFiltered, indices = me._indices || (me._indices = {}), keyProps = Object.keys(indices), indexCount = keyProps.length, values = me._values;
    let detectDuplicates = false, filteredIndices;
    if (isFiltered) {
      filteredIndices = indices[filteredIndicesProperty] = {};
    }
    for (let i = 0; i < indexCount; i++) {
      const index = indices[keyProps[i]];
      index.clear();
      if (index.onDuplicate) {
        index.count = 0;
        detectDuplicates = true;
      }
      if (isFiltered) {
        let filteredIndex = filteredIndices[keyProps[i]];
        if (filteredIndex) {
          filteredIndex.clear();
        } else {
          filteredIndex = filteredIndices[keyProps[i]] = /* @__PURE__ */ new Map();
          filteredIndex.unique = index.unique;
        }
      }
    }
    doRebuildIndices(values, indices, keyProps, indexCount);
    if (detectDuplicates) {
      for (let i = 0; i < indexCount; i++) {
        const index = indices[keyProps[i]];
        if (index.onDuplicate && index.count > index.size) {
          const checked = /* @__PURE__ */ new Set();
          for (let j = 0; j < values.length; j++) {
            const item = values[j], key = item[keyProps[i]];
            if (checked.has(key)) {
              index.onDuplicate(item, key, index);
            }
            checked.add(key);
          }
        }
      }
    }
    if (isFiltered) {
      doRebuildIndices(me._filteredValues, filteredIndices, keyProps, indexCount, true);
    }
    me._indicesInvalid = false;
  }
  // Returns an array with [indices] or [indices, filteredIndices] if filtering is used
  getIndices(propertyName) {
    const indices = [this.indices[propertyName]];
    if (this.isFiltered) {
      indices.push(this.indices[filteredIndicesProperty][propertyName]);
    }
    return indices;
  }
  /**
   * Add an item to all indices
   * @param {*} item Item already available in the Collection
   * @private
   */
  addToIndices(item) {
    Object.keys(this.indices).forEach((propertyName) => {
      this.addIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  /**
   * Remove an item from all indices
   * @param {*} item Item already available in the Collection
   * @private
   */
  removeFromIndices(item) {
    Object.keys(this.indices).forEach((propertyName) => {
      this.removeIndexEntry(item, propertyName, item[propertyName]);
    });
  }
  /**
   * Remove an entry from an index, and if filtering is used also from the filtered index.
   * @param {*} item Item already available in the Collection
   * @param {String} propertyName Property of the item, will be matched with configured indices
   * @param {*} oldValue Value to remove
   * @private
   */
  removeIndexEntry(item, propertyName, oldValue) {
    this.getIndices(propertyName).forEach((index) => removeItemFromIndex(item, index, oldValue));
  }
  /**
   * Add a new entry to an index, and if filtering is used also to the filtered index.
   * @param {*} item Item already available in the Collection
   * @param {String} propertyName Property of the item, will be matched with configured indices
   * @param {*} value Value to store
   * @private
   */
  addIndexEntry(item, propertyName, value) {
    this.getIndices(propertyName).forEach((index) => addItemToIndex(item, index, value));
  }
  /**
   * Call externally to update indices on item mutation (from Store)
   * @param {*} item Item already available in the Collection
   * @param {Object} wasSet Uses the `wasSet` format from Store, `{ field : { oldValue, newValue } }`
   * @internal
   */
  onItemMutation(item, wasSet) {
    const me = this;
    if (!me._indicesInvalid && Object.keys(me.indices).length > 1) {
      Object.keys(wasSet).forEach((propertyName) => {
        var _a2;
        const indexConfig = me.indices[propertyName];
        if (indexConfig) {
          const { value, oldValue } = wasSet[propertyName];
          me.removeIndexEntry(item, propertyName, oldValue);
          me.addIndexEntry(item, propertyName, value);
        }
        if (me.hasCompositeIndex) {
          const dependentIndex = Object.values(me.indices).find((index) => {
            var _a3;
            return (_a3 = index.dependentOn) == null ? void 0 : _a3[propertyName];
          });
          if (dependentIndex) {
            const keysAndOldValues = {};
            for (const o in dependentIndex.dependentOn) {
              keysAndOldValues[o] = ((_a2 = wasSet[o]) == null ? void 0 : _a2.oldValue) || item[o];
            }
            const oldIndex = item.buildIndexKey(keysAndOldValues);
            me.removeIndexEntry(item, dependentIndex.property, oldIndex);
            me.addIndexEntry(item, dependentIndex.property, item[dependentIndex.property]);
          }
        }
      });
    }
  }
  //endregion
};
Collection._$name = "Collection";

// ../Core/lib/Core/util/Bag.js
var nonPrimitives = /* @__PURE__ */ new WeakMap();
var safeIndexKey = (value) => {
  if (value && typeof value === "object") {
    let substitute = nonPrimitives.get(value);
    if (substitute === void 0) {
      substitute = Symbol("bscik");
      nonPrimitives.set(value, substitute);
    }
    value = substitute;
  }
  return value;
};
var Bag = class {
  constructor(config) {
    const me = this;
    me.generation = 0;
    me.items = /* @__PURE__ */ new Set();
    me.idMap = {};
    me.idProperty = "id";
    if (config) {
      if (config.idProperty) {
        me.idProperty = config.idProperty;
      }
      if (config.values) {
        me.values = config.values;
      }
    }
  }
  /**
   * Returns the item with the passed `id`.
   *
   * @param {*} id The `id` to find.
   * @returns {Object} The found item, or `undefined`.
   */
  get(key) {
    return this.idMap[safeIndexKey(key)];
  }
  /**
   * The number of items in this Bag.
   * @property {Number}
   * @readonly
   */
  get count() {
    return this.items.size;
  }
  /**
   * Adds the passed item(s) to this Bag. Existing items with the same ID
   * will be replaced.
   * @param {Object|Object[]} toAdd Item(s) to add.
   */
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    const me = this, {
      items: items2,
      idMap,
      idProperty
    } = me, len = toAdd.length;
    for (let i = 0; i < len; i++) {
      const item = toAdd[i], key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), existingItem = idMap[key];
      if (existingItem == null) {
        idMap[key] = item;
        items2.add(item);
        me.generation++;
      } else if (existingItem !== item) {
        idMap[key] = item;
        items2.delete(existingItem);
        items2.add(item);
      }
    }
  }
  /**
   * Returns `nth` item in this Bag.
   * @param {Number} nth The index of the matching item. Negative numbers index for the last item. For example, -1
   * returns the last item, -2 the 2nd to last item etc.
   * @returns {Object} The matched item, or `undefined`.
   */
  at(nth) {
    let item, ret;
    if (nth < 0) {
      nth += this.count;
    }
    for (item of this.items) {
      if (!nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  /**
   * Removes the passed item(s) from this Bag.
   * @param {Object|Object[]} toRemove Item(s) to remove.
   */
  remove(toRemove) {
    toRemove = ArrayHelper.asArray(toRemove);
    const { items: items2, idMap, idProperty } = this, len = toRemove.length;
    for (let i = 0; i < len; i++) {
      const item = toRemove[i], key = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), existingItem = idMap[key];
      if (existingItem != null) {
        items2.delete(existingItem);
        delete idMap[key];
        this.generation++;
      }
    }
  }
  clear() {
    this.items.clear();
    this.idMap = {};
    this.generation++;
  }
  /**
   * Returns the number of items in this Bag which elicits a truthy return value from the passed function.
   * @param {Function} fn A function, which, when passed an item, returns `true` to select it as the item to return.
   * @returns {Number} The number of matched items.
   */
  countOf(fn2) {
    let ret = 0, item;
    for (item of this.items) {
      if (fn2(item)) {
        ++ret;
      }
    }
    return ret;
  }
  /**
   * Change the id of an existing member by mutating its idProperty.
   * @param {String|Number|Object} item The item or id of the item to change.
   * @param {String|Number} newId The id to set in the existing member.
   */
  changeId(item, newId) {
    const me = this, { idMap, idProperty } = me, oldId = keyTypes[typeof item] ? item : safeIndexKey(item[idProperty]), member = me.get(oldId);
    if (member) {
      const existingMember = me.get(newId);
      if (existingMember && member !== existingMember) {
        throw new Error(`Attempt to set item ${oldId} to already existing member's id ${newId}`);
      }
      member[idProperty] = newId;
      delete idMap[oldId];
      idMap[newId] = member;
    }
  }
  /**
   * Extracts the matching items from this Bag into an array based upon the passed value filter function.
   * @param {Function} fn A function, which, when passed an item, returns a `true` to place into the resulting array.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   * @returns {Object[]} An array of values extracted from this Bag.
   */
  filter(fn2, thisObj) {
    const { items: items2 } = this, result = [];
    let i = 0;
    items2.forEach((item) => {
      if (fn2.call(thisObj, item, i++, items2)) {
        result.push(item);
      }
    });
    return result;
  }
  /**
   * Returns `true` if this Collection includes an item with the same `id` as the passed item.
   *
   * @param {Object|String|Number} item The item to find, or an `id` to find.
   * @returns {Boolean} True if the passed item is found.
   */
  includes(item) {
    const key = keyTypes[typeof item] ? item : safeIndexKey(item[this.idProperty]);
    return Boolean(this.idMap[key]);
  }
  /**
   * Extracts the content of this Bag into an array based upon the passed
   * value extraction function.
   * @param {Function} fn A function, which, when passed an item, returns a value to place into the resulting array.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   * @returns {Object[]} An array of values extracted from this Bag.
   */
  map(fn2, thisObj) {
    const { items: items2 } = this, result = new Array(items2.size);
    let i = 0;
    items2.forEach((item) => {
      result[i] = fn2.call(thisObj, item, i++, items2);
    });
    return result;
  }
  /**
   * Executes the passed function for each item in this Bag, passing in the item.
   * @param {Function} fn The function to execute.
   * @param {Object} [thisObj] The `this` reference when the function is called.
   */
  forEach(fn2, thisObj) {
    return this.items.forEach(fn2, thisObj);
  }
  /**
   * Returns `nth` item in this Bag which elicits a truthy return value from the provided matcher function `fn`.
   * @param {Function} fn A function which, when passed an item, returns `true` to select the item as a match.
   * @param {Number} [nth=0] The index of the matching item. By default, 0 returns the first item that matches
   * according to `fn`. Negative numbers index for the last item. For example, -1 returns the last matching item,
   * -2 the 2nd to last matching item etc..
   * @returns {Object} The matched item, or `undefined`.
   */
  find(fn2, nth = 0) {
    let item, ret;
    if (nth < 0) {
      nth += this.countOf(fn2);
    }
    for (item of this.items) {
      if (fn2(item) && !nth--) {
        ret = item;
        break;
      }
    }
    return ret;
  }
  /**
   * Iterator that allows you to do for (let item of bag)
   */
  [Symbol.iterator]() {
    return this.items[Symbol.iterator]();
  }
  indexOf(item, matchFn) {
    let index = -1, it;
    for (it of this.items) {
      if (!matchFn || matchFn(it)) {
        ++index;
        if (it === item) {
          return index;
        }
      }
    }
    return -1;
  }
  /**
   * The set of values of this Bag.
   *
   * Setting this property replaces the data set.
   * @property {Object[]}
   */
  get values() {
    return [...this.items];
  }
  set values(values) {
    values = ArrayHelper.asArray(values);
    this.clear();
    this.add.apply(this, values);
    this.generation++;
  }
  /**
   * Sort the values of this Bag using the passed comparison function.
   *
   * Setting this property replaces the data set.
   * @param {Function} fn Comparison function which returns -ve, 0, or +ve
   */
  sort(fn2) {
    this.values = this.values.sort(fn2);
  }
  some(fn2, thisObj) {
    return this.values.some(fn2, thisObj);
  }
};
Bag._$name = "Bag";

// ../Core/lib/Core/data/StoreBag.js
var StoreBag = class extends Bag {
  add(...toAdd) {
    if (toAdd.length === 1 && Array.isArray(toAdd[0])) {
      toAdd = toAdd[0];
    }
    return super.add(...toAdd.filter((record) => record.isPersistable));
  }
};
StoreBag._$name = "StoreBag";

// ../Core/lib/Core/data/mixin/StoreCRUD.js
var StoreCRUD_default = (Target) => class StoreCRUD extends (Target || Base) {
  static get $name() {
    return "StoreCRUD";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Commit changes automatically
       * @config {Boolean}
       * @default
       * @category Common
       */
      autoCommit: false
    };
  }
  static get properties() {
    return {
      isRemoving: false,
      suspendCount: 0
    };
  }
  //endregion
  //region Events
  /**
   * Fired after removing all records
   * @event removeAll
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired before committing changes. Return false from handler to abort commit
   * @event beforeCommit
   * @param {Core.data.Store} source This Store
   * @param {Object} changes Modification data
   */
  /**
   * Fired after committing changes
   * @event commit
   * @param {Core.data.Store} source This Store
   * @param {Object} changes Modification data
   */
  /**
   * Fired before records are removed from this store by the {@link #function-remove} or {@link #function-removeAll}.
   * Also fired when removing a child record in a tree store using {@link Core.data.mixin.TreeNode#function-removeChild}.
   * The remove may be vetoed by returning `false` from a handler.
   * @event beforeRemove
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records The records which are to be removed.
   * @param {Core.data.Model} parent The record from which children are being removed when using a tree store. Only
   * provided when removing a single node.
   * @param {Boolean} isMove This flag is `true` if the child node is being removed by
   * {@link Core.data.mixin.TreeNode#function-appendChild appendChild} to be moved
   * _within the same tree_.
   * @param {Boolean} removingAll This flag is `true` if the operation is removing the store's entire data set.
   * @preventable
   */
  /**
   * Fired before records are added to this store by the {@link #function-add} or {@link #function-insert}. In a tree
   * store, also fired by {@link Core.data.mixin.TreeNode#function-appendChild} and
   * {@link Core.data.mixin.TreeNode#function-insertChild}. The add or insert may be vetoed by returning `false`
   * from a handler.
   * @event beforeAdd
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records The records which are to be added
   * @param {Core.data.Model} parent The parent node when using a tree store
   * @preventable
   */
  /**
   * Fired after adding/inserting record(s). If the record was added to a parent, the `isChild` flag is set on the
   * event. If it was inserted, event contains `index`
   * @event add
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records Added records. In case of tree store, if branch is added, only branch root
   * is returned
   * @param {Core.data.Model[]} [allRecords] Flat list of all added records. In case of tree store, if branch is
   * added, all new records are returned, not only branch root
   * @param {Core.data.Model} [parent] If due to an {@link Core/data/mixin/TreeNode#function-appendChild}
   * call, this is the parent node added to.
   * @param {Number} [index] Insertion point in the store's {@link Core.data.Store#config-storage Collection}.
   * @param {Number} [oldIndex] Not used for tree stores. The index of the first record moved.
   * @param {Boolean} [isChild] Flag which is set to true if the records are added to a parent record
   * @param {Boolean} [isExpand] Flag which is set to true if records are added to the store by expanding parent
   * @param {Object} [isMove] An object keyed by the ids of the records which were moved from another
   * position in the store, or from another parent node in the store. The ids of moved records will be
   * property names with a value `true`.
   */
  /**
   * Fired when one or more records are removed
   * @event remove
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model[]} records Array of removed records. In case of tree store, if branch is removed, only branch root
   * is returned
   * @param {Core.data.Model[]} [allRecords] Flat array of all removed records. In case of tree store, if branch is
   * removed, all removed records are returned, not only branch root
   * @param {Core.data.Model} [parent] If due to a {@link Core.data.mixin.TreeNode#function-removeChild removeChild}
   * call, this is the parent node removed from. Only applicable when removing a single tree node.
   * @param {Number} [index] Visible index at which record was removed. In case the record was removed from a collapsed
   * branch, -1 is returned. For tree store, this is only provided when removing a single node.
   * @param {Boolean} [isChild] Flag which is set to true if the record was removed from a parent record
   * @param {Boolean} [isCollapse] Flag which is set to true if records were removed from the store by collapsing parent
   * @param {Boolean} [isMove] Passed as `true` if the remove was part of a move operation within this Store.
   */
  //endregion
  //region Add, insert & remove
  /**
   * Removes a record from this store. Fires a single {@link #event-remove} event passing the removed records.
   * @param {String|String[]|Number|Number[]|Core.data.Model|Core.data.Model[]} records Record/array of records (or record ids) to remove
   * @param {Boolean} [silent] Specify `true` to suppress events/autoCommit
   * @returns {Core.data.Model[]} Removed records
   * @fires beforeRemove
   * @fires remove
   * @fires change
   * @category CRUD
   */
  remove(records, silent = false) {
    const me = this, { storage } = me;
    records = ArrayHelper.asArray(records).reduce((result, r) => {
      r = me.getById(r);
      if (r) {
        result.push(r);
      }
      return result;
    }, []);
    if (records.length === 0) {
      return records;
    }
    if (!me.tree && !silent && me.trigger("beforeRemove", { records }) === false) {
      return [];
    }
    me.isRemoving = true;
    if (me.isGrouped) {
      const oldCount = storage.count, recordsInCollapsedGroups = [], changedGroupParents = /* @__PURE__ */ new Set();
      for (const rec of records) {
        const groupParent = rec.groupParent.get(me.id);
        if (groupParent.meta.collapsed) {
          recordsInCollapsedGroups.push(rec);
        }
        ArrayHelper.remove(groupParent.groupChildren, rec);
        ArrayHelper.remove(groupParent.unfilteredGroupChildren, rec);
        groupParent.meta.childCount--;
        changedGroupParents.add(groupParent);
      }
      for (const groupParent of changedGroupParents) {
        if (groupParent.groupChildren.length > 0) {
          me.onModelChange(groupParent, {}, {});
        }
      }
      if (recordsInCollapsedGroups.length) {
        storage.trigger("change", {
          action: "splice",
          removed: recordsInCollapsedGroups,
          added: [],
          replaced: [],
          oldCount
        });
      }
    } else if (me.tree) {
      const allRemovedRecords = [], removingMultiple = records.length > 1, firstRemoved = records[0], index = removingMultiple ? void 0 : storage.indexOf(firstRemoved), removeChildArgs = records.reduce((result, child) => {
        const { parent } = child;
        if (parent) {
          if (!result[parent.id]) {
            result[parent.id] = [parent, []];
          }
          result[parent.id][1].push(child);
        }
        return result;
      }, {}), removals = Array.from(Object.values(removeChildArgs));
      if (!silent && me.trigger("beforeRemove", { records, isMove: false, parent: removingMultiple ? void 0 : firstRemoved.parent }) === false) {
        me.isRemoving = false;
        return [];
      }
      me.suspendAutoCommit();
      removals.sort((a, b) => b[0].childLevel - a[0].childLevel);
      for (const [parent, children] of removals) {
        allRemovedRecords.push(...parent.removeChild(children, false, true));
      }
      if (!silent) {
        me.trigger("remove", {
          // parent is only relevant when removing single node
          parent: removingMultiple ? void 0 : firstRemoved.parent,
          index,
          isChild: true,
          allRecords: allRemovedRecords,
          isMove: false,
          records
        });
        me.trigger("change", {
          action: "remove",
          records
        });
      }
      me.resumeAutoCommit();
      me.isRemoving = false;
      return records;
    }
    if (records.length === 0) {
      me.isRemoving = false;
      return records;
    }
    for (const record of records) {
      record.beforeRemove(records);
    }
    if (silent) {
      me.suspendEvents();
    }
    storage.remove(records);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    me.isRemoving = false;
    return records;
  }
  /**
   * Clears store data. Used by removeAll, separate function for using with chained stores.
   * @private
   * @category CRUD
   */
  clear(isLoading = false) {
    var _a2, _b;
    const me = this, { storage } = me;
    if (me.storage.totalCount || ((_b = (_a2 = me.rootNode) == null ? void 0 : _a2.unfilteredChildren) == null ? void 0 : _b.length)) {
      if (!isLoading && me.trigger("beforeRemove", { records: storage.allValues, removingAll: true }) === false) {
        return null;
      }
      if (me.rootNode) {
        if (!me.isChained) {
          me.rootNode.clearChildren(isLoading);
        }
      } else if (isLoading) {
        const allRecords = me.registeredRecords;
        for (let i = allRecords.length - 1, rec; i >= 0; i--) {
          rec = allRecords[i];
          if (rec && !rec.isDestroyed) {
            rec.unjoinStore(me);
          }
        }
      }
      if (isLoading) {
        me.removed.clear();
        storage.suspendEvents();
      }
      storage.clear();
      if (isLoading) {
        storage.resumeEvents();
      }
      me.added.clear();
      me.modified.clear();
    }
  }
  /**
   * Removes all records from the store.
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Boolean} `true` unless the action was prevented, in which case it returns `false`
   * @fires beforeRemove
   * @fires removeAll
   * @fires change
   * @category CRUD
   */
  removeAll(silent = false) {
    const me = this, storage = me.storage;
    let result;
    me.isRemoving = true;
    if (silent) {
      storage.suspendEvents();
      const allRecords = me.registeredRecords;
      for (let i = allRecords.length - 1, rec; i >= 0; i--) {
        rec = allRecords[i];
        if (rec && !rec.isDestroyed && !rec.isRoot) {
          rec.unjoinStore(me);
        }
      }
    }
    if (me.tree) {
      result = me.rootNode.clear() !== false;
    } else {
      result = me.clear() !== null;
    }
    if (silent) {
      storage.resumeEvents();
    }
    me.isRemoving = false;
    return result;
  }
  /**
   * Add records to store.
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Core.data.Model[]} Added records
   * @fires add
   * @fires change
   * @category CRUD
   */
  add(records, silent = false, options = {}) {
    const me = this, { storage } = me;
    records = ArrayHelper.asArray(records);
    if (!(records == null ? void 0 : records.length)) {
      return;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      const parentIdMap = /* @__PURE__ */ new Map(), parentIndexField = me.modelClass.getFieldDataSource("parentIndex"), { parentIdField } = me.modelClass, added2 = [];
      records.forEach((node) => {
        const parentId = node[parentIdField];
        if (!parentIdMap.has(parentId)) {
          parentIdMap.set(parentId, { append: [], insert: [] });
        }
        const entry = parentIdMap.get(parentId);
        if (!node.isModel && parentIndexField in node) {
          entry.insert.push(node);
        } else {
          entry.append.push(node);
        }
      });
      parentIdMap.forEach(({ append, insert }, parentId) => {
        const parentNode2 = parentId == null ? me.rootNode : me.getById(parentId);
        if (!parentNode2) {
          throw new Error(`Parent node with id ${parentId} not found, cannot add children.`);
        }
        if (append.length) {
          added2.push(...parentNode2.appendChild(append, silent, options));
        }
        if (insert.length) {
          for (const toInsert of insert) {
            added2.push(parentNode2.insertChild(toInsert, toInsert[parentIndexField], silent, options));
          }
        }
      });
      if (me.isFiltered && me.reapplyFilterOnAdd) {
        me.filter({
          silent: true
        });
      }
      if (me.reapplySortersOnAdd && !me.isSyncingDataOnLoad) {
        me.sort();
      }
      return added2;
    }
    if (!silent && me.trigger("beforeAdd", { records }) === false) {
      return null;
    }
    me.tree = me.tree || Boolean(me.autoTree && records[0].children);
    if (me.tree) {
      return me.rootNode.appendChild(records);
    }
    const added = me.processRecords(records);
    if (silent) {
      me.suspendEvents();
    }
    me.addingClean = options.clean;
    storage.add(added);
    me.addingClean = false;
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  processRecords(records, onRecordCreated) {
    return records.map((data) => {
      const record = this.processRecord(data.isModel ? data : this.createRecord(data));
      onRecordCreated == null ? void 0 : onRecordCreated.call(this, record);
      return record;
    });
  }
  /**
   * Insert records into the store.
   * @param {Number} index Index to insert at
   * @param {Core.data.Model|Core.data.Model[]|Object|Object[]} records Array of records/data or a single record/data to insert to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Core.data.Model[]} Inserted records
   * @fires add
   * @fires change
   * @category CRUD
   */
  insert(index, records, silent = false) {
    var _a2;
    const me = this, storage = me.storage, insertBefore = me.getAt(index), _records = storage.values, removeIndices = [];
    records = ArrayHelper.asArray(records);
    if (me.tree) {
      const root = me.rootNode;
      return root.insertChild(records, (_a2 = root.children) == null ? void 0 : _a2[index], silent);
    }
    if (!silent && me.trigger("beforeAdd", { records }) === false) {
      return null;
    }
    let isNoop, start, i;
    if (_records[start = index] === records[0] || _records[start = index - 1] === records[0]) {
      for (isNoop = true, i = 0; isNoop && i < records.length; i++) {
        if (records[i] !== _records[start + i]) {
          isNoop = false;
        }
      }
    }
    if (isNoop) {
      return null;
    }
    const added = me.processRecords(records, (record) => {
      const removedAtIndex = storage.indexOf(record);
      if (record.children && record.children.length && me.autoTree) {
        me.tree = true;
      }
      if (removedAtIndex > -1) {
        if (removedAtIndex < index && insertBefore)
          index--;
        removeIndices.push(removedAtIndex);
      }
      record.meta.previousIndex = removedAtIndex;
    });
    me.suspendEvents();
    me.storage.remove(removeIndices);
    me.resumeEvents();
    if (silent) {
      me.suspendEvents();
    }
    storage.splice(index, 0, ...added);
    if (silent) {
      me.resumeEvents();
    }
    if (me.autoCommit) {
      me.doAutoCommit();
    }
    return added;
  }
  /**
   * Moves a record, or block of records to another location.
   * @param {Core.data.Model|Core.data.Model[]} records The record(s) to move.
   * @param {Core.data.Model} beforeRecord the record to insert the first record(s) before.
   * @fires change
   * @category CRUD
   */
  move(records, beforeRecord) {
    if (this.isTree) {
      beforeRecord.parent.insertChild(records, beforeRecord);
    } else {
      this.storage.move(records, beforeRecord);
    }
  }
  //endregion
  //region Update multiple
  setMultiple(filterFn, field, value) {
    const me = this, records = [], changes = [];
    me.forEach((r) => {
      if (filterFn(r)) {
        changes.push(r.set(field, value, true));
        records.push(r);
      }
    });
    me.trigger("updateMultiple", { records, all: me.records.length === records.length });
    me.trigger("change", { action: "updatemultiple", records, all: me.records.length === records.length });
    if (me.reapplyFilterOnUpdate && me.isFiltered)
      me.filter();
  }
  setAll(field, value) {
    const me = this, changes = [];
    me.forEach((r) => {
      changes.push(r.set(field, value, true));
    });
    me.trigger("updateMultiple", { records: me.records, all: true });
    me.trigger("change", { action: "updatemultiple", records: me.records, all: true });
    if (me.reapplyFilterOnUpdate && me.isFiltered)
      me.filter();
  }
  //endregion
  //region Commit
  /**
   * Accepts all changes, resets the modification tracking:
   * * Clears change tracking for all records
   * * Clears added
   * * Clears modified
   * * Clears removed
   * Leaves the store in an "unmodified" state.
   * @internal
   */
  acceptChanges() {
    const me = this;
    me.added.forEach((r) => r.clearChanges(true, false));
    me.modified.forEach((r) => r.clearChanges(true, false));
    me.added.clear();
    me.modified.clear();
    me.removed.clear();
  }
  /**
   * Commits changes, per default only returns changes and resets tracking.
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Object} Changes, see {@link #property-changes}
   * @fires beforeCommit
   * @fires commit
   * @category CRUD
   */
  commit(silent = false) {
    const { changes } = this;
    if (!silent && this.trigger("beforeCommit", { changes }) === false) {
      return false;
    }
    this.acceptChanges();
    if (!silent) {
      this.trigger("commit", { changes });
    }
    return changes;
  }
  /**
   * Reverts all changes in the store (adds removed records back, and removes newly added records).
   * @fires change
   * @fires refresh
   * @category CRUD
   */
  revertChanges() {
    const me = this, { changes } = me;
    if (changes) {
      const event = { action: "clearchanges", changes };
      me.add(me.removed.values, true);
      me.remove(me.added.values, true);
      me.modified.forEach((r) => r.revertChanges(true));
      me.added.clear();
      me.modified.clear();
      me.removed.clear();
      me.trigger("change", event);
      me.trigger("refresh", event);
    }
  }
  /**
   * Get uncommitted changes as an object of added/modified/removed arrays of records.
   *
   * ```javascript
   * // Format:
   * {
   *      added: [], // array of Core.data.Model
   *      modified: [], // array of Core.data.Model
   *      removed: [] // array of Core.data.Model
   * }
   * ```
   *
   * @member {Object} changes
   * @property {Core.data.Model[]} changes.added Records that have been added
   * @property {Core.data.Model[]} changes.modified Records that have changes to persistable fields
   * @property {Core.data.Model[]} changes.removed Records that have been removed
   * @readonly
   * @category Records
   */
  get changes() {
    const me = this, modified = me.modified.values.filter((r) => r.rawModifications);
    return me.added.count || modified.length || me.removed.count ? {
      // Slicing to have changes intact when triggering commit
      added: me.added.values.slice(),
      modified,
      removed: me.removed.values.slice()
    } : null;
  }
  /**
   * Setting autoCommit to true automatically commits changes to records.
   * @property {Boolean}
   * @category Records
   */
  get autoCommit() {
    return this._autoCommit;
  }
  set autoCommit(auto) {
    this._autoCommit = auto;
    if (auto && this.changes) {
      this.commit();
    }
  }
  /**
   * Suspends automatic commits upon store changes. Can be called multiple times (it uses an internal counter).
   * @category Records
   */
  suspendAutoCommit() {
    this.suspendCount++;
  }
  /**
   * Resumes automatic commits upon store changes. Will trigger commit if the internal counter is 0.
   * @category Records
   */
  resumeAutoCommit(doCommit = true) {
    this.suspendCount--;
    if (this.autoCommit && doCommit) {
      this.doAutoCommit();
    }
  }
  doAutoCommit() {
    if (this.suspendCount <= 0) {
      this.commit();
    }
  }
  //endregion
};

// ../Core/lib/Core/data/mixin/StoreChanges.js
var StoreChanges_default = (Target) => class StoreChanges extends (Target || Base) {
  static get $name() {
    return "StoreChanges";
  }
  static get configurable() {
    return {
      /**
       * Specifies target to filter and sort after applying changeset:
       * * `'changes'` - apply sort and filter to changeset only (see more below)
       * * `'none'` - do not apply sort and filter
       *
       * ### `changes` behavior
       * If the store has filters in effect when the changeset is applied, the following rules will determine how the
       * filtered values are affected:
       * - Among added records, only those that match the filter will be included in the filtered set
       * - Among updated records, those that did not previously match the filter but now do will be added to the filtered set,
       *   and those that did match but no longer do will also remain in the filtered set. This means that new records may
       *   appear in the filtered set as a result of `applyChanges`, but records will not disappear until filters are
       *   re-applied.
       *
       * @default
       * @prp {'changes'|'none'}
       * @category Advanced
       */
      applyChangesetFilterSortTarget: "changes"
    };
  }
  /**
   * Applies changes from another store to this store. Useful if cloning records in one store to display in a
   * grid in a popup etc. to reflect back changes.
   * @param {Core.data.Store} otherStore
   * @category CRUD
   */
  applyChangesFromStore(otherStore) {
    const me = this, { changes } = otherStore;
    if (!changes) {
      return;
    }
    if (changes.added) {
      me.add(changes.added);
    }
    if (changes.removed) {
      me.remove(changes.removed.map((r) => r.id));
    }
    if (changes.modified) {
      changes.modified.forEach((record) => {
        const localRecord = me.getById(record.id);
        localRecord == null ? void 0 : localRecord.set(record.modifications);
      });
    }
  }
  /**
   * Applies a set of changes (presumable from a backend) expressed as an object matching the format outputted by the
   * {@link Core/data/Store#property-changes} property: `{ added : [], modified/updated : [], removed : [] }`
   *
   * `added` is expected to be an array of raw data objects consumable by the stores model class for records to add to
   * the store (see example snippet below).
   *
   * `modified` (or `updated` for compatibility with Schedulers CrudManager) is expected to have the same format as
   * `added`, but should always include the `id` of the record to update.
   *
   * Records that have been created locally and gets assigned a proper id by the backend are expected to also pass a
   * `phantomId` field (name of the field is configurable using the `phantomIdField` arg, more info on phantom ids
   * below), to match it with the current id of a local record (`id` will contain the new id).
   *
   * Note that it is also possible to pass this `phantomId` -> `id` mapping in the `added` array. When encountering a
   * record in that array that already exists in the local store, it will be treated the same was as a record in the
   * `modified` array.
   *
   * `removed` is expected to be an array of objects with the `{ id : xx }` shape. Any matches on an id in the store
   * will be removed, those and any non matches will also be cleared from the change tracking of the store.
   *
   * If the store has filters in effect when the changeset is applied, the following rules will determine how the
   * filtered values are affected:
   * - Among added records, only those that match the filter will be included in the filtered set
   * - Among updated records, those that did not previously match the filter but now do will be added to the filtered set,
   *   and those that did match but no longer do will also remain in the filtered set. This means that new records may
   *   appear in the filtered set as a result of `applyChanges`, but records will not disappear until filters are
   *   re-applied.
   *
   * As an example, consider a store with the following initial state and some operations performed on it:
   *
   * ```javascript
   * // Load some data into the store
   * store.data = [
   *     { id : 1, name : 'Minerva' },
   *     { id : 2, name : 'Mars' },
   *     { id : 3, name : 'Jupiter' }
   * ];
   * // Add a new record. It gets assigned a generated id,
   * // for example 'generated56'
   * store.add({ name : 'Artemis' });
   * // Remove Jupiter
   * store.remove(3);
   * ```
   *
   * After syncing those operations to a custom backend (however you chose to solve it in your application) we might
   * get the following response (see "Transforming a response to the correct format" below if your backend responds
   * in another format):
   *
   * ```javascript
   * const serverResponse = {
   *     added : [
   *         // Added by the backend, will be added locally
   *         { id : 5, name : 'Demeter' }
   *     ],
   *
   *     updated : [
   *         // Will change the name of Minerva -> Athena
   *         { id : 1, name : 'Athena' },
   *         // Will set proper id 4 for Artemis
   *         { $PhantomId : 'generated56', id : 4 }
   *     ],
   *
   *     removed : [
   *         // Confirmed remove of Jupiter
   *         { id : 3 },
   *         // Removed by the backend, Mars will be removed locally
   *         { id : 2 }
   *     ]
   * };
   * ```
   *
   * If that response is then passed to this function:
   *
   * ```javascript
   * store.applyChangeSet(serverResponse);
   * ```
   *
   * The end result will be the following data in the store:
   *
   * ```javascript
   * [
   *     { id : 1, name : 'Athena' }, // Changed name
   *     { id : 4, name : 'Artemis' }, // Got a proper id
   *     { id : 5, name : 'Demeter' } // Added by the backend
   * ]
   * ```
   *
   * ### Phantom ids
   *
   * When a record is created locally, it is always assigned a generated id. That id is called a phantom id (note that
   * it is assigned to the normal id field). When passing the new record to the backend, the id is sent with it. When
   * the backend inserts the record into the database, it (normally) gets a proper id assigned. That id then needs to
   * be passed back in the response, to update the local record with the correct id. Making sure that future updates
   * match the correct row in the database.
   *
   * For example a newly created record should be passed similar to this to the backend (pseudo format, up to the
   * application/backend to decide):
   *
   * ```json
   * {
   *     "added" : {
   *         "id" : "generated79",
   *         "name" : "Hercules",
   *         ...
   *     }
   * }
   * ```
   *
   * For the backend response to be applicable for this function, it should then respond with:
   *
   * ```json
   * {
   *     "updated" : {
   *         {
   *             "$PhantomId" : "generated79",
   *             "id" : 465
   *         }
   *     }
   * }
   * ```
   *
   * (Or, as stated above, it can also be passed in the "added" array. Which ever suits your backend best).
   *
   * This function will then change the id of the local record using the phantom id `generated79` to `465`.
   *
   * ### Transforming a response to the correct format
   *
   * This function optionally accepts a `transformFn`, a function that will be called with the `changes`. It is
   * expected to return a changeset in the format described above (`{ added : [], updated : [], removed : [] }`),
   * which then will be used to apply the changes.
   *
   * Consider the following "non standard" (made up) changeset:
   *
   * ```javascript
   * const changes = {
   *     // Database ids for records previously added locally
   *     assignedIds : {
   *         'phantom1' : 10,
   *         'phantom2' : 15
   *     },
   *     // Ids records removed by the backend
   *     removed : [11, 27],
   *     // Modified records, keyed by id
   *     altered : {
   *         12 : { name : 'Changed' }
   *     },
   *     // New records, keyed by id
   *     inserted : {
   *         20  : { name : 'New' }
   *     }
   * }
   * ```
   *
   * Since it does not match the expected format it has to be transformed:
   *
   * ```javascript
   * store.applyChangeset(changes, ({ assignedIds, inserted, altered, removed }) => ({
   *    // Convert inserted to [{ id : 20, name : 'New' }]
   *    added : Object.entries(inserted).map(([id, data] => ({ id, ...data }),
   *    updated : [
   *        // Convert assignedIds to [{ $PhantomId : 'phantom1', id : 10 }, ...]
   *       ...Object.entries(assignedIds).map(([phantomId, id])) => ({ $PhantomId : phantomId, id }),
   *       // Convert altered to [{ id : 12, name : 'Changed' }]
   *       ...Object.entries(modified).map(([id, data] => ({ id, ...data })
   *    ],
   *    // Convert removed to [{ id : 11 }, ...]
   *    removed : removed.map(id => ({ id }))
   * }));
   * ```
   *
   * The transform function above would output:
   *
   * ```javascript
   * {
   *     added : [
   *         {  id : 20, name : 'New' }
   *     ],
   *     updated : [
   *         { $PhantomId : 'phantom1', id : 10 },
   *         { $PhantomId : 'phantom2', id : 15 },
   *         {  id : 12, name : 'Changed' }
   *     ],
   *     removed : [
   *        { id : 11 },
   *        { id : 12 }
   *     ]
   * }
   * ```
   *
   * And that format can then be applied.
   *
   * @param {Object} changes Changeset to apply to the store, see specification above
   * @param {Function} [transformFn] Optional function used to preprocess a changeset in a different format,
   * should return an object with the format expected by this function (see above)
   * @param {String} [phantomIdField] Field used by the backend when communicating a record being assigned a proper id
   * instead of a phantom id (see above)
   * @privateparam {Boolean} [remote] Set to true to indicate changes are from the remote source. Remote changes have
   * precedence over local.
   * @privateparam {Boolean} [logChanges] Used by CrudManager to be able to revert specific changes later
   * @category CRUD
   */
  applyChangeset(changes, transformFn = null, phantomIdField = "$PhantomId", remote = true, logChanges = false) {
    var _a2, _b, _c, _d, _e;
    const me = this, { added, updated, modified, removed } = (_a2 = transformFn == null ? void 0 : transformFn(changes, me)) != null ? _a2 : changes, altered = (_b = updated != null ? updated : modified) != null ? _b : [], idDataSource = me.modelClass.getFieldDataSource("id"), parentIdDataSource = me.modelClass.getFieldDataSource("parentId"), log = logChanges ? /* @__PURE__ */ new Map() : null, allAdded = [], allAltered = [];
    let rootUpdated = false, modifiedParents = [];
    me.trigger("startApplyChangeset");
    me._groupVisibleRecordIds = [];
    me.isGrouped && me.forEach((record) => {
      me._groupVisibleRecordIds.push(record.id);
    });
    if ((added == null ? void 0 : added.length) > 0) {
      const toUpdate = [], toAdd = [];
      for (const data of added) {
        if (me.getById(data[phantomIdField]) || me.getById(ObjectHelper.getPath(data, idDataSource))) {
          toUpdate.push(data);
        } else {
          toAdd.push(data);
        }
      }
      altered.unshift.apply(altered, toUpdate);
      const prevReapplySortersOnAdd = me.reapplySortersOnAdd;
      me.reapplySortersOnAdd = false;
      const addedRecords = (_c = me.add(toAdd, false, { orderedParentIndex: { skip: true } })) != null ? _c : [];
      allAdded.push(...addedRecords);
      me.reapplySortersOnAdd = prevReapplySortersOnAdd;
      if (me.tree) {
        for (const record of addedRecords) {
          const { parent } = record;
          if (parent.isRoot) {
            rootUpdated = true;
            modifiedParents = [parent];
            break;
          }
          if (!parent.isRoot && modifiedParents.every((r) => !r.contains(parent))) {
            modifiedParents.push(parent);
          }
        }
      }
      for (const record of addedRecords) {
        log == null ? void 0 : log.set(record.id, record.data);
        record.clearChanges();
      }
    }
    if ((altered == null ? void 0 : altered.length) > 0) {
      for (const data of altered) {
        const phantomId = data[phantomIdField], id = ObjectHelper.getPath(data, idDataSource), parentId = ObjectHelper.getPath(data, parentIdDataSource), record = (_d = me.getById(phantomId)) != null ? _d : me.getById(id);
        if (record) {
          const newParentWasLeaf = parentId != null ? (_e = me.getById(parentId)) == null ? void 0 : _e.isLeaf : false;
          const changes2 = record.applyChangeset(data, phantomIdField, remote);
          if (newParentWasLeaf) {
            me.toggleCollapse(record.parent, false);
          }
          if (me.tree && !rootUpdated && modifiedParents.every((r) => !r.contains(record))) {
            if (record.parent.isRoot) {
              rootUpdated = true;
              modifiedParents = [record.parent];
            } else {
              modifiedParents.push(record.parent);
            }
          }
          log == null ? void 0 : log.set(id, changes2);
          allAltered.push(record);
        }
      }
    }
    if ((removed == null ? void 0 : removed.length) > 0) {
      me.applyRemovals(removed);
    }
    if (me.applyChangesetFilterSortTarget === "changes") {
      const parentsModifiedByFilter = me.filterChangeset(allAdded, allAltered);
      modifiedParents.push(...parentsModifiedByFilter);
    }
    me.afterChangesetApplied(modifiedParents);
    if (me.tree && me.isSorted && me.reapplySortersOnAdd && ((added == null ? void 0 : added.length) || (altered == null ? void 0 : altered.length))) {
      const refreshed = /* @__PURE__ */ new Set();
      modifiedParents.forEach((record) => {
        if (refreshed.has(record)) {
          return;
        }
        refreshed.add(record);
        record.sortVisibleChildren(false, me.sorterFn);
        record.sortUnfilteredChildren(false, me.sorterFn);
      });
      me.storage.replaceValues({
        values: me.collectDescendants(me.rootNode).visible,
        silent: true
      });
      me.afterPerformSort(false);
    }
    me._groupVisibleRecordIds = null;
    me.trigger("endApplyChangeset");
    return log;
  }
  afterChangesetApplied(modifiedParents) {
    const visited = /* @__PURE__ */ new Set();
    modifiedParents.forEach((parent) => {
      if (visited.has(parent)) {
        return;
      }
      parent.traverse((record) => {
        if (visited.has(record)) {
          return;
        }
        visited.add(record);
        record.sortOrderedChildren(false, false);
        if (record.children) {
          record.updateChildrenIndices(record.children, "parentIndex", true);
        }
        if (record.unfilteredChildren) {
          record.updateChildrenIndices(record.unfilteredChildren, "unfilteredIndex", true);
        }
      });
    });
  }
  // Apply removals, removing records and updating the `removed` bag to match.
  //
  // Accepts an array of objects containing an `id` property. Records in the store matching an entry in the array
  // will be removed from the store and the `removed` bag. Unmatched entries will be removed from the `removed` bag.
  applyRemovals(removals) {
    const me = this, { removed: removedStash } = me, idDataSource = me.modelClass.idField, toRemove = [];
    for (const removedEntry of removals) {
      const id = ObjectHelper.getPath(removedEntry, idDataSource);
      if (removedStash.includes(id)) {
        const record = removedStash.get(id);
        record.clearChanges(false, true, null);
        record.$isPhantom = true;
        removedStash.remove(id);
      } else {
        toRemove.push(id);
      }
    }
    me.remove(toRemove);
    for (const record of toRemove) {
      removedStash.remove(record);
    }
  }
  /**
   * Filters records that have been added/updated as part of a changeset. The `added` and `updated` parameters
   * are arrays of values that have already been added/updated in the Collection's values. This method brings
   * the Collection's `_filteredValues` in sync without performing a full sort or filter, using the following rules:
   *
   * - Added records that do not match the filter are removed from _filteredValues
   *
   * - Updated records that now match the filter are inserted at the correct position in _filteredValues
   *   if they were not formerly included
   *
   * - Updated records that formerly matched the filter, but now do not, are NOT removed from _filteredValues
   *
   * If the collection is sorted, either on its own or via a sort applied at the store level, that sort order is
   * respected when adding items to _filteredValues. If not, items are inserted in the same order they occur in
   * _values.
   *
   * @param {Object[]} added An array of unique values that were added as part of the changeset.
   * @param {Object[]} updated An array of unique values that were updated as part of the changeset.
   * @returns {Object[]} Any records that were added or removed from view, or whose children were modified.
   * @private
   */
  filterChangeset(added, updated) {
    const me = this, {
      isFiltered,
      tree,
      isGrouped,
      filtersFunction
    } = me, storeSortFunction = me.isSorted ? me.createSorterFn(me.sorters) : void 0, {
      allValues,
      addedValues,
      isSorted
    } = me.storage, sorter = storeSortFunction != null || isSorted ? storeSortFunction != null ? storeSortFunction : me.storage.sortFunction : null, modifiedParents = /* @__PURE__ */ new Set();
    if (!isFiltered) {
      return [];
    }
    let trigger = false, groupers;
    if (isGrouped) {
      groupers = me.groupers;
      me.clearGroupers(true);
    }
    if (tree) {
      const nodesToInclude = new Set(updated.filter(filtersFunction));
      for (const matchingAdd of added.filter(filtersFunction)) {
        nodesToInclude.add(matchingAdd);
      }
      nodesToInclude.forEach((node) => node.bubble((ancestor) => nodesToInclude.add(ancestor)));
      nodesToInclude.delete(me.rootNode);
      const nodesToIncludeByParent = ArrayHelper.groupBy(
        // filter out the nodes that are already included to `children`
        Array.from(nodesToInclude).filter((child) => {
          var _a2, _b;
          return !((_b = (_a2 = child.parent) == null ? void 0 : _a2.children) == null ? void 0 : _b.includes(child));
        }),
        "parentId"
      );
      for (const siblingsToInclude of Object.values(nodesToIncludeByParent)) {
        const { parent } = siblingsToInclude[0];
        if (parent.unfilteredChildren) {
          parent.children.push(...siblingsToInclude);
          modifiedParents.add(parent);
        }
      }
    } else if (sorter && !isGrouped) {
      const { filteredValues } = me.storage, sortedLength = addedValues ? filteredValues.findLastIndex((value) => !addedValues.has(value)) + 1 : filteredValues.length, sorted = filteredValues.slice(0, sortedLength), updatedMatches = new Set(updated.filter(filtersFunction));
      for (const value of filteredValues) {
        if (updatedMatches.has(value)) {
          updatedMatches.delete(value);
        }
      }
      for (const newMatch of updatedMatches) {
        sorted.push(newMatch);
      }
      sorted.sort(sorter);
      filteredValues.splice(0, sortedLength, ...sorted);
      trigger = true;
    } else {
      const updatedMatches = updated.filter((item) => filtersFunction(item) && !me.storage.includes(item));
      if (updatedMatches.length > 0) {
        me.includeInSubset(allValues, me.storage.filteredValues, updatedMatches);
        trigger = true;
      }
    }
    const nonMatchingAdds = new Set(added.filter((value) => !filtersFunction(value)));
    if (nonMatchingAdds.size > 0) {
      if (tree) {
        for (const addedChild of nonMatchingAdds) {
          ArrayHelper.remove(addedChild.parent.children, addedChild);
          modifiedParents.add(addedChild.parent);
        }
      } else {
        ArrayHelper.remove(me.storage.filteredValues, nonMatchingAdds);
      }
      trigger = true;
    }
    if (groupers) {
      me.group(groupers[0], null, false, true, true);
      trigger = true;
    }
    if (tree && modifiedParents.size > 0) {
      me.storage.replaceValues({
        values: me.collectDescendants(me.rootNode).visible,
        silent: true
      });
    } else if (trigger) {
      me._idMap = null;
      me.trigger("refresh");
    }
    return [...modifiedParents];
  }
  /**
   * Given an array `all`, an array `subset` that is a subset of `all` in the same order, and another array
   * `toInclude` that is a different subset of `all` disjoint with `subset`, add each item from `toInclude`
   * to `subset`, in an order matching the order in `all`. The order of `subset` must match the order of `all`.
   * The order of `toInclude` is unimportant.
   *
   * Modifies `subset` in-place.
   *
   * @param {Array} all An array of unique items (e.g. records)
   * @param {Array} subset An array containing a subset of the items in `all` (same order as `all`)
   * @param {Array} toInclude An array or items from `all` that should be included in `subset` (unordered)
   * @returns {Array} The subset modified in-place.
   * @private
   */
  includeInSubset(all, subset, toInclude) {
    const toIncludeSet = new Set(toInclude);
    let subsetIndex = 0, allIndex = 0, done = toIncludeSet.size === 0;
    while (allIndex < all.length && !done) {
      const subsetItem = subset[subsetIndex];
      let allItem = all[allIndex];
      while (subsetItem !== allItem) {
        if (toIncludeSet.has(allItem)) {
          subset.splice(subsetIndex, 0, allItem);
          subsetIndex++;
          toIncludeSet.delete(allItem);
          done = toIncludeSet.size === 0;
        }
        allItem = all[++allIndex];
      }
      if (toIncludeSet.has(subsetItem)) {
        toIncludeSet.delete(subsetItem);
      }
      if (subsetIndex < subset.length) {
        subsetIndex++;
      }
    }
    return subset;
  }
};

// ../Core/lib/Core/data/mixin/StoreFilter.js
var StoreFilter_default = (Target) => class StoreFilter extends (Target || Base) {
  static get $name() {
    return "StoreFilter";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Specify one or more {@link Core/util/CollectionFilter} config objects to apply initially.
       *
       * For example:
       *
       * ```javascript
       *  // Configure the store to filter in clients over the age of 30
       *  new Store({
       *      ...,
       *      filters : [{
       *          property : 'age',
       *          value    : 30,
       *          operator : '>'
       *      }],
       *      ...
       *  })
       * ```
       *
       * or:
       *
       * ```javascript
       *  // Configure the store to filter based on a complex operation
       *  new Store({
       *      ...,
       *      filters : [{
       *          filterBy(record) {
       *              // Return true or false for filtering in or out
       *              return shouldClientBeVisible(record);
       *          }
       *      }],
       *      ...
       *  })
       * ```
       *
       * @config {CollectionFilterConfig|CollectionFilterConfig[]}
       * @category Filtering
       */
      filters: null,
      /**
       * Specify true to reapply filters when a record is added to the store.
       * @config {Boolean}
       * @default
       * @category Filtering
       */
      reapplyFilterOnAdd: false,
      /**
       * Specify true to reapply filters when a record is updated in the store.
       * @config {Boolean}
       * @default
       * @category Filtering
       */
      reapplyFilterOnUpdate: false
    };
  }
  //endregion
  //region Events
  /**
   * Fired after applying filters to the store
   * @event filter
   * @param {Core.data.Store} source This Store
   * @param {Core.util.Collection} filters Filters used by this Store
   * @param {Core.data.Model[]} removed The records which were filtered out by the action.
   * @param {Core.data.Model[]} added The records which were filtered back in by the action.
   * @param {Core.data.Model[]} records Filtered records
   */
  //endregion
  //region Properties
  set reapplyFilterOnAdd(enable) {
    this.storage.autoFilter = enable;
  }
  get reapplyFilterOnAdd() {
    return this.storage.autoFilter;
  }
  /**
   * Currently applied filters. A collection of {@link Core.util.CollectionFilter} instances.
   * @type {Core.util.Collection}
   * @readonly
   * @category Sort, group & filter
   */
  set filters(filters) {
    const me = this, collection = me.filters;
    collection.clear();
    me._filtersFunction = null;
    if (filters) {
      if (filters.constructor.name === "Object") {
        for (const f of Object.entries(filters)) {
          if (f[0] === "filterBy" && typeof f[1] === "function") {
            collection.add(new CollectionFilter({
              filterBy: f[1]
            }));
          } else {
            collection.add(new CollectionFilter(f[1].constructor.name === "Object" ? Object.assign({
              property: f[0]
            }, f[1]) : {
              property: f[0],
              value: f[1]
            }));
          }
        }
      } else if (Array.isArray(filters)) {
        collection.add(...filters.map((filterConfig) => {
          if (filterConfig instanceof CollectionFilter) {
            return filterConfig;
          }
          return new CollectionFilter(filterConfig);
        }));
      } else if (filters.isCollection) {
        collection.add(...filters.values);
      } else {
        collection.add(new CollectionFilter({
          filterBy: filters
        }));
      }
      collection.forEach((item) => item.owner = me);
    }
  }
  get filters() {
    return this._filters || (this._filters = new Collection({ extraKeys: ["property"] }));
  }
  set filtersFunction(filtersFunction) {
    this._filtersFunction = filtersFunction;
  }
  get filtersFunction() {
    const me = this, { filters, isGrouped } = me;
    if (!me._filtersFunction) {
      if (filters.count) {
        const generatedFilterFunction = CollectionFilter.generateFiltersFunction(filters);
        me._filtersFunction = (candidate) => {
          if (isGrouped && candidate.isSpecialRow) {
            return candidate.groupChildren.some(generatedFilterFunction);
          }
          return generatedFilterFunction(candidate);
        };
      } else {
        me._filtersFunction = FunctionHelper.returnTrue;
      }
    }
    return me._filtersFunction;
  }
  /**
   * Check if store is filtered
   * @property {Boolean}
   * @readonly
   * @category Sort, group & filter
   */
  get isFiltered() {
    return this.filters.values.some((filter2) => !filter2.disabled);
  }
  //endregion
  traverseFilter(record) {
    const me = this, hitsCurrent = !record.isRoot && me.filtersFunction(record), children = record.unfilteredChildren || record.children;
    if (!children || !children.length) {
      return hitsCurrent;
    }
    if (!record.unfilteredChildren) {
      record.unfilteredChildren = record.children.slice();
    }
    record.children = record.unfilteredChildren.filter((r) => {
      return me.traverseFilter(r);
    });
    if (me.isSorted) {
      record.children.sort(me.sorterFn);
    }
    record.updateChildrenIndices(record.unfilteredChildren, "unfilteredIndex", true);
    record.updateChildrenIndices(record.children, "parentIndex", true);
    return hitsCurrent || Boolean(record.children.length);
  }
  traverseClearFilter(record) {
    const me = this;
    if (record.unfilteredChildren) {
      record.children = record.orderedChildren.slice();
      record.unfilteredChildren = null;
    }
    if (record.children) {
      if (me.isSorted) {
        record.children.sort(me.sorterFn);
      }
      record.children.forEach((r) => me.traverseClearFilter(r));
      record.updateChildrenIndices(record.children, "parentIndex", true);
    }
  }
  get latestFilterField() {
    return this.filters.last ? this.filters.last.property : null;
  }
  /**
   * Adds a single filter to the {@link #config-filters} collection. By default, filters are reevaluated
   * and a Store change event fired.
   *
   * If the `silent` parameter is passed as `true`, multiple filters can be added without causing data changes.
   *
   * When the filters are as required, call {@link #function-filter} with no parameters
   * to apply the filters to the store.
   *
   * @param {CollectionFilterConfig|Function} newFilter A {@link Core.util.CollectionFilter filter} config,
   * or a function to use for filtering.
   * @param {Boolean} [silent] Pass `true` to *not* refilter the store immediately. Such as when
   * adding multiple filters.
   * @returns {Core.util.CollectionFilter} The Filter instance that was added.
   * @returns {Promise|Core.util.CollectionFilter} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method
   * returns Collection filter inside a `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  addFilter(filter2, silent = false) {
    const me = this;
    filter2 = filter2 instanceof CollectionFilter ? filter2 : new CollectionFilter(filter2);
    filter2.owner = me;
    me.filters.add(filter2);
    if (!silent) {
      if (me.remoteFilter) {
        return me.filter().then(() => filter2);
      } else {
        me.filter();
      }
    }
    return filter2;
  }
  /**
   * Filters the store by **adding** the specified filter(s) to the existing filters collection applied to this Store.
   * If a filter has an {@link Core.util.CollectionFilter#config-id id} specified,
   * or a {@link Core.util.CollectionFilter#config-property property} specified,
   * it will search for corresponding filter(s) in the existing filters first and replace it with a new filter.
   * **It will not remove other filters applied to the store!**
   *
   * To **add** a new filter:
   *
   * ```javascript
   * // Filter using simple object
   * store.filter({
   *     property : 'age',
   *     operator : '>',
   *     value    : 90
   * });
   *
   * // Filter using function
   * store.filter(r => r.age < 90);
   *
   * // Filter using a named filter as a function
   * store.filter({
   *     id : 'my-filter',
   *     filterBy : record => record.score > 10
   * });
   * ```
   *
   * To **remove** a specific filter, but keep other filters applied
   *
   * ```javascript
   * // Remove by filter `id` or `property`. Filter `id` defaults to the `property` name.
   * store.removeFilter('age');
   * store.removeFilter('my-filter');
   * ```
   *
   * To **replace** all existing filters with a new filter
   *
   * ```javascript
   * // Remove all filters and filter using simple object
   * store.filter({
   *     filters : {
   *         property : 'age',
   *         operator : '<',
   *         value    : 90
   *     },
   *     replace : true
   * });
   *
   * // Remove all filters and filter using function
   * store.filter({
   *     filters : r => r.age > 90,
   *     replace : true
   * });
   *
   * // Remove all filters and filter using a named filter as a function
   * store.filter({
   *     filters : {
   *         id : 'my-filter',
   *         filterBy : record => record.score > 10
   *     },
   *     replace : true
   * });
   * ```
   *
   * Basically filters replacing is an equivalent of having two sequenced calls:
   * {@link #function-clearFilters clearFilters} and {@link #function-filter filter}.
   *
   * Call without arguments to reapply filters.
   *
   * ```javascript
   * // Re-filter the store
   * store.filter();
   * ```
   *
   * @param {Object|CollectionFilterConfig|CollectionFilterConfig[]|Function} newFilters
   *        A {@link Core.util.CollectionFilter filter} config,
   *        or an array of {@link Core.util.CollectionFilter filter} configs,
   *        or a function to use for filtering,
   *        or a special object like: ```{ replace : true, filters : newFilters }```
   * @param {Boolean} [newFilters.replace]
   *        A flag, indicating whether or not the previous filters should be removed.
   * @param {Boolean} [newFilters.silent]
   *        Set as true to not fire events. UI will not be informed about the changes.
   * @param {CollectionFilterConfig|CollectionFilterConfig[]|Function} [newFilters.filters]
   *        If `newFilters` is an object and `replace` property is defined in the `newFilters`,
   *        it means that special object is used and real filter configuration must be nested down to this `filters` property.
   *        It can be:
   *        A {@link Core.util.CollectionFilter filter} config,
   *        or an array of {@link Core.util.CollectionFilter filter} configs,
   *        or a function to use for filtering.
   * @fires filter
   * @fires change
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns Promise
   * which is resolved after data is loaded from remote server, otherwise it returns null value
   * @async
   * @category Sort, group & filter
   */
  filter(newFilters) {
    const me = this;
    let silent = false, internal;
    if (newFilters) {
      let fieldType = typeof newFilters;
      if (fieldType === "object") {
        if ("silent" in newFilters || "replace" in newFilters || newFilters.filters) {
          silent = newFilters.silent;
          if (newFilters.replace) {
            me.clearFilters(newFilters.filters.length === 0);
          }
          internal = newFilters.internal;
          newFilters = newFilters.filters;
          fieldType = typeof newFilters;
        }
      }
      if (newFilters) {
        const wasFiltered = me.isFiltered;
        me.isConfiguring = true;
        if (Array.isArray(newFilters)) {
          newFilters.forEach((f) => me.addFilter(f, true), me);
        } else if (fieldType === "function") {
          const filter2 = new CollectionFilter(newFilters);
          filter2.internal = internal;
          me.addFilter(filter2, true);
        } else if (fieldType === "string") {
          me.addFilter({
            property: newFilters,
            value: arguments[1]
          }, true);
        } else {
          me.addFilter(newFilters, true);
        }
        me.isConfiguring = false;
        if (!me.isFiltered && !wasFiltered) {
          return null;
        }
      }
    }
    me.filtersFunction = null;
    const result = me.performFilter(silent);
    me._idMap = null;
    return result;
  }
  /**
   * Perform filtering according to the {@link #property-filters} Collection.
   * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and
   * must not be overridden.
   * @private
   */
  performFilter(silent) {
    const me = this, { storage, filters, rootNode } = me, oldCount = me.count;
    me.trigger("beforeFilter", { filters });
    let added, removed;
    if (me.tree) {
      const oldDataset = storage.values;
      if (me.isFiltered) {
        me.traverseFilter(rootNode);
      } else {
        me.traverseClearFilter(rootNode);
      }
      const newDataset = me.collectDescendants(rootNode).visible;
      storage.replaceValues({
        values: newDataset,
        silent: true
      });
      const delta = ArrayHelper.delta(newDataset, oldDataset, true);
      added = delta.toAdd;
      removed = delta.toRemove;
    } else {
      storage.ion({
        change({ removed: r, added: a }) {
          removed = r;
          added = a;
        },
        once: true
      });
      if (me.isFiltered) {
        me.isGrouped && me.includeCollapsed();
        storage.addFilter({
          id: "primary-filter",
          filterBy: me.filtersFunction
        });
        me.isGrouped && me.excludeCollapsed();
      } else {
        storage.filters.clear();
      }
    }
    me.afterPerformFilter(silent || me.isRemoteDataLoading ? null : {
      action: "filter",
      filters,
      oldCount,
      added,
      removed,
      records: me.storage.values
    });
  }
  afterPerformFilter(event) {
    this.resetRelationCache();
    if (event) {
      this.triggerFilterEvent(event);
    }
  }
  // Used from filter() and StoreCRUD when reapplying filters
  triggerFilterEvent(event) {
    this.trigger("filter", event);
    if (!this.remoteFilter) {
      this.trigger("refresh", event);
      this.trigger("change", event);
    }
  }
  /**
   * *Adds* a function used to filter the store. Alias for calling `filter(fn)`. Return `true` from the function to
   * include record in filtered set
   *
   * ```javascript
   * store.filterBy(record => record.age > 25 && record.name.startsWith('A'));
   * ```
   *
   * @param {Function} fn Function used to test records
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  filterBy(fn2) {
    return this.filter(fn2);
  }
  /**
   * Removes the passed filter, or the filter by the passed ID from the {@link #config-filters} collection.
   * By default, filters are reevaluated and a Store change event fired.
   *
   * If the `silent` parameter is passed as `true`, multiple filters can be removed without causing data changes.
   *
   * When the filters are as required, call {@link #function-filter} with no parameters
   * to apply the filters to the store.
   *
   * ```javascript
   * // Only view top priority events
   * myEventStore.filter({
   *     id       : 'priorityFilter',
   *     property : 'priority',
   *     value    : 1,
   *     operator : '='
   * });
   *
   * // That individual filter can be removed like this
   * myEventStore.removeFilter('priorityFilter');
   *
   * // Add named filter as a function
   * store.filter({
   *     id : 'my filter',
   *     filterBy : record => record.score > 10
   * });
   *
   * // Remove named filter function
   * store.removeFilter('my filter');
   * ```
   *
   * @param {String|Core.util.CollectionFilter} idOrInstance Filter to remove, or ID of the filter to remove. By default,
   * filters are reevaluated and a change event fired.
   * @param {Boolean} [silent] Pass `true` to *not* refilter the store immediately. Such as when
   * removing multiple filters.
   * @returns {Promise|Core.util.CollectionFilter} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method
   * returns Collection filter inside a `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  removeFilter(idOrInstance, silent = false) {
    const me = this, filter2 = idOrInstance instanceof CollectionFilter ? idOrInstance : me.filters.get(idOrInstance);
    if (filter2) {
      me.filters.remove(filter2);
      me._filtersFunction = null;
      if (!silent) {
        if (me.remoteFilter) {
          return me.filter().then(() => filter2);
        } else {
          me.filter();
        }
      }
      return filter2;
    }
  }
  /**
   * Removes all filters from the store.
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  clearFilters(apply = true) {
    this.filters.remove(this.filters.values.filter((f) => !f.internal));
    if (apply) {
      return this.filter();
    }
  }
  convertFilterToString(field) {
    const filter2 = this.filters.getBy("property", field);
    return filter2 && !filter2.filterBy ? String(filter2) : "";
  }
  doDestroy() {
    var _a2;
    (_a2 = this._filters) == null ? void 0 : _a2.destroy();
    super.doDestroy();
  }
};

// ../Core/lib/Core/data/mixin/StoreGroup.js
var resortActions = {
  add: 1,
  replace: 1
};
var defaultGroupSortFn = ({ _groupValue: lhs }, { _groupValue: rhs }) => lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
var StoreGroup_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    static get properties() {
      return {
        collapsedGroups: /* @__PURE__ */ new Set()
      };
    }
    //endregion
    //region Init
    construct(config) {
      super.construct(config);
      this.ion({ change: "onDataChanged", thisObj: this });
    }
    get GroupRow() {
      var _a3;
      return this._GroupRowClass || (this._GroupRowClass = (_a3 = class extends this.modelClass {
        get isCollapsed() {
          return this.meta.collapsed;
        }
      }, __publicField(_a3, "isSpecialRow", true), // The calculated group value for this group header/footer.
      __publicField(_a3, "fields", [{
        name: "_groupValue"
      }]), _a3));
    }
    updateGroupers(groupers) {
      this.setGroupers(groupers);
    }
    /**
     * Set groupers.
     * @param {Grouper[]} groupers Array of groupers to apply to store
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns
     * `Promise` which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @category Sort, group & filter
     */
    setGroupers(groupers, options = null) {
      const me = this, { storage } = me;
      let result;
      if (groupers == null ? void 0 : groupers.length) {
        me._groupers = groupers;
      } else if (me.groupers) {
        delete me._groupers;
        me.includeCollapsed();
        storage.replaceValues({
          values: me.removeHeadersAndFooters(storage._values),
          filteredValues: storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,
          silent: true
        });
        result = me.group(null, null, null, false, options == null ? void 0 : options.silent);
      }
      me._idMap = null;
      return result;
    }
    get unfilteredGroupRecords() {
      var _a3;
      const me = this;
      if (me.isGrouped) {
        const { generation } = me.storage;
        if (((_a3 = me._unfilteredGroupRecords) == null ? void 0 : _a3.generation) !== generation) {
          me._unfilteredGroupRecords = me.storage.allValues.filter((r) => r.isSpecialRow);
          me._unfilteredGroupRecords.generation = generation;
        }
      }
      return me._unfilteredGroupRecords || [];
    }
    /**
     * Returns group header record for the passed record or last group header in the store
     * @param {Core.data.Model} [targetRecord]
     * @param {Boolean} [ignoreFilter] Pass true to search in the complete collection
     * @returns {Core.data.Model}
     * @internal
     */
    getGroupHeaderForRecord(targetRecord, ignoreFilter = false) {
      if (this.isGrouped) {
        return targetRecord ? targetRecord.meta.groupRowFor ? targetRecord : targetRecord.groupParent.get(this.id) : this.groupRecords.last;
      }
    }
    // Temporarily include records from collapsed groups, for example prior to filtering
    includeCollapsed() {
      for (const groupId of this.collapsedGroups) {
        this.expand(this.getById(groupId), false);
      }
    }
    // Exclude records in collapsed groups, intended to be used after a call to includeCollapsed()
    excludeCollapsed() {
      for (const groupId of this.collapsedGroups) {
        this.collapse(this.getById(groupId));
      }
    }
    onDataChange({ source: storage, action, removed }) {
      var _a3;
      const me = this, { groupers } = me;
      if (groupers) {
        if (groupers.length) {
          if (action === "splice" && (removed == null ? void 0 : removed.length) || action === "move") {
            storage.replaceValues({
              ...me.prepareGroupRecords(),
              silent: true
            });
          }
        } else {
          storage.replaceValues({
            values: me.removeHeadersAndFooters(storage._values),
            filteredValues: storage.isFiltered ? me.removeHeadersAndFooters(storage._filteredValues) : null,
            silent: true
          });
        }
      }
      (_a3 = super.onDataChange) == null ? void 0 : _a3.call(this, ...arguments);
    }
    move(records, beforeRecord) {
      const me = this;
      if (me.isGrouped && !me.tree) {
        let prevRecord = beforeRecord;
        if (beforeRecord == null ? void 0 : beforeRecord.isSpecialRow) {
          prevRecord = me.getPrev(beforeRecord, false, false);
          if (!prevRecord) {
            return;
          }
        }
        const targetGroupHeader = me.getGroupHeaderForRecord(prevRecord), groupField = me.groupers[0].field, newGroupValue = targetGroupHeader.meta.groupRowFor, { reapplyFilterOnUpdate } = me;
        me.reapplyFilterOnUpdate = false;
        me.beginBatch();
        records.forEach((record) => record.setValue(groupField, newGroupValue));
        me.endBatch();
        me.reapplyFilterOnUpdate = reapplyFilterOnUpdate;
        if (me.isFiltered && (beforeRecord == null ? void 0 : beforeRecord.isSpecialRow)) {
          const { unfilteredGroupRecords } = me, index = unfilteredGroupRecords.indexOf(targetGroupHeader);
          beforeRecord = unfilteredGroupRecords[index + 1];
        }
      }
      super.move(records, beforeRecord);
    }
    // private function that collapses on the data level
    collapse(groupRecord) {
      if (groupRecord && !groupRecord.meta.collapsed) {
        this.excludeGroupRecords(groupRecord);
        groupRecord.meta.collapsed = true;
        this.collapsedGroups.add(groupRecord.id);
        this.trigger("toggleGroup", { groupRecord, collapse: true });
        return true;
      }
      return false;
    }
    // private function that expands on the data level
    expand(groupRecord, updateMap = true) {
      if (groupRecord == null ? void 0 : groupRecord.meta.collapsed) {
        this.includeGroupRecords(groupRecord);
        groupRecord.meta.collapsed = false;
        updateMap && this.collapsedGroups.delete(groupRecord.id);
        updateMap && this.trigger("toggleGroup", { groupRecord, collapse: false });
        return true;
      }
      return false;
    }
    removeHeadersAndFooters(records) {
      return records.filter((r) => {
        var _a3;
        if (r.unfilteredGroupChildren) {
          r.groupChildren.length = r.unfilteredGroupChildren.length = r.meta.childCount = 0;
        }
        if (r.isSpecialRow || r.isLinked && ((_a3 = r.groupParent) == null ? void 0 : _a3.get(this.id))) {
          this.unregister(r);
          return false;
        }
        return true;
      });
    }
    prepareGroupRecords() {
      var _a3;
      const me = this, {
        GroupRow,
        isFiltered,
        reapplyFilterOnUpdate,
        groupRecords
      } = me, grouper = me.groupers[0], multiplier = grouper.ascending !== false ? 1 : -1, {
        field,
        fn: groupSortFn = defaultGroupSortFn
      } = grouper, byFn = typeof field === "function", groupingById = field === me.modelClass.idField, newGroupRecords = new Collection(), visibleRecordsIds = me._groupVisibleRecordIds || [], isVisible2 = (record) => {
        const matchesFilter = !isFiltered || me.filtersFunction(record);
        return reapplyFilterOnUpdate ? matchesFilter : matchesFilter || visibleRecordsIds.includes(record.id);
      }, collapseAll = Boolean(me.startGroupsCollapsed && !(groupRecords == null ? void 0 : groupRecords.count));
      groupRecords == null ? void 0 : groupRecords.forEach((groupRec) => {
        if (groupRec.isCollapsed) {
          me.includeGroupRecords(groupRec);
        }
      });
      const records = me.removeHeadersAndFooters(me.storage._values);
      if (me.sorters.length) {
        records.sort(me.sorterFn);
      }
      if (isFiltered) {
        me.filtersFunction = null;
      }
      records.forEach((rec) => {
        const original = rec, v = byFn ? field(rec) : rec[field], groupValues = ArrayHelper.asArray(v == void 0 ? "__novalue__" : v), multiValue = Array.isArray(groupValues), emptyArray13 = multiValue && !groupValues.length, length = emptyArray13 ? 1 : groupValues.length;
        for (let i = 0; i < length; i++) {
          const groupValue = emptyArray13 ? [] : groupValues[i], id = `group-header-${typeof groupValue === "number" ? groupValue : StringHelper.createId(groupValue)}`;
          let groupRec = newGroupRecords.get(id);
          if (!groupRec) {
            groupRec = (groupRecords == null ? void 0 : groupRecords.get(id)) || new GroupRow({
              [me.modelClass.idField]: id,
              [groupingById ? "" : field]: groupValue,
              _groupValue: groupValue
            }, me, {
              collapsed: collapseAll,
              specialRow: true,
              groupRowFor: groupValue,
              groupField: field,
              emptyArray: emptyArray13
            });
            newGroupRecords.add(groupRec);
            groupRec.meta.childCount = 0;
            groupRec.groupChildren = [];
            groupRec.unfilteredGroupChildren = [];
            groupRec.stores = [me];
          }
          me.register(groupRec);
          if (i > 0) {
            const links = original.groupLinks || (original.groupLinks = []);
            rec = links[groupValue] || (links[groupValue] = original.link());
            rec.stores = [me];
            me.register(rec);
          }
          if (!rec.groupParent) {
            rec.setData("groupParent", /* @__PURE__ */ new Map());
          }
          rec.groupParent.set(me.id, groupRec);
          if (isVisible2(rec)) {
            groupRec.groupChildren.push(rec);
            groupRec.meta.childCount++;
          }
          groupRec.unfilteredGroupChildren.push(rec);
        }
      });
      newGroupRecords._values.sort((lhs, rhs) => groupSortFn(lhs, rhs) * multiplier);
      if (me.useGroupFooters) {
        for (let index = 0, length = newGroupRecords.count; index < length; index++) {
          const groupRec = newGroupRecords.values[index], val = groupRec.meta.groupRowFor, id = `group-footer-${typeof val === "number" ? val : StringHelper.createId(val)}`, footer = me.getById(id) || new GroupRow({
            [me.modelClass.idField]: id,
            [groupingById ? "" : field]: val,
            _groupValue: val
          }, me, {
            specialRow: true,
            groupFooterFor: val,
            groupRecord: groupRec
          });
          footer.stores = [me];
          me.register(footer);
          footer.groupChildren = groupRec.groupChildren;
          newGroupRecords.splice(++index, 0, footer);
          length++;
          groupRec.groupChildren.push(footer);
          groupRec.unfilteredGroupChildren.push(footer);
          groupRec.meta.childCount++;
        }
      }
      me._idMap = null;
      const result = {
        values: newGroupRecords.reduce((result2, groupRec) => {
          if (!groupRec.isGroupFooter) {
            result2.push(groupRec);
            if (!groupRec.meta.collapsed) {
              result2.push(...groupRec.unfilteredGroupChildren);
            }
          }
          return result2;
        }, false, [])
      };
      if (isFiltered) {
        result.filteredValues = result.values.filter(isVisible2);
      }
      (_a3 = me.groupRecords) == null ? void 0 : _a3.forEach((oldGroupRec) => {
        if (!newGroupRecords.includes(oldGroupRec)) {
          oldGroupRec.destroy();
        }
      });
      me.groupRecords = newGroupRecords;
      return result;
    }
    //endregion
    //region Group and ungroup
    /**
     * Is store currently grouped?
     * @property {Boolean}
     * @readonly
     * @category Sort, group & filter
     */
    get isGrouped() {
      var _a3;
      return Boolean((_a3 = this.groupers) == null ? void 0 : _a3.length);
    }
    /**
     * Group records, either by replacing current sorters or by adding to them.
     * A grouper can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).
     * Works in the same way as a standard array sorter, except that returning `null` triggers the stores
     * normal sorting routine. Grouped store **must** always be sorted by the same field.
     *
     * ```javascript
     * // simple grouper
     * store.group('city');
     *
     * // grouper as object, descending order
     * store.group({ field : 'city', ascending : false });
     *
     * // using custom sorting function
     * store.group({
     *     field : 'city',
     *     fn : (recordA, recordB) => {
     *         // apply custom logic, for example:
     *         return recordA.city.length < recordB.city.length ? -1 : 1;
     *     }
     * });
     * ```
     *
     * @param {String|Object} field Field to group by.
     * Can also be a config containing a field to group by and a custom sorting function called `fn`.
     * @param {Boolean} [ascending] Sort order of the group titles
     * @param {Boolean} [add] Add a grouper (true) or use only this grouper (false)
     * @param {Boolean} [performSort] Trigger sort directly, which does the actual grouping
     * @param {Boolean} [silent] Set as true to not fire events
     * @category Sort, group & filter
     * @fires group
     * @fires refresh
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     */
    group(field, ascending, add = false, performSort = true, silent = false) {
      var _a3, _b;
      const me = this;
      let newGrouper, fn2;
      if (field && typeof field === "object") {
        ascending = field.ascending;
        fn2 = field.fn;
        field = field.field;
      }
      if (add) {
        me.groupers.push(newGrouper = {
          field,
          ascending,
          complexMapping: field.includes(".")
        });
      } else if (field) {
        if (ascending == null) {
          ascending = ((_a3 = me.groupInfo) == null ? void 0 : _a3.field) === field && ((_b = me.groupInfo) == null ? void 0 : _b.fn) === fn2 ? !me.groupInfo.ascending : true;
        }
        me.groupInfo = newGrouper = {
          field,
          ascending,
          fn: fn2,
          complexMapping: field.includes(".")
        };
        me.groupers = [me.groupInfo];
      }
      if (newGrouper) {
        const { prototype: prototype2 } = me.modelClass;
        if (newGrouper.complexMapping && !Object.prototype.hasOwnProperty.call(prototype2, field)) {
          Object.defineProperty(prototype2, field, {
            get() {
              return ObjectHelper.getPath(this, field);
            }
          });
        }
      }
      if (performSort !== false) {
        if (me.remoteSort && !me.isRemoteDataLoading) {
          return me.sort(null, null, false, true).then(() => me.onAfterGrouping(silent));
        } else {
          me.sort(null, null, false, true);
        }
      }
      me.onAfterGrouping(silent);
    }
    onAfterGrouping(silent) {
      if (silent) {
        return;
      }
      const me = this, groupers = me.groupers || [];
      me.trigger("group", { isGrouped: me.isGrouped, groupers, records: me.storage.values });
      me.trigger("refresh", { action: "group", isGrouped: me.isGrouped, groupers, records: me.storage.values });
    }
    // Internal since UI does not support multi grouping yet
    /**
     * Add a grouping level (a grouper).
     * @param {String} field Field to group by
     * @param {Boolean} ascending Group direction
     * @category Sort, group & filter
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @internal
     */
    addGrouper(field, ascending = true) {
      return this.group(field, ascending, true);
    }
    // Internal since UI does not support multi grouping yet
    /**
     * Removes a grouping level (a grouper)
     * @param {String} field Grouper to remove
     * @category Sort, group & filter
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @internal
     */
    removeGrouper(field) {
      const me = this, { groupers } = me;
      if (!groupers) {
        return;
      }
      const index = groupers.findIndex((grouper) => grouper.field === field);
      if (index > -1) {
        groupers.splice(index, 1);
        if (!groupers.length) {
          return me.clearGroupers();
        } else {
          return me.group();
        }
      }
    }
    /**
     * Removes all groupers, turning store grouping off.
     * @privateparam {Boolean} [silent=false] Pass true to suppress events.
     * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
     * which is resolved after data is loaded from remote server, otherwise it returns `null`
     * @async
     * @category Sort, group & filter
     */
    clearGroupers(silent = false) {
      return this.setGroupers(null, { silent });
    }
    //endregion
    //region Get and check
    /**
     * Check if a record belongs to a certain group (only for the first grouping level)
     * @param {Core.data.Model} record The Record
     * @param {*} groupValue The group value
     * @returns {Boolean} True if the record belongs to the group, otherwise false
     * @category Sort, group & filter
     */
    isRecordInGroup(record, groupValue) {
      var _a3;
      if (!this.isGrouped) {
        return null;
      }
      const groupField = (_a3 = this.groupers[0]) == null ? void 0 : _a3.field;
      return record.getValue(groupField) === groupValue && !record.isSpecialRow;
    }
    isInCollapsedGroup(record) {
      const parentGroupRec = record.groupParent.get(this.id);
      return parentGroupRec == null ? void 0 : parentGroupRec.meta.collapsed;
    }
    /**
     * Returns all records in the group with specified groupValue.
     * @param {*} groupValue
     * @returns {Core.data.Model[]} Records in specified group or null if store not grouped
     * @category Sort, group & filter
     */
    getGroupRecords(groupValue) {
      if (!this.isGrouped) {
        return null;
      }
      return this.storage.values.filter((record) => this.isRecordInGroup(record, groupValue));
    }
    /**
     * Get all group titles.
     * @returns {String[]} Group titles
     * @category Sort, group & filter
     */
    getGroupTitles() {
      if (!this.isGrouped) {
        return null;
      }
      return this.getDistinctValues(this.groupers[0].field);
    }
    //endregion
    onDataChanged({ changes, action }) {
      if (this.isGrouped && // If an action flagged as requiring resort is performed...
      (!changes && resortActions[action] || // ...or if the group field has changes...
      changes && this.groupers.some((grouper) => grouper.field in changes))) {
        this.sort();
      }
    }
    /**
     * Adds or removes records in a group from storage. Used when expanding/collapsing groups.
     * @private
     * @param {Core.data.Model} groupRecord Group which records should be added or removed
     * @param {Boolean} include Include (true) or exclude (false) records
     * @category Grouping
     */
    internalIncludeExcludeGroupRecords(groupRecord, include) {
      const me = this, index = me.indexOf(groupRecord), allIndex = me.allIndexOf(groupRecord), { id: mapId, storage } = me, {
        _filteredValues,
        _values
      } = storage, {
        meta,
        groupChildren,
        unfilteredGroupChildren
      } = groupRecord;
      if (allIndex === -1 || meta.collapsed && !include || !meta.collapsed && include) {
        return;
      }
      unfilteredGroupChildren.forEach(
        (child) => child.instanceMeta(mapId).hiddenByCollapse = !include
      );
      if (include) {
        if (_filteredValues) {
          _filteredValues.splice(index + 1, 0, ...groupChildren.filter((r) => !me.isAvailable(r)));
        }
        storage._values.splice(allIndex + 1, 0, ...unfilteredGroupChildren.filter((r) => !me.isAvailable(r)));
      } else {
        if (_filteredValues) {
          _filteredValues.splice(index + 1, groupChildren.length);
        }
        _values.splice(allIndex + 1, unfilteredGroupChildren.length);
      }
      storage._indicesInvalid = true;
      me._idMap = null;
    }
    /**
     * Removes records in a group from storage. Used when collapsing a group.
     * @private
     * @param groupRecord Group which records should be removed
     * @category Grouping
     */
    excludeGroupRecords(groupRecord) {
      this.internalIncludeExcludeGroupRecords(groupRecord, false);
    }
    /**
     * Adds records in a group to storage. Used when expanding a group.
     * @private
     * @param groupRecord Group which records should be added
     * @category Grouping
     */
    includeGroupRecords(groupRecord) {
      this.internalIncludeExcludeGroupRecords(groupRecord, true);
    }
    /**
     * Collects all group headers + children, whether expanded or not
     * @private
     * @param {Boolean} allRecords True to include filtered out records
     * @param {Boolean} includeHeaders True to also include group headers
     * @returns {Core.data.Model[]}
     */
    collectGroupRecords(allRecords, includeHeaders = true) {
      const records = allRecords ? this.storage.allValues : this.storage.values;
      return records.reduce((records2, record) => {
        if (record.isSpecialRow) {
          if (includeHeaders && !record.isGroupFooter) {
            records2.push(record);
          }
          if (record.isGroupHeader) {
            records2.push.apply(records2, record.groupChildren);
          }
        }
        return records2;
      }, []);
    }
  }, __publicField(_a2, "$name", "StoreGroup"), //region Config
  __publicField(_a2, "configurable", {
    /**
     * Currently used groupers.
     * To set groupers when remote sorting is enabled by {@link Core/data/AjaxStore#config-sortParamName} you should
     * use {@link #function-setGroupers} instead to be able to wait for the operation to finish.
     * @member {Grouper[]} groupers
     * @category Sort, group & filter
     */
    /**
     * Initial groupers, specify to have store grouped automatically after initially setting data
     * @config {Grouper[]}
     * @category Common
     */
    groupers: null,
    useGroupFooters: false,
    /**
     * To have all groups __initially loaded__ start collapsed, configure this as `true`.
     *
     * Note that this only affects the initial load of the store. Subsequent reloads maintain
     * current group state where possible.
     * @config {Boolean}
     * @default false
     * @category Advanced
     */
    startGroupsCollapsed: null
  }), _a2;
};

// ../Core/lib/Core/data/mixin/StoreProxy.js
var StoreProxy_default = (Target) => class StoreProxy extends (Target || Base) {
  static get configurable() {
    return {
      /**
       * Allow object like interaction with the Store. For example:
       *
       * ```javascript
       * const store = new Store({
       *    objectify : true,
       *    data      : [
       *        { id : 'batman', name : 'Bruce' }
       *    ]
       * });
       *
       * // retrieve using id as property
       * const record = store.batman;
       *
       * // add as property
       * store.superman = { name : 'Clark' };
       *
       * // delete to remove
       * delete store.batman;
       * ``
       *
       * @config {Boolean}
       * @default false
       */
      objectify: null
    };
  }
  initProxy() {
    if (!globalThis.Proxy) {
      throw new Error("Proxy not supported");
    }
    const proxy = new Proxy(this, {
      // Support getting records using `store[id/index]
      get(target, property) {
        if (property in target) {
          return target[property];
        }
        if (property === "$store") {
          return target;
        }
        let record = target.getById(property);
        if (!record && !isNaN(parseInt(property))) {
          record = target.getAt(parseInt(property));
        }
        return record;
      },
      // Support adding/replacing records using `store.id = { ...data }`
      set(target, property, value) {
        if (property in target || target.isDestroying || property === "_triggered") {
          target[property] = value;
        } else {
          target.add({ [target.modelClass.idField]: property, ...value });
        }
        return true;
      },
      // Support deleting records using `delete store.id`
      deleteProperty(target, property) {
        if (target.isDestroying) {
          delete target[property];
          return true;
        }
        return Boolean(target.remove(property).length);
      },
      // Support `id in store`
      has(target, property) {
        if (property in target) {
          return true;
        }
        if (property.startsWith("{") && property.endsWith("}")) {
          const data = StringHelper.safeJsonParse(property);
          property = data == null ? void 0 : data.id;
        }
        return target.includes(property);
      }
    });
    return proxy;
  }
};

// ../Core/lib/Core/data/mixin/StoreRelation.js
var StoreRelation_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    //region Init
    /**
     * Initialized relations, called from constructor
     * @private
     */
    initRelations(reset) {
      const me = this, relations = me.modelClass.exposedRelations;
      if (reset && me.modelRelations) {
        me.modelRelations.forEach((relation) => {
          var _a3;
          return (_a3 = relation.storeDetacher) == null ? void 0 : _a3.call(relation);
        });
      }
      if ((!me.modelRelations || me.modelRelations.length === 0 || reset) && relations) {
        me.modelRelations = [];
        relations == null ? void 0 : relations.forEach((modelRelationConfig) => {
          const config = { ...modelRelationConfig }, {
            foreignStore,
            relationName,
            relatedCollectionName
          } = config, relatedStore = typeof foreignStore === "string" ? me[foreignStore] : foreignStore;
          config.dependentStore = me;
          me.modelRelations.push(config);
          if (relatedStore) {
            config.foreignStoreProperty = config.foreignStore;
            config.foreignStore = relatedStore;
            const dependentStoreConfigs = relatedStore.dependentStoreConfigs;
            if (dependentStoreConfigs.has(me)) {
              const dependentConfigs = dependentStoreConfigs.get(me);
              if (reset) {
                const existingConfig = dependentConfigs.find((c) => c.relationName === relationName);
                if (existingConfig) {
                  ArrayHelper.remove(dependentConfigs, existingConfig);
                }
              }
              dependentConfigs.push(config);
            } else {
              dependentStoreConfigs.set(me, [config]);
            }
            if (relatedCollectionName) {
              relatedStore.initRelationCollection(config, me);
            }
            if (relatedStore.count > 0) {
              relatedStore.updateDependentStores("dataset", relatedStore.records);
            }
          }
        });
      }
    }
    /**
     * Called from other end of a relation when this store should hold a collection of related records.
     * @private
     * @param config
     * @param collectionStore
     */
    initRelationCollection(config, collectionStore) {
      const me = this, name = config.relatedCollectionName, collectionStores = me.collectionStores || (me.collectionStores = {});
      collectionStores[name] = {
        store: collectionStore,
        config
      };
      if (!me[name + "Store"]) {
        me[name + "Store"] = collectionStore;
      }
      if (me.count > 0) {
        me.initModelRelationCollection(name, me.allRecords);
      }
    }
    initModelRelationCollection(name, records) {
      const me = this;
      records.forEach((record) => {
        record.traverse((node) => {
          const useName = name in node ? `$related${StringHelper.capitalize(name)}` : name;
          Object.defineProperty(node, useName, {
            enumerable: true,
            configurable: true,
            get: function() {
              return me.getCollection(this, name);
            },
            set: function(value) {
              return me.setCollection(this, name, value);
            }
          });
        });
      });
    }
    /**
     * Updates relationCache for all records.
     * @private
     */
    resetRelationCache() {
      this.relationCache = {};
      this.forEach((record) => record.initRelations());
    }
    /**
     * Caches related records from related store on the local store.
     * @private
     * @param record Local record
     * @param relations Relations to related store
     */
    updateRecordRelationCache(record, relations) {
      relations == null ? void 0 : relations.forEach((relation) => {
        const { config } = relation, foreignId = relation.related ? relation.related.id : record.getValue(config.foreignKey);
        foreignId !== void 0 && this.cacheRelatedRecord(record, foreignId, config.relationName, foreignId);
      });
    }
    //endregion
    //region Getters
    /**
     * Returns records the relation cache. Same result as if retrieving the collection on the dependent store, but
     * without the need of accessing that store.
     * @internal
     * @param {String} name
     * @param {Core.data.Model|String|Number} recordOrId
     * @returns {Array}
     */
    getRelationCollection(name, recordOrId) {
      var _a3;
      const id = Model.asId(recordOrId);
      return ((_a3 = this.relationCache[name]) == null ? void 0 : _a3[id]) || [];
    }
    /**
     * Returns records from a collection of related records. Not to be called directly, called from Model getter.
     * @private
     * @param {Core.data.Model} record
     * @param {String} name
     * @returns {Array}
     */
    getCollection(record, name) {
      var _a3;
      const { config, store } = this.collectionStores[name];
      return ((_a3 = store.relationCache[config.relationName]) == null ? void 0 : _a3[record.id]) || [];
    }
    /**
     * Sets a collection of related records. Will updated the related store and trigger events from it. Not to be called
     * directly, called from Model setter.
     * @private
     */
    setCollection(model, name, records) {
      const { config, store } = this.collectionStores[name], relationCache = store.relationCache[config.relationName] || (store.relationCache[config.relationName] = {}), old = (relationCache[model.id] || []).slice(), added = [], removed = [];
      store.suspendEvents();
      old.forEach((record) => {
        if (!records.includes(record)) {
          record[config.foreignKey] = null;
          store.remove(record);
          removed.push(record);
        }
      });
      records.forEach((record) => {
        if (record.isModel instanceof Model) {
          if (!record.stores.includes(store)) {
            store.add(record);
            added.push(record);
          }
        } else {
          [record] = store.add(record);
          added.push(record);
        }
        record[config.foreignKey] = model.id;
      });
      store.resumeEvents();
      if (removed.length) {
        store.trigger("remove", { records: removed });
        store.trigger("change", { action: "remove", records: removed });
      }
      if (added.length) {
        store.trigger("add", { records: added });
        store.trigger("change", { action: "add", records: added });
      }
    }
    //endregion
    //region Caching
    /**
     * Adds a record to relation cache, optionally removing it if already there.
     * @private
     * @param record
     * @param id
     * @param name
     * @param uncacheId
     */
    cacheRelatedRecord(record, id, name, uncacheId = null) {
      const me = this, cache = me.relationCache[name] || (me.relationCache[name] = {});
      if (uncacheId !== null) {
        me.uncacheRelatedRecord(record, name, uncacheId);
      }
      if (id != null) {
        ArrayHelper.include(cache[id] || (cache[id] = []), record);
      }
    }
    /**
     * Removes a record from relation cache, for a specific relation (specify relation name and id) or for all relations
     * @private
     * @param record Record to remove from cache
     * @param name Optional, relation name
     * @param id Optional, id
     */
    uncacheRelatedRecord(record, name = null, id = null) {
      const me = this;
      function remove(relationName, relatedId) {
        const cache = me.relationCache[relationName], oldCache = cache == null ? void 0 : cache[relatedId];
        if (oldCache) {
          const uncacheIndex = oldCache.indexOf(record);
          uncacheIndex >= 0 && oldCache.splice(uncacheIndex, 1);
          if (oldCache.length === 0) {
            delete cache[relatedId];
          }
        }
      }
      if (id != null) {
        remove(name, id);
      } else {
        if (record.meta.relationCache) {
          Object.entries(record.meta.relationCache).forEach(
            ([relationName, relatedRecord]) => remove(relationName, relatedRecord == null ? void 0 : relatedRecord.id)
          );
        }
      }
    }
    /**
     * Updates related stores when store is cleared, a record is removed or added.
     * @private
     * @param {String} action
     * @param {Core.data.Model[]} records
     */
    updateDependentStores(action, records) {
      this.dependentStoreConfigs.forEach((configs) => {
        configs.forEach((config) => {
          const {
            dependentStore,
            relatedCollectionName,
            relationName,
            foreignKey
          } = config, cache = dependentStore.relationCache[relationName];
          if (action === "dataset") {
            relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
            dependentStore.forEach((record) => {
              const foreign = record.initRelation(config);
              foreign && dependentStore.cacheRelatedRecord(record, foreign.id, relationName, foreign.id);
            });
            return;
          }
          if (action === "removeall") {
            dependentStore.forEach((record) => record.removeRelation(config));
            delete dependentStore.relationCache[relationName];
            return;
          }
          if (action === "replace") {
            records = records.map((r) => r[1]);
          }
          if (action === "add" || action === "replace") {
            relatedCollectionName && this.initModelRelationCollection(relatedCollectionName, records);
          }
          if (action === "add" || action === "replace" || action === "remove") {
            records.forEach((record) => {
              const dependentRecords = cache == null ? void 0 : cache[record.id];
              switch (action) {
                case "remove":
                  if (dependentRecords) {
                    dependentRecords.forEach((dependentRecord) => dependentRecord.removeRelation(config));
                  }
                  break;
                case "add":
                case "replace":
                  dependentStore.forEach((dependentRecord) => {
                    if (dependentRecord.getValue(foreignKey) == record.id) {
                      dependentRecord.initRelation(config);
                      dependentStore.cacheRelatedRecord(dependentRecord, record.id, relationName);
                    }
                  });
                  break;
              }
            });
          }
        });
      });
    }
    /**
     * Updates relation cache and foreign key value when a related objects id is changed.
     * @private
     */
    updateDependentRecordIds(oldValue, value) {
      var _a3;
      (_a3 = this.dependentStoreConfigs) == null ? void 0 : _a3.forEach((configs) => {
        configs.forEach((config) => {
          var _a4;
          const {
            dependentStore,
            relationName,
            foreignKey
          } = config, cache = dependentStore.relationCache[relationName], localRecords = (_a4 = cache == null ? void 0 : cache[oldValue]) == null ? void 0 : _a4.slice();
          localRecords == null ? void 0 : localRecords.forEach((localRecord) => {
            dependentStore.cacheRelatedRecord(localRecord, value, relationName, oldValue);
            localRecord.set(foreignKey, value, false, true);
          });
        });
      });
    }
    //endregion
  }, __publicField(_a2, "$name", "StoreRelation"), _a2;
};

// ../Core/lib/Core/data/mixin/StoreSum.js
var StoreSum_default = (Target) => class StoreSum extends (Target || Base) {
  static get $name() {
    return "StoreSum";
  }
  /**
   * Returns sum calculated by adding value of specified field for specified records. Defaults to using all records
   * in store
   * @param {String} field Field to summarize by
   * @param {Core.data.Model[]} records Records to summarize, uses all records if unspecified.
   * @returns {Number}
   * @category Sum
   */
  sum(field, records = this.storage.values) {
    if (!records) {
      return 0;
    }
    return records.reduce((sum, record) => {
      if (record.isSpecialRow) {
        return sum;
      }
      const v = Number(record.getValue(field));
      return isNaN(v) ? sum : sum + v;
    }, 0);
  }
  /**
   * Returns min value for the specified field, can be used with Date or Number values. Defaults to look through all records in store
   * @param {String} field Field to find min value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number|Date}
   * @category Sum
   */
  min(field, records = this.storage.values) {
    if (!(records == null ? void 0 : records.length)) {
      return 0;
    }
    return records.reduce((min2, record) => {
      const fieldValue = record.getValue(field), type = typeof (fieldValue == null ? void 0 : fieldValue.valueOf());
      if (type === "number" && fieldValue < min2) {
        min2 = fieldValue;
      }
      return min2;
    }, records[0].getValue(field));
  }
  /**
   * Returns max value for the specified field, can be used with Date or Number values. Defaults to look through all records in store
   * @param {String} field Field to find max value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number|Date}
   * @category Sum
   */
  max(field, records = this.storage.values) {
    if (!(records == null ? void 0 : records.length)) {
      return 0;
    }
    return records.reduce((max, record) => {
      const fieldValue = record.getValue(field), type = typeof (fieldValue == null ? void 0 : fieldValue.valueOf());
      if (type === "number" && fieldValue > max) {
        max = fieldValue;
      }
      return max;
    }, records[0].getValue(field));
  }
  /**
   * Returns the average value for the specified field. Defaults to look through all records in store
   * @param {String} field Field to calculate average value for
   * @param {Core.data.Model[]} records Records to process, uses all records if unspecified
   * @returns {Number}
   * @category Sum
   */
  average(field, records = this.storage.values) {
    if (!(records == null ? void 0 : records.length)) {
      return 0;
    }
    let count = 0;
    const sum = records.reduce((sum2, record) => {
      if (record.isSpecialRow) {
        return sum2;
      }
      const v = parseFloat(record.getValue(field));
      if (!isNaN(v)) {
        count++;
        return sum2 + v;
      } else {
        return sum2;
      }
    }, 0);
    return count > 0 ? sum / count : 0;
  }
  /**
   * Returns sum by adding value of specified field for records in the group with the specified groupValue.
   * @param {*} groupValue The group to summarize
   * @param {String} field Field to summarize by
   * @returns {Number} Sum or null if store not grouped
   * @category Sum
   */
  groupSum(groupValue, field) {
    return this.sum(field, this.getGroupRecords(groupValue));
  }
};

// ../Core/lib/Core/data/mixin/StoreSearch.js
var findInString = (value, text) => String(value).toLowerCase().includes(text);
var matchFns = {
  string: findInString,
  number: findInString,
  boolean: findInString,
  date: (value, text) => {
    if (value instanceof Date && text instanceof Date) {
      return value - text === 0;
    }
    return String(value.getMonth() + 1).includes(text) || String(value.getDate()).includes(text) || String(value.getFullYear()).includes(text);
  },
  object: (value, text) => value === text,
  // typeof null === object
  undefined: (value, text) => value === text
};
var StoreSearch_default = (Target) => class StoreSearch extends (Target || Base) {
  static get $name() {
    return "StoreSearch";
  }
  //region Search (multiple hits)
  /**
   * Find all hits matching the specified input
   * @param {String} text Value to search for
   * @param {String[]} fields Fields to search value in
   * @param {Function[]} [formatters] An array of field formatting functions to format the found value
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {StoreSearchResult[]} Array of hits, in the format { index: x, data: record }
   * @category Search
   */
  search(text, fields = null, formatters, searchAllRecords) {
    const records = this.isTree && !searchAllRecords ? this.rootNode.allChildren : this.getAllDataRecords(searchAllRecords), len = records.length, found = [];
    if (text == null) {
      return [];
    }
    if (typeof text === "string") {
      text = text.toLowerCase();
    }
    let i, j, record, value, valueType, comparison;
    for (i = 0; i < len; i++) {
      record = records[i];
      j = 0;
      for (const key of fields || record.fieldNames) {
        value = record.getValue(key);
        valueType = value instanceof Date ? "date" : typeof value;
        const formatter = formatters == null ? void 0 : formatters[j];
        if (formatter) {
          value = formatter(value);
          valueType = "string";
        }
        comparison = matchFns[valueType];
        if (value && (comparison == null ? void 0 : comparison(value, text))) {
          found.push({
            index: i,
            data: record,
            field: key,
            id: record.id
          });
        }
        j++;
      }
    }
    return found;
  }
  /**
   * Find occurrences of the specified `value` in the specified `field` on all records in the store
   * @param {String} field The record field to search in
   * @param {*} value Value to search for
   * @param {Boolean} distinct True to only return distinct matches, no duplicates
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {StoreSearchResult[]} Array of hits, in the format { index: x, data: record }
   * @category Search
   */
  findByField(field, value, distinct2 = false, searchAllRecords = false) {
    const records = this.getAllDataRecords(searchAllRecords), len = records.length, usedValues = /* @__PURE__ */ new Set(), found = [];
    let i, record, fieldValue;
    if (value != null) {
      value = String(value).toLowerCase();
    }
    for (i = 0; i < len; i++) {
      record = records[i];
      fieldValue = record.getValue(field);
      if (!distinct2 || !usedValues.has(fieldValue)) {
        const type = fieldValue instanceof Date ? "date" : typeof fieldValue, matchFn = matchFns[type];
        if (value == null && fieldValue === value || value === "" && fieldValue === "" || value && matchFn(fieldValue, value)) {
          found.push({
            id: record.id,
            index: i,
            data: record
          });
          if (distinct2) {
            usedValues.add(fieldValue);
          }
        }
      }
    }
    return found;
  }
  //endregion
  //region Find (single hit)
  /**
   * Finds the first record for which the specified function returns true
   * @param {Function} fn Comparison function, called with record as parameter
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model} Record or undefined if none found
   *
   * ```javascript
   * store.find(record => record.color === 'blue');
   * ```
   *
   * @category Search
   */
  find(fn2, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).find(fn2);
  }
  /**
   * Finds the first record for which the specified field has the specified value
   * @param {String} fieldName Field name
   * @param {*} value Value to find
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model} Record or undefined if none found
   * @category Search
   */
  findRecord(fieldName, value, searchAllRecords = false) {
    const matchFn = (r) => ObjectHelper.isEqual(r[fieldName], value);
    if (this.isTree) {
      return this.query(matchFn, searchAllRecords)[0];
    }
    return this.getAllDataRecords(searchAllRecords).find(matchFn);
  }
  /**
   * Searches the Store records using the passed function.
   * @param {Function} fn A function that is called for each record. Return true to indicate a match
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Core.data.Model[]} An array of the matching Records
   * @category Search
   */
  query(fn2, searchAllRecords = false) {
    if (this.isTree) {
      const matches = [];
      this.traverse((node) => {
        if (fn2(node)) {
          matches.push(node);
        }
      }, void 0, void 0, searchAllRecords);
      return matches;
    }
    return this.getAllDataRecords(searchAllRecords).filter(fn2);
  }
  //endregion
  //region Others
  /**
   * Returns true if the supplied function returns true for any record in the store
   * @param {Function} fn A function that should return true to indicate a match
   * @param {Boolean} [searchAllRecords] True to ignore any applied filters when searching
   * @returns {Boolean}
   *
   * ```javascript
   * store.some(record => record.age > 95); // true if any record has age > 95
   * ```
   *
   * @category Search
   */
  some(fn2, searchAllRecords = false) {
    return this.getAllDataRecords(searchAllRecords).some(fn2);
  }
  //endregion
};

// ../Core/lib/Core/data/mixin/StoreSort.js
var StoreSort_default = (Target) => class StoreSort extends (Target || Base) {
  static get $name() {
    return "StoreSort";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Use `localeCompare()` when sorting, which lets the browser sort in a locale specific order. Set to `true`,
       * a locale string or a locale config to enable.
       *
       * Enabling this has big negative impact on sorting
       * performance. For more info on `localeCompare()`, see [MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare).
       *
       * Examples:
       *
       * ```javascript
       * const store = new Store({
       *     // Swedish sorting
       *     useLocaleSort : 'sv-SE'
       * });
       *
       * const store = new Store({
       *     // Swedish sorting with custom casing order
       *     useLocaleSort : {
       *         locale    : 'sv-SE',
       *         caseFirst : 'upper'
       *     }
       * });
       * ```
       *
       * Can also be configured on a per-sorter basis:
       *
       * ```javascript
       * store.sort({ field: 'name', useLocaleSort : 'sv-SE' });
       * ```
       *
       * @config {Boolean|String|Object}
       * @default false
       * @category Advanced
       */
      useLocaleSort: null
    };
  }
  static get configurable() {
    return {
      /**
       * Initial sorters, format is:
       * ```javascript
       * { sorters : [{ field: 'name', ascending: false }, ...] }
       * // or
       * { sorters : ['name', ...] }
       * ```
       * @config {Sorter[]|String[]}
       * @category Common
       */
      sorters: [],
      /**
       * Specify true to sort this store after records are added.
       * @config {Boolean}
       * @default
       * @category Sorting
       */
      reapplySortersOnAdd: false
    };
  }
  //endregion
  //region Events
  /**
   * Fired before sorting
   * @event beforeSort
   * @param {Core.data.Store} source This Store
   * @param {Sorter[]} sorters Sorter configs
   * @param {Core.data.Model[]} records Records to sort
   */
  /**
   * Fired after sorting
   * @event sort
   * @param {Core.data.Store} source This Store
   * @param {Sorter[]} sorters Sorter configs
   * @param {Core.data.Model[]} records Sorted records
   */
  //endregion
  //region Properties
  /**
   * Currently applied sorters
   * @member {Sorter[]} sorters
   * @readonly
   * @category Sort, group & filter
   */
  /**
   * Is store sorted?
   * @property {Boolean}
   * @readonly
   * @category Sort, group & filter
   */
  get isSorted() {
    return Boolean(this.sorters.length) || this.isGrouped;
  }
  changeSorters(sorters) {
    return sorters.map((sorter) => this.normalizeSorterConfig(sorter, true));
  }
  updateReapplySortersOnAdd(enable) {
    this.storage.autoSort = enable;
  }
  //endregion
  //region Add & remove sorters
  /**
   * Sort records, either by replacing current sorters or by adding to them.
   * A sorter can specify a **_custom sorting function_** which will be called with arguments (recordA, recordB).
   * Works in the same way as a standard array sorter, except that returning `null` triggers the stores
   * normal sorting routine.
   *
   * ```javascript
   * // single sorter
   * store.sort('age');
   *
   * // single sorter as object, descending order
   * store.sort({ field : 'age', ascending : false });
   *
   * // multiple sorters
   * store.sort(['age', 'name']);
   *
   * // using custom sorting function
   * store.sort((recordA, recordB) => {
   *     // apply custom logic, for example:
   *     return recordA.name.length < recordB.name.length ? -1 : 1;
   * });
   *
   * // using locale specific sort (slow)
   * store.sort({ field : 'name', useLocaleSort : 'sv-SE' });
   * ```
   *
   * @param {String|Sorter[]|Sorter|Function} field Field to sort by.
   * Can also be an array of {@link Core.util.CollectionSorter sorter} config objects, or a sorting function, or a
   * {@link Core.util.CollectionSorter sorter} config.
   * @param {Boolean} [ascending] Sort order.
   * Applicable when the `field` is a string (if not specified and already sorted by the field, reverts direction),
   * or an object and `ascending` property is not specified for the object. `true` by default.
   * Not applicable when `field` is a function. `ascending` is always `true` in this case.
   * @param {Boolean} [add] If `true`, adds a sorter to the sorters collection.
   * Not applicable when `field` is an array. In this case always replaces active sorters.
   * @param {Boolean} [silent] Set as true to not fire events. UI will not be informed about the changes.
   * @category Sort, group & filter
   * @fires beforeSort
   * @fires sort
   * @fires refresh
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   */
  sort(field, ascending, add = false, silent = false) {
    const me = this, records = me.allRecords, currentSorters = me.sorters ? me.sorters.slice() : [];
    let currentDir = null, curSort;
    if (field) {
      if (Array.isArray(field)) {
        me.sorters = field.map((sorter) => me.normalizeSorterConfig(sorter, typeof sorter === "string" ? true : ascending));
      } else {
        const sorter = me.normalizeSorterConfig(field, ascending);
        if (add) {
          curSort = me.getCurrentSorterByField(sorter.field);
          if (curSort) {
            currentDir = curSort.ascending;
            curSort.ascending = sorter.ascending;
          } else {
            me.sorters.push(sorter);
          }
        } else {
          me.sorters = [sorter];
        }
      }
    }
    if (!silent && me.trigger("beforeSort", { sorters: me.sorters, records, currentSorters }) === false) {
      me.sorters = currentSorters;
      if (currentDir !== null) {
        curSort.ascending = currentDir;
      }
      return null;
    }
    return me.performSort(silent);
  }
  normalizeSorterConfig(field, ascending) {
    var _a2, _b, _c;
    const me = this, sorter = { ascending };
    if (typeof field === "object") {
      ObjectHelper.assign(sorter, field);
      if (field.fn) {
        delete sorter.fn;
        sorter.sortFn = field.fn;
      }
      sorter.ascending = (_a2 = field.ascending) != null ? _a2 : ascending;
    } else if (typeof field === "function") {
      sorter.sortFn = field;
    } else {
      sorter.field = field;
    }
    if (sorter.ascending == null) {
      const curSort = me.getCurrentSorterByField(sorter.field);
      sorter.ascending = curSort ? !curSort.ascending : true;
    }
    if (sorter.sortFn == null) {
      const compareItems = (_c = (_b = me.modelClass) == null ? void 0 : _b.$meta.fields.map[sorter.field]) == null ? void 0 : _c.compareItems;
      if (compareItems) {
        sorter.sortFn = compareItems;
      }
    }
    return sorter;
  }
  getCurrentSorterByField(field) {
    return typeof field === "string" && this.sorters.find((s) => s.field === field) || null;
  }
  /**
   * Add a sorting level (a sorter).
   * @param {String|Sorter[]|Sorter|Function} field Field to sort by. Can also be an array of sorters, or a sorting
   * function, or a {@link Core.util.CollectionSorter sorter} config.
   * @param {Boolean} [ascending] Sort order (used only if field specified as string)
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  addSorter(field, ascending = true) {
    return this.sort(field, ascending, true);
  }
  /**
   * Remove a sorting level (a sorter)
   * @param {String|Function} field Stop sorting by this field (or sorter function)
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  removeSorter(field) {
    const sorterIndex = this.sorters.findIndex((sorter) => sorter.field === field || sorter.sortFn === field);
    if (sorterIndex > -1) {
      this.sorters.splice(sorterIndex, 1);
      return this.sort();
    }
  }
  /**
   * Removes all sorters, turning store sorting off.
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @category Sort, group & filter
   */
  clearSorters(silent = false) {
    if (this.sorters.length) {
      this.sorters.length = 0;
      return this.sort(void 0, void 0, void 0, silent);
    }
  }
  //region
  //region Sorting logic
  /**
   * Creates a function used with Array#sort when sorting the store. Override to use your own custom sorting logic.
   * @param {Sorter[]} sorters An array of sorter config objects
   * @returns {Function}
   * @category Sort, group & filter
   */
  createSorterFn(sorters) {
    const storeLocaleSort = this.useLocaleSort;
    return (lhs, rhs) => {
      for (let i = 0; i < sorters.length; i++) {
        const sorter = sorters[i], { field, ascending = true, useLocaleSort = storeLocaleSort } = sorter, fn2 = sorter.fn || sorter.sortFn, direction = ascending ? 1 : -1;
        if (fn2) {
          const val = fn2.call(sorter, lhs, rhs);
          if (val === 0) {
            continue;
          }
          if (val !== null) {
            return val * direction;
          }
        }
        const lhsValue = lhs.isModel ? lhs.getValue(field) : lhs[field], rhsValue = rhs.isModel ? rhs.getValue(field) : rhs[field];
        if (lhsValue === rhsValue) {
          continue;
        }
        if (lhsValue == null) {
          return -direction;
        }
        if (rhsValue == null) {
          return direction;
        }
        if (useLocaleSort && typeof lhsValue === "string") {
          if (useLocaleSort === true) {
            return String(lhsValue).localeCompare(rhsValue) * direction;
          }
          if (typeof useLocaleSort === "string") {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort) * direction;
          }
          if (typeof useLocaleSort === "object") {
            return String(lhsValue).localeCompare(rhsValue, useLocaleSort.locale, useLocaleSort) * direction;
          }
        }
        if (lhsValue > rhsValue) {
          return direction;
        }
        if (lhsValue < rhsValue) {
          return -direction;
        }
      }
      return 0;
    };
  }
  /**
   * The sorter function for sorting records in the store.
   * @member {Function}
   * @internal
   * @readonly
   */
  get sorterFn() {
    return this.createSorterFn(this.remoteSort ? [{ field: "_remoteSortIndex" }] : this.sorters);
  }
  /**
   * Perform sorting according to the {@link #config-sorters} configured.
   * This is the internal implementation which is overridden in {@link Core.data.AjaxStore} and
   * must not be overridden.
   * @async
   * @private
   * @category Sort, group & filter
   */
  performSort(silent) {
    const me = this, { rootNode, storage, sorterFn: sorter } = me;
    if (me.tree) {
      !me.isChained && rootNode.traverse((node) => {
        if (node.isLoaded && node.isParent) {
          node.children.sort(sorter);
          node.updateChildrenIndices(node.children, "parentIndex", true);
        }
      });
      storage.replaceValues({
        values: me.collectDescendants(rootNode).visible,
        silent: true
      });
    } else if (me.isGrouped) {
      storage.replaceValues({
        ...me.prepareGroupRecords(),
        silent: true
      });
    } else {
      storage.replaceValues({
        values: storage.values.sort(sorter),
        silent: true
      });
    }
    me.afterPerformSort(silent || me.isRemoteDataLoading);
  }
  afterPerformSort(silent) {
    if (silent) {
      return;
    }
    const me = this;
    me._idMap = null;
    const event = {
      action: "sort",
      sorters: me.sorters,
      records: me.allRecords
    };
    me.trigger("sort", event);
    me.trigger("refresh", event);
  }
  //endregion
};

// ../Core/lib/Core/data/mixin/StoreChained.js
var returnTrue = () => true;
var StoreChained_default = (Target) => class StoreChained extends (Target || Base) {
  static get $name() {
    return "StoreChained";
  }
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Function used to filter records in the masterStore into a chained store. If not provided,
       * all records from the masterStore will be included in the chained store.
       * Return `true` to include the passed record, or a `false` to exclude it.
       * @config {Function}
       * @param {Core.data.Model} record
       * @returns {Boolean}
       * @category Chained store
       */
      chainedFilterFn: null,
      /**
       * Array of field names that should trigger filtering of chained store when the fields are updated.
       * @config {String[]}
       * @category Chained store
       */
      chainedFields: null,
      /**
       * Master store that a chained store gets its records from.
       * @config {Core.data.Store}
       * @category Chained store
       */
      masterStore: null,
      /**
       * Method names calls to which should be relayed to master store.
       * @config {String[]}
       * @category Chained store
       */
      doRelayToMaster: ["add", "remove", "insert"],
      /**
       * Method names calls to which shouldn't be relayed to master store.
       * @config {String}
       * @category Chained store
       */
      dontRelayToMaster: [],
      /**
       * If true, collapsed records in original tree will be excluded from the chained store.
       * @config {Boolean}
       * @category Chained store
       */
      excludeCollapsedRecords: true,
      chainSuspended: 0
    };
  }
  // All props should be predefined to work properly with objectified stores
  static get properties() {
    return {
      chainedStores: null
    };
  }
  //endregion
  construct(config) {
    super.construct(config);
    const me = this, { masterStore } = me, sort = me.syncOrder ? "sort" : "";
    if (masterStore) {
      me.methodNamesToRelay.forEach((fnName) => me[fnName] = (...params) => me.relayToMaster(fnName, params));
      me.removeAll = (...params) => {
        masterStore.remove(me.getRange(), ...params);
      };
      masterStore.ion({
        // HACK to have chained stores react early in a async events scenario (with engine). Could be turned
        // into a config, but this way one does not have to think about it
        changePreCommit: me.onMasterDataChangedPreCommit,
        change: me.onMasterDataChanged,
        [sort]: me.onMasterDataChanged,
        prio: 1,
        thisObj: me
      });
      if (!masterStore.chainedStores) {
        masterStore.chainedStores = [];
      }
      masterStore.chainedStores.push(me);
      me.fillFromMaster();
    }
  }
  //region Properties
  // For accessing the full set of records, whether chained or not
  get $master() {
    return this.masterStore || this;
  }
  /**
   * Is this a chained store?
   * @property {Boolean}
   * @readonly
   * @category Advanced
   */
  get isChained() {
    return Boolean(this.masterStore);
  }
  set chainedFilterFn(chainedFilterFn) {
    this._chainedFilterFn = this.thisObj ? chainedFilterFn.bind(this.thisObj) : chainedFilterFn;
  }
  get chainedFilterFn() {
    return this._chainedFilterFn || returnTrue;
  }
  get methodNamesToRelay() {
    const doIsArray = Array.isArray(this.doRelayToMaster), dontIsArray = Array.isArray(this.dontRelayToMaster);
    return doIsArray && this.doRelayToMaster.filter((name) => !dontIsArray || !this.dontRelayToMaster.includes(name)) || [];
  }
  //endregion
  //region Internal
  updateChainedStores() {
    if (this.chainedStores) {
      this.chainedStores.forEach((store) => store.fillFromMaster());
    }
  }
  /**
   * Updates records available in a chained store by filtering the master store records using
   * {@link #config-chainedFilterFn}
   * @category Chained store
   */
  fillFromMaster() {
    const me = this, { masterStore, isTree } = me;
    let records = [];
    if (!me.isChained) {
      throw new Error("fillFromMaster only allowed on chained store");
    }
    if (me.isChainSuspended) {
      return;
    }
    if (masterStore.isGrouped && masterStore.isFiltered) {
      masterStore.forEach((r) => records.push(r), masterStore, { includeFilteredOutRecords: true, includeCollapsedGroupRecords: true });
    } else {
      records = masterStore.allRecords.filter((r) => !r.isSpecialRow && me.chainedFilterFn(r));
    }
    if (isTree) {
      me.idRegister = {};
      me.internalIdRegister = {};
      records.forEach((r) => {
        if (r.stores.includes(me)) {
          me.register(r);
        } else {
          r.joinStore(me);
        }
      });
      if (me.excludeCollapsedRecords) {
        const children = me.getChildren(me.rootNode);
        records = me.doIncludeExclude(children, true);
      }
    }
    me.isFillingFromMaster = true;
    me.data = records;
    me.isFillingFromMaster = false;
  }
  /**
   * Commits changes back to master.
   * - the records deleted from chained store and present in master will be deleted from master
   * - the records added to chained store and missing in master will added to master
   * Internally calls {Store#function-commit commit()}.
   * @returns {Object} Changes, see Store#changes
   * @internal
   */
  commitToMaster() {
    const me = this, master = me.masterStore;
    if (!me.isChained) {
      throw new Error("commitToMaster only allowed on chained store");
    }
    master.beginBatch();
    master.remove(me.removed.values);
    master.add(me.added.values);
    master.endBatch();
    return me.commit();
  }
  /**
   * Relays some function calls to the master store
   * @private
   */
  relayToMaster(fnName, params) {
    return this.masterStore[fnName](...params);
  }
  // HACK, when used with engine the chained store will catch events early (sync) and prevent late (async) listeners
  onMasterDataChangedPreCommit(event) {
    this.onMasterDataChanged(event);
    this.$masterEventhandled = true;
  }
  /**
   * Handles changes in master stores data. Updates the chained store accordingly
   * @private
   */
  onMasterDataChanged({ action, changes, $handled, isMove }) {
    var _a2;
    if (this.$masterEventhandled) {
      this.$masterEventhandled = false;
      return;
    }
    if (isMove && action === "remove") {
      return;
    }
    if (action !== "update" || ((_a2 = this.chainedFields) == null ? void 0 : _a2.some((field) => field in changes))) {
      this.fillFromMaster();
    }
  }
  //endregion
  //region public API
  /**
   * Creates a chained store, a new Store instance that contains a subset of the records from current store.
   * Which records is determined by a filtering function, which is reapplied when data in the base store changes.
   *
   * ```javascript
   * const oldies = store.makeChained(record => record.age > 50);
   * // or use a simple query
   * const ages = store.makeChained(() => store.allRecords.distinct('age')));
   * ```
   *
   * If this store is a {@link Core.data.mixin.StoreTree#property-isTree tree} store, then the resulting chained store
   * will be a tree store sharing the same root node, but only child nodes which pass the `chainedFilterFn` will be
   * considered when iterating the tree through the methods such as
   * {@link Core.data.Store#function-traverse} or {@link Core.data.Store#function-forEach}.
   *
   * @param {Function} [chainedFilterFn] Either a filter function called for every record to determine if it should be
   * included (return true / false), or a query function called with no arguments (see example below). Defaults to
   * including all records (fn always returning true)
   * @param {String[]} [chainedFields] Array of fields that trigger filtering when they are updated
   * @param {StoreConfig} [config] Additional chained store configuration. See {@link Core.data.Store#configs}
   * @param {Class} [config.storeClass] The Store class to use if this Store type is not required.
   * @returns {Core.data.Store}
   * @category Chained store
   */
  makeChained(chainedFilterFn = returnTrue, chainedFields, config) {
    if (this.isChained) {
      const newChainedFilterFn = chainedFilterFn;
      chainedFilterFn = (r) => newChainedFilterFn(r) && this.chainedFilterFn(r);
    }
    return new ((config == null ? void 0 : config.storeClass) || this.constructor)({
      // Don't copy the legacy storeId, see Store#construct
      storeId: void 0,
      id: `${this.id}-chained-${StringHelper.generateUUID()}`,
      // Make sure we don't share instanceMeta with the master store
      ...config || {},
      tree: false,
      autoTree: false,
      // If someone ever chains a chained store, chain master instead
      masterStore: this.$master,
      modelClass: this.modelClass,
      // Chained store should never use syncDataOnLoad, that will create an infinite loop when they determine
      // that a record is added and then add it to master, repopulating this store and round we go
      syncDataOnLoad: false,
      chainedFilterFn,
      chainedFields
    });
  }
  /**
   * Alias for {@link Core.data.Store#function-makeChained}
   *
   * @param {Function} [chainedFilterFn] Either a filter function called for every record to determine if it should be
   * included (return true / false), or a query function called with no arguments (see example below). Defaults to
   * including all records (fn always returning true)
   * @param {String[]} [chainedFields] Array of fields that trigger filtering when they are updated
   * @param {StoreConfig} [config] Additional chained store configuration. See {@link Core.data.Store#configs}
   * @param {Class} [config.storeClass] The Store class to use if this Store type is not required.
   * @returns {Core.data.Store}
   * @category Chained store
   */
  chain() {
    return this.makeChained(...arguments);
  }
  //endregion
  doDestroy() {
    var _a2;
    (_a2 = this.chainedStores) == null ? void 0 : _a2.forEach((chainedStore) => chainedStore.destroy());
    super.doDestroy();
  }
  suspendChain() {
    this.chainSuspended++;
  }
  resumeChain(refill = false) {
    if (this.chainSuspended && !--this.chainSuspended && refill) {
      this.fillFromMaster();
    }
  }
  get isChainSuspended() {
    return this.chainSuspended > 0;
  }
};

// ../Core/lib/Core/data/mixin/StoreState.js
var StoreState_default = (Target) => class StoreState extends (Target || Base) {
  static get $name() {
    return "StoreState";
  }
  /**
   * Get store state. Used by State-plugin to serialize state
   * @private
   * @returns {{ sorters, groupers }}
   */
  getState() {
    const { sorters, groupers, filters } = this, state = {};
    if (sorters == null ? void 0 : sorters.length) {
      state.sorters = sorters.map((sorter) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(sorter));
        delete clone.fn;
        delete clone.sortFn;
        return clone;
      });
    }
    if (groupers == null ? void 0 : groupers.length) {
      state.groupers = groupers.map((grouper) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(grouper));
        delete clone.fn;
        return clone;
      });
    }
    if (filters == null ? void 0 : filters.values.length) {
      state.filters = filters.values.map((filter2) => {
        const clone = ObjectHelper.cleanupProperties(ObjectHelper.clone(filter2.config));
        clone.value = filter2.value;
        if (clone.caseSensitive) {
          delete clone.caseSensitive;
        }
        return clone;
      });
    }
    return state;
  }
  /**
   * Apply store state. Used by State-plugin to restore a previously serialized state
   * @private
   * @param {{ sorters, groupers }} state
   */
  applyState(state) {
    const me = this, {
      sorters = [],
      groupers = [],
      filters = []
    } = state, {
      sortParamName,
      filterParamName
    } = me;
    me.sorters = sorters.filter((sorter) => sorter.field || sorter.sortFn && !sortParamName);
    me.groupers = groupers.slice();
    me.sort();
    me.filters = filters.filter((filter2) => filter2.property || filter2.filterBy && !filterParamName);
    me.filter();
  }
};

// ../Core/lib/Core/data/Wbs.js
var zeroPad = (v) => String(v).padStart(6, "0");
var Wbs = class _Wbs {
  /**
   * Wbs constructor.
   * @param {String|Number} value The value of WBS
   */
  constructor(value) {
    this.value = value;
    this._padded = null;
  }
  /**
   * The WBS value
   * @readonly
   * @member {String} value
   */
  set value(value) {
    this._value = String(value != null ? value : "");
  }
  get value() {
    return this._value;
  }
  /**
   * Returns a `Wbs` instance given a `value`. If the `value` is already a `Wbs` object, it is returned. Otherwise,
   * a new `Wbs` is created. If `value` is `null` or `undefined`, that value is returned.
   * @param {String|Number|Core.data.Wbs} value
   * @returns {Core.data.Wbs}
   */
  static from(value) {
    return value == null ? value : value instanceof _Wbs ? value : new _Wbs(value);
  }
  /**
   * Returns a WBS code where each component is 0-padded on the left to 6 digits. That is "1.2" is padded to be
   * "000001.000002". These values can be compared for proper semantic order (e.g., Wbs.pad('1.2') < Wbs.pad('1.10')).
   * @param {String|Number|Core.data.Wbs} value
   * @returns {String}
   * @private
   */
  static pad(value) {
    return value instanceof _Wbs ? value.valueOf() : _Wbs.split(value).map(zeroPad).join(".");
  }
  /**
   * Returns an array of digits from a given WBS code `value`. If the value cannot be converted, an empty array is
   * returned.
   * @param {String|Number|Core.data.Wbs} value
   * @returns {Number[]}
   * @private
   */
  static split(value) {
    let i, ret;
    if (value || value === 0) {
      switch (typeof value) {
        case "object":
          value = String(value);
        case "string":
          ret = value.split(".");
          for (i = ret.length; i-- > 0; ) {
            ret[i] = parseInt(ret[i], 10);
          }
          break;
        case "number":
          ret = [value];
          break;
      }
    }
    return ret || [];
  }
  /**
   * Compares two WBS values, returning 0 if equal, -1 if `lhs` is less than `rhs, or 1 if `lhs` is greater than `rhs`.
   * @param {String|Core.data.Wbs} lhs
   * @param {String|Core.data.Wbs} rhs
   * @returns {Number}
   */
  static compare(lhs, rhs) {
    if (lhs === rhs) {
      return 0;
    }
    if (!lhs || !rhs) {
      return lhs ? 1 : rhs ? -1 : 0;
    }
    lhs = _Wbs.pad(lhs);
    rhs = _Wbs.pad(rhs);
    return lhs < rhs ? -1 : rhs < lhs ? 1 : 0;
  }
  /**
   * Appends a sub-level WBS value to this WBS code and returns a `Wbs` instance for it.
   * @param {String|Number} value
   * @returns {Core.data.Wbs}
   */
  append(value) {
    const s = this.value;
    return _Wbs.from(s ? `${s}.${value}` : value);
  }
  /**
   * Returns truthy value if this Wbs equals the passed value.
   * @param {String|Core.data.Wbs} value
   * @returns {Boolean}
   */
  isEqual(value) {
    return !_Wbs.compare(this, value);
  }
  /**
   * Compares this WBS value with a specified pattern, returning `true` if they match. If the `pattern` is simply a
   * sequence of digits and decimal points (e.g., "1.2"), it is a match if it is a substring of this WBS code (e.g.,
   * "3.1.2.4"). If the `pattern` starts with `*` (e.g., "*.1.2"), it is a match if this WBS code ends with the text
   * following the `*` (e.g., "4.3.1.2"). If the `pattern` ends with `*`, it is a match if this WBS code starts with
   * the text up to the `*`.
   *
   * Some examples:
   * ```
   *  console.log(Wbs.from('1.2.3.4').match('2.3'));
   *  > true
   *  console.log(Wbs.from('1.2.3.4').match('*.4'));
   *  > true
   *  console.log(Wbs.from('1.2.3.4').match('1.2.*'));
   *  > true
   *
   *  console.log(Wbs.from('1.2.3.4').match('2.4'));
   *  > false
   *  console.log(Wbs.from('1.2.3.4').match('*.3'));
   *  > false
   *  console.log(Wbs.from('1.2.3.4').match('2.*'));
   *  > false
   * ```
   * @param {String} pattern A partial WBS code (e.g., "1.2"), optionally starting or ending with `*`.
   * @returns {Boolean}
   */
  match(pattern) {
    let ret = false;
    if (pattern) {
      const wbs = this.value, globLeft = pattern[0] === "*", globRight = pattern.endsWith("*"), n = pattern.length;
      if (globLeft === globRight) {
        ret = wbs.indexOf(globLeft ? pattern.substr(1, n - 2) : pattern) > -1;
      } else if (globLeft) {
        ret = wbs.endsWith(pattern.substr(1));
      } else {
        ret = wbs.startsWith(pattern.substr(0, n - 1));
      }
    }
    return ret;
  }
  toString() {
    return this.value;
  }
  toJSON() {
    return this.toString();
  }
  valueOf() {
    var _a2;
    return (_a2 = this._padded) != null ? _a2 : this._padded = _Wbs.pad(this.value);
  }
};
Wbs._$name = "Wbs";

// ../Core/lib/Core/data/mixin/StoreTree.js
var emptyArray4 = Object.freeze([]);
var StopBranch = Symbol("StopBranch");
var StoreTree_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get StopBranch() {
      return StopBranch;
    }
    //region Getters
    /**
     * True if this Store is configured to handle tree data (with `tree : true`) or if this is a
     * {@link Core.data.Store#function-makeChained chained store} and the master store is a tree store.
     * @property {Boolean}
     * @readonly
     * @category Tree
     */
    get isTree() {
      return this.tree || this.masterStore && this.masterStore.tree;
    }
    /**
     * Returns all leaf records in a tree store
     * @property {Core.data.Model[]}
     * @category Tree
     */
    get leaves() {
      const me = this, result = [];
      if (me.isTree) {
        me.traverse((record) => {
          if (record.isLeaf) {
            result.push(record);
          }
        });
        return result;
      } else {
        me.allRecords.forEach((r) => {
          if (r.isLeaf) {
            result.push(r);
          }
          r.traverse((record) => {
            if (record.isLeaf) {
              result.push(record);
            }
          }, true);
        });
      }
      return result;
    }
    //endregion
    //region Children
    /**
     * Loads children for a parent node that uses load on demand (when expanding it). Base implementation does nothing,
     * either use AjaxStore which implements it, create your own subclass with an implementation or listen for
     * `toggleNode` and insert records when you have them available.
     * @param {Core.data.Model} parentRecord
     * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
     * vetoed by a {@link Core.data.AjaxStore#event-beforeLoadChildren} handler, or if an {@link Core.data.AjaxStore#event-exception} is detected.
     * The resolved function is passed the event object passed to any event handlers.
     * The rejected function is passed the {@link Core.data.AjaxStore#event-exception} event if an exception occurred,
     * or `false` if the load was vetoed by a {@link Core.data.AjaxStore#event-beforeLoadChildren} handler.
     * @category Tree
     */
    async loadChildren(parentRecord) {
    }
    /**
     * Called from Model when adding children. Not to be called directly, use Model#appendChild() instead.
     * @internal
     * @param {Core.data.mixin.TreeNode} parent
     * @param {Core.data.mixin.TreeNode[]} children
     * @param {Number} index
     * @param {Object} isMove
     * @param {Boolean} [silent]
     * @fires add
     * @fires change
     * @category Tree
     */
    onNodeAddChild(parent, children, index, isMove, silent = false) {
      var _a3;
      const me = this, isRootLoad = parent === me.rootNode && parent.isLoading, { storage } = me, { previousSibling } = children[0];
      let storeInsertionPoint;
      const { visible: toAddToUI, all: toAdd } = me.collectDescendants(children, void 0, void 0, {
        inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me)),
        applyFilter: me.isFiltered && me.reapplyFilterOnAdd
      });
      if (!isRootLoad && toAdd.length) {
        for (const record of toAdd) {
          if (!me.modified.includes(record) && !isMove[record.id]) {
            if (me.removed.includes(record)) {
              me.removed.remove(record);
            } else if (!record.isLinked) {
              me.added.add(record);
            }
          }
        }
      }
      if (isRootLoad && me.rootVisible) {
        toAddToUI.unshift(parent);
        toAdd.unshift(parent);
      }
      if (toAddToUI.length) {
        if (index === 0 || !previousSibling) {
          storeInsertionPoint = storage.indexOf(parent);
        } else {
          storeInsertionPoint = storage.indexOf(previousSibling) + previousSibling.getDescendantCount(true, me);
        }
        storage.suspendEvents();
        me.storage.splice(++storeInsertionPoint, 0, toAddToUI);
        storage.resumeEvents();
        me._idMap = null;
      } else {
        me._allRecords = null;
      }
      me.updateDependentStores("add", children);
      if (isRootLoad && toAddToUI.length) {
        if (me.sorters.length) {
          me.sort(null, null, false, true);
        }
        (_a3 = me.afterLoadData) == null ? void 0 : _a3.call(me);
        if (!silent) {
          const event = { action: "dataset", data: me._data, records: toAddToUI };
          me.trigger("refresh", event);
          me.trigger("change", event);
        }
      } else if (!silent) {
        const event = { action: "add", parent, isChild: true, isMove, records: children, allRecords: toAdd, index: storeInsertionPoint };
        me.trigger("add", event);
        me.trigger("change", event);
        if (Object.values(isMove).some((wasMoved) => wasMoved)) {
          const event2 = {
            newParent: parent,
            records: children.filter((record) => isMove[record.id]),
            oldParents: children.map((child) => {
              return me.getById(child.meta.oldParentId);
            })
          };
          me.trigger("move", event2);
        }
      }
    }
    onNodeRemoveChild(parent, children, index, flags = { isMove: false, silent: false, unfiltered: false }) {
      const me = this, { storage } = me, toRemoveFromUI = [], toRemove = [], { isMove, silent, unfiltered } = flags, removeUnfiltered = unfiltered && me.isFiltered, childrenToRemove = removeUnfiltered && parent.unfilteredChildren ? parent.unfilteredChildren : children;
      me.collectDescendants(childrenToRemove, toRemoveFromUI, toRemove, { inCollapsedBranch: !(parent.isExpanded(me) && parent.ancestorsExpanded(me)), unfiltered: removeUnfiltered });
      if (!isMove) {
        for (const record of children) {
          record.unjoinStore(me);
        }
        for (const record of toRemove) {
          if (record.stores.includes(me)) {
            record.unjoinStore(me);
          }
          if (me.added.includes(record)) {
            me.added.remove(record);
          } else if (!record.isLinked) {
            me.removed.add(record);
          }
        }
        me.modified.remove(toRemove);
      }
      if (toRemoveFromUI.length) {
        index = storage.indexOf(toRemoveFromUI[0]);
        if (index > -1) {
          storage.suspendEvents();
          storage.splice(index, toRemoveFromUI.length);
          storage.resumeEvents();
          me._idMap = null;
        }
      } else {
        index = -1;
        me._allRecords = null;
      }
      if (!silent && (me.fireRemoveEventForMoveAction || !isMove)) {
        const event = {
          action: "remove",
          parent,
          isChild: true,
          isMove,
          records: children,
          allRecords: toRemove,
          index
        };
        me.trigger("remove", event);
        me.trigger("change", event);
      }
      return toRemove;
    }
    // IMPORTANT when using `applyFilter` option, should use the return value of this function
    // instead of relying on arguments mutation
    collectDescendants(node, visible = [], all = [], flags = {}) {
      var _a3;
      const me = this, { inCollapsedBranch = false, unfiltered = false, applyFilter = false } = flags, children = Array.isArray(node) ? node : (_a3 = me.getChildren(node, unfiltered)) != null ? _a3 : [];
      if (applyFilter) {
        return {
          visible: children.flatMap((child) => this.collectVisibleNodeDescendantsFiltered(child)),
          all: children.flatMap((child) => child.allChildren)
        };
      } else {
        for (let i = 0, len = children.length, child; i < len; i++) {
          child = children[i];
          if (!inCollapsedBranch) {
            visible.push(child);
          }
          all.push(child);
          me.collectDescendants(child, visible, all, {
            inCollapsedBranch: inCollapsedBranch || !child.isExpanded(me),
            unfiltered
          });
        }
        return { visible, all };
      }
    }
    collectVisibleNodeDescendantsFiltered(node) {
      const children = node.unfilteredChildren || node.children;
      if (!children || children.length === 0 || !node.isLeaf && !node.isExpanded(this)) {
        return this.filtersFunction(node) ? [node] : [];
      }
      const filteredChildren = children.flatMap((child) => this.collectVisibleNodeDescendantsFiltered(child));
      return filteredChildren.length || this.filtersFunction(node) ? [node, ...filteredChildren] : [];
    }
    /**
     * Returns the children of the passed branch node which this store owns. By default, this
     * is the entire `children` array.
     *
     * **If this store {@link Core.data.mixin.StoreChained#property-isChained isChained}**, then
     * this returns only the subset of children which are filtered into this store by the
     * {@link Core.data.mixin.StoreChained#config-chainedFilterFn chainedFilterFn}.
     * @param {Core.data.Model} parent The node to return the children of.
     * @returns {Core.data.Model[]}
     * @category Tree
     */
    getChildren(parent, unfiltered = false) {
      const me = this, children = (unfiltered || me.isChained) && parent.unfilteredChildren || parent.children;
      return !(children == null ? void 0 : children.length) ? emptyArray4 : me.isChained ? children.filter(me.chainedFilterFn).sort(me.sorterFn) : children;
    }
    /**
     * Includes or excludes all records beneath parentRecord in storage. Used when expanding or collapsing
     * nodes.
     * @private
     * @param parentRecord Parent record
     * @param include Include (true) or exclude (false)
     * @category Tree
     */
    internalToggleTreeSubRecords(parentRecord, include) {
      const me = this, { storage } = me, index = storage.indexOf(parentRecord), children = me.doIncludeExclude(me.getChildren(parentRecord), include);
      if (me.isFiltered && include && parentRecord.unfilteredChildren) {
        me.updateChildrenHiddenState(parentRecord);
      }
      if (children.length && index !== false) {
        storage.suspendEvents();
        if (include) {
          storage.splice(index + 1, 0, ...children);
          const event = { action: "add", isExpand: true, records: children, index: index + 1 };
          me.trigger("add", event);
          me.trigger("change", event);
        } else {
          storage.splice(index + 1, children.length);
          const event = { action: "remove", isCollapse: true, records: children, index: index + 1 };
          me.trigger("remove", event);
          me.trigger("change", event);
        }
        storage.resumeEvents();
        me._idMap = null;
      }
    }
    // Updates the hidden flag of its children while store is filtered
    updateChildrenHiddenState(parentRecord) {
      var _a3;
      (_a3 = parentRecord.unfilteredChildren) == null ? void 0 : _a3.forEach((child) => {
        child.instanceMeta(this.id).hidden = false;
        if (!child.isLeaf) {
          this.updateChildrenHiddenState(child);
        }
      });
    }
    doIncludeExclude(children, include, result = []) {
      const me = this, childCount = (children == null ? void 0 : children.length) || 0;
      for (let i = 0; i < childCount; i++) {
        const child = children[i];
        if (!me.isChained || me.chainedFilterFn(child)) {
          const mapMeta = child.instanceMeta(me.id);
          if (include || !mapMeta.hidden) {
            result.push(child);
          }
          mapMeta.hidden = !include;
          if (child.isExpanded(me)) {
            me.doIncludeExclude(me.getChildren(child), include, result);
          }
        }
      }
      return result;
    }
    /**
     * Collapse an expanded record or expand a collapsed. Optionally forcing a certain state.
     * @param {String|Number|Core.data.Model} idOrRecord Record (the record itself) or id of a record to toggle
     * @param {Boolean} [collapse] Force collapse (true) or expand (false)
     * @category Tree
     */
    async toggleCollapse(idOrRecord, collapse) {
      const me = this, record = me.getById(idOrRecord), meta = record.instanceMeta(me);
      if (collapse === void 0) {
        collapse = !meta.collapsed;
      }
      if (!meta.isLoadingChildren && !record.isLeaf && record.isExpanded(me) === collapse) {
        me.trigger("beforeToggleNode", { record, collapse });
        meta.collapsed = collapse;
        if (meta.collapsed) {
          me.onNodeCollapse(record);
          return true;
        } else {
          me.onNodeExpand(record);
          let success2 = true;
          if (!record.isLoaded) {
            meta.isLoadingChildren = true;
            try {
              await me.loadChildren(record);
            } catch (exception) {
              meta.collapsed = true;
              success2 = false;
              me.trigger("loadChildrenException", { record, exception });
            } finally {
              meta.isLoadingChildren = false;
            }
          }
          return success2;
        }
      }
    }
    /**
     * Remove all records beneath parentRecord from storage.
     * @private
     * @param parentRecord Parent record
     * @category Tree
     */
    onNodeCollapse(parentRecord) {
      if (parentRecord.ancestorsExpanded(this)) {
        return this.internalToggleTreeSubRecords(parentRecord, false);
      }
    }
    /**
     * Add all records beneath parentRecord from storage.
     * @private
     * @param parentRecord Parent record
     * @category Tree
     */
    onNodeExpand(parentRecord) {
      if (parentRecord.ancestorsExpanded(this)) {
        return this.internalToggleTreeSubRecords(parentRecord, true);
      }
    }
    //endregion
    //region Transform flat data
    /**
     * Transforms flat data containing parent ids into tree data
     * @param {Object[]} data Flat raw data
     * @returns {Object[]} Tree data
     * @private
     */
    transformToTree(data) {
      const { parentIdField, idField, childrenField } = this.modelClass, indexById = /* @__PURE__ */ new Map(), parentIds = /* @__PURE__ */ new Set(), transformed = [];
      for (const node of data) {
        const id = node[idField];
        if (id != null) {
          indexById.set(id, node);
        }
      }
      const cloneParent = (node) => {
        const clone = Object.assign({}, node);
        clone[childrenField] = [];
        indexById.set(clone[idField], clone);
        parentIds.add(node[idField]);
        return clone;
      };
      for (let node of data) {
        const nodeId = node[idField];
        if (parentIds.has(nodeId)) {
          node = indexById.get(nodeId);
        } else {
          node = cloneParent(node);
        }
        const parentId = node[parentIdField];
        if (parentId != null) {
          let parent = indexById.get(parentId);
          if (parent) {
            if (!parent[childrenField]) {
              parent = cloneParent(parent);
            }
            parent[childrenField].push(node);
          }
        } else {
          if (node[childrenField]) {
            transformed.push(node);
          } else if (node[idField] != null) {
            transformed.push(cloneParent(node));
          } else {
            transformed.push(node);
          }
        }
      }
      indexById.forEach((parent) => {
        var _a3, _b;
        (_b = (_a3 = parent[childrenField]).sort) == null ? void 0 : _b.call(_a3, (child1, child2) => child1.parentIndex - child2.parentIndex);
      });
      return transformed;
    }
    /**
     * Transforms data into a tree with parent levels based on supplied fields.
     *
     * ```javascript
     * const newRoot = store.treeify(['name', r => r.age % 10]);
     * ```
     *
     * Generated parent records are indicated with `generatedParent` and `key` properties. The first one is set to
     * `true` and the latter one has a value for the group the parent represents.
     *
     * @param {Array<String|Function>} fields The field names, or a function to call to extract a value to create parent
     * nodes for records with the same value.
     * @param {Function} [parentTransform] A function which is called to allow the caller to transform the raw data
     * object of any newly created parent nodes.
     * @param {Boolean} [convertParents] Pass `true` to convert raw new parent data objects to this Store's
     * {@link Core.data.Store#config-modelClass}.
     * @returns {Core.data.Model} New root node
     * @internal
     */
    treeify(fields, parentTransform, convertParents = false) {
      const { length } = fields, parents = [], orphans = [], newRoot = {};
      let i, lastParents;
      for (i = 0; i < length; i++) {
        let field = fields[i];
        field = field.field || field;
        if (!fields[i].call) {
          fields[i] = (n) => n[field];
          fields[i].fieldName = field;
        }
        parents[i] = /* @__PURE__ */ new Map();
      }
      this.rootNode.traverse((n) => {
        var _a3;
        lastParents = [];
        if (n.isLeaf) {
          for (i = 0; i < length; i++) {
            const lastParentPath = ((_a3 = lastParents[(lastParents == null ? void 0 : lastParents.length) - 1]) == null ? void 0 : _a3.path) || "", nodeMap = parents[i], keys = ArrayHelper.asArray(fields[i](n)) || [], newParents = [];
            if (keys[0] === StopBranch) {
              break;
            }
            for (let j = 0, { length: length2 } = keys; j < length2; j++) {
              const key = keys[j], path = `${lastParentPath + ((key == null ? void 0 : key.isModel) ? key.id : key)}/`, id = StringHelper.makeValidDomId(`generated_${path}`, "_"), field = fields[i].fieldName, parent = nodeMap.get(id) || nodeMap.set(id, {
                id,
                key,
                path,
                expanded: true,
                readOnly: true,
                children: [],
                generatedParent: true,
                field,
                firstGroupChild: n
              }).get(id);
              newParents.push(parent);
            }
            lastParents.forEach((lastParent) => {
              newParents.forEach((parent) => {
                if (!lastParent.children.includes(parent)) {
                  lastParent.children.push(parent);
                }
              });
            });
            lastParents = newParents;
          }
          if (lastParents.length) {
            lastParents.forEach((lastParent, j) => lastParent.children.push(j ? n.link() : n));
          } else {
            orphans.push(n);
          }
        }
      }, true);
      if (parentTransform || convertParents) {
        parents.forEach((p) => p.forEach((p2, id, map2) => {
          parentTransform == null ? void 0 : parentTransform(p2);
          if (convertParents) {
            p2 = this.createRecord(p2);
            map2.set(id, p2);
          }
        }));
      }
      newRoot.children = [...parents[0].values(), ...orphans];
      const sort = (n) => {
        if (n.children) {
          n.children.sort((lhs, rhs) => {
            if (lhs.isLeaf === rhs.isLeaf) {
              if (lhs.isLeaf) {
                let result;
                for (let i2 = 0; !result && i2 < length; i2++) {
                  const lv = fields[i2](lhs), rv = fields[i2](rhs);
                  if (lv === StopBranch || rv === StopBranch) {
                    return lhs.isLeaf < rhs.isLeaf ? -1 : lhs.isLeaf > rhs.isLeaf ? 1 : 0;
                  }
                  result = lv < rv ? -1 : rv > lv ? 1 : 0;
                }
                return result;
              } else if (typeof lhs.key === "string" && typeof rhs.key === "string") {
                return lhs.key.localeCompare(rhs.key, void 0, { numeric: true });
              } else {
                return lhs.key < rhs.key ? -1 : lhs.key > rhs.key ? 1 : 0;
              }
            } else {
              return lhs.isLeaf < rhs.isLeaf ? -1 : lhs.isLeaf > rhs.isLeaf ? 1 : 0;
            }
          });
          n.children.forEach(sort);
        }
      };
      sort(newRoot);
      return newRoot;
    }
    //endregion
    treeifyFlatData(data) {
      const { childrenField, parentIdField } = this.modelClass;
      let hasParentId = false, shouldTransform = true;
      for (const node of data) {
        if (node.isModel || Array.isArray(node[childrenField])) {
          shouldTransform = false;
          break;
        }
        if (node[parentIdField] != null) {
          hasParentId = true;
        }
      }
      if (shouldTransform && hasParentId) {
        data = this.transformToTree(data);
      }
      return data;
    }
    /**
     * Increase the indentation level of one or more nodes in the tree
     * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to indent.
     * @fires indent
     * @fires change
     * @category Tree
     */
    async indent(nodes) {
      const me = this;
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes = nodes.filter((node) => {
        let result = Boolean(node.previousSibling);
        while (result && !node.isRoot) {
          result = !nodes.includes(node.parent);
          node = node.parent;
        }
        return result;
      });
      if (nodes.length && me.trigger("beforeIndent", { records: nodes }) !== false) {
        nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
        me.beginBatch();
        for (const node of nodes) {
          const newParent = node.previousSibling;
          newParent.appendChild(node);
          me.toggleCollapse(newParent, false);
        }
        me.endBatch();
        me.trigger("indent", { records: nodes });
        me.trigger("change", {
          action: "indent",
          records: nodes
        });
      }
    }
    /**
     * Decrease the indentation level of one or more nodes in the tree
     * @param {Core.data.Model|Core.data.Model[]} nodes The nodes to outdent.
     * @fires outdent
     * @fires change
     * @category Tree
     */
    async outdent(nodes) {
      const me = this;
      nodes = Array.isArray(nodes) ? nodes : [nodes];
      nodes = nodes.filter((node) => {
        const { parent } = node;
        let result = parent && !parent.isRoot;
        while (result && !node.isRoot) {
          result = !nodes.includes(parent);
          node = node.parent;
        }
        return result;
      });
      if (nodes.length && me.trigger("beforeOutdent", { records: nodes }) !== false) {
        nodes.sort((lhs, rhs) => Wbs.compare(lhs.wbsCode, rhs.wbsCode));
        me.beginBatch();
        for (const node of nodes) {
          const { parent } = node, newChildren = parent.children.slice(parent.children.indexOf(node) + 1);
          parent.parent.insertChild(node, parent.nextSibling);
          node.appendChild(newChildren);
          me.toggleCollapse(node, false);
        }
        me.endBatch();
        me.trigger("outdent", { records: nodes });
        me.trigger("change", {
          action: "outdent",
          records: nodes
        });
      }
    }
  }, __publicField(_a2, "$name", "StoreTree"), /**
   * A special `Symbol` signalizing treeify method that the current record grouping should be stopped.
   *
   * ```javascript
   * const newRoot = workerStore.treeify([
   *     // group workers by company
   *     worker => {
   *         // if the worker is unemployed we don't put it in a group
   *         // we just show such record on the root level
   *         if (!worker.company) {
   *             return Store.StopBranch
   *         }
   *
   *         return worker.company;
   *     ]
   * ]);
   * ```
   * @member {Symbol} StopBranch
   * @static
   * @category Advanced
   */
  __publicField(_a2, "StopBranch", StopBranch), __publicField(_a2, "configurable", {
    /**
     * Set to `true` to on load transform a flat dataset with raw objects containing `parentId` into the format
     * expected for tree data.
     *
     * Example input format:
     *
     * ```javascript
     * [
     *   { id : 1, name : 'Parent' },
     *   { id : 2, name : 'Child', parentId : 1 }
     * ]
     * ```
     *
     * Will be transformed into:
     *
     * ```javascript
     * [
     *   {
     *     id       : 1,
     *     name     : 'Parent',
     *     children : [
     *       { id : 2, name : 'Child', parentId : 1 }
     *     ]
     *   }
     * ]
     * ```
     *
     * @config {Boolean}
     * @category Tree
     */
    transformFlatData: null,
    /**
     * This flag prevents firing of 'remove' event when moving a node in the tree. In 6.0 this will be the default
     * behavior and this flag will be removed.
     * @config {Boolean}
     * @category Tree
     */
    fireRemoveEventForMoveAction: VersionHelper.checkVersion("core", "6.0", "<")
  }), _a2;
};

// ../Core/lib/Core/helper/WalkHelper.js
var WalkHelper = class {
  /**
   * Pre-walks any hierarchical data structure
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static preWalk(data, childrenFn, fn2) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack.pop();
      fn2(node);
      children = childrenFn(node);
      if (children) {
        walkStack.push.apply(walkStack, children.slice().reverse());
      }
    }
  }
  /**
   * Pre-walks any hierarchical data structure, passing along a link to the parent node
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry, called with `parent` and `node`
   */
  static preWalkWithParent(data, childrenFn, fn2) {
    const walkStack = [{ node: data, parent: null }];
    while (walkStack.length) {
      const { parent, node } = walkStack.pop();
      fn2(parent, node);
      const children = childrenFn(node);
      if (Array.isArray(children)) {
        walkStack.push(...children.slice().reverse().map((child) => ({ node: child, parent: node })));
      }
    }
  }
  /**
   * Pre-walk unordered.
   *
   * Like {@link #function-preWalk-static} but doesn't reverse children before walk,
   * thus children will be walked last child first - first child last
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static preWalkUnordered(data, childrenFn, fn2) {
    const walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack.pop();
      fn2(node);
      children = childrenFn(node);
      if (children) {
        walkStack.push.apply(walkStack, children);
      }
    }
  }
  /**
   * Post-walks any hierarchical data structure
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} fn Function to call on each entry
   */
  static postWalk(data, childrenFn, fn2) {
    const visited = /* @__PURE__ */ new Map(), walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        fn2(node);
        walkStack.pop();
      } else {
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
  /**
   * Pre-/Post-walks any hierarchical data structure calling inFn each node when it walks in,
   * and outFn when it walks out.
   *
   * @param {Object} data Walking starting point
   * @param {Function} childrenFn Function to return `data` children entries in an array
   *                   or null if no children exists for the entry
   * @param {Function} inFn  Function to call on each entry upon enter
   * @param {Function} outFn Function to call on each entry upon exit
   */
  static prePostWalk(data, childrenFn, inFn, outFn) {
    const visited = /* @__PURE__ */ new Map(), walkStack = [data];
    let node, children;
    while (walkStack.length) {
      node = walkStack[walkStack.length - 1];
      if (visited.has(node)) {
        outFn(node);
        walkStack.pop();
      } else {
        inFn(node);
        children = childrenFn(node);
        if (children) {
          walkStack.push(...children.slice().reverse());
        }
        visited.set(node, node);
      }
    }
  }
};
WalkHelper._$name = "WalkHelper";

// ../Core/lib/Core/data/mixin/StoreSync.js
var StoreSync_default = (Target) => class StoreSync extends (Target || Base) {
  static get $name() {
    return "StoreSync";
  }
  static get configurable() {
    return {
      /**
       * Configure with `true` to sync loaded data instead of replacing existing with a new dataset.
       *
       * By default (or when configured with `false`) assigning to `store.data` replaces the entire dataset
       * with a new one, creating all new records:
       *
       * ```javascript
       * store.data = [ { id : 1, name : 'Saitama' } ];
       *
       * const first = store.first;
       *
       * store.data = [ { id : 1, name : 'One-Punch man' } ];
       *
       * // store.first !== first;
       * ```
       *
       * When configured with `true` the new dataset is instead synced against the old, figuring out what was
       * added, removed and updated:
       *
       * ```javascript
       * store.data = [ { id : 1, name : 'Saitama' } ];
       *
       * const first = store.first;
       *
       * store.data = [ { id : 1, name : 'One-Punch man' } ];
       *
       * // store.first === first;
       * ```
       *
       * After the sync, any configured sorters, groupers and filters will be reapplied.
       *
       * #### Threshold
       *
       * The sync operation has a configurable threshold, above which the operation will be treated as a
       * batch/refresh and only trigger a single `refresh` event. If threshold is not reached, individual events
       * will be triggered (single `add`, `remove` and possible multiple `update`). To enable the threshold,
       * supply a config object with a `threshold` property instead of `true`:
       *
       * ```javascript
       * const store = new Store({
       *     syncDataOnLoad : {
       *         threshold : '20%'
       *     }
       * });
       * ```
       *
       * `threshold` accepts numbers or strings. A numeric threshold means number of affected records, while a
       * string is used as a percentage of the whole dataset (appending `%` is optional). By default no threshold
       * is used.
       *
       * #### Missing fields
       *
       * The value of any field not supplied in the new dataset is by default kept as is (if record is not removed
       * by the sync). This behaviour is configurable, by setting `keepMissingValues : false` in a config object
       * it will reset any unspecified field back to their default values:
       *
       * ```javascript
       * const store = new Store({
       *     syncDataOnLoad : {
       *         keepMissingValues : false
       *     }
       * });
       * ```
       *
       * Considering the following sync operation:
       *
       * ```javascript
       * // Existing data
       * { id : 1, name : 'Saitama', powerLevel : 100 }
       * // Sync data
       * { id : 1, name : 'One-Punch Man' }
       * ```
       *
       * The result would by default (or when explicitly configured with `true`)  be:
       *
       * ```javascript
       * { id : 1, name : 'One-Punch Man', powerLevel : 100 }
       * ```
       *
       * If configured with `keepMissingValues : false` it would instead be:
       *
       * ```javascript
       * { id : 1, name : 'One-Punch Man' }
       * ```
       *
       * <div class="note">Never enable `syncDataOnLoad` on a chained store, it will create an infinite loop when
       * it is populated from the main store (the main store can use the setting)</div>
       *
       * @config {Boolean|SyncDataOnLoadOptions} syncDataOnLoad
       * @default false
       * @category Common
       */
      syncDataOnLoad: null,
      shouldSyncDataset: null,
      shouldSyncRecord: null
    };
  }
  /**
   * Syncs a new dataset against the already loaded one, only applying changes.
   * Not intended to be called directly, please configure store with `syncDataOnLoad: true` and assign to
   * `store.data` as usual instead.
   *
   * ```
   * const store = new Store({
   *    syncDataOnLoad : true,
   *    data : [
   *        // initial data
   *    ]
   * });
   *
   * store.data = [ // new data ]; //  Difference between initial data and new data will be applied
   * ```
   *
   * @param {Object[]|Core.data.Model[]} data New dataset, an array of records or data objects
   * @private
   */
  syncDataset(data) {
    var _a2;
    const me = this, { storage } = me, idsToCheck = (_a2 = me.shouldSyncDataset) == null ? void 0 : _a2.call(me, { data });
    if (idsToCheck === false) {
      return;
    }
    me.trigger("startApplyChangeset");
    me.isSyncingDataOnLoad = true;
    const { toAdd, toRemove, toMove, updated, ids } = me.tree ? me.syncTreeDataset(data, idsToCheck) : me.syncFlatDataset(data, idsToCheck);
    let { threshold } = me.syncDataOnLoad, surpassed = false;
    if (threshold) {
      if (typeof threshold === "string") {
        threshold = parseInt(threshold, 10) / 100 * me.count;
      }
      surpassed = toAdd.length + toRemove.length + toMove.length + updated.length > threshold;
    }
    if (me.tree) {
      if (toAdd.length) {
        const added = me.add(toAdd, surpassed);
        added.forEach((node) => node.clearParentId());
      }
      if (toMove.length) {
        for (const { parent, node, index } of toMove) {
          const newParent = me.getById(parent.id);
          newParent.insertChild(node, index);
        }
      }
      me.remove(toRemove, surpassed);
    } else {
      if (surpassed) {
        me.suspendEvents();
      }
      me.remove(toRemove);
      me.add(toAdd);
      if (surpassed) {
        me.resumeEvents();
      }
    }
    if (threshold && !surpassed) {
      updated.forEach(({ record, toSet, wasSet }) => me.onModelChange(record, toSet, wasSet));
    }
    me.acceptChanges();
    const event = { added: toAdd, removed: toRemove, updated, thresholdSurpassed: surpassed };
    if (me.isFiltered && !me.remoteFilter) {
      me.filter({
        silent: me.isRemoteDataLoading
      });
    }
    if (me.isGrouped) {
      me.group(null, null, false, true, me.isRemoteDataLoading);
    } else if (me.isSorted) {
      if (me.remoteSort) {
        storage.replaceValues({
          values: storage.values.sort(me.createSorterFn(me.sorters)),
          silent: true
        });
      } else {
        me.sort();
      }
    } else if (!me.tree) {
      if (storage.values.some((record, index) => record.id !== ids[index])) {
        storage.replaceValues({
          values: storage.values.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id)),
          silent: true
        });
        !surpassed && me.afterPerformSort();
      }
    } else {
      let unsorted = false, i = 0;
      WalkHelper.preWalk(
        me.rootNode,
        (n) => Array.isArray(n.children) && !unsorted ? n.children : null,
        (node) => {
          if (node.id !== ids[i++]) {
            unsorted = true;
          }
        }
      );
      if (unsorted) {
        me.sort((a, b) => ids.indexOf(a.id) - ids.indexOf(b.id), void 0, void 0, true);
        me.clearSorters(true);
        !surpassed && me.afterPerformSort();
      }
    }
    if (surpassed) {
      me.trigger("refresh", {
        action: "batch",
        data,
        records: storage.values,
        syncInfo: event
      });
    }
    me.isSyncingDataOnLoad = false;
    me.trigger("endApplyChangeset");
    me.trigger("loadSync", event);
  }
  // Used by syncDataset()
  syncFlatDataset(data, idsToCheck) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this, { idField, allFields } = me.modelClass, toRemove = [], toAdd = [], updated = [], usedIds = {}, ids = [], limitedSet = Array.isArray(idsToCheck);
    const { threshold, keepMissingValues } = me.syncDataOnLoad;
    let hitCount = 0;
    data.forEach((rawData) => {
      var _a2, _b, _c;
      rawData = rawData.isModel ? rawData.data : rawData;
      const id = rawData[idField], record = me.getById(id);
      if (!limitedSet || idsToCheck.includes(id)) {
        if (record) {
          if (((_a2 = me.shouldSyncRecord) == null ? void 0 : _a2.call(me, { record, data: rawData })) !== false) {
            (_b = me.beforeSyncRecord) == null ? void 0 : _b.call(me, { record, data: rawData });
            if (keepMissingValues === false) {
              for (const field of allFields) {
                if (!(field.dataSource in rawData) && field.dataSource in record.data) {
                  rawData[field.dataSource] = field.defaultValue;
                }
              }
            }
            const wasSet = record.set(rawData, null, Boolean(threshold));
            if (wasSet) {
              updated.push({
                record,
                wasSet,
                toSet: rawData
              });
            }
            (_c = me.afterSyncRecord) == null ? void 0 : _c.call(me, { record, data: rawData });
          }
        } else {
          toAdd.push(me.processRecord(me.createRecord(rawData)));
        }
      }
      if (record) {
        hitCount++;
      }
      usedIds[id] = 1;
      ids.push(id);
    });
    if (hitCount < me.allRecords.filter((x) => !x.isSpecialRow).length) {
      if (idsToCheck) {
        for (const id of idsToCheck) {
          if (!usedIds[id]) {
            toRemove.push(me.getById(id));
          }
        }
      } else {
        me.forEach((record) => {
          if (!usedIds[record.id]) {
            toRemove.push(record);
          }
        }, me, {
          includeFilteredOutRecords: true,
          includeCollapsedGroupRecords: true
        });
      }
    }
    return { toAdd, toRemove, toMove: [], updated, ids };
  }
  // Used by syncDataset()
  syncTreeDataset(data) {
    if (!data) {
      return {
        toRemove: this.records
      };
    }
    const me = this, {
      idField,
      parentIdField,
      childrenField,
      allFields
    } = me.modelClass, {
      keepMissingValues,
      threshold
    } = me.syncDataOnLoad, toRemove = [], toAdd = [], toMove = [], updated = [], matchedNodes = /* @__PURE__ */ new Set(), ids = [];
    if (me.transformFlatData) {
      data = me.treeifyFlatData(data);
    }
    WalkHelper.preWalkWithParent({ isRoot: true, id: me.rootNode.id, children: data }, (n) => n.children, (parent, rawData) => {
      var _a2;
      if (parent) {
        const { id, node } = me.resolveSyncNode(rawData);
        if (node) {
          if (((_a2 = me.shouldSyncRecord) == null ? void 0 : _a2.call(me, { record: node, data: rawData })) !== false) {
            let childrenUpdated;
            const oldChildrenValue = node.children;
            if (oldChildrenValue !== true && rawData[childrenField] === true) {
              node.clearChildren();
              node.data[childrenField] = node.children = true;
              delete rawData[childrenField];
              me.toggleCollapse(node, true);
              childrenUpdated = true;
            }
            if (node.parent.id !== parent[idField]) {
              toMove.push({
                node,
                parent,
                index: parent[childrenField].indexOf(rawData)
              });
            }
            if (keepMissingValues === false) {
              for (const field of allFields) {
                if (field.name !== "parentId" && !(field.dataSource in rawData) && field.dataSource in node.data) {
                  rawData[field.dataSource] = field.defaultValue;
                }
              }
            }
            if (typeof rawData.expanded === "boolean") {
              this.toggleCollapse(node, !rawData.expanded);
            }
            const wasSet = node.set(rawData, null, Boolean(threshold));
            if (wasSet) {
              updated.push({
                record: node,
                wasSet,
                toSet: rawData
              });
            } else if (childrenUpdated) {
              node.signalNodeChanged({
                [childrenField]: {
                  value: true,
                  oldValue: oldChildrenValue
                }
              });
            }
          }
        } else {
          rawData[parentIdField] = parent[idField];
          toAdd.push({ ...rawData, ...Array.isArray(rawData[childrenField]) ? { children: [] } : void 0 });
        }
        matchedNodes.add(node);
        ids.push(id);
      }
    });
    if (matchedNodes.length !== data.length) {
      me.traverse((node) => {
        if (!matchedNodes.has(node)) {
          toRemove.push(node);
        }
      });
    }
    return { toAdd, toRemove, toMove, updated, ids };
  }
  // ColumnStore overrides this fn to allow syncing by field & type
  resolveSyncNode(rawData) {
    const id = rawData[this.modelClass.idField], node = this.getById(id);
    return { id, node };
  }
};

// ../Core/lib/Core/data/stm/mixin/StoreStm.js
var STM_PROP2 = Symbol("STM_PROP");
var StoreStm_default = (Target) => class StoreStm extends (Target || Base) {
  static get $name() {
    return "StoreStm";
  }
  static get defaultConfig() {
    return {
      /**
       * Reference to STM manager
       *
       * @config {Core.data.stm.StateTrackingManager}
       * @default
       * @category Advanced
       */
      stm: null,
      /**
       * Set to `false` to not record transaction during `applyChangeset` call
       *
       * @prp {Boolean}
       * @default
       * @category Advanced
       */
      ignoreRemoteChangesInSTM: false
    };
  }
  get stm() {
    return this[STM_PROP2];
  }
  set stm(stm) {
    var _a2;
    const me = this;
    if (me.stm !== stm) {
      if ((_a2 = me.stm) == null ? void 0 : _a2.hasStore(me)) {
        me.stm.removeStore(me);
      }
      me[STM_PROP2] = stm;
      if (me.stm && !me.stm.hasStore(me)) {
        me.stm.addStore(me);
      }
    }
  }
  // Overridden to notify STM about flat add action
  add(records, silent = false, options = {}) {
    let result;
    const { stm } = this;
    if (!this.tree && (stm == null ? void 0 : stm.enabled)) {
      result = super.add(records, silent);
      if (result == null ? void 0 : result.length) {
        stm.onStoreModelAdd(this, result, silent);
      }
    } else {
      result = super.add(records, silent, options);
    }
    return result;
  }
  // Overridden to notify STM about flat insert action
  insert(index, records, silent = false) {
    let result;
    const { stm } = this;
    if (!this.tree && (stm == null ? void 0 : stm.enabled)) {
      const context = (Array.isArray(records) ? records : [records]).reduce(
        (context2, r) => {
          const index2 = r instanceof Model ? this.indexOf(r) : void 0;
          if (index2 !== void 0 && index2 !== -1) {
            context2.set(r, index2);
          }
          return context2;
        },
        /* @__PURE__ */ new Map()
      );
      result = super.insert(index, records);
      if (result == null ? void 0 : result.length) {
        index = this.indexOf(result[0]);
        stm.onStoreModelInsert(this, index, result, context, silent);
      }
    } else {
      result = super.insert(index, records, silent);
    }
    return result;
  }
  // Overridden to notify STM about flat removing action
  remove(recordsOrIds, silent = false, fromRemoveChild) {
    let result;
    const { stm } = this;
    if (!this.tree && (stm == null ? void 0 : stm.enabled)) {
      const recordsOrIdsNormalized = (Array.isArray(recordsOrIds) ? recordsOrIds : [recordsOrIds]).map((r) => this.getById(r)).filter((r) => !!r);
      const context = recordsOrIdsNormalized.reduce(
        (context2, r) => {
          const index = this.indexOf(r);
          if (index !== void 0 && index !== -1) {
            context2.set(r, index);
          }
          return context2;
        },
        /* @__PURE__ */ new Map()
      );
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
      if (result == null ? void 0 : result.length) {
        stm.onStoreModelRemove(this, result, context, silent);
      }
    } else {
      result = super.remove(recordsOrIds, silent, fromRemoveChild);
    }
    return result;
  }
  // Overridden to notify STM about flat clear action
  removeAll(silent) {
    const { stm } = this;
    let result;
    if (stm == null ? void 0 : stm.enabled) {
      const { tree, rootNode, allRecords } = this, wasNotEmpty = allRecords.length, records = tree ? rootNode.children.slice() : allRecords.slice();
      result = super.removeAll(silent);
      if (wasNotEmpty && this.count === 0) {
        stm.onStoreRemoveAll(this, records, silent);
      }
    } else {
      result = super.removeAll(silent);
    }
    return result;
  }
  beforeApplyChangeset() {
    const { stm, crudManager } = this;
    let shouldResume = false, transactionId = null;
    if (!(crudManager == null ? void 0 : crudManager.applyingChangeset) && (stm == null ? void 0 : stm.enabled)) {
      shouldResume = true;
      if (stm.isRecording) {
        transactionId = stm.stash();
      }
      if (this.ignoreRemoteChangesInSTM) {
        stm.disable();
      } else {
        stm.startTransaction();
      }
    }
    return { shouldResume, transactionId };
  }
  // When applying changes while STM is in the recording state, first we need to discard local changes, then apply
  // changes from remote, then try to apply local changes. This would emulate starting transaction as if data was
  // already in the correct state
  applyChangeset(changes, transformFn, phantomIdField, remote, logChanges) {
    const {
      shouldResume,
      transactionId
    } = this.beforeApplyChangeset(), log = super.applyChangeset(changes, transformFn, phantomIdField, remote, logChanges);
    this.afterApplyChangeset(shouldResume, transactionId);
    return log;
  }
  afterApplyChangeset(shouldResume, transactionId) {
    if (shouldResume) {
      const { stm } = this;
      if (this.ignoreRemoteChangesInSTM) {
        stm.enable();
      } else {
        stm.stopTransaction();
      }
      stm.applyStash(transactionId);
    }
  }
};

// ../Core/lib/Core/data/Store.js
var dataAddRemoveActions = {
  splice: 1,
  clear: 1
};
var defaultTraverseOptions2 = {
  includeFilteredOutRecords: false,
  includeCollapsedGroupRecords: false
};
var fixTraverseOptions2 = (store, options) => {
  options = options || false;
  if (typeof options === "boolean") {
    options = {
      includeFilteredOutRecords: options,
      includeCollapsedGroupRecords: false
    };
  }
  return options || defaultTraverseOptions2;
};
var Store = class _Store extends Base.mixin(
  Delayable_default,
  Identifiable_default,
  Events_default,
  Pluggable_default,
  State_default,
  StoreFilter_default,
  StoreChanges_default,
  StoreCRUD_default,
  StoreRelation_default,
  // Private
  StoreSum_default,
  StoreSearch_default,
  StoreSort_default,
  StoreGroup_default,
  StoreChained_default,
  StoreState_default,
  StoreTree_default,
  StoreStm_default,
  StoreSync_default,
  StoreProxy_default
  // Private for now, thus not mentioned in @mixes block above
) {
  //region Config & properties
  static get $name() {
    return "Store";
  }
  static get properties() {
    return {
      relationCache: {},
      dependentStoreConfigs: /* @__PURE__ */ new Map(),
      addingClean: false
    };
  }
  static get configurable() {
    return {
      /**
       * Store's unique identifier.
       *
       * @member {String|Number} id
       * @readonly
       * @category Common
       */
      /**
       * Store's unique identifier. When set the store is added to a store map accessible through
       * `Store.getStore(id)`.
       *
       * @config {String|Number}
       * @category Common
       */
      id: true,
      /**
       * Class used to represent records in the store, should be a subclass of {@link Core.data.Model}. Only
       * applies when supplying data to the store (load, add), any supplied record instances are kept as is.
       *
       * ```javascript
       * class MyModel extends Model {
       *     static get fields() {
       *         return [
       *             'name',
       *             'city',
       *             'company'
       *         ]
       *     }
       * }
       *
       * const store = new Store({
       *     modelClass : MyModel,
       *     data : [
       *         { id : 1, name : 'Mark', city : 'London', company : 'Cool inc' },
       *         ...
       *     ]
       * });
       * ```
       *
       * @config {Core.data.Model}
       * @default
       * @typings {typeof Model}
       * @category Common
       */
      modelClass: Model,
      /**
       * Verify that loaded data does not contain any generated ids. If it does, a warning is logged on console.
       *
       * Set this to `false` to disable the check and give a very minor performance boost.
       *
       * @prp {Boolean}
       * @default
       */
      verifyNoGeneratedIds: true
    };
  }
  static get defaultConfig() {
    return {
      /**
       * An array of field definitions used to create a {@link Core.data.Model} (modelClass) subclass. Optional.
       * If the Model already has fields defined, these fields will extend those.
       *
       * ```javascript
       * const store = new Store({
       *     fields : ['name', 'city', 'company'],
       *     data   : [
       *         { id : 1, name : 'Mark', city : 'London', company : 'Cool inc' },
       *         ...
       *     ]
       * });
       * ```
       *
       * See {@link Core.data.Model} for more info on defining fields, changing data source and mapping fields to
       * nested objects.
       *
       * Note that pre-created record instances supplied to the store are kept as is and thus these fields will
       * not apply to them.
       *
       * @config {Array<String|ModelFieldConfig|Core.data.field.DataField>}
       * @category Common
       */
      fields: null,
      /**
       * Automatically detect from set data if used as tree store or flat store
       * @config {Boolean}
       * @default
       * @category Tree
       */
      autoTree: true,
      /**
       * Raw data to load initially.
       *
       * Expects an array of JavaScript objects, with properties matching store's fields (defined on its
       * {@link #config-modelClass model} or in the {@link #config-fields} config).
       *
       * ```javascript
       * const store = new Store({
       *     data : [
       *         { id : 1, name : 'Linda', city : 'NY' },
       *         { id : 2, name : 'Olivia', city : 'Paris' },
       *         ...
       *     ]
       * });
       * ```
       *
       * @config {Object[]|Core.data.Model[]}
       * @category Common
       */
      data: null,
      /**
       * `true` to act as a tree store.
       * @config {Boolean}
       * @category Tree
       */
      tree: false,
      callOnFunctions: true,
      /**
       * A {@link Core/util/Collection}, or Collection config object
       * to use to contain this Store's constituent records.
       * @config {Core.util.Collection|CollectionConfig}
       * @category Advanced
       */
      storage: null,
      /**
       * Retools the loaded data objects instead of making shallow copies of them. This increases performance but
       * pollutes the incoming data and does not allow remapping of fields (dataSource).
       *
       * Also allows disabling certain steps in data loading, to further improve performance. Either accepts an
       * object with the params described below or `true` which equals `disableDuplicateIdCheck` and
       * `disableTypeConversion`.
       *
       * ```javascript
       * // No duplicate id checking, no type conversions
       * new Store({ useRawData : true });
       *
       * new Store({
       *   // No type conversions only
       *   useRawData : {
       *     disableTypeConversion : true
       *   }
       * });
       * ```
       *
       * @config {Boolean|Object}
       * @param {Boolean} [disableDuplicateIdCheck] Data must not contain duplicate ids, check is bypassed.
       * @param {Boolean} [disableDefaultValue] Default values will not be applied to record fields.
       * @param {Boolean} [disableTypeConversion] No type conversions will be performed on record data.
       * @category Advanced
       */
      useRawData: false,
      /**
       * Specify `false` to prevent loading records without ids, a good practise to enforce when syncing with a
       * backend.
       *
       * By default Store allows loading records without ids, in which case a generated id will be assigned.
       *
       * @config {Boolean}
       * @default true
       * @category Advanced
       */
      allowNoId: true,
      /**
       * Prevent dynamically subclassing the modelClass. It does so by default to not pollute it when exposing
       * properties. Should rarely need to be used.
       * @config {Boolean}
       * @default false
       * @private
       * @category Advanced
       */
      preventSubClassingModel: null,
      /**
       * Store class to use when creating the store when it is a part of a
       * [CrudManager](https://bryntum.com/products/scheduler/docs/api/Scheduler/data/CrudManager).
       *
       * ```javascript
       * crudManager : {
       *      eventStore {
       *          storeClass : MyEventStore
       *      }
       * }
       * ```
       *
       * @config {Class}
       * @typings {typeof Store}
       * @category Advanced
       */
      storeClass: null
    };
  }
  static get identifiable() {
    return {
      registerGeneratedId: false
    };
  }
  /**
   * Class used to represent records. Defaults to class Model.
   * @member {Core.data.Model} modelClass
   * @typings {typeof Model}
   * @category Records
   */
  //endregion
  //region Events
  /**
   * Fired when the id of a record has changed
   * @event idChange
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {String|Number} oldValue Old id
   * @param {String|Number} value New id
   */
  /**
   * Fired before record is modified in this store.
   * Modification may be vetoed by returning `false` from a handler.
   * @event beforeUpdate
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {Object} changes Modification data
   */
  /**
   * Fired when a record is modified
   * @event update
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} record Modified record
   * @param {Object} changes Modification data
   */
  /**
   * Fired when one of this Store's constituent records is modified while in
   * {@link Core.data.Model#function-beginBatch batched} state. This may be used to keep
   * UIs up to date while "tentative" changes are made to a record which must not be synced with a server.
   * @event batchedUpdate
   * @private
   */
  /**
   * Fired when the root node is set
   * @event rootChange
   * @param {Core.data.Store} source This Store
   * @param {Core.data.Model} oldRoot The old root node.
   * @param {Core.data.Model} rootNode The new root node.
   */
  /**
   * Data in the store was changed. This is a catch-all event which is fired for all changes
   * which take place to the store's data.
   *
   * This includes mutation of individual records, adding and removal of records, as well as
   * setting a new data payload using the {@link #property-data} property, sorting, filtering,
   * and calling {@link Core.data.mixin.StoreCRUD#function-removeAll}.
   *
   * Simple databound widgets may use to the `change` event to refresh their UI without having to add multiple
   * listeners to the {@link #event-update}, {@link Core.data.mixin.StoreCRUD#event-add},
   * {@link Core.data.mixin.StoreCRUD#event-remove}, {@link #event-refresh} and
   * {@link Core.data.mixin.StoreCRUD#event-removeAll} events.
   *
   * A more complex databound widget such as a grid may use the more granular events to perform less
   * destructive updates more appropriate to each type of change. The properties will depend upon the value of the
   * `action` property.
   *
   * @event change
   * @param {Core.data.Store} source This Store.
   * @param {'remove'|'removeAll'|'add'|'updatemultiple'|'clearchanges'|'filter'|'update'|'dataset'|'replace'} action
   * Name of action which triggered the change. May be one of the options listed above
   * @param {Core.data.Model} record Changed record, for actions that affects exactly one record (`'update'`)
   * @param {Core.data.Model[]} records Changed records, passed for all actions except `'removeAll'`
   * @param {Object} changes Passed for the `'update'` action, info on which record fields changed
   */
  // NOTE: When updating params above, also update change event in ProjectModelMixin and dataChange in ProjectConsumer
  /**
   * Data in the store has completely changed, such as by a filter, or sort or load operation.
   * @event refresh
   * @param {Core.data.Store} source This Store.
   * @param {Boolean} batch Flag set to `true` when the refresh is triggered by ending a batch
   * @param {'dataset'|'sort'|'clearchanges'|'filter'|'create'|'update'|'delete'|'group'} action Name of
   * action which triggered the change. May be one of the options listed above.
   */
  //endregion
  /* break doc comment from next method */
  //region Init
  constructor(...args) {
    super(...args);
    if (this.objectify) {
      return this.initProxy();
    }
  }
  construct(config = {}) {
    const me = this;
    Object.assign(me, {
      added: new StoreBag(),
      removed: new StoreBag(),
      modified: new StoreBag(),
      idRegister: {},
      internalIdRegister: {},
      oldIdMap: {}
    });
    if (config.storeId) {
      config = ObjectHelper.assign({ id: config.storeId }, config);
    }
    super.construct(config);
    me.initRelations();
  }
  /**
   * Retrieves/creates a store based on the passed config.
   *
   * | Type              | Result                                                                 |
   * |-------------------|------------------------------------------------------------------------|
   * | Core.data.Store   | Returns supplied store as is                                           |
   * | String            | Retrieves an existing store by id                                      |
   * | Object            | Creates a new store using supplied config object                       |
   * | Object[]          | Creates a new store, populated with records created from supplied data |
   * | Core.data.Model[] | Creates a new store, populated with supplied records                   |
   *
   *
   * @param {Core.data.Store|StoreConfig|String|StoreConfig[]|Core.data.Model[]} config
   * @param {Object} [defaults] Config object to apply when creating a new store for passed data
   * @param {Function} [converterFn] Function called for each data object prior to creating a record from it. The
   * return value is used to create a record.
   * @private
   */
  static from(config, defaults = {}, converterFn = null) {
    if (config && !config.isStore) {
      if (typeof config === "string") {
        config = _Store.getStore(config);
      } else {
        if (Array.isArray(config)) {
          if (converterFn) {
            config = config.map((data) => data.isModel ? data : converterFn(data));
          }
          config = ObjectHelper.assign({}, defaults, { data: config });
        } else {
          config = ObjectHelper.assign({}, defaults, config);
        }
        config = new _Store(config);
      }
    }
    return config;
  }
  doDestroy() {
    var _a2, _b, _c, _d;
    const me = this, allRecords = me.registeredRecords;
    (_b = (_a2 = me.stm) == null ? void 0 : _a2.removeStore) == null ? void 0 : _b.call(_a2, me);
    for (let i = allRecords.length - 1, rec; i >= 0; i--) {
      rec = allRecords[i];
      if (!(rec == null ? void 0 : rec.isDestroyed)) {
        rec.unjoinStore(me);
      }
    }
    (_c = me._storage) == null ? void 0 : _c.destroy();
    if (!me.isChained) {
      (_d = me.rootNode) == null ? void 0 : _d.destroy();
    }
    super.doDestroy();
  }
  /**
   * Stops this store from firing events until {@link #function-endBatch} is called. Multiple calls to `beginBatch`
   * stack up, and will require an equal number of `endBatch` calls to resume events.
   *
   * Upon call of {@link #function-endBatch}, a {@link #event-refresh} event is triggered to allow UIs to
   * update themselves based upon the new state of the store.
   *
   * This is extremely useful when making a large number of changes to a store. It is important not to trigger
   * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
   * store are only updated once at the end of the updates.
   */
  beginBatch() {
    this.suspendEvents();
  }
  /**
   * Ends event suspension started by {@link #function-beginBatch}. Multiple calls to {@link #function-beginBatch}
   * stack up, and will require an equal number of `endBatch` calls to resume events.
   *
   * Upon call of `endBatch`, a {@link #event-refresh} event with `action: batch` is triggered to allow UIs to update
   * themselves based upon the new state of the store.
   *
   * This is extremely useful when making a large number of changes to a store. It is important not to trigger
   * too many UI updates for performance reasons. Batching the changes ensures that UIs attached to this
   * store are only updated once at the end of the updates.
   */
  endBatch() {
    if (this.resumeEvents()) {
      const { values: records } = this.storage;
      this.trigger("refresh", {
        action: "batch",
        data: records,
        records
      });
    }
  }
  set storage(storage) {
    const me = this;
    if (storage == null ? void 0 : storage.isCollection) {
      me._storage = storage;
    } else {
      me._storage = new Collection(storage);
    }
    me._storage.autoFilter = me.reapplyFilterOnAdd;
    me._storage.autoSort = me.reapplySortersOnAdd;
    for (const r of me._storage) {
      r.joinStore(me);
    }
    me._storage.ion({
      change: "onDataChange",
      thisObj: me
    });
  }
  get storage() {
    if (!this._storage) {
      this.storage = {};
    }
    return this._storage;
  }
  /**
   * Returns all records (ignoring any filters) from the store.
   * @property {Core.data.Model[]}
   * @readonly
   * @category Records
   */
  get allRecords() {
    var _a2;
    const me = this;
    if (((_a2 = me._allRecords) == null ? void 0 : _a2.generation) !== me.storage.generation) {
      if (me.isTree) {
        const result = me.collectDescendants(me.rootNode, void 0, void 0, { unfiltered: true }).all;
        if (me.rootVisible) {
          result.unshift(me.rootNode);
        }
        me._allRecords = result;
      } else {
        me._allRecords = me.isGrouped ? me.collectGroupRecords() : me.storage.allValues;
      }
      me._allRecords.generation = me.storage.generation;
    }
    return me._allRecords;
  }
  // All records except special rows such group headers etc
  getAllDataRecords(searchAllRecords) {
    const me = this;
    if (me.tree) {
      return searchAllRecords ? me.allRecords : me.rootNode.allChildren;
    }
    return me.isGrouped ? me.collectGroupRecords(searchAllRecords, false) : searchAllRecords ? me.storage.allValues : me.storage.values;
  }
  /**
   * Called by owned record when the record has its {@link Core.data.Model#property-isCreating}
   * property toggled.
   * @param {Core.data.Model} record The record that is being changed.
   * @param {Boolean} isCreating The new value of the {@link Core.data.Model#property-isCreating} property.
   * @internal
   */
  onIsCreatingToggle(record, isCreating) {
    const me = this, newlyPersistable = record.isPersistable && !isCreating;
    me.added[newlyPersistable ? "add" : "remove"](record);
    if (newlyPersistable) {
      me.trigger("addConfirmed", { record });
      if (me.autoCommit) {
        me.doAutoCommit();
      }
    }
  }
  // Join added records to store, not called when loading
  joinRecordsToStore(records) {
    const { allCount } = this;
    for (let i = 0; i < records.length; i++) {
      const record = records[i];
      record.setData("parentIndex", allCount + i - records.length);
      record.joinStore(this);
    }
  }
  /**
   * Responds to mutations of the underlying storage Collection
   * @param {Object} event
   * @protected
   */
  onDataChange({ source: storage, action, added, removed, replaced, oldCount, items: items2, from, to }) {
    const me = this, isAddRemove = dataAddRemoveActions[action], addedCount = isAddRemove && (added == null ? void 0 : added.length), removedCount = isAddRemove && (removed == null ? void 0 : removed.length);
    let filtersWereReapplied, sortersWereReapplied;
    me._idMap = null;
    if (addedCount) {
      me.joinRecordsToStore(added);
    }
    replaced == null ? void 0 : replaced.forEach(([oldRecord, newRecord]) => {
      oldRecord.unjoinStore(me, true);
      newRecord.joinStore(me);
    });
    super.onDataChange(...arguments);
    if (!me.isTree) {
      if (addedCount) {
        for (const record of added) {
          if (me.removed.includes(record)) {
            me.removed.remove(record);
          } else if (!me.addingClean && !record.isLinked) {
            me.added.add(record);
          }
        }
        filtersWereReapplied = !me.remoteFilter && me.isFiltered && me.reapplyFilterOnAdd;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
        sortersWereReapplied = !me.remoteSort && me.isSorted && me.reapplySortersOnAdd;
        if (sortersWereReapplied) {
          me.sort(null, null, false, true);
        }
      }
      if (removedCount) {
        for (const record of removed) {
          record.cancelBatch();
          record.unjoinStore(me);
          if (me.added.includes(record)) {
            me.added.remove(record);
          } else if (!record._undoingInsertion && !record.isCreating && !record.isLinked) {
            me.removed.add(record);
          }
        }
        me.modified.remove(removed);
        filtersWereReapplied = !me.remoteFilter && me.isFiltered;
        if (filtersWereReapplied) {
          me.filter({
            silent: true
          });
        }
      }
    }
    switch (action) {
      case "clear":
        me.relationCache = {};
        me.updateDependentStores("removeall");
        me.trigger("removeAll");
        me.trigger("change", {
          action: "removeall"
        });
        break;
      case "splice":
        if (addedCount) {
          me.updateDependentStores("add", added);
          const oldIndex = added.reduce((lowest, record) => {
            const { previousIndex } = record.meta;
            if (previousIndex > -1 && previousIndex < lowest)
              lowest = previousIndex;
            return lowest;
          }, added[0].meta.previousIndex), index = storage.indexOf(added[0], !storage.autoFilter), params = {
            records: added,
            index
          };
          if (oldIndex > -1) {
            params.oldIndex = oldIndex;
          }
          me.trigger("add", params);
          me.trigger("change", Object.assign({ action: "add" }, params));
          if (filtersWereReapplied) {
            me.triggerFilterEvent({
              action: "filter",
              filters: me.filters,
              oldCount,
              records: me.storage.allValues
            });
          }
          if (sortersWereReapplied) {
            me.trigger("sort", { action: "sort", sorters: me.sorters, records: me.storage.allValues });
          }
        }
        if (removed.length) {
          me.updateDependentStores("remove", removed);
          me.trigger("remove", {
            records: removed
          });
          me.trigger("change", {
            action: "remove",
            records: removed
          });
        }
        if (replaced.length) {
          me.updateDependentStores("replace", replaced);
          me.trigger("replace", {
            records: replaced,
            all: me.records.length === replaced.length
          });
          me.trigger("change", {
            action: "replace",
            replaced,
            all: me.records.length === replaced.length
          });
        }
        break;
      case "filter":
        if (me.isGrouped || me.isSorted) {
          me.performSort(true);
        }
        break;
      case "move": {
        const start = Math.min(from, to), end = Math.min(me.storage.allValues.length - 1, Math.max(from, to));
        for (let allRecords = me.storage.allValues, i = start; i <= end; i++) {
          allRecords[i].setData("parentIndex", i);
        }
        me.trigger("move", {
          record: items2[0],
          records: items2,
          from,
          to
        });
        if (me.isFiltered) {
          me.performFilter();
        }
        me.trigger("change", {
          action,
          record: items2[0],
          records: items2,
          from,
          to
        });
        break;
      }
    }
  }
  onDataReplaced(action, data) {
    var _a2;
    const me = this, { storage } = me, all = storage.allValues, sorted = Boolean(me.sorters.length > 0);
    for (let i = 0; i < all.length; i++) {
      all[i].joinStore(me);
    }
    if (!me.remoteFilter && me.isFiltered) {
      me.filter({
        silent: true
      });
    }
    if (me.remoteSort) {
      if (me.isGrouped) {
        storage.replaceValues({
          // Need to update group records info (headers and footers)
          ...me.prepareGroupRecords(),
          silent: true
        });
      }
    } else {
      if (me.isGrouped) {
        me.group(null, null, false, !sorted, true);
      }
      if (sorted) {
        me.sort(null, null, false, true);
      }
    }
    if (!me.useRawData.disableDuplicateIdCheck) {
      const { idMap } = me;
      if (Object.keys(idMap).length < storage.values.length) {
        const collisions = [];
        storage.values.forEach((r) => idMap[r.id] ? delete idMap[r.id] : collisions.push(r));
        throw new Error(`Id collision on ${collisions.map((r) => r.id)}`);
      }
    }
    const event = { action, data, records: storage.values };
    me.updateDependentStores(action, event.records);
    (_a2 = me.afterLoadData) == null ? void 0 : _a2.call(me);
    if (!me.isRemoteDataLoading) {
      me.trigger("refresh", event);
    }
    me.trigger("change", event);
  }
  /**
   * This is called from Model after mutating any fields so that Stores can take any actions necessary at that point,
   * and distribute mutation event information through events.
   * @param {Core.data.Model} record The record which has just changed
   * @param {Object} toSet A map of the field names and values that were passed to be set
   * @param {Object} wasSet A map of the fields that were set. Each property is a field name, and
   * the property value is an object containing two properties: `oldValue` and `value` eg:
   * ```javascript
   *     {
   *         name {
   *             oldValue : 'Rigel',
   *             value : 'Nigel'
   *         }
   *     }
   *
   * @param {Boolean} silent Do not trigger events
   * @param {Boolean} fromRelationUpdate Update caused by a change in related model
   * @private
   */
  onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
    const me = this, event = {
      record,
      records: [record],
      changes: wasSet,
      // Cannot use isBatching, since change is triggered when batching has reached 0
      // (but before it is set to null)
      batch: record.batching != null,
      fromRelationUpdate
    }, committable = record.ignoreBag || record.isLinked ? false : me.updateModifiedBagForRecord(record);
    me.storage.onItemMutation(record, wasSet);
    if ("id" in wasSet) {
      const { oldValue, value } = toSet.id;
      me.updateDependentRecordIds(oldValue, value);
      me.onRecordIdChange({ record, oldValue, value });
    }
    if (!silent) {
      if ("id" in wasSet) {
        const { oldValue, value } = toSet.id;
        me.trigger("idChange", {
          store: me,
          record,
          oldValue,
          value
        });
      }
      me.onUpdateRecord(record, wasSet);
      me.trigger("update", event);
      me.trigger("change", Object.assign({ action: "update" }, event));
    }
    if (me.autoCommit && committable) {
      me.doAutoCommit();
    }
  }
  updateModifiedBagForRecord(record) {
    const me = this;
    let addedToBag = false;
    if (record.isModified) {
      if (!me.modified.includes(record) && !me.added.includes(record) && record.isPartOfStore(me) && !record.isRoot) {
        if (record.isPhantom) {
          me.added.add(record);
        } else {
          me.modified.add(record);
        }
        addedToBag = true;
      }
    } else {
      me.modified.remove(record);
    }
    return addedToBag;
  }
  get idMap() {
    const me = this, needsRebuild = !me._idMap, idMap = me._idMap || (me._idMap = {});
    if (needsRebuild) {
      const processedRecords = me.storage.values;
      for (let record, index = 0, visibleIndex = 0; index < processedRecords.length; index++) {
        record = processedRecords[index];
        idMap[record.id] = { index, visibleIndex, record };
        if (!record.isSpecialRow) {
          visibleIndex++;
        }
      }
      if (me.isFiltered) {
        for (let index = 0, l = me.storage._values.length; index < l; index++) {
          const record = me.storage._values[index];
          if (record.id in idMap) {
            idMap[record.id].unfilteredIndex = index;
          } else {
            idMap[record.id] = { index: -1, unfilteredIndex: index, record };
          }
        }
      }
    }
    return idMap;
  }
  changeModelClass(ClassDef) {
    const { fields } = this;
    this.originalModelClass = ClassDef;
    let ClassDefEx = ClassDef;
    if (fields == null ? void 0 : fields.length) {
      class ModelClass extends ClassDef {
        static get fields() {
          return fields;
        }
      }
      ClassDefEx = ModelClass;
    } else if (!this.preventSubClassingModel) {
      class ModelClass extends ClassDef {
      }
      ClassDefEx = ModelClass;
    }
    ClassDefEx.initClass();
    return ClassDefEx;
  }
  //endregion
  //region Store id & map
  set storeId(storeId) {
    this.id = storeId;
  }
  get storeId() {
    return this.id;
  }
  changeId(id, oldId) {
    return super.changeId(id !== true && id, oldId);
  }
  updateId(id, oldId) {
    const duplicate = _Store.getById(id);
    duplicate && _Store.unregisterInstance(duplicate);
    super.updateId(id, oldId);
  }
  generateAutoId() {
    return _Store.generateId(`store-`);
  }
  get tree() {
    return this._tree;
  }
  set tree(tree) {
    this._tree = tree;
    if (tree && !this.rootNode) {
      this.rootNode = this.buildRootNode();
      this.rootNode.isAutoRoot = true;
    }
  }
  // a hook to build a customized root node
  buildRootNode() {
    return {};
  }
  /**
   * Get a store from the store map by id.
   * @param {String|Number|Object[]} id The id of the store to retrieve, or an array of objects
   * from which to create the contents of a new Store.
   * @returns {Core.data.Store} The store with the specified id
   */
  static getStore(id, storeClass) {
    if (id instanceof _Store) {
      return id;
    }
    if (this.getById(id)) {
      return this.getById(id);
    }
    if (Array.isArray(id)) {
      let storeModel;
      const storeData = id.map((item) => {
        if (item instanceof Model) {
          storeModel = item.constructor;
        } else if (typeof item === "string") {
          item = {
            text: item
          };
        } else {
        }
        return item;
      });
      if (!storeModel) {
        class ModelClass extends Model {
        }
        storeModel = ModelClass;
      }
      id = {
        autoCreated: true,
        data: storeData,
        modelClass: storeModel,
        allowNoId: true
        // String items have no id and are not guaranteed to be unique
      };
      if (!storeClass) {
        storeClass = _Store;
      }
    }
    if (storeClass) {
      return new storeClass(id);
    }
  }
  /**
   * Get all registered stores
   * @property {Core.data.Store[]}
   */
  static get stores() {
    return _Store.registeredInstances;
  }
  //endregion
  //region Data
  /**
   * The invisible root node of this tree.
   * @property {Core.data.Model}
   * @readonly
   * @category Tree
   */
  get rootNode() {
    return this.masterStore ? this.masterStore.rootNode : this._rootNode;
  }
  set rootNode(rootNode) {
    var _a2;
    const me = this, oldRoot = me._rootNode;
    if (rootNode === oldRoot) {
      return;
    }
    if (oldRoot) {
      me.clear(true);
      me.removed.clear();
    }
    if (rootNode instanceof Model) {
      rootNode.instanceMeta(me).collapsed = false;
      me._rootNode = rootNode;
    } else {
      me._rootNode = rootNode = new me.modelClass(Object.assign({
        expanded: true,
        [me.modelClass.idField]: `${me.id}-rootNode`
      }, rootNode), me, null, true);
    }
    me._tree = true;
    rootNode.isRoot = true;
    rootNode.joinStore(me);
    if (((_a2 = rootNode.children) == null ? void 0 : _a2.length) || me.rootVisible) {
      rootNode.isLoading = true;
      me.onNodeAddChild(rootNode, rootNode.children || [], 0);
      rootNode.isLoading = false;
    }
    me.trigger("rootChange", { oldRoot, rootNode });
  }
  /**
   * Sets data in the store.
   *
   * Expects an array of JavaScript objects, with properties matching store's fields (defined on its
   * {@link #config-modelClass model} or in the {@link #config-fields} config).
   *
   * Called on initialization if data is in config otherwise call it yourself after ajax call etc. Can also be used to
   * get the raw original data.
   *
   * ```javascript
   * store.data = [
   *     { id : 1, name : 'Linda', city : 'NY' },
   *     { id : 2, name : 'Olivia', city : 'Paris' },
   *     ...
   * ];
   * ```
   *
   * @property {Object[]}
   * @fires refresh
   * @fires change
   * @category Records
   */
  set data(data) {
    this.setStoreData(data);
  }
  // For overridability in engine
  setStoreData(data) {
    const me = this, { idField, childrenField } = me.modelClass;
    if (me.transformFlatData && (data == null ? void 0 : data.length) > 0 && !Object.isExtensible(data[0])) {
      me.useRawData = me.useRawData || {
        disableDuplicateIdCheck: false,
        disableDefaultValue: false,
        disableTypeConversion: false
      };
      data = ObjectHelper.clone(data);
    }
    me.getConfig("plugins");
    me.processConfiguredListeners();
    if (data && !Array.isArray(data)) {
      data = ObjectHelper.transformNamedObjectToArray(data, idField);
    }
    me.tree = !me.isChained && (me.tree || Boolean(me.autoTree && (data == null ? void 0 : data.some((r) => r[childrenField]))));
    if (data && (me.remoteSort || me.remoteFilter)) {
      for (let i = 0; i < data.length; i++) {
        data[i]._remoteSortIndex = i;
      }
    }
    if (!me.syncDataOnLoad || !me._data) {
      me._data = data;
      if (me.tree) {
        if (me.transformFlatData) {
          data = me.treeifyFlatData(data);
        }
        const root = me.rootNode;
        root.isLoading = true;
        me.clear(true);
        root.appendChild(data);
        me.updateDependentStores("dataset", [root]);
        root.isLoading = false;
        if (data.length === 0) {
          const event = { action: "dataset", data: [], records: [] };
          me.trigger("refresh", event);
          me.trigger("change", event);
        } else if (me.isFiltered) {
          me.filter();
        }
      } else {
        me.loadData(data);
      }
      me.added.clear();
      me.removed.clear();
      me.modified.clear();
    } else {
      me.syncDataset(data);
    }
  }
  loadData(data, action = "dataset") {
    var _a2, _b;
    const me = this, { storage, allowNoId } = me, idField = me.modelClass.fieldMap.id.dataSource, creatingRecord = me.find((rec) => rec.isCreating);
    if (creatingRecord) {
      storage.values.splice(me.records.indexOf(creatingRecord), 1);
    }
    let warnGenerated = me.verifyNoGeneratedIds;
    me.removeHeadersAndFooters(me.storage.values);
    me._idMap = null;
    me.oldIdMap = {};
    if (data) {
      const isRaw = !(data[0] instanceof Model);
      if (isRaw) {
        me.modelClass.exposeProperties(data[0]);
        const count = data.length, records = new Array(count);
        for (let i = 0; i < count; i++) {
          const recordData = data[i];
          if (!allowNoId && recordData[idField] == null) {
            throw new Error(`Id required but not found on row ${i}`);
          }
          if (warnGenerated && ((_b = (_a2 = recordData[idField]) == null ? void 0 : _a2.startsWith) == null ? void 0 : _b.call(_a2, "_generated"))) {
            console.warn(`Generated id found in data: ${recordData[idField]}. Generated ids are temporary and should be replaced with real ids by the backend`);
            warnGenerated = false;
          }
          records[i] = me.processRecord(me.createRecord(recordData, true), true);
          records[i].setData("parentIndex", i);
        }
        me.clear(true);
        storage.replaceValues({
          values: records,
          isNewDataset: true,
          silent: true
        });
      } else {
        me.clear(true);
        storage.replaceValues({
          values: data.slice(),
          isNewDataset: true,
          silent: true
        });
      }
      if (creatingRecord && !storage.values.includes(creatingRecord)) {
        storage.values.push(creatingRecord);
      }
      me._data = data;
      me.onDataReplaced(action, data);
    } else {
      me.clear(true);
      me._data = null;
    }
    me.isSyncingDataOnLoad = false;
  }
  get data() {
    return this._data;
  }
  /**
   * Creates an array of records from this store from the `start` to the `end' - 1
   * @param {Number} [start] The index of the first record to return
   * @param {Number} [end] The index *after* the last record to return `(start + length)`
   * @returns {Core.data.Model[]} The requested records.
   * @category Records
   */
  getRange(start, end, all = true) {
    return (all ? this.storage.allValues : this.storage.values).slice(start, end);
  }
  /**
   * Creates a model instance, used internally when data is set/added. Override this in a subclass to do your own custom
   * conversion from data to record.
   * @param {Object} data Json data
   * @param {Boolean} [skipExpose=false] Supply true when batch setting to not expose properties multiple times
   * @category Records
   */
  createRecord(data, skipExpose = false, rawData = false) {
    return new this.modelClass(data, this, null, skipExpose, false, rawData);
  }
  processRecord(record, isDataset = false) {
    return record;
  }
  refreshData() {
    this.filter();
    this.sort();
  }
  onRecordIdChange({ record, oldValue, value }) {
    const me = this, idMap = me._idMap, { idRegister, oldIdMap } = me;
    me.storage._indicesInvalid = true;
    oldIdMap[oldValue] = record;
    if (idMap && !idMap[value]) {
      const entry = idMap[oldValue];
      delete idMap[oldValue];
      idMap[value] = entry;
    }
    me.added.changeId(oldValue, value);
    me.removed.changeId(oldValue, value);
    me.modified.changeId(oldValue, value);
    delete idRegister[oldValue];
    idRegister[value] = record;
    record.index = me.storage.indexOf(record);
  }
  onUpdateRecord(record, changes) {
    const me = this, { internalId } = changes, { internalIdRegister } = me;
    if (internalId) {
      this.storage._indicesInvalid = true;
      delete internalIdRegister[internalId.oldValue];
      internalIdRegister[internalId.value] = record;
    }
    if (me.reapplyFilterOnUpdate && me.isFiltered) {
      me.filter();
    }
  }
  get useRawData() {
    return this._useRawData;
  }
  set useRawData(options) {
    if (options === true) {
      this._useRawData = {
        enabled: true,
        disableDuplicateIdCheck: true,
        disableTypeConversion: true,
        disableDefaultValue: false
      };
    } else {
      this._useRawData = options ? Object.assign(options, { enabled: true }) : { enabled: false };
    }
  }
  //endregion
  //region Count
  /**
   * Number of records in the store
   * @param {Boolean} [countProcessed] Count processed (true) or real records (false)
   * @returns {Number} Record count
   * @category Records
   */
  getCount(countProcessed = true) {
    return countProcessed ? this.count : this.originalCount;
  }
  /**
   * Record count, for data records. Not including records added for group headers etc.
   * @property {Number}
   * @readonly
   * @category Records
   */
  get originalCount() {
    var _a2;
    return this.storage.totalCount - (((_a2 = this.groupRecords) == null ? void 0 : _a2.count) || 0);
  }
  /**
   * Record count, including records added for group headers etc.
   * @property {Number}
   * @readonly
   * @category Records
   */
  get count() {
    return this.storage.count;
  }
  /**
   * Returns the complete dataset size regardless of tree node collapsing or filtering
   * @property {Number}
   * @readonly
   * @category Records
   */
  get allCount() {
    return this.isTree ? this.rootNode.descendantCount : this.storage.totalCount;
  }
  //endregion
  //region Get record(s)
  /**
   * Returns all "visible" records.
   * **Note:** The returned value **may not** be mutated!
   * @property {Core.data.Model[]}
   * @readonly
   * @immutable
   * @category Records
   */
  get records() {
    return this.storage.values;
  }
  /**
   * Get the first record in the store.
   * @property {Core.data.Model}
   * @readonly
   * @category Records
   */
  get first() {
    return this.storage.values[0];
  }
  /**
   * Get the last record in the store.
   * @property {Core.data.Model}
   * @readonly
   * @category Records
   */
  get last() {
    return this.storage.values[this.storage.values.length - 1];
  }
  /**
   * Get the record at the specified index
   * @param {Number} index Index for the record
   * @returns {Core.data.Model} Record at the specified index
   * @category Records
   */
  getAt(index, all = false) {
    return this.storage.getAt(index, all);
  }
  // These are called by Model#join and Model#unjoin
  // register a record as a findable member keyed by id and internalId
  register(record) {
    const me = this;
    if (!me.useRawData.disableDuplicateIdCheck) {
      const existingRec = me.isTree && me.idRegister[record.id];
      if (existingRec && existingRec !== record) {
        throw new Error(`Id collision on ${record.id}`);
      }
    }
    me.idRegister[record.id] = record;
    me.internalIdRegister[record.internalId] = record;
  }
  unregister(record) {
    delete this.idRegister[record.id];
    delete this.internalIdRegister[record.internalId];
  }
  get registeredRecords() {
    return Object.values(this.idRegister);
  }
  /**
   * Get a record by id. Find the record even if filtered out, part of collapsed group or collapsed node
   * @param {Core.data.Model|String|Number} id Id of record to return.
   * @returns {Core.data.Model} A record with the specified id
   * @category Records
   */
  getById(id) {
    if (id == null ? void 0 : id.isModel) {
      const record = id;
      if (record.hasLinks && !this.storage.allValues.includes(record)) {
        return record.$links.find((r) => this.storage.allValues.includes(r));
      }
      return record;
    }
    return this.idRegister[id];
  }
  /**
   * Checks if a record is available, in the sense that it is not filtered out,
   * hidden in a collapsed group or in a collapsed node.
   * @param {Core.data.Model|String|Number} recordOrId Record to check
   * @returns {Boolean}
   * @category Records
   */
  isAvailable(recordOrId) {
    const record = this.getById(recordOrId);
    return record && this.storage.includes(record) || false;
  }
  /**
   * Get a record by internalId.
   * @param {Number} internalId The internalId of the record to return
   * @returns {Core.data.Model} A record with the specified internalId
   * @category Records
   */
  getByInternalId(internalId) {
    return this.internalIdRegister[internalId];
  }
  /**
   * Checks if the specified record is contained in the store
   * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record
   * @returns {Boolean}
   * @category Records
   */
  includes(recordOrId) {
    if (this.isTree) {
      return this.idRegister[Model.asId(recordOrId)] != null;
    }
    return this.indexOf(recordOrId) > -1;
  }
  //endregion
  //region Get index
  /**
   * Returns the index of the specified record/id, or `-1` if not found.
   * @param {Core.data.Model|String|Number} recordOrId Record, or `id` of record to return the index of.
   * @param {Boolean} [visibleRecords] Pass `true` to find the visible index.
   * as opposed to the dataset index. This omits group header records.
   * @param {Boolean} [allExceptFilteredOutRecords] For trees, when true this searches all except filtered out records
   * in the flattened tree, similar to a flat store.
   * @returns {Number} Index for the record/id, or `-1` if not found.
   * @category Records
   */
  indexOf(recordOrId, visibleRecords = false, allExceptFilteredOutRecords = false) {
    if ((recordOrId == null ? void 0 : recordOrId.isModel) && !recordOrId.stores.includes(this.$store || this)) {
      const linkedRecord = recordOrId.$links.find((r) => this.storage.allValues.includes(r));
      if (linkedRecord) {
        return this.indexOf(linkedRecord, visibleRecords);
      }
      return -1;
    }
    if (this.isTree) {
      return (allExceptFilteredOutRecords ? this.rootNode.allChildren : this.storage.values).indexOf(this.getById(recordOrId));
    }
    const id = Model.asId(recordOrId);
    if (id == null) {
      return -1;
    }
    const found = this.idMap[id];
    return found ? found[visibleRecords ? "visibleIndex" : "index"] : -1;
  }
  allIndexOf(recordOrId) {
    if (this.isTree) {
      return this.allRecords.indexOf(this.getById(recordOrId));
    } else {
      return this.storage.indexOf(recordOrId, true);
    }
  }
  //endregion
  //region Get values
  /**
   * Returns an array of distinct values for the specified field.
   *
   * ```javascript
   * store.getDistinctValues('age'); // Returns an array of the unique age values
   * ```
   *
   * @param {String} field Field to extract values for
   * @param {Boolean} [includeFilteredOutRecords] True to ignore any applied filters
   * @returns {Array} Array of values
   * @category Values
   */
  getDistinctValues(field, includeFilteredOutRecords = false) {
    const me = this, values = [], keys = {};
    let value;
    me.forEach((r) => {
      if (!r.isSpecialRow && !r.isRoot) {
        value = r.getValue(field);
        const primitiveValue = value instanceof Date ? value.getTime() : value;
        if (!keys[primitiveValue]) {
          values.push(value);
          keys[primitiveValue] = 1;
        }
      }
    }, me, { includeCollapsedGroupRecords: true, includeFilteredOutRecords });
    return values;
  }
  /**
   * Counts how many times the specified value appears in the store
   * @param {String} field Field to look in
   * @param {*} value Value to look for
   * @returns {Number} Found count
   * @category Values
   */
  getValueCount(field, value) {
    let count = 0;
    this.forEach((r) => {
      if (ObjectHelper.isEqual(r.getValue(field), value))
        count++;
    });
    return count;
  }
  //endregion
  //region JSON & console
  /**
   * Retrieve or set the data of all records as a JSON string
   *
   * ```javascript
   * const store = new Store({
   *     data : [
   *         { id : 1, name : 'Superman' },
   *         { id : 2, name : 'Batman' }
   *     ]
   * });
   *
   * const jsonString = store.json;
   *
   * //jsonString:
   * '[{"id":1,"name":"Superman"},{"id":2,"name":"Batman"}]
   * ```
   *
   * @property {String}
   */
  set json(json) {
    if (typeof json === "string") {
      json = StringHelper.safeJsonParse(json);
    }
    this.data = json;
  }
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  /**
   * Pretty printed version of {@link #property-json}
   * @readonly
   * @property {String}
   */
  get formattedJSON() {
    return StringHelper.safeJsonStringify(this, null, 4);
  }
  /**
   * Retrieve the data of all (unfiltered) records as an array of JSON objects.
   *
   * ```javascript
   * const store = new Store({
   *     data : [
   *         { id : 1, name : 'Superman' },
   *         { id : 2, name : 'Batman' }
   *     ]
   * });
   *
   * const jsonArray = store.toJSON();
   *
   * //jsonArray:
   * [{id:1,name:"Superman"},{id:2,name:"Batman"}]
   * ```
   *
   * @returns {Object[]}
   */
  toJSON() {
    return (this.isTree ? this.rootNode.unfilteredChildren || this.rootNode.children || [] : this.allRecords).map((record) => record.toJSON());
  }
  //endregion
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs(configs);
    delete configs.project;
  }
  // Extract current data for all accessible records
  getInlineData(options) {
    var _a2;
    const data = [];
    if (this.tree) {
      (_a2 = this.rootNode.children) == null ? void 0 : _a2.forEach((r) => data.push(r.getCurrentConfig(options)));
    } else {
      this.forEach((r) => data.push(r.getCurrentConfig(options)));
    }
    return data;
  }
  // Extract current configs and data
  getCurrentConfig(options) {
    var _a2;
    const result = super.getCurrentConfig(options), { state } = this;
    if (result) {
      if (result.data) {
        result.data = this.getInlineData(options);
      }
      delete result.project;
      delete result.stm;
      delete result.asyncEvents;
      if (((_a2 = result.modelClass) == null ? void 0 : _a2.$meta.hierarchy[result.modelClass.$meta.hierarchy.length - 2]) === this.constructor.defaultConfig.modelClass) {
        delete result.modelClass;
      }
      if (!this.tree) {
        delete result.tree;
      }
      if (state) {
        Object.assign(result, state);
      }
    }
    return result;
  }
  //endregion
  //region Iteration & traversing
  /**
   * Iterates over all normal records in store. Omits group header and footer records if this store is grouped.
   * @param {Function} fn A function that is called for each record. Returning `false` from that function cancels
   * iteration. It is called with the following arguments:
   * @param {Core.data.Model} fn.record Current record
   * @param {Number} fn.index Current index
   * @param {Object} [thisObj] `this` reference for the function
   * @param {Object|Boolean} [options] A boolean for `includeFilteredOutRecords`, or detailed options for
   * exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] `true` to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] `true` to also include records from collapsed groups of
   * grouped store
   * @category Iteration
   */
  forEach(fn2, thisObj = this, options) {
    const me = this, callback = (r, i) => {
      if (!r.isRoot && !r.isSpecialRow) {
        return fn2.call(thisObj, r, i);
      }
    };
    options = fixTraverseOptions2(me, options);
    if (me.isTree) {
      if (me.isChained) {
        options = {
          ...options,
          sorterFn: me.sorterFn
        };
      }
      me.rootNode.traverseWhile(callback, false, options);
    } else {
      const records = options.includeFilteredOutRecords ? me.storage.allValues : me.storage.values;
      if (me.isGrouped && options.includeCollapsedGroupRecords) {
        for (let i = 0; i < records.length; i++) {
          const record = records[i], groupChildren = options.includeFilteredOutRecords ? record.unfilteredGroupChildren : record.groupChildren;
          if (groupChildren && record.meta.collapsed === true) {
            for (let j = 0; j < groupChildren.length; j++) {
              const rec = groupChildren[j];
              if (callback(rec, j) === false) {
                return;
              }
            }
          } else if (callback(record, i) === false) {
            return;
          }
        }
      } else {
        for (let i = 0; i < records.length; i++) {
          if (callback(records[i], i) === false) {
            return;
          }
        }
      }
    }
  }
  /**
   * Equivalent to Array.map(). Creates a new array with the results of calling a provided function on every record
   * @param {Function} fn
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {Array}
   * @category Iteration
   */
  map(fn2, thisObj = this) {
    return this.storage.values.map(fn2, thisObj);
  }
  /**
   * Equivalent to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flatMap Array.flatMap()}.
   * Creates a new array by spreading the results of calling a provided function on every record
   * @param {Function} fn A function returning an array of items to be spread into the new array, or a single item to include in it
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {Array} The new array
   * @category Iteration
   */
  flatMap(fn2, thisObj = this) {
    return this.storage.values.flatMap(fn2, thisObj);
  }
  /**
   * Equivalent to Array.every(). Returns `true` if every call of the provided function
   * on each record yields a truthy value.
   * @param {Function} fn
   * @param {Function} fn.record The record to test.
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store.
   * @param {Boolean} [ignoreFilters] Pass `true` to iterate all records including filtered out ones.
   * @returns {Array}
   * @category Iteration
   */
  every(fn2, thisObj = this, ignoreFilters) {
    return this.storage[ignoreFilters ? "allValues" : "values"].every(fn2, thisObj);
  }
  /**
   * Equivalent to Array.reduce(). Applies a function against an accumulator and each record (from left to right) to
   * reduce it to a single value.
   * @param {Function} fn
   * @param {*} initialValue
   * @param {Object} [thisObj] The `this` reference to call the function with. Defaults to this Store
   * @returns {*}
   * @category Iteration
   */
  reduce(fn2, initialValue = [], thisObj = this) {
    if (thisObj !== this) {
      fn2 = fn2.bind(thisObj);
    }
    return this.storage.values.reduce(fn2, initialValue, thisObj);
  }
  /**
   * Iterator that allows you to do for (let record of store)
   * @category Iteration
   */
  [Symbol.iterator]() {
    return this.storage.values[Symbol.iterator]();
  }
  /**
   * Traverse all tree nodes (only applicable for Tree Store)
   * @param {Function} fn The function to call on visiting each node.
   * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.
   * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.
   * @param {Object|Boolean} [options] A boolean for includeFilteredOutRecords, or detailed options for exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] True to also include records from collapsed groups of grouped store
   * @param {Boolean} [options.useOrderedTree] True to traverse unsorted/unfiltered tree
   * @category Traverse
   */
  traverse(fn2, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions2(me, options);
    if (me.isTree) {
      if (typeof topNode === "boolean") {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn2;
        fn2 = (node) => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverse(fn2, skipTopNode, options);
    } else {
      me.forEach((rec) => rec.traverse(fn2, false, options), me, options);
    }
  }
  /**
   * Traverse all tree nodes while the passed `fn` returns true
   * @param {Function} fn The function to call on visiting each node. Returning `false` from it stops the traverse.
   * @param {Core.data.Model} [topNode=this.rootNode] The top node to start the traverse at.
   * @param {Boolean} [skipTopNode] Pass true to not call `fn` on the top node, but proceed directly to its children.
   * @param {Object} [options] An options object to exclude/include records
   * @param {Boolean} [options.includeFilteredOutRecords] True to also include filtered out records
   * @param {Boolean} [options.includeCollapsedGroupRecords] True to also include records from collapsed groups of grouped store
   * @category Traverse
   */
  traverseWhile(fn2, topNode = this.rootNode, skipTopNode = topNode === this.rootNode, options) {
    const me = this;
    options = fixTraverseOptions2(me, options);
    if (me.isTree) {
      if (typeof topNode === "boolean") {
        skipTopNode = topNode;
        topNode = me.rootNode;
      }
      if (me.isChained) {
        const passedFn = fn2;
        fn2 = (node) => {
          if (me.chainedFilterFn(node)) {
            passedFn(node);
          }
        };
      }
      topNode.traverseWhile(fn2, skipTopNode, options);
    } else {
      for (const record of me.storage) {
        if (record.traverse(fn2, false, options) === false) {
          break;
        }
      }
    }
  }
  /**
   * Finds the next record.
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap=false] Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model} Next record or null if current is the last one
   * @category Traverse
   */
  getNext(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this, records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    const record = records[idx + 1];
    if (skipSpecialRows && record && record.isSpecialRow) {
      return me.getNext(records[idx + 1], wrap, true);
    }
    return record;
  }
  /**
   * Finds the previous record.
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap=false] Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model} Previous record or null if current is the last one
   * @category Traverse
   */
  getPrev(recordOrId, wrap = false, skipSpecialRows = false) {
    const me = this, records = me.storage.values;
    let idx = me.indexOf(recordOrId);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    const record = records[idx - 1];
    if (skipSpecialRows && record && record.isSpecialRow && idx > 0) {
      return me.getPrev(records[idx - 1], wrap, true);
    }
    return record;
  }
  /**
   * Gets the next or the previous record. Optionally wraps from first -> last and vice versa
   * @param {String|Core.data.Model} recordOrId Record or records id
   * @param {Boolean} next Next (true) or previous (false)
   * @param {Boolean} wrap Wrap at start/end or stop there
   * @param {Boolean} [skipSpecialRows=false] True to not return specialRows like group headers
   * @returns {Core.data.Model}
   * @category Traverse
   * @internal
   */
  getAdjacent(recordOrId, next = true, wrap = false, skipSpecialRows = false) {
    return next ? this.getNext(recordOrId, wrap, skipSpecialRows) : this.getPrev(recordOrId, wrap, skipSpecialRows);
  }
  /**
   * Finds the next record among leaves (in a tree structure)
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model} Next record or null if current is the last one
   * @category Traverse
   * @internal
   */
  getNextLeaf(recordOrId, wrap = false) {
    const me = this, records = me.leaves, record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx >= records.length - 1) {
      if (wrap) {
        idx = -1;
      } else {
        return null;
      }
    }
    return records[idx + 1];
  }
  /**
   * Finds the previous record among leaves (in a tree structure)
   * @param {Core.data.Model|String|Number} recordOrId Current record or its id
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model} Previous record or null if current is the last one
   * @category Traverse
   * @internal
   */
  getPrevLeaf(recordOrId, wrap = false) {
    const me = this, records = me.leaves, record = me.getById(recordOrId);
    let idx = records.indexOf(record);
    if (idx === 0) {
      if (wrap) {
        idx = records.length;
      } else {
        return null;
      }
    }
    return records[idx - 1];
  }
  /**
   * Gets the next or the previous record among leaves (in a tree structure). Optionally wraps from first -> last and
   * vice versa
   * @param {String|Core.data.Model} recordOrId Record or record id
   * @param {Boolean} [next] Next (true) or previous (false)
   * @param {Boolean} [wrap] Wrap at start/end or stop there
   * @returns {Core.data.Model}
   * @category Traverse
   * @internal
   */
  getAdjacentLeaf(recordOrId, next = true, wrap = false) {
    return next ? this.getNextLeaf(recordOrId, wrap) : this.getPrevLeaf(recordOrId, wrap);
  }
  //endregion
};
Store.initClass();
Store._$name = "Store";

// ../Core/lib/Core/data/AjaxStore.js
var processParamEntry = (paramArray, entry) => {
  if (Array.isArray(entry[1])) {
    entry[1].forEach((value) => paramArray.push(encodeURIComponent(entry[0]) + "=" + encodeURIComponent(value)));
  } else {
    paramArray.push(encodeURIComponent(entry[0]) + "=" + encodeURIComponent(entry[1]));
  }
  return paramArray;
};
var immediatePromise2 = Promise.resolve();
var prependZeros = (num) => {
  return String(num).padStart(2, "0");
};
var dateToString = (date) => {
  return `${date.getFullYear()}-${prependZeros(date.getMonth() + 1)}-${prependZeros(date.getDate())}T${prependZeros(date.getHours())}:${prependZeros(date.getMinutes())}:${prependZeros(date.getSeconds())}.${date.getMilliseconds()}`;
};
var AjaxStore = class extends Store {
  // region Events
  /**
   * Fired when a remote request fails, either at the network level, or the server returns a failure, or an invalid
   * response.
   *
   * Note that when a {@link #function-commit} fails, more than one exception event will be triggered. The individual
   * operation, `create`, `update` or `delete` will trigger their own `exception` event, but the encapsulating commit
   * operation will also trigger an `exception` event when all the operations have finished, so if exceptions are
   * going to be handled gracefully, the event's `action` property must be examined, and the constituent operations of
   * the event must be examined.
   * @event exception
   * @param {Core.data.Store} source This Store
   * @param {Boolean} exception `true`
   * @param {'create'|'read'|'update'|'delete'|'commit'} action Action that failed, `'create'`, `'read'`,
   * `'update'` or `'delete'`. May also be fired with '`commit'` to indicate the failure of an aggregated `create`,
   * `update` and `delete` operation. In this case, the event will contain a property for each operation of the commit
   * named `'create'`, `'update'` and `'delete'`, each containing the individual `exception` events.
   * @param {'network'|'failure'} exceptionType The type of failure, `'network'` or `'server'`
   * @param {Response} response the `Response` object
   * @param {Object} json The decoded response object *if the exceptionType is `'server'`*
   */
  /**
   * Fired after committing added records
   * @event commitAdded
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired after committing modified records
   * @event commitModified
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired on successful load
   * @event load
   * @param {Core.data.Store} source This Store
   * @param {Object[]} data Data loaded
   * @param {Response} response the `Response` object
   * @param {Object} json The decoded response object.
   */
  /**
   * Fired on successful load of remote child nodes for a tree node.
   * @event loadChildren
   * @param {Core.data.Store} source This Store
   * @param {Object[]} data Data loaded
   * @param {Object} json The decoded response object.
   */
  /**
   * Fired after committing removed records
   * @event commitRemoved
   * @param {Core.data.Store} source This Store
   */
  /**
   * Fired before loading starts. Allows altering parameters and is cancelable
   * @event beforeLoad
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired before loading of remote child nodes of a tree node starts. Allows altering parameters and is cancelable
   * @event beforeLoadChildren
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * When the store {@link #property-isPaged is paged}, this is fired before loading a page and is cancelable
   * @event beforeLoadPage
   * @preventable
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired when loading is beginning. This is not cancelable. Parameters in the event may still be
   * mutated at this stage.
   * @event loadStart
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired when loading of remote child nodes into a tree node is beginning. This is not cancelable. Parameters in the
   * event may still be mutated at this stage.
   * @event loadChildrenStart
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing property/name pairs which are the parameters.
   * This may be mutated to affect the parameters used in the Ajax request.
   */
  /**
   * Fired before any remote request is initiated.
   * @event beforeRequest
   * @param {Core.data.Store} source This Store
   * @param {Object} params An object containing key/value pairs that are passed on the request query string
   * @param {Object} body The body of the request to be posted to the server.
   * @param {'create'|'read'|'update'|'delete'} action Action that is making the request, `'create'`,
   * `'read'`, `'update'` or `'delete'`
   */
  /**
   * Fired after any remote request has finished whether successfully or unsuccessfully.
   * @event afterRequest
   * @param {Boolean} exception `true`. *Only present if the request triggered an exception.*
   * @param {'create'|'read'|'update'|'delete'} action Action that has finished, `'create'`, `'read'`,
   * `'update'` or `'delete'`
   * @param {'network'|'failure'} exceptionType The type of failure, `'network'` or `'server'`. *Only present
   * if the request triggered an exception.*
   * @param {Response} response The `Response` object
   * @param {Object} json The decoded response object if there was no `'network'` exception.
   */
  // endregion
  //region Config
  static get defaultConfig() {
    return {
      /**
       * A string keyed object containing the HTTP headers to add to each server request issued by this store.
       *
       * `AjaxStore` uses the Fetch API under the hood, read more about headers on
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#headers)
       *
       * Example usage:
       *
       * ```javascript
       * const store = new AjaxStore({
       *    headers : {
       *        Authorization : 'auth-contents-goes-here'
       *    }
       * });
       * ```
       *
       * @config {Object<String,String>}
       * @category Remote
       */
      headers: null,
      /**
       * An object containing the Fetch options to pass to each server request issued by this store. Use this to
       * control if credentials are sent and other options, read more at
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch#supplying_request_options).
       *
       * Example usage:
       *
       * ```javascript
       * const store = new AjaxStore({
       *    fetchOptions : {
       *        credentials : 'omit',
       *        redirect    : 'error'
       *    }
       * });
       * ```
       *
       * @config {Object}
       * @category Remote
       */
      fetchOptions: null,
      /**
       * Specify `true` to send payloads as form data, `false` to send as regular JSON.
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      sendAsFormData: null,
      /**
       * Specify `true` to send all model fields when committing modified records (as opposed to just the
       * modified fields)
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      writeAllFields: null,
      /**
       * The name of the HTTP parameter passed to this Store's {@link #config-readUrl} to indicate the node `id`
       * to load when loading child nodes on demand if the node being expanded was created with data containing
       * `children: true`.
       * @config {String}
       * @default
       * @category Remote
       */
      parentIdParamName: "id",
      /**
       * The optional property name in JSON responses from the server that contains a boolean
       * success/fail status.
       * ```json
       * {
       *   "responseMeta" : {
       *   {
       *     "success" : true,
       *     "count" : 100
       *   },
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ]
       * }
       * ```
       *
       * The store would be configured with:
       * ```javascript
       *  {
       *      ...
       *      successDataProperty : 'responseMeta.success',
       *      responseTotalProperty : 'responseMeta.count'
       *      ...
       *  }
       *
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseSuccessProperty: "success",
      /**
       * The property name in JSON responses from the server that contains the data for the records
       * ```json
       * {
       *   "success" : true,
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ]
       * }
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseDataProperty: "data",
      /**
       * The property name in JSON responses from the server that contains the dataset total size
       * **when this store {@link #property-isPaged is paged}**
       * ```json
       * {
       *   "success" : true,
       *   // The property name used here should match that of 'responseDataProperty'
       *   "data" : [
       *     ...
       *   ],
       *   // The property name used here should match that of 'responseTotalProperty'
       *   "total" : 65535
       * }
       * ```
       * @config {String}
       * @default
       * @category Remote
       */
      responseTotalProperty: "total",
      /**
       * The name of the HTTP parameter to use to pass any encoded filters when loading data from the server and a
       * filtered response is required.
       *
       * **Note:** When this is set, filters must be defined using a field name, an operator and a value
       * to compare, **not** a comparison function.
       * @config {String}
       * @category Remote
       */
      filterParamName: null,
      /**
       * Set this flag to true if you are filtering remote using restful URLs (e.g.
       * https://nominatim.openstreetmap.org/search/paris?format=json)
       *
       * **Note:** When this is set, the filter string is appended to the readUrl.
       * @config {Boolean}
       * @category Remote
       */
      restfulFilter: false,
      /**
       * The name of the HTTP parameter to use to pass any encoded sorters when loading data from the server and a
       * sorted response is required.
       *
       * **Note:** When this is set, sorters must be defined using a field name and an ascending flag,
       * **not** a sort function.
       * @config {String}
       * @category Remote
       */
      sortParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **one based** page number
       * required.
       * @config {String}
       * @category Paging
       */
      pageParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the
       * required page's starting record.
       * @config {String}
       * @category Paging
       */
      pageStartParamName: null,
      /**
       * The name of the HTTP parameter to use when requesting pages of data using the **zero based** index of the
       * required page's starting record.
       * @config {String}
       * @default
       * @category Paging
       */
      pageSizeParamName: "pageSize",
      /**
       * Set to true to use restful {@link #config-httpMethods}
       * @config {Boolean}
       * @default false
       * @category Remote
       */
      useRestfulMethods: null,
      /**
       * The HTTP methods to use for CRUD requests when {@link #config-useRestfulMethods} is enabled.
       *
       * ```javascript
       * new AjaxStore({
       *    useRestfulMethods : true,
       *    httpMethods : {
       *        create : 'POST',
       *        read   : 'POST',
       *        update : 'PATCH',
       *        delete : 'DELETE'
       *    }
       * });
       *
       * ```
       * @config {HttpMethods}
       * @default
       * @category Remote
       */
      httpMethods: {
        create: "POST",
        read: "GET",
        update: "PUT",
        delete: "DELETE"
      }
    };
  }
  // This function is called to automatically reload page whenever pageSize is set at runtime.
  updatePageSize(pageSize) {
    const me = this;
    if (!this.isConfiguring) {
      const currentPage = me.currentPage = me.currentPage ? Math.min(
        me.currentPage,
        Math.floor((me.allCount + pageSize - 1) / pageSize)
      ) : 1;
      if (pageSize) {
        me.loadPage(currentPage);
      }
    }
  }
  /**
   * Url to post newly created records to.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} createUrl
   * @category CRUD
   */
  /**
   * Url to read data from.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * If the store {@link #property-isPaged is paged}, the total dataset size must be returned in the
   * {@link #config-responseTotalProperty} property:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }],
   *         "total": 65535
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} readUrl
   * @category CRUD
   */
  /**
   * Url to post record modifications to.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true,
   *         "data": [{
   *             "id": 0, "name": "General Motors"
   *         }, {
   *             "id": 1, "name": "Apple"
   *         }]
   *     }
   *
   * Just the array of data may be returned, however that precludes the orderly handling of errors encountered at the
   * server.
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} updateUrl
   * @category CRUD
   */
  /**
   * Url for deleting records.
   *
   * The response must be in the form:
   *
   *     {
   *         "success": true
   *     }
   *
   * If the server encountered an error, the packet would look like this:
   *
   *     {
   *         "success": false,
   *         "message": "Some kind of database error"
   *     }
   *
   * And that packet would be available in the {@link #event-exception} handler in the `response` property of the
   * event.
   *
   * The `success` property may be omitted, it defaults to `true`.
   *
   * @prp {String} deleteUrl
   * @category CRUD
   */
  /**
   * True to initiate a load when the store is instantiated
   * @config {Boolean} autoLoad
   * @category Common
   */
  //endregion
  afterConstruct(config) {
    super.afterConstruct(config);
    if (this.autoLoad) {
      this.load().catch(() => {
      });
    }
  }
  /**
   * Returns a truthy value if the Store is currently loading.
   *
   * A load operation is initiated by a load call, but the network request is not sent until
   * after a delay until the next event loop because of allowing all operations which may
   * request a load to coalesce into one call.
   *
   * If the loading request is in this waiting state, the value will be `1`,
   *
   * If the network request is in flight, the value will be `2`
   * @property {Boolean|Number}
   * @readonly
   * @category CRUD
   */
  get isLoading() {
    return this._isLoading ? 2 : this.loadTriggerPromise ? 1 : false;
  }
  /**
   * Returns true if the Store is currently committing
   * @property {Boolean}
   * @readonly
   * @category CRUD
   */
  get isCommitting() {
    return Boolean(this.commitPromise);
  }
  set pageParamName(pageParamName) {
    if (this.tree) {
      throw new Error("Paging cannot be supported for tree stores");
    }
    if (this.pageStartParamName) {
      throw new Error("Configs pageStartParamName and pageParamName are mutually exclusive");
    }
    this._pageParamName = pageParamName;
  }
  get pageParamName() {
    return this._pageParamName;
  }
  set pageStartParamName(pageStartParamName) {
    if (this.tree) {
      throw new Error("Paging cannot be supported for tree stores");
    }
    if (this.pageParamName) {
      throw new Error("Configs pageParamName and pageStartParamName are mutually exclusive");
    }
    this._pageStartParamName = pageStartParamName;
  }
  get pageStartParamName() {
    return this._pageStartParamName;
  }
  /**
   * Yields true if this Store is loaded page by page. This yields `true` if either of the
   * {@link #config-pageParamName} of {@link #config-pageStartParamName} configs are set.
   * @property {Boolean}
   * @readonly
   * @category Paging
   */
  get isPaged() {
    return this.pageParamName || this.pageStartParamName;
  }
  /**
   * Yields the complete dataset size. If the store is {@link #property-isPaged is paged} this is the value
   * returned in the last loaded data block in the {@link #config-responseTotalProperty} property. Otherwise it is
   * the number of records in the store's underlying storage collection.
   * @property {Number}
   * @readonly
   * @category Paging
   */
  get allCount() {
    return "remoteTotal" in this ? this.remoteTotal : super.allCount;
  }
  /**
   * **If the store {@link #property-isPaged is paged}**, yields the highest page number in the dataset as calculated
   * from the {@link #config-responseTotalProperty}
   * returned in the last page data block loaded.
   * @property {Number}
   * @readonly
   * @category Paging
   */
  get lastPage() {
    if (this.isPaged) {
      return Math.floor((this.allCount + this.pageSize - 1) / this.pageSize);
    }
  }
  buildQueryString(url, ...paramObjects) {
    const hasParamsInUrl = url.includes("?"), queryString = Object.entries(Object.assign({}, ...paramObjects)).reduce(processParamEntry, []).join("&");
    return queryString ? (hasParamsInUrl ? "&" : "?") + queryString : "";
  }
  /**
   * Internal sort method.
   * Should not be used in application code directly.
   * @param silent
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-sortParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @internal
   */
  async performSort(silent) {
    const me = this;
    if (me.remoteSort && !me.isRemoteDataLoading) {
      me.isRemoteDataLoading = true;
      const result = await me.internalLoad({}, "", (event) => {
        me.data = event.data;
        me.afterPerformSort(silent);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performSort(silent);
    }
  }
  /**
   * Internal filter method.
   * Should not be used in application code directly.
   * @param silent
   * @returns {Promise|null} If {@link Core/data/AjaxStore#config-filterParamName} is set on store, this method returns `Promise`
   * which is resolved after data is loaded from remote server, otherwise it returns `null`
   * @async
   * @internal
   */
  async performFilter(silent) {
    var _a2;
    const me = this;
    if (me.remoteFilter) {
      (_a2 = me.loadingPromise) == null ? void 0 : _a2.abort();
      me.isRemoteDataLoading = true;
      const oldCount = me.count, { filters } = me;
      me.currentPage = 1;
      const result = await me.internalLoad({}, "", (event) => {
        me.data = event.data;
        event = silent ? null : {
          action: "filter",
          filters,
          oldCount,
          records: me.storage.values
        };
        me.afterPerformFilter(event);
        me.trigger("refresh", event);
      });
      me.isRemoteDataLoading = false;
      return result;
    } else {
      super.performFilter(silent);
    }
  }
  /**
   * A provided function which creates an array of values for the {@link #config-filterParamName} to pass
   * any filters to the server upon load.
   *
   * By default, this creates a JSON string containing the following properties:
   *
   * ```javascript
   *    [{
   *        field         : <theFieldName>
   *        operator      : May be: `'='`, `'!='`, `'>'`, `'>='`, `'<'`, `'<='`, `'*'`, `'startsWith'`, `'endsWith'`
   *        value         : The value to compare
   *        caseSensitive : true for case sensitive comparisons
   *    }]
   * ```
   * @param {Core.util.CollectionFilter[]} filters The filters to encode.
   */
  encodeFilterParams(filters) {
    const result = [];
    for (const { property, operator, value, caseSensitive } of filters) {
      result.push({
        field: property,
        operator,
        value,
        caseSensitive
      });
    }
    return JSON.stringify(result, function(key, value) {
      return key === "" ? value : this[key] instanceof Date ? dateToString(this[key]) : value;
    });
  }
  /**
   * A provided function which creates an array of values for the {#config-sortParamName} to pass
   * any sorters to the server upon load.
   *
   * By default, this creates a JSON string containing the following properties:
   *
   * ```javascript
   *    [{
   *        field     : <theFieldName>
   *        ascending : true/false
   *    }]
   * ```
   *
   * @param {Sorter[]} sorters The sorters to encode.
   */
  encodeSorterParams(sorters) {
    return JSON.stringify(sorters.filter((sorter) => !sorter.sortFn).map((sorter) => sorter));
  }
  buildReadUrl() {
    const { readUrl } = this;
    if (this.restfulFilter && this.filters.count) {
      const url = readUrl.endsWith("/") ? readUrl : readUrl + "/";
      return url + this.filters.first.value;
    }
    return readUrl;
  }
  /**
   * Internal data loading method.
   * @returns {Promise}
   * @internal
   */
  internalLoad(params, eventName, successFn, delay2 = 0) {
    params = ObjectHelper.assign({}, this.params, params);
    const me = this, url = me.buildReadUrl(), event = { action: "read" + eventName, params, url };
    if (!url) {
      throw new Error("No load url specified");
    }
    if (me.trigger("beforeLoad" + eventName, event) === false) {
      throw false;
    }
    me.loadArgs = [url, event, params, eventName, successFn];
    if (delay2 === false) {
      return new Promise((resolve, reject) => me.sendLoadRequest(resolve, reject));
    }
    return me.loadTriggerPromise || (me.loadTriggerPromise = new Promise((resolve, reject) => {
      me.setTimeout({
        delay: delay2,
        fn: "sendLoadRequest",
        args: [resolve, reject],
        cancelOutstanding: true
      });
    }));
  }
  // Send the request for the internalLoad.
  // This is called on a timeout 1ms after the internalLoad call.
  async sendLoadRequest(resolve, reject) {
    const me = this, [
      url,
      event,
      params,
      eventName,
      successFn
    ] = me.loadArgs;
    me.loadTriggerPromise = null;
    if (url) {
      me._isLoading = true;
      me.trigger(`load${eventName}Start`, event);
      me.trigger("beforeRequest", event);
      if (me.filterParamName && me.isFiltered) {
        params[me.filterParamName] = me.encodeFilterParams(me.filters.values);
      }
      if (me.remoteSort && me.isSorted) {
        params[me.sortParamName] = me.encodeSorterParams(me.groupers ? me.groupers.concat(me.sorters) : me.sorters);
      }
      if (me.isPaged) {
        if (!(me.pageParamName in params || me.pageStartParamName in params)) {
          const page = Math.min(me.currentPage || 1, me.allCount ? me.lastPage : Infinity);
          if (me.pageParamName) {
            params[me.pageParamName] = page;
          } else {
            params[me.pageStartParamName] = (page - 1) * me.pageSize;
          }
        }
        params[me.pageSizeParamName] = me.pageSize;
      }
      const options = { headers: me.headers, parseJson: true };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.read;
        if (event.body) {
          options.body = JSON.stringify(event.body);
        }
      }
      try {
        const promise = me.loadingPromise = AjaxHelper.get(event.url + me.buildQueryString(event.url, params), ObjectHelper.assign(options, me.fetchOptions)), response = await promise, data = response.parsedJson, isArray3 = Array.isArray(data), success2 = isArray3 || data && ObjectHelper.getPath(data, me.responseSuccessProperty) !== false, remoteTotal = isArray3 ? null : ObjectHelper.getPath(data, me.responseTotalProperty);
        if (me.isDestroyed) {
          return;
        }
        me.loadingPromise = null;
        me._isLoading = false;
        event.response = response;
        event.json = data;
        if (success2) {
          if (remoteTotal != null) {
            me.remoteTotal = parseInt(remoteTotal, 10);
          }
          if (me.isPaged) {
            if (me.remoteTotal >= 0) {
              const requestedPage = me.pageParamName ? params[me.pageParamName] : params[me.pageStartParamName] / me.pageSize + 1;
              me.currentPage = Math.min(requestedPage, me.lastPage);
            } else {
              throw new Error("A paged store must receive its responseTotalProperty in each data packet");
            }
          }
          event.data = isArray3 ? data : ObjectHelper.getPath(data, me.responseDataProperty);
          await successFn(event);
          !me.isDestroyed && me.trigger("load" + eventName, event);
          resolve(event);
        } else {
          Object.assign(event, {
            exception: true,
            exceptionType: "server",
            error: data == null ? void 0 : data.error
          });
          !me.isDestroyed && me.trigger("exception", event);
          reject(event);
        }
        !me.isDestroyed && me.trigger("afterRequest", event);
      } catch (responseOrError) {
        me._isLoading = false;
        event.exception = true;
        if (responseOrError instanceof Response) {
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        !me.isDestroyed && me.trigger("exception", event);
        reject(event);
        !me.isDestroyed && me.trigger("afterRequest", event);
      }
    }
  }
  /**
   * Load data from the {@link #config-readUrl}.
   * @param {Object} [params] A hash of parameters to append to querystring (will also append Store#params)
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoad} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoad} handler.
   * @fires beforeLoad
   * @fires loadStart
   * @fires beforeRequest
   * @fires load
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async load(params) {
    const me = this;
    if (me.isPaged) {
      return me.loadPage(me.currentPage || 1, params);
    } else {
      return me.internalLoad(params, "", (event) => {
        me.data = event.data;
      });
    }
  }
  /**
   * Loads children into specified parent record. Parent records id is sent as a param (param name configured with
   * {@link #config-parentIdParamName}.
   * @param {Core.data.Model} parentRecord Parent record
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoadChildren} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoadChildren} handler.
   * @fires beforeLoadChildren
   * @fires loadChildrenStart
   * @fires beforeRequest
   * @fires loadChildren
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async loadChildren(parentRecord) {
    return this.readUrl ? this.internalLoad({ [this.parentIdParamName]: parentRecord.id }, "Children", (event) => {
      event.parentRecord = parentRecord;
      if (parentRecord.children.length) {
        parentRecord.clearChildren(true);
      }
      parentRecord.data[parentRecord.constructor.childrenField] = event.data;
      parentRecord.processChildren(parentRecord.stores);
    }, false) : this.immediatePromise;
  }
  /**
   * Loads a page of data from the {@link #config-readUrl}.
   * @param {Number} page The *one based* page number to load.
   * @param {Object} params A hash of parameters to append to querystring (will also append Store#params)
   * @returns {Promise} A Promise which will be resolved if the load succeeds, and rejected if the load is
   * vetoed by a {@link #event-beforeLoadPage} handler, or if an {@link #event-exception} is detected.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * or `false` if the load was vetoed by a {@link #event-beforeLoadPage} handler.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   */
  async loadPage(page, params) {
    if (this.allCount) {
      page = Math.min(page, this.lastPage);
    }
    const me = this, pageParam = me.pageParamName ? {
      [me.pageParamName]: page
    } : {
      [me.pageStartParamName]: (page - 1) * me.pageSize
    };
    pageParam[me.pageSizeParamName] = me.pageSize;
    return me.internalLoad(ObjectHelper.assign(pageParam, params), "Page", (event) => {
      me.loadData(event.data, "pageLoad");
    });
  }
  /**
   * If this store {@link #property-isPaged is paged}, and is not already at the {@link #property-lastPage}
   * then this will load the next page of data.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
   */
  async nextPage(params) {
    const me = this;
    return me.isPaged && me.currentPage !== me.lastPage ? me.loadPage(me.currentPage + 1, params) : immediatePromise2;
  }
  /**
   * If this store {@link #property-isPaged is paged}, and is not already at the first page
   * then this will load the previous page of data.
   * @fires beforeLoadPage
   * @fires loadPageStart
   * @fires beforeRequest
   * @fires loadPage
   * @fires exception
   * @fires afterRequest
   * @category CRUD
   * @returns {Promise} A promise which is resolved when the Ajax request completes and has been processed.
   */
  async previousPage(params) {
    return this.isPaged && this.currentPage !== 1 ? this.loadPage(this.currentPage - 1, params) : immediatePromise2;
  }
  /**
   * Commits all changes (added, modified and removed) using corresponding urls ({@link #config-createUrl},
   * {@link #config-updateUrl} and {@link #config-deleteUrl})
   * @fires beforeCommit
   * @returns {Promise} A Promise which is resolved only if all pending changes (Create, Update and Delete)
   * successfully resolve. Both the resolve and reject functions are passed a `commitState` object which is stored the
   * {@link #event-afterRequest} event for each request. Each event contains the `exception`, `request` and `response`
   * properties eg:
   *
   * ```javascript
   * {
   *      // If *all* commits succeeded
   *      success: true,
   *      changes: {
   *          added: [records...],
   *          modified: [records...],
   *          removed: [records...],
   *      },
   *      added: {
   *          source: theStore,
   *
   *          // Only if the add request triggered an exception
   *          exception: true,
   *
   *          // Only if the add request triggered an exception
   *          exceptionType: 'server', // Or 'network'
   *
   *          response: Response,
   *          json: parsedResponseObject
   *      },
   *      // Same format as added
   *      modified: {},
   *      removed: {}
   * }
   * ```
   *
   * If there were no pending changes, the resolve and reject functions are passed no parameters.
   *
   * Returns `false` if a commit operation is already in progress.
   * The resolved function is passed the event object passed to any event handlers.
   * The rejected function is passed the {@link #event-exception} event if an exception occurred,
   * @category CRUD
   */
  async commit() {
    const me = this, { changes } = me, allPromises = [];
    if (me.commitPromise) {
      return false;
    }
    if (!changes) {
      if (me.modified.count) {
        me.modified.forEach((record) => record.clearChanges(true, false));
        me.modified.clear();
      }
      return immediatePromise2;
    }
    if (me.trigger("beforeCommit", { changes }) !== false) {
      [...changes.added, ...changes.modified, ...changes.removed].forEach((record) => record.meta.committing = true);
      me.trigger("commitStart", { changes });
      const commitState = {
        action: "commit",
        exception: false,
        changes
      };
      let p = me.commitRemoved(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitAdded(commitState);
      if (p) {
        allPromises.push(p);
      }
      p = me.commitModified(commitState);
      if (p) {
        allPromises.push(p);
      }
      if (!allPromises.length) {
        me.modified.forEach((r) => r.clearChanges(true, false));
        me.modified.clear();
        me.added.forEach((r) => r.clearChanges(true, false));
        me.added.clear();
        me.removed.clear();
        me.trigger("commit", { changes });
        return immediatePromise2;
      }
      p = allPromises.length === 1 ? allPromises[0] : Promise.all(allPromises);
      return me.commitPromise = new Promise((resolve, reject) => {
        p.then(() => {
          me.commitPromise = null;
          if (commitState.exception) {
            me.trigger("exception", commitState);
            reject(commitState);
          } else {
            me.trigger("commit", { changes });
            resolve(commitState);
          }
        }).catch(() => {
          me.commitPromise = null;
          reject(commitState);
        });
      });
    }
  }
  // Performs background autocommit with reject checking
  doAutoCommit() {
    if (this.suspendCount <= 0) {
      this.commit().catch((commitState) => {
        const { response } = commitState;
        if (!(response && (response.ok && response.parsedJson || [500, 404].includes(response.status)))) {
          throw commitState;
        }
      });
    }
  }
  /**
   * Commits added records by posting to {@link #config-createUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `add` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforeRequest
   * @fires commitAdded
   * @fires refresh
   * @fires exception
   * @fires afterRequest
   */
  commitAdded(commitState) {
    const me = this, added = me.added, event = { action: "create", params: me.params };
    return added.count && me.createUrl ? new Promise((resolve) => {
      const toAdd = added.values.map((r) => r.persistableData);
      commitState.create = event;
      event.body = { data: toAdd };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("data", JSON.stringify(toAdd));
        dataToSend = formData;
      }
      const options = { headers: me.headers, parseJson: true }, url = me.createUrl + me.buildQueryString(me.createUrl, me.params);
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.create;
      }
      AjaxHelper.post(url, dataToSend, ObjectHelper.assign(options, me.fetchOptions)).then((response) => {
        const data = response.parsedJson, isArray3 = Array.isArray(data), success2 = isArray3 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success2) {
          me.processReturnedData(added.values, isArray3 ? data : ObjectHelper.getPath(data, me.responseDataProperty));
          added.clear();
          me.trigger("commitAdded");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          added.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          commitState.exceptionType = event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        added.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
  }
  /**
   * Commits modified records by posting to {@link #config-updateUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `update` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforeRequest
   * @fires commitModified
   * @fires refresh
   * @fires exception
   * @fires afterRequest
   */
  commitModified(commitState) {
    const me = this, { modified } = me.changes, event = { action: "update", params: me.params }, result = modified.length && me.updateUrl ? new Promise((resolve) => {
      const modifications = modified.map((record) => {
        if (me.writeAllFields) {
          return record.persistableData;
        } else {
          return record.modificationDataToWrite;
        }
      }).filter((el) => !ObjectHelper.isEmpty(el));
      if (modifications.length === 0) {
        me.modified.clear();
        modified.forEach((r) => r.meta.committing = false);
        resolve();
        return;
      }
      commitState.update = event;
      event.body = { data: modifications };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("data", JSON.stringify(modifications));
        dataToSend = formData;
      }
      const options = { headers: me.headers, parseJson: true };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.update;
      }
      AjaxHelper.post(
        me.updateUrl + me.buildQueryString(me.updateUrl, me.params),
        dataToSend,
        ObjectHelper.assign(options, me.fetchOptions)
      ).then((response) => {
        const data = response.parsedJson, isArray3 = Array.isArray(data), success2 = isArray3 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success2) {
          me.processReturnedData(modified, isArray3 ? data : ObjectHelper.getPath(data, me.responseDataProperty), true);
          me.modified.clear();
          me.trigger("commitModified");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          modified.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        modified.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
    if (!modified.length && me.modified.count) {
      me.modified.clear();
    }
    return result;
  }
  processReturnedData(localRecords, returnedData, isUpdating = false) {
    const me = this, Model2 = me.modelClass, idDataSource = Model2.fieldMap.id.dataSource;
    returnedData.forEach((recData, i) => {
      const record = localRecords[i];
      record.clearChanges(true, false);
      record.syncId(recData[idDataSource]);
      Object.assign(localRecords[i].data, Model2.processData(recData, isUpdating, me, record));
    });
  }
  /**
   * Commits removed records by posting to {@link #config-deleteUrl}.
   * Server should return a JSON object with a 'success' property indicating whether the operation was successful.
   * @param {Object} commitState An object into which is added a `delete` property being the
   * {@link #event-afterRequest} event.
   * @returns {Promise|null} If there are added records, a Promise which will be resolved whether the commit
   * succeeds or fails. The resulting event is placed into the `delete` property of the passed `commitState`
   * parameter. If there are no added records, `null` is returned.
   * The resolved function is passed the event object passed to any event handlers.
   * @async
   * @private
   * @fires beforerequest
   * @fires commitremoved
   * @fires refresh
   * @fires exception
   * @fires afterrequest
   */
  commitRemoved(commitState) {
    const me = this, removed = me.removed, event = { action: "delete", params: me.params };
    return removed.count && me.deleteUrl ? new Promise((resolve) => {
      commitState.delete = event;
      event.body = { ids: removed.map((r) => r.id) };
      me.trigger("beforeRequest", event);
      let dataToSend = event.body;
      if (me.sendAsFormData) {
        const formData = new FormData();
        formData.append("id", JSON.stringify(dataToSend.ids));
        dataToSend = formData;
      }
      const options = { headers: me.headers, parseJson: true };
      if (me.useRestfulMethods) {
        options.method = me.httpMethods.delete;
      }
      AjaxHelper.post(
        me.deleteUrl + me.buildQueryString(me.deleteUrl, me.params),
        dataToSend,
        ObjectHelper.assign(options, me.fetchOptions)
      ).then((response) => {
        const data = response.parsedJson, isArray3 = Array.isArray(data), success2 = isArray3 || data && data.success !== false;
        commitState.response = response;
        event.json = data;
        event.response = response;
        if (success2) {
          removed.forEach((record) => record.meta.committing = false);
          removed.clear();
          me.trigger("commitRemoved");
          me.trigger("refresh", event);
          resolve(commitState);
        } else {
          removed.forEach((r) => r.meta.committing = false);
          commitState.exception = event.exception = true;
          event.exceptionType = "server";
          me.trigger("exception", event);
          resolve(commitState);
        }
        me.trigger("afterRequest", event);
      }).catch((responseOrError) => {
        removed.forEach((r) => r.meta.committing = false);
        commitState.exception = event.exception = true;
        if (responseOrError instanceof Response) {
          commitState.response = responseOrError;
          event.exceptionType = responseOrError.ok ? "server" : "network";
          event.response = responseOrError;
          event.error = responseOrError.error;
        } else {
          event.exceptionType = "server";
          event.error = responseOrError;
        }
        me.trigger("exception", event);
        resolve(commitState);
        me.trigger("afterRequest", event);
      });
    }) : null;
  }
  get remoteFilter() {
    return Boolean(this.filterParamName || this.restfulFilter);
  }
  get remoteSort() {
    return Boolean(this.sortParamName);
  }
};
__publicField(AjaxStore, "$name", "AjaxStore");
__publicField(AjaxStore, "configurable", {
  /**
   * An object containing key/value pairs that are passed on the request query string.
   * @prp {Object}
   * @category Remote
   */
  params: null,
  /**
   * When paging of data is requested by setting _either_ the {@link #config-pageParamName} _or_ the
   * {@link #config-pageStartParamName}, this is the value to send in the {@link #config-pageSizeParamName}.
   *
   * **Note:** Setting pageSize at runtime will automatically reload the page.
   * @prp {Number}
   * @default
   * @category Paging
   */
  pageSize: 50
});
AjaxStore._$name = "AjaxStore";

// ../Core/lib/Core/data/DomDataStore.js
var DomDataStore = class {
  /**
   * Get data that is connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {String} [key] The name of the property in the element data to return
   * @returns {Object} Data
   */
  static get(element, key) {
    const result = element._domData || (element._domData = {});
    return key != null ? result[key] : result;
  }
  /**
   * Remove data connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {String} key The name of the property in the element data to remove.
   */
  static remove(element, key) {
    const { _domData } = element, was = _domData == null ? void 0 : _domData[key];
    _domData == null ? true : delete _domData[key];
    return was;
  }
  /**
   * Set data connected to specified element (completely replacing any existing).
   * To update data, use DomDataStore#assign instead.
   * @param {HTMLElement} element DOM element
   * @param {Object|String} data Data object to set, or property name to set
   * @param {*} [value] If the previous parameter was a property name, this is the value to set.
   */
  static set(element, data, value) {
    if (arguments.length === 3) {
      (element._domData || (element._domData = {}))[data] = value;
    } else {
      element._domData = data;
    }
  }
  /**
   * Updates data connected to specified element.
   * @param {HTMLElement} element DOM element
   * @param {Object} data Data to assign
   */
  static assign(element, data) {
    Object.assign(element._domData || (element._domData = {}), data);
  }
};
DomDataStore._$name = "DomDataStore";

// ../Core/lib/Core/data/stm/state/StateBase.js
var throwAbstractMethodCall = () => {
  throw new Error("Abstract method call!");
};
var throwInvalidMethodCall = () => {
  throw new Error("Method cannot be called at this state!");
};
var StateBase = class extends Base {
  canUndo(stm) {
    throwAbstractMethodCall();
  }
  canRedo(stm) {
    throwAbstractMethodCall();
  }
  onUndo(stm) {
    throwAbstractMethodCall();
  }
  onRedo(stm) {
    throwAbstractMethodCall();
  }
  onStartTransaction(stm) {
    throwAbstractMethodCall();
  }
  onStopTransaction(stm) {
    throwAbstractMethodCall();
  }
  onStopTransactionDelayed(stm) {
    throwAbstractMethodCall();
  }
  onRejectTransaction(stm) {
    throwAbstractMethodCall();
  }
  onEnable(stm) {
    throwAbstractMethodCall();
  }
  onDisable(stm) {
    throwAbstractMethodCall();
  }
  onAutoRecordOn(stm) {
    throwAbstractMethodCall();
  }
  onAutoRecordOff(stm) {
    throwAbstractMethodCall();
  }
  onResetQueue(stm) {
    throwAbstractMethodCall();
  }
  onModelUpdate(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelAdd(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelInsert(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelRemove(stm) {
    throwAbstractMethodCall();
  }
  onStoreModelRemoveAll(stm) {
    throwAbstractMethodCall();
  }
  onModelInsertChild(stm) {
    throwAbstractMethodCall();
  }
  onModelRemoveChild(stm) {
    throwAbstractMethodCall();
  }
};
StateBase._$name = "StateBase";

// ../Core/lib/Core/data/stm/Props.js
var STATE_PROP = Symbol("STATE_PROP");
var STORES_PROP = Symbol("STORES_PROP");
var QUEUE_PROP = Symbol("QUEUE_PROP");
var POS_PROP = Symbol("POS_PROP");
var TRANSACTION_PROP = Symbol("TRANSACTION_PROP");
var TRANSACTION_TIMER_PROP = Symbol("TRANSACTION_TIMER_PROP");
var AUTO_RECORD_PROP = Symbol("AUTO_RECORD_PROP");
var IS_APPLYING_STASH = Symbol("IS_APPLYING_STASH");
var PROPS = Object.freeze([
  STATE_PROP,
  STORES_PROP,
  QUEUE_PROP,
  POS_PROP,
  TRANSACTION_PROP,
  TRANSACTION_TIMER_PROP,
  AUTO_RECORD_PROP,
  IS_APPLYING_STASH
]);

// ../Core/lib/Core/data/stm/state/Registry.js
var registry = /* @__PURE__ */ new Map();
var registerStmState = (name, state) => {
  registry.set(name, state);
};
var resolveStmState = (state) => {
  if (typeof state === "string") {
    state = registry.get(state);
  }
  return state;
};
var Registry_default = {
  registerStmState,
  resolveStmState
};

// ../Core/lib/Core/data/stm/Helpers.js
var resetQueue = (stm, options) => {
  const { undo, redo } = options;
  let newProps;
  if (undo && !redo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(stm.position),
      [POS_PROP]: 0
    };
  } else if (redo && !undo) {
    newProps = {
      [QUEUE_PROP]: stm[QUEUE_PROP].slice(0, stm.position)
    };
  } else {
    newProps = {
      [QUEUE_PROP]: [],
      [POS_PROP]: 0
    };
  }
  ;
  return [
    newProps,
    () => {
      stm.notifyStoresAboutQueueReset(options);
    }
  ];
};

// ../Core/lib/Core/data/stm/state/DisabledState.js
var DisabledStateClass = class extends StateBase {
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onUndo() {
    throwInvalidMethodCall();
  }
  onRedo() {
    throwInvalidMethodCall();
  }
  onEnable(stm) {
    return stm.autoRecord ? "autoreadystate" : "readystate";
  }
  onDisable() {
    throwInvalidMethodCall();
  }
  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var DisabledState = new DisabledStateClass();
var DisabledState_default = DisabledState;
Registry_default.registerStmState("disabledstate", DisabledState);

// ../Core/lib/Core/data/stm/Transaction.js
var ACTION_QUEUE_PROP = Symbol("ACTION_QUEUE_PROP");
var Transaction = class extends Base {
  get defaultConfig() {
    return {
      /**
       * Transaction title
       *
       * @config {String}
       */
      title: null
    };
  }
  construct(...args) {
    this[ACTION_QUEUE_PROP] = [];
    super.construct(...args);
  }
  /**
   * Gets transaction's actions queue
   *
   * @property {Core.data.stm.action.ActionBase[]}
   */
  get queue() {
    return this[ACTION_QUEUE_PROP].slice(0);
  }
  /**
   * Gets transaction's actions queue length
   *
   * @property {Number}
   */
  get length() {
    return this[ACTION_QUEUE_PROP].length;
  }
  /**
   * Adds an action to the transaction.
   *
   * @param {Core.data.stm.action.ActionBase|Object} action
   */
  addAction(action) {
    this[ACTION_QUEUE_PROP].push(action);
  }
  /**
   * Undoes actions held
   */
  undo() {
    const queue = this[ACTION_QUEUE_PROP];
    for (let i = queue.length - 1; i >= 0; --i) {
      queue[i].undo();
    }
  }
  /**
   * Redoes actions held
   */
  redo() {
    const queue = this[ACTION_QUEUE_PROP];
    for (let i = 0, len = queue.length; i < len; ++i) {
      queue[i].redo();
    }
  }
};
Transaction._$name = "Transaction";

// ../Core/lib/Core/data/stm/state/ReadyState.js
var ReadyStateClass = class extends StateBase {
  canUndo(stm) {
    return 0 < stm.position && stm.position <= stm.length;
  }
  canRedo(stm) {
    return 0 <= stm.position && stm.position < stm.length;
  }
  onUndo(stm, steps) {
    let curPos = stm.position;
    const queue = stm[QUEUE_PROP], newPos = Math.max(0, curPos - steps), next = () => {
      stm.notifyStoresAboutStateRestoringStart();
      const undoneTransactions = [];
      while (curPos !== newPos) {
        const transaction = queue[--curPos];
        transaction.undo();
        undoneTransactions.push(transaction);
      }
      return [stm.autoRecord ? "autoreadystate" : "readystate", () => {
        stm.notifyStoresAboutStateRestoringStop({ cause: "undo", transactions: undoneTransactions });
      }];
    };
    return [{
      [STATE_PROP]: "restoringstate",
      [POS_PROP]: newPos
    }, next];
  }
  onRedo(stm, steps) {
    let curPos = stm.position;
    const queue = stm[QUEUE_PROP], newPos = Math.min(queue.length, curPos + steps);
    const next = () => {
      stm.notifyStoresAboutStateRestoringStart();
      const redoneTransactions = [];
      do {
        const transaction = queue[curPos++];
        transaction.redo();
        redoneTransactions.push(transaction);
      } while (curPos !== newPos);
      return [stm.autoRecord ? "autoreadystate" : "readystate", () => {
        stm.notifyStoresAboutStateRestoringStop({ cause: "redo", transactions: redoneTransactions });
      }];
    };
    return [{
      [STATE_PROP]: "restoringstate",
      [POS_PROP]: newPos
    }, next];
  }
  onEnable() {
    throwInvalidMethodCall();
  }
  onDisable() {
    return "disabledstate";
  }
  onAutoRecordOn() {
    return {
      [STATE_PROP]: "autoreadystate",
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    throwInvalidMethodCall();
  }
  onStartTransaction(stm, title) {
    const transaction = new Transaction({ title });
    return [{
      [STATE_PROP]: "recordingstate",
      [TRANSACTION_PROP]: transaction
    }, () => {
      stm.notifyStoresAboutStateRecordingStart(transaction);
    }];
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var ReadyState = new ReadyStateClass();
var ReadyState_default = ReadyState;
Registry_default.registerStmState("readystate", ReadyState);

// ../Core/lib/Core/data/stm/state/RecordingState.js
var RecordingStateClass = class extends StateBase {
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onEnable() {
  }
  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP];
    stm.notifyStoresAboutStateRecordingStop(transaction, { disabled: true });
    return {
      [STATE_PROP]: "disabledstate",
      [TRANSACTION_PROP]: null
    };
  }
  onAutoRecordOn(stm) {
    return [{
      [STATE_PROP]: "autorecordingstate",
      [AUTO_RECORD_PROP]: true
    }, () => {
      stm.stopTransactionDelayed();
    }];
  }
  onAutoRecordOff() {
    throwInvalidMethodCall();
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP], queue = stm[QUEUE_PROP];
    let position = stm[POS_PROP];
    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }
      queue[position] = transaction;
      queue.length = ++position;
    }
    return [{
      [STATE_PROP]: "readystate",
      [POS_PROP]: position,
      [TRANSACTION_PROP]: null
    }, () => {
      stm.notifyStoresAboutStateRecordingStop(transaction, { stop: true });
    }];
  }
  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP];
    return [{
      [STATE_PROP]: "restoringstate",
      [TRANSACTION_PROP]: null
    }, () => {
      if (transaction.length) {
        transaction.undo();
      }
      return [
        "readystate",
        () => {
          stm.notifyStoresAboutStateRecordingStop(transaction, { rejected: true });
        }
      ];
    }];
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onModelUpdate(stm, model, newData, oldData, isInitialUserAction) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelUpdateAction(model, newData, oldData, isInitialUserAction));
  }
  onModelInsertChild(stm, parentModel, index, childModel, previousParent, previousIndex) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelInsertChildAction(parentModel, index, childModel, previousParent, previousIndex));
  }
  onModelRemoveChild(stm, parentModel, childModels, context) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeModelRemoveChildAction(parentModel, childModels, context));
  }
  onStoreModelAdd(stm, store, models, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelAddAction(store, models, silent));
  }
  onStoreModelInsert(stm, store, index, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelInsertAction(store, index, models, context, silent));
  }
  onStoreModelRemove(stm, store, models, context, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreModelRemoveAction(store, models, context, silent));
  }
  onStoreRemoveAll(stm, store, allRecords, silent) {
    const transaction = stm[TRANSACTION_PROP];
    transaction.addAction(stm.makeStoreRemoveAllAction(store, allRecords, silent));
  }
};
var RecordingState = new RecordingStateClass();
var RecordingState_default = RecordingState;
Registry_default.registerStmState("recordingstate", RecordingState);

// ../Core/lib/Core/data/stm/state/RestoringState.js
var RestoringStateClass = class extends StateBase {
  static get $name() {
    return "RestoringStateClass";
  }
  canUndo() {
    return false;
  }
  canRedo() {
    return false;
  }
  onUndo() {
    throwInvalidMethodCall();
  }
  onRedo() {
    throwInvalidMethodCall();
  }
  onEnable() {
    throwInvalidMethodCall();
  }
  onDisable() {
    throwInvalidMethodCall();
  }
  onAutoRecordOn() {
    return {
      [AUTO_RECORD_PROP]: true
    };
  }
  onAutoRecordOff() {
    return {
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransaction() {
    throwInvalidMethodCall();
  }
  onStopTransactionDelayed() {
    throwInvalidMethodCall();
  }
  onRejectTransaction() {
    throwInvalidMethodCall();
  }
  onQueueReset() {
    throwInvalidMethodCall();
  }
  onModelUpdate() {
  }
  onModelInsertChild() {
  }
  onModelRemoveChild() {
  }
  onStoreModelAdd() {
  }
  onStoreModelInsert() {
  }
  onStoreModelRemove() {
  }
  onStoreRemoveAll() {
  }
};
var RestoringState = new RestoringStateClass();
var RestoringState_default = RestoringState;
Registry_default.registerStmState("restoringstate", RestoringState);

// ../Core/lib/Core/data/stm/state/AutoReadyState.js
var AutoReadyStateClass = class extends ReadyStateClass {
  onAutoRecordOn() {
    throwInvalidMethodCall();
  }
  onAutoRecordOff() {
    return {
      [STATE_PROP]: "readystate",
      [AUTO_RECORD_PROP]: false
    };
  }
  onStartTransaction(stm, title) {
    const transaction = new Transaction({ title });
    return [{
      [STATE_PROP]: "autorecordingstate",
      [TRANSACTION_PROP]: transaction
    }, () => {
      stm.notifyStoresAboutStateRecordingStart(transaction);
      stm.stopTransactionDelayed();
    }];
  }
  onModelUpdate(stm, model, newData, oldData) {
    stm.startTransaction();
    stm.onModelUpdate(model, newData, oldData);
  }
  onModelInsertChild(stm, parentModel, index, childModels, context) {
    stm.startTransaction();
    stm.onModelInsertChild(parentModel, index, childModels, context);
  }
  onModelRemoveChild(stm, parentModel, childModels, context) {
    stm.startTransaction();
    stm.onModelRemoveChild(parentModel, childModels, context);
  }
  onStoreModelAdd(stm, store, models, silent) {
    stm.startTransaction();
    stm.onStoreModelAdd(store, models, silent);
  }
  onStoreModelInsert(stm, store, index, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelInsert(store, index, models, context, silent);
  }
  onStoreModelRemove(stm, store, models, context, silent) {
    stm.startTransaction();
    stm.onStoreModelRemove(store, models, context, silent);
  }
  onStoreRemoveAll(stm, store, allRecords, silent) {
    stm.startTransaction();
    stm.onStoreRemoveAll(store, allRecords, silent);
  }
};
var AutoReadyState = new AutoReadyStateClass();
var AutoReadyState_default = AutoReadyState;
Registry_default.registerStmState("autoreadystate", AutoReadyState);

// ../Core/lib/Core/data/stm/state/AutoRecordingState.js
var AutoRecordingStateClass = class extends RecordingStateClass.mixin(Delayable_default) {
  onDisable(stm) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    stm.notifyStoresAboutStateRecordingStop(transaction, { disabled: true });
    return {
      [STATE_PROP]: "disabledstate",
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    };
  }
  onAutoRecordOn(stm) {
    throwInvalidMethodCall();
  }
  onAutoRecordOff(stm) {
    const timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    return {
      [STATE_PROP]: "recordingstate",
      [AUTO_RECORD_PROP]: false,
      [TRANSACTION_TIMER_PROP]: null
    };
  }
  onStopTransaction(stm, title) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP], queue = stm[QUEUE_PROP];
    let position = stm[POS_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    if (transaction.length) {
      if (!transaction.title && !title && stm.getTransactionTitle) {
        transaction.title = stm.getTransactionTitle(transaction);
      } else if (title) {
        transaction.title = title;
      }
      queue[position] = transaction;
      queue.length = ++position;
    }
    return [{
      [STATE_PROP]: "autoreadystate",
      [POS_PROP]: position,
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    }, () => {
      stm.notifyStoresAboutStateRecordingStop(transaction, { stop: true });
    }];
  }
  onStopTransactionDelayed(stm) {
    let timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    timer = this.setTimeout(
      () => {
        stm.stopTransaction();
      },
      stm.autoRecordTransactionStopTimeout
    );
    return {
      [STATE_PROP]: AutoRecordingState,
      [TRANSACTION_TIMER_PROP]: timer
    };
  }
  onResetQueue(stm, options) {
    return resetQueue(stm, options);
  }
  onRejectTransaction(stm) {
    const transaction = stm[TRANSACTION_PROP], timer = stm[TRANSACTION_TIMER_PROP];
    if (timer) {
      this.clearTimeout(timer);
    }
    return [{
      [STATE_PROP]: "restoringstate",
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null
    }, () => {
      if (transaction.length) {
        transaction.undo();
      }
      return [
        "autoreadystate",
        () => {
          stm.notifyStoresAboutStateRecordingStop(transaction, { rejected: true });
        }
      ];
    }];
  }
  onModelUpdate(stm, ...rest) {
    super.onModelUpdate(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onModelInsertChild(stm, ...rest) {
    super.onModelInsertChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onModelRemoveChild(stm, ...rest) {
    super.onModelRemoveChild(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelAdd(stm, ...rest) {
    super.onStoreModelAdd(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelInsert(stm, ...rest) {
    super.onStoreModelInsert(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreModelRemove(stm, ...rest) {
    super.onStoreModelRemove(stm, ...rest);
    stm.stopTransactionDelayed();
  }
  onStoreRemoveAll(stm, ...rest) {
    super.onStoreRemoveAll(stm, ...rest);
    stm.stopTransactionDelayed();
  }
};
var AutoRecordingState = new AutoRecordingStateClass();
var AutoRecordingState_default = AutoRecordingState;
Registry_default.registerStmState("autorecordingstate", AutoRecordingState);

// ../Core/lib/Core/data/stm/action/ActionBase.js
var throwAbstractMethodCall2 = () => {
  throw new Error("Abstract method call!");
};
var ActionBase = class extends Base {
  /**
   * Gets the type of the action (stringified class name).
   * @readonly
   * @property {String}
   */
  get type() {
    return this.constructor.name;
  }
  /**
   * Undoes an action
   */
  undo() {
    throwAbstractMethodCall2();
  }
  /**
   * Redoes an action
   */
  redo() {
    throwAbstractMethodCall2();
  }
};
ActionBase._$name = "ActionBase";

// ../Core/lib/Core/data/stm/action/UpdateAction.js
var MODEL_PROP = Symbol("MODEL_PROP");
var NEW_DATA_PROP = Symbol("NEW_DATA_PROP");
var OLD_DATA_PROP = Symbol("OLD_DATA_PROP");
var UpdateAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a model which has been updated.
       *
       * @prp {Core.data.Model}
       * @readonly
       * @default
       */
      model: void 0,
      /**
       * Map of updated properties with new values.
       *
       * @prp {Object}
       * @readonly
       * @typings {{[key: string]:any}}
       * @default
       */
      newData: void 0,
      /**
       * Map of updated properties with old values.
       *
       * @prp {Object}
       * @readonly
       * @typings {{[key: string]:any}}
       * @default
       */
      oldData: void 0,
      isInitialUserAction: false
    };
  }
  get type() {
    return "UpdateAction";
  }
  get model() {
    return this[MODEL_PROP];
  }
  set model(value) {
    this[MODEL_PROP] = value;
  }
  get newData() {
    return this[NEW_DATA_PROP];
  }
  set newData(value) {
    this[NEW_DATA_PROP] = { ...value };
  }
  get oldData() {
    return this[OLD_DATA_PROP];
  }
  set oldData(value) {
    this[OLD_DATA_PROP] = { ...value };
  }
  undo() {
    const { model, oldData } = this;
    if (model.$) {
      Object.assign(model, oldData);
    }
    model.set(oldData, null, null, null, Boolean(model.$));
  }
  redo() {
    const { model, newData } = this;
    if (model.$) {
      Object.assign(model, newData);
    }
    model.set(newData, null, null, null, Boolean(model.$));
  }
};
UpdateAction._$name = "UpdateAction";

// ../Core/lib/Core/data/stm/action/InsertChildAction.js
var PARENT_MODEL_PROP = Symbol("PARENT_MODEL_PROP");
var CHILD_MODELS_PROP = Symbol("CHILD_MODELS_PROP");
var INSERT_INDEX_PROP = Symbol("INSERT_INDEX_PROP");
var CONTEXT_PROP = Symbol("CONTEXT_PROP");
var InsertChildAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a parent model a child model has been added to.
       *
       * @prp {Core.data.Model}
       * @readonly
       * @default
       */
      parentModel: void 0,
      /**
       * Children models inserted.
       *
       * @prp {Core.data.Model[]}
       * @readonly
       * @default
       */
      childModels: void 0,
      /**
       * Index a children models are inserted at
       *
       * @prp {Number}
       * @readonly
       * @default
       */
      insertIndex: void 0,
      /**
       * Map having children models as keys and values containing previous parent
       * of each model and index at the previous parent.
       *
       * @prp {Object}
       * @readonly
       * @default
       */
      context: void 0
    };
  }
  get type() {
    return "InsertChildAction";
  }
  get parentModel() {
    return this[PARENT_MODEL_PROP];
  }
  set parentModel(model) {
    this[PARENT_MODEL_PROP] = model;
  }
  get childModels() {
    return this[CHILD_MODELS_PROP];
  }
  set childModels(models) {
    this[CHILD_MODELS_PROP] = models.slice(0);
  }
  get insertIndex() {
    return this[INSERT_INDEX_PROP];
  }
  set insertIndex(index) {
    this[INSERT_INDEX_PROP] = index;
  }
  get context() {
    return this[CONTEXT_PROP];
  }
  set context(ctx) {
    this[CONTEXT_PROP] = ctx;
  }
  undo() {
    const { parentModel, context, childModels } = this, byFromParent = /* @__PURE__ */ new Map(), newlyAdded = /* @__PURE__ */ new Set();
    for (const childModel of childModels) {
      const ctx = context.get(childModel);
      if (!ctx) {
        newlyAdded.add(childModel);
      } else {
        let undoTaskData = byFromParent.get(ctx.parent);
        if (!undoTaskData) {
          undoTaskData = { moveRight: [], moveLeft: [], moveFromAnotherParent: [] };
          byFromParent.set(ctx.parent, undoTaskData);
        }
        if (ctx.parent === parentModel) {
          if (ctx.index > childModel.parentIndex) {
            undoTaskData.moveRight.push({ parent: ctx.parent, model: childModel, index: ctx.index + 1 });
          } else {
            undoTaskData.moveLeft.push({ parent: ctx.parent, model: childModel, index: ctx.index });
          }
        } else {
          undoTaskData.moveFromAnotherParent.push({ parent: ctx.parent, model: childModel, index: ctx.index });
        }
      }
    }
    for (const undoTaskData of byFromParent.values()) {
      const { moveRight, moveLeft } = undoTaskData;
      moveLeft.sort((a, b) => a.index - b.index);
      moveRight.sort((a, b) => b.index - a.index);
    }
    newlyAdded.forEach((model) => model.parent.removeChild(model));
    for (const undoTaskData of byFromParent.values()) {
      const { moveRight, moveLeft, moveFromAnotherParent } = undoTaskData;
      moveLeft.forEach((task) => {
        task.parent.insertChild(task.model, task.index);
      });
      moveRight.forEach((task) => {
        task.parent.insertChild(task.model, task.index);
      });
      moveFromAnotherParent.forEach((task) => {
        task.parent.insertChild(task.model, task.index);
      });
    }
  }
  redo() {
    var _a2, _b;
    const { parentModel, insertIndex, childModels } = this, insertBefore = (_a2 = parentModel.children) == null ? void 0 : _a2[insertIndex];
    parentModel.insertChild(childModels, insertBefore, false, {
      orderedBeforeNode: (_b = insertBefore == null ? void 0 : insertBefore.previousSibling) == null ? void 0 : _b.nextOrderedSibling
    });
  }
};
InsertChildAction._$name = "InsertChildAction";

// ../Core/lib/Core/data/stm/action/RemoveChildAction.js
var PARENT_MODEL_PROP2 = Symbol("PARENT_MODEL_PROP");
var CHILD_MODELS_PROP2 = Symbol("CHILD_MODELS_PROP");
var CONTEXT_PROP2 = Symbol("CONTEXT_PROP");
var RemoveChildAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a parent model a child model has been removed to.
       *
       * @prp {Core.data.Model}
       * @readonly
       * @default
       */
      parentModel: void 0,
      /**
       * Children models removed.
       *
       * @prp {Core.data.Model[]}
       * @readonly
       * @default
       */
      childModels: void 0,
      /**
       * Map having children models as keys and values containing previous parent
       * index at the parent.
       *
       * @prp {Object}
       * @readonly
       * @default
       */
      context: void 0
    };
  }
  get type() {
    return "RemoveChildAction";
  }
  get parentModel() {
    return this[PARENT_MODEL_PROP2];
  }
  set parentModel(model) {
    this[PARENT_MODEL_PROP2] = model;
  }
  get childModels() {
    return this[CHILD_MODELS_PROP2];
  }
  set childModels(models) {
    this[CHILD_MODELS_PROP2] = models.slice(0);
  }
  get context() {
    return this[CONTEXT_PROP2];
  }
  set context(ctx) {
    this[CONTEXT_PROP2] = ctx;
  }
  undo() {
    const { parentModel, context, childModels } = this;
    childModels.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex - rhsIndex;
    });
    childModels.forEach((m) => {
      const ctx = context.get(m);
      parentModel.insertChild(m, ctx.parentIndex, void 0, { orderedParentIndex: ctx.orderedParentIndex });
    });
  }
  redo() {
    this.parentModel.removeChild(this.childModels);
  }
};
RemoveChildAction._$name = "RemoveChildAction";

// ../Core/lib/Core/data/stm/action/AddAction.js
var STORE_PROP = Symbol("STORE_PROP");
var MODEL_LIST_PROP = Symbol("MODEL_LIST_PROP");
var AddAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store models have been added into.
       *
       * @prp {Core.data.Store}
       * @readonly
       * @default
       */
      store: void 0,
      /**
       * List of models added into the store.
       *
       * @prp {Core.data.Model[]}
       * @readonly
       * @default
       */
      modelList: void 0,
      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @prp {Boolean}
       * @readonly
       * @default
       */
      silent: false
    };
  }
  get type() {
    return "AddAction";
  }
  get store() {
    return this[STORE_PROP];
  }
  set store(store) {
    this[STORE_PROP] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP] = list.slice(0);
  }
  undo() {
    this.store.remove(this.modelList, this.silent);
  }
  redo() {
    this.store.add(this.modelList, this.silent);
  }
};
AddAction._$name = "AddAction";

// ../Core/lib/Core/data/stm/action/InsertAction.js
var STORE_PROP2 = Symbol("STORE_PROP");
var MODEL_LIST_PROP2 = Symbol("MODEL_LIST_PROP");
var INSERT_INDEX_PROP2 = Symbol("INSERT_INDEX_PROP");
var CONTEXT_PROP3 = Symbol("CONTEXT_PROP");
var InsertAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store models have been inserted into.
       *
       * @prp {Core.data.Store}
       * @readonly
       * @default
       */
      store: void 0,
      /**
       * List of models inserted into the store.
       *
       * @prp {Core.data.Model[]}
       * @readonly
       * @default
       */
      modelList: void 0,
      /**
       * Index the models have been inserted at.
       *
       * @prp {Number}
       * @readonly
       * @default
       */
      insertIndex: void 0,
      /**
       * Models move context (if models has been moved), if any.
       * Map this {@link Core/data/Model} instances as keys and their
       * previous index as values
       *
       * @prp {Map}
       * @readonly
       * @default
       */
      context: void 0,
      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @prp {Boolean}
       * @readonly
       * @default
       */
      silent: false
    };
  }
  get type() {
    return "InsertAction";
  }
  get store() {
    return this[STORE_PROP2];
  }
  set store(store) {
    this[STORE_PROP2] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP2];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP2] = list.slice(0);
  }
  get insertIndex() {
    return this[INSERT_INDEX_PROP2];
  }
  set insertIndex(index) {
    this[INSERT_INDEX_PROP2] = index;
  }
  get context() {
    return this[CONTEXT_PROP3];
  }
  set context(context) {
    this[CONTEXT_PROP3] = context;
  }
  undo() {
    const { store, modelList, context, silent } = this;
    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex !== void 0 && rhsIndex !== void 0 ? lhsIndex - rhsIndex : 0;
    });
    modelList.forEach((m) => {
      const index = context.get(m);
      m._undoingInsertion = true;
      if (index !== void 0) {
        store.insert(index, m, silent);
      } else {
        store.remove(m, silent);
      }
      m._undoingInsertion = false;
    });
  }
  redo() {
    const me = this;
    me.store.insert(me.insertIndex, me.modelList, me.silent);
  }
};
InsertAction._$name = "InsertAction";

// ../Core/lib/Core/data/stm/action/RemoveAction.js
var STORE_PROP3 = Symbol("STORE_PROP");
var MODEL_LIST_PROP3 = Symbol("MODEL_LIST_PROP");
var CONTEXT_PROP4 = Symbol("CONTEXT_PROP");
var RemoveAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store models have been removed from.
       *
       * @prp {Core.data.Store}
       * @readonly
       * @default
       */
      store: void 0,
      /**
       * List of models removed from the store.
       *
       * @prp {Core.data.Model[]}
       * @readonly
       * @default
       */
      modelList: void 0,
      /**
       * Models removing context.
       *
       * @prp {Object}
       * @readonly
       * @default
       */
      context: void 0,
      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @prp {Boolean}
       * @readonly
       * @default
       */
      silent: false
    };
  }
  get type() {
    return "RemoveAction";
  }
  get store() {
    return this[STORE_PROP3];
  }
  set store(store) {
    this[STORE_PROP3] = store;
  }
  get modelList() {
    return this[MODEL_LIST_PROP3];
  }
  set modelList(list) {
    this[MODEL_LIST_PROP3] = list.slice(0);
  }
  get context() {
    return this[CONTEXT_PROP4];
  }
  set context(context) {
    this[CONTEXT_PROP4] = context;
  }
  undo() {
    const { store, context, modelList, silent } = this;
    modelList.sort((lhs, rhs) => {
      const lhsIndex = context.get(lhs), rhsIndex = context.get(rhs);
      return lhsIndex - rhsIndex;
    });
    modelList.forEach((m) => {
      const index = context.get(m);
      store.insert(index, m, silent);
    });
  }
  redo() {
    this.store.remove(this.modelList, this.silent);
  }
};
RemoveAction._$name = "RemoveAction";

// ../Core/lib/Core/data/stm/action/RemoveAllAction.js
var STORE_PROP4 = Symbol("STORE_PROP");
var ALL_RECORDS_PROP = Symbol("ALL_RECORDS_PROP");
var RemoveAllAction = class extends ActionBase {
  static get defaultConfig() {
    return {
      /**
       * Reference to a store cleared.
       *
       * @prp {Core.data.Store}
       * @readonly
       * @default
       */
      store: void 0,
      /**
       * All store records removed
       *
       * @prp {Core.data.Model[]}
       * @readonly
       * @default
       */
      allRecords: void 0,
      /**
       * Flag showing if undo/redo should be done silently i.e. with events suppressed
       *
       * @prp {Boolean}
       * @readonly
       * @default
       */
      silent: false
    };
  }
  get type() {
    return "RemoveAllAction";
  }
  get store() {
    return this[STORE_PROP4];
  }
  set store(store) {
    this[STORE_PROP4] = store;
  }
  get allRecords() {
    return this[ALL_RECORDS_PROP];
  }
  set allRecords(records) {
    this[ALL_RECORDS_PROP] = records.slice(0);
  }
  undo() {
    const { store, allRecords, silent } = this;
    store.add(allRecords, silent);
  }
  redo() {
    this.store.removeAll(this.silent);
  }
};
RemoveAllAction._$name = "RemoveAllAction";

// ../Core/lib/Core/data/stm/StateTrackingManager.js
var makeModelUpdateAction = (model, newData, oldData, isInitialUserAction) => {
  return new UpdateAction({
    model,
    newData,
    oldData,
    isInitialUserAction
  });
};
var makeModelInsertChildAction = (parentModel, insertIndex, childModels, context) => {
  return new InsertChildAction({
    parentModel,
    childModels,
    insertIndex,
    context
  });
};
var makeModelRemoveChildAction = (parentModel, childModels, context) => {
  return new RemoveChildAction({
    parentModel,
    childModels,
    context
  });
};
var makeStoreModelAddAction = (store, modelList, silent) => {
  return new AddAction({
    store,
    modelList,
    silent
  });
};
var makeStoreModelInsertAction = (store, insertIndex, modelList, context, silent) => {
  return new InsertAction({
    store,
    insertIndex,
    modelList,
    context,
    silent
  });
};
var makeStoreModelRemoveAction = (store, modelList, context, silent) => {
  return new RemoveAction({
    store,
    modelList,
    context,
    silent
  });
};
var makeStoreRemoveAllAction = (store, allRecords, silent) => {
  return new RemoveAllAction({
    store,
    allRecords,
    silent
  });
};
var stateTransition = (stm, event, ...args) => {
  const oldState = stm.state, newState = event.call(stm[STATE_PROP], stm, ...args);
  if (typeof newState === "string") {
    stm[STATE_PROP] = Registry_default.resolveStmState(newState);
  } else if (newState instanceof StateBase) {
    stm[STATE_PROP] = newState;
  } else if (Array.isArray(newState)) {
    const [state, next] = newState;
    if (typeof state === "string") {
      stm[STATE_PROP] = Registry_default.resolveStmState(state);
    } else if (state instanceof StateBase) {
      stm[STATE_PROP] = state;
    } else if (state && typeof state === "object") {
      stm = Object.assign(stm, state);
      stm[STATE_PROP] = Registry_default.resolveStmState(stm[STATE_PROP]);
    }
    if (typeof next === "function") {
      stateTransition(stm, next, ...args);
    }
  } else if (newState && typeof newState === "object") {
    stm = Object.assign(stm, newState);
    stm[STATE_PROP] = Registry_default.resolveStmState(stm[STATE_PROP]);
  }
  if (oldState !== ReadyState_default && oldState !== AutoReadyState_default && (newState !== ReadyState_default && newState !== AutoReadyState_default)) {
    stm.trigger("ready");
  }
};
var StateTrackingManager = class extends Events_default(Base) {
  static get defaultConfig() {
    return {
      /**
       * Default manager disabled state
       *
       * @config {Boolean}
       * @default
       */
      disabled: true,
      /**
       * Whether to start transaction recording automatically in case the Manager is enabled.
       *
       * In the auto recording mode, the manager waits for the first change in any store being managed and starts a transaction, i.e.
       * records any changes in its monitored stores. The transaction lasts for {@link #config-autoRecordTransactionStopTimeout} and
       * afterwards creates one undo/redo step, including all changes in the stores during that period of time.
       *
       * In non auto recording mode you have to call {@link #function-startTransaction} / {@link #function-stopTransaction} to start and end
       * a transaction.
       *
       * @config {Boolean}
       * @default
       */
      autoRecord: false,
      /**
       * The transaction duration (in ms) for the auto recording mode {@link #config-autoRecord}
       *
       * @config {Number}
       * @default
       */
      autoRecordTransactionStopTimeout: 100,
      /**
       * Store model update action factory
       *
       * @config {Function}
       * @default
       * @private
       */
      makeModelUpdateAction,
      /**
       * Store insert child model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeModelInsertChildAction,
      /**
       * Store remove child model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeModelRemoveChildAction,
      /**
       * Store add model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreModelAddAction,
      /**
       * Store insert model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreModelInsertAction,
      /**
       * Store remove model action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreModelRemoveAction,
      /**
       * Store remove all models action factory.
       *
       * @config {Function}
       * @default
       * @private
       */
      makeStoreRemoveAllAction,
      /**
       * Function to create a transaction title if none is provided.
       * The function receives a transaction and should return a title.
       *
       * @config {Function}
       * @param {Core.data.stm.Transaction} transaction
       * @returns {String}
       * @default
       */
      getTransactionTitle: null
    };
  }
  construct(...args) {
    Object.assign(this, {
      [STATE_PROP]: ReadyState_default,
      [STORES_PROP]: [],
      [QUEUE_PROP]: [],
      [POS_PROP]: 0,
      [TRANSACTION_PROP]: null,
      [TRANSACTION_TIMER_PROP]: null,
      [AUTO_RECORD_PROP]: false,
      [IS_APPLYING_STASH]: false,
      stashedTransactions: {}
    });
    super.construct(...args);
  }
  /**
   * Gets current state of the manager
   *
   * @property {Core.data.stm.state.StateBase}
   */
  get state() {
    return this[STATE_PROP];
  }
  /**
   * Gets current undo/redo queue position
   *
   * @property {Number}
   */
  get position() {
    return this[POS_PROP];
  }
  /**
   * Gets current undo/redo queue length
   *
   * @property {Number}
   */
  get length() {
    return this[QUEUE_PROP].length;
  }
  /**
   * Gets all the stores registered in STM
   *
   * @property {Core.data.Store[]}
   */
  get stores() {
    return Array.from(this[STORES_PROP]);
  }
  /**
   * Checks if a store has been added to the manager
   *
   * @param  {Core.data.Store} store
   * @returns {Boolean}
   */
  hasStore(store) {
    return this[STORES_PROP].includes(store);
  }
  /**
   * Adds a store to the manager
   *
   * @param {Core.data.Store} store
   */
  addStore(store) {
    if (!this.hasStore(store)) {
      this[STORES_PROP].push(store);
      store.stm = this;
      store.forEach((model) => model.stm = this);
      if (store.isTree) {
        store.rootNode.stm = this;
      }
    }
  }
  /**
   * Removes a store from the manager
   *
   * @param {Core.data.Store} store
   */
  removeStore(store) {
    if (this.hasStore(store)) {
      this[STORES_PROP] = this[STORES_PROP].filter((s) => s !== store);
      store.stm = null;
      store.forEach((model) => model.stm = null);
    }
  }
  /**
   * Calls `fn` for each store registered in STM.
   *
   * @param {Function} fn (store, id) => ...
   */
  forEachStore(fn2) {
    this[STORES_PROP].forEach((s) => fn2(s, s.id));
  }
  //#region Disabled state
  /**
   * Get/set manager disabled state
   *
   * @property {Boolean}
   */
  get disabled() {
    return this.state === DisabledState_default;
  }
  set disabled(val) {
    const me = this;
    if (me.disabled !== val) {
      if (val) {
        stateTransition(me, me.state.onDisable, me);
      } else {
        stateTransition(me, me.state.onEnable, me);
      }
      me.trigger("stmDisabled", { disabled: val });
      me.trigger("disabled", { disabled: val });
    }
  }
  get enabled() {
    return !this.disabled;
  }
  /**
   * Enables manager
   */
  enable() {
    this.disabled = false;
  }
  /**
   * Disables manager
   */
  disable() {
    this.disabled = true;
  }
  //#endregion
  /**
   * Checks manager ready state
   * @readonly
   * @property {Boolean}
   */
  get isReady() {
    return this.state === ReadyState_default || this.state === AutoReadyState_default;
  }
  waitForReadiness() {
    return this.await("ready", false);
  }
  /**
   * Checks manager recording state
   * @readonly
   * @property {Boolean}
   */
  get isRecording() {
    return this.state === RecordingState_default || this.state === AutoRecordingState_default;
  }
  /**
   * Checks if STM is restoring a stash
   * @readonly
   * @property {Boolean}
   * @internal
   */
  get isApplyingStash() {
    return this[IS_APPLYING_STASH];
  }
  /**
   * Gets/sets manager auto record option
   *
   * @property {Boolean}
   */
  get autoRecord() {
    return this[AUTO_RECORD_PROP];
  }
  set autoRecord(value) {
    const me = this;
    if (me.autoRecord != value) {
      if (value) {
        stateTransition(me, me.state.onAutoRecordOn, me);
      } else {
        stateTransition(me, me.state.onAutoRecordOff, me);
      }
    }
  }
  /**
   * Starts undo/redo recording transaction.
   *
   * @param {String} [title]
   */
  startTransaction(title = null) {
    stateTransition(this, this.state.onStartTransaction, title);
  }
  /**
   * Stops undo/redo recording transaction
   *
   * @param {String} [title]
   */
  stopTransaction(title = null) {
    stateTransition(this, this.state.onStopTransaction, title);
  }
  /**
   * Stops undo/redo recording transaction after {@link #config-autoRecordTransactionStopTimeout} delay.
   *
   * @private
   */
  stopTransactionDelayed() {
    stateTransition(this, this.state.onStopTransactionDelayed);
  }
  /**
   * Rejects currently recorded transaction.
   */
  rejectTransaction() {
    stateTransition(this, this.state.onRejectTransaction);
  }
  /**
   * Gets currently recording STM transaction.
   * @readonly
   * @property {Core.data.stm.Transaction}
   */
  get transaction() {
    return this[TRANSACTION_PROP];
  }
  /**
   * Gets titles of all recorded undo/redo transactions
   * @readonly
   * @property {String[]}
   */
  get queue() {
    return this[QUEUE_PROP].map((t) => t.title);
  }
  get rawQueue() {
    return this[QUEUE_PROP];
  }
  /**
   * Gets manager restoring state.
   * @readonly
   * @property {Boolean}
   */
  get isRestoring() {
    return this.state === RestoringState_default || this.isApplyingStash;
  }
  /**
   * Checks if the manager can undo.
   *
   * @property {Boolean}
   */
  get canUndo() {
    return this.state.canUndo(this);
  }
  /**
   * Checks if the manager can redo.
   *
   * @property {Boolean}
   */
  get canRedo() {
    return this.state.canRedo(this);
  }
  /**
   * Undoes current undo/redo transaction.
   * @param {Number} [steps=1]
   * @returns {Promise} A promise which is resolved when undo action has been performed
   */
  async undo(steps = 1) {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    stateTransition(this, this.state.onUndo, steps);
  }
  /**
   * Undoes all transactions.
   * @returns {Promise} A promise which is resolved when undo actions has been performed
   */
  async undoAll() {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    this.undo(this.length);
  }
  /**
   * Redoes current undo/redo transaction.
   *
   * @param {Number} [steps=1]
   * @returns {Promise} A promise which is resolved when redo action has been performed
   */
  async redo(steps = 1) {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    stateTransition(this, this.state.onRedo, steps);
  }
  /**
   * Redoes all transactions.
   * @returns {Promise} A promise which is resolved when redo actions has been performed
   */
  async redoAll() {
    if (!this.isReady) {
      await this.waitForReadiness();
    }
    this.redo(this.length);
  }
  /**
   * Resets undo/redo queue.
   */
  resetQueue(options = { undo: true, redo: true }) {
    stateTransition(this, this.state.onResetQueue, options);
  }
  /**
   * Resets undo queue.
   */
  resetUndoQueue() {
    this.resetQueue({ undo: true });
  }
  /**
   * Resets redo queue.
   */
  resetRedoQueue() {
    this.resetQueue({ redo: true });
  }
  notifyStoresAboutStateRecordingStart(transaction) {
    this.forEachStore((store) => {
      var _a2;
      return (_a2 = store.onStmRecordingStart) == null ? void 0 : _a2.call(store, this, transaction);
    });
    this.trigger("recordingStart", { stm: this, transaction });
  }
  notifyStoresAboutStateRecordingStop(transaction, reason) {
    this.forEachStore((store) => {
      var _a2;
      return (_a2 = store.onStmRecordingStop) == null ? void 0 : _a2.call(store, this, transaction, reason);
    });
    this.trigger("recordingStop", { stm: this, transaction, reason });
  }
  notifyStoresAboutStateRestoringStart() {
    this.forEachStore((store) => {
      var _a2;
      return (_a2 = store.onStmRestoringStart) == null ? void 0 : _a2.call(store, this);
    });
    this.trigger("restoringStart", { stm: this });
  }
  /**
   * @param {'undo'|'redo'} cause The cause of the restore, if applicable
   * @internal
   */
  notifyStoresAboutStateRestoringStop({ cause, transactions }) {
    this.forEachStore((store) => {
      var _a2;
      return (_a2 = store.onStmRestoringStop) == null ? void 0 : _a2.call(store, this);
    });
    this.trigger("restoringStop", { stm: this, cause, transactions });
  }
  notifyStoresAboutQueueReset(options) {
    this.forEachStore((store) => {
      var _a2;
      return (_a2 = store.onStmQueueReset) == null ? void 0 : _a2.call(store, this, options);
    });
    this.trigger("queueReset", { stm: this, options });
  }
  /**
   * Method to call from model STM mixin upon model update
   *
   * @param {Core.data.Model} model
   * @param {Object} newData
   * @param {Object} oldData
   *
   * @private
   */
  onModelUpdate(model, newData, oldData, isInitialUserAction) {
    stateTransition(this, this.state.onModelUpdate, model, newData, oldData, isInitialUserAction);
  }
  /**
   * Method to call from model STM mixin upon tree model child insertion
   *
   * @param {Core.data.Model} parentModel Parent model
   * @param {Number} index Insertion index
   * @param {Core.data.Model[]} childModels Array of models inserted
   * @param {Map} context Map with inserted models as keys and objects with previous parent,
   *                      and index at previous parent.
   *
   * @private
   */
  onModelInsertChild(parentModel, index, childModels, context) {
    stateTransition(this, this.state.onModelInsertChild, parentModel, index, childModels, context);
  }
  /**
   * Method to call from model STM mixin upon tree model child removal
   *
   * @param {Core.data.Model} parentModel
   * @param {Core.data.Model[]} childModels
   * @param {Map} context
   *
   * @private
   */
  onModelRemoveChild(parentModel, childModels, context) {
    stateTransition(this, this.state.onModelRemoveChild, parentModel, childModels, context);
  }
  /**
   * Method to call from store STM mixin upon store models adding
   *
   * @param {Core.data.Store} store
   * @param {Core.data.Model[]} models
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreModelAdd(store, models, silent) {
    stateTransition(this, this.state.onStoreModelAdd, store, models, silent);
  }
  /**
   * Method to call from store STM mixin upon store models insertion
   *
   * @param {Core.data.Store} store
   * @param {Number} index
   * @param {Core.data.Model[]} models
   * @param {Map} context
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreModelInsert(store, index, models, context, silent) {
    stateTransition(this, this.state.onStoreModelInsert, store, index, models, context, silent);
  }
  /**
   * Method to call from store STM mixin upon store models removal
   *
   * @param {Core.data.Store} store
   * @param {Core.data.Model[]} models
   * @param {Object} context
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreModelRemove(store, models, context, silent) {
    stateTransition(this, this.state.onStoreModelRemove, store, models, context, silent);
  }
  /**
   * Method to call from store STM mixin upon store clear
   *
   * @param {Core.data.Store} store
   * @param {Core.data.Model[]} allRecords
   * @param {Boolean} silent
   *
   * @private
   */
  onStoreRemoveAll(store, allRecords, silent) {
    stateTransition(this, this.state.onStoreRemoveAll, store, allRecords, silent);
  }
  // UI key event handling
  onUndoKeyPress(event) {
    const me = this;
    if (me.enabled) {
      if (event.shiftKey) {
        if (me.canRedo) {
          event.preventDefault();
          me.redo();
        }
      } else if (me.canUndo) {
        event.preventDefault();
        me.undo();
      }
    }
  }
  stash() {
    const me = this;
    if (this.transaction) {
      const id = IdHelper.generateId("_stashedTransactionGeneratedId_");
      me.stashedTransactions[id] = me.transaction;
      me.rejectTransaction();
      return id;
    }
  }
  applyStash(id) {
    const me = this, transaction = me.stashedTransactions[id];
    me[IS_APPLYING_STASH] = true;
    if (transaction) {
      me.startTransaction(transaction.title);
      transaction.redo();
      delete me.stashedTransactions[id];
    }
    me[IS_APPLYING_STASH] = false;
  }
};
StateTrackingManager._$name = "StateTrackingManager";

// ../Core/lib/Core/helper/CSSHelper.js
var CSSHelper = class {
  /**
   * Inserts a CSS style rule based upon the passed text
   * @param {String} cssText The text of the rule including selector and rule body just as it would
   * be specified in a CSS file.
   * @returns {CSSRule} The resulting CSS Rule object if the add was successful.
   */
  static insertRule(cssText, parentElement = document.head) {
    const styleSheet = this.getStyleSheet(parentElement), oldCount = styleSheet.cssRules.length;
    styleSheet.insertRule(cssText, 0);
    if (styleSheet.cssRules.length > oldCount) {
      return styleSheet.cssRules[0];
    }
  }
  /**
   * Looks up the first rule which matched the passed selector.
   * @param {String|Function} selector Either the selector string to exactly match or a function which
   * when passed a required selector, returns `true`.
   * @returns {CSSRule} The first matching CSS Rule object if any found.
   */
  static findRule(selector) {
    let result;
    const isFn = typeof selector === "function";
    Array.prototype.find.call(document.head.querySelectorAll("link[rel=stylesheet],style[type*=css]"), (element) => {
      result = Array.prototype.find.call(element.sheet.rules || element.sheet.cssRules, (r) => {
        return isFn ? selector(r) : r.selectorText === selector;
      });
      if (result) {
        return true;
      }
    });
    return result;
  }
  static getStyleSheet(parentElement = document.head) {
    if (!parentElement.$bryntumStylesheet) {
      parentElement.$bryntumStylesheet = DomHelper.createElement({
        tag: "style",
        id: "bryntum-private-styles",
        type: "text/css",
        parent: parentElement
      }).sheet;
    }
    return parentElement.$bryntumStylesheet;
  }
  /**
   * Returns current CSS version
   * @returns {String}
   * @internal
   */
  static getCSSVersion() {
    return getComputedStyle(document.documentElement).getPropertyValue("--bryntum-version").replace(/[" ]/gm, "");
  }
};
CSSHelper._$name = "CSSHelper";

// ../Core/lib/Core/helper/DomSync.js
var arraySlice2 = Array.prototype.slice;
var emptyArray5 = Object.freeze([]);
var emptyObject5 = Object.freeze({});
var htmlRe2 = /[&<]/;
var { getPrototypeOf: getPrototypeOf2 } = Object;
var { toString: toString4 } = Object.prototype;
var { isEqual, isObject: isObject2 } = ObjectHelper;
var checkEqualityIgnore = {
  parent: 1,
  elementData: 1,
  ns: 1,
  syncOptions: 1
};
var makeCheckEqualityOptions = () => ({
  ignore: checkEqualityIgnore,
  refsFound: /* @__PURE__ */ new Set()
});
var isClass = {
  class: 1,
  className: 1,
  classname: 1
};
var simpleTypes = {
  bigint: 1,
  boolean: 1,
  function: 1,
  number: 1,
  // object
  string: 1,
  symbol: 1
  // undefined
};
var syncIgnoreAttributes = {
  tag: 1,
  html: 1,
  text: 1,
  children: 1,
  tooltip: 1,
  parent: 1,
  nextSibling: 1,
  ns: 1,
  reference: 1,
  elementData: 1,
  retainElement: 1,
  compareHtml: 1,
  syncOptions: 1,
  listeners: 1,
  // eslint-disable-line bryntum/no-listeners-in-lib
  isReleased: 1,
  null: 1,
  "": 1,
  keepChildren: 1,
  retainChildren: 1
};
var addAndCacheCls = (cls, lastDomConfig) => {
  const propertyName = "className" in lastDomConfig ? "className" : "class", propertyValue = lastDomConfig[propertyName];
  if (propertyValue) {
    if (typeof propertyValue === "string") {
      const value = propertyValue.split(" ");
      if (!value.includes(cls)) {
        value.push(cls);
        lastDomConfig[propertyName] = value.join(" ");
      }
    } else if (Array.isArray(propertyValue)) {
      if (!propertyValue.includes(cls)) {
        propertyValue.push(cls);
      }
    } else if (propertyValue.isDomClassList) {
      propertyValue.add(cls);
    } else if (ObjectHelper.isObject(propertyValue)) {
      propertyValue[cls] = 1;
    }
  }
};
var removeAndUncacheCls = (cls, lastDomConfig) => {
  const propertyName = "className" in lastDomConfig ? "className" : "class", propertyValue = lastDomConfig[propertyName];
  if (propertyValue) {
    if (typeof propertyValue === "string") {
      const value = propertyValue.split(" ");
      if (value.includes(cls)) {
        value.splice(value.indexOf(cls), 1);
        lastDomConfig[propertyName] = value.join(" ");
      }
    } else if (Array.isArray(propertyValue)) {
      if (propertyValue.includes(cls)) {
        propertyValue.splice(propertyValue.indexOf(cls), 1);
      }
    } else if (propertyValue.isDomClassList) {
      propertyValue.remove(cls);
    } else if (ObjectHelper.isObject(propertyValue)) {
      delete propertyValue[cls];
    }
  }
};
var DomSync = class _DomSync {
  /**
   * Compares two DOM configs or properties of such objects for equality.
   * @param {Object} is The new value.
   * @param {Object} was The old value.
   * @param {Object} options An object with various options to control the comparison.
   * @param {Object} options.ignore An object containing names of attributes to ignore having `true` value.
   * @param {Map} options.equalityCache A map that can be used to record equality results for objects to avoid
   * recomputing the result for the same objects.
   * @param {Set} options.refsFound A Set that must be populated with the values of any `reference` properties found.
   * @param {Boolean|String} [ignoreRefs] Pass `true` to ignore `reference` properties on domConfigs. Pass `'children'`
   * to ignore `reference` properties only on child element configs.
   * @returns {Boolean}
   * @private
   */
  static checkEquality(is, was, options, ignoreRefs) {
    var _a2;
    if (is === was) {
      return true;
    }
    if (is == null) {
      return was == null;
    }
    if (!is || !was) {
      return false;
    }
    const typeA = typeof is, typeB = typeof was;
    if (typeA !== typeB || simpleTypes[typeA]) {
      return false;
    }
    let cache = options.equalityCache || (options.equalityCache = /* @__PURE__ */ new Map()), ignoreChildRefs = Boolean(ignoreRefs), equal2, i, ignore, ignoreRefOpt, key, syncOptions, val;
    cache = cache.get(is) || cache.set(is, /* @__PURE__ */ new Map()).get(is);
    equal2 = cache.get(was);
    if (equal2 === void 0) {
      equal2 = true;
      if (getPrototypeOf2(is) !== getPrototypeOf2(was) || is instanceof Node) {
        equal2 = false;
      } else if (Array.isArray(is)) {
        i = is.length;
        if (i !== was.length) {
          equal2 = false;
        } else {
          while (i-- > 0) {
            if (!_DomSync.checkEquality(is[i], was[i], options, ignoreChildRefs)) {
              equal2 = false;
              break;
            }
          }
        }
      } else {
        syncOptions = is.syncOptions;
        ignoreRefOpt = syncOptions == null ? void 0 : syncOptions.ignoreRefs;
        if (ignoreRefOpt) {
          ignoreChildRefs = true;
          ignoreRefs = ignoreRefOpt !== "children";
        }
        ignore = options.ignore || emptyObject5;
        for (key in was) {
          if (!ignore[key] && !(key in is) && !(ignoreRefs && key === "reference")) {
            equal2 = false;
            break;
          }
        }
        if (equal2) {
          if (toString4.call(was) === "[object Date]") {
            equal2 = is.getTime() === was.getTime();
          } else if (DomHelper.isReactElement(is) || DomHelper.isReactElement(was)) {
            equal2 = false;
          } else {
            for (key in is) {
              if (!ignore[key] && !(ignoreRefs && key === "reference")) {
                if (!(key in was)) {
                  equal2 = false;
                  break;
                }
                val = is[key];
                if (!_DomSync.checkEquality(val, was[key], options, ignoreChildRefs)) {
                  equal2 = false;
                  break;
                }
              }
            }
          }
        }
      }
      if (!ignoreRefs && isObject2(is) && is.reference) {
        (_a2 = options.refsFound) == null ? void 0 : _a2.add(is.reference);
      }
      cache.set(was, equal2);
    }
    return equal2;
  }
  /**
   * Sync a DOM config to a target element
   * @param {Object} options Options object
   * @param {DomConfig} options.domConfig A DOM config object
   * @param {HTMLElement} options.targetElement Target element to apply to
   * @param {Boolean} [options.strict=false] Specify `true` to limit synchronization to only the values set by
   * previous calls. Styles and classes placed directly on the DOM elements by other means will not be affected.
   * @param {String} [options.syncIdField] Field in dataset to use to match elements for re-usage
   * @param {String|String[]} [options.affected] The references affected by a partial sync.
   * @param {Function} [options.callback] A function that will be called on element re-usage, creation and similar
   * @param {Boolean} [options.configEquality] A function that will be called to compare an incoming config to
   * the last config applied to the `targetElement`. This function returns `true` if the passed values are equal and
   * `false` otherwise.
   * @returns {HTMLElement} Returns the updated target element (which is also updated in place)
   */
  static sync(options) {
    var _a2;
    const optionsIn = options, { refOwner } = options, refsWas = refOwner == null ? void 0 : refOwner.byRef, checkEqualityOptions = makeCheckEqualityOptions();
    let affected = options.affected, i, ref, targetNode, lastDomConfig;
    if (typeof affected === "string") {
      affected = [affected];
    }
    options = {
      ...options,
      checkEqualityOptions
    };
    if (refOwner) {
      refOwner.byRef = {};
      if (affected) {
        for (ref in refsWas) {
          if (!affected.includes(ref)) {
            refOwner.byRef[ref] = refsWas[ref];
          }
        }
      }
      options.refsWas = refsWas;
    }
    optionsIn.changed = _DomSync.performSync(options, options.targetElement);
    if (refOwner) {
      if (!affected) {
        affected = Object.keys(refsWas);
      }
      for (i = 0; i < affected.length; ++i) {
        ref = affected[i];
        targetNode = refsWas[ref];
        if (checkEqualityOptions.refsFound.has(ref) || targetNode.retainElement) {
          refOwner.byRef[ref] = targetNode;
        } else {
          lastDomConfig = targetNode.lastDomConfig;
          (_a2 = targetNode.blur) == null ? void 0 : _a2.call(targetNode);
          targetNode.remove();
          refOwner.detachRef(ref, targetNode, lastDomConfig);
        }
      }
    }
    return options.targetElement;
  }
  static performSync(options, targetElement) {
    const { domConfig, callback } = options, { lastDomConfig } = targetElement, configIsEqual = options.configEquality || _DomSync.checkEquality;
    if (!configIsEqual(domConfig, lastDomConfig, options.checkEqualityOptions, options.ignoreRefs)) {
      if (domConfig) {
        if (!domConfig.onlyChildren) {
          _DomSync.syncAttributes(domConfig, targetElement, options);
          _DomSync.syncContent(domConfig, targetElement);
        }
        if (!domConfig.keepChildren) {
          _DomSync.syncChildren(options, targetElement);
        }
      } else {
        targetElement.innerHTML = null;
        targetElement.syncIdMap = null;
      }
      targetElement.lastDomConfig = !((domConfig == null ? void 0 : domConfig.onlyChildren) && lastDomConfig) ? domConfig : {
        ...lastDomConfig,
        children: domConfig.children
      };
      return true;
    } else {
      callback == null ? void 0 : callback({
        action: "none",
        domConfig,
        targetElement
      });
    }
    return false;
  }
  //region Attributes
  static syncDataset(domConfig, targetElement) {
    const { lastDomConfig } = targetElement, sameConfig = domConfig === lastDomConfig, source = Object.keys(domConfig.dataset), target = lastDomConfig && lastDomConfig.dataset && Object.keys(lastDomConfig.dataset), delta = ArrayHelper.delta(source, target);
    let attr, i, name, value;
    for (i = 0; i < delta.onlyInA.length; i++) {
      attr = delta.onlyInA[i];
      value = domConfig.dataset[attr];
      if (value != null) {
        targetElement.setAttribute(`data-${StringHelper.hyphenate(attr)}`, value);
      }
    }
    for (i = 0; i < delta.inBoth.length; i++) {
      attr = delta.inBoth[i];
      value = domConfig.dataset[attr];
      if (sameConfig || value != lastDomConfig.dataset[attr]) {
        name = `data-${StringHelper.hyphenate(attr)}`;
        if (value == null) {
          targetElement.removeAttribute(name);
        } else {
          targetElement.setAttribute(name, value);
        }
      }
    }
    for (i = 0; i < delta.onlyInB.length; i++) {
      targetElement.removeAttribute(`data-${StringHelper.hyphenate(delta.onlyInB[i])}`);
    }
  }
  /**
   * Adds CSS classes to the element and to the cache.
   * @param {Core.helper.util.DomClassList|String|String[]|Object} cls
   * @param {HTMLElement} targetElement A previously DomSynced element
   * @internal
   */
  static addCls(cls, targetElement) {
    const { lastDomConfig } = targetElement;
    cls = DomClassList.normalize(cls, "array");
    cls.forEach((cls2) => {
      targetElement.classList.add(cls2);
      addAndCacheCls(cls2, lastDomConfig);
    });
  }
  /**
   * Adds CSS classes from the element and from the cache.
   * @param {Core.helper.util.DomClassList|String|String[]|Object} cls
   * @param {HTMLElement} targetElement A previously DomSynced element
   * @internal
   */
  static removeCls(cls, targetElement) {
    const { lastDomConfig } = targetElement;
    cls = DomClassList.normalize(cls, "array");
    cls.forEach((cls2) => {
      targetElement.classList.remove(cls2);
      removeAndUncacheCls(cls2, lastDomConfig);
    });
  }
  static syncClassList(domConfig, targetElement, lastDomConfig) {
    let cls = domConfig.className || domConfig.class, changed = false, c, currentClasses, i, k, keep, last;
    if (lastDomConfig) {
      currentClasses = DomClassList.normalize(targetElement, "array");
      cls = DomClassList.normalize(cls, "object");
      last = DomClassList.normalize(lastDomConfig.className || lastDomConfig.class, "object");
      keep = [];
      for (i = 0, k = currentClasses.length; i < k; ++i) {
        c = currentClasses[i];
        if (cls[c] || !(c in last)) {
          last[c] = 1;
          keep.push(c);
        } else {
          changed = true;
        }
      }
      for (c in cls) {
        if (!last[c]) {
          keep.push(c);
          changed = true;
        }
      }
      if (!changed) {
        return;
      }
      cls = keep.join(" ");
    } else {
      cls = DomClassList.normalize(cls);
    }
    targetElement.setAttribute("class", cls);
  }
  // Attributes as map { attr : value, ... }
  static getSyncAttributes(domConfig) {
    const attributes = {}, names = [];
    if (domConfig) {
      Object.keys(domConfig).forEach((attr) => {
        if (!syncIgnoreAttributes[attr]) {
          const name = attr.toLowerCase();
          attributes[name] = domConfig[attr];
          names.push(name);
        }
      });
    }
    return { attributes, names };
  }
  static syncAttributes(domConfig, targetElement, options) {
    const { lastDomConfig } = targetElement, sameConfig = domConfig === lastDomConfig, sourceSyncAttrs = _DomSync.getSyncAttributes(domConfig), {
      attributes: sourceAttributes,
      names: sourceNames
    } = sourceSyncAttrs, {
      attributes: targetAttributes,
      names: targetNames
    } = sameConfig ? sourceSyncAttrs : _DomSync.getSyncAttributes(lastDomConfig), {
      onlyInA: toAdd,
      onlyInB: toRemove,
      inBoth: toSync
    } = sameConfig ? {
      onlyInA: emptyArray5,
      onlyInB: emptyArray5,
      inBoth: sourceNames
    } : ArrayHelper.delta(sourceNames, targetNames);
    let attr, i;
    for (i = 0; i < toAdd.length; i++) {
      attr = toAdd[i];
      const sourceAttr = sourceAttributes[attr];
      if (attr === "style" && sourceAttr != null) {
        DomHelper.applyStyle(targetElement, sourceAttr, true);
      } else if (attr === "dataset") {
        _DomSync.syncDataset(domConfig, targetElement);
      } else if (isClass[attr]) {
        _DomSync.syncClassList(domConfig, targetElement);
      } else if (sourceAttr != null) {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }
    for (i = 0; i < toRemove.length; i++) {
      targetElement.removeAttribute(toRemove[i]);
    }
    for (i = 0; i < toSync.length; i++) {
      attr = toSync[i];
      const sourceAttr = sourceAttributes[attr], targetAttr = targetAttributes[attr];
      if (sourceAttr == null) {
        targetElement.removeAttribute(attr);
      } else if (attr === "style") {
        if (options.strict) {
          if (sameConfig) {
            _DomSync.syncStyles(targetElement, sourceAttr);
          } else if (!isEqual(sourceAttr, targetAttr, true)) {
            _DomSync.syncStyles(targetElement, sourceAttr, targetAttr);
          }
        } else if (sameConfig || !isEqual(sourceAttr, targetAttr, true)) {
          DomHelper.applyStyle(targetElement, sourceAttr, true);
        }
      } else if (attr === "dataset") {
        _DomSync.syncDataset(domConfig, targetElement);
      } else if (isClass[attr]) {
        _DomSync.syncClassList(domConfig, targetElement, options.strict && targetElement.lastDomConfig);
      } else if (sameConfig || sourceAttr !== targetAttr) {
        targetElement.setAttribute(attr, sourceAttr);
      }
    }
  }
  static syncStyles(targetElement, sourceAttr, targetAttr) {
    let styles, key, value;
    if (!targetAttr) {
      styles = sourceAttr;
    } else {
      styles = {};
      sourceAttr = DomHelper.parseStyle(sourceAttr);
      targetAttr = DomHelper.parseStyle(targetAttr);
      if (sourceAttr) {
        for (key in sourceAttr) {
          value = sourceAttr[key];
          if (targetAttr[key] !== value) {
            styles[key] = value;
          }
        }
      }
      for (key in targetAttr) {
        if (!(key in sourceAttr)) {
          styles[key] = "";
        }
      }
    }
    DomHelper.applyStyle(targetElement, styles);
  }
  //endregion
  //region Content
  static syncContent(domConfig, targetElement) {
    var _a2;
    const { html, text } = domConfig, content = text != null ? text : html;
    targetElement.didSetTextContent = false;
    if (domConfig.elementData) {
      targetElement.elementData = domConfig.elementData;
    }
    if (content instanceof DocumentFragment) {
      if (targetElement.childNodes.length === 1 && DomHelper.getChildElementCount(targetElement) === 0 && content.childNodes.length === 1 && DomHelper.getChildElementCount(content) === 0) {
        DomHelper.setInnerText(targetElement, content.firstChild.data);
      } else {
        targetElement.innerHTML = "";
        targetElement.appendChild(content);
      }
    } else if (html != null && htmlRe2.test(html)) {
      targetElement.innerHTML = String(html);
    } else if (content != null) {
      const { lastDomConfig } = targetElement;
      if (((_a2 = lastDomConfig == null ? void 0 : lastDomConfig.children) == null ? void 0 : _a2.length) || (lastDomConfig == null ? void 0 : lastDomConfig.html) && htmlRe2.test(targetElement.lastDomConfig.html)) {
        targetElement.innerHTML = content;
      } else {
        DomHelper.setInnerText(targetElement, String(content));
        targetElement.didSetTextContent = true;
      }
    }
  }
  static insertTextNode(text, targetElement, callback, refOwner, beforeElement = null) {
    const newNode = document.createTextNode(text);
    targetElement.insertBefore(newNode, beforeElement);
    if (refOwner) {
      newNode.$refOwnerId = refOwner.id;
    }
    callback == null ? void 0 : callback({
      action: "newNode",
      domConfig: text,
      targetElement: newNode
    });
  }
  static insertElement(domConfig, targetElement, targetNode, refOwner, syncIdMap, syncId, options) {
    var _a2;
    const newElement = options.ns ? document.createElementNS(options.ns, domConfig.tag || "svg") : document.createElement(domConfig.tag || "div");
    targetElement.insertBefore(newElement, targetNode);
    _DomSync.performSync(options, newElement);
    if (syncId != null) {
      syncIdMap[syncId] = newElement;
    }
    if (!domConfig.role && !domConfig.tabIndex && !domConfig["aria-hidden"] && !DomHelper.isFocusable(newElement, true) && !newElement.htmlFor) {
      newElement.setAttribute("role", "presentation");
    }
    if (refOwner) {
      newElement.$refOwnerId = refOwner.id;
      if (syncId) {
        newElement.$reference = syncId;
        refOwner.attachRef(syncId, newElement, domConfig);
      }
    }
    (_a2 = options.callback) == null ? void 0 : _a2.call(options, {
      action: "newElement",
      domConfig,
      targetElement: newElement,
      syncId
    });
  }
  //endregion
  //region Children
  static syncChildren(options, targetElement) {
    var _a2, _b, _c, _d;
    let {
      domConfig,
      syncIdField,
      callback,
      releaseThreshold,
      configEquality,
      ns: ns3,
      refOwner,
      refsWas,
      strict,
      checkEqualityOptions,
      ignoreRefs
    } = options, cleanupNodes = null, index, nextNode, syncId;
    const syncOptions = domConfig.syncOptions || {};
    if ((_a2 = domConfig.html) != null ? _a2 : domConfig.text) {
      return;
    }
    ignoreRefs = Boolean((_b = syncOptions.ignoreRefs) != null ? _b : ignoreRefs);
    if (ignoreRefs) {
      refOwner = refsWas = null;
    }
    if ("strict" in syncOptions) {
      strict = syncOptions.strict;
    }
    const newSyncIdMap = refOwner ? refOwner.byRef : {}, sourceConfigs = arraySlice2.call(domConfig.children || []), targetNodes = arraySlice2.call(targetElement.childNodes), syncIdMap = refsWas || targetElement.syncIdMap || {}, releasedIdMap = targetElement.releasedIdMap || {}, nextTarget = (remove) => {
      while (targetNodes.length && targetNodes[0].parentNode !== targetElement) {
        targetNodes.shift();
      }
      return (remove ? targetNodes.shift() : targetNodes[0]) || null;
    };
    syncIdField = syncOptions.syncIdField || syncIdField;
    strict = syncOptions.strict || strict;
    callback = syncOptions.callback || callback;
    configEquality = syncOptions.configEquality || configEquality;
    releaseThreshold = "releaseThreshold" in syncOptions ? syncOptions.releaseThreshold : releaseThreshold;
    if (syncIdField) {
      targetElement.syncIdMap = newSyncIdMap;
    }
    const syncChildOptions = {
      checkEqualityOptions: checkEqualityOptions || makeCheckEqualityOptions(),
      ignoreRefs,
      refOwner,
      refsWas,
      strict,
      syncIdField,
      releaseThreshold,
      callback,
      configEquality
    };
    while (sourceConfigs.length) {
      const sourceConfig = sourceConfigs.shift();
      syncId = null;
      if (!sourceConfig) {
        continue;
      }
      if (DomHelper.isReactElement(sourceConfig)) {
        callback({ jsx: sourceConfig, targetElement, domConfig });
        continue;
      }
      if (Array.isArray(sourceConfig)) {
        this.syncChildren({
          ...options,
          domConfig: {
            ...options.domConfig,
            children: sourceConfig
          }
        }, targetElement);
        continue;
      }
      if (sourceConfig instanceof Node) {
        nextNode = nextTarget();
        if (sourceConfig !== nextNode) {
          targetElement.insertBefore(sourceConfig, nextNode);
        }
        index = targetNodes.indexOf(sourceConfig);
        if (index > -1) {
          targetNodes.splice(index, 1);
        }
        continue;
      }
      const isTextNode = typeof sourceConfig === "string";
      syncChildOptions.domConfig = sourceConfig;
      syncChildOptions.ns = sourceConfig.ns || ns3;
      if (!isTextNode) {
        if (refOwner) {
          syncId = sourceConfig.reference;
        } else if (syncIdField && sourceConfig.dataset) {
          syncId = sourceConfig.dataset[syncIdField];
        }
        if (syncId != null && !sourceConfig.unmatched) {
          const syncTargetElement = syncIdMap[syncId] || releasedIdMap[syncId];
          if (syncTargetElement) {
            const { lastDomConfig } = syncTargetElement;
            if (syncTargetElement.retainElement) {
            } else if (_DomSync.performSync(syncChildOptions, syncTargetElement)) {
              callback == null ? void 0 : callback({
                action: "reuseOwnElement",
                domConfig: sourceConfig,
                targetElement: syncTargetElement,
                lastDomConfig,
                syncId
              });
            }
            if (sourceConfig.retainElement) {
              syncTargetElement.retainElement = true;
            }
            newSyncIdMap[syncId] = syncTargetElement;
            ArrayHelper.remove(targetNodes, syncTargetElement);
            delete releasedIdMap[syncId];
            syncTargetElement.isReleased = false;
            nextNode = nextTarget();
            if (syncTargetElement.parentNode !== targetElement || strict && syncTargetElement.nextSibling !== nextNode) {
              targetElement.insertBefore(syncTargetElement, nextNode);
            }
          } else if (strict) {
            _DomSync.insertElement(
              sourceConfig,
              targetElement,
              nextTarget(),
              refOwner,
              newSyncIdMap,
              syncId,
              syncChildOptions
            );
          } else {
            sourceConfigs.push(sourceConfig);
            sourceConfig.unmatched = true;
          }
          continue;
        }
        if (sourceConfig.unmatched) {
          delete sourceConfig.unmatched;
        }
      }
      let beforeNode = null, targetNode = null, cleanupNode;
      while (!targetNode && (cleanupNode = nextTarget(true))) {
        if (refOwner) {
          if (cleanupNode.$refOwnerId !== refOwner.id) {
            continue;
          }
          if (cleanupNode.$reference) {
            if (!strict) {
              continue;
            }
            beforeNode = cleanupNode;
            break;
          }
          targetNode = cleanupNode;
        } else if (!cleanupNode.retainElement) {
          targetNode = cleanupNode;
        }
        if (!targetNode) {
          (cleanupNodes || (cleanupNodes = [])).push(cleanupNode);
        }
      }
      if (beforeNode || !targetNode) {
        if (isTextNode) {
          _DomSync.insertTextNode(sourceConfig, targetElement, callback, refOwner, beforeNode);
        } else {
          _DomSync.insertElement(
            sourceConfig,
            targetElement,
            beforeNode,
            refOwner,
            newSyncIdMap,
            syncId,
            syncChildOptions
          );
        }
      } else {
        if (!isTextNode && targetNode.nodeType === Node.ELEMENT_NODE && (sourceConfig.tag || "div").toLowerCase() === targetNode.tagName.toLowerCase()) {
          const { lastDomConfig } = targetNode, result = _DomSync.performSync(syncChildOptions, targetNode);
          if (syncIdField && ((_c = lastDomConfig == null ? void 0 : lastDomConfig.dataset) == null ? void 0 : _c[syncIdField]) != null) {
            const lastSyncId = lastDomConfig.dataset[syncIdField];
            delete releasedIdMap[lastSyncId];
            delete syncIdMap[lastSyncId];
          }
          if (syncId != null) {
            newSyncIdMap[syncId] = targetNode;
          }
          targetNode.isReleased = false;
          result && (callback == null ? void 0 : callback({
            action: "reuseElement",
            domConfig: sourceConfig,
            targetElement: targetNode,
            lastDomConfig,
            syncId
          }));
        } else if (isTextNode && targetNode.nodeType === Node.TEXT_NODE) {
          targetNode.data = sourceConfig;
        } else {
          if (isTextNode) {
            _DomSync.insertTextNode(sourceConfig, targetElement, callback, refOwner, targetNode);
          } else {
            _DomSync.insertElement(
              sourceConfig,
              targetElement,
              targetNode,
              refOwner,
              newSyncIdMap,
              syncId,
              syncChildOptions
            );
          }
          (_d = targetNode.blur) == null ? void 0 : _d.call(targetNode);
          targetNode.remove();
        }
      }
    }
    if (targetElement.didSetTextContent && targetNodes.length === 1 && targetNodes[0].nodeType === Node.TEXT_NODE) {
      return;
    }
    if (domConfig.retainChildren) {
      return;
    }
    while (nextNode = nextTarget(true)) {
      if (!refOwner || nextNode.$refOwnerId === refOwner.id && !nextNode.$reference) {
        (cleanupNodes || (cleanupNodes = [])).push(nextNode);
      }
    }
    if (cleanupNodes) {
      _DomSync.syncChildrenCleanup(
        targetElement,
        cleanupNodes,
        newSyncIdMap,
        callback,
        refOwner,
        releaseThreshold,
        syncIdField
      );
    }
  }
  static syncChildrenCleanup(targetElement, cleanupNodes, newSyncIdMap, callback, refOwner, releaseThreshold, syncIdField) {
    var _a2;
    let releaseCount = 0, ref;
    for (const targetNode of cleanupNodes) {
      const { lastDomConfig } = targetNode;
      if (targetNode.nodeType === Element.TEXT_NODE) {
        targetNode.remove();
        continue;
      }
      if (!targetNode.retainElement) {
        if (!refOwner && syncIdField && (releaseThreshold == null || releaseCount < releaseThreshold)) {
          if (!targetNode.isReleased) {
            targetNode.className = "b-released";
            targetNode.isReleased = true;
            if (lastDomConfig == null ? void 0 : lastDomConfig.dataset) {
              if (!targetElement.releasedIdMap) {
                targetElement.releasedIdMap = {};
              }
              targetElement.releasedIdMap[lastDomConfig.dataset[syncIdField]] = targetNode;
            }
            callback == null ? void 0 : callback({
              action: "releaseElement",
              domConfig: lastDomConfig,
              lastDomConfig,
              targetElement: targetNode
            });
            if (lastDomConfig) {
              lastDomConfig.isReleased = true;
              if (lastDomConfig.className) {
                lastDomConfig.className = "b-released";
              }
              if (lastDomConfig.class) {
                lastDomConfig.class = "b-released";
              }
              if (lastDomConfig.style) {
                lastDomConfig.style = null;
              }
            }
          }
          releaseCount++;
        } else {
          (_a2 = targetNode.blur) == null ? void 0 : _a2.call(targetNode);
          targetNode.remove();
          if (refOwner) {
            ref = targetNode.$reference;
            if (ref) {
              refOwner.detachRef(ref, targetNode, lastDomConfig);
            }
          }
          if (targetElement.releasedIdMap && syncIdField && (lastDomConfig == null ? void 0 : lastDomConfig.dataset)) {
            delete targetElement.releasedIdMap[lastDomConfig.dataset[syncIdField]];
          }
          callback == null ? void 0 : callback({
            action: "removeElement",
            domConfig: targetNode.lastDomConfig,
            lastDomConfig: targetNode.lastDomConfig,
            targetElement: targetNode
          });
        }
      } else if (syncIdField) {
        if (lastDomConfig) {
          newSyncIdMap[targetNode.dataset[syncIdField]] = targetNode;
        }
      }
    }
  }
  /**
   * Remove a child element without syncing, for example when dragging an element to some other parent.
   * Removes it both from DOM and the parent elements syncMap
   * @param {HTMLElement} parentElement
   * @param {HTMLElement} childElement
   */
  static removeChild(parentElement, childElement) {
    if (parentElement.contains(childElement)) {
      const syncIdMap = parentElement.syncIdMap;
      if (syncIdMap) {
        const index = Object.values(syncIdMap).indexOf(childElement);
        if (index > -1) {
          delete syncIdMap[Object.keys(syncIdMap)[index]];
        }
      }
      parentElement.removeChild(childElement);
    }
  }
  /**
   * Adds a child element without syncing, making it properly available for later syncs. Useful for example
   * when dragging and dropping an element from some other parent.
   * @param {HTMLElement} parentElement
   * @param {HTMLElement} childElement
   * @param {String|Number} syncId
   */
  static addChild(parentElement, childElement, syncId) {
    parentElement.appendChild(childElement);
    if (!parentElement.syncIdMap) {
      parentElement.syncIdMap = {};
    }
    parentElement.syncIdMap[syncId] = childElement;
  }
  /**
   * Get a child element using a dot separated syncIdMap path.
   *
   * ```javascript
   * DomSync.getChild(eventWrap, 'event.percentBar');
   * ```
   *
   * @param {HTMLElement} element "root" element, under which the path starts
   * @param {String} path Dot '.' separated path of syncIdMap entries
   * @returns {HTMLElement} Child element or `null` if path did not match any element
   */
  static getChild(element, path) {
    var _a2;
    const syncIds = String(path).split(".");
    for (const id of syncIds) {
      element = (_a2 = element == null ? void 0 : element.syncIdMap) == null ? void 0 : _a2[id];
      if (!element) {
        return null;
      }
    }
    return element;
  }
  //endregion
};
DomSync._$name = "DomSync";

// ../Core/lib/Core/helper/util/Fullscreen.js
var Fullscreen = class {
  static init() {
    const fnNames = ["fullscreenEnabled", "requestFullscreen", "exitFullscreen", "fullscreenElement"], prefixFn = (prefix) => fnNames.map((fn2) => {
      let result = prefix + StringHelper.capitalize(fn2);
      if (prefix === "moz") {
        result = result.replace("screen", "Screen");
        if ("mozCancelFullScreen" in document && fn2 === "exitFullscreen") {
          result = "mozCancelFullScreen";
        }
      }
      return result;
    });
    this.functions = "fullscreenEnabled" in document && fnNames || "webkitFullscreenEnabled" in document && prefixFn("webkit") || "mozFullScreenEnabled" in document && prefixFn("moz") || "msFullscreenEnabled" in document && prefixFn("ms") || [];
    const eventNames = [
      "fullscreenchange",
      "fullscreenerror"
    ], msEventNames = [
      "MSFullscreenChange",
      "MSFullscreenError"
    ], prefixEvt = (prefix) => eventNames.map((eventName) => prefix + StringHelper.capitalize(eventName));
    this.events = "fullscreenEnabled" in document && eventNames || "webkitFullscreenEnabled" in document && prefixEvt("webkit") || "mozFullscreenEnabled" in document && prefixEvt("moz") || "msFullscreenEnabled" in document && msEventNames || [];
    this.onFullscreenChange(this.onInternalFullscreenChange.bind(this));
  }
  /**
   * True if the fullscreen mode is supported and enabled, false otherwise
   * @property {Boolean}
   */
  static get enabled() {
    return Boolean(this.functions[0] && document[this.functions[0]]);
  }
  /**
   * Request entering the fullscreen mode.
   * @param {HTMLElement} element Element to be displayed fullscreen
   * @returns {Promise} A promise which is resolved with a value of undefined when the transition to full screen is complete.
   */
  static async request(element) {
    return this.functions[1] && (element == null ? void 0 : element[this.functions[1]]());
  }
  /**
   * Exit the previously entered fullscreen mode.
   * @returns {Promise} A promise which is resolved once the user agent has finished exiting full-screen mode
   */
  static async exit() {
    return this.functions[2] && document[this.functions[2]]();
  }
  /**
   * True if fullscreen mode is currently active, false otherwise
   * @property {Boolean}
   */
  static get isFullscreen() {
    return !!this.element;
  }
  static get element() {
    return this.functions[3] && document[this.functions[3]];
  }
  /**
   * Installs the passed listener to fullscreenchange event
   * @param {Function} fn The listener to install
   */
  static onFullscreenChange(fn2) {
    if (this.events[0]) {
      document.addEventListener(this.events[0], fn2);
    }
  }
  /**
   * Uninstalls the passed listener from fullscreenchange event
   * @param {Function} fn
   */
  static unFullscreenChange(fn2) {
    if (this.events[0]) {
      document.removeEventListener(this.events[0], fn2);
    }
  }
  // Make sure the floatRoot is added to any element going fullscreen
  static onInternalFullscreenChange() {
    const me = this, { element: fullscreenElement } = me;
    if (fullscreenElement) {
      if (!fullscreenElement.closest(".b-floatroot")) {
        const rootElement = DomHelper.getRootElement(fullscreenElement), { floatRoot } = rootElement;
        if (floatRoot) {
          me._floatRoot = floatRoot;
          me._oldParent = floatRoot.parentElement;
          fullscreenElement.appendChild(floatRoot);
        }
      }
    } else {
      if (me._floatRoot) {
        me._oldParent.appendChild(me._floatRoot);
      }
      me._oldParent = null;
      me._floatRoot = null;
    }
  }
};
Fullscreen.init();
Fullscreen._$name = "Fullscreen";

// ../Core/lib/Core/helper/ResizeMonitor.js
var resizeFireTimer = null;
var resizedQueue = [];
var isAbsolutelyPositioned = (n) => {
  var _a2;
  return n.nodeType === n.ELEMENT_NODE && ((_a2 = n.ownerDocument.defaultView) == null ? void 0 : _a2.getComputedStyle(n).getPropertyValue("position")) === "absolute";
};
var ResizeMonitor = class _ResizeMonitor {
  /**
   * Adds a resize listener to the passed element which is called when the element
   * is resized by layout.
   * @param {HTMLElement} element The element to listen for resizing.
   * @param {Function} handler The handling function. Will be passed the element.
   */
  static addResizeListener(element, handler) {
    const me = this;
    if (element === document || element === globalThis) {
      element = document.body;
    }
    if (element.nodeType === element.DOCUMENT_FRAGMENT_NODE) {
      element = element.host;
    }
    if (!element.classList.contains("b-resize-monitored")) {
      element.classList.add("b-resize-monitored");
      element._bResizemonitor = {
        handlers: []
      };
    }
    if (element === document.body) {
      if (!me.hasWindowResizeListener) {
        globalThis.addEventListener("resize", me.onWindowResize);
        me.hasWindowResizeListener = true;
      }
    } else if (globalThis.ResizeObserver) {
      if (!me.resizeObserver) {
        me.resizeObserver = new ResizeObserver(me.onElementResize);
      }
      me.resizeObserver.observe(element);
    } else {
      element.classList.add("b-no-resizeobserver");
      const [monitors, expand, shrink] = DomHelper.createElement({
        parent: element,
        className: "b-resize-monitors",
        children: [{
          className: "b-resize-monitor-expand"
        }, {
          className: "b-resize-monitor-shrink"
        }]
      }, { returnAll: true });
      expand.scrollLeft = expand.scrollTop = shrink.scrollLeft = shrink.scrollTop = 1e6;
      expand.addEventListener("scroll", me.onSizeMonitorScroll, true);
      shrink.addEventListener("scroll", me.onSizeMonitorScroll, true);
      (handler.targetMutationMonitor = new MutationObserver((m) => {
        const addedNodes = [], removedNodes = [];
        for (const mr of m) {
          if (mr.type === "childList") {
            addedNodes.push.apply(addedNodes, mr.addedNodes);
            removedNodes.push.apply(removedNodes, mr.removedNodes);
          }
        }
        const changedNodes = [
          ...addedNodes.filter((r) => !removedNodes.includes(r)),
          ...removedNodes.filter((r) => !addedNodes.includes(r))
        ];
        if (changedNodes.length === 0) {
          return;
        }
        if (changedNodes.length > 0 && changedNodes.every(isAbsolutelyPositioned)) {
          return;
        }
        expand.dispatchEvent(new CustomEvent("scroll", { bubbles: false }));
      })).observe(element, {
        childList: true,
        subtree: true
      });
      handler.monitorElement = monitors;
    }
    element._bResizemonitor.handlers.push(handler);
  }
  /**
   * Removes a resize listener from the passed element.
   * @param {HTMLElement} element The element to listen for resizing.
   * @param {Function} handler The handling function to remove.
   */
  static removeResizeListener(element, handler) {
    if (element) {
      if (element === document || element === globalThis) {
        element = document.body;
      }
      const resizeMonitor = element._bResizemonitor;
      let listenerCount = 0;
      if (resizeMonitor && resizeMonitor.handlers) {
        ArrayHelper.remove(resizeMonitor.handlers, handler);
        listenerCount = resizeMonitor.handlers.length;
      }
      if (!listenerCount) {
        element.classList.remove("b-resize-monitored");
        if (this.resizeObserver) {
          this.resizeObserver.unobserve(element);
        } else {
          if (handler.monitorElement) {
            handler.monitorElement.remove();
            handler.monitorElement = null;
          }
          if (handler.targetMutationMonitor) {
            handler.targetMutationMonitor.disconnect();
          }
        }
      }
    }
  }
  static onElementResize(entries) {
    for (const resizeObserverEntry of entries) {
      const resizedElement = resizeObserverEntry.target, resizeMonitor = resizedElement._bResizemonitor, newRect = resizeObserverEntry.contentRect || resizedElement.getBoundingClientRect();
      if (hasLayout(resizedElement)) {
        if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
          const oldRect = resizeMonitor.rectangle;
          resizeMonitor.rectangle = newRect;
          for (const resizeHandler of resizeMonitor.handlers) {
            resizeHandler(resizedElement, oldRect, newRect);
          }
        }
      }
    }
  }
  static onSizeMonitorScroll(e) {
    var _a2;
    if (e.target.isConnected || ((_a2 = document.body) == null ? void 0 : _a2.contains(e.target))) {
      e.stopImmediatePropagation();
      const monitorNode = e.target.parentNode, resizedElement = monitorNode.parentNode, resizeMonitor = resizedElement._bResizemonitor, newRect = resizedElement.getBoundingClientRect();
      if (!resizeMonitor.rectangle || newRect.width !== resizeMonitor.rectangle.width || newRect.height !== resizeMonitor.rectangle.height) {
        resizedQueue.push([resizedElement, resizeMonitor.rectangle, newRect]);
        resizeMonitor.rectangle = newRect;
        if (!resizeFireTimer) {
          resizeFireTimer = requestAnimationFrame(_ResizeMonitor.fireResizeEvents);
        }
      }
      monitorNode.firstChild.scrollLeft = monitorNode.firstChild.scrollTop = monitorNode.childNodes[1].scrollTop = monitorNode.childNodes[1].scrollLeft = 1e6;
    }
  }
  static onWindowResize(e) {
    const resizedElement = document.body, resizeMonitor = resizedElement._bResizemonitor, oldRect = resizeMonitor.rectangle;
    resizeMonitor.rectangle = document.documentElement.getBoundingClientRect();
    for (const resizeHandler of resizeMonitor.handlers) {
      resizeHandler(resizedElement, oldRect, resizeMonitor.rectangle);
    }
  }
  static fireResizeEvents() {
    for (const resizedEntry of resizedQueue) {
      for (const resizeHandler of resizedEntry[0]._bResizemonitor.handlers) {
        if (resizedEntry[0].offsetParent) {
          resizeHandler.apply(this, resizedEntry);
        }
      }
    }
    resizeFireTimer = null;
    resizedQueue.length = 0;
  }
  static removeGlobalListeners() {
    globalThis.removeEventListener("resize", this.onWindowResize);
  }
};
ResizeMonitor._$name = "ResizeMonitor";

// ../Core/lib/Core/helper/util/Scroller.js
var scrollLiterals = {
  auto: "auto",
  true: "auto",
  false: "hidden",
  "hidden-scroll": "auto",
  clip: BrowserHelper.supportsOverflowClip ? "clip" : "hidden"
};
var scrollerCls = "b-widget-scroller";
var defaultScrollOptions = {
  block: "nearest"
};
var immediatePromise3 = Promise.resolve();
var scrollPromise = (element) => new Promise((resolve) => EventHelper.on({
  element: element === document.documentElement ? globalThis : element,
  scroll: resolve,
  once: true
}));
var xAxis = {
  x: 1
};
var isScrollable = {
  auto: 1,
  scroll: 1
};
var isScrollableConfig = {
  true: 1,
  auto: 1
};
var allScroll = {
  overflowX: "auto",
  overflowY: "auto"
};
var normalizeEdgeOffset = (edgeOffset) => {
  var _a2, _b, _c, _d;
  let top, bottom, start, end;
  if (!edgeOffset) {
    top = bottom = start = end = 0;
  } else if (typeof edgeOffset === "number") {
    top = bottom = start = end = edgeOffset;
  } else {
    top = (_a2 = edgeOffset.top) != null ? _a2 : 0;
    bottom = (_b = edgeOffset.bottom) != null ? _b : 0;
    start = (_c = edgeOffset.start) != null ? _c : 0;
    end = (_d = edgeOffset.end) != null ? _d : 0;
  }
  return { top, bottom, start, end };
};
var Scroller = class _Scroller extends Delayable_default(Events_default(Base)) {
  static get configurable() {
    return {
      /**
       * The widget which is to scroll.
       * @config {Core.widget.Widget}
       */
      widget: null,
      /**
       * The element which is to scroll. Defaults to the {@link Core.widget.Widget#property-overflowElement} of
       * the configured {@link #config-widget}
       * @config {HTMLElement}
       */
      element: {
        $config: {
          nullify: true
        },
        value: null
      },
      /**
       * The element, or a selector which identifies a descendant element whose size
       * will affect the scroll range.
       * @config {HTMLElement|String}
       */
      contentElement: {
        $config: {
          nullify: true
        },
        value: null
      },
      /**
       * How to handle overflowing in the `X` axis.
       * May be:
       * * `'auto'`
       * * `'visible'`
       * * `'hidden'`
       * * `'scroll'`
       * * `'hidden-scroll'` Meaning scrollable from the UI but with no scrollbar,
       * for example a grid header. Only on platforms which support this feature.
       * * `true` - meaning `'auto'`
       * * `false` - meaning `'hidden'`
       * * `clip` - Uses `clip` where supported. Where not supported it uses
       * `hidden` and rolls back any detected scrolls in this dimension.
       * @config {String|Boolean}
       */
      overflowX: null,
      /**
       * How to handle overflowing in the `Y` axis.
       * May be:
       * * `'auto'`
       * * `'visible'`
       * * `'hidden'`
       * * `'scroll'`
       * * `'hidden-scroll'` Meaning scrollable from the UI but with no scrollbar.
       * Only on platforms which support this feature.
       * * `true` - meaning `'auto'`
       * * `false` - meaning `'hidden'`
       * * `clip` - Uses `clip` where supported. Where not supported it uses
       * `hidden` and rolls back any detected scrolls in this dimension.
       * @config {String|Boolean}
       */
      overflowY: null,
      /**
       * If configured as `true`, the {@link #config-element} is not scrolled but is translated using CSS
       * transform when controlled by this class's API. Scroll events are fired when the element is translated.
       * @default
       * @config {Boolean}
       */
      translate: null,
      x: 0,
      y: 0,
      rtlSource: null,
      /**
       * Configure as `true` to immediately sync partner scrollers when being synced by a controlling partner
       * instead of waiting for our own `scroll` event to pass the scroll on to partners.
       * @prp {Boolean}
       * @default false
       */
      propagateSync: null
    };
  }
  static get delayable() {
    return {
      onScrollEnd: {
        type: "buffer",
        delay: 100
      }
    };
  }
  /**
   * Fired when scrolling happens on this Scroller's element. The event object is a native `scroll` event
   * with the described extra properties injected.
   * @event scroll
   * @param {Core.widget.Widget} widget The owning Widget which has been scrolled.
   * @param {Core.helper.util.Scroller} source This Scroller
   */
  /**
   * Fired when scrolling finished on this Scroller's element. The event object is the last native `scroll` event
   * fires by the element with the described extra properties injected.
   * @event scrollend
   * @param {Core.widget.Widget} widget The owning Widget which has been scrolled.
   * @param {Core.helper.util.Scroller} source This Scroller
   */
  /**
   * The `overflow-x` setting for the widget. `true` means `'auto'`.
   * @member {Boolean|String} overflowX
   */
  /**
   * The `overflow-y` setting for the widget. `true` means `'auto'`.
   * @member {Boolean|String} overflowY
   */
  get isRTL() {
    var _a2;
    return Boolean((_a2 = this.rtlSource) == null ? void 0 : _a2.rtl);
  }
  syncOverflowState() {
    const me = this, { element } = me, {
      hasOverflowX,
      hasOverflowY
    } = me, x = me.hasOverflowX = element.scrollWidth > element.clientWidth, y = me.hasOverflowY = element.scrollHeight > element.clientHeight;
    if (hasOverflowX !== x || hasOverflowY !== y) {
      const classList = new DomClassList(element.classList, {
        "b-horizontal-overflow": x,
        "b-vertical-overflow": y
      });
      DomHelper.syncClassList(element, classList);
      if (!me.isConfiguring) {
        me.trigger("overflowChange", { x, y });
      }
    }
  }
  /**
   * Returns `true` if there is overflow in the specified axis.
   * @param {'x'|'y'} [axis='y'] The axis to check scrollbar for. Note that this is subtly different to asking
   * whether an axis is showing a space-consuming scrollbar, see {@link #function-hasScrollbar}.
   * @internal
   */
  hasOverflow(axis = "y") {
    const me = this, overflowSetting = me[`overflow${axis.toUpperCase()}`], otherAxis = me[`overflow${axis === "y" ? "x" : "y"}`];
    if (!DomHelper.scrollBarWidth || !isScrollableConfig[overflowSetting] || otherAxis === "hidden-scroll") {
      const dimension = axis === "y" ? "Height" : "Width";
      return me[`scroll${dimension}`] > me[`client${dimension}`];
    }
    return me[`hasOverflow${axis.toUpperCase()}`];
  }
  /**
   * Returns `true` if there is a *space-consuming* scrollbar controlling scroll in the specified axis.
   * @param {'x'|'y'} [axis='y'] The axis to check scrollbar for. Note that this is subtly different to asking
   * whether an axis *has any* overflow, see {@link #function-hasOverflow}.
   * @internal
   */
  hasScrollbar(axis = "y") {
    const { element } = this;
    if (element && DomHelper.scrollBarWidth) {
      const vertical = axis === "y", dimension = vertical ? "Width" : "Height", clientSize = element[`client${dimension}`], borderSize = parseInt(DomHelper.getStyleValue(element, `border${vertical ? "Left" : "Top"}Width`)) + parseInt(DomHelper.getStyleValue(element, `border${vertical ? "Right" : "Bottom"}Width`)), difference = element[`offset${dimension}`] - borderSize - clientSize;
      return Math.abs(difference - DomHelper.scrollBarWidth) < 2;
    }
  }
  /**
   * Partners this Scroller with the passed scroller in order to sync the scrolling position in the passed axes
   * @param {Core.helper.util.Scroller} otherScroller
   * @param {String|Object} [axes='x'] `'x'` or `'y'` or `{x: true/false, y: true/false}` axes to sync
   * @param {Boolean} [axes.x] Sync horizontal scroll
   * @param {Boolean} [axes.y] Sync vertical scroll
   */
  addPartner(otherScroller, axes = xAxis) {
    const me = this;
    if (typeof axes === "string") {
      axes = {
        [axes]: 1
      };
    }
    if (!me.partners) {
      me.partners = {};
    }
    me.partners[otherScroller.id] = {
      scroller: otherScroller,
      axes
    };
    if (axes.x) {
      otherScroller.x = me.x;
    }
    if (axes.y) {
      otherScroller.y = me.y;
    }
    if (!otherScroller.isPartneredWith(me)) {
      otherScroller.addPartner(me, axes);
    }
  }
  eachPartner(fn2) {
    const { partners } = this;
    if (partners) {
      Object.values(partners).forEach(fn2);
    }
  }
  /**
   * Breaks the link between this Scroller and the passed Scroller set up by the
   * {@link #function-addPartner} method.
   * @param {Core.helper.util.Scroller} otherScroller The Scroller to unlink from.
   */
  removePartner(otherScroller) {
    if (otherScroller && this.isPartneredWith(otherScroller)) {
      delete this.partners[otherScroller.id];
      otherScroller.removePartner(this);
    }
  }
  isPartneredWith(otherScroller) {
    var _a2;
    return Boolean((_a2 = this.partners) == null ? void 0 : _a2[otherScroller.id]);
  }
  /**
   * Breaks the link between this Scroller and all other Scrollers set up by the
   * {@link #function-addPartner} method.
   * @internal
   */
  clearPartners() {
    if (this.partners) {
      Object.values(this.partners).forEach((otherScroller) => otherScroller.scroller.removePartner(this));
    }
  }
  /**
   * Scrolls the passed element or {@link Core.helper.util.Rectangle} into view according to the passed options.
   * @param {HTMLElement|Core.helper.util.Rectangle} element The element or a Rectangle in document space to scroll
   * into view.
   * @param {BryntumScrollOptions} [options] How to scroll.
   * @returns {Promise} A promise which is resolved when the element has been scrolled into view.
   */
  async scrollIntoView(element, options = defaultScrollOptions) {
    const me = this, { isRectangle } = element, originalRect = isRectangle ? element : Rectangle.from(element), { xDelta, yDelta } = me.getDeltaTo(element, options), result = me.scrollBy(xDelta, yDelta, options);
    if (options.highlight || options.focus) {
      result.then(() => {
        var _a2, _b;
        element = isRectangle ? originalRect.translate(-xDelta, -yDelta) : (_b = (_a2 = options.elementAfterScroll) == null ? void 0 : _a2.call(options)) != null ? _b : element;
        if (options.highlight) {
          if (isNaN(options.highlight)) {
            (me.widget || me).callback(options.highlight, null, [element]);
          } else {
            DomHelper.highlight(element, me);
          }
        }
        if (options.focus) {
          DomHelper.focusWithoutScrolling(element);
        }
      });
    }
    return result;
  }
  /**
   * Scrolls the passed element into view according to the passed options.
   * @param {HTMLElement} element The element in document space to scroll into view.
   * @param {BryntumScrollOptions} [options] How to scroll.
   * @returns {Promise} A promise which is resolved when the element has been scrolled into view.
   */
  static async scrollIntoView(element, options = defaultScrollOptions, rtl = false) {
    const target = Rectangle.from(element), animate = typeof options === "object" ? options.animate : options, scrollable = _Scroller._globalScroller || (_Scroller._globalScroller = new _Scroller()), deltas = [];
    scrollable.rtlSource = { rtl };
    let totalX = 0, totalY = 0, result;
    for (let ancestor = element.parentNode; ancestor.nodeType === Node.ELEMENT_NODE; ancestor = ancestor.parentNode) {
      if (ancestor === document.body && ancestor !== document.scrollingElement) {
        continue;
      }
      const style = ancestor === document.scrollingElement ? allScroll : ancestor.ownerDocument.defaultView.getComputedStyle(ancestor);
      if (options.y !== false && isScrollable[style.overflowY] && ancestor.scrollHeight > ancestor.clientHeight || options.x !== false && isScrollable[style.overflowX] && ancestor.scrollWidth > ancestor.clientWidth) {
        scrollable.element = ancestor;
        scrollable.positionDirty = true;
        const { xDelta, yDelta } = scrollable.getDeltaTo(target, options);
        if (xDelta || yDelta) {
          deltas.push({
            element: ancestor,
            x: ancestor.scrollLeft,
            y: ancestor.scrollTop,
            xDelta,
            yDelta
          });
          target.translate(-xDelta, -yDelta);
          totalX += xDelta;
          totalY += yDelta;
        }
      }
    }
    if (deltas.length) {
      const absX = Math.abs(totalX), absY = Math.abs(totalY);
      let duration = animate && (typeof animate === "number" ? animate : typeof animate.duration === "number" ? animate.duration : 300);
      if (duration && (absX > 10 || absY > 10)) {
        if (Math.max(absX, absY) < 50) {
          duration = Math.min(duration, 500);
        }
        result = scrollable.scrollAnimation = FunctionHelper.animate(duration, (progress) => {
          const isEnd = progress === 1;
          for (const { element: element2, x, y, xDelta, yDelta } of deltas) {
            scrollable.element = element2;
            if (xDelta) {
              scrollable.x = Math[rtl ? "min" : "max"](x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
            }
            if (yDelta) {
              scrollable.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
            }
          }
        }, null, animate.easing);
        result.then(() => {
          scrollable.scrollAnimation = null;
        });
      } else {
        for (const { element: element2, xDelta, yDelta } of deltas) {
          element2.scrollTop += yDelta;
          element2.scrollLeft += xDelta;
        }
        result = scrollPromise(deltas[deltas.length - 1].element);
      }
    } else {
      result = immediatePromise3;
    }
    if (options.highlight || options.focus) {
      result.then(() => {
        if (options.highlight) {
          if (isNaN(options.highlight)) {
            scrollable.callback(options.highlight, null, [element]);
          } else {
            DomHelper.highlight(element, scrollable);
          }
        }
        if (options.focus) {
          element.focus();
        }
      });
    }
    return result;
  }
  /**
   * Scrolls by the passed deltas according to the passed options.
   * @param {Number} [xDelta=0] How far to scroll in the X axis.
   * @param {Number} [yDelta=0] How far to scroll in the Y axis.
   * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
   * @param {Boolean} [options.silent] Set to `true` to suspend `scroll` events during scrolling.
   * @param {AnimateScrollOptions|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @returns {Promise} A promise which is resolved when the scrolling has finished.
   */
  scrollBy(xDelta = 0, yDelta = 0, options = defaultScrollOptions) {
    const me = this, animate = typeof options === "object" ? options.animate : options, absX = Math.abs(xDelta), absY = Math.abs(yDelta);
    if (me.scrollAnimation) {
      me.scrollAnimation.cancel();
      me.scrollAnimation = null;
    }
    if (xDelta || yDelta) {
      me.silent = options.silent;
    }
    let duration = animate && (typeof animate === "number" ? animate : typeof animate.duration === "number" ? animate.duration : 300);
    if (duration && (absX > 10 || absY > 10)) {
      const { x, y } = me;
      let lastX = x, lastY = y;
      if (Math.max(absX, absY) < 50) {
        duration = Math.min(duration, 500);
      }
      me.scrollAnimation = FunctionHelper.animate(duration, (progress) => {
        var _a2, _b;
        const isEnd = progress === 1;
        if (xDelta) {
          if (Math.abs(me.x - lastX) > 1 && !options.force) {
            return (_a2 = me.scrollAnimation) == null ? void 0 : _a2.cancel();
          }
          me.x = Math.max(x + (isEnd ? xDelta : Math.round(xDelta * progress)), 0);
        }
        if (yDelta) {
          if (Math.abs(me.y - lastY) > 1 && !options.force) {
            return (_b = me.scrollAnimation) == null ? void 0 : _b.cancel();
          }
          me.y = Math.max(y + (isEnd ? yDelta : Math.round(yDelta * progress)), 0);
        }
        lastX = me.x;
        lastY = me.y;
      }, me, animate.easing);
      me.element.classList.add("b-scrolling");
      me.scrollAnimation.then(() => {
        if (!me.isDestroyed) {
          me.element.classList.remove("b-scrolling");
          me.scrollAnimation = null;
        }
      });
      return me.scrollAnimation;
    } else {
      if (xDelta || yDelta) {
        const xBefore = me.x, yBefore = me.y;
        if (Math.round(absX) >= 1) {
          me.x += xDelta;
        }
        if (Math.round(absY) >= 1) {
          me.y += yDelta;
        }
        if (me.x !== xBefore || me.y !== yBefore) {
          return scrollPromise(me.element);
        }
      }
      return immediatePromise3;
    }
  }
  /**
   * Scrolls to the passed position according to the passed options.
   * @param {Number} [toX=0] Where to scroll to in the X axis.
   * @param {Number} [toY=0] Where to scroll to in the Y axis.
   * @param {Object|Boolean} [options] How to scroll. May be passed as `true` to animate.
   * @param {AnimateScrollOptions|Boolean|Number} [options.animate] Set to `true` to animate the scroll by 300ms,
   * or the number of milliseconds to animate over, or an animation config object.
   * @returns {Promise} A promise which is resolved when the scrolling has finished.
   */
  async scrollTo(toX, toY, options) {
    const { x, y } = this, xDelta = toX == null ? 0 : toX - x, yDelta = toY == null ? 0 : toY - y;
    this.scrollingToCenter = options == null ? void 0 : options.scrollingToCenter;
    return this.scrollBy(xDelta, yDelta, options);
  }
  doDestroy() {
    var _a2, _b;
    const me = this;
    if (me._element) {
      me._element.removeEventListener("scroll", me.scrollHandler);
      (_a2 = me.wheelListenerRemover) == null ? void 0 : _a2.call(me);
    }
    (_b = me.scrollAnimation) == null ? void 0 : _b.cancel();
    Object.values(me.partners || {}).forEach(({ scroller }) => scroller.removePartner(me));
    super.doDestroy();
  }
  /**
   * Respond to style changes to monitor scroll *when this Scroller is in `translate: true` mode.*
   * @param {Object[]} mutations The ElementMutation records.
   * @private
   */
  onElMutation(mutations) {
    const me = this, [x, y] = DomHelper.getTranslateXY(me.element);
    if (me._x !== -x || me.y !== -y) {
      const scrollEvent = new CustomEvent("scroll", { bubbles: true });
      Object.defineProperty(scrollEvent, "target", {
        get: () => me.element
      });
      me.onScroll(scrollEvent);
    }
  }
  onElResize() {
    const me = this, { widget } = me;
    if (!(widget == null ? void 0 : widget.isAnimating)) {
      me.syncOverflowState();
    } else if (widget.findListener("animationend", "onElResize", me) === -1) {
      widget.ion({
        animationEnd: "onElResize",
        thisObj: me,
        once: true
      });
    }
  }
  onScroll(e) {
    const me = this, { _x, _y, element } = me;
    let vetoed = 0;
    if (me.overflowX === "clip" && element.scrollLeft !== _x) {
      element.scrollLeft = _x;
      ++vetoed;
    }
    if (me.overflowY === "clip" && element.scrollTop !== _y) {
      element.scrollTop = _y;
      ++vetoed;
    }
    if (vetoed === 2) {
      return;
    }
    if (!me.widget || !me.widget.isDestroyed) {
      me.positionDirty = true;
      if (!element.classList.contains("b-scrolling")) {
        element.classList.add("b-scrolling");
      }
      e.widget = me.widget;
      e.scrollingToCenter = me.scrollingToCenter;
      if (!me.silent) {
        me.trigger("scroll", e);
      }
      me.syncPartners();
      me.controllingPartner = null;
      me.onScrollEnd(e);
    }
  }
  /**
   * Syncs all attached scrolling partners with the scroll state of this Scroller.
   * @param {Boolean} force Allow this to sync a partner which is controlling this via a sync.
   * @param {Boolean} [propagate] Propagate any change immediately onwards through
   * further linked partners immediately rather than waiting for our own scroll event.
   * @internal
   */
  syncPartners(force, propagate = this.propagateSync) {
    const me = this;
    if (me.partners) {
      Object.values(me.partners).forEach(({ axes, scroller }) => {
        if (scroller !== me.controllingPartner || force) {
          if (scroller.sync(me, axes) && propagate) {
            scroller.syncPartners(force, propagate);
          }
        }
      });
    }
  }
  onScrollEnd(e) {
    const me = this;
    if (me.silent) {
      me.silent = false;
    }
    me.trigger("scrollEnd", e);
    me.scrollingToCenter = false;
    me.controllingPartner = null;
    me.element.classList.remove("b-scrolling");
  }
  /**
   * Returns the xDelta and yDelta values in an object from the current scroll position to the
   * passed element or Rectangle.
   * @param {HTMLElement|Core.helper.util.Rectangle} element The element or a Rectangle to calculate deltas for.
   * @param {Object} [options] How to scroll.
   * @param {'start'|'end'|'center'|'nearest'} [options.block] How far to scroll the element.
   * @param {Number} [options.edgeOffset] A margin around the element or rectangle to bring into view.
   * @param {Boolean} [options.x] Pass as `false` to disable scrolling in the `X` axis.
   * @param {Boolean} [options.y] Pass as `false` to disable scrolling in the `Y` axis.
   * @param {Boolean} [options.constrainToScrollable=true] Pass as `false` to allow offsets beyond the available scroll range.
   * @returns {Object} `{ xDelta, yDelta }`
   * @internal
   */
  getDeltaTo(element, options) {
    const me = this;
    if (!me.viewport) {
      return {
        xDelta: 0,
        yDelta: 0
      };
    }
    const {
      x,
      y,
      scrollWidth,
      scrollHeight,
      isRTL
    } = me, elementRect = element instanceof Rectangle ? element : Rectangle.from(element), block = options.block || "nearest", scrollerRect = me.viewport, edgeOffset = normalizeEdgeOffset(options.edgeOffset), xOffset = scrollerRect.width >= elementRect.width + (edgeOffset.start + edgeOffset.end) ? edgeOffset : { start: 0, end: 0 }, yOffset = scrollerRect.height >= elementRect.height + (edgeOffset.top + edgeOffset.bottom) ? edgeOffset : { top: 0, bottom: 0 }, constrainTo = new Rectangle(
      isRTL ? scrollerRect.right - -x - scrollWidth : scrollerRect.x - x,
      scrollerRect.y - y,
      scrollWidth,
      scrollHeight
    ), elRect = elementRect.clone().adjust(-xOffset.start, -yOffset.top, xOffset.end, yOffset.bottom).constrainTo(constrainTo), targetRect = elRect.clone(), xFactor = me.isRTL ? -1 : 1;
    let xDelta = 0, yDelta = 0;
    if (block === "start") {
      targetRect.moveTo(scrollerRect.x + (me.isRTL ? scrollerRect.width - targetRect.width : 0), scrollerRect.y);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else if (block === "end") {
      targetRect.moveTo(scrollerRect.x + (!me.isRTL ? scrollerRect.width - targetRect.width : 0), scrollerRect.bottom - targetRect.height);
      xDelta = elRect.x - targetRect.x;
      yDelta = elRect.y - targetRect.y;
    } else if (block === "center") {
      const center = scrollerRect.center;
      targetRect.moveTo(center.x - targetRect.width / 2, center.y - targetRect.height / 2);
      xDelta = xDelta || elRect.x - targetRect.x;
      yDelta = yDelta || elRect.y - targetRect.y;
    } else {
      if (targetRect.width > scrollerRect.width) {
        xDelta = targetRect.x - scrollerRect.x;
      } else {
        if (targetRect.right > scrollerRect.right) {
          xDelta = targetRect.right - scrollerRect.right;
        } else if (targetRect.x < scrollerRect.x) {
          xDelta = targetRect.x - scrollerRect.x;
        }
      }
      if (targetRect.height > scrollerRect.height) {
        yDelta = targetRect.y - scrollerRect.y;
      } else {
        if (targetRect.bottom > scrollerRect.bottom) {
          yDelta = targetRect.bottom - scrollerRect.bottom;
        } else if (targetRect.y < scrollerRect.y) {
          yDelta = targetRect.y - scrollerRect.y;
        }
      }
    }
    xDelta = xFactor * Math.round(xDelta);
    yDelta = Math.round(yDelta);
    if (options.constrainToScrollable !== false) {
      xDelta = Math.max(Math.min(xDelta, me.maxX - x), -x);
      yDelta = Math.max(Math.min(yDelta, me.maxY - y), -y);
    }
    return {
      xDelta: options.x === false ? 0 : xDelta,
      yDelta: options.y === false ? 0 : yDelta
    };
  }
  /**
   * A {@link Core/helper/util/Rectangle} describing the bounds of the scrolling viewport.
   * @property {Core.helper.util.Rectangle}
   */
  get viewport() {
    return Rectangle.client(this.element);
  }
  updateWidget(widget) {
    this.rtlSource = this.owner = widget;
  }
  updateElement(element, oldElement) {
    var _a2;
    const me = this;
    if (me === _Scroller._globalScroller) {
      me._element = element;
      me.positionDirty = true;
      return;
    }
    const scrollHandler = me.scrollHandler || (me.scrollHandler = me.onScroll.bind(me)), resizeHandler = me.resizeHandler || (me.resizeHandler = me.onElResize.bind(me));
    if (oldElement) {
      if (me.translate) {
        (_a2 = me.mutationObserver) == null ? void 0 : _a2.disconnect();
      } else {
        oldElement.removeEventListener("scroll", scrollHandler);
        oldElement.classList.remove(scrollerCls);
        oldElement.style.overflowX = oldElement.style.overflowY = "";
      }
      ResizeMonitor.removeResizeListener(oldElement, resizeHandler);
    }
    if (element) {
      if (me.translate) {
        if (!me.mutationObserver) {
          me.mutationObserver = new MutationObserver(me.mutationHandler || (me.mutationHandler = me.onElMutation.bind(me)));
        }
        me._x = me._y = 0;
        if (document.contains(element)) {
          const [x, y] = DomHelper.getTranslateXY(element);
          me._x = -x;
          me._y = -y;
        }
        me.mutationObserver.observe(element, { attributes: true });
      } else {
        element.addEventListener("scroll", scrollHandler);
        element.classList.add(scrollerCls);
      }
      ResizeMonitor.addResizeListener(element, resizeHandler);
      if (!me.widget) {
        me.rtlSource = {
          get rtl() {
            return DomHelper.getStyleValue(element, "direction") === "rtl";
          }
        };
      }
      if (me.isRTL) {
        element.classList.add("b-rtl");
      }
      if (me.positionDirty) {
        me.updateOverflowX(me.overflowX);
        me.updateOverflowY(me.overflowY);
      }
      me.syncOverflowState();
      if (me.isConfiguring) {
        me._x && me.updateX(me._x);
        me._y && me.updateY(me._y);
      }
    }
    me.positionDirty = true;
  }
  /**
   * The horizontal scroll position of the widget.
   *
   * Note that this is always +ve. Horizontal scrolling using the `X` property akways proceeds
   * in the +ve direction.
   *
   * @property {Number}
   */
  get x() {
    const me = this, { element } = me;
    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = Math.abs(element.scrollLeft);
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._x;
  }
  /**
   * The natural DOM horizontal scroll position of the widget.
   *
   * Note that this proceeds from 0 into negative space in RTL mode.
   *
   * @property {Number}
   */
  get scrollLeft() {
    return this.x * (this.isRTL ? -1 : 1);
  }
  changeX(x) {
    x = Math.max(x, 0);
    if (!this.isConfiguring || x) {
      return x;
    }
    this._x = x;
  }
  updateContentElement(contentElement) {
    if (contentElement) {
      contentElement = typeof contentElement === "string" ? this.element.querySelector(contentElement) : contentElement;
      ResizeMonitor.addResizeListener(contentElement, this.resizeHandler);
    }
  }
  updateX(x) {
    var _a2;
    const me = this, { element } = me;
    if (element && !((_a2 = me.widget) == null ? void 0 : _a2.isConfiguring)) {
      x = Math.round(x);
      me.trigger("scrollStart", { x });
      if (me.translate) {
        DomHelper.setTranslateX(element, -x);
      } else {
        element.scrollLeft = me.isRTL ? -x : x;
      }
    }
    me.positionDirty = true;
  }
  /**
   * Syncs this Scroller with the passed Scroller in the passed axes.
   * @param {Core.helper.util.Scroller} controllingPartner The Scroller which is dictating our new scroll position.
   * @param {Object} axes `{x : <boolean>, y : <boolean> }` which axes to sync.
   * @param {Boolean} axes.x Sync horizontal scroll.
   * @param {Boolean} axes.y Sync vertical scroll.
   * @returns {Boolean} `true` if this Scroller needed the passed axes syncing, `false`
   * if no changes were made.
   * @internal
   */
  sync(controllingPartner, axes) {
    const me = this, { x, y } = axes;
    let result = false;
    if (x != null) {
      if (me.x !== controllingPartner.x) {
        me.controllingPartner = controllingPartner;
        me.x = controllingPartner.x;
        result = true;
      }
    }
    if (y != null) {
      if (me.y !== controllingPartner.y) {
        me.controllingPartner = controllingPartner;
        me.y = controllingPartner.y;
        result = true;
      }
    }
    return result;
  }
  /**
   * The vertical scroll position of the widget.
   * @property {Number}
   */
  get y() {
    const me = this, { element } = me;
    if (element && me.positionDirty) {
      if (me.translate) {
        const [x, y] = DomHelper.getTranslateXY(element);
        me._x = -x;
        me._y = -y;
      } else {
        me._x = element.scrollLeft;
        me._y = element.scrollTop;
      }
      me.positionDirty = false;
    }
    return me._y;
  }
  changeY(y) {
    if (!this.isConfiguring || y) {
      return y;
    }
    this._y = y;
  }
  updateY(y) {
    const { element, widget } = this;
    if (element && !(widget == null ? void 0 : widget.isConfiguring)) {
      this.trigger("scrollStart", { y });
      if (this.translate) {
        DomHelper.setTranslateY(element, -y);
      } else {
        element.scrollTop = y;
      }
    }
    this.positionDirty = true;
  }
  /**
   * The maximum `X` scrollable position of the widget.
   * @property {Number}
   * @readonly
   */
  get maxX() {
    return this.scrollWidth - this.clientWidth;
  }
  /**
   * The maximum `Y` scrollable position of the widget.
   * @property {Number}
   * @readonly
   */
  get maxY() {
    return this.scrollHeight - this.clientHeight;
  }
  /**
   * The furthest possible `scrollLeft` position of the widget. Will be -ve
   * if in writing direction is RTL.
   * @property {Number}
   * @readonly
   */
  get lastScrollLeft() {
    return (this.scrollWidth - this.clientWidth) * (this.isRTL ? -1 : 1);
  }
  updateOverflowX(overflowX, oldOverflowX) {
    const me = this, { element, translate } = me, { style, classList } = element;
    if (oldOverflowX === "hidden-scroll") {
      classList.remove("b-hide-scroll");
    }
    if (overflowX === "hidden-scroll" && !translate) {
      const otherAxisScrollable = isScrollable[style.overflowY];
      if (otherAxisScrollable) {
        overflowX = "hidden";
        me.enableWheel();
      } else {
        classList.add("b-hide-scroll");
      }
    }
    if (!translate) {
      style.overflowX = scrollLiterals[overflowX] || overflowX;
    }
    if (!me.isConfiguring) {
      me.positionDirty = true;
      me.syncOverflowState();
    }
  }
  updateOverflowY(overflowY, oldOverflowY) {
    const me = this, { element, translate } = me, { style, classList } = element;
    if (oldOverflowY === "hidden-scroll") {
      classList.remove("b-hide-scroll");
    }
    if (overflowY === "hidden-scroll" && !translate) {
      const otherAxisScrollable = isScrollable[style.overflowX];
      if (otherAxisScrollable) {
        overflowY = "hidden";
        me.enableWheel();
      } else {
        classList.add("b-hide-scroll");
      }
    }
    if (!translate) {
      style.overflowY = scrollLiterals[overflowY] || overflowY;
    }
    if (!me.isConfiguring) {
      me.positionDirty = true;
      me.syncOverflowState();
    }
  }
  enableWheel() {
    if (!this.wheelListenerRemover) {
      this.wheelListenerRemover = EventHelper.on({
        element: this.element,
        wheel: "onWheel",
        thisObj: this
      });
    }
  }
  onWheel(e) {
    if (Math.abs(e.deltaX) > Math.abs(e.deltaY) && this.overflowX === "hidden-scroll") {
      this.x += e.deltaX;
    } else if (this.overflowY === "hidden-scroll") {
      this.y += e.deltaY;
    }
  }
  /**
   * The horizontal scroll range of the widget.
   * @property {Number}
   * @readonly
   */
  get scrollWidth() {
    var _a2, _b;
    return (_b = (_a2 = this.element) == null ? void 0 : _a2.scrollWidth) != null ? _b : 0;
  }
  set scrollWidth(scrollWidth) {
    const me = this, { element, isRTL } = me;
    let stretcher = me.widthStretcher;
    if (stretcher && scrollWidth == null) {
      stretcher.remove();
      me.widthStretcher = null;
    } else if (scrollWidth) {
      scrollWidth = Math.abs(scrollWidth);
      if (!stretcher) {
        stretcher = me.widthStretcher = DomHelper.createElement({
          className: "b-scroller-stretcher b-horizontal-stretcher",
          // Should survive its surroundings being DomSynced
          retainElement: true
        });
      }
      stretcher.style.transform = `translateX(${(scrollWidth - 1) * (isRTL ? -1 : 1)}px)`;
      if (element && !element.contains(stretcher)) {
        element.insertBefore(stretcher, element.firstElementChild);
      }
    }
    if (me.propagate !== false) {
      me.eachPartner(({ scroller }) => {
        scroller.propagate = false;
        scroller.scrollWidth = scrollWidth;
        delete scroller.propagate;
      });
    }
    me.positionDirty = true;
    me.syncOverflowState();
  }
  get scrollHeight() {
    var _a2, _b;
    return (_b = (_a2 = this.element) == null ? void 0 : _a2.scrollHeight) != null ? _b : 0;
  }
  /**
   * The vertical scroll range of the widget. May be set to larger than the actual data
   * height to enable virtual scrolling. This is how the grid extends its scroll range
   * while only rendering a small subset of the dataset.
   * @property {Number}
   */
  set scrollHeight(scrollHeight) {
    const me = this, stretcher = me.stretcher || (me.stretcher = DomHelper.createElement({
      className: "b-scroller-stretcher"
    }));
    stretcher.style.transform = `translateY(${scrollHeight - 1}px)`;
    if (me.element && me.element.lastChild !== stretcher) {
      me.element.appendChild(stretcher);
    }
    me.positionDirty = true;
    me.syncOverflowState();
  }
  /**
   * The client width of the widget.
   * @property {Number}
   * @readonly
   */
  get clientWidth() {
    var _a2;
    return ((_a2 = this.element) == null ? void 0 : _a2.clientWidth) || 0;
  }
  /**
   * The client height of the widget.
   * @property {Number}
   * @readonly
   */
  get clientHeight() {
    var _a2;
    return ((_a2 = this.element) == null ? void 0 : _a2.clientHeight) || 0;
  }
  /**
   * The unique ID of this Scroller
   * @property {String}
   * @readonly
   */
  get id() {
    if (!this._id) {
      if (this.widget) {
        this._id = `${this.widget.id}-scroller`;
      } else {
        this._id = IdHelper.generateId("scroller-");
      }
    }
    return this._id;
  }
  //region Extract configs
  // This function is not meant to be called by any code other than Base#getCurrentConfig().
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs();
    delete configs.widget;
    delete configs.element;
  }
  //endregion
};
Scroller._$name = "Scroller";

// ../Core/lib/Core/helper/util/Promissory.js
var Promissory = class {
  constructor(fn2) {
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
    if (fn2) {
      fn2(this);
    }
  }
};
Promissory._$name = "Promissory";

// ../Core/lib/Core/widget/Renderable.js
var { defineProperty: defineProperty6 } = Reflect;
var Renderable = class _Renderable extends Base.mixin(Localizable_default, Events_default, Delayable_default, Identifiable_default) {
  static get configurable() {
    return {
      /**
       * The top-level DOM element for this object. This element is produced from the {@link #function-renderDom}
       * method of the derived class. As configs used by `renderDom` change, a synchronization of the DOM is
       * scheduled by calling {@link #function-refreshDom}. This call is made automatically by this class, making
       * it rarely necessary to call `refreshDom` directly.
       * @config {HTMLElement}
       * @category DOM
       */
      element: null
    };
  }
  static get delayable() {
    return {
      refreshDom: "raf"
    };
  }
  static get identifiable() {
    return {};
  }
  /**
   * Returns the Set of configs defined as `render: true`, that is, the configs that determine the rendering (via
   * `renderDom`). If no such configs are defined, this method returns `null`.
   *
   * @returns {Set}
   * @private
   */
  static get renderConfigs() {
    const me = this, meta = me.$meta;
    let renderConfigs = meta.renderConfigs, configs, name;
    if (renderConfigs === void 0) {
      renderConfigs = null;
      configs = meta.configs;
      for (name in configs) {
        if (configs[name].render) {
          (renderConfigs || (renderConfigs = /* @__PURE__ */ new Set())).add(name);
        }
      }
      meta.renderConfigs = me.prototype.$renderConfigs = renderConfigs;
    }
    return renderConfigs;
  }
  //region Init
  construct(...args) {
    this.$iid = ++_Renderable.$idSeed;
    this.byRef = {};
    super.construct(...args);
    if (this.onDraw !== _Renderable.prototype.onDraw) {
      this.initDrawable();
    }
  }
  startConfigure(config) {
    this.element = this.renderContext.renderDom();
    super.startConfigure(config);
  }
  //endregion
  //region Configs
  get element() {
    this.refreshDom.flush();
    return this._element;
  }
  /**
   * This is called when the `element` config is assigned (via the setter).
   * @param {HTMLElement} element The new element being assigned.
   * @param {HTMLElement|null} oldElement The old element (previously assigned) or `null`.
   * @returns {HTMLElement}
   * @private
   */
  changeElement(element, oldElement) {
    const me = this;
    if (oldElement) {
      oldElement.remove();
    }
    if (element) {
      element.id = me.id;
      element = DomHelper.createElement(element, {
        refOwner: me
      });
    }
    return element;
  }
  updateId(id, oldId) {
    const me = this;
    if (oldId) {
      const element = me.element;
      element.id = id;
      me.fixRefOwnerId(element, id, oldId);
    }
  }
  //endregion
  //region Misc
  /**
   * Returns the `classList` of this instance's `element`.
   * @property {DOMTokenList}
   */
  get classes() {
    return this.element.classList;
  }
  /**
   * This method fixes the element's `$refOwnerId` when this instance's `id` is changing.
   * @param {HTMLElement} el The element to fix.
   * @param {String} id The new id being assigned.
   * @param {String} oldId The old id (previously assigned).
   * @private
   */
  fixRefOwnerId(el, id, oldId) {
    if (el.$refOwnerId === oldId) {
      el.$refOwnerId = id;
      const ref = el.$reference;
      if (ref) {
        el.id = `${id}-${ref}`;
      }
      for (const c of el.childNodes) {
        this.fixRefOwnerId(c, id, oldId);
      }
    }
  }
  onConfigChange({ name }) {
    if (!this.isConfiguring && this.$renderConfigs.has(name)) {
      this.refreshDom();
    }
  }
  //endregion
  //region Rendering
  /**
   * This method is called by `DomHelper.createElement` and `DomSync.sync` as new reference elements are created.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {Object} domConfig The DOM config object.
   * @private
   */
  attachRef(name, el, domConfig) {
    const me = this, key = "_" + name, { listeners } = domConfig;
    if (!(key in me)) {
      defineProperty6(me, name, {
        get() {
          me.refreshDom.flush();
          return me[key];
        },
        set(el2) {
          me[key] = el2;
        }
      });
    }
    el.id = `${me.id}-${name}`;
    me.byRef[name] = el;
    me[name] = el;
    if (listeners) {
      domConfig.listeners = {
        on: listeners,
        un: EventHelper.on(Object.assign({
          element: el,
          thisObj: me
        }, listeners))
      };
    }
  }
  /**
   * This method is called by `DomSync.sync` as reference elements are removed from the DOM.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {Object} domConfig The DOM config object.
   * @private
   */
  detachRef(name, el, domConfig) {
    if (domConfig.listeners) {
      domConfig.listeners.un();
      domConfig.listeners = null;
    }
    this[name] = null;
    delete this.byRef[name];
  }
  /**
   * This method returns a {@link Core.helper.DomHelper#function-createElement-static} config object that describes
   * the desired elements for this instance.
   *
   * This method is called to produce the initial DOM structure and again as necessary to generate the DOM for the
   * current state. The DOM produced by these subsequent calls is then passed through
   * {@link Core.helper.DomSync#function-sync-static DomSync.sync()} to update the DOM.
   * @returns {Object}
   */
  renderDom() {
    return {};
  }
  /**
   * This property is the object to use when calling the `renderDom` method. It may evaluate to this instance (if
   * the class declares its render configs) or a helper object to track config usage during the `renderDom` call.
   * @property {Object}
   * @private
   */
  get renderContext() {
    const me = this, meta = me.$meta, C = me.constructor;
    let renderConfigs = meta.renderConfigs || C.renderConfigs, context = me;
    if (!renderConfigs) {
      context = Object.create(me);
      renderConfigs = /* @__PURE__ */ new Set();
      for (const name in meta.configs) {
        defineProperty6(context, name, {
          get() {
            renderConfigs.add(name);
            return me[name];
          }
        });
      }
      context.renderDom = () => {
        return me.renderDom.call(context);
      };
      me.$renderConfigs = renderConfigs;
    }
    defineProperty6(me, "renderContext", {
      value: context
    });
    return context;
  }
  /**
   * This method synchronized the DOM produced by {@link #function-renderDom} with what was previously produced and
   * updates the elements accordingly.
   *
   * This method is buffered such that calls to it do not immediately execute. To perform the refresh immediately,
   * do this:
   *```
   *  instance.refreshDom.now();
   *```
   * To flush any potential updates to the DOM (and do nothing if there are none), do this:
   *```
   *  instance.refreshDom.flush();
   *```
   * To determine if there are updates to the DOM pending, do this:
   *```
   *  if (instance.refreshDom.isPending) {
   *      ...
   *  }
   *```
   */
  refreshDom() {
    DomSync.sync({
      targetElement: this.element,
      domConfig: this.renderContext.renderDom(),
      refOwner: this,
      // This limits the sync() to only removing the classes and styles added by previous renderings. This
      // allows dynamically added styles and classes to be preserved:
      strict: true
    });
  }
  //endregion
  onListen(eventName) {
    if (eventName === "draw") {
      this.initDrawable();
    }
  }
  initDrawable() {
    const me = this;
    if (!me.intersector) {
      let el = Object.values(me.byRef).find((el2) => el2.classList.contains("b-drawable"));
      if (!el) {
        el = me.element;
        el.classList.add("b-drawable");
      }
      me.intersector = new IntersectionObserver((entries) => {
        if (!me.isDestroyed) {
          entries.forEach((ent) => {
            if (ent.isIntersecting) {
              me.onDraw({
                count: ++me.drawCounter
              });
            }
          });
        }
      });
      me.intersector.observe(el);
    }
  }
  onDraw(ev) {
    this.trigger("draw", ev);
  }
};
Renderable.$idSeed = 0;
Object.assign(Renderable.prototype, {
  drawCounter: 0,
  hasGeneratedId: false,
  intersector: null
});
Renderable._$name = "Renderable";

// ../Core/lib/Core/widget/Mask.js
var _Mask = class _Mask extends Renderable {
  construct(config) {
    if (config) {
      let el = config.element, cfg;
      if (el) {
        VersionHelper.deprecate("Core", "4.0.0", 'Mask "element" config has been renamed to "target"');
        config = cfg = Object.assign({}, config);
        delete cfg.element;
        cfg.target = el;
      }
      el = config.target;
      if (typeof el === "string") {
        config = cfg = cfg || Object.assign({}, config);
        cfg.target = config.owner[el];
      }
    }
    super.construct(config);
    const me = this, { type } = me;
    if (!me.target) {
      me.target = document.body;
    }
    me.maskName = `mask${typeof type === "string" ? type.trim() : ""}-${_Mask.counter++}`;
    me.show();
  }
  doDestroy() {
    const me = this, { element } = me;
    if (me.type === "trial") {
      return false;
    }
    if (element) {
      me.element = null;
      if (me.mode.endsWith("blur")) {
        DomHelper.forEachChild(element, (child) => {
          child.classList.remove(`b-masked-${me.mode}`);
        });
      }
      me.target.classList.remove("b-masked");
      me.target[me.maskName] = null;
      ArrayHelper.remove(_Mask.masks, me);
    }
    super.doDestroy();
  }
  get maskElement() {
    return this.element;
  }
  set error(value) {
    this.setConfig(this.errorDefaults);
    this.text = value;
  }
  renderDom() {
    const me = this, { maxProgress } = me;
    return {
      class: {
        "b-mask": 1,
        "b-delayed-show": me.showDelay,
        "b-widget": 1,
        [`b-mask-${me.mode}`]: 1,
        "b-progress": maxProgress,
        "b-prevent-transitions": !me.useTransition
      },
      children: [{
        reference: "maskContent",
        class: "b-mask-content b-drawable",
        children: [
          maxProgress ? {
            reference: "progressElement",
            class: "b-mask-progress-bar",
            style: {
              width: `${Math.max(0, Math.min(100, Math.round(me.progress / maxProgress * 100)))}%`
            }
          } : null,
          {
            reference: "maskText",
            class: "b-mask-text",
            html: (me.icon ? `<i class="b-mask-icon ${me.icon}"></i>` : "") + me.text
          }
        ]
      }]
    };
  }
  //endregion
  //region Static
  static mergeConfigs(...sources) {
    const ret = {};
    for (const src of sources) {
      if (typeof src === "string") {
        ret.text = src;
      } else {
        ObjectHelper.assign(ret, src);
      }
    }
    return ret;
  }
  /**
   * Shows a mask with the specified message.
   *
   * Masks stack, call {@link #function-unmask-static} to remove the topmost mask. Or call {@link #function-close}
   * on the returned mask to close it specifically.
   *
   * @param {String|MaskConfig} text Message
   * @param {HTMLElement} target The element to mask
   * @returns {Core.widget.Mask}
   */
  static mask(text, target = document.body) {
    return _Mask.new({ target }, typeof text !== "string" ? { ...text } : { text });
  }
  /**
   * Close the topmost mask for the specified element
   * @param {HTMLElement} element Element to unmask
   * @returns {Promise|null} A promise which is resolved when the mask is gone, or null if element is not masked
   */
  static unmask(element = document.body) {
    const masks = this.getElementMasks(element);
    if (masks.length > 0) {
      return masks[masks.length - 1].close();
    }
    return null;
  }
  /**
   * Close all masks for the specified element
   * @internal
   */
  static unmaskAll(element = document.body) {
    return this.getElementMasks(element).forEach((mask) => mask.close());
  }
  static getElementMasks(element) {
    return this.masks.filter((mask) => mask.target === element);
  }
  //endregion
  //region Config
  updateAutoClose(delay2) {
    this.deferredClose.cancel();
    if (delay2) {
      this.deferredClose.delay = delay2;
      this.deferredClose();
    }
  }
  updateCover() {
    this.syncCover();
  }
  syncCover() {
    var _a2, _b;
    (_b = (_a2 = this.owner) == null ? void 0 : _a2.syncMaskCover) == null ? void 0 : _b.call(_a2, this);
  }
  onOwnerResize() {
    this.syncCover();
  }
  updateOwner(owner) {
    this.detachListeners("cover");
    owner == null ? void 0 : owner.ion({
      name: "cover",
      recompose: "onOwnerResize",
      resize: "onOwnerResize",
      thisObj: this
    });
  }
  updateShowDelay(delay2) {
    const { delayedShow } = this;
    delayedShow.delay = delay2;
    if (!delay2) {
      delayedShow.flush();
    }
  }
  //endregion
  //region Show & hide
  deferredClose() {
    var _a2;
    const { owner } = this;
    this.close().then(() => {
      var _a3;
      (_a3 = owner == null ? void 0 : owner.onMaskAutoClose) == null ? void 0 : _a3.call(owner, this);
    });
    (_a2 = owner == null ? void 0 : owner.onMaskAutoClosing) == null ? void 0 : _a2.call(owner, this);
  }
  delayedShow() {
    this.classes.remove("b-delayed-show");
  }
  /**
   * Show mask
   */
  show() {
    const me = this, { element, target, hiding, maskName } = me;
    if (hiding) {
      hiding.resolve();
      me.hiding = null;
      me.clearTimeout("hide");
    }
    if (me.showDelay) {
      element.classList.add("b-delayed-show");
      me.delayedShow();
    }
    element.classList.add("b-visible");
    element.classList.remove("b-hidden");
    target.classList.add("b-masked");
    if (!target[maskName]) {
      target[maskName] = me;
      target.appendChild(element);
    }
    ArrayHelper.include(_Mask.masks, me);
    me.shown = true;
    me.trigger("show");
    if (me.mode.endsWith("blur")) {
      DomHelper.forEachChild(target, (child) => {
        if (child !== element) {
          child.classList.add(`b-masked-${me.mode}`);
        }
      });
    }
  }
  /**
   * Hide mask
   * @returns {Promise} A promise which is resolved when the mask is hidden, or immediately if already hidden
   */
  hide() {
    const me = this, { target, element } = me;
    let { hiding } = me;
    if (!hiding) {
      if (!me.shown) {
        return Promise.resolve();
      }
      me.hiding = hiding = new Promissory();
      me.shown = false;
      element.classList.remove("b-visible");
      element.classList.add("b-hidden");
      target.classList.remove("b-masked");
      if (me.mode.endsWith("blur")) {
        DomHelper.forEachChild(target, (child) => {
          if (child !== element) {
            child.classList.remove(`b-masked-${me.mode}`);
          }
        });
      }
      hiding.promise = hiding.promise.then(() => {
        if (me.hiding === hiding) {
          me.hiding = null;
        }
      });
      me.setTimeout(() => hiding.resolve(), 500, "hide");
    }
    return hiding.promise;
  }
  /**
   * Close mask (removes it)
   * @returns {Promise} A promise which is resolved when the mask is closed
   */
  async close() {
    await this.hide();
    this.destroy();
  }
  //endregion
};
//region Config
__publicField(_Mask, "$name", "Mask");
__publicField(_Mask, "type", "mask");
__publicField(_Mask, "configurable", {
  /**
   * Set this config to trigger an automatic close after the desired delay:
   * ```javascript
   *  mask.autoClose = 2000;
   * ```
   * If the mask has an `owner`, its `onMaskAutoClosing` method is called when the close starts and its
   * `onMaskAutoClose` method is called when the close finishes.
   * @config {Number}
   * @private
   */
  autoClose: null,
  /**
   * The portion of the {@link #config-target} element to be covered by this mask. By default, the mask fully
   * covers the `target`. In some cases, however, it may be desired to only cover the `'body'` (for example,
   * in a grid).
   *
   * This config is set in conjunction with `owner` which implements the method `syncMaskCover`.
   *
   * @config {String}
   * @private
   */
  cover: null,
  /**
   * The icon to show next to the text. Defaults to showing a spinner
   * @config {String}
   * @default
   */
  icon: "b-icon b-icon-spinner",
  errorDefaults: {
    icon: "b-icon b-icon-warning",
    autoClose: 3e3,
    showDelay: 0
  },
  /**
   * The maximum value of the progress indicator
   * @property {Number}
   */
  maxProgress: null,
  /**
   * Mode: bright, bright-blur, dark or dark-blur
   * @config {'bright'|'bright-blur'|'dark'|'dark-blur'}
   * @default
   */
  mode: "dark",
  /**
   * Number expressing the progress
   * @property {Number}
   */
  progress: null,
  // The owner is involved in the following features:
  //
  // - The `autoClose` timer calls `onMaskAutoClose`.
  // - The `cover` config calls `syncMaskCover`.
  // - If the `target` is a string, that string names the property of the `owner` that holds the
  //   `HTMLElement` reference.
  /**
   * The owning widget of this mask. This is required if `target` is a string.
   *
   * @config {Core.widget.Widget}
   */
  owner: {
    $config: "nullify",
    value: null
  },
  /**
   * The element to be masked. If this config is a string, that string is the name of the property of the
   * `owner` that holds the `HTMLElement` that is the actual target of the mask.
   *
   * NOTE: In prior releases, this used to be specified as the `element` config, but that is now, as with
   * `Widget`, the primary element of the mask.
   *
   * @config {String|HTMLElement}
   */
  target: null,
  /**
   * The text (or HTML) to show in mask
   * @prp {String}
   */
  text: null,
  type: null,
  /**
   * The number of milliseconds to delay before making the mask visible. If set, the mask will have an
   * initial `opacity` of 0 but will function in all other ways as a normal mask. Setting this delay can
   * reduce flicker in cases where load operations are typically short (for example, a second or less).
   *
   * @config {Number}
   */
  showDelay: null,
  useTransition: false
});
__publicField(_Mask, "delayable", {
  deferredClose: 0,
  delayedShow: 0,
  syncCover: {
    type: "throttle",
    delay: 100
  }
});
//endregion
//region Init
// Used to give masks unique names
__publicField(_Mask, "counter", 0);
// Tracks open masks
__publicField(_Mask, "masks", []);
var Mask = _Mask;
Mask._$name = "Mask";

// ../Core/lib/Core/widget/mixin/KeyMap.js
var KeyMap_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    /**
     * Override to attach the keyMap keydown event listener to something else than this.element
     * @private
     */
    get keyMapElement() {
      return this.element;
    }
    /**
     * Override to make keyMap resolve subcomponent actions to something else than this.features.
     * @private
     */
    get keyMapSubComponents() {
      return this.features;
    }
    /**
     * Returns the `keyMap` property name which matches the passed KeyboardEvent if any.
     * @param {KeyboardEvent} keyEvent
     * @param {Object} [keyMap=this.keyMap]
     * @returns {String} the key into the `keyMap` matched by the passed KeyboardEvent
     * @internal
     */
    matchKeyMapEntry(keyEvent, keyMap = this.keyMap) {
      if (keyMap && !keyEvent.handled && keyEvent.key !== void 0) {
        return ObjectHelper.keys(keyMap).find((keyString) => {
          const keys = keyString.split("+"), requireAlt = keys.includes("Alt"), requireShift = keys.includes("Shift"), requireCtrl = keys.includes("Ctrl");
          let actualKey = keys[keys.length - 1].toLowerCase();
          if (actualKey === "space") {
            actualKey = " ";
          }
          return actualKey === keyEvent.key.toLowerCase() && (!keyEvent.altKey && !requireAlt || keyEvent.altKey && requireAlt) && (!keyEvent.ctrlKey && !requireCtrl || keyEvent.ctrlKey && requireCtrl) && (!keyEvent.shiftKey && !requireShift || keyEvent.shiftKey && requireShift);
        });
      }
    }
    /**
     * Called on keyMapElement keyDown
     * @private
     */
    performKeyMapAction(event) {
      var _a3;
      const { keyMap } = this;
      let actionHandled = false;
      if (keyMap && !event.handled && event.key !== void 0) {
        const key = this.matchKeyMapEntry(event);
        if (keyMap[key]) {
          const actions2 = ArrayHelper.asArray(keyMap[key]);
          event.fromKeyMap = true;
          let preventDefault2;
          for (let action of actions2) {
            preventDefault2 = true;
            if (ObjectHelper.isObject(action)) {
              if (!action.handler) {
                continue;
              }
              if (action.preventDefault === false) {
                preventDefault2 = false;
              }
              action = action.handler;
            }
            if (typeof action === "string") {
              const {
                thisObj,
                handler
              } = this.resolveKeyMapAction(action);
              if (((_a3 = thisObj.isActionAvailable) == null ? void 0 : _a3.call(thisObj, { key, action, event, actionName: action.split(".").pop() })) !== false) {
                if (handler.call(thisObj, event) !== false) {
                  actionHandled = true;
                  break;
                }
              }
            } else if (action.call(this) !== false) {
              actionHandled = true;
              break;
            }
          }
          delete event.fromKeyMap;
          if (actionHandled) {
            if (preventDefault2) {
              event.preventDefault();
            }
            event.handled = true;
          }
        }
      }
      return actionHandled;
    }
    /**
     * Resolves correct `this` and handler function.
     * If subComponent (action includes a dot) it will resolve in keyMapSubComponents (defaults to this.features).
     *
     * For example, in feature configurable:
     * `keyMap: {
     *     ArrowUp: 'navigateUp'
     * }`
     *
     * Will be translated (by InstancePlugin) to:
     * `keyMap: {
     *     ArrowUp: 'featureName.navigateUp'
     * }
     *
     * And resolved to correct function path here.
     *
     * Override to change action function mapping.
     * @private
     */
    resolveKeyMapAction(action) {
      const { keyMapSubComponents } = this;
      if (action.startsWith("up.") || action.startsWith("this.")) {
        return this.resolveCallback(action);
      }
      if (keyMapSubComponents && action.includes(".")) {
        const [component, actionName] = action.split(".");
        if (component && actionName) {
          return {
            thisObj: keyMapSubComponents[component],
            handler: keyMapSubComponents[component][actionName]
          };
        }
      }
      return {
        thisObj: this,
        handler: this[action]
      };
    }
    updateKeyMap(keyMap) {
      var _a3;
      (_a3 = this.keyMapDetacher) == null ? void 0 : _a3.call(this);
      if (!ObjectHelper.isEmpty(keyMap)) {
        this.keyMapDetacher = EventHelper.on({
          element: this.keyMapElement,
          keydown: "keyMapOnKeyDown",
          thisObj: this
        });
      }
    }
    // Hook on to this to catch keydowns before keymap does
    keyMapOnKeyDown(event) {
      this.performKeyMapAction(event);
    }
    /**
     * This function is used for merging two keyMaps with each other. It can be used for example by a Grid's feature to
     * merge the fetature's keyMap into the Grid's with the use of a subPrefix.
     * @param {Object} target - The existing keyMap.
     * @param {Object} source - The keyMap we want to merge into target.
     * @param {Object} subPrefix - If keyMap actions in source should be prefixed, the prefix should be provided here.
     * As example, the prefix * `rowCopyPaste` will give the action 'rowCopyPaste.action'.
     * @private
     */
    mergeKeyMaps(target, source, subPrefix = null) {
      const mergedKeyMap = {};
      if (target) {
        ObjectHelper.assign(mergedKeyMap, target);
      }
      for (const key in source) {
        if (!source[key]) {
          continue;
        }
        const existingActions = ArrayHelper.asArray(target == null ? void 0 : target[key]), actions2 = [];
        if (existingActions == null ? void 0 : existingActions.length) {
          actions2.push(...existingActions);
        }
        if (!(existingActions == null ? void 0 : existingActions.some((a) => {
          const handler = a.handler ? a.handler : a;
          return typeof handler === "string" && handler.startsWith(subPrefix + ".");
        }))) {
          for (const action of ArrayHelper.asArray(source[key])) {
            if (ObjectHelper.isObject(action) && action.handler) {
              actions2.push(ObjectHelper.assignIf({
                handler: (subPrefix ? subPrefix + "." : "") + action.handler
              }, action));
            } else if (typeof action === "function") {
              actions2.push(action);
            } else {
              actions2.push((subPrefix ? subPrefix + "." : "") + action);
            }
          }
          actions2.sort((a, b) => {
            const weight = (a.weight || 0) - (b.weight || 0);
            if (weight === 0 && (existingActions == null ? void 0 : existingActions.length)) {
              return existingActions.indexOf(a) - existingActions.indexOf(b);
            }
            return weight;
          });
        }
        mergedKeyMap[key] = actions2;
      }
      return mergedKeyMap;
    }
  }, __publicField(_a2, "$name", "KeyMap"), __publicField(_a2, "configurable", {
    keyMap: {
      value: null,
      $config: {
        merge: "objects",
        nullify: true
      }
    }
  }), _a2;
};

// ../Core/lib/Core/widget/mixin/RTL.js
var RTL_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    // Replace generated is-property, to reduce risk of confusion
    get isRTL() {
      return this.rtl;
    }
    updateRtl(rtl) {
      const { element } = this;
      if (element) {
        element.classList.toggle("b-rtl", rtl === true);
        element.classList.toggle("b-ltr", rtl === false);
      }
    }
    startConfigure(config) {
      var _a3, _b;
      (_a3 = super.startConfigure) == null ? void 0 : _a3.call(this, arguments);
      if (!config.floating && config.rtl == null) {
        const me = this, el = config.rootElement || config.forElement || ((_b = me.parent) == null ? void 0 : _b.contentElement) || (me.floating ? me.floatRoot : me.changeElementRef(me.getRenderContext(config)[0] || config.adopt || document.body)), owner = config.owner || config.parent || me.constructor.fromElement(el);
        if (owner) {
          config.rtl = owner[owner.isConfiguring ? "peekConfig" : "getConfig"]("rtl");
        } else {
          config.rtl = (el == null ? void 0 : el.nodeType) === 1 && getComputedStyle(el).getPropertyValue("direction") === "rtl";
        }
        if (config.rtl) {
          me.configDone.rtl = false;
        }
      }
    }
    // Render is only called on outer widgets, children read their setting from their owner unless explicitly set
    render(...args) {
      var _a3, _b;
      super.render && super.render(...args);
      if (BrowserHelper.isChrome && BrowserHelper.chromeVersion < 87 || BrowserHelper.isFirefox && BrowserHelper.firefoxVersion < 66 || BrowserHelper.isSafari && BrowserHelper.safariVersion < 14.1) {
        this.element.classList.add("b-legacy-inset");
      }
      if (getComputedStyle(this.element).direction === "rtl" || ((_a3 = this.owner) == null ? void 0 : _a3.rtl)) {
        this.rtl = true;
        (_b = this.childItems) == null ? void 0 : _b.forEach((i) => i.rtl = true);
      }
    }
  }, __publicField(_a2, "$name", "RTL"), __publicField(_a2, "configurable", {
    /**
     * If a widget is rendered into an element which has computed style `direction:rtl`, this property will be
     * set to `true`
     *
     * Rendering a widget into an element which, either by a CSS rule, or by its inline `style` has an
     * explicit direction will cause the widget to use that direction regardless of the owning document's
     * direction.
     *
     * In this way, an RTL widget may operate normally inside an LTR page and vice versa.
     *
     * If you are using Bryntum widgets in a different direction to that of the owning document, you
     * must use the following CSS rule to have Popups such as tooltips and event editors use
     * the desired direction instead of the direction of the document:
     *
     * ```CSS
     * .b-float-root {
     *     direction : xxx; // Floatings widgets to differ from the document
     * }
     * ```
     * @member {Boolean} rtl
     * @readonly
     * @private
     */
    /**
     * This may be configured as `true` to make the widget's element use the `direction:rtl` style.
     * @config {Boolean}
     * @default false
     * @private
     */
    rtl: null
  }), _a2;
};

// ../Core/lib/Core/widget/Widget.js
var assignValueDefaults = Object.freeze({
  highlight: false,
  onlyName: false
});
var floatRoots = [];
var highlightExternalChange = "highlightExternalChange";
var isTransparent = /transparent|rgba\(0,\s*0,\s*0,\s*0\)/;
var renderConfigObserver = Symbol("renderConfigObserver");
var textInputTypes = {
  INPUT: 1,
  TEXTAREA: 1
};
var addElementListeners = (me, element, domConfig, refName) => {
  let listeners = (domConfig == null ? void 0 : domConfig.listeners) || (domConfig == null ? void 0 : domConfig.internalListeners);
  listeners = (listeners == null ? void 0 : listeners.on) || listeners;
  if (listeners) {
    const un = EventHelper.on(ObjectHelper.assign({
      element,
      thisObj: me
    }, listeners));
    if (refName) {
      (me._refListeners || (me._refListeners = /* @__PURE__ */ Object.create(null)))[refName] = un;
    } else {
      domConfig.listeners = {
        on: listeners,
        un
      };
    }
  }
};
var mergeAnim = (value, was) => {
  return value && was && was[ObjectHelper.keys(value)[0]] ? Config.merge(value, was) : value;
};
var widgetTriggerPaint = (w) => {
  w.isVisible && w.triggerPaint();
};
var negationPseudo = /^:not\((.+)\)$/;
var nonFlowedPositions = /absolute|fixed/i;
var isScaled = (w) => w.scale != null;
var { hasOwn: hasOwn4 } = ObjectHelper;
var { defineProperty: defineProperty7 } = Reflect;
var parseDuration = (d) => parseFloat(d) * (d.endsWith("ms") ? 1 : 1e3);
var alignedClass = [
  "b-aligned-above",
  "b-aligned-right",
  "b-aligned-below",
  "b-aligned-left"
];
var returnFalseProp = {
  configurable: true,
  get() {
    return false;
  }
};
var localizeRE = /(?:L\{([^}.]+)\})/;
var localizeTooltip = (string2, part) => "L{Tooltip." + part + "}";
var alignSpecRe2 = /^([trblc])(\d*)-([trblc])(\d*)$/i;
var mergeAlign = (oldValue, newValue) => {
  if (alignSpecRe2.test(oldValue)) {
    oldValue = { align: oldValue };
  }
  if (alignSpecRe2.test(newValue)) {
    newValue = { align: newValue };
  }
  return Config.merge(oldValue, newValue);
};
var callbackRe = /^[\w.]+$/;
var alignChangeDims = {
  1: "maxHeight",
  2: "height",
  4: "maxWidth",
  8: "width"
};
var isSingletonWidget = (w) => !w.isRipple && !w.closest((w2) => w2.isMessageDialog || w2.isSharedTooltip);
var Widget = class _Widget extends Base.mixin(Localizable_default, Events_default, Delayable_default, Identifiable_default, Factoryable_default, KeyMap_default, RTL_default) {
  //region Config
  // Used when a config is a class and internally stored as a DomClassList
  // So that subclasses can add class names.
  static mergeCls(newValue, oldValue) {
    if (oldValue && newValue) {
      newValue = new DomClassList(oldValue).assign(typeof newValue === "string" ? new DomClassList(newValue) : newValue);
    } else if (newValue && !newValue.isDomClassList) {
      newValue = new DomClassList(newValue);
    }
    return newValue;
  }
  /**
   * Class name getter.
   * Used when original ES6 class name is minified or mangled during production build.
   * Should be overridden in each class which extends Widget or it descendants.
   *
   * ```javascript
   * class MyNewClass extends Widget {
   *     static get $name() {
   *        return 'MyNewClass';
   *     }
   * }
   * ```
   *
   * @static
   * @member {String} $name
   * @advanced
   */
  static get $name() {
    return "Widget";
  }
  /**
   * Widget name alias which you can use in the `items` of a Container widget.
   *
   * ```javascript
   * class MyWidget extends Widget {
   *     static get type() {
   *        return 'mywidget';
   *     }
   * }
   * ```
   *
   * ```javascript
   * const panel = new Panel({
   *    title : 'Cool widgets',
   *    items : [
   *       { type : 'mywidget', html : 'Lorem ipsum dolor sit amet...' }
   *    ]
   * });
   * ```
   *
   * @static
   * @member {String} type
   */
  static get type() {
    return "widget";
  }
  static get configurable() {
    return {
      /**
       * Get this widget's encapsulating HTMLElement, which is created along with the widget but added to DOM at
       * render time.
       * @member {HTMLElement} element
       * @readonly
       * @category DOM
       */
      /**
       * A {@link Core.helper.DomHelper#function-createElement-static} config object or HTML string from which to
       * create the Widget's element.
       * @private
       * @config {DomConfig|String}
       * @category DOM
       */
      element: true,
      /**
       * Set to false to not call onXXX method names (e.g. `onShow`, `onClick`), as an easy way to listen for events.
       *
       * ```javascript
       * const container = new Container({
       *     callOnFunctions : true
       *
       *     onHide() {
       *          // Do something when the 'hide' event is fired
       *     }
       * });
       * ```
       * @config {Boolean}
       * @default
       */
      callOnFunctions: true,
      /**
       * Get/set widgets id
       * @member {String} id
       * @category DOM
       */
      /**
       * Widget id, if not specified one will be generated. Also used for lookups through Widget.getById
       * @config {String}
       * @category DOM
       */
      id: "",
      /**
       * The HTML to display initially or a function returning the markup (called at widget construction time)
       *
       * This may be specified as the name of a function which can be resolved in the component ownership
       * hierarchy, such as 'up.getHTML' which will be found on an ancestor Widget.
       *
       * @config {String|Function}
       * @param {Core.widget.Widget} widget The calling Widget
       * @returns {String}
       * @category DOM
       */
      html: null,
      /**
       * Set HTML content safely, without disturbing sibling elements which may have been
       * added to the {@link #property-contentElement} by plugins and features.
       * When specifying html, this widget's element will also have the {@link #config-htmlCls}
       * added to its classList, to allow targeted styling.
       * @member {String} content
       * @category DOM
       * @advanced
       */
      /**
       * The HTML content that coexists with sibling elements which may have been added to the
       * {@link #property-contentElement} by plugins and features.
       * When specifying html, this widget's element will also have the {@link #config-htmlCls}
       * class added to its classList, to allow targeted styling.
       * @config {String} content
       * @category DOM
       * @advanced
       */
      content: null,
      /**
       * Custom CSS classes to add to element.
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the class names:
       * ```javascript
       *  cls : {
       *      'b-my-class'     : 1,
       *      [this.extraCls]  : 1,
       *      [this.activeCls] : this.isActive
       *  }
       *  ```
       *
       * @prp {String|Object}
       * @category CSS
       */
      cls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      /**
       * Custom CSS class name suffixes to apply to the elements rendered by this widget. This may be specified
       * as a space separated string, an array of strings, or as an object in which property names with truthy
       * values are used as the class names.
       *
       * For example, consider a `Panel` with a `ui` config like so:
       *
       * ```javascript
       *  new Panel({
       *      text : 'OK',
       *      ui   : 'light'
       *  });
       * ```
       * This will apply the CSS class `'b-panel-ui-light'` to the main element of the panel as well as its many
       * child elements. This allows simpler CSS selectors to match the child elements of this particular panel
       * UI:
       *
       * ```css
       *  .b-panel-content.b-panel-ui-light {
       *      background-color : #eee;
       *  }
       * ```
       * Using the {@link #config-cls cls config} would make matching the content element more complex, and in
       * the presence of {@link Core.widget.Panel#config-strips docked items} and nested panels, impossible to
       * target accurately.
       *
       * @config {String|Object}
       * @category CSS
       */
      ui: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      /**
       * Determines how a {@link Core.widget.Panel#config-collapsed} panel will treat this widget if it resides
       * within the panel's header (for example, as one of its {@link Core.widget.Panel#config-strips} or
       * {@link Core.widget.Panel#config-tools}).
       *
       * Valid options are:
       *  - `null` : The widget will be moved to the overlay header when the panel is collapsed (the default).
       *  - `false` : The widget will be unaffected when the panel is collapsed and will remain in the primary
       *    panel header at all times.
       *  - `'hide'` : The widget will be hidden when the panel is collapsed.
       *  - `'overlay'` : The widget will only appear in the collapsed panel's overlay header. See
       *    {@link Core.widget.panel.PanelCollapserOverlay collapsible type='overlay'}.
       *
       * @config {Boolean|'hide'|'overlay'}
       * @internal
       */
      collapsify: null,
      /**
       * Custom CSS classes to add to the {@link #property-contentElement}.
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the class names:
       * ```javascript
       *  cls : {
       *      'b-my-class'     : 1,
       *      [this.extraCls]  : 1,
       *      [this.activeCls] : this.isActive
       *  }
       *  ```
       *
       * @config {String|Object}
       * @category CSS
       * @advanced
       */
      contentElementCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      /**
       * Custom CSS classes to add to this widget's `element`. This property is typically used internally to
       * assign default CSS classes while allowing `cls` to alter these defaults. It is not recommended that
       * client code set this config but instead should set `cls`.
       *
       * For example, to remove a class defined by `defaultCls` using `cls`, declare the class name as a key with
       * a falsy value:
       *
       * ```javascript
       *  cls : {
       *      'default-class' : false
       *  }
       * ```
       * @config {String|Object|String[]}
       * @internal
       */
      defaultCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      /**
       * Controls the placement of this widget when it is added to a {@link Core.widget.Panel panel's }
       * {@link Core.widget.Panel#config-strips strips collection}. Typical values for this config are `'top'`,
       * `'bottom'`, `'left'`, or `'right'`, which cause the widget to be placed on that side of the panel's
       * body. Such widgets are called "edge strips".
       *
       * Also accepts direction neutral horizontal values `'start'` and `'end'`.
       *
       * If this config is set to `'header'`, the widget is placed in the panel's header, following the title. If
       * this config is set to `'pre-header'`, the widget is placed before the title. Such widgets are called
       * "header strips".
       *
       * @config {'top'|'bottom'|'left'|'right'|'start'|'end'|'header'|'pre-header'|Object} dock
       * @category Layout
       */
      dock: null,
      /**
       * The events to forward from an overflow twin to its origin widget.
       *
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the event names:
       * ```javascript
       *  forwardTwinEvents : {
       *      change : this.syncTwinOnChange,
       *      input  : 1
       *  }
       *  ```
       * NOTE: This config cannot be dynamically changed after the `overflowTwin` has been created (see
       * {@link #function-ensureOverflowTwin}.
       * @config {String|String[]|Object}
       * @internal
       */
      forwardTwinEvents: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      parent: null,
      /**
       * The {@link Core.widget.Tab tab} created for this widget when it is placed in a
       * {@link Core.widget.TabPanel}.
       * @member {Core.widget.Tab} tab
       * @readonly
       * @category Misc
       */
      /**
       * A configuration for the {@link Core.widget.Tab tab} created for this widget when it is placed in a
       * {@link Core.widget.TabPanel}. For example, this config can be used to control the icon of the `tab` for
       * this widget:
       *
       * ```javascript
       *  items : [{
       *      type : 'panel',
       *      // other configs...
       *
       *      tab : {
       *          icon : 'b-fa-wrench'
       *      }
       *  }, ... ]
       * ```
       *
       * Another use for this config is to set the tab's {@link Core.widget.mixin.Rotatable#config-rotate} value
       * differently than the default managed by the `TabPanel`:
       *
       * ```javascript
       *  items : [{
       *      type : 'panel',
       *      // other configs...
       *
       *      tab : {
       *          rotate : false   // don't rotate even if tabBar is docked left or right
       *      }
       *  }, ... ]
       * ```
       *
       * Set this to `false` to prevent the creation of a `tab` for this widget. In this case, this widget must
       * be {@link #function-show shown} explicitly. The {@link Core.widget.TabPanel#config-activeTab} for the
       * tab panel will be -1 in this situation.
       *
       * ```javascript
       *  items : [{
       *      type : 'panel',
       *      tab  : false,    // no tab for this item
       *
       *      // other configs...
       *  }, ... ]
       * ```
       *
       * @config {Boolean|TabConfig} tab
       * @category Misc
       */
      tab: null,
      /**
       * An object specifying attributes to assign to the root element of this widget
       * @internal
       * @config {Object}
       * @category Misc
       */
      elementAttributes: null,
      /**
       * The CSS class(es) to add when HTML content is being applied to this widget.
       * @config {String|Object}
       * @category CSS
       */
      htmlCls: {
        $config: {
          merge: "classList"
        },
        value: {
          "b-html": 1
        }
      },
      /**
       * Custom style spec to add to element
       * @config {String}
       * @category CSS
       */
      style: null,
      /**
       * Get/set element's disabled state
       * @member {Boolean} disabled
       * @category Misc
       */
      /**
       * Disable or enable the widget. It is similar to {@link #config-readOnly} except a disabled widget
       * cannot be focused, uses a different rendition (usually greyish) and does not allow selecting its value.
       * @default false
       * @config {Boolean}
       * @category Misc
       */
      disabled: null,
      /**
       * Get/set element's readOnly state. This is only valid if the widget is an input
       * field, __or contains input fields at any depth__. Updating this property will trigger
       * a {@link #event-readOnly} event.
       *
       * All descendant input fields follow the widget's setting. If a descendant
       * widget has a readOnly config, that is set.
       * @member {Boolean} readOnly
       * @category Misc
       */
      /**
       * Whether this widget is read-only.  This is only valid if the widget is an input
       * field, __or contains input fields at any depth__.
       *
       * All descendant input fields follow the widget's setting. If a descendant
       * widget has a readOnly config, that is set.
       * @default false
       * @config {Boolean}
       * @category Misc
       */
      readOnly: {
        value: null,
        default: false,
        $config: null
      },
      /**
       * Determines if the widgets read-only state should be controlled by its parent.
       *
       * When set to `false`, setting a parent container to read-only will not affect the widget. When set to
       * `true`, it will.
       *
       * @category Misc
       * @config {Boolean}
       * @default false
       */
      ignoreParentReadOnly: null,
      /**
       * Element (or element id) to adopt as this Widget's encapsulating element. The widget's
       * content will be placed inside this element.
       *
       * If this widget has not been configured with an id, it will adopt the id of the element
       * in order to preserve CSS rules which may apply to the id.
       * @config {HTMLElement|String}
       * @default
       * @category DOM
       */
      adopt: null,
      /**
       * Element (or the id of an element) to append this widget's element to. Can be configured, or set once at
       * runtime. To access the element of a rendered widget, see {@link #property-element}.
       * @prp {HTMLElement}
       * @accepts {HTMLElement|String}
       * @category DOM
       */
      appendTo: null,
      /**
       * Element (or element id) to insert this widget before. If provided, {@link #config-appendTo} config is ignored.
       * @prp {HTMLElement|String}
       * @category DOM
       */
      insertBefore: null,
      /**
       * Element (or element id) to append this widget element to, as a first child. If provided, {@link #config-appendTo} config is ignored.
       * @prp {HTMLElement|String}
       * @category DOM
       */
      insertFirst: null,
      /**
       * Object to apply to elements dataset (each key will be used as a data-attribute on the element)
       * @config {Object}
       * @category DOM
       */
      dataset: null,
      /**
       * Tooltip for the widget, either as a string or as a Tooltip config object.
       *
       * By default, the Widget will use a single, shared instance to display its tooltip as configured,
       * reconfiguring it to the specification before showing it. Therefore, it may not be permanently
       * mutated by doing things such as adding fixed event listeners.
       *
       * To have this Widget *own* its own `Tooltip` instance, add the property `newInstance : true`
       * to the configuration. In this case, the tooltip's {@link #property-owner} will be this Widget.
       *
       * __Note that in the absence of a configured {@link #config-ariaDescription}, the tooltip's value
       * will be used to populate an `aria-describedBy` element within this Widget.__
       * @config {String|TooltipConfig}
       * @category Misc
       */
      tooltip: {
        $config: ["lazy", "nullify"],
        value: null
      },
      /**
       * Set to false to not show the tooltip when this widget is {@link #property-disabled}
       * @config {Boolean}
       * @default
       * @category Misc
       */
      showTooltipWhenDisabled: true,
      /**
       * Prevent tooltip from being displayed on touch devices. Useful for example for buttons that display a
       * menu on click etc, since the tooltip would be displayed at the same time.
       * @config {Boolean}
       * @default false
       * @category Misc
       */
      preventTooltipOnTouch: null,
      /**
       * When this is configured as `true` a [ResizeObserver](https://developer.mozilla.org/en-US/docs/Web/API/ResizeObserver)
       * is used to monitor this element for size changes caused by either style manipulation, or by CSS
       * layout.
       *
       * Size changes are announced using the {@link #event-resize} event.
       * @config {Boolean}
       * @default false
       * @category Misc
       * @advanced
       */
      monitorResize: {
        $config: ["lazy", "nullify"],
        value: null
      },
      /**
       * Set to `true` to apply the default mask to the widget. Alternatively, this can be the mask message or a
       * {@link Core.widget.Mask} config object.
       * @config {Boolean|String|MaskConfig}
       * @category Misc
       */
      masked: {
        $config: "nullify",
        value: null
      },
      /**
       * This config object contains the defaults for the {@link Core.widget.Mask} created for the
       * {@link #config-masked} config. Any properties specified in the `masked` config will override these
       * values.
       * @config {MaskConfig}
       * @category Misc
       */
      maskDefaults: {
        target: "element"
      },
      cache: {},
      /**
       * Set to `true` to move the widget out of the document flow and position it
       * absolutely in browser viewport space.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      floating: null,
      /**
       * Set to `true` when a widget is rendered into another widget's {@link #property-contentElement}, but must
       * not participate in the standard layout of that widget, and must be positioned relatively to that
       * widget's {@link #property-contentElement}.
       *
       * {@link Core.widget.Editor Editor}s are positioned widgets.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      positioned: null,
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       * Set to `true` to be able to drag a widget freely on the page. Or set to an object with a handleSelector
       * property which controls when a drag should start.
       *
       * ```javascript
       *
       * draggable : {
       *     handleSelector : ':not(button)'
       * }
       *
       * ```
       *
       * @config {Boolean|Object}
       * @property {String} handleSelector CSS selector used to determine if drag can be started from a
       * mouse-downed element inside the widget
       * @default false
       * @category Float & align
       */
      draggable: null,
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * How to align this element with its target when {@link #function-showBy} is called
       * passing a simple element as an align target.
       *
       * Either a full alignment config object, or for simple cases, the edge alignment string to use.
       *
       * When using a simple string, the format is `'[trblc]n-[trblc]n'` and it specifies our edge and
       * the target edge plus optional offsets from 0 to 100 along the edges to align to. Also supports direction
       * independent edges horizontally, `s` for start and `e` for end (maps to `l` and `r` for LTR, `r` and `l`
       * for RTL).
       *
       * See the {@link #function-showBy} function for more details about using the object form.
       *
       * Once set, this is stored internally in object form.
       * @config {AlignSpec|String}
       * @category Float & align
       */
      align: {
        $config: {
          merge: mergeAlign
        },
        value: "t-b"
      },
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       * Set to `true` to centre the Widget in browser viewport space.
       * @config {Boolean}
       * @default
       * @category Float & align
       */
      centered: null,
      /**
       * _Only valid if this Widget is {@link #config-floating} or {@link #config-positioned}._
       * Element, Widget or Rectangle to which this Widget is constrained.
       * @config {HTMLElement|Core.widget.Widget|Core.helper.util.Rectangle}
       * @default document.body
       * @category Float & align
       */
      constrainTo: void 0,
      /**
       * _Only valid if this Widget is {@link #config-floating} and being shown through {@link #function-showBy}._
       * `true` to show a connector arrow pointing to the align target.
       * @config {Boolean}
       * @default false
       * @category Float & align
       */
      anchor: null,
      /**
       * The owning Widget of this Widget. If this Widget is directly contained, this will be the containing Widget.
       * If there is a `forElement`, this config will be that element's encapsulating Widget.
       *
       * If this Widget is floating, this config must be specified by the developer.
       * @config {Core.widget.Widget}
       * @category Misc
       */
      owner: null,
      /**
       * Defines what to do if document is scrolled while Widget is visible (only relevant when floating is set to true).
       * Valid values: null: do nothing, hide: hide the widget or realign: realign to the target if possible.
       * @config {'hide'|'realign'|null}
       * @default
       * @category Float & align
       */
      scrollAction: null,
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * An object which defined which CSS style property should be animated upon hide, and how it should be
       * animated eg:
       *
       * ```javascript
       * {
       *    opacity: {
       *        to : 0,
       *        duration: '10s',
       *        delay: '0s'
       *    }
       * }
       * ```
       *
       * Set to `'false'` to disable animation.
       *
       * @config {Boolean|Object}
       * @category Float & align
       */
      hideAnimation: {
        $config: {
          merge: mergeAnim
        },
        value: null
      },
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * An object which defined which CSS style property should be animated upon show, and how it should be
       * animated eg:
       *
       * ```javascript
       * {
       *    opacity: {
       *        to : 1,
       *        duration: '10s',
       *        delay: '0s'
       *    }
       * }
       * ```
       *
       * Set to `'false'` to disable animation.
       *
       * @config {Boolean|Object}
       * @category Float & align
       */
      showAnimation: {
        $config: {
          merge: mergeAnim
        },
        value: null
      },
      /**
       * The x position for the widget.
       *
       * _Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element._
       *
       * @config {Number}
       * @default
       * @category Float & align
       */
      x: null,
      /**
       * The y position for the widget.
       *
       * _Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element._
       *
       * @config {Number}
       * @default
       * @category Float & align
       */
      y: null,
      /**
       * Accessor to the {@link Core.helper.util.Scroller} which can be used
       * to both set and read scroll information.
       * @member {Core.helper.util.Scroller} scrollable
       * @category Layout
       */
      /**
       * Specifies whether (and optionally in which axes) a Widget may scroll. `true` means this widget may scroll
       * in both axes. May be an object containing boolean `overflowX` and `overflowY` properties which are
       * applied to CSS style properties `overflowX` and `overflowY`. If they are boolean, they are translated to
       * CSS overflow properties thus:
       *
       * *`true` -> `'auto'`
       * *`false` -> `'hidden'`
       *
       * After initialization, this property yields a {@link Core.helper.util.Scroller} which may be used to both
       * set and read scroll information.
       *
       * A Widget uses its `get overflowElement` property to select which element is to be scrollable. By default,
       * in the base `Widget` class, this is the Widget's encapsulating element. Subclasses may implement `get
       * overflowElement` to scroll inner elements.
       * @config {Boolean|ScrollerConfig|Core.helper.util.Scroller}
       * @default false
       * @category Scrolling
       */
      scrollable: {
        $config: ["lazy", "nullify"],
        value: null
      },
      /**
       * The class to instantiate to use as the {@link #config-scrollable}. Defaults to
       * {@link Core.helper.util.Scroller}.
       * @internal
       * @config {Core.helper.util.Scroller}
       * @typings {typeof Scroller}
       * @category Scrolling
       */
      scrollerClass: Scroller,
      /**
       * The name of the property to set when a single value is to be applied to this Widget. Such as when used
       * in a grid WidgetColumn, this is the property to which the column's `field` is applied.
       * @config {String}
       * @default 'html'
       * @category Misc
       */
      defaultBindProperty: "html",
      /**
       * Event that should be considered the default action of the widget. When that event is triggered the
       * widget is also expected to trigger an `action` event. Purpose is to allow reacting to most widgets in
       * a coherent way.
       * @private
       * @config {String}
       * @category Misc
       */
      defaultAction: null,
      /**
       * When set to `true`, this widget is considered as a whole when processing {@link Core.widget.Toolbar}
       * overflow. When `false`, this widget's child items are considered instead.
       *
       * When set to the string `'none'`, this widget is ignored by overflow processing. This option should be
       * used with caution as it prevents the overflow algorithm from moving such widgets into the overflow
       * popup which may result in not clearing enough space to avoid overflowing the toolbar.
       * @config {Boolean|String}
       * @default true
       * @category Layout
       * @internal
       */
      overflowable: {
        value: null,
        default: true,
        $config: null
      },
      /**
       * Widget's width, used to set element style.width. Either specify a valid width string or a number, which
       * will get 'px' appended. We recommend using CSS as the primary way to control width, but in some cases
       * this config is convenient.
       * @config {String|Number}
       * @category Layout
       */
      width: null,
      /**
       * Widget's height, used to set element style.height. Either specify a valid height string or a number, which
       * will get 'px' appended. We recommend using CSS as the primary way to control height, but in some cases
       * this config is convenient.
       * @config {String|Number}
       * @category Layout
       */
      height: null,
      /**
       * The element's maxHeight. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-height}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      maxHeight: null,
      /**
       * The elements maxWidth. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-width}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      maxWidth: null,
      /**
       * The elements minWidth. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-width}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      minWidth: null,
      /**
       * The element's minHeight. Can be either a String or a Number (which will have 'px' appended). Note that
       * like {@link #config-height}, _reading_ the value will return the numeric value in pixels.
       * @config {String|Number}
       * @category Layout
       */
      minHeight: null,
      // not public, only used by us in docs
      scaleToFitWidth: null,
      allowGrowWidth: true,
      // only used if scaleToFitWidth is true
      /**
       * Get element's margin property. This may be configured as a single number or a `TRBL` format string.
       * numeric-only values are interpreted as pixels.
       * @member {Number|String} margin
       * @category Layout
       */
      /**
       * Widget's margin. This may be configured as a single number or a `TRBL` format string.
       * numeric-only values are interpreted as pixels.
       * @config {Number|String}
       * @category Layout
       */
      margin: null,
      /**
       * Get element's flex property. This may be configured as a single number or a format string:
       *
       *      <flex-grow> <flex-shrink> <flex-basis>
       *
       * Numeric-only values are interpreted as the `flex-grow` value.
       * @member {Number|String} flex
       * @category Layout
       */
      /**
       * When this widget is a child of a {@link Core.widget.Container}, it will by default be participating in a
       * flexbox layout. This config allows you to set this widget's
       * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex">flex</a> style.
       * This may be configured as a single number or a `<flex-grow> <flex-shrink> <flex-basis>` format string.
       * numeric-only values are interpreted as the `flex-grow` value.
       * @config {Number|String}
       * @category Layout
       */
      flex: null,
      /**
       * A widgets weight determines its position among siblings when added to a {@link Core.widget.Container}.
       * Higher weights go further down.
       * @config {Number}
       * @category Layout
       */
      weight: null,
      /**
       * Get/set this widget's `align-self` flexbox setting. This may be set to modify how this widget is aligned
       * within the cross axis of a flexbox layout container.
       * @member {String} alignSelf
       * @category Layout
       */
      /**
       * When this widget is a child of a {@link Core.widget.Container}, it will by default be participating in a
       * flexbox layout. This config allows you to set this widget's
       * <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-self">align-self</a> style.
       * @config {String}
       * @category Layout
       */
      alignSelf: null,
      /**
       * Configure as `true` to have the component display a translucent ripple when its
       * {@link #property-focusElement}, or {@link #property-element} is tapped *if the
       * current theme supports ripples*. Out of the box, only the Material theme supports ripples.
       *
       * This may also be a config object containing the properties listed below.
       *
       * eg:
       *```
       *    columns  : [{}...],
       *    ripple   : {
       *        color : 'red',
       *        clip  : '.b-grid-row'
       *    },
       *    ...
       *```
       * @config {Boolean|Object}
       * @property {String} [delegate] A CSS selector to filter which child elements trigger ripples. By default,
       * the ripple is clipped to the triggering element.
       * @property {String} [color='#000'] A CSS color name or specification.
       * @property {Number} [radius=100] The ending radius of the ripple. Note that it will be clipped by the
       * target element by default.
       * @property {String} [clip] A string which describes how to clip the ripple if it is not to be clipped to
       * the default element. Either the property of the widget to use as the clipping element, or a selector to
       * allow clipping to the closest matching ancestor to the target element.
       * @category Misc
       */
      ripple: null,
      /**
       * A title to display for the widget. Only in effect when inside a container that uses it (such as TabPanel)
       * @default
       * @config {String}
       * @category DOM
       */
      title: null,
      localizableProperties: ["title", "ariaLabel", "ariaDescription"],
      // Set this flag to require element to have a size to be considered visible
      requireSize: false,
      /**
       * An identifier by which this widget will be registered in the {@link Core.widget.Container#property-widgetMap}
       * of all ancestor containers.
       *
       * If omitted, this widget will be registered using its {@link #config-id}. In most cases `ref` is
       * preferable over `id` since `id` is required to be globally unique while `ref` is not.
       *
       * The `ref` value is also added to the elements dataset, to allow targeting it using CSS etc.
       * @prp {String}
       * @readonly
       * @category Misc
       */
      ref: null,
      /**
       * Get/set the widget hidden state.
       *
       * Note: `hidden : false` does *not* mean that this widget is definitely visible.
       * To ascertain visibility, use the {@link #property-isVisible} property.
       * @member {Boolean} hidden
       * @category Visibility
       */
      /**
       * Configure with true to make widget initially hidden.
       * @default false
       * @config {Boolean}
       * @category Layout
       */
      hidden: null,
      /**
       * Text alignment: 'left', 'center' or 'right'. Also accepts direction neutral 'start' and 'end'.
       *
       * Applied by adding a `b-text-align-xx` class to the widgets element. Blank by default, which does not add
       * any alignment class.
       *
       * To be compliant with RTL, 'left' yields same result as 'start' and 'right' as 'end'.
       *
       * @config {'left'|'center'|'right'|'start'|'end'}
       * @category Layout
       */
      textAlign: null,
      // When adding our scroll listeners to hide/realign, we ignore events
      // happening too quickly as a result of the show/align action
      ignoreScrollDuration: 500,
      /**
       * The tag name of this Widget's root element
       * @config {String}
       * @default
       * @category DOM
       * @advanced
       */
      tag: "div",
      /**
       * Set this config to `false` to disable batching DOM updates on animation frames for this widget. This
       * has the effect of synchronously updating the DOM when configs affecting the rendered DOM are modified.
       * Depending on the situation, this could simplify code while increasing time spent updating the DOM.
       * @config {Boolean}
       * @default true
       * @internal
       */
      recomposeAsync: null,
      /**
       * If you are rendering this widget to a shadow root inside a web component, set this config to the shadowRoot
       * @config {ShadowRoot}
       * @default
       * @category Misc
       */
      rootElement: null,
      htmlMutationObserver: {
        $config: ["lazy", "nullify"],
        value: {
          childList: true,
          subtree: true
        }
      },
      role: {
        $config: "lazy",
        value: "presentation"
      },
      /**
       * A localizable string (May contain `'L{}'` tokens which resolve in the locale file) to inject as
       * the `aria-label` attribute.
       *
       * This widget is passed as the `templateData` so that functions in the locale file can
       * interrogate the widget's state.
       * @config {String}
       * @category Accessibility
       * @advanced
       */
      ariaLabel: {
        $config: "lazy",
        value: null
      },
      /**
       * A localizable string (May contain `'L{}'` tokens which resolve in the locale file) to inject
       * into an element which will be linked using the `aria-describedby` attribute.
       *
       * This widget is passed as the `templateData` so that functions in the locale file can
       * interrogate the widget's state.
       * @config {String}
       * @category Accessibility
       * @advanced
       */
      ariaDescription: {
        $config: "lazy",
        value: null
      },
      ariaElement: "element",
      ariaHasPopup: null,
      realignTimeout: 300,
      testConfig: {
        ignoreScrollDuration: 100,
        realignTimeout: 50
      },
      /**
       * _Only valid if this Widget is {@link #config-floating}._
       *
       * When configured as `true`, this widget uses {@link Core.helper.BrowserHelper#property-isMobile-static}
       * to maximize itself on mobile devices.
       * @prp {Number|String}
       * @category Float & align
       */
      maximizeOnMobile: null
    };
  }
  static get prototypeProperties() {
    return {
      /**
       * true if no id was set, will use generated id instead (widget1, ...). Toggle automatically on creation
       * @member {Boolean} hasGeneratedId
       * @private
       * @category Misc
       */
      hasGeneratedId: false,
      /**
       * This readonly property is `true` for normal widgets in the {@link Core.widget.Container#config-items} of
       * a container. It is `false` for special widgets such as a {@link Core.widget.Panel#config-tbar}.
       * @member {Boolean} innerItem
       * @internal
       * @category Misc
       */
      innerItem: true
    };
  }
  static get declarable() {
    return [
      /**
       * This property declares the set of config properties that affect a Widget's rendering, i.e., the configs
       * used by the {@link #function-compose} method.
       *
       * For example:
       * ```javascript
       *  class Button extends Widget {
       *      static renderConfigs = [ 'cls', 'iconCls', 'text' ];
       *  }
       * ```
       *
       * Alternatively this can be an object:
       *
       * ```javascript
       *  class Button extends Widget {
       *      static renderConfigs = {
       *          cls     : true,
       *          iconCls : true,
       *          text    : true
       *      };
       *  }
       * ```
       * @member {Object|String[]} renderConfigs
       * @static
       * @category Configuration
       * @internal
       */
      "renderConfigs"
    ];
  }
  /**
   * An object providing the `record` and `column` for a widget embedded inside a {@link Grid.column.WidgetColumn}
   *
   * ```javascript
   * columns : [
   *    {
   *        type   : 'widget',
   *        widgets: [{
   *            type     : 'button',
   *            icon     : 'b-fa b-fa-trash',
   *            onAction : ({ source : btn }) => btn.cellInfo.record.remove()
   *        }]
   *    }
   * ]
   * ```
   * @readonly
   * @member {Object} cellInfo
   * @property {Core.data.Model} cellInfo.record Record for the widgets row
   * @property {Object} cellInfo.column Column the widget is displayed in
   * @category Misc
   */
  static get delayable() {
    return {
      recompose: "raf",
      doHideOrRealign: "raf",
      // Screen size and orientation changes must be buffered in line with.
      // ResponsiveMixin whose responsiveUpdate method is on a RAF.
      onAlignConstraintChange: "raf"
    };
  }
  static get factoryable() {
    return {
      defaultType: "widget"
    };
  }
  static get identifiable() {
    return {};
  }
  /**
   * Returns an array containing all existing Widgets. The returned array is generated by this call and is not an
   * internal structure.
   * @property {Core.widget.Widget[]}
   * @readonly
   * @internal
   */
  static get all() {
    return super.all;
  }
  /**
   * Get/set the {@link #config-recomposeAsync} config for all widgets. Setting this value will set the config for
   * all existing widgets and will be the default value for newly created widgets. Set this value to `null` to disable
   * the default setting for new widgets while leaving existing widgets unaffected.
   * @property {Boolean}
   * @internal
   */
  static get recomposeAsync() {
    return _Widget._recomposeAsync;
  }
  static set recomposeAsync(value) {
    _Widget._recomposeAsync = value;
    if (value != null) {
      const { all } = _Widget;
      for (let i = 0; i < all.length; ++i) {
        if (all[i].isComposable) {
          all[i].recomposeAsync = value;
        }
      }
    }
  }
  isType(type, deep) {
    return _Widget.isType(this, type, deep);
  }
  static setupRenderConfigs(cls, meta) {
    const classRenderConfigs = meta.getInherited("renderConfigs"), { renderConfigs } = cls;
    if (renderConfigs) {
      if (Array.isArray(renderConfigs)) {
        for (const name of renderConfigs) {
          classRenderConfigs[name] = true;
        }
      } else {
        ObjectHelper.assign(classRenderConfigs, renderConfigs);
      }
      classRenderConfigs[renderConfigObserver] = null;
    }
  }
  /**
   * Call once per class for custom widgets to have them register with the `Widget` class, allowing them to be created
   * by type.
   *
   * For example:
   * ```javascript
   * class MyWidget extends Widget {
   *   static get type() {
   *     return 'mywidget';
   *   }
   * }
   * MyWidget.initClass();
   * ```
   * @method initClass
   * @static
   * @category Lifecycle
   * @advanced
   */
  //endregion
  //region Init & destroy
  construct(config = {}, ...args) {
    const me = this, { domSyncCallback } = me;
    if (!globalThis.bryntum.cssVersion) {
      const cssVersion = globalThis.bryntum.cssVersion = CSSHelper.getCSSVersion(), jsVersion = VersionHelper.getVersion("core");
      if (cssVersion && cssVersion !== jsVersion) {
        console.warn(`CSS version ${cssVersion} doesn't match bundle version ${jsVersion}!
Make sure you have imported css from the appropriate product version.`);
      }
    }
    me.configureAriaDescription = config.ariaDescription;
    me._isAnimatingCounter = 0;
    me.alignmentChanges = 0;
    me.byRef = /* @__PURE__ */ Object.create(null);
    me.onTargetResize = me.onTargetResize.bind(me);
    me.onFullscreenChange = me.onFullscreenChange.bind(me);
    me.domSyncCallback = domSyncCallback.$nullFn ? null : domSyncCallback.bind(me);
    me._isUserAction = false;
    super.construct(config, ...args);
    const { recomposeAsync } = _Widget;
    if (recomposeAsync != null && me.recomposeAsync == null) {
      me.recomposeAsync = recomposeAsync;
    }
    me.finalizeInit();
  }
  startConfigure(config) {
    super.startConfigure(config);
    const me = this, { adopt, element } = me;
    if (adopt) {
      me.adoptElement(element, adopt, config.id);
      me.updateElement(me._element, element);
    }
  }
  /**
   * Called by the Base constructor after all configs have been applied.
   * @internal
   * @category Lifecycle
   */
  finalizeInit() {
    var _a2;
    const me = this, refElement = me.insertBefore || me.appendTo || me.insertFirst || me.adopt;
    if (refElement) {
      if (me.owner || ((_a2 = refElement.nodeType ? refElement : document.getElementById(refElement)) == null ? void 0 : _a2.isConnected)) {
        me.render();
      } else {
        me.onFirstResizeAfterConnect = me.onFirstResizeAfterConnect.bind(me);
        ResizeMonitor.addResizeListener(refElement, me.onFirstResizeAfterConnect);
      }
    }
  }
  onFirstResizeAfterConnect(el) {
    ResizeMonitor.removeResizeListener(el, this.onFirstResizeAfterConnect);
    if (!this.isDestroyed && !this.rendered) {
      this.render();
    }
  }
  doDestroy() {
    var _a2, _b, _c, _d;
    const me = this, {
      preExistingElements,
      element,
      adopt,
      _refListeners,
      _rootElement,
      eventRoot
    } = me;
    if (Fullscreen.element === element) {
      Fullscreen.exit();
    }
    if (_refListeners) {
      Object.values(_refListeners, (un) => un());
      me._refListeners = null;
    }
    if (element) {
      const sharedTooltip = !me._tooltip && _rootElement && ((_a2 = _Widget.Tooltip) == null ? void 0 : _a2.getSharedTooltip(_rootElement, eventRoot, true));
      if ((sharedTooltip == null ? void 0 : sharedTooltip.owner) === me) {
        sharedTooltip.owner = null;
        sharedTooltip.hide();
      }
      me.onExitFullscreen();
      me.clearTimeout(me.scrollListenerTimeout);
      me.clearTimeout(me.resizeListenerTimeout);
      me.removeTransientListeners();
      if (me.floating || me.positioned) {
        me.hide(false);
      } else {
        me.revertFocus();
      }
      ResizeMonitor.removeResizeListener(element.parentElement, me.onParentElementResize);
      ResizeMonitor.removeResizeListener(element, me.onElementResize);
      if (adopt) {
        for (let nodes = Array.from(element.childNodes), i = 0, { length } = nodes; i < length; i++) {
          const el = nodes[i];
          if (!preExistingElements.includes(el) && el !== me.floatRoot) {
            el.remove();
          }
        }
        element.className = me.adoptedElementClassName;
        element.style.cssText = me.adoptedElementCssText;
      }
      (_b = me.dragEventDetacher) == null ? void 0 : _b.call(me);
      (_c = me.dragOverEventDetacher) == null ? void 0 : _c.call(me);
      me.dragGhost.remove();
    }
    (_d = me.connectedObserver) == null ? void 0 : _d.disconnect();
    super.doDestroy();
    if (eventRoot && !Object.values(_Widget.identifiable.idMap).some(isSingletonWidget)) {
      GlobalEvents_default.detachFocusListeners(eventRoot);
    }
    if (!adopt) {
      element.remove();
    }
  }
  //endregion
  //region Values
  get assignValueDefaults() {
    return assignValueDefaults;
  }
  get valueName() {
    return this.name || this.ref || this.id;
  }
  getValueName(onlyName) {
    onlyName = onlyName && typeof onlyName === "object" ? onlyName.onlyName : onlyName;
    return onlyName ? this.name : this.valueName;
  }
  assignFieldValue(values, key, value) {
    const me = this, valueBindProperty = me.defaultBindProperty;
    if (valueBindProperty in me) {
      me[valueBindProperty] = value;
    }
  }
  assignValue(values, options = assignValueDefaults) {
    const me = this, hec = me[highlightExternalChange], key = me.getValueName(options);
    if (key && (!values || key in values)) {
      if (options.highlight === false) {
        me[highlightExternalChange] = false;
      }
      me.assignFieldValue(values, key, values ? values[key] : null);
      me[highlightExternalChange] = hec;
    }
  }
  gatherValue(values) {
    const me = this, valueBindProperty = me.defaultBindProperty;
    if (me.constructor !== _Widget && valueBindProperty in me) {
      values[me.name || me.ref || me.id] = me[valueBindProperty];
    }
  }
  gatherValues(values) {
    this.eachWidget((widget) => widget.gatherValue(values), false);
  }
  //endregion
  get forwardTwinEvents() {
    const value = this._forwardTwinEvents;
    return value && ObjectHelper.getTruthyKeys(value);
  }
  /**
   * This widget's twin that is placed in an overflow menu when this widget has been hidden by its owner, typically
   * a {@link Core.widget.Toolbar} due to {@link Core.widget.Toolbar#config-overflow}. The `overflowTwin` is created
   * lazily by {@link #function-ensureOverflowTwin}.
   *
   * @member {Core.widget.Widget} overflowTwin
   * @readonly
   * @internal
   */
  /**
   * This method returns the config object to use for creating this widget's {@link #property-overflowTwin}.
   *
   * @param {Function|Object} [overrides] If an object is passed, it is a set of config properties to override the
   * config object returned by {@link #function-configureOverflowTwin}. If a function is passed, it is called with
   * the config object. The function may either alter the object it is given or return a replacement.
   * @returns {Object} The `overflowTwin` config object
   * @internal
   */
  configureOverflowTwin(overrides) {
    var _a2;
    const me = this;
    let config = ObjectHelper.clone(me.initialConfig);
    delete config.id;
    config.hidden = false;
    config.type = me.type;
    config._overflowTwinOrigin = me;
    config.disabled = me.disabled;
    if ("value" in me) {
      config.value = me.value;
    }
    (_a2 = me.forwardTwinEvents) == null ? void 0 : _a2.forEach((ev) => {
      delete config[`on${StringHelper.capitalize(ev)}`];
    });
    if (overrides) {
      config = typeof overrides === "function" ? overrides(config) || config : ObjectHelper.assign(config, overrides);
    }
    return config;
  }
  /**
   * This method creates the {@link #property-overflowTwin} for this widget. It is called by
   * {@link #function-ensureOverflowTwin} if the `overflowTwin` does not yet exist.
   *
   * The config for the {@link #property-overflowTwin} is produced by {@link #function-configureOverflowTwin}.
   *
   * @param {Function|Object} [overrides] If an object is passed, it is a set of config properties to override the
   * config object returned by {@link #function-configureOverflowTwin}. If a function is passed, it is called with
   * the config object. The function may either alter the object it is given or return a replacement.
   * @returns {Core.widget.Widget} The `overflowTwin`
   * @internal
   */
  createOverflowTwin(overrides) {
    var _a2;
    const me = this, config = me.configureOverflowTwin(overrides), overflowTwin = _Widget.create(config);
    (_a2 = me.forwardTwinEvents) == null ? void 0 : _a2.forEach((ev) => {
      overflowTwin.ion({
        [ev]: (info) => {
          if (me.overflowTwin === info.source) {
            info = ObjectHelper.assign({}, info);
            delete info.source;
            me.trigger(info.eventName, info);
          }
        }
      });
    });
    return overflowTwin;
  }
  /**
   * This method returns the existing {@link #property-overflowTwin} or creates it, if it has not yet been created
   * (see {@link #function-createOverflowTwin}).
   *
   * @param {Function|Object} [overrides] If an object is passed, it is a set of config properties to override the
   * config object returned by {@link #function-configureOverflowTwin}. If a function is passed, it is called with
   * the config object. The function may either alter the object it is given or return a replacement.
   * @param {Function} [onCreate] A function to call when the `overflowTwin` is initially created.
   * @returns {Core.widget.Widget} The `overflowTwin`
   * @internal
   */
  ensureOverflowTwin(overrides, onCreate) {
    let { overflowTwin } = this;
    if (!overflowTwin) {
      this.overflowTwin = overflowTwin = this.createOverflowTwin(overrides);
      onCreate == null ? void 0 : onCreate(overflowTwin);
    }
    return overflowTwin;
  }
  //---------------------------------------------------------------------------------------------------------
  //region Render
  /**
   * Returns `true` if this class uses `compose()` to render itself.
   * @returns {Boolean}
   * @internal
   */
  get isComposable() {
    return !this.compose.$nullFn;
  }
  adoptElement(element, adopt, id) {
    var _a2;
    const me = this, adoptElement = typeof adopt === "string" ? document.getElementById(adopt) : adopt, previousHolder = _Widget.fromElement(adoptElement);
    if (previousHolder && previousHolder.adopt && previousHolder !== me) {
      const previousHolderAdopt = typeof previousHolder.adopt === "string" ? document.getElementById(previousHolder.adopt) : previousHolder.adopt;
      if (previousHolderAdopt === adoptElement) {
        previousHolder.destroy();
      }
    }
    me.preExistingElements = Array.from(adoptElement.childNodes);
    me.adoptedElementClassName = adoptElement.className;
    me.adoptedElementCssText = adoptElement.style.cssText;
    if (adoptElement.id && !id) {
      me.id = element.id = adoptElement.id;
    }
    DomHelper.syncAttributes(element, adoptElement);
    for (let i = 0, { length } = element.childNodes; i < length; i++) {
      adoptElement.appendChild(element.childNodes[0]);
    }
    delete me._contentRange;
    me._element = adoptElement;
    const domConfig = element.lastDomConfig, listeners = domConfig == null ? void 0 : domConfig.listeners;
    if (listeners && me.isComposable) {
      (_a2 = listeners.un) == null ? void 0 : _a2.call(listeners);
      addElementListeners(me, adoptElement, domConfig);
    }
    adoptElement.lastDomConfig = domConfig || adoptElement.lastDomConfig;
    adoptElement.$refOwnerId = me.id;
    if (!me.scaleToFitWidth) {
      me.getConfig("monitorResize");
    }
  }
  /**
   * Defines an element reference accessor on the class prototype. This accessor is used to flush any pending DOM
   * changes prior to accessing such elements.
   * @param {String} name
   * @param {String} key
   * @private
   */
  addRefAccessor(name, key) {
    const { prototype: prototype2 } = this.constructor;
    defineProperty7(prototype2, key, {
      writable: true,
      value: null
    });
    defineProperty7(prototype2, name, {
      get() {
        this.recompose.flush();
        return this[key];
      },
      set(el) {
        this[key] = el;
      }
    });
  }
  /**
   * This method is called by `DomHelper.createElement` and `DomSync.sync` as new reference elements are created.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {DomConfig} [domConfig] The DOM config object.
   * @internal
   */
  attachRef(name, el, domConfig) {
    const me = this, key = "_" + name;
    el.dataset && (el.dataset.ownerCmp = me.id);
    if (me.isComposable) {
      if (!(key in me)) {
        me.addRefAccessor(name, key);
      }
      addElementListeners(me, el, domConfig, name);
    }
    me.byRef[name] = el;
    me[name] = el;
  }
  /**
   * This method is called by `DomSync.sync` as reference elements are removed from the DOM.
   * @param {String} name The name of the element, i.e., the value of its `reference` attribute.
   * @param {HTMLElement} el The element instance
   * @param {DomConfig} domConfig The DOM config object.
   * @internal
   */
  detachRef(name, el, domConfig) {
    const me = this, listeners = me._refListeners;
    if (listeners == null ? void 0 : listeners[name]) {
      listeners[name]();
      delete listeners[name];
    }
    me[name] = null;
    delete me.byRef[name];
  }
  /**
   * This method is called following an update to the widget's rendered DOM.
   * @internal
   */
  afterRecompose() {
  }
  /**
   * Returns a {@link Core.helper.DomHelper#function-createElement-static} config object that defines this widget's
   * DOM structure. This object should be determined using {@link Core.Base#property-configurable-static} properties
   * to ensure this method is called again if these properties are modified.
   *
   * For more information see {@link Core.widget.Widget class documentation}.
   * @returns {DomConfig}
   * @advanced
   */
  compose() {
    return {
      class: DomClassList.normalize(this.widgetClassList, "object")
    };
  }
  /**
   * This method iterates the class hierarchy from Widget down to the class of this instance and calls any `compose`
   * methods implemented by derived classes.
   * @returns {Object}
   * @private
   */
  doCompose() {
    const me = this, { $meta: meta } = me, classes = meta.hierarchy, renderConfigs = meta.renderConfigs || meta.getInherited("renderConfigs");
    let { composers } = meta, domConfig = null, c, key, i, proto4;
    me.recompose.suspend();
    if (!composers) {
      meta.composers = composers = [];
      for (i = classes.indexOf(_Widget); i < classes.length; ++i) {
        proto4 = classes[i].prototype;
        if (hasOwn4(proto4, "compose")) {
          composers.push(proto4);
        }
      }
      if (!hasOwn4(renderConfigs, renderConfigObserver)) {
        renderConfigs[renderConfigObserver] = {
          get(name) {
            renderConfigs[name] = true;
          }
        };
      }
    }
    me.configObserver = renderConfigs[renderConfigObserver];
    for (i = 0; i < composers.length; ++i) {
      c = composers[i].compose.call(me, domConfig);
      domConfig = domConfig ? DomHelper.merge(domConfig, c) : c;
    }
    if (hasOwn4(me, "compose") && (c = me.compose)) {
      c = c.call(me, domConfig);
      DomHelper.merge(domConfig, c);
    }
    me.configObserver = null;
    return DomHelper.normalizeChildren(domConfig, (childName, hoist) => {
      if (hoist) {
        key = "_" + childName;
        if (!(key in me)) {
          me.addRefAccessor(childName, key);
        }
      }
    });
  }
  get element() {
    if (this.isComposable && !this.isDestroying) {
      this.recompose.flush();
    }
    return this._element;
  }
  /**
   * Template method called during DOM updates. See {@link Core.helper.DomSync#function-sync-static DomSync.sync()}.
   * @param {Object} info Properties describing the sync action taken.
   * @internal
   */
  domSyncCallback(info) {
  }
  changeElement(element) {
    const me = this, compose = me.isComposable;
    if (compose) {
      element = me.doCompose();
    }
    if (typeof element === "string") {
      element = DomHelper.createElementFromTemplate(element);
    } else if (ObjectHelper.isObject(element)) {
      element = DomHelper.createElement(element, {
        refOwner: me,
        callback: me.domSyncCallback
        // mimic DomSync callbacks (needed by TaskBoard)
      });
      me.recompose.resume();
      compose && addElementListeners(me, element, element.lastDomConfig);
    } else if (DomHelper.isReactElement(me.peekConfig("html"))) {
      element = document.createElement("div");
    } else if (element.nodeType !== 1) {
      element = DomHelper.createElementFromTemplate(me.template(me));
    }
    element.id = me.id;
    if (me.elementAttributes) {
      DomHelper.setAttributes(element, me.elementAttributes);
    }
    return element;
  }
  updateElement(element) {
    const me = this, { className } = element, { contentElement, contentElementCls, isComposable } = me, hasChildContent = contentElement !== element, namedElements = !isComposable && element.querySelectorAll("[data-reference]"), classes = isComposable ? [] : me.widgetClassList;
    let uiClasses = (hasChildContent || !isComposable) && me.uiClasses;
    className && classes.unshift(className);
    me._hidden && classes.push("b-hidden");
    me._readOnly && classes.push("b-readonly");
    FunctionHelper.noThrow(
      element,
      "remove"
      /*, () => { debugger; } /**/
    );
    if (uiClasses) {
      if (contentElementCls == null ? void 0 : contentElementCls.value) {
        uiClasses = uiClasses.slice();
        uiClasses.push(contentElementCls.value);
      }
      uiClasses = uiClasses.join(" ");
    } else {
      uiClasses = contentElementCls == null ? void 0 : contentElementCls.value;
    }
    if (uiClasses) {
      if (hasChildContent) {
        contentElement.className += " " + uiClasses;
      } else {
        classes.push(uiClasses);
      }
    }
    if (!me.parent) {
      const { defaultCls } = me, { outerCls } = _Widget;
      classes.push(...defaultCls ? outerCls.filter((c) => !(c in defaultCls) || defaultCls[c]) : outerCls);
    }
    element.className = classes.join(" ");
    if (namedElements) {
      for (let el, i = 0; i < namedElements.length; ++i) {
        el = namedElements[i];
        me.attachRef(el.getAttribute("data-reference"), el);
        el.removeAttribute("data-reference");
      }
    }
    if (!me.adopt && !me.scaleToFitWidth) {
      me.getConfig("monitorResize");
    }
    me.getConfig("role");
    me.getConfig("ariaLabel");
    me.getConfig("ariaDescription");
    if (me._html) {
      me.getConfig("htmlMutationObserver");
    }
    me.trigger("elementCreated", { element });
  }
  updateAriaDescription(ariaDescription) {
    const { ariaElement } = this, descElId = `${this.id}-aria-desc-el`;
    if (ariaDescription) {
      const ariaDescEl = this._ariaDescEl || (this._ariaDescEl = DomHelper.createElement({
        className: "b-aria-desc-element",
        id: descElId,
        parent: ariaElement
      }));
      ariaDescEl.innerText = ariaDescription.match(localizeRE) ? this.L(ariaDescription, this) : ariaDescription;
      ariaElement.setAttribute("aria-describedBy", ariaDescEl.id);
    } else if (ariaElement.getAttribute("aria-describedby") === descElId) {
      ariaElement.removeAttribute("aria-describedBy");
    }
  }
  updateAriaLabel(ariaLabel) {
    DomHelper.setAttributes(this.ariaElement, {
      "aria-label": (ariaLabel == null ? void 0 : ariaLabel.match(localizeRE)) ? this.L(ariaLabel, this) : ariaLabel
    });
  }
  updateAriaHasPopup(ariaHasPopup) {
    DomHelper.setAttributes(this.ariaElement, {
      "aria-haspopup": ariaHasPopup
    });
  }
  updateRole(role) {
    var _a2, _b;
    if (role) {
      (_a2 = this.ariaElement) == null ? void 0 : _a2.setAttribute("role", role);
    } else {
      (_b = this.ariaElement) == null ? void 0 : _b.removeAttribute("role");
    }
  }
  get ariaElement() {
    this.getConfig("element");
    const { _ariaElement } = this;
    return _ariaElement.nodeType === Node.ELEMENT_NODE ? _ariaElement : ObjectHelper.getPath(this, _ariaElement);
  }
  /**
   * This method determines if this widget (typically a {@link Core.widget.Tool}) should be placed in the header of
   * the calling {@link Core.widget.Panel}.
   * @param {Object} options An object specifying various options.
   * @param {Boolean} options.collapsed True if the panel is in a {@link Core.widget.Panel#config-collapsed} state.
   * @param {Boolean} options.alt True if the panel is rendering its alternate panel header, false for the primary header.
   * @returns {Boolean}
   * @internal
   */
  isCollapsified({ collapsed, alt: alt2 }) {
    const { collapsify } = this, hideIfCollapsed = collapsify === "hide", alwaysPrimary = collapsify === false, altIfCollapsedElsePrimary = collapsify == null, alwaysAlt = collapsify === "overlay";
    return alt2 ? alwaysAlt || altIfCollapsedElsePrimary && collapsed : alwaysPrimary || hideIfCollapsed || altIfCollapsedElsePrimary && !collapsed;
  }
  /**
   * Calling this {@link Core.mixin.Delayable#property-delayable-static} method marks this widget as dirty. The DOM
   * will be updated on the next animation frame:
   *
   * ```javascript
   *  widget.recompose();
   *
   *  console.log(widget.recompose.isPending);
   *  > true
   * ```
   *
   * A pending update can be flushed by calling `flush()` (this does nothing if no update is pending):
   *
   * ```javascript
   *  widget.recompose.flush();
   * ```
   *
   * This can be combined in one call to force a DOM update without first scheduling one:
   *
   * ```javascript
   *  widget.recompose.now();
   * ```
   * @advanced
   */
  async recompose() {
    const me = this, options = {
      targetElement: me.element,
      domConfig: me.doCompose(),
      refOwner: me,
      callback: me.domSyncCallback,
      // This limits the sync() to only removing the classes and styles added by previous renderings. This
      // allows dynamically added styles and classes to be preserved:
      strict: true
    };
    if (me.transitionRecompose) {
      me.isTransitioningDom = true;
      await DomHelper.transition(ObjectHelper.assign({
        element: me.element,
        action() {
          DomSync.sync(options);
        }
      }, me.transitionRecompose));
      if (me.isDestroyed) {
        return;
      }
      me.isTransitioningDom = false;
      me.trigger("transitionedRecompose");
    } else {
      DomSync.sync(options);
    }
    if (options.changed) {
      me.afterRecompose();
      me.trigger("recompose");
    }
    me.resumeRecompose();
  }
  // To allow hooking into resuming recompose, used by TaskBoard
  resumeRecompose() {
    this.recompose.resume();
  }
  changeElementRef(el) {
    if (typeof el === "string") {
      const id = el;
      if (!(el = document.getElementById(id))) {
        throw new Error(`No element found with id '${id}'`);
      }
    }
    return el;
  }
  changeAppendTo(appendTo) {
    return this.changeElementRef(appendTo);
  }
  updateAppendTo(appendTo) {
    if (!this.isConfiguring && appendTo) {
      this.render();
    }
  }
  changeInsertBefore(insertBefore) {
    return this.changeElementRef(insertBefore);
  }
  updateInsertBefore(insertBefore) {
    if (!this.isConfiguring && insertBefore) {
      this.render();
    }
  }
  changeInsertFirst(insertFirst) {
    return this.changeElementRef(insertFirst);
  }
  updateInsertFirst(insertFirst) {
    if (!this.isConfiguring && insertFirst) {
      this.render();
    }
  }
  /**
   * Interprets the {@link #config-appendTo}, {@link #config-insertBefore} and {@link #config-insertFirst}
   * configs to return an array containing `[parentElement, insertBefore]`
   * @internal
   * @param {Core.widget.Widget} source The widget for which to ascertain its render context.
   * @returns {HTMLElement[]} The `[parentElement, insertBefore]` elements.
   */
  getRenderContext(config = this, renderTo) {
    let parentElement = renderTo || config.appendTo, { insertFirst, insertBefore } = config;
    if (insertFirst) {
      parentElement = insertFirst;
      insertBefore = parentElement.firstChild;
    }
    if (insertBefore) {
      if (!parentElement) {
        parentElement = insertBefore.parentElement;
      }
    }
    return [parentElement, insertBefore || void 0];
  }
  render(renderTo, triggerPaint = true) {
    const me = this, { element } = me, [
      parentElement,
      insertBefore
    ] = me.getRenderContext(me, renderTo);
    me.emptyCache();
    if (me.syncElement && me.currentElement) {
      DomHelper.sync(element, me.currentElement);
    } else {
      parentElement == null ? void 0 : parentElement.insertBefore(element, insertBefore);
      me.currentElement = element;
    }
    if (_Widget.fromElement(element.parentElement)) {
      element.classList.remove(..._Widget.outerCls);
    }
    super.render(parentElement, triggerPaint);
    me.rendered = true;
    me.getConfig("role");
    if (triggerPaint) {
      me.getConfig("contentRange");
      me.triggerPaint();
    }
    me.setupFocusListeners();
  }
  /**
   * A function which, when passed an instance of this Widget, produces a valid HTML string which is compiled
   * to create the encapsulating element for this Widget, and its own internal DOM structure.
   *
   * Note that this just creates the DOM structure that *this* Widget owns. If it contains child widgets
   * (Such as for example a grid), this is not included. The template creates own structure.
   *
   * Certain elements within the generated element can be identified as special elements with a `reference="name"`
   * property. These will be extracted from the element upon creation and injected as the named property into
   * the Widget. For example, a {@link Core.widget.TextField} will have an `input` property which is its
   * `<input>` element.
   * @param {Core.widget.Widget} me The widget for which to produce the initial HTML structure.
   * @internal
   */
  template({ tag, html, htmlCls, name }) {
    const me = this;
    if (typeof html === "string" && callbackRe.test(html) && me.resolveCallback(html, me, false)) {
      html = me.callback(html, me, [me]);
    }
    const content = (html == null ? void 0 : html.call) ? html.call(me, me) : html;
    return `<${tag} class="${content ? htmlCls : ""}" ${name ? `data-name="${name}"` : ""}>${content || ""}</${tag}>`;
  }
  updateRecomposeAsync(async) {
    this.recompose.immediate = !async;
  }
  //endregion
  //---------------------------------------------------------------------------------------------------------
  onConfigChange({ name }) {
    var _a2;
    if (this._element && !this.isDestroying && ((_a2 = this.$meta.renderConfigs) == null ? void 0 : _a2[name])) {
      this.recompose();
    }
  }
  //region Extract config
  // These functions are not meant to be called by any code other than Base#getCurrentConfig()
  // Clean up configs
  preProcessCurrentConfigs(configs) {
    super.preProcessCurrentConfigs(configs);
    delete configs.parent;
  }
  // Extract config's current value, special handling for style
  getConfigValue(name, options) {
    if (name === "style") {
      return this._style;
    }
    return super.getConfigValue(name, options);
  }
  // Extract current value of all initially used configs, special handling for widget type
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    if ((options == null ? void 0 : options.depth) > 0) {
      result.type = this.type;
    }
    return result;
  }
  //endregion
  /**
   * Get widgets elements dataset or assign to it
   * @property {Object}
   * @category DOM
   */
  get dataset() {
    return this.element.dataset;
  }
  changeDataset(dataset) {
    ObjectHelper.assign(this.dataset, dataset);
  }
  get dragGhost() {
    return this.constructor._dragGhost || (this.constructor._dragGhost = DomHelper.createElement({
      // Safari won't allow dragging an empty node
      html: "\xA0",
      style: "position:absolute;top:-10000em;left:-10000em"
    }));
  }
  updateParent(parent) {
    const { _element: element } = this;
    if (element) {
      element.classList[parent ? "remove" : "add"](..._Widget.outerCls);
    }
  }
  get constrainTo() {
    let result = this._constrainTo;
    result = result === void 0 ? globalThis : (result == null ? void 0 : result.nodeType) === Node.DOCUMENT_FRAGMENT_NODE ? result.host || result.ownerDocument : result;
    if (this.positioned) {
      const { offsetParent } = this.element;
      if (offsetParent && DomHelper.getStyleValue(offsetParent, "overflow") === "hidden") {
        result = Rectangle.from(offsetParent).moveTo(0, 0);
      } else if (result && !result.isRectangle) {
        const isViewport = result === document || result === globalThis;
        result = Rectangle.from(result, offsetParent);
        if (isViewport) {
          result.translate(globalThis.pageXOffset, globalThis.pageYOffset);
        }
      }
    }
    return result;
  }
  updateCentered(value) {
    const {
      element,
      _anchorElement
    } = this;
    if (value && !this.floating && !this.positioned) {
      throw new Error("`centered` is only relevant when a Widget is `floating` or `positioned`");
    }
    if (value) {
      element.classList.add("b-centered");
      element.style.transform = element.style.left = element.style.top = "";
      _anchorElement == null ? void 0 : _anchorElement.classList.add("b-hide-display");
      element.classList.remove("b-anchored");
    } else {
      element.classList.remove("b-centered");
    }
  }
  /**
   * The child element into which content should be placed. This means where {@link #config-html} should be put,
   * or, for {@link Core.widget.Container Container}s, where child items should be rendered.
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   * @advanced
   */
  get contentElement() {
    return this.element;
  }
  get contentRange() {
    const me = this, { contentElement } = me, contentRange = me._contentRange || (me._contentRange = new Range());
    if (contentRange.collapsed) {
      contentRange.setStart(contentElement, me.contentRangeStartOffset || 0);
      contentRange.setEnd(contentElement, me.contentRangeEndOffset || contentElement.childNodes.length);
    }
    return contentRange;
  }
  /**
   * This method fixes the element's `$refOwnerId` when this instance's `id` is changing.
   * @param {Node} el The element or DOM node to fix.
   * @param {String} id The new id being assigned.
   * @param {String} oldId The old id (previously assigned).
   * @private
   */
  fixRefOwnerId(el, id, oldId) {
    if (el.$refOwnerId === oldId) {
      el.$refOwnerId = id;
      for (let { childNodes } = el, i = childNodes.length; i-- > 0; ) {
        this.fixRefOwnerId(childNodes[i], id, oldId);
      }
    }
  }
  get placement() {
    var _a2;
    const me = this, { element } = me;
    let adjRect, placement, rect;
    if ((element == null ? void 0 : element.offsetParent) && !nonFlowedPositions.test(DomHelper.getStyleValue(element, "position"))) {
      const next = element.nextElementSibling, previous = element.previousElementSibling, last = !next && previous;
      placement = DomHelper.getStyleValue(element.parentElement, "flex-direction");
      if (placement) {
        placement = placement.startsWith("row") ? "h" : "v";
      } else {
        adjRect = (_a2 = next || previous) == null ? void 0 : _a2.getBoundingClientRect();
        rect = adjRect && element.getBoundingClientRect();
        placement = adjRect && Math.abs(adjRect.top - rect.top) < Math.abs(adjRect.left - rect.left) ? "h" : "v";
      }
      placement += placement === "h" ? last ? "r" : "l" : last ? "b" : "t";
    }
    return placement;
  }
  updateId(id, oldId) {
    super.updateId(id, oldId);
    if (oldId) {
      const { byRef, element } = this;
      for (const ref in byRef) {
        byRef[ref].dataset && (byRef[ref].dataset.ownerCmp = id);
      }
      element.id = id;
      this.fixRefOwnerId(element, id, oldId);
    }
  }
  /**
   * Get/set widgets elements style. The setter accepts a cssText string or a style config object, the getter always
   * returns a CSSStyleDeclaration
   * @property {CSSStyleDeclaration}
   * @accepts {String|Object|CSSStyleDeclaration}
   * @category DOM
   */
  get style() {
    const { element } = this;
    return (element == null ? void 0 : element.ownerDocument.defaultView.getComputedStyle(element)) || this._style;
  }
  updateStyle(style) {
    this.element && DomHelper.applyStyle(this.element, style);
  }
  updateTitle(title) {
    if (this.titleElement) {
      this.titleElement.innerHTML = title;
    }
  }
  //region floating
  // Hook used by Tooltip to handle RTL
  beforeAlignTo(spec) {
  }
  /**
   * If this Widget is {@link #config-floating} or {@link #config-positioned}, and visible, aligns the widget
   * according to the passed specification. To stop aligning, call this method without arguments.
   * @param {AlignSpec|HTMLElement} [spec] Alignment options. May be an alignment specification object, or an
   * `HTMLElement` to align to using this Widget's {@link #config-align} configuration.
   * @category Float & align
   */
  alignTo(spec) {
    var _a2;
    const me = this, {
      lastAlignSpec,
      element
    } = me, {
      offsetParent,
      style,
      classList
    } = element;
    if (lastAlignSpec) {
      lastAlignSpec.monitorIntersection && me.intersectionObserver.unobserve(lastAlignSpec.target);
      if (isFinite(lastAlignSpec.zone)) {
        element.classList.remove(alignedClass[lastAlignSpec.zone]);
      }
    }
    if (!spec) {
      me.removeTransientListeners();
      me.anchor = me.lastAlignSpec = null;
      return;
    }
    me.beforeAlignTo(spec);
    if (spec.nodeType === Element.ELEMENT_NODE || spec.isWidget || spec.$$name === "Point") {
      spec = {
        target: spec
      };
    }
    me.releaseSizeConstraints();
    const {
      scrollable,
      constrainTo
    } = me, elMinHeight = DomHelper.measureSize(DomHelper.getStyleValue(element, "minHeight"), element), elMinWidth = DomHelper.measureSize(DomHelper.getStyleValue(element, "minWidth"), element), positioned = me.positioned && DomHelper.getStyleValue(element, "position") !== "fixed", scale = me.scale || 1, passedTarget = spec.target, targetEvent = spec.domEvent || spec.event || passedTarget, target = (passedTarget == null ? void 0 : passedTarget.isRectangle) ? passedTarget : (passedTarget == null ? void 0 : passedTarget.element) || passedTarget, aligningToElement = (target == null ? void 0 : target.nodeType) === Element.ELEMENT_NODE, aligningToEvent = ((_a2 = targetEvent == null ? void 0 : targetEvent.target) == null ? void 0 : _a2.nodeType) === Element.ELEMENT_NODE;
    spec = spec.realignTarget ? spec : ObjectHelper.assign({
      aligningToEvent,
      aligningToElement,
      constrainTo,
      align: "b-t",
      // we can end up w/o a value for this if an object replaces a string
      axisLock: me.axisLock,
      anchor: me.anchor
    }, me.align, spec);
    const minWidth = spec.minWidth || elMinWidth, minHeight = spec.minHeight || elMinHeight;
    me.lastAlignSpec = spec;
    if (aligningToEvent) {
      delete spec.target;
      spec.domEvent = targetEvent;
      spec.anchoredTo = targetEvent.target;
      spec.position = new Point(targetEvent.clientX + 1, targetEvent.clientY + 1);
    } else if (aligningToElement) {
      spec.target = target;
      if (hasLayout(target instanceof SVGElement ? target.closest("svg") : target)) {
        spec = Object.setPrototypeOf({}, spec);
        spec.target = me.lastAlignSpec.targetRect = spec.realignTarget || (spec.allowTargetOut ? Rectangle.from(target, positioned ? offsetParent : null, !positioned) : DomHelper.isInView(target, false, me));
        if (!spec.target) {
          const result2 = me.hide();
          if (!me.isDestroyed) {
            me.lastAlignSpec.targetOutOfView = true;
          }
          return result2;
        }
        spec.target.height = Math.max(spec.target.height, 1);
        spec.target.width = Math.max(spec.target.width, 1);
        me.lastAlignSpec.anchoredTo = target;
      }
    }
    if (spec.anchor) {
      spec.anchorSize = me.anchorSize;
      if (!element.contains(me.anchorPathElement)) {
        element.appendChild(me.anchorElement);
      }
    }
    me.isAligning = true;
    me.trigger("beforeAlign", spec);
    const myPosition = Rectangle.from(element, positioned ? offsetParent : null, true), {
      width: startWidth,
      height: startHeight
    } = myPosition;
    myPosition.isAlignRectangle = true;
    minWidth && (myPosition.minWidth = minWidth * scale);
    minHeight && (myPosition.minHeight = minHeight * scale);
    me.isAligning = false;
    spec.rtl = me.rtl;
    if (spec.align.includes("s") || spec.align.includes("e")) {
      if (me.rtl) {
        spec.align = spec.align.replace(/s/g, "r").replace(/e/g, "l");
      } else {
        spec.align = spec.align.replace(/s/g, "l").replace(/e/g, "r");
      }
    }
    const result = me.lastAlignSpec.result = myPosition.alignTo(spec);
    let { align, anchor, x, y, width, height, overlap } = result;
    me.lastAlignSpec.zone = result.zone;
    if (height != startHeight) {
      const shrunk = height < startHeight;
      me.alignmentChanges = me.alignmentChanges | (shrunk ? 1 : 2);
      style[me.alignedHeightStyle = alignChangeDims[me.alignmentChanges & 3]] = `${height / scale}px`;
      if (shrunk && !me._minHeight && elMinHeight) {
        style.minHeight = `${Math.min(height, elMinHeight) / scale}px`;
      }
      if (scrollable) {
        scrollable.overflowY = shrunk;
      }
    }
    if (width != startWidth) {
      const shrunk = width < startWidth;
      me.alignmentChanges = me.alignmentChanges | (shrunk ? 4 : 8);
      style[me.alignedWidthStyle = alignChangeDims[me.alignmentChanges & 12]] = `${width / scale}px`;
      if (shrunk && !me._minWidth && elMinWidth) {
        style.minWidth = `${Math.min(width, elMinWidth) / scale}px`;
      }
      if (scrollable) {
        scrollable.overflowX = shrunk;
      }
    }
    if (align && me.alignmentChanges) {
      const newRect = Rectangle.from(element, positioned ? offsetParent : null, true);
      spec.align = align;
      const newResult = me.lastAlignSpec.result = newRect.alignTo(spec);
      anchor = newResult.anchor;
      x = newResult.x;
      y = newResult.y;
      width = newResult.width;
      height = newResult.height;
    }
    if (!me.centered) {
      me.setXY(x, y);
    }
    if (!result.overlap && isFinite(result.zone)) {
      classList.add(alignedClass[result.zone]);
    }
    if (anchor == null ? void 0 : anchor.edge) {
      const { edge } = anchor, { anchorElement } = me, { style: anchorStyle } = anchorElement, elRect = Rectangle.from(element), colorMatchPoint = [];
      if (edge === "top" || edge === "bottom") {
        colorMatchPoint[0] = anchor.x;
        colorMatchPoint[1] = edge === "top" ? 1 : elRect.height - 1;
      } else {
        colorMatchPoint[0] = edge === "left" ? 1 : elRect.width - 1;
        colorMatchPoint[1] = anchor.y;
      }
      anchorStyle.display = "none";
      let colourSource = DomHelper.childFromPoint(element, ...colorMatchPoint);
      if (((colourSource == null ? void 0 : colourSource.matches(":focus")) || colourSource === GlobalEvents_default.currentOverElement) && element.compareDocumentPosition(colourSource) & Node.DOCUMENT_POSITION_CONTAINED_BY) {
        colourSource = colourSource.parentNode;
      }
      if (colourSource && colourSource !== document) {
        let fillColour = DomHelper.getStyleValue(colourSource, "background-color");
        while (fillColour.match(isTransparent) && DomHelper.getStyleValue(colourSource, "position") !== "absolute") {
          colourSource = colourSource.parentNode;
          if (colourSource === document) {
            break;
          }
          fillColour = DomHelper.getStyleValue(colourSource, "background-color");
        }
        if (fillColour.match(isTransparent)) {
          me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
        } else {
          me.anchorPathElement.setAttribute("fill", fillColour);
        }
      }
      anchorStyle.transform = anchorStyle.display = "";
      anchorElement.className = `b-anchor b-anchor-${edge}`;
      anchor.x && (anchor.x /= scale);
      anchor.y && (anchor.y /= scale);
      DomHelper.setTranslateXY(anchorElement, anchor.x, anchor.y);
      classList.add("b-anchored");
    } else if (me._anchorElement) {
      me.anchorElement.classList.add("b-hide-display");
      classList.remove("b-anchored");
    }
    if (!aligningToElement) {
      style.pointerEvents = "none";
      const el = DomHelper.elementFromPoint(x, y);
      if (!me.owns(el)) {
        me.lastAlignSpec.anchoredTo = el;
      }
      style.pointerEvents = "";
    }
    if ((me.scrollAction === "realign" && aligningToElement || me.scrollAction === "hide") && !me.documentScrollListener) {
      me.clearTimeout(me.scrollListenerTimeout);
      if (spec.monitorTargetMutation && !me.targetObserver) {
        const targetObserver = me.targetObserver || (me.targetObserver = new MutationObserver(me.onTargetParentMutation.bind(me)));
        targetObserver.observe(DomHelper.getRootElement(target), {
          childList: true,
          attributes: true,
          subtree: true
        });
      }
      me.scrollListenerTimeout = me.setTimeout(() => {
        var _a3, _b;
        const targetRoot = (_b = (_a3 = aligningToElement ? target : me.lastAlignSpec.anchoredTo).getRootNode) == null ? void 0 : _b.call(_a3);
        me.documentScrollListener = EventHelper.addListener(document, "scroll", "doHideOrRealign", {
          capture: true,
          thisObj: me
        });
        if (targetRoot == null ? void 0 : targetRoot.mode) {
          me.targetRootScrollListener = EventHelper.addListener(targetRoot, "scroll", "doHideOrRealign", {
            capture: true,
            thisObj: me
          });
        }
      }, me.scrollAction === "hide" ? me.ignoreScrollDuration : 0);
    }
    if (aligningToElement) {
      if (spec.monitorResize && !me.targetResizeListener) {
        ResizeMonitor.addResizeListener(target, me.onTargetResize);
        me.targetResizeListener = true;
      }
      if (spec.monitorIntersection && !(overlap || target.contains(element) || target.ownerSVGElement)) {
        me.intersectionObserver.observe(target);
      }
    }
    if (!BrowserHelper.isAndroid) {
      if (!me.constrainListeners) {
        const el = (constrainTo == null ? void 0 : constrainTo.isRectangle) ? globalThis : constrainTo;
        me.clearTimeout(me.resizeListenerTimeout);
        me.resizeListenerTimeout = me.setTimeout(() => {
          me.constrainListeners = true;
          ResizeMonitor.addResizeListener(el || globalThis, me.onAlignConstraintChange);
        }, me.ignoreScrollDuration);
      }
    }
  }
  onTargetParentMutation(mutationRecords) {
    var _a2;
    const { element, lastAlignSpec } = this;
    if (lastAlignSpec == null ? void 0 : lastAlignSpec.aligningToElement) {
      if (!((_a2 = lastAlignSpec.target) == null ? void 0 : _a2.isConnected)) {
        this.hide();
      } else if (mutationRecords.some(({ target }) => target.contains(lastAlignSpec.target) && !element.contains(target))) {
        this.realign();
      }
    }
  }
  get intersectionObserver() {
    return this._intersectionObserver || (this._intersectionObserver = new IntersectionObserver(this.onTargetIntersectionchange.bind(this), {
      root: BrowserHelper.isSafari ? this.rootElement : this.rootElement.ownerDocument
    }));
  }
  onTargetIntersectionchange(entries) {
    if (!this.isDestroyed) {
      const e = entries[entries.length - 1];
      if (!e.isIntersecting) {
        this.onAlignTargetOutOfView(e.target);
      }
    }
  }
  onTargetResize() {
    const { lastAlignSpec } = this;
    if (lastAlignSpec) {
      const {
        width: lastWidth,
        height: lastHeight
      } = lastAlignSpec.targetRect, {
        width,
        height
      } = lastAlignSpec.target.getBoundingClientRect();
      if (width !== lastWidth || height !== lastHeight) {
        this.onAlignConstraintChange(...arguments);
      }
    }
  }
  /**
   * This method is called when the {@link #function-alignTo} target element loses intersection with the
   * visible viewport. That means it has been scrolled out of view, or becomes zero size, or hidden or
   * is removed from the DOM.
   *
   * The base class implementation hides by default.
   * @param {HTMLElement} target The alignTo target that is no longer in view.
   * @internal
   */
  onAlignTargetOutOfView(target) {
    this.hide();
    this.lastAlignSpec && (this.lastAlignSpec.targetOutOfView = true);
  }
  onAlignConstraintChange(el, oldRect, { height }) {
    const { style } = this.contentElement, { overflowY } = style;
    this.setTimeout(this.realign, 50);
    if (oldRect && height > oldRect.height) {
      style.overflowY = "hidden";
      this.requestAnimationFrame(() => style.overflowY = overflowY);
    }
  }
  /**
   * Called when an element which affects the position of this Widget's
   * {@link #function-alignTo align target} scrolls so that this can realign.
   *
   * If the target has scrolled out of view, then this Widget is hidden.
   * @internal
   */
  realign() {
    const me = this, { lastAlignSpec } = me;
    if ((me.floating || me.positioned) && lastAlignSpec && me.isVisible) {
      if (lastAlignSpec.aligningToElement) {
        const insideTarget = lastAlignSpec.target.contains(this.element), realignTarget = DomHelper.isInView(lastAlignSpec.target, false, me);
        if (!lastAlignSpec.allowTargetOut && (!hasLayout(lastAlignSpec.target) || !realignTarget)) {
          me.hide();
          if (!me.isDestroyed) {
            me.lastAlignSpec.targetOutOfView = true;
          }
          return;
        }
        lastAlignSpec.realignTarget = insideTarget ? null : realignTarget;
      }
      DomHelper.addTemporaryClass(me.element, "b-realigning", me.realignTimeout, me);
      me.alignTo(lastAlignSpec);
    }
  }
  /**
   * Returns the specified bounding rectangle of this widget.
   * @param {'border'|'client'|'content'|'inner'|'outer'} [which='border'] By default, the rectangle returned is the
   * bounding rectangle that contains the `element` border. Pass any of these values to retrieve various rectangle:
   *  - `'border'` to get the {@link Core.helper.util.Rectangle#function-from-static border rectangle} (the default).
   *  - `'client'` to get the {@link Core.helper.util.Rectangle#function-client-static client rectangle}.
   *  - `'content'` to get the {@link Core.helper.util.Rectangle#function-content-static content rectangle}.
   *  - `'inner'` to get the {@link Core.helper.util.Rectangle#function-inner-static inner rectangle}.
   *  - `'outer'` to get the {@link Core.helper.util.Rectangle#function-outer-static outer rectangle}.
   * @param {HTMLElement|Core.widget.Widget} [relativeTo] Optionally, a parent element or widget in whose space to
   * calculate the Rectangle.
   * @param {Boolean} [ignorePageScroll=false] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle}
   * @internal
   */
  rectangle(which, relativeTo, ignorePageScroll) {
    return this.rectangleOf("element", which, relativeTo, ignorePageScroll);
  }
  /**
   * Returns the specified bounding rectangle of the specified child `element` of this widget.
   * @param {String} [element] The child element name.
   * @param {'border'|'client'|'content'|'inner'|'outer'} [which='border'] By default, the rectangle returned
   * is the bounding rectangle that contains the `element` border. Pass any of these values to retrieve various
   * rectangle:
   *  - `'border'` to get the {@link Core.helper.util.Rectangle#function-from-static border rectangle} (the default).
   *  - `'client'` to get the {@link Core.helper.util.Rectangle#function-client-static client rectangle}.
   *  - `'content'` to get the {@link Core.helper.util.Rectangle#function-content-static content rectangle}.
   *  - `'inner'` to get the {@link Core.helper.util.Rectangle#function-inner-static inner rectangle}.
   *  - `'outer'` to get the {@link Core.helper.util.Rectangle#function-outer-static outer rectangle}.
   * @param {HTMLElement|Core.widget.Widget} [relativeTo] Optionally, a parent element or widget in whose space to
   * calculate the Rectangle. If `element` is not `'element'`, then this defaults to the widget's primary element.
   * @param {Boolean} [ignorePageScroll=false] Use browser viewport based coordinates.
   * @returns {Core.helper.util.Rectangle}
   * @internal
   */
  rectangleOf(element, which, relativeTo, ignorePageScroll) {
    if (typeof which !== "string") {
      ignorePageScroll = relativeTo;
      relativeTo = which;
      which = "";
    } else if (which === "border") {
      which = "";
    }
    if (typeof relativeTo === "boolean") {
      ignorePageScroll = relativeTo;
      relativeTo = void 0;
    }
    if (element !== "element" && relativeTo === void 0) {
      relativeTo = this.element;
    }
    relativeTo = (relativeTo == null ? void 0 : relativeTo.isWidget) ? relativeTo.element : relativeTo;
    return Rectangle[which || "from"](this[element], relativeTo, ignorePageScroll);
  }
  releaseSizeConstraints() {
    const me = this, {
      scrollable,
      element,
      alignmentChanges
    } = me, { style } = element;
    if (alignmentChanges & 12) {
      DomHelper.setLength(element, me.alignedWidthStyle, me[`_last${StringHelper.capitalize(me.alignedWidthStyle)}`] || "");
      style.minWidth = me._minWidth || "";
      if (scrollable) {
        scrollable.overflowY = scrollable.config.overflowY;
      }
    }
    if (alignmentChanges & 3) {
      DomHelper.setLength(element, me.alignedHeightStyle, me[`_last${StringHelper.capitalize(me.alignedHeightStyle)}`] || "");
      style.minHeight = me._minHeight || "";
      if (scrollable) {
        scrollable.overflowX = scrollable.config.overflowX;
      }
    }
    me.alignmentChanges = 0;
  }
  /**
   * Only valid for {@link #config-floating} Widgets. Moves to the front of the visual stacking order.
   * @category Float & align
   */
  toFront() {
    const { element } = this, parent = this.floating ? this.floatRoot : this.positioned ? element == null ? void 0 : element.parentNode : null, widgetsFrag = document.createDocumentFragment();
    if (this.containsFocus) {
      for (let followingEl = element.nextSibling, nextEl; followingEl; followingEl = nextEl) {
        nextEl = followingEl.nextSibling;
        if (parent.contains(followingEl) && !this.owns(followingEl)) {
          widgetsFrag.appendChild(followingEl);
        }
      }
      parent.insertBefore(widgetsFrag, element);
    } else {
      parent.appendChild(element);
    }
  }
  //endregion
  //region Getters/setters
  updateRef(ref) {
    this.element.dataset.ref = ref;
  }
  /**
   * The child element which scrolls if any. This means the element used by the {@link #config-scrollable}.
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   * @advanced
   */
  get overflowElement() {
    return this.contentElement;
  }
  get maxHeightElement() {
    return this.element;
  }
  changeAlign(align) {
    return typeof align === "string" ? { align } : align;
  }
  changeScrollable(scrollable, oldScrollable) {
    if (typeof scrollable === "boolean") {
      scrollable = {
        overflowX: scrollable,
        overflowY: scrollable
      };
    }
    if (scrollable) {
      scrollable.element = this.overflowElement;
      scrollable.widget = this;
      if (!scrollable.isScroller) {
        scrollable = oldScrollable ? oldScrollable.setConfig(scrollable) : new this.scrollerClass(scrollable);
      }
      scrollable.syncOverflowState();
    } else {
      oldScrollable == null ? void 0 : oldScrollable.destroy();
    }
    return scrollable;
  }
  handleReactElement(html) {
    const parent = this.closest((cmp) => cmp.reactComponent);
    if (parent == null ? void 0 : parent.reactComponent) {
      parent.reactComponent.processWidgetContent({
        reactElement: html,
        widget: this,
        reactComponent: parent.reactComponent
      });
    }
  }
  /**
   * Get/set HTML to display. When specifying HTML, this widget's element will also have the
   * {@link #config-htmlCls} added to its classList, to allow targeted styling.
   * @property {String}
   * @category DOM
   */
  get html() {
    if (this.initializingElement || !this.element) {
      return this.content || this._html;
    }
    return this.contentElement.innerHTML;
  }
  updateHtml(html) {
    const me = this, isClearing = html == null, {
      element,
      contentElement,
      htmlCls
    } = me;
    if (!element && DomHelper.isReactElement(html)) {
      me.whenVisible(() => me.handleReactElement(html));
      return;
    }
    if (element) {
      me.updatingHtml = true;
      const anchorEl = contentElement === element && me._anchorElement;
      if (htmlCls) {
        htmlCls.values.forEach((value) => element.classList[isClearing ? "remove" : "add"](value));
      }
      if (anchorEl) {
        element.removeChild(anchorEl);
      }
      if (html && typeof html === "object") {
        if (DomHelper.isReactElement(html)) {
          me.handleReactElement(html);
        } else {
          DomSync.sync({
            domConfig: {
              ...html,
              onlyChildren: true
            },
            targetElement: me.contentElement
          });
        }
      } else {
        me.contentElement.innerHTML = isClearing ? "" : html;
      }
      me.getConfig("htmlMutationObserver");
      if (anchorEl) {
        element.appendChild(anchorEl);
      }
      if (me.isComposable) {
        me.recompose();
      } else if (me.floating || me.positioned) {
        if (!me.isAligning) {
          me.realign();
        }
      }
    }
  }
  changeHtmlMutationObserver(htmlMutationObserver, was) {
    const me = this, { contentElement } = me;
    was == null ? void 0 : was.disconnect();
    if (htmlMutationObserver) {
      const result = new MutationObserver(() => {
        if (me.updatingHtml) {
          me.updatingHtml = false;
        } else {
          me._html = contentElement.innerHTML;
        }
      });
      result.observe(contentElement, htmlMutationObserver);
      return result;
    }
  }
  updateContent(html) {
    const me = this, isClearing = html == null, { element, htmlCls } = me;
    if (element) {
      const { contentRange } = me;
      if (htmlCls) {
        htmlCls.values.forEach((value) => element.classList[isClearing ? "remove" : "add"](value));
      }
      if (element.isConnected) {
        contentRange.deleteContents();
        if (!isClearing) {
          contentRange.insertNode(DomHelper.createElementFromTemplate(html, {
            fragment: true
          }));
        }
      } else {
        me.contentElement.innerHTML = html;
      }
      me.contentRangeStartOffset = contentRange.startOffset;
      me.contentRangeEndOffset = contentRange.endOffset;
      if ((me.floating || me.positioned) && !me.isAligning) {
        me.realign();
      }
    }
  }
  onThemeChange() {
    var _a2;
    if ((_a2 = this.anchorElement) == null ? void 0 : _a2.offsetParent) {
      this._anchorSize = null;
      this.realign();
    }
  }
  /**
   * Returns an `[x, y]` array containing the width and height of the anchor arrow used when
   * aligning this Widget to another Widget or element.
   *
   * The height is the height of the arrow when pointing upwards, the width is the width
   * of the baseline.
   * @property {Number[]}
   * @category Float & align
   */
  get anchorSize() {
    const me = this;
    let result = this._anchorSize;
    if (!result) {
      const borderWidth = parseFloat(DomHelper.getStyleValue(me.element, "border-top-width")), borderColour = DomHelper.getStyleValue(me.element, "border-top-color"), anchorElement = me.anchorElement, { className } = anchorElement, svgEl = anchorElement.firstElementChild, pathElement = me.anchorPathElement = svgEl.lastElementChild, hidden = me._hidden;
      anchorElement.className = "b-anchor b-anchor-top";
      let backgroundColour = DomHelper.getStyleValue(me.contentElement, "background-color");
      if (backgroundColour.match(isTransparent)) {
        backgroundColour = DomHelper.getStyleValue(me.element, "background-color");
      }
      me.defaultAnchorBackgroundColor = backgroundColour;
      result = anchorElement.getBoundingClientRect();
      const [width, height] = result = me._anchorSize = [result.width, result.height];
      anchorElement.className = className;
      svgEl.setAttribute("height", height + borderWidth);
      svgEl.setAttribute("width", width);
      pathElement.setAttribute("d", `M0,${height}L${width / 2},0.5L${width},${height}`);
      if (borderWidth) {
        pathElement.setAttribute("stroke-width", borderWidth);
        pathElement.setAttribute("stroke", borderColour);
      }
      result[1] -= borderWidth;
      if (hidden) {
        me.element.classList.add("b-hidden");
      }
      if (!me.themeChangeListener) {
        me.themeChangeListener = GlobalEvents_default.ion({
          theme: "onThemeChange",
          thisObj: me
        });
      }
      me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
    }
    return result;
  }
  get anchorElement() {
    const me = this;
    if (!me._anchorElement) {
      const useFilter = me.floating, filterId = `${me.id}-shadow-filter`;
      me._anchorElement = DomHelper.createElement({
        parent: me.element,
        className: "b-anchor b-anchor-top",
        children: [{
          tag: "svg",
          ns: "http://www.w3.org/2000/svg",
          version: "1.1",
          class: "b-pointer-el",
          children: [useFilter ? {
            tag: "defs",
            children: [{
              tag: "filter",
              id: filterId,
              children: [{
                tag: "feDropShadow",
                dx: 0,
                dy: -1,
                stdDeviation: 1,
                "flood-opacity": 0.2
              }]
            }]
          } : null, {
            tag: "path",
            [useFilter ? "filter" : ""]: `url(#${filterId})`
          }]
        }]
      });
    }
    return me._anchorElement;
  }
  updateAnchor(anchor) {
    if (this._anchorElement) {
      this._anchorElement.classList[anchor ? "remove" : "add"]("b-hide-display");
    }
  }
  updateDraggable(draggable) {
    var _a2, _b, _c;
    const me = this, { element } = me;
    if (draggable) {
      me.dragEventDetacher = EventHelper.addListener({
        element,
        dragstart: "onWidgetDragStart",
        dragend: "onWidgetDragEnd",
        thisObj: me
      });
      me.dragDetacher = EventHelper.on({
        element,
        mousedown(event) {
          const { target } = event, closestWidget = _Widget.fromElement(target);
          if (!event.target.closest(".b-field-inner") && // Only allow drag to start when the action originates from the widget element itself,
          // or one of its toolbars. https://github.com/bryntum/support/issues/3214
          closestWidget === this || this.strips && Object.values(this.strips).includes(closestWidget)) {
            element.setAttribute("draggable", "true");
          }
        },
        // Only needed for automatic listener removal on destruction of the thisObj
        thisObj: me
      });
    } else {
      (_a2 = me.dragEventDetacher) == null ? void 0 : _a2.call(me);
      (_b = me.dragOverEventDetacher) == null ? void 0 : _b.call(me);
      (_c = me.dragDetacher) == null ? void 0 : _c.call(me);
    }
  }
  onWidgetDragStart(e) {
    var _a2;
    const me = this;
    if (!me.validateDragStartEvent(e)) {
      return;
    }
    const {
      element,
      align,
      constrainTo
    } = me, positioned = me.positioned && DomHelper.getStyleValue(element, "position") !== "fixed", parentElement = positioned ? element.parentElement : me.rootElement, myRect = Rectangle.from(element, positioned ? parentElement : null), dragStartX = e.clientX, dragStartY = e.clientY, scrollingPageElement = document.scrollingElement || document.body, [widgetX, widgetY] = positioned ? DomHelper.getOffsetXY(element, parentElement) : me.getXY(), constrainRect = (_a2 = positioned ? Rectangle.content(parentElement).moveTo(0, 0) : constrainTo && ((constrainTo == null ? void 0 : constrainTo.isRectangle) ? constrainTo : Rectangle.from(constrainTo))) == null ? void 0 : _a2.deflate(align.constrainPadding || 0), dragListeners = {
      element: parentElement,
      dragover: (event) => {
        element.classList.remove("b-centered");
        myRect.moveTo(
          widgetX + event.clientX - dragStartX - (positioned ? 0 : scrollingPageElement.scrollLeft),
          widgetY + event.clientY - dragStartY - (positioned ? 0 : scrollingPageElement.scrollTop)
        );
        if (constrainRect) {
          myRect.constrainTo(constrainRect);
        }
        DomHelper.setTranslateXY(element, myRect.x, myRect.y);
      }
    };
    if (BrowserHelper.isTouchDevice) {
      dragListeners.touchmove = (e13) => e13.preventDefault();
    }
    me.floatRoot.appendChild(me.dragGhost);
    me.setDragImage(e);
    e.dataTransfer.effectAllowed = "none";
    me.dragOverEventDetacher = EventHelper.addListener(dragListeners);
    me.alignTo();
  }
  /**
   * Validates a `dragstart` event with respect to the target element. Dragging is not normally
   * initiated when the target is interactive such as an input field or its label, or a button.
   * This may be overridden to provide custom drag start validation.
   * @param {DragEvent} e The `dragstart` event to validate.
   * @returns {Boolean} Return `true` if the drag is to be allowed.
   * @internal
   */
  validateDragStartEvent(e) {
    var _a2;
    const me = this, { element } = me, actualTarget = DomHelper.elementFromPoint(e.clientX, e.clientY), { handleSelector } = me.draggable;
    if (handleSelector) {
      const blacklist = (_a2 = negationPseudo.exec(handleSelector)) == null ? void 0 : _a2[1];
      if (blacklist) {
        if (actualTarget.closest(`#${element.id} ${blacklist}`)) {
          e.preventDefault();
          return false;
        }
      } else if (!actualTarget.closest(`#${element.id} ${handleSelector}`)) {
        e.preventDefault();
        return false;
      }
    }
    return true;
  }
  setDragImage(e) {
    if (e.dataTransfer.setDragImage) {
      e.dataTransfer.setData("application/node type", "");
      e.dataTransfer.setDragImage(this.dragGhost, -9999, -9999);
    }
  }
  setStyle(name, value) {
    DomHelper.applyStyle(this.element, ObjectHelper.isObject(name) ? name : { [name]: value });
    return this;
  }
  onWidgetDragEnd() {
    this.dragGhost.remove();
    this.dragOverEventDetacher();
    this.element.removeAttribute("draggable");
  }
  changeFloating(value) {
    return Boolean(value);
  }
  changePositioned(value) {
    return Boolean(value);
  }
  updatePositioned(positioned) {
    this.element.classList[positioned ? "add" : "remove"]("b-positioned");
  }
  getXY() {
    return [
      DomHelper.getPageX(this.element),
      DomHelper.getPageY(this.element)
    ];
  }
  /**
   * Moves this Widget to the x,y position. Both arguments can be omitted to just set one value.
   *
   * *For {@link #config-floating} Widgets, this is a position in the browser viewport.*
   * *For {@link #config-positioned} Widgets, this is a position in the element it was rendered into.*
   *
   * @param {Number} [x]
   * @param {Number} [y]
   * @category Float & align
   */
  setXY(x, y) {
    const me = this, { element } = me;
    if (me.floating || me.positioned) {
      if (x != null) {
        me._x = x;
      }
      if (y != null) {
        me._y = y;
      }
      if (DomHelper.getStyleValue(element, "position") === "fixed") {
        const r = element.getBoundingClientRect(), [cx, cy] = DomHelper.getTranslateXY(element), xDelta = x - r.x, yDelta = y - r.y;
        DomHelper.setTranslateXY(element, cx + xDelta, cy + yDelta);
      } else {
        DomHelper.setTranslateXY(element, me._x || 0, me._y || 0);
      }
      if (me.isConstructing) {
        me.centered = false;
      } else {
        element.classList.remove("b-centered");
      }
    }
  }
  /**
   * Moves this Widget to the desired x position.
   *
   * Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element.
   * @property {Number}
   * @category Float & align
   */
  get x() {
    return this.getXY()[0];
  }
  changeX(x) {
    this.setXY(x);
  }
  /**
   * Moves this Widget to the desired y position.
   *
   * Only valid if this Widget is {@link #config-floating} and not aligned or anchored to an element.
   * @property {Number}
   * @category Float & align
   */
  get y() {
    return this.getXY()[1];
  }
  changeY(y) {
    this.setXY(null, y);
  }
  /**
   * Get elements offsetWidth or sets its style.width, or specified width if element not created yet.
   * @property {Number}
   * @accepts {Number|String}
   * @category Layout
   */
  get width() {
    const me = this, element = me.element;
    if (me.monitorResize) {
      if (me._width == null) {
        me._width = element.offsetWidth;
      }
      return me._width;
    }
    return element.offsetWidth;
  }
  changeWidth(width) {
    const me = this;
    DomHelper.setLength(me.element, "width", width);
    me._lastWidth = width;
    me._oldWidth = me._width;
    me._width = null;
    me._flex = null;
    me.element.style.flex = "";
  }
  // This method is used by State API to drop cached width early to not rely on ResizeMonitor
  clearWidthCache() {
    this._width = null;
  }
  /**
   * Get/set elements maxWidth. Getter returns max-width from elements style, which is always a string. Setter accepts
   * either a String or a Number (which will have 'px' appended). Note that like {@link #config-width},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get maxWidth() {
    return DomHelper.measureSize(this.element.style.maxWidth, this.element);
  }
  updateMaxWidth(maxWidth) {
    this._lastMaxWidth = maxWidth;
    DomHelper.setLength(this.element, "maxWidth", maxWidth);
  }
  /**
   * Get/set elements minWidth. Getter returns min-width from elements style, which is always a string. Setter accepts
   * either a String or a Number (which will have 'px' appended). Note that like {@link #config-width},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get minWidth() {
    return DomHelper.measureSize(this.element.style.minWidth, this.element);
  }
  updateMinWidth(minWidth) {
    DomHelper.setLength(this.element, "minWidth", minWidth);
  }
  updateFlex(flex) {
    this.getConfig("width");
    if (typeof flex === "number" || !isNaN(flex)) {
      flex = `${flex} ${flex}`;
    }
    this.element.style.flex = flex;
    this.element.style.width = "";
  }
  updateAlignSelf(alignSelf) {
    this.element.style.alignSelf = alignSelf;
  }
  updateMargin(margin) {
    this.element.style.margin = this.parseTRBL(margin).join(" ");
  }
  updateTextAlign(align, oldAlign) {
    oldAlign && this.element.classList.remove(`b-text-align-${oldAlign}`);
    this.element.classList.add(`b-text-align-${align}`);
  }
  updatePlaceholder(placeholder) {
    if (this.input) {
      if (placeholder == null) {
        this.input.removeAttribute("placeholder");
      } else {
        this.input.placeholder = placeholder;
      }
    }
  }
  /**
   * Get element's offsetHeight or sets its style.height, or specified height if element no created yet.
   * @property {Number}
   * @accepts {Number|String}
   * @category Layout
   */
  get height() {
    const me = this, element = me.element;
    if (me.monitorResize) {
      if (me._height == null) {
        me._height = element.offsetHeight;
      }
      return me._height;
    }
    return element.offsetHeight;
  }
  changeHeight(height) {
    DomHelper.setLength(this.element, "height", height);
    this._lastHeight = height;
    this._height = null;
  }
  /**
   * Get/set element's maxHeight. Getter returns max-height from elements style, which is always a string. Setter
   * accepts either a String or a Number (which will have 'px' appended). Note that like {@link #config-height},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get maxHeight() {
    return DomHelper.measureSize(this.maxHeightElement.style.maxHeight, this.element);
  }
  updateMaxHeight(maxHeight) {
    this._lastMaxHeight = maxHeight;
    DomHelper.setLength(this.maxHeightElement, "maxHeight", maxHeight);
  }
  /**
   * Get/set element's minHeight. Getter returns min-height from elements style, which is always a string. Setter
   * accepts either a String or a Number (which will have 'px' appended). Note that like {@link #config-height},
   * _reading_ the value will return the numeric value in pixels.
   * @property {String}
   * @accepts {String|Number}
   * @category Layout
   */
  get minHeight() {
    return DomHelper.measureSize(this.element.style.minHeight, this.element);
  }
  updateMinHeight(minHeight) {
    DomHelper.setLength(this.element, "minHeight", minHeight);
  }
  updateDisabled(disabled = false) {
    const {
      element,
      focusElement,
      ariaElement
    } = this;
    this.trigger("beforeUpdateDisabled", { disabled });
    if (disabled) {
      this.revertFocus();
      if (this._disabled !== disabled) {
        return;
      }
    }
    if (element) {
      element.classList[disabled ? "add" : "remove"]("b-disabled");
      if (focusElement) {
        focusElement.disabled = disabled;
      }
      if (ariaElement) {
        ariaElement.setAttribute("aria-disabled", disabled);
      }
    }
    this.onDisabled(disabled);
  }
  /**
   * Called when disabled state is changed.
   * Override in subclass that needs special handling when being disabled.
   * @param {Boolean} disabled current state
   * @private
   */
  onDisabled(disabled) {
  }
  /**
   * Disable the widget
   */
  disable() {
    this.disabled = true;
  }
  /**
   * Enable the widget
   */
  enable() {
    this.disabled = false;
  }
  /**
   * Requests fullscreen display for this widget
   * @returns {Promise} A Promise which is resolved with a value of undefined when the transition to full screen is complete.
   */
  requestFullscreen() {
    const me = this, result = Fullscreen.request(me.floating ? me.floatRoot : me.element);
    Fullscreen.onFullscreenChange(me.onFullscreenChange);
    me.element.classList.add("b-fullscreen");
    return result;
  }
  /**
   * Exits fullscreen mode
   * @returns {Promise} A Promise which is resolved once the user agent has finished exiting full-screen mode
   */
  exitFullscreen() {
    return Fullscreen.exit();
  }
  onFullscreenChange() {
    if (!Fullscreen.isFullscreen) {
      this.onExitFullscreen();
    }
  }
  onExitFullscreen() {
    Fullscreen.unFullscreenChange(this.onFullscreenChange);
    this.element.classList.remove("b-fullscreen");
  }
  /**
   * Get/set a tooltip on the widget. Accepts a string or tooltip config (specify true (or 'true') to use placeholder
   * as tooltip). When using a string it will configure the tooltip with `textContent: true` which enforces a default
   * max width.
   *
   * By default, this uses a singleton Tooltip instance which may be accessed from the `{@link Core.widget.Widget}`
   * class under the name `Widget.tooltip`. This is configured according to the config object on pointer over.
   *
   * To request a separate instance be created just for this widget, add `newInstance : true` to the configuration.
   *
   * @property {String|TooltipConfig}
   * @category Misc
   */
  get tooltip() {
    var _a2;
    const me = this;
    if (me._tooltip) {
      return me._tooltip;
    } else {
      const tooltip = (_a2 = _Widget.Tooltip) == null ? void 0 : _a2.getSharedTooltip(me.rootElement, me.eventRoot);
      if (tooltip && tooltip.activeTarget === me._element && tooltip.isVisible) {
        return tooltip;
      }
    }
  }
  //noinspection JSAnnotator
  changeTooltip(tooltip, oldTooltip) {
    var _a2;
    const me = this, { element } = me;
    if (tooltip) {
      if (!(me.preventTooltipOnTouch && BrowserHelper.isTouchDevice)) {
        if (!tooltip.isTooltip && tooltip.constructor.name !== "Object") {
          tooltip = {
            html: typeof tooltip === "string" ? tooltip : me.placeholder,
            textContent: true
          };
        }
        if (!me.configureAriaDescription) {
          me.ariaDescription = ((_a2 = tooltip.html) == null ? void 0 : _a2.match(localizeRE)) ? tooltip.html.replace(localizeRE, localizeTooltip) : tooltip.html;
        }
        if ((oldTooltip == null ? void 0 : oldTooltip.isTooltip) || tooltip.newInstance) {
          tooltip.type = "tooltip";
          if (!tooltip.forElement)
            tooltip.forElement = element;
          if (!("showOnHover" in tooltip) && !tooltip.forSelector)
            tooltip.showOnHover = true;
          if (!("autoClose" in tooltip))
            tooltip.autoClose = true;
          tooltip = _Widget.reconfigure(oldTooltip, tooltip, me);
          me.detachListeners("tooltipValueListener");
          if (!me.configureAriaDescription) {
            tooltip.ion({
              name: "tooltipValueListener",
              innerHtmlUpdate: "onTooltipValueChange",
              thisObj: me
            });
          }
        } else {
          element.dataset.btip = true;
          me.tipConfig = tooltip;
          return;
        }
      }
    } else {
      if (oldTooltip) {
        if (tooltip == null && oldTooltip.isTooltip) {
          oldTooltip.destroy();
        } else {
          oldTooltip.html = null;
          return;
        }
      } else {
        delete element.dataset.btip;
      }
    }
    return tooltip;
  }
  /**
   * The shared {@link Core.widget.Tooltip} instance which handles
   * {@link Core.widget.Widget#config-tooltip tooltips} which are __not__ configured
   * with `newInstance : true`.
   * @member {Core.widget.Tooltip} tooltip
   * @readonly
   * @static
   */
  // This property is defined in the Tooltip module but must be documented here.
  // If our tooltip is dynamic, then we must update our aria-describedBy whenever it changes.
  onTooltipValueChange({ value, source }) {
    this.ariaDescription = typeof value == "string" ? value : source.contentElement.innerText;
  }
  get tooltipText() {
    const tooltip = this._tooltip;
    if (tooltip) {
      return tooltip.isTooltip ? tooltip.contentElement.innerText : typeof tooltip === "string" ? tooltip : tooltip.html;
    } else if (this.tipConfig) {
      return this.tipConfig.html;
    }
  }
  /**
   * Determines visibility by checking if the Widget is hidden, or any ancestor is hidden and that it has an
   * element which is visible in the DOM
   * @property {Boolean}
   * @category Visibility
   * @readonly
   */
  get isVisible() {
    const me = this, { element } = me;
    let owner;
    return Boolean(
      element && !me._hidden && !me.isDestroying && element.isConnected && (!me.requireSize || hasLayout(element)) && (!(owner = me.containingWidget) || owner.isVisible)
    );
  }
  // If the callback is a function (instead of the name of the function),
  // the id must be converted into string format to be used as key for `toCallWhenVisible` map element
  whenVisible(callback, thisObj = this, args, id = callback.toString()) {
    var _a2;
    const me = this;
    if (me.isVisible && me.isPainted) {
      (_a2 = me.toCallWhenVisible) == null ? void 0 : _a2.delete(id);
      me.callback(callback, thisObj, args);
    } else {
      (me.toCallWhenVisible || (me.toCallWhenVisible = /* @__PURE__ */ new Map())).set(id, { callback, thisObj, args });
    }
  }
  /**
   * Focuses this widget if it has a focusable element.
   */
  focus() {
    if (this.isFocusable) {
      DomHelper.focusWithoutScrolling(this.focusElement);
    }
  }
  /**
   * Get this widget's primary focus holding element if this widget is itself focusable, or contains focusable widgets.
   * @property {HTMLElement}
   * @readonly
   * @category DOM
   * @advanced
   */
  get focusElement() {
  }
  get isFocusable() {
    const focusElement = !this.isDestroying && this.isVisible && !this.disabled && this.focusElement;
    return focusElement && (focusElement === document.body || focusElement.offsetParent);
  }
  /**
   * Shows this widget
   * @param {Object} [options] modifications to the show operation
   * @param {AlignSpec} [options.align] An alignment specification as passed to {@link #function-alignTo}
   * @param {Boolean} [options.animate=true] Specify as `false` to omit the {@link #config-showAnimation}
   * @category Visibility
   * @returns {Promise} A promise which is resolved when the widget is shown
   */
  async show({ align, animate = true } = {}) {
    const me = this, {
      element,
      floating
    } = me, { style } = element, showAnimation = animate && me.showAnimation;
    let styleProp, animProps, trigger = !me.isVisible;
    if (trigger) {
      trigger = me.trigger("beforeShow");
      if (ObjectHelper.isPromise(trigger)) {
        trigger = await trigger;
      }
    }
    if (trigger !== false && (!me.internalBeforeShow || me.internalBeforeShow() !== false)) {
      return new Promise((resolve) => {
        me.cancelHideShowAnimation();
        me.updateCentered(me._centered);
        if (floating) {
          const floatRoot = me.floatRoot;
          if (!floatRoot.contains(element)) {
            if (me.rendered) {
              floatRoot.appendChild(me.element);
            } else {
              me.render(floatRoot, false);
            }
          }
          if (style.transform.includes("scale")) {
            me.scale = null;
            style.transform = style.transformOrigin = "";
          }
          const scaledAncestor = me.closest(isScaled);
          if (scaledAncestor) {
            const { scale } = scaledAncestor;
            me.scale = scale;
            style.transform = `scale(${scale})`;
            style.transformOrigin = `0 0`;
          }
        }
        me._hidden = false;
        element.classList.remove("b-hidden");
        if (floating && !isVisible(element)) {
          me.hide(false);
          resolve();
        }
        me.onConfigChange({
          name: "hidden",
          value: false,
          was: true,
          config: me.$meta.configs.hidden
        });
        if (showAnimation) {
          styleProp = Object.keys(showAnimation)[0];
          animProps = showAnimation[styleProp];
          const currentAnimation = me.currentAnimation = {
            showing: true,
            styleProp,
            resolve
          };
          me.isAnimating = true;
          style.transition = "none";
          style[styleProp] = animProps.from;
          DomHelper.getStyleValue(element, styleProp);
          me.currentAnimation.detacher = EventHelper.onTransitionEnd({
            element,
            property: styleProp,
            duration: parseDuration(animProps.duration) + 20,
            handler: () => me.afterHideShowAnimate(currentAnimation),
            thisObj: me
          });
          style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
          style[styleProp] = animProps.to;
        }
        me.afterShow(align, !showAnimation ? resolve : null);
      });
    } else {
      return Promise.resolve();
    }
  }
  /**
   * Show aligned to another target element or {@link Core.widget.Widget} or {@link Core.helper.util.Rectangle}
   * @param {AlignSpec|HTMLElement|Number[]} align Alignment specification, or the element to align to using the
   * configured {@link #config-align}.
   * @category Float & align
   * @returns {Promise} A promise which is resolved when the widget is shown
   */
  async showBy(align, yCoord, options) {
    const me = this, isArray3 = Array.isArray(align);
    if (isArray3 || typeof align === "number") {
      const xy = isArray3 ? align : [align, yCoord];
      align = Object.assign({
        target: new Point(xy[0] + 1, xy[1] + 1),
        // Override any matchSize that we might have in our align config.
        // Otherwise we are going to be 1px wide/high
        matchSize: false,
        align: "t0-b0"
      }, isArray3 ? yCoord : options);
    }
    me.requireSize = true;
    if (me.isVisible) {
      DomHelper.addTemporaryClass(me.element, "b-realigning", 300, me);
      me.alignTo(align);
    } else {
      return me.show({ align });
    }
  }
  /**
   * Show this widget anchored to a coordinate
   * @param {Number|Number[]} x The x position (or an array with [x,y] values) to show by
   * @param {Number} [y] The y position to show by
   * @param {AlignSpec} [options] See {@link #function-showBy} for reference
   * @category Float & align
   * @deprecated Since 5.0.2. Use {@link #function-showBy} method with the same signature.
   * @returns {Promise} A promise which is resolved when the widget is shown
   */
  async showByPoint() {
    VersionHelper.deprecate("Core", "6.0.0", "Widget.showByPoint() replaced by Widget.showBy() with the same signature");
    return this.showBy(...arguments);
  }
  afterShow(align, resolveFn) {
    var _a2, _b;
    const me = this;
    me.trigger("show");
    me._configuredAnchorState = me.anchor;
    (_b = (_a2 = me.owner) == null ? void 0 : _a2.onChildShow) == null ? void 0 : _b.call(_a2, me);
    me.triggerPaint();
    if (me.floating || me.positioned) {
      if (align) {
        me.alignTo(align);
      } else if (me.centered) {
        me.alignTo({
          target: me.constrainTo,
          align: "c-c"
        });
      } else if (me.forElement) {
        me.alignTo(me.forElement);
      }
    }
    resolveFn == null ? void 0 : resolveFn();
  }
  onChildHide(hidden) {
    if (hidden.floating) {
      this.ariaElement.removeAttribute("aria-owns");
    }
  }
  onChildShow(shown) {
    if (shown.floating) {
      this.ariaHasPopup = shown.role;
      this.ariaElement.setAttribute("aria-owns", shown.id);
    }
  }
  triggerPaint() {
    const me = this, { element, toCallWhenVisible } = me, firstPaint = !me.isPainted;
    if (me.isVisible) {
      if (firstPaint) {
        me.getConfig("scrollable");
        if (me.scaleToFitWidth && !me.monitorResize) {
          me.onParentElementResize = me.onParentElementResize.bind(me);
          ResizeMonitor.addResizeListener(element.parentElement, me.onParentElementResize);
          me.updateScale();
        }
        if (!me.hideBryntumDomMessage && (me.isTaskBoardBase || me.isGridBase || me.isCalendar)) {
          element.insertBefore(new Comment("POWERED BY BRYNTUM (https://bryntum.com)"), element.firstChild);
        }
        if (me.onConnectedCallback && globalThis.ResizeObserver) {
          me.connectedObserver = new ResizeObserver(() => {
            if (me.isElementConnected && !element.isConnected) {
              me.onConnectedCallback(false);
              me.isElementConnected = false;
            } else if (!me.isElementConnected && element.isConnected) {
              me.onConnectedCallback(true, me.isElementConnected == null);
              me.isElementConnected = true;
            }
          });
          me.connectedObserver.observe(element);
        }
      }
      me.eachWidget(widgetTriggerPaint, false);
      if (firstPaint) {
        me.getConfig("tooltip");
        if (!_Widget.Ripple && _Widget.RippleClass) {
          _Widget.Ripple = new _Widget.RippleClass({
            rootElement: me.rootElement
          });
        }
        if (globalThis.DocsBrowser && me.floating && me.closest((w) => {
          var _a2;
          return (_a2 = w.element) == null ? void 0 : _a2.closest(".fiddlePanelResult,.b-owned-by-fiddle");
        })) {
          element.classList.add("b-owned-by-fiddle");
        }
      }
      me.isPainted = true;
      firstPaint && me.triggerConfigs("paint");
      me.onInternalPaint({ firstPaint });
      me.trigger("paint", { firstPaint });
      if (toCallWhenVisible == null ? void 0 : toCallWhenVisible.size) {
        for (const { callback, thisObj, args } of toCallWhenVisible.values()) {
          me.callback(callback, thisObj, args);
        }
        toCallWhenVisible.clear();
      }
      if (firstPaint) {
        if (me.monitorResize && !me.scaleToFitWidth) {
          ResizeMonitor.onElementResize([{ target: element }]);
        }
      }
    }
  }
  onInternalPaint() {
  }
  cancelHideShowAnimation() {
    const me = this, { currentAnimation, element } = me;
    if (currentAnimation) {
      me.isAnimating = false;
      if (element.classList.contains("b-hiding")) {
        element.classList.remove("b-hiding");
        me._hidden = false;
      }
      currentAnimation.detacher();
      currentAnimation.resolve();
      element.style.transition = element.style[currentAnimation.styleProp] = "";
      me.currentAnimation = null;
      me.trigger(`${currentAnimation.showing ? "show" : "hide"}AnimationEnd`);
    }
  }
  afterHideShowAnimate(currentAnimation) {
    const me = this;
    if (currentAnimation === me.currentAnimation) {
      me.element.classList.remove("b-hiding");
      me.cancelHideShowAnimation();
      if (me._hidden) {
        me.afterHideAnimation();
      }
    }
  }
  /**
   * Temporarily changes the {@link #property-isVisible} to yield `false` regardless of this
   * Widget's true visibility state. This can be useful for suspending operations which rely on
   * the {@link #property-isVisible} property.
   *
   * This increments a counter which {@link #function-resumeVisibility} decrements.
   * @internal
   */
  suspendVisibility() {
    this._visibilitySuspended = (this._visibilitySuspended || 0) + 1;
    Object.defineProperty(this, "isVisible", returnFalseProp);
  }
  /**
   * Resumes visibility. If the suspension counter is returned to zero by this, then the
   * {@link #event-paint} event is triggered, causing a cascade of `paint` events on all
   * descendants. This can be prevented by passing `false` as the only parameter.
   * @param {Boolean} [triggerPaint=true] Trigger the {@link #event-paint} event.
   * @internal
   */
  resumeVisibility(triggerPaint = true) {
    if (!--this._visibilitySuspended) {
      delete this.isVisible;
      if (triggerPaint) {
        this.triggerPaint();
      }
    }
  }
  /**
   * Hide widget
   * @param {Boolean} animate Pass `true` (default) to animate the hide action
   * @category Visibility
   * @returns {Promise} A promise which is resolved when the widget has been hidden
   */
  hide(animate = true) {
    return new Promise((resolve) => {
      const me = this, {
        element,
        lastAlignSpec
      } = me, { style } = element, hideAnimation = animate && me.hideAnimation;
      me.clearTimeout(me.scrollListenerTimeout);
      me.clearTimeout(me.resizeListenerTimeout);
      if (!me._hidden && me.trigger("beforeHide", { animate }) !== false) {
        me._hidden = true;
        if (lastAlignSpec) {
          lastAlignSpec.targetOutOfView = null;
          if (lastAlignSpec.monitorIntersection) {
            me.intersectionObserver.takeRecords();
            me.intersectionObserver.unobserve(lastAlignSpec.target);
          }
        }
        me.onConfigChange({
          name: "hidden",
          value: true,
          was: false,
          config: me.$meta.configs.hidden
        });
        if (!element) {
          resolve();
          return;
        }
        if (element.contains(DomHelper.getActiveElement(element))) {
          me.revertFocus(true);
        }
        if (me.isDestroyed) {
          resolve();
          return;
        }
        me.cancelHideShowAnimation();
        if (hideAnimation) {
          const styleProp = Object.keys(hideAnimation)[0], animProps = hideAnimation[styleProp];
          if (Number(getComputedStyle(me.element)[styleProp]) !== animProps.to) {
            const currentAnimation = me.currentAnimation = {
              hiding: true,
              styleProp,
              resolve
            };
            element.classList.add("b-hiding");
            me.isAnimating = true;
            me.currentAnimation.detacher = EventHelper.onTransitionEnd({
              element,
              property: styleProp,
              duration: parseDuration(animProps.duration) + 20,
              handler: () => me.afterHideShowAnimate(currentAnimation),
              thisObj: me
            });
            style[styleProp] = animProps.from;
            DomHelper.getStyleValue(element, styleProp);
            style.transition = `${styleProp} ${animProps.duration} ease ${animProps.delay}`;
            style[styleProp] = animProps.to;
          } else {
            element.classList.add("b-hidden");
          }
        } else {
          element.classList.add("b-hidden");
        }
        me.afterHide(!hideAnimation && resolve, hideAnimation);
      }
    });
  }
  doHideOrRealign({ target, isTrusted }) {
    const me = this, {
      lastAlignSpec,
      element
    } = me, anchoredTo = lastAlignSpec == null ? void 0 : lastAlignSpec.anchoredTo, lastTarget = lastAlignSpec == null ? void 0 : lastAlignSpec.target, position = lastAlignSpec == null ? void 0 : lastAlignSpec.position, activeEl = DomHelper.getActiveElement(me);
    if (
      // If it's a synthesized scroll event (such as from our ResizeMonitor polyfill), ignore it.
      !isTrusted || // Realign happens on frame, might have been removed from DOM so check whether it has layout
      !hasLayout(element) || // event.target might be missing with LockerService enabled. we still need to call the logic as it does not
      // depend much on the scroll target
      target && // If the scroll is inside our element, ignore it.
      (element.contains(target) || target.nodeType === Element.ELEMENT_NODE && me.owns(target) || // If we're scrolling because a focused textual input field which we contain is being shifted into view,
      // we must not reposition - we'll just move with the document content.
      target.nodeType === Element.DOCUMENT_NODE && element.contains(activeEl) && textInputTypes[activeEl] && globalThis.innerHeight < document.body.offsetHeight)
    ) {
      return;
    }
    if (lastAlignSpec.aligningToElement) {
      const newTarget = DomHelper.isInView(lastTarget, false, me);
      if (newTarget && newTarget.equals(lastAlignSpec.targetRect)) {
        return;
      }
    }
    const xy = me.scrollAction === "hide" && me.getXY();
    me.realign();
    if (!me.isDestroyed && isVisible(element) && me.scrollAction === "hide") {
      const [newX, newY] = me.getXY(), moved = newX !== xy[0] || newY !== xy[1];
      if ((lastAlignSpec == null ? void 0 : lastAlignSpec.aligningToEvent) || (moved || (lastTarget == null ? void 0 : lastTarget.$$name) === "Point" || position) && (!anchoredTo || !hasLayout(anchoredTo) || target && DomHelper.isDescendant(target, anchoredTo))) {
        me.hide();
      }
    }
  }
  afterHide(resolveFn = null, hideAnimation = this.hideAnimation) {
    var _a2, _b;
    const me = this;
    me._anchor = me._configuredAnchorState;
    me.removeTransientListeners();
    if (!hideAnimation) {
      me.afterHideAnimation();
    }
    me.trigger("hide");
    (_b = (_a2 = me.owner) == null ? void 0 : _a2.onChildHide) == null ? void 0 : _b.call(_a2, me);
    resolveFn && resolveFn();
  }
  removeTransientListeners() {
    var _a2, _b, _c;
    const me = this, {
      targetObserver,
      lastAlignSpec
    } = me;
    me.clearTimeout(me.resizeListenerTimeout);
    me.clearTimeout(me.scrollListenerTimeout);
    if (targetObserver) {
      targetObserver.disconnect();
      delete me.targetObserver;
    }
    me.documentScrollListener = (_a2 = me.documentScrollListener) == null ? void 0 : _a2.call(me);
    me.targetRootScrollListener = (_b = me.targetRootScrollListener) == null ? void 0 : _b.call(me);
    if (me.targetResizeListener) {
      ResizeMonitor.removeResizeListener(lastAlignSpec.target, me.onTargetResize);
      me.targetResizeListener = false;
    }
    if (me.constrainListeners) {
      const el = ((_c = lastAlignSpec.constrainTo) == null ? void 0 : _c.isRectangle) ? globalThis : lastAlignSpec.constrainTo;
      ResizeMonitor.removeResizeListener(el || globalThis, me.onAlignConstraintChange);
      me.constrainListeners = false;
    }
  }
  afterHideAnimation() {
    const me = this, { element } = me;
    if (me.floating && me.floatRoot.contains(element)) {
      element.remove();
    } else {
      element.classList.add("b-hidden");
    }
    if (me.defaultAnchorBackgroundColor) {
      me.anchorPathElement.setAttribute("fill", me.defaultAnchorBackgroundColor);
    }
  }
  changeHidden(value) {
    const me = this;
    let ret;
    if (me.isConfiguring) {
      ret = Boolean(value);
      me.element.classList[value ? "add" : "remove"]("b-hidden");
    } else {
      me.trigger("beforeChangeHidden", { hidden: value });
      if (value) {
        me.hide();
      } else {
        me.show();
      }
    }
    return ret;
  }
  /**
   * Get id assigned by user (not generated id)
   * @returns {String}
   * @readonly
   * @private
   * @category Misc
   */
  get assignedId() {
    return this.hasGeneratedId ? null : this.id;
  }
  /**
   * Get this Widget's parent when used as a child in a {@link Core.widget.Container},
   * @member {Core.widget.Widget} parent
   * @readonly
   * @category Widget hierarchy
   */
  /**
   * Get the owning Widget of this Widget. If this Widget is directly contained, then the containing
   * Widget is returned. If this Widget is floating, the configured `owner` property is returned.
   * If there is a `forElement`, that element's encapsulating Widget is returned.
   * @property {Core.widget.Widget}
   * @readonly
   * @category Widget hierarchy
   */
  get owner() {
    return this.parent || this._owner || this.containingWidget;
  }
  get containingWidget() {
    var _a2, _b;
    let result = this.parent;
    if (!result) {
      const owningEl = ((_a2 = this.forElement) == null ? void 0 : _a2.nodeType) === Element.ELEMENT_NODE ? this.forElement : (_b = this.element) == null ? void 0 : _b.parentNode;
      result = (owningEl == null ? void 0 : owningEl.closest(".b-widget")) && _Widget.fromElement(owningEl);
    }
    return result;
  }
  /**
   * Get this Widget's previous sibling in the parent {@link Core.widget.Container Container}, or, if not
   * in a Container, the previous sibling widget in the same _parentElement_.
   * @property {Core.widget.Widget}
   * @readonly
   * @category Widget hierarchy
   */
  get previousSibling() {
    return this.getSibling(-1);
  }
  /**
   * Get this Widget's next sibling in the parent {@link Core.widget.Container Container}, or, if not
   * in a Container, the next sibling widget in the same _parentElement_.
   * @property {Core.widget.Widget}
   * @readonly
   * @category Widget hierarchy
   */
  get nextSibling() {
    return this.getSibling(1);
  }
  getSibling(increment) {
    const me = this, { parent } = me, siblings = parent ? parent.childItems : Array.from(me.element.parentElement.querySelectorAll(".b-widget"));
    return parent ? siblings[siblings.indexOf(me) + increment] : _Widget.fromElement(siblings[siblings.indexOf(me.element) + increment]);
  }
  /**
   * Looks up the {@link #property-owner} axis to find an ancestor which matches the passed selector.
   * The selector may be a widget type identifier, such as `'grid'`, or a function which will return
   * `true` when passed the desired ancestor.
   * @param {String|Function} [selector] A Type identifier or selection function. If not provided, this method returns
   * the {@link #property-owner} of this widget
   * @param {Boolean} [deep] When using a string identifier, pass `true` if all superclasses should be included, i.e.,
   * if a `Grid` should match `'widget'`.
   * @param {Number|String|Core.widget.Widget} [limit] how many steps to step up before aborting the search, or a
   * selector to stop at or the topmost ancestor to consider.
   * @returns {Core.widget.Widget|*}
   * @category Widget hierarchy
   */
  up(selector, deep, limit) {
    var _a2;
    const { owner } = this;
    return selector ? (_a2 = owner == null ? void 0 : owner.closest) == null ? void 0 : _a2.call(owner, selector, deep, limit) : owner;
  }
  /**
   * Starts with this Widget, then Looks up the {@link #property-owner} axis to find an ancestor which matches the
   * passed selector. The selector may be a widget type identifier, such as `'grid'`, or a function which will return
   * `true` when passed the desired ancestor.
   * @param {String|Function} selector A Type identifier or selection function.
   * @param {Boolean} [deep] When using a string identifier, pass `true` if all superclasses should be included, i.e.,
   * if a `Grid` should match `'widget'`.
   * @param {Number|String|Core.widget.Widget} [limit] how many steps to step up before aborting the search, or a
   * selector to stop at or the topmost ancestor to consider.
   * @category Widget hierarchy
   */
  closest(selector, deep, limit) {
    const limitType = typeof limit, numericLimit = limitType === "number", selectorLimit = limitType === "string";
    for (let result = this, steps = 1; result; result = result.owner, steps++) {
      if (_Widget.widgetMatches(result, selector, deep)) {
        return result;
      }
      if (numericLimit && steps >= limit) {
        return;
      } else if (selectorLimit && _Widget.widgetMatches(result, limit, deep)) {
        return;
      } else if (result === limit) {
        return;
      }
    }
  }
  /**
   * Returns `true` if this Widget owns the passed Element, Event or Widget. This is based on the widget hierarchy,
   * not DOM containment. So an element in a `Combo`'s dropdown list will be owned by the `Combo`.
   * @param {HTMLElement|Event|Core.widget.Widget} target The element event or Widget to test for being
   * within the ownership tree of this Widget.
   * @category Widget hierarchy
   */
  owns(target) {
    if (target) {
      if ("eventPhase" in target) {
        target = target.target;
      }
      if (target.nodeType === Element.ELEMENT_NODE) {
        if (this.element.contains(target)) {
          return true;
        }
        target = _Widget.fromElement(target);
      }
      while (target) {
        if (target === this) {
          return true;
        }
        target = target.owner;
      }
    }
    return false;
  }
  /**
   * Iterate over all ancestors of this widget.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   * @param {Function} fn Function to execute for all ancestors. Terminate iteration by returning `false`.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   * @category Widget hierarchy
   */
  eachAncestor(fn2) {
    let ancestor = this.owner;
    while (ancestor) {
      if (fn2(ancestor) === false) {
        return false;
      }
      ancestor = ancestor.owner;
    }
    return true;
  }
  changeMaximizeOnMobile(maximizeOnMobile) {
    const me = this;
    if (me.floating && BrowserHelper.isMobile) {
      const { initialConfig } = me;
      if (maximizeOnMobile) {
        me.centered = me.modal = false;
        me.maximized = true;
      } else {
        me.centered = initialConfig.modal;
        me.modal = initialConfig.centered;
        me.maximized = initialConfig.maximized;
      }
    }
  }
  changeMonitorResize(monitorResize, oldMonitorResize) {
    const result = this.scaleToFitWidth ? false : Boolean(monitorResize);
    if (result !== Boolean(oldMonitorResize)) {
      return result;
    }
  }
  updateMonitorResize(monitorResize) {
    const me = this;
    if (!hasOwn4(me, "onElementResize")) {
      me.onElementResize = me.onElementResize.bind(me);
    }
    ResizeMonitor[monitorResize ? "addResizeListener" : "removeResizeListener"](me.element, me.onElementResize);
  }
  changeReadOnly(readOnly) {
    readOnly = Boolean(readOnly);
    if (Boolean(this._readOnly) !== readOnly) {
      return readOnly;
    }
  }
  updateReadOnly(readOnly) {
    var _a2;
    (_a2 = this.element) == null ? void 0 : _a2.classList[readOnly ? "add" : "remove"]("b-readonly");
    if (!this.isConfiguring) {
      this.eachWidget((widget) => {
        if (widget.ignoreParentReadOnly) {
          return;
        }
        if (!("_originalReadOnly" in widget)) {
          widget._originalReadOnly = widget.config.readOnly || false;
        }
        widget.readOnly = readOnly || widget._originalReadOnly;
      }, false);
      this.trigger("readOnly", { readOnly });
    }
  }
  /**
   * Iterate over all widgets owned by this widget and any descendants.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   * @param {Function} fn A function to execute upon each descendant widget.
   * Iteration terminates if this function returns `false`.
   * @param {Core.widget.Widget} fn.widget The current descendant widget.
   * @param {Object} fn.control An object containing recursion control options.
   * @param {Boolean} fn.control.down A copy of the `deep` parameter. This can be adjusted by `fn` to decide which
   * widgets should be recursed. This value will always be the value of `deep` on entry and the value of `control.down`
   * upon return determines the recursion into the current widget.
   * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   * @category Widget hierarchy
   */
  eachWidget(fn2, deep = true) {
    const widgets = this.childItems, length = (widgets == null ? void 0 : widgets.length) || 0, control = {};
    for (let i = 0; i < length; i++) {
      const widget = widgets[i];
      control.down = deep;
      if (fn2(widget, control) === false) {
        return false;
      }
      if (control.down && widget.eachWidget) {
        if (widget.eachWidget(fn2, deep) === false) {
          return false;
        }
      }
    }
    return true;
  }
  /**
   * Returns an array of all descendant widgets which the passed
   * filter function returns `true` for.
   * @param {Function} filter A function which, when passed a widget,
   * returns `true` to include the widget in the results.
   * @returns {Core.widget.Widget[]} All matching descendant widgets.
   * @category Widget hierarchy
   */
  queryAll(filter2) {
    const result = [];
    this.eachWidget((w) => {
      if (filter2(w)) {
        result.push(w);
      }
    });
    return result;
  }
  /**
   * Returns the first descendant widgets which the passed
   * filter function returns `true` for.
   * @param {Function} filter A function which, when passed a widget,
   * returns `true` to return the widget as the sole result.
   * @returns {Core.widget.Widget} The first matching descendant widget.
   * @category Widget hierarchy
   */
  query(filter2) {
    let result = null;
    this.eachWidget((w) => {
      if (filter2(w)) {
        result = w;
        return false;
      }
    });
    return result;
  }
  /**
   * Get a widget by ref, starts on self and traverses up the owner hierarchy checking `widgetMap` at each level.
   * Not checking the top level widgetMap right away to have some acceptance for duplicate refs.
   * @param {String} ref ref to find
   * @returns {Core.widget.Widget}
   * @internal
   * @category Widget hierarchy
   */
  getWidgetByRef(ref) {
    var _a2, _b;
    if (ref instanceof _Widget) {
      return ref;
    }
    return ((_a2 = this == null ? void 0 : this.widgetMap) == null ? void 0 : _a2[ref]) || ((_b = this == null ? void 0 : this.owner) == null ? void 0 : _b.getWidgetByRef(ref));
  }
  onFocusIn(e) {
    const me = this, { element } = me;
    me.containsFocus = true;
    me.focusInEvent = e;
    if (me.floating || me.positioned) {
      me.toFront();
    }
    element.classList.add("b-contains-focus");
    me.updateAriaLabel(me.localizeProperty("ariaLabel"));
    me.updateAriaDescription(me.localizeProperty("ariaDescription"));
    if (element.contains(e._target) && me.onInternalKeyDown && !me.keyDownListenerRemover) {
      me.keyDownListenerRemover = EventHelper.on({
        element,
        keydown: "onInternalKeyDown",
        thisObj: me
      });
    }
    me.trigger("focusin", e);
  }
  onFocusOut(e) {
    const me = this;
    if (me.keyDownListenerRemover) {
      me.keyDownListenerRemover();
      me.keyDownListenerRemover = null;
    }
    if (!me.isDestroyed) {
      if (!e.relatedTarget) {
        me.revertFocus(!me.isVisible);
      }
      me.containsFocus = false;
      me.element.classList.remove("b-contains-focus");
      me.updateAriaLabel(me.localizeProperty("ariaLabel"));
      me.updateAriaDescription(me.localizeProperty("ariaDescription"));
      me.trigger("focusout", e);
    }
  }
  /**
   * Returns a function that will set the focus (`document.activeElement`) to the most consistent element possible
   * based on the focus state at the time this method was called. Derived classes can implement `captureFocusItem()`
   * to refine this process to include logical items (e.g., a grid cell) that would be more stable than DOM element
   * references.
   *
   * If this widget does not contain the focus, the returned function will do nothing.
   * @returns {Function}
   * @internal
   */
  captureFocus() {
    const me = this, activeElementWas = DomHelper.getActiveElement(me), restore = me.contains(activeElementWas) && me.captureFocusItem(activeElementWas);
    return (scrollIntoView, force) => {
      if (restore && !me.isDestroying) {
        const activeElementNow = DomHelper.getActiveElement(me);
        if (activeElementNow !== activeElementWas || force) {
          restore(scrollIntoView);
        }
      }
    };
  }
  /**
   * This method is called by `captureFocus()` when this widget contains the focus and it returns a function that
   * restores the focus to the correct internal element. The returned function is only called if the current
   * `document.activeElement` is different from the passed `activeElement`.
   *
   * This method can be replaced by derived classes to capture stable identifiers for the currently focused, logical
   * item (for example, a cell of a grid).
   *
   * @param {HTMLElement} activeElement The current `document.activeElement`.
   * @returns {Function} Returns a function that accepts a boolean argument. Defaults to `true`, `false` attempts to
   * focus without scrolling.
   * @internal
   */
  captureFocusItem(activeElement) {
    return (scrollIntoView = true) => {
      if (this.contains(activeElement)) {
        scrollIntoView ? activeElement.focus() : DomHelper.focusWithoutScrolling(activeElement);
      }
    };
  }
  /**
   * Returns `true` if this widget is or contains the specified element or widget.
   * @param {HTMLElement|Core.widget.Widget} elementOrWidget The element or widget
   * @param {Boolean} [strict] Pass `true` to test for strict containment (if `elementOrWidget` is this widget, the
   * return value will be `false`).
   * @returns {Boolean}
   * @category Widget hierarchy
   */
  contains(elementOrWidget, strict) {
    const { element } = this;
    if (elementOrWidget && element) {
      if (elementOrWidget.isWidget) {
        elementOrWidget = elementOrWidget.element;
      }
      return element.contains(elementOrWidget) && (!strict || element !== elementOrWidget);
    }
  }
  /**
   * If this Widget contains focus, focus is reverted to the source from which it entered if possible,
   * or to a close relative if not.
   * @param {Boolean} [force] Pass as `true` to move focus to the previously focused item, or the
   * closest possible relative even if this widget does not contain focus.
   * @advanced
   */
  revertFocus(force) {
    var _a2;
    const me = this, activeElement = DomHelper.getActiveElement(me);
    let target = (_a2 = me.focusInEvent) == null ? void 0 : _a2.relatedTarget;
    if (force || me.containsFocus && (target == null ? void 0 : target.nodeType) === Element.ELEMENT_NODE && me.element.contains(activeElement)) {
      if (!target || !DomHelper.isFocusable(target)) {
        target = me.getFocusRevertTarget();
      }
      me._isRevertingFocus = true;
      if (target && DomHelper.isFocusable(target)) {
        target._isRevertingFocus = true;
        DomHelper.focusWithoutScrolling(target);
        target._isRevertingFocus = false;
      } else {
        activeElement == null ? void 0 : activeElement.blur();
      }
      me._isRevertingFocus = false;
    }
  }
  /**
   * This method finds a close sibling (or parent, or parent's sibling etc. recursively) to which focus
   * can be directed in the case of revertFocus not having a focusable element from our focusInEvent.
   *
   * This can happen when the "from" component is destroyed or hidden. We should endeavour to prevent
   * focus escaping to `document.body` for accessibility and ease of use, and keep focus close.
   * @internal
   */
  getFocusRevertTarget() {
    var _a2;
    const me = this, {
      owner,
      focusInEvent
    } = me, searchDirection = focusInEvent ? focusInEvent.backwards ? 1 : -1 : -1;
    let target = focusInEvent && focusInEvent.relatedTarget;
    const toComponent = target && _Widget.fromElement(target);
    if (owner && !owner.isDestroyed && (!target || !DomHelper.isFocusable(target) || toComponent && !toComponent.isFocusable)) {
      target = null;
      if (owner.eachWidget) {
        const siblings = [];
        owner.eachWidget((w) => {
          if (w === me || w.isFocusable) {
            siblings.push(w);
          }
        }, false);
        if (siblings.length > 1) {
          const myIndex = siblings.indexOf(me);
          target = siblings[myIndex + searchDirection] || siblings[myIndex - searchDirection];
        }
      }
      if (!target && owner.isFocusable) {
        target = owner;
      }
      target = target ? target.focusElement : (_a2 = owner.getFocusRevertTarget) == null ? void 0 : _a2.call(owner);
    }
    return target;
  }
  /**
   * Returns a `DomClassList` computed from the `topMostBase` (e.g., `Widget` or `Panel`) with the given `suffix`
   * appended to each `widgetClass`.
   * @param {Function} topMostBase The top-most base class constructor at which to start gathering classes.
   * @param {String} [suffix] An optional suffix to apply to all widget classes.
   * @returns {Core.helper.util.DomClassList}
   * @internal
   * @category DOM
   */
  getStaticWidgetClasses(topMostBase, suffix) {
    const classList = new DomClassList(), hierarchy = this.$meta.hierarchy;
    let cls, i, name, widgetClass, widgetClassProperty;
    for (i = hierarchy.indexOf(topMostBase); i < hierarchy.length; ++i) {
      cls = hierarchy[i];
      widgetClassProperty = Reflect.getOwnPropertyDescriptor(cls.prototype, "widgetClass");
      if (widgetClassProperty == null ? void 0 : widgetClassProperty.get) {
        widgetClass = widgetClassProperty.get.call(this);
      } else {
        name = hasOwn4(cls, "$$name") || hasOwn4(cls, "$name") || hasOwn4(cls, "_$name") ? cls.$$name : cls.name;
        if (name.length < 3 || name.includes("$")) {
          console.warn(
            `Class "${name}" extending "${cls.$name}" should have "$name" static getter with no less than 3 chars.`
          );
        }
        widgetClass = `b-${name.toLowerCase()}`;
      }
      if (widgetClass) {
        classList.add(suffix ? widgetClass + suffix : widgetClass);
      }
    }
    return classList;
  }
  get rootUiClass() {
    return _Widget;
  }
  /**
   * Returns the `DomClassList` for this widget's class. This object should not be mutated.
   * @returns {Core.helper.util.DomClassList}
   * @internal
   * @category DOM
   */
  get staticClassList() {
    const { $meta: meta } = this;
    let classList = meta.staticClassList;
    if (!classList) {
      meta.staticClassList = classList = this.getStaticWidgetClasses(_Widget);
      BrowserHelper.isTouchDevice && classList.add("b-touch");
    }
    return classList;
  }
  /**
   * Returns the cross-product of the classes `staticClassList` with each `ui` as an array of strings.
   *
   * For example, a Combo with a `ui: 'foo bar'` would produce:
   *
   *      [
   *          'b-widget-foo', 'b-field-foo', 'b-textfield-foo', 'b-pickerfield-foo', 'b-combo-foo',
   *          'b-widget-bar', 'b-field-bar', 'b-textfield-bar', 'b-pickerfield-bar', 'b-combo-bar'
   *      ]
   *
   * @returns {String[]}
   * @internal
   * @category DOM
   */
  get uiClasses() {
    this.getConfig("ui");
    return this._uiClasses;
  }
  /**
   * Returns the cross-product of the classes `staticClassList` with each `ui` as a `DomClassList` instance.
   *
   * For example, a Combo with a `ui: 'foo bar'` would produce:
   *
   * ```javascript
   *      new DomClassList({
   *          'b-field-ui-foo'       : 1,
   *          'b-textfield-ui-foo'   : 1,
   *          'b-pickerfield-ui-foo' : 1,
   *          'b-combo-ui-foo'       : 1,
   *
   *          'b-field-ui-bar'       : 1,
   *          'b-textfield-ui-bar'   : 1,
   *          'b-pickerfield-ui-bar' : 1,
   *          'b-combo-ui-bar'       : 1
   *      });
   * ```
   *
   * A Panel with a `ui: 'foo bar'` would produce:
   *
   * ```javascript
   *      new DomClassList({
   *          'b-panel-ui-foo' : 1,
   *          'b-panel-ui-bar' : 1
   *      });
   * ```
   * @returns {Core.helper.util.DomClassList}
   * @internal
   * @category DOM
   */
  get uiClassList() {
    this.getConfig("ui");
    return this._uiClassList;
  }
  /**
   * Used by the Widget class internally to create CSS classes based on this Widget's
   * inheritance chain to allow styling from each level to apply.
   *
   * For example Combo would yield `"["b-widget", "b-field", "b-textfield", "b-pickerfield", "b-combo"]"`
   *
   * May be implemented in subclasses to add or remove classes from the super.widgetClassList
   * @returns {String[]} The css class list named using the class name.
   * @internal
   * @category DOM
   */
  get widgetClassList() {
    const me = this, { cls, defaultCls, uiClasses } = me;
    let { staticClassList } = me;
    if (defaultCls || cls) {
      staticClassList = staticClassList.clone();
      defaultCls && staticClassList.assign(defaultCls);
      cls && staticClassList.assign(cls);
    }
    const classList = staticClassList.values;
    uiClasses && classList.push(...uiClasses);
    me.floating && classList.push("b-floating");
    if (me.collapsify === "hide") {
      classList.push("b-collapsify-hide");
    }
    return classList;
  }
  changeCls(cls) {
    return DomClassList.from(cls);
  }
  updateCls(cls, was) {
    if (!this.isConfiguring && !this.isComposable) {
      const { element } = this;
      if (was) {
        ObjectHelper.getTruthyKeys(was).forEach((c) => element.classList.remove(c));
      }
      cls.assignTo(element);
    }
  }
  changeContentElementCls(cls) {
    return DomClassList.from(cls);
  }
  changeHtmlCls(cls) {
    return DomClassList.from(cls);
  }
  changeDefaultCls(cls) {
    return DomClassList.from(
      cls,
      /* returnEmpty */
      true
    );
  }
  changeUi(ui) {
    return DomClassList.from(ui);
  }
  updateUi(ui) {
    let uiClassList = null, cls, suffix;
    if (ui) {
      const staticClassList = this.getStaticWidgetClasses(this.rootUiClass);
      for (suffix in ui) {
        if (ui[suffix]) {
          for (cls in staticClassList) {
            if (staticClassList[cls]) {
              (uiClassList || (uiClassList = new DomClassList()))[`${cls}-ui-${suffix}`] = 1;
            }
          }
        }
      }
    }
    this._uiClasses = uiClassList == null ? void 0 : uiClassList.values;
    this._uiClassList = uiClassList;
  }
  //endregion
  //region Cache
  /**
   * Gets dom elements in the view. Caches the results for faster future calls.
   * @param {String} query CSS selector
   * @param {Boolean} children true to fetch multiple elements
   * @param {HTMLElement} element Element to use as root for the query, defaults to the views outermost element
   * @returns {HTMLElement|HTMLElement[]|null} A single element or an array of elements (if parameter children is set to true)
   * @internal
   * @category DOM
   */
  fromCache(query, children = false, element = this.element) {
    if (!element)
      return null;
    const me = this;
    if (!me.cache[query]) {
      me.cache[query] = children ? DomHelper.children(element, query) : DomHelper.down(element, query);
    }
    return me.cache[query];
  }
  /**
   * Clear caches, forces all calls to fromCache to requery dom. Called on render/rerender.
   * @internal
   * @category DOM
   */
  emptyCache() {
    this.cache = {};
  }
  //endregion
  //region Mask
  changeMasked(mask, maskInstance) {
    var _a2;
    if (((_a2 = this.masked) == null ? void 0 : _a2.type) === "trial") {
      return;
    }
    if (mask === true || mask === "") {
      mask = "\xA0";
    }
    if (maskInstance && !maskInstance.isDestroyed) {
      if (typeof mask === "string") {
        maskInstance.text = mask;
        mask = maskInstance;
      } else if (mask) {
        maskInstance.setConfig(mask);
        mask = maskInstance;
      } else {
        maskInstance.destroy();
      }
    } else if (mask) {
      const Mask2 = _Widget.resolveType("mask");
      mask = Mask2.mergeConfigs(this.maskDefaults, mask);
      mask.owner = this;
      mask = Mask2.mask(mask);
    }
    return mask || null;
  }
  onMaskAutoClose(mask) {
    if (mask.isDestroyed && mask === this.masked) {
      this.masked = null;
    }
  }
  /**
   * Mask the widget, showing the specified message
   * @param {String|MaskConfig} msg Mask message (or a {@link Core.widget.Mask} config object
   * @returns {Core.widget.Mask}
   */
  mask(msg) {
    this.masked = msg;
    return this.masked;
  }
  /**
   * Unmask the widget
   */
  unmask() {
    this.masked = null;
  }
  //endregion
  //region Monitor resize
  onInternalResize(element, width, height, oldWidth, oldHeight) {
    this._width = element.offsetWidth;
    this._height = element.offsetHeight;
  }
  onElementResize(resizedElement, lastRect) {
    var _a2;
    const me = this, { element } = me, oldWidth = (_a2 = me._width) != null ? _a2 : me._oldWidth, oldHeight = me._height, newWidth = element.offsetWidth, newHeight = element.offsetHeight;
    if (me.floating && lastRect) {
      me.onFloatingWidgetResize(...arguments);
    }
    if (!me.suspendResizeMonitor && (oldWidth !== newWidth || oldHeight !== newHeight)) {
      me.onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight);
      me.trigger("resize", { width: newWidth, height: newHeight, oldWidth, oldHeight });
    }
  }
  onFloatingWidgetResize(resizedElement, lastRect, myRect) {
    const me = this, {
      lastAlignSpec,
      constrainTo
    } = me;
    if (me.isVisible && lastAlignSpec && lastAlignSpec.target) {
      const heightChange = !lastRect || myRect.height !== lastRect.height, widthChange = !lastRect || myRect.width !== lastRect.width, failsConstraint = constrainTo && !Rectangle.from(constrainTo).contains(Rectangle.from(me.element, null, true));
      if (heightChange && lastAlignSpec.zone !== 2 || widthChange && lastAlignSpec.zone !== 1 || failsConstraint) {
        me.requestAnimationFrame(() => me.realign());
      }
    }
  }
  updateScale() {
    const me = this, element = me.element, parentElement = element.parentElement;
    if (!me.configuredWidth) {
      me.configuredWidth = me.width;
    }
    element.style.display = "none";
    const rect = Rectangle.client(parentElement), scale = rect.width / me.configuredWidth, adjustedScale = me.scale = me.allowGrowWidth ? Math.min(scale, 1) : scale;
    element.style.transform = `scale(${adjustedScale})`;
    element.style.transformOrigin = "top left";
    element.style.display = "";
    if (me.allowGrowWidth && scale > 1) {
      me.width = me.configuredWidth * scale;
    }
  }
  onParentElementResize(event) {
    this.updateScale();
  }
  //endregion
  /**
   * Returns a `TRBL` array of values parse from the passed specification. This can be used to parse`
   * a value list for `margin` or `padding` or `border-width` etc - any CSS value which takes a `TRBL` value.
   * @param {Number|String|String[]} values The `TRBL` value
   * @param {String} [units=px] The units to add to values which are specified as numeric.
   * @internal
   */
  parseTRBL(values, units = "px") {
    values = values || 0;
    if (typeof values === "number") {
      return [`${values}${units}`, `${values}${units}`, `${values}${units}`, `${values}${units}`];
    }
    const parts = values.split(" "), len = parts.length;
    if (len === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else if (len === 2) {
      parts[2] = parts[0];
      parts[3] = parts[1];
    } else if (len === 3) {
      parts[3] = parts[1];
    }
    return [
      isFinite(parts[0]) ? `${parts[0]}${units}` : parts[0],
      isFinite(parts[1]) ? `${parts[1]}${units}` : parts[2],
      isFinite(parts[2]) ? `${parts[2]}${units}` : parts[3],
      isFinite(parts[3]) ? `${parts[3]}${units}` : parts[4]
    ];
  }
  // Returns root node for this widget, either a document or a shadowRoot
  get documentRoot() {
    var _a2;
    return ((_a2 = this.owner) == null ? void 0 : _a2.documentRoot) || this.element.getRootNode();
  }
  // Returns the root from which to add global events. Prioritizes owner last.
  get eventRoot() {
    var _a2, _b;
    return ((_a2 = this.element) == null ? void 0 : _a2.isConnected) ? DomHelper.getRootElement(this.element) : ((_b = this.owner) == null ? void 0 : _b.eventRoot) || this._rootElement;
  }
  // Returns top most DOM element of the visible DOM tree for this widget element, either document.body or a shadowRoot
  get rootElement() {
    var _a2, _b;
    const me = this;
    if (!me._rootElement) {
      let root = ((_a2 = me.owner) == null ? void 0 : _a2.rootElement) || DomHelper.getRootElement(me.forElement || (((_b = me.element) == null ? void 0 : _b.isConnected) ? me.element : me.getRenderContext()[0] || me.element));
      if (!root) {
        root = document.body;
      }
      me._rootElement = root;
    }
    return me._rootElement;
  }
  get floatRoot() {
    var _a2;
    const me = this, { rootElement } = me;
    let { floatRoot } = rootElement;
    if (!floatRoot) {
      const { outerCls } = _Widget, themeName = (_a2 = DomHelper.getThemeInfo(null, rootElement)) == null ? void 0 : _a2.name;
      if (!DomHelper.isValidFloatRootParent(rootElement)) {
        throw new Error("Attaching float root to wrong root");
      }
      if (themeName) {
        outerCls.push(`b-theme-${themeName.toLowerCase()}`);
      }
      floatRoot = rootElement.floatRoot = DomHelper.createElement({
        className: `b-float-root ${outerCls.join(" ")}`,
        parent: rootElement
      });
      floatRoots.push(floatRoot);
      if (BrowserHelper.isAndroid) {
        floatRoot.style.height = `${screen.height}px`;
        EventHelper.on({
          element: globalThis,
          orientationchange: () => floatRoot.style.height = `${screen.height}px`,
          thisObj: this
        });
      }
      GlobalEvents_default.ion({
        theme: ({ theme, prev }) => {
          floatRoot.classList.add(`b-theme-${theme.toLowerCase()}`);
          floatRoot.classList.remove(`b-theme-${prev.toLowerCase()}`);
        }
      });
    } else if (!rootElement.contains(floatRoot)) {
      rootElement.appendChild(floatRoot);
    }
    return floatRoot;
  }
  get floatRootMaxZIndex() {
    let max = 1;
    Array.from(this.floatRoot.children).forEach((child) => {
      const zIndex = parseInt(getComputedStyle(child).zIndex || 0, 10);
      if (zIndex > max) {
        max = zIndex;
      }
    });
    return max;
  }
  static resetFloatRootScroll() {
    floatRoots.forEach((floatRoot) => floatRoot.scrollTop = floatRoot.scrollLeft = 0);
  }
  static get floatRoots() {
    return floatRoots;
  }
  static removeFloatRoot(floatRoot) {
    floatRoots.splice(floatRoots.indexOf(floatRoot), 1);
  }
  // CSS classes describing outer-most Widgets to provide styling / behavioral CSS style rules
  static get outerCls() {
    const result = ["b-outer"], { platform } = BrowserHelper;
    if (platform) {
      result.push(`b-${platform}`);
    }
    if (BrowserHelper.isTouchDevice) {
      result.push("b-touch-events");
    }
    if (BrowserHelper.isMobile) {
      result.push("b-mobile");
    }
    if (DomHelper.scrollBarWidth) {
      result.push("b-visible-scrollbar");
    } else {
      result.push("b-overlay-scrollbar");
    }
    if (BrowserHelper.isChrome) {
      result.push("b-chrome");
    } else if (BrowserHelper.isSafari) {
      result.push("b-safari");
    } else if (BrowserHelper.isFirefox) {
      result.push("b-firefox");
    }
    if (BrowserHelper.isPhone) {
      result.push("b-phone");
    }
    if (!globalThis.ResizeObserver) {
      result.push("b-no-resizeobserver");
    }
    return result;
  }
  get isAnimating() {
    return this._isAnimatingCounter > 0;
  }
  set isAnimating(value) {
    const me = this, { _isAnimatingCounter } = me;
    me._isAnimatingCounter = Math.max(0, _isAnimatingCounter + (value ? 1 : -1));
    if (_isAnimatingCounter === 0 && value) {
      me.element.classList.add("b-animating");
      me.trigger("animationStart");
    } else if (_isAnimatingCounter === 1 && !value) {
      me.element.classList.remove("b-animating");
      me.trigger("animationEnd");
    }
  }
  // Waits until all transitions are completed
  async waitForAnimations() {
    if (this.isAnimating) {
      await this.await("animationend", { checkLog: false });
    }
  }
  /**
   * Analogous to `document.querySelector`, finds the first Bryntum widget matching the passed
   * selector. Right now, only class name (lowercased) selector strings, or
   * a filter function which returns `true` for required object are allowed:
   *
   * ```javascript
   * Widget.query('grid').destroy();
   * ```
   *
   * @param {String|Function} selector A lowercased class name, or a filter function.
   * @param {Boolean} [deep] Specify `true` to search the prototype chain (requires supplying a string `selector`). For
   * example 'widget' would then find a Grid
   * @returns {Core.widget.Widget} The first matched widget if any.
   * @category Widget hierarchy
   */
  static query(selector, deep = false) {
    const { idMap } = _Widget.identifiable;
    for (const id in idMap) {
      if (_Widget.widgetMatches(idMap[id], selector, deep)) {
        return idMap[id];
      }
    }
    return null;
  }
  /**
   * Analogous to document.querySelectorAll, finds all Bryntum widgets matching the passed
   * selector. Right now, only registered widget `type` strings, or a filter function which
   * returns `true` for required object are allowed:
   *
   * ```javascript
   * let allFields = Widget.queryAll('field', true);
   * ```
   *
   * @param {String|Function} selector A lowercased class name, or a filter function.
   * @param {Boolean} [deep] Specify `true` to search the prototype chain (requires supplying a string `selector`). For
   * example 'widget' would then find a Grid
   * @returns {Core.widget.Widget[]} The first matched widgets if any - an empty array will be returned
   * if no matches are found.
   * @category Widget hierarchy
   */
  static queryAll(selector, deep = false) {
    const { idMap } = _Widget.identifiable, result = [];
    for (const id in idMap) {
      if (_Widget.widgetMatches(idMap[id], selector, deep)) {
        result.push(idMap[id]);
      }
    }
    return result;
  }
  /**
   * Returns the Widget which owns the passed element (or event).
   * @param {HTMLElement|Event} element The element or event to start from
   * @param {String|Function} [type] The type of Widget to scan upwards for. The lowercase
   * class name. Or a filter function which returns `true` for the required Widget
   * @param {HTMLElement|Number} [limit] The number of components to traverse upwards to find a
   * match of the type parameter, or the element to stop at
   * @returns {Core.widget.Widget|null} The found Widget or null
   * @category Misc
   */
  static fromElement(element, type, limit) {
    const typeOfType = typeof type;
    if (element && !element.nodeType) {
      element = element.target;
    }
    if (typeOfType === "number" || type && type.nodeType === Element.ELEMENT_NODE) {
      limit = type;
      type = null;
    }
    let target = element, depth = 0, topmost, cmpId, cmp;
    if (typeof limit !== "number") {
      topmost = limit;
      limit = Number.MAX_VALUE;
    }
    if (typeOfType === "string") {
      type = type.toLowerCase();
    }
    while (target && target.nodeType === Element.ELEMENT_NODE && depth < limit && target !== topmost) {
      cmpId = target.dataset && target.dataset.ownerCmp || target.id;
      if (cmpId) {
        cmp = _Widget.getById(cmpId);
        if (cmp) {
          if (type) {
            if (typeOfType === "function") {
              if (type(cmp)) {
                return cmp;
              }
            } else if (_Widget.widgetMatches(cmp, type, true)) {
              return cmp;
            }
          } else {
            return cmp;
          }
        }
        depth++;
      }
      target = target.parentNode;
    }
    return null;
  }
  /**
   * Returns the Widget which owns the passed CSS selector.
   *
   * ```javascript
   * const button = Widget.fromSelector('#my-button');
   * ```
   *
   * @param {String} selector CSS selector
   * @returns {Core.widget.Widget|null} The found Widget or null
   * @category Misc
   */
  static fromSelector(selector) {
    const element = document.querySelector(selector);
    return element ? _Widget.fromElement(element) : null;
  }
  // NOTE: Not named `triggerChange` to not conflict with existing fn on Field
  /**
   * Triggers a 'change' event with the supplied params. After triggering it also calls `onFieldChange()` on each
   * ancestor the implements that function, supplying the same set of params.
   * @param {Object} params Event params, used both for triggering and notifying ancestors
   * @param {Boolean} [trigger] `false` to not trigger, only notifying ancestors
   * @internal
   */
  triggerFieldChange(params, trigger = true) {
    var _a2;
    if (trigger) {
      this.trigger("change", params);
    }
    (_a2 = this.eachAncestor) == null ? void 0 : _a2.call(this, (ancestor) => {
      var _a3, _b;
      (_a3 = ancestor.onFieldChange) == null ? void 0 : _a3.call(ancestor, params);
      if ((_b = ancestor.isolateFieldChange) == null ? void 0 : _b.call(ancestor, this)) {
        return false;
      }
    });
  }
  /**
   * Returns `true` if the given `field`'s value change should be isolated (kept hidden by this widget). By default,
   * this method returns the value of {@link Core.widget.Container#config-isolateFields} for all fields.
   * @param {Core.widget.Field} field The field in question.
   * @internal
   */
  isolateFieldChange(field) {
    return this.isolateFields;
  }
  // Sets up the focus listeners, one set for every document root (shadow root or document)
  setupFocusListeners() {
    GlobalEvents_default.setupFocusListenersOnce(this.eventRoot, EventHelper);
  }
  static widgetMatches(candidate, selector, deep) {
    if (selector === "*") {
      return true;
    }
    if (typeof selector === "function") {
      return selector(candidate);
    }
    return _Widget.isType(candidate, selector, deep);
  }
  /**
   * Attached a tooltip to the specified element.
   *
   * ```javascript
   * Widget.attachTooltip(element, {
   *   text: 'Useful information goes here'
   * });
   * ```
   *
   * @param {HTMLElement} element Element to attach tooltip for
   * @param {TooltipConfig|String} configOrText Tooltip config or tooltip string, see example and source
   * @returns {HTMLElement} The passed element
   * @category Misc
   */
  static attachTooltip(element, configOrText) {
    if (typeof configOrText === "string")
      configOrText = { html: configOrText };
    _Widget.create(Object.assign({
      forElement: element
    }, configOrText), "tooltip");
    return element;
  }
  //region RTL
  // Since we use flexbox docking flips correctly out of the box. start and end values can be mapped straight to
  // left and right, for both LTR and RTL
  changeDock(dock) {
    if (dock === "start") {
      return "left";
    }
    if (dock === "end") {
      return "right";
    }
    return dock;
  }
  updateRtl(rtl) {
    super.updateRtl(rtl);
    this.eachWidget((item) => {
      if (!("rtl" in item.initialConfig)) {
        item.rtl = rtl;
      }
    });
  }
  //endregion
};
var proto2 = Widget.prototype;
["compose", "domSyncCallback"].forEach((fn2) => proto2[fn2].$nullFn = true);
Widget.initClass();
Widget.register("mask", Mask);
DomHelper.Widget = Widget;
GlobalEvents_default.Widget = Widget;
Mask.identifiable.idMap = Widget.identifiable.idMap;
Object.assign(globalThis.bryntum || (globalThis.bryntum = {}), {
  get: Widget.getById.bind(Widget),
  query: Widget.query,
  queryAll: Widget.queryAll,
  fromElement: Widget.fromElement,
  fromSelector: Widget.fromSelector
});
Widget._$name = "Widget";

// ../Core/lib/Core/widget/layout/Layout.js
var Layout = class extends Base.mixin(Events_default, Factoryable_default) {
  get contentElement() {
    var _a2;
    return (_a2 = this.owner) == null ? void 0 : _a2.contentElement;
  }
  onChildAdd(item) {
  }
  onChildRemove(item) {
  }
  renderChildren() {
    const me = this, { owner, itemCls } = me, { contentElement, items: items2 } = owner, ownerItemCls = owner.itemCls, itemCount = items2 == null ? void 0 : items2.length;
    if (itemCount) {
      owner.textContent = false;
      for (let i = 0; i < itemCount; i++) {
        const item = items2[i], { element } = item, { classList } = element;
        element.dataset.itemIndex = i;
        if (classList.contains("b-outer")) {
          classList.remove(...Widget.outerCls);
        }
        if (itemCls) {
          classList.add(itemCls);
        }
        if (ownerItemCls) {
          classList.add(ownerItemCls);
        }
        item.render(contentElement, Boolean(owner.isPainted));
      }
    }
    me.syncPendingConfigs();
    me.syncChildCount();
  }
  removeChild(child) {
    const me = this, { element } = child, { owner, itemCls } = me, { contentElement } = owner, ownerItemCls = owner.itemCls;
    if (contentElement.contains(element)) {
      element.remove();
    }
    delete element.dataset.itemIndex;
    if (itemCls) {
      element.classList.remove(itemCls);
    }
    if (ownerItemCls) {
      element.classList.remove(ownerItemCls);
    }
    me.fixChildIndices();
    me.syncChildCount();
  }
  appendChild(child) {
    const { element } = child, { owner, itemCls } = this, { contentElement } = owner, ownerItemCls = owner.itemCls;
    element.dataset.itemIndex = owner.indexOfChild(child);
    owner.textContent = false;
    if (itemCls) {
      element.classList.add(itemCls);
    }
    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }
    child.render(contentElement, Boolean(owner.isPainted));
    this.syncChildCount();
  }
  insertChild(toAdd, childIndex) {
    const me = this, { element } = toAdd, { owner, itemCls } = me, { contentElement } = owner, nextSibling = DomHelper.getChild(contentElement, `[data-item-index="${childIndex}"]`), ownerItemCls = owner.itemCls;
    owner.textContent = false;
    if (itemCls) {
      element.classList.add(itemCls);
    }
    if (ownerItemCls) {
      element.classList.add(ownerItemCls);
    }
    contentElement.insertBefore(element, nextSibling);
    toAdd.render(null, Boolean(owner.isPainted));
    me.fixChildIndices();
    me.syncChildCount();
  }
  fixChildIndices() {
    this.owner.items.forEach((child, index) => {
      child.element.dataset.itemIndex = index;
    });
  }
  syncChildCount() {
    var _a2;
    const { owner } = this, { length } = owner.items;
    (_a2 = owner.contentElement) == null ? void 0 : _a2.classList[length === 1 ? "add" : "remove"]("b-single-child");
  }
  /**
   * Registers a layout `config` property that cannot be acted upon at this time but must wait for the `owner` to
   * fully render its elements (in particular the `contentElement`).
   * @param {String} config The name of the config to sync later.
   * @internal
   */
  syncConfigLater(config) {
    const pendingConfigs = this.pendingConfigs || (this.pendingConfigs = []);
    if (!pendingConfigs.includes(config)) {
      pendingConfigs.push(config);
    }
  }
  /**
   * Sets the specified `style` to the value of the config given its `name`.
   * @param {Object} options The name of the config with the value to apply to the given `style`.
   * @param {String} options.name The name of the config with the value to apply to the given `style`.
   * @param {String} options.style The style property to set on the `contentElement`.
   * @param {String[]} [options.classes] A list of config values that should be added as CSS classes.
   * @param {Object} [options.map] An mapping object to convert the config's value to the `style` value.
   * @internal
   */
  syncConfigStyle({ name, style, classes, map: map2 }) {
    const me = this, baseCls = `b-box-${name}-`, { contentElement } = me, raw = me[name];
    let value = (map2 == null ? void 0 : map2[raw]) || raw;
    if (contentElement) {
      if (classes) {
        const { classList } = contentElement;
        classes.forEach((c) => {
          if (c !== value) {
            classList.remove(baseCls + c);
          }
        });
        if (classes.includes(value)) {
          classList.add(baseCls + value);
          value = "";
        }
      }
      contentElement.style[style] = value;
    } else {
      me.syncConfigLater(name);
    }
  }
  syncPendingConfigs() {
    const me = this, { pendingConfigs } = me;
    let name;
    if (pendingConfigs) {
      me.pendingConfigs = null;
      while (name = pendingConfigs.pop()) {
        me[me.$meta.configs[name].updater](me[name]);
      }
    }
  }
};
__publicField(Layout, "type", "default");
__publicField(Layout, "configurable", {
  /**
   * The owning Widget.
   * @member {Core.widget.Widget} owner
   * @readonly
   */
  /**
   * @config {Core.widget.Widget} owner
   * @private
   */
  owner: null,
  /**
   * The CSS class which should be added to the owning {@link Core.widget.Container}'s.
   * {@link Core.widget.Widget#property-contentElement}.
   * @config {String}
   */
  containerCls: "b-auto-container",
  /**
   * The CSS class which should be added to the encapsulating element of child items.
   * @config {String}
   */
  itemCls: null
});
// establish this class as the Factoryable base
__publicField(Layout, "factoryable", {
  defaultType: "default"
});
Layout.initClass();
Layout._$name = "Layout";

// ../Core/lib/Core/widget/Ripple.js
var lastTouchTime = 0;
var hasRipple = (w) => w.ripple;
var Ripple = class extends Widget {
  static get defaultConfig() {
    return {
      old_element: {
        children: [{
          className: "b-ripple-inner",
          reference: "rippleElement"
        }]
      },
      element: {
        children: [{
          tag: "svg",
          class: "b-ripple-inner",
          reference: "rippleElement",
          ns: "http://www.w3.org/2000/svg",
          version: "1.1",
          viewBox: "0 0 100 100",
          children: [{
            reference: "circleElement",
            tag: "circle",
            cx: "0",
            cy: "0",
            r: 10
          }]
        }]
      },
      floating: true,
      hideAnimation: false,
      showAnimation: false,
      scrollAction: "realign",
      color: "rgba(0,0,0,.3)",
      startRadius: 10,
      radius: 100
    };
  }
  afterConstruct() {
    super.afterConstruct();
    EventHelper.on({
      element: this.rootElement,
      mousedown: "onRippleControllingEvent",
      thisObj: this,
      capture: true,
      once: true
    });
  }
  onRippleControllingEvent(event) {
    var _a2;
    const me = this;
    me.show();
    const rippleAnimation = DomHelper.getStyleValue(me.circleElement, "animationName");
    me.hide();
    (_a2 = me.listenerDetacher) == null ? void 0 : _a2.call(me);
    if (rippleAnimation && rippleAnimation !== "none") {
      me.listenerDetacher = EventHelper.on({
        // Trap all mousedowns and see if the encapsulating Component is configured to ripple
        mousedown: {
          element: me.rootElement,
          capture: true,
          handler: "onMousedown"
        },
        touchstart: {
          element: me.rootElement,
          capture: true,
          handler: "onTouchStart"
        },
        // Hide at the end of the ripple
        animationend: {
          element: me.circleElement,
          handler: "onAnimationEnd"
        },
        thisObj: me
      });
      if (event.type === "mousedown") {
        me.onMousedown(event);
        GlobalEvents_default.ion({
          theme: "onRippleControllingEvent",
          thisObj: this
        });
      }
    }
  }
  onTouchStart(event) {
    lastTouchTime = performance.now();
    this.handleTriggerEvent(event);
  }
  onMousedown(event) {
    if (performance.now() - lastTouchTime > 200) {
      this.handleTriggerEvent(event);
    }
  }
  handleTriggerEvent(event) {
    const targetWidget = Widget.fromElement(event.target, hasRipple);
    if (targetWidget) {
      const rippleCfg = targetWidget.ripple, target = rippleCfg.delegate ? event.target.closest(rippleCfg.delegate) : targetWidget.focusElement || targetWidget.element;
      if (target) {
        const ripple = ObjectHelper.assign({
          event,
          target,
          radius: this.radius
        }, rippleCfg);
        if (typeof ripple.clip === "string") {
          ripple.clip = targetWidget[ripple.clip] || event.target.closest(ripple.clip);
          if (!ripple.clip) {
            return;
          }
        }
        this.ripple(ripple);
      }
    }
  }
  ripple({
    event,
    point = EventHelper.getClientPoint(event),
    target = event.target,
    clip = target,
    radius = this.radius,
    color = this.color
  }) {
    this.clip = clip;
    clip = Rectangle.from(clip, null, true);
    const me = this, centreDelta = clip.getDelta(point), rippleStyle = me.rippleElement.style, circleElement = me.circleElement, borderRadius = DomHelper.getStyleValue(target, "border-radius");
    me.hide();
    rippleStyle.transform = `translateX(${centreDelta[0]}px) translateY(${centreDelta[1]}px)`;
    rippleStyle.height = rippleStyle.width = `${radius}px`;
    me.element.style.borderRadius = borderRadius;
    circleElement.setAttribute("r", radius);
    circleElement.setAttribute("fill", color);
    me.showBy({
      target: clip,
      align: "c-c",
      matchSize: true
    });
  }
  // When fully expanded, it's all over.
  onAnimationEnd(event) {
    if (event.animationName === "b-ripple-expand") {
      this.hide();
    }
  }
};
__publicField(Ripple, "$name", "Ripple");
__publicField(Ripple, "type", "ripple");
Widget.RippleClass = Ripple;
Ripple._$name = "Ripple";

// ../Core/lib/Core/widget/Container.js
var emptyObject6 = Object.freeze({});
var { isArray: isArray2 } = Array;
var returnWeight = (i) => i.weight;
var sortByWeight = ({ weight: a }, { weight: b }) => {
  if (typeof a === "string" || typeof b === "string") {
    return String(a).localeCompare(String(b));
  }
  return (a != null ? a : Number.MAX_SAFE_INTEGER) - (b != null ? b : Number.MAX_SAFE_INTEGER);
};
var isNotHidden = (w) => w && !w.hidden;
var stylesToCheck = ["display", "flex-direction"];
var boxLayouts = {
  default: 1,
  box: 1
};
var Container = class extends Widget {
  static get configurable() {
    return {
      /**
       * An object containing typed child widget config objects or Widgets. May also be specified
       * as an array.
       *
       * If configured as an Object, the property names are used as the child component's
       * {@link Core.widget.Widget#config-ref} name, and the value is the child component's config object.
       *
       * ```javascript
       *
       *  class MyContainer extends Container {
       *      static get configurable() {
       *          return {
       *              items : {
       *                  details : {
       *                      type : 'panel',
       *                      ....
       *                  },
       *                  button : {
       *                      type : 'button',
       *                      text : 'Save'
       *                  }
       *              }
       *          }
       *      }
       *  }
       *
       *  new MyContainer({
       *      title    : 'Test Container',
       *      floating : true,
       *      centered : true,
       *      width    : 600,
       *      height   : 400,
       *      layout   : 'fit',
       *      items    : {
       *          button : {
       *              disabled : true
       *          },
       *          details : {
       *              title : 'More coolness',
       *              html  : 'Details content'
       *          }
       *      }
       *  }).show();
       * ```
       *
       * The order of the child widgets is determined by the order they are defined in `items`, but can also be
       * affected by configuring a {@link Core.widget.Widget#config-weight} on one or more widgets.
       *
       * To remove existing items, set corresponding keys to `null`.
       *
       * If you want to customize child items of an existing class, you can do this using the child widget
       * 'ref' identifier (useful for reconfiguring Event Editor in Scheduler / Gantt):
       *
       * ```javascript
       *  new MyCustomTabPanel({
       *      items    : {
       *          // Reconfigure tabs
       *          firstTab : {
       *              title : 'My custom title'
       *          },
       *          secretTab : null // hide this tab
       *      }
       *  }).show();
       * ```
       *
       * @config {Object<String,ContainerItemConfig|MenuItemConfig|Boolean|null>|Array<ContainerItemConfig|MenuItemConfig|Core.widget.Widget>}
       * @category Content
       */
      items: null,
      /**
       * An array of {@link #config-items child item} _config objects_ which is to be converted into
       * instances only when this Container is rendered, rather than eagerly at construct time.
       *
       * _This is mutually exclusive with the {@link #config-items} config._
       *
       * @config {Object<String,ContainerItemConfig>|ContainerItemConfig[]|Core.widget.Widget[]}
       * @category Content
       */
      lazyItems: {
        $config: ["lazy"],
        value: null
      },
      /**
       * A config object containing default settings to apply to all child widgets.
       * @config {Object}
       * @category Content
       */
      defaults: null,
      defaultType: "widget",
      /**
       * The CSS style properties to apply to the {@link Core.widget.Widget#property-contentElement}.
       *
       * By default, a Container's {@link Core.widget.Widget#property-contentElement} uses flexbox layout, so this
       * config may contain the following properties:
       *
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction">flexDirection</a> default '`row`'
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap">flexWrap</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/flex-flow">flexFlow</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content">justifyContent</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-items">alignItems</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-content">alignContent</a>
       * - <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/place-content">placeContent</a>
       * @prp {Object}
       * @category Layout
       */
      layoutStyle: null,
      /**
       * An optional CSS class to add to child items of this container.
       * @config {String}
       * @category CSS
       */
      itemCls: null,
      /**
       * The {@link #config-layout} as an instance of {@link Core.widget.layout.Layout}.
       * This is a helper class which adds and removes child widgets to this Container's
       * DOM and applies CSS classes based upon its requirements.
       *
       * The {@link Core.widget.layout.Card card} layout provides for showing one child
       * widget at a time, and provides a switching API to change which child widget is
       * currently active.
       * @member {Core.widget.layout.Layout} layout
       * @category Layout
       */
      /**
       * The short name of a helper class which manages rendering and styling of child items.
       *
       * Or a config object which includes a `type` property which specifies which type
       * of layout to use, and how to configure that layout.
       *
       * By default, the only special processing that is applied is that the Container class's
       * {@link #config-itemCls} is added to child items.
       *
       * Containers use CSS flexbox in its default configuration to arrange child items. You may either use the
       * {@link #config-layoutStyle} configuration to tune how child items are layed out, or use one of the built
       * in helper classes which include:
       *
       *  - `fit` A single child item is displayed fitting exactly into the
       *  {@link Core.widget.Widget#property-contentElement}.
       *  - `card` Child items are displayed one at a time, size to fit the
       *  {@link Core.widget.Widget#property-contentElement} and are slid in from the side when activated.
       *  - `box` Child items are layed out using flexbox.
       *
       * For example:
       * ```javascript
       * {
       *     id     : 'myContainer',
       *     // Our child items flow downwards and are stretched to fill our width
       *     layout : {
       *         type       : 'box',
       *         direction  : 'column'
       *         align      : 'stretch'
       *     }
       * }
       * @config {String|ContainerLayoutConfig}
       * @category Layout
       */
      layout: {
        type: "default"
      },
      /**
       * An object containing named config objects which may be referenced by name in any {@link #config-items}
       * object. For example, a specialized {@link Core.widget.Menu Menu} subclass may have a `namedItems` default
       * value defined like this:
       *
       * ```javascript
       *  namedItems : {
       *      removeRow : {
       *          text : 'Remove row',
       *          onItem() {
       *              this.ownerGrid.remove(this.ownerGrid.selectedRecord);
       *          }
       *      }
       *  }
       * ```
       *
       * Then whenever that subclass is instantiated and configured with an {@link #config-items} object, the
       * items may be configured like this:
       *
       * ```javascript
       *  items : {
       *      removeRow : true,   // The referenced namedItem will be applied to this
       *      otherItemRef : {
       *          text : 'Option 2',
       *          onItem() {
       *          }
       *      }
       * }
       * ```
       * @config {Object<string,ContainerItemConfig>}
       * @category Content
       */
      namedItems: null,
      /**
       * When set to `true`, this widget is considered as a whole when processing {@link Core.widget.Toolbar}
       * overflow. When `false`, this widget's child items are considered instead.
       *
       * When set to the string `'none'`, this widget is ignored by overflow processing. This option should be
       * used with caution as it prevents the overflow algorithm from moving such widgets into the overflow
       * popup which may result in not clearing enough space to avoid overflowing the toolbar.
       * @config {Boolean|String}
       * @default false
       * @category Layout
       * @internal
       */
      overflowable: {
        value: null,
        default: false,
        $config: null
      },
      /**
       * Specify `true` for a container used to show text markup. It will apply the CSS class `b-text-content`
       * which specifies a default max-width that makes long text more readable.
       *
       * This CSS class is automatically removed if the container adds/defines child Widgets.
       * @config {Boolean}
       * @default
       * @category Content
       */
      textContent: true,
      /**
       * {@link Core.data.Model Record} whose values will be used to populate fields in the container.
       *
       * Any descendant widgets of this Container with a `name` property (or a `ref` if no name is configured)
       * will have its value set to the value of that named property of the record.
       *
       * If no record is passed, the widget has its value set to `null`.
       *
       * To strictly match by the `name` property, configure {@link #config-strictRecordMapping} as `true`.
       *
       * @prp {Core.data.Model}
       * @category Record
       */
      record: null,
      /**
       * Specify `true` to match fields by their `name` property only when assigning a {@link #config-record},
       * without falling back to `ref`.
       *
       * @prp {Boolean}
       * @default false
       * @category Record
       */
      strictRecordMapping: null,
      /**
       * Update assigned {@link #config-record} automatically on field changes
       * @config {Boolean}
       * @category Record
       */
      autoUpdateRecord: null,
      /**
       * Update fields if the {@link #config-record} changes
       * @config {Boolean}
       * @internal
       */
      autoUpdateFields: null,
      /**
       * Specify `true` to make this container hide when it has no visible children (Either empty
       * or all children hidden).
       *
       * Container will show itself when there are visible children, ie: hidden children are
       * shown, or new visible children are added.
       * @config {Boolean}
       * @default
       * @category Layout
       */
      hideWhenEmpty: null,
      contentElMutationObserver: {
        $config: ["lazy", "nullify"],
        value: true
      },
      /**
       * Specify `true` to isolate record changes to this container and its ancestors. Prevents record updates
       * from propagating up from here and also prevents record updates from parent from propagating down to us.
       *
       * @config {Boolean}
       * @default false
       * @internal
       */
      isolateFields: false,
      /**
       * Can be set to `true` to make a focus of a focusable encapsulating element relay focus down into a
       * focusable child. This is normally `false` to allow mousedown to begin text selection in Popups.
       * @internal
       */
      focusDescendant: false,
      // Our own setValues/getValues system should not set/get HTML content
      defaultBindProperty: null,
      /**
       * A {@link #function-query} selector function which can identify the descendant widget to which
       * focus should be directed by default.
       *
       * By default, the first focusable descendant widget is chosen. This may direct focus to a different
       * widget:
       *
       * ```javascript
       *     new Popup({
       *         title        : 'Details',
       *         width        : '25em',
       *         centered     : true,
       *         modal        : true,
       *
       *         // Focus goes straight to OK button in the bottom toolbar on show
       *         defaultFocus : w => w.ref === 'okButton',
       *         items        : {
       *             nameField : {
       *                 type  : 'textfield',
       *                 label : 'Name'
       *             },
       *             ageField  : {
       *                 type  : 'numberfield',
       *                 label : 'Name'
       *             }
       *         },
       *         bbar     : {
       *             items : {
       *                 okButton : {
       *                     text    : 'OK',
       *                     handler : okFunction
       *                 },
       *                 cncelButton : {
       *                     text    : 'Cancel',
       *                     handler : cancelFunction
       *                 }
       *             }
       *         }
       *     }).show();
       * ```
       * @config {Function}
       * @param {Core.widget.Widget} widget Widget passed to method
       * @returns {Boolean} truthy value if widget is the default one
       */
      defaultFocus: null
    };
  }
  static get prototypeProperties() {
    return {
      // These classes have opinions about how fields should fill the space, so allow them to be replaced by the
      // less opinionated b-hbox/b-vbox classes when that is not desired. Using ":not(.b-toolbar-content)" in
      // the CSS does not scale now that FieldSet wants similar treatment... adding more ":not()"s is not only a
      // messy approach, it increases the selector specificity and causes interference with other selectors (e.g.
      // TimePicker's number field rules).
      flexRowCls: "b-flex-row",
      flexColCls: "b-flex-column",
      /**
       * @member {Boolean} initialItems
       * This property is `true` until the container's initial `items` config has been processed. This property
       * is set to `false` by the `updateItems` method.
       * @readonly
       * @internal
       */
      initialItems: true
    };
  }
  startConfigure(config) {
    const items2 = config.items || config.lazyItems;
    if (!(this.hasItems = Boolean(items2 && (isArray2(items2) ? items2 : Object.keys(items2)).length))) {
      this.initialItems = false;
    }
    super.startConfigure(config);
  }
  /**
   * Returns the first widget in this Container.
   * @property {Core.widget.Widget}
   * @readonly
   */
  get firstItem() {
    return this.getAt(0);
  }
  /**
   * Returns the last widget in this Container.
   * @property {Core.widget.Widget}
   * @readonly
   */
  get lastItem() {
    return this.getAt(-1);
  }
  /**
   * Returns the widget at the specified `index` in this Container.
   * @param {Number} index The index of the widget to return. Negative numbers index for the last item. For example,
   * `index = -1` returns the last matching item, -2 the 2nd to last matching item etc..
   * @returns {Core.widget.Widget} The requested widget.
   */
  getAt(index) {
    return this.ensureItems().at(index);
  }
  /**
   * Removes the passed child/children from this Container.
   * @param  {...Core.widget.Widget} toRemove The child or children to remove.
   * @returns {Core.widget.Widget|Core.widget.Widget[]} All the removed items. An array if multiple items
   * were removed, otherwise, just the item removed.
   */
  remove(...toRemove) {
    let returnArray = true;
    if (toRemove.length === 1) {
      if (isArray2(toRemove[0])) {
        toRemove = toRemove[0];
      } else {
        returnArray = false;
      }
    }
    const me = this, { _items } = me, result = [];
    for (let i = 0; i < toRemove.length; i++) {
      const childToRemove = toRemove[i];
      if (_items.includes(childToRemove)) {
        _items.remove(childToRemove);
        me.layout.removeChild(childToRemove);
        result.push(childToRemove);
        me.onChildRemove(childToRemove);
      }
    }
    return returnArray ? result : result[0];
  }
  /**
   * Removes all children from this Container.
   * @returns {Core.widget.Widget[]} All the removed items.
   */
  removeAll() {
    return this.remove(this.items);
  }
  /**
   * Appends the passed widget / widgets or config(s) describing widgets to this Container.
   *
   * If the widgets specify a `weight`, they are inserted at the correct index compared to the existing items weights.
   *
   * @param {ContainerItemConfig|ContainerItemConfig[]|Core.widget.Widget|Core.widget.Widget[]} toAdd The child or children instances (or config objects) to add.
   * @returns {Core.widget.Widget|Core.widget.Widget[]} All the added widgets. An array if multiple items
   * were added, otherwise just the item added.
   */
  add(...toAdd) {
    const me = this, items2 = me.ensureItems(), result = [];
    let returnArray = true, childToAdd, i, index;
    if (toAdd.length === 1) {
      if (isArray2(toAdd[0])) {
        toAdd = toAdd[0];
      } else {
        returnArray = false;
      }
    }
    for (i = 0; i < toAdd.length; i++) {
      childToAdd = toAdd[i];
      if (childToAdd.isWidget) {
        childToAdd.parent = me;
      } else {
        childToAdd = me.createWidget(childToAdd);
      }
      if ((childToAdd == null ? void 0 : childToAdd.weight) != null) {
        index = ArrayHelper.findInsertionIndex(childToAdd, items2.values, sortByWeight);
        result.push(me.insert(childToAdd, index));
      } else if (childToAdd) {
        if (!items2.includes(childToAdd)) {
          items2.add(childToAdd);
          me.onChildAdd(childToAdd);
          me.layout.appendChild(childToAdd);
          result.push(childToAdd);
        }
      }
    }
    return returnArray ? result : result[0];
  }
  ensureItems() {
    const me = this;
    me.getConfig("items");
    me.getConfig("lazyItems");
    if (!me._items) {
      me.items = [];
    }
    return me._items;
  }
  /**
   * Inserts the passed widget into this Container at the specified position.
   * @param  {Core.widget.Widget} toAdd The child to insert.
   * @param {Number|Core.widget.Widget} index The index to insert at or the existing child to insert before.
   * @returns {Core.widget.Widget} The added widget.
   */
  insert(toAdd, index) {
    const me = this, items2 = me.ensureItems();
    if (toAdd instanceof Widget) {
      toAdd.parent = me;
    } else {
      toAdd = me.createWidget(toAdd);
    }
    if (items2.includes(index)) {
      index = me.indexOfChild(index);
    }
    index = Math.min(index, items2.count);
    const newValues = items2.values;
    newValues.splice(index, 0, toAdd);
    items2.values = newValues;
    me.onChildAdd(toAdd);
    me.layout.insertChild(toAdd, index);
    return toAdd;
  }
  indexOfChild(child) {
    return this.items.indexOf(child);
  }
  changeLazyItems(lazyItems) {
    this.items = lazyItems;
    this.layout.renderChildren();
  }
  changeItems(items2, oldItems) {
    const me = this, newItems = [], result = new Bag();
    if (isArray2(items2)) {
      me.processItemsArray(items2, newItems);
    } else if (items2) {
      me.processItemsObject(items2, me.namedItems, newItems);
    }
    if (newItems.some(returnWeight)) {
      newItems.sort(sortByWeight);
    }
    result.add(newItems);
    if (oldItems) {
      oldItems.forEach((w) => {
        me.remove(w);
        if (!result.includes(w) && w._createdBy === me) {
          w.destroy();
        }
      });
    }
    return result;
  }
  afterConstruct() {
    const { rtl } = this, { classList } = this.contentElement;
    classList.toggle("b-rtl", rtl === true);
    classList.toggle("b-ltr", rtl === false);
  }
  updateRtl(rtl) {
    super.updateRtl(rtl);
    const { contentElement } = this;
    if (contentElement) {
      contentElement.classList.toggle("b-rtl", rtl === true);
      contentElement.classList.toggle("b-ltr", rtl === false);
    }
  }
  updateItems(items2, oldItems) {
    let index = 0;
    items2.forEach((item) => {
      this.onChildAdd(item);
      if (oldItems && !oldItems.temporary) {
        this.layout.insertChild(item, index);
      }
      ++index;
    });
    this.initialItems = false;
  }
  updateHideWhenEmpty() {
    this.syncChildCount(this.rendered);
  }
  /**
   * A property, which, when *read*, returns an array of the child items of this container in rendered order.
   *
   * This property may also be *set* to change the child items of the container. Just as in the
   * {@link #config-items initial items configuration}, the new value may either be an array of
   * Widgets/Widget configs or an object.
   *
   * If specified as an Object, the property names are used as the child Widget's
   * {@link Core.widget.Widget#config-ref} name, and the value is the child Widget/Widget config.
   *
   * When setting this, any items which are *only* in the outgoing child items which were created
   * by this container from raw config objects are destroyed.
   *
   * Usage patterns:
   *
   * ```javascript
   * myContainer.items = {
   *     name : {
   *         type  : 'textfield',
   *         label : 'User name'
   *     },
   *     age : {
   *         type  : 'numberfield',
   *         label : 'User age'
   *     }
   * };
   * ```
   *
   * or
   *
   * ```javascript
   * myContainer.items = [{
   *     ref   : 'name',
   *     type  : 'textfield',
   *     label : 'User name'
   * },
   *     ref   : 'age',
   *     type  : 'numberfield',
   *     label : 'User age'
   * }];
   * ```
   * @property {Core.widget.Widget[]}
   * @accepts {Array<ContainerItemConfig|MenuItemConfig|Core.widget.Widget>|Object<String,ContainerItemConfig|MenuItemConfig>}
   */
  get items() {
    const me = this;
    me.getConfig("lazyItems");
    if (!me._items) {
      if (me.initializingItems) {
        return [];
      }
      me._items = new Bag();
      me._items.temporary = true;
    }
    return me._items.values;
  }
  processItemsArray(items2, result) {
    const len = items2.length;
    let i, item;
    for (i = 0; i < len; i++) {
      item = items2[i];
      if (item instanceof Widget) {
        item.parent = this;
        item.element.classList.remove(...Widget.outerCls);
      } else {
        item = this.createWidget(item);
      }
      if (item) {
        if (item.ref || item.id) {
          this.addDescendant(item);
        }
        result.push(item);
      }
    }
  }
  processItemsObject(items2, namedItems, result) {
    let item, ref;
    for (ref in items2) {
      item = items2[ref];
      if (item) {
        if (namedItems && ref in namedItems) {
          item = typeof item === "object" ? ObjectHelper.merge(ObjectHelper.clone(namedItems[ref]), item) : namedItems[ref];
        }
        if (item) {
          if (item instanceof Widget) {
            item.parent = this;
          } else {
            if (item instanceof Object) {
              item.ref = ref;
            }
            item = this.createWidget(item);
          }
          if (item) {
            item.ref = ref;
            this.addDescendant(item);
            result.push(item);
          }
        }
      }
    }
  }
  onChildAdd(item) {
    if (item.innerItem && this.readOnly && !item.ignoreParentReadOnly) {
      item.readOnly = true;
    }
    this.onChildAddLayout(item);
    if (item.ref || item.id) {
      for (let current = this; current; current = current.parent) {
        current.addDescendant(item);
      }
    }
    this.syncChildCount(true);
  }
  onChildAddLayout(item) {
    if (item.innerItem) {
      this.layout.onChildAdd(item);
    }
  }
  onChildHide(hidden) {
    var _a2;
    super.onChildHide(hidden);
    if ((_a2 = this._items) == null ? void 0 : _a2.includes(hidden)) {
      this.syncChildCount(true);
    }
  }
  onChildShow(shown) {
    var _a2;
    super.onChildShow(shown);
    if ((_a2 = this._items) == null ? void 0 : _a2.includes(shown)) {
      this.syncChildCount(true);
    }
  }
  syncChildCount(enforceHideWhenEmpty) {
    if (!this.isConfiguring) {
      const me = this, {
        // This must be our direct child item payload, not all items owned by this Container.
        // It's used to sync the b-first-visible-child/b-last-visible-child class presence.
        items: items2,
        hasItems
      } = me, visibleItems = items2.filter(isNotHidden), { length: visibleLength } = visibleItems;
      me.visibleChildCount = visibleLength;
      if (me.hideWhenEmpty && enforceHideWhenEmpty) {
        const shouldHide = Boolean(!visibleLength);
        if (Boolean(me._hidden) !== shouldHide) {
          me.hidden = shouldHide;
        }
      }
      items2.forEach((childItem) => childItem.element.classList.remove("b-last-visible-child", "b-first-visible-child"));
      if (visibleLength) {
        visibleItems[0].element.classList.add("b-first-visible-child");
        visibleItems[visibleLength - 1].element.classList.add("b-last-visible-child");
      }
      me.hasItems = Boolean(me.childItems.length);
      me.contentElement.classList[visibleLength ? "remove" : "add"]("b-no-visible-children");
      if (!me.isComposable) {
        me.updateTextContent(me._textContent);
      } else if (hasItems !== me.hasItems) {
        me.recompose();
      }
    }
  }
  syncFlexDirection() {
    const me = this, { contentElement, flexColCls, flexRowCls } = me, classList = new DomClassList(contentElement.className), styles = DomHelper.getStyleValue(contentElement, stylesToCheck);
    classList[flexRowCls] = classList[flexColCls] = 0;
    if (styles.display === "flex") {
      classList[styles["flex-direction"] === "row" ? flexRowCls : flexColCls] = 1;
    }
    DomHelper.syncClassList(contentElement, classList);
  }
  addDescendant(item) {
    const ref = item.ref || item.id, widgetMap = this._widgetMap || (this._widgetMap = {});
    if (!widgetMap[ref]) {
      widgetMap[ref] = item;
    }
  }
  onChildRemove(item) {
    const me = this, ref = item.ref || item.id;
    if (ref) {
      for (let current = me; current; current = current.parent) {
        if (current.widgetMap[ref] === item) {
          delete current.widgetMap[ref];
        }
      }
    }
    me.layout.onChildRemove(item);
    me.syncChildCount(true);
  }
  /**
   * An object which contains a map of descendant widgets keyed by their {@link Core.widget.Widget#config-ref}.
   * All descendant widgets will be available in the `widgetMap`.
   * @property {Object<String,Core.widget.Widget>}
   * @readonly
   * @category Widget hierarchy
   */
  get widgetMap() {
    if (!this._widgetMap) {
      this._widgetMap = {};
    }
    if (!this.initializingItems) {
      this.getConfig("items");
    }
    return this._widgetMap;
  }
  //region Record & values
  changeRecord(record) {
    this._record = record == null ? emptyObject6 : null;
    return record;
  }
  updateRecord(record) {
    var _a2;
    const me = this;
    (_a2 = me.recordUpdateDetacher) == null ? void 0 : _a2.call(me);
    me.trigger("beforeSetRecord", { record });
    me.setValues(record, {
      onlyName: me.strictRecordMapping,
      highlight: Boolean(me.$highlight)
    });
    if (me.autoUpdateFields && (record == null ? void 0 : record.firstStore)) {
      me.recordUpdateDetacher = record.firstStore.ion({
        update: me.onRecordUpdated,
        thisObj: me
      });
    }
  }
  setRecord(record, highlightChanges) {
    this.$highlight = highlightChanges;
    this.record = record;
    this.$highlight = false;
  }
  onRecordUpdated({ record }) {
    if (record === this.record) {
      this.setValues(this.record, true, true);
    }
  }
  /**
   * A function called by descendant widgets after they trigger their 'change' event, in reaction to field changes.
   * By default, implements the functionality for the `autoUpdateRecord` config.
   *
   * @param {Object} params Normally the event params used when triggering the 'change' event
   * @internal
   */
  onFieldChange({ source, userAction }) {
    if (this.autoUpdateRecord && userAction) {
      const { record, strictRecordMapping } = this, { name, ref, isValid = true, value } = source, key = strictRecordMapping ? name : name || ref;
      if (record && key && isValid) {
        if (record.isModel) {
          record.setValue(key, value);
        } else {
          record[key] = value;
        }
      }
    }
  }
  getValues(filterFn) {
    const values = {};
    this.eachWidget((widget, control) => {
      if (widget.isolateFields) {
        control.down = false;
      } else if ("name" in widget && (!filterFn || filterFn(widget))) {
        values[widget.name] = widget.value;
      }
    }, true);
    return values;
  }
  /**
   * Retrieves or sets all values from/to contained widgets.
   *
   * The property set or read from a contained widget is its {@link Core.widget.Widget#config-defaultBindProperty}.
   *
   * This defaults to the `value` for fields.
   *
   * You may add child widgets which may accept and yield a value to/from another property, such as a `Button` having
   * its {@link Core.widget.Button#config-href} set.
   *
   * Accepts and returns a map, using {@link Core.widget.Field#config-name}, {@link Core.widget.Widget#config-ref} or
   * {@link Core.widget.Widget#config-id} (in that order) as keys.
   *
   * ```javascript
   * const container = new Container({
   *     appendTo : document.body,
   *     items    : {
   *         firstName : {
   *             type : 'textfield
   *         },
   *         surName : {
   *             type : 'textfield
   *         }
   *         saveButton : {
   *             type                : 'button',
   *             text                : 'Save',
   *             defaultBindProperty : 'href'
   *             href                : '#'
   *         }
   *     }
   * });
   *
   * container.values = {
   *     firstName  : 'Clark',
   *     surname    : 'Kent',
   *     saveButton : '#save-route'
   * };
   * ```
   *
   * @property {Object<String,Object>}
   */
  get values() {
    const values = {};
    this.gatherValue(values);
    return values;
  }
  set values(values) {
    this.assignValue(values);
  }
  /**
   * Returns `true` if currently setting values. Allow fields to change highlighting to distinguishing between
   * initially setting values and later on changing values.
   * @property {Boolean}
   */
  get isSettingValues() {
    return Boolean(this.assigningValues);
  }
  get assigningValues() {
    var _a2;
    return this._assigningValues || ((_a2 = this.parent) == null ? void 0 : _a2.assigningValues);
  }
  set assigningValues(v) {
    this._assigningValues = v;
  }
  assignValue(values, options) {
    super.assignValue(values, options);
    if (!this.isolateFields) {
      this.setValues(values, options);
    }
  }
  gatherValue(values) {
    super.gatherValue(values);
    if (!this.isolateFields) {
      this.gatherValues(values);
    }
  }
  setValues(values, options = this.assignValueDefaults) {
    this.assigningValues = options;
    this.eachWidget((widget) => widget.assignValue(values, options), false);
    this.assigningValues = false;
  }
  //endregion
  get hasNoChildren() {
    const me = this, { items: items2, lazyItems } = me.initialConfig, itemsArray = items2 && (isArray2(items2) ? items2 : ObjectHelper.values(items2)), lazyItemsArray = lazyItems && (isArray2(lazyItems) ? lazyItems : ObjectHelper.values(lazyItems)), whichItems = me.isConfiguring ? lazyItemsArray || itemsArray : me.items;
    return !(whichItems == null ? void 0 : whichItems.filter(isNotHidden).length);
  }
  afterRecompose() {
    super.afterRecompose();
    this.realign();
  }
  updateTextContent(textContent) {
    const me = this;
    if (!me.isComposable) {
      const needsClass = Boolean(textContent && me.hasNoChildren), { classList } = me.contentElement, changed = needsClass !== classList.contains("b-text-content");
      if (changed) {
        classList[needsClass ? "add" : "remove"]("b-text-content");
        if (me.rendered) {
          me.realign();
        }
      }
    }
  }
  updateLayoutStyle(layoutStyle) {
    DomHelper.applyStyle(this.contentElement, layoutStyle);
  }
  updateElement(element) {
    super.updateElement(...arguments);
    if (element) {
      const { classList } = this.contentElement, { containerCls } = this.layout;
      classList.add("b-content-element");
      if (containerCls) {
        classList.add(containerCls);
      }
    }
  }
  onInternalPaint() {
    var _a2;
    (_a2 = super.onInternalPaint) == null ? void 0 : _a2.call(this, ...arguments);
    this.getConfig("contentElMutationObserver");
  }
  changeContentElMutationObserver(contentElMutationObserver, oldContentElMutationObserver) {
    if (oldContentElMutationObserver) {
      oldContentElMutationObserver.takeRecords();
      oldContentElMutationObserver.disconnect();
    }
    if (contentElMutationObserver) {
      const me = this, {
        element,
        contentElement
      } = me;
      contentElMutationObserver = new MutationObserver((mutations) => me.onContentElMutation(mutations));
      contentElMutationObserver.observe(contentElement, { attributes: true });
      if (contentElement !== element) {
        contentElMutationObserver.observe(element, { attributes: true });
      }
      me.syncFlexDirection();
    }
    return contentElMutationObserver;
  }
  onContentElMutation(mutations) {
    if (boxLayouts[this.layout.type] && this.isVisible && mutations.some((m) => this.contentElement.contains(m.target))) {
      this.syncFlexDirection();
    }
  }
  changeLayout(config, existingLayout) {
    return Layout.reconfigure(existingLayout, config, {
      owner: this,
      defaults: {
        owner: this
      }
    });
  }
  // Items to iterate over
  get childItems() {
    return this.items;
  }
  /**
   * Returns a directly contained widget by id
   * @param {String} id The widget id
   * @returns {Core.widget.Widget}
   */
  getWidgetById(id) {
    return this.widgetMap[id];
  }
  /**
   * This function is called prior to creating widgets, override it in subclasses to allow containers to modify the
   * configuration of each widget. When adding a widget to a container hierarchy each parent containers
   * `processWidgetConfig` will be called. Returning false from the function prevents the widget from being added at
   * all.
   */
  processWidgetConfig(widget) {
  }
  /**
   * This method combines container {@link #config-defaults}
   * @param {String|ContainerItemConfig} widgetConfig
   * @param {String|Function} [type] The type of widget described by `widgetConfig`.
   * @returns {ContainerItemConfig}
   * @internal
   */
  setupWidgetConfig(widgetConfig, type) {
    const me = this;
    if (typeof widgetConfig === "string") {
      widgetConfig = {
        html: widgetConfig
      };
    } else if (widgetConfig.nodeType === Element.ELEMENT_NODE) {
      widgetConfig = {
        element: widgetConfig,
        id: widgetConfig.id
      };
    }
    if (typeof type === "string" || !type && (type = widgetConfig.type)) {
      if (type === "checkbox" && BrowserHelper.isMobile && Widget.resolveType("slidetoggle", true)) {
        type = widgetConfig.type = "slidetoggle";
      }
      type = Widget.resolveType(type, true);
    }
    widgetConfig = (type || Widget).mergeConfigs(me.defaults, widgetConfig, { parent: me });
    for (let ancestor = widgetConfig.parent; ancestor; ancestor = ancestor.parent) {
      if (ancestor.processWidgetConfig(widgetConfig) === false) {
        return null;
      }
    }
    if (me.trigger("beforeWidgetCreate", { widgetConfig }) === false) {
      return null;
    }
    return widgetConfig;
  }
  /**
   * This function converts a Widget config object into a Widget.
   * @param {ContainerItemConfig} widget A Widget config object.
   * @internal
   */
  createWidget(widget) {
    const result = Widget.create(this.setupWidgetConfig(widget), this.defaultType);
    result && (result._createdBy = this);
    return result;
  }
  // Reapply defaults, not used during config
  updateDefaults(defaults, oldDefaults) {
    if (!this.isConfiguring && defaults) {
      const entries = Object.entries(defaults);
      this.eachWidget((widget) => {
        entries.forEach(([prop, value]) => {
          if (!oldDefaults || widget[prop] === oldDefaults[prop]) {
            widget[prop] = value;
          }
        });
      }, false);
    }
  }
  render() {
    this.getConfig("lazyItems");
    this.layout.renderChildren();
    this.syncChildCount();
    super.render(...arguments);
  }
  get focusElement() {
    const firstFocusable = this.query(this.defaultFocus || ((w) => {
      var _a2;
      return w.isFocusable && w.ref !== "close" && !((_a2 = w.ref) == null ? void 0 : _a2.endsWith("collapse"));
    }));
    if (firstFocusable) {
      return firstFocusable.focusElement;
    }
    return super.focusElement;
  }
  doDestroy() {
    var _a2;
    (_a2 = this._items) == null ? void 0 : _a2.forEach((widget) => {
      var _a3;
      return (_a3 = widget.destroy) == null ? void 0 : _a3.call(widget);
    });
    this.layout.destroy();
    super.doDestroy();
  }
  /**
   * Returns `true` if all contained fields are valid, otherwise `false`
   * @property {Boolean}
   */
  get isValid() {
    let valid = true;
    this.eachWidget((widget) => {
      if (widget.isVisible && "isValid" in widget && !widget.isValid) {
        valid = false;
      }
    }, true);
    return valid;
  }
};
__publicField(Container, "$name", "Container");
__publicField(Container, "type", "container");
Container.initClass();
Container._$name = "Container";

// ../Core/lib/Core/util/Animator.js
var { assign } = ObjectHelper;
var now = () => performance.now();
var nostart = { start: false };
var unitRe = /^[.\d]+([^\d].*)?$/;
var getTransitions = (element) => {
  const $bryntum = element.$bryntum || (element.$bryntum = {});
  return $bryntum.transitions || ($bryntum.transitions = /* @__PURE__ */ Object.create(null));
};
var milliseconds = (duration, unit) => {
  var _a2;
  if (typeof duration === "string") {
    unit = (_a2 = unitRe.exec(duration)) == null ? void 0 : _a2[1];
    duration = parseFloat(duration);
  }
  return duration && duration * (unit === "s" || !unit && duration < 10 ? 1e3 : 1);
};
var syncTransitions = (element) => {
  const all = ObjectHelper.values(getTransitions(element)).filter((a) => a.completed == null).map((a) => a.toString());
  element.style.transition = all.join(", ");
};
var Anim = (Target) => class Anim extends Target {
  static get prototypeProperties() {
    return {
      _delay: null,
      _duration: null,
      _retain: null,
      _timing: null,
      _unit: null,
      owner: null,
      reverting: null
    };
  }
  constructor(...args) {
    super(...args);
    this.id = ++idSeed;
  }
  start() {
    this.startTime = now();
  }
  get delay() {
    var _a2, _b, _c;
    return milliseconds((_c = (_b = this._delay) != null ? _b : (_a2 = this.owner) == null ? void 0 : _a2.delay) != null ? _c : 0, this.unit);
  }
  set delay(v) {
    this._delay = v;
  }
  get duration() {
    var _a2;
    const { owner, unit } = this;
    return milliseconds((_a2 = this._duration) != null ? _a2 : owner ? owner.duration : Animator.defaultDuration, unit);
  }
  set duration(v) {
    this._duration = v;
  }
  get elapsed() {
    return now() - this.startTime;
  }
  get remaining() {
    return this.duration - this.elapsed;
  }
  get retain() {
    var _a2, _b;
    return (_b = this._retain) != null ? _b : (_a2 = this.owner) == null ? void 0 : _a2.retain;
  }
  set retain(v) {
    this._retain = v;
  }
  get timing() {
    var _a2, _b;
    return (_b = this._timing) != null ? _b : (_a2 = this.owner) == null ? void 0 : _a2.timing;
  }
  set timing(v) {
    this._timing = v;
  }
  get unit() {
    var _a2, _b;
    return (_b = this._unit) != null ? _b : (_a2 = this.owner) == null ? void 0 : _a2.unit;
  }
  set unit(v) {
    this._unit = v;
  }
};
var idSeed = 0;
var AnimatorTransition = class _AnimatorTransition extends Base.mixin(Anim) {
  static get $name() {
    return "AnimatorTransition";
  }
  static get prototypeProperties() {
    return {
      element: null,
      property: null,
      from: null,
      to: null,
      completed: null,
      promissory: null,
      reverting: null
    };
  }
  afterConstruct() {
    super.afterConstruct();
    const me = this, { element, transitions } = me;
    let { property } = me;
    [property, me.to] = DomHelper.unitize(property, me.to);
    me.from = DomHelper.unitize(property, me.from)[1];
    me.promissory = new Promissory();
    me.property = property;
    const was = transitions[property];
    transitions[property] = me;
    let { from } = me;
    if (was) {
      me.from = was.to;
      from = null;
      was.destroy();
    }
    if (from === null) {
      from = me.getCurrentStyleValue();
      if (!was) {
        me.from = from;
      }
    }
    element.style[property] = from;
    me.getCurrentStyleValue();
  }
  doDestroy() {
    const me = this;
    me.finish(false);
    if (me.completed && !me.retain) {
      me.clearStyle();
    }
    super.doDestroy();
  }
  get promise() {
    var _a2;
    return (_a2 = this.promissory) == null ? void 0 : _a2.promise;
  }
  get transitions() {
    return getTransitions(this.element);
  }
  clearStyle() {
    this.setStyle("");
  }
  finish(complete) {
    const me = this, { transitions, promissory, property } = me;
    if (promissory) {
      me.completed = complete;
      me.promissory = null;
      promissory.resolve(complete);
      if (transitions[property] === me) {
        delete transitions[property];
        if (!complete) {
          syncTransitions(me.element);
          me.clearStyle();
        }
      } else {
        me.completed = false;
      }
    }
  }
  getCurrentStyleValue() {
    return DomHelper.getStyleValue(this.element, this.property);
  }
  revert() {
    const { duration, elapsed, element, from, property, _retain: retain, _timing: timing } = this;
    return new _AnimatorTransition({
      element,
      property,
      retain,
      timing,
      duration: Math.round(Math.min(duration, elapsed)),
      reverting: this,
      to: from,
      unit: "ms"
    });
  }
  setStyle(value) {
    this.element.style[this.property] = value;
  }
  start() {
    const me = this, { delay: delay2, duration, element, property } = me;
    EventHelper.onTransitionEnd({
      element,
      property,
      duration: delay2 + duration + 20,
      thisObj: me.owner,
      handler: () => {
        var _a2;
        return (_a2 = me.finish) == null ? void 0 : _a2.call(me, true);
      }
      // finish() is gone if destroyed
    });
    super.start();
    me.setStyle(me.to);
  }
  toString() {
    const { delay: delay2, duration, property, timing } = this;
    return `${property} ${duration}ms ${timing || "ease-in-out"}${delay2 ? ` ${delay2}ms` : ""}`;
  }
};
AnimatorTransition.initClass();
var Animator = class _Animator extends Base.mixin(Anim) {
  static get $name() {
    return "Animator";
  }
  static get prototypeProperties() {
    return {
      /**
       * The optional delay before starting the animation. Numbers less than 10 are assumed to be seconds
       * (instead of milliseconds) unless the `unit` property is specified.
       * @config {Number|String} delay
       */
      /**
       * The duration of the animation. Numbers less than 10 are assumed to be seconds (instead of milliseconds)
       * unless the `unit` property is specified.
       * @config {Number|String} duration
       * @default
       */
      /**
       * The element to animate.
       * @config {HTMLElement} element
       */
      element: null,
      /**
       * A callback function called when the animation completes. This is called after restoring styles to the
       * original values (based on {@link #config-retain}). When this function is provided, `retain` defaults to
       * `false`. By implementing this function, a CSS class can be applied to the {@link #config-element} to
       * give the proper style, while the inline styles are removed (e.g., a hide animation based on opacity).
       *
       * For example:
       * ```javascript
       *  const anim = Animator.run({
       *      element,
       *      duration : 500,
       *      opacity  : 0,
       *
       *      finalize() {
       *          element.classList.add('hidden');
       *      }
       *  });
       *
       *  await anim.done();
       * ```
       *
       * @config {Function} finalize
       * @returns {void}
       */
      finalize: null,
      /**
       * A callback function called when the animation completes. This is called prior to restoring styles to the
       * original values (based on {@link #config-retain}).
       *
       * @config {Function} prefinalize
       * @returns {void}
       * @internal
       */
      prefinalize: null,
      /**
       * Set to `true` to retain the style property values after the animation. This defaults to `true` if a
       * {@link #config-finalize} function is not specified, and `false` otherwise. When a `finalize` function
       * is provided, it is typically to apply a CSS class to achieve the desired styling so that inline styles
       * can be removed.
       * @config {Boolean} retain
       */
      /**
       * The [timing function](https://developer.mozilla.org/en-US/docs/Web/CSS/transition-timing-function) for
       * the animation.
       * @config {String} timing
       * @default 'ease-in-out'
       */
      /**
       * The duration/delay unit (either `'s'` or `'ms'`).
       * @config {'s'|'ms'} unit
       */
      /**
       * This readonly property is set to `true` when the animation completes or `false` if the animation is
       * aborted (by calling the `destroy()` method).
       * @member {Boolean} completed
       * @readonly
       */
      completed: null,
      /**
       * An array containing a mixture of `Animator` and/or `AnimatorTransition` objects, depending on what was
       * specified at construction time.
       * @member {Core.util.Animator[]|AnimatorTransition[]} items
       * @readonly
       */
      /**
       * When passed at construction time, `items` can be an array of other `Animator` config objects. This can be
       * used to animate multiple elements and wait for this instance to be {@link #function-done done}.
       * @config {Core.util.Animator[]} items
       */
      items: null
    };
  }
  static register(name, fn2) {
    if (ObjectHelper.isObject(name)) {
      ObjectHelper.entries(name).forEach((entry) => _Animator.register(...entry));
      return;
    }
    _Animator.fx[name] = fn2;
    _Animator[name] = (options) => {
      if (DomHelper.isElement(options)) {
        options = {
          element: options,
          [name]: {}
        };
      } else {
        options = {
          element: options.element,
          [name]: options
        };
        delete options[name].element;
      }
      return _Animator.run(options);
    };
  }
  /**
   * A short-hand way to create an `Animator` instance and call its {@link #function-start} method.
   *
   * ```javascript
   *  const anim = Animator.run({
   *      element,
   *      duration : 500,
   *
   *      // style transitions:
   *      opacity : 0
   *  });
   *
   *  await anim.done();
   * ```
   * @param {Core.util.Animator|AnimatorConfig} options A config object for an `Animator` instance.
   * @returns {Core.util.Animator}
   */
  static run(options) {
    return new _Animator(options).start();
  }
  constructor(options) {
    var _a2;
    super(null);
    const me = this, items2 = [], properties = {};
    let anim, fx, key, t;
    if (Array.isArray(options)) {
      me.items = options;
    } else {
      for (key in options) {
        (_Animator.specialPropsRe.test(key) ? me : properties)[key] = options[key];
      }
    }
    ObjectHelper.keys(properties).forEach((property) => {
      t = properties[property];
      if (t != null && t !== false && t === t) {
        if (!(fx = _Animator.fx[property])) {
          t = assign(me.defaults, typeof t === "object" ? t : { to: t });
          t.owner = me;
          t.property = property;
          anim = new AnimatorTransition(t);
        } else {
          t = assign(me.defaults, fx(t, me, property));
          t.owner = me;
          anim = new _Animator(t);
        }
        items2.push(anim);
      }
    });
    (_a2 = me.items) == null ? void 0 : _a2.forEach((item) => {
      if (ObjectHelper.isInstantiated(item)) {
        item.owner = me;
      } else {
        item = assign(me.defaults, item);
        item.owner = me;
        item = new _Animator(item);
      }
      items2.push(item);
    });
    me.items = items2;
    me.promise = (items2.length === 1 ? items2[0].promise : Promise.all(items2.map((it) => it.promise))).then((res) => {
      var _a3;
      (_a3 = me.finish) == null ? void 0 : _a3.call(me, res);
      return me.completed || false;
    });
  }
  doDestroy() {
    this.items.forEach((a) => a.destroy());
    super.doDestroy();
  }
  get defaults() {
    return {
      element: this.element
    };
  }
  get retain() {
    const { _retain, finalize, owner } = this;
    return _retain != null ? _retain : finalize ? false : owner ? owner.retain : true;
  }
  set retain(v) {
    super.retain = v;
  }
  /**
   * Returns a `Promise` that resolves to a `Boolean` when this animation completes. The resolved value is that of
   * this instance's {@link #property-completed} property.
   * @async
   */
  done() {
    return this.promise;
  }
  finish(complete) {
    var _a2, _b;
    const me = this, { items: items2 } = me;
    syncTransitions(me.element);
    me.completed = typeof complete === "boolean" ? complete : !complete.some((a) => !a);
    (_a2 = me.prefinalize) == null ? void 0 : _a2.call(me, me.completed, me);
    while (items2.length) {
      items2.pop().destroy();
    }
    (_b = me.finalize) == null ? void 0 : _b.call(me, me.completed, me);
  }
  revert(options) {
    var _a2;
    const me = this, { reverting } = me, start = !options || ((_a2 = options.start) != null ? _a2 : true);
    let anim = me.defaults;
    if (reverting) {
      if (reverting.finalize) {
        anim.finalize = reverting.finalize;
      }
      if (reverting.prefinalize) {
        anim.prefinalize = reverting.prefinalize;
      }
      anim.retain = reverting._retain;
    }
    anim = assign(anim, options, {
      items: me.items.map((it) => it.revert(nostart)),
      reverting: me
    });
    anim = new _Animator(anim);
    start && anim.start();
    return anim;
  }
  /**
   * Starts this animation and returns a reference to itself. This method is called automatically by the
   * {@link #function-run-static} method.
   * @returns {Core.util.Animator}
   */
  start() {
    const { element, items: items2 } = this;
    super.start();
    if (items2.length) {
      syncTransitions(element);
      items2.forEach((a) => a.start());
    }
    return this;
  }
};
Animator.initClass().Transition = AnimatorTransition;
Animator.specialPropsRe = new RegExp(`^(?:${Object.keys(Animator.prototypeProperties).concat(
  Object.keys(Animator.superclass.prototypeProperties)
).map((s) => s[0] === "_" ? s.substr(1) : s).join("|")})$`);
Animator.defaultDuration = 200;
Animator.fx = {};
Animator.register({
  /**
   * A compound animation to achieve `transform: scale()` and `opacity: 0`. The `scale` defaults to 8 but can be set
   * in the `anim` config object.
   *
   * For example
   * ```javascript
   *  const puff = Animator.puff(element);
   *
   *  const puff = Animator.puff({
   *      element,
   *      scale : 12
   *  });
   * ```
   *
   * This compound animation can also be specified in an `Animator` config object along with other style transitions:
   * ```javascript
   *  const anim = Animator.run({
   *      element,
   *      marginLeft : -200,
   *      puff       : true   // true for default scale, a number, or config object
   *  });
   * ```
   * @param {Element|AnimatorConfig|Core.util.Animator} anim The element to animate or the config object containing at least
   * the `element` property. This config object can contain an optional `scale` property to adjust the animation's
   * `transform: scale()` value.
   * @param {Number} [anim.scale=8] The scale value for the `transform:scale()` transition.
   * @returns {Core.util.Animator}
   * @static
   */
  puff(anim) {
    if (anim === true) {
      anim = {};
    } else if (typeof anim !== "object") {
      anim = {
        transform: `scale(${anim})`
      };
    } else if (anim.scale) {
      anim = ObjectHelper.clone(anim);
      anim.transform = `scale(${anim.scale})`;
      delete anim.scale;
    }
    return assign({
      opacity: 0,
      transform: "scale(8)"
    }, anim);
  }
});
Animator._$name = "Animator";

// ../Core/lib/Core/util/ClickRepeater.js
var ClickRepeater = class extends Base.mixin(Delayable_default) {
  static get configurable() {
    return {
      /**
       * The element on which to fire autorepeating `click` events when the mouse is held down.
       * @config {HTMLElement}
       */
      element: null,
      /**
       * A query selector which specifies subtargets of this ClickRepeater's {@link #config-element}
       * which act as the click auto repeat event targets.
       * @config {String}
       * @default
       */
      delegate: null,
      /**
       * How long in milliSeconds to pause before starting the click repeats.
       * @config {Number}
       * @default
       */
      delay: 500,
      /**
       * Clicks per second to start firing after the initial {@link #config-delay}
       * @config {Number}
       * @default
       */
      startRate: 2,
      /**
       * Clicks per second to fire at top speed, after accelerating over the {@link #config-accelerateDuration}
       * @config {Number}
       * @default
       */
      endRate: 20,
      /**
       * How long in milliseconds to accelerate from the
       * {@link #config-startRate} to the {@link #config-startRate}.
       * @config {Number}
       * @default
       */
      accelerateDuration: 4e3,
      pressedCls: "b-pressed"
    };
  }
  doDestroy() {
    var _a2;
    (_a2 = this.mousedownRemover) == null ? void 0 : _a2.call(this);
    this.cancel();
    super.doDestroy();
  }
  cancel() {
    var _a2, _b, _c;
    const me = this;
    (_a2 = me.activeElement) == null ? void 0 : _a2.classList.remove(me.pressedCls);
    me.activeElement = null;
    (_b = me.acceleration) == null ? void 0 : _b.cancel();
    me.activeListenerRemover = (_c = me.activeListenerRemover) == null ? void 0 : _c.call(me);
    me.clearTimeout(me.autoRepeatTimer);
    me.clearTimeout(me.repeatTimer);
  }
  updateElement(element) {
    var _a2;
    (_a2 = this.mousedownRemover) == null ? void 0 : _a2.call(this);
    this.mousedownRemover = EventHelper.on({
      element,
      mousedown: "onMouseDown",
      thisObj: this
    });
  }
  onMouseDown(e) {
    const me = this, target = me.delegate ? e.target.closest(me.delegate) : me.element;
    me.cancel();
    if (target) {
      me.activeElement = target;
      me.triggerEvent = e;
      target.classList.add(me.pressedCls);
      me.activeListenerRemover = EventHelper.on({
        mouseup: {
          element: document,
          capture: true,
          handler: "onMouseUp"
        },
        mousemove: {
          element: target,
          handler: "onTargetMouseMove"
        },
        mouseleave: {
          element: target,
          handler: "onTargetMouseLeave"
        },
        mouseenter: {
          element: target,
          handler: "onTargetMouseEnter"
        },
        thisObj: me
      });
      me.autoRepeatTimer = me.setTimeout("startAutoRepeat", me.delay);
    }
  }
  onMouseUp() {
    this.cancel();
  }
  onTargetMouseLeave() {
    this.activeElement.classList.remove(this.pressedCls);
    this.clearTimeout(this.repeatTimer);
  }
  onTargetMouseEnter(e) {
    const me = this;
    if (!e.buttons) {
      me.cancel();
    } else {
      me.activeElement.classList.add(me.pressedCls);
      me.triggerEvent = e;
      me.fireClick();
    }
  }
  onTargetMouseMove(e) {
    this.triggerEvent = e;
  }
  startAutoRepeat() {
    const me = this;
    me.interval = me.startInterval = 1e3 / me.startRate;
    me.accelerationDelta = me.startInterval - 1e3 / me.endRate;
    me.fireClick();
    me.acceleration = FunctionHelper.animate(me.accelerateDuration, me.nextTick, me, "easeOutQuad");
  }
  nextTick(progress) {
    this.interval = this.startInterval - this.accelerationDelta * progress;
  }
  fireClick() {
    const me = this, clickEvent = new MouseEvent("click", me.triggerEvent);
    me.triggerEvent.target.dispatchEvent(clickEvent);
    me.repeatTimer = me.setTimeout(me.fireClick, me.interval);
  }
};
ClickRepeater._$name = "ClickRepeater";

// ../Core/lib/Core/widget/mixin/Rotatable.js
var autoRotateRe = /^(?:undefined|null|LEFT|RIGHT)$/;
var inverted = {
  TOP: "BOTTOM",
  RIGHT: "LEFT",
  BOTTOM: "TOP",
  LEFT: "RIGHT"
};
var canonicalDock = (dock) => {
  const DOCK = dock == null ? void 0 : dock.toUpperCase();
  return [DOCK, DOCK === "LEFT" || DOCK === "RIGHT"];
};
var Rotatable_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    static get configurable() {
      return {
        /**
         * Set to `'left'` to rotate the button content 90 degrees counter-clockwise or `'right'` for clockwise.
         * @member {'left'|'right'} rotate
         */
        /**
         * Specify `'left'` to rotate the button content 90 degrees counter-clockwise or `'right'` for clockwise.
         * @config {'left'|'right'}
         */
        rotate: null,
        invertRotate: null
      };
    }
    compose() {
      const { rotate } = this;
      return {
        class: {
          [`b-rotate-${(rotate || "").toLowerCase()}`]: rotate,
          "b-rotate-vertical": rotate
        }
      };
    }
    syncRotationToDock(dock) {
      if (autoRotateRe.test(String(this.rotate))) {
        const [DOCK, vertical] = canonicalDock(dock);
        this.rotate = vertical ? this.invertRotate ? inverted[DOCK] : DOCK : null;
      }
    }
    get widgetClass() {
      return null;
    }
  }, __publicField(_a2, "$name", "Rotatable"), _a2;
};

// ../Core/lib/Core/widget/Tool.js
var Tool = class extends Widget.mixin(Rotatable_default) {
  compose() {
    const { align, href } = this;
    return {
      tag: href != null ? "a" : "button",
      class: {
        [`b-align-${align || "end"}`]: 1,
        "b-icon": 1
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: "onInternalClick"
      }
    };
  }
  get focusElement() {
    return this.element;
  }
  get panel() {
    var _a2, _b;
    if (((_a2 = this.parent) == null ? void 0 : _a2.isPanel) && ((_b = this.element) == null ? void 0 : _b.parentNode.matches(".b-panel-header"))) {
      return this.parent;
    }
  }
  changeAlign(align) {
    return align;
  }
  onInternalClick(domEvent) {
    const me = this, { handler, panel } = me, bryntumEvent = { domEvent, tool: me };
    if (me.disabled) {
      return;
    }
    me.trigger("click", bryntumEvent);
    if (!me.isDestroyed) {
      me.trigger("action", bryntumEvent);
      if (!me.isDestroyed && (panel == null ? void 0 : panel.trigger("toolClick", bryntumEvent)) !== false) {
        handler && me.callback(handler, panel, [domEvent, panel, me]);
      }
    }
  }
  onInternalKeyDown(keyEvent) {
    const keyName = keyEvent.key.trim() || keyEvent.code;
    if (keyName === "Enter") {
      keyEvent.cancelBubble = true;
      keyEvent.stopPropagation();
    }
  }
  updateDisabled(disabled, was) {
    var _a2;
    super.updateDisabled(disabled, was);
    disabled && ((_a2 = this.repeat) == null ? void 0 : _a2.cancel());
  }
  changeRepeat(repeat, oldRepeat) {
    oldRepeat == null ? void 0 : oldRepeat.destroy();
    return repeat && ClickRepeater.new({
      element: this.element
    }, repeat);
  }
};
__publicField(Tool, "$name", "Tool");
__publicField(Tool, "type", "tool");
__publicField(Tool, "configurable", {
  /**
   * Specify `'start'` to place the tool before the owner's central element (e.g., the `title` of the panel).
   * @config {'start'|'end'}
   * @default 'end'
   * @category Float & align
   */
  align: {
    value: null,
    $config: {
      merge: "replace"
    }
  },
  /**
   * If provided, turns the tool into a link
   * @config {String}
   */
  href: null,
  /**
   * The function to call when this tool is clicked. May be a function or function name
   * prepended by `"up."` that is resolvable in an ancestor component (such as an owning
   * Grid, Scheduler, Calendar, Gantt or TaskBoard)
   *
   * @config {Function|String} handler
   * @param {Event} handler.event The DOM event which activated the tool
   * @param {Core.widget.Panel} handler.panel The owning Panel of the tool
   * @param {Core.widget.Tool} handler.tool The clicked Tool
   * @returns {void}
   */
  /**
   * A {@link Core.util.ClickRepeater } config object to specify how click-and-hold gestures repeat the click
   * action.
   * @config {ClickRepeaterConfig}
   */
  repeat: null,
  defaultBindProperty: null
});
Tool.initClass();
Tool._$name = "Tool";

// ../Core/lib/Core/widget/panel/CollapseTool.js
var rightRe = /right/i;
var autoAlign = (tool) => (tool.collapsed || tool.collapsing) && // special case to align the expand tool with the collapse tool
tool.owner.expandedHeaderDock === "top" && tool.owner.collapsible.direction.match(rightRe) ? "start" : "end";
var CollapseTool = class extends Tool {
  static get configurable() {
    return {
      /**
       * Set to `false` to disable automatic adjustment of the {@link #config-align} config based on the state
       * of the panel's {@link Core.widget.Panel#config-collapsed} config and the
       * {@link Core.widget.panel.PanelCollapser#config-direction}.
       *
       * If this is set to a function, that function is called passing the owning `Panel` instance and its
       * return value is assigned to the {@link #config-align} config.
       *
       * @config {Boolean|Function}
       * @param {Core.widget.Panel} owner The owning `Panel` instance
       * @returns {Boolean} Auto align value
       * @default
       */
      autoAlign: true,
      collapsed: null,
      collapsing: null,
      collapsify: false,
      // ...unaffected when the panel is collapsed
      direction: "up",
      // Our own setValues/getValues system should not set/get HTML content
      defaultBindProperty: null
    };
  }
  compose() {
    const { collapsed, direction } = this;
    return {
      class: {
        [`b-icon-collapse-${direction}`]: 1,
        "b-collapsed": collapsed
      }
    };
  }
  changeAutoAlign(v) {
    return v === true ? autoAlign : v;
  }
  syncAutoAlign() {
    const { autoAlign: autoAlign2 } = this;
    if (autoAlign2) {
      this.align = autoAlign2(this);
    }
  }
  updateAutoAlign() {
    this.syncAutoAlign();
  }
  updateCollapsed() {
    this.syncAutoAlign();
  }
  updateCollapsing() {
    this.syncAutoAlign();
  }
  updateDirection() {
    this.syncAutoAlign();
  }
};
__publicField(CollapseTool, "$name", "CollapseTool");
__publicField(CollapseTool, "type", "collapsetool");
CollapseTool.initClass();
CollapseTool._$name = "CollapseTool";

// ../Core/lib/Core/widget/panel/PanelCollapser.js
var defaultedDirectionRe = /^(?:UP|DOWN|LEFT|RIGHT)$/;
var dockBeforeRe = /^(left|top)$/i;
var emptyObject7 = {};
var headerDockRe = /^b-dock-(top|left|right|bottom)$/;
var revealerCls = "b-panel-collapse-revealer";
var sideDockRe = /^(?:left|right)$/i;
var unflexCls = "b-collapse-unflex";
var { round } = Math;
var canonicalDirection = ["up", "down", "left", "right"].reduce((o, v) => {
  o[v.toUpperCase()] = o[v] = v;
  return o;
}, {});
var clipByDock = {
  top: ["top", "bottom"],
  right: ["right", "left"],
  bottom: ["bottom", "top"],
  left: ["left", "right"]
};
var collapseDirectionByPlacement = {
  hl: "LEFT",
  hr: "RIGHT",
  vb: "DOWN",
  vt: "UP"
};
var crossAxis = {
  h: "w",
  w: "h"
};
var dockByDirection = {
  up: "top",
  right: "right",
  down: "bottom",
  left: "left"
};
var dockIsHorz = {
  top: false,
  right: true,
  bottom: false,
  left: true
};
var directionByDock = {
  top: "UP",
  right: "RIGHT",
  bottom: "DOWN",
  left: "LEFT"
};
var transverseTransform = {
  top: (rect) => `translate(0, -${round(rect.height || 0)}px)`,
  bottom: (rect) => `translate(0, ${round(rect.height || 0)}px)`,
  right: (rect) => `translate(${round(rect.width || 0)}px, 0)`,
  left: (rect) => `translate(-${round(rect.width || 0)}px, 0)`
};
var idSeed2 = 0;
var PanelCollapser = class extends Base.mixin(Factoryable_default) {
  static get configurable() {
    return {
      /**
       * An animation config object.
       * @config {Object} animation
       * @property {Number} [animation.duration=200] The duration of the animation (in milliseconds).
       */
      animation: {
        duration: 200
      },
      /**
       * Tracks whether or not the panel is collapsed.
       * @config {Boolean}
       * @private
       */
      collapsed: {
        value: null,
        $config: null,
        default: false
      },
      /**
       * Specifies the direction of panel collapse. The default value for this config is determined dynamically
       * based on the {@link Core.widget.Panel#config-header header's} `dock` property and the containing layout's
       * flex direction and, therefore, often does not need to be explicitly specified.
       *
       * This config can be any of the following:
       * - `'up'`
       * - `'down'`
       * - `'left'`
       * - `'right'`
       *
       * @config {'up'|'down'|'left'|'right'}
       */
      direction: null,
      /**
       * The tooltip to use for the collapse tool when the panel is expanded.
       * @config {String}
       */
      collapseTooltip: "L{Collapse}",
      /**
       * The tooltip to use for the expand tool when the panel is collapsed.
       * @config {String}
       */
      expandTooltip: "L{Expand}",
      panel: {
        value: null,
        $config: "nullify"
      },
      /**
       * To support the panel's collapsed size, a minimum width and height may be assigned to the panel's header,
       * based on this config and the panel's positioning style.
       *
       * When a panel is collapsed it may need to retain the pre-collapse dimension perpendicular to the collapse
       * {@link #config-direction}. For example, the height of a panel that collapses to the left. The dimension
       * parallel to the collapse (the width in this example) may also need to be supported using the pre-collapse
       * size of the panel's header.
       *
       * When this config is set to `true`, or by default when the owning panel is `position: absolute`, both
       * axes are given a minimum size based on the panel's pre-collapse size. When this config is `false`, no
       * minimum sizes will be assigned.
       *
       * This config can also be a string containing the single letters 'w' and/or 'h' indicating which axis/axes
       * of the panel header should be assigned a minimum size. That is, 'w' to assign only a minimum width, 'h'
       * for only a minimum height, or 'wh' to assign both.
       *
       * @config {String|Boolean}
       * @internal
       */
      supportAxis: null,
      /**
       * The collapse/expand tool. The `type` of this instance should not be changed but the tool instance can be
       * configured in other ways via this config property.
       * @config {ToolConfig|Core.widget.Tool}
       */
      tool: {
        type: "collapsetool",
        handler(ev) {
          var _a2;
          (_a2 = this.collapsible) == null ? void 0 : _a2.onCollapseClick(ev);
        }
      }
    };
  }
  static get factoryable() {
    return {
      defaultType: "inline"
    };
  }
  get collapsing() {
    return this.collapsingExpanding === "collapsing";
  }
  get collapsingExpanding() {
    var _a2;
    const state = (_a2 = this.currentOperation) == null ? void 0 : _a2.collapsing;
    return state == null ? null : state ? "collapsing" : "expanding";
  }
  get currentDock() {
    var _a2, _b, _c, _d;
    return (_d = (_c = (_b = (_a2 = this.panel) == null ? void 0 : _a2.header) == null ? void 0 : _b.dock) == null ? void 0 : _c.toLowerCase()) != null ? _d : "top";
  }
  get expanding() {
    return this.collapsingExpanding === "expanding";
  }
  get collapseTool() {
    var _a2, _b;
    return (_b = (_a2 = this.panel) == null ? void 0 : _a2.tools) == null ? void 0 : _b.collapse;
  }
  get collapseDim() {
    return sideDockRe.test(this.collapseDir) ? "width" : "height";
  }
  getCollapseDir(canonical) {
    var _a2;
    let { direction, panel } = this;
    if (!direction || defaultedDirectionRe.test(direction)) {
      const placement = panel == null ? void 0 : panel.placement;
      if (placement) {
        direction = collapseDirectionByPlacement[placement];
      } else {
        direction = directionByDock[((_a2 = panel == null ? void 0 : panel.header) == null ? void 0 : _a2.dock) || "top"];
      }
    }
    return canonical ? canonicalDirection[direction] : direction;
  }
  get collapseDir() {
    return this.getCollapseDir(true);
  }
  get collapseDock() {
    return this.collapseInfo[0];
  }
  get collapseInfo() {
    const { panel } = this, headerDock2 = panel.hasHeader && panel.expandedHeaderDock;
    let dock = dockByDirection[this.collapseDir], transverse = false;
    if (headerDock2) {
      if (!(transverse = dockIsHorz[dock] !== dockIsHorz[headerDock2])) {
        dock = headerDock2;
      }
    }
    return [dock, transverse];
  }
  get toolsConfig() {
    const { direction, tool } = this;
    return tool && {
      collapse: ObjectHelper.assign({
        direction: direction.toLowerCase()
      }, tool)
    };
  }
  beforeCollapse(operation) {
    const { panel } = this, { element } = panel;
    if (element.contains(DomHelper.getActiveElement(element))) {
      panel.revertFocus(true);
    }
  }
  changeTool(tool) {
    const me = this, { panel } = me;
    if (me.isConfiguring || me.isDestroying || !panel || panel.isDestroying) {
      return tool;
    }
    panel.tools = {
      collapse: tool
    };
  }
  collapse(collapsed) {
    var _a2, _b;
    const me = this, { panel } = me, operation = {
      id: ++idSeed2,
      completed: false,
      panel
    };
    let { currentOperation } = me;
    collapsed = collapsed != null ? collapsed : true;
    if (ObjectHelper.isObject(collapsed)) {
      operation.collapsed = true;
      ObjectHelper.assign(operation, collapsed);
      collapsed = operation.collapsed;
      delete operation.collapsed;
    }
    operation.collapsing = collapsed;
    operation.previous = currentOperation != null ? currentOperation : null;
    if (collapsed !== me.collapsed) {
      if (currentOperation) {
        if (currentOperation.collapsing !== collapsed) {
          operation.animation = currentOperation.animation.revert({
            finalize() {
              var _a3;
              (_a3 = me.collapseFinalize) == null ? void 0 : _a3.call(me, operation, true);
            }
          });
          operation.collapsing = collapsed;
          currentOperation = operation;
        }
      } else {
        operation.animation = ObjectHelper.clone(("animation" in operation ? operation : me).animation);
        if (me.beforeCollapse(operation) !== false) {
          if (operation.animation) {
            operation.animation.finalize = (complete) => {
              var _a3;
              return (_a3 = me.collapseFinalize) == null ? void 0 : _a3.call(me, operation, complete);
            };
          }
          panel.changingCollapse = true;
          me[collapsed ? "collapseBegin" : "expandBegin"](operation);
          if (operation.animation) {
            currentOperation = operation;
          } else {
            operation.completed = true;
            me[collapsed ? "collapseEnd" : "expandEnd"](operation);
          }
          panel.changingCollapse = false;
          if (!operation.animation) {
            me.onComplete(collapsed ? "collapse" : "expand");
          }
        }
      }
    } else if (currentOperation && currentOperation.collapsing !== collapsed) {
      me[collapsed ? "expandRevert" : "collapseRevert"](operation);
      operation.animation = currentOperation.animation.revert({
        finalize() {
          var _a3;
          (_a3 = me.collapseFinalize) == null ? void 0 : _a3.call(me, operation, false);
        }
      });
      currentOperation = operation;
    }
    me.currentOperation = currentOperation;
    return (_b = (_a2 = currentOperation == null ? void 0 : currentOperation.animation) == null ? void 0 : _a2.done()) != null ? _b : Promise.resolve(collapsed === me.collapsed);
  }
  collapseFinalize(operation, complete) {
    const me = this, { currentOperation, panel } = me, action = panel.collapsed ? "expand" : "collapse";
    if (currentOperation === operation) {
      me.currentOperation = null;
      operation.completed = complete;
      panel.changingCollapse = true;
      me[action + "End"](operation);
      panel.changingCollapse = false;
      complete && me.onComplete(action);
    }
  }
  applyHeaderDock(collapsed, flush = true) {
    const me = this, { currentDock, panel } = me, dock = collapsed ? me.collapseDock : panel.expandedHeaderDock;
    if (dock !== currentDock && panel.hasHeader) {
      panel.header = {
        dock
      };
      flush && panel.recompose.flush();
    }
  }
  composeHeader(header) {
    const { panel } = this, { class: cls } = header, dock = panel.expandedHeaderDock || Object.keys(cls).filter((k) => cls[k] && headerDockRe.test(k)).map((k) => headerDockRe.exec(k)[1][0]);
    cls[revealerCls] = 1;
    cls[`b-collapsible-${dock[0]}${this.collapseDir[0]}`] = 1;
    return header;
  }
  composeTitle(title) {
    title.class[revealerCls] = 1;
    return title;
  }
  collapseBegin(operation) {
    var _a2;
    const me = this, { animation } = operation, { collapseDim, collapseTool, panel } = me, { element, placement } = panel, [collapseDock, transverse] = me.collapseInfo, collapseToolClasses = collapseTool == null ? void 0 : collapseTool.element.classList, unflex = !placement || placement[0] === "h" && collapseDim === "width" || placement[0] === "v" && collapseDim === "height";
    me.configuredWidth = panel._lastWidth;
    me.configuredHeight = panel._lastHeight;
    me.transverseCollapse = transverse;
    me.applyHeaderDock(true);
    const panelRect = panel.rectangle(), bodyWrapRect = me.lockInnerSize().moveTo(0, 0), bodyWrapClipRect = bodyWrapRect.clone(), clipDir = clipByDock[collapseDock], headerRect = (_a2 = panel.headerElement) == null ? void 0 : _a2.getBoundingClientRect(), collapsedSize = round((headerRect == null ? void 0 : headerRect[collapseDim]) || 0);
    element.classList.toggle(unflexCls, unflex);
    if (animation) {
      bodyWrapClipRect[clipDir[0]] = bodyWrapClipRect[clipDir[1]];
      element.classList.add("b-collapsing");
      collapseToolClasses == null ? void 0 : collapseToolClasses.add("b-collapsed", "b-collapsing");
      if (collapseTool) {
        collapseTool.collapsing = true;
      }
      if (collapseToolClasses) {
        collapseToolClasses.remove("b-collapsed");
        panel.rectangle();
        collapseToolClasses.remove("b-collapsing");
        collapseToolClasses.add("b-collapsed");
      }
      animation.element = element;
      animation.retain = true;
      animation[collapseDim] = {
        from: round(panelRect[collapseDim]),
        to: collapsedSize
      };
      animation.items = [{
        element: me.innerElement,
        retain: false,
        clip: {
          from: `rect(${bodyWrapRect})`,
          to: `rect(${bodyWrapClipRect})`
        }
      }];
      if (transverse) {
        animation.items.push({
          element: panel.headerElement,
          duration: animation.duration,
          retain: false,
          transform: {
            from: transverseTransform[collapseDock](headerRect),
            to: `translate(0, 0)`
          }
        });
      }
      operation.animation = Animator.run(animation);
    } else {
      element.style[collapseDim] = `${collapsedSize}px`;
      if (collapseTool) {
        collapseToolClasses.add("b-collapsing", "b-collapsed");
        collapseTool.rectangle();
        collapseToolClasses.remove("b-collapsing");
      }
    }
  }
  collapseEnd(operation) {
    const me = this, { collapseTool } = me;
    me.panel.element.classList.remove("b-collapsing");
    if (collapseTool) {
      collapseTool.collapsing = false;
    }
    if (operation.completed) {
      me.collapsed = true;
    } else {
      me.applyHeaderDock(false);
      me.restoreConfiguredSize();
      me.lockInnerSize(false);
    }
  }
  collapseRevert(operation) {
    var _a2;
    (_a2 = this.collapseTool) == null ? void 0 : _a2.element.classList.remove("b-collapsed");
  }
  expandBegin(operation) {
    const me = this, { animation } = operation, { collapseDim, collapseTool, panel } = me, [collapseDock, transverse] = me.collapseInfo, { element } = panel, elementClassList = element.classList, unflex = elementClassList.contains(unflexCls), fromRect = panel.rectangle();
    elementClassList.remove("b-collapsed", "b-collapsing");
    panel.element.style[collapseDim] = "";
    me.restoreConfiguredSize();
    me.lockInnerSize(false);
    const toRect = panel.rectangle(), bodyWrapRect = me.lockInnerSize().moveTo(0, 0), bodyWrapClipRect = bodyWrapRect.clone(), clipDir = clipByDock[me.collapseDock];
    collapseTool == null ? void 0 : collapseTool.element.classList.remove("b-collapsed");
    if (animation) {
      bodyWrapClipRect[clipDir[0]] = bodyWrapClipRect[clipDir[1]];
      elementClassList.add("b-collapsed", "b-expanding");
      unflex && elementClassList.add(unflexCls);
      animation.element = element;
      animation[collapseDim] = {
        from: round(fromRect[collapseDim]),
        to: round(toRect[collapseDim])
      };
      animation.items = [{
        element: me.innerElement,
        retain: false,
        clip: {
          from: `rect(${bodyWrapClipRect})`,
          to: `rect(${bodyWrapRect})`
        }
      }];
      if (transverse) {
        animation.items.push({
          element: panel.headerElement,
          duration: animation.duration,
          retain: false,
          transform: {
            from: `translate(0, 0)`,
            to: transverseTransform[collapseDock](fromRect)
          }
        });
      }
      operation.animation = Animator.run(animation);
    }
  }
  expandEnd(operation) {
    const me = this;
    me.panel.element.classList.remove("b-expanding");
    if (operation.completed) {
      me.collapsed = false;
      me.applyHeaderDock(false);
      me.restoreConfiguredSize();
      me.lockInnerSize(false);
    }
  }
  expandRevert(operation) {
    var _a2;
    (_a2 = this.collapseTool) == null ? void 0 : _a2.element.classList.add("b-collapsed");
  }
  get innerElement() {
    return this.panel.collapseWrapElement || this.panel.bodyWrapElement;
  }
  get innerSizeElement() {
    return this.transverseCollapse ? this.panel.element : this.innerElement;
  }
  get supportAxis() {
    let { _supportAxis } = this;
    const fullSupport = _supportAxis === true;
    if (fullSupport || _supportAxis == null) {
      _supportAxis = this.collapseDim[0];
      if (fullSupport || DomHelper.getStyleValue(this.panel.element, "position") === "absolute") {
        _supportAxis += crossAxis[_supportAxis];
      }
    }
    return _supportAxis || "";
  }
  lockInnerSize(lock = true) {
    const me = this, { innerElement, panel } = me, supportAxis = lock ? me.supportAxis : "", panelEl = panel.element, headerEl = panel.headerElement, headerRect = lock && headerEl && Rectangle.from(headerEl, panelEl), innerRect = lock && Rectangle.from(me.innerSizeElement, panelEl), innerStyle = innerElement.style;
    if (headerEl) {
      headerEl.style.minWidth = supportAxis.includes("w") ? `${headerRect.width}px` : "";
      headerEl.style.minHeight = supportAxis.includes("h") ? `${headerRect.height}px` : "";
    }
    innerStyle.width = lock ? `${innerRect.width}px` : "";
    innerStyle.height = lock ? `${innerRect.height}px` : "";
    innerElement.classList[lock ? "add" : "remove"]("b-panel-collapse-size-locker");
    return innerRect;
  }
  onCollapseClick(e) {
    let collapsed = this.collapsing ? false : this.expanding ? true : !this.collapsed;
    if (e.altKey) {
      collapsed = {
        animation: null,
        collapsed
      };
    }
    this.collapse(collapsed);
  }
  onComplete(action) {
    var _a2;
    (_a2 = this.panel) == null ? void 0 : _a2.trigger(action);
  }
  onHeaderClick({ event }) {
    if (event.button === 0 && this.panel.collapsed && event.target.classList.contains(revealerCls)) {
      this.onRevealerClick();
    }
  }
  onPanelConfigChange({ name, value }) {
    const me = this, { panel } = me;
    if (name === "collapsed") {
      if (panel.isPainted) {
        me.collapsed = value;
      }
    } else if (name === "header" && !panel.changingCollapse) {
      me.syncDirection();
    }
  }
  onPanelPaint() {
    this.syncDirection();
    if (this.panel.collapsed && !this.collapsed) {
      this.collapse({
        animation: null,
        collapsed: true
      });
    }
  }
  onRevealerClick() {
    this.panel._collapse({ collapsed: false });
  }
  restoreConfiguredSize(which) {
    const { configuredHeight, configuredWidth, panel } = this;
    which = which != null ? which : "wh";
    panel.element.classList.remove(unflexCls);
    if (configuredWidth != null && which.includes("w")) {
      panel.width = configuredWidth;
    }
    if (configuredHeight != null && which.includes("h")) {
      panel.height = configuredHeight;
    }
  }
  splitHeaderItems({ as, dock } = emptyObject7) {
    var _a2;
    return (_a2 = this.panel) == null ? void 0 : _a2.splitHeaderItems({ as, dock, alt: true });
  }
  syncDirection() {
    const me = this, { direction } = me;
    if (!direction || defaultedDirectionRe.test(direction)) {
      me.direction = me.getCollapseDir();
    }
  }
  changeCollapsed(collapsed) {
    return Boolean(collapsed);
  }
  updateCollapsed(collapsed) {
    const { collapseTool, panel } = this;
    if (panel) {
      panel.collapsed = collapsed;
      panel.element.classList[collapsed ? "add" : "remove"]("b-collapsed");
    }
    if (collapseTool) {
      collapseTool.collapsed = collapsed;
    }
  }
  updateDirection(direction) {
    const { collapseTool, panel } = this;
    if (collapseTool) {
      collapseTool.direction = canonicalDirection[direction];
    }
    if (panel == null ? void 0 : panel.rendered) {
      panel.recompose();
    }
  }
  updatePanel(panel) {
    var _a2;
    const me = this;
    me.syncDirection();
    (_a2 = me.panelChangeDetacher) == null ? void 0 : _a2.call(me);
    me.panelChangeDetacher = panel && FunctionHelper.after(panel, "onConfigChange", "onPanelConfigChange", me, {
      return: false
    });
  }
  wrapCollapser(key, body) {
    var _a2;
    const me = this, [collapseDock, transverse] = me.collapseInfo;
    if (!transverse) {
      return [key, body];
    }
    const { collapseDir, panel } = me, { expandedHeaderDock, header: panelHeader, uiClassList } = panel, recollapse = (_a2 = panel.tools) == null ? void 0 : _a2.recollapse, [before, after] = me.splitHeaderItems({ as: "element", dock: collapseDock }), title = panel.hasHeader ? panel.title || (panelHeader == null ? void 0 : panelHeader.title) || "\xA0" : null, headerElement = title && {
      tag: "header",
      class: new DomClassList({
        ...uiClassList,
        [`b-dock-${expandedHeaderDock}`]: 1,
        "b-panel-header": 1,
        "b-panel-collapser-header": 1
      }, panelHeader == null ? void 0 : panelHeader.cls),
      children: [
        ...before,
        {
          reference: "collapserTitleElement",
          html: title,
          class: {
            ...uiClassList,
            [`b-align-${(panelHeader == null ? void 0 : panelHeader.titleAlign) || "start"}`]: 1,
            "b-header-title": 1
          }
        },
        ...after
      ]
    };
    if (recollapse) {
      recollapse.direction = collapseDir;
    }
    return [
      "collapseWrapElement",
      {
        class: {
          ...uiClassList,
          [`b-panel-collapser-header-${expandedHeaderDock}`]: 1,
          [`b-panel-collapser-${collapseDir}`]: 1,
          [`b-${dockIsHorz[expandedHeaderDock] ? "h" : "v"}box`]: 1,
          "b-panel-collapser": 1,
          "b-box-center": 1
        },
        children: dockBeforeRe.test(expandedHeaderDock) ? {
          collapserHeaderElement: headerElement,
          [key]: body
        } : {
          [key]: body,
          collapserHeaderElement: headerElement
        }
      }
    ];
  }
};
__publicField(PanelCollapser, "$name", "PanelCollapser");
__publicField(PanelCollapser, "type", "inline");
PanelCollapser.maps = {
  clipByDock,
  dockByDirection,
  dockIsHorz
};
PanelCollapser.initClass();
PanelCollapser._$name = "PanelCollapser";

// ../Core/lib/Core/util/DynamicObject.js
var PENDING = Symbol("pendingCreate");
var DynamicObject = class extends Base {
  static get prototypeProperties() {
    return {
      /**
       * Optional function that will be passed an instance prior to destroying it.
      *
       * @config {Function}
       * @param {String} name The property name in the Dynamic object by which the new instance may be referenced
       * @param {Object} instance The value of the property
       * @returns {void}
       */
      cleanup: null,
      /**
       * Optional name of the config property managed by this instance. If changes are made directly, this
       * property is used to run the `onConfigChange` method of the `owner`.
       * @config {String}
       */
      configName: null,
      /**
       * Optional function to call as instances are created. Each new instance is passed to this function.
       *
       * @config {Function}
       * @param {Object} instance The newly created instance.
       * @param {String} key The property name in the dynamic object by which the new instance may be referenced.
       * @returns {void}
       */
      created: null,
      /**
       * The {@link Core.mixin.Factoryable factory} to use to create instances.
       * @config {Object}
       */
      factory: null,
      /**
       * By default, the name of the member is used for the type. Set this config to `true` to also allow the
       * config object for a property to contain a `type` property. Set this to `false` to ignore the name of the
       * member and rely on the {@link #config-factory} to process the config object.
       * @config {Boolean|String}
       * @default
       */
      inferType: "name",
      /**
       * The owning object to pass along to the instances as the `ownerName` property.
       * @config {Object}
       */
      owner: null,
      /**
       * The property name by which to store the `owner` on each instance.
       * @config {String}
       */
      ownerName: null,
      /**
       * Set to `false` to prevent using a `Proxy` even if that JavaScript platform feature is available. Using
       * a `Proxy` is ideal because it allows for all forms of access to the dynamic properties to be handled
       * instead of only those that have predefined configuration values.
       * @config {Boolean}
       * @private
       */
      proxyable: typeof Proxy !== "undefined",
      /**
       * Optional function that will be passed a config object prior to instantiating an object. This function
       * can either modify the passed object or return a new object.
       *
       * @config {Function}
       * @param {Object} config The config object used to create the object
       * @param {String} name The property name in the Dynamic object by which the new instance may be referenced
       * @returns {Object|null}
       */
      setup: null,
      /**
       * Optional function that will be passed a raw config object prior to processing and the value it returns
       * replaces the raw value. This function is used to transform strings or arrays (for example) into proper
       * config objects.
       *
       * @config {Function}
       * @param {*} config The original value of the config object parameter
       * @returns {*}
       */
      transform: null
    };
  }
  static get properties() {
    return {
      /**
       * Holds config objects for each defined object. These are used to hold class and instance config values
       * and use them to create instances on first request, or when `flush()` is called. Further, if the instance
       * is initially assigned instead of retrieved, these values act as the defaults for the instance and are
       * combined with those provided in the assignment.
       * @member {Object} defaults
       * @private
       */
      defaults: {},
      /**
       * This object holds the actual instances that are retrieved by the dynamic accessor or `Proxy`.
       * @member {Object} instances
       * @private
       */
      instances: {},
      /**
       * The object that contains the dynamic accessors for each instance. This object is not used when using a
       * `Proxy`.
       * @member {Object} object
       * @private
       */
      object: /* @__PURE__ */ Object.create({})
    };
  }
  /**
   * Returns the `Proxy` instance used to manage dynamic assignments. If the JavaScript platform does not support the
   * `Proxy` class, this will be `null`.
   * @property {Proxy}
   * @private
   */
  get proxy() {
    const me = this;
    let proxy = null;
    if (me.proxyable) {
      proxy = new Proxy(me.instances, {
        get(o, name) {
          return me.get(name);
        },
        set(o, name, value) {
          me.set(name, value);
          return true;
        },
        deleteProperty(o, name) {
          me.set(name, null);
          return true;
        }
      });
    }
    Reflect.defineProperty(me, "proxy", {
      configurable: true,
      // allow destroy() to delete it
      value: proxy
    });
    return proxy;
  }
  /**
   * Returns the object that contains the dynamic properties. This may be a `Proxy` instance or an object with getter
   * and setter accessors.
   * @property {Object}
   * @internal
   */
  get target() {
    return this.proxy || this.object;
  }
  /**
   * This method establishes the initial definition of a dynamic property. When using a `Proxy`, this method simply
   * needs to cache away the initial config for use by the getter. When `Proxy` is unavailable, this method will
   * also defined a getter/setter to intercept access to the dynamic property.
   * @param {String} name The name of the dynamic property.
   * @param {Object} config The initial config object for the dynamic property.
   * @private
   */
  define(name, config) {
    const me = this, { transform } = me, transformed = transform ? transform(config, name) : config, instantiated = ObjectHelper.isInstantiated(transformed);
    me.instances[name] = PENDING;
    if (!instantiated) {
      me.setDefaults(name, transformed);
    }
    me.defineProp(name, true);
    if (instantiated) {
      me.set(name, transformed);
    }
  }
  /**
   * Define the get/set accessors for `name` on our `object` or its prototype.
   * @param {String} name
   * @param {Boolean} [base] Pass `true` to indicate the property should be defined on the prototype.
   * @private
   */
  defineProp(name, base) {
    const me = this, { object } = me;
    if (!me.proxy) {
      Reflect.defineProperty(base ? Object.getPrototypeOf(object) : object, name, {
        configurable: !base,
        enumerable: true,
        get() {
          return me.get(name);
        },
        set(value) {
          return me.set(name, value);
        }
      });
    }
  }
  /**
   * Ensures that all defined members are touched to trigger their creation.
   * @internal
   */
  flush() {
    var _a2;
    const me = this;
    try {
      me.updating = true;
      for (const name in me.defaults) {
        me.get(name);
      }
      me.afterConfigureOwner = (_a2 = me.afterConfigureOwner) == null ? void 0 : _a2.call(me);
    } finally {
      me.updating = false;
    }
  }
  /**
   * Returns (lazily creating as necessary) the value of a dynamic property given its name.
   * @param {String} name
   * @returns {Object}
   * @private
   */
  get(name) {
    const { defaults, instances } = this;
    if (instances[name] === PENDING) {
      this.set(name, PENDING);
    }
    return instances[name] || defaults[name] && null;
  }
  /**
   * Sets the value of a dynamic property given its name and value.
   * @param {String} name
   * @param {Object} value
   * @private
   */
  set(name, value) {
    var _a2;
    const me = this, { cleanup, configName, defaults, factory, instances, owner, setup, transform, updating } = me, inform = owner && configName && !updating, was = instances[name] === PENDING ? null : instances[name], instance = factory.reconfigure(was, value === PENDING ? {} : value || null, {
      cleanup: cleanup && ((instance2) => cleanup(instance2, name)),
      defaults: defaults[name] || me.setDefaults(name, {}),
      owner: me.owner,
      setup: setup && ((config, type, defaults2) => setup(config, name, type, defaults2)),
      transform: transform && ((config) => transform(config, name))
    });
    if (instance !== was) {
      const before = inform && { ...instances };
      instances[name] = instance;
      if (instance) {
        me.defineProp(name);
        (_a2 = me.created) == null ? void 0 : _a2.call(me, instance, name);
      } else {
        delete me.object[name];
        delete instances[name];
      }
      if (inform) {
        owner.onConfigChange({
          name: configName,
          config: owner.$meta.configs[configName],
          value: me.target,
          was: before
        });
      }
    }
  }
  /**
   * Stores the default config values for use in the factory reconfiguration process.
   * @param {String} name The name and default type of the dynamic property. Depending on {@link #config-inferType},
   * this may not be overridden by a type property in the config object.
   * @param {Object} config The config object.
   * @returns {Object}
   * @private
   */
  setDefaults(name, config) {
    const { defaults, factory, inferType, instances, owner, ownerName } = this, { typeKey } = factory.factoryable;
    config = config === true ? {} : ObjectHelper.assign({}, config);
    if (inferType === "name" || inferType === true && !config[typeKey]) {
      config[typeKey] = name;
    }
    if (ownerName) {
      config[ownerName] = owner;
    }
    config.beforeConfigure = (instance) => {
      instances[name] = instance;
    };
    return defaults[name] = config;
  }
  /**
   * Updates the members of `object` based on the provided configuration.
   * @param {Object} members The configuration for the instances of `object`.
   * @internal
   */
  update(members) {
    const me = this, { owner } = me;
    let name, config;
    try {
      me.updating = true;
      if (members) {
        for (name in members) {
          config = members[name];
          if (me.defaults[name]) {
            me.set(name, config);
          } else if (config) {
            me.define(name, config);
          }
        }
      } else {
        for (name in me.instances) {
          me.set(name, null);
        }
      }
    } finally {
      me.updating = false;
    }
    if (owner) {
      if (!owner.isConfiguring) {
        me.flush();
      } else if (!me.afterConfigureOwner) {
        me.afterConfigureOwner = FunctionHelper.before(owner, "afterConfigure", "flush", me);
      }
    }
  }
};
DynamicObject.initClass();
DynamicObject._$name = "DynamicObject";

// ../Core/lib/Core/widget/mixin/Toolable.js
var emptyArray6 = [];
var emptyObject8 = {};
var toolConfigs = {
  align: 1,
  // hidden : 1,
  weight: 1
};
var Toolable_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Widget) {
    static get configurable() {
      return {
        /**
         * The {@link Core.widget.Tool tools} as specified by the {@link #config-tools} configuration. Each is a
         * {@link Core.widget.Tool} instance which may be hidden, shown and observed and styled just like any other
         * widget.
         * @member {Object<String,Core.widget.Tool>} tools
         * @accepts {Object<String,Core.widget.Tool|ToolConfig>}
         * @category Content
         */
        /**
         * The {@link Core.widget.Tool tools} to add either before or after the `title` in the Panel header. Each
         * property name is the reference by which an instantiated tool may be retrieved from the live
         * `{@link #property-tools}` property.
         * @config {Object<String,ToolConfig>} tools
         * @category Content
         */
        tools: {
          value: null,
          $config: {
            nullify: true
          }
        },
        /**
         * An object containing config defaults for corresponding {@link #config-tools} objects with a matching name.
         *
         * This object contains a key named `'*'` with default config properties to apply to all tools. This
         * object provides the default `type` (`'tool').
         * @config {Object} toolDefaults
         * @private
         */
        toolDefaults: {
          "*": {
            type: "tool",
            align: "end"
          }
        }
      };
    }
    byWeightSortFn(a, b) {
      return (a.weight || 0) - (b.weight || 0);
    }
    byWeightReverseSortFn(a, b) {
      return (b.weight || 0) - (a.weight || 0);
    }
    gatherTools({ align, alt: alt2, refs } = emptyObject8) {
      var _a3, _b, _c;
      const { collapsed, tools } = this, options = { collapsed, alt: alt2 };
      let ret = [], alignment, key, i, item, tool;
      for (key in tools) {
        tool = tools[key];
        alignment = (_c = (_b = (_a3 = tool == null ? void 0 : tool.align) == null ? void 0 : _a3.align) != null ? _b : tool == null ? void 0 : tool.align) != null ? _c : "end";
        if (alignment === align && tool.isCollapsified(options)) {
          ret.push(tool);
        }
      }
      ret.sort(this[align === "end" ? "byWeightReverseSortFn" : "byWeightSortFn"]);
      if (refs) {
        const asWidget = refs === "widget", asRefs = {};
        for (i = 0; i < ret.length; ++i) {
          item = ret[i];
          asRefs[item.ref] = asWidget ? item : item.element;
        }
        ret = asRefs;
      }
      return ret;
    }
    getEndTools({ alt: alt2, refs } = emptyObject8) {
      return this.gatherTools({ align: "end", alt: alt2, refs });
    }
    getStartTools({ alt: alt2, refs } = emptyObject8) {
      return this.gatherTools({ align: "start", alt: alt2, refs });
    }
    get childItems() {
      return [
        ...this.getStartTools(),
        ...this._items || emptyArray6,
        ...this.getEndTools()
      ];
    }
    changeTools(tools, oldTools) {
      const me = this, manager = me.$tools || (me.$tools = new DynamicObject({
        configName: "tools",
        factory: Widget,
        inferType: false,
        // the name of a tool in the tools object is not its type
        owner: me,
        created(instance) {
          var _a3, _b;
          instance.innerItem = false;
          (_b = instance.syncRotationToDock) == null ? void 0 : _b.call(instance, (_a3 = me.header) == null ? void 0 : _a3.dock);
          FunctionHelper.after(instance, "onConfigChange", (ret, { name }) => {
            if (toolConfigs[name]) {
              me.onConfigChange({
                name: "tools",
                value: manager.target
              });
            }
          });
          me.onChildAdd(instance);
        },
        setup(config, name) {
          config = ObjectHelper.merge({}, me.toolDefaults["*"], me.toolDefaults[name], config);
          config.parent = me;
          config.ref = name;
          return config;
        }
      }));
      manager.update(tools);
      if (!oldTools) {
        return manager.target;
      }
    }
    get widgetClass() {
    }
  }, __publicField(_a2, "$name", "Toolable"), _a2;
};

// ../Core/lib/Core/widget/layout/Box.js
var directionCls = [
  "b-hbox",
  "b-vbox"
];
var syncAlign = {
  name: "align",
  style: "alignItems"
};
var syncContentAlign = {
  name: "contentAlign",
  style: "alignContent"
};
var syncDirection = {
  name: "direction",
  style: "flexDirection"
};
var syncJustify = {
  name: "justify",
  style: "justifyContent",
  classes: ["stretch"]
};
var syncWrap = {
  name: "wrap",
  style: "flexWrap",
  map: {
    false: "nowrap",
    true: "wrap",
    reverse: "wrap-reverse"
  }
};
var Box = class extends Layout {
  /**
   * Set this value to `true` to set the [flex-direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction)
   * style of the {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}
   * to `column`. Or alternatively, set {@link #config-horizontal} to `false`.
   * @config {Boolean} vertical
   * @default false
   */
  get vertical() {
    return this.horizontal === false;
  }
  set vertical(v) {
    return this.horizontal = !v;
  }
  updateAlign() {
    this.syncConfigStyle(syncAlign);
  }
  updateContentAlign() {
    this.syncConfigStyle(syncContentAlign);
  }
  updateDirection() {
    this.syncConfigStyle(syncDirection);
  }
  updateHorizontal() {
    var _a2;
    const me = this, classList = (_a2 = me.contentElement) == null ? void 0 : _a2.classList, vertical = Number(me.vertical);
    if (classList) {
      classList.remove(directionCls[1 - vertical]);
      classList.add(directionCls[vertical]);
    } else {
      me.syncConfigLater("horizontal");
    }
    me.syncDirection();
  }
  updateJustify() {
    this.syncConfigStyle(syncJustify);
  }
  updateReverse() {
    this.syncDirection();
  }
  updateWrap() {
    this.syncConfigStyle(syncWrap);
  }
  syncDirection() {
    const me = this, { reverse } = me;
    me.direction = reverse ? `${me.vertical ? "column" : "row"}${reverse ? "-reverse" : ""}` : null;
  }
};
__publicField(Box, "$name", "Box");
__publicField(Box, "type", "box");
__publicField(Box, "alias", "hbox");
__publicField(Box, "configurable", {
  containerCls: "b-box-container",
  itemCls: "b-box-item",
  /**
   * Sets the [align-items](https://developer.mozilla.org/en-US/docs/Web/CSS/align-items) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * @config {String} align
   * @default 'stretch'
   */
  align: null,
  /**
   * Sets the [align-content](https://developer.mozilla.org/en-US/docs/Web/CSS/align-content) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * @config {String} contentAlign
   * @default 'normal'
   */
  contentAlign: null,
  /**
   * Sets the [direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * This config is not set directly. Set {@link #config-horizontal}, {@link #config-vertical}, and/or
   * {@link #config-reverse} instead.
   * @config {String} direction
   * @private
   */
  direction: null,
  /**
   * Set this value to `false` to set the [flex-direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction)
   * style of the {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}
   * to `column`. Or alternatively, set {@link #config-vertical} to `true`.
   * @config {Boolean} horizontal
   * @default
   */
  horizontal: true,
  /**
   * Sets the [justify-content](https://developer.mozilla.org/en-US/docs/Web/CSS/justify-content) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * @config {String} justify
   * @default 'flex-start'
   */
  justify: null,
  /**
   * Set this value to `true` to add `'-reverse'` to the [flex-direction](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-direction)
   * style of the {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   * This config combines with {@link #config-horizontal} or {@link #config-vertical} to set the `flex-direction`
   * style.
   * @config {Boolean} reverse
   * @default false
   */
  reverse: null,
  /**
   * Sets the [flex-wrap](https://developer.mozilla.org/en-US/docs/Web/CSS/flex-wrap) style of the
   * {@link #property-owner owner's} {@link Core.widget.Widget#property-contentElement}.
   *
   * The value of `true` is equivalent to `'wrap'`, `false` is equivalent to `'nowrap'`, and `'reverse'` is
   * equivalent to `'wrap-reverse'`.
   *
   * ```javascript
   *  layout : {
   *      type : 'box',
   *      wrap : false        // equivalent to 'nowrap'
   *      wrap : true         // equivalent to 'wrap'
   *      wrap : 'reverse'    // equivalent to 'wrap-reverse'
   *  }
   * ```
   * @config {String|Boolean} wrap
   * @default false
   */
  wrap: null
});
Box.initClass();
Box._$name = "Box";

// ../Core/lib/Core/widget/layout/VBox.js
var VBox = class extends Box {
};
__publicField(VBox, "$name", "VBox");
__publicField(VBox, "type", "vbox");
__publicField(VBox, "configurable", {
  horizontal: false
});
VBox.initClass();
VBox._$name = "VBox";

// ../Core/lib/Core/widget/mixin/Badge.js
var Badge_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    static get configurable() {
      return {
        /**
         * Get/sets and display badge, set to null or empty string to hide.
         * @member {String} badge
         * @category Misc
         */
        /**
         * Initial text to show in badge.
         * @config {String} badge
         * @category Misc
         */
        badge: null
      };
    }
    compose() {
      const { badge } = this;
      return {
        dataset: {
          badge
        },
        class: {
          "b-badge": badge != null && badge !== ""
        }
      };
    }
  }, __publicField(_a2, "$name", "Badge"), _a2;
};

// ../Core/lib/Core/widget/Button.js
var bIcon = /(?:^|\s)b-icon-/;
var bFa = /(?:^|\s)b-fa-/;
var defaultToggleable = Symbol("defaultToggleable");
var fullConfigKeys = ["items", "type", "widgets", "html", "listeners"];
var menuListenersName = Symbol("defaultListener");
var Button = class extends Widget.mixin(Badge_default, Rotatable_default) {
  static get configurable() {
    return {
      /**
       * Button icon class.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       * @prp {String}
       */
      icon: null,
      /**
       * The menu icon class to show when the button has a menu. Set to `null` to not show a menu icon.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * @prp {String}
       * @default
       */
      menuIcon: "b-icon-picker",
      /**
       * Icon class for the buttons pressed state. Only applies to toggle buttons
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       *
       * ```
       * new Button({
       *    // Icon for unpressed button
       *    icon        : 'b-fa-wine-glass',
       *
       *    // Icon for pressed button
       *    pressedIcon : 'b-fa-wine-glass-alt',
       *
       *    // Only applies to toggle buttons
       *    toggleable  : true
       * });
       * ```
       *
       * @prp {String}
       */
      pressedIcon: null,
      /**
       * Button icon alignment. May be `'start'` or `'end'`. Defaults to `'start'`
       * @prp {'start'|'end'}
       * @default
       */
      iconAlign: "start",
      /**
       * The button behavioral type, will be applied as a `type` attribute to this button's element.
       * @prp {'button'|'submit'|'reset'}
       * @default
       */
      behaviorType: "button",
      /**
       * The button's text.
       * @prp {String}
       */
      text: {
        value: null,
        $config: null,
        default: ""
      },
      /**
       * Button color (should have match in button.scss or your custom styling). Valid values in Bryntum themes
       * are:
       * * b-amber
       * * b-blue
       * * b-dark-gray
       * * b-deep-orange
       * * b-gray
       * * b-green
       * * b-indigo
       * * b-lime
       * * b-light-gray
       * * b-light-green
       * * b-orange
       * * b-purple
       * * b-red
       * * b-teal
       * * b-white
       * * b-yellow
       * Combine with specifying `b-raised` for raised/filled style (theme dependent).
       *
       * ```
       * new Button({
       *    color : 'b-teal b-raised'
       * });
       * ```
       *
       * @prp {String}
       */
      color: null,
      /**
       * Enabled toggling of the button (stays pressed when pressed).
       * @prp {Boolean}
       * @default false
       */
      toggleable: defaultToggleable,
      /**
       * Initially pressed or not. Only applies with `toggleable = true`.
       *
       * ```javascript
       * const toggleButton = new Button({
       *    toggleable : true,
       *    text : 'Enable cool action'
       * });
       * ```
       * @prp {Boolean}
       * @default
       */
      pressed: false,
      /**
       * Indicates that this button is part of a group where only one button can be pressed. Assigning a value
       * also sets `toggleable` to `true`.
       *
       * When part of a {@link Core.widget.ButtonGroup}, you can set {@link Core.widget.ButtonGroup#config-toggleGroup}
       * on it as an alternative to on each button. This config can then be used to override that value if needed.
       *
       * ```javascript
       * const yesButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'Yes'
       * });
       *
       * const noButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'No'
       * });
       * ```
       * @prp {String}
       */
      toggleGroup: null,
      /**
       * Set to `true` to perform action on clicking the button if it's already pressed
       * and belongs to a {@link #config-toggleGroup}.
       * @config {Boolean}
       * @default
       */
      supportsPressedClick: false,
      ripple: {
        radius: 75
      },
      forwardTwinEvents: ["action", "toggle"],
      localizableProperties: ["text"],
      /**
       * Returns the instantiated menu widget as configured by {@link #config-menu}.
       * @member {Core.widget.Widget} menu
       */
      /**
       * A submenu configuration object, or an array of MenuItem configuration objects from which to create a
       * submenu which is shown when this button is pressed.
       *
       * Note that this does not have to be a Menu. The `type` config can be used to specify any widget as the
       * submenu.
       *
       * May also be specified as a fully instantiated {@link Core.widget.Widget#config-floating floating Widget}
       * such as a {@link Core/widget/Popup}.
       * @config {Object<String,MenuItemConfig|ContainerItemConfig>|Array<MenuItemConfig|ContainerItemConfig>}
       */
      menu: {
        $config: ["lazy", "nullify"],
        value: null
      },
      menuDefaults: {
        type: "menu",
        autoShow: false,
        autoClose: true,
        floating: true,
        scrollAction: "realign",
        align: "t0-b0"
      },
      /**
       * If provided, turns the button into a link.
       * <div class="note">Not compatible with the {@link Core.widget.Widget#config-adopt} config.</div>
       * @prp {String}
       */
      href: null,
      /**
       * The `target` attribute for the {@link #config-href} config
       * @prp {String}
       */
      target: null,
      // Our own setValues/getValues system should not set/get HTML content
      defaultBindProperty: null
    };
  }
  updateElement(element, oldElement) {
    var _a2, _b, _c;
    const me = this, { constructor } = me, result = super.updateElement(element, oldElement), menu = me.peekConfig("menu"), role = menu ? menu.isWidget ? menu.role : ((_b = (_a2 = constructor.resolveType(menu.type)) == null ? void 0 : _a2.configurable) == null ? void 0 : _b.role) || ((_c = constructor.configurable.menuDefaults) == null ? void 0 : _c.type) || "menu" : false;
    me.ariaHasPopup = role;
    return result;
  }
  compose() {
    const {
      color,
      href,
      icon,
      iconAlign,
      pressed,
      pressedIcon,
      target,
      text,
      toggleable,
      toggleGroup,
      menuIcon,
      behaviorType
    } = this, hasMenu = this.hasConfig("menu"), iconCls = pressed && pressedIcon ? pressedIcon : icon;
    return {
      tag: href ? "a" : "button",
      href,
      target,
      type: behaviorType,
      class: {
        [`b-icon-align-${iconAlign}`]: icon,
        [color]: Boolean(color),
        "b-pressed": pressed && toggleable,
        "b-text": Boolean(text),
        "b-has-menu": hasMenu
      },
      [toggleable && !hasMenu ? "aria-pressed" : ""]: pressed,
      dataset: {
        group: toggleGroup
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: "onInternalClick",
        mousedown: "onInternalMousedown"
      },
      children: {
        iconElement: (icon || pressedIcon) && {
          // This element is a purely visual cue with no meaning to the A11Y tree
          "aria-hidden": true,
          tag: "i",
          class: {
            ...DomClassList.normalize(iconCls, "object"),
            "b-icon": bIcon.test(iconCls),
            "b-fa": bFa.test(iconCls)
          }
        },
        label: text && {
          tag: "label",
          for: this.id,
          text
        },
        menuIconElement: hasMenu && menuIcon && {
          tag: "i",
          class: {
            "b-icon": bIcon.test(menuIcon),
            "b-fa": bFa.test(menuIcon),
            "b-button-menu-icon": 1,
            [menuIcon]: 1
          }
        }
      }
    };
  }
  //endregion
  configureOverflowTwin(overrides) {
    const me = this, config = super.configureOverflowTwin(overrides);
    if (!config.text) {
      config.text = me.text || me.tooltipText;
    }
    return config;
  }
  onHide() {
    var _a2;
    (_a2 = this._menu) == null ? void 0 : _a2.hide();
  }
  /**
   * Iterate over all widgets owned by this widget and any descendants.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   *
   * _Due to the {@link #config-menu} config being a lazy config and only being converted to be a
   * `Menu` instance just before it's shown, the menu will not be part of the iteration before
   * it has been shown once_.
   * @function eachWidget
   * @param {Function} fn A function to execute upon all descendant widgets.
   * Iteration terminates if this function returns `false`.
   * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   */
  get childItems() {
    return this._menu && [this.menu];
  }
  onFocusOut(e) {
    var _a2;
    super.onFocusOut(e);
    (_a2 = this.menu) == null ? void 0 : _a2.hide();
  }
  //region Getters/Setters
  get focusElement() {
    return this.element;
  }
  changeText(text) {
    return text == null ? "" : text;
  }
  changeToggleable(toggleable) {
    if (toggleable === defaultToggleable) {
      return this.toggleGroup || this.config.menu;
    }
    return toggleable;
  }
  changeMenu(menu, oldMenu) {
    const me = this, { element: forElement } = me;
    if (menu) {
      if (menu.isWidget) {
        menu.forElement = forElement;
        menu.owner = me;
        menu.constrainTo = me.rootElement;
      } else {
        if (typeof menu === "object" && !fullConfigKeys.some((key) => key in menu)) {
          menu = {
            lazyItems: menu
          };
        }
        menu = Widget.reconfigure(oldMenu, menu ? ObjectHelper.merge({
          owner: me,
          constrainTo: me.rootElement,
          forElement
        }, me.menuDefaults, menu) : null, me);
      }
      menu.align.constrainPadding = 10;
      me.detachListeners(menuListenersName);
      menu.ion({
        name: menuListenersName,
        beforeShow: "onMenuBeforeShow",
        hide: "onMenuHide",
        show: "onMenuShow",
        thisObj: this
      });
    } else {
      oldMenu == null ? void 0 : oldMenu.destroy();
    }
    return menu;
  }
  onMenuBeforeShow({ source }) {
    return this.trigger("beforeShowMenu", {
      menu: source
    });
  }
  onMenuShow() {
    this.ariaElement.setAttribute("aria-expanded", true);
  }
  onMenuHide() {
    this.ariaElement.setAttribute("aria-expanded", false);
    this.toggle(false);
  }
  updateMenu(menu) {
    this.toggleable = Boolean(menu);
  }
  updatePressed(pressed) {
    var _a2, _b;
    const me = this;
    if (!me.toggleable || me.isConfiguring) {
      return;
    }
    const { menu } = me;
    if (pressed) {
      DomHelper.forEachSelector(me.rootElement, `button[data-group=${me.toggleGroup}]`, (btnEl) => {
        if (btnEl !== me.element) {
          Widget.getById(btnEl.id).pressed = false;
        }
      });
    }
    if (menu) {
      if (!menu.initialConfig.minWidth) {
        menu.minWidth = me.width;
      }
      menu.align.minHeight = (_a2 = menu._minHeight) != null ? _a2 : 100;
      menu.align.minWidth = (_b = menu._minWidth) != null ? _b : 100;
      menu[pressed ? "show" : "hide"]();
    }
    me.trigger("toggle", { pressed, userAction: me._isUserAction });
  }
  //endregion
  //region Events
  onInternalMousedown(event) {
    var _a2;
    if (((_a2 = this._menu) == null ? void 0 : _a2.containsFocus) && this.pressed) {
      event.preventDefault();
    }
  }
  /**
   * Triggers events when user clicks button
   * @fires click
   * @fires action
   * @internal
   */
  onInternalClick(event) {
    const me = this, bryntumEvent = { event };
    if (me.disabled) {
      return;
    }
    me._isUserAction = true;
    if (me.toggleable) {
      if (me.toggleGroup && me.pressed && !me.supportsPressedClick) {
        return;
      }
      if (!me.toggleGroup || !me.pressed) {
        me.toggle(!me.pressed);
      }
      if (me.isDestroyed) {
        return;
      }
    }
    me.trigger("click", bryntumEvent);
    if (!me.isDestroyed) {
      me.trigger("action", bryntumEvent);
    }
    if (!me.href) {
      event.preventDefault();
      event.stopPropagation();
    }
    me._isUserAction = false;
  }
  //endregion
  //region Misc
  /**
   * Toggle button state (only use with toggleable = true)
   * @param {Boolean} pressed Specify to force a certain toggle state
   * @fires toggle
   */
  toggle(pressed = !this.pressed) {
    if (this.trigger("beforeToggle", { pressed, userAction: this._isUserAction }) !== false) {
      this.pressed = pressed;
    }
  }
  //endregion
};
//region Config
__publicField(Button, "$name", "Button");
__publicField(Button, "type", "button");
Button.initClass();
Button._$name = "Button";

// ../Core/lib/Core/widget/Toolbar.js
var asElementRefs = { refs: "element" };
var onCreateTwin = (overflowTwin) => overflowTwin.element.style.margin = "";
var isToolbar = (w) => w.isToolbar;
var itemScoreFn = (ent) => ent[0] + (ent[1].minifiable ? 0 : 9e9);
var twinOverrides = {
  // If the initialConfig was hidden, we must override that
  hidden: false,
  // Item must obey menu's align-items : stretch style.
  width: ""
};
var twinOverridesHorz = {
  ...twinOverrides,
  // Don't allow horizontal flex styles to apply in the vertical layout of the Menu.
  flex: ""
};
var _axisProps = [{
  box: "hbox",
  clientSizeProp: "clientWidth",
  edgeProp: "right",
  flexDir: "row",
  horizontal: true,
  max: "maxX",
  overflow: "overflowX",
  pos: "x",
  scrollSize: "scrollWidth",
  sizeProp: "width"
}, {
  box: "vbox",
  clientSizeProp: "clientHeight",
  edgeProp: "bottom",
  flexDir: "column",
  horizontal: false,
  max: "maxY",
  overflow: "overflowY",
  pos: "y",
  scrollSize: "scrollHeight",
  sizeProp: "height"
}];
var defaultRepeat = {
  delay: 0,
  startRate: 40,
  endRate: 200,
  accelerateDuration: 500
};
var nonSyncedConfigs = {
  menu: 1,
  pressed: 1
};
var _Toolbar = class _Toolbar extends Container.mixin(Toolable_default) {
  static get delayable() {
    return {
      syncOverflowVisibility: {
        type: "raf",
        cancelOutstanding: true
      }
      // && 50   // restore the "&& 50" here to help when debugging syncOverflowVisibility
    };
  }
  static get configurable() {
    return {
      defaultType: "button",
      dock: "top",
      layout: {
        type: "box"
      },
      /**
       * An object containing typed child widget config objects or {@link Core/widget/Widget Widgets}. Can also be
       * specified as an array.
       *
       * If configured as an Object, the property names are used as the child component's
       * {@link Core.widget.Widget#config-ref} name, and the value is the child component's config object.
       *
       * ```javascript
       *  new Toolbar({
       *      appendTo : document.body
       *      items    : [{
       *          type : 'button',
       *          onClick() {
       *
       *          }
       *      }]
       *  })
       * ```
       *
       * Some special items can also be added:
       *
       * - `->` Pushes following items to the other side
       * - `|` Adds a vertical separator
       *
       * ```javascript
       *  new Toolbar({
       *      appendTo : document.body
       *      items    : [
       *      {
       *          type : 'button',
       *          text : 'Click me',
       *          onClick() {
       *
       *          }
       *      },
       *      '|', // separator
       *      {
       *          type : 'textfield',
       *          label : 'Enter name'
       *      },
       *      // Align following items to the end of the toolbar
       *      '->',
       *      {
       *          type : 'button',
       *          text : 'Save',
       *          onClick() {
       *
       *          }
       *      }]
       *  })
       * ```
       *
       * @config {Object<String,ToolbarItems|Boolean|null>|ToolbarItems[]|Core.widget.Widget[]} items
       * @category Content
       */
      /**
       * How this Toolbar should deal with items that overflow its main axis.
       *
       * Values may be:
       * - `'menu'` A button with a menu is shown and the menu contains the overflowing items.
       * - `'scroll'` The items overflow and mey be scrolled into view using the mouse or scroll buttons.
       * - `null` Disable overflow handling
       *
       * When mode is `'menu'`, clones of overflowing toolbar item are created and added to a Menu. Any config
       * changes to the original toolbar item are propagated to the menu's clone, so disabling a toolbar
       * item will make the clone in the menu disabled.
       *
       * The clone of an input field will propagate its `value` changes back to the original. The
       * overflow button, its menu, and the clones should not be accessed or manipulated by application code.
       *
       * Note that cloned items will be allocated a unique, generated ID because all IDs must be unique,
       * so CSS targeting an element ID will not apply to a clone in the overflow menu.
       *
       * Values may also be specified in object form containing the following properties:
       * @config {String|Object|null} overflow
       * @property {'scroll'|'menu'} overflow.type `'scroll'` or `'menu'`
       * @property {ClickRepeaterConfig} overflow.repeat A config object to reconfigure the
       * {@link Core.util.ClickRepeater} which controls auto repeat speed when holding down the scroll buttons
       * when `type` is `'scroll'`
       * @property {Function} overflow.filter A filter function which may return a falsy value to prevent toolbar
       * items from being cloned into the overflow menu.
       * @default 'menu'
       */
      overflow: {
        // Wait until first paint to evaluate so that we can read our CSS style.
        // Set to null on destroy which destroys the overflow Tools and Scroller.
        $config: ["lazy", "nullify"],
        value: {
          type: "menu"
        }
      },
      toolDefaults: {
        overflowMenuButton: {
          type: "button",
          hidden: true,
          icon: "b-icon-menu",
          menuIcon: null,
          ariaLabel: "Show overflowing items",
          defaultCls: {
            "b-overflow-button": 1
          }
        },
        overflowScrollEnd: {
          handler: "up.onEndScrollClick",
          hidden: true,
          defaultCls: {
            "b-icon-angle-right": 1,
            "b-overflow-button": 1,
            "b-icon": 1
          }
        },
        overflowScrollStart: {
          align: "start",
          handler: "up.onStartScrollClick",
          hidden: true,
          defaultCls: {
            "b-icon-angle-left": 1,
            "b-overflow-button": 1,
            "b-icon": 1
          }
        }
      },
      /**
       * Custom CSS class to add to toolbar widgets
       * @config {String}
       * @category CSS
       */
      widgetCls: null,
      /**
       * Determines if the toolbars read-only state should be controlled by its parent.
       *
       * When set to `false`, setting a parent container to read-only will not affect the widget. When set to
       * `true`, it will.
       *
       * @category Misc
       * @config {Boolean}
       * @default
       */
      ignoreParentReadOnly: true
    };
  }
  static get prototypeProperties() {
    return {
      flexRowCls: "b-hbox",
      flexColCls: "b-vbox"
    };
  }
  /**
   * Returns the Core.widget.Widget[] of items to hide to clear an overflow. The `visibleItems` array should be in
   * order of the `items` in the container.
   * @param {Core.widget.Widget[]} visibleItems
   * @returns {Array}
   * @private
   */
  static getEvictionList(visibleItems) {
    const ret = visibleItems.filter((it) => it.overflowable !== "none");
    ret.forEach((it, n) => ret[n] = [n, it]);
    ret.sort((a, b) => itemScoreFn(b) - itemScoreFn(a));
    return ret;
  }
  compose() {
    const me = this, { axisProps, dock } = me, endToolElementRefs = me.getEndTools(asElementRefs), startToolElementRefs = me.getStartTools(asElementRefs);
    return {
      class: {
        [`b-dock-${dock}`]: 1,
        [`b-${dock}-toolbar`]: 1,
        [`b-${axisProps.box}`]: 1
      },
      children: {
        ...startToolElementRefs,
        toolbarContent: {
          class: {
            "b-box-center": 1,
            "b-toolbar-content": 1
          }
        },
        ...endToolElementRefs
      }
    };
  }
  get axisProps() {
    return _axisProps[this.layout.horizontal ? 0 : 1];
  }
  get contentElement() {
    return this.toolbarContent;
  }
  get overflowMenuButton() {
    var _a2;
    return (_a2 = this.tools) == null ? void 0 : _a2.overflowMenuButton;
  }
  get overflowType() {
    const { overflow } = this;
    return typeof overflow === "string" ? overflow : overflow == null ? void 0 : overflow.type;
  }
  onChildAdd(item) {
    var _a2;
    super.onChildAdd(item);
    this.processAddedLeafItem(item);
    (_a2 = item.syncRotationToDock) == null ? void 0 : _a2.call(item, this.dock);
  }
  onChildRemove(item) {
    super.onChildRemove(item);
    this.syncOverflowVisibility();
  }
  processAddedLeafItem(item) {
    FunctionHelper.after(item, "onConfigChange", this.onLeafItemConfigChange, item);
    if (item.isContainer) {
      item.eachWidget((w) => this.processAddedLeafItem(w));
    }
  }
  onInternalPaint({ firstPaint }) {
    var _a2;
    (_a2 = super.onInternalPaint) == null ? void 0 : _a2.call(this, ...arguments);
    if (firstPaint) {
      this.getConfig("overflow");
    }
  }
  updateDock(dock) {
    var _a2;
    const me = this, { layout } = me, { vertical } = layout;
    layout.vertical = canonicalDock(dock)[1];
    if (!me.initialItems) {
      if (vertical !== layout.vertical) {
        me.updateOverflow(me.overflow);
      }
      for (const item of me.childItems) {
        (_a2 = item.syncRotationToDock) == null ? void 0 : _a2.call(item, dock);
      }
    }
  }
  updateOverflow(overflow, oldOverflow) {
    var _a2, _b;
    const me = this, { axisProps, contentElement, overflowType } = me, { flexDir } = axisProps, overflowMenu = (_a2 = me.overflowMenuButton) == null ? void 0 : _a2._menu, overflowTools = {};
    if (overflowMenu) {
      if (overflow) {
        overflowMenu == null ? void 0 : overflowMenu.removeAll();
      } else {
        overflowMenu.eachWidget((overflowTwin) => {
          overflowTwin._overflowTwinOrigin.overflowTwin = null;
        });
      }
    }
    if (oldOverflow === "menu") {
      overflowTools.overflowMenuButton = null;
    } else if (oldOverflow === "scroll") {
      overflowTools.overflowScrollStart = overflowTools.overflowScrollEnd = null;
    }
    if (overflowType === "menu") {
      (_b = me.scrollable) == null ? void 0 : _b.destroy();
      contentElement.style.overflow = contentElement.style.overflowX = contentElement.style.overflowY = "";
      overflowTools.overflowMenuButton = {
        cls: {
          [`b-${flexDir}-menu`]: 1
        }
      };
    } else if (overflowType === "scroll") {
      const repeat = typeof overflow === "object" && (overflow == null ? void 0 : overflow.repeat) || defaultRepeat;
      me.scrollable = {
        [axisProps.overflow]: "hidden-scroll",
        element: contentElement,
        internalListeners: {
          scroll: "onContentScroll",
          thisObj: me
        }
      };
      overflowTools.overflowScrollStart = {
        repeat,
        invertRotate: true,
        cls: {
          [`b-${flexDir}-start-scroller`]: 1
        }
      };
      overflowTools.overflowScrollEnd = {
        repeat,
        invertRotate: true,
        cls: {
          [`b-${flexDir}-end-scroller`]: 1
        }
      };
    }
    me.tools = overflowTools;
    if (overflowType) {
      contentElement.classList.add("b-overflow");
      me.monitorResize = true;
      me.syncOverflowVisibility();
    } else {
      contentElement.classList.remove("b-overflow");
      me.monitorResize = false;
    }
  }
  onContentScroll() {
    this.syncScrollerState();
  }
  onStartScrollClick() {
    this.scrollable[this.axisProps.pos] -= 2;
  }
  onEndScrollClick() {
    this.scrollable[this.axisProps.pos] += 2;
  }
  // Only called when monitorResize is true, which is only set when we have an overflow mode
  onInternalResize() {
    super.onInternalResize(...arguments);
    if (this.isPainted) {
      this.syncOverflowVisibility();
    }
  }
  syncOverflowVisibility() {
    const me = this, { overflowType, contentElement, isVisible: isVisible2 } = me, { clientSizeProp, edgeProp, sizeProp } = me.axisProps, { overflowMenuButton, overflowScrollStart, overflowScrollEnd } = me.tools, rtl = me.rtl && me.layout.horizontal, menuOverflow = overflowType === "menu", getAvailSpace = () => Math.ceil(
      contentElement[clientSizeProp] + // Since we cannot simply hide these to remove their influence, we need to add their width/height:
      (!overflowScrollStart || overflowScrollStart.hidden ? 0 : overflowScrollStart.rectangle("outer")[sizeProp]) + (!overflowScrollEnd || overflowScrollEnd.hidden ? 0 : overflowScrollEnd.rectangle("outer")[sizeProp])
    ), getContentSize = () => {
      if (visibleItems.length === 0) {
        return 0;
      }
      const rect = visibleItems[visibleItems.length - 1].rectangle(contentElement);
      return Math.floor(rtl ? contentElement[clientSizeProp] - rect.left : rect[edgeProp]);
    };
    let availableSpace, contentSize, eviction, evictionList, it, itemSize, minifiable, minifiables, minified, overflowable, overflowItems, visibleItems;
    if (!isVisible2 || !overflowType || me.items.length === 0) {
      return;
    }
    me.inSyncOverflowVisibility = true;
    overflowMenuButton == null ? void 0 : overflowMenuButton.hide();
    me.eachWidget((item, control) => {
      minifiable = item.minifiable;
      overflowable = item.overflowable;
      overflowable = minifiable ? overflowable || minifiable : overflowable;
      if (item.floating) {
        control.down = false;
      } else {
        control.down = !overflowable;
        if (item.innerItem) {
          if (item._toolbarOverflow) {
            item.hidden = item._toolbarOverflow = false;
          }
          if (item._toolbarMinified) {
            item.minified = item._toolbarMinified = false;
          }
          if (item.isVisible) {
            minifiable && (minifiables || (minifiables = [])).push(item);
            overflowable && (visibleItems || (visibleItems = [])).push(item);
          }
        }
      }
    });
    if (visibleItems) {
      availableSpace = getAvailSpace();
      contentSize = getContentSize();
    }
    if (visibleItems && contentSize > availableSpace) {
      if (menuOverflow) {
        while (contentSize > availableSpace && (it = minifiables == null ? void 0 : minifiables.pop())) {
          itemSize = contentSize;
          it._toolbarMinified = true;
          it.minified = true;
          contentSize = getContentSize();
          itemSize -= contentSize;
          (minified || (minified = [])).push([it, itemSize]);
        }
        if (contentSize > availableSpace) {
          overflowMenuButton.show();
          availableSpace = getAvailSpace();
          evictionList = _Toolbar.getEvictionList(visibleItems);
          for (eviction of evictionList) {
            if (contentSize > availableSpace) {
              it = eviction[1];
              it._toolbarOverflowWidth = it.width;
              it._toolbarOverflow = true;
              it.hidden = true;
              visibleItems.splice(visibleItems.indexOf(it), 1);
              (overflowItems || (overflowItems = [])).push(eviction);
              contentSize = getContentSize();
            }
          }
          if (overflowItems) {
            overflowItems.sort((a, b) => a[0] - b[0]).forEach((ent, n) => overflowItems[n] = ent[1]);
            while (minified == null ? void 0 : minified.length) {
              [it, itemSize] = minified.pop();
              if (contentSize + itemSize <= availableSpace && !it._toolbarOverflow) {
                contentSize += itemSize;
                it.minified = it._toolbarMinified = false;
              }
            }
            me.syncOverflowMenuButton(overflowItems);
          } else {
            overflowMenuButton.hide();
          }
        }
      } else {
        overflowScrollEnd.show();
        overflowScrollStart.show();
        me.syncScrollerState();
      }
    } else if (!menuOverflow) {
      overflowScrollEnd == null ? void 0 : overflowScrollEnd.hide();
      overflowScrollStart == null ? void 0 : overflowScrollStart.hide();
    }
    me.inSyncOverflowVisibility = false;
  }
  syncOverflowMenuButton(overflowItems) {
    var _a2;
    const me = this, { axisProps, overflowMenuButton } = me, menu = {
      cls: "b-toolbar-overflow-menu",
      minWidth: 280,
      items: [],
      align: {
        align: axisProps.horizontal ? "t100-b100" : "r100-l100",
        axisLock: "flexible"
      }
    };
    me.addToMenu(menu, overflowItems.filter((item) => me.overflowItemFilter(item)));
    if ((_a2 = overflowMenuButton._menu) == null ? void 0 : _a2.isMenu) {
      const existingMenu = overflowMenuButton.menu, {
        toAdd,
        toRemove
      } = ArrayHelper.delta(menu.items, existingMenu.items, 1);
      existingMenu.remove(toRemove);
      if (existingMenu.items.length) {
        for (let i = toAdd.length - 1; i >= 0; i--) {
          existingMenu.insert(toAdd[i], 0);
        }
      } else {
        existingMenu.add(toAdd);
      }
    } else {
      overflowMenuButton.menu = menu;
    }
  }
  syncScrollerState() {
    const me = this, { axisProps, scrollable } = me, { overflowScrollStart, overflowScrollEnd } = me.tools, scrollPos = scrollable[axisProps.pos], maxScrollPos = scrollable[axisProps.max];
    overflowScrollStart.disabled = !scrollPos;
    overflowScrollEnd.disabled = Math.abs(Math.ceil(scrollPos)) >= Math.abs(maxScrollPos);
  }
  overflowItemFilter(item) {
    const { filter: filter2 } = this.overflow;
    return Boolean(filter2 ? filter2.call(this, item) : DomHelper.getChildElementCount(item.element));
  }
  addToMenu(menu, overflowingItems) {
    const overrides = this.horizontal ? twinOverridesHorz : twinOverrides;
    for (const item of overflowingItems) {
      const overflowTwin = item.ensureOverflowTwin(overrides, onCreateTwin);
      menu.items.push(overflowTwin);
    }
  }
  // Note that this is called with the thisObj of the tbar item being reconfigured.
  // It propagates the new setting into its toolbar overflow clone.
  onLeafItemConfigChange(origResult, { name, value }) {
    const item = this, toolbar = item.up(isToolbar), overflow = toolbar.hasConfig("overflow"), { overflowTwin } = item;
    if (!overflow || (toolbar == null ? void 0 : toolbar.inSyncOverflowVisibility) || name === "hidden" && value === item._toolbarOverflow) {
      return;
    }
    if (overflowTwin && !nonSyncedConfigs[name]) {
      overflowTwin[name] = value;
    }
    if ((toolbar == null ? void 0 : toolbar.isPainted) && item.ref !== "overflowMenuButton") {
      if (!(item.isTextField && name === "value" && (item.containsFocus || (overflowTwin == null ? void 0 : overflowTwin.containsFocus)))) {
        toolbar.syncOverflowVisibility();
      }
    }
  }
  createWidget(widget) {
    if (widget === "->") {
      widget = {
        type: "widget",
        cls: "b-toolbar-fill"
      };
    } else if (widget === "|") {
      widget = {
        type: "widget",
        cls: "b-toolbar-separator"
      };
    } else if (typeof widget === "string") {
      widget = {
        type: "widget",
        cls: "b-toolbar-text",
        html: widget
      };
    }
    const result = super.createWidget(widget);
    if (this.widgetCls) {
      result.element.classList.add(this.widgetCls);
    }
    return result;
  }
};
__publicField(_Toolbar, "$name", "Toolbar");
__publicField(_Toolbar, "type", "toolbar");
var Toolbar = _Toolbar;
Toolbar.initClass();
Toolbar._$name = "Toolbar";

// ../Core/lib/Core/widget/Panel.js
var acceptNode = (e) => !e.classList.contains("b-focus-trap") && DomHelper.isFocusable(e) ? DomHelper.NodeFilter.FILTER_ACCEPT : DomHelper.NodeFilter.FILTER_SKIP;
var emptyArray7 = [];
var emptyObject9 = {};
var emptySplit = [emptyArray7, emptyArray7];
var finishBodyWrap = (config, classes, final) => {
  const { vertical } = config;
  delete config.vertical;
  return {
    ...config,
    class: {
      ...classes,
      [`b-${vertical ? "v" : "h"}box`]: 1,
      "b-box-center": 1,
      "b-panel-bar-wrap": !final
    }
  };
};
var wrapBody = (inner, bodyWrapTag, vertical = false) => {
  const wrap = {
    vertical,
    children: inner ? [inner] : []
  };
  if (bodyWrapTag) {
    wrap.tag = bodyWrapTag;
  }
  return wrap;
};
var setCls = (elOrConfig, cls) => {
  if (elOrConfig == null ? void 0 : elOrConfig.classList) {
    elOrConfig == null ? void 0 : elOrConfig.classList.add(cls);
  } else if (elOrConfig == null ? void 0 : elOrConfig.class) {
    if (typeof elOrConfig.class === "string") {
      elOrConfig.class = { [elOrConfig.class]: 1 };
    }
    elOrConfig.class[cls] = 1;
  }
};
var barConfigs = {
  dock: 1,
  hidden: 1,
  weight: 1
};
var dockDirection = {
  //       [vertical, before]
  top: [true, true],
  bottom: [true, false],
  left: [false, true],
  right: [false, false]
};
var headerDock = {
  header: 1,
  "pre-header": 1
};
var _Panel = class _Panel extends Container.mixin(State_default, Toolable_default) {
  static get configurable() {
    return {
      localizableProperties: ["title"],
      /**
       * Controls whether the panel is collapsed (the body of the panel is hidden while only the header is
       * visible). Only valid if the panel is {@link #config-collapsible}.
       * @config {Boolean}
       * @category Layout
       */
      collapsed: {
        value: null,
        $config: null,
        default: false
      },
      /**
       * This config enables collapsibility for the panel. See {@link #config-collapsed}.
       *
       * For example:
       * ```javascript
       *      {
       *          type        : 'panel',
       *          collapsible : true
       *      }
       * ```
       * This is managed by an instance of {@link Core.widget.panel.PanelCollapser} which can be configured if an
       * object is passed for this config property:
       * ```javascript
       *      {
       *          type        : 'panel',
       *          collapsible : {
       *              direction : 'left'
       *          }
       *      }
       * ```
       * The config object form can contain a `type` property to specify the type of collapse the panel will use.
       * This property can be one of the following:
       *
       * - `'inline'` (see {@link Core.widget.panel.PanelCollapser})
       * - `'overlay'` (see {@link Core.widget.panel.PanelCollapserOverlay})
       *
       * @config {Boolean|PanelCollapserConfig|PanelCollapserOverlayConfig}
       * @category Layout
       */
      collapsible: {
        value: null,
        $config: "nullify"
      },
      /**
       * Custom CSS classes to add to the panel's body element.
       *
       * May be specified as a space separated string, or as an object in which property names
       * with truthy values are used as the class names:
       *
       * ```javascript
       *  bodyCls : {
       *      'b-my-class'     : 1,
       *      [this.extraCls]  : 1,
       *      [this.activeCls] : this.isActive
       *  }
       *  ```
       *
       * @config {String|Object}
       * @category CSS
       */
      bodyCls: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      bodyTag: null,
      bodyWrapTag: null,
      /**
       * By default, tabbing within a Panel is not contained, ie you can TAB out of the Panel
       * forwards or backwards.
       * Configure this as `true` to disallow tabbing out of the Panel, and make tabbing circular within this Panel.
       * @config {Boolean}
       * @default false
       * @category Content
       */
      trapFocus: null,
      /**
       * Get/set this Panel's title. This may only be set when a header exists. If a header
       * has been disabled by configuring the {@link #config-header} as `false`, setting it
       * will have no effect.
       * @member {String} title
       */
      /**
       * A title to display in the header. Causes creation and docking of a header
       * to the top if no header is configured.
       *
       * If specified, overrides any title configured within the {@link #config-header} configuration.
       * @default
       * @config {String}
       * @category Misc
       */
      title: null,
      /**
       * A config {@link PanelHeader object} for the panel's header or a string in place of a `title`.
       *
       * Configuring this as `false` explicitly removes the header bar, overriding any
       * {@link #config-tools} or {@link #config-title} configs.
       * @default
       * @config {String|Boolean|PanelHeader}
       * @category Content
       */
      header: null,
      stateful: ["collapsed"],
      /**
       * An object containing config defaults for corresponding {@link #config-strips} objects with a matching name.
       *
       * By default, this object contains the keys `'bbar'` and `'tbar'` to provide default config values for the
       * {@link #config-bbar} and {@link #config-tbar} configs.
       *
       * This object also contains a key named `'*'` with default config properties to apply to all strips. This
       * object provides the default `type` (`'toolbar') and {@link Core.widget.Widget#config-dock} (`'top'`)
       * property for strips.
       * @config {Object} stripDefaults
       * @internal
       * @category Content
       */
      stripDefaults: {
        "*": {
          type: "toolbar",
          dock: "top"
        },
        bbar: {
          dock: "bottom",
          weight: -1e3
        },
        tbar: {
          weight: -1e3
        }
      },
      /**
       * An object containing widgets keyed by name. By default (when no `type` is given), strips are
       * {@link Core.widget.Toolbar toolbars}. If the value assigned to a strip is an array, it is converted to
       * the toolbar's {@link Core.widget.Container#config-items}.
       *
       * The {@link #config-bbar} and {@link #config-tbar} configs are shortcuts for adding toolbars to the
       * panel's `strips`.
       *
       * Strips are arranged based on their {@link Core.widget.Widget#config-dock} and
       * {@link Core.widget.Widget#config-weight} configs.
       *
       * For widgets using a `dock` of `'top'`, `'bottom'`, `'left'`, `'right'`, `'start'` or `'end'`(an "edge
       * strip"), the higher the `weight` assigned to a widget, the closer that widget will be to the panel body.
       *
       * For widgets with `'header'` or `'pre-header'` for `dock` (a "header strip"), higher `weight` values
       * cause the widget to be placed closer to the panel's title.
       *
       * ```javascript
       *  new Panel({
       *      title : 'Test',
       *      html  : 'Panel strip test',
       *      strips : {
       *          left : [{
       *              text : 'Go'
       *          }]
       *      }
       *  });
       * ```
       * @config {Object<String,ContainerItemConfig>} strips
       * @category Content
       */
      strips: {
        value: null,
        $config: "nullify"
      },
      toolDefaults: {
        close: {
          weight: -1e3
        },
        collapse: {
          weight: -990
        }
      },
      /**
       * Config object of a footer. May contain a `dock`, `html` and a `cls` property. A footer is not a widget,
       * but rather plain HTML that follows the last element of the panel's body and {@link #config-strips}.
       *
       * The `dock` property may be `top`, `right`, `bottom`, `left`, `start` or `end`
       *
       * @config {Object|String}
       * @property {'top'|'right'|'bottom'|'left'|'start'|'end'} dock Where to dock
       * @property {String} html Html to populate the footer with
       * @property {String} cls CSS class to add to the footer
       * @default
       * @category Content
       */
      footer: null,
      /**
       * This config is used with {@link Core.widget.panel.PanelCollapserOverlay} to programmatically control the
       * visibility of the panel's body. In this mode of collapse, the body of a collapsed panel is a floating
       * overlay. Setting this config to `true` will show this element, while `false` will hide it.
       * @config {Boolean}
       * @private
       */
      revealed: null,
      /**
       * The tool Widgets as specified by the {@link #config-tools} configuration
       * (and the {@link Core.widget.Popup#config-closable} configuration in the Popup subclass).
       * Each is a {@link Core.widget.Widget} instance which may be hidden, shown and observed and styled
       * just like any other widget.
       *
       * ```javascript
       * panel.tools.add = {
       *     cls : 'b-fa b-fa-plus',
       *     handler() {
       *         // Clicked the tool
       *     }
       * }
       * ```
       * @member {Object<String,Core.widget.Tool>} tools
       * @accepts {Object<String,Core.widget.Tool|ToolConfig>}
       */
      /**
       * The {@link Core.widget.Tool tools} to add either before or after the `title` in the Panel header. Each
       * property name is the reference by which an instantiated tool may be retrieved from the live
       * `{@link Core.widget.mixin.Toolable#property-tools}` property.
       * ```javascript
       * new Panel({
       *     ...
       *     tools : {
       *         add : {
       *             cls : 'b-fa b-fa-plus',
       *             handler() {
       *                 // Clicked the tool
       *             }
       *         }
       *     }
       * });
       * ```
       * @config {Object<string,ToolConfig>} tools
       * @category Content
       */
      /**
       * Get toolbar {@link Core.widget.Toolbar} docked to the top of the panel
       * @member {Core.widget.Toolbar} tbar
       * @readonly
       * @category Content
       */
      /**
       * A Config object representing the configuration of a {@link Core.widget.Toolbar},
       * or array of config objects representing the child items of a Toolbar.
       *
       * This creates a toolbar docked to the top of the panel immediately below the header.
       * @config {Array<ContainerItemConfig|String>|ToolbarConfig}
       * @category Content
       */
      tbar: null,
      /**
       * Get toolbar {@link Core.widget.Toolbar} docked to the bottom of the panel
       * @member {Core.widget.Toolbar} bbar
       * @readonly
       * @category Content
       */
      /**
       * A Config object representing the configuration of a {@link Core.widget.Toolbar},
       * or array of config objects representing the child items of a Toolbar.
       *
       * This creates a toolbar docked to the bottom of the panel immediately above the footer.
       * @config {Array<ContainerItemConfig|String>|ToolbarConfig}
       * @category Content
       */
      bbar: null,
      role: "region"
    };
  }
  //endregion
  /**
   * A header {@link #config-tools tool} has been clicked.
   * @event toolClick
   * @param {Core.widget.Tool} source - This Panel.
   * @param {Core.widget.Tool} tool - The tool which is being clicked.
   */
  /**
   * Fires when a Panel is collapsed using the {@link Core.widget.Panel#config-collapsible} setting.
   * @event collapse
   * @param {Core.widget.Panel} source - This Panel.
   */
  /**
   * Fires when a Panel is expanded using the {@link Core.widget.Panel#config-collapsible} setting.
   * @event expand
   * @param {Core.widget.Panel} source - This Panel.
   */
  //region Composition
  updateElement(element, oldElement) {
    const result = super.updateElement(element, oldElement);
    if (this.titleElement) {
      DomHelper.setAttributes(this.ariaElement, {
        "aria-describedby": this.titleElement.id
      });
    }
    return result;
  }
  compose() {
    const me = this, { collapsible, focusable, hasItems, revealed, tools } = me, header = me.composeHeader(), horz = (header == null ? void 0 : header.class["b-dock-left"]) || (header == null ? void 0 : header.class["b-dock-right"]);
    let body = me.composeBody(), key = "bodyWrapElement";
    if (collapsible) {
      [key, body] = collapsible.wrapCollapser(key, body);
    }
    return {
      tabIndex: hasItems && focusable !== false || focusable ? 0 : null,
      class: {
        [`b-panel-collapsible-${collapsible == null ? void 0 : collapsible.type}`]: collapsible,
        [`b-panel-collapse-${collapsible == null ? void 0 : collapsible.collapseDir}`]: collapsible,
        [`b-${horz ? "h" : "v"}box`]: 1,
        "b-panel-collapsible": collapsible,
        "b-panel-has-header": header,
        "b-panel-has-tools": tools ? 1 : 0,
        "b-panel-overlay-revealed": revealed
      },
      children: {
        topFocusTrap: {
          "aria-hidden": true,
          tabIndex: 0,
          class: {
            "b-focus-trap": 1
          }
        },
        // Note: we always put header before bodyWrap since it is likely (though untested) to be better for
        // a11y. We use flexbox order to make the right/bottom docking appear correct but it is likely that
        // the DOM order of the <header> element vs (optional) <footer> is important to screen readers.
        headerElement: header,
        [key]: body,
        bottomFocusTrap: {
          "aria-hidden": true,
          tabIndex: 0,
          class: {
            "b-focus-trap": 1,
            "b-end-focus-trap": 1
          }
        }
      }
    };
  }
  composeBody() {
    var _a2, _b;
    const me = this, { bodyCls, bodyConfig, bodyWrapTag, footer, uiClassList } = me, strips = ObjectHelper.values(me.strips, (k, v) => !dockDirection[v == null ? void 0 : v.dock]).sort(me.byWeightSortFn), innermostStrips = {
      top: null,
      right: null,
      bottom: null,
      left: null
    };
    let bar, before, dock, i, name, vertical, wrap;
    if (footer) {
      dock = footer.dock || "bottom";
      strips.unshift({
        dock,
        element: {
          tag: "footer",
          reference: "footerElement",
          html: typeof footer === "string" ? footer : footer.html,
          class: {
            ...uiClassList,
            [`b-dock-${dock}`]: 1,
            [`${footer.cls || ""}`]: 1
          }
        }
      });
    }
    if (bodyCls) {
      if (!bodyConfig[name = "className"]) {
        name = "class";
      }
      bodyConfig[name] = new DomClassList(bodyConfig[name]).assign(bodyCls);
    }
    for (i = strips.length; i-- > 0; ) {
      bar = strips[i];
      [vertical, before] = dockDirection[bar.dock];
      if (!wrap) {
        wrap = wrapBody(bodyConfig, bodyWrapTag, vertical);
      } else if (wrap.vertical !== vertical) {
        wrap = wrapBody(finishBodyWrap(wrap, uiClassList), "", vertical);
      }
      wrap.children[before ? "unshift" : "push"](bar.element);
      innermostStrips[bar.dock] = bar;
    }
    setCls(innermostStrips.top, "b-innermost");
    setCls(innermostStrips.right, "b-innermost");
    setCls(innermostStrips.bottom, "b-innermost");
    setCls(innermostStrips.left, "b-innermost");
    const body = finishBodyWrap(wrap || wrapBody(bodyConfig, bodyWrapTag), uiClassList, true);
    body.class[`${(_a2 = me.layout) == null ? void 0 : _a2.containerCls}-panel`] = Boolean((_b = me.layout) == null ? void 0 : _b.containerCls);
    body.class["b-panel-body-wrap"] = 1;
    body.class[`b-${me.$$name.toLowerCase()}-body-wrap`] = 1;
    return body;
  }
  get hasHeader() {
    if (this.header === false) {
      return false;
    }
    const { header, title, tools, parent } = this, hasVisibleTools = this.maximizable || Object.values(tools || {}).some((tool) => !tool.hidden);
    return header || !(parent == null ? void 0 : parent.suppressChildHeaders) && (title || hasVisibleTools);
  }
  get rootUiClass() {
    return _Panel;
  }
  composeHeader(force) {
    var _a2;
    const me = this;
    if (!me.hasHeader && !force) {
      return;
    }
    const header = me.header || {}, dock = header.dock || "top", [before, after] = me.splitHeaderItems({ as: "element", dock }), classes = me.$meta.hierarchy, title = me.composeTitle(header), cls = new DomClassList({
      [`b-dock-${dock}`]: 1,
      ...me.uiClassList
    }, header.cls);
    let i, name;
    for (i = classes.indexOf(_Panel); i < classes.length; ++i) {
      name = classes[i].$$name;
      if (name !== "Grid") {
        cls[`b-${name.toLowerCase()}-header`] = 1;
      }
    }
    const headerConfig = {
      tag: "header",
      class: cls,
      children: [
        ...before,
        title,
        ...after
      ]
    };
    return ((_a2 = me.collapsible) == null ? void 0 : _a2.composeHeader(headerConfig)) || headerConfig;
  }
  composeTitle(header) {
    var _a2;
    const title = typeof header === "string" ? header : this.title || header.title, titleConfig = {
      reference: "titleElement",
      id: `${this.id}-panel-title`,
      html: title != null ? title : "\xA0",
      class: {
        [`b-align-${header.titleAlign || "start"}`]: 1,
        "b-header-title": 1,
        ...this.uiClassList
      }
    };
    if (ObjectHelper.isObject(title)) {
      delete titleConfig.html;
      ObjectHelper.merge(titleConfig, title);
    }
    return ((_a2 = this.collapsible) == null ? void 0 : _a2.composeTitle(titleConfig)) || titleConfig;
  }
  // Needed to make title go through recompose
  updateTitle() {
  }
  afterRecompose() {
    var _a2;
    super.afterRecompose();
    const me = this, { headerElement } = me;
    (_a2 = me._headerClickDetacher) == null ? void 0 : _a2.call(me);
    me._headerClickDetacher = headerElement && EventHelper.on({
      element: headerElement,
      // Click might have lead to panel being destroyed (clicking close tool with `hideAction : 'destroy'`)
      click: (ev) => {
        var _a3;
        return (_a3 = me.trigger) == null ? void 0 : _a3.call(me, "headerClick", { event: ev });
      }
    });
  }
  onHeaderClick(info) {
    var _a2;
    (_a2 = this.collapsible) == null ? void 0 : _a2.onHeaderClick(info);
  }
  onInternalPaint() {
    var _a2;
    super.onInternalPaint(...arguments);
    (_a2 = this.collapsible) == null ? void 0 : _a2.onPanelPaint(this);
  }
  splitHeaderItems({ as, dock, alt: alt2 } = emptyObject9) {
    var _a2, _b, _c, _d;
    const me = this, asElement = as === "element", { collapsed } = me, endTools = me.getEndTools({ alt: alt2 }), startTools = me.getStartTools({ alt: alt2 }), strips = ObjectHelper.values(
      me.strips,
      (k, v) => !headerDock[v == null ? void 0 : v.dock] && v.isCollapsified({ collapsed, alt: alt2 })
    );
    let ret = emptySplit, after, before, i;
    if (strips.length + endTools.length + startTools.length) {
      ret = [
        // the problem w/mixing tools and strips is the strip weight needs to do two jobs (one when docked
        // in the body and one when docked in the header)
        before = [
          ...startTools,
          ...strips.filter((e) => e.dock === "pre-header").sort(me.byWeightSortFn)
        ],
        after = [
          ...strips.filter((e) => e.dock === "header").sort(me.byWeightReverseSortFn),
          ...endTools
        ]
      ];
      for (i = 0; i < before.length; ++i) {
        dock && ((_b = (_a2 = before[i]).syncRotationToDock) == null ? void 0 : _b.call(_a2, dock));
        if (asElement) {
          before[i] = before[i].element;
        }
      }
      for (i = 0; i < after.length; ++i) {
        dock && ((_d = (_c = after[i]).syncRotationToDock) == null ? void 0 : _d.call(_c, dock));
        if (asElement) {
          after[i] = after[i].element;
        }
      }
    }
    return ret;
  }
  set bodyConfig(bodyConfig) {
    this._bodyConfig = bodyConfig;
  }
  get bodyConfig() {
    const me = this, { bodyTag } = me, result = ObjectHelper.merge({
      reference: "bodyElement",
      className: {
        ...me.getStaticWidgetClasses(_Panel, "-content"),
        "b-box-center": 1,
        "b-text-content": me.textContent && me.hasNoChildren
      }
    }, me._bodyConfig);
    if (bodyTag) {
      result.tag = bodyTag;
    }
    if (me.initializingElement || !me._element) {
      result.html = me.content || me._html;
    }
    return result;
  }
  //endregion
  //region Configs
  changeBodyCls(cls) {
    return DomClassList.from(cls);
  }
  changeTbar(bar) {
    this.getConfig("strips");
    this.strips = {
      tbar: bar
    };
    return this.strips.tbar;
  }
  changeBbar(bar) {
    this.getConfig("strips");
    this.strips = {
      bbar: bar
    };
    return this.strips.bbar;
  }
  // Override to iterate docked Toolbars in the correct order around contained widgets.
  get childItems() {
    var _a2;
    const me = this, strips = ObjectHelper.values(me.strips, (k, v) => !dockDirection[v == null ? void 0 : v.dock]).sort(me.byWeightSortFn), [before, after] = me.splitHeaderItems(), [before2, after2] = ((_a2 = me.collapsible) == null ? void 0 : _a2.splitHeaderItems()) || emptySplit;
    return [
      ...before,
      ...before2,
      ...after,
      ...after2,
      ...strips.filter((b) => dockDirection[b.dock][1]),
      // the "before" strips come before the items
      ...me._items || emptyArray7,
      ...strips.filter((b) => !dockDirection[b.dock][1]).reverse()
    ];
  }
  changeStrips(strips, oldStrips) {
    const me = this, manager = me.$strips || (me.$strips = new DynamicObject({
      configName: "strips",
      factory: Widget,
      inferType: false,
      // the name of a bar in the strips object is not its type
      owner: me,
      created(instance) {
        var _a2;
        const { dock } = instance;
        if (!headerDock[dock] && !dockDirection[dock]) {
          throw new Error(
            `Invalid dock value "${dock}"; must be: top, left, right, bottom, header, or pre-header`
          );
        }
        FunctionHelper.after(instance, "onConfigChange", (ret, { name }) => {
          if (barConfigs[name]) {
            me.onConfigChange({
              name: "strips",
              value: manager.target
            });
          }
        });
        instance.innerItem = false;
        me.onChildAdd(instance);
        instance.parent = me;
        (_a2 = instance.layout) == null ? void 0 : _a2.renderChildren();
        if (instance.hasItems) {
          me.hasItems = true;
        }
      },
      setup(config, name) {
        config = ObjectHelper.merge(ObjectHelper.clone(me.stripDefaults["*"]), me.stripDefaults[name], config);
        config.parent = me;
        config.ref = name;
        return config;
      },
      transform(config) {
        if (Array.isArray(config)) {
          config = {
            items: config
          };
        }
        return config || null;
      }
    }));
    manager.update(strips);
    if (!oldStrips) {
      return manager.target;
    }
  }
  //endregion
  //region Collapse/Expand
  /**
   * This property is `true` if the panel is currently collapsing.
   * @property {Boolean}
   * @readonly
   * @category Layout
   */
  get collapsing() {
    var _a2;
    return (_a2 = this.collapsible) == null ? void 0 : _a2.collapsing;
  }
  /**
   * This property is `true` if the panel is currently either collapsing or expanding.
   * @property {Boolean}
   * @readonly
   * @internal
   * @category Layout
   */
  get collapsingExpanding() {
    var _a2;
    return (_a2 = this.collapsible) == null ? void 0 : _a2.collapsingExpanding;
  }
  /**
   * This property is `true` if the panel is currently expanding.
   * @property {Boolean}
   * @readonly
   * @category Layout
   */
  get expanding() {
    var _a2;
    return (_a2 = this.collapsible) == null ? void 0 : _a2.expanding;
  }
  changeCollapsed(value) {
    const me = this, { collapsible } = me;
    me.recompose.flush();
    value = Boolean(value);
    if (!collapsible || me.changingCollapse || !me.isPainted) {
      return value;
    }
    collapsible == null ? void 0 : collapsible.collapse({
      animation: null,
      collapsed: value
    });
  }
  changeCollapsible(collapsible, was) {
    const me = this;
    me.getConfig("tools");
    if (collapsible) {
      if (collapsible === true) {
        collapsible = {};
      } else if (typeof collapsible === "string") {
        collapsible = {
          [dockDirection[collapsible] ? "direction" : "type"]: collapsible
        };
      }
    }
    return PanelCollapser.reconfigure(was, collapsible, {
      owner: me,
      defaults: {
        panel: me
      },
      cleanup() {
        if (me.collapsed) {
          was.collapse({
            animation: null,
            collapsed: false
          });
          me._collapsed = 1;
        }
      }
    });
  }
  updateCollapsible(collapsible) {
    const me = this, tools = collapsible == null ? void 0 : collapsible.toolsConfig;
    me.tools = {
      collapse: (tools == null ? void 0 : tools.collapse) || null,
      recollapse: (tools == null ? void 0 : tools.recollapse) || null
    };
    if (collapsible && me.isPainted && me.collapsed) {
      me._collapsed = 1;
    }
    if (me.collapsed === 1) {
      me.collapsed = true;
    }
  }
  _collapse(collapsed, options) {
    var _a2;
    if (options !== true && options !== void 0) {
      if (options === false) {
        collapsed.collapsed = !collapsed.collapsed;
      } else if (typeof options === "number") {
        collapsed.animation = {
          duration: options
        };
      } else if (options === null) {
        collapsed.animation = options;
      } else if (options === true) {
      } else if ("animation" in options) {
        ObjectHelper.merge(collapsed, options);
      } else {
        collapsed.animation = options;
      }
    }
    return (_a2 = this.collapsible) == null ? void 0 : _a2.collapse(collapsed);
  }
  collapse(options) {
    return this._collapse({ collapsed: true }, options);
  }
  expand(options) {
    return this._collapse({ collapsed: false }, options);
  }
  /**
   * Toggles collapsed state of the panel.
   * Collapses an expanded or expands a collapsed panel.
   * @privateparam [options] options object with animation config (for internal use)
   * @returns {Boolean} `true` value for collapsed panel or `false` for expanded
   */
  toggleCollapsed(options) {
    return this.collapsed ? this.expand(options) : this.collapse(options);
  }
  //endregion
  //region Misc
  get expandedHeaderDock() {
    var _a2, _b, _c;
    return (_c = (_b = this._expandedHeaderDock) != null ? _b : (_a2 = this.initialConfig.header) == null ? void 0 : _a2.dock) != null ? _c : "top";
  }
  set expandedHeaderDock(v) {
    this._expandedHeaderDock = v == null ? void 0 : v.toLowerCase();
  }
  updateHeader(header) {
    if (!this.changingCollapse) {
      this.expandedHeaderDock = header == null ? void 0 : header.dock;
    }
  }
  updateTrapFocus(trapFocus) {
    var _a2;
    const me = this;
    me.element.classList[trapFocus ? "add" : "remove"]("b-focus-trapped");
    me.focusTrapListener = (_a2 = me.focusTrapListener) == null ? void 0 : _a2.call(me);
    if (trapFocus) {
      me.focusTrapListener = EventHelper.on({
        element: me.element,
        focusin: "onFocusTrapped",
        delegate: ".b-focus-trap",
        thisObj: me
      });
      if (!me.treeWalker) {
        me.treeWalker = this.setupTreeWalker(me.element, DomHelper.NodeFilter.SHOW_ELEMENT, acceptNode);
      }
    }
  }
  setupTreeWalker(root, whatToShow, filter2) {
    return document.createTreeWalker(root, whatToShow, filter2);
  }
  onFocusTrapped(e) {
    const me = this, treeWalker = me.treeWalker;
    if (e.target === me.bottomFocusTrap) {
      treeWalker.currentNode = me.topFocusTrap;
      treeWalker.nextNode();
    } else if (e.target === me.topFocusTrap) {
      treeWalker.currentNode = me.bottomFocusTrap;
      treeWalker.previousNode();
    } else {
      return;
    }
    me.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }
  get focusElement() {
    return this.hasItems && (super.focusElement || this.element);
  }
  get contentElement() {
    return this.element && this.bodyElement;
  }
  get widgetClassList() {
    var _a2;
    const me = this, result = super.widgetClassList;
    if (me.hasHeader) {
      result.push("b-panel-has-header", `b-header-dock-${((_a2 = me.header) == null ? void 0 : _a2.dock) || "top"}`);
    }
    if (me.tbar) {
      result.push("b-panel-has-top-toolbar");
    }
    if (me.bbar) {
      result.push("b-panel-has-bottom-toolbar");
    }
    return result;
  }
};
//region Config
__publicField(_Panel, "$name", "Panel");
__publicField(_Panel, "type", "panel");
var Panel = _Panel;
Panel.initClass();
Panel._$name = "Panel";

// ../Core/lib/Core/widget/Popup.js
var _Popup = class _Popup extends Panel {
  static get configurable() {
    return {
      /**
       * Auto show flag for Popup.
       * If truthy then Popup is shown automatically upon hover.
       * @config {Boolean}
       * @default
       */
      autoShow: true,
      /**
       * By default, a Popup is transient, and will {@link #function-close} when the user clicks or
       * taps outside its owned widgets and when focus moves outside its owned widgets.
       *
       * **Note**: {@link #config-modal Modal} popups won't {@link #function-close} when focus moves outside even
       * if autoClose is `true`.
       *
       * Configure as `false` to make a Popup non-transient.
       * @config {Boolean}
       * @default
       */
      autoClose: true,
      /**
       * Show popup when user clicks the element that it is anchored to. Cannot be combined with showOnHover
       * @config {Boolean}
       * @default
       */
      showOnClick: false,
      /**
       * DOM element to attach popup.
       * @config {HTMLElement}
       */
      forElement: null,
      monitorResize: true,
      floating: true,
      hidden: true,
      axisLock: true,
      // Flip edges if align violates constrainTo
      hideAnimation: {
        opacity: {
          from: 1,
          to: 0,
          duration: ".3s",
          delay: "0s"
        }
      },
      showAnimation: {
        opacity: {
          from: 0,
          to: 1,
          duration: ".4s",
          delay: "0s"
        }
      },
      stripDefaults: {
        bbar: {
          layout: {
            justify: "flex-end"
          }
        }
      },
      testConfig: {
        hideAnimation: null,
        showAnimation: null
      },
      /**
       * The action to take when calling the {@link #function-close} method.
       * By default, the popup is hidden.
       *
       * This may be set to `'destroy'` to destroy the popup upon close.
       * @config {'hide'|'destroy'}
       * @default
       */
      closeAction: "hide",
      /**
       * By default, tabbing within a Popup is circular - that is it does not exit.
       * Configure this as `false` to allow tabbing out of the Popup.
       * @config {Boolean}
       * @default
       */
      trapFocus: true,
      /**
       * By default a Popup is focused when it is shown.
       * Configure this as `false` to prevent automatic focus on show.
       * @config {Boolean}
       * @default
       */
      focusOnToFront: true,
      /**
       * Show a tool in the header to close this Popup, and allow `ESC` close it.
       * The tool is available in the {@link Core.widget.mixin.Toolable#property-tools} object
       * under the name `close`. It uses the CSS class `b-popup-close` to apply a
       * default close icon. This may be customized with your own CSS rules.
       * @default false
       * @config {Boolean}
       */
      closable: null,
      /**
       * Show a tool in the header to maximize this popup
       * @config {Boolean}
       * @default false
       */
      maximizable: null,
      /**
       * Optionally show an opaque mask below this Popup when shown.
       * Configure this as `true` to show the mask.
       *
       * When a Popup is modal, it defaults to being {@link Core.widget.Widget#config-centered}.
       * Also, it won't {@link #function-close} when focus moves outside even if {@link #config-autoClose} is
       * `true`.
       *
       * The default action is to focus the popup.
       *
       * Usage:
       * ```javascript
       * new Popup({
       *     title  : 'I am modal',
       *     modal  : {
       *         closeOnMaskTap : true
       *     },
       *     height : 100,
       *     width  : 200
       * });
       * ```
       *
       * @default false
       * @config {Boolean|Object}
       * @property {Boolean} [closeOnMaskTap=false] Specify as `true` to close when mask is tapped.
       * @property {Boolean} [transparent=false] Specify as `true` to use a transparent mask.
       */
      modal: null,
      /**
       * Set to `true` to make this widget take all available space in the visible viewport.
       * @member {Boolean} maximized
       * @category Float & align
       */
      /**
       * Set to `true` to make this widget take all available space in the visible viewport.
       * @config {Boolean}
       * @default false
       * @category Float & align
       */
      maximized: null,
      tools: {
        close: {
          cls: "b-popup-close",
          handler: "close",
          weight: -1e3,
          ariaLabel: "L{Popup.close}",
          hidden: true
          // shown when closable set to true
        },
        maximize: {
          cls: "b-popup-expand",
          handler: "toggleMaximized",
          weight: -999,
          hidden: true
          // shown when maximizable set to true
        }
      },
      highlightReturnedFocus: true,
      role: "dialog"
    };
  }
  //endregion
  //region Init & destroy
  finalizeInit() {
    const me = this, { forElement } = me;
    me.anchoredTo = forElement;
    me.initialAnchor = me.anchor;
    if (forElement && me.showOnClick) {
      if (!me.initialConfig.autoShow) {
        me.autoShow = false;
      }
      EventHelper.on({
        element: forElement,
        click: "onElementUserAction",
        thisObj: me
      });
    }
    super.finalizeInit();
    if (me.autoShow && (!forElement || DomHelper.isVisible(forElement))) {
      if (me.autoShow === true) {
        me.show();
      } else {
        me.setTimeout(() => me.show(), me.autoShow);
      }
    }
  }
  onInternalPaint({ firstPaint }) {
    var _a2;
    (_a2 = super.onInternalPaint) == null ? void 0 : _a2.call(this, ...arguments);
    const me = this;
    if (firstPaint && me.headerElement) {
      EventHelper.on({
        element: me.headerElement,
        dblclick: me.onHeaderDblClick,
        thisObj: me
      });
    }
  }
  doDestroy() {
    this.syncModalMask();
    super.doDestroy();
  }
  //endregion
  compose() {
    const { hasNoChildren, textContent } = this;
    return {
      class: {
        // Popup has extra CSS responsibilities at the top level.
        // The CSS needs to know whether it should impose a max-width.
        "b-text-popup": Boolean(textContent && hasNoChildren)
      }
    };
  }
  //region Show/hide
  /**
   * Performs the configured {@link #config-closeAction} upon this popup.
   * By default, the popup hides. The {@link #config-closeAction} may be
   * configured as `'destroy'`.
   * @fires beforeclose If popup is not hidden
   */
  close() {
    const me = this;
    if (!me._hidden && me.trigger("beforeClose") !== false || // we should destroy it even if it's hidden just omit beforeclose event
    me._hidden && me.closeAction === "destroy") {
      me.modal && me.closeAction === "destroy" && me.revertFocus();
      me.unmask();
      if (me.containsFocus && me.highlightReturnedFocus) {
        me.setTimeout(() => me.element.classList.add("b-using-keyboard"), 0);
      }
      return me[me.closeAction]();
    }
  }
  toggleMaximized() {
    this.maximized = !this.maximized;
  }
  updateMaximized(value) {
    DomHelper.toggleClasses(this.element, ["b-maximized"], value);
  }
  //endregion
  //region Events
  onInternalKeyDown(event) {
    const me = this;
    if (event.key === "Escape") {
      event.stopImmediatePropagation();
      if (me.floating || me.positioned) {
        me.close(true);
      } else if (me.collapsible) {
        if (me.revealed) {
          me.collapsible.toggleReveal();
        } else {
          me.collapse();
        }
      }
    }
  }
  onDocumentMouseDown({ event }) {
    const me = this, { owner } = me, { target } = event;
    if (event.type !== "touchend" && (owner == null ? void 0 : owner.isButton) && owner._menu === me && owner.element.contains(target)) {
      event.preventDefault();
      return false;
    }
    if (me.modal && target === _Popup.modalMask) {
      event.preventDefault();
      if (me.modal.closeOnMaskTap) {
        me.close();
      } else if (!me.containsFocus) {
        me.focus();
      }
    } else if (!me.owns(target) && me.autoClose && !me.containsFocus) {
      me.close();
    }
  }
  get isTopModal() {
    return DomHelper.isVisible(_Popup.modalMask) && this.element.previousElementSibling === _Popup.modalMask;
  }
  onFocusIn(e) {
    const activeEl = DomHelper.getActiveElement(this);
    super.onFocusIn(e);
    if (DomHelper.getActiveElement(this) === activeEl && e.target === this.element) {
      this.focus();
    }
  }
  onFocusOut(e) {
    const usingVirtualKeyboard = globalThis.visualViewport && globalThis.visualViewport.height < document.documentElement.clientHeight - 1;
    if (!usingVirtualKeyboard && !this.modal && this.autoClose) {
      this.close();
    }
    super.onFocusOut(e);
  }
  onShow() {
    var _a2;
    const me = this;
    if (me.autoClose || me.modal) {
      me.addDocumentMouseDownListener();
    }
    if (me.focusOnToFront) {
      me.focus();
    }
    (_a2 = super.onShow) == null ? void 0 : _a2.call(this);
    me.syncModalMask();
  }
  addDocumentMouseDownListener() {
    if (!this.mouseDownRemover) {
      this.mouseDownRemover = GlobalEvents_default.ion({
        globaltap: "onDocumentMouseDown",
        thisObj: this
      });
    }
  }
  updateModal(modal) {
    if (modal) {
      this.floating = true;
    }
  }
  syncModalMask() {
    const me = this, {
      modal,
      element
    } = me;
    element.setAttribute("aria-modal", Boolean(modal));
    if (modal && me.isVisible) {
      if (typeof me._x !== "number" && typeof me._y !== "number") {
        me.centered = true;
        me.anchor = false;
      }
      me.modalMask.classList.remove("b-hide-display");
      me.modalMask.classList.toggle("b-modal-transparent", Boolean(modal.transparent));
      element.classList.add("b-modal");
    } else if (me.isPainted) {
      element.classList.remove("b-modal");
      const remainingModals = me.floatRoot.querySelectorAll(".b-modal"), topModal = remainingModals.length ? _Popup.fromElement(remainingModals[remainingModals.length - 1], "popup") : null;
      if (topModal) {
        topModal.syncModalMask();
      } else {
        _Popup.modalMask.classList.add("b-hide-display");
      }
    }
  }
  onHide() {
    var _a2, _b;
    const me = this;
    (_a2 = me.mouseDownRemover) == null ? void 0 : _a2.call(me);
    me.mouseDownRemover = null;
    (_b = super.onHide) == null ? void 0 : _b.call(this);
    me.syncModalMask();
  }
  onElementUserAction() {
    this.show();
  }
  onHeaderDblClick() {
    if (this.maximizable) {
      this.toggleMaximized();
    }
  }
  //endregion
  updateClosable(closable) {
    this.tools.close.hidden = !closable;
  }
  updateMaximizable(maximizable) {
    this.tools.maximize.hidden = !maximizable;
  }
  /**
   * Returns the modal mask element for this Popup correctly positioned just below this Popup.
   * @internal
   */
  get modalMask() {
    const { modalMask } = _Popup;
    if (modalMask.nextElementSibling !== this.element) {
      this.floatRoot.insertBefore(modalMask, this.element);
    }
    return modalMask;
  }
  /**
   * Returns the modal mask element. It does NOT guarantee its placement in the DOM relative
   * to any Popup. To get the modal mask for a particular Popup, use the instance property.
   * @internal
   */
  static get modalMask() {
    if (!this._modalMask) {
      this._modalMask = DomHelper.createElement({
        className: "b-modal-mask b-hide-display"
      });
      EventHelper.on({
        element: this._modalMask,
        wheel: (e) => e.preventDefault()
      });
    }
    return this._modalMask;
  }
};
//region Config
__publicField(_Popup, "$name", "Popup");
__publicField(_Popup, "type", "popup");
var Popup = _Popup;
Popup.initClass();
Popup._$name = "Popup";

// ../Core/lib/Core/widget/MenuItem.js
var bIcon2 = /^b-icon-/;
var bFa2 = /^b-fa-/;
var MenuItem = class extends Widget {
  static get configurable() {
    return {
      /**
       * If configured with a `Boolean` value, a checkbox is displayed
       * as the start icon, and the {@link #event-toggle} event is fired
       * when the checked state changes.
       * @config {Boolean}
       */
      checked: null,
      /**
       * Set to `true` to display a border above this menu item, if there are other visible menu items before it.
       * @config {Boolean}
       * @default false
       */
      separator: null,
      /**
       * Indicates that this menu item is part of a group where only one can be checked. Assigning a value
       * also sets `toggleable` to `true`.
       * ```
       * const yesButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'Yes'
       * });
       *
       * const noButton = new Button({
       *    toggleGroup : 'yesno',
       *    text        : 'No'
       * });
       * ```
       * @prp {String}
       */
      toggleGroup: null,
      /**
       * Returns the instantiated menu widget as configured by {@link #config-menu}.
       * @member {Core.widget.Widget} menu
       * @readonly
       */
      /**
       * A submenu configuration object, or an array of MenuItem configuration
       * objects from which to create a submenu.
       *
       * Configuration object example:
       * ```javascript
       * new Menu({
       *     // Menu items
       *     items : {
       *         move : {
       *             text : 'Main item',
       *             menu : {
       *                 // Submenu items
       *                 firstItem : {
       *                     text : 'Sub-item 1',
       *                     onItem({ eventRecord }) {}
       *                 },
       *                 secondItem : {
       *                     text : 'Sub-item 2',
       *                     onItem({ eventRecord }) {}
       *                 }
       *             }
       *         }
       *     }
       * });
       * ```
       *
       * Array of items example:
       * ```javascript
       * new Menu({
       *     // Menu items
       *     items : {
       *         move : {
       *             text : 'Main item',
       *             // Submenu items
       *             menu : [
       *                 {
       *                     text : 'Sub-item 1',
       *                     onItem({ eventRecord }) {}
       *                 },
       *                 {
       *                     text : 'Sub-item 2',
       *                     onItem({ eventRecord }) {}
       *                 }
       *             ]
       *         }
       *     }
       * });
       * ```
       *
       * Note that this does not have to be a Menu. The `type` config can be used to specify any widget as the submenu.
       * ```javascript
       * new Menu({
       *     // Menu items
       *     items : {
       *         move : {
       *             text : 'Main item',
       *             // Submenu items
       *             menu : [
       *                 {
       *                     type  : 'textfield',
       *                     label : 'Type here'
       *                 },
       *                 {
       *                     type : 'button',
       *                     text : 'Confirm'
       *                 }
       *             ]
       *         }
       *     }
       * });
       * ```
       *
       * @config {Object<String,MenuItemConfig|ContainerItemConfig>|Array<MenuItemConfig|ContainerItemConfig>}
       */
      menu: {
        value: null,
        $config: ["lazy", "nullify"]
      },
      /**
       * Item icon class.
       *
       * All [Font Awesome](https://fontawesome.com/cheatsheet) icons may also be specified as `'b-fa-' + iconName`.
       *
       * Otherwise this is a developer-defined CSS class string which results in the desired icon.
       * @config {String}
       */
      icon: null,
      /**
       * The text to be displayed in the item
       * @prp {String} text
       */
      /**
       * By default, upon activate, non-checkbox menu items will collapse
       * the owning menu hierarchy.
       *
       * Configure this as `false` to cause the menu to persist after
       * activating an item
       * @config {Boolean}
       */
      closeParent: null,
      /**
       * If provided, turns the menu item into a link
       * @config {String}
       */
      href: null,
      /**
       * The `target` attribute for the {@link #config-href} config
       * @config {'_self'|'_blank'|'_parent'|'_top'|null}
       */
      target: null,
      localizableProperties: ["text"],
      role: "menuitem",
      closeMenuDelay: 200
    };
  }
  updateElement(element, oldElement) {
    const result = super.updateElement(element, oldElement);
    if (typeof this.checked === "boolean") {
      this.role = "menuitemcheckbox";
    }
    this.ariaHasPopup = this.hasMenu ? "menu" : false;
    return result;
  }
  compose() {
    var _a2;
    const me = this, { checked, href, hasMenu, separator, target, text, toggleGroup } = me, isCheckItem = typeof checked === "boolean", icon = me.icon || (isCheckItem ? "b-fw-icon" : ""), checkCls = `b-icon-${toggleGroup ? "radio-" : ""}`, hasCustomContent = typeof text === "object";
    return {
      tag: href ? "a" : "div",
      tabIndex: -1,
      href,
      target,
      class: {
        "b-has-submenu": hasMenu,
        "b-checked": checked,
        // Support both separator config and directly setting separator class
        "b-separator": separator || ((_a2 = me.cls) == null ? void 0 : _a2["b-separator"])
      },
      dataset: {
        group: me.toggleGroup
      },
      // Only set aria-checked if it's a check item
      [isCheckItem ? "aria-checked" : ""]: checked,
      // Only set expanded if there's a submenu to expand
      [hasMenu ? "aria-expanded" : ""]: false,
      children: {
        iconElement: icon && {
          // This element is a purely visual cue with no meaning to the A11Y tree
          "aria-hidden": true,
          tag: "i",
          class: {
            "b-fa": bFa2.test(icon),
            "b-icon": bIcon2.test(icon),
            "b-menuitem-icon": 1,
            [`${checkCls}checked`]: checked === true,
            [`${checkCls}unchecked`]: checked === false,
            ...DomClassList.normalize(icon, "object")
          }
        },
        textElement: {
          tag: "span",
          html: hasCustomContent ? null : text,
          class: {
            "b-menu-text": 1,
            "b-menu-custom-content": hasCustomContent
          },
          children: hasCustomContent ? [text] : null
        },
        subMenuIcon: hasMenu && {
          // This element is a purely visual cue with no meaning to the A11Y tree
          "aria-hidden": true,
          tag: "i",
          class: {
            "b-fw-icon": 1,
            "b-icon-sub-menu": 1
          }
        }
      }
    };
  }
  /**
   * Actions this item. Fires the {@link #event-item} event, and if this is a {@link #config-checked} item, toggles
   * the checked state, firing the {@link #event-toggle} event.
   */
  doAction(event) {
    const item = this, menu = this.parent, itemEvent = { menu, item, element: item.element, bubbles: true, domEvent: event };
    if (typeof item.checked === "boolean") {
      const newCheckedState = !item.checked;
      if (!item.toggleGroup || newCheckedState) {
        item.checked = !item.checked;
      }
    } else if (item.href && event.key) {
      item.element.click();
    }
    item.trigger("beforeItem", itemEvent);
    item.trigger("item", itemEvent);
    if (item.closeParent && menu) {
      menu.rootMenu.close();
      if (event && !item.href) {
        event.preventDefault();
      }
    }
  }
  get focusElement() {
    return this.element;
  }
  get contentElement() {
    return this.textElement;
  }
  get isFocusable() {
    const { focusElement } = this;
    return focusElement && this.isVisible && (focusElement === document.body || focusElement.offsetParent);
  }
  get hasMenu() {
    return this.hasConfig("menu");
  }
  get childItems() {
    const { _menu } = this;
    return _menu ? [_menu] : [];
  }
  get text() {
    return this.html;
  }
  set text(text) {
    this.html = text;
  }
  onFocusIn(e) {
    super.onFocusIn(e);
    if (!this.disabled && this.menu) {
      this.delay("openMenu", 200);
    }
  }
  onFocusOut(e) {
    this.clearTimeout("openMenu");
    super.onFocusOut(e);
    if (this._menu) {
      this.menu.closeTimer = this.menu.setTimeout(() => this.closeMenu(), this.closeMenuDelay);
    }
  }
  openMenu(andFocus) {
    const { menu } = this;
    if (!this.disabled && menu) {
      menu.focusOnToFront = andFocus;
      menu.show();
    }
  }
  onChildShow(shown) {
    super.onChildShow(shown);
    this.ariaElement.setAttribute("aria-expanded", true);
  }
  closeMenu() {
    if (this._menu instanceof Widget) {
      this.menu.close();
    }
  }
  onChildHide(hidden) {
    super.onChildHide(hidden);
    this.ariaElement.setAttribute("aria-expanded", false);
  }
  changeToggleGroup(toggleGroup) {
    if (toggleGroup && typeof this.checked !== "boolean") {
      this.checked = false;
    }
    return toggleGroup;
  }
  /**
   * Get/sets the checked state of this `MenuItem` and fires the {@link #event-toggle}
   * event upon change.
   *
   * Note that this must be configured as a `Boolean` to enable the checkbox UI.
   * @member {Boolean} checked
   */
  changeChecked(checked, old) {
    if (this.isConfiguring || typeof old === "boolean") {
      return Boolean(checked);
    }
  }
  updateChecked(checked) {
    const me = this;
    if (!me.isConfiguring) {
      if (me.toggleGroup) {
        me.uncheckToggleGroupMembers();
      }
      me.element.setAttribute("aria-checked", checked);
      me.trigger("toggle", {
        menu: me.owner,
        item: me,
        element: me.element,
        bubbles: true,
        checked
      });
    }
  }
  getToggleGroupMembers() {
    const me = this, { checked, toggleGroup, element } = me, result = [];
    if (checked && toggleGroup) {
      DomHelper.forEachSelector(me.rootElement, `[data-group=${toggleGroup}]`, (otherElement) => {
        if (otherElement !== element) {
          const partnerCheckItem = Widget.fromElement(otherElement);
          partnerCheckItem && result.push(partnerCheckItem);
        }
      });
    }
    return result;
  }
  uncheckToggleGroupMembers() {
    if (this.checked && this.toggleGroup) {
      this.getToggleGroupMembers().forEach((widget) => widget.checked = false);
    }
  }
  get closeParent() {
    const result = typeof this.checked === "boolean" ? this._closeParent : this._closeParent !== false;
    return result && !this.hasMenu;
  }
  changeMenu(config, existingMenu) {
    const me = this, { constrainTo, scrollAction } = me.owner;
    if (config && typeof config === "object" && !("items" in config) && !("widgets" in config) && !("html" in config)) {
      config = {
        lazyItems: config
      };
    }
    return Menu.reconfigure(existingMenu, config, {
      owner: me,
      defaults: {
        type: "menu",
        align: "s0-e0",
        anchor: true,
        autoClose: true,
        autoShow: false,
        cls: "b-sub-menu",
        // Makes the anchor hoverable to avoid mouseleave
        forElement: me.element,
        owner: me,
        ariaLabel: me.text,
        constrainTo,
        scrollAction
      }
    });
  }
};
//region Config
__publicField(MenuItem, "$name", "MenuItem");
__publicField(MenuItem, "type", "menuitem");
MenuItem.initClass();
MenuItem._$name = "MenuItem";

// ../Core/lib/Core/widget/Menu.js
var validKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowRight: 1,
  ArrowLeft: 1,
  Enter: 1,
  Escape: 1
};
var Menu = class extends Popup {
  static get configurable() {
    return {
      layout: "vbox",
      focusable: true,
      align: "t-b",
      scrollAction: "hide",
      /**
       * Specify false to prevent the menu from getting focus when hovering items
       * @default
       * @config {Boolean}
       */
      focusOnHover: null,
      // We do need a Scroller so that we can use its API to scroll around.
      // But the overflow flags default to false.
      scrollable: false,
      defaultType: "menuitem",
      tools: {
        // To get rid of the close tool from Popup
        close: false
      },
      role: "menu",
      ariaElement: "bodyElement"
    };
  }
  /**
   * Currently open sub menu, if any
   * @member {Core.widget.Menu} currentSubMenu
   * @readonly
   */
  //endregion
  /**
   * A descendant menu item has been activated.
   *
   * Note that this event bubbles up through parents and can be
   * listened for on a top level {@link Core.widget.Menu Menu} for convenience.
   * @event item
   * @param {Core.widget.MenuItem} item - The menu item which is being actioned.
   * @param {Core.widget.Menu} menu - Menu containing the menu item
   */
  /**
   * The checked state of a descendant menu item has changed.
   *
   * Note that this event bubbles up through parents and can be
   * listened for on a top level {@link Core.widget.Menu Menu} for convenience.
   * @event toggle
   * @param {Core.widget.MenuItem} item - The menu item whose checked state changed.
   * @param {Core.widget.Menu} menu - Menu containing the menu item
   * @param {Boolean} checked - The _new_ checked state.
   */
  /* break doc comment */
  //region Init
  construct(config) {
    if (Array.isArray(config)) {
      config = {
        lazyItems: config
      };
    }
    super.construct(config);
    EventHelper.on({
      element: this.element,
      click: "onMouseClick",
      mouseover: "onMouseOver",
      mouseenter: "onMouseEnter",
      mouseleave: "onMouseLeave",
      thisObj: this
    });
  }
  afterShow() {
    const { items: items2, element } = this, hasSubmenu = items2.some((item) => Boolean(item._menu));
    if (hasSubmenu) {
      element.classList.add("b-menu-with-submenu");
    }
    const hasIcon = items2.some((item) => item.icon);
    if (hasIcon) {
      element.classList.add("b-menu-with-icon");
    }
    super.afterShow(...arguments);
  }
  createWidget(item) {
    if (typeof item === "string") {
      item = {
        text: item
      };
    }
    return super.createWidget(item);
  }
  get focusElement() {
    var _a2;
    const me = this, fromParentMenu = (_a2 = me.parentMenu) == null ? void 0 : _a2.element.contains(DomHelper.getActiveElement(me.parentMenu)), firstWidget = me.items[0];
    if (fromParentMenu || DomHelper.usingKeyboard || !(firstWidget instanceof MenuItem)) {
      return super.focusElement;
    }
    return me.element;
  }
  //endregion
  onDocumentMouseDown({ event }) {
    if (!this.parentMenu || !this.parentMenu.owns(event.target)) {
      return super.onDocumentMouseDown(...arguments);
    }
  }
  //region Show
  hide(animate) {
    var _a2, _b;
    const me = this;
    super.hide(animate);
    if (!me.isVisible) {
      (_b = (_a2 = me.currentSubMenu) == null ? void 0 : _a2.hide) == null ? void 0 : _b.call(_a2, animate);
      if (me.parentMenu) {
        me.parentMenu.currentSubMenu = null;
      }
    }
  }
  show() {
    super.show(...arguments);
    const { parentMenu } = this;
    if (this.isVisible && parentMenu) {
      parentMenu.currentSubMenu = this;
    }
  }
  //endregion
  //region Events
  /**
   * Activates a menu item if user clicks on it
   * @private
   */
  onMouseClick(event) {
    const menuItem = event.target.closest(".b-menuitem");
    if (menuItem) {
      this.triggerElement(menuItem, event);
    }
  }
  /**
   * Activates menu items on hover. On real mouse hover, not on a touchstart.
   * @private
   */
  onMouseOver(event) {
    var _a2;
    if (this.focusOnHover !== false) {
      const fromItemElement = (_a2 = event.relatedTarget) == null ? void 0 : _a2.closest(".b-widget"), toItemElement = event.target.closest(".b-widget"), overItem = Widget.fromElement(toItemElement);
      if (!DomHelper.isTouchEvent && toItemElement && toItemElement !== fromItemElement && overItem.parent === this) {
        this.setTimeout({
          fn: "handleMouseOver",
          delay: 30,
          args: [overItem],
          cancelOutstanding: true
        });
      }
    }
  }
  handleMouseOver(overItem) {
    overItem.focus();
  }
  onMouseEnter() {
    this.clearTimeout(this.closeTimer);
  }
  // unselect any menu item if mouse leaves the menu element (unless it enters a child menu)
  onMouseLeave(event) {
    const me = this, { relatedTarget } = event, leavingToChild = relatedTarget && me.owns(relatedTarget);
    let targetCmp = relatedTarget instanceof HTMLElement && Widget.fromElement(relatedTarget), shouldHideMenu = !leavingToChild;
    if (targetCmp) {
      while (targetCmp.ownerCmp) {
        targetCmp = targetCmp.ownerCmp;
      }
      shouldHideMenu &= !DomHelper.getAncestor(targetCmp.element, [event.target]);
    }
    if (!leavingToChild && shouldHideMenu) {
      if (me.currentSubMenu && !me.currentSubMenu.closeTimer) {
        me.currentSubMenu.hide();
      }
      if (me.element.contains(DomHelper.getActiveElement(me)) && DomHelper.getActiveElement(me).matches(".b-menuitem")) {
        me.focusElement.focus();
      }
    }
  }
  /**
   * Keyboard navigation. Up/down, close with esc, activate with enter
   * @private
   */
  onInternalKeyDown(event) {
    const sourceWidget = Widget.fromElement(event), isFromWidget = sourceWidget && sourceWidget !== this && !(sourceWidget instanceof MenuItem);
    if (event.key === "Escape") {
      (isFromWidget ? this : this.rootMenu).close();
      return;
    }
    super.onInternalKeyDown(event);
    if (isFromWidget) {
      return;
    }
    if (validKeys[event.key]) {
      event.preventDefault();
    }
    const el = this.element, active = DomHelper.getActiveElement(el);
    this.navigateFrom(active !== el && el.contains(active) ? active : null, event.key, event);
  }
  navigateFrom(active, key, event) {
    const me = this, { treeWalker } = me, item = active && me.getItem(active), enterSubMenu = me.rtl ? "ArrowLeft" : "ArrowRight", exitSubMenu = me.rtl ? "ArrowRight" : "ArrowLeft";
    let toActivate;
    switch (key) {
      case "ArrowUp":
        treeWalker.currentNode = active || (active = me.bottomFocusTrap);
        treeWalker.previousNode();
        toActivate = treeWalker.currentNode;
        break;
      case "ArrowDown":
        treeWalker.currentNode = active || (active = me.topFocusTrap);
        treeWalker.nextNode();
        toActivate = treeWalker.currentNode;
        break;
      case " ":
        if (active && !active.classList.contains("b-disabled")) {
          if (item == null ? void 0 : item.menu) {
            me.openSubMenu(active, item);
          } else {
            me.triggerElement(active, event);
          }
        }
        break;
      case enterSubMenu:
        if (active && (item == null ? void 0 : item.menu) && !active.classList.contains("b-disabled")) {
          const openedMenu = me.openSubMenu(active, item);
          openedMenu == null ? void 0 : openedMenu.focus();
        } else {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;
      case exitSubMenu:
        if (me.isSubMenu) {
          me.hide();
        } else if (!active) {
          treeWalker.currentNode = active || (active = me.topFocusTrap);
          treeWalker.nextNode();
          toActivate = treeWalker.currentNode;
        }
        break;
      case "Enter":
        if (active && !active.classList.contains("b-disabled")) {
          me.triggerElement(active, event);
        }
        break;
    }
    if (toActivate) {
      if (toActivate === me.element) {
        me.navigateFrom(me.bottomFocusTrap, "ArrowUp", event);
      } else if (toActivate === active) {
        me.navigateFrom(me.topFocusTrap, "ArrowDown", event);
      } else {
        toActivate.focus();
      }
    }
  }
  //endregion
  //region Activate menu item
  getItem(item) {
    if (item != null) {
      if (typeof item === "number") {
        return this.items[item];
      }
      if (item.nodeType === Element.ELEMENT_NODE) {
        return Widget.fromElement(item, "menuitem", this.contentElement);
      }
      return this.items.find((c) => c.id == item);
    }
  }
  /**
   * Activate a menu item (from its element)
   * @private
   * @fires item
   * @param menuItemElement
   */
  triggerElement(menuItemElement, event) {
    const item = this.getItem(menuItemElement);
    if (item && !item.disabled) {
      item.doAction(event);
    }
  }
  /**
   * Returns true if this menu is a sub menu.
   * To find out which menu is the parent, check {@link #property-parentMenu}.
   * @type {Boolean}
   * @readonly
   */
  get isSubMenu() {
    var _a2;
    return this === ((_a2 = this.owner) == null ? void 0 : _a2.menu);
  }
  /**
   * Opens a submenu anchored to a menu item
   * @private
   * @param element
   * @param item
   */
  openSubMenu(element, item) {
    var _a2;
    const me = this, subMenu = item.menu;
    if (subMenu) {
      if (!subMenu.isVisible) {
        const event = { item, element };
        if (me.trigger("beforeSubMenu", event) === false) {
          return;
        }
        if (((_a2 = item.onBeforeSubMenu) == null ? void 0 : _a2.call(item, event)) === false) {
          return;
        }
        subMenu.show();
      }
      return me.currentSubMenu = subMenu;
    }
  }
  /**
   * Get/set focused menu item.
   * Shows submenu if newly focused item has a menu and is not disabled.
   * @property {HTMLElement}
   */
  set selectedElement(element) {
    const me = this, lastSelected = me._selectedElement;
    if (lastSelected) {
      const lastItem = me.getItem(lastSelected), lastItemMenu = lastItem == null ? void 0 : lastItem.menu;
      lastItemMenu == null ? void 0 : lastItemMenu.hide();
      lastSelected.classList.remove("b-active");
    }
    me._selectedElement = element;
    if (element) {
      const doFocus = DomHelper.isFocusable(element);
      element.classList.add("b-active");
      me.scrollable.scrollIntoView(element, {
        animate: !doFocus,
        focus: doFocus
      });
    }
  }
  get selectedElement() {
    return this._selectedElement;
  }
  selectFirst() {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = this.topFocusTrap;
    treeWalker.nextNode();
    this.requestAnimationFrame(() => treeWalker.currentNode.focus());
  }
  //endregion
  //region Close
  /**
   * Gets the parent Menu if this Menu is a submenu, or `undefined`.
   * @property {Core.widget.Menu}
   */
  get parentMenu() {
    var _a2;
    const result = this.owner;
    return result && (result.isMenu ? result : (_a2 = result.up) == null ? void 0 : _a2.call(result, "menu"));
  }
  /**
   * Gets this menus root menu, the very first menu shown in a sub menu hierarchy
   * @property {Core.widget.Menu}
   * @private
   */
  get rootMenu() {
    let menu = this;
    while (menu.parentMenu instanceof this.constructor) {
      menu = menu.parentMenu;
    }
    return menu;
  }
  //endregion
};
//region Config
__publicField(Menu, "$name", "Menu");
__publicField(Menu, "type", "menu");
Menu.initClass();
Menu._$name = "Menu";

// ../Core/lib/Core/feature/base/ContextMenuBase.js
var contextMenuKeyEvent;
var ContextMenuBase = class extends InstancePlugin {
  static get $name() {
    return "ContextMenuBase";
  }
  //region Config
  static get configurable() {
    return {
      /**
       * This is a type of the context menu used to generate correct names for methods and events.
       * Should be in camel case. Required to be set in subclass.
       * @config {String}
       * @readonly
       */
      type: null,
      /**
       * Gets the Menu instance that this feature is using.
       * @member {Core.widget.Menu} menu
       * @readonly
       */
      /**
       * A config which will be applied when creating the Menu component.
       * @config {MenuConfig}
       */
      menu: {
        $config: ["lazy", "nullify"],
        value: {
          type: "menu",
          autoShow: false,
          closeAction: "hide",
          scrollAction: "hide",
          constrainTo: globalThis
        }
      },
      /**
       * {@link Core/widget/Menu} items object containing named child menu items to apply to the feature's
       * provided context menu.
       *
       * This may add extra items as below, but may also remove any of the default items by configuring the name
       * of the item as `null`.
       *
       * ```javascript
       * features : {
       *     cellMenu : {
       *         // This object is applied to the Feature's predefined default items
       *         items : {
       *             switchToDog : {
       *                 text : 'Dog',
       *                 icon : 'b-fa b-fa-fw b-fa-dog',
       *                 onItem({record}) {
       *                     record.dog = true;
       *                     record.cat = false;
       *                 },
       *                 weight : 500     // Make this second from end
       *             },
       *             switchToCat : {
       *                 text : 'Cat',
       *                 icon : 'b-fa b-fa-fw b-fa-cat',
       *                 onItem({record}) {
       *                     record.dog = false;
       *                     record.cat = true;
       *                 },
       *                 weight : 510     // Make this sink to end
       *             },
       *             add : null // We do not want the "Add" submenu to be available
       *         }
       *     }
       * }
       * ```
       *
       * @config {Object<String,MenuItemConfig|Boolean|null>}
       */
      items: {},
      /**
       * Event which is used to show context menu.
       * Available options are: 'contextmenu', 'click', 'dblclick' or `false` to disable.
       * Default value is used from {@link Grid/view/GridBase#config-contextMenuTriggerEvent}
       * @config {String|Boolean}
       */
      triggerEvent: false,
      /**
       * A CSS selector targeting an element, such as an ellipsis icon that when
       * clicked will trigger the menu to show.
       * @config {String}
       */
      clickTriggerSelector: null,
      /**
       * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
       * @config {Object<String,String>} keyMap
       */
      keyMap: {
        " ": { handler: "showContextMenuByKey", weight: 100 },
        "Ctrl+Space": "showContextMenuByKey"
      }
    };
  }
  // Plugin configuration. This plugin chains some of the functions in Grid.
  // The contextmenu event is emulated from a taphold gesture on touch platforms.
  static get pluginConfig() {
    return {
      assign: ["showContextMenu"],
      chain: [
        "onElementContextMenu",
        "onElementClick",
        "onElementDblClick"
      ]
    };
  }
  //endregion
  //region Init
  construct(...args) {
    var _a2;
    super.construct(...args);
    if (!((_a2 = this.type) == null ? void 0 : _a2.length)) {
      throw new Error(`Config 'type' is required to be specified for context menu`);
    }
  }
  //endregion
  //region Events
  /**
   * This event fires on the owning widget when an item is selected in the context menu.
   * @event contextMenuItem
   * @on-owner
   * @param {Core.widget.Widget} source The owning widget
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   */
  /**
   * This event fires on the owning widget when a check item is toggled in the context menu.
   * @event contextMenuToggleItem
   * @on-owner
   * @param {Core.widget.Widget} source The owning widget
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   * @param {Boolean} checked Checked or not
   */
  onElementContextMenu(event) {
    this.onElementEvent(event);
  }
  onElementClick(event) {
    this.onElementEvent(event);
  }
  onElementDblClick(event) {
    this.onElementEvent(event);
  }
  onElementEvent(event) {
    if (!event.handled && this.triggerEvent === event.type) {
      if (event.ctrlKey === true && !BrowserHelper.isMac) {
        event.preventDefault();
        return;
      }
      const originalEvent = event;
      if (contextMenuKeyEvent) {
        const { target } = contextMenuKeyEvent;
        event = EventHelper.fixEvent(new MouseEvent(event.type, event));
        Object.defineProperty(event, "target", { get: () => target, configurable: true });
        event.preventDefault = function() {
          originalEvent.preventDefault();
          originalEvent.handled = true;
        };
      }
      this.internalShowContextMenu(event);
    } else if (event.type === "click" && this.clickTriggerSelector && event.target.matches(this.clickTriggerSelector)) {
      this.internalShowContextMenu(event, { align: "l-r", target: event.target });
    }
  }
  showContextMenuByKey(event) {
    if (!DomHelper.isEditable(event.target)) {
      const target = this.getKeyboardContextMenuTarget(event.target);
      if (target) {
        contextMenuKeyEvent = event;
        DomHelper.triggerMouseEvent(target, this.triggerEvent);
        event.handled = true;
        event.preventDefault();
        event.stopImmediatePropagation();
        contextMenuKeyEvent = null;
        return true;
      }
    }
    return false;
  }
  // Pick a target child of a keydowned element to fire a contextmenu event through.
  getKeyboardContextMenuTarget(targetElement) {
    const targetRect = DomHelper.isInView(targetElement);
    return targetElement.children.length ? DomHelper.childFromPoint(targetElement, targetRect.width / 2, targetRect.height / 2) : targetElement;
  }
  //endregion
  //region Menu handlers
  internalShowContextMenu(domEvent, alignSpec) {
    const me = this;
    if (me.disabled) {
      return;
    }
    const data = me.getDataFromEvent(domEvent);
    if (!domEvent.handled && !domEvent.defaultPrevented && data && me.shouldShowMenu(data)) {
      if (domEvent.type === "contextmenu" && BrowserHelper.isSafari && domEvent.ctrlKey && !domEvent.metaKey) {
        EventHelper.on({
          element: domEvent.target,
          capture: true,
          once: true,
          thisObj: this,
          click(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
          }
        });
      }
      data.domEvent = domEvent;
      me.showContextMenu(data, alignSpec);
    }
  }
  getDataFromEvent(event) {
    return {
      event,
      targetElement: this.getTargetElementFromEvent(event)
    };
  }
  getTargetElementFromEvent(event) {
    return event.target;
  }
  /**
   * Shows the context menu.
   * @param {Event} event The initiating event.
   * @param {AlignSpec|HTMLElement} [alignSpec] Menu alignment specification, or an element to align to
   * @on-owner
   */
  async showContextMenu(event, alignSpec) {
    var _a2, _b;
    const me = this, isDOMEvent = DomHelper.isDOMEvent(event), menuContext = isDOMEvent ? me.getDataFromEvent(event) : event, domEvent = isDOMEvent ? event : menuContext.domEvent;
    (_a2 = me._menu) == null ? void 0 : _a2.hide();
    if (me.disabled) {
      return;
    }
    me.menuContext = menuContext;
    const {
      type,
      client,
      processItems
    } = me, elCenter = DomHelper.isInView(menuContext.targetElement).center;
    Objects.assign(menuContext, {
      feature: me,
      point: (domEvent == null ? void 0 : domEvent.clientX) ? [domEvent.clientX + 1, domEvent.clientY + 1] : [elCenter.x, elCenter.y],
      menu: me,
      items: {},
      selection: client.selectedRecords
    });
    me.callChainablePopulateMenuMethod(menuContext);
    Objects.merge(menuContext.items, me.baseItems);
    me.preventDefaultEvent(menuContext);
    if ((!processItems || await me.callback(processItems, client, [menuContext]) !== false) && me.hasActiveMenuItems(menuContext)) {
      me.populateItemsWithData(menuContext);
      if (me.beforeContextMenuShow(menuContext) !== false) {
        const { menu } = me;
        let result = client.trigger(`${type}MenuBeforeShow`, menuContext);
        if (ObjectHelper.isPromise(result)) {
          domEvent.handled = true;
          result = await result;
        }
        if (result !== false) {
          menu.items = menuContext.items;
          menu.showBy(alignSpec || {
            target: menuContext.domEvent
          });
          (_b = me.touchMoveDetacher) == null ? void 0 : _b.call(me);
          me.touchMoveDetacher = EventHelper.on({
            element: client.element,
            touchmove: () => menu.hide(),
            thisObj: menu,
            once: true
          });
          if (domEvent) {
            domEvent.preventDefault();
            domEvent.handled = true;
          }
        }
      }
    }
  }
  /**
   * Returns the base, configured-in menu items set from the configured items, taking into
   * account the namedItems the feature offers.
   * @property {Object[]}
   * @readonly
   * @internal
   */
  get baseItems() {
    if (!this._baseItems) {
      const me = this, { namedItems } = me, baseItems = me._baseItems = Objects.assign({}, me.items);
      for (const ref in baseItems) {
        const item = baseItems[ref];
        if (item) {
          if (namedItems && ref in namedItems) {
            baseItems[ref] = typeof item === "object" ? Objects.merge(Objects.clone(namedItems[ref]), item) : namedItems[ref];
          } else if (item === true) {
            delete baseItems[ref];
          }
        }
      }
    }
    return this._baseItems;
  }
  /**
   * Hides the context menu
   * @internal
   */
  hideContextMenu(animate) {
    var _a2;
    (_a2 = this.menu) == null ? void 0 : _a2.hide(animate);
  }
  callChainablePopulateMenuMethod(eventParams) {
    var _a2, _b;
    (_b = (_a2 = this.client)[`populate${StringHelper.capitalize(this.type)}Menu`]) == null ? void 0 : _b.call(_a2, eventParams);
  }
  hasActiveMenuItems(eventParams) {
    return Object.values(eventParams.items).some((item) => item && !item.hidden);
  }
  /**
   * Override this function and return `false` to prevent the context menu from being shown. Returns `true` by default.
   * @returns {Boolean}
   * @internal
   */
  shouldShowMenu() {
    return true;
  }
  beforeContextMenuShow(eventParams) {
  }
  populateItemsWithData(eventParams) {
  }
  preventDefaultEvent(eventParams) {
    var _a2;
    (_a2 = eventParams.event) == null ? void 0 : _a2.preventDefault();
  }
  //endregion
  //region Configurables
  changeTriggerEvent(triggerEvent) {
    return triggerEvent || this.client.contextMenuTriggerEvent;
  }
  changeMenu(menu, oldMenu) {
    const me = this, {
      client,
      type
    } = me;
    if (menu) {
      return Menu.reconfigure(oldMenu, menu ? Menu.mergeConfigs({
        owner: client,
        rootElement: client.rootElement,
        onItem(itemEvent) {
          client.trigger(`${type}MenuItem`, itemEvent);
        },
        onToggle(itemEvent) {
          client.trigger(`${type}MenuToggleItem`, itemEvent);
        },
        onDestroy() {
          me.menu = null;
        },
        // Load up the item event with the contextual info
        onBeforeItem(itemEvent) {
          Object.assign(itemEvent, me.menuContext);
        },
        onShow({ source: menu2 }) {
          me.menuContext.menu = menu2;
          client.trigger(`${type}MenuShow`, me.menuContext);
        }
      }, menu) : null, me);
    } else if (oldMenu == null ? void 0 : oldMenu.isWidget) {
      oldMenu.destroy();
    }
  }
  //endregion
};
ContextMenuBase._$name = "ContextMenuBase";

// ../Core/lib/Core/helper/mixin/DragHelperContainer.js
var DragHelperContainer_default = (Target) => class DragHelperContainer extends (Target || Base) {
  static get $name() {
    return "DragHelperContainer";
  }
  //region Init
  /**
   * Initialize container drag mode.
   * @private
   */
  initContainerDrag() {
    const me = this;
    if (!me.mode) {
      me.mode = "container";
    }
    if (me.mode === "container" && !me.containers) {
      throw new Error("Container drag mode must specify containers");
    }
  }
  //endregion
  //region Grab, update, finish
  /**
   * Grab an element which can be dragged between containers.
   * @private
   * @param event
   * @returns {Boolean}
   */
  grabContainerDrag(event) {
    const me = this;
    if (!me.ignoreSelector || !event.target.closest(me.ignoreSelector)) {
      const element = DomHelper.getAncestor(event.target, me.containers, me.outerElement);
      if (element) {
        const box = element.getBoundingClientRect();
        me.context = {
          element,
          valid: true,
          action: "container",
          offsetX: event.pageX - box.left,
          offsetY: event.pageY - box.top,
          originalPosition: {
            parent: element.parentElement,
            prev: element.previousElementSibling,
            next: element.nextElementSibling
          }
        };
      }
      return true;
    }
    return false;
  }
  startContainerDrag(event) {
    var _a2;
    const me = this, { context, floatRootOwner } = me, { element: dragElement } = context, clonedNode = dragElement.cloneNode(true), outerWidgetEl = floatRootOwner == null ? void 0 : floatRootOwner.element.closest(".b-outer");
    clonedNode.classList.add(me.dragProxyCls, me.draggingCls);
    ((floatRootOwner == null ? void 0 : floatRootOwner.floatRoot) || DomHelper.getRootElement(dragElement)).appendChild(clonedNode);
    context.dragProxy = clonedNode;
    context.dragging = dragElement;
    dragElement.classList.add(me.dropPlaceholderCls);
    if ((_a2 = outerWidgetEl == null ? void 0 : outerWidgetEl.parentElement) == null ? void 0 : _a2.matches(".b-float-root")) {
      clonedNode.style.zIndex = floatRootOwner.floatRootMaxZIndex + 1;
    }
  }
  onContainerDragStarted(event) {
    const me = this, { context } = me, { element: dragElement, dragProxy } = context, box = dragElement.getBoundingClientRect();
    if (me.autoSizeClonedTarget) {
      dragProxy.style.width = box.width + "px";
      dragProxy.style.height = box.height + "px";
      DomHelper.setTranslateXY(context.dragProxy, box.left, box.top);
    } else {
      const proxyBox = dragProxy.getBoundingClientRect();
      Object.assign(context, {
        offsetX: proxyBox.width / 2,
        offsetY: proxyBox.height / 2
      });
      DomHelper.setTranslateXY(dragProxy, event.clientX, event.clientY);
    }
  }
  /**
   * Move the placeholder element into its new position on valid drag.
   * @private
   * @param event
   */
  updateContainerDrag(event) {
    var _a2;
    const me = this, { context } = me;
    if (!context.started || !context.targetElement) {
      return;
    }
    const containerElement = DomHelper.getAncestor(context.targetElement, me.containers, "b-gridbase"), willLoseFocus = (_a2 = context.dragging) == null ? void 0 : _a2.contains(DomHelper.getActiveElement(context.dragging));
    if (containerElement && DomHelper.isDescendant(context.element, containerElement)) {
      return;
    }
    if (willLoseFocus) {
      GlobalEvents_default.suspendFocusEvents();
    }
    if (containerElement && context.valid) {
      me.moveNextTo(containerElement, event);
    } else {
      me.revertPosition();
    }
    if (willLoseFocus) {
      GlobalEvents_default.resumeFocusEvents();
    }
    event.preventDefault();
  }
  /**
   * Finalize drag, fire drop.
   * @private
   * @param event
   * @fires drop
   */
  finishContainerDrag(event) {
    const me = this, { context } = me, { dragging, dragProxy, valid, draggedTo, insertBefore, originalPosition } = context;
    if (dragging) {
      context.valid = Boolean(valid && (draggedTo || me.externalDropTargetSelector && event.target.closest(me.externalDropTargetSelector)) && // no drop on self or parent
      (dragging !== insertBefore || originalPosition.parent !== draggedTo));
      context.finalize = (valid2 = context.valid) => {
        if (!valid2 && me.context) {
          me.revertPosition();
        }
        dragging.classList.remove(me.dropPlaceholderCls);
        dragProxy.remove();
        me.reset();
      };
      context.async = false;
      me.trigger("drop", { context, event });
      if (!context.async) {
        context.finalize();
      }
    }
  }
  /**
   * Aborts a drag operation.
   * @private
   * @param {Boolean} [invalid]
   * @param {Object} [event]
   * @param {Boolean} [silent]
   */
  abortContainerDrag(invalid = false, event = null, silent = false) {
    const me = this, { context } = me;
    if (context.dragging) {
      context.dragging.classList.remove(me.dropPlaceholderCls);
      context.dragProxy.remove();
      me.revertPosition();
    }
    if (!silent) {
      me.trigger(invalid ? "drop" : "abort", { context, event });
    }
    me.reset();
  }
  //endregion
  //region Helpers
  /**
   * Updates the drag proxy position.
   * @private
   * @param event
   */
  updateContainerProxy(event) {
    const me = this, { context } = me, proxy = context.dragProxy;
    let newX = event.pageX - context.offsetX, newY = event.pageY - context.offsetY;
    if (typeof me.minX === "number") {
      newX = Math.max(me.minX, newX);
    }
    if (typeof me.maxX === "number") {
      newX = Math.min(me.maxX - proxy.offsetWidth, newX);
    }
    if (typeof me.minY === "number") {
      newY = Math.max(me.minY, newY);
    }
    if (typeof me.maxY === "number") {
      newY = Math.min(me.maxY - proxy.offsetHeight, newY);
    }
    if (me.lockX) {
      DomHelper.setTranslateY(proxy, newY);
    } else if (me.lockY) {
      DomHelper.setTranslateX(proxy, newX);
    } else {
      DomHelper.setTranslateXY(proxy, newX, newY);
    }
    let targetElement;
    if (event.type === "touchmove") {
      const touch = event.changedTouches[0];
      targetElement = DomHelper.elementFromPoint(touch.clientX, touch.clientY);
    } else {
      targetElement = event.target;
    }
    context.targetElement = targetElement;
  }
  /**
   * Positions element being dragged in relation to targetElement.
   * @private
   * @param targetElement
   * @param event
   */
  moveNextTo(targetElement, event) {
    const { context } = this, dragElement = context.dragging, parent = targetElement.parentElement;
    if (targetElement !== dragElement) {
      const centerX = Rectangle.from(targetElement).center.x;
      if (this.isRTL && event.pageX > centerX || !this.isRTL && event.pageX < centerX) {
        parent.insertBefore(dragElement, targetElement);
        context.insertBefore = targetElement;
      } else {
        if (targetElement.nextElementSibling) {
          if (targetElement.nextElementSibling !== dragElement) {
            context.insertBefore = targetElement.nextElementSibling;
            parent.insertBefore(dragElement, targetElement.nextElementSibling);
          } else if (!context.insertBefore && dragElement.parentElement.lastElementChild !== dragElement) {
            context.insertBefore = targetElement.nextElementSibling;
          }
        } else {
          parent.appendChild(dragElement);
          context.insertBefore = null;
        }
      }
      context.draggedTo = parent;
    }
  }
  /**
   * Moves element being dragged back to its original position.
   * @private
   */
  revertPosition() {
    const { context } = this, { dragging } = context, { parent, next } = context.originalPosition;
    if (next) {
      const isNoop = next.previousSibling === dragging || !next && dragging === parent.lastChild;
      if (!isNoop) {
        parent.insertBefore(dragging, next);
      }
    } else {
      parent.appendChild(dragging);
    }
    context.draggedTo = null;
  }
  //endregion
};

// ../Core/lib/Core/helper/mixin/DragHelperTranslate.js
var noScroll = { pageXOffset: 0, pageYOffset: 0 };
var DragHelperTranslate_default = (Target) => class DragHelperTranslate extends Delayable_default(Target || Base) {
  static get $name() {
    return "DragHelperTranslate";
  }
  static get configurable() {
    return {
      positioning: null,
      // Private config that disables updating elements position, for when data is live updated during drag,
      // leading to element being redrawn
      skipUpdatingElement: null
    };
  }
  //region Init
  /**
   * Initialize translation drag mode.
   * @private
   */
  initTranslateDrag() {
    const me = this;
    if (!me.isElementDraggable && me.targetSelector) {
      me.isElementDraggable = (element) => element.closest(me.targetSelector);
    }
  }
  //endregion
  //region Grab, update, finish
  /**
   * Grab an element which can be moved using translation.
   * @private
   * @param event
   * @returns {Boolean}
   */
  grabTranslateDrag(event) {
    const element = this.getTarget(event);
    if (element) {
      this.context = {
        valid: true,
        element,
        startPageX: event.pageX,
        startPageY: event.pageY,
        startClientX: event.clientX,
        startClientY: event.clientY
      };
      return true;
    }
    return false;
  }
  getTarget(event) {
    return event.target.closest(this.targetSelector);
  }
  getX(element) {
    if (this.positioning === "absolute") {
      return parseFloat(element.style.left, 10);
    } else {
      return DomHelper.getTranslateX(element);
    }
  }
  getY(element) {
    if (this.positioning === "absolute") {
      return parseFloat(element.style.top, 10);
    } else {
      return DomHelper.getTranslateY(element);
    }
  }
  getXY(element) {
    if (this.positioning === "absolute") {
      return [element.offsetLeft, element.offsetTop];
    } else {
      return DomHelper.getTranslateXY(element);
    }
  }
  setXY(element, x, y) {
    if (this.skipUpdatingElement) {
      return;
    }
    if (this.positioning === "absolute") {
      element.style.left = x + "px";
      element.style.top = y + "px";
    } else {
      DomHelper.setTranslateXY(element, x, y);
    }
  }
  /**
   * Start translating, called on first mouse move after dragging
   * @private
   * @param event
   */
  startTranslateDrag(event) {
    const me = this, { context, outerElement, proxySelector } = me, dragWithin = me.dragWithin = me.dragWithin || me.cloneTarget && document.body;
    let element = context.dragProxy || context.element;
    const grabbed = element, grabbedParent = element.parentElement;
    if (me.cloneTarget) {
      const elementToClone = proxySelector ? element.querySelector(proxySelector) : element, { width, height, x: proxyX, y: proxyY } = Rectangle.from(elementToClone, Rectangle.outer(dragWithin));
      element = me.createProxy(element);
      let x = proxyX, y = proxyY;
      if (me.autoSizeClonedTarget) {
        element.style.width = `${width}px`;
        element.style.height = `${height}px`;
      }
      element.classList.add(me.dragProxyCls, me.draggingCls);
      element.classList.remove("b-hover", "b-selected", "b-focused");
      dragWithin.appendChild(element);
      if (!me.autoSizeClonedTarget || proxySelector) {
        const proxyRect = element.getBoundingClientRect(), { x: dragWithinX, y: dragWithinY } = dragWithin.getBoundingClientRect(), localX = event.clientX - dragWithinX, localY = event.clientY - dragWithinY + (dragWithin !== document.body ? document.body.getBoundingClientRect().y : 0);
        x = localX - proxyRect.width / 2;
        y = localY - proxyRect.height / 2;
        context.startPageX = event.pageX;
        context.startPageY = event.pageY;
      }
      me.setXY(element, x, y);
      grabbed.classList.add("b-drag-original");
      if (me.hideOriginalElement) {
        grabbed.classList.add("b-hidden");
      }
    }
    element.classList.add(me.draggingCls);
    Object.assign(context, {
      // The element which we're moving, could be a cloned version of grabbed, or the grabbed element itself
      element,
      // The original element upon which the mousedown event triggered a drag operation
      grabbed,
      // The parent of the original element where the pointerdown was detected - to be able to restore after an invalid drop
      grabbedParent,
      // The next sibling of the original element where the pointerdown was detected - to be able to restore after an invalid drop
      grabbedNextSibling: element.nextElementSibling,
      // elements position within parent element
      elementStartX: me.getX(element),
      elementStartY: me.getY(element),
      elementX: DomHelper.getOffsetX(element, dragWithin || outerElement),
      elementY: DomHelper.getOffsetY(element, dragWithin || outerElement),
      scrollX: 0,
      scrollY: 0,
      scrollManagerElementContainsDragProxy: !me.cloneTarget || dragWithin === outerElement
    });
    if (dragWithin) {
      context.parentElement = element.parentElement;
      if (dragWithin !== element.parentElement) {
        dragWithin.appendChild(element);
      }
      me.updateTranslateProxy(event);
    }
  }
  // When drag has started, create proxy versions (if applicable) and store original positions of all related elements
  // to be able to animate back to these positions in case of an aborted drag
  onTranslateDragStarted() {
    const me = this, { context } = me;
    let { relatedElements } = context;
    if (me.unifiedProxy) {
      context.element.classList.add("b-drag-main", "b-drag-unified-proxy");
    }
    if ((relatedElements == null ? void 0 : relatedElements.length) > 0) {
      context.relatedElStartPos = [];
      context.relatedElDragFromPos = [];
      const { proxySelector } = me;
      let [elementStartX, elementStartY] = [context.elementStartX, context.elementStartY];
      context.originalRelatedElements = relatedElements;
      relatedElements = context.relatedElements = relatedElements.map((relatedEl, i) => {
        const proxyTemplateElement = proxySelector ? relatedEl.querySelector(proxySelector) : relatedEl, { x, y, width, height } = Rectangle.from(proxyTemplateElement, me.dragWithin), relatedElementToDrag = me.cloneTarget ? me.createProxy(relatedEl) : relatedEl;
        relatedElementToDrag.classList.add(me.draggingCls);
        relatedElementToDrag.classList.remove("b-hover", "b-selected", "b-focused");
        if (me.cloneTarget) {
          me.setXY(relatedElementToDrag, x, y);
          me.dragWithin.appendChild(relatedElementToDrag);
          relatedElementToDrag.classList.add(me.dragProxyCls);
          if (me.autoSizeClonedTarget) {
            relatedElementToDrag.style.width = `${width}px`;
            relatedElementToDrag.style.height = `${height}px`;
          }
          if (me.hideOriginalElement) {
            relatedEl.classList.add("b-hidden");
          }
          relatedEl.classList.add("b-drag-original");
        }
        context.relatedElStartPos[i] = context.relatedElDragFromPos[i] = me.getXY(relatedElementToDrag);
        if (me.unifiedProxy) {
          relatedElementToDrag.classList.add("b-drag-unified-animation", "b-drag-unified-proxy");
          elementStartX += me.unifiedOffset;
          elementStartY += me.unifiedOffset;
          me.setXY(relatedElementToDrag, elementStartX, elementStartY);
          context.relatedElDragFromPos[i] = [elementStartX, elementStartY];
          relatedElementToDrag.style.zIndex = 100 - i;
        }
        return relatedElementToDrag;
      });
      if (me.unifiedProxy && relatedElements && relatedElements.length > 0) {
        EventHelper.onTransitionEnd({
          element: relatedElements[0],
          property: "transform",
          handler() {
            relatedElements.forEach((el) => el.classList.remove("b-drag-unified-animation"));
          },
          thisObj: me,
          once: true
        });
      }
    }
  }
  /**
   * Limit translation to outer bounds and specified constraints
   * @private
   * @param element
   * @param x
   * @param y
   * @returns {{constrainedX: *, constrainedY: *}}
   */
  applyConstraints(element, x, y) {
    const me = this, { constrain, dragWithin } = me, { pageXOffset, pageYOffset } = dragWithin === document.body ? globalThis : noScroll;
    if (dragWithin && constrain) {
      if (x < 0) {
        x = 0;
      }
      if (x + element.offsetWidth > dragWithin.scrollWidth) {
        x = dragWithin.scrollWidth - element.offsetWidth;
      }
      if (y < 0) {
        y = 0;
      }
      if (y + element.offsetHeight > dragWithin.scrollHeight) {
        y = dragWithin.scrollHeight - element.offsetHeight;
      }
    }
    if (typeof me.minX === "number") {
      x = Math.max(me.minX + pageXOffset, x);
    }
    if (typeof me.maxX === "number") {
      x = Math.min(me.maxX + pageXOffset, x);
    }
    if (typeof me.minY === "number") {
      y = Math.max(me.minY + pageYOffset, y);
    }
    if (typeof me.maxY === "number") {
      y = Math.min(me.maxY + pageYOffset, y);
    }
    return { constrainedX: x, constrainedY: y };
  }
  /**
   * Update elements translation on mouse move.
   * @private
   * @param {MouseEvent} event
   * @param {Object} scrollManagerConfig
   */
  updateTranslateProxy(event, scrollManagerConfig) {
    const me = this, { lockX, lockY, context } = me, element = context.dragProxy || context.element, { relatedElements, relatedElDragFromPos } = context;
    if (context.scrollManagerElementContainsDragProxy && scrollManagerConfig) {
      context.scrollX = scrollManagerConfig.getRelativeLeftScroll(element);
      context.scrollY = scrollManagerConfig.getRelativeTopScroll(element);
    }
    context.pageX = event.pageX;
    context.pageY = event.pageY;
    context.clientX = event.clientX;
    context.clientY = event.clientY;
    let newX = context.elementStartX + event.pageX - context.startPageX + context.scrollX, newY = context.elementStartY + event.pageY - context.startPageY + context.scrollY;
    if (me.snapCoordinates) {
      const snapped = me.snapCoordinates({ element, newX, newY });
      newX = snapped.x;
      newY = snapped.y;
    }
    const { constrainedX, constrainedY } = me.applyConstraints(element, newX, newY);
    if (context.started || constrainedX !== newX || constrainedY !== newY) {
      me.setXY(element, lockX ? void 0 : constrainedX, lockY ? void 0 : constrainedY);
    }
    if (relatedElements) {
      const deltaX = lockX ? 0 : constrainedX - context.elementStartX, deltaY = lockY ? 0 : constrainedY - context.elementStartY;
      relatedElements.forEach((r, i) => {
        const [x, y] = relatedElDragFromPos[i];
        me.setXY(r, x + deltaX, y + deltaY);
      });
    }
    context.newX = constrainedX;
    context.newY = constrainedY;
  }
  /**
   * Finalize drag, fire drop.
   * @private
   * @param event
   * @fires drop
   */
  async finishTranslateDrag(event) {
    const me = this, context = me.context, { target } = event, xChanged = !me.lockX && Math.round(context.newX) !== Math.round(context.elementStartX), yChanged = !me.lockY && Math.round(context.newY) !== Math.round(context.elementStartY), element = context.dragProxy || context.element, { relatedElements } = context;
    if (!me.ignoreSamePositionDrop || xChanged || yChanged) {
      if (context.valid === false) {
        await me.abortTranslateDrag(true, event);
      } else {
        const targetRect = !me.allowDropOutside && Rectangle.from(me.dragWithin || me.outerElement);
        if (targetRect && (typeof me.minX !== "number" && me.minX !== true && event.pageX < targetRect.left || typeof me.maxX !== "number" && me.maxX !== true && event.pageX > targetRect.right || typeof me.minY !== "number" && me.minY !== true && event.pageY < targetRect.top || typeof me.maxY !== "number" && me.maxY !== true && event.pageY > targetRect.bottom)) {
          await me.abortTranslateDrag(true, event);
        } else {
          context.finalize = async (valid = context.valid) => {
            if (context.finalized) {
              console.warn("DragHelper: Finalizing already finalized drag");
              return;
            }
            context.finalized = true;
            if (!valid && me.context) {
              await me.abortTranslateDrag(true, null, true);
            }
            if (!me.isDestroyed) {
              me.trigger("dropFinalized", { context, event, target });
              me.reset();
            }
            if (!me.cloneTarget && element.parentElement !== context.grabbedParent) {
              [element, ...relatedElements || []].forEach((el) => el.style.transform = "");
            }
          };
          context.async = false;
          await me.trigger("drop", { context, event, target });
          if (!context.async) {
            await context.finalize();
          }
        }
      }
    } else {
      me.abortTranslateDrag(false, event);
    }
  }
  /**
   * Abort translation
   * @private
   * @param invalid
   * @fires abort
   */
  async abortTranslateDrag(invalid = false, event = null, silent = false) {
    var _a2, _b;
    const me = this, {
      cloneTarget,
      context,
      proxySelector,
      dragWithin,
      draggingCls
    } = me, { relatedElements, relatedElStartPos, grabbed } = context, element = context.dragProxy || context.element;
    context.valid = false;
    (_a2 = me.scrollManager) == null ? void 0 : _a2.stopMonitoring();
    if (context.aborted) {
      console.warn("DragHelper: Aborting already aborted drag");
      return;
    }
    let { elementStartX, elementStartY } = context;
    const proxyMoved = elementStartX !== me.getX(element) || elementStartY !== me.getY(element);
    if (element && context.started) {
      if (!cloneTarget && dragWithin && dragWithin !== context.grabbedParent) {
        context.grabbedParent.insertBefore(element, context.grabbedNextSibling);
      }
      if (cloneTarget) {
        if (proxySelector) {
          const animateTo = grabbed.querySelector(proxySelector) || grabbed, { x, y } = Rectangle.from(animateTo);
          elementStartX = x;
          elementStartY = y;
        }
      }
      element.classList.add("b-aborting");
      me.setXY(element, elementStartX, elementStartY);
      relatedElements == null ? void 0 : relatedElements.forEach((element2, i) => {
        element2.classList.remove(draggingCls);
        element2.classList.add("b-aborting");
        me.setXY(element2, relatedElStartPos[i][0], relatedElStartPos[i][1]);
      });
      if (!silent) {
        me.trigger(invalid ? "drop" : "abort", { context, event });
      }
      if (element.isConnected && !me.isDestroying && proxyMoved) {
        await EventHelper.waitForTransitionEnd({
          element,
          property: DomHelper.getPropertyTransitionDuration(element, "transform") ? "transform" : "all",
          thisObj: me,
          once: true,
          runOnDestroy: true
        });
      }
      if (!me.isDestroyed) {
        me.trigger("abortFinalized", { context, event });
      }
    }
    if ((_b = me.context) == null ? void 0 : _b.started) {
      me.reset();
    }
  }
  // Restore state of all mutated elements
  cleanUp() {
    const me = this, { context, cloneTarget, draggingCls, dragProxyCls } = me, element = context.dragProxy || context.element, { relatedElements, originalRelatedElements, grabbed } = context, removeClonedProxies = cloneTarget && (me.removeProxyAfterDrop || !context.valid), cssClassesToRemove = [draggingCls, "b-aborting", dragProxyCls, "b-drag-main", "b-drag-unified-proxy"];
    element.classList.remove(...cssClassesToRemove);
    if (removeClonedProxies) {
      element.remove();
    }
    relatedElements == null ? void 0 : relatedElements.forEach((element2) => {
      if (removeClonedProxies) {
        element2.remove();
      } else {
        element2.classList.remove(...cssClassesToRemove);
      }
    });
    grabbed.classList.remove("b-drag-original", "b-hidden");
    originalRelatedElements == null ? void 0 : originalRelatedElements.forEach((element2) => element2.classList.remove("b-hidden", "b-drag-original"));
  }
  //endregion
};

// ../Core/lib/Core/helper/DragHelper.js
var rootElementListeners = {
  move: "onMouseMove",
  up: "onMouseUp",
  docclick: "onDocumentClick",
  touchstart: "onTouchStart",
  touchmove: "onTouchMove",
  touchend: "onTouchEnd",
  keydown: "onKeyDown"
};
var DragHelper = class extends Base.mixin(Events_default, DragHelperContainer_default, DragHelperTranslate_default) {
  //region Config
  static get defaultConfig() {
    return {
      /**
       * Drag proxy CSS class
       * @config {String}
       * @default
       * @private
       */
      dragProxyCls: "b-drag-proxy",
      /**
       * CSS class added when drag is invalid
       * @config {String}
       * @default
       */
      invalidCls: "b-drag-invalid",
      /**
       * CSS class added to the source element in Container drag
       * @config {String}
       * @default
       * @private
       */
      draggingCls: "b-dragging",
      /**
       * CSS class added to the source element in Container drag
       * @config {String}
       * @default
       * @private
       */
      dropPlaceholderCls: "b-drop-placeholder",
      /**
       * The amount of pixels to move mouse before it counts as a drag operation
       * @config {Number}
       * @default
       */
      dragThreshold: 5,
      /**
       * The outer element where the drag helper will operate (attach events to it and use as outer limit when looking for ancestors)
       * @config {HTMLElement}
       * @default
       */
      outerElement: document.body,
      /**
       * Outer element that limits where element can be dragged
       * @config {HTMLElement}
       */
      dragWithin: null,
      /**
       * Set to true to stack any related dragged elements below the main drag proxy element. Only applicable when
       * using translate {@link #config-mode} with {@link #config-cloneTarget}
       * @config {Boolean}
       */
      unifiedProxy: null,
      monitoringConfig: null,
      /**
       * Constrain translate drag to dragWithin elements bounds (set to false to allow it to "overlap" edges)
       * @config {Boolean}
       * @default
       */
      constrain: true,
      /**
       * Smallest allowed x when dragging horizontally.
       * @config {Number}
       */
      minX: null,
      /**
       * Largest allowed x when dragging horizontally.
       * @config {Number}
       */
      maxX: null,
      /**
       * Smallest allowed y when dragging horizontally.
       * @config {Number}
       */
      minY: null,
      /**
       * Largest allowed y when dragging horizontally.
       * @config {Number}
       */
      maxY: null,
      /**
       * Enabled dragging, specify mode:
       * <table>
       * <tr><td>container<td>Allows reordering elements within one and/or between multiple containers
       * <tr><td>translateXY<td>Allows dragging within a parent container
       * </table>
       * @config {'container'|'translateXY'}
       * @default
       */
      mode: "translateXY",
      /**
       * A function that determines if dragging an element is allowed. Gets called with the element as argument,
       * return `true` to allow dragging or `false` to prevent.
       * @config {Function}
       * @param {HTMLElement} element
       * @returns {Boolean}
       */
      isElementDraggable: null,
      /**
       * A CSS selector used to determine if dragging an element is allowed.
       * @config {String}
       */
      targetSelector: null,
      /**
       * A CSS selector used to determine if a drop is allowed at the current position.
       * @config {String}
       */
      dropTargetSelector: null,
      /**
       * A CSS selector added to each drop target element while dragging.
       * @config {String}
       */
      dropTargetCls: null,
      /**
       * A CSS selector used to target a child element of the mouse down element, to use as the drag proxy element.
       * Applies to translate {@link #config-mode mode} when using {@link #config-cloneTarget}.
       * @config {String}
       */
      proxySelector: null,
      /**
       * Set to `true` to clone the dragged target, and not move the actual target DOM node.
       * @config {Boolean}
       * @default
       */
      cloneTarget: false,
      /**
       * Set to `false` to not apply width/height of cloned drag proxy elements.
       * @config {Boolean}
       * @default
       */
      autoSizeClonedTarget: true,
      /**
       * Set to true to hide the original element while dragging (applicable when `cloneTarget` is true).
       * @config {Boolean}
       * @default
       */
      hideOriginalElement: false,
      /**
       * Containers whose elements can be rearranged (and moved between the containers). Used when
       * mode is set to "container".
       * @config {HTMLElement[]}
       */
      containers: null,
      /**
       * A CSS selector used to exclude elements when using container mode
       * @config {String}
       */
      ignoreSelector: null,
      startEvent: null,
      /**
       * Configure as `true` to disallow dragging in the `X` axis. The dragged element will only move vertically.
       * @config {Boolean}
       * @default
       */
      lockX: false,
      /**
       * Configure as `true` to disallow dragging in the `Y` axis. The dragged element will only move horizontally.
       * @config {Boolean}
       * @default
       */
      lockY: false,
      /**
       * The amount of milliseconds to wait after a touchstart, before a drag gesture will be allowed to start.
       * @config {Number}
       * @default
       */
      touchStartDelay: 300,
      /**
       * Scroll manager of the target. If specified, scrolling while dragging is supported.
       * @config {Core.util.ScrollManager}
       */
      scrollManager: null,
      /**
       * A method provided to snap coordinates to fixed points as you drag
       * @config {Function}
       * @internal
       */
      snapCoordinates: null,
      /**
       * When using {@link #config-unifiedProxy}, use this amount of pixels to offset each extra element when dragging multiple items
       * @config {Number}
       * @default
       */
      unifiedOffset: 5,
      /**
       * Configure as `false` to take ownership of the proxy element after a valid drop (advanced usage).
       * @config {Boolean}
       * @default
       */
      removeProxyAfterDrop: true,
      clickSwallowDuration: 50,
      ignoreSamePositionDrop: true,
      // true to allow drops outside the dragWithin element
      allowDropOutside: null,
      // for container mode
      floatRootOwner: null,
      mouseMoveListenerElement: document,
      externalDropTargetSelector: null,
      testConfig: {
        transitionDuration: 10,
        clickSwallowDuration: 50,
        touchStartDelay: 100
      },
      rtlSource: null,
      /**
       * Creates the proxy element to be dragged, when using {@link #config-cloneTarget}. Clones the original element by default.
       * Provide your custom {@link #function-createProxy} function to be used for creating drag proxy.
       * @param {HTMLElement} element The element from which the drag operation originated
       * @config {Function}
       * @returns {HTMLElement}
       */
      createProxy: null
    };
  }
  //endregion
  //region Events
  /**
   * Fired before dragging starts, return `false` to prevent the drag operation.
   * @preventable
   * @event beforeDragStart
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The original element upon which the mousedown event triggered a drag operation
   * @param {MouseEvent|TouchEvent} event
   */
  /**
   * Fired when dragging starts. The event includes a `context` object. If you want to drag additional elements you can
   * provide these as an array of elements assigned to the `relatedElements` property of the context object.
   * @event dragStart
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The element which we're moving, could be a cloned version of grabbed, or the grabbed element itself
   * @param {HTMLElement} context.grabbed The original element upon which the mousedown event triggered a drag operation
   * @param {HTMLElement[]} context.relatedElements Array of extra elements to include in the drag.
   * @param {MouseEvent|TouchEvent} event
   */
  /**
   * Fired while dragging, you can signal that the drop is valid or invalid by setting `context.valid = false;`
   * @event drag
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The element which we are moving, could be a cloned version of grabbed, or the grabbed element itself
   * @param {HTMLElement} context.target The target element below the cursor
   * @param {HTMLElement} context.grabbed The original element upon which the mousedown event triggered a drag operation
   * @param {HTMLElement[]} context.relatedElements An array of extra elements dragged with the main dragged element
   * @param {Boolean} context.valid Set this to true or false to indicate whether the drop position is valid.
   * @param {MouseEvent} event
   */
  /**
   * Fired after a drop at an invalid position
   * @event abort
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The element which we are moving, could be a cloned version of grabbed, or the grabbed element itself
   * @param {HTMLElement} context.target The target element below the cursor
   * @param {HTMLElement} context.grabbed The original element upon which the mousedown event triggered a drag operation
   * @param {HTMLElement[]} context.relatedElements An array of extra elements dragged with the main dragged element
   * @param {MouseEvent} event
   */
  /**
   * Fires after {@link #event-abort} and after drag proxy has animated back to its original position
   * @private
   * @event abortFinalized
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The element which we are moving, could be a cloned version of grabbed, or the grabbed element itself
   * @param {HTMLElement} context.target The target element below the cursor
   * @param {HTMLElement} context.grabbed The original element upon which the mousedown event triggered a drag operation
   * @param {MouseEvent} event
   */
  //endregion
  //region Init
  /**
   * Initializes a new DragHelper.
   * @param {DragHelperConfig} config Configuration object, accepts options specified under Configs above
   *
   * ```javascript
   * new DragHelper({
   *   containers: [div1, div2],
   *   isElementDraggable: element => element.className.contains('handle'),
   *   outerElement: topParent,
   *   listeners: {
   *     drop: onDrop,
   *     thisObj: this
   *   }
   * });
   * ```
   *
   * @function constructor
   */
  construct(config) {
    const me = this;
    super.construct(config);
    me.initListeners();
    if (me.isContainerDrag) {
      me.initContainerDrag();
    } else {
      me.initTranslateDrag();
    }
    me.onScrollManagerScrollCallback = me.onScrollManagerScrollCallback.bind(me);
  }
  doDestroy() {
    this.reset(true);
    super.doDestroy();
  }
  /**
   * Initialize listener
   * @private
   */
  initListeners() {
    const me = this, { outerElement } = me, dragStartListeners = {
      element: outerElement,
      pointerdown: "onPointerDown",
      thisObj: me
    };
    me.mouseMoveListenerElement = me.getMouseMoveListenerTarget(outerElement);
    EventHelper.on(dragStartListeners);
  }
  // Salesforce hook: we override this method to move listener from the body (which is default root node) to element
  // inside of LWC
  getMouseMoveListenerTarget(element) {
    const root = element.getRootNode();
    let result = this.mouseMoveListenerElement;
    if (root.nodeType === Node.DOCUMENT_FRAGMENT_NODE && root.mode === "closed") {
      result = element.closest(".b-outer") || result;
    }
    return result;
  }
  get isRTL() {
    var _a2;
    return Boolean((_a2 = this.rtlSource) == null ? void 0 : _a2.rtl);
  }
  //endregion
  //region Events
  /**
   * Fires after drop. For valid drops, it exposes `context.async` which you can set to true to signal that additional
   * processing is needed before finalizing the drop (such as showing some dialog). When that operation is done, call
   * `context.finalize(true/false)` with a boolean that determines the outcome of the drop.
   *
   * You can signal that the drop is valid or invalid by setting `context.valid = false;`
   *
   * For translate type drags with {@link #config-cloneTarget}, you can also set `transitionTo` if you want to animate
   * the dragged proxy to a position before finalizing the operation. See class intro text for example usage.
   *
   * @event drop
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The element which we are moving, could be a cloned version of grabbed, or the grabbed element itself
   * @param {HTMLElement} context.target The target element below the cursor
   * @param {HTMLElement} context.grabbed The original element upon which the mousedown event triggered a drag operation
   * @param {HTMLElement[]} context.relatedElements An array of extra elements dragged with the main dragged element
   * @param {Boolean} context.valid true if the drop position is valid
   */
  /**
   * Fires after {@link #event-drop} and after drag proxy has animated to its final position (if setting `transitionTo`
   * on the drag context object).
   * @private
   * @event dropFinalized
   * @param {Core.helper.DragHelper} source
   * @param {Object} context
   * @param {HTMLElement} context.element The element which we are moving, could be a cloned version of grabbed, or the grabbed element itself
   * @param {HTMLElement} context.target The target element below the cursor
   * @param {HTMLElement} context.grabbed The original element upon which the mousedown event triggered a drag operation
   */
  onPointerDown(event) {
    const me = this;
    if (
      // Left button or touch allowed
      event.button !== 0 || // If a drag is ongoing already, finalize it and don't proceed with new drag (happens if pointerup happened
      // when current window wasn't focused - tab switch or window switch). Also handles the edge case of trying to
      // start a new drag while previous is awaiting finalization, in which case it just bails out.
      me.context
    ) {
      return;
    }
    if (me.isElementDraggable && !me.isElementDraggable(event.target, event)) {
      return;
    }
    me.startEvent = event;
    const handled = me.isContainerDrag ? me.grabContainerDrag(event) : me.grabTranslateDrag(event);
    if (handled) {
      me.blurDetacher = EventHelper.on({
        element: globalThis,
        blur: me.onWindowBlur,
        thisObj: me
      });
      const dragListeners = {
        element: me.mouseMoveListenerElement,
        thisObj: me,
        capture: true,
        keydown: rootElementListeners.keydown
      };
      if (event.pointerType === "touch") {
        me.touchStartTimer = me.setTimeout(() => me.touchStartTimer = null, me.touchStartDelay, "touchStartDelay");
        dragListeners.touchmove = {
          handler: rootElementListeners.touchmove,
          passive: false
          // We need to be able to preventDefault on the touchmove
        };
        dragListeners.touchend = dragListeners.pointerup = rootElementListeners.touchend;
      } else {
        dragListeners.pointermove = rootElementListeners.move;
        dragListeners.pointerup = rootElementListeners.up;
      }
      me.dragListenersDetacher = EventHelper.on(dragListeners);
      if (me.dragWithin && me.dragWithin !== me.outerElement && me.outerElement.contains(me.dragWithin)) {
        const box = Rectangle.from(me.dragWithin, me.outerElement);
        me.minY = box.top;
        me.maxY = box.bottom;
        me.minX = box.left;
        me.maxX = box.right;
      }
    }
  }
  async internalMove(event) {
    var _a2, _b;
    if (event.scrollInitiated) {
      return;
    }
    const me = this, { context } = me, distance = EventHelper.getDistanceBetween(me.startEvent, event), abortTouchDrag = me.touchStartTimer && distance > me.dragThreshold;
    if (abortTouchDrag) {
      me.abort(true);
      return;
    }
    if (!me.touchStartTimer && (context == null ? void 0 : context.element) && (context.started || distance >= me.dragThreshold) && // Ignore text nodes
    ((_a2 = event.target) == null ? void 0 : _a2.nodeType) === Node.ELEMENT_NODE) {
      if (!context.started) {
        if (me.trigger("beforeDragStart", { context, event }) === false) {
          return me.abort();
        }
        if (me.isContainerDrag) {
          me.startContainerDrag(event);
        } else {
          me.startTranslateDrag(event);
        }
        context.started = true;
        (_b = me.scrollManager) == null ? void 0 : _b.startMonitoring(ObjectHelper.merge({
          scrollables: [
            {
              element: me.dragWithin || me.outerElement
            }
          ],
          callback: me.onScrollManagerScrollCallback
        }, me.monitoringConfig));
        context.outermostEl = DomHelper.getOutermostElement(event.target);
        context.outermostEl.classList.add("b-draghelper-active");
        if (me.dropTargetSelector && me.dropTargetCls) {
          DomHelper.getRootElement(me.outerElement).querySelectorAll(me.dropTargetSelector).forEach(
            (el) => el.classList.add(me.dropTargetCls)
          );
        }
        const result = me.trigger("dragStart", { context, event });
        if (ObjectHelper.isPromise(result)) {
          await result;
        }
        context.moveUnblocked = true;
        if (me.isContainerDrag) {
          me.onContainerDragStarted(event);
        } else {
          me.onTranslateDragStarted(event);
        }
        me.trigger("afterDragStart", { context, event });
      }
      if (context.moveUnblocked) {
        if (me._cachedMouseEvent) {
          me.update(event);
          me.update(me._cachedMouseEvent);
          delete me._cachedMouseEvent;
        } else {
          me.update(event);
        }
      } else {
        me._cachedMouseEvent = event;
      }
      if (event.type === "touchmove") {
        event.preventDefault();
        event.stopImmediatePropagation();
      }
    }
  }
  onScrollManagerScrollCallback(config) {
    var _a2;
    const { lastMouseMoveEvent } = this;
    if (((_a2 = this.context) == null ? void 0 : _a2.element) && lastMouseMoveEvent) {
      lastMouseMoveEvent.isScroll = true;
      this.update(lastMouseMoveEvent, config);
    }
  }
  onTouchMove(event) {
    this.internalMove(event);
  }
  /**
   * Move drag element with mouse.
   * @param event
   * @fires beforeDragStart
   * @fires dragStart
   * @private
   */
  onMouseMove(event) {
    this.internalMove(event);
  }
  /**
   * Updates drag, called when an element is grabbed and mouse moves
   * @private
   * @fires drag
   */
  update(event, scrollManagerConfig) {
    const me = this, { context } = me, scrollingPageElement = document.scrollingElement || document.body;
    let target = me.getMouseMoveEventTarget(event);
    if (event.type === "touchmove") {
      const touch = event.changedTouches[0];
      target = DomHelper.elementFromPoint(touch.clientX + scrollingPageElement.scrollLeft, touch.clientY + scrollingPageElement.scrollTop);
    }
    context.target = target;
    let internallyValid = me.allowDropOutside || !me.dragWithin || me.dragWithin.contains(event.target);
    if (internallyValid && me.dropTargetSelector) {
      internallyValid = internallyValid && Boolean(target == null ? void 0 : target.closest(me.dropTargetSelector));
    }
    if (me.isContainerDrag) {
      me.updateContainerProxy(event, scrollManagerConfig);
    } else {
      me.updateTranslateProxy(event, scrollManagerConfig);
    }
    context.valid = internallyValid;
    me.trigger("drag", { context, event });
    if (me.isContainerDrag) {
      me.updateContainerDrag(event, scrollManagerConfig);
    }
    context.valid = context.valid && internallyValid;
    for (const element of me.draggedElements) {
      element.classList.toggle(me.invalidCls, !context.valid);
    }
    if (event) {
      me.lastMouseMoveEvent = event;
    }
  }
  get draggedElements() {
    var _a2;
    const { context } = this;
    return [context.dragProxy || context.element, ...(_a2 = context.relatedElements) != null ? _a2 : []];
  }
  /**
   * Abort dragging
   * @fires abort
   */
  async abort(silent = false) {
    var _a2, _b;
    const me = this, { context } = me;
    (_b = (_a2 = me.scrollManager) == null ? void 0 : _a2.stopMonitoring) == null ? void 0 : _b.call(_a2);
    me.removeListeners();
    if ((context == null ? void 0 : context.started) && !context.aborted) {
      context.element.getBoundingClientRect();
      context.valid = false;
      if (me.isContainerDrag) {
        me.abortContainerDrag(void 0, void 0, silent);
      } else {
        me.abortTranslateDrag(void 0, void 0, silent);
      }
      context.aborted = true;
    } else {
      me.reset(true);
    }
  }
  // Empty class implementation. If listeners *are* added, the detacher is added
  // as an instance property. So this is always callable.
  removeListeners() {
    var _a2, _b;
    (_a2 = this.dragListenersDetacher) == null ? void 0 : _a2.call(this);
    (_b = this.blurDetacher) == null ? void 0 : _b.call(this);
  }
  // Called when a drag operation is completed, or aborted
  // Removes DOM listeners and resets context
  reset(silent) {
    const me = this, { context } = me;
    if (context == null ? void 0 : context.started) {
      for (const element of me.draggedElements) {
        element.classList.remove(me.invalidCls);
      }
      context.outermostEl.classList.remove("b-draghelper-active");
      if (me.isContainerDrag) {
        context.dragProxy.remove();
      } else {
        me.cleanUp();
      }
      if (me.dropTargetSelector && me.dropTargetCls) {
        DomHelper.getRootElement(me.outerElement).querySelectorAll(me.dropTargetSelector).forEach(
          (el) => el.classList.remove(me.dropTargetCls)
        );
      }
    }
    me.removeListeners();
    if (!silent) {
      me.trigger("reset");
    }
    me.context = me.lastMouseMoveEvent = null;
  }
  onTouchEnd(event) {
    this.onMouseUp(event);
  }
  /**
   * This is a capture listener, only added during drag, which prevents a click gesture
   * propagating from the terminating mouseup gesture
   * @param {MouseEvent} event
   * @private
   */
  onDocumentClick(event) {
    event.stopPropagation();
  }
  /**
   * Drop on mouse up (if dropped on valid target).
   * @param event
   * @private
   */
  onMouseUp(event) {
    var _a2;
    const me = this, { context } = me;
    me.removeListeners();
    if (context) {
      (_a2 = me.scrollManager) == null ? void 0 : _a2.stopMonitoring();
      if (context.started) {
        if (context.moveUnblocked) {
          event.stopPropagation();
          context.finalizing = true;
          if (me.isContainerDrag) {
            me.finishContainerDrag(event);
          } else {
            me.finishTranslateDrag(event);
          }
          EventHelper.on({
            element: document,
            thisObj: me,
            click: rootElementListeners.docclick,
            capture: true,
            expires: me.clickSwallowDuration,
            // In case a click did not ensue, remove the listener
            once: true
          });
        } else {
          me.ion({
            drag() {
              me.onMouseUp(event);
            },
            once: true
          });
        }
      } else {
        me.reset(true);
      }
    }
  }
  /**
   * Cancel on ESC key
   * @param event
   * @private
   */
  onKeyDown(event) {
    var _a2;
    if (((_a2 = this.context) == null ? void 0 : _a2.started) && event.key === "Escape") {
      event.stopImmediatePropagation();
      this.abort();
    }
  }
  onWindowBlur() {
    if (this.context && !this.context.finalizing) {
      this.abort();
    }
  }
  /**
   * Creates the proxy element to be dragged, when using {@link #config-cloneTarget}. Clones the original element by default.
   * Override it to provide your own custom HTML element structure to be used as the drag proxy.
   * @param {HTMLElement} element The element from which the drag operation originated
   * @returns {HTMLElement}
   */
  createProxy(element) {
    if (this.proxySelector) {
      element = element.querySelector(this.proxySelector) || element;
    }
    const proxy = element.cloneNode(true);
    proxy.removeAttribute("id");
    return proxy;
  }
  //endregion
  get isContainerDrag() {
    return this.mode === "container";
  }
  /**
   * Animated the proxy element to be aligned with the passed element. Returns a Promise which resolves after the
   * DOM transition completes. Only applies to 'translateXY' mode.
   * @param {HTMLElement|Core.helper.util.Rectangle} element The target element or a Rectangle
   * @param {AlignSpec} [alignSpec] An object describing how to the align drag proxy to the target element
   * to offset the aligned widget further from the target. May be configured as -ve to move the aligned widget
   * towards the target - for example producing the effect of the anchor pointer piercing the target.
   */
  async animateProxyTo(targetElement, alignSpec = { align: "c-c" }) {
    const { context, draggedElements } = this, { element } = context, targetRect = targetElement.isRectangle ? targetElement : Rectangle.from(targetElement);
    draggedElements.forEach((el) => {
      el.classList.add("b-drag-final-transition");
      DomHelper.alignTo(el, targetRect, alignSpec);
    });
    await EventHelper.waitForTransitionEnd({
      element,
      property: "all",
      thisObj: this,
      once: true
    });
    draggedElements.forEach((el) => el.classList.remove("b-drag-final-transition"));
  }
  /**
   * Returns true if a drag operation is active
   * @property {Boolean}
   * @readonly
   */
  get isDragging() {
    var _a2;
    return Boolean((_a2 = this.context) == null ? void 0 : _a2.started);
  }
  //#region Salesforce hooks
  getMouseMoveEventTarget(event) {
    return !event.isScroll ? event.target : DomHelper.elementFromPoint(event.clientX, event.clientY);
  }
  //#endregion
};
DragHelper._$name = "DragHelper";

// ../Core/lib/Core/helper/ResizeHelper.js
var documentListeners = {
  down: "onMouseDown",
  move: "onMouseMove",
  up: "onMouseUp",
  docclick: "onDocumentClick",
  touchstart: {
    handler: "onTouchStart",
    // We preventDefault touchstart so as not to scroll. Must not be passive.
    // https://developers.google.com/web/updates/2017/01/scrolling-intervention
    passive: false
  },
  touchmove: "onTouchMove",
  touchend: "onTouchEnd",
  keydown: "onKeyDown"
};
var ResizeHelper = class extends Events_default(Base) {
  //region Config
  static get defaultConfig() {
    return {
      /**
       * CSS class added when resizing
       * @config {String}
       * @default
       */
      resizingCls: "b-resizing",
      /**
       * The amount of pixels to move mouse before it counts as a drag operation
       * @config {Number}
       * @default
       */
      dragThreshold: 5,
      /**
       * Resizing handle size
       * @config {Number}
       * @default
       */
      handleSize: 10,
      /**
       * Automatically shrink virtual handles when available space < handleSize. The virtual handles will
       * decrease towards width/height 1, reserving space between opposite handles to for example leave room for
       * dragging. To configure reserved space, see {@link #config-reservedSpace}.
       * @config {Boolean}
       * @default false
       */
      dynamicHandleSize: null,
      //
      /**
       * Room in px to leave unoccupied by handles when shrinking them dynamically (see
       * {@link #config-dynamicHandleSize}).
       * @config {Number}
       * @default
       */
      reservedSpace: 10,
      /**
       * Resizing handle size on touch devices
       * @config {Number}
       * @default
       */
      touchHandleSize: 30,
      /**
       * Minimum width when resizing
       * @config {Number}
       * @default
       */
      minWidth: 1,
      /**
       * Max width when resizing.
       * @config {Number}
       * @default
       */
      maxWidth: 0,
      /**
       * Minimum height when resizing
       * @config {Number}
       * @default
       */
      minHeight: 1,
      /**
       * Max height when resizing
       * @config {Number}
       * @default
       */
      maxHeight: 0,
      // outerElement, attach events to it and use as outer limit when looking for ancestors
      outerElement: document.body,
      /**
       * Optional scroller used to read scroll position. If unspecified, the outer element will be used.
       * @config {Core.helper.util.Scroller}
       */
      scroller: null,
      /**
       * Assign a function to determine if a hovered element can be resized or not.
       * Return `true` to allow resizing or `false` to prevent.
       * @config {Function}
       * @param {HTMLElement} element
       * @returns {Boolean}
       * @default
       */
      allowResize: null,
      /**
       * Outer element that limits where element can be dragged
       * @config {HTMLElement}
       * @default
       */
      dragWithin: null,
      /**
       * A function that determines if dragging an element is allowed. Gets called with the element as argument,
       * return `true` to allow dragging or `false` to prevent.
       * @config {Function}
       * @param {HTMLElement} element
       * @returns {Boolean}
       * @default
       */
      isElementResizable: null,
      /**
       * A CSS selector used to determine if resizing an element is allowed.
       * @config {String}
       * @default
       */
      targetSelector: null,
      /**
       * Use left handle when resizing. Only applies when `direction` is 'horizontal'
       * @config {Boolean}
       * @default
       */
      leftHandle: true,
      /**
       * Use right handle when resizing. Only applies when `direction` is 'horizontal'
       * @config {Boolean}
       * @default
       */
      rightHandle: true,
      /**
       * Use top handle when resizing. Only applies when `direction` is 'vertical'
       * @config {Boolean}
       * @default
       */
      topHandle: true,
      /**
       * Use bottom handle when resizing. Only applies when `direction` is 'vertical'
       * @config {Boolean}
       * @default
       */
      bottomHandle: true,
      /**
       * A CSS selector used to determine where handles should be "displayed" when resizing. Defaults to
       * targetSelector if unspecified
       * @config {String}
       */
      handleSelector: null,
      /**
       * A CSS selector used to determine which inner element contains handles.
       * @config {String}
       */
      handleContainerSelector: null,
      startEvent: null,
      /*
       * Optional config object, used by EventResize feature: it appends proxy and has to start resizing immediately
       * @config {Object}
       * @private
       */
      grab: null,
      /**
       * CSS class added when the resize state is invalid
       * @config {String}
       * @default
       */
      invalidCls: "b-resize-invalid",
      // A number that controls whether or not the element is wide enough for it to make sense to show resize handles
      // e.g. handle width is 10px, so doesn't make sense to show them unless handles on both sides fit
      handleVisibilityThreshold: null,
      // Private config that disables translation when resizing left edge. Useful for example in cases when element
      // being resized is part of a flex layout
      skipTranslate: false,
      /**
       * Direction to resize in, either 'horizontal' or 'vertical'
       * @config {'horizontal'|'vertical'}
       * @default
       */
      direction: "horizontal",
      clickSwallowDuration: 50,
      rtlSource: null
    };
  }
  //endregion
  //region Events
  /**
   * Fired while dragging
   * @event resizing
   * @param {Core.helper.ResizeHelper} source
   * @param {ResizeContext} context Resize context
   * @param {MouseEvent} event Browser event
   */
  /**
   * Fired when dragging starts.
   * @event resizeStart
   * @param {Core.helper.ResizeHelper} source
   * @param {ResizeContext} context Resize context
   * @param {MouseEvent|TouchEvent} event Browser event
   */
  /**
   * Fires after resize, and allows for asynchronous finalization by setting 'async' to `true` on the context object.
   * @event resize
   * @param {Core.helper.ResizeHelper} source
   * @param {ResizeContext} context Context about the resize operation. Set 'async' to `true` to indicate asynchronous
   * validation of the resize flow (for showing a confirmation dialog etc)
   */
  /**
   * Fires when a resize is canceled (width & height are reverted)
   * @event cancel
   * @param {Core.helper.ResizeHelper} source
   * @param {ResizeContext} context Resize context
   * @param {MouseEvent|TouchEvent} event Browser event
   */
  //endregion
  //region Init
  construct(config) {
    const me = this;
    super.construct(config);
    if (!me.handleSelector && !BrowserHelper.isHoverableDevice) {
      me.handleSize = me.touchHandleSize;
    }
    me.handleVisibilityThreshold = me.handleVisibilityThreshold || 2 * me.handleSize;
    me.initListeners();
    me.initResize();
  }
  doDestroy() {
    this.abort(true);
    super.doDestroy();
  }
  updateSkipUpdatingElement(skip) {
    if (skip) {
      this.skipTranslate = true;
    }
  }
  /**
   * Initializes resizing
   * @private
   */
  initResize() {
    const me = this;
    if (!me.isElementResizable && me.targetSelector) {
      me.isElementResizable = (element) => element.closest(me.targetSelector);
    }
    if (me.grab) {
      const { edge, element, event } = me.grab;
      me.startEvent = event;
      const cursorOffset = me.getCursorOffsetToElementEdge(event, element, edge);
      me.context = {
        element,
        edge,
        valid: true,
        async: false,
        elementStartX: DomHelper.getTranslateX(element) || element.offsetLeft,
        // extract x from translate
        elementStartY: DomHelper.getTranslateY(element) || element.offsetTop,
        // extract x from translate
        newX: DomHelper.getTranslateX(element) || element.offsetLeft,
        // No change yet on start, but info must be present
        newY: DomHelper.getTranslateY(element) || element.offsetTop,
        // No change yet on start, but info must be present
        elementWidth: element.offsetWidth,
        elementHeight: element.offsetHeight,
        cursorOffset,
        startX: event.clientX + cursorOffset.x + me.scrollLeft,
        startY: event.clientY + cursorOffset.y + me.scrollTop,
        finalize: () => {
          var _a2;
          return (_a2 = me.reset) == null ? void 0 : _a2.call(me);
        }
      };
      element.classList.add(me.resizingCls);
      me.internalStartResize(me.isTouch);
    }
  }
  /**
   * Initialize listeners
   * @private
   */
  initListeners() {
    const me = this, dragStartListeners = {
      element: me.outerElement,
      mousedown: documentListeners.down,
      touchstart: documentListeners.touchstart,
      thisObj: me
    };
    if (!me.handleSelector && BrowserHelper.isHoverableDevice) {
      dragStartListeners.mousemove = {
        handler: documentListeners.move,
        // Filter events for checkResizeHandles so we only get called if the mouse
        // is over one of our targets.
        delegate: me.targetSelector
      };
      dragStartListeners.mouseleave = {
        handler: "onMouseLeaveTarget",
        delegate: me.targetSelector,
        capture: true
      };
    }
    EventHelper.on(dragStartListeners);
  }
  get isRTL() {
    var _a2;
    return Boolean((_a2 = this.rtlSource) == null ? void 0 : _a2.rtl);
  }
  //endregion
  //region Scroll helpers
  get scrollLeft() {
    if (this.scroller) {
      return this.scroller.x;
    }
    return this.outerElement.scrollLeft;
  }
  get scrollTop() {
    if (this.scroller) {
      return this.scroller.y;
    }
    return this.outerElement.scrollTop;
  }
  //endregion
  //region Events
  internalStartResize(isTouch) {
    var _a2;
    const dragListeners = {
      element: document,
      keydown: documentListeners.keydown,
      thisObj: this
    };
    if (isTouch) {
      dragListeners.touchmove = documentListeners.touchmove;
      dragListeners.touchend = dragListeners.pointerup = documentListeners.touchend;
    } else {
      dragListeners.mousemove = documentListeners.move;
      dragListeners.mouseup = documentListeners.up;
    }
    this.removeDragListeners = EventHelper.on(dragListeners);
    (_a2 = this.onResizeHandlePointerDown) == null ? void 0 : _a2.call(this, this.startEvent);
  }
  // Empty class implementation. If listeners *are* added, the detacher is added
  // as an instance property. So this is always callable.
  removeDragListeners() {
  }
  reset() {
    var _a2;
    (_a2 = this.removeDragListeners) == null ? void 0 : _a2.call(this);
    this.context = null;
    this.trigger("reset");
  }
  canResize(element, event) {
    return !this.isElementResizable || this.isElementResizable(element, event);
  }
  onPointerDown(isTouch, event) {
    const me = this;
    me.startEvent = event;
    if (me.canResize(event.target, event) && me.grabResizeHandle(isTouch, event)) {
      event.stopImmediatePropagation();
      if (event.type === "touchstart") {
        event.preventDefault();
      }
      me.internalStartResize(isTouch);
    }
  }
  onTouchStart(event) {
    if (event.touches.length > 1) {
      return;
    }
    this.onPointerDown(true, event);
  }
  /**
   * Grab draggable element on mouse down.
   * @private
   * @param {MouseEvent|PointerEvent} event
   */
  onMouseDown(event) {
    if (event.button !== 0) {
      return;
    }
    this.onPointerDown(false, event);
  }
  internalMove(isTouch, event) {
    var _a2;
    const me = this, { context, direction } = me;
    if ((context == null ? void 0 : context.element) && (context.started || EventHelper.getDistanceBetween(me.startEvent, event) >= me.dragThreshold)) {
      if (!context.started) {
        (_a2 = me.scrollManager) == null ? void 0 : _a2.startMonitoring(ObjectHelper.merge({
          scrollables: [
            {
              element: me.dragWithin || me.outerElement,
              direction
            }
          ],
          callback: (config) => {
            var _a3;
            return ((_a3 = me.context) == null ? void 0 : _a3.element) && me.lastMouseMoveEvent && me.update(me.lastMouseMoveEvent, config);
          }
        }, me.monitoringConfig));
        me.trigger("resizeStart", { context, event });
        context.started = true;
      }
      me.update(event);
    } else if (!isTouch && !me.handleSelector) {
      me.checkResizeHandles(event);
    }
  }
  onTouchMove(event) {
    this.internalMove(true, event);
  }
  /**
   * Move grabbed element with mouse.
   * @param {MouseEvent|PointerEvent} event
   * @fires resizestart
   * @private
   */
  onMouseMove(event) {
    this.internalMove(false, event);
  }
  onPointerUp(isTouch, event) {
    var _a2, _b, _c;
    const me = this, context = me.context;
    (_a2 = me.removeDragListeners) == null ? void 0 : _a2.call(me);
    if (context) {
      (_b = me.scrollManager) == null ? void 0 : _b.stopMonitoring();
      if (context.started) {
        EventHelper.on({
          element: document,
          thisObj: me,
          click: documentListeners.docclick,
          expires: me.clickSwallowDuration,
          // In case a click did not ensue, remove the listener
          capture: true,
          once: true
        });
      }
      me.finishResize(event);
    } else {
      (_c = me.reset) == null ? void 0 : _c.call(me);
    }
  }
  onTouchEnd(event) {
    this.onPointerUp(true, event);
  }
  /**
   * Drop on mouse up (if dropped on valid target).
   * @param {MouseEvent|PointerEvent} event
   * @private
   */
  onMouseUp(event) {
    this.onPointerUp(false, event);
  }
  /**
   * This is a capture listener, only added during drag, which prevents a click gesture
   * propagating from the terminating mouseup gesture
   * @param {MouseEvent} event
   * @private
   */
  onDocumentClick(event) {
    event.stopPropagation();
  }
  /**
   * Cancel on ESC key
   * @param {KeyboardEvent} event
   * @private
   */
  onKeyDown(event) {
    if (event.key === "Escape") {
      this.abort();
    }
  }
  //endregion
  //region Grab, update, finish
  /**
   * Updates resize, called when an element is grabbed and mouse moves
   * @private
   * @fires resizing
   */
  update(event) {
    const me = this, context = me.context, { element } = context, parentRectangle = Rectangle.from(me.outerElement);
    context.currentX = Math.max(Math.min(event.clientX + context.cursorOffset.x, parentRectangle.right), parentRectangle.x) + me.scrollLeft;
    context.currentY = Math.max(Math.min(event.clientY + context.cursorOffset.y, parentRectangle.bottom), parentRectangle.y) + me.scrollTop;
    element.classList.add(me.resizingCls);
    if (event) {
      if (me.updateResize(event)) {
        me.trigger("resizing", { context, event });
        element.classList.toggle(me.invalidCls, context.valid === false);
      }
      me.lastMouseMoveEvent = event;
    }
  }
  /**
   * Abort dragging
   */
  abort(silent = false) {
    var _a2, _b;
    const me = this;
    (_b = (_a2 = me.scrollManager) == null ? void 0 : _a2.stopMonitoring) == null ? void 0 : _b.call(_a2);
    if (me.context) {
      me.abortResize(null, silent);
    } else if (!me.isDestroyed) {
      me.reset();
    }
  }
  /**
   * Starts resizing, updates ResizeHelper#context with relevant info.
   * @private
   * @param {Boolean} isTouch
   * @param {MouseEvent} event
   * @returns {Boolean} True if handled, false if not
   */
  grabResizeHandle(isTouch, event) {
    var _a2;
    const me = this;
    if (me.allowResize && !me.allowResize(event.target, event)) {
      return false;
    }
    const handleSelector = me.handleSelector, coordsFrom = event.type === "touchstart" ? event.changedTouches[0] : event, clientX = coordsFrom.clientX, clientY = coordsFrom.clientY;
    let element = me.targetSelector ? event.target.closest(me.targetSelector) : event.target;
    if (element) {
      let edge;
      if (handleSelector) {
        if (event.target.matches(handleSelector)) {
          if (me.direction === "horizontal") {
            if (event.pageX < DomHelper.getPageX(element) + element.offsetWidth / 2) {
              edge = me.isRTL ? "right" : "left";
            } else {
              edge = me.isRTL ? "left" : "right";
            }
          } else {
            if (event.pageY < DomHelper.getPageY(element) + element.offsetHeight / 2) {
              edge = "top";
            } else {
              edge = "bottom";
            }
          }
        } else {
          return false;
        }
      } else {
        if (me.direction === "horizontal") {
          if (me.overLeftHandle(event, element)) {
            edge = me.isRTL ? "right" : "left";
          } else if (me.overRightHandle(event, element)) {
            edge = me.isRTL ? "left" : "right";
          }
        } else {
          if (me.overTopHandle(event, element)) {
            edge = "top";
          } else if (me.overBottomHandle(event, element)) {
            edge = "bottom";
          }
        }
        if (!edge) {
          me.context = null;
          return false;
        }
      }
      if (event.type === "touchstart") {
        event.preventDefault();
      }
      const cursorOffset = me.getCursorOffsetToElementEdge(coordsFrom, element, edge), mutatedContext = (_a2 = me.internalBeforeStart) == null ? void 0 : _a2.call(me, { element, edge });
      if (mutatedContext) {
        element = mutatedContext.element;
        edge = mutatedContext.edge;
      }
      if (me.trigger("beforeResizeStart", { element, event }) !== false) {
        me.context = {
          element,
          edge,
          isTouch,
          valid: true,
          async: false,
          direction: me.direction,
          elementStartX: DomHelper.getTranslateX(element) || element.offsetLeft,
          // extract x from translate
          elementStartY: DomHelper.getTranslateY(element) || element.offsetTop,
          // extract y from translate
          newX: DomHelper.getTranslateX(element) || element.offsetLeft,
          // No change yet on start, but info must be present
          newY: DomHelper.getTranslateY(element) || element.offsetTop,
          // No change yet on start, but info must be present
          elementWidth: element.offsetWidth,
          elementHeight: element.offsetHeight,
          cursorOffset,
          startX: clientX + cursorOffset.x + me.scrollLeft,
          startY: clientY + cursorOffset.y + me.scrollTop,
          finalize: () => {
            var _a3;
            return (_a3 = me.reset) == null ? void 0 : _a3.call(me);
          }
        };
        element.classList.add(me.resizingCls);
        return true;
      }
    }
    return false;
  }
  getCursorOffsetToElementEdge(event, element, edge) {
    const rectEl = Rectangle.from(element);
    let x = 0, y = 0;
    switch (edge) {
      case "left":
        x = rectEl.x - (this.isRTL ? rectEl.width : 0) - event.clientX;
        break;
      case "right":
        x = rectEl.x + (this.isRTL ? 0 : rectEl.width) - event.clientX;
        break;
      case "top":
        y = rectEl.y - event.clientY;
        break;
      case "bottom":
        y = rectEl.y + rectEl.height - event.clientY;
        break;
    }
    return { x, y };
  }
  /**
   * Check if mouse is over a resize handle (virtual). If so, highlight.
   * @private
   * @param {MouseEvent} event
   */
  checkResizeHandles(event) {
    const me = this, target = me.targetSelector ? event.target.closest(me.targetSelector) : event.target;
    if (target && (!me.allowResize || me.allowResize(event.target, event))) {
      me.currentElement = me.handleContainerSelector ? event.target.closest(me.handleContainerSelector) : event.target;
      if (me.currentElement) {
        let over;
        if (me.direction === "horizontal") {
          over = me.overLeftHandle(event, target) || me.overRightHandle(event, target);
        } else {
          over = me.overTopHandle(event, target) || me.overBottomHandle(event, target);
        }
        if (over) {
          me.highlightHandle();
        } else {
          me.unHighlightHandle();
        }
      }
    } else if (me.currentElement) {
      me.unHighlightHandle();
    }
  }
  onMouseLeaveTarget(event) {
    const me = this;
    me.currentElement = me.handleContainerSelector ? event.target.closest(me.handleContainerSelector) : event.target;
    if (me.currentElement) {
      me.unHighlightHandle();
    }
  }
  /**
   * Updates size of target (on mouse move).
   * @private
   * @param {MouseEvent|PointerEvent} event
   */
  updateResize(event) {
    const me = this, {
      context,
      allowEdgeSwitch,
      skipTranslate,
      skipUpdatingElement
    } = me;
    let updated;
    if (allowEdgeSwitch) {
      if (me.direction === "horizontal") {
        context.edge = context.currentX > context.startX ? "right" : "left";
      } else {
        context.edge = context.currentY > context.startY ? "bottom" : "top";
      }
    }
    const {
      element,
      elementStartX,
      elementStartY,
      elementWidth,
      elementHeight,
      edge
    } = context, { style } = element, deltaX = context.currentX - context.startX, deltaY = context.currentY - context.startY, minWidth = DomHelper.getExtremalSizePX(element, "minWidth") || me.minWidth, maxWidth = DomHelper.getExtremalSizePX(element, "maxWidth") || me.maxWidth, minHeight = DomHelper.getExtremalSizePX(element, "minHeight") || me.minHeight, maxHeight = DomHelper.getExtremalSizePX(element, "maxHeight") || me.maxHeight, sign = edge === "right" && !me.isRTL || edge === "bottom" ? 1 : -1, newWidth = elementWidth + deltaX * sign, newHeight = elementHeight + deltaY * sign;
    let width = Math.max(minWidth, newWidth), height = Math.max(minHeight, newHeight);
    if (maxWidth > 0) {
      width = Math.min(width, maxWidth);
    }
    if (maxHeight > 0) {
      height = Math.min(height, maxHeight);
    }
    if (style.flex) {
      style.flex = "";
    }
    if (me.direction === "horizontal" && elementWidth !== width) {
      if (!skipUpdatingElement) {
        style.width = Math.abs(width) + "px";
      }
      context.newWidth = width;
      if (edge === "left" || width < 0) {
        const newX = Math.max(Math.min(elementStartX + elementWidth - me.minWidth, elementStartX + deltaX), 0);
        if (!skipTranslate) {
          DomHelper.setTranslateX(element, Math.round(newX));
        }
        context.newX = newX;
      } else if (edge === "right" && allowEdgeSwitch && !skipTranslate) {
        DomHelper.setTranslateX(element, elementStartX);
      }
      updated = true;
    } else if (me.direction === "vertical" && elementHeight !== newHeight) {
      if (!skipUpdatingElement) {
        style.height = Math.abs(height) + "px";
      }
      context.newHeight = height;
      if (edge === "top" || height < 0) {
        context.newY = Math.max(Math.min(elementStartY + elementHeight - me.minHeight, elementStartY + deltaY), 0);
        if (!skipTranslate) {
          DomHelper.setTranslateY(element, context.newY);
        }
      } else if (edge === "bottom" && allowEdgeSwitch && !skipTranslate) {
        DomHelper.setTranslateY(element, elementStartY);
      }
      updated = true;
    }
    return updated;
  }
  /**
   * Finalizes resize, fires drop.
   * @private
   * @param {MouseEvent|PointerEvent} event
   * @fires resize
   * @fires cancel
   */
  finishResize(event) {
    var _a2;
    const me = this, context = me.context, eventObject = { context, event };
    context.element.classList.remove(me.resizingCls);
    if (context.started) {
      let changed = false;
      if (me.direction === "horizontal") {
        changed = context.newWidth && context.newWidth !== context.elementWidth;
      } else {
        changed = context.newHeight && context.newHeight !== context.elementHeight;
      }
      me.trigger(changed ? "resize" : "cancel", eventObject);
      if (!context.async) {
        context.finalize();
      }
    } else {
      (_a2 = me.reset) == null ? void 0 : _a2.call(me);
    }
  }
  /**
   * Abort resizing
   * @private
   * @fires cancel
   */
  abortResize(event = null, silent = false) {
    const me = this, context = me.context;
    context.element.classList.remove(me.resizingCls);
    if (me.direction === "horizontal") {
      if (context.edge === "left" || context.allowEdgeSwitch && !context.skipTranslate) {
        DomHelper.setTranslateX(context.element, context.elementStartX);
      }
      context.element.style.width = context.elementWidth + "px";
    } else {
      DomHelper.setTranslateY(context.element, context.elementStartY);
      context.element.style.height = context.elementHeight + "px";
    }
    !silent && me.trigger("cancel", { context, event });
    if (!me.isDestroyed) {
      me.reset();
    }
  }
  //endregion
  //region Handles
  // /**
  //  * Constrain resize to outerElements bounds
  //  * @private
  //  * @param x
  //  * @returns {*}
  //  */
  // constrainResize(x) {
  //     const me = this;
  //
  //     if (me.outerElement) {
  //         const box = me.outerElement.getBoundingClientRect();
  //         if (x < box.left) x = box.left;
  //         if (x > box.right) x = box.right;
  //     }
  //
  //     return x;
  // }
  /**
   * Highlights handles (applies css that changes cursor).
   * @private
   */
  highlightHandle() {
    const me = this, target = me.targetSelector ? me.currentElement.closest(me.targetSelector) : me.currentElement;
    me.currentElement.classList.add("b-resize-handle");
    target.classList.add("b-over-resize-handle");
  }
  /**
   * Unhighlight handles (removes css).
   * @private
   */
  unHighlightHandle() {
    const me = this, target = me.targetSelector ? me.currentElement.closest(me.targetSelector) : me.currentElement;
    target && target.classList.remove("b-over-resize-handle");
    me.currentElement.classList.remove("b-resize-handle");
    me.currentElement = null;
  }
  overAnyHandle(event, target) {
    return this.overStartHandle(event, target) || this.overEndHandle(event, target);
  }
  overStartHandle(event, target) {
    return this.direction === "horizontal" ? this.overLeftHandle(event, target) : this.overTopHandle(event, target);
  }
  overEndHandle(event, target) {
    return this.direction === "horizontal" ? this.overRightHandle(event, target) : this.overBottomHandle(event, target);
  }
  getDynamicHandleSize(opposite, offsetWidth) {
    const handleCount = opposite ? 2 : 1, { handleSize } = this;
    if (this.dynamicHandleSize && handleSize * handleCount > offsetWidth - this.reservedSpace) {
      return Math.max(Math.floor((offsetWidth - this.reservedSpace) / handleCount), 0);
    }
    return handleSize;
  }
  /**
   * Check if over left handle (virtual).
   * @private
   * @param {MouseEvent} event MouseEvent
   * @param {HTMLElement} target The current target element
   * @returns {Boolean} Returns true if mouse is over left handle, otherwise false
   */
  overLeftHandle(event, target) {
    const me = this, { offsetWidth } = target;
    if (me.leftHandle && me.canResize(target, event) && (offsetWidth >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const leftHandle = Rectangle.from(target);
      leftHandle.width = me.getDynamicHandleSize(me.rightHandle, offsetWidth);
      return leftHandle.width > 0 && leftHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  /**
   * Check if over right handle (virtual).
   * @private
   * @param {MouseEvent} event MouseEvent
   * @param {HTMLElement} target The current target element
   * @returns {Boolean} Returns true if mouse is over left handle, otherwise false
   */
  overRightHandle(event, target) {
    const me = this, { offsetWidth } = target;
    if (me.rightHandle && me.canResize(target, event) && (offsetWidth >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const rightHandle = Rectangle.from(target);
      rightHandle.x = rightHandle.right - me.getDynamicHandleSize(me.leftHandle, offsetWidth);
      return rightHandle.width > 0 && rightHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  /**
   * Check if over top handle (virtual).
   * @private
   * @param {MouseEvent} event MouseEvent
   * @param {HTMLElement} target The current target element
   * @returns {Boolean} Returns true if mouse is over top handle, otherwise false
   */
  overTopHandle(event, target) {
    const me = this, { offsetHeight } = target;
    if (me.topHandle && me.canResize(target, event) && (offsetHeight >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const topHandle = Rectangle.from(target);
      topHandle.height = me.getDynamicHandleSize(me.bottomHandle, offsetHeight);
      return topHandle.height > 0 && topHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  /**
   * Check if over bottom handle (virtual).
   * @private
   * @param {MouseEvent} event MouseEvent
   * @param {HTMLElement} target The current target element
   * @returns {Boolean} Returns true if mouse is over bottom handle, otherwise false
   */
  overBottomHandle(event, target) {
    const me = this, { offsetHeight } = target;
    if (me.bottomHandle && me.canResize(target, event) && (offsetHeight >= me.handleVisibilityThreshold || me.dynamicHandleSize)) {
      const bottomHandle = Rectangle.from(target);
      bottomHandle.y = bottomHandle.bottom - me.getDynamicHandleSize(me.bottomHandle, offsetHeight);
      return bottomHandle.height > 0 && bottomHandle.contains(EventHelper.getPagePoint(event));
    }
    return false;
  }
  //endregion
};
__publicField(ResizeHelper, "configurable", {
  // Private config that disables updating elements width and position, for when data is live updated during
  // resize, leading to element being redrawn
  skipUpdatingElement: null
});
ResizeHelper._$name = "ResizeHelper";

// ../Core/lib/Core/helper/TemplateHelper.js
var tagSpaceRe = />[ \t\r\n]+</g;
var multiSpaceRe = /\s\s+/g;
var TemplateHelper = class _TemplateHelper {
  /**
   * Tag function for template literals that does some basic cleanup
   * @private
   */
  static tpl(strings, ...values) {
    let count = 0, output = values.map((val, i) => {
      let ret = strings[i];
      if (Array.isArray(val)) {
        ret += val.reduce((ack, item) => ack += (typeof item === "string" ? item.trim() : item) + "\n", "");
      } else {
        if (val === void 0) {
          val = "";
        }
        ret += typeof val === "string" ? val.trim() : val;
      }
      count++;
      return ret;
    }).join("");
    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }
    return output.replace(tagSpaceRe, "><").replace(multiSpaceRe, " ").trim();
  }
  /**
   * Tag function for template literals that does some basic cleanup. Version for docs that do not remove blank space,
   * to keep code snippets formatting intact.
   * @private
   */
  static docsTpl(strings, ...values) {
    let count = 0, output = values.map((val, i) => {
      let ret = strings[i];
      if (Array.isArray(val)) {
        ret += val.reduce((ack, item) => ack += (typeof item === "string" ? item.trim() : item) + "\n", "");
      } else {
        if (val === void 0) {
          val = "";
        }
        ret += typeof val === "string" ? val.trim() : val;
      }
      count++;
      return ret;
    }).join("");
    if (count <= strings.length) {
      output += strings[strings.length - 1];
    }
    return output.replace(tagSpaceRe, "><").trim();
  }
  static repeat(times) {
    return function(...args) {
      return _TemplateHelper.tpl(...args).repeat(times);
    };
  }
  static loop(times) {
  }
};
TemplateHelper._$name = "TemplateHelper";

// ../Core/lib/Core/helper/TimeZoneHelper.js
var TimeZoneOffsetInfo = class extends Array {
  constructor(timeZone, year) {
    super();
    this.timeZone = timeZone;
    this.year = year;
  }
};
var TimeZoneDate = class {
  constructor(asString, timeZone) {
    this.asString = asString;
    this.timeZone = timeZone;
    this.asArray = parseStringDate(asString);
  }
  // Lazy, used in TZH.toTimeZone
  get asLocalDate() {
    if (!this._asLocalDate) {
      this._asLocalDate = new Date(...this.asArray);
    }
    return this._asLocalDate;
  }
  // Lazy, used when finding offsets
  get asTicksUtc() {
    if (!this._asTicksUtc) {
      this._asTicksUtc = new Date(Date.UTC(...this.asArray)).getTime();
    }
    return this._asTicksUtc;
  }
};
var toTimeZoneInternal = (date, timeZone) => {
  const tzDateString = date.toLocaleString("sv-SE", { timeZone });
  return new TimeZoneDate(tzDateString, timeZone);
};
var getOffsetUtc = (ticks, timeZone) => {
  const { asTicksUtc, asString } = toTimeZoneInternal(new Date(ticks), timeZone);
  return { offset: (ticks - asTicksUtc) / 6e4, tzTicksUtc: asTicksUtc, tzString: asString };
};
var parseStringDate = (stringDate) => {
  const parsed = stringDate.split(/[\s-:]/).map((i) => i * 1);
  parsed[1] -= 1;
  return parsed;
};
var min = -6e4;
var hour = 36e5;
var day = -864e5;
var month = 2592e6;
var findOffsetDates = (timeZone, year) => {
  const cached = offsetDateCache.get(timeZone, year);
  if (cached) {
    return cached;
  }
  const offsets = new TimeZoneOffsetInfo(timeZone, year), startUtcTicks = new Date(Date.UTC(year, 0, 1)).getTime();
  let ticks = startUtcTicks, incr = month, monthIndex = 0, previousOffset = [], currentOffset = null, tzTicksUtc, tzString, offset, done;
  while (!done) {
    ({ offset, tzTicksUtc, tzString } = getOffsetUtc(ticks, timeZone));
    if (currentOffset == null) {
      currentOffset = offset;
      offsets.push({ offset });
    } else if (incr > 0 && offset !== currentOffset) {
      incr = incr === month ? day : min;
    } else if (incr < 0 && offset === currentOffset) {
      if (incr === day) {
        incr = hour;
      } else {
        if (offsets.length === 1) {
          offsets.push(previousOffset);
          currentOffset = previousOffset.offset;
        } else {
          offsets[0].startTicks = previousOffset.startTicks;
          offsets[0].startDateString = previousOffset.startDateString;
          done = true;
        }
        incr = month;
      }
    }
    previousOffset = { offset, startDateString: tzString, startTicks: tzTicksUtc };
    if (incr === month) {
      ticks = startUtcTicks;
      ticks += monthIndex * month;
      monthIndex += 1;
    }
    ticks += incr;
    if (monthIndex > 11) {
      done = true;
    }
  }
  offsetDateCache.set(offsets);
  return offsets;
};
var offsetDateCache = {
  _cache: {},
  get(timeZone, year) {
    var _a2;
    return (_a2 = this._cache[timeZone]) == null ? void 0 : _a2[year];
  },
  set(offsetInfo) {
    const { timeZone } = offsetInfo, { _cache } = this;
    if (!_cache[timeZone]) {
      _cache[timeZone] = {};
    }
    _cache[timeZone][offsetInfo.year] = offsetInfo;
  }
};
var TimeZoneHelper = class {
  static get $name() {
    return "TimeZoneHelper";
  }
  /**
   * Adjusts the time of the specified date to match the specified time zone. i.e. "what time is it now in this
   * timezone?"
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * Note that this time zone calculation relies on the browsers built-in functionality to convert a local date to a
   * string in a given time zone and then converting the string back into a date. If browsers time zone information
   * or interpretation is inaccurate or lacks data, the conversion will probably be inaccurate as well.
   *
   * ```javascript
   * const localDate = new Date(2020, 7, 31, 7); // UTC+2 ('Europe/Stockholm')
   * const cstDate   = TimeZoneHelper.toTimezone(localDate, 'America/Chicago'); // 2020, 7, 31, 0 (still UTC+2, but
   * // appear as UTC-6)
   * ```
   *
   * @static
   * @param {Date} date
   * @param {String|Number} timeZone Timezone supported by `Intl.DateFormat` or a UTC offset in minutes
   * @returns {Date}
   */
  static toTimeZone(date, timeZone) {
    if (typeof timeZone === "number") {
      return this.toUtcOffset(date, timeZone);
    }
    const tzDate = toTimeZoneInternal(date, timeZone);
    if (tzDate.asArray[3] !== tzDate.asLocalDate.getHours()) {
      console.warn("Incorrect time zone conversion due to local DST-switch detected");
    }
    return tzDate.asLocalDate;
  }
  /**
   * Adjusts the time of the specified date to match local system time zone in the specified time zone. i.e. "what
   * time in my timezone would match time in this timezone?"
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * Note that this time zone calculation relies on the browsers built-in functionality to convert a date from a given
   * timezone into a local date by calculating specified time zone UTC offsets and using those to perform the date
   * conversion. If browsers time zone information or interpretation is inaccurate or lacks data, the conversion will
   * probably be inaccurate as well.
   *
   * ```javascript
   * const cstDate   = new Date(2022, 8, 27, 4); // CST 'America/Chicago'
   * const localDate = TimeZoneHelper.fromTimeZone(cstDate, 'America/Chicago'); // 2022, 8, 27, 11 (UTC+2 Europe/Stockholm)
   * ```
   *
   * @static
   * @param {Date} date
   * @param {String|Number} timeZone Timezone supported by Intl.DateFormat or a UTC offset in minutes
   * @returns {Date}
   */
  static fromTimeZone(date, timeZone) {
    if (typeof timeZone === "number") {
      return this.fromUtcOffset(date, timeZone);
    }
    const dateArr = this.dateAsArray(date), offsetDates = findOffsetDates(timeZone, date.getUTCFullYear());
    let useOffset = offsetDates[0].offset;
    if (offsetDates.length === 2) {
      const utcTicks = Date.UTC(...dateArr);
      if (utcTicks >= offsetDates[1].startTicks && utcTicks < offsetDates[0].startTicks) {
        useOffset = offsetDates[1].offset;
      }
    }
    dateArr[4] += useOffset;
    return new Date(Date.UTC(...dateArr));
  }
  /**
   * Adjusts the time of the specified date with provided UTC offset in minutes
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * ```javascript
   * const localDate = new Date(2020, 7, 31, 7); // UTC+2
   * const utcDate   = TimeZoneHelper.toUtcOffset(localDate, 0); // 2020, 7, 31, 5 (still UTC+2, but appear as UTC+0)
   * ```
   *
   * @static
   * @private
   * @param {Date} date
   * @param {Number} utcOffset in minutes
   * @returns {Date}
   */
  static toUtcOffset(date, utcOffset) {
    const offset = date.getTimezoneOffset() + utcOffset;
    return new Date(date.getTime() + offset * 60 * 1e3);
  }
  /**
   * Adjusts the time of the specified date by removing the provided UTC offset in minutes.
   *
   * JavaScript dates are always in the local time zone. This function adjusts the time to match the time in the
   * specified time zone, without altering the time zone. Thus, it won't hold the same time as the original date.
   *
   * ```javascript
   * const utcDate = new Date(2020, 7, 31, 7); // UTC
   * const utcDate = TimeZoneHelper.fromUtcOffset(localDate, 0); // 2020, 7, 31, 9 (matches 2020-08-31 07:00+00:00)
   * ```
   *
   * @static
   * @private
   * @param {Date} date
   * @param {Number} utcOffset in minutes
   * @returns {Date}
   */
  static fromUtcOffset(date, utcOffset) {
    const offset = -date.getTimezoneOffset() - utcOffset;
    return new Date(date.getTime() + offset * 60 * 1e3);
  }
  // Converts a date into an array of its parts ([year, month, day, etc.]).
  // Convenient as a date info bearer which is not affected by local time zone
  static dateAsArray(date) {
    return [date.getFullYear(), date.getMonth(), date.getDate(), date.getHours(), date.getMinutes(), date.getSeconds(), date.getMilliseconds()];
  }
};
TimeZoneHelper.findOffsetDates = findOffsetDates;
TimeZoneHelper._$name = "TimeZoneHelper";

// ../Core/lib/Core/widget/Toast.js
var _Toast = class _Toast extends Widget {
  static get configurable() {
    return {
      testConfig: {
        destroyTimeout: 1,
        timeout: 1e3
      },
      floating: true,
      /**
       * Timeout (in ms) until the toast is automatically dismissed. Set to 0 to never hide.
       * @config {Number}
       * @default
       */
      timeout: 2500,
      autoDestroy: null,
      // How long to wait after hide before destruction
      destroyTimeout: 200,
      /**
       * Show a progress bar indicating the time remaining until the toast is dismissed.
       * @config {Boolean}
       * @default
       */
      showProgress: true,
      /**
       * Toast color (should have match in toast.scss or your custom styling).
       * Valid values in Bryntum themes are:
       * * b-amber
       * * b-blue
       * * b-dark-gray
       * * b-deep-orange
       * * b-gray
       * * b-green
       * * b-indigo
       * * b-lime
       * * b-light-gray
       * * b-light-green
       * * b-orange
       * * b-purple
       * * b-red
       * * b-teal
       * * b-white
       * * b-yellow
       *
       * ```
       * new Toast({
       *    color : 'b-blue'
       * });
       * ```
       *
       * @config {String}
       */
      color: null,
      bottomMargin: 20
    };
  }
  compose() {
    const { appendTo, color, html, showProgress, style, timeout } = this;
    return {
      parent: appendTo || this.floatRoot,
      class: {
        ...DomClassList.normalize(color, "object"),
        "b-toast-hide": 1
        // toasts start hidden so we can animate them into view
      },
      html,
      style,
      children: {
        progressElement: showProgress && {
          style: `animation-duration:${timeout / 1e3}s;`,
          class: {
            "b-toast-progress": 1
          }
        }
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: "hide"
      }
    };
  }
  doDestroy() {
    this.untoast();
    super.doDestroy();
  }
  get nextBottom() {
    const { bottomMargin, element } = this;
    return parseInt(element.style.bottom, 10) + element.offsetHeight + bottomMargin;
  }
  /**
   * Show the toast
   */
  async show() {
    var _a2, _b;
    await super.show(...arguments);
    const me = this, { element } = me, { toasts } = _Toast;
    if (!toasts.includes(me)) {
      element.style.bottom = ((_b = (_a2 = toasts[0]) == null ? void 0 : _a2.nextBottom) != null ? _b : me.bottomMargin) + "px";
      toasts.unshift(me);
      element.getBoundingClientRect();
      element.classList.remove("b-toast-hide");
      if (me.timeout > 0) {
        me.hideTimeout = me.setTimeout("hide", me.timeout);
      }
    }
  }
  /**
   * Hide the toast
   */
  async hide() {
    const me = this;
    me.untoast();
    me.element.classList.add("b-toast-hide");
    if (me.autoDestroy && !me.destroyTimer) {
      me.destroyTimer = me.setTimeout("destroy", me.destroyTimeout);
    }
  }
  untoast() {
    const { toasts } = _Toast;
    if (toasts.includes(this)) {
      toasts.splice(toasts.indexOf(this), 1);
    }
  }
  /**
   * Hide all visible toasts
   */
  static hideAll() {
    _Toast.toasts.slice().reverse().forEach((toast) => toast.hide());
  }
  /**
   * Easiest way to show a toast
   *
   * ```javascript
   * Toast.show('Hi');
   *
   * Toast.show({
   *   html   : 'Read quickly, please',
   *   timeout: 1000
   * });
   * ```
   *
   * @param {String|ToastConfig} config Message or toast config object
   * @returns {Core.widget.Toast}
   */
  static show(config) {
    const toast = _Toast.new({
      autoDestroy: true,
      rootElement: document.body
    }, typeof config === "string" ? { html: config } : config);
    toast.show();
    return toast;
  }
};
__publicField(_Toast, "$name", "Toast");
__publicField(_Toast, "type", "toast");
var Toast = _Toast;
Toast.toasts = [];
Toast.initClass();
Toast._$name = "Toast";

// ../Core/lib/Core/helper/WidgetHelper.js
var WidgetHelper = class {
  //region Querying
  /**
   * Returns the widget with the specified id.
   * @param {String} id Id of widget to find
   * @returns {Core.widget.Widget} The widget if any
   * @category Querying
   */
  static getById(id) {
    return Widget.getById(id);
  }
  /**
   * Returns the Widget which owns the passed element (or event).
   * @param {HTMLElement|Event} element The element or event to start from
   * @param {String|Function} [type] The type of Widget to scan upwards for. The lowercase
   * class name. Or a filter function which returns `true` for the required Widget.
   * @param {HTMLElement|Number} [limit] The number of components to traverse upwards to find a
   * match of the type parameter, or the element to stop at.
   * @returns {Core.widget.Widget} The found Widget or null.
   * @category Querying
   */
  static fromElement(element, type, limit) {
    return Widget.fromElement(element, type, limit);
  }
  //endregion
  //region Widgets
  /**
   * Create a widget.
   *
   * ```javascript
   * WidgetHelper.createWidget({
   *   type: 'button',
   *   icon: 'user',
   *   text: 'Edit user'
   * });
   * ```
   *
   * @param {ContainerItemConfig} config Widget config
   * @returns {Core.widget.Widget} The widget
   * @category Widgets
   */
  static createWidget(config = {}) {
    return config.isWidget ? config : Widget.create(config);
  }
  /**
   * Appends a widget (array of widgets) to the DOM tree. If config is empty, widgets are appended to the DOM. To
   * append widget to certain position you can pass HTMLElement or its id as config, or as a config, that will be
   * applied to all passed widgets.
   *
   * Usage:
   *
   * ```javascript
   * // Will append button as last item to element with id 'container'
   * let [button] = WidgetHelper.append({ type : 'button' }, 'container');
   *
   * // Same as above, but will add two buttons
   * let [button1, button2] = WidgetHelper.append([
   *     { type : 'button' },
   *     { type : 'button' }
   *     ], { appendTo : 'container' });
   *
   * // Will append two buttons before element with id 'someElement'. Order will be preserved and all widgets will have
   * // additional class 'my-cls'
   * let [button1, button2] = WidgetHelper.append([
   *     { type : 'button' },
   *     { type : 'button' }
   *     ], {
   *         insertBefore : 'someElement',
   *         cls          : 'my-cls'
   *     });
   * ```
   *
   * @param {ContainerItemConfig|ContainerItemConfig[]} widget Widget config or array of such configs
   * @param {HTMLElement|String|Object} [config] Element (or element id) to which to append the widget or config to
   * apply to all passed widgets
   * @returns {Core.widget.Widget[]} Array or widgets
   * @category Widgets
   */
  static append(widget, config) {
    widget = Array.isArray(widget) && widget || [widget];
    if (config instanceof HTMLElement || typeof config === "string") {
      config = {
        appendTo: config
      };
    }
    if (config.insertFirst) {
      const target = typeof config.insertFirst === "string" ? document.getElementById(config.insertFirst) : config.insertFirst;
      if (target.firstChild) {
        config.insertBefore = target.firstChild;
      } else {
        config.appendTo = target;
      }
    }
    return widget.map((item) => Widget.create(ObjectHelper.assign({}, config || {}, item)));
  }
  //endregion
  //region Popups
  /**
   * Shows a popup (~tooltip) containing widgets connected to specified element.
   *
   * ```javascript
   * WidgetHelper.openPopup(element, {
   *   position: 'bottom center',
   *   items: [
   *      { widgetConfig }
   *   ]
   * });
   * ```
   *
   * @param {HTMLElement} element Element to connect popup to
   * @param {PopupConfig} config Config object, or string to use as html in popup
   * @returns {*|{close, widgets}}
   * @category Popups
   */
  static openPopup(element, config) {
    return Widget.create(ObjectHelper.assign({
      forElement: element
    }, typeof config === "string" ? {
      html: config
    } : config), "popup");
  }
  /**
   * Shows a context menu connected to the specified element.
   *
   * ```javascript
   * WidgetHelper.showContextMenu(element, {
   *   items: [
   *      { id: 'addItem', icon: 'add', text: 'Add' },
   *      ...
   *   ],
   *   onItem: item => alert('Clicked ' + item.text)
   * });
   * ```
   *
   * @param {HTMLElement|Number[]} element Element (or a coordinate) to show the context menu for
   * @param {MenuItemConfig} config Context menu config, see example
   * @returns {Core.widget.Menu}
   * @category Popups
   */
  static showContextMenu(element, config) {
    const me = this;
    if (me.currentContextMenu) {
      me.currentContextMenu.destroy();
    }
    if (element instanceof HTMLElement) {
      config.forElement = element;
    } else {
      config.forElement = document.body;
      if (Array.isArray(element)) {
        element = new Point(...element);
      }
      if (element instanceof Point) {
        config.align = {
          position: element
        };
      }
    }
    config.internalListeners = { destroy: me.currentContextMenu = null };
    return me.currentContextMenu = Widget.create(config, "menu");
  }
  /**
   * Attached a tooltip to the specified element.
   *
   * ```javascript
   * WidgetHelper.attachTooltip(element, {
   *   text: 'Useful information goes here'
   * });
   * ```
   *
   * @param {HTMLElement} element Element to attach tooltip for
   * @param {String|TooltipConfig} configOrText Tooltip config or tooltip string, see example and source
   * @returns {HTMLElement} The passed element
   * @category Popups
   */
  static attachTooltip(element, configOrText) {
    return Widget.attachTooltip(element, configOrText);
  }
  /**
   * Checks if element has tooltip attached
   *
   * @param {HTMLElement} element Element to check
   * @returns {Boolean}
   * @category Popups
   */
  static hasTooltipAttached(element) {
    return Widget.resolveType("tooltip").hasTooltipAttached(element);
  }
  /**
   * Destroys any tooltip attached to an element, removes it from the DOM and unregisters any tip related listeners
   * on the element.
   *
   * @param {HTMLElement} element Element to remove tooltip from
   * @category Popups
   */
  static destroyTooltipAttached(element) {
    return Widget.resolveType("tooltip").destroyTooltipAttached(element);
  }
  //endregion
  //region Mask
  /**
   * Masks the specified element, showing a message in the mask.
   * @param {HTMLElement} element Element to mask
   * @param {String} msg Message to show in the mask
   * @returns {Core.widget.Mask}
   * @category Mask
   */
  static mask(element, msg = "Loading") {
    if (element) {
      if (element instanceof HTMLElement) {
        element = {
          target: element,
          text: msg
        };
      }
      return Mask.mask(element, element.target);
    }
  }
  /**
   * Unmask the specified element.
   * @param {HTMLElement} element
   * @category Mask
   */
  static unmask(element, close = true) {
    if (element.mask) {
      if (close) {
        element.mask.close();
      } else {
        element.mask.hide();
      }
    }
  }
  //endregion
  //region Toast
  /**
   * Show a toast
   * @param {String} msg message to show in the toast
   * @category Mask
   */
  static toast(msg) {
    return Toast.show(msg);
  }
  //endregion
};
WidgetHelper._$name = "WidgetHelper";

// ../Core/lib/Core/helper/XMLHelper.js
var XMLHelper = class {
  /**
   * Convert a JavaScript object to an XML string.
   *
   * From:
   * ```javascript
   * {
   *     name : 'Task 1',
   *     data : [
   *         {
   *             text : 'foo 1',
   *             ref  : 'fooItem 1'
   *         },
   *         {
   *             text : 'foo 2',
   *             ref  : 'fooItem 2'
   *         }
   *     ]
   * }
   * ```
   *
   * To:
   * ```xml
   * <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   * <root>
   *     <name>Task 1</name>
   *     <data>
   *         <element>
   *             <text>foo 1</text>
   *             <ref>fooItem 1</ref>
   *         </element>
   *         <element>
   *             <text>foo 2</text>
   *             <ref>fooItem 2</ref>
   *         </element>
   *     </data>
   * </root>
   * ```
   *
   * @param {Object} obj Object to convert.
   * @param {Object} [options] Convert options.
   * @param {String} [options.rootName] Root name for the XML. `root` by default.
   * @param {String} [options.elementName] Element name for each node of the XML. `element` by default.
   * @param {String} [options.xmlns] Add value for xmlns property for the root tag of the XML.
   * @param {Boolean} [options.includeHeader] `false` to not include the header `<?xml version="1.0" encoding="UTF-8"?>` on top of the XML.
   * @param {Boolean} [options.rootElementForArray] `false` to not include a root element for array of items. e.g. for the above example:
   * ```xml
   * <?xml version="1.0" encoding="UTF-8" standalone="yes"?>
   * <root>
   *     <name>Task 1</name>
   *     <element>
   *         <text>foo 1</text>
   *         <ref>fooItem 1</ref>
   *     </element>
   *     <element>
   *         <text>foo 2</text>
   *         <ref>fooItem 2</ref>
   *     </element>
   * </root>
   * ```
   * @returns {String} the XML
   */
  static convertFromObject(obj, options = {}) {
    Objects.assignIf(options, {
      rootName: "root",
      elementName: "element",
      includeHeader: true,
      rootElementForArray: true
    });
    const { rootName, elementName, includeHeader, rootElementForArray } = options;
    let { xmlns } = options;
    xmlns = xmlns ? ` xmlns="${xmlns}"` : "";
    const header = includeHeader ? '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>' : "";
    const converter = (o) => {
      const xmlItems = [];
      for (const key in o) {
        const item = o[key];
        if (Array.isArray(item)) {
          if (rootElementForArray) {
            xmlItems.push(`<${key}>`);
          }
          for (const subItem of item) {
            if (elementName.length) {
              xmlItems.push(`<${elementName}>`);
            } else {
              xmlItems.push(`<${key}>`);
            }
            xmlItems.push(converter(subItem));
            if (elementName.length) {
              xmlItems.push(`</${elementName}>`);
            } else {
              xmlItems.push(`</${key}>`);
            }
          }
          if (rootElementForArray) {
            xmlItems.push(`</${key}>`);
          }
        } else if (Objects.isObject(item)) {
          xmlItems.push(`<${key}>${converter(item)}</${key}>`);
        } else {
          if (item == null) {
            xmlItems.push(`<${key}/>`);
          } else {
            xmlItems.push(`<${key}>${StringHelper.encodeHtml(item)}</${key}>`);
          }
        }
      }
      return xmlItems.join("");
    };
    return `${header}<${rootName}${xmlns}>${converter(obj)}</${rootName}>`;
  }
};
XMLHelper._$name = "XMLHelper";

// ../Core/lib/Core/helper/util/RandomGenerator.js
var RandomGenerator = class {
  constructor() {
    this.random100 = [46, 2, 36, 46, 54, 59, 18, 20, 71, 55, 88, 98, 13, 61, 61, 40, 2, 15, 3, 32, 51, 45, 64, 25, 81, 85, 54, 13, 57, 49, 64, 22, 81, 94, 0, 62, 17, 7, 11, 2, 33, 99, 85, 26, 83, 83, 96, 26, 20, 89, 91, 38, 26, 13, 11, 79, 32, 30, 5, 51, 70, 7, 5, 56, 58, 77, 37, 89, 40, 80, 78, 59, 26, 36, 8, 51, 60, 23, 86, 5, 11, 96, 64, 94, 87, 64, 4, 78, 17, 85, 35, 0, 90, 86, 23, 55, 53, 9, 35, 59, 29, 2, 64, 42, 8, 49, 43, 73, 6, 53, 38, 9, 39, 31, 32, 40, 49, 13, 78, 68, 20, 99, 24, 78, 35, 91, 73, 46, 67, 76, 89, 69, 30, 69, 25, 3, 4, 55, 1, 65, 66, 76, 83, 19, 67, 1, 95, 24, 54, 45, 56, 40, 67, 92, 72, 4, 69, 8, 47, 50, 27, 2, 38, 9, 14, 83, 12, 14, 62, 95, 22, 47, 35, 18, 38, 14, 86, 64, 68, 61, 52, 69, 39, 93, 20, 73, 32, 52, 74, 6, 56, 68, 99, 29, 24, 92, 40, 67, 6, 72, 31, 41, 91, 53, 80, 55, 33, 97, 97, 99, 18, 20, 5, 27, 82, 84, 61, 78, 27, 67, 7, 42, 75, 95, 91, 25, 63, 21, 70, 36, 46, 0, 1, 45, 84, 6, 86, 15, 10, 62, 96, 94, 10, 23, 93, 83, 94, 47, 5, 29, 29, 52, 51, 37, 77, 96, 43, 72, 43, 14, 54, 14, 72, 52, 4, 39, 15, 26, 68, 28, 25, 76, 60, 50, 22, 40, 72, 74, 68, 58, 8, 48, 40, 62, 52, 24, 9, 26, 47, 44, 49, 96, 7, 77, 90, 45, 76, 47, 5, 86, 1, 36, 18, 42, 19, 90, 34, 23, 70, 32, 69, 79, 0, 99, 57, 80, 72, 21, 19, 72, 85, 68, 4, 40, 86, 62, 0, 63, 4, 11, 69, 31, 78, 31, 21, 78, 29, 84, 13, 53, 57, 10, 26, 50, 24, 30, 90, 42, 51, 96, 93, 21, 99, 23, 81, 0, 89, 43, 86, 63, 93, 19, 54, 71, 92, 36, 4, 95, 37, 99, 60, 29, 23, 50, 68, 95, 57, 95, 77, 53, 99, 78, 75, 12, 92, 47, 23, 14, 0, 41, 98, 11, 34, 64, 26, 90, 50, 23, 38, 31, 74, 76, 16, 76, 66, 23, 22, 72, 48, 50, 20, 36, 37, 58, 5, 43, 49, 64, 81, 30, 8, 21, 98, 75, 60, 17, 50, 42, 27, 38, 90, 74, 45, 68, 67, 27, 31, 15, 58, 76, 41, 99, 23, 98, 53, 98, 56, 19, 79, 2, 4, 38, 96, 24, 65, 51, 43, 42, 41, 60, 46, 7, 90, 65, 3, 27, 63, 99, 51, 44, 86, 1, 54, 40, 15, 74, 3, 81, 51, 63, 87, 79, 84, 72, 22, 38, 96, 95, 33, 41, 21, 99, 21, 69, 7, 49, 40, 52, 41, 6, 91, 19, 76, 40, 54, 17, 33, 11, 11, 0, 1, 32, 94, 33, 13, 18, 45, 7, 85, 61, 42, 54, 45, 72, 78, 96, 17, 9, 80, 87, 41, 96, 66, 0, 8, 59, 18, 21, 2, 28, 64, 75, 97, 32, 80, 86, 97, 97, 55, 2, 73, 75, 11, 89, 67, 58, 70, 76, 12, 46, 64, 17, 22, 97, 25, 35, 93, 57, 82, 46, 57, 61, 31, 74, 27, 4, 32, 85, 53, 86, 53, 53, 42, 5, 28, 50, 65, 63, 70, 61, 73, 37, 13, 80, 7, 34, 22, 3, 26, 6, 62, 78, 12, 56, 87, 41, 58, 64, 31, 27, 45, 35, 18, 66, 62, 43, 89, 69, 94, 93, 33, 74, 2, 43, 85, 37, 82, 41, 74, 9, 15, 44, 33, 42, 65, 19, 1, 49, 78, 12, 29, 9, 78, 7, 55, 12, 45, 40, 33, 16, 86, 14, 52, 16, 73, 76, 0, 98, 75, 91, 78, 46, 99, 95, 90, 69, 78, 45, 62, 55, 37, 88, 49, 77, 27, 83, 38, 73, 39, 1, 75, 40, 65, 83, 54, 95, 7, 73, 4, 30, 26, 36, 89, 21, 5, 95, 11, 14, 87, 45, 36, 21, 77, 55, 5, 66, 51, 98, 48, 62, 74, 58, 23, 82, 30, 28, 19, 53, 89, 76, 98, 8, 34, 70, 28, 54, 16, 52, 35, 93, 54, 54, 72, 49, 18, 93, 72, 90, 71, 73, 15, 60, 38, 80, 76, 53, 70, 39, 69, 25, 5, 31, 61, 46, 6, 54, 34, 31, 52, 33, 36, 79, 76, 44, 29, 28, 38, 1, 66, 2, 90, 91, 1, 76, 78, 31, 55, 37, 71, 2, 3, 38, 85, 0, 95, 42, 2, 39, 57, 87, 61, 77, 98, 2, 24, 80, 48, 27, 47, 71, 15, 7, 49, 60, 86, 3, 2, 29, 38, 54, 36, 59, 83, 27, 47, 9, 36, 42, 8, 73, 85, 9, 16, 73, 60, 39, 12, 43, 25, 23, 29, 28, 47, 40, 77, 20, 89, 22, 30, 41, 59, 96, 19, 56, 20, 76, 73, 39, 46, 72, 40, 47, 37, 52, 29, 79, 37, 39, 50, 41, 87, 66, 17, 75, 31, 45, 26, 88, 70, 11, 90, 40, 74, 9, 32, 65, 72, 61, 6, 93, 54, 15, 84, 22, 99, 47, 10, 96, 4, 84, 19, 85, 73, 45, 25, 16, 8, 94, 99, 39, 28, 26, 68, 87, 48, 1, 65, 86, 46, 86, 7, 60, 82, 45, 75, 38, 56, 41, 35, 30, 86, 91, 97, 85, 45, 5, 14, 69, 85, 96, 37, 18, 26, 16, 38, 16, 1, 44, 94, 85, 58, 60, 20, 5, 47, 52, 41, 50, 71, 43, 42, 67, 64, 38, 65, 83, 99, 78, 96, 33, 20, 98, 24, 6, 2, 25, 16, 16, 44, 63, 24, 68, 56, 49, 91, 15, 59, 99, 27, 43, 34, 28, 36, 45, 1, 10, 19, 54, 26, 75, 17, 88, 96, 63, 24, 71, 93, 72, 97, 66, 87, 18, 86];
    this.randomCache = {};
    this.rndIndex = 0;
  }
  /**
   * Returns next pseudo random integer number from sequence between 0 and max parameter value (99 is maximum value)
   * @param {Number} max max value
   * @returns {Number}
   */
  nextRandom(max) {
    const { randomCache } = this;
    let randomNumbers;
    if (randomCache[max]) {
      randomNumbers = randomCache[max];
    } else {
      randomNumbers = this.random100.filter((num) => num < max);
      randomCache[max] = randomNumbers;
    }
    return randomNumbers[this.rndIndex++ % randomNumbers.length];
  }
  /**
   * Resets sequence to initial number
   */
  reset() {
    this.rndIndex = 0;
  }
  /**
   * Returns pseudo random array element
   * @param {Array} array input array
   * @returns {*}
   */
  fromArray(array) {
    return array[this.nextRandom(array.length)];
  }
  /**
   * Creates a randon array from a larger array of possibilities
   */
  randomArray(array, maxLength) {
    const result = [], length = this.nextRandom(maxLength + 1), used = {};
    for (let i = 0, index = this.nextRandom(array.length); i < length; i++) {
      while (used[index]) {
        index = this.nextRandom(array.length);
      }
      used[index] = true;
      result.push(array[index]);
    }
    return result;
  }
};
RandomGenerator._$name = "RandomGenerator";

// ../Core/lib/Core/helper/util/DataGenerator.js
var lorem = [
  "Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.",
  "Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.",
  "Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur.",
  "Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.",
  "Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium, totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae dicta sunt explicabo.",
  "Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit, sed quia consequuntur magni dolores eos qui atione voluptatem sequi nesciunt.",
  "Neque porro quisquam est, qui dolorem ipsum quia dolor sit amet, consectetur, adipisci velit, sed quia non numquam eius modi tempora incidunt ut labore et dolore magnam aliquam quaerat voluptatem.",
  "Ut enim ad minima veniam, quis nostrum exercitationem ullam corporis suscipit laboriosam, nisi ut aliquid ex ea commodi consequatur?",
  "Quis autem vel eum iure reprehenderit qui in ea voluptate velit esse quam nihil molestiae consequatur, vel illum qui dolorem eum fugiat quo voluptas nulla pariatur?"
];
var _DataGenerator = class _DataGenerator {
  //region Random
  static reset() {
    this.rnd.reset();
    this.rndTime.reset();
    this.rndRating.reset();
  }
  //region Data arrays
  /**
   * Array with available city values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get cities() {
    return [
      "Stockholm",
      "Barcelona",
      "Paris",
      "Dubai",
      "New York",
      "San Francisco",
      "Washington",
      "Moscow"
    ];
  }
  /**
   * Array with available first name values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get firstNames() {
    return [
      "Mike",
      "Linda",
      "Don",
      "Karen",
      "Doug",
      "Jenny",
      "Daniel",
      "Melissa",
      "John",
      "Jane",
      "Theo",
      "Lisa",
      "Adam",
      "Mary",
      "Barbara",
      "James",
      "David"
    ];
  }
  /**
   * Array with available sur name values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get surNames() {
    return [
      "McGregor",
      "Ewans",
      "Scott",
      "Smith",
      "Johnson",
      "Adams",
      "Williams",
      "Brown",
      "Jones",
      "Miller",
      "Davis",
      "More",
      "Wilson",
      "Taylor",
      "Anderson",
      "Thomas",
      "Jackson"
    ];
  }
  /**
   * Array with available team values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get teams() {
    return [
      "Lions",
      "Eagles",
      "Tigers",
      "Horses",
      "Dogs",
      "Cats",
      "Panthers",
      "Rats",
      "Ducks",
      "Cougars",
      "Hens",
      "Roosters"
    ];
  }
  /**
   * Array with available food values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get foods() {
    return [
      "Pancake",
      "Burger",
      "Fish n chips",
      "Carbonara",
      "Taco",
      "Salad",
      "Bolognese",
      "Mac n cheese",
      "Waffles"
    ];
  }
  /**
   * Array with available color values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get colors() {
    return [
      "Blue",
      "Green",
      "Red",
      "Yellow",
      "Pink",
      "Purple",
      "Orange",
      "Teal",
      "Black"
    ];
  }
  /**
   * Array with available skill values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get skills() {
    return [
      "JavaScript",
      "CSS",
      "TypeScript",
      "React",
      "Vue",
      "Angular",
      "Java",
      "PHP",
      "Python",
      "C#",
      "C++",
      "BASIC",
      "COBOL",
      "FORTRAN",
      "PASCAL",
      "SQL"
    ];
  }
  /**
   * Array with available task values
   * @static
   * @readonly
   * @member {String[]}
   */
  static get tasks() {
    return [
      "Meetings",
      "Documentation",
      "Email communication",
      "Project management",
      "Budgeting",
      "Marketing and advertising",
      "Customer service",
      "Research and analysis",
      "Data entry",
      "IT support",
      "Employee management",
      "Sales and business development",
      "Event planning",
      "Graphic design",
      "Writing and editing",
      "Presentation",
      "Travel arrangements and expense management",
      "Training and development",
      "Quality assurance",
      "Customer support",
      "Technical writing",
      "Social media management",
      "Translation",
      "Legal research",
      "Data analysis and visualization",
      "Video editing and production",
      "Network admin",
      "Content creation",
      "Market research",
      "Public relations",
      "Teaching and training",
      "Recruiting",
      "Product development"
    ];
  }
  //endregion
  //region Generate data
  /**
   * Generates an array of objects with specified properties.
   *
   * @param {Number} count The number of objects to generate or an options object.
   * @privateparam {Boolean|Number} [randomHeight=false] If `true`, assigns random heights to objects. If a number is provided, it sets the maximum height.
   * @privateparam {Number} [initialId=1] The initial ID for the generated objects.
   * @yields {Object} An object representing a generated item with various properties.
   * @generator
   * @static
   */
  static *generate(count, randomHeight = false, initialId = 1) {
    var _a2;
    let addSkills, rowCallback;
    if (typeof count === "object") {
      randomHeight = count.randomHeight;
      initialId = (_a2 = count.initialId) != null ? _a2 : 1;
      addSkills = count.addSkills;
      rowCallback = count.rowCallback;
      count = count.count;
    }
    const me = this, {
      rnd,
      rndTime,
      rndRating,
      rndText,
      firstNames,
      surNames,
      teams,
      foods,
      colors,
      cities,
      skills
    } = me;
    for (let i = 0; i < count; i++) {
      const firstName = rnd.fromArray(firstNames), surName = rnd.fromArray(surNames), name = `${firstName} ${String.fromCharCode(65 + i % 25)} ${surName}`, startDay = rnd.nextRandom(60) + 1, start = new Date(2019, 0, startDay), finish = new Date(2019, 0, startDay + rnd.nextRandom(30) + 2), row = {
        id: initialId > -1 ? i + initialId : void 0,
        title: "Row " + i,
        name,
        firstName,
        surName,
        city: rnd.fromArray(cities),
        team: rnd.fromArray(cities) + " " + rnd.fromArray(teams),
        age: 10 + rnd.nextRandom(80),
        food: rnd.fromArray(foods),
        color: rnd.fromArray(colors),
        score: rnd.nextRandom(100) * 10,
        rank: rnd.nextRandom(100) + 1,
        start,
        finish,
        time: DateHelper.getTime(rndTime.nextRandom(24), rndTime.nextRandom(12) * 5),
        percent: rnd.nextRandom(100),
        done: rnd.nextRandom(100) < 50,
        rating: rndRating.nextRandom(5),
        active: startDay > 30,
        relatedTo: Math.min(count - 1, i + initialId + rnd.nextRandom(10)),
        notes: lorem[rndText.nextRandom(7) + 1]
      };
      if (addSkills) {
        row.skills = rnd.randomArray(skills, typeof addSkills === "number" ? addSkills : 7);
      }
      const additionalData = rowCallback == null ? void 0 : rowCallback(row);
      additionalData && Object.assign(row, additionalData);
      if (randomHeight) {
        row.rowHeight = rnd.nextRandom(randomHeight === true ? 20 : randomHeight) * 5 + 20;
      }
      yield row;
    }
  }
  /**
   * Generates a pseudo random dataset. Used in Grid examples.
   * @param {Number|Object} count number of records, or an object with properties:
   * @param {Boolean} [count.randomHeight] Generate random row height
   * @param {Boolean} [count.initialId] Row initial id. Set -1 to disable Id generation. Defaults to 1.
   * @param {Boolean} [count.reset] Set true to ensure we get the same dataset on consecutive calls. Defaults to true
   * @param {Boolean} [count.rowCallback] A callback called for each row to allow appending extra data, returned data in
   * object form will be applied to the generated data
   * @param {Boolean} [count.addSkills] Add skills to the dataset
   * @param {Boolean} [randomHeight] Generate random row height
   * @param {Number} [initialId] Row initial id. Set -1 to disable Id generation. Defaults to 1.
   * @param {Boolean} [reset] Set true to ensure we get the same dataset on consecutive calls. Defaults to true
   * @returns {Object[]} Generated rows array
   */
  static generateData(count, randomHeight = false, initialId = 1, reset = true) {
    let args = count;
    if (typeof count !== "object") {
      args = {
        count,
        randomHeight,
        initialId,
        reset
      };
    }
    args.reset !== false && this.reset();
    if (_DataGenerator.overrideRowCount) {
      args.count = _DataGenerator.overrideRowCount;
    }
    const rows = [], generator = this.generate(args);
    for (let i = 0; i < args.count; i++) {
      rows.push(generator.next().value);
    }
    return rows;
  }
  /**
   * Generates a dataset of events
   * @returns {Object[]}
   */
  static generateEvents({
    viewStartDate,
    viewEndDate,
    nbrResources = 50,
    nbrEvents = 5,
    dependencies,
    tickUnit = "days",
    minDuration = 2,
    maxDuration = 10,
    gap = 1,
    eventCallback
  }) {
    const resources = this.generateData(nbrResources), events = [];
    let startDate, endDate;
    dependencies = [];
    for (let i = 0; i <= nbrResources; i++) {
      for (let j = 0; j <= nbrEvents; j++) {
        const duration = Math.round(Math.random() * (maxDuration - 1 - minDuration)) + minDuration, eventId = events.length + 1;
        startDate = j === 0 ? DateHelper.add(viewStartDate, Math.round(Math.random() * 3) * gap, tickUnit) : DateHelper.add(endDate, gap, tickUnit);
        endDate = DateHelper.add(startDate, duration, tickUnit);
        events.push({
          id: eventId,
          name: this.tasks[(i + j) % (this.tasks.length - 1)],
          startDate,
          duration,
          endDate,
          resourceId: i
        });
        eventCallback == null ? void 0 : eventCallback(events[events.length - 1]);
        if (dependencies && i > 0) {
          dependencies.push({
            id: dependencies.length + 1,
            from: eventId - 1,
            to: eventId
          });
        }
      }
    }
    return {
      resources,
      events,
      dependencies
    };
  }
  /**
   * Generates a pseudo random dataset with one scheduled event per resource & date tick.
   * @param {Object} data
   * @param {Boolean} [data.startDate] Start date of the first generated event
   * @param {Boolean} [data.endDate] End date of the last generated event
   * @param {Boolean} [data.nbrResources] Number of resources
   * @param {Boolean} [data.tickUnit] The tick unit for the time axis, defaults to `days`
   * @returns {Object[]} Generated rows array
   */
  static generateOneEventPerTickAndResource({
    startDate,
    endDate,
    nbrResources = 50,
    tickUnit = "days"
  }) {
    const resources = this.generateData(nbrResources), events = [], visibleTicks = DateHelper.getDurationInUnit(startDate, endDate, tickUnit);
    for (let i = 0; i <= nbrResources; i++) {
      for (let j = 0; j < visibleTicks; j++) {
        events.push({
          id: events.length + 1,
          resourceId: i,
          name: this.tasks[(i + j) % (this.tasks.length - 1)],
          startDate: DateHelper.add(startDate, j, tickUnit),
          duration: 1,
          durationUnit: tickUnit
        });
      }
    }
    return {
      resources,
      events
    };
  }
  /**
   * Generates pseudo random data for a Grid row.
   * @returns {Object} Generated row
   */
  static generateRow() {
    return _DataGenerator.generateData(1, false, -1, false)[0];
  }
  //endregion
};
//endregion
__publicField(_DataGenerator, "rnd", new RandomGenerator());
__publicField(_DataGenerator, "rndTime", new RandomGenerator());
__publicField(_DataGenerator, "rndRating", new RandomGenerator());
__publicField(_DataGenerator, "rndText", new RandomGenerator());
var DataGenerator = _DataGenerator;
DataGenerator._$name = "DataGenerator";

// ../Core/lib/Core/helper/util/DemoBot.js
var knownProps = [
  "action",
  "target",
  "to",
  "deltaX",
  "deltaY",
  "x",
  "y",
  "text"
];
var DemoBot = class extends Events_default(Delayable_default()) {
  static get defaultConfig() {
    return {
      repeat: true,
      outerElement: document.body,
      callOnFunctions: true
    };
  }
  // expects an outer element (grid.element/scheduler.element) and an array of steps similar to chain steps in siesta
  construct(config) {
    super.construct(config);
    const me = this;
    if (me.widget) {
      me.outerElement = me.widget.element;
      me.widget.playingDemo = true;
    }
    EventHelper.playingDemo = true;
    Object.assign(me, {
      prevTarget: null,
      currentStep: 0,
      mouse: DomHelper.createElement({
        parent: me.outerElement,
        tag: "div",
        className: "simulated-mouse"
      }),
      timeoutId: null,
      innerIntervalId: null,
      mouseOutElements: []
    });
    me.intervalId = me.setInterval(me.nextStep.bind(me), 1e3);
    me.outerElement.classList.add("b-playing-demo");
    me.outerElement.addEventListener("click", (event) => {
      if (event.isTrusted) {
        me.abort();
      }
    });
  }
  doDestroy() {
    this.abort();
  }
  // stops the bot
  abort(atEnd = false) {
    const me = this;
    me.mouse.style.top = "-100px";
    me.clearInterval(me.intervalId);
    me.timeoutId && me.clearTimeout(me.timeoutId);
    me.innerIntervalId && me.clearInterval(me.innerIntervalId);
    me.outerElement.classList.remove("b-playing-demo");
    if (me.widget) {
      me.widget.playingDemo = false;
    }
    EventHelper.playingDemo = false;
    me.trigger(atEnd ? "done" : "abort");
  }
  // triggers a synthetic event
  triggerEvent(element, type, data) {
    if (!element)
      return null;
    let event;
    if (type.startsWith("mouse")) {
      const box = this.mouse.getBoundingClientRect();
      event = new MouseEvent(type, Object.assign({
        view: globalThis,
        bubbles: true,
        cancelable: true,
        clientX: box.left,
        clientY: box.top
      }, data || {}));
    } else {
      event = document.createEvent("Event");
      event.initEvent(type, true, false);
    }
    element.dispatchEvent(event);
    return event;
  }
  // moves mouse to target in 10 steps, with animated transition between steps
  handleMouseMove(step, target) {
    const me = this, mouse = me.mouse;
    mouse.classList.add("quick");
    if (me.mouseDown)
      mouse.classList.add("drag");
    const mouseBox = Rectangle.from(mouse, me.outerElement), x = mouseBox.x, y = mouseBox.y;
    let deltaX = 0, deltaY = 0;
    if (step.to) {
      if (typeof step.to === "string") {
        const toElement = me.outerElement.querySelector(step.to);
        if (toElement) {
          const rect = Rectangle.from(toElement, me.outerElement), toX = rect.x + rect.width / 2, toY = rect.y + rect.height / 2;
          deltaX = (toX - x) / 10;
          deltaY = (toY - y) / 10;
        }
      } else if (step.to.x) {
        deltaX = (step.to.x - x) / 10;
      } else {
        deltaX = step.to[0] / 10;
        deltaY = step.to[1] / 10;
      }
    } else if (step.deltaX) {
      deltaX = step.deltaX / 10;
    } else if (step.x) {
      deltaX = (step.x - x) / 10;
    }
    if (step.deltaY) {
      deltaY = step.deltaY / 10;
    }
    let i = 0;
    me.innerIntervalId = me.setInterval(() => {
      if (me.shouldPause) {
        return;
      }
      if (i++ === 9) {
        clearInterval(me.innerIntervalId);
        if (step.then) {
          step.then();
        }
      }
      const mouseX = x + deltaX * i, mouseY = y + deltaY * i;
      mouse.style.left = mouseX + "px";
      mouse.style.top = mouseY + "px";
      const mouseBounds = mouse.getBoundingClientRect(), clientX = mouseBounds.left, clientY = mouseBounds.top, eventTarget = DomHelper.elementFromPoint(clientX, clientY);
      if (eventTarget !== me.prevTarget) {
        if (me.prevTarget) {
          me.mouseOutElements.push(me.prevTarget);
          if (!DomHelper.isDescendant(me.mouseOutElements[0], eventTarget)) {
            me.mouseOutElements.forEach((element) => me.triggerEvent(element, "mouseout"));
            me.mouseOutElements.length = 0;
          }
        }
        me.prevTarget = eventTarget;
        me.triggerEvent(eventTarget, "mouseover");
      }
      me.triggerEvent(eventTarget, step.action, {
        clientX,
        clientY
      });
    }, 50);
  }
  // target can be a string selector, a function or blank to use last target or outerElement if first time
  getTarget(step) {
    const me = this, target = step.target;
    if (!target) {
      return me.prevTarget || me.outerElement;
    }
    if (typeof target === "function") {
      return target(step);
    }
    return document.querySelector(target);
  }
  // action can be a function, a string or extracted from a property by scanning for unknown names
  normalizeStep(step) {
    if (step.action) {
      if (typeof step.action === "function") {
        return step.action(step);
      }
      return step;
    }
    if (typeof step === "function") {
      step();
      return step;
    }
    for (const prop in step) {
      if (Object.hasOwnProperty.call(step, prop) && !knownProps.includes(prop)) {
        step.action = prop.toLowerCase();
        step.to = step[prop];
      }
    }
    if (!step.target && (typeof step.to === "string" || typeof step.to === "function"))
      step.target = step.to;
    return step;
  }
  get isScrolling() {
    const me = this, box = me.outerElement.getBoundingClientRect(), scrolled = me.lastTop && box.top !== me.lastTop;
    me.lastTop = box.top;
    return scrolled;
  }
  get isInView() {
    const box = this.outerElement.getBoundingClientRect();
    return box.top < globalThis.innerHeight && box.bottom > 0;
  }
  get shouldPause() {
    return !this.isInView || this.isScrolling || document.hidden || !document.hasFocus();
  }
  // process the next step
  nextStep() {
    const me = this;
    if (me.shouldPause) {
      return;
    }
    if (me.currentStep === me.steps.length) {
      if (me.repeat) {
        me.currentStep = 0;
      } else {
        return me.abort(true);
      }
    }
    if (me.currentStep === 0) {
      me.trigger("initialize");
    }
    const mouse = me.mouse, step = me.normalizeStep(me.steps[me.currentStep++]), target = me.getTarget(step), action = step.action;
    if (target && action) {
      mouse.className = "simulated-mouse";
      if (action === "mousemove") {
        me.handleMouseMove(step, target);
      } else {
        if (target !== me.prevTarget) {
          const rect = Rectangle.from(target, me.outerElement);
          mouse.style.left = rect.x + rect.width / 2 + "px";
          mouse.style.top = rect.y + rect.height / 2 + "px";
        }
        if (action === "mousedown") {
          me.mouseDown = true;
        }
        if (action === "mouseup") {
          me.mouseDown = false;
        }
        me.timeoutId = me.setTimeout(() => {
          me.prevTarget = target;
          mouse.classList.add(action);
          if (action === "type") {
            const field = Widget.fromElement(target), parts = step.text.split("|");
            field.value = parts[parts.length === 1 || field.value != parts[0] ? 0 : 1];
          } else {
            me.triggerEvent(target, action);
          }
        }, action === "type" ? 100 : 550);
      }
    }
  }
};
DemoBot._$name = "DemoBot";

// ../Core/lib/Core/helper/util/Formatter.js
var hasOwn5 = Object.hasOwn || ((obj, key) => Object.prototype.hasOwnProperty.call(obj, key));
var cacheKey = null;
function setParser(me, parser) {
  Object.defineProperty(me, "parser", {
    value: parser
  });
  return parser;
}
var Default = class {
  constructor(formatter) {
    this.formatter = formatter;
  }
  format(value) {
    return this.formatter.defaultFormat(value);
  }
  parse(value, strict) {
    return this.formatter.defaultParse(value, strict);
  }
  resolvedOptions() {
    return null;
  }
};
var Formatter = class {
  static get(format2) {
    if (format2 == null) {
      return this.NULL;
    }
    if (format2 instanceof this) {
      return format2;
    }
    const key = typeof format2 === "string" ? format2 : JSON.stringify(format2), cache = this.cache;
    let fmt = cache.get(key);
    if (!fmt) {
      cacheKey = key;
      fmt = new this(format2);
      cache.set(key, fmt);
    }
    return fmt;
  }
  static get cache() {
    return hasOwn5(this, "_cache") && this._cache || (this._cache = /* @__PURE__ */ new Map());
  }
  static get NULL() {
    return hasOwn5(this, "_null") ? this._null : this._null = new this(null);
  }
  constructor(config) {
    const me = this, { standardOptions } = me.constructor;
    me.cacheKey = cacheKey;
    cacheKey = null;
    me.initialize();
    if (config === null) {
      me.formatter = new Default(me);
    } else {
      me.configure(config);
      for (const [key, value] of Object.entries(me.resolvedOptions())) {
        if (value != null && standardOptions.includes(key)) {
          me[key] = value;
        }
      }
    }
  }
  get parser() {
    return setParser(this, new this.constructor.Parser(this));
  }
  defaultFormat(value) {
    return value == null ? value : String(value);
  }
  defaultParse(value) {
    return value;
  }
  format(value) {
    return value == null ? value : this.formatter.format(value);
  }
  parse(value, strict) {
    return value == null ? value : this.parser.parse(value, strict);
  }
  parseStrict(value) {
    return this.parse(value, true);
  }
  resolvedOptions() {
    return this.formatter.resolvedOptions();
  }
};
__publicField(Formatter, "standardOptions", Object.freeze([]));
Formatter._$name = "Formatter";

// ../Core/lib/Core/helper/util/Navigator.js
var Navigator = class extends Base.mixin(Events_default, Factoryable_default) {
  static get $name() {
    return "Navigator";
  }
  // Factoryable type name
  static get type() {
    return "navigator";
  }
  static get configurable() {
    return {
      /**
       * The owning Widget which is using this Navigator.
       * @config {Core.widget.Widget}
       */
      ownerCmp: null,
      /**
       * If the items in the owning widget are naturally tabbable, then the Navigator does not
       * need to listen for navigation keys and move focus. It just reacts to natural focus
       * movement.
       * @config {Boolean}
       */
      itemsTabbable: null,
      /**
       * The encapsulating element in which navigation takes place.
       * @config {HTMLElement}
       */
      target: null,
      /**
       * The element which provides key events for navigation. Optional. Defaults to the {@link #config-target} element.
       * @config {HTMLElement}
       */
      keyEventTarget: null,
      /**
       * An optional key event processor which may preprocess the key event. Returning `null` prevents processing of the event.
       * @param {KeyboardEvent} event
       * @returns {Boolean|null}
       * @config {Function}
       */
      processEvent: null,
      /**
       * A query selector which identifies descendant elements within the {@link #config-target} which are navigable.
       * @config {String}
       */
      itemSelector: null,
      /**
       * The currently focused element within the {@link #config-target}.
       * @config {HTMLElement}
       */
      activeItem: null,
      /**
       * A CSS class name to add to focused elements.
       * @config {String}
       * @default
       */
      focusCls: "b-active",
      /**
       * An object containing key definitions keyed by the key name eg:
       *
       * ```javascript
       *  keys : {
       *      "CTRL+Space" : 'onCtrlSpace',
       *      Enter        : 'onEnterKey'
       *  }
       * ```
       *
       * The {@link #config-ownerCmp} is used as the `this` reference and to resolve string method names.
       *
       * Modified key names must be created prepending one or more `'CTRL+'`, `'SHIFT+'`, `'ALT+'`
       * in that order, for example `"CTRL+SHIFT+Enter" : 'showMenu'`
       * @config {Object<String,String>}
       * @default
       */
      keys: null,
      /**
       * Configure as `true` to also navigate when the `CTRL` modifier key is used along with
       * navigation keys.
       * @config {Boolean}
       * @default false
       */
      allowCtrlKey: null,
      /**
       * Configure as `true` to also navigate when the `SHIFT` modifier key is used along with
       * navigation keys.
       * @config {Boolean}
       * @default false
       */
      allowShiftKey: null,
      scrollDuration: 50,
      /**
       * Configure as, or set to `true` to disable the processing of keys.
       * @config {Boolean}
       */
      disabled: null,
      datasetIdProperty: "id",
      testConfig: {
        scrollDuration: 1
      }
    };
  }
  static get factoryable() {
    return {
      defaultType: "navigator"
    };
  }
  get activeItem() {
    const { _activeItem } = this;
    if (this.target.contains(_activeItem)) {
      return _activeItem;
    }
    this._activeItem = null;
  }
  updateOwnerCmp(ownerCmp) {
    if (!this.itemSelector) {
      this.itemSelector = `.${this.ownerCmp.itemCls}`;
    }
    DomHelper.setAttributes(this.keyEventTarget, {
      "aria-activedescendant": `${this.owner.id}-active-descendant`
    });
  }
  set navigationEvent(navigationEvent) {
    const { owner } = this;
    this._navigationEvent = owner.navigationEvent = navigationEvent;
    if (navigationEvent) {
      Promise.resolve(1).then(() => this.navigationEvent = null);
    }
  }
  get navigationEvent() {
    return this._navigationEvent;
  }
  static getComposedKeyName(keyEvent) {
    const keyName = (keyEvent.key || "").trim() || keyEvent.code;
    return `${keyEvent.ctrlKey ? "CTRL+" : ""}${keyEvent.shiftKey ? "SHIFT+" : ""}${keyEvent.altKey ? "ALT+" : ""}${keyName}`;
  }
  onKeyDown(keyEvent) {
    var _a2;
    const me = this, {
      ownerCmp,
      itemSelector,
      activeItem,
      itemsTabbable
    } = me, { target } = keyEvent, firstItem = me.target.querySelector(itemSelector), keyName = (keyEvent.key || "").trim() || keyEvent.code, composedKeyName = me.constructor.getComposedKeyName(keyEvent), validTarget = target.matches(itemSelector) || target === me.keyEventTarget;
    if (!me.disabled && me.processEvent) {
      keyEvent = me.processEvent.call(ownerCmp, keyEvent);
    }
    if (keyEvent && !me.disabled && firstItem && me.target.offsetParent && validTarget) {
      if (!itemsTabbable) {
        if (me.inlineFlow == null) {
          const itemContainer = firstItem.parentNode, itemPositionStyle = DomHelper.getStyleValue(firstItem, "position"), itemDisplayStyle = DomHelper.getStyleValue(firstItem, "display"), itemFloatStyle = DomHelper.getStyleValue(firstItem, "float");
          me.inlineFlow = itemPositionStyle === "absolute" || itemDisplayStyle === "inline" || itemDisplayStyle === "inline-block" || itemFloatStyle === "left" || itemFloatStyle === "right" || DomHelper.getStyleValue(itemContainer, "display") === "flex" && DomHelper.getStyleValue(itemContainer, "flex-direction") === "row";
        }
        if (!me.prevKey) {
          if (me.inlineFlow) {
            me.prevKey = "ArrowLeft";
            me.nextKey = "ArrowRight";
          } else {
            me.prevKey = "ArrowUp";
            me.nextKey = "ArrowDown";
          }
        }
      }
      me.navigationEvent = keyEvent;
      if (activeItem) {
        switch (keyName) {
          case me.prevKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            keyEvent.handled = true;
            me.navigatePrevious(keyEvent);
            break;
          case me.nextKey:
            if (me.disabled || keyEvent.ctrlKey && !me.allowCtrlKey) {
              return;
            }
            if (keyEvent.shiftKey && !me.allowShiftKey) {
              return;
            }
            keyEvent.preventDefault();
            keyEvent.handled = true;
            me.navigateNext(keyEvent);
            break;
          default: {
            const keyHandler = (_a2 = me.keys) == null ? void 0 : _a2[composedKeyName];
            if (keyHandler && !me.disabled) {
              if (me.callback(keyHandler, me.thisObj || ownerCmp, [keyEvent]) === false) {
                return;
              }
            } else if (ownerCmp.onInternalKeyDown) {
              ownerCmp.onInternalKeyDown(keyEvent);
            }
            if (DomHelper.getActiveElement(target) !== target) {
              keyEvent.preventDefault();
            }
            if (itemsTabbable) {
              return;
            }
          }
        }
      } else {
        if (itemsTabbable) {
          return;
        }
        if (keyName === me.nextKey || keyName === me.prevKey) {
          me.activeItem = me.getDefaultNavigationItem(keyEvent);
        }
      }
      if (me.activeItem !== activeItem) {
        me.triggerNavigate(keyEvent);
      }
    }
  }
  getDefaultNavigationItem(keyEvent) {
    const { target, itemSelector, prevKey, nextKey } = this;
    if (target.compareDocumentPosition(keyEvent.target) & 4 && keyEvent.key === prevKey) {
      return target.querySelector(`${itemSelector}:last-of-type`);
    }
    if (target.compareDocumentPosition(keyEvent.target) & 2 && keyEvent.key === nextKey) {
      return target.querySelector(`${itemSelector}`);
    }
  }
  navigatePrevious(keyEvent) {
    const me = this, previous = me.previous;
    keyEvent.preventDefault();
    if (previous) {
      me.ownerCmp.scrollable.scrollIntoView(previous, { animate: me.scrollDuration }).then(() => {
        me.activeItem = previous;
        me.triggerNavigate(keyEvent);
      });
    }
  }
  navigateNext(keyEvent) {
    const me = this, next = me.next;
    keyEvent.preventDefault();
    if (next) {
      me.ownerCmp.scrollable.scrollIntoView(next, { animate: me.scrollDuration }).then(() => {
        me.activeItem = next;
        me.triggerNavigate(keyEvent);
      });
    }
  }
  get owner() {
    return this.ownerCmp;
  }
  get previous() {
    return this.getAdjacent(-1);
  }
  get next() {
    return this.getAdjacent(1);
  }
  /**
   * Returns the next or previous navigable element starting from the passed `from` element,
   * navigating in the passed direction.
   * @param {HTMLElement} [from] The start point. Defaults to the current {@link #config-activeItem}
   * @param {Number} [direction=1] The direction. -1 for backwards, else forwards.
   */
  getAdjacent(direction = 1, from = this.activeItem) {
    const treeWalker = this.treeWalker;
    treeWalker.currentNode = from;
    treeWalker[direction < 0 ? "previousNode" : "nextNode"]();
    if (treeWalker.currentNode !== this.activeItem) {
      return treeWalker.currentNode;
    }
  }
  onTargetFocusIn(focusInEvent) {
    var _a2;
    const me = this, {
      target,
      relatedTarget
    } = focusInEvent, {
      owner,
      itemsTabbable,
      skipScrollIntoView,
      previousActiveItem
    } = me;
    if (!target.matches(".b-focus-trap")) {
      if (target.matches(me.itemSelector)) {
        me.skipScrollIntoView = true;
        me.activeItem = target;
        me.skipScrollIntoView = skipScrollIntoView;
        if (me.activeItem && itemsTabbable) {
          me.triggerNavigate(focusInEvent);
        }
      } else if (target === me.target) {
        const fromWhere = relatedTarget ? target.compareDocumentPosition(relatedTarget) : 0;
        if (fromWhere & Node.DOCUMENT_POSITION_CONTAINED_BY) {
          (_a2 = owner.previousSibling) == null ? void 0 : _a2.focus();
        } else {
          me.activeItem = previousActiveItem && me.target.contains(previousActiveItem) ? previousActiveItem : 0;
        }
      }
    }
  }
  onTargetFocusOut(focusOutEvent) {
    const me = this, { relatedTarget } = focusOutEvent;
    if (!(relatedTarget == null ? void 0 : relatedTarget.matches(".b-focus-trap"))) {
      if (!relatedTarget || !me.target.contains(relatedTarget) || !relatedTarget.matches(me.itemSelector)) {
        if (me.activeItem) {
          me.activeItem = null;
          if (me.itemsTabbable) {
            me.triggerNavigate(focusOutEvent);
          }
        }
      }
    }
  }
  onTargetMouseDown(mouseDownEvent) {
    const me = this, target = mouseDownEvent.target.closest(me.itemSelector);
    me.navigationEvent = mouseDownEvent;
    if (me.itemsTabbable) {
      if (target === me.activeItem) {
        me.triggerNavigate(mouseDownEvent);
      }
    } else if (me.ownerCmp.itemsFocusable === false) {
      me.onFocusGesture(mouseDownEvent);
    } else if (target) {
      mouseDownEvent.preventDefault();
      DomHelper.focusWithoutScrolling(target);
    }
  }
  onTargetClick(clickEvent) {
    var _a2;
    const me = this, { skipScrollIntoView } = me;
    if (me.skipNextClick || ((_a2 = me.navigationEvent) == null ? void 0 : _a2.ignoreNavigation)) {
      me.skipNextClick = false;
      return;
    }
    if (me.disabled) {
      return;
    }
    me.skipScrollIntoView = true;
    if (me.processEvent) {
      clickEvent = me.processEvent.call(me.ownerCmp, clickEvent);
    }
    if (clickEvent) {
      me.activeItem = clickEvent.target.closest(me.itemSelector);
      me.triggerNavigate(clickEvent);
    }
    me.skipScrollIntoView = skipScrollIntoView;
  }
  // We have to prevent focus moving from eg, an input field when we mousedown
  // or touchtap a non focusable item when ownerCmp has itemsFocusable: false.
  // If the event was not on an item, we must allow it through to allow Lists
  // to contain other widgets.
  onFocusGesture(event) {
    if (event.target === this.ownerCmp.contentElement || event.target.closest(this.itemSelector) && this.ownerCmp.itemsFocusable === false) {
      event.preventDefault();
    }
  }
  acceptNode(node) {
    return node.offsetParent && node.matches && node.matches(this.itemSelector) ? DomHelper.NodeFilter.FILTER_ACCEPT : DomHelper.NodeFilter.FILTER_SKIP;
  }
  changeActiveItem(activeItem) {
    if (activeItem != null) {
      if (this.ownerCmp.getItem) {
        activeItem = this.ownerCmp.getItem(activeItem);
      }
    }
    return activeItem;
  }
  updateActiveItem(activeItem, oldActiveItem) {
    var _a2;
    const me = this, { ownerCmp } = me, isActive = oldActiveItem && me.target.contains(oldActiveItem), needsFocus = activeItem && DomHelper.isFocusable(activeItem) && activeItem !== DomHelper.getActiveElement(activeItem);
    if (isActive) {
      me.previousActiveItem = oldActiveItem;
    }
    if (oldActiveItem) {
      oldActiveItem.classList.remove(me.focusCls);
      oldActiveItem.removeAttribute("id");
    }
    if (activeItem != null) {
      if (me.skipScrollIntoView) {
        if (needsFocus) {
          DomHelper.focusWithoutScrolling(activeItem);
        }
      } else {
        (_a2 = ownerCmp.scrollable) == null ? void 0 : _a2.scrollIntoView(activeItem, {
          block: "nearest",
          focus: needsFocus,
          silent: me.scrollSilently
        });
      }
      if (activeItem === oldActiveItem && isActive) {
        return;
      }
      activeItem.classList.add(me.focusCls);
      activeItem.id = `${me.owner.id}-active-descendant`;
      me._activeItem = activeItem;
    } else {
      me._activeItem = null;
      if (oldActiveItem === DomHelper.getActiveElement(oldActiveItem)) {
        ownerCmp.revertFocus();
      }
    }
  }
  updateTarget(target, oldTarget) {
    const me = this, listeners = {
      element: target,
      thisObj: me,
      focusin: "onTargetFocusIn",
      focusout: "onTargetFocusOut",
      // If items are tabbable the mousedown handler will not force the issue by focusing
      // the closest item. We just need to trigger the method so that it is hookable
      mousedown: {
        handler: "onTargetMouseDown",
        delegate: me.itemSelector
      }
    };
    if (!me.itemsTabbable && !me.itemsFocusable) {
      listeners.click = "onTargetClick";
    }
    if (!Object.prototype.hasOwnProperty.call(me, "acceptNode")) {
      me.acceptNode = me.acceptNode.bind(me);
      me.acceptNode.acceptNode = me.acceptNode;
    }
    EventHelper.on(listeners);
    me.treeWalker = me.setupTreeWalker(target, DomHelper.NodeFilter.SHOW_ELEMENT, me.acceptNode);
    if (!me.keyEventTarget) {
      me.keyEventTarget = target;
    }
    (me.targetMutationMonitor = new MutationObserver(me.onTargetChildListChange.bind(me))).observe(target, {
      childList: true,
      subtree: true
    });
  }
  setupTreeWalker(root, whatToShow, filter2) {
    return document.createTreeWalker(root, whatToShow, filter2);
  }
  onTargetChildListChange() {
    var _a2;
    const me = this, {
      activeItem,
      datasetIdProperty
    } = me;
    if (activeItem) {
      if (me.target.contains(activeItem)) {
        if (!activeItem.classList.contains(me.focusCls)) {
          activeItem.classList.add(me.focusCls);
        }
      } else {
        me.activeItem = me.target.querySelector(`${me.itemSelector}.${me.focusCls}[data-${StringHelper.hyphenate(datasetIdProperty)}="${activeItem.dataset[datasetIdProperty]}"]`) || ((_a2 = me.target.querySelector(`${me.itemSelector}.${me.focusCls}`)) == null ? void 0 : _a2[activeItem.dataset.index]) || null;
      }
    }
  }
  changeKeyEventTarget(keyEventTarget) {
    this._keyEventTarget = keyEventTarget;
    EventHelper.on({
      element: keyEventTarget,
      keydown: "onKeyDown",
      thisObj: this
    });
  }
  triggerNavigate(event, item = this.activeItem) {
    var _a2;
    const navEvent = {
      event,
      item,
      oldItem: this.previousActiveItem
    };
    this.trigger("navigate", navEvent);
    (_a2 = this.ownerCmp) == null ? void 0 : _a2.trigger("navigate", navEvent);
  }
};
Navigator._$name = "Navigator";

// ../Core/lib/Core/helper/util/NumberFormat.js
var escapeRegExp = StringHelper.escapeRegExp;
var digitsRe2 = /[\d+-]/g;
var newFormatter = (locale4, config) => new Intl.NumberFormat(locale4 || void 0, config);
var numFormatRe = /^(?:([$])\s*)?(?:(\d+)>)?\d+(,\d+)?(?:\.((\d*)(?:#*)|[*]))?(?:\s*([%])?)?$/;
var unicodeMinus = "\u2212";
var NumberParser = class {
  constructor(formatter) {
    const me = this, locale4 = formatter.locale, numFmt = newFormatter(locale4, {
      maximumFractionDigits: 3
    }), currency = formatter.is.currency ? me._decodeStyle(locale4, {
      style: "currency",
      currency: formatter.currency,
      currencyDisplay: formatter.currencyDisplay
    }) : null, percent = formatter.is.percent ? me._decodeStyle(locale4, {
      style: "percent"
    }) : null, decimal = numFmt.format(1.2).replace(digitsRe2, "")[0], grouper = numFmt.format(1e9).replace(digitsRe2, "")[0] || "";
    Object.assign(me, { currency, decimal, formatter, grouper, percent });
    me.decimal = decimal;
    me.decimalRe = escapeRegExp(decimal, "g");
    me.grouper = grouper;
    me.stripRe = new RegExp(
      `(?:\\s+|${escapeRegExp(grouper)})` + (currency ? `|(?:${escapeRegExp(currency.text)})` : "") + (percent ? `|(?:${escapeRegExp(percent.text)})` : ""),
      "g"
    );
  }
  decimalPlaces(value) {
    value = value.replace(this.stripRe, "");
    const dot = value.indexOf(this.decimal) + 1;
    return dot && value.length - dot;
  }
  parse(value, strict) {
    if (typeof value === "string") {
      value = value.replace(this.stripRe, "").replace(this.decimalRe, ".").replace(unicodeMinus, "-");
      value = strict ? Number(value) : parseFloat(value);
      if (this.formatter.is.percent) {
        value /= 100;
      }
    }
    return value;
  }
  _decodeStyle(locale4, fmtDef) {
    const fmt = newFormatter(locale4, fmtDef), decFmt = newFormatter(locale4, Object.assign(
      fmt.resolvedOptions(),
      { style: "decimal" }
    )), zero = fmt.format(0), zeroDec = decFmt.format(0);
    return {
      suffix: zero.startsWith(zeroDec),
      text: zero.replace(zeroDec, "").trim()
    };
  }
};
var _NumberFormat = class _NumberFormat extends Formatter {
  static get $name() {
    return "NumberFormat";
  }
  initialize() {
    this._as = {
      // cacheKey : cachedInstance
    };
    this.is = {
      decimal: false,
      currency: false,
      percent: false,
      null: true,
      from: null
    };
  }
  get truncator() {
    const scale = this.maximumFractionDigits, digits = Math.min(20, scale + 1);
    return scale == null ? null : this.as({ style: "decimal", maximumFractionDigits: digits, minimumFractionDigits: digits }, "truncator");
  }
  configure(options) {
    if (typeof options !== "string") {
      Object.assign(this, options);
    } else {
      this.template = options;
    }
    const me = this, config = {}, loc = me.locale ? LocaleManager_default.locales[me.locale] : LocaleManager_default.locale, localeDefaults = loc == null ? void 0 : loc.NumberFormat, { template } = me, { standardOptions } = me.constructor;
    if (localeDefaults) {
      for (const key in localeDefaults) {
        if (me[key] == null && typeof localeDefaults[key] !== "function") {
          me[key] = localeDefaults[key];
        }
      }
    }
    if (template) {
      const match = numFormatRe.exec(template), m2 = match[2], m4 = match[4];
      me.useGrouping = !!match[3];
      me.style = match[1] ? "currency" : match[6] ? "percent" : "decimal";
      if (m2) {
        me.integer = +m2;
      }
      if (m4 === "*") {
        me.fraction = [0, 20];
      } else if (m4 != null) {
        me.fraction = [match[5].length, m4.length];
      }
    }
    me._minMax("fraction", true, true);
    me._minMax("integer", true, false);
    me._minMax("significant", false, true);
    for (const key of standardOptions) {
      if (me[key] != null) {
        config[key] = me[key];
      }
    }
    me.is.from = me.from && me.from.is;
    me.is[me.style] = !(me.is.null = false);
    me.formatter = newFormatter(me.locale, config);
  }
  /**
   * Creates a derived `NumberFormat` from this instance, with a different `style`. This is useful for processing
   * currency and percentage styles without the symbols being injected in the formatting.
   *
   * @param {String|Object} change The new style (if a string) or a set of properties to update.
   * @param {String} [cacheAs] A key by which to cache this derived formatter.
   * @returns {Core.helper.util.NumberFormat}
   */
  as(change, cacheAs = null) {
    const config = this.resolvedOptions() || { template: "9.*" }, cache = this._as;
    let ret = cacheAs && cache[cacheAs];
    if (!ret) {
      if (typeof change === "string") {
        config.style = change;
      } else {
        Object.assign(config, change);
      }
      config.from = this;
      ret = new _NumberFormat(config);
    }
    if (cacheAs) {
      cache[cacheAs] = ret;
    }
    return ret;
  }
  defaultParse(value, strict) {
    return value == null ? value : strict ? Number(value) : parseFloat(value);
  }
  /**
   * Returns the given `value` formatted in accordance with the specified locale and
   * formatting options.
   *
   * @param {Number} value
   * @returns {String}
   */
  format(value) {
    if (typeof value === "string") {
      const v = Number(value);
      value = isNaN(v) ? this.parse(value) : v;
    }
    return super.format(value);
  }
  // The parse() method is inherited but the base class implementation
  // cannot properly document the parameter and return types:
  /**
   * Returns a `Number` parsed from the given, formatted `value`, in accordance with the
   * specified locale and formatting options.
   *
   * If the `value` cannot be parsed, `NaN` is returned.
   *
   * Pass `strict` as `true` to require all text to convert. In essence, the default is
   * in line with JavaScript's `parseFloat` while `strict=true` behaves like the `Number`
   * constructor:
   *```
   *  parseFloat('1.2xx');  // = 1.2
   *  Number('1.2xx')       // = NaN
   *```
   * @method parse
   * @param {String} value
   * @param {Boolean} [strict=false]
   * @returns {Number}
   */
  /**
   * Returns a `Number` parsed from the given, formatted `value`, in accordance with the
   * specified locale and formatting options.
   *
   * If the `value` cannot be parsed, `NaN` is returned.
   *
   * This method simply passes the `value` to `parse()` and passes `true` for the second
   * argument.
   *
   * @method parseStrict
   * @param {String} value
   * @returns {Number}
   */
  /**
   * Returns the given `Number` rounded in accordance with the specified locale and
   * formatting options.
   *
   * @param {Number|String} value
   * @returns {Number}
   */
  round(value) {
    return this.parse(this.format(value));
  }
  /**
   * Returns the given `Number` truncated to the `maximumFractionDigits` in accordance
   * with the specified locale and formatting options.
   *
   * @param {Number|String} value
   * @returns {Number}
   */
  truncate(value) {
    const me = this, scale = me.maximumFractionDigits, { truncator } = me;
    let v = me.parse(value), dot;
    if (truncator) {
      v = truncator.format(v);
      dot = v.indexOf(truncator.parser.decimal);
      if (dot > -1 && v.length - dot - 1 > scale) {
        v = v.slice(0, dot + scale + 1);
      }
      v = truncator.parse(v);
    }
    return v;
  }
  resolvedOptions() {
    const options = super.resolvedOptions();
    for (const key in options) {
      if (options[key] === void 0) {
        options[key] = this[key];
      }
    }
    return options;
  }
  /**
   * Expands the provided shorthand into the "minimum*Digits" and "maximum*Digits".
   * @param {String} name
   * @param {Boolean} setMin
   * @param {Boolean} setMax
   * @private
   */
  _minMax(name, setMin, setMax) {
    const me = this, value = me[name];
    if (value != null) {
      const capName = StringHelper.capitalize(name), max = `maximum${capName}Digits`, min2 = `minimum${capName}Digits`;
      if (typeof value === "number") {
        if (setMin) {
          me[min2] = value;
        }
        if (setMax) {
          me[max] = value;
        }
      } else {
        me[min2] = value[0];
        me[max] = value[1];
      }
    }
  }
};
// This object holds only those properties that Intl.NumberFormat accepts in its
// "options" parameter. Only these options will be copied from the NumberFormat
// and passed to the Intl.NumberFormat constructor and only these will be copied
// back from its resolvedOptions:
__publicField(_NumberFormat, "standardOptions", [
  "currency",
  "currencyDisplay",
  "locale",
  "maximumFractionDigits",
  "minimumFractionDigits",
  "minimumIntegerDigits",
  "maximumSignificantDigits",
  "minimumSignificantDigits",
  "style",
  "useGrouping"
]);
var NumberFormat = _NumberFormat;
NumberFormat.Parser = NumberParser;
Object.assign(NumberFormat.prototype, {
  /**
   * The currency to use when using `style: 'currency'`. For example, `'USD'` (US dollar)
   * or `'EUR'` for the euro.
   *
   * If not provided, the {@link Core.localization.LocaleManager} default will be used.
   * @config {String}
   */
  currency: null,
  /**
   * The format in which to display the currency value when using `style: 'currency'`.
   *
   * Valid values are: `'symbol'` (the default), `'code'`, and `'name'`.
   * @config {'symbol'|'code'|'name'}
   * @default
   */
  currencyDisplay: "symbol",
  /**
   * Specifies the `minimumFractionDigits` and `minimumFractionDigits` in a compact
   * way. If this value is a `Number`, it sets both the minimum and maximum to that
   * value. If this value is an array, `[0]` sets the minimum and `[1]` sets the
   * maximum.
   * @config {Number|Number[]}
   */
  fraction: null,
  from: null,
  /**
   * An alias for `minimumIntegerDigits`.
   * @config {Number}
   */
  integer: null,
  /**
   * The name of the locale. For example, `'en-US'`. This config is the same as the
   * first argument to the `Intl.NumberFormat` constructor.
   *
   * Defaults to the browser's default locale.
   * @config {String}
   */
  locale: null,
  /**
   * The maximum number of digits following the decimal.
   *
   * This is more convenient to specify using the {@link #config-fraction} config.
   * @config {Number}
   */
  maximumFractionDigits: null,
  /**
   * The minimum number of digits following the decimal.
   *
   * This is more convenient to specify using the {@link #config-fraction} config.
   * @config {Number}
   */
  minimumFractionDigits: null,
  /**
   * The minimum number of digits preceding the decimal.
   *
   * This is more convenient to specify using the {@link #config-integer} config.
   * @config {Number}
   */
  minimumIntegerDigits: null,
  /**
   * The maximum number of significant digits.
   *
   * This is more convenient to specify using the {@link #config-significant} config.
   * @config {Number}
   */
  maximumSignificantDigits: null,
  /**
   * The minimum number of significant digits.
   *
   * This is more convenient to specify using the {@link #config-significant} config.
   * @config {Number}
   */
  minimumSignificantDigits: null,
  /**
   * Specifies the `minimumSignificantDigits` and `minimumSignificantDigits` in a compact
   * format. If this value is a `Number`, it sets only the maximum to that value. If this
   * value is an array, `[0]` sets the minimum and `[1]` sets the maximum.
   *
   * If this value (or `minimumSignificantDigits` or `minimumSignificantDigits`) is set,
   * `integer` (and `minimumIntegerDigits`) and `fraction` (and `minimumFractionDigits`
   * and `minimumFractionDigits`) are ignored.
   *
   * @config {Number|Number[]}
   */
  significant: null,
  /**
   * The formatting style.
   *
   * Valid values are: `'decimal'` (the default), `'currency'`, and `'percent'`.
   * @config {'decimal'|'currency'|'percent'}
   * @default
   */
  style: "decimal",
  /**
   * A format template consisting of the following parts:
   *```
   *  [$] [\d+:] \d+ [,\d+] [.\d* [#*] | *] [%]
   *```
   * If the template begins with a `'$'`, the formatter's `style` option is set to
   * `'currency'`. If the template ends with `'%'`, `style` is set to `'percent'`.
   * It is invalid to include both characters. When using `'$'`, the `currency` symbol
   * defaults to what is provided by the {@link Core.localization.LocaleManager}.
   *
   * To set the `minimumIntegerDigits`, the desired minimum comes before the first
   * digits in the template and is followed by a `'>'` (greater-than). For example:
   *```
   *  5>9,999.00
   *```
   * The above sets `minimumIntegerDigits` to 5.
   *
   * The `useGrouping` option is enabled if there is a `','` (comma) present and is
   * disabled otherwise.
   *
   * If there is a `'.'` (decimal) present, it may be followed by either of:
   *
   *  - Zero or more digits which may then be followed by zero or more `'#'` characters.
   *    The number of digits determines the `minimumFractionDigits`, while the total
   *    number of digits and `'#'`s determines the `maximumFractionDigits`.
   *  - A single `'*'` (asterisk) indicating any number of fractional digits (no minimum
   *    or maximum).
   *
   * @config {String}
   */
  template: null,
  /**
   * Specify `false` to disable thousands separators.
   * @config {Boolean}
   * @default
   */
  useGrouping: true
});
Formatter.number = (format2, value) => NumberFormat.get(format2).format(value);
NumberFormat._$name = "NumberFormat";

// ../Core/lib/Core/util/WebSocketManager.js
var WebSocketManager = class extends Events_default(Base) {
  construct(config = {}) {
    const me = this;
    super.construct(config);
    me.onWsOpen = me.onWsOpen.bind(me);
    me.onWsClose = me.onWsClose.bind(me);
    me.onWsMessage = me.onWsMessage.bind(me);
    me.onWsError = me.onWsError.bind(me);
    if (me.autoConnect && me.address) {
      me.open();
    }
  }
  doDestroy() {
    const me = this;
    if (me.connector) {
      me.detachSocketListeners(me.connector);
      me.connector.close();
      me.connector = null;
    }
    super.doDestroy();
  }
  //#region Websocket state
  get isConnecting() {
    var _a2;
    return ((_a2 = this.connector) == null ? void 0 : _a2.readyState) === this.constructor.webSocketImplementation.CONNECTING;
  }
  get isOpened() {
    var _a2;
    return ((_a2 = this.connector) == null ? void 0 : _a2.readyState) === this.constructor.webSocketImplementation.OPEN;
  }
  get isClosing() {
    var _a2;
    return ((_a2 = this.connector) == null ? void 0 : _a2.readyState) === this.constructor.webSocketImplementation.CLOSING;
  }
  get isClosed() {
    var _a2;
    return ((_a2 = this.connector) == null ? void 0 : _a2.readyState) === this.constructor.webSocketImplementation.CLOSED;
  }
  //#endregion
  //#region Websocket init
  createWebSocketConnector() {
    const connector = this.connector = new this.constructor.webSocketImplementation(this.address);
    this.attachSocketListeners(connector);
  }
  destroyWebSocketConnector() {
    this.detachSocketListeners(this.connector);
    this.connector.close();
    this.connector = null;
  }
  attachSocketListeners(connector) {
    const me = this;
    connector.addEventListener("open", me.onWsOpen);
    connector.addEventListener("close", me.onWsClose);
    connector.addEventListener("message", me.onWsMessage);
    connector.addEventListener("error", me.onWsError);
  }
  detachSocketListeners(connector) {
    const me = this;
    connector.removeEventListener("open", me.onWsOpen);
    connector.removeEventListener("close", me.onWsClose);
    connector.removeEventListener("message", me.onWsMessage);
    connector.removeEventListener("error", me.onWsError);
  }
  //#endregion
  //#region Websocket methods
  /**
   * Connect to the server and start listening for messages
   * @returns {Promise} Returns true if connection was successful and false otherwise
   */
  async open() {
    const me = this;
    if (me._openPromise) {
      return me._openPromise;
    }
    if (!me.address) {
      console.warn("Server me.address cannot be empty");
      return;
    }
    if (me.isOpened) {
      return true;
    }
    me.createWebSocketConnector();
    let detacher2;
    me._openPromise = new Promise((resolve) => {
      detacher2 = me.ion({
        open() {
          resolve(true);
        },
        error() {
          resolve(false);
        }
      });
    }).then((value) => {
      detacher2();
      me._openPromise = null;
      if (!value) {
        me.destroyWebSocketConnector();
      }
      return value;
    }).catch(() => {
      me._openPromise = null;
      me.destroyWebSocketConnector();
    });
    return me._openPromise;
  }
  /**
   * Close socket and disconnect from the server
   */
  close() {
    if (this.connector) {
      this.destroyWebSocketConnector();
      this.trigger("close");
    }
  }
  /**
   * Send data to the websocket server
   * @param {String} command
   * @param {*} data
   */
  send(command, data = {}) {
    var _a2;
    (_a2 = this.connector) == null ? void 0 : _a2.send(JSON.stringify({ command, ...data }));
  }
  //#endregion
  //#region websocket event listeners
  onWsOpen(event) {
    this.trigger("open", { event });
  }
  onWsClose(event) {
    this.trigger("close", { event });
  }
  onWsMessage(message) {
    try {
      const data = JSON.parse(message.data);
      this.trigger("message", { data });
    } catch (error) {
      this.trigger("error", { error });
    }
  }
  onWsError(error) {
    this.trigger("error", { error });
  }
  //#endregion
};
// This allows to hook into for testing purposes
__publicField(WebSocketManager, "webSocketImplementation", typeof WebSocket === "undefined" ? null : WebSocket);
__publicField(WebSocketManager, "configurable", {
  /**
   * WebSocket server address
   * @config {String}
   */
  address: "",
  /**
   * User name allowing to identify client
   * @config {String}
   */
  userName: "User",
  /**
   * Connect to websocket server immediately after instantiation
   * @config {Boolean}
   */
  autoConnect: true
});
WebSocketManager._$name = "WebSocketManager";

// ../Core/lib/Core/mixin/Clipboardable.js
var Clipboard = class extends Base.mixin(Events_default) {
  constructor() {
    super(...arguments);
    // Defaults to true, so to set this lazy on first read/write
    __publicField(this, "hasNativeAccess", true);
    __publicField(this, "_content", null);
  }
  /**
   * Write to the native Clipboard API or a local clipboard as a fallback.
   * @param {String} text Only allows string values
   * @param {Boolean} allowNative `true` will try writing to the Clipboard API once
   * @private
   */
  async writeText(text, allowNative) {
    const me = this, { _content } = me;
    if (allowNative && me.hasNativeAccess) {
      try {
        await navigator.clipboard.writeText(text);
      } catch (e) {
        me.hasNativeAccess = false;
      }
    }
    if (_content !== text) {
      me._content = text;
      me.triggerContentChange(_content, false, true);
    }
  }
  /**
   * Reads from the native Clipboard API or a local clipboard as a fallback.
   * @param {Boolean} allowNative `true` will try reading from the Clipboard API once
   * @private
   */
  async readText(allowNative) {
    const me = this, { _content } = me;
    if (allowNative && me.hasNativeAccess) {
      try {
        const text = await navigator.clipboard.readText();
        if (_content !== text) {
          me._content = text;
          me.triggerContentChange(_content, true);
        }
        return text;
      } catch (e) {
        me.hasNativeAccess = false;
      }
    }
    return _content;
  }
  /**
   * Call this to let other instances know that data has been pasted
   * @param {Object} source
   */
  triggerPaste(source) {
    this.trigger("paste", { source, text: this._content });
  }
  triggerContentChange(oldText, fromRead = false, fromWrite = false) {
    this.trigger("contentChange", { fromRead, fromWrite, oldText, newText: this._content });
  }
  async clear(allowNative) {
    await this.writeText("", allowNative);
  }
};
var Clipboardable_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    construct(...args) {
      super.construct(...args);
      if (!globalThis.bryntum.clipboard) {
        globalThis.bryntum.clipboard = new Clipboard();
      }
      globalThis.bryntum.clipboard.ion({
        paste: "onClipboardPaste",
        contentChange: "onClipboardContentChange",
        thisObj: this
      });
    }
    /**
     * Gets the current shared Clipboard instance
     * @private
     */
    get clipboard() {
      return globalThis.bryntum.clipboard;
    }
    // Called when someone triggers a paste event on the shared Clipboard
    onClipboardPaste({ text, source }) {
      var _a3;
      const me = this, { clipboardText, isCut } = me, isOwn = me.compareClipboardText(clipboardText, text);
      if (isOwn && isCut) {
        (_a3 = me.handleCutData) == null ? void 0 : _a3.call(me, { text, source });
        me.isCut = false;
        me.cutData = null;
      } else if (!isOwn) {
        me.clearClipboard(false);
      }
    }
    // Calls when the shared clipboard writes or reads a new string value
    onClipboardContentChange({ newText }) {
      if (!this.compareClipboardText(this.clipboardText, newText)) {
        this.clearClipboard(false);
      }
    }
    // When a cut is done, or a cut is deactivated
    set cutData(data) {
      var _a3, _b;
      const me = this;
      (_a3 = me._cutData) == null ? void 0 : _a3.forEach((r) => me.setIsCut(r, false));
      me._cutData = ArrayHelper.asArray(data);
      (_b = me._cutData) == null ? void 0 : _b.forEach((r) => me.setIsCut(r, true));
    }
    get cutData() {
      return this._cutData;
    }
    setIsCut() {
    }
    /**
     * Writes string data to the shared/native clipboard. Also saves a local copy of the string and the unconverted
     * data.
     *
     * But firstly, it will call beforeCopy function and wait for a response. If false, the copy will be prevented.
     *
     * @param {Object} data
     * @param {Boolean} isCut
     * @param {Object} [params] Will be passed to beforeCopy function
     * @returns {String} String data that was written to the clipboard
     * @private
     */
    async writeToClipboard(data, isCut, params = {}) {
      if (await this.beforeCopy({ data, isCut, ...params }) === false) {
        return;
      }
      const me = this, isString = typeof data === "string", stringData = isString ? data : me.stringConverter ? me.stringConverter(data) : StringHelper.safeJsonStringify(data);
      me.clipboardText = stringData;
      await me.clipboard.writeText(stringData, me.useNativeClipboard);
      me.clipboardData = data;
      me.isCut = isCut;
      me.cutData = isCut && !isString ? data : null;
      return stringData;
    }
    /**
     * Reads string data from the shared/native clipboard. If string matches current instance local clipboard data, a
     * non-modified version will be return. Otherwise, a stringParser function will be called.
     *
     * But firstly, it will call beforePaste function and wait for a response. If false, the paste will be prevented.
     *
     * This function will also trigger a paste event on the clipboard instance.
     *
     * @param {Object} [params] Will be passed to beforePaste function
     * @param {Boolean} [skipPasteTrigger] Set to `true` not trigger a paste when paste completes
     * @returns {Object}
     * @private
     */
    async readFromClipboard(params = {}, skipPasteTrigger = false) {
      var _a3;
      const me = this, { clipboard } = me, text = await clipboard.readText(me.useNativeClipboard), { isOwn, data } = me.transformClipboardText(text), isCut = text && isOwn && me.isCut;
      if (data == null || Array.isArray(data) && data.length == 0 || // Hook to trigger event or something like that
      await ((_a3 = me.beforePaste) == null ? void 0 : _a3.call(me, { data, text, ...params, isCut })) === false) {
        return;
      }
      if (!isOwn) {
        me.clearClipboard(false);
      }
      skipPasteTrigger || clipboard.triggerPaste(me);
      return data;
    }
    /**
     * Clears the clipboard data
     * @privateparam {Boolean} [clearShared] Set to `false` not to clear the internally shared and native clipboard
     * @category Common
     */
    async clearClipboard(clearShared = true) {
      const me = this;
      me.clipboardData = me.clipboardText = me.cutData = null;
      me.isCut = false;
      if (clearShared) {
        await me.clipboard.clear(me.useNativeClipboard);
      }
    }
    compareClipboardText(a, b) {
      const regex = /\r\n|(?!\r\n)[\n-\r\x85\u2028\u2029]/g;
      return (a == null ? void 0 : a.replace(regex, "\n")) === (b == null ? void 0 : b.replace(regex, "\n"));
    }
    /**
     * Takes a clipboard text and returns an object with an `isOwn` property and the parsed `data`
     * @param {String} text The text string that was read from the clipboard
     * @returns {Object}
     * @private
     */
    transformClipboardText(text) {
      const me = this, isOwn = me.compareClipboardText(me.clipboardText, text), data = isOwn ? me.clipboardData : me.stringParser && text ? me.stringParser(text) : text;
      return {
        isOwn,
        data
      };
    }
    /**
     * Checks local clipboard if there is clipboard data present. If native clipboard API is available, this function
     * will return `undefined`
     * @returns {Object}
     * @private
     */
    hasClipboardData() {
      const { clipboard } = this, { _content } = clipboard;
      if (this.useNativeClipboard && clipboard.hasNativeAccess) {
        return;
      }
      return Boolean(_content && this.transformClipboardText(_content).data);
    }
  }, __publicField(_a2, "$name", "Clipboardable"), __publicField(_a2, "configurable", {
    /**
     * Set this to `true` to use native Clipboard API if it is available
     * @config {Boolean}
     * @default
     * @private
     */
    useNativeClipboard: false
  }), _a2;
};

// ../Core/lib/Core/mixin/Finalizable.js
var Finalizable_default = (Target) => class Finalizable extends (Target || Base) {
  static get $name() {
    return "Finalizable";
  }
  construct(...args) {
    super.construct(...args);
    this.finalizer = null;
    this.finalizing = null;
    this.isFinalized = false;
    this.isFinalizing = false;
  }
  /**
   * This template method is called at the end of {@link #function-finalize}. By default it calls `destroy()`, but
   * can be replaced by the derived class. This can be useful if it is not the `Finalizable` instance that awaits
   * the {@link #function-finalize} method.
   */
  doFinalize() {
    this.destroy();
  }
  /**
   * This method is called (typically by this instance or its owner) to cleanup this instance while possibly first
   * waiting for the {@link #property-finalizer} promise to settle. Once settled, the {@link #function-doFinalize}
   * method is called.
   * @async
   */
  finalize() {
    const me = this;
    let ret = me.finalizing;
    if (!ret && !me.isFinalized) {
      me.isFinalizing = true;
      me.finalizing = ret = me._awaitFinalizer();
    }
    return ret;
  }
  async _awaitFinalizer() {
    const me = this;
    try {
      await me.finalizer;
    } finally {
      me.finalizing = null;
      me.isFinalized = true;
      me.doFinalize();
    }
  }
};

// ../Core/lib/Core/util/drag/DragContext.js
var ABORTED = Symbol("dragAbort");
var INIT = Symbol("dragInit");
var DRAGGING = Symbol("dragDrag");
var DROPPED = Symbol("dragDrop");
var lockDirections = {
  x: "horizontal",
  y: "vertical"
};
var DragContext = class extends Base.mixin(Finalizable_default, Delayable_default, Identifiable_default) {
  static get configurable() {
    return {
      /**
       * The element that will have the {@link Core.mixin.Draggable#property-draggingItemCls}. This element is
       * determined by the {@link Core.mixin.Draggable#config-dragItemSelector}.
       * @config {HTMLElement}
       */
      itemElement: null,
      /**
       * The `ScrollManager` instance to use for scrolling while dragging.
       * @config {Core.util.ScrollManager}
       * @private
       */
      scrollManager: null,
      /**
       * Config for `startMonitoring` call.
       * @config {Object}
       * @private
       */
      monitoringConfig: null,
      /**
       * The source of the drag operation.
       * @config {Core.mixin.Draggable}
       * @default
       * @readonly
       * @private
       */
      source: null,
      /**
       * The current target of the drag.
       * @member {Core.mixin.Droppable}
       * @readonly
       * @private
       */
      target: null,
      /**
       * The current target element of the drag.
       * @member {HTMLElement}
       * @private
       */
      targetElement: null,
      /**
       * The minimum distance from the touchstart/mousedown/pointerdown that must be moved to actually start a
       * drag operation.
       * @config {Number}
       * @default
       * @readonly
       */
      threshold: 5,
      /**
       * The minimum amount of time a touch must be maintained before it will initiate a drag. Movement prior to
       * this time will cancel the drag in order to allow touch scrolling.
       * @config {Number}
       * @default
       */
      touchStartDelay: 300
    };
  }
  static get identifiable() {
    return {};
  }
  /**
   * The current DOM event being processed.
   * @member {Event} event
   * @readonly
   */
  construct(...args) {
    super.construct(...args);
    const me = this, { event } = me;
    Object.assign(me, {
      /**
       * This property holds the `altKey` state of the most recent event.
       * @member {Boolean}
       */
      altKey: null,
      /**
       * An array of functions to call when cleaning up the context instance.
       * @member {Function[]}
       * @private
       */
      cleaners: [],
      /**
       * This property holds the `ctrlKey` state of the most recent event.
       * @member {Boolean}
       */
      ctrlKey: null,
      /**
       * Container for data associated with the drag. Data items are added by the {@link Core.mixin.Draggable}
       * when the drag starts.
       * @member {Map}
       * @private
       */
      data: /* @__PURE__ */ new Map(),
      /**
       * The element from which the drag operation started.
       * @member {HTMLElement}
       * @readonly
       */
      element: event.target,
      /**
       * The event that completed the drag (a `mouseup`, `pointerup` or `touchend`).
       * @member {Event}
       * @readonly
       */
      endEvent: null,
      /**
       * The most recent `mousemove`, `pointermove` or `touchmove` event.
       * @member {Event}
       * @private
       */
      lastMoveEvent: null,
      /**
       * This property holds the `metaKey` state of the most recent event.
       * @member {Boolean}
       */
      metaKey: null,
      /**
       * The previous {@link #property-target} of the drag.
       * @member {Core.mixin.Droppable}
       * @readonly
       * @private
       */
      previousTarget: null,
      /**
       * The scroll actions reported by the {@link #config-scrollManager}.
       * @member {Object}
       * @private
       */
      scrollerAction: null,
      /**
       * This property holds the `shiftKey` state of the most recent event.
       * @member {Boolean}
       */
      shiftKey: null,
      /**
       * This property holds the current state of the drag process.
       *
       * This will be one of the following values:
       *
       *  - `DragContext.STATE.INIT` - The button is down but there is insufficient movement to start the drag.
       *  - `DragContext.STATE.DRAGGING` - The button is down and movement has started the drag.
       *  - `DragContext.STATE.DROPPED` - The button has been released and drop has occurred.
       *  - `DragContext.STATE.ABORTED` - The drag has been aborted (this happens if the user presses the `ESC`
       *    key or if the {@link #function-abort} method is called).
       *
       * @member {Symbol}
       * @readonly
       * @internal
       */
      state: INIT,
      /**
       * The event that started the drag operation.
       * @member {Event}
       * @readonly
       */
      startEvent: event,
      /**
       * The timer that fires when a touch pointermove is allowed to start the drag. A touch pointermove event
       * prior to this will `abort()` the drag to allow touch scrolling.
       * @member {Number}
       * @private
       */
      touchStartTimer: null,
      /**
       * Stores the value from writes to the {@link #property-valid} property.
       * @member {Boolean}
       * @private
       */
      _valid: true
    });
    if ("touches" in event && me.touchStartDelay) {
      me.touchStartTimer = me.setTimeout(() => me.touchStartTimer = null, me.touchStartDelay, "touchStartDelay");
    }
    EventHelper.on({
      element: globalThis,
      blur: "onWindowBlur",
      thisObj: me
    });
  }
  doDestroy() {
    const me = this, { source, target } = me;
    me.cleanup();
    if ((target == null ? void 0 : target.dropping) === me) {
      target.dropping = null;
    }
    if ((source == null ? void 0 : source.dragging) === me) {
      source.dragging = null;
    }
    super.doDestroy();
  }
  onWindowBlur() {
    if (this.started) {
      this.abort();
    }
  }
  /**
   * This property is `true` if the {@link #function-abort} method was called and `false` otherwise. This
   * is typically because the user pressed the ESC key, however, a drag can be aborted for other reasons.
   * @property {Boolean}
   * @readonly
   */
  get aborted() {
    return this.state === ABORTED;
  }
  /**
   * Returns `true` if the drag has completed either by mouse/pointerup or the {@link #function-abort} method.
   * @property {Boolean}
   * @readonly
   */
  get completed() {
    return this.isDestroying || this.aborted || this.endEvent !== null;
  }
  /**
   * This property is `true` if the drag {@link #config-threshold} has not yet been reached.
   * @property {Boolean}
   * @readonly
   */
  get pending() {
    return this.state === INIT;
  }
  /**
   * This property is `true` if the drag {@link #config-threshold} has been reached and the drag operation is active.
   * @property {Boolean}
   * @readonly
   */
  get started() {
    return this.state !== INIT && !this.aborted;
  }
  /**
   * This property is `true` when the drag is in a valid drop state. This can be set to `false` to indicate the drop
   * is invalid. Setting to `true` does not ensure that the property will be `true` when next read due to other factors
   * that are required to make the drop valid. For example, setting `valid = true` will still return `false` if called
   * before the drag {@link #config-threshold} has not been reached or if the {@link #function-abort} method has been
   * called.
   * @property {Boolean}
   */
  get valid() {
    return this.started && this.targetElement != null && this._valid;
  }
  set valid(v) {
    this._valid = v;
  }
  //region Data Access
  /**
   * Retrieves a data item from the drag source. This method can only be called after the drag has completed.
   * @param {String|String[]} name The name of the data item.
   * @returns {*}
   */
  async get(name) {
    if (this.aborted) {
      throw new Error("Data is not available on aborted drag");
    }
    if (!this.completed) {
      throw new Error("Data is not available until drag completion");
    }
    if (Array.isArray(name)) {
      return Promise.all(name.map((s) => this.get(s)));
    }
    let value = this.data.get(name);
    if (typeof value === "function") {
      value = await value();
      this.data.set(name, value);
    }
    return value;
  }
  /**
   * Returns `true` if the named data item is present.
   * @param {String} name The name of the data item.
   * @returns {Boolean}
   */
  has(name) {
    return this.data.has(name);
  }
  /**
   * Retrieves a data item from the drag source if it is available. This will return `true` for an item that was
   * {@link #function-set} using a renderer function.
   * @param {String|String[]} name The name of the data item.
   * @returns {*}
   */
  peek(name) {
    if (this.aborted) {
      throw new Error("Data is not available on aborted drag");
    }
    if (Array.isArray(name)) {
      return name.map((s) => this.peek(s));
    }
    let value = this.data.get(name);
    if (typeof value === "function") {
      value = true;
    }
    return value;
  }
  /**
   * Sets a data item for the drag. If a function is passed, it is called to render the data only if that data is
   * actually requested via the {@link #function-get} method. A data renderer function can be `async`.
   * @param {String} name The name of the data item.
   * @param {*} value The value of the data item.
   */
  set(name, value) {
    this.data.set(name, value);
  }
  //endregion
  //region Configs
  changeTarget(target, was) {
    if (target !== was) {
      const me = this;
      me._target = target;
      me.previousTarget = was;
      if (was) {
        was.dropping = null;
      }
      if (target) {
        target.dropping = me;
        if (target.dropping !== me) {
          target = null;
          me.valid = false;
        }
      }
      me._target = was;
    }
    return target;
  }
  updateTarget(target, was) {
    const me = this;
    if (was) {
      me.source.dragLeaveTarget(me, was);
    }
    if (target) {
      me.valid = true;
      target.dragMove(me);
      me.source.dragEnterTarget(me);
    }
  }
  updateTargetElement(targetElement) {
    let droppable, droppables, droppableSelector, i, t;
    for (t = targetElement; t; t = t.parentElement) {
      droppables = DomDataStore.get(t, "droppables");
      if (droppables) {
        for (i = 0; i < droppables.length; ++i) {
          droppable = droppables[i];
          if (droppable.dropRootElement.contains(targetElement)) {
            droppableSelector = droppable.droppableSelector;
            if (!droppableSelector || targetElement.closest(`#${DomHelper.getId(droppable.dropRootElement)} ${droppableSelector}`)) {
              this.target = droppable;
              if (this.target === droppable) {
                return;
              }
            }
          }
        }
      }
    }
  }
  //endregion
  //region Operations
  /**
   * Aborts the drag. After calling this method, {@link #property-aborted} will be `true`, {@link #property-valid}
   * will be `false` and {@link #property-completed} will be `true`.
   */
  abort() {
    const me = this, { element, source } = me;
    element == null ? void 0 : element.getBoundingClientRect();
    if (me.state !== DROPPED) {
      me.state = ABORTED;
      me.cleanup();
    }
    source == null ? void 0 : source.endDrag(me);
  }
  begin() {
    const me = this, { source } = me, ret = source.beforeDrag(me);
    if (ret !== false) {
      source.dragging = me;
    }
    return ret;
  }
  cleanup() {
    let cleaner;
    while (cleaner = this.cleaners.pop()) {
      cleaner();
    }
  }
  end(event) {
    const me = this, { lastMoveEvent: lastEvent, target } = me, { dragSwallowClickTime } = me.source;
    me.event = me.domEvent = me.endEvent = event;
    me.syncFlags();
    if (me.started) {
      if ((lastEvent == null ? void 0 : lastEvent.clientX) !== event.clientX || (lastEvent == null ? void 0 : lastEvent.clientY) !== event.clientY || (lastEvent == null ? void 0 : lastEvent.target) !== event.target) {
        me.track();
      }
      if (dragSwallowClickTime) {
        EventHelper.on({
          element: document,
          capture: true,
          expires: dragSwallowClickTime,
          // In case a click did not ensue, remove the listener
          once: true,
          click(event2) {
            event2.stopPropagation();
          }
        });
      }
      me.state = DROPPED;
      if (target !== me.source) {
        target == null ? void 0 : target.dragDrop(me);
      }
    }
  }
  fakeKey(event, down) {
    const me = this, { lastMoveEvent } = me;
    if (lastMoveEvent && me.element) {
      let changed;
      lastMoveEvent.isKey = true;
      if (event.key === "Alt") {
        if (me.altKey !== down) {
          me.altKey = down;
          changed = true;
        }
      } else if (event.key === "Control") {
        if (me.ctrlKey !== down) {
          me.ctrlKey = down;
          changed = true;
        }
      }
      if (changed) {
        me.event = me.domEvent = lastMoveEvent;
        me.track();
      }
    }
  }
  keyDown(event) {
    if (!this.completed) {
      if (event.key === "Escape") {
        this.abort();
      } else if (this.isDragToggleKey(event.key)) {
        this.fakeKey(event, true);
      }
    }
  }
  keyUp(event) {
    if (!this.completed && this.isDragToggleKey(event.key)) {
      this.fakeKey(event, false);
    }
  }
  getDistance(event) {
    return EventHelper.getDistanceBetween(this.startEvent, event);
  }
  isDragToggleKey(key) {
    return key === "Control" || key === "Alt";
  }
  move(event) {
    const me = this, { target } = event, distance = me.getDistance(event), significant = distance >= me.threshold;
    me.syncFlags();
    if (me.touchStartTimer) {
      if (significant) {
        me.abort();
      }
      return;
    }
    if (target && target.nodeType === Node.ELEMENT_NODE) {
      if (significant && !me.started) {
        me.event = me.domEvent = event;
        if (me.start() === false) {
          me.abort();
          return;
        }
      }
      if (me.started && !me.completed) {
        me.lastMoveEvent = me.event = me.domEvent = event;
        if (event.type === "touchmove") {
          event.preventDefault();
          event.stopImmediatePropagation();
        }
        me.track();
      }
    }
  }
  start() {
    const me = this, { scrollManager, monitoringConfig, source } = me, { draggingBodyCls: activeCls, dragLock } = source, element = (
      /* source.dragWithin || */
      source.dragRootElement
    );
    me.state = DRAGGING;
    if (me.startEvent.type === "touchstart" && BrowserHelper.isMobileSafari) {
      for (let node = me.startEvent.target.parentElement; node; node = node.parentElement) {
        const { style } = node, overflow = DomHelper.getStyleValue(node, "overflow");
        if (overflow === "auto" || overflow == "scroll") {
          if (!me.scrollingAncestors) {
            me.scrollingAncestors = [];
          }
          me.scrollingAncestors.push([node, style.overflow, style.overflowX, style.overflowY]);
          style.overflow = "hidden";
        }
      }
      me.requestAnimationFrame(() => {
        me.scrollingAncestors.forEach(([{ style }, overflow, overflowX, overflowY]) => {
          style.overflow = overflow;
          style.overflowX = overflowX;
          style.overflowY = overflowY;
        });
        me.scrollingAncestors = null;
      });
    }
    if (scrollManager) {
      const detacher2 = scrollManager.startMonitoring(Objects.merge({
        scrollables: [{
          element
        }],
        direction: lockDirections[dragLock] || dragLock || "both",
        callback(scrollerAction) {
          const { lastMoveEvent } = me;
          if (lastMoveEvent && me.element) {
            lastMoveEvent.isScroll = true;
            me.event = me.domEvent = lastMoveEvent;
            me.scrollerAction = scrollerAction;
            me.track();
            me.scrollerAction = null;
          }
        }
      }, monitoringConfig));
      me.cleaners.push(detacher2);
    }
    const rootEl = source.dragRootElement.closest(".b-outer") || document.body;
    rootEl.classList.add(activeCls);
    me.cleaners.push(() => rootEl.classList.remove(activeCls));
    if (source.startDrag(me) === false) {
      me.cleanup();
      return false;
    }
  }
  syncFlags() {
    const me = this, { event } = me;
    me.altKey = event.altKey;
    me.ctrlKey = event.ctrlKey || event.metaKey;
    me.metaKey = event.metaKey;
    me.shiftKey = event.shiftKey;
  }
  track() {
    const me = this, { event, source, target } = me;
    let targetElement = event.target, touch;
    if (event.type === "touchmove") {
      touch = event.changedTouches[0];
      targetElement = DomHelper.elementFromPoint(touch.clientX, touch.clientY);
    }
    me.targetElement = targetElement;
    if (target === me.target) {
      target == null ? void 0 : target.dragMove(me);
    }
    source.trackDrag(me);
  }
  //endregion
};
__publicField(DragContext, "$name", "DragContext");
DragContext.prototype.STATE = DragContext.STATE = Object.freeze({
  ABORTED,
  INIT,
  DRAGGING,
  DROPPED
});
DragContext._$name = "DragContext";

// ../Core/lib/Core/util/drag/DragProxy.js
var DragProxy = class _DragProxy extends Base.mixin(Factoryable_default) {
  static get type() {
    return "default";
  }
  static get configurable() {
    return {
      /**
       * The currently active `DragContext`. This context will be active prior to be passed to the proxy. This
       * config is set by {@link #function-dragStart} and cleared by {@link #function-dragEnd}.
       * @config {Core.util.drag.DragContext}
       */
      dragging: null
    };
  }
  static get factoryable() {
    return {
      defaultType: _DragProxy
    };
  }
  /**
   * The `Draggable` instance that owns this drag proxy.
   * @member {Core.mixin.Draggable} owner
   * @readonly
   */
  //region Configs
  updateDragging(drag, was) {
    if (was) {
      this.close(was);
    }
    if (drag) {
      this.open(drag);
    }
  }
  //endregion
  //region Operations
  /**
   * This template method is called when {@link #config-dragging} is reset to `null`.
   * @param {Core.util.drag.DragContext} drag The drag instance.
   */
  close(drag) {
  }
  /**
   * This template method is called when {@link #config-dragging} is set to a non-`null` value.
   * @param {Core.util.drag.DragContext} drag The drag instance.
   */
  open(drag) {
  }
  //endregion
  //region Drag Processing
  /**
   * This template method is called by the `Draggable` instance when the drag officially starts.
   * This sets the {@link #config-dragging} config to `drag`, which triggers the call to {@link #function-open}.
   * @param {Core.util.drag.DragContext} drag The drag instance.
   */
  dragStart(drag) {
    this.dragging = drag;
  }
  /**
   * This template method is called by the `Draggable` instance as drag movement occurs.
   * @param {Core.util.drag.DragContext} drag The drag instance.
   */
  dragMove(drag) {
  }
  /**
   * This template method is called by the `Draggable` instance when the drag completes.
   *
   * This sets the {@link #config-dragging} config to `null`, which triggers the call to {@link #function-close}.
   * @param {Core.util.drag.DragContext} drag The drag instance.
   */
  dragEnd(drag) {
    this.dragging = null;
  }
  //endregion
};
DragProxy.initClass();
DragProxy._$name = "DragProxy";

// ../Core/lib/Core/mixin/Draggable.js
var Draggable_default = (Target) => class Draggable extends (Target || Base) {
  static get $name() {
    return "Draggable";
  }
  //region Configs
  static get configurable() {
    return {
      /**
       * The current `DragContext`. This is created immediately on pointerdown but does not become active until
       * some movement occurs. This {@link #config-dragThreshold threshold} is configurable.
       * @member {Core.util.drag.DragContext}
       * @readonly
       */
      dragging: {
        $config: "nullify",
        value: null
      },
      /**
       * A CSS selector to use to ascend from the {@link #config-dragRootElement} to find the element that will
       * gain the {@link #property-draggingCls} and {@link #property-draggingStartedCls} CSS classes.
       * @config {String}
       */
      draggingClsSelector: null,
      /**
       * The listeners to add to the `document` during a drag.
       * @config {Object}
       * @private
       */
      dragDocumentListeners: {
        element: document,
        keydown: "onDragKeyDown",
        keyup: "onDragKeyUp",
        // On mobile, a long-press will (sometimes) trigger a context menu, so we suppress it:
        contextmenu: "onDragContextMenu",
        // We don't use pointermove/up because they get snared in the "touch-action" vs "pan-x/y" trap and we
        // cannot prevent panning (aka scrolling) in response to move events if we go that way:
        mousemove: "onDragPointerMove",
        mouseup: "onDragPointerUp",
        // Touch desktops don't fire touchend event when touch has ended, instead pointerup is fired. iOS does
        // fire touchend:
        pointerup: "onDragPointerUp",
        touchend: "onDragPointerUp",
        touchmove: {
          handler: "onDragPointerMove",
          passive: false
          // We need to be able to preventDefault on the touchmove
        }
      },
      /**
       * A CSS selector to use to ascend from the drag element to find the element that will gain the
       * {@link #property-draggingItemCls} CSS class. If not supplied, the drag element will gain this CSS
       * class.
       * @config {String}
       */
      dragItemSelector: null,
      /**
       * A CSS class to add to items identified by the {@link #config-dragItemSelector} when the mouse
       * enters.
       * @config {String}
       */
      dragItemOverCls: null,
      /**
       * A function to call when the pointer enters a {@link #config-dragItemSelector}.
       * @config {Function} onDragItemMouseEnter
       * @param {MouseEvent} event Pointer event
       * @param {HTMLElement} element Over element
       * @returns {void}
       */
      /**
       * A function to call when the pointer moves inside a {@link #config-dragItemSelector}.
       * @config {Function} onDragItemMouseMove
       * @param {MouseEvent} event Pointer event
       * @param {HTMLElement} element Over element
       * @returns {void}
       */
      /**
       * A function to call when the pointer leaves a {@link #config-dragItemSelector}.
       * @config {Function} onDragItemMouseLeave
       * @param {MouseEvent} event Pointer event
       * @param {HTMLElement} element Over element
       * @returns {void}
       */
      /**
       * Configure as `'x'` to lock dragging to the `X` axis (the drag will only move horizontally) or `'y'`
       * to lock dragging to the `Y` axis (the drag will only move vertically).
       * @config {'x'|'y'|null}
       */
      dragLock: null,
      /**
       * The minimum distance a drag must move to be considered a drop and not
       * {@link Core.util.drag.DragContext#property-aborted}.
       * @config {Number}
       * @default
       */
      dragMinDistance: 1,
      /**
       * The {@link Core.util.drag.DragProxy drag proxy} is a helper object that can be used to display feedback
       * during a drag.
       * @config {DragProxyConfig|Core.util.drag.DragProxy}
       */
      dragProxy: {
        $config: ["lazy", "nullify"],
        value: null
      },
      /**
       * The outer element where dragging will operate (attach events to it and use as root limit when looking
       * for ancestors).
       * @config {HTMLElement}
       */
      dragRootElement: {
        $config: "nullify",
        value: null
      },
      /**
       * Set to `true` to allow a drag to drop on to the same element from which the drag started.
       * @config {Boolean}
       * @default
       */
      dragSameTargetDrop: false,
      /**
       * A CSS selector used to determine which element(s) can be dragged.
       * @config {String}
       * @default
       */
      dragSelector: null,
      /**
       * A CSS selector used to identify child element(s) that should not trigger drag.
       * @config {String}
       */
      ignoreSelector: null,
      /**
       * The number of milliseconds after a pointerup to ignore click events on the document. This
       * is used to avoid the "up" event itself generating a `click` on the target.
       * @config {Number}
       * @default
       */
      dragSwallowClickTime: 50,
      /**
       * The amount of pixels to move pointer/mouse before it counts as a drag operation.
       * @config {Number}
       * @default
       */
      dragThreshold: 5,
      /**
       * The number of milliseconds that must elapse after a `touchstart` event before it is considered a drag. If
       * movement occurs before this time, the drag is aborted. This is to allow touch swipes and scroll gestures.
       * @config {Number}
       * @default
       */
      dragTouchStartDelay: 300,
      /**
       * The CSS selector to use to identify the closest valid target from the event target.
       * @config {String}
       */
      dropTargetSelector: null,
      /**
       * The {@link #config-dragSelector} item the mouse is currently over.
       * @member {HTMLElement} overItem
       * @readonly
       */
      overItem: null,
      testConfig: {
        dragSwallowClickTime: 50
      }
    };
  }
  static get properties() {
    return {
      /**
       * The CSS class to add to the {@link #config-dragRootElement} (or {@link #config-draggingClsSelector} from
       * there) as soon as the pointerdown event occurs.
       * @member {String}
       * @readonly
       */
      draggingCls: "b-draggable-active",
      /**
       * The CSS class to add to the `body` element as soon as the {@link #config-dragThreshold} is reached and
       * an actual drag is in progress.
       * @member {String}
       * @readonly
       */
      draggingBodyCls: "b-draghelper-active",
      // match DragHelper since we need the same treatment
      /**
       * The CSS class to add to the element being dragged as soon as the pointerdown event occurs.
       * @member {String}
       * @readonly
       */
      draggingItemCls: "b-dragging-item",
      /**
       * The CSS class to add to the {@link #config-dragRootElement} (or {@link #config-draggingClsSelector} from
       * there) as soon as the {@link #config-dragThreshold} is reached and an actual drag is in progress.
       * @member {String}
       * @readonly
       */
      draggingStartedCls: "b-draggable-started",
      /**
       * The CSS class that is added to the {@link #config-dragRootElement}, i.e., `'b-draggable'`.
       * @property {String}
       * @readonly
       */
      draggableCls: "b-draggable"
    };
  }
  //endregion
  //region Drag Processing
  // These template methods are implemented by derived classes as desired. There is only one overlap with Droppable's
  // template methods (dragDrop) so that a class can easily mixin both Draggable and Droppable and always distinguish
  // whether it is acting as the source, the target, or both.
  /**
   * This template method is called when the mousedown of a potential drag operation occurs. This happens before the
   * gesture is known to be a drag, meaning the {@link #config-dragThreshold} has not been reached. This method
   * should initialize the {@link Core.util.drag.DragContext} using the {@link Core.util.drag.DragContext#function-set}
   * method. Alternatively, this method may return `false` to prevent the drag operation.
   *
   * *Important:* Because no drag has occurred at the time this method is called, only minimal processing should be
   * done (such as initializing the {@link Core.util.drag.DragContext}). Anything more should be done in the
   * {@link #function-dragStart} method or in response to the {@link #event-dragStart} event which happen only if
   * the user drags the mouse before releasing the mouse button.
   * @param {Core.util.drag.DragContext} drag
   */
  beforeDrag(drag) {
    const { dragRootElement, dragSelector, ignoreSelector } = this, target = dragSelector && drag.element.closest(dragSelector);
    return !dragSelector || Boolean(
      target && target === dragRootElement || dragRootElement.contains(target) && (!ignoreSelector || !drag.element.matches(ignoreSelector))
    );
  }
  /**
   * This template method is called when the drag operation starts. This occurs when the {@link #config-dragThreshold}
   * has been reached.
   * Your implementation may return `false` to prevent the startup of the drag operation.
   * @param {Core.util.drag.DragContext} drag
   */
  dragStart(drag) {
  }
  /**
   * This template method is called as the drag moves. This occurs on each mouse/pointer/touchmove event.
   * @param {Core.util.drag.DragContext} drag
   */
  dragOver(drag) {
  }
  /**
   * This template method is called when the drag enters a {@link Core.mixin.Droppable target}.
   * @param {Core.util.drag.DragContext} drag
   */
  dragEnterTarget(drag) {
  }
  /**
   * This template method is called when the drag leaves a {@link Core.mixin.Droppable target}.
   * @param {Core.util.drag.DragContext} drag
   * @param {Core.mixin.Droppable} oldTarget The previous value of `drag.target`.
   */
  dragLeaveTarget(drag, oldTarget) {
  }
  /**
   * This template method is called when the drag operation completes. This occurs on the pointerup event.
   *
   * This method is not called if the drag is {@link Core.util.drag.DragContext#property-aborted}.
   * @param {Core.util.drag.DragContext} drag
   */
  dragDrop(drag) {
  }
  /**
   * This template method is called when the drag operation completes. This occurs on the pointerup event or perhaps
   * a keypress event.
   *
   * This method is always called, even if the drag is {@link Core.util.drag.DragContext#property-aborted}.
   * @param {Core.util.drag.DragContext} drag
   */
  dragEnd(drag) {
  }
  //endregion
  //region Drag Management
  // These methods are called by the DragContext and generally manage element updates (adding/removing classes) or
  // event firing. In most cases these methods then call a corresponding Drag Processing template method intended
  // for derived classes to implement.
  get activeDrag() {
    const { dragging: drag } = this;
    return (drag == null ? void 0 : drag.started) && !drag.completed ? drag : null;
  }
  /**
   * Return the `Events` instance from which drag events are fired.
   * @internal
   * @property {Core.mixin.Events}
   */
  get dragEventer() {
    return this.trigger ? this : null;
  }
  get draggingClassElement() {
    const { draggingClsSelector, dragRootElement } = this;
    return draggingClsSelector ? dragRootElement == null ? void 0 : dragRootElement.closest(draggingClsSelector) : dragRootElement;
  }
  beginDrag(drag) {
    const { draggingCls, draggingClassElement } = this;
    if (draggingCls && draggingClassElement) {
      draggingClassElement.classList.add(draggingCls);
      drag.cleaners.push(() => draggingClassElement.classList.remove(draggingCls));
    }
  }
  async endDrag(drag) {
    const me = this, { dragEventer, dragProxy } = me;
    if (drag.valid) {
      await me.dragDrop(drag);
    }
    if (me.isDestroyed) {
      return;
    }
    if (drag.pending) {
      drag.destroy();
    } else {
      me.dragEnd(drag);
      dragProxy == null ? void 0 : dragProxy.dragEnd(drag);
      dragEventer == null ? void 0 : dragEventer.trigger(drag.valid ? "drop" : "dragCancel", { drag, event: drag.event });
      me.finalizeDrag(drag);
    }
  }
  async finalizeDrag(drag) {
    var _a2;
    await ((_a2 = drag.finalize) == null ? void 0 : _a2.call(drag));
  }
  moveDrag(drag) {
    if (this.dragOver(drag) !== false) {
      const { dragEventer, dragProxy } = this;
      dragProxy == null ? void 0 : dragProxy.dragMove(drag);
      dragEventer == null ? void 0 : dragEventer.trigger("drag", { drag, event: drag.event });
    }
  }
  setupDragContext(event) {
    const me = this, { dragItemSelector, id } = me, { target } = event;
    return {
      event,
      id: id ? `${id}-drag-${me._nextDragId = (me._nextDragId || 0) + 1}` : null,
      itemElement: dragItemSelector ? target.closest(dragItemSelector) : target,
      touchStartDelay: me.dragTouchStartDelay,
      source: me,
      threshold: me.dragThreshold
    };
  }
  startDrag(drag) {
    const { draggingStartedCls, draggingClassElement, draggingItemCls, dragEventer, dragProxy } = this, { itemElement } = drag;
    if ((dragEventer == null ? void 0 : dragEventer.trigger("beforeDragStart", { drag, event: drag.event })) === false) {
      return false;
    }
    if (draggingStartedCls && draggingClassElement) {
      draggingClassElement.classList.add(draggingStartedCls);
      drag.cleaners.push(() => draggingClassElement.classList.remove(draggingStartedCls));
    }
    if (draggingItemCls && itemElement) {
      itemElement.classList.add(draggingItemCls);
      drag.cleaners.push(() => itemElement.classList.remove(draggingItemCls));
    }
    dragProxy == null ? void 0 : dragProxy.dragStart(drag);
    const result = this.dragStart(drag);
    if (result !== false) {
      dragEventer == null ? void 0 : dragEventer.trigger("dragStart", { drag, event: drag.event });
    }
    return result;
  }
  trackDrag(drag) {
    var _a2;
    const { dropTargetSelector } = this;
    drag.valid = !(dropTargetSelector && !((_a2 = drag.targetElement) == null ? void 0 : _a2.closest(dropTargetSelector)));
    this.moveDrag(drag);
  }
  //endregion
  //region Configs
  configureListeners(drag) {
    const me = this, listeners = ObjectHelper.assign({
      thisObj: me
    }, me.dragDocumentListeners);
    if ("touches" in drag.startEvent) {
      delete listeners.mousemove;
      delete listeners.mouseup;
    } else {
      delete listeners.contextmenu;
      delete listeners.touchmove;
      delete listeners.touchend;
      delete listeners.pointerup;
    }
    return listeners;
  }
  //endregion
  //region Configs
  updateDragging(drag, old) {
    const me = this;
    if (drag) {
      const listeners = me.configureListeners(drag);
      drag.cleaners.push(EventHelper.on(listeners));
      me.beginDrag(drag);
    } else if (old) {
      old.destroy();
    }
  }
  changeDragProxy(config, existing) {
    return DragProxy.reconfigure(existing, config, {
      owner: this,
      defaults: {
        owner: this
      }
    });
  }
  updateDragRootElement(rootEl, was) {
    var _a2;
    const me = this, {
      draggableCls,
      dragItemSelector,
      onDragItemMouseMove
    } = me;
    was == null ? void 0 : was.classList.remove(draggableCls);
    (_a2 = me._dragRootDetacher) == null ? void 0 : _a2.call(me);
    if (rootEl) {
      const listeners = {
        thisObj: me,
        element: rootEl,
        mousedown: "onDragMouseDown",
        // We have touchstart listener in place since Siesta/Chrome can send these events even on non-touch
        // devices:
        touchstart: "onDragTouchStart",
        // On iOS, because we use pointerup to represent the drop gesture,
        // the initiating pointerdown event is captured, and its target is
        // the original start target. We must always release pointer capture.
        // https://github.com/bryntum/support/issues/4111
        pointerdown: (e) => {
          var _a3, _b;
          return e.pointerId && ((_b = (_a3 = e.target).releasePointerCapture) == null ? void 0 : _b.call(_a3, e.pointerId));
        }
      };
      if (onDragItemMouseMove) {
        listeners.mousemove = {
          delegate: dragItemSelector,
          handler: "onDragItemMouseMove"
        };
      }
      if (me.dragItemOverCls || onDragItemMouseMove || me.onDragItemMouseEnter || me.onDragItemMouseLeave) {
        Object.assign(listeners, {
          mouseover: {
            delegate: dragItemSelector,
            handler: "onDragItemMouseOver"
          },
          mouseout: {
            delegate: dragItemSelector,
            handler: "onDragItemMouseOut"
          }
        });
      }
      rootEl.classList.add(draggableCls);
      me._dragRootDetacher = EventHelper.on(listeners);
    }
  }
  //endregion
  //region Events
  onDragItemMouseOver(event) {
    this.overItem = event;
  }
  onDragItemMouseOut(event) {
    if (!this.dragging) {
      this.overItem = event;
    }
  }
  changeOverItem(event) {
    var _a2;
    this.enterLeaveEvent = event;
    if (event.type === "mouseout") {
      return ((_a2 = event.relatedTarget) == null ? void 0 : _a2.closest(this.dragItemSelector)) || null;
    } else {
      return event.target.closest(this.dragItemSelector);
    }
  }
  updateOverItem(overItem, oldOverItem) {
    var _a2, _b;
    const me = this, { dragItemOverCls } = me;
    if (oldOverItem) {
      dragItemOverCls && oldOverItem.classList.remove(dragItemOverCls);
      (_a2 = me.onDragItemMouseLeave) == null ? void 0 : _a2.call(me, me.enterLeaveEvent, oldOverItem);
    }
    if (overItem) {
      dragItemOverCls && overItem.classList.add(dragItemOverCls);
      (_b = me.onDragItemMouseEnter) == null ? void 0 : _b.call(me, me.enterLeaveEvent, overItem);
    }
  }
  onDragContextMenu(event) {
    event.preventDefault();
  }
  onDragKeyDown(event) {
    this.dragging.keyDown(event);
  }
  onDragKeyUp(event) {
    this.dragging.keyUp(event);
  }
  /**
   * Grab draggable element on mouse down.
   * @param {Event} event
   * @private
   */
  onDragMouseDown(event) {
    if (event.button === 0) {
      this.onDragPointerDown(event);
    }
  }
  /**
   * Grab draggable element on pointerdown.
   * @param {Event} event
   * @private
   */
  onDragPointerDown(event) {
    let { dragging: drag } = this;
    if (!drag) {
      drag = this.setupDragContext(event);
      if (drag) {
        drag = new DragContext(drag);
        if (drag.begin() === false) {
          drag.destroy();
        }
      }
    } else if (!drag.isFinalizing) {
      drag.abort();
    }
  }
  // Set by the DragContext in its begin method, and auto-nullified at destruction.
  changeDragging(value, was) {
    was == null ? void 0 : was.destroy();
    return value;
  }
  onDragPointerMove(event) {
    const { dragging: drag } = this;
    if (drag && !drag.completed) {
      drag == null ? void 0 : drag.move(event);
    }
  }
  onDragPointerUp(event) {
    const { dragging: drag } = this;
    if (drag && !drag.completed) {
      drag.end(event);
      this.endDrag(drag);
    }
  }
  /**
   * @param {Event} event
   * @private
   */
  onDragTouchStart(event) {
    if (event.touches.length === 1) {
      this.onDragPointerDown(event);
    }
  }
  //endregion
};

// ../Core/lib/Core/mixin/Droppable.js
var Droppable_default = (Target) => class Droppable extends (Target || Base) {
  static get $name() {
    return "Droppable";
  }
  //region Configs
  static get configurable() {
    return {
      /**
       * A selector, which, if specified, narrows the dropability to child elements of the
       * {@link #config-dropRootElement} which match this selector.
       * @config {String}
       */
      droppableSelector: null,
      /**
       * The current `DragContext`. This is set when a drag enters this target. Changing this config causes the
       * {@link #function-dragEnter} and {@link #function-dragLeave} methods to be called. If `dragEnter` returns
       * `false` for a drag, this value will be set to `null`.
       * @member {Core.util.drag.DragContext}
       * @readonly
       */
      dropping: null,
      /**
       * Set this config to the element where drops should be received. When set, the `b-droppable` CSS class is
       * added to the element and the `Droppable` instance is associated with that element so that it can be
       * found by {@link Core.mixin.Draggable draggables}.
       * @config {HTMLElement}
       */
      dropRootElement: {
        $config: "nullify",
        value: null
      }
    };
  }
  /**
   * Return the `Events` instance from which drop events are fired.
   * @internal
   * @property {Core.mixin.Events}
   */
  get dropEventer() {
    return this.trigger ? this : null;
  }
  /**
   * Returns the CSS class that is added to the {@link #config-dropRootElement}, i.e., `'b-droppable'`.
   * @property {String}
   * @readonly
   */
  get droppableCls() {
    return "b-droppable";
  }
  //endregion
  //region Drop Management
  /**
   * This method is called when a drag enters this droppable's `dropRootElement`. In many cases, this method is used
   * to create some sort of drop indicator to provide user feedback.
   *
   * If this method does not return `false`, the {@link #property-dropping} config will retain the given `drag` context
   * which was set prior to this method being called.
   *
   * If this method returns `false`, the drop will not be accepted. Neither {@link #function-dragDrop} nor
   * {@link #function-dragLeave} will be called for this drop. If the drag leaves this target and re-enters, this
   * method will be called again. While `dropping` will already be updated before this method is called, it will be
   * reset to `null` in this case.
   *
   * The base class implementation of this method fires the {@link #event-dragEnter} event.
   * @param {Core.util.drag.DragContext} drag
   * @returns {Boolean}
   */
  dragEnter(drag) {
    var _a2;
    return (_a2 = this.dropEventer) == null ? void 0 : _a2.trigger("dragEnter", { drag, event: drag.event });
  }
  /**
   * This method is called when the drag that was previously announced via {@link #function-dragEnter} moves to a new
   * position. This is typically where drop indicators are updated to reflect the new position.
   *
   * The base class implementation of this method fires the {@link #event-dragMove} event.
   * @param {Core.util.drag.DragContext} drag
   */
  dragMove(drag) {
    var _a2;
    return (_a2 = this.dropEventer) == null ? void 0 : _a2.trigger("dragMove", { drag, event: drag.event });
  }
  /**
   * This method is called when the drag that was previously announced via {@link #function-dragEnter} has ended with
   * a drop. In addition to any cleanup (since {@link #function-dragLeave} will not be called), this method handles
   * any updates associated with the data from the drag context and the position of the drop.
   *
   * The base class implementation of this method fires the {@link #event-drop} event.
   * @param {Core.util.drag.DragContext} drag
   */
  dragDrop(drag) {
    var _a2;
    return (_a2 = this.dropEventer) == null ? void 0 : _a2.trigger("drop", { drag, event: drag.event });
  }
  /**
   * This method is called when the drag that was previously announced via {@link #function-dragEnter} leaves this
   * droppable's `dropRootElement`, or the drag is {@link Core.util.drag.DragContext#property-aborted} by the user
   * pressing the `ESC` key, or the {@link Core.util.drag.DragContext#function-abort} method is called.
   *
   * This is the time to cleanup anything created by `dragEnter`.
   *
   * The base class implementation of this method fires the {@link #event-dragLeave} event.
   * @param {Core.util.drag.DragContext} drag
   */
  dragLeave(drag) {
    var _a2;
    return (_a2 = this.dropEventer) == null ? void 0 : _a2.trigger("dragLeave", { drag, event: drag.event });
  }
  //endregion
  //region Configs
  changeDropping(dropping, was) {
    if (dropping !== was) {
      const me = this;
      if (was) {
        if (was.aborted || !was.completed) {
          me.dragLeave(was);
        }
      }
      if (dropping) {
        me._dropping = dropping;
        if (me.dragEnter(dropping) === false) {
          dropping = null;
        }
        me._dropping = was;
      }
    }
    return dropping;
  }
  updateDropRootElement(rootEl, was) {
    const me = this, { droppableCls } = me;
    let droppables, i, removeCls;
    if (was) {
      droppables = DomDataStore.get(was, "droppables");
      removeCls = true;
      if (Array.isArray(droppables) && (i = droppables.indexOf(me)) > -1) {
        if (droppables.length < 2) {
          DomDataStore.remove(was, "droppables");
        } else {
          droppables.splice(i, 1);
          droppables.forEach((d) => {
            if (droppableCls === d.droppableCls) {
              removeCls = false;
            }
          });
        }
      }
      removeCls && was.classList.remove(droppableCls);
    }
    if (rootEl) {
      droppables = DomDataStore.get(rootEl, "droppables");
      if (droppables) {
        droppables.push(me);
      } else {
        DomDataStore.set(rootEl, "droppables", [me]);
      }
      rootEl.classList.add(droppableCls);
    }
  }
  //endregion
};

// ../Core/lib/Core/mixin/Featureable.js
var Featureable_default = (Target) => class Featureable extends (Target || Base) {
  static get $name() {
    return "Featureable";
  }
  static get configurable() {
    return {
      /**
       * Specifies the features to create and associate with the instance. The keys of this object are the names
       * of features. The values are config objects for those feature instances.
       *
       * After construction, this property can be used to access the feature instances and even reconfigure them.
       *
       * For example:
       * ```
       *  instance.features.amazing = {
       *      // reconfigure this feature
       *  }
       * ```
       * This can also be done in bulk:
       * ```
       *  instance.features = {
       *      amazing : {
       *          // reconfigure this feature
       *      },
       *      // reconfigure other features
       *  }
       * ```
       * @config {Object}
       */
      features: null
    };
  }
  static get declarable() {
    return [
      /**
       * This property getter returns options that control feature management for the derived class. This
       * property getter must be defined by the class that mixes in `Featureable` in order to initialize the
       * class properly.
       * ```
       *  class SuperWidget extends Widget.mixin(Featureable) {
       *      static get featureable() {
       *          return {
       *              factory : SuperWidgetFeature
       *          };
       *      }
       *      ...
       *  }
       * ```
       * @static
       * @member {Object} featureable
       * @property {Core.mixin.Factoryable} featureable.factory The factoryable class (not one of its instances)
       * that will be used to create feature instances.
       * @property {String} [featureable.ownerName='client'] The config or property to assign on each feature as
       * a reference to its creator, the `Featureable` instance.
       * @internal
       */
      "featureable"
    ];
  }
  static setupFeatureable(cls) {
    const featureable = {
      ownerName: "client",
      ...cls.featureable
    };
    featureable.factory.initClass();
    Reflect.defineProperty(cls, "featureable", {
      get() {
        return featureable;
      }
    });
  }
  doDestroy() {
    var _a2;
    const features = this.features;
    super.doDestroy();
    for (const name in features) {
      const feature = features[name];
      (_a2 = feature.destroy) == null ? void 0 : _a2.call(feature);
    }
  }
  /**
   * Returns `true` if the specified feature is active for this instance and `false` otherwise.
   * @param {String} name The feature name
   * @returns {Boolean}
   */
  hasFeature(name) {
    var _a2;
    return Boolean((_a2 = this.features) == null ? void 0 : _a2[name]);
  }
  changeFeatures(features, was) {
    if (this.isDestroying) {
      return;
    }
    const me = this, { featureable } = me.constructor, manager = me.$features || (me.$features = new DynamicObject({
      configName: "features",
      factory: featureable.factory,
      owner: me,
      ownerName: featureable.ownerName
    }));
    manager.update(features);
    if (!was) {
      return manager.target;
    }
  }
  // This does not need a className on Widgets.
  // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
  // to the Widget it's mixed in to should implement thus.
  get widgetClass() {
  }
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options), { features } = result;
    if (features) {
      for (const featureName in features) {
        if (Object.keys(features[featureName]).length === 0) {
          features[featureName] = true;
        }
      }
    }
    return result;
  }
};

// ../Core/lib/Core/mixin/Hoverable.js
var EDGES = {
  e: "b-hover-edge",
  t: "b-hover-top",
  r: "b-hover-right",
  b: "b-hover-bottom",
  l: "b-hover-left"
};
var EDGE_CLASSES = {
  [EDGES.e]: 1,
  [EDGES.t]: 1,
  [EDGES.r]: 1,
  [EDGES.b]: 1,
  [EDGES.l]: 1
};
var ZONES = {
  t: [EDGES.e, EDGES.t],
  r: [EDGES.e, EDGES.r],
  b: [EDGES.e, EDGES.b],
  l: [EDGES.e, EDGES.l],
  tr: [EDGES.e, EDGES.t, EDGES.r],
  bl: [EDGES.e, EDGES.b, EDGES.l],
  tl: [EDGES.e, EDGES.t, EDGES.l],
  br: [EDGES.e, EDGES.b, EDGES.r]
};
var Hoverable_default = (Target) => class Hoverable extends Target.mixin(Delayable_default) {
  static get $name() {
    return "Hoverable";
  }
  //region Configs
  static get configurable() {
    return {
      /**
       * A CSS class to add to the {@link #config-hoverTarget target} element.
       * @config {String}
       */
      hoverCls: null,
      /**
       * A CSS class to add to the {@link #config-hoverTarget target} element to enable CSS animations. This class
       * is added after calling {@link #function-hoverEnter}.
       * @config {String}
       */
      hoverAnimationCls: null,
      /**
       * A CSS class to add to the {@link #config-hoverRootElement root} element.
       * @config {String}
       */
      hoverRootCls: null,
      /**
       * A CSS class to add to the {@link #config-hoverRootElement root} element when there is an active
       * {@link #config-hoverTarget target}.
       * @config {String}
       */
      hoverRootActiveCls: null,
      /**
       * The number of milliseconds to delay notification of changes in the {@link #config-hoverTarget}.
       * @config {Number}
       */
      hoverDelay: null,
      /**
       * The current element that the cursor is inside as determined by `mouseover` and `mouseout`. Changes in
       * this config trigger re-evaluation of the {@link #config-hoverSelector} to determine if there is a
       * {@link #config-hoverTarget}.
       * @config {HTMLElement}
       * @private
       */
      hoverElement: null,
      /**
       * An element to ignore. Mouse entry into this element will not trigger a change in either of the
       * {@link #config-hoverElement} or {@link #config-hoverTarget} values.
       * @config {HTMLElement}
       */
      hoverIgnoreElement: null,
      /**
       * This property is a string containing one character for each edge that is hoverable. For example, a
       * value of "tb" indicates that the top and bottom edges are hoverable.
       * @config {String}
       */
      hoverEdges: null,
      /**
       * When {@link #config-hoverEdges} is used, this value determines the size (in pixels) of the edge. When
       * the cursor is within this number of pixels of an edge listed in `hoverEdges`, the appropriate CSS class
       * is added to the {@link #config-hoverTarget}:
       *
       *  - `b-hover-top`
       *  - `b-hover-right`
       *  - `b-hover-bottom`
       *  - `b-hover-left`
       *
       * Depending on the values of `hoverEdges`, it is possible to have at most two of these classes present at
       * any one time (when the cursor is in a corner).
       * @config {Number}
       * @default
       */
      hoverEdgeSize: 10,
      /**
       * The outer element where hover tracking will operate (attach events to it and use as root limit when
       * looking for ancestors).
       *
       * A common choice for this will be `document.body`.
       * @config {HTMLElement}
       */
      hoverRootElement: {
        $config: "nullify",
        value: null
      },
      /**
       * A selector for the [closest](https://developer.mozilla.org/en-US/docs/Web/API/Element/closest) API to
       * determine the actual element of interest. This selector is used to process changes to the
       * {@link #config-hoverElement} to determine the {@link #config-hoverTarget}.
       * @config {String}
       */
      hoverSelector: null,
      /**
       * The currently active hover target. This will be the same as {@link #config-hoverElement} unless there is
       * a {@link #config-hoverSelector}.
       * @config {HTMLElement}
       */
      hoverTarget: {
        $config: "nullify",
        value: null
      },
      /**
       * Set to `true` to include tracking of `mousemove` events for the active {@link #config-hoverTarget}. This
       * is required for the {@link #function-hoverMove} method to be called.
       * @config {Boolean}
       * @default false
       */
      hoverTrack: null,
      /**
       * A string value containing one character per active edge (e.g., "tr").
       * @config {String}
       * @private
       */
      hoverZone: null
    };
  }
  static get delayable() {
    return {
      setHoverTarget: 0
    };
  }
  //endregion
  //region State Handling
  /**
   * This method is called when the cursor enters the {@link #config-hoverTarget}. The `hoverTarget` will not be
   * `null`.
   * @param {HTMLElement} leaving The element that was previously the `hoverTarget`. This value may be null.
   */
  hoverEnter(leaving) {
  }
  /**
   * This method should return true if the given `element` should be ignored. By default, this is `true` if the
   * `element` is contained inside the {@link #config-hoverIgnoreElement}.
   * @param {HTMLElement} element
   * @returns {Boolean}
   * @protected
   */
  hoverIgnore(element) {
    var _a2;
    return (_a2 = this.hoverIgnoreElement) == null ? void 0 : _a2.contains(element);
  }
  /**
   * This method is called when the cursor leaves the {@link #config-hoverTarget}. The `hoverTarget` may be `null`
   * or refer to the new `hoverTarget`
   * @param {HTMLElement} leaving The element that was previously the `hoverTarget`. This value will not be null.
   */
  hoverLeave(leaving) {
  }
  /**
   * This method is called when the mouse moves within a {@link #config-hoverTarget}, but only if enabled by the
   * {@link #config-hoverTrack} config.
   * @param {Event} event
   */
  hoverMove(event) {
  }
  //endregion
  //region Events
  onHoverMouseMove(event) {
    const me = this, { hoverEdges, hoverEdgeSize, hoverTarget } = me;
    if (hoverTarget) {
      if (hoverEdges) {
        const { top, left, width, height, right, bottom } = hoverTarget.getBoundingClientRect(), { clientX, clientY } = event, centerX = left + width / 2, centerY = top + height / 2, t = clientY < (hoverEdgeSize ? top + hoverEdgeSize : centerY), r = clientX >= (hoverEdgeSize ? right - hoverEdgeSize : centerX), b = clientY >= (hoverEdgeSize ? bottom - hoverEdgeSize : centerY), l = clientX < (hoverEdgeSize ? left + hoverEdgeSize : centerX), tb = t || b ? t ? "t" : "b" : "", rl = r || l ? r ? "r" : "l" : "";
        me.hoverZone = (hoverEdges.includes(tb) ? tb : "") + (hoverEdges.includes(rl) ? rl : "");
      }
      me.hoverEvent = event;
      me.hoverTrack && me.hoverMove(event);
    }
  }
  onHoverMouseOver(event) {
    this.hoverEvent = event;
    this.hoverElement = event.target;
  }
  onHoverMouseOut(event) {
    this.hoverEvent = event;
    this.hoverElement = event.relatedTarget;
  }
  //endregion
  //region Configs
  // hoverDelay
  updateHoverDelay(delay2) {
    this.setHoverTarget.delay = delay2;
  }
  // hoverEdges
  changeHoverEdges(edges) {
    return edges === true ? "trbl" : (edges || "").replace("v", "tb").replace("h", "lr");
  }
  updateHoverEdges() {
    this.syncHoverListeners();
  }
  // hoverElement
  changeHoverElement(element) {
    if (!this.hoverIgnore(element)) {
      return element;
    }
  }
  updateHoverElement(hoverEl) {
    const { hoverSelector } = this;
    if (hoverSelector) {
      hoverEl = hoverEl == null ? void 0 : hoverEl.closest(hoverSelector);
    }
    this.setHoverTarget(hoverEl);
  }
  // hoverRootElement
  updateHoverRootElement(rootEl, was) {
    const { hoverRootCls } = this;
    if (hoverRootCls) {
      was == null ? void 0 : was.classList.remove(hoverRootCls);
      rootEl == null ? void 0 : rootEl.classList.add(hoverRootCls);
    }
    this.syncHoverListeners();
  }
  // hoverTarget
  changeHoverTarget(hoverEl, was) {
    if (was) {
      this.hoverZone = null;
    }
    return hoverEl;
  }
  updateHoverTarget(hoverEl, was) {
    const me = this, { hoverCls, hoverAnimationCls, hoverRootActiveCls, hoverRootElement } = me;
    if (hoverRootActiveCls) {
      hoverRootElement == null ? void 0 : hoverRootElement.classList[hoverEl ? "add" : "remove"](hoverRootActiveCls);
    }
    if (was) {
      hoverCls && was.classList.remove(hoverCls);
      hoverAnimationCls && was.classList.remove(hoverAnimationCls);
      me.hoverLeave(was);
    }
    if (hoverEl) {
      hoverCls && hoverEl.classList.add(hoverCls);
      me.hoverEnter(was);
      if (me.hoverTrack) {
        me.hoverMove(me.hoverEvent);
      }
      if (hoverAnimationCls) {
        hoverEl.getBoundingClientRect();
        hoverEl.classList.add(hoverAnimationCls);
      }
    }
  }
  // hoverTrack
  updateHoverTrack() {
    this.syncHoverListeners();
  }
  // hoverZone
  updateHoverZone(zone) {
    const { hoverAnimationCls, hoverTarget } = this;
    if (hoverTarget) {
      const { className } = hoverTarget, cls = DomClassList.change(
        className,
        /* add= */
        zone ? ZONES[zone] : null,
        /* remove= */
        EDGE_CLASSES
      );
      if (className !== cls) {
        hoverTarget.className = cls;
        if (zone && hoverAnimationCls) {
          hoverTarget.classList.remove(hoverAnimationCls);
          hoverTarget.getBoundingClientRect();
          hoverTarget.classList.add(hoverAnimationCls);
        }
      }
    }
  }
  //endregion
  //region Misc
  setHoverTarget(target) {
    this.hoverTarget = target;
  }
  syncHoverListeners() {
    var _a2;
    const me = this, element = me.hoverRootElement, listeners = {
      element,
      thisObj: me,
      mouseover: "onHoverMouseOver",
      mouseout: "onHoverMouseOut"
    };
    if (me.hoverTrack || me.hoverEdges) {
      listeners.mousemove = "onHoverMouseMove";
    }
    (_a2 = me._hoverRootDetacher) == null ? void 0 : _a2.call(me);
    me._hoverRootDetacher = element && EventHelper.on(listeners);
  }
  //endregion
};

// ../Core/lib/Core/mixin/LoadMaskable.js
var LoadMaskable_default = (Target) => {
  var _a2;
  return _a2 = class extends Target {
    static get configurable() {
      return {
        /**
         * A {@link Core.widget.Mask} config object to adjust the {@link Core.widget.Widget#config-maskDefaults}
         * when data is loading. The message and optional configuration from the
         * {@link Core.mixin.LoadMaskable#config-loadMask} config take priority over these options, just as they do
         * for `maskDefaults`, respectively.
         *
         * The final mask configuration for a load mask is as if the following were applied:
         *
         * ```
         *  Object.assign({},
         *      widget.maskDefaults,
         *      widget.loadMaskDefaults,
         *      widget.loadMask);
         * ```
         * @config {MaskConfig}
         * @category Masking
         */
        loadMaskDefaults: {
          useTransition: true,
          showDelay: 1e3
        },
        /**
         * A {@link Core.widget.Mask} config object to adjust the {@link Core.widget.Widget#config-maskDefaults}
         * when an error occurs loading data.
         *
         * Set to `false` to disable showing data loading error mask.
         *
         * The final mask configuration for an error mask is as if the following were applied:
         *
         * ```
         *  Object.assign({},
         *      widget.maskDefaults,
         *      widget.loadMaskDefaults,
         *      widget.loadMaskError,
         *      errorMessage);
         * ```
         * @config {MaskConfig|Core.widget.Mask|Boolean}
         * @category Masking
         */
        loadMaskError: {
          icon: "b-icon b-icon-warning",
          autoClose: 3e3,
          showDelay: 0
        },
        /**
         * A {@link Core.widget.Mask} config object, or a message to be shown when a store is performing a remote
         * operation, or Crud Manager is loading data from the sever. Set to `null` to disable default load mask.
         *
         * @config {String|MaskConfig|null}
         * @default "Loading..."
         * @category Masking
         */
        loadMask: {
          text: "L{GridBase.loadMask}"
        },
        /**
         * A {@link Core.widget.Mask} config object, or a message to be shown when Crud Manager
         * is persisting changes on the server. Set to `null` to disable default sync mask.
         *
         * This config is similar to {@link Core.mixin.LoadMaskable#config-loadMask} but designed for saving data.
         *
         * To create a custom sync mask need to subscribe to the Crud Manager events and show
         * {@link Core.widget.Mask Mask} on `beforeSend` and hide it on `requestDone` and `requestFail`.
         *
         * To create a custom sync mask, set this config to `null` and subscribe to the CrudManager's events to
         * show or hide the {@link Core.widget.Widget#config-masked mask} as desired.
         *
         * ```javascript
         *  widget.crudManager.on({
         *      loadStart() {
         *          widget.masked = {
         *              text : 'Data is loading...'
         *          };
         *      },
         *      load() {
         *          widget.masked = null;
         *      },
         *      loadCanceled() {
         *          widget.masked = null;
         *      },
         *      syncStart() {
         *          widget.masked = null;
         *      },
         *      sync() {
         *          widget.masked = null;
         *      },
         *      syncCanceled() {
         *          widget.masked = null;
         *      },
         *      requestFail({ response }) {
         *          widget.masked.error = response.message || 'Sync failed';
         *      }
         *  });
         *
         *  store.load();
         * ```
         *
         * @config {String|MaskConfig|null}
         * @default "Saving changes, please wait..."
         * @category Masking
         */
        syncMask: {
          text: "L{GridBase.syncMask}"
        },
        localizableProperties: ["loadMask.text", "syncMask.text"],
        testConfig: {
          loadMaskError: {
            icon: "b-icon b-icon-warning",
            autoClose: 500,
            showDelay: 0
          }
        }
      };
    }
    /**
     * Applies the {@link Core.mixin.LoadMaskable#config-loadMask} as the {@link Core.widget.Widget#config-masked mask}
     * for this widget.
     * @returns {Core.widget.Mask}
     * @internal
     */
    applyLoadMask() {
      const me = this, { loadMask } = me;
      if (loadMask) {
        me.masked = Mask.mergeConfigs(me.loadMaskDefaults, loadMask);
      }
      return me.masked;
    }
    /**
     * Updates the current {@link Core.widget.Widget#config-masked mask} for this widget to present the specified
     * `error`.
     * @param {String} error The error message to display in the mask.
     * @returns {Core.widget.Mask}
     * @internal
     */
    applyMaskError(error) {
      const { loadMaskError, masked } = this;
      if (loadMaskError === false) {
        masked.hide();
      } else if (masked) {
        ObjectHelper.assign(masked.errorDefaults, loadMaskError);
        masked.error = error;
      }
      return masked;
    }
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {
    }
  }, __publicField(_a2, "$name", "LoadMaskable"), _a2;
};

// ../Core/lib/Core/mixin/Override.js
var excludedPropNames = {
  constructor: 1,
  prototype: 1,
  name: 1,
  length: 1,
  arguments: 1,
  caller: 1,
  callee: 1,
  __proto__: 1
};
var Override = class {
  /**
   * Apply override. We strongly suggest that you at least specify a maxVersion for your overrides.
   * ```
   * class OriginalOverride {
   *     static get target() {
   *         return {
   *             class      : Original,
   *             product    : 'grid',
   *             minVersion : '1.0',
   *             maxVersion : '1.5'
   *         }
   *     }
   * }
   * ```
   * @param {Object} override An override class definition
   */
  static apply(override) {
    if (!override.target)
      throw new Error("Override must specify what it overrides, using static getter target");
    if (!override.target.class)
      throw new Error("Override must specify which class it overrides, using target.class");
    if (!this.shouldApplyOverride(override))
      return false;
    const staticKeys = Object.getOwnPropertyNames(override), instanceKeys = Object.getOwnPropertyNames(override.prototype);
    staticKeys.splice(staticKeys.indexOf("target"), 1);
    this.internalOverrideAll(override.target.class, staticKeys, override);
    this.internalOverrideAll(override.target.class.prototype, instanceKeys, override.prototype);
    return true;
  }
  static internalOverrideAll(targetClass, properties, overrideDefinition) {
    Reflect.ownKeys(overrideDefinition).forEach((key) => {
      if (properties.includes(key) && !excludedPropNames[key]) {
        const desc = Object.getOwnPropertyDescriptor(overrideDefinition, key);
        let currentTargetClass = targetClass;
        let targetProperty = null;
        while (!targetProperty && currentTargetClass) {
          targetProperty = Object.getOwnPropertyDescriptor(currentTargetClass, key);
          if (!targetProperty) {
            currentTargetClass = Object.getPrototypeOf(currentTargetClass);
          }
        }
        if (targetProperty) {
          this.internalOverride(currentTargetClass, key, desc, targetProperty);
        }
      }
    });
  }
  static internalOverride(target, key, desc, targetDesc) {
    const overrides = target._overridden = target._overridden || {};
    overrides[key] = target[key];
    if (targetDesc.get) {
      Object.defineProperty(target, key, {
        enumerable: false,
        configurable: true,
        get: desc.get
      });
    } else {
      target[key] = desc.value;
    }
  }
  /**
   * Checks versions if an override should be applied. Specify version in your overrides target config
   *
   * ```javascript
   * class OriginalOverride {
   *     static get target() {
   *         return {
   *             class      : Original,
   *             product    : 'grid',
   *             minVersion : '1.0',
   *             maxVersion : '1.5'
   *         }
   *     }
   * }
   * ```
   *
   * @param override
   * @returns {Boolean}
   * @private
   */
  static shouldApplyOverride(override) {
    const config = override.target;
    if (!config.maxVersion && !config.minVersion)
      return true;
    if (!config.product)
      throw new Error("Override must specify product when using versioning");
    if (config.maxVersion && VersionHelper[config.product].isNewerThan(config.maxVersion)) {
      return false;
    }
    if (config.minVersion && VersionHelper[config.product].isOlderThan(config.minVersion)) {
      return false;
    }
    return true;
  }
};
Override._$name = "Override";

// ../Core/lib/Core/mixin/Fencible.js
var { defineProperty: defineProperty8 } = Object;
var { hasOwn: hasOwn6 } = ObjectHelper;
var fencibleSymbol = Symbol("fencible");
var NONE = [];
var distinct = (array) => Array.from(new Set(array));
var parseNames = (names) => names ? distinct(StringHelper.split(names)) : NONE;
var fenceMethod = (target, name, options) => {
  if (options === true) {
    options = name;
  }
  if (!ObjectHelper.isObject(options)) {
    options = {
      all: options
    };
  }
  let any = parseNames(options.any);
  const all = parseNames(options.all), lock = options.lock ? parseNames(options.lock) : distinct(all.concat(any)), implName = name + "Impl", fence = function(...params) {
    const me = this, fences = hasOwn6(me, fencibleSymbol) ? me[fencibleSymbol] : me[fencibleSymbol] = {}, isFree = (key) => !fences[key];
    if (all.every(isFree) && (!any || any.some(isFree))) {
      try {
        lock.forEach((key) => fences[key] = (fences[key] || 0) + 1);
        return me[implName](...params);
      } finally {
        lock.forEach((key) => --fences[key]);
      }
    }
  };
  any = any.length ? any : null;
  !target[implName] && defineProperty8(target, implName, {
    configurable: true,
    value: target[name]
  });
  defineProperty8(target, name, {
    configurable: true,
    value: fence
  });
};
var Fencible_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    static setupFenced(cls) {
      let { fenced } = cls;
      const statics = fenced.static, pairs = [];
      if (statics) {
        fenced = { ...fenced };
        delete fenced.static;
        pairs.push([statics, cls]);
      }
      pairs.push([fenced, cls.prototype]);
      for (const [methods, target] of pairs) {
        for (const methodName in methods) {
          fenceMethod(target, methodName, methods[methodName]);
        }
      }
    }
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {
    }
  }, __publicField(_a2, "$name", "Fencible"), __publicField(_a2, "declarable", [
    /**
     * This class property returns an object that specifies methods to be wrapped to prevent reentrancy.
     *
     * It is used like so:
     * ```javascript
     *  class Foo extends Base.mixin(Fencible) {
     *      static fenced = {
     *          reentrantMethod : true
     *      };
     *
     *      reentrantMethod() {
     *          // things() may cause reentrantMethod() to be called...
     *          // but we won't be allowed to reenter this method since we are already inside it
     *          this.things();
     *      }
     *  }
     * ```
     *
     * This can also be used to protect mutually reentrant method groups:
     *
     * ```javascript
     *  class Foo extends Base.mixin(Fencible) {
     *      static fenced = {
     *          foo : 'foobar'
     *          bar : 'foobar'
     *      };
     *
     *      foo() {
     *          console.log('foo');
     *          this.bar();
     *      }
     *
     *      bar() {
     *          console.log('bar');
     *          this.foo();
     *      }
     *  }
     *
     *  instance = new Foo();
     *  instance.foo();
     *  >> foo
     *  instance.bar();
     *  >> bar
     * ```
     *
     * The value for a fenced method value can be `true`, a string, an array of strings, or a
     * {@link #typedef-MethodFence} options object.
     *
     * Internally these methods are protected by assigning a wrapper function in their place. The original function
     * is moved to a new named property by appending 'Impl' to the original name. For example, in the above code,
     * `foo` and `bar` are wrapper functions that apply reentrancy protection and call `fooImpl` and `barImpl`,
     * respectively. This is important for inheritance and `super` calling because the new name must be used in
     * order to retain the guard function implementations.
     *
     * @static
     * @member {Object} fenced
     * @internal
     */
    "fenced"
  ]), _a2;
};

// ../Core/lib/Core/util/DayTime.js
var MILLIS_PER_MINUTE = 60 * 1e3;
var MILLIS_PER_HOUR = 60 * MILLIS_PER_MINUTE;
var MILLIS_PER_DAY = 24 * MILLIS_PER_HOUR;
var timeRe = /(\d+)?:?(\d*)/;
var DayTime = class _DayTime {
  /**
   * Returns a string of "HH:MM" for a given time of day in milliseconds.
   * @param {Number} timeOfDay The time of day in milliseconds.
   * @returns {String}
   * @private
   */
  static format(timeOfDay) {
    const h = Math.floor(timeOfDay / MILLIS_PER_HOUR), m = Math.floor(timeOfDay / MILLIS_PER_MINUTE) % 60;
    return `${h}:${m < 10 ? "0" : ""}${m}`;
  }
  /**
   * Parses a time of day which may be a number (0-24 for the hour of the day) or a string in "H:MM" format and
   * returns the time of day as a number of milliseconds.
   *
   * If `time` is a `Date` instance, its time of day is returned.
   * @param {Date|Number|String} time
   * @returns {Number}
   * @private
   */
  static parse(time) {
    const type = typeof time;
    if (type === "string") {
      const match = timeRe.exec(time);
      time = Number(match[1] || 0) * MILLIS_PER_HOUR + Number(match[2] || 0) * MILLIS_PER_MINUTE;
    } else if (type !== "number") {
      time = DateHelper.getTimeOfDay(time);
    } else if (time <= 24) {
      time *= MILLIS_PER_HOUR;
    }
    return Math.min(Math.max(Math.floor(time), 0), MILLIS_PER_DAY);
  }
  constructor(config) {
    let startShift = 0, startTime, endTime;
    if (config == null ? void 0 : config.isDayView) {
      startShift = config.dayStartShift;
      startTime = config.dayStartTime;
      endTime = config.dayEndTime;
    } else if (typeof config === "number") {
      startShift = startTime = endTime = config;
    } else if (config) {
      startShift = config.startShift;
      startTime = config.timeStart;
      endTime = config.timeEnd;
    }
    this.startShift = startShift = _DayTime.parse(startShift || 0);
    this.timeEnd = (endTime == null ? (startShift + MILLIS_PER_DAY) % MILLIS_PER_DAY : _DayTime.parse(endTime)) || MILLIS_PER_DAY;
    this.timeStart = startTime == null ? startShift : _DayTime.parse(startTime);
  }
  get startHour() {
    return Math.floor(this.timeStart / MILLIS_PER_HOUR);
  }
  get endHour() {
    return Math.floor(this.timeEnd / MILLIS_PER_HOUR);
  }
  /**
   * The number of milliseconds from the day's `startShift` to its `timeStart`.
   * @member {Number}
   */
  get startTimeOffsetMs() {
    const { startShift, timeStart } = this;
    return timeStart < startShift ? MILLIS_PER_DAY - startShift + timeStart : timeStart - startShift;
  }
  /**
   * The `Date` object for the most recently started, shifted day. The time of this `Date` will be the `startShift`.
   * It is possible for this date to be yesterday on a midnight-based calendar. For example, if the `startShift` is
   * 6PM and the current time is 6AM on May 20, this value will be 6PM of May 19 (the most recently started day).
   * @member {Date}
   */
  get today() {
    return this.startOfDay(/* @__PURE__ */ new Date());
  }
  /**
   * Returns `Date` object for the nearest (shifted) day ending after the given `date`. The time of this `Date` will
   * be the `startShift`.
   *
   * It is possible for this date to be in the next day on a midnight-based calendar. For example, if the `startShift`
   * is 6PM and `date` is 7PM on May 20, this method will return 6PM of May 21 (the nearest day ending).
   * @param {Date} date The date for which to find the nearest day ending.
   * @returns {Date}
   */
  ceil(date) {
    const ret = this.startOfDay(date);
    if (ret < date) {
      ret.setDate(ret.getDate() + 1);
    }
    return ret;
  }
  /**
   * Returns `true` if the time of day for the given `date` is between `timeStart` and `timeEnd`.
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance to test.
   * @returns {Boolean}
   */
  contains(date) {
    return !this.outside(date);
  }
  /**
   * Returns a "YYYY-MM-DD" string for the given `date`. This value will match the `date` if the time of day is at or
   * after `startShift`, but will be the prior date otherwise.
   * @param {Date|Number} date The date from which to compute the 'YYYY-MM-DD' key.
   * @returns {String}
   */
  dateKey(date) {
    date = this.shiftDate(date, -1);
    return DateHelper.makeKey(date);
  }
  /**
   * Returns a `Date` instance with `startShift` as the time of day and the Y/M/D of the given `date`.
   * @param {Date} date The date's year, month, and day values.
   * @returns {Date}
   */
  dayOfDate(date) {
    return this.shiftDate(DateHelper.clearTime(date));
  }
  /**
   * Returns the day of week (0-8) for the given `date`. This value will match the `date` if the time of day is at or
   * after `startShift`, but will be the prior day otherwise.
   * @param {Date|Number} date The date from which to compute the day of week.
   * @returns {Number}
   */
  dayOfWeek(date) {
    date = this.shiftDate(date, -1);
    return date.getDay();
  }
  /**
   * Returns the difference between the time of day of the given `date` and `timeStart` in the specified time `unit`.
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance.
   * @param {String} unit The desired unit of time to return (see {@link Core.helper.DateHelper#function-as-static}).
   * @returns {Number}
   */
  delta(date, unit = "ms") {
    const { timeStart } = this, time = _DayTime.parse(date), t = (this.startShift && time < timeStart ? time + MILLIS_PER_DAY : time) - timeStart;
    return unit === "ms" ? t : DateHelper.as(unit, t, "ms");
  }
  /**
   * Returns the duration of the visible day (between `timeStart` and `timeEnd`) in the specified time `unit`.
   * @param {String} unit The desired unit of time to return (see {@link Core.helper.DateHelper#function-as-static}).
   * @returns {Number}
   */
  duration(unit = "ms") {
    const { timeStart, timeEnd } = this, millis = timeStart < timeEnd ? timeEnd - timeStart : MILLIS_PER_DAY - timeStart + timeEnd;
    return unit === "ms" ? millis : DateHelper.as(unit, millis, "ms");
  }
  /**
   * Returns `true` if this instance describes the same day as the `other`.
   * @param {Core.util.DayTime} other The other instance to which `this` instance should be tested for equality.
   * @returns {Boolean}
   */
  equals(other) {
    return this.startShift === (other == null ? void 0 : other.startShift) && this.timeStart === other.timeStart && this.timeEnd === other.timeEnd;
  }
  /**
   * Returns `true` if the times of day described by `startDate` and `endDate` intersect the visible time of this day.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  intersects(startDate, endDate) {
    const me = this, { timeStart, timeEnd } = me, [date0, date1] = me._dateRangeArgs(startDate, endDate), [start, end] = me.timeRange(date0, date1);
    if (timeStart < timeEnd) {
      if (start < end) {
        return start < timeEnd && timeStart <= end;
      }
      return start < timeEnd || timeStart <= end;
    }
    return !(start < end) || start < timeEnd || timeStart <= end;
  }
  /**
   * Returns `true` if the given date range is contained within one day.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  isIntraDay(startDate, endDate) {
    const me = this, [date0, date1] = me._dateRangeArgs(startDate, endDate), dayStart = me.startOfDay(date0), diff = MILLIS_PER_DAY - DateHelper.diff(dayStart, date1, "ms");
    if (diff < 0) {
      return false;
    }
    return diff > 0 || dayStart < date0;
  }
  /**
   * Returns `true` if the given date range or event crosses the day boundary.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Boolean}
   */
  isInterDay(timeSpan) {
    return timeSpan.allDay || !this.isIntraDay(...arguments);
  }
  /**
   * Returns -1, 0, or 1 based on whether the time of day for the given `date` is before `timeStart` (-1), or after
   * `timeEnd` (1), or between these times (0).
   * @param {Date|Number|String} date The hour number, 'HH:MM' time or a `Date` instance to test.
   * @returns {Number}
   */
  outside(date) {
    const { startShift, timeStart, timeEnd } = this, time = _DayTime.parse(date);
    if (timeStart < timeEnd) {
      if (time < timeStart) {
        return time < startShift ? 1 : -1;
      }
      if (time < timeEnd) {
        return 0;
      }
      return time < startShift ? -1 : 1;
    }
    if (time < timeEnd || time >= timeStart) {
      return 0;
    }
    return time < startShift ? 1 : -1;
  }
  parseKey(key) {
    return this.dayOfDate(DateHelper.parseKey(key));
  }
  /**
   * Returns the given `date` shifted forward (`direction` > 0) or backward (`direction` < 0) by the `startShift`.
   * @param {Number|Date} date The date as a `Date` or the millisecond UTC epoch.
   * @param {Number} direction A value > 0 to shift `date` forward, or < 0 to shift it backwards.
   * @returns {Date}
   */
  shiftDate(date, direction = 1) {
    const { startShift } = this, type = typeof date;
    date = type === "number" ? new Date(date) : type === "string" ? DateHelper.parse(date) : new Date(date.getTime());
    if (direction && startShift) {
      date.setMilliseconds(direction > 0 ? startShift : -startShift);
    }
    return date;
  }
  /**
   * Sorts the given set of `events` by the maximum of `startDate` and `startOfDay` for the given `date`, followed
   * by `duration` in case of a tie.
   * @param {Date} date The day for which events are to be sorted.
   * @param {Object[]} events The events to sort, typically an `Scheduler.model.EventModel[]` but any objects with
   * both `startDate` and `endDate` fields are acceptable.
   * @returns {Object[]} The passed `events` array.
   * @internal
   */
  sortEvents(date, events) {
    const startOfDay = this.startOfDay(date);
    return events == null ? void 0 : events.sort((event1, event2) => {
      event1 = event1.eventRecord || event1;
      event2 = event2.eventRecord || event2;
      let { startDate: start1 } = event1, { startDate: start2 } = event2;
      if (!start1) {
        return -1;
      }
      if (!start2) {
        return 1;
      }
      start1 = start1 < startOfDay ? startOfDay : start1;
      start2 = start2 < startOfDay ? startOfDay : start2;
      return start1 - start2 || event2.endDate - start2 - (event1.endDate - start1);
    });
  }
  /**
   * Returns `Date` object for the nearest started (shifted) day prior to the given `date`. The time of this `Date`
   * will be the `startShift`.
   *
   * It is possible for this date to be in the prior day on a midnight-based calendar. For example, if the `startShift`
   * is 6PM and `date` is 6AM on May 20, this method will return 6PM of May 19 (the nearest started day).
   * @param {Date} date The date for which to find the nearest started day.
   * @returns {Date}
   */
  startOfDay(date) {
    date = this.shiftDate(date, -1);
    date = DateHelper.clearTime(date);
    date = this.shiftDate(date);
    return date;
  }
  /**
   * Returns a range of {@link Core.helper.DateHelper#function-getTimeOfDay-static times of day} for the given
   * date range.
   * @param {Date} startDate The start date of the date range or an event record containing both `startDate` and `endDate` fields
   * @param {Date} [endDate] The end date if `startDate` is not an event record
   * @returns {Number[]}
   */
  timeRange(startDate, endDate) {
    const [start, end] = this._dateRangeArgs(startDate, endDate);
    return [DateHelper.getTimeOfDay(start), DateHelper.getTimeOfDay(end)];
  }
  toString() {
    const { startShift, timeEnd, timeStart } = this, suffix = startShift ? `@${_DayTime.format(startShift)}` : "", prefix = _DayTime.format(timeStart);
    if (timeStart === timeEnd) {
      return startShift ? suffix : prefix;
    }
    return `${prefix}-${_DayTime.format(timeEnd)}${suffix}`;
  }
  /**
   * Decodes the arguments and returns a pair of `Date` objects for the start and end of the date range.
   * @param {Date} startDate The start date of the date range or an event record containing both startDate and endDate
   * fields.
   * @param {Date} [endDate] The end date if `startDate` is not an event record.
   * @returns {Date[]}
   * @private
   */
  _dateRangeArgs(startDate, endDate) {
    return startDate.isModel ? [startDate.startDate, startDate.endingDate] : [startDate, endDate];
  }
};
DayTime.MIDNIGHT = new DayTime({
  startShift: 0,
  timeStart: 0,
  timeEnd: 24
});
DayTime.MILLIS_PER_MINUTE = MILLIS_PER_MINUTE;
DayTime.MILLIS_PER_HOUR = MILLIS_PER_HOUR;
DayTime.MILLIS_PER_DAY = MILLIS_PER_DAY;
DayTime._$name = "DayTime";

// ../Core/lib/Core/util/Month.js
var _Month = class _Month extends Events_default(Base) {
  static get configurable() {
    return {
      /**
       * The date which the month should encapsulate. May be a `Date` object, or a
       * `YYYY-MM-DD` format string.
       *
       * Mutating a passed `Date` after initializing a `Month` object has no effect on
       * the `Month` object.
       * @config {Date|String}
       */
      date: {
        $config: {
          equal: "date"
        },
        value: DateHelper.clearTime(/* @__PURE__ */ new Date())
      },
      month: null,
      year: null,
      /**
       * The week start day, 0 meaning Sunday, 6 meaning Saturday.
       * Defaults to {@link Core.helper.DateHelper#property-weekStartDay-static}.
       * @config {Number}
       */
      weekStartDay: null,
      /**
       * Configure as `true` to have the visibleDayColumnIndex and visibleColumnCount properties
       * respect the configured {@link #config-nonWorkingDays}.
       * @config {Boolean}
       */
      hideNonWorkingDays: null,
      /**
       * Non-working days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
       * Defaults to {@link Core.helper.DateHelper#property-nonWorkingDays-static}.
       * @config {Object<String,Boolean>}
       */
      nonWorkingDays: null,
      /**
       * Configure as `true` to always have the month encapsulate six weeks.
       * This is useful for UIs which must be a fixed height.
       * @prp {Boolean}
       */
      sixWeeks: null
    };
  }
  //region events
  /**
   * Fired when setting the {@link #config-date} property causes the encapsulated date to change
   * in **any** way, date, week, month or year.
   * @event dateChange
   * @param {Core.util.Month} source The Month which triggered the event.
   * @param {Date} newDate The new encapsulated date value.
   * @param {Date} oldDate The previous encapsulated date value.
   * @param {Number} changes An object which contains properties which indicate what part of the date changed.
   * @param {Boolean} changes.d True if the date changed in any way.
   * @param {Boolean} changes.w True if the week changed (including same week in a different year).
   * @param {Boolean} changes.m True if the month changed (including same month in a different year).
   * @param {Boolean} changes.y True if the year changed.
   * @param {Boolean} changes.r True if the row count (with respect to the {@link #config-sixWeeks} setting) changed.
   */
  /**
   * Fired when setting the {@link #config-date} property causes a change of week. Note that
   * weeks are calculated in the ISO standard form such that if there are fewer than four
   * days in the first week of a year, then that week is owned by the previous year.
   *
   * The {@link #config-weekStartDay} is honoured when making this calculation and this is a
   * locale-specific value which defaults to the ISO standard of 1 (Monday) in provided European
   * locales and 0 (Sunday) in the provided US English locale.
   * @event weekChange
   * @param {Core.util.Month} source The Month which triggered the event.
   * @param {Date} newDate The new encapsulated date value.
   * @param {Date} oldDate The previous encapsulated date value.
   * @param {Number} changes An object which contains properties which indicate what part of the date changed.
   * @param {Boolean} changes.d True if the date changed in any way.
   * @param {Boolean} changes.w True if the week changed (including same week in a different year).
   * @param {Boolean} changes.m True if the month changed (including same month in a different year).
   * @param {Boolean} changes.y True if the year changed.
   * @param {Boolean} changes.r True if the row count (with respect to the {@link #config-sixWeeks} setting) changed.
   */
  /**
   * Fired when setting the {@link #config-date} property causes a change of month. This
   * will fire when changing to the same month in a different year.
   * @event monthChange
   * @param {Core.util.Month} source The Month which triggered the event.
   * @param {Date} newDate The new encapsulated date value.
   * @param {Date} oldDate The previous encapsulated date value.
   * @param {Number} changes An object which contains properties which indicate what part of the date changed.
   * @param {Boolean} changes.d True if the date changed in any way.
   * @param {Boolean} changes.w True if the week changed (including same week in a different year).
   * @param {Boolean} changes.m True if the month changed (including same month in a different year).
   * @param {Boolean} changes.y True if the year changed.
   * @param {Boolean} changes.r True if the row count (with respect to the {@link #config-sixWeeks} setting) changed.
   */
  /**
   * Fired when setting the {@link #config-date} property causes a change of year.
   * @event yearChange
   * @param {Core.util.Month} source The Month which triggered the event.
   * @param {Date} newDate The new encapsulated date value.
   * @param {Date} oldDate The previous encapsulated date value.
   * @param {Number} changes An object which contains properties which indicate what part of the date changed.
   * @param {Boolean} changes.d True if the date changed in any way.
   * @param {Boolean} changes.w True if the week changed (including same week in a different year).
   * @param {Boolean} changes.m True if the month changed (including same month in a different year).
   * @param {Boolean} changes.y True if the year changed.
   * @param {Boolean} changes.r True if the row count (with respect to the {@link #config-sixWeeks} setting) changed.
   */
  //endRegion
  /**
   * For use when this Month's `weekStartDay` is non-zero.
   *
   * An array to map the days of the week 0-6 of this Calendar to the canonical day numbers
   * used by the Javascript [Date](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date) object.
   * @member {Number[]} canonicalDayNumbers
   * @readonly
   */
  /**
   * An array to map a canonical day number to a *visible* column index.
   * For example, if we have `weekStartDay` as Monday which is 1, and non working days as
   * Wednesday, and `hideNonWorkingDays : true`, then the calendar would look like
   *
   *```
   * 
   * | Mo | Tu | Th | Fr | Sa | Su |
   * 
   *```
   *
   * So we'd need this array: `[ 5, 0, 1, undefined, 2, 3, 4]`
   * @member {Number[]} visibleDayColumnIndex
   * @readonly
   */
  /**
   * An array to map a canonical day number to a 0-6 column index.
   * For example, if we have `weekStartDay` as Monday which is 1, then the calendar would look like
   *
   *```
   * 
   * | Mo | Tu | We | Th | Fr | Sa | Su |
   * 
   *```
   *
   * So we'd need this array: `[ 6, 0, 1, 2, 3, 4, 5]`
   * @member {Number[]} dayColumnIndex
   * @readonly
   */
  /**
   * The number of visible days in the week as defined by the `nonWorkingDays` and
   * `hideNonWorkingDays` options.
   * @member {Number} weekLength
   * @readonly
   */
  configure(config) {
    super.configure(config);
    this.updateDayNumbers();
    if (config.date) {
      this.date = config.date;
    }
    this.generation = 0;
  }
  changeDate(date) {
    if (this.isConfiguring) {
      return;
    }
    date = typeof date === "string" ? DateHelper.parse(date, "YYYY-MM-DD") : new Date(date);
    if (isNaN(date)) {
      throw new Error("Month date ingestion must be passed a Date, or a valid YYYY-MM-DD date string");
    }
    return date;
  }
  updateDate(newDate, oldDate) {
    const me = this, {
      dayColumnIndex,
      weekCount
    } = me, monthStart = DateHelper.getFirstDateOfMonth(newDate), monthEnd = DateHelper.getLastDateOfMonth(monthStart), startWeekDay = dayColumnIndex[monthStart.getDay()], endWeekDay = dayColumnIndex[monthEnd.getDay()], yearChanged = !oldDate || newDate.getFullYear() !== oldDate.getFullYear(), monthChanged = !oldDate || newDate.getMonth() !== oldDate.getMonth(), changes = me.eventListeners && (oldDate ? newDate.getDate() !== oldDate.getDate() | (me.getWeekId(newDate) !== me.getWeekId(oldDate)) << 1 | monthChanged << 2 | yearChanged << 3 : 15);
    me._year = newDate.getFullYear();
    me._month = newDate.getMonth();
    me.startDayOfMonth = 1 - startWeekDay;
    me.endDayOfMonth = monthEnd.getDate() + (6 - endWeekDay);
    if (me.sixWeeks) {
      me.endDayOfMonth += (6 - me.weekCount) * 7;
    }
    if (!me.weekBase || yearChanged) {
      me.calculateWeekBase();
    }
    if (monthChanged || yearChanged) {
      me.generation++;
    }
    if (changes) {
      const event = {
        newDate,
        oldDate,
        changes: {
          d: true,
          w: Boolean(changes & 2),
          m: Boolean(changes & 12),
          y: Boolean(changes & 8),
          r: me.weekCount !== weekCount
        }
      };
      me.trigger("dateChange", event);
      if (changes & 2) {
        me.trigger("weekChange", event);
      }
      if (changes & 12) {
        me.trigger("monthChange", event);
      }
      if (changes & 8) {
        me.trigger("yearChange", event);
      }
    }
  }
  calculateWeekBase() {
    const me = this, {
      dayColumnIndex
    } = me, jan1 = new Date(me.year, 0, 1), dec31 = new Date(me.year, 11, 31), january = me.month ? me.getOtherMonth(jan1) : me;
    if (me.dayColumnIndex[jan1.getDay()] > 3) {
      me.weekBase = january.startDate;
    } else {
      me.weekBase = new Date(me.year, 0, january.startDayOfMonth - 7);
    }
    const dec31Week = Math.floor(DateHelper.diff(me.weekBase, dec31, "day") / 7);
    me.has53weeks = dec31Week === 53 && dayColumnIndex[dec31.getDay()] > 2;
  }
  /**
   * Returns the week start date, based on the configured {@link #config-weekStartDay} of the
   * passed week.
   * @param {Number| Number[]} week The week number in the current year, or an array containing
   * `[year, weekOfYear]` for any year.
   *
   * Week numbers greater than the number of weeks in the year just wrap into the following year.
   */
  getWeekStart(week) {
    if (typeof week === "number") {
      return DateHelper.add(this.weekBase, Math.max(week, 1) * 7, "day");
    }
    const me = this, [year, weekOfYear] = week;
    if (year === me.year) {
      return me.getWeekStart(weekOfYear);
    }
    return me.getOtherMonth(new Date(year, 0, 1)).getWeekStart(weekOfYear);
  }
  getOtherMonth(date) {
    const me = this, result = me === otherMonth ? new _Month(null) : otherMonth;
    result.configure({
      weekBase: null,
      weekStartDay: me.weekStartDay,
      nonWorkingDays: me.nonWorkingDays,
      hideNonWorkingDays: me.hideNonWorkingDays,
      sixWeeks: me.sixWeeks,
      date: new Date(date.getFullYear(), 0, 1)
      // Make it easy to calculate its own weekBase
    });
    result.date = date;
    result.updateDate(result.date, result.date);
    return result;
  }
  changeYear(year) {
    const newDate = new Date(this.date);
    newDate.setFullYear(year);
    this.date = newDate;
  }
  changeMonth(month2) {
    const newDate = new Date(this.date);
    newDate.setMonth(month2);
    this.date = newDate;
  }
  get weekStartDay() {
    return typeof this._weekStartDay === "number" ? this._weekStartDay : DateHelper.weekStartDay;
  }
  updateWeekStartDay() {
    const me = this;
    me.updateDayNumbers();
    if (!me.isConfiguring && me.date) {
      me.weekBase = null;
      me.updateDate(me.date, me.date);
    }
  }
  get nonWorkingDays() {
    return this._nonWorkingDays || DateHelper.nonWorkingDays;
  }
  changeNonWorkingDays(nonWorkingDays) {
    return ObjectHelper.assign({}, nonWorkingDays);
  }
  updateNonWorkingDays() {
    this.updateDayNumbers();
  }
  updateHideNonWorkingDays() {
    this.updateDayNumbers();
  }
  updateSixWeeks() {
    if (!this.isConfiguring) {
      this.updateDate(this.date, this.date);
    }
  }
  /**
   * The number of days in the calendar for this month. This will always be
   * a multiple of 7, because this represents the number of calendar cells
   * occupied by this month.
   * @property {Number}
   * @readonly
   */
  get dayCount() {
    return this.endDayOfMonth + 1 - this.startDayOfMonth;
  }
  /**
   * The number of weeks in the calendar for this month.
   * @property {Number}
   * @readonly
   */
  get weekCount() {
    return this.dayCount / 7;
  }
  /**
   * The date of the first cell in the calendar view of this month.
   * @property {Date}
   * @readonly
   */
  get startDate() {
    const me = this;
    if (me.year != null && me.month != null && me.startDayOfMonth != null) {
      return new Date(me.year, me.month, me.startDayOfMonth);
    }
  }
  /**
   * The date of the last cell in the calendar view of this month.
   * @property {Date}
   * @readonly
   */
  get endDate() {
    const me = this;
    if (me.year != null && me.month != null && me.startDayOfMonth != null) {
      return new Date(me.year, me.month, me.endDayOfMonth);
    }
  }
  /**
   * Iterates through all calendar cells in this month, calling the passed function for each date.
   * @param {Function} fn The function to call.
   * @param {Date} fn.date The date for the cell.
   */
  eachDay(fn2) {
    for (let dayOfMonth = this.startDayOfMonth; dayOfMonth <= this.endDayOfMonth; dayOfMonth++) {
      fn2(new Date(this.year, this.month, dayOfMonth));
    }
  }
  /**
   * Iterates through all weeks in this month, calling the passed function
   * for each week.
   * @param {Function} fn The function to call.
   * @param {Number[]} fn.week An array containing `[year, weekNumber]`
   * @param {Date[]} fn.dates The dates for the week.
   */
  eachWeek(fn2) {
    const me = this, { weekCount } = me;
    for (let dayOfMonth = me.startDayOfMonth, week = 0; week < weekCount; week++) {
      const weekDates = [], weekOfYear = me.getWeekNumber(new Date(me.year, me.month, dayOfMonth));
      for (let day2 = 0; day2 < 7; day2++, dayOfMonth++) {
        weekDates.push(new Date(me.year, me.month, dayOfMonth));
      }
      fn2(weekOfYear, weekDates);
    }
  }
  /**
   * Returns the week of the year for the passed date. This returns an array containing *two* values,
   * the year **and** the week number are returned.
   *
   * The week number is calculated according to ISO rules, meaning that if the first week of the year
   * contains less than four days, it is considered to be the last week of the preceding year.
   *
   * The configured {@link #config-weekStartDay} is honoured in this calculation. So if the weekStartDay
   * is **NOT** the ISO standard of `1`, (Monday), then the weeks do not coincide with ISO weeks.
   * @param {Date} date The date to calculate the week for.
   * @returns {Number[]} A numeric array: `[year, week]`
   */
  getWeekNumber(date) {
    const me = this;
    date = DateHelper.clearTime(date);
    if (date.getFullYear() !== me.year) {
      return me.getOtherMonth(new Date(date.getFullYear(), 0, 1)).getWeekNumber(date);
    }
    let weekNo = Math.floor(DateHelper.diff(me.weekBase, date, "day") / 7), year = date.getFullYear();
    if (!weekNo) {
      return me.getOtherMonth(new Date(me.year - 1, 0, 1)).getWeekNumber(new Date(me.year, 0, 0));
    } else if (weekNo === 53 && !me.has53weeks) {
      weekNo = 1;
      year++;
    } else if (weekNo > 53) {
      weekNo = weekNo % 52;
    }
    return [year, weekNo];
  }
  getWeekId(date) {
    const week = this.getWeekNumber(date);
    return week[0] * 100 + week[1];
  }
  getCellData(date, ownerMonth, dayTime = DayTime.MIDNIGHT) {
    const me = this, day2 = date.getDay(), visibleColumnIndex = me.visibleDayColumnIndex[day2], isNonWorking = me.nonWorkingDays[day2], isHiddenDay = me.hideNonWorkingDays && isNonWorking;
    if (date < me.startDate || date > me.endDate) {
      me.month = date.getMonth();
    }
    return {
      day: day2,
      dayTime,
      visibleColumnIndex,
      isNonWorking,
      week: me.getOtherMonth(date).getWeekNumber(date),
      key: DateHelper.format(date, "YYYY-MM-DD"),
      columnIndex: me.dayColumnIndex[day2],
      date: new Date(date),
      dayEnd: dayTime.duration("s"),
      tomorrow: dayTime.dayOfDate(DateHelper.add(date, 1, "day")),
      // These two properties are only significant when used by a CalendarPanel which encapsulates
      // a single month.
      isOtherMonth: Math.sign(date.getMonth() + date.getFullYear() * 12 - (ownerMonth.month + ownerMonth.year * 12)),
      visible: !isHiddenDay && (date >= ownerMonth.startDate && date < DateHelper.add(ownerMonth.endDate, 1, "day")),
      isRowStart: visibleColumnIndex === 0,
      isRowEnd: visibleColumnIndex === me.visibleColumnCount - 1
    };
  }
  updateDayNumbers() {
    const me = this, {
      weekStartDay,
      nonWorkingDays,
      hideNonWorkingDays
    } = me, dayColumnIndex = me.dayColumnIndex = [], canonicalDayNumbers = me.canonicalDayNumbers = [], visibleDayColumnIndex = me.visibleDayColumnIndex = [];
    let visibleColumnIndex = 0;
    for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
      const canonicalDay = (weekStartDay + columnIndex) % 7;
      canonicalDayNumbers[columnIndex] = canonicalDay;
      dayColumnIndex[canonicalDay] = columnIndex;
      if (!hideNonWorkingDays || !nonWorkingDays[canonicalDay]) {
        visibleDayColumnIndex[canonicalDay] = visibleColumnIndex++;
      }
    }
    me.visibleColumnCount = visibleColumnIndex;
    me.weekLength = hideNonWorkingDays ? 7 - ObjectHelper.keys(nonWorkingDays).length : 7;
  }
};
__publicField(_Month, "$name", "Month");
var Month = _Month;
var otherMonth = new Month(null);
Month._$name = "Month";

// ../Core/lib/Core/util/Parser.js
var nextObjectIdentity = 0;
var objectIdentityMap = /* @__PURE__ */ new WeakMap();
var argsToCacheKey = (...args) => args.map((arg) => {
  let result;
  if (arg && typeof arg == "object" || typeof arg == "function") {
    result = objectIdentityMap.get(arg);
    if (result === void 0) {
      result = ++nextObjectIdentity;
      objectIdentityMap.set(arg, result);
    }
  } else {
    result = String(arg);
  }
  return result;
}).join("-");
var memo = (fn2) => {
  const mlist = /* @__PURE__ */ new Map();
  return (...args) => {
    const mkey = argsToCacheKey(args);
    let result = mlist.get(mkey);
    if (result === void 0) {
      result = fn2(...args);
      mlist.set(mkey, result);
    }
    return result;
  };
};
var memoCps = (fn2) => {
  const table = /* @__PURE__ */ new Map(), entryContinuations = (entry) => entry[0], entryResults = (entry) => entry[1], pushContinuation = (entry, cont) => entryContinuations(entry).push(cont), pushResult = (entry, result) => entryResults(entry).push(result), isResultSubsumed = (entry, result) => entryResults(entry).some((r) => ObjectHelper.isEqual(r, result)), makeEntry = () => [[], []], isEmptyEntry = (entry) => !entryResults(entry).length && !entryContinuations(entry).length, tableRef = (str) => {
    let entry = table.get(str);
    if (entry === void 0) {
      entry = makeEntry();
      table.set(str, entry);
    }
    return entry;
  };
  return (str, cont) => {
    const entry = tableRef(str);
    if (isEmptyEntry(entry)) {
      pushContinuation(entry, cont);
      fn2(str, (result) => {
        if (!isResultSubsumed(entry, result)) {
          pushResult(entry, result);
          entryContinuations(entry).forEach((cont2) => cont2(result));
        }
      });
    } else {
      pushContinuation(entry, cont);
      entryResults(entry).forEach((result) => cont(result));
    }
  };
};
var SUCCESS = Symbol("success");
var FAILURE = Symbol("failure");
var success = (val, rest) => [SUCCESS, val, rest];
var failure = (rest) => [FAILURE, rest];
var isSuccess = (result) => result.length && result[0] === SUCCESS;
var resolveParser = (p) => typeof p === "function" && !p.length ? p() : p;
var succeed = memo(
  (val) => memoCps(
    (str, cont) => cont(success(val, str))
  )
);
var string = memo(
  (match) => memoCps(
    (str, cont) => {
      const len = Math.min(match.length, str.length), head = str.substr(0, len), tail = str.substr(len);
      cont(head === match ? success(head, tail) : failure(tail));
    }
  )
);
var bind = (p, fn2) => (str, cont) => resolveParser(p)(str, (result) => {
  if (isSuccess(result)) {
    const [, val, rest] = result;
    fn2(val)(rest, cont);
  } else {
    cont(result);
  }
});
var seq = memo(
  (...parsers2) => {
    const seq2 = memo(
      (a, b) => memoCps(
        bind(
          a,
          (x) => bind(
            b,
            (y) => succeed([].concat(x, y))
          )
        )
      )
    );
    return parsers2.reduce(seq2, succeed([]));
  }
);
var alt = memo(
  (...parsers2) => memoCps(
    (str, cont) => parsers2.forEach((p) => resolveParser(p)(str, cont))
  )
);
var regexp = memo(
  (pattern) => (str, cont) => {
    const rexp = new RegExp(`^${pattern}`), match = rexp.exec(str);
    if (match) {
      const head = match[0], tail = str.substr(head.length);
      cont(success(head, tail));
    } else {
      cont(failure(str));
    }
  }
);
var red = memo(
  (p, fn2) => bind(
    p,
    (...val) => succeed(fn2(...[].concat.apply([], val)))
  )
);
var runParser = (body, str) => {
  const results = [];
  body(str, (result) => {
    if (isSuccess(result)) {
      const [, , left] = result;
      if (left === "") {
        results.push(result);
      }
    }
  });
  return results;
};
var defineParser = (body) => (str, cont) => cont ? resolveParser(body)(str, cont) : runParser(resolveParser(body), str);
var Parser_default = {
  memo,
  memoCps,
  success,
  failure,
  isSuccess,
  resolveParser,
  succeed,
  string,
  bind,
  seq,
  alt,
  regexp,
  red,
  runParser,
  defineParser
};

// ../Core/lib/Core/util/ScrollManager.js
var ScrollManager = class extends Delayable_default(Base) {
  //region Default config
  static get configurable() {
    return {
      /**
       * Default element to use for scrolling. Can be overridden in calls to `startMonitoring()`.
       * @config {HTMLElement}
       */
      element: null,
      /**
       * Width in pixels of the area at the edges of an element where scrolling should be triggered
       * @config {Number}
       * @default
       */
      zoneWidth: 50,
      /**
       * Scroll speed, higher number is slower. Calculated as "distance from zone edge / scrollSpeed"
       * @config {Number}
       * @default
       */
      scrollSpeed: 5,
      /**
       * The direction(s) to scroll ('horizontal', 'vertical' or 'both')
       * @config {'horizontal'|'vertical'|'both'}
       * @default
       */
      direction: "both",
      /**
       * Number of milliseconds to wait before scroll starts when the mouse is moved close to an edge monitored by this scroll manager
       * @config {Number}
       * @default
       */
      startScrollDelay: 500,
      /**
       * Set to true to stop scrolling when pointing device leaves the scrollable element.
       * @config {Boolean}
       * @default
       */
      // https://github.com/bryntum/support/issues/394
      stopScrollWhenPointerOut: false,
      testConfig: {
        scrollSpeed: 2,
        startScrollDelay: 100
      },
      activeScroll: {
        $config: ["lazy"],
        value: {}
      },
      monitoring: {
        $config: ["lazy", "nullify"],
        value: true
      },
      owner: null
    };
  }
  changeMonitoring(value, was) {
    was == null ? void 0 : was.clear();
    return /* @__PURE__ */ new Map();
  }
  //endregion
  doDestroy() {
    this.stopMonitoring();
    super.doDestroy();
  }
  /**
   * Returns true if some of the monitored elements is being scrolled at the moment.
   * @property {Boolean}
   * @readonly
   */
  get isScrolling() {
    return Object.keys(this.activeScroll).length !== 0;
  }
  get rtl() {
    var _a2;
    return (_a2 = this.owner) == null ? void 0 : _a2.rtl;
  }
  //region Start/stop monitoring
  /**
   * Starts monitoring an element. It will be scrolled if mouse is pressed and within `zoneWidth` pixels from element
   * edge. Supports monitoring multiple elements using `scrollables` option:
   *
   * ```javascript
   * new ScrollManager({ element : '.item' }).startMonitoring({
   *     scrollables : [
   *         {
   *             // Applies config to all elements matching `.item .child-item`
   *             // selector
   *             element : '.child-item',
   *             // Only manage vertical scroll
   *             direction : 'vertical',
   *             // Specific callback for this scrollable. Shared callback is
   *             // ignored.
   *             callback : () => console.log('Specific callback')
   *         },
   *         {
   *             // Instance can be used
   *             element : document.querySelector('.item .child2')
   *             // Direction and callback are not provided, so element will
   *             // be scrollable in horizontal direction and will use shared
   *             // callback
   *         }
   *     ],
   *     direction : 'horizontal',
   *     callback  : () => console.log('Shared callback')
   * })
   * ```
   *
   * @param {Object} config Element which might be scrolled or config { element, callback, thisObj }
   * @param {'horizontal'|'vertical'|'both'} [config.direction] Direction to scroll. Overrides default scroll direction
   * @param {Function} [config.callback] Callback to execute on every scroll of the target element.
   *
   * ```javascript
   * startMonitoring({
   *     callback(monitor) {
   *         // Current left and top scroll of the monitored element
   *         console.log(monitor.scrollLeft)
   *         console.log(monitor.scrollTop)
   *         // Scroll position relative to the initial position
   *         console.log(monitor.relativeScrollLeft)
   *         console.log(monitor.relativeScrollTop)
   *     }
   * })
   * ```
   *
   * @param {Object} [config.thisObj] Scope for the callback.
   * @param {Object[]} [config.scrollables] Array of configs if multiple elements should be monitored.
   * @param {HTMLElement|String} [config.scrollables.0.element] Element or selector.
   * @param {'horizontal'|'vertical'|'both'} [config.scrollables.0.direction] Direction to scroll. Overrides upper config object direction.
   * @param {Function} [config.scrollables.0.callback] Callback to execute on every scroll of the target element.
   * Overrides upper config object callback.
   * @returns {Function} Returns function to cleanup instantiated monitors
   * ```javascript
   * const detacher = new ScrollManager({ element }).startMonitoring({ ... });
   * detacher(); // All monitors setup by the previous call are removed
   * ```
   */
  startMonitoring(config = {}) {
    const me = this, {
      element,
      direction: defaultDirection
    } = me, {
      scrollables = [],
      direction = defaultDirection,
      callback
    } = config, attachedElements = [];
    if (!scrollables.length) {
      scrollables.push({ element });
    }
    scrollables.forEach((scrollable) => {
      const target = scrollable.element;
      if (typeof target === "string") {
        DomHelper.forEachSelector(element, target, (element2) => {
          me.createMonitor(element2, scrollable.direction || direction, scrollable.callback || callback);
          attachedElements.push(element2);
        });
      } else {
        me.createMonitor(target, scrollable.direction || direction, scrollable.callback || callback);
        attachedElements.push(target);
      }
    });
    return function detacher2() {
      var _a2;
      (_a2 = me.stopMonitoring) == null ? void 0 : _a2.call(me, attachedElements);
    };
  }
  createMonitor(element, direction, callback) {
    const { monitoring } = this;
    if (!monitoring.has(element)) {
      monitoring.set(element, new ScrollManagerMonitor({
        scrollManager: this,
        element,
        direction,
        callback
      }));
    }
  }
  /**
   * Stops monitoring an element. If no particular element is given, stop monitoring everything.
   * @param {HTMLElement|HTMLElement[]} [element] Element or array of elements for which monitoring is not desired any
   * more and should stop as soon as possible.
   */
  stopMonitoring(element) {
    const me = this, { monitoring } = me;
    element = ArrayHelper.asArray(element);
    if (monitoring) {
      if (!element) {
        monitoring.forEach((monitor) => me.stopMonitoring(monitor.element));
        return;
      }
      element.forEach((element2) => {
        const monitor = monitoring.get(element2);
        element2.classList.remove("b-scrolling");
        if (monitor) {
          monitor.destroy();
          monitoring.delete(element2);
        }
      });
    }
  }
  //endregion
  /*
   * Attempts to reserve given scrolling direction for the given monitor.
   * @param {String} direction 'horizontal' or 'vertical'
   * @param {Object} monitor
   * @returns {Boolean} Returns true in case scroll direction was reserved for given monitor. False otherwise.
   * @private
   */
  requestScroll(direction, monitor) {
    const { activeScroll } = this;
    if (direction in activeScroll && activeScroll[direction] !== monitor) {
      return false;
    } else {
      activeScroll[direction] = monitor;
      return true;
    }
  }
  /*
   * Releases all scroll directions, blocked by given monitor
   * @param {Object} monitor
   * @private
   */
  releaseScroll(monitor) {
    const { activeScroll = {} } = this;
    Object.keys(activeScroll).forEach((key) => {
      if (activeScroll[key] === monitor) {
        delete activeScroll[key];
      }
    });
  }
  //#region Scroll position
  getRelativeScroll(element, direction = "left") {
    let result = 0;
    this.monitoring.forEach((monitor, monitoredElement) => {
      if (DomHelper.isDescendant(monitoredElement, element)) {
        result += direction === "left" ? monitor.scrollRelativeLeft : monitor.scrollRelativeTop;
      }
    });
    return result;
  }
  //#endregion
};
var ScrollManagerMonitor = class extends Base {
  construct(config) {
    const me = this, { element } = config, startScrollLeft = element.scrollLeft, startScrollTop = element.scrollTop;
    Object.assign(config, { startScrollLeft, startScrollTop });
    super.construct(config);
    EventHelper.on({
      element,
      scroll: "onElementScroll",
      pointermove: "onMouseMove",
      // Capture pointermove events early to start scrolling from top elements
      capture: true,
      thisObj: me
    });
    EventHelper.on({
      element,
      pointerleave: "onPointerLeave",
      thisObj: me
    });
  }
  doDestroy() {
    this.stopScroll();
    super.doDestroy();
  }
  /**
   * Starts scrolling (see #performScroll). Called from onMouseMove.
   * @private
   */
  startScroll() {
    const me = this;
    if (me.pendingScrollFinalize) {
      me.scrollManager.releaseScroll(me);
      me.pendingScrollFinalize = false;
    }
    me.scrolling = true;
    me.performScroll();
  }
  /**
   * Stops scrolling. Called from onMouseMove.
   * @private
   */
  stopScroll(force = null) {
    const me = this, finalize = () => {
      me.pendingScrollFinalize = false;
      if (!me.isDestroyed) {
        me.scrollManager.releaseScroll(me);
        me.scrolling = false;
      }
    };
    if (me.scrollRequested) {
      me.scrollManager.cancelAnimationFrame(me.frameId);
      me.scrollRequested = false;
    }
    me.scrollManager.clearTimeout(me.scrollTimeout);
    me.scrollTimeout = null;
    if (!force && (me.ongoingScrollTop || me.ongoingScrollLeft)) {
      me.pendingScrollFinalize = true;
      Promise.all([me.ongoingScrollTop, me.ongoingScrollLeft].filter(Boolean)).then(() => me.pendingScrollFinalize && finalize());
    } else {
      me.ongoingScrollTop = me.ongoingScrollLeft = null;
      finalize();
    }
  }
  onPointerLeave() {
    this.scrollManager.stopScrollWhenPointerOut && this.stopScroll();
  }
  /**
   * Listener for mouse move on monitored element. Determines if scrolling is needed, and if so how fast to scroll.
   * See #zoneWidth & #scrollSpeed configs.
   * @private
   * @param {MouseEvent} event
   */
  onMouseMove(event) {
    const me = this, {
      scrollManager
    } = me, box = me.element.getBoundingClientRect(), width = scrollManager.zoneWidth, speed = scrollManager.scrollSpeed;
    me.scrollDeltaX = me.scrollDeltaY = 0;
    if (me.direction !== "vertical") {
      const { scrollLeft, scrollWidth, clientWidth } = me.element;
      if (scrollManager.rtl) {
        if (event.clientX < box.left + width && scrollWidth + scrollLeft - clientWidth >= 1) {
          me.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
        } else if (event.clientX > box.right - width && scrollLeft < 0) {
          me.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
        }
      } else {
        if (event.clientX > box.right - width && scrollWidth - scrollLeft - clientWidth >= 1) {
          me.scrollDeltaX = Math.round((width - (box.right - event.clientX)) / speed) + 1;
        } else if (event.clientX < box.left + width && scrollLeft > 0) {
          me.scrollDeltaX = -Math.round((width + (box.left - event.clientX)) / speed) - 1;
        }
      }
    }
    if (me.direction !== "horizontal") {
      const { scrollTop, scrollHeight, clientHeight } = me.element;
      if (event.clientY > box.bottom - width && scrollHeight - scrollTop - clientHeight >= 1) {
        me.scrollDeltaY = Math.round((width - (box.bottom - event.clientY)) / speed) + 1;
      } else if (event.clientY < box.top + width && scrollTop > 0) {
        me.scrollDeltaY = -Math.round((width + (box.top - event.clientY)) / speed) - 1;
      }
    }
    if (me.scrollDeltaX !== 0 && !scrollManager.requestScroll("horizontal", me)) {
      me.scrollDeltaX = 0;
    }
    if (me.scrollDeltaY !== 0 && !scrollManager.requestScroll("vertical", me)) {
      me.scrollDeltaY = 0;
    }
    if (me.scrollDeltaX === 0 && me.scrollDeltaY === 0) {
      me.scrolling && me.stopScroll();
    } else if (!me.scrollTimeout) {
      me.scrollTimeout = scrollManager.setTimeout(() => me.startScroll(), scrollManager.startScrollDelay);
    }
  }
  /**
   * Scrolls by an amount determined by config.scrollDeltaX/Y on each frame. Start/stop by calling #startScroll and
   * #stopScroll.
   * @private
   */
  performScroll() {
    const me = this, { element } = me;
    if (me.scrolling && !me.scrollRequested) {
      if (me.scrollDeltaX !== 0) {
        const oldScrollLeft = element.scrollLeft, newScrollLeft = Math.min(oldScrollLeft + me.scrollDeltaX, element.scrollWidth - element.clientWidth);
        element.scrollLeft = newScrollLeft;
        if (element.scrollLeft !== oldScrollLeft) {
          me.ongoingScrollLeft = new Promise((resolve) => element.addEventListener("scroll", resolve, { once: true }));
        } else {
          me.ongoingScrollLeft = null;
          me.scrollDeltaX = 0;
        }
      }
      if (me.scrollDeltaY !== 0) {
        const oldScrollTop = element.scrollTop, newScrollTop = Math.min(oldScrollTop + me.scrollDeltaY, element.scrollHeight - element.clientHeight);
        element.scrollTop = newScrollTop;
        if (element.scrollTop !== oldScrollTop) {
          me.ongoingScrollTop = new Promise((resolve) => element.addEventListener("scroll", resolve, { once: true }));
        } else {
          me.ongoingScrollTop = null;
          me.scrollDeltaY = 0;
        }
      }
      if (me.scrollDeltaX !== 0 || me.scrollDeltaY !== 0) {
        me.scrollRequested = true;
        me.frameId = me.scrollManager.requestAnimationFrame(() => {
          me.scrollRequested = false;
          me.performScroll(me);
        });
      } else {
        me.stopScroll();
      }
    }
  }
  onElementScroll() {
    var _a2, _b;
    (_b = (_a2 = this.config) == null ? void 0 : _a2.callback) == null ? void 0 : _b.call(this.thisObj || this.scrollManager, this);
  }
  get scrollLeft() {
    return this.element.scrollLeft;
  }
  get scrollTop() {
    return this.verticalElement ? this.verticalElement.scrollTop : this.element.scrollTop;
  }
  get scrollRelativeLeft() {
    return this.scrollLeft - this.startScrollLeft;
  }
  get scrollRelativeTop() {
    return this.scrollTop - this.startScrollTop;
  }
  // There could be several scrollables controlling different axes. If we want to calculate combined scroll from all
  // those monitors (e.g. for the case when we drag scheduler event in both directions), we should ask scroll manager
  // to iterate over monitored elements and aggregate scroll.
  getRelativeLeftScroll(element) {
    return this.scrollManager.getRelativeScroll(element, "left");
  }
  getRelativeTopScroll(element) {
    return this.scrollManager.getRelativeScroll(element, "top");
  }
};
ScrollManager._$name = "ScrollManager";

// ../Core/lib/Core/widget/Tooltip.js
var realignTransitions = {
  left: true,
  right: true,
  top: true,
  bottom: true,
  transform: true
};
var isBoolean = {
  true: 1,
  false: 1
};
var immediatePromise4 = Promise.resolve();
var _Tooltip = class _Tooltip extends Popup {
  /**
   * Triggered before tooltip widget is shown. Return `false` to prevent the action.
   * @preventable
   * @async
   * @event beforeShow
   * @param {Core.widget.Tooltip} source The Tooltip
   * @param {Event} source.triggeredByEvent The event that triggered this Tooltip to show.
   */
  static get configurable() {
    return {
      /**
       * By default, a Tooltip is transient, and will {@link #function-hide} when the mouse exits the target
       * element. Configure as `false` to make a Tooltip non-transient.
       * @config {Boolean}
       * @default
       */
      autoHide: true,
      /**
       * By default, a Tooltip is transient, and will {@link #function-hide} when the user clicks or
       * taps outside its widget. Configure as `false` to make a Tooltip non-transient when user clicks outside it.
       *
       * If you would like the Tooltip to stay visible when mouse leaves the Tooltip target, please see
       * {#config-autoHide}.
       *
       * @config {Boolean} autoClose
       * @default true
       */
      /**
       * Horizontal offset from mouse when {@link #config-anchorToTarget} is `false`.
       *
       * Direction independent, the value is internally flipped (by multiplying it with -1) for RTL.
       *
       * @config {Number}
       * @default
       */
      mouseOffsetX: 15,
      /**
       * Vertical offset from mouse when {@link #config-anchorToTarget} is `false`
       * @config {Number}
       * @default
       */
      mouseOffsetY: 15,
      html: {
        // Ensure the html setter can never veto the operation as a no-change.
        // Because of beforeShow listeners augmenting the content.
        $config: {
          equals: () => false
        }
      },
      /**
       * A method, or the *name* of a method called to update the tooltip's content when the
       * cursor is moved over a target. It receives one argument containing context about the
       * tooltip and show operation. The function should return a string, or a Promise yielding
       * a string.
       *
       * ```javascript
       * new Grid({
       *     title    : 'Client list',
       *     appendTo : myElement,
       *     store    : myStore,
       *     columns  : myColumns,
       *     tbar     : {
       *         items : {
       *             text : 'Reload,
       *             tooltip : {
       *                 // Will look in ownership hierarchy for the method
       *                 // which will be found on the grid.
       *                 getHtml : 'up.getReloadButtonTip'
       *             }
       *         }
       *     },
       *     getReloadButtonTip() {
       *         return `Reload ${this.title}`;
       *     }
       * });
       * ```
       *
       * @config {Function|String}
       * @param {Object} context
       * @param {Core.widget.Tooltip} context.tip The tooltip instance
       * @param {HTMLElement} context.element The Element for which the Tooltip is monitoring mouse movement
       * @param {HTMLElement} context.activeTarget The target element that triggered the show
       * @param {Event} context.event The raw DOM event
       * @returns {String|Promise}
       */
      getHtml: null,
      /**
       * DOM element to attach tooltip to. By default, the mouse entering this element will kick off a timer
       * (see {@link #config-hoverDelay}) to show itself.
       *
       * If the {@link #config-forSelector} is specified, then mouse entering matching elements within the `forElement`
       * will trigger the show timer to start.
       *
       * Note that when moving from matching element to matching element within the `forElement`, the tooltip
       * will remain visible for {@link #config-hideDelay} milliseconds after exiting one element, so that rapidly
       * entering another matching element will not cause hide+show flicker. To prevent this behaviour configure
       * with `hideDelay: 0`.
       * @config {HTMLElement}
       */
      forElement: null,
      /**
       * By default, once a tooltip is shown aligned as requested, it stays put.
       *
       * Setting this to `true` causes the tooltip to be aligned by the mouse,
       * offset by `[{@link #config-mouseOffsetX}, {@link #config-mouseOffsetY}]` and
       * keeps the tooltip aligned to the mouse maintaining the configured offsets
       * as the mouse moves within its activating element.
       * @config {Boolean}
       * @default false
       */
      trackMouse: null,
      /**
       * By default, a tooltip displays static content. In the Scheduler however, there are
       * plenty of uses cases when the tip content is based on the current mouse position (dragging events, resizing events, schedule hover tip, drag creation of events etc). Set
       * to `true` to update contents on mouse movement.
       * @config {Boolean}
       * @private
       * @default
       */
      updateContentOnMouseMove: false,
      /**
       * A CSS selector which targets child elements of the {@link #config-forElement} that should produce a
       * tooltip when hovered over.
       * @config {String}
       */
      forSelector: null,
      /**
       * By default, when moving rapidly from target to target, if, when mouseovering
       * a new target, the tip is still visible, the tooltip does not hide, it remains
       * visible, but updates its content however it is configured to do so.
       *
       * Configure `hideOnDelegateChange : true` to have the tip hide, and then trigger
       * a new show delay upon entry of a new target while still visible.
       * @config {Boolean}
       * @default false
       */
      hideOnDelegateChange: null,
      /**
       * Set to true to anchor tooltip to the triggering target. If set to `false`, the tooltip
       * will align to the mouse position. When set to `false`, it will also set `anchor: false`
       * to hide anchor arrow.
       * @config {Boolean}
       * @default
       */
      anchorToTarget: true,
      /**
       * Show on hover
       * @config {Boolean}
       * @default false
       */
      showOnHover: null,
      /**
       * The amount of time to hover before showing
       * @prp {Number}
       * @default
       */
      hoverDelay: 500,
      /**
       * Show immediately when created
       * @config {Boolean}
       * @default
       */
      autoShow: false,
      /**
       * The time (in milliseconds) that the Tooltip should stay visible for when it shows over its
       * target. If the tooltip is anchored to its target, then moving the mouse during this time
       * resets the timer so that the tooltip will remain visible.
       *
       * Defaults to `0` which means the Tooltip will persist until the mouse leaves the target.
       * @config {Number}
       * @default
       */
      dismissDelay: 0,
      /**
       * The time (in milliseconds) for which the Tooltip remains visible when the mouse leaves the target.
       *
       * May be configured as `false` to persist visible after the mouse exits the target element. Configure it
       * as 0 to always retrigger `hoverDelay` even when moving mouse inside `fromElement`
       * @config {Number|Boolean}
       * @default
       */
      hideDelay: 500,
      /**
       * The message to show while an async tooltip is fetching its content.
       * @config {String}
       * @default
       */
      loadingMsg: "Loading...",
      /**
       * Keep the tooltip open if user moves the mouse over it.
       *
       * If this is *not* explicitly configured as `false`, then this is automatically set
       * when there are any visible, interactive child items added such as {@link #config-tools}, or
       * {@link #config-items} which are interactive such as buttons or input fields.
       * @config {Boolean}
       * @default false
       */
      allowOver: null,
      anchor: true,
      align: {
        align: "b-t",
        // This signals to the align code that this widget is prepared to shrink
        // in height in order to comply with alignTo specifications.
        // Without a minHeight, it is assumed that the height of the widget
        // is inviolable.
        minHeight: 300
      },
      axisLock: true,
      /**
       * The HTML element that triggered this Tooltip to show
       * @readonly
       * @member {HTMLElement} activeTarget
       */
      activeTarget: null,
      testConfig: {
        hideDelay: 100,
        hoverDelay: 100,
        showAnimation: null,
        hideAnimation: null
      }
    };
  }
  //endregion
  //region Events
  /**
   * Triggered when a mouseover event is detected on a potential target element.
   * Return false to prevent the action
   * @event pointerOver
   * @param {Core.widget.Tooltip} sourceThe tooltip instance.
   * @param {Event} event The mouseover event.
   */
  //endregion
  //region Properties
  //endregion
  //region Init & destroy
  afterConfigure() {
    const me = this, { forSelector } = me;
    if (forSelector) {
      me.showOnHover = me.showOnHover !== false;
      if (!me.forElement) {
        if (!me.anchorToTarget) {
          me.trackMouse = true;
        }
        me.forElement = me.rootElement.host || me.rootElement;
      }
    }
    super.afterConfigure();
    if (me.forElement && me.showOnHover) {
      me.pointerOverOutDetacher = EventHelper.on({
        element: me.forElement,
        // Using pointerover/pointerout since mouseover events are not fired in Chrome when the native `disabled`
        // attribute is present https://github.com/bryntum/support/issues/3179
        pointerover: "internalOnPointerOver",
        pointerout: "internalOnPointerOut",
        thisObj: me
      });
    }
  }
  doDestroy() {
    var _a2;
    (_a2 = this.pointerOverOutDetacher) == null ? void 0 : _a2.call(this);
    super.doDestroy();
  }
  set focusOnToFront(focusOnToFront) {
    super.focusOnToFront = focusOnToFront;
  }
  get focusOnToFront() {
    return super.focusOnToFront && DomHelper.usingKeyboard;
  }
  get focusElement() {
    const result = super.focusElement;
    if (result !== this.element) {
      return result;
    }
  }
  get anchorToTarget() {
    return this._anchorToTarget && !this.trackMouse;
  }
  get anchor() {
    return super.anchor && !this.trackMouse;
  }
  set anchor(anchor) {
    super.anchor = anchor;
  }
  //endregion
  //region Hovering, show and hide
  onDocumentMouseDown({ event }) {
    const me = this, { triggeredByEvent } = me;
    if (triggeredByEvent && DomHelper.isTouchEvent) {
      if (event.pageX === triggeredByEvent.pageX && event.pageY === triggeredByEvent.pageY && me.activeTarget.contains(event.target) && performance.now() - triggeredByEvent.timeStamp < 500) {
        return;
      }
    }
    me.abortDelayedShow();
    super.onDocumentMouseDown({ event });
  }
  internalOnPointerOver(event) {
    const me = this, { target, relatedTarget } = event, { forElement, forSelector, activeTarget } = me;
    let newTarget;
    if (me.disabled || me.owner && !me.owner.showTooltipWhenDisabled && me.owner.disabled) {
      return;
    }
    if (me.allowOver && me.element.contains(target)) {
      return;
    }
    if (forSelector) {
      newTarget = me.filterTarget(target);
      if ((activeTarget == null ? void 0 : activeTarget.contains(target)) && activeTarget.contains(relatedTarget) && newTarget === activeTarget) {
        return;
      }
      if (newTarget && (relatedTarget == null ? void 0 : relatedTarget.closest(forSelector)) === newTarget) {
        return;
      }
    } else if (!forElement.contains(relatedTarget)) {
      newTarget = forElement;
    } else {
      return;
    }
    if (newTarget) {
      me.handleForElementOver(event, newTarget);
    } else if (activeTarget) {
      me.handleForElementOut();
    }
  }
  filterTarget(element) {
    return element.closest(this.forSelector);
  }
  // Handle a transitioned reposition when the activeTarget moved beneath the pointer.
  // When it comes to an end, if the mouseout has not hidden, then realign at the new position
  // if the activeTarget is still beneath the pointer.
  onTransitionEnd(event) {
    var _a2;
    const me = this, { currentOverElement: currentOverElement2 } = _Tooltip;
    if (realignTransitions[event.propertyName]) {
      if (me.allowOver && me.element.contains(currentOverElement2)) {
        return;
      }
      if (((_a2 = me.activeTarget) == null ? void 0 : _a2.contains(currentOverElement2)) && !me.trackMouse) {
        me.realign();
      }
    }
  }
  async handleForElementOver(event, newTarget) {
    const me = this, {
      activeTarget,
      hideOnDelegateChange,
      anchorToTarget
    } = me, isNewTarget = newTarget !== activeTarget, needsHide = isNewTarget && hideOnDelegateChange;
    if (me.trigger("pointerOver", { event, target: newTarget }) === false) {
      me.internalOnPointerOut(event);
    } else {
      me.triggeredByEvent = event;
      if (me.hasTimeout("hide")) {
        me.abortDelayedHide();
        if (!isNewTarget) {
          return;
        }
      }
      if (!hideOnDelegateChange && me.element.classList.contains("b-hiding")) {
        me.cancelHideShowAnimation();
      }
      if (!me._hidden && needsHide) {
        me.hide(false);
      }
      me.activeTarget = newTarget;
      if (me.isVisible) {
        const result = me.updateContent();
        if (Objects.isPromise(result) && !me.loadingMsg) {
          await result;
        }
        if (me.trigger("beforeShow") === false) {
          return me.hide();
        }
        me.alignTo({
          [anchorToTarget ? "target" : "position"]: anchorToTarget ? newTarget : "mouse",
          overlap: !(anchorToTarget && me.anchor)
        });
        me.trigger("show");
        me.afterShowByTarget();
      } else {
        me.delayShow(newTarget);
      }
    }
  }
  async delayShow(target) {
    var _a2;
    const me = this;
    if ((_a2 = me.currentAnimation) == null ? void 0 : _a2.showing) {
      me.cancelHideShowAnimation();
    }
    if (!me.isVisible && !me.hasTimeout("show")) {
      if (!me.hoverDelay || me.forSelector && Date.now() - me.lastHidden < me.quickShowInterval) {
        const result = me.updateContent();
        if (Objects.isPromise(result) && !me.loadingMsg) {
          await result;
        }
        me.showByTarget(target);
      } else {
        me.addDocumentMouseDownListener();
        if (!me.listeningForMouseMove && !me.anchorToTarget) {
          me.mouseMoveRemover = EventHelper.on({
            element: me.rootElement,
            mousemove: "onMouseMove",
            thisObj: me
          });
        }
        me.setTimeout(async () => {
          if (me.activeTarget === target && target.isConnected) {
            const result = me.updateContent();
            if (Objects.isPromise(result) && !me.loadingMsg) {
              await result;
            }
            me.showByTarget(target);
          }
        }, !me.triggeredByEvent || me.triggeredByEvent.type === "pointerover" ? me.hoverDelay : 0, "show");
      }
    } else if (me.isVisible) {
      me.showByTarget(target);
    }
  }
  changeAllowOver(allowOver) {
    if (!this.inAfterShow) {
      this.configuredAllowOver = allowOver;
    }
    return allowOver;
  }
  updateAllowOver(allowOver) {
    var _a2;
    const me = this, { element } = me;
    element.classList.toggle("b-allow-over", Boolean(allowOver));
    if (allowOver) {
      me.allowOverlisteners = EventHelper.on({
        element,
        mouseenter: "onOwnElementMouseEnter",
        mouseleave: "internalOnPointerOut",
        thisObj: me
      });
    } else {
      (_a2 = me.allowOverlisteners) == null ? void 0 : _a2.call(me);
    }
  }
  updateContent() {
    const me = this;
    if (me.getHtml) {
      const result = me.callback(me.getHtml, me, [{
        tip: me,
        element: me.element,
        activeTarget: me.activeTarget,
        event: me.triggeredByEvent
      }]);
      me.html = result;
      return result;
    }
  }
  // There are 3 possible scenarios:
  // - Static content
  // - Remote content being loaded (meaning we (possibly) set a loading message as the `html`
  // - Tooltip acts as a Container
  get hasContent() {
    return Boolean(DomHelper.isReactElement(this._html) || (this._html !== "" && (typeof this.html === "string" && this.html.length) || this.items.length));
  }
  internalBeforeShow() {
    return (this.updateContentOnMouseMove || this.hasContent) && !this.disabled;
  }
  /**
   * Shows a spinner and a message to indicate an async flow is ongoing
   * @param {String} message The message, defaults to {@link #config-loadingMsg}
   */
  showAsyncMessage(message = this.optionalL(this.loadingMsg)) {
    if (message) {
      this.html = `
                <div class="b-tooltip-loading">
                    <i class="b-icon b-icon-spinner"></i>
                    ${message}
                </div>
            `;
    }
  }
  showByTarget(target) {
    var _a2;
    const me = this, { anchorToTarget } = me;
    me.mouseMoveRemover = (_a2 = me.mouseMoveRemover) == null ? void 0 : _a2.call(me);
    me.showBy({
      [anchorToTarget ? "target" : "position"]: anchorToTarget ? target : "mouse",
      overlap: !(anchorToTarget && me.anchor)
    });
  }
  afterShowByTarget() {
    const me = this, { dismissDelay } = me;
    me.abortDelayedShow();
    if (dismissDelay) {
      me.setTimeout("hide", dismissDelay);
    }
    if (me.element.parentNode) {
      me.toFront();
    }
    if (!me.mouseMoveRemover && (me.trackMouse || me.updateContentOnMouseMove)) {
      me.mouseMoveRemover = EventHelper.on({
        element: me.rootElement,
        pointermove: "onMouseMove",
        thisObj: me
      });
    }
    me.inAfterShow = true;
    me.allowOver = me.allowOver || me.configuredAllowOver != false && me.childItems.some((w) => w.isVisible && !w.disabled && w.focusElement);
    me.inAfterShow = false;
  }
  updateActiveTarget(newTarget, lastTarget) {
    if (newTarget && !this.isConfiguring) {
      this.trigger("overTarget", { newTarget, lastTarget });
    }
  }
  internalOnPointerOut(event) {
    var _a2;
    const me = this, toElement = event.relatedTarget;
    if (me.allowOver && me.element.contains(toElement)) {
      return;
    }
    if (me.element.contains(event.target) && ((_a2 = me.activeTarget) == null ? void 0 : _a2.contains(toElement))) {
      return;
    }
    if (me.activeTarget && !me.activeTarget.contains(toElement)) {
      me.handleForElementOut();
    }
  }
  handleForElementOut() {
    const me = this, { hideDelay } = me;
    if (me.trigger("pointerOut") === false) {
      me.activeTarget = null;
      return true;
    }
    me.abortDelayedShow();
    if (me.isVisible && hideDelay !== false) {
      me.abortDelayedHide();
      if (hideDelay > 0) {
        me.setTimeout("hide", hideDelay);
      } else {
        me.hide();
      }
    }
  }
  show(spec) {
    const me = this;
    if (!spec && me.forElement && me.anchorToTarget && !me.forSelector) {
      me.showByTarget(me.forElement);
    } else {
      super.show(...arguments);
    }
    if (me.isVisible) {
      me.afterShowByTarget();
      if (me.forElement && !me.transitionEndDetacher && !me._hidden) {
        me.transitionEndDetacher = EventHelper.on({
          element: me.forElement,
          transitionend: "onTransitionEnd",
          thisObj: me
        });
      }
    }
  }
  get hideDelay() {
    return this.autoHide ? this._hideDelay : false;
  }
  hide() {
    var _a2, _b;
    const me = this;
    me.abortDelayedShow();
    if (!me._hidden) {
      me.abortDelayedHide();
      const result = super.hide(...arguments);
      me.lastHidden = Date.now();
      me.activeTarget = null;
      (_a2 = me.mouseMoveRemover) == null ? void 0 : _a2.call(me);
      me.mouseMoveRemover = null;
      (_b = me.transitionEndDetacher) == null ? void 0 : _b.call(me);
      me.transitionEndDetacher = null;
      return result;
    } else {
      return immediatePromise4;
    }
  }
  abortDelayedShow() {
    var _a2, _b, _c;
    const me = this;
    if (me.hasTimeout("show")) {
      (_a2 = me.mouseDownRemover) == null ? void 0 : _a2.call(me);
      me.mouseDownRemover = null;
      me.clearTimeout("show");
      (_b = me.mouseMoveRemover) == null ? void 0 : _b.call(me);
      me.mouseMoveRemover = null;
      (_c = me.transitionEndDetacher) == null ? void 0 : _c.call(me);
      me.transitionEndDetacher = null;
    }
  }
  /**
   * Stops both timers which may hide this tooltip, the one which counts down from mouseout
   * and the one which counts down from mouseover show for dismissDelay ms
   * @private
   */
  abortDelayedHide() {
    this.clearTimeout("hide");
  }
  realign() {
    const me = this, spec = me.lastAlignSpec;
    if (!me.isConfiguring && !me.isVisible && (spec == null ? void 0 : spec.targetOutOfView)) {
      if (spec.allowTargetOut || DomHelper.isInView(spec.target, false, me)) {
        me.show();
        spec.targetOutOfView = false;
      }
    }
    super.realign();
  }
  alignTo(spec) {
    const me = this, mouseOffsetX = (me.mouseOffsetX || 1) * (me.rtl ? -1 : 1), mouseOffsetY = me.mouseOffsetY || 1, xMargin = Math.max(Math.min(mouseOffsetX, 5), 0), yMargin = Math.max(Math.min(mouseOffsetY, 5), 0);
    if (!me.isVisible) {
      return;
    }
    let mousePosition;
    if (!me.anchorToTarget && spec.position === "mouse") {
      mousePosition = new Point(
        me.triggeredByEvent.pageX - globalThis.scrollX,
        me.triggeredByEvent.pageY - globalThis.scrollY
      );
      spec.position = new Point(
        mousePosition.x + (mouseOffsetX || 1) - (mouseOffsetX < 0 ? me.width : 0),
        mousePosition.y + (mouseOffsetY || 1) - (mouseOffsetY < 0 ? me.height : 0)
      );
    }
    if (spec && !(me.triggeredByEvent && me.element.contains(me.triggeredByEvent.target))) {
      if (spec.nodeType === Node.ELEMENT_NODE) {
        spec = {
          target: spec
        };
      }
    }
    super.alignTo(spec);
    if (mousePosition && me.lastAlignSpec.result.inflate(yMargin, xMargin).contains(mousePosition)) {
      me.lastAlignSpec.position = "mouse";
      me.mouseOffsetY = -mouseOffsetY;
      me.mouseOffsetX = -mouseOffsetX;
      me.realign();
      me.mouseOffsetY = mouseOffsetY;
      me.mouseOffsetX = mouseOffsetX;
    }
  }
  //endregion
  //region Tooltip contents
  /**
   * Get/set the HTML to display. When specifying HTML, this widget's element will also have `b-html` added to its
   * classList, to allow targeted styling. To create async tooltip and show the {@link #config-loadingMsg}, see code below:
   * For example:
   *
   * ```javascript
   * new Tooltip({
   *     listeners : {
   *         beforeShow : ({ source : tip }) => {
   *             tip.showAsyncMessage();
   *             AjaxHelper.get('someurl').then(response => tip.html = 'Done!');
   *         }
   *     }
   * });
   * ```
   *
   * @member {String} html
   * @category DOM
   */
  changeHtml(htmlOrPromise) {
    const me = this;
    if (Objects.isPromise(htmlOrPromise)) {
      me.showAsyncMessage();
      htmlOrPromise.target = me.activeTarget;
      htmlOrPromise.then((html) => {
        if (htmlOrPromise.target === me.activeTarget) {
          me.html = html;
        }
      });
      return;
    }
    if (typeof htmlOrPromise !== "object") {
      htmlOrPromise = htmlOrPromise != null ? me.optionalL(String(htmlOrPromise)) : "";
    }
    return htmlOrPromise;
  }
  updateHtml(value, was) {
    const me = this;
    let empty2 = value === "";
    if (!empty2) {
      super.updateHtml(value, was);
      if (me.hasContent) {
        if (me.isVisible) {
          me.realign();
        }
        if (!Objects.isPromise(value)) {
          me.trigger("innerHtmlUpdate", { value });
        }
      } else {
        empty2 = true;
      }
    }
    if (empty2) {
      me.hide();
    }
  }
  //endregion
  //region Events
  /**
   * Mouse move event listener which updates tooltip
   * @private
   */
  onMouseMove(event) {
    const me = this, {
      forElement,
      activeTarget
    } = me, isHiding = me.hasTimeout("hide"), target = event.target;
    me.triggeredByEvent = event;
    if (!me._hidden) {
      let hideVetoed;
      const isWithinTarget = activeTarget == null ? void 0 : activeTarget.contains(target), isElementOut = !isWithinTarget && me.forSelector && activeTarget && !isHiding && target.nodeType === Node.ELEMENT_NODE && !target.matches(me.forSelector) && !(me.allowOver && me.element.contains(target)), containingElement = (forElement == null ? void 0 : forElement.document) ? forElement.document.documentElement : forElement, forElementContainsTarget = containingElement && (containingElement.contains ? containingElement.contains(target) : containingElement.compareDocumentPosition(target) & 16);
      if (isElementOut) {
        hideVetoed = me.handleForElementOut();
      }
      if (hideVetoed || !isHiding || forElementContainsTarget) {
        if (me.dismissDelay && !isHiding) {
          me.setTimeout("hide", me.dismissDelay);
        }
        if (me.updateContentOnMouseMove && me.getHtml) {
          me.html = me.callback(me.getHtml, me, [{
            tip: me,
            element: me.element,
            forElement: activeTarget,
            event
          }]);
          if (!me.html) {
            me.hide();
            return;
          }
        }
        if (me.trackMouse) {
          me.alignTo({
            position: "mouse",
            ignorePageScroll: true
          });
        }
      }
    }
  }
  // Handle if implementer has defined "showOnClick"
  onElementUserAction(event) {
    this.internalOnPointerOver(event);
  }
  onOwnElementMouseEnter(event) {
    this.abortDelayedHide();
  }
  //endregion
  // rootElement = where to find the float root
  // forElement = where to set up listeners
  // Can be different when using a shadowRoot not part of a webcomponent
  static getSharedTooltip(rootElement, forElement, skipCreating) {
    var _a2, _b, _c;
    let sharedTooltip = (_b = (_a2 = forElement.bryntum) == null ? void 0 : _a2.tooltip) == null ? void 0 : _b.get(_Tooltip);
    if (!sharedTooltip && !skipCreating) {
      if (!((_c = forElement.bryntum) == null ? void 0 : _c.tooltip)) {
        ObjectHelper.setPath(forElement, "bryntum.tooltip", /* @__PURE__ */ new Map());
      }
      const map2 = forElement.bryntum.tooltip;
      map2.set(_Tooltip, true);
      sharedTooltip = new _Tooltip({
        forElement,
        rootElement,
        forSelector: "[data-btip]",
        resetCfg: {},
        isSharedTooltip: true,
        cls: "b-tooltip-shared",
        internalListeners: {
          // Reconfigure on pointerOver
          pointerOver({ source: me, target }) {
            for (const key in me.resetCfg) {
              if (key === "listeners") {
                me.un(me.resetCfg[key].set);
              } else if (key !== "html") {
                me[key] = me.resetCfg[key].was;
              }
            }
            me.resetCfg = {};
            const forComponent = Widget.getById(target.id), config = (forComponent == null ? void 0 : forComponent.tipConfig) || me.gatherDataConfigs(target.dataset);
            if (forComponent && forComponent.element !== target || !forComponent && target.matches(".b-widget") || // Respect our forComponent's wish to not show when it's disabled
            (forComponent == null ? void 0 : forComponent.disabled) && !forComponent.showTooltipWhenDisabled) {
              return false;
            }
            me.owner = forComponent;
            for (const key in config) {
              me.resetCfg[key] = {
                set: config[key],
                was: me[key]
              };
              if (key === "listeners") {
                me.ion(config[key]);
              } else {
                me[key] = config[key];
              }
            }
          },
          hide({ source: me }) {
            me.owner = null;
          }
        },
        gatherDataConfigs(dataset) {
          const me = this, config = {};
          for (const key in dataset) {
            if (key.startsWith("btip")) {
              if (key.length > 4) {
                const configProp = StringHelper.uncapitalize(key.substr(4));
                if (configProp in me.getDefaultConfiguration()) {
                  const value = dataset[key];
                  config[configProp] = isBoolean[value] ? value === "true" : isNaN(value) ? value : parseInt(value, 10);
                }
              } else {
                config.html = dataset[key];
              }
            }
          }
          return config;
        },
        filterTarget(element) {
          const target = element.closest(this.forSelector);
          if (target) {
            return target;
          }
          if (_Tooltip.showOverflow && element.closest(".b-widget")) {
            while ((element == null ? void 0 : element.nodeType) === Element.ELEMENT_NODE) {
              if (DomHelper.getStyleValue(element, "text-overflow") === "ellipsis" && element.clientWidth < element.scrollWidth) {
                this.html = StringHelper.encodeHtml(element.textContent);
                return element;
              }
              element = element.parentNode;
            }
          }
        }
      });
      EventHelper.on({
        element: forElement,
        mouseenter: (event) => _Tooltip.currentOverElement = event.target,
        // If mouse is not used for editing cell then Tooltip has no `currentOverElement` and no error tooltip is shown. We use keydown event.target for this
        keydown: (event) => _Tooltip.currentOverElement = event.target,
        capture: true,
        thisObj: sharedTooltip
      });
      map2.set(_Tooltip, sharedTooltip);
    }
    return sharedTooltip;
  }
  static encodeConfig(tooltip) {
    const dataset = {};
    if (typeof tooltip === "string") {
      dataset.btip = tooltip;
    } else {
      for (const config in tooltip) {
        dataset[`btip${config === "html" ? "" : StringHelper.capitalize(config)}`] = tooltip[config];
      }
    }
    return dataset;
  }
};
//region Default config
__publicField(_Tooltip, "$name", "Tooltip");
__publicField(_Tooltip, "type", "tooltip");
var Tooltip = _Tooltip;
Tooltip.initClass();
Object.defineProperty(Widget, "tooltip", {
  get() {
    return Tooltip.getSharedTooltip(document.body, document.body);
  }
});
Widget.Tooltip = Tooltip;
Tooltip._$name = "Tooltip";

// ../Core/lib/Core/util/drag/DragTipProxy.js
var DragTipProxy = class extends DragProxy {
  static get type() {
    return "tip";
  }
  static get configurable() {
    return {
      /**
       * Controls how the tooltip will be aligned to the current drag position.
       *
       * See {@link Core.helper.util.Rectangle#function-alignTo} for details.
       * @config {String}
       * @default
       */
      align: "t10-b50",
      /**
       * The number of pixels to offset from the drag position.
       * @config {Number}
       * @default
       */
      offset: 20,
      /**
       * The tooltip to be shown, hidden and repositioned to track the drag position.
       * @config {Core.widget.Tooltip}
       */
      tooltip: {
        $config: ["lazy", "nullify"],
        value: {
          type: "tooltip"
        }
      }
    };
  }
  open() {
    this.getConfig("tooltip");
  }
  close() {
    var _a2;
    (_a2 = this.tooltip) == null ? void 0 : _a2.hide();
  }
  dragMove(drag) {
    const { offset, tooltip } = this, { event } = drag;
    if (tooltip) {
      if (!tooltip.isVisible) {
        tooltip.show();
      }
      tooltip.alignTo({
        align: this.align,
        target: new Rectangle(event.clientX - offset, event.clientY - offset, offset * 2, offset * 2)
      });
    }
  }
  changeTooltip(config, existing) {
    return Widget.reconfigure(
      existing,
      config,
      /* owner = */
      this
    );
  }
};
DragTipProxy.initClass();
DragTipProxy._$name = "DragTipProxy";

// ../Core/lib/Core/widget/mixin/Labelable.js
var Labelable_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    static get configurable() {
      return {
        /**
         * Get/set fields label. Please note that the Field needs to have a label specified from start for this to
         * work, otherwise no element is created.
         * @member {String} label
         */
        /**
         * Label, prepended to field
         * @config {String}
         * @category Label
         */
        label: null,
        /**
         * Label position, either 'before' the field or 'above' the field
         * @config {'before'|'above'}
         * @default
         * @category Label
         */
        labelPosition: "before",
        /**
         * CSS class name or class names to add to any configured {@link #config-label}
         * @config {String|Object}
         * @category Label
         */
        labelCls: null,
        /**
         * The width to apply to the `<label>` element. If a number is specified, `px` will be used.
         * @config {String|Number}
         * @localizable
         * @category Label
         */
        labelWidth: {
          value: null,
          $config: {
            localeKey: "L{labelWidth}"
          }
        }
      };
    }
    get hasLabel() {
      return Boolean(this.label);
    }
    compose() {
      const { hasLabel, labelPosition } = this;
      return {
        class: {
          [`b-label-${labelPosition}`]: hasLabel,
          "b-has-label": hasLabel
        }
      };
    }
    changeLabel(label) {
      return label || "";
    }
    setupLabel(lbl) {
      return ObjectHelper.assign({
        tag: "label",
        for: `${this.id}-input`,
        class: `b-label b-align-${lbl.align || "start"}`
      }, lbl);
    }
    updateLabelWidth(newValue) {
      if (this.labelElement) {
        this.labelElement.style.flex = `0 0 ${DomHelper.setLength(newValue)}`;
        this.inputWrap.style.flexBasis = newValue == null ? "" : "auto";
      }
    }
    //endregion
    // This does not need a className on Widgets.
    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding
    // to the Widget it's mixed in to should implement thus.
    get widgetClass() {
    }
  }, //region Config
  __publicField(_a2, "$name", "Labelable"), _a2;
};

// ../Core/lib/Core/widget/FieldContainer.js
var FieldContainer = class extends Container {
  static get configurable() {
    return {
      /**
       * An animation config object to use when expanding or collapsing the field's
       * {@link Core.widget.Field#config-container}.
       * @config {Object} animation
       * @property {Number} [animation.duration=300] The duration of the animation (in milliseconds).
       * @internal
       */
      animation: {
        duration: 300
      },
      /**
       * Controls whether the field is collapsed (that is, the field's {@link Core.widget.Field#config-container}
       * is hidden).
       * @config {Boolean}
       * @default false
       */
      collapsed: null,
      /**
       * The animator performing the field's currently running expand or collapse animation.
       * @config {Core.util.Animator}
       * @private
       */
      collapser: {
        value: null,
        $config: "nullify"
        // to abort animations on destroy
      },
      /**
       * A mapping object for config properties of the items in the {@link Core.widget.Field#config-container}.
       * The keys are the config names and the values are functions that compute the config value when passed
       * the field instance.
       *
       * For example, this is the default:
       * ```javascript
       *      syncableConfigs : {
       *          disabled : field => field.disabled
       *      }
       * ```
       * This indicates that the config property named with the key ('disabled') should be assigned to the result
       * of the function assigned to that key (`field => field.disabled`). In other words, when the field is
       * {@link Core.widget.Field#config-disabled}, all of the field's items should also be disabled.
       *
       * @config {Object}
       * @internal
       */
      syncableConfigs: null,
      /**
       * This object holds truthy values for each config property that, when modified, should trigger a sync of
       * this field's items as defined in {@link #config-syncableConfigs}.
       * @config {Object}
       * @internal
       */
      syncConfigTriggers: {
        $config: {
          merge: "classList"
        },
        value: null
      },
      testConfig: {
        animation: {
          duration: 10
        }
      }
    };
  }
  static get delayable() {
    return {
      syncChildConfigs: "raf"
    };
  }
  get inline() {
    var _a2;
    return (_a2 = this.owner.inline) != null ? _a2 : this.ensureItems().count === 1;
  }
  changeCollapsed(collapsed) {
    if (this.togglingCollapse) {
      this.togglingCollapse = false;
      return collapsed;
    }
    this.toggleCollapse(Boolean(collapsed));
  }
  updateCollapsed(collapsed) {
    var _a2;
    this.collapser = (_a2 = this.collapser) == null ? void 0 : _a2.destroy();
    this.setCollapsedCls(collapsed);
  }
  updateCollapser(collapser, was) {
    if (was && was.completed == null) {
      if (!was.reverting || !collapser) {
        was.destroy();
      }
    }
    this.setOwnerCls("b-collapsing", collapser);
  }
  //endregion
  /**
   * This property is `true` if the field container is currently collapsing.
   * @property {Boolean}
   * @readonly
   */
  get collapsing() {
    const { collapser } = this;
    return collapser != null && collapser.collapsed;
  }
  /**
   * This property is `true` if the field container is currently either collapsing or expanding.
   * @property {Boolean}
   * @readonly
   * @internal
   */
  get collapsingExpanding() {
    return this.collapser != null;
  }
  /**
   * This property is `true` if the field container is currently expanding.
   * @property {Boolean}
   * @readonly
   */
  get expanding() {
    const { collapser } = this;
    return collapser != null && !collapser.collapsed;
  }
  collapse(animation) {
    this.toggleCollapse(true, animation);
  }
  expand(animation) {
    this.toggleCollapse(false, animation);
  }
  setCollapsedCls(collapsed) {
    this.setOwnerCls("b-collapsed", collapsed);
  }
  setOwnerCls(cls, state) {
    var _a2, _b;
    (_b = (_a2 = this.owner) == null ? void 0 : _a2.element) == null ? void 0 : _b.classList[state ? "add" : "remove"](cls);
  }
  syncChildConfigs() {
    const me = this, { owner, syncableConfigs } = me;
    if (syncableConfigs) {
      let destProp, val;
      for (destProp in syncableConfigs) {
        val = syncableConfigs[destProp](owner);
        me.eachWidget(
          (item) => {
            item[destProp] = val;
          },
          /* deep = */
          false
        );
      }
    }
    owner.afterSyncChildConfigs(me);
  }
  syncContainer() {
    const { inline, layout } = this;
    if (this.autoLayout) {
      layout.horizontal = inline;
      layout.justify = inline ? "center" : "stretch";
    }
  }
  toggleCollapse(collapsed, animation) {
    const me = this, { animation: collapseAnimation, collapser, inline } = me, { containerWrapElement } = me.owner, finalize = (complete) => {
      if (complete) {
        me.element.style.height = "";
        me.togglingCollapse = true;
        me.collapsed = collapsed;
        me.collapser = null;
      }
    };
    if (collapsed == null) {
      collapsed = !me.collapsed;
    }
    if (animation !== false && animation !== null) {
      if (!containerWrapElement || !me.isVisible) {
        animation = null;
      } else {
        if (animation === true) {
          animation = {};
        } else if (typeof animation === "number") {
          animation = {
            duration: animation
          };
        }
        animation = collapseAnimation || animation ? ObjectHelper.merge({}, collapseAnimation, animation) : null;
      }
    }
    if (!animation) {
      me.togglingCollapse = true;
      me.collapsed = collapsed;
    } else if (collapser && collapsed !== collapser.collapsed) {
      me.collapser = collapser.revert({ finalize });
      me.collapser.collapsed = collapsed;
    } else if (!collapser && collapsed !== me.collapsed) {
      !collapsed && me.setCollapsedCls(false);
      const { element } = me, { height } = element.getBoundingClientRect(), expanded = inline ? 1 : height;
      !collapsed && me.setCollapsedCls(true);
      element.style.height = `${height}px`;
      me.collapser = Animator.run(ObjectHelper.merge({
        finalize,
        element: containerWrapElement,
        [inline ? "opacity" : "height"]: {
          from: collapsed ? expanded : 0,
          to: collapsed ? 0 : expanded
        }
      }, animation));
      me.collapser.collapsed = collapsed;
    }
  }
};
//region Config
__publicField(FieldContainer, "$name", "FieldContainer");
__publicField(FieldContainer, "type", "fieldcontainer");
FieldContainer.initClass();
FieldContainer._$name = "FieldContainer";

// ../Core/lib/Core/widget/Field.js
var byWeight = (l, r) => (l.weight || 0) - (r.weight || 0);
var byWeightReverse = (l, r) => (r.weight || 0) - (l.weight || 0);
var emptyArray8 = [];
var triggerConfigs = {
  align: true,
  weight: true
};
var _Field = class _Field extends Widget.mixin(Badge_default, Labelable_default) {
  static get configurable() {
    return {
      defaultBindProperty: "value",
      /**
       * @hideconfigs htmlCls, content, tag, scrollable, html
       */
      /**
       * Text to display in empty field.
       * @config {String} placeholder
       */
      placeholder: null,
      /**
       * Gets or sets the value. The returned type will depend upon the Field subclass.
       *
       * `TextField` returns a `String`.
       *
       * `NumberField` returns a `Number`.
       *
       * `DateField` and `TimeField` return a `Date` object, and `null` if the field is empty.
       *
       * `Combo` will return a `String` if configured with `items` as a simple string array.
       * Otherwise it will return the {@link Core.widget.Combo#config-valueField} value from the
       * selected record, or `null` if no selection has been made.
       * @member {*} value
       */
      /**
       * Default value
       * @config {String}
       */
      value: "",
      /**
       * Name of the field which is used as a key to get/set values from/to the field.
       * Used prior to {@link Core.widget.Widget#config-ref ref} and {@link Core.widget.Widget#config-id id} in
       * {@link Core.widget.Container#property-values Container.values}.
       *
       * The config is useful when the field is used in EventEditor or TaskEditor to load/save values automatically.
       * @config {String}
       */
      name: null,
      /**
       * The labels to add either before or after the input field.
       * Each label may have the following properties:
       * * `html` The label text.
       * * `align` `'start'` or `'end'` which end of the field the label should go.
       * @config {Object[]}
       * @property {String} html Label text
       * @property {'start'|'end'} align Which end of the file the label should go
       * @category Label
       */
      labels: null,
      /**
       * Configure as `true` to indicate that a `null` field value is to be marked as invalid.
       * @config {Boolean}
       * @default false
       */
      required: null,
      /**
       * Show a trigger to clear field, and allow `SHIFT+BACKSPACE` key to clear field if this field is
       * not {@link #config-readOnly}. The trigger is available in the {@link #property-triggers} object
       * under the name `clear`. May also be an object which configures the `clear`
       * {@link #property-triggers trigger}.
       * @config {Boolean|FieldTriggerConfig}
       * @default false
       */
      clearable: null,
      /**
       * If this field is not {@link #config-readOnly}, then setting this option means that pressing
       * the `ESCAPE` key after editing the field will revert the field to the value it had when
       * the user focused the field. If the field is _not_ changed from when focused, the {@link #config-clearable}
       * behaviour will be activated.
       * @config {Boolean}
       * @default false
       */
      revertOnEscape: null,
      /**
       * An optional string to display inside the input field as an overlay. This can be useful for displaying
       * a field's units.
       *
       * This config is ignored if {@link #config-hintHtml} is set.
       *
       * For example:
       * ```javascript
       *  {
       *      type  : 'numberfield',
       *      label : 'Temperature',
       *      hint  : 'C'
       *  }
       * ```
       *
       * This config can be set to a function to dynamically generate the `hint` text:
       * ```javascript
       *  {
       *      type  : 'numberfield',
       *      label : 'Duration',
       *      hint  : ({ value }) => (value === 1) ? 'Day' : 'Days'
       *  }
       * ```
       *
       * The function is passed an object with the following properties:
       *
       *  - `source` A reference to the field instance.
       *  - `value` The current value of the field.
       *
       * A `hint` function will be called when the field changes value.
       *
       * @config {String|Function}
       * @param {Object} data A data object
       * @param {Core.widget.Field} data.source A reference to the field instance
       * @param {*} data.value The current value of the field
       * @returns {String}
       * @category Label
       */
      hint: null,
      /**
       * This config is similar to {@link #config-hint} except that this config is used to display HTML content.
       * Since this can allow malicious content to be executed, be sure not to include user-entered data or to
       * encode such data (see {@link Core.helper.StringHelper#function-encodeHtml-static}).
       *
       * If this config is set, {@link #config-hint} is ignored.
       *
       * For example:
       * ```javascript
       *  {
       *      type     : 'numberfield',
       *      label    : 'Temperature',
       *      hintHtml : '<i>C</i>'
       *  }
       * ```
       *
       * This config can be set to a function to dynamically generate the `hintHtml` text:
       * ```javascript
       *  {
       *      type     : 'numberfield',
       *      label    : 'Duration',
       *      hintHtml : ({ value }) => (value === 1) ? '<i>Day</i>' : '<i>Days</i>'
       *  }
       * ```
       *
       * The function is passed an object with the following properties:
       *
       *  - `source` A reference to the field instance.
       *  - `value` The current value of the field.
       *
       * A `hintHtml` function will be called when the field changes value.
       *
       * @config {String|Function}
       * @param {Object} data A data object
       * @param {Core.widget.Field} data.source A reference to the field instance
       * @param {*} data.value The current value of the field
       * @returns {String}
       * @category Label
       */
      hintHtml: null,
      /**
       * The width to apply to the `<input>` element. If a number is specified, `px` will be used.
       * @config {String|Number}
       * @category Input element
       */
      inputWidth: null,
      /**
       * The delay in milliseconds to wait after the last keystroke before triggering a change event.
       * Set to 0 to not trigger change events from keystrokes (listen for input event instead to have
       * immediate feedback, change will still be triggered on blur).
       *
       * If the field is {@link #config-clearable}, the change event fires immediately on receiving
       * the clear gesture.
       * @config {Number}
       * @default
       */
      keyStrokeChangeDelay: 0,
      /**
       * Makes the field unmodifiable by user action. The input area is not editable, and triggers
       * are unresponsive.
       *
       * This is a wider-acting setting than {@link #config-editable} which *only* sets the
       * `readOnly` attribute of the `<input>` field.
       *
       * {@link Core.widget.PickerField}s such as `Combo` and `DateField` can be `editable : false`, but still
       * modifiable through the UI.
       * @prp {Boolean}
       */
      readOnly: null,
      /**
       * Set to false to prevent user from editing the field. For TextFields it is basically the same as setting
       * {@link #config-readOnly}, but for PickerFields there is a distinction where it allows you to pick a value
       * but not to type one in the field.
       *
       * {@link Core.widget.PickerField}s such as `Combo` and `DateField` can be `editable : false`, but still
       * modifiable through the UI.
       *
       * On mobile devices, {@link Core.widget.PickerField}s are set to `editable : false` by
       * default so that the user must select a value from the dropdown picker rather than having
       * to type a value which will cause a display of the virtual keyboard.
       *
       * If typing is essential to the functioning of the field, configuring the field
       * with `editable : true` will override this behaviour.
       * @prp {Boolean}
       * @default true
       */
      editable: true,
      defaultAction: "change",
      /**
       * The trigger Widgets as specified by the {@link #config-triggers} configuration and the
       * {@link #config-clearable} configuration. Each is a {@link Core.widget.Widget} instance which may
       * be hidden, shown and observed and styled just like any other widget.
       * @member {Object<String,Core.widget.Widget>} triggers
       */
      /**
       * The triggers to add either before or after the input field. Each property name is the reference by which
       * an instantiated Trigger Widget may be retrieved from the live `{@link #property-triggers}` property.
       *
       * Each trigger may have the following properties:
       * * `cls` The CSS class to apply.
       * * `handler` A method in the field to call upon click
       * * `align` `'start'` or `'end'` which end of the field the trigger should go.
       * * `weight` (Optional) Higher weighted triggers gravitate towards the input field.
       *
       * ```javascript
       * const textField = new TextField({
       *   triggers : {
       *       check : {
       *           cls : 'b-fa b-fa-check',
       *           handler() {
       *               ...
       *           }
       *       },
       *       ...
       *   }
       * })
       * ```
       *
       * @config {Object<String,FieldTriggerConfig>}
       */
      triggers: null,
      /**
       * Specify `false` to prevent field from being highlighted when on external value changes
       * @config {Boolean}
       */
      highlightExternalChange: true,
      localizableProperties: ["label", "title", "placeholder", "labelWidth"],
      /**
       * Specify `true` to auto select field contents on focus
       * @config {Boolean}
       * @default
       */
      autoSelect: false,
      /**
       * Sets the native `autocomplete` property of the underlying input element. For more information, please refer to
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/autocomplete)
       * @config {String}
       * @default
       * @category Input element
       */
      autoComplete: "off",
      /**
       * Sets the native `spellcheck` property of the underlying input element. For more information, please refer to
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/spellcheck)
       * @config {Boolean}
       * @category Input element
       */
      spellCheck: null,
      /**
       * Set to `false` to not highlight a field as invalid while typing, to instead show it on ENTER key press
       * or similar.
       * @config {Boolean}
       * @category Input element
       */
      validateOnInput: true,
      /**
       * Sets custom attributes of the underlying input element. For more information, please refer to
       * [MDN](https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes)
       * @config {Object}
       * @default
       * @category Input element
       */
      inputAttributes: null,
      /**
       * Sets the `type` attribute of the underlying input element (password, hidden, date, color, etc).
       * @config {String}
       * @category Input element
       */
      inputType: "text",
      /**
       * Text alignment for the input field.
       * @config {String}
       * @category Input element
       */
      inputAlign: null,
      /**
       * A list of property names to be set in the underlying input element from properties
       * by the same name in this Field object if the value is not `== null`.
       * @private
       * @category Input element
       */
      attributes: {
        value: [
          "placeholder",
          "autoComplete",
          "spellCheck",
          "minLength",
          "maxLength",
          "pattern",
          "tabIndex",
          "min",
          "max"
        ],
        $config: {
          merge: "distinct"
        }
      },
      nullValue: {
        $config: null,
        value: null,
        default: null
        // store _value=null on prototype
      },
      updatedClsDuration: 500,
      inputReadOnly: false,
      ariaElement: "input",
      /**
       * The configuration for additional items associated to this field. This is typically used to add contextual
       * fields related to a {@link Core.widget.Checkbox checkbox} or {@link Core.widget.Radio radio button}. See
       * these classes for examples of nested fields.
       *
       * This config can be provided as an array of widget config objects, an object with named widgets (see
       * {@link Core.widget.FieldContainer#config-namedItems}, or a config object for the whole
       * {@link Core.widget.FieldContainer field container}.
       *
       * To determine if the object is a `namedItems` object or a {@link Core.widget.FieldContainer field container}
       * config, the object is checked for either a `type` or an `items` property. If it has either of these
       * properties, it is a field container config object. Configuring the container is useful for applying
       * {@link Core.widget.FieldContainer#config-cls classes} or {@link Core.widget.FieldContainer#config-style styles}
       * to the container as a whole.
       *
       * For example, to add named items:
       * ```javascript
       *  new Checkbox({
       *      text : 'Separate shipping address',
       *      container : {
       *          address1 : {
       *              type : 'textfield'
       *          },
       *          address2 : {
       *              type : 'textfield'
       *          }
       *      }
       *  });
       * ```
       *
       * To style the container as well, move the items to the `items` property and add `cls`:
       * ```javascript
       *  new Checkbox({
       *      text : 'Separate shipping address',
       *      container : {
       *          cls   : 'address-form',
       *          items : {
       *              address1 : {
       *                  type : 'textfield'
       *              },
       *              address2 : {
       *                  type : 'textfield'
       *              }
       *          }
       *      }
       *  });
       * ```
       *
       * @config {Core.widget.FieldContainer}
       * @accepts {Object<string,ContainerItemConfig>|ContainerItemConfig[]|FieldContainerConfig}
       * @category Container
       */
      container: {
        $config: "nullify",
        value: null
      },
      /**
       * The default configuration for the {@link #config-container}.
       * @config {Core.widget.FieldContainer}
       * @accepts {Core.widget.FieldContainer|FieldContainerConfig}
       * @category Container
       * @internal
       */
      containerDefaults: {
        type: "fieldcontainer",
        syncableConfigs: {
          disabled: (field) => field.disabled
        },
        syncConfigTriggers: {
          disabled: 1
        }
      },
      /**
       * The config controls how the value of nested items are handled when a parent container gets or sets its
       * {@link Core.widget.Container#property-values}.
       *
       * The valid values for this config are:
       *  - `null` (the default) will include the values of this field's items if this field stores its own value.
       *  - `true` to always include the values of this field's items.
       *  - `false` to never include the values of this field's items.
       *  - `'nested'` to include the values of this field's items as a nested object under the field's `name`.
       *    This field's `value` is stored as the `'value'` property of that object.
       *  - Any other string is treated as the name of a property on this field. When truthy, the values of this
       *    field's items will be included.
       *  - A function can be supplied that must return a value given this field as its sole argument. If that
       *    value is truthy, this field's items will be included.
       *
       * @config {Boolean|String|Function}
       * @param {Core.widget.Field} field Field instance
       * @returns {Boolean}
       * @category Container
       */
      containValues: null,
      /**
       * Set this config to `true` to always display items horizontally along with this field. This assigns an
       * {@link Core.widget.layout.Box hbox} as the {@link Core.widget.Container#config-layout} to the
       * {@link #config-container}.
       *
       * Alternatively, set this config to `false` to wrap this field's items below. This assigns a
       * {@link Core.widget.layout.VBox} as the {@link Core.widget.Container#config-layout} to the
       * {@link #config-container}.
       *
       * This config defaults to `true` if there is exactly one item, and `false` otherwise.
       * @config {Boolean}
       * @category Container
       */
      inline: null,
      testConfig: {
        updatedClsDuration: 10
      },
      keyMap: {}
    };
  }
  static get delayable() {
    return {
      highlightChanged: "raf"
    };
  }
  doDestroy() {
    var _a2, _b, _c;
    const me = this, { triggers } = me, errorTip = me.isPainted && _Field.getSharedErrorTooltip(me.rootElement, true);
    (_a2 = me.inputListenerRemover) == null ? void 0 : _a2.call(me);
    (_b = me.keyListenerRemover) == null ? void 0 : _b.call(me);
    (_c = me.container) == null ? void 0 : _c.destroy();
    super.doDestroy();
    if (triggers) {
      for (const t of Object.values(triggers)) {
        t.destroy();
      }
    }
    if ((errorTip == null ? void 0 : errorTip.field) === me) {
      errorTip.hide();
    }
  }
  get childItems() {
    const { container, triggers } = this, ret = triggers ? Object.values(triggers) : [];
    return container ? [...ret, ...container.childItems] : ret;
  }
  get invalidValueError() {
    return "L{invalidValue}";
  }
  /**
   * A singleton error tooltip which activates on hover of invalid fields.
   * before show, it gets a reference to the field and interrogates its
   * active error list to display as the tip content.
   * @member {Core.widget.Tooltip}
   * @readonly
   */
  get errorTip() {
    return this.constructor.getSharedErrorTooltip(this.rootElement);
  }
  static getSharedErrorTooltip(rootElement, doNotCreate) {
    var _a2;
    let sharedErrorTooltip = (_a2 = rootElement.bryntum) == null ? void 0 : _a2.errorTooltip;
    if (!sharedErrorTooltip && !doNotCreate) {
      rootElement.bryntum = rootElement.bryntum || {};
      sharedErrorTooltip = new Tooltip({
        cls: "b-field-error-tip",
        forSelector: ".b-field.b-invalid .b-field-inner",
        align: {
          align: "l-r",
          monitorTargetMutation: true
        },
        scrollAction: "realign",
        trapFocus: false,
        rootElement,
        onBeforeShow() {
          const tip = this, field = Widget.fromElement(tip.activeTarget);
          if (field) {
            const errors = field.getErrors();
            if (errors) {
              tip.html = errors.join("<br>");
              tip.field = field;
              return true;
            }
          }
          return false;
        }
      });
      rootElement.bryntum.errorTooltip = sharedErrorTooltip;
    }
    return sharedErrorTooltip;
  }
  /**
   * A singleton error tooltip which activates on hover of invalid fields.
   * before show, it gets a reference to the field and interrogates its
   * active error list to display as the tip content.
   *
   * Please note: Not applicable when using widgets inside a shadow root
   * @member {Core.widget.Tooltip}
   * @readonly
   * @static
   */
  static get errorTip() {
    return this.getSharedErrorTooltip(document.body);
  }
  //endregion
  //region Event
  /**
   * Fired when the user types into this field.
   * @event input
   * @param {Core.widget.Field} source This field
   * @typings source -> {Core.widget.Field||any}
   * @param {String} value - This field's value
   * @typings value -> {String||Number||Boolean||any}
   * @param {Event} event - The triggering DOM event
   */
  /**
   * Fired when this field's value changes.
   * @event change
   * @param {Core.widget.Field} source - This Field
   * @typings source -> {Core.widget.Field||any}
   * @param {String} value - This field's value
   * @typings value -> {String||Number||Boolean||any}
   * @param {String} oldValue - This field's previous value
   * @typings oldValue -> {String||Number||Boolean||any}
   * @param {Boolean} valid - True if this field is in a valid state
   * @param {Event} event - The triggering DOM event if any
   * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
   *
   * @typings checked -> {Boolean} // Used for compatibility with Checkbox event
   */
  /**
   * User performed default action (typed into this field).
   * @event action
   * @param {Core.widget.Field} source - This Field
   * @typings source -> {Core.widget.Field||any}
   * @param {String} value - This field's value
   * @typings value -> {String||Number||Boolean||any}
   * @param {String} oldValue - This field's previous value
   * @typings oldValue -> {String||Number||Boolean||any}
   * @param {Boolean} valid - True if this field is in a valid state
   * @param {Event} event - The triggering DOM event if any
   * @param {Core.data.Model} record Selected record. Available for fields with records selection functionality
   * @param {Core.data.Model[]} records Selected records as an array. Available for fields with records selection functionality
   * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
   *
   * @typings checked -> {Boolean} // Used for compatibility with Checkbox event
   */
  /**
   * Fired when this field is {@link #function-clear cleared}.
   *
   * This will be triggered when a user clicks this field's clear {@link #property-triggers trigger}
   * @event clear
   * @param {Core.widget.Field} source - This Field
   * @typings source -> {Core.widget.Field||any}
   */
  /**
   * User clicked one of this field's {@link #property-triggers}
   * @event trigger
   * @param {Core.widget.Field} source This field
   * @typings source -> {Core.widget.Field||any}
   * @param {Core.widget.Widget} trigger The trigger activated by click or touch tap.
   */
  //endregion
  //region Init
  construct(config) {
    super.construct(config);
    const me = this;
    if (me.keyStrokeChangeDelay) {
      me.changeOnKeyStroke = me.buffer(me.internalOnChange, me.keyStrokeChangeDelay);
    }
  }
  // Adding triggers keymap to field keymap with prefix 'triggerName.';
  changeKeyMap(keyMap) {
    var _a2;
    const me = this;
    let mergedKeyMap = {};
    if (keyMap) {
      if (!me._fieldKeyMap) {
        me._fieldKeyMap = keyMap;
        ObjectHelper.assign(mergedKeyMap, keyMap);
      } else {
        ObjectHelper.assign(mergedKeyMap, me._fieldKeyMap);
      }
    }
    for (const triggerName in me.triggers) {
      if ((_a2 = me.triggers[triggerName]) == null ? void 0 : _a2.keyMap) {
        mergedKeyMap = me.mergeKeyMaps(mergedKeyMap, me.triggers[triggerName].keyMap, triggerName);
      }
    }
    return mergedKeyMap;
  }
  get keyMapSubComponents() {
    return this.triggers;
  }
  onFocusIn(e) {
    const me = this;
    me.valueOnFocus = ObjectHelper.clone(me.value);
    me.validOnFocus = !(me.errors && Object.keys(me.errors).length);
    super.onFocusIn(e);
    me.focusing = true;
    me.syncInvalid();
    me.focusing = false;
  }
  onFocusOut(e) {
    super.onFocusOut(e);
    this.syncRequired();
    this.onEditComplete();
  }
  /**
   * Template function which may be implemented by subclasses to synchronize
   * input state and validity state upon completion of the edit.
   * @internal
   */
  onEditComplete() {
  }
  get rootUiClass() {
    return _Field;
  }
  compose() {
    this.getConfig("clearable");
    const me = this, { container, innerElements, label, labels, labelCls, readOnly, triggers } = me, triggerInstances = ObjectHelper.values(triggers, (k, v) => !v), startTriggers = triggerInstances.filter((t) => t.align === "start").sort(byWeight), endTriggers = triggerInstances.filter((t) => t.align !== "start").sort(byWeightReverse), setupLabel = me.setupLabel.bind(me), innerChildren = [
      ...startTriggers.map((t) => t.element),
      ...innerElements,
      ...endTriggers.map((t) => t.element)
    ];
    return {
      class: {
        "b-has-start-trigger": startTriggers.length,
        "b-no-input": !innerElements.length,
        "b-readonly": readOnly,
        "b-field-container": Boolean(container),
        "b-field-container-inline": container == null ? void 0 : container.inline
      },
      children: [
        ...(labels || emptyArray8).filter((t) => t && t.align !== "end").map(setupLabel),
        (label || null) && setupLabel({
          reference: "labelElement",
          class: `b-label b-align-start ${labelCls || ""}`,
          html: label
        }),
        innerChildren.length ? {
          class: "b-field-inner",
          reference: "inputWrap",
          children: innerChildren
        } : null,
        ...(labels || emptyArray8).filter((t) => (t == null ? void 0 : t.align) === "end").map(setupLabel),
        ...container ? [{
          reference: "containerWrapElement",
          children: [container.element],
          class: {
            "b-field-container-wrap": 1
          }
        }] : emptyArray8
      ]
    };
  }
  updateElement(element, was) {
    var _a2;
    const me = this, value = me.initialConfig.value, { input } = me;
    super.updateElement(element, was);
    if (value != null) {
      me.value = value;
    }
    me.syncEmpty();
    me.updateInputReadOnly(me.inputReadOnly);
    me.syncInvalid();
    const keyEventElement = input || me.focusElement;
    (_a2 = me.keyListenerRemover) == null ? void 0 : _a2.call(me);
    me.keyListenerRemover = keyEventElement && EventHelper.on({
      element: keyEventElement,
      thisObj: me,
      keydown: "internalOnKeyEvent",
      keypress: "internalOnKeyEvent",
      keyup: "internalOnKeyEvent"
    });
  }
  // Subclasses may implement this.
  // Needed because Checkbox produces an array of two elements as its innerElements
  get innerElements() {
    return [this.inputElement];
  }
  /**
   * The input element at the heart if this field
   * @member {HTMLElement} input
   */
  get inputElement() {
    const { attributes, inputAttributes, id, inputCls, inputType, name } = this, domConfig = ObjectHelper.assign({
      reference: "input",
      tag: "input",
      type: inputType,
      name: name || id,
      id: `${id}-input`,
      retainElement: true
      // allow the input to be transplanted as in combo/chipView
    }, inputAttributes);
    if (inputCls) {
      domConfig.class = inputCls;
    }
    for (let key, value, i = attributes.length; i-- > 0; ) {
      key = attributes[i];
      value = this[key];
      if (value != null) {
        domConfig[key] = value;
      }
    }
    return domConfig;
  }
  //endregion
  //region Focus & select
  get caretPos() {
    return this.textSelection[0];
  }
  set caretPos(value) {
    this.textSelection = value;
  }
  get focusElement() {
    return this.input;
  }
  get textSelection() {
    var _a2;
    const input = this.input;
    let ret;
    try {
      ret = [input.selectionStart, input.selectionEnd, input.selectionDirection];
    } catch (e) {
      ret = ((_a2 = input.value) == null ? void 0 : _a2.length) || 0;
      ret = [ret, ret];
    }
    return ret;
  }
  set textSelection(value) {
    if (typeof value === "number") {
      this.select(value, value);
    } else {
      this.select(...value);
    }
  }
  get hasTextSelection() {
    const [selectionStart, selectionEnd] = this.textSelection;
    return selectionStart && selectionEnd - selectionStart > 0;
  }
  /**
   * Returns the input value for this field's input element that will be present if
   * the event carrying the given text is allowed to proceed.
   * @param {String} text
   * @returns {String}
   * @private
   */
  getAfterValue(text) {
    const [begin, end] = this.textSelection, value = this.input.value;
    return `${value.substr(0, begin)}${text}${value.substr(end || begin)}`;
  }
  /**
   * Selects the field contents. Optionally may be passed a start and end.
   * @param {Number} [start] The start index from which to select the input.
   * @param {Number} [end] The index at which to end the selection of the input.
   */
  select(start, end) {
    const input = this.focusElement;
    if (input.value.length) {
      if (arguments.length === 0) {
        this.selectAll();
        return;
      }
      if (!this.supportsTextSelection) {
        return;
      }
      input.setSelectionRange(start, end);
    }
  }
  moveCaretToEnd() {
    const input = this.input;
    if (input.createTextRange) {
      const range = input.createTextRange();
      range.collapse(false);
      range.select();
    } else if (this.supportsTextSelection) {
      this.select(input.value.length, input.value.length);
    }
  }
  selectAll() {
    this.focusElement.select();
  }
  // called on value changes to update styling of empty vs non-empty field
  syncEmpty() {
    var _a2;
    const { isEmptyInput, isEmpty, element } = this, clear = (_a2 = this.triggers) == null ? void 0 : _a2.clear, empty2 = isEmptyInput && isEmpty;
    if (element) {
      if (clear) {
        clear[empty2 ? "hide" : "show"]();
      }
      element.classList.toggle("b-empty", empty2);
    }
  }
  updateHint() {
    this.syncHint();
  }
  updateHintHtml() {
    this.syncHint();
  }
  syncHint() {
    const me = this, { input, hint, hintHtml } = me, parent = input == null ? void 0 : input.parentElement;
    if (input) {
      let hintValue = hintHtml || hint;
      const hintElement = me.hintElement || hintValue && (me.hintElement = DomHelper.createElement({
        parent,
        className: "b-field-hint",
        nextSibling: input.nextSibling,
        children: [{
          className: "b-field-hint-content"
        }]
      }));
      if (hintElement) {
        if (typeof hintValue === "function") {
          hintValue = hintValue({ source: me, value: me.value });
        }
        hintElement.firstChild[hintHtml ? "innerHTML" : "textContent"] = hintValue || "";
      }
      me.element.classList[hintValue ? "remove" : "add"]("b-field-no-hint");
    }
  }
  syncInvalid() {
    const me = this, { isPainted } = me;
    me.updatingInvalid = true;
    if (isPainted) {
      const { isValid, element, inputWrap } = me;
      element.classList[isValid ? "remove" : "add"]("b-invalid");
      if (isValid) {
        const errorTip = me.constructor.getSharedErrorTooltip(me.rootElement, true);
        if ((errorTip == null ? void 0 : errorTip.isVisible) && errorTip.field === me) {
          errorTip.hide();
        }
      } else {
        const errorTip = me.errorTip;
        if (errorTip && (me.containsFocus || me.isVisible && inputWrap.contains(Tooltip.currentOverElement))) {
          if (errorTip.activeTarget === inputWrap && errorTip.isVisible) {
            errorTip.onBeforeShow();
          } else {
            errorTip.activeTarget = inputWrap;
            errorTip.showBy(inputWrap);
          }
        }
      }
    }
    me.updatingInvalid = false;
  }
  //endregion
  //region Getters/setters
  updateEditable() {
    this.syncInputReadOnly();
  }
  syncInputReadOnly() {
    this.getConfig("readOnly");
    this.inputReadOnly = this._readOnly || this.editable === false;
  }
  updateInputReadOnly(readOnly) {
    const me = this, { input, inputListenerRemover } = me;
    if (input) {
      input.readOnly = readOnly ? "readOnly" : null;
      if (readOnly) {
        me.inputListenerRemover = inputListenerRemover == null ? void 0 : inputListenerRemover();
      } else if (!inputListenerRemover) {
        me.inputListenerRemover = EventHelper.on({
          element: input,
          thisObj: me,
          focus: "internalOnInputFocus",
          change: "internalOnChange",
          input: "internalOnInput"
        });
      }
    }
  }
  changeReadOnly(value) {
    return Boolean(value);
  }
  updateReadOnly(readOnly) {
    this.syncInputReadOnly();
  }
  updateClearable(clearable) {
    const me = this;
    me.getConfig("triggers");
    me.triggers = {
      clear: clearable && ObjectHelper.assign({
        cls: "b-icon-remove",
        weight: 1e3,
        key: "Shift+backspace",
        handler() {
          me._isUserAction = true;
          me.clear(...arguments);
          me._isUserAction = false;
        }
      }, clearable) || null
    };
  }
  changeTriggers(triggers, was) {
    const me = this, manager = me.$triggers || (me.$triggers = new DynamicObject({
      configName: "triggers",
      factory: _Field.Trigger,
      inferType: false,
      // the name of a trigger in the triggers object is not its type
      owner: me,
      created(instance) {
        FunctionHelper.after(instance, "onConfigChange", (ret, { name }) => {
          if (triggerConfigs[name]) {
            me.onConfigChange({
              name: "triggers",
              value: manager.target
            });
          }
        });
      },
      setup(config, name) {
        config.reference = config.ref = name;
        config.parent = me;
      }
    }));
    if (me.stepTriggers === false && (triggers.back || triggers.forward)) {
      triggers = ObjectHelper.assign({}, triggers);
      delete triggers.back;
      delete triggers.forward;
    }
    manager.update(triggers);
    if (me.element) {
      me.keyMap = me.keyMap;
    }
    if (!was) {
      return manager.target;
    }
  }
  updateInputWidth(newValue) {
    this.input.style.width = DomHelper.setLength(newValue);
    this.element.classList.add("b-has-width");
  }
  updateInputAlign(newValue) {
    this.input.style.textAlign = newValue;
  }
  /**
   * Returns true if the field value is valid
   * @type {Boolean}
   * @readonly
   */
  get isValid() {
    const me = this;
    if (!me.disabled) {
      me.syncRequired();
      if (me.errors && Object.keys(me.errors).length) {
        return false;
      }
      const validity = me.validity;
      if (validity) {
        return validity.valid;
      }
    }
    return true;
  }
  /**
   * Returns `true` if this field is empty. That is, if it would violate the {@link #config-required}
   * setting.
   *
   * This may have different definitions in subclasses from simple text fields.
   * @type {Boolean}
   * @readonly
   */
  get isEmpty() {
    return this.value == null || this.value === "";
  }
  /**
   * Returns true if the field's input is empty
   * @type {Boolean}
   * @readonly
   */
  get isEmptyInput() {
    return !this.input || this.input.value == null || this.input.value === "";
  }
  /**
   * Returns the DOM `ValidityState` for this widget's input element, or `null` if there
   * isn't one.
   * @returns {ValidityState}
   * @private
   */
  get validity() {
    const input = this.input;
    return input == null ? void 0 : input.validity;
  }
  // Called by Editor.js, for overriding in subclasses that require async setting of values (custom editors in React)
  async setValue(value) {
    this.value = value;
  }
  changeValue(value, was) {
    if (value == null) {
      value = this.nullValue;
    }
    if (this.hasChanged(was, value)) {
      return value;
    }
    if (value === "") {
      this.syncRequired();
    }
    return was;
  }
  updateValue(value, oldValue) {
    const me = this;
    if (!me.isConfiguring) {
      me.syncRequired();
      if (!me.inputting) {
        me.triggerChange();
      }
    }
    if (!me.inputting) {
      me._lastValue = value;
    }
    me.syncInputFieldValue();
    if (me.overflowTwin && !me._overflowTwinSync) {
      me._overflowTwinSync = true;
      me.overflowTwin.value = value;
      me._overflowTwinSync = false;
    }
  }
  /**
   * Compares this field's value with its previous value. May be overridden in subclasses
   * which have more complex value types. See, for example, {@link Core.widget.DurationField}.
   * @param {*} oldValue
   * @param {*} newValue
   * @private
   */
  hasChanged(oldValue, newValue) {
    return newValue !== oldValue;
  }
  /**
   * Called by the base Field class's `set value` to sync the state of the UI with the field's value.
   *
   * Relies upon the class implementation of `get inputValue` to return a string representation of
   * the value for user consumption and editing.
   * @private
   */
  syncInputFieldValue(skipHighlight = false) {
    const me = this, { input, parent, inputValueAttr, inputValue } = me;
    if (input && !me.inputting && input[inputValueAttr] !== inputValue) {
      input[inputValueAttr] = inputValue;
      if (!me.isConfiguring && !me.containsFocus && me.highlightExternalChange) {
        input.classList.remove("b-field-updated");
        me.clearTimeout("removeUpdatedCls");
        if (parent) {
          const { assigningValues } = parent;
          if (assigningValues === true || (assigningValues == null ? void 0 : assigningValues.highlight) === false) {
            skipHighlight = true;
          }
        }
        if (!skipHighlight) {
          me.highlightChanged();
        }
      }
    }
    me.syncEmpty();
    me.syncInvalid();
  }
  highlightChanged() {
    this.input.classList.add("b-field-updated");
    this.setTimeout("removeUpdatedCls", this.updatedClsDuration);
  }
  removeUpdatedCls() {
    this.input.classList.remove("b-field-updated");
  }
  /**
   * A String representation of the value of this field for {@link #function-syncInputFieldValue} to use
   * as the input element's value.
   *
   * Subclasses may override this to create string representations.
   *
   * For example, {@link Core.widget.DateField}'s implementation will format the field date
   * value according to its configured {@link Core.widget.DateField#config-format}. And {@link Core.widget.Combo}'s
   * implementation will return the {@link Core.widget.Combo#config-displayField} of the selected record.
   * @internal
   * @readOnly
   */
  get inputValue() {
    return this.value == null ? "" : this.value;
  }
  get inputValueAttr() {
    return "value";
  }
  get supportsTextSelection() {
    const input = this.focusElement;
    return input && (input.tagName.toLowerCase() === "textarea" || input.type && /text|search|password|tel|url/.test(input.type));
  }
  //endregion
  //region Events
  internalOnInputFocus() {
    if (this.autoSelect) {
      this.selectAll();
    }
  }
  /**
   * Trigger event when fields input changes
   * @fires change
   * @private
   */
  internalOnChange(event) {
    const me = this;
    if (me.hasChanged(me._lastValue, me.value) && me.isValid) {
      me.triggerChange(event, true);
      me._lastValue = me.value;
    }
  }
  triggerChange(event, userAction = Boolean(this._isUserAction)) {
    const me = this, {
      value,
      _lastValue: oldValue,
      isValid: valid
    } = me;
    me.syncHint();
    me.triggerFieldChange({ value, oldValue, event, userAction, valid });
    if (me.defaultAction === "change") {
      me.trigger("action", { value, oldValue, event, userAction, valid });
    }
  }
  fetchInputValue() {
    this.value = this.input[this.inputValueAttr];
  }
  /**
   * Trigger event when user inputs into field
   * @fires input
   * @param event
   * @private
   */
  internalOnInput(event) {
    var _a2;
    const me = this;
    if (!me.validateOnInput) {
      me.errorTip.hide();
    }
    me.inputting = true;
    me.fetchInputValue();
    me.inputting = false;
    me.trigger("input", { value: me.value, event });
    (_a2 = me.changeOnKeyStroke) == null ? void 0 : _a2.call(me, event);
  }
  /**
   * Returns `true` if the {@link #property-input} field needs to be synced with the internal
   * {@link #property-value} of this field.
   *
   * May be overridden in subclasses where this is more complex such as multiSelect Combo
   * with a `ChipView` where the input area does not reflect the field's value.
   * @private
   */
  get needsInputSync() {
    var _a2;
    return this.input[this.inputValueAttr] !== String((_a2 = this.inputValue) != null ? _a2 : "");
  }
  internalOnKeyEvent(event) {
    const me = this, { value } = me;
    let stopEvent = false;
    if (event.type === "keydown") {
      if (event.key === "Escape" && !(me.readOnly || me.disabled)) {
        const wasValid = me.isValid, initialValue = "initialValue" in me ? me.initialValue : me.valueOnFocus, valueChanged = me.hasChanged(initialValue, value), { needsInputSync } = me;
        if (me.revertOnEscape && (!wasValid || valueChanged || needsInputSync)) {
          if (valueChanged) {
            me.value = initialValue;
          }
          if (needsInputSync) {
            me.syncInputFieldValue(true);
          }
          me.clearError();
          stopEvent = (valueChanged || needsInputSync) && me.isValid || wasValid !== me.validOnFocus;
        }
      }
    }
    if (!me.isDestroyed) {
      if (stopEvent) {
        event.stopImmediatePropagation();
      }
      me.trigger(event.type, { event });
    }
  }
  /**
   * Clears the value of this Field, and triggers the {@link #event-clear} event.
   */
  clear(event) {
    const me = this, { value } = me;
    if (value !== me.nullValue || me.input.value.length > 0) {
      me.value = me.nullValue;
      me.clearError();
      me.syncInvalid();
      me.trigger("clear", { event });
    }
  }
  /**
   * Called when disabled state is changed.
   * Used to add or remove 'b-invalid' class for the invalid field based on current disabled state.
   * @private
   */
  onDisabled() {
    this.syncInvalid();
  }
  //endregion
  //region Error
  syncRequired() {
    var _a2;
    const me = this;
    if (!me.isConfiguring && !me.focusing && me.required && me.isEmpty && !((_a2 = me.parent) == null ? void 0 : _a2.isSettingValues)) {
      me.setError("L{fieldRequired}", me.updatingInvalid);
    } else {
      me.clearError("L{fieldRequired}", me.updatingInvalid);
    }
  }
  /**
   * Adds an error message to the list of errors on this field.
   * By default, the field's valid/invalid state is updated; pass
   * `false` as the second parameter to disable that if multiple
   * changes are being made to the error state.
   *
   * Note, that you need to manually remove the added error with the {@link #function-clearError} method
   * to "release" the normal data update process (invalid data won't be synced). You can also use the 3rd
   * argument of this method to automatically remove the error upon the next user interaction.
   *
   * @param {String} error A locale string, or message to use as an error message.
   * @param {Boolean} [silent=false] Pass as `true` to skip updating the field's valid/invalid state.
   * @param {Boolean} [temporary=false] Pass as `true` to remove the error upon the next user interaction.
   */
  setError(error, silent, temporary) {
    const me = this;
    (me.errors || (me.errors = {}))[me.optionalL(error)] = 1;
    if (!silent) {
      me.syncInvalid();
    }
    if (temporary) {
      const clearError = () => {
        me.clearError(error);
        remover();
      }, remover = me.ion({
        keydown: clearError,
        focusOut: clearError
      });
    }
  }
  /**
   * Removes an error message from the list of errors on this field.
   *
   * By default, the field's valid/invalid state is updated; pass `false` as the second parameter to disable that if
   * multiple changes are being made to the error state.
   *
   * @param {String} [error] A locale string, or message to remove. If not passed, all errors are cleared.
   * @param {Boolean} [silent=false] Pass as `true` to skip updating the field's valid/invalid state.
   */
  clearError(error, silent) {
    const me = this;
    if (me.errors) {
      if (error) {
        delete this.errors[this.optionalL(error)];
      } else {
        me.errors = {};
      }
    }
    if (!silent) {
      me.syncInvalid();
    }
  }
  /**
   * Returns an array of error messages as set by {@link #function-setError}, or
   * `undefined` if there are currently no errors.
   * @returns {String[]} The errors for this field, or `undefined` if there are no errors.
   */
  getErrors() {
    const me = this;
    if (!me.isValid) {
      const validity = me.validity, stateName = ObjectHelper.keys(validity).find((key) => key !== "valid" && key !== "customError" && validity[key]), errorKeys = me.errors && Object.keys(me.errors);
      let errors;
      if (errorKeys == null ? void 0 : errorKeys.length) {
        errors = errorKeys;
      } else if (validity.customError) {
        errors = [me.input.validationMessage];
      } else if (stateName) {
        errors = [me.L(stateName, {
          // In case min/max limits are present they will be used in the translation
          min: me.min,
          max: me.max
        })];
      } else {
        errors = [me.L(me.invalidValueError)];
      }
      if ((errors == null ? void 0 : errors.length) > 0) {
        return errors;
      }
    }
  }
  //endregion
  createOverflowTwin(overrides) {
    const me = this, overflowTwin = super.createOverflowTwin(overrides);
    overflowTwin.ion({
      change({ value }) {
        me._overflowTwinSync = true;
        me.value = value;
        me._overflowTwinSync = false;
      }
    });
    return overflowTwin;
  }
  //region Container
  get containerCollapsed() {
    var _a2;
    return (_a2 = this.container) == null ? void 0 : _a2.collapsed;
  }
  set containerCollapsed(collapsed) {
    const { container } = this;
    if (container) {
      container.collapsed = collapsed;
    }
  }
  afterSyncChildConfigs(container) {
  }
  changeContainer(config, existing) {
    if (config && (Array.isArray(config) || !("type" in config || "items" in config))) {
      config = {
        items: config
      };
    }
    const me = this, defaults = config && ObjectHelper.merge({
      owner: me,
      layout: "box"
    }, me.containerDefaults), container = Widget.reconfigure(existing, config, {
      owner: me,
      defaults
    });
    if (container) {
      container.autoLayout = (defaults == null ? void 0 : defaults.layout) === "box";
      if (container === existing) {
        container.syncContainer();
        return;
      }
    }
    return container;
  }
  onConfigChange(info) {
    var _a2, _b;
    super.onConfigChange(info);
    if ((_b = (_a2 = this.container) == null ? void 0 : _a2.syncConfigTriggers) == null ? void 0 : _b[info.name]) {
      this.container.syncChildConfigs();
    }
  }
  assignValue(values, options) {
    const me = this, { container, containValues } = me, valueName = me.getValueName(options), storedValue = values && valueName in values;
    if (container && containValues !== false) {
      if (values && containValues === "nested") {
        if (storedValue) {
          values = ObjectHelper.clone(values[valueName]);
          super.assignValue({
            // Removing 'value:true' from nested values is a trick done by checkbox (could be done by
            // any toggle-like thing) so just put true back in:
            [valueName]: values && !("value" in values) || values.value
          }, options);
          if (values) {
            delete values.value;
          }
          container.assignValue(values, options);
        }
      } else {
        super.assignValue(values, options);
        container.assignValue(values, options);
      }
    } else {
      super.assignValue(values, options);
    }
  }
  gatherValue(values) {
    super.gatherValue(values);
    this.gatherValues(values);
  }
  gatherValues(values, storedValue) {
    const me = this, { container, containValues, valueName } = me, cvt = typeof containValues;
    storedValue = storedValue != null ? storedValue : valueName in values;
    if (container && containValues !== false) {
      if (containValues === "nested") {
        if (storedValue) {
          values[valueName] = {
            value: values[valueName],
            ...container.values
          };
        }
      } else if (containValues === true || containValues == null && storedValue || cvt === "string" && me[containValues] || cvt === "function" && containValues(me)) {
        container.gatherValues(values);
      }
    }
  }
  updateContainer(container, was) {
    was && this.detachListeners(was.id);
    if (container) {
      if (!container.rendered) {
        container.render();
      }
      container.syncContainer();
      container.syncChildConfigs();
    }
  }
  //endregion
};
//region Config
__publicField(_Field, "$name", "Field");
__publicField(_Field, "type", "field");
var Field = _Field;
Field.Trigger = class FieldTrigger extends Widget {
  static get $name() {
    return "FieldTrigger";
  }
  static get factoryable() {
    return {
      defaultType: Field.Trigger,
      extends: null
    };
  }
  // Factoryable type name
  static get type() {
    return "trigger";
  }
  // Align is a simple string at this level
  static get configurable() {
    return {
      align: null,
      weight: null,
      role: void 0
    };
  }
  get field() {
    return this.parent;
  }
  construct() {
    super.construct(...arguments);
    if (this.key) {
      this.keyMap = {
        [this.key]: "onClick"
      };
    }
  }
  compose() {
    return {
      "aria-hidden": true,
      class: {
        [`b-align-${this.align || "end"}`]: 1,
        "b-icon": 1
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        click: "onClick",
        mousedown: "onMousedown"
      }
    };
  }
  changeAlign(align) {
    return align;
  }
  onClick(e) {
    const me = this, { field } = me;
    if (!(field.disabled || field.readOnly)) {
      if (e.key) {
        e.preventDefault();
      }
      if (field.trigger("trigger", { trigger: me }) !== false && me.handler) {
        field.callback(me.handler, field, [e, me]);
      }
    }
  }
  onMousedown(e) {
    const field = this.field, isKeyEvent = "key" in e;
    if (!isKeyEvent && DomHelper.isTouchEvent) {
      if (field.editable) {
        field.editable = false;
        field.setTimeout(() => field.editable = true, 500);
      }
    }
    e.preventDefault();
    if (DomHelper.getActiveElement(field.input) !== field.input) {
      field.focus();
    }
  }
};
Field.SpinTrigger = class SpinTrigger extends Field.Trigger {
  static get $name() {
    return "SpinTrigger";
  }
  // Factoryable type name
  static get type() {
    return "spintrigger";
  }
  static get configurable() {
    return {
      repeat: {
        $config: ["nullify"],
        value: true
      }
    };
  }
  compose() {
    return {
      children: {
        upButton: {
          class: {
            "b-icon": 1,
            "b-spin-up": 1
          }
        },
        downButton: {
          class: {
            "b-icon": 1,
            "b-spin-down": 1
          }
        }
      }
    };
  }
  updateRepeat(repeat) {
    var _a2;
    (_a2 = this.clickRepeater) == null ? void 0 : _a2.destroy();
    this.clickRepeater = repeat ? ClickRepeater.new({
      element: this.element
    }, repeat) : null;
  }
  onClick(e) {
    const me = this, { field } = me;
    if (!(field.disabled || field.readOnly)) {
      if (e.target === me.upButton) {
        field.doSpinUp(e.shiftKey);
      } else if (e.target === me.downButton) {
        field.doSpinDown(e.shiftKey);
      }
    }
  }
};
Field.Trigger.initClass();
Field.SpinTrigger.initClass();
Widget.register(Field.Trigger, "trigger");
Widget.register(Field.SpinTrigger, "spintrigger");
Field._$name = "Field";

// ../Core/lib/Core/widget/TextField.js
var TextField = class extends Field {
  static get configurable() {
    return {
      /**
       * The tab index of the input field
       * @config {Number} tabIndex
       * @category Input element
       */
      /**
       * The min number of characters for the input field
       * @config {Number} minLength
       * @category Field
       */
      /**
       * The max number of characters for the input field
       * @config {Number} maxLength
       * @category Field
       */
      nullValue: ""
    };
  }
  construct(config) {
    if ((config == null ? void 0 : config.inputType) === "hidden") {
      config.hidden = true;
    }
    super.construct(...arguments);
  }
};
__publicField(TextField, "$name", "TextField");
__publicField(TextField, "type", "textfield");
__publicField(TextField, "alias", "text");
TextField.initClass();
TextField._$name = "TextField";

// ../Core/lib/Core/widget/PickerField.js
var PickerField = class extends TextField {
  static get configurable() {
    return {
      /**
       * User can edit text in text field (otherwise only pick from attached picker)
       * @config {Boolean}
       * @default
       */
      editable: true,
      /**
       * The name of the element property to which the picker should size and align itself.
       * @config {String}
       * @default element
       */
      pickerAlignElement: "inputWrap",
      // Does not get set, but prevents PickerFields inheriting value:'' from Field.
      value: null,
      triggers: {
        expand: {
          cls: "bars"
        }
      },
      /**
       * By default PickerField's picker is transient, and will {@link #function-hidePicker} when the user clicks or
       * taps outside or when focus moves outside picker.
       *
       * Configure as `false` to make picker non-transient.
       * @config {Boolean}
       * @default
       * @deprecated This will be removed in 6.0
       */
      autoClose: true,
      /**
       * Configure as `true` to have the picker expand upon focus enter.
       * @config {Boolean}
       */
      autoExpand: null,
      /**
       * Configuration object for the {@link Core.widget.List picker} on initialization. Returns the
       * {@link Core.widget.List picker} instance at runtime.
       * A config object which is merged into the generated picker configuration on initialization
       * to allow specific use cases to override behaviour.
       * For example:
       *
       * ```javascript
       *     picker: {
       *         align: {
       *             anchor: true
       *         }
       *     }
       * ```
       *
       * Returns the picker instance at runtime.
       *
       * @prp {Core.widget.Widget}
       * @accepts {Object}
       * @readonly
       */
      picker: {
        value: {
          floating: true
        },
        $config: ["lazy", "nullify"]
      },
      inputType: "text",
      // We need to realign the picker if we resize (eg a multiSelect Combo's ChipView wrapping)
      monitorResize: true,
      nullValue: null
    };
  }
  //endregion
  //region Init & destroy
  doDestroy() {
    var _a2;
    (_a2 = this.globalTapListener) == null ? void 0 : _a2.call(this);
    super.doDestroy();
  }
  changeEditable(editable) {
    if (BrowserHelper.isMobile && this.initialConfig.editable !== true) {
      editable = false;
    }
    return editable;
  }
  updateAutoClose(autoClose) {
    !autoClose && VersionHelper.deprecate("Core", "6.0.0", "PickerField.autoClose is no longer supported");
  }
  updateEditable(editable) {
    var _a2;
    const me = this, {
      element,
      ariaElement,
      nonEditableClickTarget
    } = me, { expand } = me.triggers, narrow = globalThis.matchMedia("(max-width: 410px)").matches;
    super.updateEditable(...arguments);
    element.classList.toggle("b-not-editable", !editable);
    if (editable === false) {
      if (BrowserHelper.isMobile && narrow) {
        expand == null ? void 0 : expand.hide();
      }
      ariaElement.removeAttribute("aria-autocomplete");
      (_a2 = me.globalTapListener) == null ? void 0 : _a2.call(me);
      EventHelper.on({
        element: nonEditableClickTarget,
        click: (e) => {
          const target = nonEditableClickTarget.getRootNode().elementFromPoint(e.clientX, e.clientY);
          if (e.target === nonEditableClickTarget && target === nonEditableClickTarget) {
            me.onTriggerClick(e);
          }
        },
        thisObj: me
      });
    } else {
      expand == null ? void 0 : expand.show();
      ariaElement.setAttribute("aria-autocomplete", "list");
      me.globalTapListener = GlobalEvents_default.ion({
        globaltap: "showKeyboard",
        thisObj: me
      });
    }
  }
  get nonEditableClickTarget() {
    return this.input;
  }
  updateElement(element, oldElement) {
    var _a2;
    const result = super.updateElement(element, oldElement), picker = this.peekConfig("picker"), role = picker ? picker.isWidget ? picker.role : (_a2 = this.constructor.resolveType(picker.type)) == null ? void 0 : _a2.$meta.config.role : false;
    DomHelper.setAttributes(this.ariaElement, {
      "aria-expanded": false
    });
    this.ariaHasPopup = role;
    return result;
  }
  //endregion
  //region Picker
  changePicker(picker, oldPicker) {
    throw new Error("changePicker(oldPicker, newPicker) must be implemented in PickerField subclass implementations");
  }
  /**
   * Iterate over all widgets owned by this widget and any descendants.
   *
   * *Note*: Due to this method aborting when the function returns `false`, beware of using short form arrow
   * functions. If the expression executed evaluates to `false`, iteration will terminate.
   *
   * _Due to the {@link #config-picker} config being a lazy config and only being converted to be a
   * `List` instance just before it's shown, the picker will not be part of the iteration before
   * it has been shown once_.
   * @function eachWidget
   * @param {Function} fn A function to execute upon all descendant widgets.
   * Iteration terminates if this function returns `false`.
   * @param {Boolean} [deep=true] Pass as `false` to only consider immediate child widgets.
   * @returns {Boolean} Returns `true` if iteration was not aborted by a step returning `false`
   */
  get childItems() {
    const result = super.childItems;
    if (this._picker) {
      result.push(this.picker);
    }
    return result;
  }
  //endregion
  //region Events
  /**
   * Check if field value is valid
   * @internal
   */
  onEditComplete() {
    super.onEditComplete();
    this.autoClosePicker();
  }
  onElementResize(resizedElement) {
    const me = this;
    if (me.pickerVisible) {
      me.picker.requestAnimationFrame(me.picker.realign, null, me.picker);
    }
    super.onElementResize(resizedElement);
  }
  /**
   * Allows using arrow keys to open/close list. Relays other keypresses to list if open.
   * @private
   */
  internalOnKeyEvent(event) {
    const me = this;
    let callSuper = true;
    if (event.type === "keydown" && !me.disabled && !event.shiftKey && !event.ctrlKey) {
      if (me.pickerVisible) {
        const { picker } = me;
        if (event.key === "Escape") {
          event.preventDefault();
          event.stopImmediatePropagation();
          me.hidePicker();
          callSuper = false;
        } else if (picker.onInternalKeyDown) {
          picker.onInternalKeyDown(event);
        } else if (event.key === "ArrowDown") {
          if (picker.focusable) {
            picker.focus();
          }
        }
      } else if (event.key === "ArrowDown") {
        event.stopImmediatePropagation();
        event.preventDefault();
        me.onTriggerClick(event);
      }
    }
    if (callSuper) {
      super.internalOnKeyEvent(event);
    }
  }
  onFocusIn(e) {
    const me = this;
    super.onFocusIn(e);
    if (me.autoExpand) {
      me.minChars = 0;
      me.onTriggerClick(e);
      me.ignoreTriggerClick = true;
      me.setTimeout(() => me.ignoreTriggerClick = false, 100);
    }
  }
  /**
   * User clicked trigger icon, toggle list.
   * @private
   */
  onTriggerClick(event) {
    if (!this.disabled) {
      this.togglePicker("key" in event);
    }
  }
  /**
   * User clicked on an editable input field. If it's a touch event
   * ensure that the keyboard is shown.
   * @private
   */
  showKeyboard({ event }) {
    const input = this.input;
    if (DomHelper.isTouchEvent && DomHelper.getActiveElement(input) === input && event.target === input) {
      GlobalEvents_default.suspendFocusEvents();
      input.blur();
      input.focus();
      GlobalEvents_default.resumeFocusEvents();
    }
  }
  //endregion
  //region Toggle picker
  /**
   * Toggle the {@link #property-picker} visibility
   * @privateparam {Boolean} [focus] Pass `true` to focus the picker when it gets shown.
   */
  togglePicker(focus) {
    if (this.pickerVisible) {
      this.hidePicker();
    } else {
      this.showPicker(focus);
    }
  }
  /**
   * Show the {@link #property-picker}
   * @privateparam {Boolean} [focus] Pass `true` to focus the picker when it gets shown.
   */
  showPicker(focus) {
    const me = this, { picker } = me;
    if (!me.pickerHideShowListenersAdded) {
      picker.ion({
        show: "onPickerShow",
        hide: "onPickerHide",
        thisObj: me
      });
      me.pickerHideShowListenersAdded = true;
    }
    DomHelper.setAttributes(me.ariaElement, {
      "aria-controls": picker.id,
      "aria-expanded": true
    });
    picker.autoClose = me.autoClose;
    picker.show();
    if (picker.isVisible) {
      if (focus) {
        me.focusPicker();
      }
    }
  }
  onPickerShow() {
    const me = this;
    me.pickerVisible = true;
    me.element.classList.add("b-open");
    me.trigger("togglePicker", { show: true });
    me.pickerTapOutRemover = GlobalEvents_default.ion({
      globaltap: "onPickerTapOut",
      thisObj: me
    });
    me.pickerKeyDownRemover = EventHelper.on({
      element: me.picker.element,
      keydown: "onPickerKeyDown",
      thisObj: me
    });
  }
  onPickerHide() {
    var _a2, _b;
    const me = this;
    me.ariaElement.setAttribute("aria-expanded", false);
    me.pickerVisible = false;
    me.element.classList.remove("b-open");
    me.trigger("togglePicker", { show: false });
    (_a2 = me.pickerTapOutRemover) == null ? void 0 : _a2.call(me);
    (_b = me.pickerKeyDownRemover) == null ? void 0 : _b.call(me);
  }
  onPickerTapOut({ event }) {
    if (!this.containsFocus && !this.owns(event.target)) {
      this.autoClosePicker();
    }
  }
  onPickerKeyDown(event) {
    if (event.key === "Tab" && !this.picker.trapFocus) {
      const activeEl = DomHelper.getActiveElement(this.input), forwardedEvent = new KeyboardEvent("keydown", event);
      this.input.dispatchEvent(forwardedEvent);
      if (forwardedEvent.defaultPrevented) {
        event.preventDefault();
      }
      if (DomHelper.getActiveElement(this.input) === activeEl) {
        this.input.focus();
      } else {
        event.preventDefault();
      }
      if (!this.isDestroyed) {
        this.hidePicker();
      }
    }
  }
  //endregion
  //region Visibility
  autoClosePicker() {
    if (this.autoClose) {
      this.hidePicker();
    }
  }
  /**
   * Hide picker
   */
  hidePicker() {
    if (this.pickerVisible) {
      this.picker.hide();
    }
  }
  focusPicker() {
  }
  focus() {
    const input = this.input;
    if (DomHelper.isTouchEvent && this.editable) {
      input.readOnly = true;
      this.setTimeout(() => input.readOnly = false, 500);
    }
    super.focus();
  }
  //endregion
};
//region Config
__publicField(PickerField, "$name", "PickerField");
__publicField(PickerField, "type", "pickerfield");
PickerField._$name = "PickerField";

// ../Core/lib/Core/widget/List.js
var itemRange = document.createRange();
var List = class extends Widget {
  static get configurable() {
    return {
      itemCls: "b-list-item",
      selectedCls: "b-selected",
      selectIconCls: "b-icon-check",
      tag: "ul",
      /**
       * An array of Objects which are converted into records and used to create this
       * List's {@link #config-store}
       * @config {Object[]}
       */
      items: null,
      /**
       * The model field to render into each list item
       * @config {String}
       * @default
       */
      displayField: "text",
      /**
       * A {@link Core.data.Store} which provides the records which map to List items. Each record is passed through the
       * {@link #config-itemTpl} to produce the DOM structure of the List. May be generated from an array of {@link #config-items}.
       *
       * The store may also be configured as an array of records, or record data objects from which records may be constructed.
       * @config {Object|Object[]|Core.data.Store}
       */
      store: null,
      navigator: true,
      scrollable: {
        overflowX: false,
        overflowY: true
      },
      itemsFocusable: true,
      /**
       * Configure as `true` to allow multi select and add checkboxes to the items
       * @prp {Boolean}
       * @default
       */
      multiSelect: false,
      /**
       * Select/deselect all if `CMD`/`CTRL` is pressed when clicking
       * @prp {Boolean}
       * @default false
       */
      toggleAllIfCtrlPressed: false,
      /**
       * True to add a collapse icon to toggle groups being collapsed or expanded
       * @prp {Boolean}
       * @default false
       */
      collapsibleGroups: false,
      /**
       * Set to `true` to add a "Select all" item to the list to select/unselect all items at once.
       * Only applies when {@link #config-multiSelect} mode is enabled.
       * @config {Boolean|String}
       * @default false
       */
      selectAllItem: false,
      /**
       * Template function which, when passed a record, returns the textual HTML for that item. Defaults to a
       * function returning the value of the records {@link #config-displayField}
       *
       * @config {Function}
       * @param {Core.data.Model} record The record
       * @returns {String}
       */
      itemTpl(record) {
        let text = StringHelper.encodeHtml(record.getValue(this.displayField));
        if (text == null || text === "") {
          text = "&nbsp;";
        }
        return text;
      },
      /**
       * Configure this as a function or the name of a function, which when passed a record in the
       * list, returns a style string to apply to its list item.
       *
       * @config {Function|String} getItemStyle
       * @param {Core.data.Model} record The record
       * @returns {String}
       */
      getItemStyle: null,
      /**
       * Configure this as a function or the name of a function, which when passed a record in the
       * list, returns a CSS class name string to apply to its list item.
       *
       * @config {Function|String} getItemCls
       * @param {Core.data.Model} record The record
       * @returns {String}
       */
      getItemCls: null,
      /**
       * Template function which is passed a group record and the uppercased group field name. The text returned
       * will be rendered as the group header.
       *
       * @config {Function}
       * @param {Core.data.Model} record The record
       * @param {String} groupName The current group name
       * @returns {String}
       */
      groupHeaderTpl(record, groupName) {
        let name = StringHelper.encodeHtml(groupName);
        if (name == null || name === "") {
          name = "&nbsp;";
        }
        return `${this.allowGroupSelect ? this.itemIconTpl(record) : ""}${name}`;
      },
      /**
       * Configure as `true` to allow selecting groups (all the group child records will be toggled). Only
       * applicable when the store is grouped.
       * @config {Boolean}
       * @default
       */
      allowGroupSelect: true,
      /**
       * Configure as `true` to clear selection when clicking on empty space inside the Lists element.
       * @config {Boolean}
       * @default false
       */
      clearSelectionOnEmptySpaceClick: false,
      /**
       * A {@link Core.util.Collection}, or Collection config object to use to contain this List's selected
       * records.
       *
       * Or, an array encapsulating the initial selection which this List is to have upon Store load. This may be
       * an array of `id`s , or an array of objects with an `id` property:
       *
       * ```javascript
       * new List({
       *     // initially select record IDs 1 and 5 when store loads
       *     selected : [1, 5]
       * });
       * ```
       * @config {Object[]|Number[]|String[]|Core.util.Collection|CollectionConfig}
       */
      selected: {
        $config: ["nullify", "lazy"],
        value: []
      },
      /**
       * Configure as `true` to activate items on mouseover. This is used by the Combo
       * field when using a List as its dropdown.
       * @config {Boolean}
       */
      activateOnMouseover: null,
      role: "listbox",
      keyMap: {
        "Ctrl+a": "selectAll"
      }
    };
  }
  //endregion
  //region Events
  /**
   * User activated an item in the list either by pointer or keyboard.
   * The active record, list item index, and the triggering event are passed.
   * @event item
   * @param {Core.widget.List} source The List instance
   * @param {Core.data.Model} record Activated record
   * @param {Number} index List item index
   * @param {Event} event Triggering event
   */
  /**
   * User going to activate an item in the list either by pointer or keyboard.
   * The active record, list item index, and the triggering event are passed.
   * It is preventable by returning `false`
   * @event beforeItem
   * @preventable
   * @param {Core.widget.List} source The List instance
   * @param {Core.data.Model} record Activated record
   * @param {Number} args List item index
   * @param {Event} event Triggering event
   */
  /**
   * Fired when selection changes
   * @event selectionChange
   * @param {Core.widget.List} source The List instance
   * @param {Core.data.Model[]} selected An array of the currently selected records
   */
  //endregion
  construct(config, ...args) {
    var _a2;
    const me = this;
    if (Array.isArray(config)) {
      config = {
        items: config
      };
    }
    super.construct(config, ...args);
    const { element } = me, { classList } = element;
    if (me.multiSelect) {
      classList.add("b-multiselect");
    }
    if ((_a2 = me.store) == null ? void 0 : _a2.count) {
      me.refresh();
    } else {
      classList.add("b-empty");
    }
    EventHelper.on({
      element,
      delegate: me.itemSelector,
      mouseover: "onMouseOver",
      thisObj: me
    });
    EventHelper.on({
      element,
      click: "onClick",
      thisObj: me
    });
  }
  doDestroy() {
    var _a2;
    this.detachListeners("store");
    (_a2 = this.navigator) == null ? void 0 : _a2.destroy();
    super.doDestroy();
  }
  onFocusIn(e) {
    var _a2;
    this.restoreActiveItem((_a2 = e._target) == null ? void 0 : _a2.closest(this.itemSelector));
    super.onFocusIn(e);
  }
  contentTpl() {
    const me = this, allRecordsTpl = me.store.records.map((record, i) => me.itemWrapperTpl(record, i));
    if (me.multiSelect && me.selectAllItem !== false) {
      allRecordsTpl.unshift(me.selectAllItemTpl());
    }
    return TemplateHelper.tpl`${allRecordsTpl}`;
  }
  itemWrapperTpl(record, i) {
    const {
      selected,
      getItemStyle,
      store
    } = this, style = getItemStyle ? `style="${this.callback(getItemStyle, this, [record])}"` : "";
    if (store.isGrouped && !record.isGroupHeader) {
      const groupRecord = record.groupParent.get(store.id);
      if (groupRecord.meta.collapsed) {
        return "";
      }
    }
    return TemplateHelper.tpl`<li ${style} class="${this.getItemClasses(record, i)}" role="option" aria-selected="${selected.includes(record)}" data-index="${i}" data-id="${StringHelper.encodeHtml(record.id)}" ${this.itemsFocusable ? 'tabindex="-1"' : ""}>${this.itemContentTpl(record, i)}</li>`;
  }
  itemContentTpl(record, i) {
    if (record.isGroupHeader) {
      let result = this.groupHeaderTpl(record, StringHelper.capitalize(record.meta.groupRowFor));
      if (this.collapsibleGroups) {
        const arrowDirection = record.meta.collapsed ? "right" : "down";
        result += `<button class="b-button b-tool b-icon b-icon-collapse-${arrowDirection} b-list-expander-icon" data-noselect></button>`;
      }
      return result;
    }
    return `${this.itemIconTpl(record, i)}${this.itemTpl(record, i)}`;
  }
  itemIconTpl(record, i) {
    return this.multiSelect ? `<i class="b-selected-icon b-icon ${this.selectIconCls}"></i>` : "";
  }
  selectAllItemTpl() {
    const selectedCls = this.allSelected ? "b-selected" : "";
    return `<li class="${this.itemCls} b-select-all-item ${selectedCls}" data-noselect data-select-all data-id="select-all">${this.itemIconTpl({})}<div>${this.L("selectAll")}</div></li>`;
  }
  getItemClasses(record) {
    var _a2;
    const me = this, { getItemCls } = me, activeItem = (_a2 = me._navigator) == null ? void 0 : _a2.activeItem, isActive = (activeItem == null ? void 0 : activeItem.dataset.id) == record.id, groupHeaderCls = "groupRowFor" in record.meta ? "b-list-item-group-header" : "", isSelected = me.selected.includes(record) || record.isSpecialRow && record.groupChildren.every((r) => me.selected.includes(r)), itemCls = getItemCls ? this.callback(getItemCls, this, [record]) : "";
    return `${me.itemCls} ${record.cls || ""} ${itemCls} ${isSelected ? me.selectedCls : ""} ${isActive ? me.navigator.focusCls : ""} ${groupHeaderCls}`;
  }
  onBeforeStoreLoad() {
    this.mask(this.L("L{loading}"));
  }
  onAfterStoreRequest() {
    this.unmask();
  }
  onStoreChange({ source: store, action, records, record, changes }) {
    const me = this, { selected } = me;
    switch (action) {
      case "dataset": {
        selected.match(store.storage, !me._externallyOwnedSelection);
        break;
      }
      case "remove":
        selected.remove(records);
        break;
      case "clear":
        me.deselectAll();
        break;
      case "update": {
        const { id } = changes;
        if (id) {
          DomHelper.setAttributes(
            me.contentElement.querySelector(StringHelper.encodeAttributeSelector(`data-id`, id.oldValue)),
            {
              "data-id": id.value
            }
          );
        }
        me.refreshItem(record);
        return;
      }
    }
    me.refresh();
  }
  onStoreRefresh() {
    if (this._selected) {
      this.refresh();
    } else {
      this.getConfig("selected");
    }
  }
  refresh() {
    var _a2;
    const me = this;
    if (me.isVisible && me.store) {
      const activeItem = (_a2 = me.navigator) == null ? void 0 : _a2.activeItem;
      me.paintListener = null;
      const node = DomHelper.createElementFromTemplate(me.contentTpl(), { fragment: true });
      me.clearItems().insertNode(node);
      if (activeItem) {
        me.restoreActiveItem(activeItem);
      }
      me.refreshCount = (me.refreshCount || 0) + 1;
      me.element.classList[me.store.count > 0 ? "remove" : "add"]("b-empty");
      me.updateSelectAllState();
    } else if (!me.paintListener) {
      me.paintListener = me.ion({
        paint: "refresh",
        thisObj: me,
        once: true
      });
    }
  }
  clearItems() {
    const me = this, firstItem = me.contentElement.querySelector(me.itemSelector), lastChild = me.contentElement.lastChild;
    if (firstItem) {
      const items2 = me.contentElement.querySelectorAll(`${me.itemSelector}:not(.b-mask)`);
      itemRange.setStartBefore(firstItem);
      itemRange.setEndAfter(items2[items2.length - 1]);
      itemRange.deleteContents();
    } else {
      if (lastChild) {
        itemRange.setStartAfter(lastChild);
        itemRange.setEndAfter(lastChild);
      } else {
        itemRange.setStart(me.contentElement, 0);
        itemRange.setEnd(me.contentElement, 0);
      }
    }
    return itemRange;
  }
  refreshItem(...records) {
    for (const record of records) {
      const item = this.getItem(record);
      if (item) {
        const index = this.store.indexOf(record), newItem = DomHelper.createElementFromTemplate(this.itemWrapperTpl(record, index));
        DomHelper.sync(newItem, item);
      }
    }
  }
  getItem(recordOrId) {
    if (recordOrId != null) {
      if (typeof recordOrId === "number") {
        return this.contentElement.querySelector(`[data-index="${recordOrId < 0 ? this.store.count + recordOrId : recordOrId}"]`);
      } else if (recordOrId.nodeType === Element.ELEMENT_NODE) {
        recordOrId = recordOrId.dataset.id;
      }
      if ((recordOrId == null ? void 0 : recordOrId.id) != null) {
        recordOrId = recordOrId.id;
      }
      return this.contentElement.querySelector(StringHelper.encodeAttributeSelector(`data-id`, recordOrId));
    }
  }
  /**
   * Searches up from the specified element for a list item and returns the associated record.
   * @param {HTMLElement} element Element somewhere within a list item element
   * @returns {Core.data.Model} Record for the item
   */
  getRecordFromElement(element) {
    if (element.target) {
      element = element.target;
    }
    element = element.closest(this.itemSelector);
    return this.store.getAt(parseInt(element.dataset.index));
  }
  //region getters/setters
  /**
   * May be *set* as an array of Objects which are converted into records and used to create this
   * List's {@link #config-store}
   * @member {Object[]} items
   */
  updateItems(items2) {
    var _a2;
    const me = this, newStore = Store.getStore(ArrayHelper.asArray(items2));
    if ((_a2 = me.store) == null ? void 0 : _a2.autoCreated) {
      me.store.data = (newStore == null ? void 0 : newStore.records) || [];
    } else {
      me.store = newStore;
    }
  }
  updateDisabled(disabled) {
    super.updateDisabled(...arguments);
    this.navigator && (this.navigator.disabled = disabled);
  }
  changeSelected(selected, oldSelected) {
    const me = this, internalListeners = {
      change: "onInternalSelectionChange",
      thisObj: me
    };
    oldSelected == null ? void 0 : oldSelected.un(internalListeners);
    if (selected) {
      if (selected.isCollection) {
        me._externallyOwnedSelection = true;
        selected.ion(internalListeners);
      } else {
        me._externallyOwnedSelection = false;
        selected = ArrayHelper.asArray(selected).reduce((r, s) => {
          s = s.isModel ? s : me.store.getById(s);
          if (s) {
            r.push(s);
          }
          return r;
        }, []);
        if (oldSelected) {
          oldSelected.splice(0, oldSelected.count, selected);
          selected = oldSelected;
          me.refresh();
        } else {
          const records = selected;
          selected = me._selected = new Collection({
            internalListeners
          });
          selected.add(records);
        }
      }
    } else {
      oldSelected == null ? void 0 : oldSelected.destroy();
    }
    return selected;
  }
  updateSelected(selected) {
    if (selected) {
      this.refresh();
    }
  }
  get itemSelector() {
    return `.${this.itemCls}`;
  }
  /**
   * Gets/sets the collection of selected records.
   *
   * When used as a setter, a record, or record `id` or array of same may be passed to
   * set the selected records.
   * @property {Core.util.Collection}
   * @accepts {Core.data.Model|Core.data.Model[]|String|String[]|Number|Number[]}
   */
  get selected() {
    return this._selected;
  }
  updateMultiSelect(value, old) {
    if (!value && old && this.selected.count > 1) {
      this.deselect(this.selected.allValues.slice(1));
    }
  }
  /**
   * Get the backing store, a {@link Core.data.Store} holding the records used to generate list items
   * @property {Core.data.Store}
   * @readonly
   */
  get store() {
    this.getConfig("items");
    return this._store;
  }
  changeStore(store) {
    const me = this;
    if (!(store instanceof Store)) {
      if (Array.isArray(store)) {
        store = {
          data: store
        };
      }
      store = new Store(store);
    }
    me.detachListeners("store");
    if (store) {
      const storeListeners = {
        name: "store",
        change: "onStoreChange",
        refresh: "onStoreRefresh",
        thisObj: me
      };
      if (store.readUrl) {
        storeListeners.beforeLoad = "onBeforeStoreLoad";
        storeListeners.afterRequest = "onAfterStoreRequest";
      }
      if (store.isGrouped) {
        me.element.classList.add("b-grouped");
        storeListeners.groupchange = "onStoreRefresh";
      }
      store.ion(storeListeners);
    }
    return store;
  }
  updateStore(store) {
    if (store == null ? void 0 : store.records.length) {
      this.getConfig("selected");
    }
    if (!this.refreshCount) {
      this.refresh();
    }
  }
  changeNavigator(navigator2, oldNavigator) {
    const me = this, { element } = me;
    if (element) {
      navigator2 = Navigator.reconfigure(oldNavigator, navigator2 ? Navigator.mergeConfigs({
        ownerCmp: me,
        disabled: me.disabled,
        target: element,
        keyEventTarget: element
      }, navigator2) : null, me);
      if ((navigator2 == null ? void 0 : navigator2.keyEventTarget) === element && !me.itemsTabbable) {
        element.tabIndex = 0;
      }
    }
    return navigator2;
  }
  get minAlignHeight() {
    const lastItem = this.element.lastElementChild, minHeight = this.minHeight;
    if (minHeight != null) {
      return lastItem ? Math.min(lastItem.offsetTop + lastItem.offsetHeight, minHeight) : 0;
    }
  }
  //endregion
  //region Hide/Show
  alignTo(...args) {
    super.minHeight = this.minAlignHeight;
    super.alignTo(...args);
  }
  hide(...args) {
    this.navigator && (this.navigator.activeItem = null);
    return super.hide(...args);
  }
  show() {
    const { refreshCount } = this, { previousActiveItem } = this.navigator;
    super.minHeight = this._minHeight;
    const retVal = super.show(...arguments);
    if (this.refreshCount === refreshCount) {
      this.restoreActiveItem(previousActiveItem, true);
    }
    return retVal;
  }
  /**
   * Sets the passed record as the current focused record for keyboard navigation and selection purposes.
   * @param {Core.data.Model} activeItem The item to highlight as the active ("focused") item.
   * @param {String|Boolean} [block='nearest'] The block scroll specification to scroll
   * the item into view. Defaults to `'nearest'` which means a minimal scroll, only if
   * the item is actually out of view. Passing `true` is for when the List is aligned
   * to a picker and the selected item should be scrolled to be close to the picker,
   * however that is aligned. See `Combo.showPicker` for usage.
   * @internal
   */
  restoreActiveItem(activeItem = this.navigator.previousActiveItem, block = "nearest") {
    const me = this, { navigator: navigator2, lastAlignSpec } = me;
    if (activeItem != null) {
      if (typeof block !== "string") {
        const alignZone = lastAlignSpec ? lastAlignSpec.zone : 1;
        block = alignZone & 1 ? "nearest" : alignZone ? "start" : "end";
      }
      activeItem = me.getItem(activeItem);
      if (activeItem && !me.disabled) {
        me.scrollable.scrollIntoView(activeItem, {
          block
        });
        navigator2.activeItem = activeItem;
      }
    }
  }
  //endregion
  //region Events
  /**
   * Focuses list items on hover.
   * @private
   */
  onMouseOver(event) {
    const me = this, itemElement = event.currentTarget;
    if (!DomHelper.isTouchEvent && itemElement && me.navigator && me.activateOnMouseover) {
      me.setTimeout({
        fn: "handleMouseOver",
        delay: 30,
        args: [itemElement],
        cancelOutstanding: true
      });
    }
  }
  handleMouseOver(itemElement) {
    this.navigator.activeItem = itemElement;
  }
  /**
   * Selects list items on click.
   * @private
   */
  onClick(event) {
    const itemElement = event.target.closest(this.itemSelector);
    if (itemElement) {
      this.onItemClick(itemElement, event);
    } else if (this.clearSelectionOnEmptySpaceClick) {
      this.deselectAll();
    }
  }
  onSpaceKey(event) {
    if (event.target.nodeName.toUpperCase() !== "INPUT" || event.target.readOnly) {
      this.onEnterKey(event);
    }
  }
  onEnterKey(event) {
    const active = this.navigator.activeItem;
    if (active && !this.disabled) {
      this.onItemClick(active, event);
      event.stopImmediatePropagation();
      event.preventDefault();
    }
  }
  /**
   * Key events which are not navigation are delegated up to here by the Navigator
   * @private
   */
  onInternalKeyDown(event) {
    const me = this;
    switch (event.key) {
      case "ArrowLeft":
        me.collapseItem();
        break;
      case "ArrowRight":
        me.expandItem();
        break;
      case " ":
        me.onSpaceKey(event);
        break;
      case "Enter":
        me.onEnterKey(event);
        break;
    }
  }
  collapseItem() {
    const { activeItem } = this.navigator;
    if (activeItem) {
      this.toggleCollapse(this.getRecordFromElement(activeItem), true);
    }
  }
  expandItem() {
    const { activeItem } = this.navigator;
    if (activeItem) {
      this.toggleCollapse(this.getRecordFromElement(activeItem), false);
    }
  }
  //endregion
  onItemClick(item, event) {
    var _a2;
    const me = this, { allowGroupSelect } = me, index = parseInt(item.dataset.index), record = me.store.getAt(index), isSpecialRow = record == null ? void 0 : record.isSpecialRow, isNoSelect = item.contains(event.target.closest("[data-noselect]"));
    if (me.disabled || me.trigger("beforeItem", { item, record, index, event, userAction: true }) === false) {
      return;
    }
    me._isUserAction = true;
    if (item.contains(event.target.closest("[data-select-all]"))) {
      me.onSelectAllClick(item, event);
    } else if (event.target.matches(".b-list-expander-icon")) {
      me.toggleCollapse(record);
      return;
    } else if (record && !isNoSelect && (!isSpecialRow || allowGroupSelect)) {
      const { selected } = me, groupParent = (_a2 = record.groupParent) == null ? void 0 : _a2.get(me.store.id);
      if (me.multiSelect) {
        let isSelected = selected.includes(record), toAddRemove = record;
        if (me.toggleAllIfCtrlPressed && event.ctrlKey) {
          toAddRemove = me.store.records;
        } else if (allowGroupSelect && isSpecialRow) {
          isSelected = !record.groupChildren.some((rec) => !selected.includes(rec));
          item.classList.toggle("b-selected", !isSelected);
          toAddRemove = record.groupChildren;
        }
        selected[isSelected ? "remove" : "add"](toAddRemove);
        if (!isSpecialRow && groupParent && allowGroupSelect) {
          const groupItem = me.getItem(groupParent);
          groupItem.classList.toggle("b-selected", groupParent.groupChildren.every((r) => selected.includes(r)));
        }
      } else {
        selected.splice(0, selected.count, record);
      }
    }
    if (me.isDestroyed) {
      return;
    }
    me.lastClicked = record;
    me.trigger("item", {
      item,
      record,
      index,
      event,
      userAction: true
    });
    me._isUserAction = false;
  }
  /**
   * Handles items being added or removed from the selected Collection
   * @param {Object} changeEvent
   * @private
   */
  onInternalSelectionChange({ action, removed, added, replaced }) {
    const me = this, {
      selectedCls,
      unselectedCls
    } = me;
    let record, item;
    if (action === "clear") {
      for (item of me.element.querySelectorAll(`.${selectedCls}`)) {
        item.classList.remove(selectedCls);
        item.setAttribute("aria-selected", false);
        unselectedCls && item.classList.remove(unselectedCls);
      }
    } else if (action !== "replaceValues") {
      for (record of removed) {
        item = me.getItem(record);
        if (item) {
          item.classList.remove(selectedCls);
          item.setAttribute("aria-selected", false);
        }
      }
      for (record of added) {
        item = me.getItem(record);
        if (item) {
          item.classList.add(selectedCls);
          item.setAttribute("aria-selected", true);
        }
      }
    }
    me.selectAllItem && me.updateSelectAllState();
    me.trigger("selectionChange", { selected: me.selected.values });
  }
  onSelectAllClick(item) {
    const checked = item.classList.contains(this.selectedCls);
    if (checked) {
      this.deselectAll();
    } else {
      this.selectAll();
    }
  }
  updateSelectAllState() {
    var _a2;
    (_a2 = this.element.querySelector(".b-select-all-item")) == null ? void 0 : _a2.classList.toggle(this.selectedCls, this.allSelected);
  }
  /**
   * Yields `true` if all the available items are selected.
   * @property {Boolean}
   * @readonly
   */
  get allSelected() {
    const { selected, store } = this;
    return selected.count && (store.isFiltered ? store.records.every((r) => selected.includes(r)) : store.count === selected.count);
  }
  /**
   * Selects all items in this list.
   * @category Selection
   */
  selectAll(keyEvent) {
    const me = this;
    if (me.multiSelect || !keyEvent) {
      me.selected.add(me.store.records);
      if (keyEvent && !me.navigator.activeItem) {
        me.navigator.activeItem = me.getItem(-1);
      }
    }
  }
  /**
   * Deselects all selected items
   * @category Selection
   */
  deselectAll() {
    this.selected.clear();
  }
  /**
   * Selects the passed item(s).
   *
   * An item to select may be the `id` of a record in this List's {@link #config-store}, or
   * it may be an object with an `id` __property__ which is the `id` of a record in this List's
   * {@link #config-store} (For example one of the records).
   * @param {String|String[]|Number|Number[]|Object|Object[]} toSelect
   * @category Selection
   */
  select(toSelect) {
    const { store } = this, { modelClass } = store;
    toSelect = ArrayHelper.asArray(toSelect).reduce((v, c) => {
      c = store.getById(modelClass.asId(c));
      if (c) {
        v.push(c);
      }
      return v;
    }, []);
    this.selected.add(toSelect);
  }
  /**
   * Deselects the passed item(s).
   *
   * An item to deselect may be the `id` of a record in this List's {@link #config-store}, or
   * it may be an object with an `id` __property__ which is the `id` of a record in this List's
   * {@link #config-store} (For example one of the records).
   * @param {String|String[]|Number|Number[]|Object|Object[]} toSelect
   * @category Selection
   */
  deselect(toDeselect) {
    const { modelClass } = this.store;
    toDeselect = ArrayHelper.asArray(toDeselect).reduce((v, c) => {
      c = this.selected.get(modelClass.asId(c));
      if (c) {
        v.push(c);
      }
      return v;
    }, []);
    this.selected.remove(toDeselect);
  }
  /**
   * Toggles the collapsed state of a group header record
   * @param {Core.data.Model} record The group record
   * @param {Boolean} [collapse] Force collapse (true) or expand (false)
   * @fires togglegroup
   */
  toggleCollapse(groupRecord, collapse) {
    if (!groupRecord.isGroupHeader) {
      return;
    }
    collapse = collapse === void 0 ? !groupRecord.meta.collapsed : collapse;
    this.store[collapse ? "collapse" : "expand"](groupRecord);
    this.refresh();
    this.trigger("toggleGroup", { groupRecord, collapse });
  }
  updateCollapsibleGroups(value, old) {
    if (old && !value) {
      const { store } = this;
      store.groupRecords.forEach((record) => store.expand(record));
    }
    this.refresh();
  }
};
//region Config
__publicField(List, "$name", "List");
__publicField(List, "type", "list");
List.initClass();
List.prototype.navigatorClass = Navigator;
List._$name = "List";

// ../Core/lib/Core/widget/ChipView.js
var ChipView = class extends List {
  static get configurable() {
    return {
      itemCls: "b-chip",
      /**
       * Configure as `true` to allow multi select and allow clicking and key navigation
       * to select multiple chips.
       * @config {Boolean}
       * @default
       */
      multiSelect: false,
      /**
       * Configure as `true` to display a clickable close icon after the {@link Core.widget.List#config-itemTpl}.
       * When tapped, the configured {@link #config-closeHandler} is called passing the
       * associated record.
       *
       * Chips may also be selected using the `LEFT` and `RIGHT` arrows (And the `Shift` key to
       * do multiple, contiguous election). Pressing the `DELETE` or `BACKSPACE` key passes the
       * selected records to the {@link #config-closeHandler}
       * @config {Boolean}
       * @default
       */
      closable: true,
      /**
       * A template function, which, when passed a record, returns the markup which
       * encapsulates a chip's icon to be placed before the {@link Core.widget.List#config-itemTpl}.
       * @config {Function}
       * @param {Core.data.Model} record The record to provide an icon for
       * @returns {DomConfig|String|null}
       */
      iconTpl: null,
      /**
       * If {@link #config-closable} is `true`, this is the name of a callback function
       * to handle what the "close" action means. If not provided, the record representing the chip is removed
       * from the store
       *
       * @config {String|Function}
       * @params {Core.data.Model[]} records Records to be closed
       * @params {Object} options Close options
       * @returns {void}
       */
      closeHandler: null
    };
  }
  itemContentTpl(record, i) {
    const me = this;
    return TemplateHelper.tpl`${me.iconTpl ? this.iconTpl(record) : ""}
            ${me.itemTpl(record, i)}
            ${me.closable ? '<div class="b-icon b-close-icon b-icon-clear" data-noselect></div>' : ""}`;
  }
  onInternalKeyDown(event) {
    const me = this;
    if (me.closable && me.selected.count && (event.key === "Delete" || event.key === "Backspace")) {
      me.callback(me.closeHandler, me.owner, [me.selected.values, { isKeyEvent: true }]);
    } else {
      super.onInternalKeyDown(event);
    }
  }
  updateClosable(closable) {
    this.element.classList[closable ? "add" : "remove"]("b-chips-closable");
    this.navigator && (this.navigator.disabled = !closable);
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  onClick(event) {
    const me = this, item = event.target.closest(`.${me.itemCls}`);
    if (me.closable && event.target.classList.contains("b-close-icon")) {
      const record = me.store.getAt(parseInt(item.dataset.index));
      if (me.closeHandler) {
        me.callback(me.closeHandler, me.owner, [[record]]);
      } else {
        me.store.remove(record);
      }
    } else {
      super.onClick(event);
    }
  }
};
//region Config
__publicField(ChipView, "$name", "ChipView");
__publicField(ChipView, "type", "chipview");
ChipView.initClass();
ChipView._$name = "ChipView";

// ../Core/lib/Core/widget/Combo.js
var errorFieldRequired = "L{Field.fieldRequired}";
var errorValidateFilter = "L{Field.validateFilter}";
var errorRecordNotCommitted = "L{Combo.recordNotCommitted}";
var filterKeyTypes = /[\w\s]/;
var Combo = class extends PickerField {
  static get configurable() {
    return {
      /**
       * Optionally a {@link Core.util.CollectionFilter Filter} config object which the combo should use for
       * filtering using the typed value.
       * This may use a `filterBy` property to test its `value` against any field in the passed record.
       * ```javascript
       * {
       *     type          : 'combo',
       *     store         : myStore,
       *     primaryFilter : {
       *         filterBy(record) {
       *             if (this.value == null) {
       *                 return true;
       *             }
       *             const value = this.value.toLowerCase();
       *
       *             // Match typed value with forename or surname
       *             return record.forename.toLowerCase().startsWith(value)
       *                 || record.surname.toLowerCase().startsWith(value);
       *         }
       *     }
       * }
       * ```
       * @config {CollectionFilterConfig}
       */
      primaryFilter: {},
      /**
       * Configuration object for the {@link Core.widget.List picker} on initialization. Returns the
       * {@link Core.widget.List picker} instance at runtime.
       *
       * For example:
       *
       * ```javascript
       * new Combo({
       *     ...
       *     // configure the combobox picker
       *     picker : {
       *         listeners : {
       *             // prevent selection of item with id == 2
       *             beforeItem : ({ record }) => record.id !== 2
       *         }
       *     }
       * })
       * ```
       *
       * @prp {Core.widget.List}
       * @accepts {ListConfig}
       */
      picker: {
        type: "list",
        floating: true,
        scrollAction: "realign",
        itemsFocusable: false,
        activateOnMouseover: true,
        align: {
          align: "t0-b0",
          axisLock: true
        },
        maxHeight: 324,
        scrollable: {
          overflowY: true
        },
        autoShow: false,
        focusOnHover: false
      },
      /**
       * Configure as `true` to allow selection of multiple values from the dropdown list.
       *
       * Each value is displayed as a "Chip" to the left of the input area. Chips may be
       * selected using the `LEFT` and `RIGHT` arrow keys and deleted using the `DELETE` key
       * to remove values from the field. There is also a clickable close icon in each chip.
       *
       * Use {@link Core.widget.List#config-toggleAllIfCtrlPressed} to implement "select all" behaviour.
       *
       * ```javascript
       * {
       *     type   : 'combo',
       *     store  : myStore,
       *     picker : {
       *         toggleAllIfCtrlPressed : true
       *     }
       * }
       * ```
       *
       * @config {Boolean}
       * @default false
       */
      multiSelect: null,
      /**
       * Rows to display in the dropdown (list items).
       *
       * If an object, the property names provide the {@link #config-value} for the Combo, and
       * the property values provide the displayed test in the list and input area eg:
       *
       *     items : {
       *         small  : 'Small',
       *         medium : 'Medium',
       *         large  : 'Large'
       *     }
       *
       * If an array, each entry may be
       *  - an object containing properties which must include
       * the {@link #config-valueField} and {@link #config-displayField} which populates the dropdown
       * with text and provides the corresponding field value.
       *  - An array whose first value provides the {@link #config-value} for the Combo and whose
       * second value provides the displayed test in the list and input area.
       *  - An array of values where the {@link #config-valueField} and {@link #config-displayField} are the same.
       *
       * eg:
       *
       *     items : [
       *         {value : 'small',  text : 'Small'},
       *         {value : 'medium', text : 'Medium'},
       *         {value : 'large',  text : 'Large'},
       *     ]
       *
       * or
       *
       *     items : [
       *         ['small',  'Small'],
       *         ['medium', 'Medium'],
       *         ['large',  'Large'],
       *     ]
       *
       * or
       *
       *     items : [ 'Small', 'Medium', 'Large' ]
       *
       * @config {Object[]|String[]|Object}
       */
      items: null,
      /**
       * Store used to populate items. Also accepts a Store config object
       * @prp {Core.data.Store|StoreConfig}
       */
      store: null,
      /**
       * Field used for item value when populating from store. Setting this to `null` will
       * yield the selected record as the Combo's {@link #property-value}.
       * @config {String|null}
       */
      valueField: void 0,
      /**
       * Field used for item text when populating from store
       * @config {String}
       * @default
       */
      displayField: "text",
      /**
       * Width of picker, defaults to this combo's {@link #config-pickerAlignElement} width
       * @config {Number}
       */
      pickerWidth: null,
      /**
       * The minimum string length to trigger the filtering, only relevant when {@link #config-editable} is `true`.
       *
       * This defaults to `1` in the case of local filtering, but `4` if the
       * {@link #config-filterParamName} is set to cause remote dropdown loading.
       *
       * @config {Number}
       * @default
       */
      minChars: null,
      selected: null,
      /**
       * Template string used to render the list items in the dropdown list
       *
       * ```javascript
       * new Combo({
       *     listItemTpl : ({ text }) => `<div class="combo-color-box ${text}"></div>${text}`,
       *     editable    : false,
       *     items       : [
       *         'Black',
       *         'Green',
       *         'Orange',
       *         'Pink',
       *         'Purple',
       *         'Red',
       *         'Teal'
       *     ]
       * });
       * ```
       *
       * @config {Function}
       * @param {Core.data.Model} record The record representing the item being rendered
       * @returns {String|null}
       */
      listItemTpl: null,
      /**
       * Template function that can be used to customize the displayed value
       * @param {Core.data.Model} record The record to provide a textual value for
       * @param {Core.widget.Combo} combo A reference to this Combo
       * @config {Function}
       * @returns {String|null}
       */
      displayValueRenderer: null,
      /**
       * CSS class to add to picker
       * @config {String}
       */
      listCls: null,
      triggers: {
        expand: {
          cls: "b-icon-picker",
          handler: "onTriggerClick"
        }
      },
      /**
       * If the dropdown is to be populated with a filtered query to a remote server, specify the
       * name of the parameter to pass the typed string here. By default, the string is simply sent
       * as the value of the parameter. For special encoding, configure the combo with {@link #config-encodeFilterParams}
       * @config {String}
       */
      filterParamName: null,
      /**
       * A function which creates an array of values for the {#config-filterParamName} to pass
       * any filters to the server upon load.
       *
       * The default behaviour is just to set the parameter value to the filter's `value`,
       * but the filter can be fully encoded for example:
       *
       * ```javascript
       *    {
       *        encodeFilterParams(filters) {
       *            const result = [];
       *
       *            for (const { property, operator, value, caseSensitive } of filters) {
       *                result.push(JSON.stringify({
       *                    field : property,
       *                    operator,
       *                    value,
       *                    caseSensitive
       *                }));
       *           }
       *        return result;
       *    }
       * ```
       * @config {Function}
       * @param {Object[]} filters filters
       * @returns {Object[]} array of values
       */
      encodeFilterParams: (filters) => filters.map((f) => f.value),
      /**
       * If `false`, filtering will be triggered once you exceed {@link #config-minChars}. To filter only when
       * hitting Enter key, set this to `true`;
       * @config {Boolean}
       */
      filterOnEnter: false,
      /**
       * Configure as `true` to hide the expand trigger. This is automatically set to `true` if
       * remote filtering is enabled by setting the {@link #config-filterParamName} config.
       * @config {Boolean}
       * @default false
       */
      hideTrigger: null,
      /**
       * This implies that the picker will display an anchor pointer, but also means that the picker will align closer
       * to the input field so that the pointer pierces the {@link #config-pickerAlignElement}
       * @config {Boolean}
       * @default false
       */
      overlayAnchor: null,
      /**
       * The delay in milliseconds to wait after the last keystroke before filtering the list.
       *
       * This is a minimum of 300ms for remote filtering to keep network requests manageable, and
       * defaults to 10ms for locally filtered stores.
       * @config {Number}
       * @default
       */
      keyStrokeFilterDelay: null,
      defaultAction: "select",
      /**
       * How to query the store upon click of the expand trigger. Specify one of these values:
       *
       *  - `'all'` - Clear the filter and display the whole dataset in the dropdown.
       *  - `'last'` - Filter the dataset using the last filter value.
       *  - `null`/any other - Use the value in the input field to filter the dataset.
       *
       * @config {'all'|'last'|null}
       * @default
       */
      triggerAction: "all",
      /**
       * The name of an operator type as implemented in {@link Core.util.CollectionFilter#config-operator}
       * to use when filtering the dropdown list based upon the typed value.
       *
       * This defaults to `'startsWith'`, but the `'*'` operator may be used to match all
       * values which _contain_ the typed value.
       *
       * Not used when {@link #config-filterParamName} is set to cause remote dropdown loading.
       * The exact filtering operation is up to the server.
       *
       * @default
       * @prp {'='|'!='|'>'|'>='|'<'|'<='|'*'|'startsWith'|'endsWith'|'isIncludedIn'}
       */
      filterOperator: "startsWith",
      /**
       * Configure as `true` to force case matching when filtering the dropdown list based upon the typed value.
       *
       * @config {Boolean}
       * @default false
       */
      caseSensitive: false,
      /**
       * By default, the picker is hidden on selection in single select mode, and
       * remains to allow more selections when {@link #config-multiSelect} is `true`.
       * Setting this to a `Boolean` value can override that default.
       * @config {Boolean}
       */
      hidePickerOnSelect: null,
      /**
       * A config object to configure the {@link Core.widget.ChipView} to display the
       * selected value set when {@link #config-multiSelect} is `true`.
       *
       * For example the {@link Core.widget.List#config-itemTpl} or
       * {@link Core.widget.ChipView#config-iconTpl} might be configured to display
       * richer chips for selected items.
       * @config {ChipViewConfig}
       */
      chipView: {
        $config: ["lazy", "nullify"],
        value: {
          type: "combochipview"
        }
      },
      chipStore: {
        $config: ["lazy", "nullify"],
        value: {}
      },
      /**
       * When {@link #config-multiSelect} is `true`, you may configure `filterSelected` as
       * `true` to hide items in the dropdown when they are added to the selection.
       * It will appear as if the requested item has "moved" into the field's
       * {@link #config-chipView ChipView}.
       *
       * @config {Boolean}
       * @default false
       */
      filterSelected: null,
      /**
       * Text to display in the drop down when there are no items in the underlying store
       * @config {String}
       * @default
       */
      emptyText: null,
      /**
       * Get/sets combo value, selects corresponding item in the list
       * Setting null clears the field.
       *
       * If {@link #config-multiSelect} is `true`, then multiple values may be passed as an array.
       * If the values are records, these become the selected record set held by {@link #property-valueCollection},
       * and the `value` yielded by this field is an array of all the {@link #config-valueField}s from the records.
       * @fires select
       * @fires action
       * @member {Object|Number|String} value
       */
      /**
       * The initial value of this Combo box. In single select mode (default) it's a simple string value, for
       * {@link #config-multiSelect} mode, it should be an array of record ids.
       * @config {String|Number|String[]|Number[]}
       * @default
       */
      value: null,
      valueCollection: {
        $config: ["nullify", "lazy"],
        value: {}
      },
      /**
       * `true` to cause the field to be in an invalid state while the typed filter string does not match a record in the store.
       * @config {Boolean}
       * @default
       */
      validateFilter: true,
      /**
       * `true` to clear value typed to a multiselect combo when picker is collapsed
       * @config {Boolean}
       * @default
       */
      clearTextOnPickerHide: true,
      // set to true to destroy the old combo store when it is replaced with a new store
      destroyStore: false,
      /**
       * A key value which, when typed in a {@link #config-multiSelect} Combo, selects the
       * currently active item in the picker, and clears the input field ready for another
       * match to be typed.
       * @config {String}
       * @default
       */
      multiValueSeparator: ",",
      /**
       * If configured as `true`, this means that when an unmatched string is typed into the
       * combo's input field, and `ENTER`, or the {@link #config-multiValueSeparator} is typed,
       * a new record will be created using the typed string as the {@link #config-displayField}.
       *
       * If configured as a function, or the name of a function in the owning component hierarchy, the function
       * will be called passing the string and combo field instance and should return the record to add (if any).
       *
       * The new record will be appended to the store, and the value selected.
       *
       * If the Store is an {@link Core.data.AjaxStore}, the new record will be eiligible for
       * syncing to the database through its {@link Core.data.AjaxStore#config-createUrl createUrl}.
       *
       * If the `AjaxStore` is configured to {@link Core.data.AjaxStore#config-autoCommit autoCommit},
       * the record will be synced immediately. If the server does not accept the new addition,
       * the field is placed temporarily into an invalid state with a message that explains this.
       *
       * For example:
       *
       * ```javascript
       *     new Combo({
       *         label : 'Employee name',
       *         store : employees,
       *         createOnUnmatched(name, combo) {
       *             name = validateEmployeeName(name);
       *
       *             if (name) {
       *                 return new Employee({
       *                     name,
       *                     email : generateEmployeeEmail(name)
       *                 });
       *             }
       *             else {
       *                 combo.setError('Invalid new employee name');
       *             }
       *         }
       *     });
       * ```
       * @config {Function|String|Boolean}
       * @param {String} name Record name
       * @param {Core.widget.Combo} combo Combo instance
       * @returns {Core.data.Model} New record
       */
      createOnUnmatched: null,
      role: "combobox",
      /**
       * Configure this as `true` to render the dropdown list as a permanently visible list
       * in the document flow immediately below the input area instead of as a popup.
       *
       * This also hides the expand trigger since it is not needed.
       * @config {Boolean}
       * @default false
       */
      inlinePicker: null,
      testConfig: {
        // So that locally filtered tests do not have to wait after type gestures.
        // Note that for remote filtering, we set a min of 300ms
        keyStrokeFilterDelay: 0
      },
      /**
       * Configure this as `true` and the items display field values will be localized. The display field values
       * need to be a locale string.
       * @config {Boolean}
       * @private
       * @default
       */
      localizeDisplayFields: false,
      /**
       * Provide a function that returns items to be shown in the combo's selector.
       * @config {Function}
       * @private
       */
      buildItems: null
    };
  }
  /**
   * A constant value for the {@link #config-triggerAction} config to indicate that clicking the trigger should
   * filter the dataset using the last filter query string, *not* the input field value.
   * @member {String} queryLast
   * @readonly
   * @static
   */
  static get queryLast() {
    return "last";
  }
  //endregion
  construct(config) {
    super.construct(...arguments);
    if (!this.store) {
      this.items = [];
    }
    if (this.filterOnEnter) {
      this.hideTrigger = true;
    }
  }
  startConfigure(config) {
    this.usingRecordAsValue = config.valueField === null;
    super.startConfigure(...arguments);
  }
  afterConfigure() {
    super.afterConfigure();
    const me = this;
    if (!ObjectHelper.hasOwn(me, "_value")) {
      me._value = me.valueField === me.displayField ? "" : null;
      me._lastValue = me._lastValue || me._value;
    }
  }
  get childItems() {
    const { _chipView, _picker } = this, result = super.childItems;
    if (_chipView) {
      result.push(_chipView);
    }
    if (_picker) {
      result.push(_picker);
    }
    return result;
  }
  get innerElements() {
    var _a2;
    const chipViewElement = (_a2 = this._chipView) == null ? void 0 : _a2.element, { input, inputElement } = this;
    if (chipViewElement) {
      DomSync.sync({
        targetElement: input,
        domConfig: inputElement
      });
    }
    return [chipViewElement || inputElement];
  }
  updateInlinePicker(inlinePicker) {
    if (inlinePicker) {
      this.element.classList.add("b-inline-picker");
      this.getConfig("picker");
      this.triggers.expand = null;
      this.pickerVisible = true;
    }
  }
  hidePicker() {
    if (!this.inlinePicker) {
      return super.hidePicker(...arguments);
    }
  }
  changeChipStore(chipStore) {
    if (chipStore && !(chipStore instanceof Store)) {
      chipStore = new Store(Store.mergeConfigs({
        storage: this.valueCollection
      }, chipStore));
    }
    return chipStore;
  }
  updateChipStore(store, was) {
    was == null ? void 0 : was.destroy();
  }
  changeChipView(chipView, oldChipView) {
    const me = this;
    me.element.classList[chipView ? "add" : "remove"]("b-uses-chipview");
    if (chipView) {
      const { input } = me;
      if (!me.chipStore) {
        me.chipStore = {};
      }
      return ComboChipView.reconfigure(oldChipView, chipView, {
        defaults: {
          parent: me,
          insertBefore: input,
          store: me.chipStore,
          closable: !me.readOnly,
          navigator: {
            type: "combochipnavigator",
            keyEventTarget: input
          }
        }
      });
    }
    oldChipView == null ? void 0 : oldChipView.destroy();
  }
  updateChipView(chipView) {
    var _a2;
    const me = this;
    me._chipViewEventDetacher = (_a2 = me._chipViewEventDetacher) == null ? void 0 : _a2.call(me);
    me.chipStore = chipView == null ? void 0 : chipView.store;
    if (chipView) {
      chipView.element.appendChild(me.input);
      me._chipViewEventDetacher = EventHelper.on({
        element: chipView.element,
        mousedown: "onChipViewMousedown",
        thisObj: me
      });
    }
  }
  updateMultiSelect(multiSelect, oldMultiSelect) {
    const me = this, {
      input,
      element
    } = me, fixValue = !me.isConfiguring;
    let { value } = me;
    element.classList[multiSelect ? "add" : "remove"]("b-multiselect");
    if (multiSelect) {
      const { chipView } = me, { parentNode: parentNode2 } = input, chipViewEl = chipView == null ? void 0 : chipView.element;
      if (chipViewEl && chipViewEl !== parentNode2) {
        parentNode2.insertBefore(chipViewEl, input);
        chipViewEl.appendChild(input);
        me.chipView.refresh();
      }
      input.value = "";
      if (fixValue) {
        value = ArrayHelper.asArray(value);
      }
    } else {
      const chipView = me._chipView, { parentNode: parentNode2 } = input, chipViewEl = chipView == null ? void 0 : chipView.element;
      if (chipViewEl === parentNode2) {
        chipViewEl.parentNode.insertBefore(input, chipViewEl);
        chipViewEl.remove();
        element.classList.remove("b-uses-chipview");
      }
      if (fixValue && typeof value !== "string") {
        value = (value == null ? void 0 : value.length) ? value[0] : null;
      }
    }
    if (fixValue) {
      me.value = value;
    }
  }
  onChipViewMousedown(mousedownEvent) {
    mousedownEvent.preventDefault();
    if (!this.containsFocus) {
      this.focus();
    }
  }
  onChipClose(records, options = {}) {
    if (options.isKeyEvent && this.input.value === "" || !options.isKeyEvent) {
      this._isUserAction = true;
      this.valueCollection.remove(records);
      this._isUserAction = false;
    }
  }
  updateFilterParamName(filterParamName) {
    if (this.hideTrigger !== false) {
      this.hideTrigger = Boolean(filterParamName);
    }
  }
  updateHideTrigger(hideTrigger) {
    this.element.classList[hideTrigger ? "add" : "remove"]("b-hide-trigger");
  }
  //region Getters/setters
  updateKeyStrokeFilterDelay(delay2) {
    this.filterOnInput.delay = delay2;
  }
  updateReadOnly(readOnly) {
    super.updateReadOnly(...arguments);
    this._chipView && (this._chipView.closable = !readOnly);
  }
  updateDisabled(disabled) {
    super.updateDisabled(...arguments);
    this._chipView && (this._chipView.closable = !disabled);
  }
  updateFilterOperator(filterOperator) {
    if (this.primaryFilter) {
      this.primaryFilter.operator = filterOperator;
    }
  }
  get minChars() {
    const minChars = this._minChars;
    if (minChars != null) {
      return minChars;
    }
    return this.remoteFilter ? 4 : 1;
  }
  get validateFilter() {
    return this._validateFilter && !this.createOnUnmatched;
  }
  get items() {
    return this.store.allRecords;
  }
  updateBuildItems(fn2) {
    if (fn2) {
      this.items = fn2.call(this);
    }
  }
  /**
   * Prepares items to work in attached menu (converts strings to items)
   * @private
   */
  changeItems(items2) {
    const me = this;
    if (items2 == null) {
      if (me.store && !me.store.isItemStore) {
        return;
      }
      items2 = [];
    }
    if (me.buildItems && !(items2 == null ? void 0 : items2.length)) {
      items2 = me.buildItems();
    }
    if (items2 instanceof Store) {
      me.store = items2;
      return;
    }
    const displayField = me.displayField;
    let itemModel, valueField = me.valueField, storeData;
    if (Array.isArray(items2)) {
      storeData = items2.map((item) => {
        let result = item;
        if (item instanceof Model) {
          itemModel = item.constructor;
          if (!valueField) {
            me.valueField = valueField = itemModel.idField;
          }
        } else {
          if (typeof item === "string" || typeof item === "number") {
            if (!valueField) {
              me.valueField = valueField = me.displayField;
            }
            result = {
              [valueField]: item,
              [displayField]: item
            };
          } else {
            if (!valueField) {
              me.valueField = valueField = "value";
            }
            if (Array.isArray(item)) {
              result = {
                [valueField]: item[0],
                [displayField]: item[1]
              };
            }
          }
        }
        if (item.selected) {
          me.value = result;
        }
        return result;
      });
    } else {
      if (!valueField) {
        me.valueField = valueField = "value";
      }
      storeData = [];
      Object.entries(items2).forEach(([key, value]) => {
        storeData.push({
          [valueField]: key,
          [displayField]: value
        });
      });
    }
    if (me.store) {
      me.store.data = storeData;
    } else {
      const valueFieldDefinition = valueField === displayField ? {
        name: "value",
        dataSource: displayField
      } : valueField;
      if (!itemModel) {
        class ModelClass extends Model {
          static get idField() {
            return me.valueField;
          }
          static set idField(idField) {
            super.idField = idField;
          }
          static get fields() {
            return [valueFieldDefinition, displayField];
          }
        }
        itemModel = ModelClass;
      }
      me.store = new Store({
        isItemStore: true,
        data: storeData,
        idField: valueField,
        // We frequently populate combos with data from other stores, don't want warnings for consuming local
        // records from those stores with generated ids
        verifyNoGeneratedIds: false,
        modelClass: itemModel
      });
    }
  }
  get value() {
    const me = this, { valueCollection, valueField } = me;
    if (valueField == null) {
      return me.multiSelect ? valueCollection.values.slice() : valueCollection.first;
    }
    let value;
    if (me.multiSelect) {
      value = valueCollection.count ? valueCollection.map((r) => r[valueField]) : me._lastValue || [];
    } else {
      value = valueCollection.count ? valueCollection.first[valueField] : me._lastValue;
    }
    return value;
  }
  set value(value) {
    super.value = value;
  }
  // Documented in superclass.
  get needsInputSync() {
    return this.usesChipView ? false : !this.editable;
  }
  changeValue(value, oldValue) {
    var _a2, _b;
    const me = this;
    if (value === oldValue) {
      me.syncInputFieldValue(true);
      return;
    }
    if (!me.multiSelect && Array.isArray(value) && value.length > 1) {
      throw new Error("Multiple values cannot be set to a non-multiSelect Combo");
    }
    me.triggerConfig("items");
    if (!me.inputting) {
      (_a2 = me._chipView) == null ? void 0 : _a2.selected.clear();
    }
    if (!me.store) {
      me.items = [];
    }
    const {
      valueField,
      displayField,
      store,
      valueCollection,
      _picker
    } = me, { storage } = store, hidePicker = (_b = me.hidePickerOnSelect) != null ? _b : !me.multiSelect, isUserAction = me._isUserAction || (_picker == null ? void 0 : _picker._isUserAction) || hidePicker && me.pickerVisible || false;
    if (!me.remoteFilter && store.isAjaxStore && !store.count) {
      store.ion({ load: () => me.value = value, once: true, thisObj: me });
      me._lastValue = value;
      return;
    }
    let record;
    if (value != null) {
      const arrayPassed = Array.isArray(value), values = arrayPassed ? value.slice() : [value];
      if (me.remoteFilter) {
        if (value != null) {
          if (ObjectHelper.isObject(value) || value.isModel) {
            me.store.data = [value];
            me.valueCollection.splice(0, me.valueCollection.count, me.store.first);
          } else {
            const wasConfiguring = me.isConfiguring;
            me.primaryFilter.setConfig({
              value,
              disabled: false
            });
            store.performFilter(true).then(() => {
              if (me.isDestroyed) {
                return;
              }
              const { isConfiguring } = me;
              me.isConfiguring = wasConfiguring;
              valueCollection.splice(0, valueCollection.count, store.allRecords);
              me.isConfiguring = isConfiguring;
            });
          }
          return;
        }
      } else if (store.isFiltered) {
        me.primaryFilter.disabled = true;
        store.filter();
      }
      for (let i = 0, len = values.length; i < len; i++) {
        let currentValue = values[i];
        if (currentValue instanceof Model) {
          if (!storage.includes(currentValue, true)) {
            store.add(currentValue);
          }
        } else {
          const isObject3 = ObjectHelper.isObject(currentValue);
          if (isObject3) {
            currentValue = currentValue[store.modelClass.fieldMap[valueField].dataSource];
          }
          record = storage.getBy(displayField, currentValue) || storage.getBy(valueField, currentValue) || (valueCollection.getBy(displayField, currentValue) || valueCollection.getBy(valueField, currentValue));
          if (record instanceof Set) {
            record = [...record][0];
          }
          if (record) {
            if (isObject3) {
              record.set(values[i]);
            }
            values[i] = record;
          } else {
            values.splice(i, 1);
            len--;
            i--;
          }
        }
      }
      const noMatches = !values.length;
      const vcGen = valueCollection.generation;
      valueCollection.splice(0, valueCollection.count, values);
      if (noMatches) {
        me._value = arrayPassed && value.length === 0 ? null : value;
        me._lastValue = me._value;
      }
      if (noMatches || valueCollection.generation === vcGen) {
        me.syncInputFieldValue();
      }
      me.syncEmpty();
      if (noMatches && !me.isConfiguring) {
        me.triggerFieldChange({
          value,
          oldValue,
          userAction: isUserAction,
          valid: me.isValid
        });
      }
    } else {
      if (valueCollection.count) {
        valueCollection.clear();
      } else {
        const oldValue2 = me._value;
        me._value = null;
        me.syncInputFieldValue();
        me.syncEmpty();
        if (!me.isConfiguring) {
          me.triggerFieldChange({
            value,
            oldValue: oldValue2,
            userAction: isUserAction,
            valid: me.isValid
          });
        }
      }
    }
    me._lastValue = me._value;
  }
  hasChanged(oldValue, newValue) {
    if (this.multiSelect) {
      return !ObjectHelper.isEqual(oldValue, newValue);
    }
    return super.hasChanged(...arguments);
  }
  onComboStoreChange({ action }) {
    if (action !== "filter") {
      this.syncInputFieldValue(true);
    }
  }
  syncInputFieldValue(skipHighlight) {
    var _a2;
    if (this.usesChipView) {
      (_a2 = this.chipView) == null ? void 0 : _a2.refresh();
    } else {
      super.syncInputFieldValue(skipHighlight);
    }
  }
  get usesChipView() {
    return Boolean(this.multiSelect && this._chipView);
  }
  /**
   * Returns `true` if this field has no selected records.
   * @property {Boolean}
   * @readonly
   */
  get isEmpty() {
    return this.valueCollection.count === 0;
  }
  get inputValue() {
    const me = this;
    let result = me.selected ? me.selected[me.displayField] : me.value;
    if (me.displayValueRenderer) {
      result = me.callback(me.displayValueRenderer, me, [me.selected, me]);
    }
    return result == null ? "" : result;
  }
  get nonEditableClickTarget() {
    var _a2;
    return this.multiSelect && ((_a2 = this.chipView) == null ? void 0 : _a2.element) || super.nonEditableClickTarget;
  }
  /**
   * A {@link Core/util/Collection} which holds the currently selected records
   * from the store which dictates this field's value.
   *
   * Usually, this will contain one record, the record selected.
   *
   * When {@link #config-multiSelect} is `true`, there may be several records selected.
   * @member {Core.util.Collection} valueCollection
   * @readonly
   */
  changeValueCollection(valueCollection, oldValueCollection) {
    oldValueCollection == null ? void 0 : oldValueCollection.destroy();
    if (valueCollection) {
      if (!valueCollection.isCollection) {
        valueCollection = new Collection({
          internalListeners: {
            noChange: "onValueCollectionNoChange",
            change: "onValueCollectionChange",
            prio: -1e3,
            // The ChipView must react to changes first.
            thisObj: this
          }
        });
      }
      return valueCollection;
    }
  }
  changePrimaryFilter(primaryFilter) {
    if (primaryFilter.isCollectionFilter) {
      primaryFilter.setConfig({
        disabled: true,
        property: this.displayField,
        operator: this.filterOperator,
        caseSensitive: this.caseSensitive
      });
    } else {
      if (typeof primaryFilter === "function") {
        primaryFilter = {
          filterBy: primaryFilter
        };
      }
      primaryFilter = new CollectionFilter({
        // Need an id to replace any existing combo filter on the store.
        id: "primary",
        disabled: true,
        property: this.displayField,
        operator: this.filterOperator,
        caseSensitive: this.caseSensitive,
        ...primaryFilter
      });
    }
    return primaryFilter;
  }
  changeStore(store) {
    const me = this, storeFilters = [], {
      valueCollection,
      keyStrokeFilterDelay,
      filterParamName
    } = me;
    if (Array.isArray(store)) {
      me.items = store;
      return;
    }
    let remoteFilter;
    if (store) {
      if (store.isStore) {
        const sharedFilter = store.filters.get("primary");
        if (me.remoteFilter) {
          store.filterParamName = filterParamName;
        }
        remoteFilter = store.remoteFilter || store.restfulFilter;
        if (sharedFilter) {
          me.primaryFilter = sharedFilter;
        } else {
          storeFilters.push(me.primaryFilter);
        }
      } else {
        if (typeof store === "string") {
          store = Store.getStore(store);
        } else {
          store = new (store.readUrl ? AjaxStore : Store)(store);
          me.destroyStore = true;
        }
        remoteFilter = me.remoteFilter || store.restfulFilter;
        if (remoteFilter && filterParamName) {
          store.filterParamName = filterParamName;
          if (me.encodeFilterParams) {
            store.encodeFilterParams = me.encodeFilterParams;
          }
        }
        storeFilters.push(me.primaryFilter);
      }
      if (!me.valueField && !me.usingRecordAsValue) {
        me.valueField = store.modelClass.idField;
      }
      if (me.filterSelected) {
        const selectedItemsFilter = (r) => !me.containsFocus || !valueCollection.includes(r);
        if (remoteFilter) {
          store.storage.autoFilter = true;
          store.storage.addFilter({
            id: `${me.id}-selected-filter`,
            filterBy: selectedItemsFilter
          });
        } else {
          storeFilters.push(selectedItemsFilter);
          store.reapplyFilterOnAdd = true;
        }
      }
      valueCollection.addIndex({
        property: me.displayField,
        unique: false
      });
      valueCollection.addIndex({
        property: me.valueField,
        unique: true
      });
      storeFilters.forEach((f) => store.addFilter(f, true));
      if (remoteFilter) {
        me.keyStrokeFilterDelay = Math.max(300, keyStrokeFilterDelay || 0);
      } else {
        me.keyStrokeFilterDelay = keyStrokeFilterDelay != null ? keyStrokeFilterDelay : 10;
      }
    }
    return store;
  }
  updateStore(store, oldStore) {
    const me = this, { _picker } = me;
    let storeListeners;
    if (me.destroyStore && oldStore) {
      oldStore.destroy();
    }
    if (_picker) {
      _picker.store = store;
    }
    store.storage.addIndex({
      property: me.displayField,
      unique: false
    });
    store.storage.addIndex({
      property: me.valueField,
      unique: true
    });
    storeListeners = {
      filter: "onStoreFilter"
    };
    if (me.displayValueRenderer) {
      (storeListeners || (storeListeners = {})).change = "onComboStoreChange";
    }
    me.detachListeners("store");
    (store == null ? void 0 : store.storage) && me.valueCollection.match(store.storage);
    me.syncInputFieldValue();
    if (storeListeners) {
      storeListeners.name = "store";
      storeListeners.thisObj = me;
      store.ion(storeListeners);
    }
  }
  get remoteFilter() {
    var _a2;
    return Boolean(this.filterParamName || ((_a2 = this._store) == null ? void 0 : _a2.restfulFilter));
  }
  /**
   * Get selected record.
   * @property {Core.data.Model[]}
   * @readonly
   */
  get record() {
    return this.selected;
  }
  /**
   * Get the selected record(s).
   * @property {Core.data.Model[]}
   * @readonly
   */
  get records() {
    return this.valueCollection.values.slice();
  }
  get selected() {
    const { store } = this;
    return this.multiSelect ? this.valueCollection.values.slice().sort((l, r) => store.indexOf(l) - store.indexOf(r))[0] : this.valueCollection.first;
  }
  //endregion
  //region Value handling
  /**
   * Check if field value is valid
   * @internal
   */
  onEditComplete() {
    const me = this, selectionCount = me.valueCollection.count;
    super.onEditComplete();
    if (selectionCount) {
      me.clearError(errorValidateFilter);
      me.syncInputFieldValue();
    }
    if (me.required && !selectionCount) {
      me.setError(errorFieldRequired);
    }
  }
  //endregion
  //region Events
  /**
   * User clicked trigger icon, toggle list.
   * @private
   */
  onTriggerClick(event) {
    var _a2;
    const me = this, activatePicker = "key" in event;
    if (me.ignoreTriggerClick || me.remoteFilter && me.filterOnEnter) {
      return;
    }
    if (me.pickerVisible) {
      me.hidePicker();
    } else if (!me.readOnly && !me.disabled) {
      switch ((_a2 = me.triggerAction) == null ? void 0 : _a2.toLowerCase()) {
        case "all":
          me.doFilter(null, activatePicker);
          break;
        case "last":
          me.doFilter(me.lastQuery, activatePicker);
          break;
        default:
          me.doFilter(me.input.value, activatePicker);
      }
    }
  }
  /**
   * User types into input field in editable combo, show list and filter it.
   * @private
   */
  internalOnInput(event) {
    const me = this;
    me.syncEmpty();
    me.syncInputWidth();
    me.filterOnInput(event);
    me.trigger("input", { value: me.input.value, event });
  }
  filterOnInput(event) {
    const me = this, { value } = event.type === "input" ? event.target : me.input, inputLen = value.length;
    me.inputting = true;
    if (me.inlinePicker || inputLen >= me.minChars && (!me.filterOnEnter || event.key === "Enter")) {
      me.doFilter(value);
    } else {
      if (me.validateFilter && !me.remoteFilter) {
        me[inputLen ? "setError" : "clearError"](errorValidateFilter);
      }
      me.hidePicker();
    }
    me.inputting = false;
  }
  syncInputWidth() {
    const me = this;
    if (me.usesChipView) {
      const input = me.input, inputPadding = me._inputPadding || (me._inputPadding = DomHelper.getEdgeSize(input, "padding", "lr")), value = input.value || "", width = (
        // +'W' to avoid text getting clipped or horizontal scrolling
        DomHelper.measureText(value + "W", input, false, me.element) + inputPadding.width
      );
      input.style.flex = `1 1 ${Math.ceil(width)}px`;
    }
  }
  doFilter(queryString, activatePicker) {
    var _a2;
    const me = this, {
      store,
      // Force the lazy config to create picker since the List needs to add its beforeLoad listener
      picker
    } = me, disableFilter = queryString == null || queryString === "";
    me.lastQuery = queryString;
    me.primaryFilter.setConfig({
      value: queryString,
      disabled: disableFilter
    });
    if (me.remoteFilter) {
      store.clear(true);
    }
    const onAfterFilter = () => {
      const { navigator: navigator2, isVisible: isVisible2 } = picker;
      if (store.count) {
        if (!disableFilter && navigator2) {
          navigator2.activeItem = 0;
        }
      } else if (!me.remoteFilter && !disableFilter) {
        if (navigator2) {
          navigator2.activeItem = null;
        }
        if (me.validateFilter) {
          me.setError(errorValidateFilter);
        }
      }
      isVisible2 && picker.realign();
    };
    (_a2 = me.filterPromise = store.filter()) == null ? void 0 : _a2.then(() => {
      me.filterPromise = null;
      onAfterFilter();
    });
    if (!me.inlinePicker) {
      if (picker == null ? void 0 : picker.isVisible) {
        if (picker.lastAlignSpec.zone === 0) {
          picker.realign();
        }
      } else {
        me.showPicker(activatePicker);
      }
    }
    if (!me.filterPromise) {
      onAfterFilter();
    }
  }
  onStoreFilter({ source: store }) {
    const me = this, picker = me._picker, dataset = picker == null ? void 0 : picker.element.dataset, { count } = store;
    if (me.remoteFilter) {
      if (count) {
        if (picker) {
          picker.navigator.activeItem = 0;
        }
      } else {
        if (me.validateFilter) {
          me.setError(errorValidateFilter);
        }
      }
      if (me.filterSelected && me.valueCollection.count) {
        store.storage.onFiltersChanged({ action: "splice", oldCount: 1 });
        if (picker) {
          picker.refresh();
        }
      }
    }
    if (dataset) {
      if (me.createOnUnmatched && !count && me.primaryFilter.value != null) {
        dataset.addNewValue = me.L("L{addNewValue}")(me.primaryFilter.value);
      } else {
        dataset == null ? true : delete dataset.addNewValue;
      }
    }
  }
  /**
   * This reacts to our {@link #property-valueCollection} being mutated in any way.
   * The `change`, `select` and `action` events are fired here.
   *
   * This could happen in four ways:
   *
   *  - User selected or deselected an item in the dropdown list.
   *  - `set value` changes the content.
   *  - The {@link #config-multiSelect} Chip view (which uses this in its store) deletes a record.
   *  - The application programmatically mutates the {@link #property-valueCollection}.
   *
   * @private
   */
  onValueCollectionChange({ source: valueCollection }) {
    var _a2, _b, _c, _d;
    const me = this, { multiSelect, _picker } = me, hidePicker = (_a2 = me.hidePickerOnSelect) != null ? _a2 : !multiSelect, record = multiSelect ? valueCollection.values.slice() : valueCollection.first, records = valueCollection.values.slice(), isUserAction = me._isUserAction || (_picker == null ? void 0 : _picker._isUserAction) || hidePicker && me.pickerVisible || false, oldValue = me._value;
    if (hidePicker) {
      me.hidePicker();
    }
    if (!valueCollection.count && me.required) {
      me.setError(errorFieldRequired);
    } else {
      me.clearError(errorFieldRequired);
      me.clearError(errorValidateFilter);
    }
    if (me.validateFilter && record) {
      me.clearError(errorValidateFilter);
    }
    if (me.filterSelected) {
      const navigator2 = _picker == null ? void 0 : _picker.navigator, activeItem = Number((_c = (_b = navigator2 == null ? void 0 : navigator2.activeItem) == null ? void 0 : _b.dataset) == null ? void 0 : _c.index);
      if (me.remoteFilter) {
        me.store.storage.onFiltersChanged({ action: "splice", oldCount: 1 });
        if (me._picker) {
          me._picker.refresh();
        }
      } else {
        me.store.filter();
      }
      if (!isNaN(activeItem)) {
        navigator2.activeItem = Math.min(_picker.store.count, activeItem);
      }
    }
    me._value = null;
    me._lastValue = null;
    const value = me.cacheCurrentValue(me.value);
    me.syncInputFieldValue();
    me.syncEmpty();
    if (!me.isConfiguring) {
      me.triggerFieldChange({
        value,
        oldValue,
        userAction: isUserAction,
        valid: me.isValid
      });
      (_d = me.trigger) == null ? void 0 : _d.call(me, "select", { record, records, userAction: isUserAction });
      if (me.defaultAction === "select") {
        me.trigger("action", { value, record, records, userAction: isUserAction });
      }
    }
  }
  // Caching a copy of current value, which can be changed by subclasses (see AssignmentField for reference)
  cacheCurrentValue(v) {
    return this._value = v;
  }
  /**
   * This listens for when a record from the list is selected, but is already part of
   * the selection and so the {@link #property-valueCollection} rejects that as a no-op.
   * At this point, the user will still expect the picker to hide.
   * @param {Object} event The noChange event containing the splice parameters
   * @private
   */
  onValueCollectionNoChange({ toAdd }) {
    if (!this.inlinePicker && !this.multiSelect && toAdd.length && this.pickerVisible) {
      this.picker.hide();
      this.syncInputFieldValue();
    }
  }
  //endregion
  //region Picker
  showPicker() {
    var _a2;
    const me = this, { picker } = me;
    if (me.readOnly || me.inlinePicker) {
      return;
    }
    picker.multiSelect = me.multiSelect;
    super.showPicker(...arguments);
    if (me.overlayAnchor && !picker.align.offset) {
      picker.align.offset = -picker.anchorSize[1];
      picker.realign();
    }
    if (picker.restoreActiveItem) {
      if (me.multiSelect) {
        picker.restoreActiveItem(((_a2 = picker.navigator) == null ? void 0 : _a2.previousActiveItem) || me.selected || 0, true);
      } else {
        picker.restoreActiveItem(me.selected || 0, true);
      }
    }
    me.input.focus();
  }
  /**
   * Creates default picker widget
   *
   * @internal
   */
  changePicker(picker, oldPicker) {
    if (picker) {
      const me = this, pickerWidth = me.pickerWidth || (picker == null ? void 0 : picker.width), config = List.mergeConfigs({
        owner: me,
        store: me.store,
        selected: me.valueCollection,
        multiSelect: me.multiSelect,
        cls: me.listCls,
        displayField: me.displayField,
        forElement: me[me.pickerAlignElement],
        align: {
          matchSize: pickerWidth == null,
          anchor: me.overlayAnchor,
          target: me[me.pickerAlignElement],
          // Reasonable minimal height to fit few combo items below the combo.
          // When height is not enough, list will appear on top. That works for windows higher than 280px,
          // worrying about shorter windows sounds overkill.
          // We cannot use relative measures here, each combo list item is ~40px high
          minHeight: me.inlinePicker ? null : Math.min(3, me.store.count) * 40
        },
        [me.listItemTpl ? "itemTpl" : void 0]: me.listItemTpl,
        width: pickerWidth,
        navigator: {
          keyEventTarget: me.input
        }
      }, picker);
      if (me.inlinePicker) {
        Object.assign(config, {
          floating: false,
          align: null,
          activateOnMouseover: false,
          maxHeight: null,
          appendTo: me.element
        });
      }
      picker = List.reconfigure(oldPicker, picker ? config : null, me);
      picker.element.classList.add("b-combo-picker");
      picker.element.dataset.emptyText = me.emptyText ? me.L(me.emptyText) : me.L("L{noResults}");
      picker.ion({
        navigate: "onPickerNavigate",
        thisObj: me
      });
      EventHelper.on({
        element: picker.element,
        pointerdown: (event) => me.onPickerNavigate({ event }),
        thisObj: me
      });
    } else {
      oldPicker == null ? void 0 : oldPicker.destroy();
    }
    return picker;
  }
  onPickerNavigate({ event }) {
    if (event.target.matches("[data-add-new-value]")) {
      this.addNewRecord(this.primaryFilter.value);
    }
  }
  onPickerHide() {
    const me = this;
    super.onPickerHide();
    if (me.multiSelect && me.clearTextOnPickerHide) {
      me.input.value = "";
    }
  }
  //endregion
  async internalOnKeyEvent(keyEvent) {
    var _a2;
    const me = this, value = me.input[me.inputValueAttr], inputLen = value.length, { key } = keyEvent, {
      primaryFilter,
      store,
      _picker: picker,
      multiSelect
    } = me;
    if (keyEvent.type === "keydown" && (picker == null ? void 0 : picker.isVisible) && picker.navigator) {
      const { activeItem } = picker.navigator;
      if (activeItem && multiSelect && key === me.multiValueSeparator) {
        me.input.value = "";
        primaryFilter.setConfig({
          value: "",
          disabled: true
        });
        store.filter();
        picker.onItemClick(activeItem, keyEvent);
        picker.hide();
        keyEvent.preventDefault();
        return;
      }
      if (!activeItem && me.createOnUnmatched && (multiSelect && key === me.multiValueSeparator || key === "Enter")) {
        keyEvent.preventDefault();
        await me.addNewRecord(value);
        return;
      }
    }
    if (!me.editable && me.pickerVisible) {
      if (key === "Backspace" && ((_a2 = primaryFilter.value) == null ? void 0 : _a2.length)) {
        primaryFilter.value = primaryFilter.value.substring(0, primaryFilter.value.length - 1);
        me.store.filter();
        picker.restoreActiveItem(0);
      } else if (keyEvent.type == "keypress" && key.match(filterKeyTypes)) {
        if (!me.lastFilterKepressTime || keyEvent.timeStamp - me.lastFilterKepressTime > 2e3) {
          primaryFilter.value = "";
        }
        primaryFilter.setConfig({
          value: (primaryFilter.value || "") + key,
          disabled: false
        });
        me.store.filter();
        picker.restoreActiveItem(0);
      }
      me.lastFilterKepressTime = keyEvent.timeStamp;
    }
    super.internalOnKeyEvent(...arguments);
    if (keyEvent.type === "keydown" && key === "Enter" && me.filterOnEnter && inputLen >= me.minChars) {
      keyEvent.stopPropagation();
      me.filterOnInput.now(keyEvent);
    }
  }
  async addNewRecord(value) {
    var _a2, _b;
    const me = this, {
      store,
      _picker: picker,
      valueCollection,
      multiSelect,
      primaryFilter
    } = me, remoteAutoCommit = store.remoteFilter && store.autoCommit;
    if (me.filterPromise) {
      await me.filterPromise;
    }
    if (!remoteAutoCommit) {
      primaryFilter.setConfig({
        value: "",
        disabled: true
      });
      store.filter();
    }
    const [newRecord] = store.add(me.callback(me.createOnUnmatched, me, [value, me]));
    if (store.isCommitting) {
      let error;
      try {
        await store.commitPromise;
      } catch (exception) {
        error = (_b = (_a2 = exception.response) == null ? void 0 : _a2.parsedJson) == null ? void 0 : _b.error;
      }
      if (newRecord.isPhantom) {
        me.clearError();
        me.setError(error || errorRecordNotCommitted, false, true);
        store.remove(newRecord);
        store.removed.remove(newRecord);
      }
    }
    if (remoteAutoCommit) {
      primaryFilter.setConfig({
        value: "",
        disabled: true
      });
      store.filter();
    }
    me.input.value = "";
    if (store.includes(newRecord)) {
      valueCollection.splice(multiSelect ? valueCollection.count : 0, multiSelect ? 0 : valueCollection.count, newRecord);
    }
    picker == null ? void 0 : picker.hide();
  }
  changeCreateOnUnmatched(createOnUnmatched) {
    if (createOnUnmatched === true) {
      createOnUnmatched = this.defaultRecordCreater;
    }
    return createOnUnmatched;
  }
  defaultRecordCreater(value) {
    return this.store.createRecord({
      [this.displayField]: value
    });
  }
  updateLocalization() {
    var _a2;
    super.updateLocalization();
    const me = this, { displayField } = me;
    let { localizedDisplayFieldsMap } = me;
    if (me.localizeDisplayFields === true) {
      if (!localizedDisplayFieldsMap) {
        me.localizedDisplayFieldsMap = localizedDisplayFieldsMap = /* @__PURE__ */ new Map();
      }
      if (!me.store && me.buildItems) {
        me.items = me.buildItems();
      }
      for (const item of me.items) {
        if (item.id) {
          let localeString = localizedDisplayFieldsMap.get(item.id);
          if (!localeString && ((_a2 = item[displayField]) == null ? void 0 : _a2.startsWith("L{"))) {
            localeString = item[displayField];
            localizedDisplayFieldsMap.set(item.id, localeString);
          }
          if (localeString) {
            item[displayField] = me.L(localeString);
          }
        }
      }
      me.syncInputFieldValue();
    }
  }
};
//region Config
__publicField(Combo, "$name", "Combo");
__publicField(Combo, "type", "combo");
__publicField(Combo, "alias", "combobox,dropdown");
__publicField(Combo, "delayable", {
  filterOnInput: 0
});
var ComboChipView = class extends ChipView {
  static get $name() {
    return "ComboChipView";
  }
  static get type() {
    return "combochipview";
  }
  static get defaultConfig() {
    return {
      closeHandler: "up.onChipClose",
      itemsFocusable: false,
      multiSelect: true,
      itemTpl(record) {
        return StringHelper.encodeHtml(record.getValue(this.owner.displayField));
      },
      scrollable: {
        overflowY: "auto"
      }
    };
  }
};
var ComboChipNavigator = class extends Navigator {
  static get $name() {
    return "ComboChipNavigator";
  }
  // Factoryable type name
  static get type() {
    return "combochipnavigator";
  }
  static get configurable() {
    return {
      allowShiftKey: true
    };
  }
  onTargetClick(clickEvent) {
    const me = this, item = clickEvent.target.closest(me.itemSelector);
    if (item && !clickEvent.target.classList.contains("b-close-icon")) {
      if (!clickEvent.shiftKey && !item.contains(clickEvent.target.closest("[data-noselect]"))) {
        me.ownerCmp.selected.clear();
      }
      me.inClickHandler = true;
      me.activeItem = item;
      me.inClickHandler = false;
    }
  }
  onKeyDown(keyEvent) {
    if (keyEvent.key !== "Enter" && !keyEvent.target.selectionStart && !keyEvent.target.selectionEnd) {
      super.onKeyDown(keyEvent);
    }
  }
  updateActiveItem(activeItem, oldActiveItem) {
    const chipView = this.ownerCmp;
    super.updateActiveItem(activeItem, oldActiveItem);
    if (activeItem && !this.inClickHandler) {
      chipView.selected.add(chipView.getRecordFromElement(activeItem));
    }
  }
  navigatePrevious(keyEvent) {
    const chipView = this.ownerCmp;
    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.previous) {
      super.navigatePrevious(keyEvent);
    } else {
      this.activeItem = null;
    }
  }
  navigateNext(keyEvent) {
    const chipView = this.ownerCmp;
    if (chipView.navigator.activeItem && !keyEvent.shiftKey) {
      chipView.selected.clear();
    }
    if (this.next) {
      super.navigateNext(keyEvent);
    } else {
      this.activeItem = null;
    }
  }
};
Combo.initClass();
ComboChipView.initClass();
ComboChipNavigator.initClass();
Combo._$name = "Combo";

// ../Core/lib/Core/widget/base/UndoRedoBase.js
var UndoRedoBase = class extends Container {
  static get configurable() {
    return {
      // Documented on subclasses
      project: null,
      stm: null,
      /**
       * Configure as `true` to show "Undo" and "Redo" as button texts. The buttons always have a tooltip
       * as a hint to the user as to their purpose.
       * @config {Boolean}
       */
      text: null,
      /**
       * Button color for the undo and redo buttons. See {@link Core.widget.Button#config-color}.
       * @config {String}
       */
      color: null,
      /**
       * Configure as `true` to show "0" badge on the undo and redo buttons when they have no actions
       * left to perform. By default when there are no actions, no badge is displayed.
       * @config {Boolean}
       */
      showZeroActionBadge: null,
      cls: "b-undo-controls b-toolbar",
      layoutStyle: {
        alignItems: "stretch",
        flexFlow: "row nowrap",
        overflow: "visible"
      },
      items: {
        undoBtn: {
          type: "button",
          icon: "b-icon-undo",
          tooltip: "L{UndoRedo.UndoLastAction}",
          onAction: "up.onUndo"
          // 'up.' means method is on a parent Widget.
        },
        transactionsCombo: {
          type: "combo",
          valueField: "idx",
          editable: false,
          store: {},
          emptyText: "L{UndoRedo.NoActions}",
          onAction: "up.onTransactionSelected",
          displayValueRenderer: "up.transactionsDisplayValueRenderer"
        },
        redoBtn: {
          type: "button",
          icon: "b-icon-redo",
          tooltip: "L{UndoRedo.RedoLastAction}",
          onAction: "up.onRedo"
        }
      },
      // This is treated as atomic by the Toolbar's menu overflow processing.
      overflowable: true
    };
  }
  afterConstruct() {
    this.updateUndoRedoControls();
  }
  updateStm(stm) {
    this.detachListeners("undoredo");
    stm == null ? void 0 : stm.ion({
      name: "undoredo",
      recordingstop: "updateUndoRedoControls",
      restoringstop: "updateUndoRedoControls",
      queueReset: "updateUndoRedoControls",
      disabled: "updateUndoRedoControls",
      thisObj: this
    });
  }
  changeItems(items2) {
    const { undoBtn, redoBtn } = items2;
    if (this.color) {
      undoBtn && (undoBtn.color = this.color);
      redoBtn && (redoBtn.color = this.color);
    }
    if (this.text) {
      undoBtn && (undoBtn.text = "L{UndoRedo.Undo}");
      redoBtn && (redoBtn.text = "L{UndoRedo.Redo}");
    }
    return super.changeItems(items2);
  }
  updateProject(project) {
    this.stm = project.stm;
  }
  fillUndoRedoCombo() {
    const { transactionsCombo } = this.widgetMap;
    transactionsCombo && (transactionsCombo.items = [[0, "Original data"], ...this.stm.queue.map((title, idx) => [idx + 1, title || `Transaction ${idx + 1}`])]);
  }
  updateUndoRedoControls() {
    const {
      stm,
      showZeroActionBadge
    } = this, {
      undoBtn,
      redoBtn,
      transactionsCombo
    } = this.widgetMap;
    undoBtn.badge = stm.position || (showZeroActionBadge ? "0" : "");
    redoBtn.badge = stm.length - stm.position || (showZeroActionBadge ? "0" : "");
    undoBtn.disabled = !stm.canUndo;
    redoBtn.disabled = !stm.canRedo;
    this.fillUndoRedoCombo();
    if (transactionsCombo) {
      transactionsCombo.disabled = transactionsCombo.store.count <= 1;
    }
  }
  transactionsDisplayValueRenderer(record, combo) {
    var _a2;
    const stmPos = ((_a2 = this.stm) == null ? void 0 : _a2.position) || 0;
    return `${stmPos} undo actions / ${combo.store.count - stmPos - 1} redo actions`;
  }
  onUndo() {
    this.stm.canUndo && this.stm.undo();
  }
  onRedo() {
    this.stm.canRedo && this.stm.redo();
  }
  onTransactionSelected(combo) {
    const { stm } = this, delta = stm.position - combo.value;
    if (delta > 0) {
      stm.canUndo && stm.undo(delta);
    } else if (delta < 0) {
      stm.canRedo && stm.redo(-delta);
    }
  }
};
__publicField(UndoRedoBase, "$name", "UndoRedoBase");
__publicField(UndoRedoBase, "type", "undoredobase");
UndoRedoBase.initClass();
UndoRedoBase._$name = "UndoRedoBase";

// ../Core/lib/Core/widget/BooleanCombo.js
var BooleanCombo = class extends Combo {
  //region Config
  static get configurable() {
    return {
      /**
       * Positive option value
       *
       * @config {*}
       */
      positiveValue: true,
      /**
       * Positive option display value
       *
       * @config {String}
       */
      positiveText: null,
      /**
       * Negative option value
       *
       * @config {*}
       */
      negativeValue: false,
      /**
       * False option display value
       *
       * @config {String}
       */
      negativeText: null,
      store: {
        value: [],
        $config: "lazy"
      },
      /**
       * Default value
       *
       * @config {*}
       */
      value: false
    };
  }
  //endregion
  changeStore(store, oldStore) {
    const me = this;
    return super.changeStore(new Store({
      data: [{
        id: me.positiveValue,
        text: me.positiveText || me.L("L{Object.Yes}")
      }, {
        id: me.negativeValue,
        text: me.negativeText || me.L("L{Object.No}")
      }]
    }), oldStore);
  }
};
__publicField(BooleanCombo, "$name", "BooleanCombo");
__publicField(BooleanCombo, "type", "booleancombo");
BooleanCombo.initClass();
BooleanCombo._$name = "BooleanCombo";

// ../Core/lib/Core/widget/ButtonGroup.js
var _ButtonGroup = class _ButtonGroup extends Container.mixin(Rotatable_default) {
  onChildAdd(item) {
    super.onChildAdd(item);
    item.ion({
      click: "resetValueCache",
      toggle: "onItemToggle",
      thisObj: this,
      // This needs to run before the 'click' event is relayed by this button group, in such listener
      // the `value` must already be updated
      prio: 1e4
    });
  }
  onChildRemove(item) {
    item.un({
      toggle: "resetValueCache",
      click: "resetValueCache",
      thisObj: this
    });
    super.onChildRemove(item);
  }
  onItemToggle(event) {
    const me = this;
    me.resetValueCache();
    if (!me.isSettingValue && (!me.toggleGroup || event.pressed)) {
      me.triggerFieldChange({ value: me.value, userAction: true, event });
    }
  }
  resetValueCache() {
    this._value = null;
  }
  createWidget(widget) {
    const me = this, type = me.constructor.resolveType(widget.type || "button");
    if (type.isButton) {
      if (me.color && !widget.color) {
        widget.color = me.color;
      }
      if (me.toggleGroup && !widget.toggleGroup) {
        if (typeof me.toggleGroup === "boolean") {
          me.toggleGroup = _ButtonGroup.generateId("toggleGroup");
        }
        widget.toggleGroup = me.toggleGroup;
      }
    }
    if (me.columns) {
      widget.width = `${100 / me.columns}%`;
    }
    widget = super.createWidget(widget);
    me.relayEvents(widget, ["click", "action", "toggle"]);
    return widget;
  }
  updateRotate(rotate) {
    this.eachWidget((btn) => {
      if (btn.rotate !== false) {
        btn.rotate = rotate;
      }
    });
  }
  get value() {
    if (!this._value) {
      const values = [];
      this.items.forEach((w) => {
        if (w.pressed && w.value !== void 0) {
          values.push(w.value);
        }
      });
      this._value = values.join(this.valueSeparator);
    }
    return this._value;
  }
  set value(value) {
    const me = this, oldValue = me.value;
    if (!Array.isArray(value)) {
      if (value === void 0 || value === null) {
        value = [];
      } else if (typeof value == "string") {
        value = value.split(me.valueSeparator);
      } else {
        value = [value];
      }
    }
    me._value = value.join(me.valueSeparator);
    me.isSettingValue = true;
    me.items.forEach((w) => {
      if (w.value !== void 0) {
        w.pressed = value.includes(w.value);
      }
    });
    me.isSettingValue = false;
    if (!me.isConfiguring && oldValue !== me.value) {
      me.triggerFieldChange({ value: me.value, userAction: false });
    }
  }
  updateDisabled(disabled) {
    this.items.forEach((button) => button.disabled = disabled || !button.ignoreParentReadOnly && this.readOnly);
  }
  updateReadOnly(readOnly) {
    super.updateReadOnly(readOnly);
    this.updateDisabled(this.disabled);
  }
  get widgetClassList() {
    const classList = super.widgetClassList;
    this.columns && classList.push("b-columned");
    return classList;
  }
};
/**
 * Fires when a button in the group is clicked
 * @event click
 * @param {Core.widget.Button} source Clicked button
 * @param {Event} event DOM event
 */
/**
 * Fires when the default action is performed on a button in the group (the button is clicked)
 * @event action
 * @param {Core.widget.Button} source Clicked button
 * @param {Event} event DOM event
 */
/**
 * Fires when a button in the group is toggled (the {@link Core.widget.Button#property-pressed} state is changed).
 * If you need to process the pressed button only, consider using {@link #event-click} event or {@link #event-action} event.
 * @event toggle
 * @param {Core.widget.Button} source Toggled button
 * @param {Boolean} pressed New pressed state
 * @param {Event} event DOM event
 */
__publicField(_ButtonGroup, "$name", "ButtonGroup");
__publicField(_ButtonGroup, "type", "buttongroup");
__publicField(_ButtonGroup, "configurable", {
  defaultType: "button",
  /**
   * Custom CSS class to add to element. When using raised buttons (cls 'b-raised' on the buttons), the group
   * will look nicer if you also set that cls on the group.
   *
   * ```
   * new ButtonGroup({
   *   cls : 'b-raised,
   *   items : [
   *       { icon : 'b-fa b-fa-unicorn', cls : 'b-raised' },
   *       ...
   *   ]
   * });
   * ```
   *
   * @config {String}
   * @category CSS
   */
  cls: null,
  /**
   * An array of Buttons or typed Button config objects.
   * @config {ButtonConfig[]|Core.widget.Button[]}
   */
  items: null,
  /**
   * Default color to apply to all contained buttons, see {@link Core.widget.Button#config-color Button#color}.
   * Individual buttons can override the default.
   * @config {String}
   */
  color: null,
  /**
   * Set to `true` to turn the ButtonGroup into a toggle group, assigning a generated value to each contained
   * buttons {@link Core.widget.Button#config-toggleGroup toggleGroup config}. Individual buttons can
   * override the default.
   * @config {Boolean}
   */
  toggleGroup: null,
  valueSeparator: ",",
  columns: null,
  hideWhenEmpty: true,
  defaultBindProperty: "value"
});
var ButtonGroup = _ButtonGroup;
ButtonGroup.initClass();
ButtonGroup._$name = "ButtonGroup";

// ../Core/lib/Core/widget/CalendarPanel.js
var CalendarPanel = class extends Panel {
  static get configurable() {
    return {
      layout: "vbox",
      textContent: false,
      /**
       * Gets or sets the date that orientates the panel to display a particular month.
       * Changing this causes the content to be refreshed.
       * @member {Date} date
       */
      /**
       * The date which this CalendarPanel encapsulates.
       * @config {Date|String}
       */
      date: {
        $config: {
          equal: "date"
        },
        value: null
      },
      /**
       * A {@link Core.util.Month} Month utility object which encapsulates this Panel's month
       * and provides contextual information and navigation services.
       * @config {Core.util.Month|MonthConfig}
       */
      month: {},
      year: null,
      /**
       * The week start day, 0 meaning Sunday, 6 meaning Saturday.
       * Defaults to {@link Core.helper.DateHelper#property-weekStartDay-static}.
       * @config {Number}
       */
      weekStartDay: null,
      /**
       * Configure as `true` to always show a six week calendar.
       * @config {Boolean}
       * @default
       */
      sixWeeks: true,
      /**
       * Configure as `true` to show a week number column at the start of the calendar block.
       * @deprecated Since 4.0.0. Use {@link #config-showWeekColumn} instead.
       * @config {Boolean}
       */
      showWeekNumber: null,
      /**
       * Configure as `true` to show a week number column at the start of the calendar block.
       * @config {Boolean}
       */
      showWeekColumn: null,
      /**
       * Either an array of `Date` objects which are to be disabled, or
       * a function (or the name of a function), which, when passed a `Date` returns `true` if the
       * date is disabled.
       * @config {Function|Date[]|String}
       * @param {Date} date Date to check
       * @returns {Boolean} Returns `true` if the provided date is disabled
       */
      disabledDates: null,
      /**
       * A function (or the name of a function) which creates content in, and may mutate a day header element.
       *
       * @config {Function|String}
       * @param {Object} renderData
       * @param {HTMLElement} renderData.cell The header element
       * @param {Number} renderData.day The day number conforming to the specified {@link #config-weekStartDay}. Will be in the range `0` to `6`
       * @param {Number} renderData.weekDay The canonical day number where Monday is 0 and Sunday is
       * @returns {String|DomConfig|null}
       */
      headerRenderer: null,
      /**
       * A function (or the name of a function) which creates content in, and may mutate the week cell element at the start of a week row.
       *
       * @config {Function|String}
       * @param {Object} renderData
       * @param {HTMLElement} renderData.cell The header element
       * @param {Number[]} renderData.week An array containing `[year, weekNumber]`
       * @returns {String|DomConfig|null}
       */
      weekRenderer: null,
      /**
       * A function (or the name of a function) which creates content in, and may mutate a day cell element.
       *
       * @config {Function|String}
       * @param {Object} renderData
       * @param {HTMLElement} renderData.cell The header element
       * @param {Date} renderData.date The date for the cell
       * @param {Number} renderData.day The day for the cell (`0` to `6` for Sunday to Saturday)
       * @param {Number[]} renderData.rowIndex The row index, 0 to month row count (6 if {@link #config-sixWeeks} is `true`)
       * @param {HTMLElement} renderData.row The row element encapsulating the week which the cell is a part of
       * @param {Number[]} renderData.cellIndex The cell index in the whole panel. May be from `0` to up to `42`
       * @param {Number[]} renderData.columnIndex The column index, `0` to `6`
       * @param {Number[]} renderData.visibleColumnIndex The visible column index taking hidden non working days into account
       * @returns {String|DomConfig|null}
       */
      cellRenderer: null,
      /**
       * Configure as `true` to render weekends as {@link #config-disabledDates}.
       * @config {Boolean}
       */
      disableWeekends: null,
      hideNonWorkingDays: null,
      hideNonWorkingDaysCls: "b-hide-nonworking-days",
      /**
       * Non-working days as an object where keys are day indices, 0-6 (Sunday-Saturday), and the value is `true`.
       * Defaults to {@link Core.helper.DateHelper#property-nonWorkingDays-static}.
       * @config {Object<Number,Boolean>}
       */
      nonWorkingDays: null,
      /**
       * A config object to create a tooltip which will show on hover of a date cell including disabled, weekend,
       * and "other month" cells.
       *
       * It is the developer's responsibility to hook the `beforeshow` event to either veto the show by returning
       * `false` or provide contextual content for the date.
       *
       * The tip instance will be primed with a `date` property.
       * @config {TooltipConfig}
       */
      tip: null,
      dayCellCls: "b-calendar-cell",
      dayHeaderCls: "b-calendar-day-header",
      /**
       * The class name to add to disabled calendar cells.
       * @config {String}
       * @private
       */
      disabledCls: "b-disabled-date",
      /**
       * The class name to add to calendar cells which are in the previous or next month.
       * @config {String}
       * @private
       */
      otherMonthCls: "b-other-month",
      /**
       * The class name to add to calendar cells which are weekend dates.
       * @config {String}
       * @private
       */
      weekendCls: "b-weekend",
      /**
       * The class name to add to the calendar cell which contains today's date.
       * @config {String}
       * @private
       */
      todayCls: "b-today",
      /**
       * The class name to add to calendar cells which are {@link #config-nonWorkingDays}.
       * @config {String}
       * @private
       */
      nonWorkingDayCls: "b-nonworking-day",
      /**
       * The {@link Core.helper.DateHelper} format string to format the day names
       * in the header row above the calendar cells.
       * @config {String}
       * @default
       */
      dayNameFormat: "ddd",
      /**
       * By default, week rows flex to share available Panel height equally.
       *
       * Set this config if the available height is too small, and the cell height needs
       * to be larger to show events.
       *
       * Setting this config causes the month grid to become scrollable in the `Y` axis.
       *
       * May be specified as a number in which case it will be taken to mean pixels,
       * or a length in standard CSS units.
       * @config {Number|String}
       */
      minRowHeight: {
        $config: ["lazy"],
        value: null
      },
      /**
       * By default, day cells flex to share available Panel width equally.
       *
       * Set this config if the available width is too small, and the cell width needs
       * to be larger to show events.
       *
       * Setting this config causes the month grid to become scrollable in the `X` axis.
       * @config {Number}
       */
      minColumnWidth: {
        $config: ["lazy"],
        value: null
      },
      /**
       * Configure this as true to disable pointer interaction with cells which are outside the
       * range of the current month.
       * @config {Boolean}
       */
      disableOtherMonthCells: null,
      disableOtherMonthCellsCls: "b-disable-othermonth-cells",
      /**
       * Configure this as `true` to hide cells which are outside the range of the current month.
       * @config {Boolean}
       */
      hideOtherMonthCells: null,
      hideOtherMonthCellsCls: "b-hide-othermonth-cells",
      /**
       * By default, when navigating through time, the next time
       * block will be animated in from the appropriate direction.
       *
       * Configure this as `false` to disable this.
       * @prp {Boolean} animateTimeShift
       * @default
       */
      animateTimeShift: true
    };
  }
  construct(config) {
    super.construct(config);
    if (!this.refreshCount) {
      this.refresh();
    }
  }
  onInternalPaint({ firstPaint }) {
    var _a2;
    (_a2 = super.onInternalPaint) == null ? void 0 : _a2.call(this, ...arguments);
    if (firstPaint) {
      if (!this.refreshCount) {
        this.refresh();
      }
      this.getConfig("minColumnWidth");
      this.getConfig("minRowHeight");
    }
  }
  get overflowElement() {
    return this.weeksElement;
  }
  doDestroy() {
    var _a2;
    (_a2 = this.tip) == null ? void 0 : _a2.destroy();
    super.doDestroy();
  }
  updateMinRowHeight(minRowHeight) {
    this.element.style.setProperty("--min-row-height", DomHelper.setLength(minRowHeight));
    this.scrollable = {
      overflowY: minRowHeight ? "auto" : false
    };
  }
  updateMinColumnWidth(minColumnWidth) {
    const me = this;
    me.element.style.setProperty("--min-column-width", DomHelper.setLength(minColumnWidth));
    me.scrollable = {
      overflowX: minColumnWidth ? "auto" : false
    };
    me.overflowElement.classList[minColumnWidth ? "add" : "remove"]("b-min-columnwidth");
  }
  getDateFromDomEvent(domEvent) {
    const element = (domEvent.nodeType === Element.ELEMENT_NODE ? domEvent : domEvent.target).closest(`#${this.id} [data-date]`);
    if (element) {
      return DateHelper.parseKey(element.dataset.date);
    }
  }
  changeTip(tip, existingTip) {
    const me = this;
    return Tooltip.reconfigure(existingTip, tip, {
      owner: me,
      defaults: {
        type: "tooltip",
        owner: me,
        id: `${me.id}-cell-tip`,
        forElement: me.bodyElement,
        forSelector: `.${me.dayCellCls}`
      }
    });
  }
  updateTip(tip) {
    this.detachListeners("tip");
    tip == null ? void 0 : tip.ion({
      pointerOver: "onTipOverCell",
      name: "tip",
      thisObj: this
    });
  }
  updateElement(element, was) {
    const me = this;
    super.updateElement(element, was);
    me.updateHideNonWorkingDays(me.hideNonWorkingDays);
    me.weekdayCells = Array.from(element.querySelectorAll(".b-calendar-day-header"));
    me.weekElements = Array.from(element.querySelectorAll(".b-calendar-week"));
    me.weekDayElements = Array.from(element.querySelectorAll(".b-calendar-days"));
    me.cellElements = [];
    for (let i = 0, { length } = me.weekDayElements; i < length; i++) {
      me.cellElements.push(me.weekDayElements[i].previousSibling, ...me.weekDayElements[i].children);
    }
  }
  changeDate(date) {
    date = typeof date === "string" ? DateHelper.parse(date) : new Date(date);
    if (isNaN(date)) {
      throw new Error("CalendarPanel date ingestion must be passed a Date, or a YYYY-MM-DD date string");
    }
    return DateHelper.clearTime(date);
  }
  /**
   * The date which this CalendarPanel encapsulates. Setting this causes the
   * content to be refreshed.
   * @property {Date}
   */
  updateDate(value) {
    this.month.date = value;
  }
  updateDayNameFormat() {
    const d = /* @__PURE__ */ new Date("2000-06-04T12:00:00");
    this.shortDayNames = [];
    for (let date = 4; date < 11; date++) {
      d.setDate(date);
      this.shortDayNames.push(DateHelper.format(d, this.dayNameFormat));
    }
  }
  get weekStartDay() {
    return typeof this._weekStartDay === "number" ? this._weekStartDay : DateHelper.weekStartDay;
  }
  /**
   * Set to 0 for Sunday (the default), 1 for Monday etc.
   *
   * Set to `null` to use the default value from {@link Core/helper/DateHelper}.
   */
  updateWeekStartDay(weekStartDay) {
    const me = this;
    if (me._month) {
      me.month.weekStartDay = weekStartDay;
      me.dayNames = [];
      for (let i = 0; i < 7; i++) {
        me.dayNames[i] = me.shortDayNames[me.canonicalDayNumbers[i]];
      }
      if (me.refreshCount) {
        me.refresh();
      }
    }
  }
  updateHideNonWorkingDays(hideNonWorkingDays) {
    var _a2;
    this.contentElement.classList.toggle(this.hideNonWorkingDaysCls, Boolean(hideNonWorkingDays));
    (_a2 = this.scrollable) == null ? void 0 : _a2.syncOverflowState();
    if (this._month) {
      this.month.hideNonWorkingDays = hideNonWorkingDays;
    }
    if (!this.isConfiguring) {
      this.refresh();
    }
  }
  updateHideOtherMonthCells(hideOtherMonthCells) {
    var _a2;
    this.element.classList.toggle(this.hideOtherMonthCellsCls, Boolean(hideOtherMonthCells));
    (_a2 = this.scrollable) == null ? void 0 : _a2.syncOverflowState();
  }
  updateDisableOtherMonthCells(disableOtherMonthCells) {
    var _a2;
    this.element.classList.toggle(this.disableOtherMonthCellsCls, Boolean(disableOtherMonthCells));
    (_a2 = this.scrollable) == null ? void 0 : _a2.syncOverflowState();
  }
  get nonWorkingDays() {
    return this._nonWorkingDays || (this._localeNonWorkingDays || (this._localeNonWorkingDays = DateHelper.nonWorkingDays));
  }
  get weekends() {
    return this._localeWeekends || (this._localeWeekends = DateHelper.weekends);
  }
  changeNonWorkingDays(nonWorkingDays) {
    return ObjectHelper.assign({}, nonWorkingDays);
  }
  updateNonWorkingDays(nonWorkingDays) {
    var _a2;
    if (this._month) {
      this.month.nonWorkingDays = nonWorkingDays;
      this.refresh();
      (_a2 = this.scrollable) == null ? void 0 : _a2.syncOverflowState();
    }
  }
  get visibleDayColumnIndex() {
    return this.month.visibleDayColumnIndex;
  }
  get dayColumnIndex() {
    return this.month.dayColumnIndex;
  }
  get canonicalDayNumbers() {
    return this.month.canonicalDayNumbers;
  }
  get visibleColumnCount() {
    return this.month.visibleColumnCount;
  }
  get weekLength() {
    return this.month.weekLength;
  }
  /**
   * The date of the first day cell in this panel.
   * Note that this may *not* be the first of this panel's current month.
   * @property {Date}
   * @readonly
   */
  get startDate() {
    return this.month.startDate;
  }
  get duration() {
    return DateHelper.diff(this.month.startDate, this.month.endDate, "day") + 1;
  }
  /**
   * The end date of this view. Note that in terms of full days, this is exclusive,
   * ie: 2020-01-012 to 2020-01-08 is *seven* days. The end is 00:00:00 on the 8th.
   *
   * Note that this may *not* be the last date of this panel's current month.
   * @property {Date}
   * @readonly
   */
  get endDate() {
    const { endDate } = this.month;
    if (endDate) {
      return DateHelper.add(endDate, 1, "day");
    }
  }
  changeMonth(month2, currentMonth) {
    const me = this;
    if (!(month2 instanceof Month)) {
      if (typeof month2 === "number") {
        if (currentMonth) {
          currentMonth.month = month2;
          return;
        }
        const date = me.date || DateHelper.clearTime(/* @__PURE__ */ new Date());
        date.setMonth(month2);
        month2 = {
          date
        };
      }
      month2 = Month.new({
        weekStartDay: me.weekStartDay,
        nonWorkingDays: me.nonWorkingDays,
        hideNonWorkingDays: me.hideNonWorkingDays,
        sixWeeks: me.sixWeeks
      }, month2);
    }
    month2.ion({
      dateChange: "onMonthDateChange",
      thisObj: me
    });
    return month2;
  }
  onMonthDateChange({ source: month2, newDate, oldDate, changes }) {
    const me = this;
    me.year = month2.year;
    if (!me.isConfiguring) {
      if (!me.getCell(newDate) || (changes.m || changes.y)) {
        const { isVisible: isVisible2 } = me;
        me.refresh();
        if (me.animateTimeShift && isVisible2) {
          DomHelper.slideIn(me.contentElement, newDate > oldDate ? 1 : -1);
        }
      }
      me.trigger("dateChange", {
        changes,
        value: newDate,
        oldValue: oldDate
      });
    }
  }
  updateYear(year) {
    this.month.year = year;
  }
  updateShowWeekNumber(showWeekNumber) {
    this.updateShowWeekColumn(showWeekNumber);
  }
  updateShowWeekColumn(showWeekColumn) {
    const me = this;
    me.element.classList[showWeekColumn ? "add" : "remove"]("b-show-week-column");
    if (me.floating) {
      if (!me.isAligning) {
        me.realign();
      }
    }
  }
  updateSixWeeks(sixWeeks) {
    if (this.month) {
      this.month.sixWeeks = sixWeeks;
      this.refresh();
    }
  }
  /**
   * Refreshes the UI after changing a config that would affect the UI.
   */
  refresh() {
    this.doRefresh();
  }
  /**
   * Implementation of the UI refresh.
   * @private
   */
  doRefresh() {
    var _a2;
    this.getConfig("element");
    const me = this, timeZone = me.timeZone != null ? me.timeZone : (_a2 = me.project) == null ? void 0 : _a2.timeZone, today = timeZone != null ? TimeZoneHelper.toTimeZone(/* @__PURE__ */ new Date(), timeZone) : /* @__PURE__ */ new Date(), {
      weekElements,
      weekDayElements,
      date,
      month: month2,
      dayCellCls,
      dayHeaderCls,
      disabledCls,
      otherMonthCls,
      weekendCls,
      todayCls,
      nonWorkingDayCls,
      nonWorkingDays,
      canonicalDayNumbers,
      sixWeeks
    } = me;
    today.setHours(0, 0, 0, 0);
    if (!date) {
      me.date = today;
      return;
    }
    me.element.style.setProperty("--visible-week-count", month2.weekCount);
    me.trigger("beforeRefresh");
    me.getConfig("dayNameFormat");
    for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
      const cell = me.weekdayCells[columnIndex], cellDay = me.canonicalDayNumbers[columnIndex], cellClassList = {
        [dayHeaderCls]: 1,
        [weekendCls]: DateHelper.weekends[cellDay],
        [nonWorkingDayCls]: nonWorkingDays[cellDay]
      };
      if (me.headerRenderer) {
        cell.innerHTML = "";
        me.callback(me.headerRenderer, me, [cell, columnIndex, cellDay]);
      } else {
        DomHelper.setInnerText(cell, me.shortDayNames[cellDay]);
      }
      DomHelper.syncClassList(cell, cellClassList);
      cell.dataset.columnIndex = columnIndex;
      cell.dataset.cellDay = cellDay;
    }
    let rowIndex = 0, cellIndex = 0, lastWorkingColumn = 6;
    for (let columnIndex = 6; columnIndex >= 0; columnIndex--) {
      if (!nonWorkingDays[canonicalDayNumbers[columnIndex]]) {
        lastWorkingColumn = columnIndex;
        break;
      }
    }
    weekElements[4].classList.toggle("b-hide-display", month2.weekCount < 5 && !sixWeeks);
    weekElements[5].classList.toggle("b-hide-display", month2.weekCount < 6 && !sixWeeks);
    month2.eachWeek((week, dates) => {
      const weekDayElement = weekDayElements[rowIndex], weekCells = [weekDayElement.previousSibling, ...weekDayElement.children];
      weekElements[rowIndex].dataset.week = `${week[0]},${week[1]}`;
      if (me.weekRenderer) {
        me.callback(me.weekRenderer, me, [weekCells[0], week]);
      } else {
        weekCells[0].innerText = week[1];
      }
      for (let columnIndex = 0; columnIndex < 7; columnIndex++) {
        const date2 = dates[columnIndex], day2 = date2.getDay(), key = DateHelper.makeKey(date2), isNonWorking = nonWorkingDays[day2], cell = weekCells[columnIndex + 1], cellClassList = {
          [dayCellCls]: 1,
          [disabledCls]: me.isDisabledDate(date2),
          [otherMonthCls]: date2.getMonth() !== month2.month,
          [weekendCls]: DateHelper.weekends[day2],
          [todayCls]: date2.getTime() === today.getTime(),
          [nonWorkingDayCls]: isNonWorking,
          "b-last-working-day": columnIndex === lastWorkingColumn,
          "b-first-visible-cell": !(date2 - (me.firstVisibleDate || -1)),
          "b-last-visible-cell": !(date2 - (me.lastVisibleDate || -1)),
          [`b-day-of-week-${day2}`]: 1
        };
        DomHelper.syncClassList(cell, cellClassList);
        cell.dataset.date = key;
        cell.dataset.cellIndex = cellIndex;
        cell.dataset.columnIndex = columnIndex;
        if (cell.lastDomConfig) {
          delete cell.lastDomConfig.class;
          delete cell.lastDomConfig.className;
        }
        if (me.cellRenderer) {
          me.callback(me.cellRenderer, me, [{
            cell,
            date: date2,
            day: day2,
            row: weekElements[rowIndex],
            rowIndex,
            cellIndex,
            columnIndex,
            visibleColumnIndex: me.visibleDayColumnIndex[day2],
            week,
            key
          }]);
        } else {
          cell.innerHTML = date2.getDate();
        }
        cellIndex++;
      }
      rowIndex++;
    });
    me.visibleWeekCount = rowIndex;
    if (me.floating) {
      if (!me.isAligning) {
        me.realign();
      }
    }
    me.refreshCount = (me.refreshCount || 0) + 1;
    me.trigger("refresh");
  }
  isDisabledDate(date) {
    const day2 = date.getDay(), {
      disabledDates,
      nonWorkingDays
    } = this;
    if (this.disableWeekends && nonWorkingDays[day2]) {
      return true;
    }
    if (disabledDates) {
      if (Array.isArray(disabledDates)) {
        date = DateHelper.clearTime(date, true);
        return disabledDates.some((d) => !(DateHelper.clearTime(d, true) - date));
      } else {
        return this.callback(this.disabledDates, this, [date]);
      }
    }
  }
  get bodyConfig() {
    const result = super.bodyConfig, weeksContainerChildren = [];
    result.children = [{
      tag: "div",
      className: "b-calendar-row b-calendar-weekdays",
      reference: "weekdaysHeader",
      children: [
        { class: "b-week-number-cell" },
        ...ArrayHelper.fill(7, { class: this.dayHeaderCls }),
        DomHelper.scrollBarPadElement
      ]
    }, {
      // `notranslate` prevents google translate messing up the DOM, https://github.com/facebook/react/issues/11538
      className: "b-weeks-container notranslate",
      reference: "weeksElement",
      children: weeksContainerChildren
    }];
    for (let i = 0; i < 6; i++) {
      const weekRow = {
        className: "b-calendar-row b-calendar-week",
        dataset: {
          rowIndex: i
        },
        children: [{
          className: "b-week-number-cell"
        }, {
          className: "b-calendar-days",
          children: [{}, {}, {}, {}, {}, {}, {}],
          syncOptions: {
            ignoreRefs: true,
            strict: false
            // allow complete replacement of classes w/o matching lastDomConfig
          }
        }]
      };
      weeksContainerChildren.push(weekRow);
    }
    return result;
  }
  get firstVisibleDate() {
    if (this.hideOtherMonthCells) {
      const { year, month: month2 } = this.month;
      return new Date(year, month2, 1);
    }
    for (const me = this, date = me.month.startDate; ; date.setDate(date.getDate() + 1)) {
      if (!me.hideNonWorkingDays || !me.nonWorkingDays[date.getDay()]) {
        return date;
      }
    }
  }
  get lastVisibleDate() {
    const lastDate = DateHelper.add(this.endDate, -1, "d");
    if (this.hideOtherMonthCells) {
      return lastDate;
    }
    for (const me = this, date = lastDate; ; date.setDate(date.getDate() - 1)) {
      if (!me.hideNonWorkingDays || !me.nonWorkingDays[date.getDay()]) {
        return date;
      }
    }
  }
  /**
   * Returns the cell associated with the passed date.
   *
   * To exclude dates which are outside of the panel's current month, pass the `strict` parameter as `true`
   * @param {Date|String} date The date to find the element for or a key in the format `YYYY-MM-DD`
   * @param {Boolean} strict Only return the element if this view *owns* the date.
   * @returns {HTMLElement} The cell for the passed date if it exists
   */
  getCell(date, strict) {
    if (!(typeof date === "string")) {
      date = DateHelper.makeKey(date);
    }
    const cell = this.weeksElement.querySelector(`[data-date="${date}"]`);
    if (cell && (!strict || !cell.classList.contains(this.otherMonthCls))) {
      return cell;
    }
  }
  onTipOverCell({ source: tip, target }) {
    tip.date = DateHelper.parseKey(target.dataset.date);
  }
  updateLocalization() {
    this._localeNonWorkingDays = this._localeWeekends = null;
    this.updateDayNameFormat();
    this.updateWeekStartDay(this.weekStartDay);
    super.updateLocalization();
  }
};
__publicField(CalendarPanel, "$name", "CalendarPanel");
__publicField(CalendarPanel, "type", "calendarpanel");
CalendarPanel.initClass();
CalendarPanel._$name = "CalendarPanel";

// ../Core/lib/Core/widget/Checkbox.js
var whenNotChecked = (field) => !field.value;
var Checkbox = class extends Field {
  static get configurable() {
    return {
      inputType: "checkbox",
      /**
       * Specify `true` to automatically {@link Core.widget.FieldContainer#config-collapsed collapse} the field's
       * {@link #config-container} when the field is not {@link #property-checked}.
       *
       * Alternatively, this can be a function that returns the desired `collapse` state when passed the field
       * instance as its one parameter.
       *
       * @config {Boolean|Function}
       * @returns {Boolean}
       * @default false
       */
      autoCollapse: null,
      containerDefaults: {
        syncableConfigs: {
          disabled: (field) => field.disabled || !field.value
        },
        syncConfigTriggers: {
          autoCollapse: 1,
          value: 1
        }
      },
      /**
       * Get/set label
       * @member {String} name
       */
      /**
       * Text to display on checkbox label
       * @config {String}
       */
      text: "",
      /**
       * The value to provide for this widget in {@link Core.widget.Container#property-values} when it is
       * {@link #property-checked}.
       * A value of `undefined` will cause this widget not to include its value when checked.
       * @config {*}
       * @default
       */
      checkedValue: true,
      /**
       * The value to provide for this widget in {@link Core.widget.Container#property-values} when it is not
       * {@link #property-checked}.
       *
       * A value of `undefined` will cause this widget to not include its value when it is unchecked.
       * @config {*}
       * @default
       */
      uncheckedValue: false,
      /**
       * The checked state. The same as `value`.
       * @config {Boolean} checked
       */
      /**
       * Checkbox color, must have match in CSS
       * @config {String}
       */
      color: null,
      /**
       * Get/set value
       * @member {String} value
       */
      /**
       * Sets input fields value attribute
       * @config {String}
       */
      value: "",
      toggleGroup: null,
      localizableProperties: ["label", "text"]
    };
  }
  //endregion
  //region Init
  construct(config) {
    if ("checked" in config) {
      config = ObjectHelper.assign({}, config);
      config.value = config.checked;
      delete config.checked;
    }
    super.construct(config);
    this.syncHasText();
  }
  get textLabelCls() {
    return "b-checkbox-label";
  }
  // Implementation needed at this level because it has two inner elements in its inputWrap
  get innerElements() {
    return [
      this.inputElement,
      {
        tag: "label",
        class: this.textLabelCls,
        for: `${this.id}-input`,
        reference: "textLabel",
        html: this.text || ""
      }
    ];
  }
  get inputElement() {
    const config = super.inputElement;
    if (this.toggleGroup) {
      config.dataset = {
        group: this.toggleGroup
      };
    }
    config.listeners = {
      click: "internalOnClick",
      change: "internalOnChange",
      input: "internalOnInput"
    };
    return config;
  }
  //endregion
  //region Toggle
  /**
   * Get/set checked state. Equivalent to `value` config.
   * @property {Boolean}
   */
  get checked() {
    return this.value;
  }
  set checked(value) {
    this.value = value;
  }
  syncHasText() {
    this.element.classList[this.text ? "add" : "remove"]("b-text");
  }
  updateText(value) {
    if (this.textLabel) {
      this.syncHasText();
      this.textLabel.innerHTML = value;
    }
  }
  afterSyncChildConfigs(container) {
    super.afterSyncChildConfigs(container);
    let { autoCollapse } = this;
    if (autoCollapse) {
      autoCollapse = autoCollapse === true ? whenNotChecked : autoCollapse;
      container.collapsed = autoCollapse(this);
    }
  }
  assignFieldValue(values, key, value) {
    this.value = value === this.checkedValue || (value === this.uncheckedValue ? false : null);
  }
  fetchInputValue() {
    if (!this.readOnly) {
      this.value = this.input.checked;
    }
  }
  gatherValue(values) {
    var _a2;
    const me = this, value = me.value ? me.checkedValue : me.uncheckedValue, storedValue = value !== void 0, { valueName } = me;
    if (storedValue) {
      values[valueName] = value;
    }
    me.gatherValues(values, storedValue);
    if (value === true && ((_a2 = values[valueName]) == null ? void 0 : _a2.value) === value) {
      delete values[valueName].value;
    }
  }
  changeValue(value) {
    return value === "false" ? false : Boolean(value);
  }
  updateValue(value) {
    var _a2;
    const me = this, changed = me.input.checked !== value;
    me.input.checked = value;
    (_a2 = me.container) == null ? void 0 : _a2.syncChildConfigs();
    if (changed && !me.inputting && !me.isConfiguring) {
      me.uncheckToggleGroupMembers();
      me.triggerChange(false, null);
    }
  }
  get inputValueAttr() {
    return "checked";
  }
  updateColor(value, was) {
    const classes = this.element.classList;
    if (was) {
      classes.remove(was);
    }
    if (value) {
      classes.add(value);
    }
  }
  getToggleGroupMembers() {
    const me = this, { checked, toggleGroup, input: checkedElement, type } = me, result = [];
    if (checked && toggleGroup) {
      DomHelper.forEachSelector(me.rootElement, `input[type=${type}][data-group=${toggleGroup}]`, (inputEl) => {
        if (inputEl !== checkedElement) {
          const partnerCheckbox = Widget.fromElement(inputEl);
          partnerCheckbox && result.push(partnerCheckbox);
        }
      });
    }
    return result;
  }
  uncheckToggleGroupMembers() {
    if (this.checked && this.toggleGroup) {
      this.getToggleGroupMembers().forEach((widget) => widget.checked = false);
    }
  }
  /**
   * Check the box
   */
  check() {
    this.checked = true;
  }
  /**
   * Uncheck the box
   */
  uncheck() {
    this.checked = false;
  }
  /**
   * Toggle checked state. If you want to force a certain state, assign to {@link #property-checked} instead.
   */
  toggle() {
    this.checked = !this.checked;
  }
  //endregion
  //region Events
  internalOnClick(event) {
    if (this.readOnly) {
      event.preventDefault();
      return false;
    }
    return this.trigger("click", { event });
  }
  /**
   * Triggers events when user toggles the checkbox
   * @fires beforeChange
   * @fires change
   * @fires action
   * @private
   */
  internalOnChange(event) {
    const me = this;
    if (me.readOnly && me.value !== me.input.checked) {
      me.input.checked = me.value;
      return;
    }
    me.value = me.input.checked;
    if (!me.inputting) {
      me.inputting = true;
      me.triggerChange(true, event);
      me.inputting = false;
    }
  }
  // Need to catch changes even if readOnly, because of chrome behaviour when re-enabling
  updateInputReadOnly(readOnly) {
  }
  /**
   * Triggers events when checked state is changed
   * @fires beforeChange
   * @fires change
   * @fires action
   * @private
   */
  triggerChange(userAction, event) {
    const me = this, { checked } = me.input;
    const eventObject = { checked, value: checked, oldValue: !checked, userAction, valid: true, event }, prevented = !checked && userAction && me.toggleGroup && me.getToggleGroupMembers().filter((widget) => widget.isVisible && !widget.disabled).length || // Since Widget has Events mixed in configured with 'callOnFunctions' this will also call onBeforeChange,
    // onChange and onAction
    me.trigger("beforeChange", eventObject) === false;
    if (prevented) {
      me.input.checked = me._value = !checked;
    } else {
      me.triggerFieldChange(eventObject, false);
      if (userAction) {
        me.uncheckToggleGroupMembers();
      }
      me.trigger("action", eventObject);
      me.trigger("change", eventObject);
      return true;
    }
  }
  //endregion
};
//region Config
__publicField(Checkbox, "$name", "Checkbox");
__publicField(Checkbox, "type", "checkbox");
__publicField(Checkbox, "alias", "check");
Checkbox.initClass();
Checkbox._$name = "Checkbox";

// ../Core/lib/Core/widget/ColorPicker.js
var ColorPicker = class extends List {
  configure(config) {
    super.configure(config);
    this.setItems();
    this.ion({
      item: "onColorSelect"
    });
  }
  setItems() {
    const me = this, { colors, colorClasses } = me;
    let useColors = colorClasses || colors;
    if (me.addNoColorItem) {
      useColors = [...useColors];
      useColors.push(null);
    }
    me.items = useColors.map((color) => !color || typeof color == "string" ? { color, text: (colorClasses ? StringHelper.capitalize(color) : color) || me.L("L{noColor}") } : color);
  }
  afterConfigure() {
    var _a2;
    super.afterConfigure(...arguments);
    if (this.addNoColorItem || this.value) {
      this.select((_a2 = this.value) != null ? _a2 : null);
    }
  }
  updateColors() {
    if (!this.isConfiguring) {
      this.setItems();
    }
  }
  updateAddNoColorItem() {
    if (!this.isConfiguring) {
      this.setItems();
    }
  }
  onColorSelect({ record }) {
    var _a2;
    this.refresh();
    const event = { color: record.color, record, bubbles: true };
    (_a2 = this.colorSelected) == null ? void 0 : _a2.call(this, event);
    this.trigger("colorSelected", event);
  }
  select(value) {
    if (!value || typeof value === "string") {
      value = this.store.findRecord("color", value != null ? value : null);
    }
    value && super.select(value);
  }
  updateColumns(columns) {
    this.style = `grid-template-columns:repeat(${columns}, 1fr);`;
  }
  getColorClassName(color) {
    var _a2, _b;
    if (((_a2 = this.colorClasses) == null ? void 0 : _a2.includes(color)) || ((_b = this.colorClasses) == null ? void 0 : _b.find((r) => r && r.color === color))) {
      return this.colorClassPrefix + color;
    }
    return color ? "" : "b-no-color";
  }
};
__publicField(ColorPicker, "$name", "ColorPicker");
__publicField(ColorPicker, "type", "colorpicker");
__publicField(ColorPicker, "configurable", {
  itemsFocusable: false,
  navigator: {
    focusCls: "b-color-active"
  },
  itemWrapperTpl(record, i) {
    const { selected } = this, { color, text } = record, colorClassName = this.getColorClassName(color);
    return TemplateHelper.tpl`
                    <li
                        class="${this.getItemClasses(record, i)} ${colorClassName}"
                        role="option"
                        aria-selected="${selected.includes(record)}"
                        data-index="${i}"
                        data-id="${StringHelper.encodeHtml(color)}"
                        data-btip="${text}"
                        ${this.itemsFocusable ? 'tabindex="-1"' : ""}
                        style="${colorClassName ? "" : "background-color: " + color}"
                    ></li>`;
  },
  /**
   * Array of internal color class names, without prefix, like `red`, `violet` etc. If specified, this will
   * take precedence over {@link #config-colors}.
   * @config {String[]}
   * @private
   */
  colorClasses: null,
  /**
   * Prefix to be inserted before the color class names in {@link #config-colorClasses}, like `b-sch-`
   * @config {String}
   * @private
   */
  colorClassPrefix: null,
  /**
   * Array of CSS color strings from which the user can chose from.
   *
   * Provide an array of string CSS colors:
   * ```javascript
   * new ColorMenu({
   *     colors : ['#00FFFF', '#F0FFFF', '#89CFF0', '#0000FF', '#7393B3']
   * });
   * ```
   *
   * The colors can also be named. To do that, put them in an object with a `color` and a `text` property, like:
   * ```javascript
   * new ColorMenu({
   *    colors : [
   *        { color : '#000000', text : 'Black'},
   *        { color : '#FF0000', text : 'Red'},
   *        { color : '#00FF00', text : 'Green'},
   *        { color : '#0000FF', text : 'Blue'},
   *        { color : '#FFFFFF', text : 'White'},
   *    ]
   * });
   * ```
   *
   * Default colors are:
   * <div class="b-colorbox b-inline" style="background-color: #45171D"></div>#45171D
   * <div class="b-colorbox b-inline" style="background-color: #F03861"></div>#F03861
   * <div class="b-colorbox b-inline" style="background-color: #FF847C"></div>#FF847C
   * <div class="b-colorbox b-inline" style="background-color: #FECEA8"></div>#FECEA8
   * <div class="b-colorbox b-inline" style="background-color: #A5F2E7"></div>#A5F2E7
   * <div class="b-colorbox b-inline" style="background-color: #AA83F3"></div>#AA83F3
   * <div class="b-colorbox b-inline" style="background-color: #8983F3"></div>#8983F3
   * <div class="b-colorbox b-inline" style="background-color: #A10054"></div>#A10054
   * <div class="b-colorbox b-inline" style="background-color: #073059"></div>#073059
   * <div class="b-colorbox b-inline" style="background-color: #2866AB"></div>#2866AB
   * <div class="b-colorbox b-inline" style="background-color: #5FBDC5"></div>#5FBDC5
   * <div class="b-colorbox b-inline" style="background-color: #D8D95C"></div>#D8D95C
   * <div class="b-colorbox b-inline" style="background-color: #FFDEDE"></div>#FFDEDE
   * <div class="b-colorbox b-inline" style="background-color: #F7F3CE"></div>#F7F3CE
   * <div class="b-colorbox b-inline" style="background-color: #C5ECBE"></div>#C5ECBE
   * <div class="b-colorbox b-inline" style="background-color: #3E3E3E"></div>#3E3E3E
   * <div class="b-colorbox b-inline" style="background-color: #405559"></div>#405559
   * <div class="b-colorbox b-inline" style="background-color: #68868C"></div>#68868C
   * <div class="b-colorbox b-inline" style="background-color: #EDEDED"></div>#EDEDED
   * <div class="b-colorbox b-inline" style="background-color: #D3D6DB"></div>#D3D6DB
   * <div class="b-colorbox b-inline" style="background-color: #3A4750"></div>#3A4750
   * <div class="b-colorbox b-inline" style="background-color: #303841"></div>#303841
   * <div class="b-colorbox b-inline" style="background-color: #BE3144"></div>#BE3144
   * @prp {String[]}
   */
  colors: [
    "#45171D",
    "#F03861",
    "#FF847C",
    "#FECEA8",
    "#A5F2E7",
    "#AA83F3",
    "#8983F3",
    "#A10054",
    "#073059",
    "#2866AB",
    "#5FBDC5",
    "#D8D95C",
    "#FFDEDE",
    "#F7F3CE",
    "#C5ECBE",
    "#3E3E3E",
    "#405559",
    "#68868C",
    "#EDEDED",
    "#D3D6DB",
    "#3A4750",
    "#303841",
    "#BE3144"
  ],
  /**
   * Adds an option to set no background color
   * @prp {Boolean}
   */
  addNoColorItem: true,
  /**
   * The color items is displayed in a grid layout with 6 columns as default. Change this to another number to
   * affect appearance.
   * @prp {Number}
   */
  columns: 6,
  /**
   * A callback function that will be called when the user selects a color in the picker.
   * @param {Object} event Object containing event data
   * @param {Core.data.Model} event.record The selected color's record instance
   * @param {String} event.color The string color value
   * @config {Function}
   * @returns {void}
   */
  colorSelected: null
});
ColorPicker.initClass();
ColorPicker._$name = "ColorPicker";

// ../Core/lib/Core/widget/ColorField.js
var ColorField = class extends Combo {
  configure(config) {
    var _a2;
    const pickerCfg = (_a2 = config.picker) != null ? _a2 : {};
    if (config.colors) {
      pickerCfg.colors = config.colors;
    }
    if ("addNoColorItem" in config) {
      pickerCfg.addNoColorItem = config.addNoColorItem;
    }
    config.picker = pickerCfg;
    super.configure(config);
  }
  updatePicker(picker) {
    if (picker) {
      this.items = picker.store.records;
    }
  }
  updateColors(colors) {
    if (!this.isConfiguring) {
      this.picker.colors = colors;
    }
  }
  updateAddNoColorItem(addNoColorItem) {
    if (!this.isConfiguring) {
      this.picker.addNoColorItem = addNoColorItem;
    }
  }
  set value(value) {
    if (!this.store) {
      this.items = [];
      this.store = this.picker.store;
    }
    if (!value) {
      value = this.store.findRecord("color", null);
    }
    super.value = value;
  }
  showPicker() {
    this.picker.refresh();
    super.showPicker(...arguments);
  }
  get value() {
    return super.value;
  }
  syncInputFieldValue(...args) {
    var _a2;
    const me = this, { value } = me;
    let className = (_a2 = me.picker) == null ? void 0 : _a2.getColorClassName(value);
    if (!className) {
      me.colorBox.style.color = value;
    }
    className = "b-colorbox " + className;
    me.colorBox.className = className;
    if (!me.showBoxForNoColor) {
      me.element.classList.toggle("b-colorless", !value);
    }
    super.syncInputFieldValue(...args);
  }
  get innerElements() {
    return [
      {
        reference: "colorBox",
        className: "b-colorbox"
      },
      ...super.innerElements
    ];
  }
};
__publicField(ColorField, "$name", "ColorField");
__publicField(ColorField, "type", "colorfield");
__publicField(ColorField, "configurable", {
  /*
   * @hideconfigs text,color,editable,picker
   */
  displayField: "text",
  valueField: "color",
  editable: false,
  picker: {
    type: "colorpicker",
    align: {
      align: "t100-b100",
      matchSize: false
    }
  },
  showBoxForNoColor: true,
  /**
   * Array of CSS color strings to be able to chose from. This will override the
   * {@link Core.widget.ColorPicker#config-colors pickers default colors}.
   *
   * Provide an array of string CSS colors:
   * ```javascript
   * new ColorField({
   *     colors : ['#00FFFF', '#F0FFFF', '#89CFF0', '#0000FF', '#7393B3']
   * });
   * ```
   *
   * @prp {String[]}
   */
  colors: null,
  /**
   * Adds an option in the picker to set no background color
   * @prp {Boolean}
   */
  addNoColorItem: true
});
ColorField.initClass();
ColorField._$name = "ColorField";

// ../Core/lib/Core/widget/YearPicker.js
var YearPicker = class extends Panel {
  construct(config) {
    super.construct({
      year: (/* @__PURE__ */ new Date()).getFullYear(),
      ...config
    });
    EventHelper.on({
      element: this.contentElement,
      click: "onYearClick",
      delegate: ".b-yearpicker-year",
      thisObj: this
    });
  }
  get focusElement() {
    return this.getYearButton(this.year) || this.getYearButton(this.startYear);
  }
  getYearButton(y) {
    return this.contentElement.querySelector(`.b-yearpicker-year[data-year="${y}"]`);
  }
  /**
   * The currently selected year.
   * @member {Number} value
   */
  get value() {
    return this.year;
  }
  set value(year) {
    this.year = year;
  }
  onYearClick({ target }) {
    const clickedYear = Math.min(Math.max(parseInt(target.innerText), this.minYear || 1), this.maxYear || 9999);
    if (this.year === clickedYear) {
      this.trigger("select", { oldValue: clickedYear, value: clickedYear });
    } else {
      this.year = clickedYear;
    }
  }
  handleTitleClick(e) {
    this.trigger("titleClick", e);
  }
  previous() {
    this.startYear = this.startYear - this.yearButtonCount;
  }
  next() {
    this.startYear = this.endYear + 1;
  }
  ingestYear(year) {
    if (!isNaN(year)) {
      return ObjectHelper.isDate(year) ? year.getFullYear() : year;
    }
  }
  changeYear(year) {
    if (year = this.ingestYear(year)) {
      return Math.min(Math.max(year, this.minYear || 1), this.maxYear || 9999);
    }
  }
  updateYear(year, oldValue) {
    const me = this;
    if (!me.startYear || year > me.endYear) {
      me.startYear = year;
    } else if (year < me.startYear) {
      me.startYear = year - (me.yearButtonCount - 1);
    }
    if (!me.isConfiguring) {
      me.trigger("select", { oldValue, value: year });
    }
  }
  /**
   * The ending year displayed in the widget.
   * @member {Number} endYear
   * @readonly
   */
  get endYear() {
    return this.startYear + this.yearButtonCount - 1;
  }
  changeStartYear(startYear) {
    if (startYear = this.ingestYear(startYear)) {
      startYear = this.minYear ? Math.max(startYear, this.minYear) : startYear;
      return this.maxYear ? Math.min(startYear, this.maxYear - (this.yearButtonCount - 1)) : startYear;
    }
  }
  async updateStartYear(startYear, oldStartYear) {
    if (this.isVisible) {
      DomHelper.slideIn(this.contentElement, Math.sign(startYear - oldStartYear));
    }
  }
  composeBody() {
    this.getConfig("year");
    const { startYear } = this, result = super.composeBody(), children = result.children[this.tbar ? 1 : 0].children = [];
    this.widgetMap.title.text = `${`000${startYear}`.slice(-4)} - ${`000${this.endYear}`.slice(-4)}`;
    for (let i = 0, y = startYear; i < this.yearButtonCount; i++, y++) {
      children.push({
        tag: "button",
        dataset: {
          year: y
        },
        class: {
          "b-yearpicker-year": 1,
          "b-selected": y === this.year
        },
        text: `000${y}`.slice(-4)
      });
    }
    return result;
  }
};
__publicField(YearPicker, "$name", "YearPicker");
__publicField(YearPicker, "type", "yearpicker");
__publicField(YearPicker, "configurable", {
  textContent: false,
  /**
   * The definition of the top toolbar which displays the title and "previous" and
   * "next" buttons.
   *
   * This contains the following predefined `items` which may be reconfigured by
   * application code:
   *
   * - `title` A widget which displays the visible year range. Weight 100.
   * - `previous` A button which navigates to the previous block. Weight 200.
   * - `next` A button which navigates to the next block. Weight 300.
   *
   * These may be reordered:
   *
   * ```javascript
   * new YearPicker({
   *     appendTo : targetElement,
   *     tbar     : {
   *         items : {
   *             // Move title to centre
   *             title : {
   *                 weight : 250
   *             }
   *         }
   *     },
   *     width    : '24em'
   * });
   * ```
   * @config {ToolbarConfig}
   */
  tbar: {
    overflow: null,
    items: {
      previous: {
        type: "tool",
        cls: "b-icon b-icon-previous",
        onAction: "up.previous",
        weight: 100
      },
      title: {
        type: "button",
        cls: "b-yearpicker-title",
        weight: 200,
        onAction: "up.handleTitleClick"
      },
      next: {
        type: "tool",
        cls: "b-icon b-icon-next",
        onAction: "up.next",
        weight: 300
      }
    }
  },
  itemCls: "b-year-container",
  /**
   * The number of clickable year buttons to display in the widget.
   *
   * It may be useful to change this if a non-standard shape or size is used.
   * @config {Number}
   * @default
   */
  yearButtonCount: 12,
  /**
   * The currently selected year.
   * @member {Number} year
   */
  /**
   * The year to use as the selected year. Defaults to the current year.
   * @config {Number}
   */
  year: null,
  /**
   * The lowest year to allow.
   * @config {Number}
   */
  minYear: null,
  /**
   * The highest year to allow.
   * @config {Number}
   */
  maxYear: null,
  /**
   * The starting year displayed in the widget.
   * @member {Number} startYear
   */
  /**
   * The year to show at the start of the widget
   * @config {Number}
   */
  startYear: null
});
YearPicker.initClass();
YearPicker._$name = "YearPicker";

// ../Core/lib/Core/widget/DisplayField.js
var DisplayField = class extends TextField {
  static get configurable() {
    return {
      readOnly: true,
      editable: false,
      cls: "b-display-field",
      /**
       * A template string used to render the value of this field. Please note you are responsible for encoding
       * any strings protecting against XSS.
       *
       * ```javascript
       * new DisplayField({
       *     appendTo : document.body,
       *     name     : 'age',
       *     label    : 'Age',
       *     template : data => `${data.value} years old`
       * })
       * ```
       * @config {Function}
       * @param {ContainerItemConfig} fieldConfig Configuration object for the field
       * @returns {DomConfig|String|null}
       */
      template: null,
      ariaElement: "displayElement"
    };
  }
  get focusElement() {
  }
  changeReadOnly() {
    return true;
  }
  changeEditable() {
    return false;
  }
  get inputElement() {
    return {
      tag: "span",
      id: `${this.id}-input`,
      reference: "displayElement",
      html: this.template ? this.template(this.value) : StringHelper.encodeHtml(this.value)
    };
  }
};
__publicField(DisplayField, "$name", "DisplayField");
__publicField(DisplayField, "type", "displayfield");
__publicField(DisplayField, "alias", "display");
DisplayField.initClass();
DisplayField._$name = "DisplayField";

// ../Core/lib/Core/widget/DatePicker.js
var generateMonthNames = () => DateHelper.getMonthNames().map((m, i) => [i, m]);
var dateSort = (lhs, rhs) => lhs.valueOf() - rhs.valueOf();
var emptyArray9 = Object.freeze([]);
var ReadOnlyCombo = class extends Combo {
  static get $name() {
    return "ReadOnlyCombo";
  }
  static get type() {
    return "readonlycombo";
  }
  static get configurable() {
    return {
      editable: false,
      inputAttributes: {
        tag: "div",
        tabIndex: -1
      },
      inputValueAttr: "innerHTML",
      highlightExternalChange: false,
      monitorResize: false,
      triggers: {
        expand: false
      },
      picker: {
        align: {
          align: "t-b",
          axisLock: true,
          matchSize: false
        },
        cls: "b-readonly-combo-list",
        scrollable: {
          overflowX: false
        }
      }
    };
  }
};
ReadOnlyCombo.initClass();
var DatePicker = class extends CalendarPanel {
  static get delayable() {
    return {
      refresh: "raf"
    };
  }
  static get configurable() {
    return {
      /**
       * The date that the user has navigated to using the UI *prior* to setting the widget's
       * value by selecting. The initial default is today's date.
       *
       * This may be changed using keyboard navigation. The {@link Core.widget.CalendarPanel#property-date} is set
       * by pressing `ENTER` when the desired date is reached.
       *
       * Programmatically setting the {@link Core.widget.CalendarPanel#config-date}, or using the UI to select the date
       * by clicking it also sets the `activeDate`
       * @config {Date}
       */
      activeDate: {
        value: /* @__PURE__ */ new Date(),
        $config: {
          equal: "date"
        }
      },
      focusable: true,
      textContent: false,
      tbar: {
        overflow: null,
        items: {
          prevYear: {
            cls: "b-icon b-icon-first",
            onAction: "up.gotoPrevYear",
            tooltip: "L{DatePicker.gotoPrevYear}"
          },
          prevMonth: {
            cls: "b-icon b-icon-previous",
            onAction: "up.gotoPrevMonth",
            tooltip: "L{DatePicker.gotoPrevMonth}"
          },
          fields: {
            type: "container",
            cls: "b-datepicker-title",
            items: {
              monthField: {
                type: "readonlycombo",
                cls: "b-datepicker-monthfield",
                items: generateMonthNames(),
                internalListeners: {
                  select: "up.onMonthPicked"
                }
              },
              yearButton: {
                type: "button",
                cls: "b-datepicker-yearbutton",
                internalListeners: {
                  click: "up.onYearPickerRequested"
                }
              }
            }
          },
          nextMonth: {
            cls: "b-icon b-icon-next",
            onAction: "up.gotoNextMonth",
            tooltip: "L{DatePicker.gotoNextMonth}"
          },
          nextYear: {
            cls: "b-icon b-icon-last",
            onAction: "up.gotoNextYear",
            tooltip: "L{DatePicker.gotoNextYear}"
          }
        }
      },
      yearPicker: {
        value: {
          type: "YearPicker",
          yearButtonCount: 16,
          trapFocus: true,
          positioned: true,
          hidden: true,
          internalListeners: {
            titleClick: "up.onYearPickerTitleClick",
            select: "up.onYearPicked"
          }
        },
        $config: "lazy"
      },
      /**
       * The initially selected date.
       * @config {Date}
       */
      date: null,
      /**
       * The minimum selectable date. Selection of and navigation to dates prior
       * to this date will not be possible.
       * @config {Date}
       */
      minDate: {
        value: null,
        $config: {
          equal: "date"
        }
      },
      /**
       * The maximum selectable date. Selection of and navigation to dates after
       * this date will not be possible.
       * @config {Date}
       */
      maxDate: {
        value: null,
        $config: {
          equal: "date"
        }
      },
      /**
       * By default, disabled dates cannot be navigated to, and they are skipped over
       * during keyboard navigation. Configure this as `true` to enable navigation to
       * disabled dates.
       * @config {Boolean}
       * @default
       */
      focusDisabledDates: null,
      /**
       * Configure as `true` to enable selecting multiple discontiguous date ranges using
       * click and Shift+click to create ranges and Ctrl+click to select/deselect individual dates.
       *
       * Configure as `'range'` to enable selecting a single date range by selecting a
       * start and end date. Hold "SHIFT" button to select date range. Ctrl+click may add
       * or remove dates to/from either end of the range.
       * @config {Boolean|'range'}
       * @default
       */
      multiSelect: false,
      /**
       * If {@link #config-multiSelect} is configured as `true`, this is an array of dates
       * which are selected. There may be multiple, discontiguous date ranges.
       *
       * If {@link #config-multiSelect} is configured as `'range'`, this is a two element array
       * specifying the first and last selected dates in a range.
       * @config {Date[]}
       */
      selection: {
        $config: {
          equal: (v1, v2) => v1 && v1.equals(v2)
        },
        value: null
      },
      /**
       * By default, the month and year are editable. Configure this as `false` to prevent that.
       * @config {Boolean}
       * @default
       */
      editMonth: true,
      /**
       * The {@link Core.helper.DateHelper} format string to format the day names.
       * @config {String}
       * @default
       */
      dayNameFormat: "dd",
      trapFocus: true,
      role: "grid",
      focusDescendant: true,
      /**
       * By default, when the {@link #property-date} changes, the UI will only refresh
       * if it doesn't contain a cell for that date, so as to keep a stable UI when
       * navigating.
       *
       * Configure this as `true` to refresh the UI whenever the month changes, even if
       * the UI already shows that date.
       * @config {Boolean}
       * @internal
       */
      alwaysRefreshOnMonthChange: null
    };
  }
  static get prototypeProperties() {
    return {
      /**
       * The class name to add to the calendar cell whose date which is outside of the
       * {@link #config-minDate}/{@link #config-maxDate} range.
       * @config {String}
       * @private
       */
      outOfRangeCls: "b-out-of-range",
      /**
       * The class name to add to the currently focused calendar cell.
       * @config {String}
       * @private
       */
      activeCls: "b-active-date",
      /**
       * The class name to add to selected calendar cells.
       * @config {String}
       * @private
       */
      selectedCls: "b-selected-date"
    };
  }
  // region Init
  construct(config) {
    const me = this;
    super.construct(config);
    me.externalCellRenderer = me.cellRenderer;
    me.cellRenderer = me.internalCellRenderer;
    me.element.setAttribute("aria-activedescendant", `${me.id}-active-day`);
    me.weeksElement.setAttribute("role", "grid");
    me.weekElements.forEach((w) => w.setAttribute("role", "row"));
    me.element.setAttribute("ariaLabelledBy", me.widgetMap.fields.id);
    EventHelper.on({
      element: me.weeksElement,
      click: {
        handler: "onCellClick",
        delegate: `.${me.dayCellCls}:not(.${me.disabledCls}):not(.${me.outOfRangeCls})`
      },
      mousedown: {
        handler: "onCellMousedown",
        delegate: `.${me.dayCellCls}`
      },
      thisObj: me
    });
    me.widgetMap.monthField.readOnly = me.widgetMap.yearButton.disabled = !me.editMonth;
    me.refresh.flush();
  }
  afterHide() {
    var _a2;
    (_a2 = this._yearPicker) == null ? void 0 : _a2.hide();
    super.afterHide(...arguments);
  }
  doDestroy() {
    var _a2, _b;
    (_a2 = this.yearButton) == null ? void 0 : _a2.destroy();
    (_b = this.monthField) == null ? void 0 : _b.destroy();
    super.doDestroy();
  }
  // endregion
  get focusElement() {
    return this.weeksElement.querySelector(`.${this.dayCellCls}[tabIndex="0"]`);
  }
  doRefresh() {
    const me = this, { date } = me, oldActiveCell = me.focusElement, activeDate = DateHelper.betweenLesser(me.activeDate, me.month.startDate, me.month.endDate) ? me.activeDate : me._activeDate = date;
    me.getConfig("tbar");
    super.doRefresh(...arguments);
    me.widgetMap.monthField.value = date.getMonth();
    me.widgetMap.yearButton.text = date.getFullYear();
    const dateOfOldActiveCell = DateHelper.parseKey(oldActiveCell == null ? void 0 : oldActiveCell.dataset.date);
    if (activeDate - dateOfOldActiveCell) {
      me.syncActiveDate(activeDate, dateOfOldActiveCell);
    }
  }
  internalCellRenderer({ cell, date }) {
    const me = this, {
      activeCls,
      selectedCls,
      externalCellRenderer
    } = me, isSelected = me.isSelectedDate(date), cellClassList = {
      [activeCls]: activeCls && me.isActiveDate(date),
      [selectedCls]: isSelected,
      [me.outOfRangeCls]: me.minDate && date < me.minDate || me.maxDate && date > me.maxDate
    };
    if (isSelected) {
      if (me.multiSelect) {
        const isStart = !me.isSelectedDate(DateHelper.add(date, -1, "d")), isEnd = !me.isSelectedDate(DateHelper.add(date, 1, "d"));
        cellClassList["b-range-start"] = isStart;
        cellClassList["b-range-end"] = isEnd;
        cellClassList["b-in-range"] = !isStart && !isEnd;
      }
    }
    DomHelper.updateClassList(cell, cellClassList);
    cell.innerHTML = `<div class="b-datepicker-cell-inner">${date.getDate()}</div>`;
    cell.setAttribute("role", "gridcell");
    cell.setAttribute("aria-label", DateHelper.format(date, "MMMM D, YYYY"));
    if (me.isActiveDate(date)) {
      cell.id = `${me.id}-active-day`;
    } else {
      cell.removeAttribute("id");
    }
    if (externalCellRenderer) {
      arguments[0].cell = cell.firstChild;
      me.callback(externalCellRenderer, this, arguments);
    }
  }
  onCellMousedown(event) {
    const cell = event.target.closest("[data-date]");
    cell.focus();
    if (DomHelper.getActiveElement(cell) === cell) {
      event.preventDefault();
    }
    this.activeDate = DateHelper.parseKey(cell.dataset.date);
  }
  onCellClick(event) {
    const cell = event.target.closest("[data-date]");
    this.onUIDateSelect(DateHelper.parseKey(cell.dataset.date), event);
  }
  /**
   * Called when the user uses the UI to select the current activeDate. So ENTER when focused
   * or clicking a date cell.
   * @param {Date} date The active date to select
   * @param {Event} event the instigating event, either a `click` event or a `keydown` event.
   * @internal
   */
  onUIDateSelect(date, event) {
    const me = this, {
      lastClickedDate,
      multiSelect
    } = me;
    me.lastClickedDate = date;
    if (!me.isDisabledDate(date)) {
      me.activatingEvent = event;
      if (multiSelect) {
        me.handleMultiSelect(lastClickedDate, date, event);
      } else {
        me.selection = date;
        if (me.floating) {
          me.hide();
        }
      }
      me.activatingEvent = null;
    }
  }
  // Calls updateSelection if the selection is mutated
  handleMultiSelect(lastClickedDate, date, event) {
    const me = this, {
      multiSelect
    } = me, _selection = me._selection || (me._selection = new DateSet()), selection = _selection.dates, singleRange = multiSelect === "range", {
      size,
      generation
    } = _selection, rangeEnds = size && {
      [DateHelper.makeKey(DateHelper.add(selection[0], -1, "d"))]: 1,
      [DateHelper.makeKey(selection[0])]: 1,
      [DateHelper.makeKey(selection[selection.length - 1])]: 1,
      [DateHelper.makeKey(DateHelper.add(selection[selection.length - 1], 1, "d"))]: 1
    }, isSelected = _selection.has(date), toggleFn = isSelected ? "delete" : "add";
    const clickedRangeEnd = singleRange && (rangeEnds == null ? void 0 : rangeEnds[DateHelper.makeKey(date)]);
    if (event.ctrlKey) {
      if (multiSelect === true || !size || clickedRangeEnd) {
        _selection[toggleFn](date);
        if (singleRange && !_selection.has(me.rangeStartDate)) {
          me.rangeStartDate.setDate(me.rangeStartDate.getDate() + (date < selection[1] ? 1 : -1));
        }
      }
    } else if (event.shiftKey && size) {
      const [start, end] = [
        new Date(singleRange ? me.rangeStartDate || (me.rangeStartDate = selection[0]) : lastClickedDate),
        date
      ].sort(dateSort);
      if (singleRange) {
        _selection.clear();
      }
      for (const d = start; d <= end; d.setDate(d.getDate() + 1)) {
        _selection.add(d);
      }
    } else if (!(_selection.has(date) && _selection.size === 1)) {
      _selection.clear();
      _selection.add(date);
    }
    const newSize = _selection.size;
    if (newSize === 1) {
      me.rangeStartDate = date;
    } else if (!newSize) {
      me.rangeStartDate = null;
    }
    if (_selection.generation !== generation) {
      me.updateSelection(_selection);
    }
  }
  changeSelection(selection) {
    const me = this;
    let result, rangeStartDate;
    if (selection) {
      if (!selection.forEach) {
        selection = [selection];
      }
      selection.forEach((d, i) => selection[i] = me.changeDate(d));
      rangeStartDate = selection[0];
      selection.sort(dateSort);
      if (me.multiSelect === "range" && selection.length === 2) {
        result = new DateSet();
        for (const d = new Date(selection[0]); d <= selection[1]; d.setDate(d.getDate() + 1)) {
          result.add(d);
        }
      } else {
        rangeStartDate = selection[0];
        result = new DateSet(selection);
      }
    } else {
      result = new DateSet();
    }
    if (rangeStartDate) {
      me.activeDate = me.rangeStartDate = DateHelper.clearTime(rangeStartDate);
    }
    return result;
  }
  updateMultiSelect(multiSelect) {
    this.element.classList.toggle("b-multiselect", Boolean(multiSelect));
    if (!multiSelect) {
      this.selection = [...this.selection][0];
    }
  }
  updateSelection(dateSet) {
    const me = this, { dates } = dateSet, selection = me.multiSelect === "range" ? [dates[0], dates[dates.length - 1]] : dates;
    dates.length && (me.date = dates[0]);
    if (!me.isConfiguring) {
      me.refresh.now();
      me.trigger("selectionChange", {
        selection,
        userAction: Boolean(me.activatingEvent)
      });
    }
  }
  /**
   * The selected Date(s).
   *
   * When {@link #config-multiSelect} is `'range'`, then this yields a two element array
   * representing the start and end of the selected range.
   *
   * When {@link #config-multiSelect} is `true`, this yields an array containing every selected
   * Date.
   * @member {Date[]} selection
   */
  get selection() {
    const { _selection } = this, dates = _selection ? _selection.dates : emptyArray9;
    return this.multiSelect === "range" && dates.length ? [dates[0], dates[dates.length - 1]] : dates;
  }
  onInternalKeyDown(keyEvent) {
    const me = this, keyName = keyEvent.key.trim() || keyEvent.code, activeDate = me.activeDate;
    let newDate = new Date(activeDate);
    if (keyName === "Escape" && me.floating) {
      return me.hide();
    }
    if (activeDate && me.weeksElement.contains(keyEvent.target)) {
      do {
        switch (keyName) {
          case "ArrowLeft":
            keyEvent.preventDefault();
            if (keyEvent.ctrlKey) {
              newDate = me.gotoPrevMonth();
            } else {
              newDate.setDate(newDate.getDate() - 1);
            }
            break;
          case "ArrowUp":
            keyEvent.preventDefault();
            newDate.setDate(newDate.getDate() - 7);
            break;
          case "ArrowRight":
            keyEvent.preventDefault();
            if (keyEvent.ctrlKey) {
              newDate = me.gotoNextMonth();
            } else {
              newDate.setDate(newDate.getDate() + 1);
            }
            break;
          case "ArrowDown":
            keyEvent.preventDefault();
            newDate.setDate(newDate.getDate() + 7);
            break;
          case "Enter":
            return me.onUIDateSelect(activeDate, keyEvent);
        }
      } while (me.isDisabledDate(newDate) && !me.focusDisabledDates);
      if (me.minDate && newDate < me.minDate) {
        return;
      }
      if (me.maxDate && newDate > me.maxDate) {
        return;
      }
      me.activeDate = newDate;
    }
  }
  changeMinDate(minDate) {
    return minDate && CalendarPanel.prototype.changeDate.apply(this, arguments);
  }
  updateMinDate(minDate) {
    this._yearpicker && (this._yearpicker.minYear = minDate == null ? void 0 : minDate.getFullYear());
    this.refresh();
  }
  changeMaxDate(minDate) {
    return minDate && CalendarPanel.prototype.changeDate.apply(this, arguments);
  }
  updateMaxDate(maxDate) {
    this._yearpicker && (this._yearpicker.maxYear = maxDate == null ? void 0 : maxDate.getFullYear());
    this.refresh();
  }
  changeDate(date) {
    return DateHelper.clamp(super.changeDate(date), this.minDate, this.maxDate);
  }
  updateDate(date, oldDate) {
    const me = this, { month: month2 } = me;
    me.isConfiguring && !me.initializingActiveDate && (me.selection = date);
    if (!month2.date || date.getMonth() === month2.month || !me.getCell(date) || me.alwaysRefreshOnMonthChange || me.isNavigating) {
      super.updateDate(date);
    } else {
      const newMonth = month2.getOtherMonth(date), changes = me.eventListeners && (oldDate ? date.getDate() !== oldDate.getDate() | (newMonth.getWeekId(date) !== month2.getWeekId(oldDate)) << 1 | (date.getMonth() !== (oldDate == null ? void 0 : oldDate.getMonth())) << 2 | (date.getFullYear() !== (oldDate == null ? void 0 : oldDate.getFullYear())) << 3 : 15);
      me.trigger("dateChange", {
        changes: {
          d: true,
          w: Boolean(changes & 2),
          m: Boolean(changes & 12),
          y: Boolean(changes & 8),
          r: newMonth.weekCount !== month2.weekCount
        },
        value: date,
        oldValue: oldDate
      });
    }
  }
  changeActiveDate(activeDate, oldActiveDate) {
    if (this.trigger("beforeActiveDateChange", { activeDate, oldActiveDate }) === false) {
      return;
    }
    activeDate = activeDate ? this.changeDate(activeDate) : this.date || (this.date = DateHelper.clearTime(/* @__PURE__ */ new Date()));
    if (isNaN(activeDate)) {
      throw new Error("DatePicker date ingestion must be passed a Date, or a YYYY-MM-DD date string");
    }
    return DateHelper.clamp(activeDate, this.minDate, this.maxDate);
  }
  updateActiveDate(activeDate, wasActiveDate) {
    const me = this, { isConfiguring } = me;
    if (isConfiguring || !me.getCell(activeDate)) {
      me.initializingActiveDate = isConfiguring;
      me.date = activeDate;
      me.initializingActiveDate = false;
    }
    if (!isConfiguring && !me.refresh.isPending) {
      me.syncActiveDate(activeDate, wasActiveDate);
    }
  }
  syncActiveDate(activeDate, wasActiveDate) {
    const me = this, { activeCls } = me, activeCell = me.getCell(activeDate), wasActiveCell = wasActiveDate && me.getCell(wasActiveDate), activeElement = DomHelper.getActiveElement(me.element);
    activeCell.setAttribute("tabIndex", 0);
    activeCls && activeCell.classList.add(activeCls);
    activeCell.id = `${me.id}-active-day`;
    if (me.weeksElement.contains(activeElement)) {
      activeCell.focus();
    }
    if (wasActiveCell && wasActiveCell !== activeCell) {
      wasActiveCell.removeAttribute("tabIndex");
      activeCls && wasActiveCell.classList.remove(activeCls);
      wasActiveCell.removeAttribute("id");
    }
  }
  set value(value) {
    const me = this, {
      selection,
      duration
    } = me;
    if (value) {
      value = me.changeDate(value, me.value);
      if (me.multiSelect === "range" && (selection == null ? void 0 : selection.length) === 2) {
        if (!DateHelper.betweenLesserEqual(value, ...selection)) {
          if (value < selection[0]) {
            me.selection = [value, DateHelper.add(value, duration - 1, "d")];
          } else {
            me.selection = [DateHelper.add(value, -(duration - 1), "d"), value];
          }
        }
        me.date = me.activeDate = value;
        return;
      }
      if (value !== void 0) {
        me.selection = value;
      }
    } else {
      me.date = /* @__PURE__ */ new Date();
      me.selection = null;
    }
  }
  get value() {
    return this.selection[this.selection.length - 1];
  }
  get duration() {
    return this.multiSelect === "range" ? DateHelper.diff(...this.selection, "d") + 1 : 1;
  }
  gotoPrevYear() {
    return this.goto(-1, "year");
  }
  gotoPrevMonth() {
    return this.goto(-1, "month");
  }
  gotoNextMonth() {
    return this.goto(1, "month");
  }
  gotoNextYear() {
    return this.goto(1, "year");
  }
  goto(direction, unit) {
    const me = this, { activeDate } = me, activeCell = activeDate && me.getCell(activeDate);
    let newDate;
    if (unit === "month" && activeCell && (activeDate == null ? void 0 : activeDate.getMonth()) === me.month.month + direction) {
      newDate = activeDate;
    } else {
      newDate = DateHelper.add(activeCell ? activeDate : me.date, direction, unit);
    }
    const firstDateOfNewMonth = new Date(newDate);
    firstDateOfNewMonth.setDate(1);
    const lastDateOfNewMonth = DateHelper.add(DateHelper.add(firstDateOfNewMonth, 1, "month"), -1, "day");
    if (me.minDate && direction < 0 && lastDateOfNewMonth < me.minDate || me.maxDate && direction > 0 && firstDateOfNewMonth > me.maxDate) {
      return;
    }
    me.isNavigating = true;
    const result = me.date = newDate;
    if (activeCell) {
      me.activeDate = newDate;
    }
    me.isNavigating = false;
    return result;
  }
  isActiveDate(date) {
    return !(date - this.activeDate);
  }
  isSelectedDate(date) {
    var _a2;
    return (_a2 = this._selection) == null ? void 0 : _a2.has(date);
  }
  onMonthPicked({ record, userAction }) {
    var _a2;
    if (userAction) {
      this.activeDate = DateHelper.add(this.activeDate, record.value - this.activeDate.getMonth(), "month");
      (_a2 = this.focusElement) == null ? void 0 : _a2.focus();
    }
  }
  onYearPickerRequested() {
    const { yearPicker } = this;
    if (yearPicker.isVisible) {
      yearPicker.hide();
    } else {
      yearPicker.year = yearPicker.startYear = this.activeDate.getFullYear();
      yearPicker.show();
      yearPicker.focus();
    }
  }
  onYearPickerTitleClick() {
    this.yearPicker.hide();
  }
  onYearPicked({ value, source }) {
    const newDate = new Date(this.activeDate);
    newDate.setFullYear(value);
    this.activeDate = newDate;
    this.focusElement && DomHelper.focusWithoutScrolling(this.focusElement);
    source.hide();
  }
  changeYearPicker(yearPicker, oldYearPicker) {
    var _a2, _b;
    return YearPicker.reconfigure(oldYearPicker, yearPicker ? YearPicker.mergeConfigs({
      owner: this,
      appendTo: this.element,
      minYear: (_a2 = this.minDate) == null ? void 0 : _a2.getFullYear(),
      maxYear: (_b = this.maxDate) == null ? void 0 : _b.getFullYear()
    }, yearPicker) : null, this);
  }
  get childItems() {
    const { _yearPicker } = this, result = super.childItems;
    if (_yearPicker) {
      result.push(_yearPicker);
    }
    return result;
  }
  updateLocalization() {
    var _a2;
    const {
      monthField
    } = this.widgetMap, newData = generateMonthNames();
    if (!this.isConfiguring && !newData.every((d, i) => d[1] === monthField.store.getAt(i).text)) {
      newData[(_a2 = monthField.value) != null ? _a2 : this.date.getMonth()].selected = true;
      monthField.items = newData;
    }
    super.updateLocalization();
  }
};
__publicField(DatePicker, "$name", "DatePicker");
__publicField(DatePicker, "type", "datepicker");
var DateSet = class _DateSet extends Set {
  add(d) {
    d = DateHelper.makeKey(d);
    if (!this.has(d)) {
      this.generation = (this.generation || 0) + 1;
    }
    return super.add(d);
  }
  delete(d) {
    d = DateHelper.makeKey(d);
    if (this.has(d)) {
      this.generation++;
    }
    return super.delete(d);
  }
  has(d) {
    return super.has(DateHelper.makeKey(d));
  }
  clear() {
    if (this.size) {
      this.generation++;
    }
    return super.clear();
  }
  equals(other) {
    Array.isArray(other) && (other = new _DateSet(other));
    return other.size === this.size && [...this].every((s) => other.has(s));
  }
  get dates() {
    return [...this].sort().map((k) => DateHelper.parseKey(k));
  }
};
DatePicker.initClass();
DatePicker._$name = "DatePicker";

// ../Core/lib/Core/widget/DateField.js
var DateField = class extends PickerField {
  static get configurable() {
    return {
      /**
       * Get / set format for date displayed in field (see {@link Core.helper.DateHelper#function-format-static}
       * for formatting options).
       * @member {String} format
       */
      /**
       * Format for date displayed in field. Defaults to using long date format, as defined by current locale (`L`)
       * @config {String}
       * @default
       */
      format: "L",
      /**
       * A flag which indicates whether the date parsing should be strict - meaning if the date
       * is missing a year/month/day part - parsing fails.
       *
       * Turned off by default, meaning default values are substituted for missing parts.
       *
       * @config {Boolean}
       * @default
       */
      strictParsing: false,
      // same for all languages
      fallbackFormat: "YYYY-MM-DD",
      timeFormat: "HH:mm:ss:SSS",
      /**
       * A flag which indicates what time should be used for selected date.
       * `false` by default which means time is reset to midnight.
       *
       * Possible options are:
       * - `false` to reset time to midnight
       * - `true` to keep original time value
       * - `'17:00'` a string which is parsed automatically
       * - `new Date(2020, 0, 1, 17)` a date object to copy time from
       * - `'entered'` to keep time value entered by user (in case {@link #config-format} includes time info)
       *
       * @config {Boolean|Date|String}
       * @default
       */
      keepTime: false,
      /**
       * Format for date in the {@link #config-picker}. Uses localized format per default
       * @config {String}
       */
      pickerFormat: null,
      /**
       * Set to true to first clear time of the field's value before comparing it to the max value
       * @internal
       * @config {Boolean}
       */
      validateDateOnly: null,
      triggers: {
        expand: {
          cls: "b-icon-calendar",
          handler: "onTriggerClick",
          weight: 200
        },
        back: {
          cls: "b-icon b-icon-angle-left b-step-trigger",
          key: "Shift+ArrowDown",
          handler: "onBackClick",
          align: "start",
          weight: 100
        },
        forward: {
          cls: "b-icon b-icon-angle-right b-step-trigger",
          key: "Shift+ArrowUp",
          handler: "onForwardClick",
          align: "end",
          weight: 100
        }
      },
      // An optional extra CSS class to add to the picker container element
      calendarContainerCls: "",
      /**
       * Get/set min value, which can be a Date or a string. If a string is specified, it will be converted using
       * the specified {@link #config-format}.
       * @member {Date} min
       * @accepts {String|Date}
       */
      /**
       * Min value
       * @config {String|Date}
       */
      min: null,
      /**
       * Get/set max value, which can be a Date or a string. If a string is specified, it will be converted using
       * the specified {@link #config-format}.
       * @member {Date} max
       * @accepts {String|Date}
       */
      /**
       * Max value
       * @config {String|Date}
       */
      max: null,
      /**
       * The `step` property may be set in object form specifying two properties, `magnitude`, a Number, and
       * `unit`, a String.
       *
       * If a Number is passed, the step's current unit is used (or `day` if no current step set) and just the
       * magnitude is changed.
       *
       * If a String is passed, it is parsed by {@link Core.helper.DateHelper#function-parseDuration-static}, for
       * example `'1d'`, `'1 d'`, `'1 day'`, or `'1 day'`.
       *
       * Upon read, the value is always returned in object form containing `magnitude` and `unit`.
       * @member {DurationConfig} step
       * @accepts {String|Number|DurationConfig}
       */
      /**
       * Time increment duration value. If specified, `forward` and `back` triggers are displayed.
       * The value is taken to be a string consisting of the numeric magnitude and the units.
       * The units may be a recognised unit abbreviation of this locale or the full local unit name.
       * For example `'1d'` or `'1w'` or `'1 week'`. This may be specified as an object containing
       * two properties: `magnitude`, a Number, and `unit`, a String
       * @config {String|Number|DurationConfig}
       */
      step: false,
      stepTriggers: null,
      /**
       * The week start day in the {@link #config-picker}, 0 meaning Sunday, 6 meaning Saturday.
       * Uses localized value per default.
       * @config {Number}
       */
      weekStartDay: null,
      /**
       * A config object used to configure the {@link Core.widget.DatePicker datePicker}.
       * ```javascript
       * dateField = new DateField({
       *      picker    : {
       *          multiSelect : true
       *      }
       *  });
       * ```
       * @config {DatePickerConfig}
       */
      picker: {
        type: "datepicker",
        role: "dialog",
        floating: true,
        scrollAction: "realign",
        align: {
          align: "t0-b0",
          axisLock: true
        }
      },
      /**
       * Get/set value, which can be set as a Date or a string but always returns a Date. If a string is
       * specified, it will be converted using the specified {@link #config-format}
       * @member {Date} value
       * @accepts {String|Date}
       */
      /**
       * Value, which can be a Date or a string. If a string is specified, it will be converted using the
       * specified {@link #config-format}
       * @config {String|Date}
       */
      value: null
    };
  }
  //endregion
  //region Init & destroy
  /**
   * Creates default picker widget
   *
   * @internal
   */
  changePicker(picker, oldPicker) {
    const me = this, defaults = {
      owner: me,
      forElement: me[me.pickerAlignElement],
      minDate: me.min,
      maxDate: me.max,
      weekStartDay: me._weekStartDay,
      // need to pass the raw value to let the component to use its default value
      align: {
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement]
      },
      onSelectionChange: ({ selection, source: picker2 }) => {
        if (picker2.isVisible) {
          me._isUserAction = me._isPickerInput = true;
          me.value = me.value ? DateHelper.copyTimeValues(new Date(selection[0]), me.value) : new Date(selection[0]);
          me._isPickerInput = me._isUserAction = false;
          picker2.hide();
        }
      }
    };
    if (me.calendarContainerCls) {
      defaults.cls = me.calendarContainerCls;
    }
    if (me.value) {
      defaults.value = me.value;
    } else {
      defaults.activeDate = /* @__PURE__ */ new Date();
    }
    const result = DatePicker.reconfigure(oldPicker, picker, {
      owner: me,
      defaults
    });
    result == null ? void 0 : result.refresh.flush();
    return result;
  }
  //endregion
  //region Click listeners
  get backShiftDate() {
    return DateHelper.add(this.value, -1 * this._step.magnitude, this._step.unit);
  }
  onBackClick() {
    const me = this, { min: min2 } = me;
    if (!me.readOnly && me.value) {
      const newValue = me.backShiftDate;
      if (!min2 || min2.getTime() <= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  get forwardShiftDate() {
    return DateHelper.add(this.value, this._step.magnitude, this._step.unit);
  }
  onForwardClick() {
    const me = this, { max } = me;
    if (!me.readOnly && me.value) {
      const newValue = me.forwardShiftDate;
      if (!max || max.getTime() >= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  //endregion
  //region Toggle picker
  showPicker(focusPicker) {
    if (this.readOnly) {
      return;
    }
    const me = this, { _picker } = me;
    if (_picker) {
      const pickerConfig = {
        minDate: me.min,
        maxDate: me.max
      };
      if (me.value) {
        pickerConfig.value = me.value;
      } else if (!_picker.activeDate) {
        pickerConfig.activeDate = /* @__PURE__ */ new Date();
      }
      _picker.setConfig(pickerConfig);
    }
    super.showPicker(focusPicker);
  }
  focusPicker() {
    this.picker.focus();
  }
  //endregion
  // region Validation
  get isValid() {
    const me = this;
    me.clearError("L{Field.minimumValueViolation}", true);
    me.clearError("L{Field.maximumValueViolation}", true);
    let value = me.value;
    if (value) {
      const { min: min2, max, validateDateOnly } = me;
      if (validateDateOnly) {
        value = DateHelper.clearTime(value, false);
      }
      if (min2 && value < min2) {
        me.setError("L{Field.minimumValueViolation}", true);
        return false;
      }
      if (max && value > max) {
        me.setError("L{Field.maximumValueViolation}", true);
        return false;
      }
    }
    return super.isValid;
  }
  //endregion
  //region Getters/setters
  transformDateValue(value, checkBounds = true) {
    const me = this;
    if (value != null) {
      if (!DateHelper.isDate(value)) {
        if (typeof value === "string") {
          value = DateHelper.parse(value, me.format, me.strictParsing) || DateHelper.parse(value, me.fallbackFormat, me.strictParsing);
        } else {
          value = new Date(value);
        }
      }
      if (DateHelper.isValidDate(value)) {
        if (checkBounds && (!me.min || value - me.min > -DateHelper.MS_PER_DAY) && (!me.max || value <= me.max)) {
          return me.transformTimeValue(value);
        }
        return value;
      }
    }
    return null;
  }
  transformTimeValue(value) {
    const me = this, { keepTime } = me;
    value = DateHelper.clone(value);
    if (!keepTime) {
      DateHelper.clearTime(value, false);
    } else if (keepTime !== "entered" && keepTime !== true) {
      const timeValue = DateHelper.parse(keepTime, me.timeFormat);
      if (DateHelper.isValidDate(timeValue)) {
        DateHelper.copyTimeValues(value, timeValue);
      } else if (DateHelper.isValidDate(me.value)) {
        DateHelper.copyTimeValues(value, me.value);
      }
    } else if (keepTime === true && (me._isPickerInput || me.inputting) && DateHelper.isValidDate(me.value)) {
      DateHelper.copyTimeValues(value, me.value);
    }
    return value;
  }
  changeMin(value) {
    return this.transformDateValue(value, false);
  }
  updateMin(min2) {
    const { input, _picker } = this;
    if (input) {
      if (min2 == null) {
        input.removeAttribute("min");
      } else {
        input.min = min2;
      }
    }
    if (_picker) {
      _picker.minDate = min2;
    }
    this.syncInvalid();
  }
  changeMax(value) {
    return this.transformDateValue(value, false);
  }
  updateMax(max) {
    const { input, _picker } = this;
    if (input) {
      if (max == null) {
        input.removeAttribute("max");
      } else {
        input.max = max;
      }
    }
    if (_picker) {
      _picker.maxDate = max;
    }
    this.syncInvalid();
  }
  get weekStartDay() {
    return typeof this._weekStartDay === "number" ? this._weekStartDay : DateHelper.weekStartDay;
  }
  updateWeekStartDay(weekStartDay) {
    if (this._picker) {
      this._picker.weekStartDay = weekStartDay;
    }
  }
  changeValue(value, oldValue) {
    const me = this, newValue = me.transformDateValue(value);
    if (value && !newValue) {
      me.setError("L{invalidDate}");
      return;
    }
    me.clearError("L{invalidDate}");
    if (me.hasChanged(oldValue, newValue)) {
      return super.changeValue(newValue, oldValue);
    }
    if (!me.inputting) {
      me.syncInputFieldValue();
    }
  }
  updateValue(value, oldValue) {
    const picker = this._picker;
    if (picker && !this.inputting) {
      picker.value = picker.activeDate = value;
    }
    super.updateValue(value, oldValue);
  }
  changeStep(value, was) {
    const type = typeof value;
    if (!value) {
      return null;
    }
    if (type === "number") {
      value = {
        magnitude: Math.abs(value),
        unit: was ? was.unit : "day"
      };
    } else if (type === "string") {
      value = DateHelper.parseDuration(value);
    }
    if (value && value.unit && value.magnitude) {
      if (value.magnitude < 0) {
        value = {
          magnitude: -value.magnitude,
          // Math.abs
          unit: value.unit
        };
      }
      return value;
    }
  }
  updateStep(value) {
    this.element.classList[value ? "remove" : "add"]("b-no-steppers");
    this.syncInvalid();
  }
  hasChanged(oldValue, newValue) {
    if ((oldValue == null ? void 0 : oldValue.getTime) && (newValue == null ? void 0 : newValue.getTime) && this.keepTime !== "entered" && this.keepTime !== true) {
      return !DateHelper.isEqual(DateHelper.clearTime(oldValue), DateHelper.clearTime(newValue));
    }
    return super.hasChanged(oldValue && oldValue.getTime(), newValue && newValue.getTime());
  }
  get inputValue() {
    const date = this.value;
    return date ? DateHelper.format(date, this.format) : "";
  }
  updateFormat() {
    if (!this.isConfiguring) {
      this.syncInputFieldValue(true);
    }
  }
  //endregion
  //region Localization
  updateLocalization() {
    super.updateLocalization();
    this.syncInputFieldValue(true);
  }
  //endregion
  //region Other
  internalOnKeyEvent(event) {
    super.internalOnKeyEvent(event);
    if (event.key === "Enter" && this.isValid) {
      this.picker.hide();
    }
  }
  //endregion
};
//region Config
__publicField(DateField, "$name", "DateField");
__publicField(DateField, "type", "datefield");
__publicField(DateField, "alias", "date");
DateField.initClass();
DateField._$name = "DateField";

// ../Core/lib/Core/widget/NumberField.js
var preventDefault = (e) => e.ctrlKey && e.preventDefault();
var NumberField = class extends Field {
  static get configurable() {
    return {
      /**
       * Reset to min value when max value is reached using steppers, and vice-versa.
       * @config {Boolean}
       * @default false
       */
      wrapAround: null,
      /**
       * Min value
       * @config {Number}
       */
      min: null,
      /**
       * Max value
       * @config {Number}
       */
      max: null,
      /**
       * Step size for spin button clicks.
       * @member {Number} step
       */
      /**
       * Step size for spin button clicks. Also used when pressing up/down keys in the field.
       * @config {Number}
       * @default
       */
      step: 1,
      /**
       * Large step size, defaults to 10 * `step`. Applied when pressing SHIFT and stepping either by click or
       * using keyboard.
       * @config {Number}
       * @default 10
       */
      largeStep: 0,
      /**
       * Initial value
       * @config {Number}
       */
      value: null,
      /**
       * The format to use for rendering numbers.
       *
       * For example:
       * ```
       *  format: '9,999.00##'
       * ```
       * The above enables digit grouping and will display at least 2 (but no more than 4) fractional digits.
       * @config {String|NumberFormatConfig}
       * @default
       */
      format: "",
      /**
       * The number of decimal places to allow. Defaults to no constraint.
       *
       * This config has been replaced by {@link #config-format}. Instead of this:
       *```
       *  decimalPrecision : 3
       *```
       * Use `format`:
       *```
       *  format : '9.###'
       *```
       * To set both `decimalPrecision` and `leadingZeroes` (say to `3`), do this:
       *```
       *  format : '3>9.###'
       *```
       * @config {Number}
       * @default
       * @deprecated Since 3.1. Use {@link #config-format} instead.
       */
      decimalPrecision: null,
      /**
       * The maximum number of leading zeroes to show. Defaults to no constraint.
       *
       * This config has been replaced by {@link #config-format}. Instead of this:
       *```
       *  leadingZeros : 3
       *```
       * Use `format`:
       *```
       *  format : '3>9'
       *```
       * To set both `leadingZeroes` and `decimalPrecision` (say to `2`), do this:
       *```
       *  format : '3>9.##'
       *```
       * @config {Number}
       * @default
       * @deprecated Since 3.1. Use {@link #config-format} instead.
       */
      leadingZeroes: null,
      triggers: {
        spin: {
          type: "spintrigger"
        }
      },
      /**
       * Controls how change events are triggered when stepping the value up or down using either spinners or
       * arrow keys.
       *
       * Configure with:
       * * `true` to trigger a change event per step
       * * `false` to not trigger change while stepping. Will trigger on blur/Enter
       * * A number of milliseconds to buffer the change event, triggering when no steps are performed during that
       *   period of time.
       *
       * @config {Boolean|Number}
       * @default
       */
      changeOnSpin: true,
      // NOTE: using type="number" has several trade-offs:
      //
      // Negatives:
      //   - No access to caretPos/textSelection. This causes anomalies when replacing
      //     the input value with a formatted version of that value (the caret moves to
      //     the end of the input el on each character typed).
      //   - The above also prevents Siesta/synthetic events from mimicking typing.
      //   - Thousand separators cannot be displayed (input.value = '1,000' throws an
      //     exception).
      // Positives:
      //   - On mobile, the virtual keyboard only shows digits et al.
      //   - validity property on DOM node that handles min/max checks.
      //
      // The above may not be exhaustive, but there is not a compelling reason to
      // use type="number" except on mobile.
      /**
       * This can be set to `'number'` to enable the numeric virtual keyboard on
       * mobile devices. Doing so limits this component's ability to handle keystrokes
       * and format properly as the user types, so this is not recommended for
       * desktop applications. This will also limit similar features of automated
       * testing tools that mimic user input.
       * @config {String}
       * @default text
       */
      inputType: null
    };
  }
  //endregion
  //region Init
  construct(config) {
    super.construct(config);
    const me = this;
    me.input.addEventListener("dblclick", () => {
      me.select();
    });
    if (typeof me.changeOnSpin === "number") {
      me.bufferedSpinChange = me.buffer(me.triggerChange, me.changeOnSpin);
    }
  }
  //endregion
  //region Internal functions
  acceptValue(value, rawValue) {
    let accept = !isNaN(value);
    if (accept && !this.hasTextSelection) {
      accept = false;
      const raw = this.input.value, current = parseFloat(raw);
      if (raw !== rawValue) {
        accept = !this.acceptValue(current, raw);
      }
    }
    return accept;
  }
  okMax(value) {
    return isNaN(this.max) || value <= this.max;
  }
  okMin(value) {
    return isNaN(this.min) || value >= this.min;
  }
  internalOnKeyEvent(e) {
    if (e.type === "keydown") {
      const me = this, key = e.key;
      let block;
      if (key === "ArrowUp") {
        me.doSpinUp(e.shiftKey);
        block = true;
      } else if (key === "ArrowDown") {
        me.doSpinDown(e.shiftKey);
        block = true;
      } else if (!e.altKey && !e.ctrlKey && key && key.length === 1) {
        const after = me.getAfterValue(key), afterValue = me.formatter.parseStrict(after), accepted = afterValue === me.value || after === "-" && (isNaN(me.min) || me.min < 0);
        block = !accepted && !me.acceptValue(afterValue, after);
      }
      if (key === "Enter" && me._changedBySilentSpin) {
        me.triggerChange(e, true);
        me._changedBySilentSpin = false;
      }
      if (block) {
        e.preventDefault();
      }
    }
    super.internalOnKeyEvent(e);
  }
  doSpinUp(largeStep = false) {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.value || 0) + (largeStep ? me.largeStep : me.step);
    if (!me.okMin(newValue)) {
      newValue = me.min;
    }
    if (me.okMax(newValue)) {
      me.applySpinChange(newValue);
    } else if (me.wrapAround) {
      newValue = me.min;
      me.applySpinChange(newValue);
    }
  }
  doSpinDown(largeStep = false) {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.value || 0) - (largeStep ? me.largeStep : me.step);
    if (!me.okMax(newValue)) {
      newValue = me.max;
    }
    if (me.okMin(newValue)) {
      me.applySpinChange(newValue);
    } else if (me.wrapAround) {
      newValue = me.max;
      me.applySpinChange(newValue);
    }
  }
  applySpinChange(newValue) {
    const me = this;
    me._isUserAction = true;
    if (me.changeOnSpin !== true) {
      me._changedBySilentSpin = true;
      me.silenceChange = true;
      me.bufferedSpinChange && me.bufferedSpinChange(null, true);
    }
    me.value = newValue;
    me._isUserAction = false;
    me.silenceChange = false;
  }
  triggerChange() {
    if (!this.silenceChange) {
      super.triggerChange(...arguments);
    }
  }
  onFocusOut(e) {
    var _a2, _b, _c;
    super.onFocusOut(...arguments);
    const me = this, { input } = me, raw = input.value, value = me.formatter.truncate(raw), formatted = isNaN(value) ? raw : me.formatValue(value);
    (_c = (_b = (_a2 = me.triggers) == null ? void 0 : _a2.spin) == null ? void 0 : _b.clickRepeater) == null ? void 0 : _c.cancel();
    me.lastTouchmove = null;
    if (raw !== formatted) {
      input.value = formatted;
    }
    if (me._changedBySilentSpin) {
      me.triggerChange(e, true);
      me._changedBySilentSpin = false;
    }
  }
  internalOnInput(event) {
    const me = this, { formatter, input } = me, { parser, maximumFractionDigits } = formatter, raw = input.value, decimals = parser.decimalPlaces(raw);
    if (formatter.truncator && decimals > maximumFractionDigits) {
      let value = raw, valueDecimals;
      const trunc = formatter.truncate(raw);
      if (!isNaN(trunc)) {
        value = me.formatValue(trunc);
        valueDecimals = parser.decimalPlaces(value);
        if (valueDecimals < maximumFractionDigits) {
          value += "0".repeat(maximumFractionDigits - valueDecimals);
          valueDecimals = maximumFractionDigits;
        }
        if (valueDecimals < decimals) {
          const pos = raw.length - me.caretPos;
          input.value = value;
          me.caretPos = value.length - pos + 1;
        }
      }
    }
    super.internalOnInput(event);
  }
  formatValue(value) {
    return this.formatter.format(value);
  }
  changeFormat(format2) {
    const me = this;
    if (format2 === "") {
      const { leadingZeroes, decimalPrecision } = me;
      format2 = leadingZeroes ? `${leadingZeroes}>9` : null;
      if (decimalPrecision != null) {
        format2 = `${format2 || ""}9.${"#".repeat(decimalPrecision)}`;
      } else if (format2) {
        format2 += ".*";
      }
    }
    return format2;
  }
  get formatter() {
    const me = this, format2 = me.format;
    let formatter = me._formatter;
    if (!formatter || me._lastFormat !== format2) {
      formatter = NumberFormat.get(me._lastFormat = format2);
      me._formatter = formatter;
    }
    return formatter;
  }
  //endregion
  //region Getters/Setters
  updateStep(step) {
    var _a2;
    const me = this;
    me.element.classList.toggle("b-hide-spinner", !step);
    me._step = step;
    if (step && BrowserHelper.isMobile) {
      if (!me.touchMoveListener) {
        me.touchMoveListener = EventHelper.on({
          element: me.input,
          touchmove: "onInputSwipe",
          thisObj: me,
          throttled: {
            buffer: 150,
            alt: preventDefault
          }
        });
      }
    } else {
      (_a2 = me.touchMoveListener) == null ? void 0 : _a2.call(me);
    }
  }
  onInputSwipe(e) {
    const { lastTouchmove } = this;
    if (lastTouchmove) {
      const deltaX = e.screenX - lastTouchmove.screenX, deltaY = lastTouchmove.screenY - e.screenY, delta = Math.abs(deltaX) > Math.abs(deltaY) ? deltaX : deltaY;
      this[`doSpin${delta > 0 ? "Up" : "Down"}`]();
    }
    e.preventDefault();
    this.lastTouchmove = e;
  }
  changeLargeStep(largeStep) {
    return largeStep || this.step * 10;
  }
  get validity() {
    const value = this.value, validity = {};
    if (value != null) {
      validity.rangeUnderflow = !this.okMin(value);
      validity.rangeOverflow = !this.okMax(value);
    }
    validity.valid = !validity.rangeUnderflow && !validity.rangeOverflow;
    return validity;
  }
  /**
   * Get/set the NumberField's value, or `undefined` if the input field is empty
   * @property {Number}
   */
  changeValue(value, was) {
    const me = this;
    if (value || value === 0) {
      let valueIsNaN;
      if (typeof value !== "number") {
        value = typeof value === "string" ? me.formatter.parse(value) : Number(value);
        valueIsNaN = isNaN(value);
        if (valueIsNaN) {
          value = "";
        }
      }
      if (!valueIsNaN && me.format) {
        value = me.formatter.round(value);
      }
    } else {
      value = void 0;
    }
    return super.changeValue(value, was);
  }
  get inputValue() {
    let value = this.value;
    if (value != null && this.format) {
      value = this.formatValue(value);
    }
    return value;
  }
  //endregion
};
//region Config
__publicField(NumberField, "$name", "NumberField");
__publicField(NumberField, "type", "numberfield");
__publicField(NumberField, "alias", "number");
NumberField.initClass();
NumberField._$name = "NumberField";

// ../Core/lib/Core/widget/TimePicker.js
var TimePicker = class extends Panel {
  //endregion
  //region Init
  construct(config) {
    super.construct(config);
    this.refresh();
  }
  updateSeconds(seconds) {
    this.widgetMap.second[seconds ? "show" : "hide"]();
  }
  //endregion
  //region Event listeners
  // Automatically called by Widget's triggerFieldChange which announces changes to all ancestors
  onFieldChange() {
    if (!this.isConfiguring && !this.isRefreshing) {
      this.value = this.pickerToTime();
    }
  }
  onAmPmButtonClick({ source }) {
    this._pm = source.ref === "pmButton";
    if (this._value) {
      this.value = this.pickerToTime();
    }
  }
  onInternalKeyDown(keyEvent) {
    var _a2;
    const me = this;
    switch (keyEvent.key) {
      case "Escape":
        me.triggerTimeChange(me._initialValue);
        me.hide();
        keyEvent.preventDefault();
        return;
      case "Enter":
        me.value = me.pickerToTime();
        me.hide();
        keyEvent.preventDefault();
        return;
    }
    (_a2 = super.onInternalKeyDown) == null ? void 0 : _a2.call(this, keyEvent);
  }
  //endregion
  //region Internal functions
  pickerToTime() {
    const me = this, pm = me._pm, { hour: hour2, minute, second } = me.widgetMap;
    hour2.format = me._is24Hour ? "2>9" : null;
    let hours = hour2.value, newValue = new Date(me.value);
    if (!me._is24Hour) {
      if (pm && hours < 12)
        hours = hours + 12;
      if (!pm && hours === 12)
        hours = 0;
    }
    newValue.setHours(hours);
    newValue.setMinutes(minute.value);
    if (me.seconds) {
      newValue.setSeconds(second.value);
    }
    if (me._min) {
      newValue = DateHelper.max(me._min, newValue);
    }
    if (me._max) {
      newValue = DateHelper.min(me._max, newValue);
    }
    return newValue;
  }
  triggerTimeChange(time) {
    this.trigger("timeChange", { time });
  }
  //endregion
  //region Getters / Setters
  updateInitialValue(initialValue) {
    this.value = initialValue;
  }
  changeValue(value) {
    if (value) {
      value = typeof value === "string" ? DateHelper.parse(value, this.format) : value;
    }
    if (!this.isVisible) {
      this._initialValue = value;
    }
    return value != null ? value : DateHelper.getTime(0);
  }
  updateValue(value) {
    if (this.isVisible) {
      this.triggerTimeChange(value);
    }
    this.refresh();
  }
  updateFormat(format2) {
    this._is24Hour = DateHelper.is24HourFormat(format2);
    this.refresh();
  }
  changeMin(min2) {
    return typeof min2 === "string" ? DateHelper.parse(min2, this.format) : min2;
  }
  changeMax(max) {
    return typeof max === "string" ? DateHelper.parse(max, this.format) : max;
  }
  //endregion
  //region Display
  refresh() {
    const me = this;
    if (!me.isConfiguring && me.value) {
      me.isRefreshing = true;
      const { hour: hour2, minute, second, amButton, pmButton } = me.widgetMap, time = me.value, is24 = me._is24Hour, hours = time.getHours(), pm = me._pm = hours >= 12;
      me.element.classList[is24 ? "add" : "remove"]("b-24h");
      hour2.min = is24 ? 0 : 1;
      hour2.max = is24 ? 23 : 12;
      hour2.value = is24 ? hours : hours % 12 || 12;
      minute.value = time.getMinutes();
      second.value = time.getSeconds();
      amButton.pressed = !pm;
      pmButton.pressed = pm;
      amButton.hidden = pmButton.hidden = is24;
      me.isRefreshing = false;
    }
  }
  //endregion
};
//region Config
__publicField(TimePicker, "$name", "TimePicker");
__publicField(TimePicker, "type", "timepicker");
__publicField(TimePicker, "configurable", {
  floating: true,
  layout: "hbox",
  items: {
    hour: {
      label: "L{TimePicker.hour}",
      type: "number",
      min: 0,
      max: 23,
      highlightExternalChange: false,
      format: "2>9",
      wrapAround: true
    },
    minute: {
      label: "L{TimePicker.minute}",
      type: "number",
      min: 0,
      max: 59,
      highlightExternalChange: false,
      format: "2>9",
      wrapAround: true
    },
    second: {
      hidden: true,
      label: "L{TimePicker.second}",
      type: "number",
      min: 0,
      max: 59,
      highlightExternalChange: false,
      format: "2>9",
      wrapAround: true
    },
    amPm: {
      type: "buttongroup",
      items: {
        amButton: {
          type: "button",
          text: "AM",
          toggleGroup: "am-pm",
          cls: "b-blue",
          onClick: "up.onAmPmButtonClick"
        },
        pmButton: {
          type: "button",
          text: "PM",
          toggleGroup: "am-pm",
          cls: "b-blue",
          onClick: "up.onAmPmButtonClick"
        }
      }
    }
  },
  autoShow: false,
  trapFocus: true,
  /**
   * By default the seconds field is not displayed. If you require seconds to be visible,
   * configure this as `true`
   * @config {Boolean}
   * @default false
   */
  seconds: null,
  /**
   * Time value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @prp {Date}
   * @accepts {Date|String}
   */
  value: {
    $config: {
      equal: "date"
    },
    value: null
  },
  /**
   * Time format. Used to set appropriate 12/24 hour format to display.
   * See {@link Core.helper.DateHelper#function-format-static DateHelper} for formatting options.
   * @prp {String}
   */
  format: null,
  /**
   * Max value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @prp {Date}
   * @accepts {Date|String}
   */
  max: null,
  /**
   * Min value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}
   * @prp {Date}
   * @accepts {Date|String}
   */
  min: null,
  /**
   * Initial value, which can be a Date or a string. If a string is specified, it will be converted using the
   * specified {@link #config-format}. Initial value is restored on Escape click
   * @member {Date} initialValue
   * @accepts {Date|String}
   */
  initialValue: null
  // Not documented as config on purpose, API was that way
});
TimePicker.initClass();
TimePicker._$name = "TimePicker";

// ../Core/lib/Core/widget/TimeField.js
var TimeField = class extends PickerField {
  static get configurable() {
    return {
      picker: {
        type: "timepicker",
        align: {
          align: "t0-b0",
          axisLock: true
        }
      },
      /**
       * Get/Set format for time displayed in field (see {@link Core.helper.DateHelper#function-format-static}
       * for formatting options).
       * @member {String} format
       */
      /**
       * Format for date displayed in field (see Core.helper.DateHelper#function-format-static for formatting
       * options).
       * @config {String}
       * @default
       */
      format: "LT",
      triggers: {
        expand: {
          align: "end",
          handler: "onTriggerClick",
          compose: () => ({
            children: [{
              class: {
                "b-icon-clock-live": 1
              }
            }]
          })
        },
        back: {
          align: "start",
          cls: "b-icon b-icon-angle-left b-step-trigger",
          key: "Shift+ArrowDown",
          handler: "onBackClick"
        },
        forward: {
          align: "end",
          cls: "b-icon b-icon-angle-right b-step-trigger",
          key: "Shift+ArrowUp",
          handler: "onForwardClick"
        }
      },
      /**
       * Get/set min value, which can be a Date or a string. If a string is specified, it will be converted using
       * the specified {@link #config-format}.
       * @member {Date} min
       * @accepts {String|Date}
       */
      /**
       * Min time value
       * @config {String|Date}
       */
      min: null,
      /**
       * Get/set max value, which can be a Date or a string. If a string is specified, it will be converted using
       * the specified {@link #config-format}.
       * @member {Date} max
       * @accepts {String|Date}
       */
      /**
       * Max time value
       * @config {String|Date}
       */
      max: null,
      /**
       * The `step` property may be set in Object form specifying two properties, `magnitude`, a Number, and
       * `unit`, a String.
       *
       * If a Number is passed, the steps's current unit is used and just the magnitude is changed.
       *
       * If a String is passed, it is parsed by {@link Core.helper.DateHelper#function-parseDuration-static}, for
       * example `'5m'`, `'5 m'`, `'5 min'`, `'5 minutes'`.
       *
       * Upon read, the value is always returned in object form containing `magnitude` and `unit`.
       * @member {DurationConfig} step
       * @accepts {String|Number|DurationConfig}
       */
      /**
       * Time increment duration value. Defaults to 5 minutes.
       * The value is taken to be a string consisting of the numeric magnitude and the units.
       * The units may be a recognised unit abbreviation of this locale or the full local unit name.
       * For example `"10m"` or `"5min"` or `"2 hours"`
       * @config {String}
       */
      step: "5m",
      stepTriggers: null,
      /**
       * Get/set value, which can be a Date or a string. If a string is specified, it will be converted using the
       * specified {@link #config-format}.
       * @member {Date} value
       * @accepts {String|Date}
       */
      /**
       * Value, which can be a Date or a string. If a string is specified, it will be converted using the
       * specified {@link #config-format}
       * @config {String|Date}
       */
      value: null,
      /**
       * Set to true to not clean up the date part of the passed value. Set to false to reset the date part to
       * January 1st
       * @prp {Boolean}
       * @default
       */
      keepDate: false
    };
  }
  //endregion
  //region Init & destroy
  changePicker(picker, oldPicker) {
    const me = this;
    return TimePicker.reconfigure(oldPicker, picker, {
      owner: me,
      defaults: {
        value: me.value,
        forElement: me[me.pickerAlignElement],
        owner: me,
        align: {
          anchor: me.overlayAnchor,
          target: me[me.pickerAlignElement]
        },
        onTimeChange({ time }) {
          me._isUserAction = true;
          me.value = time;
          me._isUserAction = false;
        }
      }
    });
  }
  //endregion
  //region Click listeners
  onBackClick() {
    const me = this, { min: min2 } = me;
    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, -1 * me.step.magnitude, me.step.unit);
      if (!min2 || min2.getTime() <= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  onForwardClick() {
    const me = this, { max } = me;
    if (!me.readOnly && me.value) {
      const newValue = DateHelper.add(me.value, me.step.magnitude, me.step.unit);
      if (!max || max.getTime() >= newValue) {
        me._isUserAction = true;
        me.value = newValue;
        me._isUserAction = false;
      }
    }
  }
  //endregion
  // region Validation
  get isValid() {
    const me = this;
    me.clearError("L{Field.minimumValueViolation}", true);
    me.clearError("L{Field.maximumValueViolation}", true);
    let value = me.value;
    if (value) {
      value = value.getTime();
      if (me._min && me._min.getTime() > value) {
        me.setError("L{Field.minimumValueViolation}", true);
        return false;
      }
      if (me._max && me._max.getTime() < value) {
        me.setError("L{Field.maximumValueViolation}", true);
        return false;
      }
    }
    return super.isValid;
  }
  hasChanged(oldValue, newValue) {
    if ((oldValue == null ? void 0 : oldValue.getTime) && (newValue == null ? void 0 : newValue.getTime)) {
      return oldValue.getHours() !== newValue.getHours() || oldValue.getMinutes() !== newValue.getMinutes() || oldValue.getSeconds() !== newValue.getSeconds() || oldValue.getMilliseconds() !== newValue.getMilliseconds();
    }
    return super.hasChanged(oldValue, newValue);
  }
  //endregion
  //region Toggle picker
  /**
   * Show picker
   */
  showPicker() {
    const me = this, {
      picker,
      value
    } = me;
    if (me.readOnly) {
      return;
    }
    picker.value = value;
    picker.format = me.format;
    picker.maxTime = me.max;
    picker.minTime = me.min;
    if (!value) {
      me.value = picker.value;
    }
    super.showPicker(true);
  }
  onPickerShow() {
    var _a2;
    super.onPickerShow();
    this.pickerKeyDownRemover = (_a2 = this.pickerKeyDownRemover) == null ? void 0 : _a2.call(this);
  }
  /**
   * Focus time picker
   */
  focusPicker() {
    this.picker.focus();
  }
  //endregion
  //region Getters/setters
  transformTimeValue(value) {
    if (value != null) {
      if (typeof value === "string") {
        value = DateHelper.parse(value, this.format);
        if (this.keepDate) {
          value = DateHelper.copyTimeValues(new Date(this.value), value);
        }
      } else {
        value = new Date(value);
      }
      if (DateHelper.isValidDate(value)) {
        if (!this.keepDate) {
          return DateHelper.getTime(value);
        } else {
          return value;
        }
      }
    }
    return null;
  }
  changeMin(value) {
    return this.transformTimeValue(value);
  }
  updateMin(value) {
    const { input } = this;
    if (input) {
      if (value == null) {
        input.removeAttribute("min");
      } else {
        input.min = value;
      }
    }
    this.syncInvalid();
  }
  changeMax(value) {
    return this.transformTimeValue(value);
  }
  updateMax(value) {
    const { input } = this;
    if (input) {
      if (value == null) {
        input.removeAttribute("max");
      } else {
        input.max = value;
      }
    }
    this.syncInvalid();
  }
  changeValue(value, was) {
    const me = this, newValue = me.transformTimeValue(value);
    if (value && !newValue || me.isRequired && value === "") {
      me.setError("L{invalidTime}");
      return;
    }
    me.clearError("L{invalidTime}");
    if (me.hasChanged(was, newValue)) {
      return super.changeValue(newValue, was);
    }
    if (!me.inputting) {
      me.syncInputFieldValue(true);
    }
  }
  updateValue(value, was) {
    const { expand } = this.triggers;
    if (expand && value) {
      expand.element.firstElementChild.style.animationDelay = -((value.getHours() * 60 + value.getMinutes()) / 10) + "s";
    }
    super.updateValue(value, was);
  }
  changeStep(value, was) {
    const type = typeof value;
    if (!value) {
      return null;
    }
    if (type === "number") {
      value = {
        magnitude: Math.abs(value),
        unit: was ? was.unit : "hour"
      };
    } else if (type === "string") {
      value = DateHelper.parseDuration(value);
    }
    if ((value == null ? void 0 : value.unit) && (value == null ? void 0 : value.magnitude)) {
      if (value.magnitude < 0) {
        value = {
          magnitude: -value.magnitude,
          // Math.abs
          unit: value.unit
        };
      }
      return value;
    }
  }
  updateStep(value) {
    this.element.classList[value ? "remove" : "add"]("b-no-steppers");
    this.syncInvalid();
  }
  updateFormat() {
    this.syncInputFieldValue(true);
  }
  get inputValue() {
    return DateHelper.format(this.value, this.format);
  }
  //endregion
  //region Localization
  updateLocalization() {
    super.updateLocalization();
    this.syncInputFieldValue(true);
  }
  //endregion
};
//region Config
__publicField(TimeField, "$name", "TimeField");
__publicField(TimeField, "type", "timefield");
__publicField(TimeField, "alias", "time");
TimeField.initClass();
TimeField._$name = "TimeField";

// ../Core/lib/Core/widget/DateTimeField.js
var midnightDate = new Date(2e3, 0, 1);
var DateTimeField = class extends Field {
  doDestroy() {
    this.dateField.destroy();
    this.timeField.destroy();
    super.doDestroy();
  }
  get focusElement() {
    return this.dateField.input;
  }
  // Implementation needed at this level because it has two inner elements in its inputWrap
  get innerElements() {
    return [
      this.dateField.element,
      this.timeField.element
    ];
  }
  // Each subfield handles its own keystrokes
  internalOnKeyEvent() {
  }
  // CellEdit sets this dynamically on its editor field
  updateRevertOnEscape(revertOnEscape) {
    this.timeField.revertOnEscape = revertOnEscape;
    this.dateField.revertOnEscape = revertOnEscape;
  }
  // Converts the timeField config into a TimeField
  changeTimeField(config) {
    const me = this, result = TimeField.new({
      revertOnEscape: me.revertOnEscape,
      syncInvalid(...args) {
        const updatingInvalid = me.updatingInvalid;
        TimeField.prototype.syncInvalid.apply(this, args);
        me.timeField && !updatingInvalid && me.syncInvalid();
      }
    }, config);
    EventHelper.on({
      element: result.element,
      keydown: "onTimeFieldKeyDown",
      thisObj: me
    });
    if (me.readOnly) {
      result.readOnly = true;
    }
    return result;
  }
  // Set up change listener when TimeField is available. Not in timeField config to enable users to supply their own
  // listeners block there
  updateTimeField(timeField) {
    const me = this;
    timeField.ion({
      change({ userAction, value }) {
        if (userAction && !me.$settingValue) {
          const dateAndTime = me.dateField.value;
          me._isUserAction = true;
          me.value = dateAndTime ? DateHelper.copyTimeValues(new Date(dateAndTime), value || midnightDate) : null;
          me._isUserAction = false;
        }
      },
      thisObj: me
    });
  }
  // Converts the dateField config into a class based on { type : "..." } provided (DateField by default)
  changeDateField(config) {
    const me = this, type = (config == null ? void 0 : config.type) || "datefield", cls = Widget.resolveType(config.type || "datefield"), result = Widget.create(ObjectHelper.assign({
      type,
      revertOnEscape: me.revertOnEscape,
      syncInvalid(...args) {
        const updatingInvalid = me.updatingInvalid;
        cls.prototype.syncInvalid.apply(this, args);
        me.dateField && !updatingInvalid && me.syncInvalid();
      }
    }, config));
    EventHelper.on({
      element: result.element,
      keydown: "onDateFieldKeyDown",
      thisObj: me
    });
    if (me.readOnly) {
      result.readOnly = true;
    }
    result.ion({
      keydown: ({ event }) => {
        var _a2;
        if (event.key === "Tab" && !event.shiftKey && ((_a2 = this.timeField) == null ? void 0 : _a2.isVisible)) {
          event.stopPropagation();
          event.cancelBubble = true;
        }
      }
    });
    return result;
  }
  get childItems() {
    return [this.dateField, this.timeField];
  }
  // Set up change listener when DateField is available. Not in dateField config to enable users to supply their own
  // listeners block there
  updateDateField(dateField) {
    const me = this;
    dateField.ion({
      change({ userAction, value }) {
        if (userAction && !me.$isInternalChange) {
          me._isUserAction = true;
          me.timeField.value = value;
          me.value = value;
          me._isUserAction = false;
        }
      },
      thisObj: me
    });
  }
  updateWeekStartDay(weekStartDay) {
    if (this.dateField) {
      this.dateField.weekStartDay = weekStartDay;
    }
  }
  changeWeekStartDay(value) {
    var _a2, _b;
    return typeof value === "number" ? value : (_b = (_a2 = this.dateField) == null ? void 0 : _a2.weekStartDay) != null ? _b : DateHelper.weekStartDay;
  }
  // Apply our value to our underlying fields
  syncInputFieldValue(skipHighlight = this.isConfiguring) {
    super.syncInputFieldValue(true);
    const me = this, { dateField, timeField } = me, highlightDate = dateField.highlightExternalChange, highlightTime = timeField.highlightExternalChange;
    if (!skipHighlight && !me.highlightExternalChange) {
      skipHighlight = true;
    }
    me.$isInternalChange = true;
    dateField.highlightExternalChange = false;
    dateField.highlightExternalChange = highlightDate;
    if (skipHighlight) {
      timeField.highlightExternalChange = dateField.highlightExternalChange = false;
    }
    timeField.value = dateField.value = me.inputValue;
    dateField.highlightExternalChange = highlightDate;
    timeField.highlightExternalChange = highlightTime;
    me.$isInternalChange = false;
    me.syncInvalid();
  }
  onTimeFieldKeyDown(e) {
    const me = this;
    if (e.key === "Enter" || e.key === "Tab") {
      const dateAndTime = me.dateField.value;
      me._isUserAction = true;
      me.value = dateAndTime ? DateHelper.copyTimeValues(new Date(dateAndTime), me.timeField.value || midnightDate) : null;
      me._isUserAction = false;
    }
  }
  onDateFieldKeyDown(e) {
    const me = this;
    if (e.key === "Tab" && !e.shiftKey) {
      e.stopPropagation();
      e.preventDefault();
      me.timeField.focus();
    } else if (e.key === "Enter") {
      me.value = me.dateField.value;
    }
  }
  // Make us and our underlying fields required
  updateRequired(required, was) {
    this.timeField.required = this.dateField.required = required;
  }
  updateReadOnly(readOnly, was) {
    super.updateReadOnly(readOnly, was);
    if (!this.isConfiguring) {
      this.timeField.readOnly = this.dateField.readOnly = readOnly;
    }
  }
  // Make us and our underlying fields disabled
  onDisabled(value) {
    this.timeField.disabled = this.dateField.disabled = value;
  }
  focus() {
    this.dateField.focus();
  }
  hasChanged(oldValue, newValue) {
    return !DateHelper.isEqual(oldValue, newValue);
  }
  get isValid() {
    return this.timeField.isValid && this.dateField.isValid;
  }
  setError(error, silent) {
    [this.dateField, this.timeField].forEach((f) => f.setError(error, silent));
  }
  getErrors() {
    const errors = [...this.dateField.getErrors() || [], ...this.timeField.getErrors() || []];
    return errors.length ? errors : null;
  }
  clearError(error, silent) {
    [this.dateField, this.timeField].forEach((f) => f.clearError(error, silent));
  }
  updateInvalid() {
    this.updatingInvalid = true;
    [this.dateField, this.timeField].forEach((f) => f.updateInvalid());
    this.updatingInvalid = false;
  }
};
__publicField(DateTimeField, "$name", "DateTimeField");
__publicField(DateTimeField, "type", "datetimefield");
__publicField(DateTimeField, "alias", "datetime");
__publicField(DateTimeField, "configurable", {
  /**
   * Returns the TimeField instance
   * @readonly
   * @member {Core.widget.TimeField} timeField
   */
  /**
   * Configuration for the {@link Core.widget.TimeField}
   * @config {TimeFieldConfig}
   */
  timeField: {},
  /**
   * Returns the DateField instance
   * @readonly
   * @member {Core.widget.DateField} dateField
   */
  /**
   * Configuration for the {@link Core.widget.DateField}
   * @config {DateFieldConfig}
   */
  dateField: {
    // To be able to use transformDateValue for parsing without loosing time, a bit of a hack
    keepTime: true,
    step: "1 d"
  },
  /**
   * The week start day in the {@link Core.widget.DateField#config-picker}, 0 meaning Sunday, 6 meaning Saturday.
   * Uses localized value per default.
   *
   * @config {Number}
   */
  weekStartDay: null,
  inputTemplate: () => "",
  ariaElement: "element"
});
DateTimeField.initClass();
DateTimeField._$name = "DateTimeField";

// ../Core/lib/Core/widget/DurationField.js
var DurationField = class extends TextField {
  static get defaultConfig() {
    return {
      /**
       * The `value` config may be set in Object form specifying two properties,
       * `magnitude`, a Number, and `unit`, a String.
       *
       * If a String is passed, it is parsed in accordance with current locale rules.
       * The string is taken to be the numeric magnitude, followed by whitespace, then an abbreviation, or name of
       * the unit.
       * @config {DurationConfig|String}
       * @category Common
       */
      value: null,
      /**
       * Step size for spin button clicks.
       * @config {Number}
       * @default
       * @category Common
       */
      step: 1,
      /**
       * The duration unit to use with the current magnitude value.
       * @config {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}
       * @category Common
       */
      unit: null,
      defaultUnit: "day",
      /**
       * The duration magnitude to use with the current unit value. Can be either an integer or a float value.
       * Both "," and "." are valid decimal separators.
       * @config {Number}
       * @category Common
       */
      magnitude: null,
      /**
       * When set to `true` the field will use short names of unit durations
       * (as returned by {@link Core.helper.DateHelper#function-getShortNameOfUnit-static}) when creating the
       * input field's display value.
       * @config {Boolean}
       * @category Common
       */
      useAbbreviation: false,
      /**
       * Set to `true` to allow negative duration
       * @config {Boolean}
       * @category Common
       */
      allowNegative: false,
      /**
       * The number of decimal places to allow. Defaults to no constraint.
       * @config {Number}
       * @default
       * @category Common
       */
      decimalPrecision: null,
      triggers: {
        spin: {
          type: "spintrigger"
        }
      },
      nullValue: null
    };
  }
  /**
   * Fired when this field's value changes.
   * @event change
   * @param {Core.data.Duration} value - This field's value
   * @param {Core.data.Duration} oldValue - This field's previous value
   * @param {Boolean} valid - True if this field is in a valid state.
   * @param {Event} [event] - The triggering DOM event if any.
   * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
   * @param {Core.widget.DurationField} source - This field
   */
  /**
   * User performed default action (typed into this field or hit the triggers).
   * @event action
   * @param {Core.data.Duration} value - This field's value
   * @param {Core.data.Duration} oldValue - This field's previous value
   * @param {Boolean} valid - True if this field is in a valid state.
   * @param {Event} [event] - The triggering DOM event if any.
   * @param {Boolean} userAction - Triggered by user taking an action (`true`) or by setting a value (`false`)
   * @param {Core.widget.DurationField} source - This field
   */
  static get configurable() {
    return {
      /**
       * Get/set the min value (e.g. 1d)
       * @member {String} min
       * @category Common
       */
      /**
       * Minimum duration value (e.g. 1d)
       * @config {String}
       * @category Common
       */
      min: null,
      /**
       * Get/set the max value
       * @member {String} max (e.g. 10d)
       * @category Common
       */
      /**
       * Max duration value (e.g. 10d)
       * @config {String}
       * @category Common
       */
      max: null,
      /**
       * Get/set the allowed units, e.g. "day,hour,year".
       * @member {String} allowedUnits
       * @category Common
       */
      /**
       * Comma-separated list of units to allow in this field, e.g. "day,hour,year". Leave blank to allow all
       * valid units (the default)
       * @config {String}
       * @category Common
       */
      allowedUnits: null
    };
  }
  changeMin(value) {
    return typeof value === "string" ? new Duration(value) : value;
  }
  changeMax(value) {
    return typeof value === "string" ? new Duration(value) : value;
  }
  changeAllowedUnits(units) {
    if (typeof units === "string") {
      units = units.split(",");
    }
    if (units.length > 0 && !units.includes(this.defaultUnit)) {
      this.defaultUnit = units[0];
    }
    return units;
  }
  updateAllowedUnits(units) {
    this.allowedUnitsRe = new RegExp(`(${units.join("|")})`, "i");
  }
  get inputValue() {
    return this.value == null ? "" : this.calcValue(true).toString(this.useAbbreviation);
  }
  /**
   * Get/Set duration unit to use with the current magnitude value.
   * Valid values are:
   * - "millisecond" - Milliseconds
   * - "second" - Seconds
   * - "minute" - Minutes
   * - "hour" - Hours
   * - "day" - Days
   * - "week" - Weeks
   * - "month" - Months
   * - "quarter" - Quarters
   * - "year"- Years
   *
   * @property {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}
   * @category Common
   */
  set unit(unit) {
    this._unit = unit;
    this.value = this.calcValue();
  }
  get unit() {
    return this._unit;
  }
  get unitWithDefault() {
    return this._unit || this.defaultUnit;
  }
  /**
   * Get/Set numeric magnitude `value` to use with the current unit value.
   * @property {Number}
   * @category Common
   */
  set magnitude(magnitude) {
    this.clearError("L{invalidUnit}");
    this._magnitude = magnitude;
    super.value = this.calcValue();
  }
  get magnitude() {
    return this._magnitude;
  }
  roundMagnitude(value) {
    return value && this.decimalPrecision != null ? ObjectHelper.round(value, this.decimalPrecision) : value;
  }
  get allowDecimals() {
    return this.decimalPrecision !== 0;
  }
  get isValid() {
    const me = this, isEmpty = me.value == null || me.value && me.value.magnitude == null;
    return super.isValid && (isEmpty && !me.required || !isEmpty && (me.allowNegative || me.value.magnitude >= 0));
  }
  internalOnChange(event) {
    const me = this, value = me.value, oldVal = me._lastValue;
    if (me.hasChanged(oldVal, value)) {
      me._lastValue = value;
      me.triggerFieldChange({ value, event, userAction: true, valid: me.isValid });
    }
  }
  onFocusOut(e) {
    var _a2, _b, _c;
    this.syncInputFieldValue(true);
    (_c = (_b = (_a2 = this.triggers) == null ? void 0 : _a2.spin) == null ? void 0 : _b.clickRepeater) == null ? void 0 : _c.cancel();
    return super.onFocusOut(e);
  }
  /**
   * The `value` property may be set in Object form specifying two properties, `magnitude`, a Number, and `unit`, a
   * String.
   *
   * If a Number is passed, the field's current unit is used and just the magnitude is changed.
   *
   * If a String is passed, it is parsed in accordance with current locale rules. The string is taken to be the
   * numeric magnitude, followed by whitespace, then an abbreviation, or name of the unit.
   *
   * Upon read, the value is always a {@link Core.data.Duration} object containing `magnitude` and `unit`.
   *
   * @property {Core.data.Duration}
   * @accepts {String|Number|DurationConfig|Core.data.Duration}
   * @category Common
   */
  set value(value) {
    const me = this;
    let newMagnitude, newUnit;
    me.getConfig("allowedUnits");
    me.clearError("L{invalidUnit}");
    if (typeof value === "number" || typeof value === "string" && value.length > 0 && !isNaN(value)) {
      newMagnitude = Number(value);
      newUnit = me.unitWithDefault;
    } else if (typeof value === "string") {
      if (/^\s*$/.test(value)) {
        newMagnitude = null;
      } else {
        const parsedDuration = DateHelper.parseDuration(value, me.allowDecimals, me.unitWithDefault);
        if (parsedDuration) {
          if (!me.allowedUnitsRe || me.allowedUnitsRe.test(parsedDuration.unit)) {
            newUnit = parsedDuration.unit;
            newMagnitude = parsedDuration.magnitude;
          } else {
            me.setError("L{invalidUnit}");
          }
        }
      }
    } else {
      if (value && "unit" in value && "magnitude" in value) {
        newUnit = value.unit;
        newMagnitude = value.magnitude;
      } else {
        newUnit = null;
        newMagnitude = null;
      }
    }
    if (me._magnitude !== newMagnitude || me._unit != newUnit) {
      me._magnitude = newMagnitude;
      if (newUnit) {
        me._unit = newUnit;
      }
      super.value = me.calcValue();
    }
  }
  okMax(value) {
    if (typeof value === "number") {
      value = new Duration({
        unit: this.unitWithDefault,
        magnitude: value
      });
    }
    return this.max == null || value <= this.max;
  }
  okMin(value) {
    if (typeof value === "number") {
      value = new Duration({
        unit: this.unitWithDefault,
        magnitude: value
      });
    }
    return this.min == null || value >= this.min;
  }
  get validity() {
    const value = this.value, validity = {};
    if (value != null) {
      validity.rangeUnderflow = !this.okMin(value);
      validity.rangeOverflow = !this.okMax(value);
    }
    validity.valid = !validity.rangeUnderflow && !validity.rangeOverflow;
    return validity;
  }
  get value() {
    return super.value;
  }
  calcValue(round2 = false) {
    const me = this;
    if ((!me._unit || me._magnitude == null) && me.clearable) {
      return null;
    } else {
      return new Duration(round2 ? this.roundMagnitude(me._magnitude) : this._magnitude, me.unitWithDefault);
    }
  }
  hasChanged(oldValue, newValue) {
    return newValue && !oldValue || !newValue && oldValue || newValue && oldValue && !oldValue.isEqual(newValue);
  }
  /**
   * The `milliseconds` property is a read only property which returns the number of milliseconds in this field's
   * value
   * @member {Number} milliseconds
   * @readonly
   */
  get milliseconds() {
    return this.value ? this.value.milliseconds : 0;
  }
  onInternalKeyDown(keyEvent) {
    if (keyEvent.key === "ArrowUp") {
      this.doSpinUp();
    } else if (keyEvent.key === "ArrowDown") {
      this.doSpinDown();
    }
  }
  doSpinUp() {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.magnitude || 0) + me.step;
    me._isUserAction = true;
    if (!me.okMin(newValue)) {
      newValue = me.min;
    }
    if (me.okMax(newValue)) {
      me.value = newValue;
    }
    me._isUserAction = false;
  }
  doSpinDown() {
    const me = this;
    if (me.readOnly) {
      return;
    }
    let newValue = (me.magnitude || 0) - me.step;
    if (!me.okMax(newValue)) {
      newValue = me.max;
    }
    if (me.okMin(newValue) && (me.allowNegative || (me.magnitude || 0) > 0)) {
      me._isUserAction = true;
      me.value = newValue;
      me._isUserAction = false;
    }
  }
};
__publicField(DurationField, "$name", "DurationField");
__publicField(DurationField, "type", "durationfield");
__publicField(DurationField, "alias", "duration");
DurationField.initClass();
DurationField._$name = "DurationField";

// ../Core/lib/Core/widget/layout/Fit.js
var Fit = class extends Layout {
};
__publicField(Fit, "$name", "Fit");
__publicField(Fit, "type", "fit");
__publicField(Fit, "configurable", {
  containerCls: "b-fit-container",
  itemCls: "b-fit-item"
});
Fit.initClass();
Fit._$name = "Fit";

// ../Core/lib/Core/widget/Editor.js
var Editor = class extends Container {
  //endregion
  //region Events
  /**
   * Fired before the editor is shown to start an edit operation. Returning `false` from a handler vetoes the edit operation.
   * @event beforeStart
   * @param {HTMLElement} target The element which the Editor is to overlay to edit its content.
   * @param {Core.data.Model} [record] The record being edited.
   * @param {String} [field] The name of the field if a record is being edited.
   * @param {Object} value - The value to be edited.
   * @param {String|AlignSpec} align - How to align the editor.
   * @param {Boolean} hideTarget `true` if the target is to be hidden during the edit.
   * @param {Boolean|Object} matchSize Whether to match the target size. See {@link #config-matchSize}
   * @param {Boolean} matchSize.width Match width
   * @param {Boolean} matchSize.height Match height
   * @param {Boolean} matchFont Whether to match the target's font. See {@link #config-matchFont}
   * @param {Boolean} focus Whether to focus the editor's field.
   * @preventable
   */
  /**
   * Fired when an edit operation has begun.
   * @event start
   * @param {Object} value - The starting value of the field.
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fired when an edit completion has been requested, either by `ENTER`, or focus loss (if configured to complete on blur).
   * The completion may be vetoed, in which case, focus is moved back into the editor.
   * @event beforeComplete
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The new value.
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   * @param {Function} [finalize] An async function may be injected into this property
   * which performs asynchronous finalization tasks such as complex validation of confirmation. The
   * value `true` or `false` must be returned.
   * @param {Object} [finalize.context] An object describing the editing context upon requested completion of the edit.
   * @preventable
   */
  /**
   * Edit has been completed, and any associated record or element has been updated.
   * @event complete
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The new value.
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fired when cancellation has been requested, either by `ESC`, or focus loss (if configured to cancel on blur).
   * The cancellation may be vetoed, in which case, focus is moved back into the editor.
   * @event beforeCancel
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The new value.
   * @param {Event} event - Included if the cancellation was triggered by a DOM event
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   * @preventable
   */
  /**
   * Edit has been canceled without updating the associated record or element.
   * @event cancel
   * @param {Object} oldValue - The original value.
   * @param {Object} value - The value of the field.
   * @param {Event} event - Included if the cancellation was triggered by a DOM event
   * @param {Core.widget.Editor} source - The Editor that triggered the event.
   */
  /**
   * Fire to relay a `keypress` event from the field.
   * @event keypress
   * @param {Event} event - The key event.
   */
  //endregion
  afterConfigure() {
    const me = this;
    super.afterConfigure();
    me.onTargetSizeChange = me.onTargetSizeChange.bind(me);
    EventHelper.on({
      element: me.element,
      keydown: "onKeyDown",
      contextmenu: "stopMouseEvents",
      mousedown: "stopMouseEvents",
      mouseover: "stopMouseEvents",
      mouseout: "stopMouseEvents",
      mouseup: "stopMouseEvents",
      click: "stopMouseEvents",
      dblclick: "stopMouseEvents",
      thisObj: me
    });
    me.ion({
      beforeHide: "beforeEditorHide",
      hide: "afterEditorHide",
      thisObj: me
    });
    LocaleManager_default.ion({
      locale: "onLocaleChange",
      thisObj: me
    });
  }
  onLocaleChange() {
    const { inputField } = this;
    if (inputField && !inputField.isDestroyed) {
      if (inputField.syncInputFieldValue) {
        inputField.syncInputFieldValue(true);
      } else if (!(inputField instanceof Field)) {
      }
    }
  }
  render(renderTo) {
    const oldParent = this.element.parentNode, [parentElement] = this.getRenderContext(this, renderTo);
    parentElement.classList.add("b-editing");
    super.render(...arguments);
    if ((oldParent == null ? void 0 : oldParent.classList) && parentElement !== oldParent) {
      oldParent.classList.remove("b-editing");
    }
  }
  /**
   * Start editing
   * @param {Object} editObject An object containing details about what to edit.
   * @param {HTMLElement|Core.helper.util.Rectangle} editObject.target the element or Rectangle to align to.
   * @param {String} [editObject.align=t0-t0] How to align to the target.
   * @param {Boolean} [editObject.matchSize=true] Match editor size to target size.
   * @param {Boolean} [editObject.matchFont=true] Match editor's font-size size to target's font-size.
   * @param {Core.data.Model} [editObject.record] The record to edit.
   * @param {String} [editObject.field] The field name in the record to edit. This defaults to the `name` of the
   * {@link #config-inputField}. Also if record has method set + capitalized field, method will be called, e.g. if
   * record has method named `setFoobar` and this config is `foobar`, then instead of `record.foobar = value`,
   * `record.setFoobar(value)` will be called.
   * @param {Object} [editObject.value] The value to edit.
   * @param {Boolean} [editObject.focus=true] Focus the field.
   * @param {Boolean} [editObject.fitTargetContent] Pass `true` to allow the Editor to expand beyond the width of its
   * target element if its content overflows horizontally. This is useful if the editor has triggers to display, such
   * as a combo.
   * @returns {Promise} Resolved promise returns`true` if editing has been started, `false` if an
   * {@link #event-beforeStart} listener has vetoed the edit.
   */
  async startEdit(editObject) {
    var _a2, _b, _c;
    const me = this;
    editObject = ObjectHelper.assignIf(editObject, {
      align: me.align,
      hideTarget: me.hideTarget,
      matchSize: me.matchSize,
      matchFont: me.matchFont,
      fitTargetContent: me.fitTargetContent,
      focus: true
    });
    if (me.trigger("beforeStart", editObject) !== false) {
      const {
        target,
        hideTarget,
        matchSize,
        matchFont,
        fitTargetContent,
        record,
        field = me.inputField.name,
        focus
      } = editObject, { inputField } = me, { input } = inputField, targetFontSize = DomHelper.getStyleValue(target, "font-size"), targetFontFamily = DomHelper.getStyleValue(target, "font-family");
      let { value, align } = editObject;
      if (record && field) {
        me.record = record;
        me.dataField = field;
        if (value === void 0) {
          value = record.getValue(field);
        }
      }
      if (matchSize) {
        if (target instanceof HTMLElement) {
          me.updateSize(target, matchSize);
        }
        if (target instanceof HTMLElement) {
          ResizeMonitor.addResizeListener(target, me.onTargetSizeChange);
        }
      }
      if (input) {
        if (matchFont) {
          input.style.fontSize = targetFontSize;
          input.style.fontFamily = targetFontFamily;
        } else {
          input.style.fontSize = input.style.fontFamily = "";
        }
      }
      me.assigningValues = true;
      (_a2 = inputField.clearError) == null ? void 0 : _a2.call(inputField);
      if ("setValue" in inputField) {
        await inputField.setValue(value);
      } else {
        inputField.value = value;
      }
      me.assigningValues = false;
      if (typeof align === "string") {
        align = { align };
      }
      await me.showBy({
        target,
        allowTargetOut: true,
        ...align
      });
      if (fitTargetContent) {
        const overflow = input.scrollWidth - input.clientWidth;
        if (overflow > 0) {
          me.width += overflow + DomHelper.scrollBarWidth;
        }
      }
      focus && ((_b = inputField.focus) == null ? void 0 : _b.call(inputField));
      if (target.nodeType === Element.ELEMENT_NODE) {
        if (hideTarget) {
          target.classList.add("b-hide-visibility");
        }
      }
      me.editing = true;
      const convertedValue = inputField.value;
      me.trigger("start", { value: convertedValue });
      if (Array.isArray(convertedValue) && inputField.editingRecords && ((_c = convertedValue[0]) == null ? void 0 : _c.isModel)) {
        me.oldValue = convertedValue.map((record2) => record2.copy(record2.id));
      } else {
        me.oldValue = convertedValue;
        if (Array.isArray(me.oldValue)) {
          me.oldValue = me.oldValue.slice();
        }
      }
      inputField.initialValue = me.oldValue;
      return true;
    }
    return false;
  }
  async refreshEdit() {
    if (this.isVisible) {
      const { record, dataField, inputField } = this;
      if (record && dataField) {
        const value = record.getValue(dataField);
        if (!ObjectHelper.isEqual(inputField.value, value)) {
          await inputField.setValue(value);
        }
      }
    }
  }
  finishEdit() {
    const { target, aligningToElement } = this.lastAlignSpec;
    if (aligningToElement) {
      target.classList.remove("b-editing");
      target.classList.remove("b-hide-visibility");
    }
    this.editing = false;
    this.trigger("finishEdit");
  }
  onKeyDown(event) {
    var _a2;
    const me = this;
    switch (event.key) {
      case me.completeKey:
        me.completeEdit(null, event);
        event.stopImmediatePropagation();
        break;
      case me.cancelKey:
        me.cancelEdit(event);
        event.stopImmediatePropagation();
        break;
    }
    (_a2 = me.trigger) == null ? void 0 : _a2.call(me, "keydown", { event });
  }
  stopMouseEvents(e) {
    if (!this.allowMouseEvents) {
      e.stopPropagation();
    }
  }
  onFocusOut(event) {
    super.onFocusOut(event);
    const me = this;
    if (!me.isFinishing && me.editing) {
      switch (me.blurAction) {
        case "cancel":
          me.cancelEdit(event);
          break;
        case "complete":
          me.completeEdit(null, event);
      }
    }
  }
  /**
   * Complete the edit, and, if associated with a record, update the record if possible.
   * If editing is completed, the editor is hidden.
   *
   * If the field is invalid, the `{@link #config-invalidAction}` config is used to decide
   * upon the course of action.
   *
   * If a {@link #event-beforeComplete} handler returns `false` then editing is not completed.
   *
   * If the field's values has not been changed, then editing is terminated through {@link #function-cancelEdit}.
   *
   * @returns {Boolean} `true` if editing ceased, `false` if the editor is still active.
   */
  async completeEdit(finalize, triggeredByEvent) {
    var _a2, _b, _c, _d;
    const me = this, { inputField, oldValue, record } = me, invalidAction = inputField.invalidAction || (inputField.allowInvalid === false ? "block" : me.invalidAction), { value } = inputField;
    if (!me.isVisible) {
      return;
    }
    if (!inputField.isValid && invalidAction !== "allow") {
      if (invalidAction === "block") {
        (_a2 = inputField.focus) == null ? void 0 : _a2.call(inputField);
        return false;
      } else if (invalidAction === "revert") {
        return me.cancelEdit(triggeredByEvent) !== false;
      }
    } else if (ObjectHelper.isEqual(value, oldValue)) {
      return me.cancelEdit(triggeredByEvent) !== false;
    } else {
      const context = { inputField, record, value, oldValue };
      if (me.trigger("beforeComplete", context) === false) {
        (_b = inputField.focus) == null ? void 0 : _b.call(inputField);
      } else {
        if (!finalize) {
          finalize = context.finalize || ((_c = context.editorContext) == null ? void 0 : _c.finalize);
        }
        if (finalize) {
          let result = await finalize(context);
          if (result === true) {
            me.onEditComplete();
          } else {
            if (inputField.setError) {
              const error = result || inputField.invalidValueError, clearError = () => {
                listeners();
                inputField.clearError(error);
              }, listeners = inputField.ion({
                change: clearError,
                input: clearError
              });
              inputField.setError(error);
            }
            if (invalidAction === "block") {
              (_d = inputField.focus) == null ? void 0 : _d.call(inputField);
            } else if (invalidAction === "revert") {
              await inputField.setValue(oldValue);
              result = true;
            }
            result = false;
          }
          return result;
        } else {
          me.onEditComplete();
          return true;
        }
      }
    }
    return false;
  }
  /**
   * Cancel the edit and hide the editor.
   */
  cancelEdit(triggeredByEvent) {
    var _a2;
    const me = this, { inputField, oldValue } = me, { value } = inputField;
    if (me.editing && !me.isFinishing && me.trigger("beforeCancel", { value, oldValue, event: triggeredByEvent }) !== false) {
      (_a2 = inputField.clearError) == null ? void 0 : _a2.call(inputField);
      me.isFinishing = true;
      me.hide();
      me.trigger("cancel", { value, oldValue, event: triggeredByEvent });
      me.finishEdit();
      me.isFinishing = false;
    } else {
      return false;
    }
  }
  // Handle updating what needs to be updated.
  onEditComplete() {
    const me = this, { record, dataField, inputField, oldValue } = me, { value } = inputField;
    if (!me.isFinishing) {
      me.isFinishing = true;
      me.hide();
      if (record) {
        const setterName = `set${StringHelper.capitalize(dataField)}`;
        if (record[setterName]) {
          record[setterName](value);
        } else {
          record.setValue(dataField, value);
        }
      }
      me.trigger("complete", { value, oldValue });
      me.finishEdit();
      me.isFinishing = false;
    }
  }
  doDestroy() {
    if (this.createdInputField) {
      this.inputField.destroy();
    }
    super.doDestroy();
  }
  set owner(owner) {
    this._owner = owner;
  }
  // This is a positioned widget appended to a Widget's contentElement. It may have no owner link.
  // Grab the owner by finding what widget it is inside.
  get owner() {
    return this._owner || Widget.fromElement(this.element.parentNode);
  }
  changeInputField(inputField, oldInputField) {
    const me = this;
    if (oldInputField) {
      oldInputField.destroy();
    }
    if (typeof inputField === "string") {
      inputField = {
        type: inputField
      };
    }
    if (!(inputField instanceof Widget)) {
      inputField = Widget.create(inputField);
      me.createdInputField = true;
    }
    if (me.completeOnChange) {
      inputField.ion({
        change: "onInputFieldChange",
        thisObj: me
      });
    }
    inputField.parent = me;
    return inputField;
  }
  updateInputField(inputField) {
    this.removeAll();
    this.add(inputField);
  }
  get inputField() {
    return this.items[0];
  }
  onInputFieldChange() {
    if (this.containsFocus) {
      this.completeEdit();
    }
  }
  onTargetSizeChange(resizedElement, oldRect, newRect) {
    if (oldRect && newRect) {
      this.updateSize(resizedElement);
    }
  }
  updateSize(targetEl, matchSize = this.lastMatchSize) {
    const me = this, rect = Rectangle.inner(targetEl);
    me.width = matchSize.width === false ? "auto" : rect.width - me.align.offset[0];
    me.height = matchSize.height === false ? "auto" : rect.height;
    me.lastMatchSize = matchSize;
  }
  beforeEditorHide() {
    if (this.editing && !this.isFinishing) {
      this.cancelEdit();
      return false;
    }
  }
  afterEditorHide() {
    if (this.positioned) {
      this.element.remove();
    }
    ResizeMonitor.removeResizeListener(this.lastAlignSpec.target, this.onTargetSizeChange);
  }
};
//region Config
__publicField(Editor, "$name", "Editor");
__publicField(Editor, "type", "editor");
__publicField(Editor, "configurable", {
  positioned: true,
  hidden: true,
  layout: "fit",
  /**
   * The alignment config for how this editor aligns to a target when asked to {@link #function-startEdit}
   * @config {AlignSpec}
   * @default
   */
  align: {
    align: "t0-t0",
    offset: [0, 0]
  },
  /**
   * Controls whether to hide the target element when asked to {@link #function-startEdit}
   * @config {Boolean}
   * @default
   */
  hideTarget: false,
  /**
   * By default, an Editor matches both dimensions, width and height of the element it is targeted at in the
   * {@link #function-startEdit} function.
   *
   * Configure this as false to allow the editor's configured dimensions, or its CSS-imposed dimensions size it.
   *
   * This may also operate with more granularity by specifying both dimensions in an object:
   *
   * ```javascript
   *     // Editor can exceed its target's height
   *     matchSize : {
   *         width  : true,
   *         height : false
   *     }
   * ```
   * @config {Boolean|Object}
   * @property {Boolean} width `true` to match width
   * @property {Boolean} height `true`to match height
   * @default
   */
  matchSize: true,
  /**
   * Controls whether the editor should match target element's font when asked to {@link #function-startEdit}
   * @config {Boolean}
   * @default
   */
  matchFont: true,
  /**
   * Controls whether the editor should expand its width if the input field has overflow {@link #function-startEdit}
   * @config {Boolean}
   * @default
   */
  fitTargetContent: false,
  /**
   * A config object, or the `type` string of the widget (usually a {@link Core.widget.Field} subclass,
   * i.e. {@link Core.widget.TextField}) which this editor will encapsulate.
   * @prp {Core.widget.Widget}
   * @accepts {InputFieldConfig|String}
   * @default
   */
  inputField: "textfield",
  /**
   * What action should be taken when focus moves out of the editor, either by `TAB` or clicking outside.
   * May be `'complete'` or `'cancel`'. Any other value results in no action being taken upon focus leaving the editor
   * leaving the application to listen for the {@link #event-focusOut focusOut} event.
   * @config {'complete'|'cancel'|null}
   * @default
   */
  blurAction: "complete",
  /**
   * The name of the `key` which completes the edit.
   *
   * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for key names.
   * @config {String}
   * @default
   */
  completeKey: "Enter",
  /**
   * The name of the `key` which cancels the edit.
   *
   * See https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key/Key_Values for key names.
   * @config {String}
   * @default
   */
  cancelKey: "Escape",
  /**
   * How to handle a request to complete the edit if the field is invalid. There are three choices:
   *  - `block` The default. The edit is not exited, the field remains focused.
   *  - `allow` Allow the edit to be completed.
   *  - `revert` The field value is reverted and the edit is completed.
   * @config {'block'|'allow'|'revert'}
   * @default
   */
  invalidAction: "block",
  /**
   * Configure as `true` to have editing complete as soon as the field fires its `change` event.
   * @config {Boolean}
   * @default false
   */
  completeOnChange: null,
  isolateFields: true
});
Editor.initClass();
Editor._$name = "Editor";

// ../Core/lib/Core/widget/FieldFilterPicker.js
var filterableFieldDataTypes = {
  number: true,
  boolean: true,
  string: true,
  date: true,
  duration: true,
  time: true,
  auto: true
};
var isInferrableType = {
  number: true,
  boolean: true,
  string: true
};
var isSupportedDurationField = (field) => {
  var _a2;
  return ((_a2 = field == null ? void 0 : field.column) == null ? void 0 : _a2.type) === "duration";
};
var emptyString = "";
var clsBase = `b-fieldfilterpicker`;
var multiValueOperators = {
  between: true,
  notBetween: true,
  isIncludedIn: true,
  isNotIncludedIn: true
};
var valueInputTypes = {
  textfield: true,
  datefield: true,
  numberfield: true,
  durationfield: true,
  combo: true,
  timefield: true
};
var commonOperators = {
  empty: { value: "empty", text: "L{isEmpty}", argCount: 0 },
  notEmpty: { value: "notEmpty", text: "L{isNotEmpty}", argCount: 0 },
  "=": { value: "=", text: "L{equals}" },
  "!=": { value: "!=", text: "L{doesNotEqual}" },
  ">": { value: ">", text: "L{isGreaterThan}" },
  "<": { value: "<", text: "L{isLessThan}" },
  ">=": { value: ">=", text: "L{isGreaterThanOrEqualTo}" },
  "<=": { value: "<=", text: "L{isLessThanOrEqualTo}" },
  between: { value: "between", text: "L{isBetween}", argCount: 2 },
  notBetween: { value: "notBetween", text: "L{isNotBetween}", argCount: 2 },
  isIncludedIn: { value: "isIncludedIn", text: "L{isOneOf}", isArrayValued: true },
  isNotIncludedIn: { value: "isNotIncludedIn", text: "L{isNotOneOf}", isArrayValued: true }
};
var _FieldFilterPicker = class _FieldFilterPicker extends Container {
  static get defaultValueFieldPlaceholders() {
    return {
      string: "L{enterAValue}",
      number: "L{enterANumber}",
      date: "L{selectADate}",
      relation: "L{selectValue}",
      list: "L{selectOneOrMoreValues}",
      duration: "L{enterAValue}",
      time: "L{selectATime}",
      auto: "L{enterAValue}"
    };
  }
  afterConstruct() {
    const me = this;
    if (!me._fields) {
      throw new Error(`${_FieldFilterPicker.name} requires 'fields' to be configured.`);
    }
    if (!me._filter) {
      throw new Error(`${_FieldFilterPicker.name} requires 'filter' to be configured.`);
    }
    super.afterConstruct();
    const { widgetMap: { propertyPicker, operatorPicker, caseSensitive } } = me;
    propertyPicker.ion({ select: "onPropertySelect", thisObj: me });
    operatorPicker.ion({ select: "onOperatorSelect", thisObj: me });
    caseSensitive.ion({ change: "onCaseSensitiveChange", thisObj: me });
    me.propertyFieldConfig && propertyPicker.setConfig(me.propertyFieldConfig);
    me.operatorFieldConfig && operatorPicker.setConfig(me.operatorFieldConfig);
    propertyPicker.cls = me.allPropertyPickerClasses;
    operatorPicker.cls = me.allOperatorPickerClasses;
    me.populateUIFromFilter();
  }
  changeDateFormat(dateFormat) {
    return this.L(dateFormat);
  }
  get allChildInputs() {
    const { propertyPicker, operatorPicker, caseSensitive } = this.widgetMap;
    return [propertyPicker, operatorPicker, ...this.valueFields, caseSensitive];
  }
  updateDisabled(newDisabled) {
    this.allChildInputs.forEach((field) => field.disabled = newDisabled);
  }
  updateReadOnly(newReadOnly) {
    const { propertyPicker, operatorPicker } = this.widgetMap;
    this.allChildInputs.forEach((field) => field.readOnly = newReadOnly);
    propertyPicker.readOnly = propertyPicker.readOnly || newReadOnly;
    operatorPicker.readOnly = operatorPicker.readOnly || newReadOnly;
  }
  updatePropertyLocked(newPropertyLocked) {
    this.widgetMap.propertyPicker.readOnly = newPropertyLocked || this.readOnly;
    this.widgetMap.propertyPicker.cls = this.allPropertyPickerClasses;
  }
  updateOperatorLocked(newOperatorLocked) {
    this.widgetMap.operatorPicker.readOnly = newOperatorLocked || this.readOnly;
    this.widgetMap.operatorPicker.cls = this.allOperatorPickerClasses;
  }
  changeOperators(newOperators) {
    const operators = newOperators != null ? newOperators : _FieldFilterPicker.defaultOperators;
    return Object.keys(operators).reduce((outOperators, dataType) => ({
      ...outOperators,
      [dataType]: operators[dataType].map((op) => ({ ...op, text: this.L(op.text) }))
    }), {});
  }
  changeFields(newFields) {
    let fields = newFields;
    if (Array.isArray(newFields)) {
      VersionHelper.deprecate("Core", "6.0.0", "FieldOption[] deprecated, use Object<String, FieldOption> keyed by field name instead");
      fields = ArrayHelper.keyBy(fields, "name");
    }
    return fields;
  }
  get isMultiSelectValueField() {
    var _a2;
    return ["isIncludedIn", "isNotIncludedIn"].includes((_a2 = this._filter) == null ? void 0 : _a2.operator);
  }
  get allPropertyPickerClasses() {
    var _a2;
    return new DomClassList(`${clsBase}-property`, (_a2 = this.propertyFieldConfig) == null ? void 0 : _a2.cls, {
      [`${clsBase}-combo-locked`]: this.propertyLocked
    });
  }
  get allOperatorPickerClasses() {
    var _a2;
    return new DomClassList(`${clsBase}-operator`, (_a2 = this.operatorFieldConfig) == null ? void 0 : _a2.cls, {
      [`${clsBase}-combo-locked`]: this.operatorLocked
    });
  }
  getValueFieldConfigs() {
    const me = this, {
      valueFieldCls,
      fieldType,
      _filter: { operator },
      onValueChange,
      filterValues,
      isMultiSelectValueField,
      operatorArgCount,
      getValueFieldConfig,
      fieldIsRelation,
      triggerChangeOnInput
    } = me, valueFieldPlaceholders = ObjectHelper.merge(
      {},
      _FieldFilterPicker.defaultValueFieldPlaceholders,
      me.valueFieldPlaceholders
    );
    if (!fieldType || !operator || operatorArgCount === 0) {
      return [];
    }
    let valueFieldCfg = {
      type: "textfield",
      // replaced as needed below
      internalListeners: {
        change: onValueChange,
        input: triggerChangeOnInput ? onValueChange : null,
        thisObj: me
      },
      bubbleEvents: { keydown: true },
      cls: valueFieldCls,
      dataset: {
        type: fieldType
      },
      placeholder: me.L(valueFieldPlaceholders[isMultiSelectValueField ? "list" : fieldIsRelation ? "relation" : fieldType]),
      highlightExternalChange: false
    };
    if (isMultiSelectValueField || fieldIsRelation) {
      valueFieldCfg = {
        ...valueFieldCfg,
        type: "combo",
        multiSelect: isMultiSelectValueField,
        createOnUnmatched: true,
        items: me.getUniqueDataValues(filterValues),
        value: filterValues != null ? filterValues : []
      };
    } else if (["number", "date", "boolean", "duration", "time"].includes(fieldType)) {
      valueFieldCfg.type = `${fieldType}field`;
    }
    if (getValueFieldConfig) {
      valueFieldCfg = me.callback(getValueFieldConfig, me, [me.filter, valueFieldCfg]);
    }
    if (isMultiSelectValueField) {
      return [valueFieldCfg];
    }
    return ArrayHelper.populate(operatorArgCount, (index) => [{
      type: "widget",
      tag: "div",
      cls: `${clsBase}-value-separator`,
      content: me.L("L{FieldFilterPicker.and}")
    }, {
      ...valueFieldCfg,
      value: filterValues[index]
    }]).flat().slice(1);
  }
  /**
   * Return an array of unique values in the data store for the currently selected field. If no store is
   * configured or no field is selected, returns an empty array.
   */
  getUniqueDataValues(extraValuesToInclude = []) {
    var _a2;
    const me = this, { fieldType } = me;
    if (!me.store || !((_a2 = me._filter) == null ? void 0 : _a2.property)) {
      return [];
    }
    const { relatedDisplayField } = me.selectedField;
    let values, sortedValues;
    if (me.fieldIsRelation) {
      const { foreignStore } = me.currentPropertyRelationConfig;
      if (relatedDisplayField) {
        values = foreignStore.allRecords.reduce((options, record) => {
          if (record.id != null) {
            options.push({
              text: record.getValue(relatedDisplayField),
              value: record.id
            });
          }
          return options;
        }, []);
        sortedValues = values.sort((a, b) => me.sortStrings(a.text, b.text));
      } else {
        values = foreignStore.allRecords.map((record) => record.id);
      }
    } else {
      values = me.store.allRecords.map((record) => record.getValue(me._filter.property));
    }
    if (!sortedValues) {
      values.push(...extraValuesToInclude);
      const uniqueValues = ArrayHelper.unique(values.reduce((primitiveValues, value) => {
        if (value != null && String(value).trim() !== "") {
          if (fieldType === "date") {
            primitiveValues.push(value.valueOf());
          } else if (fieldType === "duration") {
            primitiveValues.push(value.toString());
          } else {
            primitiveValues.push(value);
          }
        }
        return primitiveValues;
      }, []));
      if (fieldType === "string") {
        sortedValues = uniqueValues.sort(me.sortStrings);
      } else if (fieldType === "duration") {
        sortedValues = uniqueValues.map((durationStr) => new Duration(durationStr)).filter((duration) => duration.isValid).sort(me.sortDurations);
      } else {
        sortedValues = uniqueValues.sort(me.sortNumerics);
      }
      if (fieldType === "date") {
        sortedValues = sortedValues.map((timestamp) => {
          const date = new Date(timestamp);
          return {
            text: DateHelper.format(date, me.dateFormat),
            value: timestamp
          };
        });
      } else if (fieldType === "duration") {
        sortedValues = sortedValues.map((duration) => duration.toString());
      }
    }
    return sortedValues;
  }
  sortStrings(a, b) {
    return (a != null ? a : emptyString).localeCompare(b != null ? b : emptyString);
  }
  sortNumerics(a, b) {
    return a - b;
  }
  sortDurations(a, b) {
    return a.valueOf() - b.valueOf();
  }
  get fieldType() {
    var _a2;
    return (_a2 = this.selectedField) == null ? void 0 : _a2.type;
  }
  get selectedField() {
    var _a2, _b;
    return (_b = this.fields) == null ? void 0 : _b[(_a2 = this._filter) == null ? void 0 : _a2.property];
  }
  get propertyOptions() {
    var _a2;
    return Object.entries((_a2 = this.fields) != null ? _a2 : {}).filter(
      ([, fieldDef]) => filterableFieldDataTypes[fieldDef.type] || isSupportedDurationField(fieldDef)
    ).map(([fieldName, { title }]) => ({ value: fieldName, text: title != null ? title : fieldName })).sort((a, b) => a.text.localeCompare(b.text));
  }
  get operatorOptions() {
    return this.operators[this.fieldIsRelation ? "relation" : this.fieldType];
  }
  get fieldIsRelation() {
    return Boolean(this.currentPropertyRelationConfig);
  }
  get currentPropertyRelationConfig() {
    var _a2, _b;
    return (_b = (_a2 = this.store) == null ? void 0 : _a2.modelRelations) == null ? void 0 : _b.find(({ foreignKey }) => {
      var _a3;
      return foreignKey === ((_a3 = this._filter) == null ? void 0 : _a3.property);
    });
  }
  updateOperators() {
    delete this._operatorArgCountLookup;
  }
  /**
   * @internal
   */
  get operatorArgCountLookup() {
    return this._operatorArgCountLookup || (this._operatorArgCountLookup = _FieldFilterPicker.buildOperatorArgCountLookup(this.operators));
  }
  updateFilter() {
    if (this._filter) {
      this.onFilterChange();
    }
  }
  updateStore(newStore) {
    var _a2;
    (_a2 = this._store) == null ? void 0 : _a2.un(this);
    newStore == null ? void 0 : newStore.ion({ refresh: "onStoreRefresh", thisObj: this });
    this.inferFieldTypes();
  }
  onStoreRefresh({ action }) {
    if (this.isMultiSelectValueField && ["dataset", "create", "update", "delete"].includes(action)) {
      this.valueFields[0].items = this.getUniqueDataValues(this.filterValues);
    }
  }
  refreshValueFields() {
    const me = this, { valueFields } = me.widgetMap, {
      fieldType,
      operatorArgCount,
      _filter: { property, operator }
    } = me, isMultiValue = multiValueOperators[operator];
    valueFields.element.className = new DomClassList({
      [`${clsBase}-values`]: true,
      [`${clsBase}-values-multiple`]: isMultiValue,
      [`${clsBase}-values-${fieldType}`]: fieldType !== void 0,
      "b-hidden": property == void 0 || operator == void 0 || operatorArgCount === 0
    });
    valueFields.removeAll();
    valueFields.add(me.getValueFieldConfigs());
    delete me._valueFields;
    me.refreshCaseSensitive();
  }
  refreshCaseSensitive() {
    var _a2, _b;
    const me = this, { fieldType, operatorArgCount, isMultiSelectValueField } = me, operator = (_a2 = me._filter) == null ? void 0 : _a2.operator, { caseSensitive } = me.widgetMap;
    caseSensitive.hidden = fieldType !== "string" || !operator || isMultiSelectValueField || operatorArgCount === 0;
    caseSensitive.checked = ((_b = me._filter) == null ? void 0 : _b.caseSensitive) !== false;
  }
  onPropertySelect(event) {
    var _a2;
    const me = this, { _filter } = me;
    _filter.property = ((_a2 = event.record) == null ? void 0 : _a2.data.value) || null;
    if (me.fieldType !== me._fieldType) {
      _filter.operator = null;
      _filter.value = null;
    }
    me._fieldType = _filter.type = me.fieldType;
    me.refreshOperatorPicker();
    me.refreshValueFields();
    me.triggerChange();
  }
  onCaseSensitiveChange({ checked }) {
    this._filter.caseSensitive = checked;
    this.triggerChange();
  }
  onOperatorSelect(event) {
    var _a2;
    const me = this, wasMultiSelectValueField = me.isMultiSelectValueField;
    const prevArgCount = this.operatorArgCount;
    me._filter.operator = ((_a2 = event.record) == null ? void 0 : _a2.data.value) || null;
    if (me.operatorArgCount !== prevArgCount) {
      me._filter.value = null;
    }
    if (me.isMultiSelectValueField && !wasMultiSelectValueField) {
      me._filter.value = [];
    }
    me.refreshValueFields();
    me.triggerChange();
  }
  triggerChange() {
    const { filter: filter2, isValid } = this;
    this.trigger("change", {
      filter: filter2,
      isValid
    });
  }
  onValueChange() {
    const me = this, { isMultiSelectValueField, fieldType, _filter } = me, values = this.valueFields.map((field) => field.value);
    if (isMultiSelectValueField && fieldType === "date") {
      _filter.value = values[0].map((timestamp) => new Date(timestamp));
    } else if (isMultiSelectValueField && fieldType === "duration") {
      _filter.value = values[0].map((durationStr) => new Duration(durationStr));
    } else {
      if (fieldType === "date" && _filter.operator === "between" && DateHelper.isValidDate(values[1])) {
        values[1].setHours(23, 59, 59, 999);
      }
      _filter.value = values.length === 1 ? values[0] : values;
    }
    me.triggerChange();
  }
  refreshOperatorPicker() {
    const { operatorPicker } = this.widgetMap, { _filter: { operator, property }, operatorOptions } = this;
    operatorPicker.items = operatorOptions;
    operatorPicker.value = operator;
    operatorPicker.hidden = property === null;
  }
  populateUIFromFilter(forceRefreshValueFields = false) {
    const me = this, {
      filterValues,
      widgetMap: { propertyPicker, operatorPicker },
      _filter: { property, operator, disabled },
      propertyOptions,
      operatorOptions,
      isMultiSelectValueField
    } = me;
    propertyPicker.items = propertyOptions;
    operatorPicker.items = operatorOptions;
    operatorPicker.hidden = property === null;
    let refreshValueFields = forceRefreshValueFields;
    if (propertyPicker.value !== property) {
      propertyPicker.value = property;
      me.refreshOperatorPicker();
      refreshValueFields = true;
    }
    if (operatorPicker.value !== operator) {
      if (operator === null || !operatorPicker.items.find(({ value }) => value === operator)) {
        operatorPicker.clear();
      } else {
        operatorPicker.value = operator;
      }
      refreshValueFields = true;
    }
    if (!operator && operatorPicker.items.length === 1) {
      operatorPicker.value = me._filter.operator = operatorPicker.items[0].value;
    }
    if (refreshValueFields) {
      me.refreshValueFields();
    }
    me.refreshCaseSensitive();
    me.valueFields.forEach((valueField, fieldIndex) => {
      if (isMultiSelectValueField && (valueField.value.length > 0 || filterValues.length > 0)) {
        if (me.fieldType === "date") {
          valueField.value = filterValues.map((date) => date == null ? void 0 : date.valueOf());
        } else if (me.fieldType === "duration") {
          valueField.value = filterValues.map((duration) => duration == null ? void 0 : duration.toString());
        } else {
          valueField.value = filterValues;
        }
      } else if (fieldIndex >= filterValues.length) {
        valueField.clear();
      } else {
        valueField.value = filterValues[fieldIndex];
      }
    });
    me.allChildInputs.forEach((widget) => widget.disabled = me.disabled || disabled);
  }
  get valueFields() {
    return this._valueFields || (this._valueFields = this.widgetMap.valueFields.queryAll(
      (w) => w.owner === this.widgetMap.valueFields && valueInputTypes[w.type]
    ));
  }
  get filterValues() {
    var _a2;
    if (((_a2 = this._filter) == null ? void 0 : _a2.value) == null) {
      return [];
    }
    return ArrayHelper.asArray(this._filter.value);
  }
  // Must be called manually when filter modified externally
  onFilterChange() {
    const me = this, newFieldType = me.fieldType, forceRefreshValueFields = newFieldType !== me._fieldType;
    me._fieldType = me._filter.type = newFieldType;
    me.populateUIFromFilter(forceRefreshValueFields);
  }
  get operatorArgCount() {
    const { fieldType, filter: { operator }, operatorArgCountLookup } = this;
    return fieldType && operator ? operatorArgCountLookup[fieldType][operator] : 1;
  }
  get isValid() {
    const me = this, { filter: filter2, fieldType, filterValues, isMultiSelectValueField, operatorArgCount } = me, { operator } = filter2, missingValue = operatorArgCount > 0 && (filter2 == null ? void 0 : filter2.value) == null;
    return (
      // fieldType here validates that we have a matching field
      fieldType && operator && !missingValue && (isMultiSelectValueField && filterValues.length > 0 || filterValues.length === operatorArgCount) && filterValues.every((value) => value != null && (fieldType !== "duration" || value.isValid))
    );
  }
  focus() {
    var _a2, _b, _c;
    (_c = (_b = (_a2 = this.valueFields.find((f) => f.isEmptyInput)) != null ? _a2 : this.operatorPicker) != null ? _b : this.propertyPicker) == null ? void 0 : _c.focus();
  }
  inferFieldTypes() {
    if (this.store && this.fields) {
      for (const [fieldName, fieldDef] of Object.entries(this.fields)) {
        if (fieldDef.type === "auto") {
          fieldDef.type = _FieldFilterPicker.inferFieldType(this.store, fieldName);
        }
      }
    }
  }
  static inferFieldType(store, fieldName) {
    var _a2;
    const firstValue = (_a2 = store.find((record) => record.getValue(fieldName) != null, true)) == null ? void 0 : _a2.getValue(fieldName);
    if (firstValue !== void 0) {
      const valueType = typeof firstValue;
      if (valueType === "object" && firstValue instanceof Date) {
        return "date";
      } else if (isInferrableType[valueType]) {
        return valueType;
      }
    }
    return "auto";
  }
};
//region Config
__publicField(_FieldFilterPicker, "$name", "FieldFilterPicker");
__publicField(_FieldFilterPicker, "type", "fieldfilterpicker");
__publicField(_FieldFilterPicker, "operators", {
  empty: { value: "empty", text: "L{isEmpty}", argCount: 0 },
  notEmpty: { value: "notEmpty", text: "L{isNotEmpty}", argCount: 0 },
  "=": { value: "=", text: "L{equals}" },
  "!=": { value: "!=", text: "L{doesNotEqual}" },
  ">": { value: ">", text: "L{isGreaterThan}" },
  "<": { value: "<", text: "L{isLessThan}" },
  ">=": { value: ">=", text: "L{isGreaterThanOrEqualTo}" },
  "<=": { value: "<=", text: "L{isLessThanOrEqualTo}" },
  between: { value: "between", text: "L{isBetween}", argCount: 2 },
  notBetween: { value: "notBetween", text: "L{isNotBetween}", argCount: 2 },
  isIncludedIn: { value: "isIncludedIn", text: "L{isOneOf}" },
  isNotIncludedIn: { value: "isNotIncludedIn", text: "L{isNotOneOf}" }
});
__publicField(_FieldFilterPicker, "defaultOperators", {
  string: [
    // In display order
    commonOperators.empty,
    commonOperators.notEmpty,
    commonOperators["="],
    commonOperators["!="],
    { value: "includes", text: "L{contains}" },
    { value: "doesNotInclude", text: "L{doesNotContain}" },
    { value: "startsWith", text: "L{startsWith}" },
    { value: "endsWith", text: "L{endsWith}" },
    commonOperators.isIncludedIn,
    commonOperators.isNotIncludedIn
  ],
  number: [
    commonOperators.empty,
    commonOperators.notEmpty,
    commonOperators["="],
    commonOperators["!="],
    commonOperators[">"],
    commonOperators["<"],
    commonOperators[">="],
    commonOperators["<="],
    commonOperators.between,
    commonOperators.notBetween,
    commonOperators.isIncludedIn,
    commonOperators.isNotIncludedIn
  ],
  date: [
    commonOperators.empty,
    commonOperators.notEmpty,
    commonOperators["="],
    commonOperators["!="],
    { value: "<", text: "L{isBefore}" },
    { value: ">", text: "L{isAfter}" },
    commonOperators.between,
    { value: "isToday", text: "L{isToday}", argCount: 0 },
    { value: "isTomorrow", text: "L{isTomorrow}", argCount: 0 },
    { value: "isYesterday", text: "L{isYesterday}", argCount: 0 },
    { value: "isThisWeek", text: "L{isThisWeek}", argCount: 0 },
    { value: "isNextWeek", text: "L{isNextWeek}", argCount: 0 },
    { value: "isLastWeek", text: "L{isLastWeek}", argCount: 0 },
    { value: "isThisMonth", text: "L{isThisMonth}", argCount: 0 },
    { value: "isNextMonth", text: "L{isNextMonth}", argCount: 0 },
    { value: "isLastMonth", text: "L{isLastMonth}", argCount: 0 },
    { value: "isThisYear", text: "L{isThisYear}", argCount: 0 },
    { value: "isNextYear", text: "L{isNextYear}", argCount: 0 },
    { value: "isLastYear", text: "L{isLastYear}", argCount: 0 },
    { value: "isYearToDate", text: "L{isYearToDate}", argCount: 0 },
    commonOperators.isIncludedIn,
    commonOperators.isNotIncludedIn
  ],
  boolean: [
    { value: "isTrue", text: "L{isTrue}", argCount: 0 },
    { value: "isFalse", text: "L{isFalse}", argCount: 0 }
  ],
  duration: [
    commonOperators.empty,
    commonOperators.notEmpty,
    commonOperators["="],
    commonOperators["!="],
    commonOperators[">"],
    commonOperators["<"],
    commonOperators[">="],
    commonOperators["<="],
    commonOperators.between,
    commonOperators.notBetween,
    commonOperators.isIncludedIn,
    commonOperators.isNotIncludedIn
  ],
  time: [
    commonOperators.empty,
    commonOperators.notEmpty,
    commonOperators["="],
    commonOperators["!="],
    commonOperators[">"],
    commonOperators["<"],
    commonOperators[">="],
    commonOperators["<="],
    commonOperators.between,
    commonOperators.notBetween,
    commonOperators.isIncludedIn,
    commonOperators.isNotIncludedIn
  ],
  relation: [
    commonOperators.empty,
    commonOperators.notEmpty,
    commonOperators["="],
    commonOperators["!="],
    commonOperators.isIncludedIn,
    commonOperators.isNotIncludedIn
  ],
  auto: [
    { value: "*", text: "L{contains}" }
  ]
});
__publicField(_FieldFilterPicker, "configurable", {
  /**
   * Dictionary of {@link #typedef-FieldOption} representing the fields against which filters can be defined,
   * keyed by field name.
   *
   * <div class="note">5.3.0 Syntax accepting FieldOption[] was deprecated in favor of dictionary and will be removed in 6.0</div>
   *
   * If filtering a {@link Grid.view.Grid}, consider using {@link Grid.widget.GridFieldFilterPicker}, which can be configured
   * with an existing {@link Grid.view.Grid} instead of, or in combination with, defining fields manually.
   *
   * Example:
   * ```javascript
   * fields: {
   *     // Allow filters to be defined against the 'age' and 'role' fields in our data
   *     age  : { title: 'Age', type: 'number' },
   *     role : { title: 'Role', type: 'string' }
   * }
   * ```
   *
   * @config {Object<String,FieldOption>}
   */
  fields: null,
  /**
   * Make the entire picker disabled.
   *
   * @config {Boolean}
   * @default
   */
  disabled: false,
  /**
   * Make the entire picker read-only.
   *
   * @config {Boolean}
   * @default
   */
  readOnly: false,
  layout: "vbox",
  /**
   * Make only the property selector readOnly.
   * @private
   *
   * @config {Boolean}
   * @default
   */
  propertyLocked: false,
  /**
   * Make only the operator selector readOnly.
   * @private
   *
   * @config {Boolean}
   * @default
   */
  operatorLocked: false,
  /**
   * Configuration object for the {@link Core.util.CollectionFilter} displayed
   * and editable in this picker.
   *
   * Example:
   *
   * ```javascript
   * {
   *     property: 'age',
   *     operator: '=',
   *     value: 25
   * }
   * ```
   *
   * @config {CollectionFilterConfig}
   */
  filter: null,
  /**
   * Optional configuration for the property selector {@link Core.widget.Combo}.
   *
   * @config {ComboConfig}
   */
  propertyFieldConfig: null,
  /**
   * Optional configuration for the operator selector {@link Core.widget.Combo}.
   *
   * @config {ComboConfig}
   * @private
   */
  operatorFieldConfig: null,
  /**
   * Optional CSS class to apply to the value field(s).
   *
   * @config {String}
   * @private
   */
  valueFieldCls: null,
  /**
   * Whether to raise {@link #event-change} events as the user types into a value field. If `false`,
   * {@link #event-change} events will be raised only when the value input field's own `change` event
   * occurs, for example on field blur.
   *
   * @config {Boolean}
   * @default
   */
  triggerChangeOnInput: true,
  /**
   * @private
   */
  items: {
    inputs: {
      type: "container",
      layout: "hbox",
      cls: `${clsBase}-inputs`,
      items: {
        propertyPicker: {
          type: "combo",
          items: {},
          cls: `${clsBase}-property`,
          placeholder: "L{FieldFilterPicker.selectAProperty}",
          highlightExternalChange: false
        },
        operatorPicker: {
          type: "combo",
          items: {},
          cls: `${clsBase}-operator`,
          placeholder: "L{FieldFilterPicker.selectAnOperator}",
          highlightExternalChange: false
        },
        valueFields: {
          type: "container",
          cls: `${clsBase}-values`,
          items: {}
        }
      }
    },
    caseSensitive: {
      type: "checkbox",
      text: "L{FieldFilterPicker.caseSensitive}",
      cls: `${clsBase}-case-sensitive`
    }
  },
  /**
   * Overrides the built-in list of operators that are available for selection. Specify operators as
   * an object with data types as keys and lists of operators as values, like this:
   *
   * ```javascript
   * operators : {
   *     string : [
   *         { value : 'empty', text : 'is empty', argCount : 0 },
   *         { value : 'notEmpty', text : 'is not empty', argCount : 0 }
   *     ],
   *     number : [
   *         { value : '=', text : 'equals' },
   *         { value : '!=', text : 'does not equal' }
   *     ],
   *     date : [
   *         { value : '<', text : 'is before' }
   *     ]
   * }
   * ```
   *
   * Here `value` is what will be stored in the `operator` field in the filter when selected, `text` is the text
   * displayed in the Combo for selection, and `argCount` is the number of arguments (comparison values) the
   * operator requires. The default argCount if not specified is 1.
   *
   * @config {Object}
   */
  operators: _FieldFilterPicker.defaultOperators,
  /**
   * The date format string used to display dates when using the 'is one of' / 'is not one of' operators with a date
   * field. Defaults to the current locale's `FieldFilterPicker.dateFormat` value.
   *
   * @config {String}
   * @default
   */
  dateFormat: "L{FieldFilterPicker.dateFormat}",
  /**
   * Optional {Core.data.Store} against which filters are being defined. This is used to supply options to filter against
   * when using the 'is one of' and 'is not one of' operators.
   *
   * @config {Core.data.Store}
   */
  store: null,
  /**
   * Optional {@link ValueFieldPlaceholders} object specifying custom placeholder text for value input fields.
   *
   * @config {ValueFieldPlaceholders}
   */
  valueFieldPlaceholders: null,
  /**
   * Optional function that modifies the configuration of value fields shown for a filter. The default configuration
   * is received as an argument and the returned value will be used as the final configuration. For example:
   *
   * ```javascript
   * getValueFieldConfig : (filter, fieldConfig) => {
   *     return {
   *         ...fieldConfig,
   *         title : fieldName    // Override the `title` config for the field
   *     };
   * }
   * ```
   *
   * The supplied function should accept the following arguments:
   *
   * @config {Function}
   * @param {Core.util.CollectionFilter} filter The filter being displayed
   * @param {ContainerItemConfig} fieldConfig Configuration object for the value field
   * @returns {ContainerItemConfig} the resulting configuration
   */
  getValueFieldConfig: null
});
//endregion
// Make lookup of operator arity (arg count) by [fieldType][operator]
__publicField(_FieldFilterPicker, "buildOperatorArgCountLookup", (operators) => ArrayHelper.keyBy(
  Object.entries(operators),
  ([fieldType]) => fieldType,
  ([, operators2]) => ArrayHelper.keyBy(
    operators2,
    ({ value }) => value,
    ({ argCount }) => argCount === void 0 ? 1 : argCount
  )
));
var FieldFilterPicker = _FieldFilterPicker;
FieldFilterPicker.initClass();
FieldFilterPicker._$name = "FieldFilterPicker";

// ../Core/lib/Core/widget/Label.js
var Label = class extends Widget {
  compose() {
    const { text, html } = this;
    return {
      tag: "label",
      text,
      html
    };
  }
};
__publicField(Label, "$name", "Label");
__publicField(Label, "type", "label");
__publicField(Label, "configurable", {
  /**
   * Get/set label text
   * @prp {String}
   */
  text: null,
  localizableProperties: ["text"]
});
Label.initClass();
Label._$name = "Label";

// ../Core/lib/Core/widget/FieldFilterPickerGroup.js
var _FieldFilterPickerGroup = class _FieldFilterPickerGroup extends Container {
  afterConstruct() {
    const me = this;
    me.validateConfig();
    const { addFilterButton } = me.widgetMap;
    addFilterButton.ion({ click: "addFilter", thisObj: me });
    addFilterButton.text = me.L(addFilterButton.text);
    me.store && me.updateStore(me.store);
    super.afterConstruct();
  }
  changeDateFormat(dateFormat) {
    return this.L(dateFormat);
  }
  validateConfig() {
    if (!this.fields && !this.store) {
      throw new Error(
        `FieldFilterPickerGroup requires either a 'fields' or 'store' config property.`
      );
    }
  }
  updateFields(newFields) {
    this.widgetMap.pickers.childItems.forEach((picker) => picker.fields = newFields);
  }
  updateFilters(newFilters, oldFilters) {
    const me = this;
    if (oldFilters) {
      oldFilters.filter((filter2) => !newFilters.find((newFilter) => newFilter.id === filter2.id)).forEach((filter2) => {
        var _a2;
        return (_a2 = me.store) == null ? void 0 : _a2.removeFilter(filter2.id);
      });
    }
    newFilters.forEach((filter2) => filter2.id = filter2.id || me.nextFilterId);
    me.widgetMap.pickers.items = (newFilters == null ? void 0 : newFilters.map((filter2) => me.getPickerRowConfig(filter2))) || [];
  }
  changeFilters(newFilters) {
    const { canManageFilter } = this;
    return newFilters && canManageFilter ? newFilters.filter((filter2) => this.callback(canManageFilter, this, [filter2])) : newFilters;
  }
  updateStore(newStore) {
    const me = this;
    me.detachListeners("store");
    if (newStore) {
      me.widgetMap.pickers.childItems.forEach(({ widgetMap: { filterPicker: { filter: filter2, isValid } } }) => {
        newStore.removeFilter(filter2.id, true);
        if (isValid) {
          newStore.addFilter(filter2, true);
        }
      });
      newStore.filter();
      me.appendFiltersFromStore();
      newStore.ion({
        name: "store",
        filter: "onStoreFilter",
        thisObj: me
      });
    }
    me.widgetMap.pickers.childItems.forEach((picker) => picker.store = newStore);
  }
  updateShowAddFilterButton(newShow) {
    this.widgetMap.addFilterButton.hidden = !newShow;
  }
  updateAddFilterButtonText(newText) {
    this.widgetMap.addFilterButton.text = newText != null ? newText : _FieldFilterPickerGroup.addFilterButtonDefaultText;
  }
  /**
   * Find any filters the store has that we don't know about yet, and add to our list
   * @private
   */
  appendFiltersFromStore() {
    const me = this;
    me.store.filters.forEach((filter2) => {
      var _a2;
      const canManage = me.canManage(filter2), { property, operator, id } = filter2;
      if (canManage && property && operator && !((_a2 = me.filters) == null ? void 0 : _a2.find((filter3) => filter3.id === id))) {
        me.appendFilter(filter2);
      }
    });
  }
  /**
   * @private
   */
  canManage(filter2) {
    const me = this;
    return !me.canManageFilter || me.callback(me.canManageFilter, me, [filter2]) === true;
  }
  /**
   * Get the configuration object for one child FieldFilterPicker.
   * @param {Core.util.CollectionFilter} filter The filter represented by the child FieldFilterPicker
   * @returns {Object} The FieldFilterPicker configuration
   */
  getFilterPickerConfig(filter2) {
    const me = this, {
      fields,
      store,
      disabled,
      readOnly,
      valueFieldCls,
      operators,
      limitToProperty,
      dateFormat,
      getFieldFilterPickerConfig,
      triggerChangeOnInput
    } = me;
    return {
      type: me.constructor.childPickerType,
      fields: fields != null ? fields : me.getFieldsFromStore(store),
      filter: filter2,
      store,
      disabled,
      readOnly,
      propertyLocked: Boolean(limitToProperty),
      valueFieldCls,
      operators,
      dateFormat,
      internalListeners: {
        change: "onFilterPickerChange",
        thisObj: me
      },
      flex: 1,
      triggerChangeOnInput,
      ...getFieldFilterPickerConfig ? me.callback(getFieldFilterPickerConfig, me, [filter2]) : void 0
    };
  }
  /**
   * Get store fields as {@link Core.widget.FieldFilterPicker#typedef-FieldOption}s in a dictionary keyed by name.
   * @private
   */
  getFieldsFromStore(store) {
    var _a2, _b;
    return Object.fromEntries((_b = (_a2 = store.modelClass) == null ? void 0 : _a2.fields.map(({ name, type }) => [name, { type }])) != null ? _b : []);
  }
  getPickerRowConfig(filter2) {
    const me = this, { disabled, readOnly, canDeleteFilter } = me, canDelete = !(canDeleteFilter && me.callback(canDeleteFilter, me, [filter2]) === false);
    return {
      type: "container",
      layout: "box",
      cls: {
        [`b-${_FieldFilterPickerGroup.type}-row`]: true,
        [`b-${_FieldFilterPickerGroup.type}-row-removable`]: canDelete
      },
      dataset: {
        separatorText: me.L("L{FieldFilterPicker.and}")
      },
      items: {
        activeCheckbox: {
          type: "checkbox",
          disabled,
          readOnly,
          checked: !Boolean(filter2.disabled),
          internalListeners: {
            change: "onFilterActiveChange",
            thisObj: me
          },
          cls: `b-${_FieldFilterPickerGroup.type}-filter-active`
        },
        filterPicker: me.getFilterPickerConfig(filter2),
        removeButton: {
          type: "button",
          ref: "removeButton",
          disabled,
          readOnly,
          hidden: !canDelete,
          cls: `b-transparent b-${_FieldFilterPickerGroup.type}-remove`,
          icon: "b-fa-trash",
          internalListeners: {
            click: "removeFilter",
            thisObj: me
          }
        }
      }
    };
  }
  get allInputs() {
    const childInputTypes = [this.constructor.childPickerType, "button", "checkbox"];
    return this.queryAll((w) => childInputTypes.includes(w.type));
  }
  updateDisabled(newDisabled) {
    this.allInputs.forEach((input) => input.disabled = newDisabled);
  }
  updateReadOnly(newReadOnly) {
    this.allInputs.forEach((input) => input.readOnly = newReadOnly);
  }
  onFilterActiveChange({ source, checked }) {
    const me = this, filterIndex = me.getFilterIndex(source), filter2 = me.filters[filterIndex], filterPicker = me.getFilterPicker(filterIndex);
    filter2.disabled = !checked;
    filterPicker.onFilterChange();
    if (me.store && filterPicker.isValid) {
      me.store.addFilter(filter2, true);
    }
    me.updateStoreFilter();
    me.triggerChange();
  }
  onFilterPickerChange({ source, filter: filter2, isValid }) {
    const me = this, { store } = me, filterIndex = me.getFilterIndex(source);
    if (store) {
      store.removeFilter(filter2.id, true);
      if (isValid) {
        store.addFilter(filter2, true);
      }
      me.updateStoreFilter();
    }
    Object.assign(me.filters[filterIndex], filter2);
    me.triggerChange();
  }
  getFilterIndex(eventSource) {
    return this.widgetMap.pickers.childItems.indexOf(
      eventSource.containingWidget
    );
  }
  getPickerRow(index) {
    return this.widgetMap.pickers.childItems[index];
  }
  /**
   * Return the {@link Core.widget.FieldFilterPicker} for the filter at the specified index.
   * @param {Number} filterIndex
   * @returns {Core.widget.FieldFilterPicker}
   */
  getFilterPicker(filterIndex) {
    return this.getPickerRow(filterIndex).widgetMap.filterPicker;
  }
  get nextFilterId() {
    this._nextId = (this._nextId || 0) + 1;
    return `${this.id}-filter-${this._nextId}`;
  }
  removeFilter({ source }) {
    const me = this, filterIndex = me.getFilterIndex(source), filter2 = me.filters[filterIndex], pickerRow = me.getPickerRow(filterIndex), newFocusWidget = me.query((w) => w.isFocusable && w.type !== "container" && !pickerRow.contains(w));
    if (newFocusWidget) {
      newFocusWidget.focus();
    }
    me.removeFilterAt(filterIndex);
    if (me.store) {
      me.store.removeFilter(filter2.id, true);
      me.updateStoreFilter();
    }
    me.trigger("remove", { filter: filter2 });
    me.triggerChange();
  }
  /**
   * Appends a filter at the bottom of the list.
   * @param {CollectionFilterConfig} [filter={}] Configuration object for the {@link Core.util.CollectionFilter} to
   * add. Defaults to an empty filter.
   */
  addFilter({ property = null, operator = null, value = null } = {}) {
    var _a2;
    const me = this, { filters } = me, newFilter = {
      property: me.limitToProperty || property,
      operator,
      value,
      disabled: false,
      id: me.nextFilterId,
      caseSensitive: false
    };
    if (!me.trigger("beforeAddFilter", { filter: newFilter })) {
      return;
    }
    me.appendFilter(newFilter);
    if (me.getFilterPicker(filters.length - 1).isValid) {
      (_a2 = me.store) == null ? void 0 : _a2.addFilter(newFilter, true);
      me.store && me.updateStoreFilter();
    }
    me.trigger("add", { filter: newFilter });
    me.triggerChange();
  }
  /**
   * @private
   */
  appendFilter(filter2) {
    const me = this;
    if (!me.limitToProperty || filter2.property === me.limitToProperty) {
      me.filters.push(filter2);
      me.widgetMap.pickers.add(
        me.getPickerRowConfig(filter2, me.filters.length - 1)
      );
    }
  }
  onStoreFilter(event) {
    const me = this;
    if (me._isUpdatingStore) {
      return;
    }
    const { filters } = event, storeFiltersById = filters.values.reduce((byId, filter2) => ({ ...byId, [filter2.id]: filter2 }), {});
    for (let filterIndex = me.filters.length - 1; filterIndex >= 0; filterIndex--) {
      const filter2 = me.filters[filterIndex], storeFilter = storeFiltersById[filter2.id], filterRow = me.getPickerRow(filterIndex);
      if (filterRow) {
        const { filterPicker, activeCheckbox } = filterRow.widgetMap;
        if (!storeFilter && filterPicker.isValid) {
          me.removeFilterAt(filterIndex);
        } else if (storeFilter !== void 0) {
          const { operator, value, property, disabled, caseSensitive } = storeFilter;
          if (filter2 !== storeFilter) {
            Object.assign(filter2, { operator, value, property, disabled, caseSensitive });
          }
          filterPicker.filter = filter2;
          filterPicker.onFilterChange();
          activeCheckbox.checked = !disabled;
        }
      }
    }
    me.appendFiltersFromStore();
    me.triggerChange();
  }
  /**
   * Remove the filter at the given index.
   * @param {Number} filterIndex The index of the filter to remove
   */
  removeFilterAt(filterIndex) {
    const { widgetMap: { pickers }, filters } = this;
    pickers.remove(pickers.childItems[filterIndex]);
    filters.splice(filterIndex, 1);
    this.triggerChange();
  }
  /**
   * Trigger a store re-filter after filters have been silently modified.
   * @private
   */
  updateStoreFilter() {
    var _a2;
    this._isUpdatingStore = true;
    (_a2 = this.store) == null ? void 0 : _a2.filter();
    this._isUpdatingStore = false;
  }
  /**
   * Returns the array of filter configuration objects currently represented by this picker group.
   * @type {CollectionFilterConfig[]}
   */
  get value() {
    return this.filters;
  }
  triggerChange() {
    const { filters } = this, validFilters = filters.filter((f, index) => this.getPickerRow(index).widgetMap.filterPicker.isValid);
    this.trigger("change", {
      filters,
      validFilters
    });
  }
  /**
   * Sets all current filters to enabled and checks their checkboxes.
   */
  activateAll() {
    this.setAllActiveStatus(true);
  }
  /**
   * Sets all current filters to disabled and clears their checkboxes.
   */
  deactivateAll() {
    this.setAllActiveStatus(false);
  }
  /**
   * @private
   */
  setAllActiveStatus(newActive) {
    const me = this, { _filters, store } = me;
    _filters.forEach((filter2, filterIndex) => {
      if (newActive === filter2.disabled) {
        const { filterPicker, activeCheckbox } = me.getPickerRow(filterIndex).widgetMap;
        filter2.disabled = !newActive;
        filterPicker.onFilterChange();
        activeCheckbox.checked = newActive;
        if (newActive && store && filterPicker.isValid) {
          store.addFilter(filter2, true);
        }
      }
    });
    me.updateStoreFilter();
  }
  focus() {
    var _a2;
    const { length } = this._filters;
    if (length > 0) {
      (_a2 = this.getPickerRow(length - 1)) == null ? void 0 : _a2.widgetMap.filterPicker.focus();
    }
  }
};
//region Config
__publicField(_FieldFilterPickerGroup, "$name", "FieldFilterPickerGroup");
__publicField(_FieldFilterPickerGroup, "type", "fieldfilterpickergroup");
/**
 * @private
 */
__publicField(_FieldFilterPickerGroup, "addFilterButtonDefaultText", "L{FieldFilterPickerGroup.addFilter}");
__publicField(_FieldFilterPickerGroup, "configurable", {
  /**
   * Array of {@link Core.util.CollectionFilter} configuration objects. One
   * {@link Core.widget.FieldFilterPicker} will be created
   * for each object in the array.
   *
   * When {@link #config-store} is provided, any filters in the store will
   * be automatically added and do not need to be provided explicitly.
   *
   * Example:
   * ```javascript
   * filters: [{
   *     // Filter properties should exist among field names configured
   *     // via `fields` or `store`
   *     property: 'age',
   *     operator: '<',
   *     value: 30
   * },{
   *     property: 'title',
   *     operator: 'startsWith',
   *     value: 'Director'
   * }]
   * ```
   *
   * @config
   * @type {CollectionFilterConfig[]}
   */
  filters: [],
  /**
   * Dictionary of {@link Core.widget.FieldFilterPicker#typedef-FieldOption} representing the fields against which filters can be defined,
   * keyed by field name.
   *
   * If filtering a {@link Grid.view.Grid}, consider using {@link Grid.widget.GridFieldFilterPicker}, which can be configured
   * with an existing {@link Grid.view.Grid} instead of, or in combination with, defining fields manually.
   *
   * Example:
   * ```javascript
   * fields: {
   *     // Allow filters to be defined against the 'age' and 'role' fields in our data
   *     age  : { text: 'Age', type: 'number' },
   *     role : { text: 'Role', type: 'string' }
   * }
   * ```
   *
   * @config {Object<String,FieldOption>}
   * @deprecated 5.3.0 Syntax accepting FieldOptions[] was deprecated in favor of dictionary and will be removed in 6.0
   */
  fields: null,
  /**
   * Whether the picker group is disabled.
   *
   * @config {Boolean}
   * @default
   */
  disabled: false,
  /**
   * Whether the picker group is read-only.
   *
   * Example:
   * fields: [
   *    { name: 'age', type: 'number' },
   *    { name: 'title', type: 'string' }
   * ]
   *
   * @config {Boolean}
   * @default
   */
  readOnly: false,
  layout: "vbox",
  /**
   * The {@link Core.data.Store} whose records will be filtered. The store's {@link Core.data.Store#property-modelClass}
   * will be used to determine field types.
   *
   * This store will be kept in sync with the filters defined in the picker group, and new filters added to the store
   * via other means will appear in this filter group when they are able to be modified by it. (Some types of filters,
   * like arbitrary filter functions, cannot be managed through this widget.)
   *
   * As a corollary, multiple `FieldFilterPickerGroup`s configured with the same store will stay in sync, showing the
   * same filters as the store's filters change.
   *
   * @config {Core.data.Store}
   */
  store: null,
  /**
   * When `limitToProperty` is set to the name of an available field (as specified either
   * explicitly in {@link #config-fields} or implicitly in the
   * {@link #config-store}'s model), it has the following effects:
   *
   * - the picker group will only show filters defined on the specified property
   * - it will automatically set the `property` to the specified property for all newly added
   *   filters where the property is not already set
   * - the property selector is made read-only
   *
   * @config {String}
   */
  limitToProperty: null,
  /**
   * Optional CSS class to apply to the value field(s).
   *
   * @config {String}
   * @private
   */
  valueFieldCls: null,
  /**
   * Show a button at the bottom of the group that adds a new, blank filter to the group.
   *
   * @config {Boolean}
   * @default
   */
  showAddFilterButton: true,
  /**
   * Optional predicate that returns whether a given filter can be deleted. When `canDeleteFilter` is provided,
   * it will be called for each filter and will not show the delete button for those for which the
   * function returns `false`.
   *
   * @config {Function}
   * @param {*} filter  filter for checking
   * @returns {Boolean} truthy value if filter can be deleted
   */
  canDeleteFilter: null,
  /**
   * Optional function that returns {@link Core.widget.FieldFilterPicker} configuration properties for
   * a given filter. When `getFieldFilterPickerConfig` is provided, it will be called for each filter and the returned
   * object will be merged with the configuration properties for the individual
   * {@link Core.widget.FieldFilterPicker} representing that filter.
   *
   * The supplied function should accept a single argument, the {@link Core.util.CollectionFilter} whose picker
   * is being created.
   *
   * @config {Function}
   * @returns {FieldFilterPickerConfig}
   */
  getFieldFilterPickerConfig: null,
  /**
   * Optional predicate that returns whether a given filter can be managed by this widget. When `canManageFilter`
   * is provided, it will be used to decide whether to display filters found in the configured
   * {@link #config-store}.
   *
   * @config {Function}
   * @param {*} filter  filter for checking
   * @returns {Boolean} truthy value if filter can be managed
   */
  canManageFilter: null,
  /**
   * Sets the text displayed in the 'add filter' button if one is present.
   *
   * @config {String}
   */
  addFilterButtonText: null,
  /**
   * Whether to raise {@link #event-change} events as the user types into a value field. If `false`,
   * {@link #event-change} events will be raised only when the value input field's own `change` event
   * occurs, for example on field blur.
   *
   * @config {Boolean}
   * @default
   */
  triggerChangeOnInput: true,
  /**
   * @private
   */
  items: {
    pickers: {
      type: "container",
      layout: "vbox",
      scrollable: true,
      items: {}
    },
    addFilterButton: {
      type: "button",
      text: _FieldFilterPickerGroup.addFilterButtonDefaultText,
      cls: `b-${_FieldFilterPickerGroup.type}-add-button`,
      hidden: true
    }
  },
  /**
   * When specified, overrides the built-in list of available operators. See
   * {@link Core.widget.FieldFilterPicker#config-operators}.
   *
   * @config {Object}
   */
  operators: null,
  /**
   * The date format string used to display dates when using the 'is one of' / 'is not one of' operators with a date
   * field. Defaults to the current locale's `FieldFilterPicker.dateFormat` value.
   *
   * @config {String}
   * @default
   */
  dateFormat: "L{FieldFilterPicker.dateFormat}"
});
// endregion
__publicField(_FieldFilterPickerGroup, "childPickerType", "fieldfilterpicker");
var FieldFilterPickerGroup = _FieldFilterPickerGroup;
FieldFilterPickerGroup.initClass();
FieldFilterPickerGroup._$name = "FieldFilterPickerGroup";

// ../Core/lib/Core/widget/FieldSet.js
var FieldSet = class extends Panel.mixin(Labelable_default) {
  static get configurable() {
    return {
      bodyTag: "fieldset",
      focusable: false,
      /**
       * Setting this config to `true` assigns a horizontal box layout (`flex-flow: row`) to the items in this
       * container, while `false` assigns a vertical box layout (`flex-flow: column`).
       *
       * By default, this value is automatically determined based on the {@link #config-label} and
       * {@link #config-labelPosition} configs.
       * @config {Boolean}
       */
      inline: null,
      inlineInternal: null,
      layout: {
        type: "box",
        horizontal: false
      }
    };
  }
  static get prototypeProperties() {
    return {
      flexRowCls: "b-hbox",
      flexColCls: "b-vbox"
    };
  }
  //endregion
  //region Composition
  get bodyConfig() {
    const result = super.bodyConfig, { className } = result, { inlineInternal: inline, hasLabel, title } = this;
    delete result.html;
    className["b-inline"] = inline;
    className["b-fieldset-has-label"] = hasLabel;
    if (title) {
      result.children = {
        // We render the <legend> element for a11y (not 100% sure it is needed)
        legendElement: {
          tag: "legend",
          text: title,
          class: {
            "b-fieldset-legend": 1
          }
        }
      };
    }
    return result;
  }
  compose() {
    const { inlineInternal: inline, label, labelCls, labelWidth } = this;
    return {
      class: {
        "b-field": label,
        "b-vbox": !inline
        // override panel
      },
      children: {
        "labelElement > headerElement": (label || null) && {
          tag: "label",
          html: label,
          class: {
            "b-label": 1,
            "b-align-start": 1,
            [labelCls]: labelCls
          },
          style: {
            width: DomHelper.unitize("width", labelWidth)[1]
          }
        }
      }
    };
  }
  //endregion
  syncInlineInternal() {
    var _a2;
    this.inlineInternal = (_a2 = this.inline) != null ? _a2 : this.label != null && this.labelPosition === "before";
  }
  updateDisabled(value, was) {
    super.updateDisabled(value, was);
    this.eachWidget(
      (item) => {
        item.disabled = value;
      },
      /* deep = */
      false
    );
  }
  updateInline() {
    this.syncInlineInternal();
  }
  updateInlineInternal(inline) {
    this.layout.horizontal = inline;
  }
  updateLabel() {
    this.syncInlineInternal();
  }
  updateLabelPosition() {
    this.syncInlineInternal();
  }
};
//region Config
__publicField(FieldSet, "$name", "FieldSet");
__publicField(FieldSet, "type", "fieldset");
FieldSet.initClass();
FieldSet._$name = "FieldSet";

// ../Core/lib/Core/widget/FileField.js
var FileField = class extends Field {
  static get configurable() {
    return {
      /**
       * Set to true to allow picking multiple files. Note that when set to a truthy value,
       * the field is set to accept multiple files, but the value returned will be
       * an empty string since this is what is rendered into the HTML.
       * @config {Boolean}
       * @default
       */
      multiple: null,
      /**
       * Comma-separated list of file extensions or MIME type to accept. E.g.
       * ".jpg,.png,.doc" or "image/*". Null by default, allowing all files.
       * @config {String}
       */
      accept: null,
      inputType: "file",
      attributes: ["multiple", "accept"]
    };
  }
  /**
   * Returns list of selected files
   * @property {FileList}
   * @readonly
   */
  get files() {
    return this.input.files;
  }
  /**
   * Opens browser file picker
   * @internal
   */
  pickFile() {
    this.input.click();
  }
  get multiple() {
    return this._multiple ? "" : null;
  }
  /**
   * Clears field value
   */
  clear() {
    this.input.value = null;
  }
  triggerChange(event) {
    this.triggerFieldChange({
      event,
      value: this.input.value,
      oldValue: this._lastValue,
      userAction: true,
      valid: true
    });
  }
};
__publicField(FileField, "$name", "FileField");
__publicField(FileField, "type", "filefield");
FileField.initClass();
FileField._$name = "FileField";

// ../Core/lib/Core/widget/FilePicker.js
var FilePicker = class extends Container {
  static get defaultConfig() {
    return {
      /**
       * The name of the property to set when a single value is to be applied to this FilePicker. Such as when used
       * in a grid WidgetColumn, this is the property to which the column's `field` is applied.
       * @config {String}
       * @default
       * @category Misc
       */
      defaultBindProperty: "value",
      /**
       * Fires after user closes file picker dialog.
       * @event change
       * @param {FileList} files List of picked files
       */
      /**
       * Fires when field is cleared with {@link #function-clear} method
       * @event clear
       */
      /**
       * Wrapper button config object. See {@link Core/widget/Button} for list of available configs.
       * @config {ButtonConfig}
       */
      buttonConfig: null,
      /**
       * Underlying field config object. See {@link Core/widget/FileField} for list of available configs.
       * @config {FileFieldConfig}
       */
      fileFieldConfig: null
    };
  }
  construct(config = {}) {
    const me = this;
    config.items = [
      Object.assign({
        type: "button",
        ref: "fileButton",
        text: "L{FilePicker.file}",
        localeClass: this
      }, config.buttonConfig),
      Object.assign({
        type: "filefield",
        ref: "fileField",
        style: "display: none"
      }, config.fileFieldConfig)
    ].concat(config.items || []);
    super.construct(config);
    me.button.ion({
      click: me.onButtonClick,
      thisObj: me
    });
    me.fileField.ion({
      change: me.onFileFieldChange,
      thisObj: me
    });
    me._thisIsAUsedExpression(me.fileTip);
  }
  get button() {
    return this.widgetMap.fileButton;
  }
  get fileField() {
    return this.widgetMap.fileField;
  }
  /**
   * List of selected files
   * @property {FileList}
   * @readonly
   */
  get files() {
    return this.fileField.files;
  }
  get fileTip() {
    const me = this;
    return me._fileTip || (me._fileTip = new Tooltip({
      cls: "b-file-tip",
      forElement: me.button.element,
      showOnHover: true,
      align: "b-t",
      scrollAction: "realign",
      internalListeners: {
        beforeshow() {
          const tip = this, files = me.files;
          if (files && files.length) {
            tip.html = `${Array.from(files).map((file) => file.name).join("<br>")}`;
            return true;
          }
          return false;
        }
      }
    }));
  }
  /**
   * Clears field
   */
  clear() {
    const me = this;
    me.fileField.clear();
    me.button.badge = "";
    me.trigger("clear");
  }
  onButtonClick({ event }) {
    const me = this;
    me.fileField.pickFile();
    event.preventDefault();
  }
  onFileFieldChange({ valid }) {
    const me = this;
    me.button.badge = me.files.length || "";
    me.triggerFieldChange({ files: me.files, valid });
  }
};
__publicField(FilePicker, "$name", "FilePicker");
__publicField(FilePicker, "type", "filepicker");
FilePicker.initClass();
FilePicker._$name = "FilePicker";

// ../Core/lib/Core/widget/FilterField.js
var FilterField = class extends TextField {
  static get configurable() {
    return {
      /**
       * The model field name to filter by. Can optionally be replaced by {@link #config-filterFunction}
       * @config {String}
       * @category Filtering
       */
      field: null,
      /**
       * The store to filter.
       * @config {Core.data.Store}
       * @category Filtering
       */
      store: null,
      /**
       * Optional filter function to be called with record and value as parameters for store filtering.
       * ```javascript
       * {
       *     type           : 'filterfield',
       *     store          : myStore,
       *     filterFunction : (record, value)  => {
       *        return record.text.includes(value);
       *     }
       * }
       * ```
       *
       * @config {Function}
       * @param {Core.data.Model} record Record for comparison
       * @param {String} value Value to compare with
       * @returns {Boolean} Returns `true` if record matches comparison requirements
       *
       * @category Filtering
       */
      filterFunction: null,
      clearable: true,
      revertOnEscape: true,
      ignoreParentReadOnly: true,
      keyStrokeChangeDelay: 100,
      onChange({ value }) {
        const { store, field, filterFunction } = this;
        if (store) {
          const filterId = `${field || this.id}-Filter`;
          if (value.length === 0) {
            store.removeFilter(filterId);
          } else {
            let filterBy;
            if (filterFunction) {
              filterBy = (record) => filterFunction(record, value);
            } else {
              value = value.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
              filterBy = (record) => {
                var _a2;
                return (_a2 = record.getValue(field)) == null ? void 0 : _a2.match(new RegExp(value, "i"));
              };
            }
            store.filter({
              id: filterId,
              filterBy
            });
          }
        }
      }
    };
  }
  updateValue(value, old) {
    super.updateValue(value, old);
    if (value && this.isConfiguring) {
      this.onChange({ value });
    }
  }
};
__publicField(FilterField, "$name", "FilterField");
__publicField(FilterField, "type", "filterfield");
FilterField.initClass();
FilterField._$name = "FilterField";

// ../Core/lib/Core/widget/MessageDialog.js
var items = [
  {
    ref: "cancelButton",
    cls: "b-messagedialog-cancelbutton b-gray",
    text: "L{Object.Cancel}",
    onClick: "up.onCancelClick"
  },
  {
    ref: "okButton",
    cls: "b-messagedialog-okbutton b-raised b-blue",
    text: "L{Object.Ok}",
    onClick: "up.onOkClick"
  }
];
if (BrowserHelper.isWindows) {
  items.reverse();
}
var _MessageDialogConstructor = class _MessageDialogConstructor extends Popup {
  static get configurable() {
    return {
      centered: true,
      modal: true,
      hidden: true,
      autoShow: false,
      closeAction: "hide",
      title: "\xA0",
      lazyItems: {
        $config: ["lazy"],
        value: [{
          cls: "b-messagedialog-message",
          ref: "message"
        }, {
          type: "textfield",
          cls: "b-messagedialog-input",
          ref: "input"
        }]
      },
      showClass: null,
      bbar: {
        overflow: null,
        items
      }
    };
  }
  construct() {
    this.okButton = this.yesButton = 1;
    this.cancelButton = 3;
    super.construct(...arguments);
  }
  // Protect from queryAll -> destroy
  destroy() {
  }
  /**
   * Shows a confirm dialog with "Ok" and "Cancel" buttons. The returned promise resolves passing the button identifier
   * of the button that was pressed ({@link #property-okButton} or {@link #property-cancelButton}).
   * @function confirm
   * @param {Object} options An options object for what to show.
   * @param {String} [options.title] The title to show in the dialog header.
   * @param {String} [options.message] The message to show in the dialog body.
   * @param {String} [options.rootElement] The root element of this widget, defaults to document.body. Use this
   * if you use the MessageDialog inside a web component ShadowRoot
   * @param {String|ButtonConfig} [options.cancelButton] A text or a config object to apply to the Cancel button.
   * @param {String|ButtonConfig} [options.okButton] A text or config object to apply to the OK button.
   * @returns {Promise} A promise which is resolved when the dialog is closed
   */
  async confirm() {
    return this.showDialog("confirm", ...arguments);
  }
  /**
   * Shows an alert popup with a message. The returned promise resolves when the button is clicked.
   * @function alert
   * @param {Object} options An options object for what to show.
   * @param {String} [options.title] The title to show in the dialog header.
   * @param {String} [options.message] The message to show in the dialog body.
   * @param {String} [options.rootElement] The root element of this widget, defaults to document.body. Use this
   * if you use the MessageDialog inside a web component ShadowRoot
   * @param {String|ButtonConfig} [options.okButton] A text or config object to apply to the OK button.
   * @returns {Promise} A promise which is resolved when the dialog is closed
   */
  async alert() {
    return this.showDialog("alert", ...arguments);
  }
  /**
   * Shows a popup with a basic {@link Core.widget.TextField} along with a message. The returned promise resolves when
   * the dialog is closed and yields an Object with a `button` ({@link #property-okButton} or {@link #property-cancelButton})
   * and a `text` property with the text the user provided
   * @function prompt
   * @param {Object} options An options object for what to show.
   * @param {String} [options.title] The title to show in the dialog header.
   * @param {String} [options.message] The message to show in the dialog body.
   * @param {String} [options.rootElement] The root element of this widget, defaults to document.body. Use this
   * if you use the MessageDialog inside a web component ShadowRoot
   * @param {TextFieldConfig} [options.textField] A config object to apply to the TextField.
   * @param {String|ButtonConfig} [options.cancelButton] A text or a config object to apply to the Cancel button.
   * @param {String|ButtonConfig} [options.okButton] A text or config object to apply to the OK button.
   * @returns {Promise} A promise which is resolved when the dialog is closed. The promise yields an Object with
   * a `button` ({@link #property-okButton} or {@link #property-cancelButton}) and a `text` property with the text the
   * user provided
   */
  async prompt({
    textField
  }) {
    const field = this.widgetMap.input;
    Widget.reconfigure(field, textField);
    field.value = "";
    return this.showDialog("prompt", ...arguments);
  }
  showDialog(mode, {
    message = "",
    title = "\xA0",
    cancelButton,
    okButton,
    rootElement = document.body
  }) {
    const me = this;
    me.rootElement = rootElement;
    me.getConfig("lazyItems");
    me.title = me.optionalL(title);
    me.widgetMap.message.html = me.optionalL(message);
    me.showClass = `b-messagedialog-${mode}`;
    if (okButton) {
      okButton = typeof okButton === "string" ? { text: okButton } : okButton;
    }
    if (cancelButton) {
      cancelButton = typeof cancelButton === "string" ? { text: cancelButton } : cancelButton;
    }
    okButton = Object.assign({}, me.widgetMap.okButton.initialConfig, okButton);
    cancelButton = Object.assign({}, me.widgetMap.cancelButton.initialConfig, cancelButton);
    okButton.text = me.optionalL(okButton.text);
    cancelButton.text = me.optionalL(cancelButton.text);
    Widget.reconfigure(me.widgetMap.okButton, okButton);
    Widget.reconfigure(me.widgetMap.cancelButton, cancelButton);
    me.show();
    return me.promise = new Promise((resolve) => {
      me.resolve = resolve;
    });
  }
  show() {
    const activeElement = DomHelper.getActiveElement(this.element);
    this.owner = this.element.contains(activeElement) ? null : _MessageDialogConstructor.fromElement(document.activeElement);
    return super.show(...arguments);
  }
  updateShowClass(showClass, oldShowClass) {
    const { classList } = this.element;
    if (oldShowClass) {
      classList.remove(oldShowClass);
    }
    if (showClass) {
      classList.add(showClass);
    }
  }
  doResolve(value) {
    const me = this, { resolve } = me;
    if (resolve) {
      const isPrompt = me.showClass === "b-messagedialog-prompt";
      if (isPrompt && value === me.okButton && !me.widgetMap.input.isValid) {
        return;
      }
      me.resolve = me.reject = me.promise = null;
      resolve(isPrompt ? { button: value, text: me.widgetMap.input.value } : value);
      me.hide();
    }
  }
  onInternalKeyDown(event) {
    if (event.key === "Escape") {
      event.stopImmediatePropagation();
      this.onCancelClick();
    } else if (event.key === "Enter" && !event.target.closest(".b-button")) {
      event.stopImmediatePropagation();
      event.preventDefault();
      this.onOkClick();
    }
    super.onInternalKeyDown(event);
  }
  onOkClick() {
    this.doResolve(MessageDialog.okButton);
  }
  onCancelClick() {
    this.doResolve(MessageDialog.cancelButton);
  }
};
__publicField(_MessageDialogConstructor, "$name", "MessageDialog");
__publicField(_MessageDialogConstructor, "type", "messagedialog");
var MessageDialogConstructor = _MessageDialogConstructor;
MessageDialogConstructor.initClass();
var MessageDialog = new Proxy({}, {
  get(target, prop) {
    const instance = target.instance || (target.instance = new MessageDialogConstructor({
      rootElement: document.body
    })), result = instance[prop];
    return typeof result === "function" ? result.bind(instance) : result;
  }
});
var MessageDialog_default = MessageDialog;

// ../Core/lib/Core/widget/PagingToolbar.js
var PagingToolbar = class extends Toolbar {
  static get defaultConfig() {
    return {
      /**
       * The {@link Core.data.AjaxStore AjaxStore} that this PagingToolbar is to control.
       * @config {Core.data.AjaxStore}
       */
      store: null,
      defaults: {
        localeClass: this
      },
      items: {
        firstPageButton: {
          onClick: "up.onFirstPageClick",
          icon: "b-icon-first",
          weight: 100,
          tooltip: "L{PagingToolbar.firstPage}"
        },
        previousPageButton: {
          onClick: "up.onPreviousPageClick",
          icon: "b-icon-previous",
          weight: 110,
          tooltip: "L{PagingToolbar.prevPage}"
        },
        pageNumber: {
          type: "numberfield",
          label: "L{page}",
          min: 1,
          max: 1,
          triggers: null,
          onChange: "up.onPageNumberChange",
          highlightExternalChange: false,
          weight: 120
        },
        pageCount: {
          type: "widget",
          cls: "b-pagecount b-toolbar-text",
          weight: 130
        },
        nextPageButton: {
          onClick: "up.onNextPageClick",
          icon: "b-icon-next",
          weight: 140,
          tooltip: "L{PagingToolbar.nextPage}"
        },
        lastPageButton: {
          onClick: "up.onLastPageClick",
          icon: "b-icon-last",
          weight: 150,
          tooltip: "L{PagingToolbar.lastPage}"
        },
        separator: {
          type: "widget",
          cls: "b-toolbar-separator",
          weight: 151
        },
        reloadButton: {
          onClick: "up.onReloadClick",
          icon: "b-icon-reload",
          weight: 160,
          tooltip: "L{PagingToolbar.reload}"
        },
        spacer: {
          type: "widget",
          cls: "b-toolbar-fill",
          weight: 161
        },
        dataSummary: {
          type: "widget",
          cls: "b-toolbar-text",
          weight: 170
        }
      }
    };
  }
  // Retrieve store from grid when "assigned" to it
  set parent(parent) {
    super.parent = parent;
    if (!this.store) {
      this.store = parent.store;
    }
  }
  get parent() {
    return super.parent;
  }
  set store(store) {
    const me = this;
    me.detachListeners("store");
    me._store = store;
    if (store) {
      store.ion({
        name: "store",
        beforerequest: "onStoreBeforeRequest",
        afterrequest: "onStoreChange",
        change: "onStoreChange",
        thisObj: me
      });
      if (store.isLoading) {
        me.onStoreBeforeRequest();
      }
    }
  }
  get store() {
    return this._store;
  }
  onStoreBeforeRequest() {
    this.eachWidget((w) => w.disable());
  }
  updateLocalization() {
    this.updateSummary();
    super.updateLocalization();
  }
  updateSummary() {
    const me = this, { pageCount, dataSummary } = me.widgetMap;
    let count = 0, lastPage = 0, start = 0, end = 0, allCount = 0;
    if (me.store) {
      const { store } = me, { pageSize, currentPage } = store;
      count = store.count;
      lastPage = store.lastPage;
      allCount = store.allCount;
      start = Math.max(0, (currentPage - 1) * pageSize + 1);
      end = Math.min(allCount, start + pageSize - 1);
    }
    pageCount.html = me.L("L{pageCountTemplate}")({ lastPage });
    dataSummary.html = count ? me.L("L{summaryTemplate}")({ start, end, allCount }) : me.L("L{noRecords}");
  }
  onStoreChange() {
    const me = this, { widgetMap, store } = me, { count, lastPage, currentPage } = store, {
      pageNumber,
      pageCount,
      firstPageButton,
      previousPageButton,
      nextPageButton,
      lastPageButton,
      dataSummary
    } = widgetMap;
    me.eachWidget((w) => w.enable());
    pageNumber.value = currentPage;
    pageNumber.max = lastPage;
    dataSummary.disabled = pageNumber.disabled = pageCount.disabled = !count;
    firstPageButton.disabled = previousPageButton.disabled = currentPage <= 1 || !count;
    nextPageButton.disabled = lastPageButton.disabled = currentPage >= lastPage || !count;
    me.updateSummary();
  }
  onPageNumberChange({ value }) {
    if (this.store.currentPage !== value) {
      this.store.loadPage(value);
    }
  }
  onFirstPageClick() {
    this.store.loadPage(1);
  }
  onPreviousPageClick() {
    this.store.previousPage();
  }
  onNextPageClick() {
    this.store.nextPage();
  }
  onLastPageClick() {
    this.store.loadPage(this.store.lastPage);
  }
  onReloadClick() {
    this.store.loadPage(this.store.currentPage);
  }
};
__publicField(PagingToolbar, "$name", "PagingToolbar");
__publicField(PagingToolbar, "type", "pagingtoolbar");
PagingToolbar.initClass();
PagingToolbar._$name = "PagingToolbar";

// ../Core/lib/Core/widget/panel/PanelCollapserOverlay.js
var { dockIsHorz: dockIsHorz2 } = PanelCollapser.maps;
var collapseExposeEdge = {
  top: 0,
  down: 0,
  left: 1,
  bottom: 2,
  up: 2,
  right: 3
};
var translateByDir = {
  up: {
    from: `translate(0,0)`,
    to: "translate(0,-100%)"
  },
  down: {
    from: `translate(0,0)`,
    to: "translate(0,100%)"
  },
  left: {
    from: `translate(0,0)`,
    to: "translate(-100%,0)"
  },
  right: {
    from: `translate(0,0)`,
    to: "translate(100%,0)"
  }
};
var PanelCollapserOverlay = class extends PanelCollapser.mixin(Delayable_default) {
  static get configurable() {
    return {
      /**
       * The number of milliseconds to wait once the mouse leaves a {@link Core.widget.Panel#config-revealed}
       * panel before returning to an unrevealed state. Clicking outside the revealed panel will immediately
       * return the panel to its collapsed state.
       *
       * This may be disabled by configuring {@link #config-autoClose} as `null`.
       *
       * If this value is negative, the panel will not automatically recollapse due to the mouse leaving, however,
       * clicks outside the panel will still recollapse it.
       *
       * If this value is `null`, the panel will not automatically recollapse for either outside clicks or if
       * the mouse leaves the panel.
       * @config {Number}
       * @default
       */
      autoCloseDelay: 1e3,
      /**
       * By default, clicking outside the revealed overlay hides the revealed overlay.
       *
       * If the revealed overlay was shown using the {@link #property-recollapseTool}
       * then moving the mouse outside of the revealed overlay hides the revealed overlay.
       *
       * Configure this as `false` to disable auto hiding, making overlayed
       * state permanent, and changeable using the {@link #function-toggleReveal} method.
       * @config {Boolean}
       * @default
       */
      autoClose: true,
      revealing: {
        value: null,
        $config: null,
        default: false
      },
      /**
       * The reveal/hide tool which slides the collapsed panel over the top of the UI.
       * @member {Core.widget.Tool} recollapseTool
       */
      /**
       * The reveal/hide tool which slides the collapsed panel over the top of the UI.
       *
       * The `type` of this instance should not be changed but the tool instance can be
       * configured in other ways via this config property.
       * @config {ToolConfig|Core.widget.Tool}
       */
      recollapseTool: {
        type: "collapsetool",
        cls: "b-recollapse",
        collapsify: "overlay",
        handler() {
          var _a2;
          (_a2 = this.collapsible) == null ? void 0 : _a2.toggleReveal();
        }
      }
    };
  }
  static get delayable() {
    return {
      doAutoClose: 0
    };
  }
  doAutoClose() {
    this.toggleReveal(false);
  }
  updateAutoCloseDelay(delay2) {
    const { doAutoClose } = this;
    if (!(doAutoClose.suspended = delay2 == null || delay2 < 0)) {
      doAutoClose.delay = delay2;
      doAutoClose.immediate = !delay2;
    }
  }
  changeRecollapseTool(tool) {
    const me = this, { panel } = me;
    if (me.isConfiguring || me.isDestroying || !panel || panel.isDestroying) {
      return tool;
    }
    panel.tools = {
      recollapse: tool
    };
  }
  beforeCollapse(operation) {
    if (super.beforeCollapse(operation) === false) {
      return false;
    }
    if (this.panel.revealed) {
      operation.animation = null;
    }
  }
  applyHeaderDock(collapsed, flush = true) {
    var _a2;
    (_a2 = this.panel) == null ? void 0 : _a2.recompose();
    super.applyHeaderDock(collapsed, flush);
  }
  collapseBegin(operation) {
    const me = this, { collapseDir, innerElement } = me, { animation } = operation, { collapseTool, panel } = me;
    me.configuredWidth = panel._lastWidth;
    me.configuredHeight = panel._lastHeight;
    me.applyHeaderDock(true);
    me.lockInnerSize();
    collapseTool == null ? void 0 : collapseTool.element.classList.add("b-collapsed");
    if (animation) {
      panel.element.classList.add("b-collapsing");
      animation.element = innerElement;
      animation.transform = translateByDir[collapseDir];
      operation.animation = Animator.run(animation);
    }
  }
  onComplete(action) {
    var _a2, _b;
    super.onComplete(action);
    const me = this, { panel } = me, { element } = panel;
    me.autoCloseLeaveDetacher = (_a2 = me.autoCloseLeaveDetacher) == null ? void 0 : _a2.call(me);
    me.autoCloseClickDetacher = (_b = me.autoCloseClickDetacher) == null ? void 0 : _b.call(me);
    me.doAutoClose.cancel();
    if (action === "reveal" && me.autoClose) {
      if (panel.containsFocus) {
        me.autoCloseLeaveDetacher = EventHelper.on({
          element,
          mouseenter: (ev) => {
            me.doAutoClose.cancel();
          },
          mouseleave: (ev) => {
            me.doAutoClose();
          }
        });
      }
      me.autoCloseClickDetacher = EventHelper.on({
        element: document.body,
        thisObj: panel,
        mousedown: (ev) => {
          var _a3;
          if (!panel.owns(ev) && !((_a3 = me.revealer) == null ? void 0 : _a3.contains(ev.target)) && me.autoCloseDelay != null) {
            me.doAutoClose.now();
          }
        }
      });
    }
  }
  expandBegin(operation) {
    const me = this, { animation } = operation, { collapseDir, collapseTool, innerElement, panel } = me, { element } = panel;
    element.classList.remove("b-collapsed", "b-collapsing");
    me.restoreConfiguredSize();
    me.lockInnerSize(false);
    me.lockInnerSize();
    collapseTool == null ? void 0 : collapseTool.element.classList.remove("b-collapsed");
    if (animation) {
      element.classList.add("b-collapsed", "b-expanding");
      animation.element = innerElement;
      animation.transform = {
        from: translateByDir[collapseDir].to,
        to: translateByDir[collapseDir].from
      };
      operation.animation = Animator.run(animation);
    }
  }
  expandEnd(operation) {
    super.expandEnd(operation);
    const { panel } = this;
    if (operation.completed) {
      panel.revealed = false;
    }
    panel.element.classList.remove("b-expanding");
  }
  expandRevert(operation) {
    super.expandRevert(operation);
    this.panel.element.classList.add("b-expanding");
  }
  get innerElement() {
    return this.panel.overlayElement;
  }
  get innerSizeElement() {
    return this.panel.element;
  }
  get toolsConfig() {
    const me = this, { direction } = me, config = super.toolsConfig, tool = me.recollapseTool;
    if (tool) {
      return {
        ...config,
        recollapse: tool && ObjectHelper.assign({
          direction: direction.toLowerCase()
        }, tool)
      };
    }
    return config;
  }
  lockInnerSize(lock = true) {
    const me = this, { panel } = me, panelRect = lock && panel.rectangle(), inset = lock ? [0, 0, 0, 0] : "", innerRect = super.lockInnerSize(lock);
    if (lock) {
      inset[collapseExposeEdge[me.collapseDir]] = `-${panelRect[me.collapseDim] + 10}px`;
    }
    panel.element.style.clipPath = lock ? `inset(${inset.join(" ")})` : "";
    return innerRect;
  }
  onOverlayTransitionDone(ev) {
    const me = this, { panel } = me;
    if (ev.srcElement === panel.overlayElement && me.revealing) {
      me.revealing = false;
      me.onComplete(panel.revealed ? "reveal" : "unreveal");
    }
  }
  onRevealerClick() {
    this.toggleReveal();
  }
  /**
   * Toggles the revealed state of the Panel to match the passed boolean flag.
   * @param {Boolean} [state]  If not specified, this method toggles current state. Otherwise, pass `true` to reveal
   * the overlay, or `false` to hide it.
   */
  toggleReveal(state) {
    const { panel } = this, { element } = panel;
    if (panel.collapsed) {
      this.revealer = DomHelper.getActiveElement(element);
      if (state == null) {
        state = !panel.revealed;
      }
      if (panel.revealed !== state && panel.trigger("beforeToggleReveal", { reveal: state }) !== false) {
        if (!state && element.contains(this.revealer)) {
          panel.revertFocus(true);
        }
        this.revealing = true;
        panel.revealed = state;
      }
    }
  }
  updateRevealing(value) {
    const me = this, horzDirRe = /left|right/i, { panel } = me, dim = horzDirRe.test(me.collapseDir) ? "height" : "width";
    if (panel) {
      me.innerElement.style[dim] = "0px";
      me.innerElement.style[`min-${dim}`] = "100%";
      panel.element.classList[value ? "add" : "remove"]("b-panel-overlay-revealing");
    }
  }
  wrapCollapser(key, body) {
    var _a2;
    const me = this, { collapseDir, panel } = me, { expandedHeaderDock, header, uiClassList } = panel, recollapse = (_a2 = panel.tools) == null ? void 0 : _a2.recollapse, [before, after] = me.splitHeaderItems({ as: "element", dock: me.collapseDock }), horz = dockIsHorz2[expandedHeaderDock], title = panel.hasHeader ? panel.title || (header == null ? void 0 : header.title) || "\xA0" : null;
    if (recollapse) {
      recollapse.direction = collapseDir;
    }
    return [
      "overlayElement",
      {
        class: {
          ...uiClassList,
          [`b-panel-overlay-header-${expandedHeaderDock}`]: 1,
          [`b-panel-overlay-${collapseDir}`]: 1,
          [`b-${horz ? "h" : "v"}box`]: 1,
          "b-panel-overlay": 1,
          "b-box-center": 1
        },
        // internalListeners is not correct for element listeners in domConfigs
        listeners: {
          // eslint-disable-line bryntum/no-listeners-in-lib
          transitionend: (ev) => me.onOverlayTransitionDone(ev),
          transitioncancel: (ev) => me.onOverlayTransitionDone(ev)
        },
        children: {
          overlayHeaderElement: title && {
            tag: "header",
            class: new DomClassList({
              ...uiClassList,
              [`b-dock-${expandedHeaderDock}`]: 1,
              "b-panel-header": 1,
              "b-panel-overlay-header": 1
            }, header == null ? void 0 : header.cls),
            children: [
              ...before,
              {
                reference: "overlayTitleElement",
                html: title,
                class: {
                  ...uiClassList,
                  [`b-align-${(header == null ? void 0 : header.titleAlign) || "start"}`]: 1,
                  "b-header-title": 1
                }
              },
              ...after
            ]
          },
          [key]: body
        }
      }
    ];
  }
};
__publicField(PanelCollapserOverlay, "$name", "PanelCollapserOverlay");
__publicField(PanelCollapserOverlay, "type", "overlay");
PanelCollapserOverlay.initClass();
PanelCollapserOverlay._$name = "PanelCollapserOverlay";

// ../Core/lib/Core/widget/PasswordField.js
var PasswordField = class extends Field {
  construct(config = {}) {
    config.inputType = "password";
    super.construct(...arguments);
    this.element.classList.add("b-textfield");
  }
};
__publicField(PasswordField, "$name", "PasswordField");
__publicField(PasswordField, "type", "passwordfield");
__publicField(PasswordField, "alias", "password");
PasswordField.initClass();
PasswordField._$name = "PasswordField";

// ../Core/lib/Core/widget/Radio.js
var Radio = class extends Checkbox {
  static get configurable() {
    return {
      inputType: "radio",
      /**
       * Set this to `true` so that clicking a checked radio button will clear its checked state.
       * @config {Boolean}
       * @default false
       */
      clearable: null,
      uncheckedValue: void 0
      // won't store to Container#values when unchecked
    };
  }
  //endregion
  //region Init
  get textLabelCls() {
    return super.textLabelCls + " b-radio-label";
  }
  //endregion
  internalOnClick(info) {
    if (super.internalOnClick(info) !== false) {
      if (this.checked && this.clearable) {
        this.checked = false;
      }
    }
  }
  updateName(name) {
    this.toggleGroup = name;
  }
  // Empty override to get rid of clear trigger
  updateClearable() {
  }
};
//region Config
__publicField(Radio, "$name", "Radio");
__publicField(Radio, "type", "radio");
__publicField(Radio, "alias", "radiobutton");
Radio.initClass();
Radio._$name = "Radio";

// ../Core/lib/Core/widget/RadioGroup.js
var RadioGroup = class extends FieldSet {
  static get configurable() {
    return {
      defaultType: "radio",
      /**
       * Set this to `true` so that clicking the currently checked radio button will clear the check from all
       * radio buttons in the group.
       * @config {Boolean}
       * @default false
       */
      clearable: null,
      /**
       * The name by which this widget's {@link #property-value} is accessed using the parent container's
       * {@link Core.widget.Container#property-values}.
       *
       * The config must be provided as it is used to set the {@link Core.widget.Radio#config-name} of the
       * child {@link Core.widget.Radio radio buttons}.
       * @config {String}
       */
      name: null,
      /**
       * The set of radio button options for this radio button group. This is a shorthand for defining these in
       * the {@link Core.widget.Container#config-items}. The keys of this object hold the radio button's
       * {@link Core.widget.Radio#config-checkedValue} while the object values are a string for the radio button's
       * {@link Core.widget.Radio#config-text} or a config object for that radio button.
       *
       * The {@link #property-value} of this radio button group will be one of the keys in this object or `null`
       * if no radio button is checked.
       *
       * For example, consider the following configuration:
       * ```javascript
       *  {
       *      type    : 'radiogroup',
       *      name    : 'resolution',
       *      value   : 'A',
       *      options : {
       *          A : 'Keep the original version',
       *          B : 'Use the new version',
       *          C : 'Reconcile individual conflicts'
       *      }
       *  }
       * ```
       *
       * The above is equivalent to this configuration below using {@link #config-items}:
       * ```javascript
       *  {
       *      type  : 'radiogroup',
       *      items : [{
       *          text         : 'Keep the original version',
       *          name         : 'resolution',
       *          ref          : 'resolution_A',
       *          checked      : true,
       *          checkedValue : 'A'
       *      }, {
       *          text         : 'Use the new version',
       *          name         : 'resolution',
       *          ref          : 'resolution_B',
       *          checkedValue : 'B'
       *      }, {
       *          text         : 'Reconcile individual conflicts',
       *          name         : 'resolution',
       *          ref          : 'resolution_C',
       *          checkedValue : 'C'
       *      }]
       *  }
       * ```
       * @config {Object<String,String|RadioConfig>} options
       */
      options: {
        value: null,
        $config: {
          merge: "items"
        }
      },
      defaultBindProperty: "value"
    };
  }
  get existingOptions() {
    const { name } = this;
    return this.ensureItems().filter((c) => c.name === name);
  }
  get refPrefix() {
    return `${this.name || this.ref || this.id}_`;
  }
  get selected() {
    return this.existingOptions.filter((c) => c.input.checked)[0] || null;
  }
  /**
   * This property corresponds to the {@link Core.widget.Radio#config-checkedValue} of the currently
   * {@link Core.widget.Radio#property-checked} radio button.
   * @property {String}
   */
  get value() {
    const { selected } = this;
    return selected ? selected.checkedValue : null;
  }
  set value(v) {
    this.existingOptions.forEach((c) => {
      c.isConfiguring = this.isConfiguring;
      c.checked = c.checkedValue === v;
      c.isConfiguring = false;
    });
  }
  ensureItems() {
    this.getConfig("options");
    return super.ensureItems();
  }
  changeOptions(options, was) {
    if (!(options && was && ObjectHelper.isDeeplyEqual(was, options))) {
      return options;
    }
  }
  convertOption(key, option, existing) {
    const me = this, { name } = me, ret = {
      name,
      type: "radio",
      value: key === me.value,
      ref: `${me.refPrefix}${key}`,
      checkedValue: key
    };
    if (typeof option === "string") {
      ret.text = option;
    } else {
      ObjectHelper.assign(ret, option);
    }
    return existing ? Widget.reconfigure(existing, ret) : ret;
  }
  isOurRadio(item) {
    return item.isRadio && item.name === this.name;
  }
  isolateFieldChange(field) {
    return this.isOurRadio(field);
  }
  onChildAdd(item) {
    super.onChildAdd(item);
    if (this.isOurRadio(item)) {
      item.ion({
        name: item.id,
        beforeChange: "onRadioItemBeforeChange",
        change: "onRadioItemChange",
        click: "onRadioClick",
        thisObj: this
      });
    }
  }
  onChildRemove(item) {
    if (this.isOurRadio(item)) {
      this.detachListeners(item.id);
    }
    super.onChildRemove(item);
  }
  onRadioClick(ev) {
    const { source } = ev;
    if (source.checked && this.clearable && source.clearable == null) {
      source.checked = false;
    }
  }
  onRadioItemBeforeChange(ev) {
    if (ev.checked) {
      const me = this, { lastValue } = me;
      if (!me.reverting && me.trigger("beforeChange", me.wrapRadioEvent(ev)) === false) {
        if (lastValue != null && lastValue !== me.value) {
          me.reverting = true;
          ev.source.uncheckToggleGroupMembers();
          me.value = lastValue;
          me.lastValue = lastValue;
          me.reverting = false;
          return false;
        }
      }
    }
  }
  onRadioItemChange(ev) {
    const me = this;
    if (ev.checked && !me.reverting) {
      me.triggerFieldChange(me.wrapRadioEvent(ev));
      me.lastValue = me.value;
    }
  }
  wrapRadioEvent(ev) {
    return {
      from: ev,
      item: ev.source,
      userAction: ev.userAction,
      lastValue: this.lastValue,
      value: this.value
    };
  }
  updateOptions() {
    const me = this, { options, refPrefix } = me, existingOptions = me.existingOptions.reduce((m, c) => {
      m[c.ref.substring(refPrefix.length)] = c;
      return m;
    }, {});
    let index = 0, key, option;
    if (options) {
      for (key in options) {
        option = me.convertOption(key, options[key], existingOptions[key]);
        delete existingOptions[key];
        me.insert(option, index++);
      }
    }
    const existing = Object.values(existingOptions);
    if (existing == null ? void 0 : existing.length) {
      me.remove(existing);
      existing.forEach((c) => c.destroy());
    }
  }
  //endregion
};
//region Config
__publicField(RadioGroup, "$name", "RadioGroup");
__publicField(RadioGroup, "type", "radiogroup");
RadioGroup.initClass();
RadioGroup._$name = "RadioGroup";

// ../Core/lib/Core/widget/Slider.js
var arrowKeys = {
  ArrowUp: 1,
  ArrowDown: 1,
  ArrowLeft: 1,
  ArrowRight: 1
};
var Slider = class extends Widget {
  static get configurable() {
    return {
      /**
       * Get input element.
       * @readonly
       * @member {HTMLInputElement} input
       */
      /**
       * Get/set text. Appends value if Slider.showValue is true
       * @member {String} text
       */
      /**
       * Slider label text
       * @config {String}
       */
      text: null,
      /**
       * Show value in label (appends in () if text is set)
       * @config {Boolean}
       * @default
       */
      showValue: true,
      /**
       * Show the slider value in a tooltip
       * @config {Boolean}
       * @default
       */
      showTooltip: false,
      /**
       * Get/set min value
       * @member {Number} min
       */
      /**
       * Minimum value
       * @config {Number}
       * @default
       */
      min: 0,
      /**
       * Get/set max value
       * @member {Number} max
       */
      /**
       * Maximum value
       * @config {Number}
       * @default
       */
      max: 100,
      /**
       * Get/set step size
       * @member {Number} step
       */
      /**
       * Step size
       * @config {Number}
       * @default
       */
      step: 1,
      /**
       * Get/set value
       * @member {Number} value
       */
      /**
       * Initial value
       * @config {Number}
       */
      value: 50,
      /**
       * Unit to display next to the value, when configured with `showValue : true`
       * @config {String}
       * @default
       */
      unit: null,
      // The value is set in the Light theme. The Material theme will have different value.
      thumbSize: 20,
      /**
       * A config object for the tooltip to show while hovering the slider.
       * @config {TooltipConfig}
       */
      tooltip: {
        $config: ["lazy", "nullify"],
        value: {
          type: "tooltip",
          align: "b-t",
          anchor: false,
          // No anchor displayed since thumbSize is different for different themes
          axisLock: true
        }
      },
      localizableProperties: ["text"],
      /**
       * By default, the {@link #event-change} event is fired when a change gesture is completed, ie: on
       * the mouse up gesture of a drag.
       *
       * Configure this as `true` to fire the {@link #event-change} event as the value changes *during* a drag.
       * @prp {Boolean}
       */
      triggerChangeOnInput: null,
      defaultBindProperty: "value"
    };
  }
  //endregion
  //region Init
  compose() {
    const { id, min: min2, max, showValue, step, text, value, unit = "", disabled } = this, inputId = `${id}-input`, hasText = Boolean(text || showValue);
    return {
      class: {
        "b-has-label": hasText,
        "b-text": hasText,
        "b-disabled": disabled
      },
      children: {
        input: {
          tag: "input",
          type: "range",
          id: inputId,
          reference: "input",
          [disabled ? "disabled" : ""]: disabled,
          min: min2,
          max,
          step,
          value,
          // eslint-disable-next-line bryntum/no-listeners-in-lib
          listeners: {
            input: "onInternalInput",
            change: "onInternalChange",
            mouseover: "onInternalMouseOver",
            mouseout: "onInternalMouseOut"
          }
        },
        label: {
          tag: "label",
          for: inputId,
          html: showValue ? text ? `${text} (${value}${unit})` : value + unit : text
        }
      }
    };
  }
  get focusElement() {
    return this.input;
  }
  get percentProgress() {
    return (this.value - this.min) / (this.max - this.min) * 100;
  }
  //endregion
  //region Events
  /**
   * Fired while slider thumb is being dragged.
   * @event input
   * @param {Core.widget.Slider} source The slider
   * @param {Number} value The value
   */
  /**
   * Fired after the slider value changes (on mouse up following slider interaction).
   * @event change
   * @param {Number} value The value
   * @param {Boolean} userAction Triggered by user taking an action (`true`) or by setting a value (`false`)
   * @param {Core.widget.Slider} source The slider
   */
  /* break from doc comment */
  onInternalKeyDown(e) {
    if (!this.readOnly && arrowKeys[e.key]) {
      e.stopImmediatePropagation();
    }
  }
  onInternalChange() {
    this.updateUI();
    this.triggerChange(true);
    this.trigger("action", { value: this.value });
  }
  onInternalInput() {
    const me = this;
    if (me.readOnly) {
      me.input.value = me.value;
      return;
    }
    me.value = parseInt(me.input.value, 10);
    me.trigger("input", { value: me.value });
    if (me.triggerChangeOnInput) {
      me.triggerChange(me);
    }
  }
  onInternalMouseOver() {
    var _a2;
    const me = this, thumbPosition = me.rtl ? 100 - me.percentProgress : me.percentProgress;
    (_a2 = me.tooltip) == null ? void 0 : _a2.showBy({
      target: Rectangle.from(me.input).inflate(me.thumbSize / 2, -me.thumbSize / 2),
      align: `b-t${Math.round(thumbPosition)}`
    });
  }
  onInternalMouseOut() {
    var _a2;
    (_a2 = this.tooltip) == null ? void 0 : _a2.hide();
  }
  triggerChange(userAction) {
    this.triggerFieldChange({
      value: this.value,
      valid: true,
      userAction
    });
  }
  //endregion
  //region Config Handling
  // max
  updateMax(max) {
    const me = this;
    if (me.input && me._value > max) {
      me.value = max;
      me.trigger("input", { value: me.value });
    }
  }
  // min
  updateMin(min2) {
    const me = this;
    if (me.input && me._value < min2) {
      me.value = min2;
      me.trigger("input", { value: me.value });
    }
  }
  // tooltip
  changeTooltip(config, existingTooltip) {
    var _a2;
    if (config) {
      config.owner = this;
    }
    return this.showTooltip ? Tooltip.reconfigure(existingTooltip, config, {
      owner: this,
      defaults: {
        forElement: this.input,
        html: String(this.value) + ((_a2 = this.unit) != null ? _a2 : "")
      }
    }) : null;
  }
  changeValue(value) {
    const me = this, { min: min2, step } = me;
    value = Math.min(Math.max(value, min2), me.max);
    if (value > min2) {
      return min2 + ObjectHelper.roundTo(value - min2, step);
    }
    return ObjectHelper.roundTo(value, step);
  }
  updateValue(value) {
    var _a2;
    const me = this, { input, _tooltip } = me;
    if (_tooltip) {
      _tooltip.html = me.value + ((_a2 = me.unit) != null ? _a2 : "");
    }
    if (input && input.value !== String(value)) {
      input.value = value;
      me.triggerChange(false);
    }
    me.updateUI();
  }
  //endregion
  //region Util
  updateUI() {
    var _a2, _b;
    const me = this;
    ((_a2 = me._tooltip) == null ? void 0 : _a2.isVisible) && ((_b = me._tooltip) == null ? void 0 : _b.alignTo({
      target: Rectangle.from(me.input).inflate(me.thumbSize / 2, -me.thumbSize / 2),
      align: `b-t${Math.round(me.percentProgress)}`
    }));
  }
  //endregion
};
//region Config
__publicField(Slider, "$name", "Slider");
__publicField(Slider, "type", "slider");
Slider.initClass();
Slider._$name = "Slider";

// ../Core/lib/Core/widget/SlideToggle.js
var SlideToggle = class extends Checkbox {
  static get properties() {
    return {
      toggledCls: "b-slidetoggle-checked"
    };
  }
  construct(config) {
    if (config.checked) {
      config.cls = DomClassList.from(config.cls) || {};
      config.cls[this.constructor.properties.toggledCls] = 1;
    }
    super.construct(config);
  }
  get innerElements() {
    const innerEls = super.innerElements;
    innerEls.splice(1, 0, this.toggleElement);
    if (this.text) {
      innerEls[innerEls.length - 1].class = "b-slidetoggle-label";
    } else {
      innerEls.pop();
    }
    return innerEls;
  }
  get toggleElement() {
    return {
      class: "b-slidetoggle-toggle",
      reference: "slideToggle",
      children: [
        {
          class: "b-slidetoggle-thumb",
          reference: "slideThumb"
        }
      ]
    };
  }
  internalOnChange() {
    super.internalOnChange();
    this.element.classList[this.value ? "add" : "remove"](this.toggledCls);
  }
};
__publicField(SlideToggle, "$name", "SlideToggle");
__publicField(SlideToggle, "type", "slidetoggle");
SlideToggle.initClass();
SlideToggle._$name = "SlideToggle";

// ../Core/lib/Core/widget/Splitter.js
var classesHV = ["b-horizontal", "b-vertical"];
var hasFlex = (el) => DomHelper.getStyleValue(el.parentElement, "display") === "flex" && (parseInt(DomHelper.getStyleValue(el, "flex-basis"), 10) || parseInt(DomHelper.getStyleValue(el, "flex-grow"), 10));
var verticality = {
  horizontal: false,
  vertical: true
};
var Splitter = class extends Widget {
  static get configurable() {
    return {
      /**
       * Fired when a drag starts
       * @event dragStart
       * @param {Core.widget.Splitter} source The Splitter
       * @param {MouseEvent|TouchEvent} event The DOM event
       */
      /**
       * Fired while dragging
       * @event drag
       * @param {Core.widget.Splitter} source The Splitter
       * @param {MouseEvent|TouchEvent} event The DOM event
       */
      /**
       * Fired after a drop
       * @event drop
       * @param {Core.widget.Splitter} source The Splitter
       * @param {MouseEvent|TouchEvent} event The DOM event
       */
      /**
       * Splitter orientation, see {@link #config-orientation}. When set to 'auto' then actually used orientation
       * can be retrieved using {@link #property-currentOrientation}.
       * @member {'auto'|'horizontal'|'vertical'} orientation
       * @readonly
       */
      /**
       * The splitter's orientation, configurable with 'auto', 'horizontal' or 'vertical'.
       *
       * 'auto' tries to determine the orientation by either checking the `flex-direction` of the parent element
       * or by comparing the positions of the closest sibling elements to the splitter. If they are above and
       * below 'horizontal' is used, if not it uses 'vertical'.
       *
       * ```
       * new Splitter({
       *    orientation : 'horizontal'
       * });
       * ```
       *
       * To receive the actually used orientation when configured with 'auto', see
       * {@link #property-currentOrientation}.
       *
       * @config {'auto'|'horizontal'|'vertical'}
       * @default
       */
      orientation: "auto",
      vertical: null,
      containerElement: {
        $config: "nullify",
        value: null
      },
      nextNeighbor: {
        $config: "nullify",
        value: null
      },
      previousNeighbor: {
        $config: "nullify",
        value: null
      }
    };
  }
  static get delayable() {
    return {
      syncState: "raf"
    };
  }
  //endregion
  //region Init & destroy
  doDestroy() {
    var _a2;
    (_a2 = this.mouseDetacher) == null ? void 0 : _a2.call(this);
    super.doDestroy();
  }
  //endregion
  //region Template & element
  compose() {
    return {
      class: {
        "b-splitter": 1
      },
      // eslint-disable-next-line bryntum/no-listeners-in-lib
      listeners: {
        pointerdown: "onMouseDown",
        mouseenter: "syncState",
        ...!BrowserHelper.supportsPointerEvents && {
          mousedown: "onMouseDown",
          touchstart: "onMouseDown"
        }
      }
    };
  }
  //endregion
  //region Orientation
  /**
   * Get actually used orientation, which is either the configured value for `orientation` or if configured with
   * 'auto' the currently used orientation.
   * @property {String}
   * @readonly
   */
  get currentOrientation() {
    return this.vertical ? "vertical" : "horizontal";
  }
  getSibling(next = true) {
    let { element } = this, result;
    while (!result && (element = element[`${next ? "next" : "previous"}ElementSibling`])) {
      if (!element.isConnected || DomHelper.isVisible(element)) {
        result = element;
      }
    }
    return result;
  }
  get nextWidget() {
    let { element } = this, result;
    while (!result && (element = element.nextElementSibling)) {
      result = Widget.fromElement(element, this.element.parentElement);
    }
    return result;
  }
  get previousWidget() {
    let { element } = this, result;
    while (!result && (element = element.previousElementSibling)) {
      result = Widget.fromElement(element, this.element.parentElement);
    }
    return result;
  }
  updateContainerElement(containerElement) {
    var _a2;
    const me = this;
    me.stateDetector = (_a2 = me.stateDetector) == null ? void 0 : _a2.disconnect();
    if (containerElement) {
      me.stateDetector = new MutationObserver(() => me.syncState());
      me.stateDetector.observe(containerElement, {
        attributes: true,
        // in case style changes flip our orientation (when == 'auto')
        childList: true
        // watch for our neighbors to render (so we can disable on hidden/collapsed state)
      });
    }
  }
  updateNextNeighbor(next) {
    this.watchNeighbor(next, "next");
  }
  updatePreviousNeighbor(previous) {
    this.watchNeighbor(previous, "previous");
  }
  watchNeighbor(neighbor, name) {
    this.detachListeners(name);
    neighbor == null ? void 0 : neighbor.ion({
      name,
      thisObj: this,
      collapse: "syncState",
      expand: "syncState",
      hide: "syncState",
      show: "syncState"
    });
  }
  updateOrientation() {
    this.syncState.now();
  }
  updateVertical(vertical) {
    var _a2;
    const classList = (_a2 = this.element) == null ? void 0 : _a2.classList;
    classList == null ? void 0 : classList.add(classesHV[vertical ? 1 : 0]);
    classList == null ? void 0 : classList.remove(classesHV[vertical ? 0 : 1]);
  }
  /**
   * Determine orientation when set to `'auto'` and detects neighboring widgets to monitor their hidden/collapsed
   * states.
   * @private
   */
  syncState() {
    var _a2;
    const me = this, { element, nextWidget, previousWidget } = me;
    let vertical = (_a2 = verticality[me.orientation]) != null ? _a2 : null;
    me.nextNeighbor = nextWidget;
    me.previousNeighbor = previousWidget;
    me.disabled = nextWidget && (nextWidget.collapsible && nextWidget.collapsed || nextWidget.hidden) || previousWidget && (previousWidget.collapsible && previousWidget.collapsed || previousWidget.hidden);
    if (vertical !== null && nextWidget && previousWidget) {
      me.containerElement = null;
    } else {
      me.containerElement = element.parentElement;
      if (me.rendered && element.offsetParent) {
        const flexDirection = DomHelper.getStyleValue(element.parentElement, "flex-direction");
        if (flexDirection) {
          vertical = !flexDirection.startsWith("column");
        } else {
          const previous = element.previousElementSibling, next = element.nextElementSibling;
          if (!previous || !next) {
            return;
          }
          const prevRect = previous.getBoundingClientRect(), nextRect = next.getBoundingClientRect(), topMost = prevRect.top < nextRect.top ? prevRect : nextRect, bottomMost = topMost === nextRect ? prevRect : nextRect;
          vertical = topMost.top === bottomMost.top;
        }
      }
    }
    me.vertical = vertical;
  }
  //endregion
  //region Events
  onMouseDown(event) {
    var _a2;
    event.preventDefault();
    if (event.touches) {
      event = event.touches[0];
    }
    const me = this, {
      element,
      nextNeighbor,
      previousNeighbor
    } = me, prev = previousNeighbor ? previousNeighbor.element : me.getSibling(false), next = nextNeighbor ? nextNeighbor.element : me.getSibling(), prevHasFlex = hasFlex(prev), nextHasFlex = hasFlex(next), flexed = [];
    (_a2 = me.mouseDetacher) == null ? void 0 : _a2.call(me);
    for (const child of element.parentElement.children) {
      if (hasFlex(child) && child !== element) {
        flexed.push({
          element: child,
          width: child.offsetWidth,
          height: child.offsetHeight
        });
      }
    }
    me.context = {
      startX: event.pageX,
      startY: event.pageY,
      prevWidth: prev.offsetWidth,
      prevHeight: prev.offsetHeight,
      nextWidth: next.offsetWidth,
      nextHeight: next.offsetHeight,
      prevHasFlex,
      nextHasFlex,
      flexed,
      prev,
      next
    };
    const events = {
      element: document,
      pointermove: "onMouseMove",
      pointerup: "onMouseUp",
      thisObj: me
    };
    if (!BrowserHelper.supportsPointerEvents) {
      events.mousemove = events.touchmove = "onMouseMove";
      events.mouseup = events.touchend = "onMouseUp";
    }
    element.classList.add("b-moving");
    me.mouseDetacher = EventHelper.on(events);
    me.trigger("splitterMouseDown", { event });
  }
  onMouseMove(event) {
    const me = this, {
      context,
      nextWidget,
      previousWidget
    } = me, prevStyle = context.prev.style, nextStyle = context.next.style, deltaX = (event.pageX - context.startX) * (me.rtl ? -1 : 1), deltaY = event.pageY - context.startY;
    event.preventDefault();
    Object.assign(context, {
      deltaX,
      deltaY
    });
    if (!context.started) {
      context.started = true;
      me.trigger("dragStart", { context, event });
      context.flexed.forEach((flexed) => {
        flexed.element.style.flexGrow = me.vertical ? flexed.width : flexed.height;
        flexed.element.style.flexBasis = "0";
      });
    }
    if (me.vertical) {
      const newPrevWidth = context.prevWidth + deltaX, newNextWidth = context.nextWidth - deltaX;
      if (context.prevHasFlex) {
        prevStyle.flexGrow = newPrevWidth;
      } else if (previousWidget) {
        previousWidget.width = newPrevWidth;
      } else {
        prevStyle.width = `${newPrevWidth}px`;
      }
      if (context.nextHasFlex) {
        nextStyle.flexGrow = newNextWidth;
      } else if (nextWidget) {
        nextWidget.width = newNextWidth;
      } else {
        nextStyle.width = `${newNextWidth}px`;
      }
    } else {
      const newPrevHeight = context.prevHeight + deltaY, newNextHeight = context.nextHeight - deltaY;
      if (context.prevHasFlex) {
        prevStyle.flexGrow = newPrevHeight;
      } else if (previousWidget) {
        previousWidget.height = newPrevHeight;
      } else {
        prevStyle.height = `${newPrevHeight}px`;
      }
      if (context.nextHasFlex) {
        nextStyle.flexGrow = newNextHeight;
      } else if (nextWidget) {
        nextWidget.height = newNextHeight;
      } else {
        nextStyle.height = `${newNextHeight}px`;
      }
    }
    me.trigger("drag", { context, event });
  }
  onMouseUp(event) {
    var _a2;
    const me = this;
    (_a2 = me.mouseDetacher) == null ? void 0 : _a2.call(me);
    me.mouseDetacher = null;
    me.element.classList.remove("b-moving");
    if (me.context.started) {
      me.trigger("drop", { context: me.context, event });
    }
    me.context = null;
  }
  //endregion
  render() {
    super.render(...arguments);
    this.syncState.now();
    if (this.vertical === null) {
      this.syncState();
    }
  }
};
//region Config
__publicField(Splitter, "$name", "Splitter");
__publicField(Splitter, "type", "splitter");
Splitter.initClass();
Splitter._$name = "Splitter";

// ../Core/lib/Core/widget/Tab.js
var Tab = class extends Button {
  static get configurable() {
    return {
      /**
       * This config is set to `true` when this tab represents the `activeTab` of a {@link Core.widget.TabPanel}. It
       * is managed by the tab panel is not set directly.
       * @config {Boolean} active
       * @default false
       */
      active: null,
      /**
       * This config is set to the ordinal position of this tab in the {@link Core.widget.TabPanel}. It is managed
       * by the tab panel is not set directly.
       * @config {Number} index
       */
      index: null,
      /**
       * This config is set to `true` when this tab represents the first tab of a {@link Core.widget.TabPanel}. It
       * is managed by the tab panel is not set directly.
       * @config {Boolean} isFirst
       */
      isFirst: null,
      /**
       * This config is set to `true` when this tab represents the last tab of a {@link Core.widget.TabPanel}. It
       * is managed by the tab panel is not set directly.
       * @config {Boolean} isLast
       */
      isLast: null,
      /**
       * The {@link Core.widget.Widget} in the {@link Core.widget.TabPanel} corresponding to this tab. This is
       * managed by the tab panel is not set directly.
       * @config {Core.widget.Widget} item
       */
      item: {
        value: null,
        $config: "nullify"
      },
      itemCls: null,
      /**
       * The tab panel that owns this tab.
       * @config {Core.widget.TabPanel} tabPanel
       */
      tabPanel: null,
      /**
       * The config property on this tab that will be set to the value of the {@link #config-titleSource} property
       * of this tab's {@link #config-item}.
       *
       * By default, the {@link #config-text} property of the tab is set to the {@link Core.widget.Widget#config-title}
       * property of its {@link #config-item}.
       * @config {String} titleProperty
       * @default
       */
      titleProperty: "text",
      /**
       * The config property on this tab's {@link #config-item} that is used to set the value of the
       * {@link #config-titleProperty} of this tab.
       *
       * By default, the {@link #config-text} property of the tab is set to the {@link Core.widget.Widget#config-title}
       * property of its {@link #config-item}.
       * @config {String} titleSource
       * @default
       */
      titleSource: "title",
      role: "tab"
    };
  }
  compose() {
    const { active, cls, index, isFirst, isLast } = this, setSize = this.owner.visibleChildCount;
    return {
      tabindex: 0,
      "aria-selected": active,
      "aria-setsize": setSize,
      "aria-posinset": index + 1,
      class: {
        "b-tabpanel-tab": 1,
        "b-active": active,
        "b-tab-first": isFirst,
        "b-tab-last": isLast,
        ...cls
        // cls is a DomClassList
      },
      dataset: {
        index
      }
    };
  }
  //endregion
  updateIndex(index) {
    this.isFirst = !index;
  }
  updateItem(item, was) {
    var _a2, _b;
    const me = this;
    if ((was == null ? void 0 : was.tab) === me) {
      was.tab = null;
    }
    if (item) {
      item.tab = me;
      me[me.titleProperty] = item[me.titleSource];
      me.itemCls = item.cls;
      me.ariaElement.setAttribute("aria-controls", item.id);
      item.role = "tabpanel";
    }
    (_a2 = me.itemChangeDetacher) == null ? void 0 : _a2.call(me);
    me.itemChangeDetacher = item && FunctionHelper.after(item, "onConfigChange", "onItemConfigChange", me, {
      return: false
    });
    (_b = me.itemHideDetacher) == null ? void 0 : _b.call(me);
    me.itemHideDetacher = item == null ? void 0 : item.ion({
      beforeChangeHidden: "onItemBeforeChangeHidden",
      beforeHide: "onItemBeforeHide",
      beforeUpdateDisabled: "onItemBeforeUpdateDisabled",
      thisObj: me,
      prio: 1e3
      // We must know before the layout intercepts and activates a sibling
    });
    me.syncMinMax();
  }
  updateItemCls(cls, was) {
    const { element } = this, classList = element && DomClassList.from(
      element == null ? void 0 : element.classList,
      /* returnEmpty= */
      true
    );
    if (element) {
      classList.remove(was).add(cls);
      element.className = classList.value;
    }
  }
  updateRotate(rotate, was) {
    if (!rotate !== !was) {
      this.syncMinMax();
    }
  }
  syncMinMax() {
    const me = this, { rotate, tabPanel } = me;
    let { _minWidth: minWidth, _minHeight: minHeight, _maxWidth: maxWidth, _maxHeight: maxHeight } = me;
    if (tabPanel) {
      const { tabMinWidth, tabMaxWidth } = tabPanel;
      if (tabMinWidth != null) {
        if (rotate) {
          if (minWidth === tabMinWidth) {
            minWidth = null;
          }
          minHeight = tabMinWidth;
        } else {
          if (minHeight === tabMinWidth) {
            minHeight = null;
          }
          minWidth = tabMinWidth;
        }
      }
      if (tabMaxWidth != null) {
        if (rotate) {
          if (maxWidth === tabMaxWidth) {
            maxWidth = null;
          }
          maxHeight = tabMaxWidth;
        } else {
          if (maxHeight === tabMaxWidth) {
            maxHeight = null;
          }
          maxWidth = tabMaxWidth;
        }
      }
      me.minWidth = minWidth;
      me.minHeight = minHeight;
      me.maxWidth = maxWidth;
      me.maxHeight = maxHeight;
    }
  }
  onItemBeforeChangeHidden({ source: hidingChild, hidden }) {
    if (!hidingChild.$isDeactivating && !hidingChild.$isActivating) {
      const { tabPanel } = this;
      this.hidden = hidden;
      if (hidden && hidingChild === tabPanel.activeItem) {
        tabPanel.activateAvailableTab(hidingChild);
      }
    }
  }
  onItemBeforeHide() {
    if (!this.item.$isDeactivating) {
      this.hide();
    }
  }
  onItemBeforeUpdateDisabled({ source: disablingChild, disabled }) {
    const { tabPanel } = this;
    this.disabled = disabled;
    if (disablingChild === tabPanel.activeItem) {
      tabPanel.activateAvailableTab(disablingChild);
    }
  }
  onItemConfigChange({ name, value }) {
    if (name === this.titleSource) {
      this[this.titleProperty] = value;
    }
  }
};
//region Config
__publicField(Tab, "$name", "Tab");
__publicField(Tab, "type", "tab");
Tab.initClass();
Tab._$name = "Tab";

// ../Core/lib/Core/widget/TabBar.js
var isTab = (t) => t.isTab;
var TabBar = class extends Toolbar {
  static get configurable() {
    return {
      defaultType: "tab",
      overflow: "scroll",
      role: "tablist",
      ignoreParentReadOnly: true
    };
  }
  get firstTab() {
    return this.tabAt(0);
  }
  get lastTab() {
    return this.tabAt(-1);
  }
  get tabCount() {
    return this._items.countOf(isTab);
  }
  get tabs() {
    return ArrayHelper.from(this._items, isTab);
  }
  compose() {
    return {
      children: {
        toolbarContent: {
          class: {
            "b-tabpanel-tabs": 1
          }
        }
      }
    };
  }
  indexOfTab(tab) {
    return this._items.indexOf(tab, isTab);
  }
  onChildAdd(child) {
    super.onChildAdd(child);
    if (child.index == null) {
      this.syncTabs();
    }
  }
  onChildRemove(child) {
    super.onChildRemove(child);
    this.syncTabs();
  }
  onFocusIn() {
    const { activeIndex } = this.owner;
    if (!isNaN(activeIndex)) {
      this.tabs[activeIndex].focus();
    }
  }
  syncTabs() {
    const { tabs } = this;
    for (let i = 0, n = tabs.length; i < n; ++i) {
      tabs[i].index = i;
      tabs[i].isFirst = !i;
      tabs[i].isLast = i === n - 1;
    }
  }
  tabAt(index) {
    return this._items.find(isTab, index) || null;
  }
};
__publicField(TabBar, "$name", "TabBar");
__publicField(TabBar, "type", "tabbar");
TabBar.initClass();
TabBar._$name = "TabBar";

// ../Core/lib/Core/widget/layout/Card.js
var animationClasses = [
  "b-slide-out-left",
  "b-slide-out-right",
  "b-slide-in-left",
  "b-slide-in-right"
];
var Card = class extends Layout {
  onChildAdd(item) {
    super.onChildAdd(item);
    const me = this, {
      activeItem,
      owner
    } = me, activeIndex = owner.activeIndex != null ? owner.activeIndex : me.activeIndex || 0, itemIndex = owner.items.indexOf(item), isActive = activeItem != null ? item === activeItem : itemIndex === activeIndex;
    item.ion({
      beforeHide: "onBeforeChildHide",
      beforeShow: "onBeforeChildShow",
      thisObj: me
    });
    if (isActive) {
      me._activeIndex = itemIndex;
      me._activeItem = item;
      item.show();
    } else {
      item.$isDeactivating = true;
      item.hide();
      item.$isDeactivating = false;
    }
  }
  onChildRemove(item) {
    super.onChildRemove(item);
    const me = this;
    if (me._activeItem === item) {
      me.activateSiblingOf(item);
    }
    me._activeIndex = me.owner.items.indexOf(me._activeItem);
    item.un({
      beforeHide: "onBeforeChildHide",
      beforeShow: "onBeforeChildShow",
      thisObj: me
    });
  }
  /**
   * Detect external code showing a child. We veto that show and activate it through the API.
   * @internal
   */
  onBeforeChildShow({ source: showingChild }) {
    if (!this.owner.isConfiguring && !showingChild.$isActivating) {
      this.activeItem = showingChild;
      return false;
    }
  }
  /**
   * Detect external code hiding a child. We veto that show and activate an immediate sibling through the API.
   * @internal
   */
  onBeforeChildHide({ source: hidingChild }) {
    if (!this.owner.isConfiguring && !hidingChild.$isDeactivating) {
      this.activateSiblingOf(hidingChild);
      return false;
    }
  }
  activateSiblingOf(item) {
    const { owner } = this, items2 = owner.items.slice(), removeAt = items2.indexOf(item);
    items2.splice(removeAt, 1);
    this.activeIndex = Math.min(removeAt, items2.length - 1);
  }
  /**
   * Get/set active item, using index or the Widget to activate
   * @param {Core.widget.Widget|Number} activeIndex
   * @param {Number} [prevActiveIndex]
   * @param {Object} [options]
   * @param {Boolean} [options.animation] Pass `false` to disable animation
   * @param {Boolean} [options.silent] Pass `true` to not fire transition events
   * @returns {Object} An object describing the card change containing the following properties:
   *  - `prevActiveIndex` The previously active index.
   *  - `prevActiveItem ` The previously active child item.
   *  - `activeIndex    ` The newly active index.
   *  - `activeItem     ` The newly active child item.
   *  - `promise        ` A promise which completes when the slide-in animation finishes and the child item contains
   * focus if it is focusable.
   * @internal
   */
  setActiveItem(activeIndex, prevActiveIndex = this.activeIndex, options) {
    var _a2;
    const me = this, { owner } = me, { items: items2 } = owner, widgetPassed = activeIndex instanceof Widget, prevActiveItem = items2[prevActiveIndex], newActiveItem = owner.items[activeIndex = widgetPassed ? items2.indexOf(activeIndex) : parseInt(activeIndex, 10)], animation = (options == null ? void 0 : options.animation) !== false, chatty = !(options == null ? void 0 : options.silent), event = {
      prevActiveIndex,
      prevActiveItem
    };
    if (newActiveItem && !newActiveItem.$isActivating && newActiveItem !== prevActiveItem) {
      const prevItemElement = prevActiveItem && prevActiveItem.element, newActiveElement = newActiveItem && newActiveItem.element;
      if (me.animateDetacher) {
        const activeCardChange = me.animateDetacher.event;
        if (activeCardChange.activeItem === newActiveItem) {
          return activeCardChange.promise;
        }
        me.animateDetacher();
        activeCardChange.prevActiveItem.element.classList.remove(...animationClasses);
        activeCardChange.activeItem.element.classList.remove(...animationClasses);
        me.animateDetacher = null;
      }
      event.activeIndex = activeIndex;
      event.activeItem = newActiveItem;
      if (chatty && owner.trigger("beforeActiveItemChange", event) === false) {
        return null;
      }
      const reset = me._activeIndex !== event.activeIndex;
      if (reset) {
        me._activeIndex = event.activeIndex;
      }
      chatty && ((_a2 = owner.onBeginActiveItemChange) == null ? void 0 : _a2.call(owner, event));
      if (reset) {
        me._activeIndex = event.prevActiveIndex;
      }
      if (animation && prevItemElement && owner.isVisible && me.animateCardChange) {
        event.promise = me.cardChangeAnimation = new Promise((resolve, reject) => {
          const wasMonitoringSize = prevActiveItem.monitorResize;
          prevActiveItem.monitorResize = false;
          me.contentElement.style.overflowX = "hidden";
          prevActiveItem._hidden = true;
          newActiveItem.$isActivating = true;
          newActiveItem.show();
          newActiveItem.$isActivating = false;
          prevItemElement.classList.add(activeIndex > prevActiveIndex ? "b-slide-out-left" : "b-slide-out-right");
          newActiveElement.classList.add(activeIndex < prevActiveIndex ? "b-slide-in-left" : "b-slide-in-right");
          owner.isAnimating = true;
          me.animateDetacher = EventHelper.onTransitionEnd({
            mode: "animation",
            element: newActiveElement,
            // onTransitionEnd protects us from being called
            // after the thisObj is destroyed.
            thisObj: prevActiveItem,
            handler() {
              owner.isAnimating = me.cardChangeAnimation = false;
              if (!me.animateDetacher) {
                me.setActiveItem(activeIndex, prevActiveIndex, options);
                return;
              }
              me.animateDetacher = null;
              newActiveElement.classList.remove(...animationClasses);
              if (prevItemElement) {
                prevItemElement.classList.remove(...animationClasses);
                prevActiveItem.$isDeactivating = true;
                prevActiveItem._hidden = false;
                prevActiveItem.hide();
                prevActiveItem.monitorResize = wasMonitoringSize;
                prevActiveItem.$isDeactivating = false;
              }
              me.contentElement.style.overflowX = "";
              me.onActiveItemChange(event, resolve, !chatty);
            }
          });
          me.animateDetacher.reject = reject;
          me.animateDetacher.event = event;
        });
      } else {
        newActiveItem.$isActivating = true;
        newActiveItem.show();
        newActiveItem.focus();
        newActiveItem.$isActivating = false;
        if (prevActiveItem) {
          prevActiveItem.$isDeactivating = true;
          prevActiveItem.hide();
          prevActiveItem.$isDeactivating = false;
        }
        me.onActiveItemChange(event, null, !chatty);
      }
    }
    return event;
  }
  onActiveItemChange(event, resolve, silent) {
    const me = this;
    me._activeItem = event.activeItem;
    me._activeIndex = event.activeIndex;
    !silent && me.owner.trigger("activeItemChange", event);
    me.owner.containsFocus && event.activeItem.focus();
    resolve == null ? void 0 : resolve(event);
  }
  renderChildren() {
    const { owner } = this;
    owner.contentElement.classList.toggle(this.hideChildHeaderCls, owner.suppressChildHeaders);
    super.renderChildren();
  }
  changeActiveIndex(activeIndex) {
    const { owner } = this;
    return owner.isConfiguring && !owner._items ? activeIndex : Math.min(activeIndex, owner.items.length - 1);
  }
  updateActiveIndex(activeIndex, oldActiveIndex) {
    if (!this.owner.isConfiguring) {
      this.setActiveItem(activeIndex, oldActiveIndex);
    }
  }
  updateActiveItem(activeItem) {
    if (!this.owner.isConfiguring) {
      this.setActiveItem(activeItem, this.activeIndex);
    }
  }
  /**
   * If the layout is set to {@link #config-animateCardChange}, then this property
   * will be `true` during the animated card change.
   * @property {Boolean}
   * @readonly
   */
  get isChangingCard() {
    return Boolean(this.animateDetacher);
  }
};
__publicField(Card, "$name", "Card");
__publicField(Card, "type", "card");
__publicField(Card, "configurable", {
  containerCls: "b-card-container",
  itemCls: "b-card-item",
  hideChildHeaderCls: "b-hide-child-headers",
  /**
   * Specifies whether to slide tabs in and out of visibility.
   * @config {Boolean}
   * @default
   */
  animateCardChange: true,
  /**
   * The active child item.
   * @config {Core.widget.Widget}
   */
  activeItem: null,
  /**
   * The active child index.
   * @config {Number}
   */
  activeIndex: null
});
Card.initClass();
Card._$name = "Card";

// ../Core/lib/Core/widget/TabPanel.js
var isMaximized = (w) => w.maximized;
var TabPanel = class extends Panel {
  static get configurable() {
    return {
      /**
       * The index of the initially active tab.
       * @member {Number} activeTab
       */
      /**
       * The index of the initially active tab.
       * @config {Number}
       * @default
       */
      activeTab: 0,
      /**
       * Specifies whether to slide tabs in and out of visibility.
       * @config {Boolean}
       * @default
       */
      animateTabChange: true,
      /**
       * Set the height of all tabs to match the tab with the highest content.
       * @config {Boolean}
       * @default
       */
      autoHeight: false,
      defaultType: "container",
      focusable: false,
      itemCls: "b-tabpanel-item",
      layout: {
        type: "card"
      },
      // Prevent child panels from displaying a header unless explicitly configured with one
      suppressChildHeaders: true,
      tabBar: {
        type: "tabbar",
        weight: -2e3
      },
      /**
       * Min width of a tab title. 0 means no minimum width. This is default.
       * @config {Number}
       * @default
       */
      tabMinWidth: null,
      /**
       * Max width of a tab title. 0 means no maximum width. This is default.
       * @config {Number}
       * @default
       */
      tabMaxWidth: null
    };
  }
  //endregion
  //region Init
  /**
   * The active tab index. Setting must be done through {@link #property-activeTab}
   * @property {Number}
   * @readonly
   */
  get activeIndex() {
    return this.layout.activeIndex;
  }
  /**
   * The active child widget. Setting must be done through {@link #property-activeTab}
   * @property {Core.widget.Widget}
   * @readonly
   */
  get activeItem() {
    return this.layout.activeItem;
  }
  get activeTabItemIndex() {
    var _a2;
    const { activeTab, items: items2, tabBar } = this;
    return items2.indexOf((_a2 = tabBar.tabs[activeTab]) == null ? void 0 : _a2.item);
  }
  get bodyConfig() {
    return ObjectHelper.merge({
      className: {
        "b-tabpanel-body": 1
      }
    }, super.bodyConfig);
  }
  get focusElement() {
    var _a2;
    const activeTab = this.items[this.activeTab || 0];
    return (activeTab == null ? void 0 : activeTab.focusElement) || ((_a2 = activeTab == null ? void 0 : activeTab.tab) == null ? void 0 : _a2.focusElement);
  }
  get tabPanelBody() {
    return this.bodyElement;
  }
  finalizeInit() {
    super.finalizeInit();
    const me = this, { activeTab, layout } = me, { activeIndex } = layout, { tabs } = me.tabBar, activeTabItemIndex = activeTab >= 0 && activeTab < tabs.length && me.items.indexOf(tabs[activeTab].item);
    if (tabs.length > 0 && (activeTabItemIndex === false || activeTabItemIndex < 0)) {
      throw new Error(`Invalid activeTab ${activeTab} (${tabs.length} tabs)`);
    }
    if (activeTabItemIndex !== activeIndex) {
      layout.setActiveItem(activeTabItemIndex, activeIndex, {
        animation: false,
        silent: true
      });
    }
    layout.animateCardChange = me.animateTabChange;
  }
  onChildAdd(child) {
    super.onChildAdd(child);
    if (!this.initialItems) {
      const me = this, { tabBar } = me, config = me.makeTabConfig(child), firstTab = config && (tabBar == null ? void 0 : tabBar.firstTab), tabBarItems = firstTab && tabBar._items, tabItems = firstTab && ArrayHelper.from(me._items, (it) => it.tab || it === child), index = firstTab ? tabItems.indexOf(child) + tabBarItems.indexOf(firstTab) : 0;
      if (config && tabBar) {
        if (firstTab && child.weight == null && index < tabBarItems.count - 1) {
          tabBar.insert(config, index);
        } else {
          tabBar.add(config);
        }
      }
    }
  }
  onChildRemove(child) {
    const { tab } = child, { items: items2 } = this;
    if (tab) {
      this.tabBar.remove(tab);
      tab.destroy();
    }
    if (child === this.activeItem) {
      this._activeTab = null;
      if (items2.length) {
        this.activeTab = items2[Math.min(this.activeIndex, items2.length - 1)];
      }
    }
    super.onChildRemove(child);
  }
  //endregion
  //region Tabs
  isDisabledOrHiddenTab(tabIndex) {
    const { tabs } = this.tabBar, tab = tabs == null ? void 0 : tabs[tabIndex];
    return tab && (tab.disabled || tab.hidden);
  }
  findAvailableTab(item, delta = 1) {
    const { tabs } = this.tabBar, tabCount = tabs.length, itemIndex = Math.max(0, tabs.indexOf(item.tab));
    if (itemIndex) {
      delta = -delta;
    }
    let activeTab;
    for (let n = 1; n <= tabCount; ++n) {
      activeTab = (itemIndex + (delta < 0 ? tabCount : 0) + n * delta) % tabCount;
      if (!this.isDisabledOrHiddenTab(activeTab)) {
        break;
      }
    }
    return activeTab;
  }
  activateAvailableTab(item, delta = 1) {
    this.activeTab = this.findAvailableTab(item, delta);
  }
  changeActiveTab(activeTab, oldActiveTab) {
    const me = this, {
      tabBar,
      layout
    } = me, { tabCount } = tabBar;
    if (activeTab.isWidget || ObjectHelper.isObject(activeTab)) {
      if (me.items.indexOf(activeTab) === -1) {
        activeTab = me.add(activeTab);
      }
      activeTab = tabBar.indexOfTab(activeTab.tab);
    } else {
      activeTab = parseInt(activeTab, 10);
    }
    if (!me.initialItems && tabCount > 0 && (activeTab < -1 || activeTab >= tabCount)) {
      throw new Error(`Invalid activeTab ${activeTab} (${tabCount} tabs)`);
    }
    if (me.isDisabledOrHiddenTab(activeTab)) {
      activeTab = me.findAvailableTab(activeTab);
    }
    if (layout.animateCardChange && layout.cardChangeAnimation) {
      layout.cardChangeAnimation.then((cardChange) => {
        if ((cardChange == null ? void 0 : cardChange.activeIndex) !== activeTab) {
          me._activeTab = activeTab;
          me.updateActiveTab(activeTab, oldActiveTab);
        }
      });
    } else {
      return activeTab;
    }
  }
  async updateActiveTab(activeTab, was) {
    var _a2;
    if (!this.initialItems) {
      const { activeTabItemIndex, layout } = this;
      if (activeTabItemIndex > -1) {
        const oldActiveItem = this.items[was], newActiveItem = this.items[activeTabItemIndex];
        if (layout.activeItem !== newActiveItem) {
          if (layout.animateCardChange) {
            await this.tabSelectionPromise;
          }
          if (oldActiveItem == null ? void 0 : oldActiveItem.containsFocus) {
            oldActiveItem.tab.focus();
          }
          this.tabSelectionPromise = (_a2 = layout.setActiveItem(newActiveItem)) == null ? void 0 : _a2.promise;
        }
      }
    }
  }
  changeTabBar(bar) {
    this.getConfig("strips");
    this.strips = {
      tabBar: bar
    };
    return this.strips.tabBar;
  }
  makeTabConfig(item) {
    const { tab } = item, config = {
      item,
      type: "tab",
      tabPanel: this,
      disabled: Boolean(item.disabled),
      hidden: item.initialConfig.hidden,
      weight: item.weight || 0,
      internalListeners: {
        click: "onTabClick",
        thisObj: this
      },
      localizableProperties: {
        // our tabs copy their text from the item's title and so are not directly localized
        text: false
      }
    };
    if (tab === false) {
      return null;
    }
    return ObjectHelper.isObject(tab) ? Tab.mergeConfigs(config, tab) : config;
  }
  updateItems(items2, was) {
    const me = this, { activeTab, initialItems } = me;
    let index = 0, tabs;
    super.updateItems(items2, was);
    if (initialItems) {
      tabs = Array.from(items2, (it) => me.makeTabConfig(it)).filter((it) => {
        if (it) {
          it.index = index++;
          return true;
        }
      });
      if (index) {
        tabs[0].isFirst = true;
        tabs[index - 1].isLast = true;
        tabs[activeTab].active = true;
        me.tabBar.add(tabs);
        me.activeTab = activeTab;
      }
    }
  }
  updateTabMinWidth(tabMinWidth) {
    var _a2;
    (_a2 = this.tabBar) == null ? void 0 : _a2.items.forEach((tab) => {
      if (tab.isTab) {
        tab.minWidth = tabMinWidth;
      }
    });
  }
  updateTabMaxWidth(tabMaxWidth) {
    var _a2;
    (_a2 = this.tabBar) == null ? void 0 : _a2.items.forEach((tab) => {
      if (tab.isTab) {
        tab.maxWidth = tabMaxWidth;
      }
    });
  }
  //endregion
  //region Auto height
  updateAutoHeight(autoHeight) {
    this.detachListeners("themeAutoHeight");
    autoHeight && GlobalEvents_default.ion({
      name: "themeAutoHeight",
      theme: "internalOnThemeChange",
      thisObj: this
    });
    this.$measureHeight = autoHeight;
  }
  applyAutoHeight() {
    const me = this, { layout, activeTab, element } = me, { animateCardChange } = layout;
    layout.animateCardChange = false;
    me.height = null;
    if (!me.up(isMaximized)) {
      const maxContentHeight = me.height = Math.max(...me.items.map((tab) => {
        me.activeTab = tab;
        return element.clientHeight;
      })) + 1;
      me.flex = `1 1 ${maxContentHeight}px`;
    }
    me.activeTab = activeTab;
    layout.animateCardChange = animateCardChange;
    me.$measureHeight = false;
  }
  internalOnThemeChange() {
    if (this.isVisible) {
      this.applyAutoHeight();
    } else {
      this.$measureHeight = true;
    }
  }
  //endregion
  //region Events
  // Called after beforeActiveItemChange has fired and not been vetoed before animation and activeItemChange
  onBeginActiveItemChange(activeItemChangeEvent) {
    const tabs = this.tabBar.tabs, { activeItem, prevActiveItem } = activeItemChangeEvent;
    this.activeTab = tabs.indexOf(activeItem == null ? void 0 : activeItem.tab);
    if (prevActiveItem == null ? void 0 : prevActiveItem.tab) {
      prevActiveItem.tab.active = false;
    }
    if (activeItem == null ? void 0 : activeItem.tab) {
      activeItem.tab.active = true;
      activeItem.tab.show();
    }
  }
  // Auto called because Card layout triggers the beforeActiveItemChange on its owner
  onBeforeActiveItemChange(activeItemChangeEvent) {
    return this.trigger("beforeTabChange", activeItemChangeEvent);
  }
  // Auto called because Card layout triggers the activeItemChange on its owner
  onActiveItemChange(activeItemChangeEvent) {
    this.trigger("tabChange", activeItemChangeEvent);
  }
  onTabClick(event) {
    this.activeTab = event.source.item;
  }
  onInternalPaint() {
    super.onInternalPaint(...arguments);
    if (this.$measureHeight) {
      this.applyAutoHeight();
    }
  }
  //endregion
};
//region Config
__publicField(TabPanel, "$name", "TabPanel");
__publicField(TabPanel, "type", "tabpanel");
__publicField(TabPanel, "alias", "tabs");
TabPanel.initClass();
TabPanel._$name = "TabPanel";

// ../Core/lib/Core/widget/TextAreaField.js
var TextAreaField = class extends Field {
  static get configurable() {
    return {
      /**
       * The resize style to apply to the `<textarea>` element.
       * @config {'none'|'both'|'horizontal'|'vertical'}
       * @default
       */
      resize: "none",
      inputAttributes: {
        tag: "textarea"
      }
    };
  }
  updateResize(resize) {
    this.input.style.resize = resize;
  }
};
__publicField(TextAreaField, "$name", "TextAreaField");
__publicField(TextAreaField, "type", "textareafield");
__publicField(TextAreaField, "alias", "textarea");
TextAreaField.initClass();
TextAreaField._$name = "TextAreaField";

// ../Core/lib/Core/widget/TextAreaPickerField.js
var _TextAreaPickerField = class _TextAreaPickerField extends PickerField {
  static get configurable() {
    return {
      picker: {
        type: "widget",
        tag: "textarea",
        cls: "b-textareapickerfield-picker",
        scrollAction: "realign",
        align: {
          align: "t-b",
          axisLock: true
        },
        autoShow: false
      },
      triggers: {
        expand: {
          cls: "b-icon-picker",
          handler: "onTriggerClick"
        }
      },
      /**
       * The resize style to apply to the `<textarea>` element.
       * @config {'none'|'both'|'horizontal'|'vertical'}
       * @default
       */
      resize: "none",
      inputType: null
    };
  }
  startConfigure(config) {
    if (typeof config.inline === "boolean") {
      VersionHelper.deprecate("Core", "6.0.0", "TextAreaPickerField.inline config is no longer supported");
    }
    super.startConfigure(config);
  }
  get inputElement() {
    const result = super.inputElement;
    result.readOnly = "readonly";
    result.reference = "displayElement";
    this.ariaElement = "displayElement";
    return result;
  }
  get focusElement() {
    var _a2;
    return ((_a2 = this._picker) == null ? void 0 : _a2.isVisible) ? this.input : this.displayElement;
  }
  get needsInputSync() {
    var _a2;
    return this.displayElement[this.inputValueAttr] !== String((_a2 = this.inputValue) != null ? _a2 : "");
  }
  showPicker() {
    const me = this, { picker } = me;
    if (!me.inline) {
      picker.width = me.pickerWidth || me[me.pickerAlignElement].offsetWidth;
      super.showPicker(true);
    }
  }
  focusPicker() {
    this.input.focus();
  }
  onPickerKeyDown(keyEvent) {
    const me = this, realInput = me.input;
    switch (keyEvent.key.trim() || keyEvent.code) {
      case "Escape":
        me.picker.hide();
        return;
      case "Enter":
        if (keyEvent.ctrlKey) {
          me.syncInputFieldValue();
          me.picker.hide();
        }
        break;
    }
    me.input = me.displayElement;
    const result = super.onPickerKeyDown(keyEvent);
    me.input = realInput;
    return result;
  }
  syncInputFieldValue(skipHighlight) {
    if (this.displayElement) {
      this.displayElement.value = this.inputValue;
    }
    super.syncInputFieldValue(skipHighlight);
  }
  changeValue(value) {
    return value == null ? "" : value;
  }
  changePicker(picker, oldPicker) {
    var _a2;
    const me = this, pickerWidth = me.pickerWidth || (picker == null ? void 0 : picker.width);
    picker = _TextAreaPickerField.reconfigure(oldPicker, picker ? Objects.merge({
      owner: me,
      forElement: me[me.pickerAlignElement],
      align: {
        matchSize: pickerWidth == null,
        anchor: me.overlayAnchor,
        target: me[me.pickerAlignElement]
      },
      id: me.id + "-input",
      style: {
        resize: me.resize
      },
      html: (_a2 = me.value) != null ? _a2 : ""
    }, picker) : null, me);
    if (picker) {
      const input = me.input = picker.element;
      me.inputListenerRemover = EventHelper.on({
        element: input,
        thisObj: me,
        focus: "internalOnInputFocus",
        change: "internalOnChange",
        input: "internalOnInput",
        keydown: "internalOnKeyEvent",
        keypress: "internalOnKeyEvent",
        keyup: "internalOnKeyEvent"
      });
    }
    return picker;
  }
};
__publicField(_TextAreaPickerField, "$name", "TextAreaPickerField");
__publicField(_TextAreaPickerField, "type", "textareapickerfield");
var TextAreaPickerField = _TextAreaPickerField;
TextAreaPickerField.initClass();
TextAreaPickerField._$name = "TextAreaPickerField";

// ../Core/lib/Core/widget/mixin/Minifiable.js
var Minifiable_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    compose() {
      const { minified } = this;
      return {
        class: {
          "b-minified": minified
        }
      };
    }
    get widgetClass() {
    }
  }, __publicField(_a2, "$name", "Minifiable"), __publicField(_a2, "configurable", {
    /**
     * Set to `false` to prevent this widget from assuming its {@link #config-minified} form automatically (for
     * example, due to {@link Core.widget.Toolbar#config-overflow} handling.
     *
     * When this value is `true` (the default), the minifiable widget's {@link #config-minified} config may be
     * set to `true` to reduce toolbar overflow.
     *
     * @config {Boolean}
     * @default
     */
    minifiable: true,
    /**
     * Set to `true` to present this widget in its minimal form.
     * @config {Boolean}
     * @default false
     */
    minified: null
  }), _a2;
};

// ../Core/lib/Core/widget/mixin/Responsive.js
var EMPTY = [];
var isStateName = (name) => name[0] !== "*";
var pop = (object, key) => {
  const ret = object[key] || null;
  delete object[key];
  return ret;
};
var responsiveRootFn = (widget) => widget.responsiveRoot;
var scoring = {
  number: (threshold) => ({ width }) => width <= threshold && threshold
};
var splitConfigs = (configs) => {
  delete configs.once;
  return {
    callback: pop(configs, "callback"),
    configs,
    when: pop(configs, "when")
  };
};
var splitMergedConfigs = (cls, ...parts) => {
  const once = parts.flatMap((p) => (p == null ? void 0 : p.once) || EMPTY), configs = cls.mergeConfigs(...parts), ret = splitConfigs(configs);
  ret.once = once.length ? splitConfigs(cls.mergeConfigs(...once)) : null;
  return ret;
};
var wrapWidget = (widget, handler) => {
  let triggers, desc = Proxy.revocable(widget, {
    get(o, name) {
      if (triggers) {
        triggers[name] = true;
      }
      return widget[name];
    }
  }), detacher2 = FunctionHelper.after(widget, "onConfigChange", (ignore, { name }) => {
    if (triggers == null ? void 0 : triggers[name]) {
      handler();
    }
  }), resizer = widget.ion({
    resize: () => {
      handler();
    }
  });
  widget.monitorResize = true;
  return {
    widget,
    get object() {
      return desc == null ? void 0 : desc.proxy;
    },
    destroy() {
      if (desc) {
        desc.revoke();
        detacher2();
        resizer();
        desc = detacher2 = resizer = null;
      }
    },
    reset() {
      triggers = /* @__PURE__ */ Object.create(null);
    }
  };
};
var Responsive_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base).mixin(Delayable_default, Fencible_default) {
    get isResponsivePending() {
      return this.responsiveUpdateCount === 0 && this.hasConfig("responsive");
    }
    get isResponsiveUpdating() {
      var _a3;
      return this._responsiveUpdating || ((_a3 = this.responsiveWidget) == null ? void 0 : _a3._responsiveUpdating);
    }
    // responsive
    updateResponsive(responsive) {
      var _a3;
      const me = this, cls = me.constructor, { responsiveDefaults } = me, stateNames = Array.from(
        new Set(ObjectHelper.keys(responsive).concat(ObjectHelper.keys(responsiveDefaults)))
      ).filter(isStateName);
      let states = null, hasWhen, name, state, when;
      if (responsive) {
        states = {
          "*": splitMergedConfigs(cls, responsiveDefaults["*"], responsive["*"])
        };
        for (name of stateNames) {
          state = responsive[name];
          if (state !== null && state !== false) {
            hasWhen = hasWhen || state && "when" in state;
            states[name] = splitMergedConfigs(
              cls,
              responsiveDefaults["*"],
              responsiveDefaults[name],
              responsive["*"],
              state
            );
            when = states[name].when;
            states[name].when = ((_a3 = scoring[typeof when]) == null ? void 0 : _a3.call(scoring, when)) || when;
          }
        }
      }
      me.$responsiveStates = states;
      me.$responsiveWhen = hasWhen;
      me.syncResponsiveWidget();
    }
    // responsiveState
    updateResponsiveState(state, oldState) {
      var _a3, _b, _c, _d, _e;
      const me = this, { $responsiveStates: states } = me, initial = ++me.responsiveStateChanges === 1, classList = (_a3 = me.element) == null ? void 0 : _a3.classList, defaults = states["*"], def = states[state] || defaults, once = initial && (def.once || defaults.once), isStateful = initial && me.isStateful, target = me.responsiveWidget;
      let config = def.configs, otherConfigs = once == null ? void 0 : once.configs;
      if (otherConfigs) {
        config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;
      }
      oldState && (classList == null ? void 0 : classList.remove(`b-responsive-${oldState.toLowerCase()}`));
      state && (classList == null ? void 0 : classList.add(`b-responsive-${state.toLowerCase()}`));
      if (isStateful) {
        otherConfigs = me.loadStatefulData();
        if (otherConfigs) {
          config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;
        }
        me.suspendStateful();
      }
      me._responsiveUpdating = true;
      try {
        (_b = me.trigger) == null ? void 0 : _b.call(me, "beforeResponsiveStateChange", { state, oldState, target });
        config && me.setConfig(config);
        (_c = def.callback) == null ? void 0 : _c.call(def, { source: me, state, oldState, target, initial });
        (_d = once == null ? void 0 : once.callback) == null ? void 0 : _d.call(once, { source: me, state, oldState, target, initial });
        (_e = me.trigger) == null ? void 0 : _e.call(me, "responsiveStateChange", { state, oldState, target });
      } finally {
        me._responsiveUpdating = false;
        isStateful && me.resumeStateful();
      }
    }
    // responsiveTarget
    get responsiveTarget() {
      return this.responsiveWidget || this._responsiveTarget;
    }
    updateResponsiveTarget() {
      this.syncResponsiveWidget();
    }
    // responsiveWidget
    updateResponsiveWidget(target) {
      var _a3;
      const me = this, responsiveUpdate = target && me.responsiveUpdate;
      (_a3 = me.$responsiveWrapper) == null ? void 0 : _a3.destroy();
      me.$responsiveWrapper = target && wrapWidget(target, responsiveUpdate);
      responsiveUpdate == null ? void 0 : responsiveUpdate.now();
    }
    // Support methods
    responsiveUpdate() {
      const me = this, { $responsiveStates: states, $responsiveWrapper: wrapper } = me, responsiveTarget = wrapper == null ? void 0 : wrapper.widget;
      if (states && wrapper) {
        let best = null, bestScore = 0, fromWhen = states, score, state;
        if (responsiveTarget && responsiveTarget !== me && !me.$responsiveWhen) {
          responsiveTarget.getConfig("responsive");
          fromWhen = responsiveTarget.$responsiveStates || fromWhen;
        }
        wrapper.reset();
        for (state in states) {
          if (state !== "*") {
            score = fromWhen[state].when(wrapper.object, BrowserHelper);
            if (score != null && score !== false && (!best || score < bestScore)) {
              best = state;
              bestScore = score;
            }
          }
        }
        ++me.responsiveUpdateCount;
        me.responsiveState = best;
      }
    }
    syncResponsiveWidget() {
      var _a3;
      const me = this;
      let widget = null, responsiveTarget;
      if (!me.isDestroying && me.responsive) {
        responsiveTarget = me.responsiveTarget;
        if (!(widget = responsiveTarget)) {
          widget = !me.responsiveRoot && ((_a3 = me.up) == null ? void 0 : _a3.call(me, responsiveRootFn)) || me;
        } else if (typeof responsiveTarget === "string") {
          widget = responsiveTarget === "@" ? me : responsiveTarget[0] === "@" ? me[responsiveTarget.substring(1)] : me.up(responsiveTarget);
          if (!widget) {
            throw new Error(`No match for responsiveTarget="${responsiveTarget}"`);
          }
        }
        if (!widget.isWidget) {
          throw new Error(`${widget.constructor.$$name} is not a widget and cannot be a responsiveTarget`);
        }
      }
      me.responsiveWidget = widget;
      return widget;
    }
    changeBreakpoints(breakpoints) {
      ObjectHelper.assertObject(breakpoints, "breakpoints");
      if (breakpoints == null ? void 0 : breakpoints.width) {
        Object.keys(breakpoints.width).forEach((key) => {
          breakpoints.width[key].maxWidth = key;
        });
      }
      if (breakpoints == null ? void 0 : breakpoints.height) {
        Object.keys(breakpoints.height).forEach((key) => {
          breakpoints.height[key].maxHeight = key;
        });
      }
      return breakpoints;
    }
    updateBreakpoints(breakpoints) {
      if (breakpoints) {
        this.monitorResize = true;
      }
    }
    // Get a width/height breakpoint for the supplied dimension
    getBreakpoint(levels, dimension) {
      const ascendingLevels = Object.keys(levels).map((l) => parseInt(l)).sort(), breakpoint = ascendingLevels.find((bp) => dimension <= bp);
      return levels[breakpoint != null ? breakpoint : levels["*"] && "*"];
    }
    // Apply a breakpoints configs, trigger event and call any callback
    activateBreakpoint(orientation, breakpoint) {
      var _a3, _b;
      const me = this, prevBreakpoint = me[`current${orientation}Breakpoint`];
      if (breakpoint !== prevBreakpoint) {
        me[`current${orientation}Breakpoint`] = breakpoint;
        me.setConfig(breakpoint.configs);
        prevBreakpoint && me.element.classList.remove(`b-breakpoint-${prevBreakpoint.name.toLowerCase()}`);
        me.element.classList.add(`b-breakpoint-${breakpoint.name.toLowerCase()}`);
        me.trigger(`responsive${orientation}Change`, { breakpoint, prevBreakpoint });
        (_a3 = breakpoint.callback) == null ? void 0 : _a3.call(breakpoint, { source: me, breakpoint, prevBreakpoint });
        (_b = me.recompose) == null ? void 0 : _b.call(me);
      }
    }
    // Called on resize to pick and apply a breakpoint, if size changed enough
    applyResponsiveBreakpoints(width, height) {
      var _a3;
      const me = this, {
        width: widths,
        height: heights
      } = (_a3 = me.breakpoints) != null ? _a3 : {};
      if (widths) {
        const breakpoint = me.getBreakpoint(widths, width);
        me.activateBreakpoint("Width", breakpoint);
      }
      if (heights) {
        const breakpoint = me.getBreakpoint(heights, height);
        me.activateBreakpoint("Height", breakpoint);
      }
    }
    onInternalResize(element, width, height, oldWidth, oldHeight) {
      super.onInternalResize(element, width, height, oldWidth, oldHeight);
      this.applyResponsiveBreakpoints(width, height);
    }
  }, __publicField(_a2, "$name", "Responsive"), __publicField(_a2, "configurable", {
    /**
     * Specifies the various responsive state objects keyed by their name. Each key (except `'*'`, see below) in
     * this object is a state name (see {@link #config-responsiveState}) and its corresponding value is the
     * associated {@link #typedef-ResponsiveState} object.
     *
     * Some properties of a `ResponsiveState` object are special, for example `when` and `callback`. All other
     * properties of the state object are config properties to apply when that state is active.
     *
     * The `when` property can be a function that computes the score for the state. The state whose `when` function
     * returns the lowest score is selected and its non-special properties will be assigned to the instance. If
     * `when` is a number, it will be converted into a scoring function (see below).
     *
     * A `when` function accepts two readonly parameters and returns either a numeric score if the state should be
     * considered, or `false` or `null` if the state should be ignored (i.e., it does match with the current state).
     *
     * The first parameter is a readonly proxy for the {@link #config-responsiveTarget widget} whose size and other
     * properties determine the state's score. The proxy tracks property access to that widget in order to update
     * the responsive state should any of those properties change.
     *
     * The second argument to a `when` function is the {@link Core.helper.BrowserHelper} singleton. This allows
     * a `when` function to conveniently test platform and browser information.
     *
     * The state whose `when` function returns the lowest score is selected as the new
     * {@link #config-responsiveState} and its config object (minus the `when` function and other special
     * properties) is applied to the instance.
     *
     * If `when` is a number, it is converted to function. The following two snippets produce the same `when`
     * scoring:
     *
     * ```javascript
     *      small : {
     *          when : 400,
     *          ...
     *      }
     * ```
     *
     * The above converted to:
     *
     * ```javascript
     *      small : {
     *          when : ({ width }) => width <= 400 && 400,
     *          ...
     *      }
     * ```
     * Selecting the lowest score as the winner allows for the simple conversion of width threshold to score value,
     * such that the state with the smallest matching width is selected.
     *
     * If the `responsive` config object has an asterisk key (`'*'`), its value is used as the default set of config
     * properties to apply all other states. This will be the only config properties to apply if no `when` function
     * returns a score. In this way, this special state object acts as a default state as well as a set of
     * default values for other states to share. This state object has no `when` function.
     *
     * The default for this config is:
     * ```javascript
     *  {
     *      small : {
     *          when : 400
     *      },
     *
     *      medium : {
     *          when : 800
     *      },
     *
     *      large : {
     *          when : () => Infinity
     *      },
     *
     *      '*' : {}
     *  }
     * ```
     *
     * A derived class (or instance) can use these states by populating other config properties, define
     * additional states, and/or adjust the `when` properties to use different size thresholds.
     *
     * @config {Object}
     */
    responsive: {
      $config: {
        lazy: "paint"
      },
      value: null
    },
    /**
     * The defaults for the {@link #config-responsive} config. These are separated so that the act of setting the
     * {@link #config-responsive} config is what triggers additional processing.
     * @config {Object}
     * @internal
     * @default
     */
    responsiveDefaults: {
      small: {
        when: 400
      },
      medium: {
        when: 800
      },
      large: {
        when: () => Infinity
      },
      "*": {}
    },
    /**
     * Set to `true` to mark this instance as the default {@link #config-responsiveTarget} for descendants that do
     * not specify an explicit {@link #config-responsiveTarget} of their own.
     * @config {Boolean}
     * @default false
     */
    responsiveRoot: null,
    /**
     * The name of the active state of the {@link #config-responsive} config. This is assigned internally
     * and should not be assigned directly.
     *
     * @config {String}
     * @readonly
     */
    responsiveState: null,
    /**
     * The widget whose size and other properties drive this object's responsive behavior. If this config is not
     * specified, the closest ancestor that specified {@link #config-responsiveRoot responsiveRoot=true} will be
     * used. If there is no such ancestor, then the instance using this mixin is used.
     *
     * If this value is set to `'@'`, then this instance is used even if there is a {@link #config-responsiveRoot}
     * ancestor.
     *
     * If this config is a string that starts with `'@'`, the text following the first character is the name of the
     * property on this instance that holds the target to use. For example, `'@owner'` to use the value of the
     * `owner` property as the responsive target.
     *
     * If this config is a string that does not start with `'@'`, that string is passed to
     * {@link Core.widget.Widget#function-up} to find the closest matching ancestor.
     *
     * If another widget is used as the `responsiveTarget` and if this instance does not specify any explicit `when`
     * properties in its {@link #config-responsive} config, then the `when` definitions of the `responsiveTarget`
     * will be used for this instance.
     * @config {String|Core.widget.Widget}
     */
    responsiveTarget: {
      value: null,
      $config: {
        lazy: "paint"
      }
    },
    responsiveWidget: {
      value: null,
      $config: {
        nullify: true
      }
    },
    /**
     * Defines responsive breakpoints, based on max-width or max-height.
     *
     * When the widget is resized, the defined breakpoints are queried to find the closest larger or equal
     * breakpoint for both width and height. If the found breakpoint differs from the currently applied, it is
     * applied.
     *
     * Applying a breakpoint triggers an event that applications can catch to react to the change. It also
     * optionally applies a set of configs and calls a configured callback.
     *
     * ```javascript
     * breakpoints : {
     *     width : {
     *         50 : { name : 'small', configs : { text : 'Small', ... } }
     *         100 : { name : 'medium', configs : { text : 'Medium', ... } },
     *         '*' : { name : 'large', configs : { text : 'Large', ... } }
     *     }
     * }
     * ```
     *
     * @config {Object}
     * @param {Object} width Max-width breakpoints, with keys as numerical widths (or '*' for larger widths than the
     * largest defined one) and the value as a {@link #typedef-Breakpoint breakpoint definition}
     * @param {Object} height Max-height breakpoints, with keys as numerical heights (or '*' for larger widths than
     * the largest defined one) and the value as a {@link #typedef-Breakpoint breakpoint definition}
     * @deprecated 5.0 Use {@link #config-responsive} instead.
     */
    breakpoints: null
  }), __publicField(_a2, "delayable", {
    responsiveUpdate: "raf"
  }), __publicField(_a2, "fenced", {
    syncResponsiveWidget: true
  }), __publicField(_a2, "prototypeProperties", {
    responsiveStateChanges: 0,
    responsiveUpdateCount: 0
  }), _a2;
};

// ../Core/lib/Core/widget/mixin/Styleable.js
var Styleable_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    changeCssVarPrefix(prefix) {
      ObjectHelper.assertString(prefix, "prefix");
      if (prefix && !prefix.endsWith("-")) {
        prefix = prefix + "-";
      }
      return prefix || "";
    }
    changeCss(css) {
      ObjectHelper.assertObject(css, "css");
      const me = this;
      if (!globalThis.Proxy) {
        throw new Error("Proxy not supported");
      }
      const proxy = new Proxy({}, {
        get(target, property) {
          var _a3;
          const styles = getComputedStyle(me.element || document.documentElement);
          return (_a3 = styles.getPropertyValue(`--${me.cssVarPrefix}${StringHelper.hyphenate(property)}`)) == null ? void 0 : _a3.trim();
        },
        set(target, property, value) {
          const element = me.element || document.documentElement;
          element.style.setProperty(`--${me.cssVarPrefix}${StringHelper.hyphenate(property)}`, value);
          return true;
        }
      });
      if (css) {
        if (me._element) {
          ObjectHelper.assign(proxy, css);
        } else {
          me.$initialCSS = css;
        }
      }
      return proxy;
    }
    // Apply any initially supplied CSS when we have an element
    updateElement(element, ...args) {
      super.updateElement(element, ...args);
      if (this.$initialCSS) {
        ObjectHelper.assign(this.css, this.$initialCSS);
      }
    }
    get widgetClass() {
    }
  }, __publicField(_a2, "$name", "Styleable"), __publicField(_a2, "configurable", {
    /**
     * CSS variable prefix, appended to the keys used in {@link #config-css}.
     *
     * For example:
     *
     * ```javascript
     * {
     *    cssVarPrefix : 'taskboard',
     *
     *    css : {
     *        cardBackground : '#333'
     *    }
     * }
     * ```
     *
     * Results in the css var `--taskboard-card-background` being set to `#333`.
     * @config {String}
     * @category CSS
     */
    cssVarPrefix: "",
    /**
     * Allows runtime manipulating of CSS variables.
     *
     * See {@link #config-css} for more information.
     *
     * ```javascript
     * taskBoard.css.columnBackground = '#ccc';
     *
     * // Will set "--taskboard-column-background : #ccc"
     * ```
     *
     * @member {Proxy} css
     * @typings {typeof Proxy}
     * @category DOM
     */
    /**
     * Initial CSS variables to set.
     *
     * Each key will be applied as a CSS variable to the target elements style. Key names are hyphenated and
     * prefixed with {@link #config-cssVarPrefix} in the process. For example:
     *
     * ```javascript
     * {
     *    cssVarPrefix : 'taskboard',
     *
     *    css : {
     *        cardBackground : '#333'
     *    }
     * }
     * ```
     *
     * Results in the css var `--taskboard-card-background` being set to `#333`.
     *
     * @config {Object}
     * @category CSS
     */
    css: {}
  }), _a2;
};

// ../Core/lib/Core/widget/graph/Histogram.js
var ns = "http://www.w3.org/2000/svg";
var typePrio = {
  bar: 1,
  outline: 2,
  text: 3
};
var byOrder = (l, r) => parseInt(l.order, 10) - parseInt(r.order, 10);
var byDatasetOrder = (l, r) => parseInt(l.dataset.order, 10) - parseInt(r.dataset.order, 10);
var getField = (s) => s.field;
var returnFalse = () => false;
var classesDelimiter = /\s+/;
var Histogram = class extends Widget {
  static get configurable() {
    return {
      /**
       * An array of data objects used to drive the histogram. The property/properties used
       * are defined in the {@link #config-series} option.
       * @config {Object[]}
       * @default
       */
      data: null,
      /**
       * The values to represent in bar form.
       * @config {Number[]}
       */
      values: null,
      /**
       * Object enumerating data series for the histogram.
       * The object keys are treated as series identifiers and values are objects that
       * can contain the following properties:
       *  - `type` A String, either `'bar'` or `'outline'`
       *  - `field` A String, the name of the property to use from the data objects in the {@link #config-data} option.
       * If the value is omitted the series identifier is used as the property name.
       * @config {Object<String, HistogramSeries>}
       */
      series: null,
      /**
       * By default, the bars are scaled based upon the detected max value across all the series.
       * A specific top value to represent the 100% height may be configured.
       * @config {Number}
       */
      topValue: null,
      element: {
        children: [{
          ns,
          tag: "svg",
          reference: "svgElement",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "none",
          children: [{
            ns,
            tag: "g",
            reference: "scaledSvgGroup"
          }, {
            ns,
            tag: "g",
            reference: "unscaledSvgGroup"
          }]
        }]
      },
      /**
       * By default, all bars are rendered, even those with zero height. Configure this as `true`
       * to omit zero height bars.
       * @config {Boolean}
       * @default
       */
      omitZeroHeightBars: false,
      /**
       * By default, the histogram calls {@link #config-getBarText} once per each datum.
       * So the function is supposed to output all the series values the way it needs.
       * Configure this as `false` to call the function for each series value
       * if you need to display the values separately or having different styling.
       * @config {Boolean}
       * @default
       */
      singleTextForAllBars: true,
      monitorResize: true,
      /**
       * A Function which returns a CSS class name to add to a rectangle element.
       * The following parameters are passed:
       * @config {Function}
       * @param {HistogramSeries} series The series being rendered
       * @param {Object} rectConfig The rectangle configuration object
       * @param {Object} datum The datum being rendered
       * @param {Number} index The index of the datum being rendered
       * @returns {String} CSS class name of the rectangle element
       * @returns {String} CSS class name
       */
      getRectClass(series, rectConfig, datum, index) {
        return "";
      },
      /**
       * A Function which returns a CSS class name to add to a path element
       * built for an `outline` type series.
       * The following parameters are passed:
       * @param {HistogramSeries} series The series being rendered
       * @param {Object[]} data The series data
       * @returns {String} CSS class name of the path element
       * @config {Function}
       */
      getOutlineClass(series, data) {
        return "";
      },
      /**
       * A Function which returns the tooltip text to display when hovering a bar.
       * The following parameters are passed:
       *
       * @config {Function}
       * @param {HistogramSeries} series The series being rendered
       * @param {Object} rectConfig The rectangle configuration object
       * @param {Object} datum The datum being rendered
       * @param {Number} index The index of the datum being rendered
       * @returns {String} Tip for the the bar.
       */
      getBarTip(series, rectConfig, datum, index) {
      },
      /**
       * A Function which returns the text to render inside a bar.
       * The following parameters are passed:
       * @param {Object} datum The datum being rendered
       * @param {Number} index The index of the datum being rendered
       * @param {HistogramSeries} [series] The series (provided if {@link #config-singleTextForAllBars}
       * is `false`)
       * @returns {String} Text to render in the bar.
       * @config {Function}
       */
      getBarText(datum, index, series) {
        return "";
      },
      getRectConfig: null,
      getBarTextRenderData(renderData, datum, index, series) {
        return renderData;
      },
      getBarTextTip(renderData, datum, index, series) {
      }
    };
  }
  //endregion
  //region Init
  construct(config) {
    const me = this;
    super.construct(config);
    me.scheduleRefresh = me.createOnFrame(me.refresh, [], me, true);
    me.refresh();
  }
  set tip(tip) {
    var _a2;
    const me = this;
    (_a2 = me.tip) == null ? void 0 : _a2.destroy();
    if (tip) {
      me._tip = Tooltip.new({
        owner: me,
        forElement: me.svgElement,
        forSelector: "rect",
        internalListeners: {
          beforeShow: "up.onBeforeTipShow"
        }
      }, tip);
    } else {
      me._tip = null;
    }
  }
  onElementResize() {
    super.onElementResize(...arguments);
    const svgRect = this.svgElement.getBoundingClientRect();
    this.scaledSvgGroup.setAttribute("transform", `scale(${svgRect.width} ${svgRect.height})`);
  }
  onBeforeTipShow({ source: tip }) {
    const index = parseInt(tip.activeTarget.dataset.index);
    tip.html = tip.contentTemplate({
      histogram: this,
      index
    });
  }
  updateSeries(value) {
    const me = this, series = me._series = {};
    let index = 0, barSeriesCount = 0;
    for (const id in value) {
      if (value[id] !== false) {
        const data = series[id] = Objects.merge({}, value[id]);
        if (!data.field) {
          data.field = id;
        }
        if (!data.type) {
          data.type = "bar";
        }
        if (!("order" in data)) {
          data.order = typePrio[data.type] * 10 + index;
        }
        if (!("index" in data)) {
          data.index = index;
        }
        if (data.type === "bar") {
          data.index = barSeriesCount++;
        }
        data.id = id;
        index++;
      }
    }
    if (!me.topValue && me._data) {
      me.topValue = me.getDataTopValue(me._data);
    }
    if (!me.refreshSuspended) {
      me.scheduleRefresh();
    }
  }
  getDataTopValue(data, series) {
    const fields = Object.values(series || this.series).map(getField);
    let result = 0, datum;
    for (let i = 0, { length } = data; i < length; i++) {
      datum = data[i];
      for (let j = 0, { length: length2 } = fields; j < length2; j++) {
        result = Math.max(result, datum[fields[j]]);
      }
    }
    return result;
  }
  updateData(data) {
    const me = this;
    me._data = data;
    if (!me.topValue && me._data && me._series) {
      me.topValue = me.getDataTopValue(data);
    }
    if (!me.refreshSuspended) {
      me.scheduleRefresh();
    }
  }
  updateTopValue(value) {
    const me = this;
    me._topValue = value;
    if (!value && me._data) {
      me._topValue = me.getDataTopValue(me._data);
    }
    if (!me.refreshSuspended) {
      me.scheduleRefresh();
    }
  }
  // Must exist from the start because configuration setters call it.
  // Once configured, will be replaced with a function which schedules a refresh for the next animation frame.
  scheduleRefresh() {
  }
  suspendRefresh() {
    this.refreshSuspended++;
  }
  resumeRefresh() {
    if (this.refreshSuspended) {
      this.refreshSuspended--;
    }
  }
  refresh(params) {
    const me = this, {
      series,
      _tip,
      topValue,
      singleTextForAllBars
    } = me, extraArgs = (params == null ? void 0 : params.args) || [], histogramElements = [], textElements = [];
    if (!series) {
      return;
    }
    for (const data of Object.values(series).sort(byOrder)) {
      const elConfig = me[`draw${StringHelper.capitalize(data.type)}`](data, ...extraArgs);
      if (Array.isArray(elConfig)) {
        histogramElements.push.apply(histogramElements, elConfig);
      } else {
        histogramElements.push(elConfig);
      }
      if (!singleTextForAllBars && data.type === "bar") {
        textElements.push(...me.drawText(data, ...extraArgs));
      }
    }
    histogramElements.sort(byDatasetOrder);
    if (singleTextForAllBars) {
      textElements.push(...me.drawText(null, ...extraArgs));
    } else {
      textElements.sort(byDatasetOrder);
    }
    DomSync.sync({
      domConfig: {
        width: "100%",
        height: "100%",
        preserveAspectRatio: "none",
        dataset: {
          topValue
        },
        children: [
          {
            ns,
            tag: "g",
            reference: "scaledSvgGroup",
            children: histogramElements
          },
          {
            ns,
            tag: "g",
            reference: "unscaledSvgGroup",
            children: textElements
          }
        ]
      },
      configEquality: returnFalse,
      targetElement: me.svgElement
    });
    if (_tip && _tip.isVisible) {
      me.onBeforeTipShow({ source: _tip });
    }
  }
  drawBar(series, ...args) {
    const me = this, {
      topValue,
      data,
      omitZeroHeightBars,
      barStyle
    } = me, {
      field,
      order,
      stretch
    } = series, { length } = data, defaultWidth = 1 / length, children = [], seriesId = StringHelper.createId(series.id), seriesIndex = series.index, forceHeight = stretch ? 1 : void 0;
    let width;
    for (let index = 0, x = 0, { length: length2 } = data; index < length2; index++, x += width) {
      const datum = data[index];
      let rectConfig = datum.rectConfig = {
        ns,
        tag: "rect",
        dataset: {}
      };
      const value = datum[field], height = value ? forceHeight || datum.height || (value > topValue ? topValue : value) / topValue : 0, y = 1 - height, barTip = me.callback("getBarTip", me, [series, rectConfig, datum, index, ...args]);
      width = datum.width || defaultWidth;
      if (barStyle) {
        rectConfig.style = barStyle;
      } else {
        delete rectConfig.style;
      }
      Object.assign(rectConfig.dataset, {
        index,
        order,
        series: seriesId
      });
      const rectClass = {
        [`b-series-${seriesId}`]: 1,
        [`b-series-index-${seriesIndex}`]: 1
      }, classes = me.callback("getRectClass", me, [series, rectConfig, datum, index, ...args]);
      if (classes) {
        classes.split(classesDelimiter).forEach((cls) => rectClass[cls] = 1);
      }
      Object.assign(rectConfig, {
        x,
        y,
        width,
        height,
        class: rectClass
      });
      if (barTip) {
        rectConfig.dataset.btip = barTip;
      } else {
        delete rectConfig.dataset.btip;
      }
      if (me.getRectConfig) {
        rectConfig = me.getRectConfig(rectConfig, datum, index, series, ...args);
      }
      if (rectConfig && (rectConfig.height || !omitZeroHeightBars)) {
        children.push(rectConfig);
      }
    }
    return children;
  }
  changeGetRectConfig(fn2) {
    return fn2 ? this.bindCallback(fn2) : null;
  }
  drawOutline(series, ...args) {
    const me = this, {
      topValue,
      data
    } = me, {
      field,
      order,
      id
    } = series, defaultWidth = 1 / data.length, coords = ["M 0,1"], result = {
      ns,
      tag: "path",
      dataset: {
        order,
        id
      }
    };
    let barWidth, command1 = "M", command2 = "L";
    for (let i = 0, x = 0, { length } = data; i < length; i++) {
      const barHeight = 1 - data[i][field] / topValue;
      barWidth = data[i].width || defaultWidth;
      coords.push(`${command1} ${x},${barHeight} ${command2} ${x += barWidth},${barHeight}`);
      command1 = command2 = "";
    }
    result.class = `b-series-${series.id} b-series-index-${series.index} ` + me.callback("getOutlineClass", me, [series, data, ...args]);
    result.d = coords.join(" ");
    return result;
  }
  drawText(series, ...args) {
    const me = this, { data } = me, defaultWidth = 1 / data.length, defaultY = "100%", unscaledSvgGroups = [];
    for (let index = 0, width, x = 0, { length } = data; index < length; index++, x += width) {
      width = data[index].width || defaultWidth;
      const barText = me.callback("getBarText", me, [data[index], index, series, ...args]);
      if (barText) {
        const renderData = me.callback("getBarTextRenderData", me, [{
          ns,
          tag: "text",
          className: "b-bar-legend",
          html: barText,
          left: x,
          width,
          x: `${(x + width / 2) * 100}%`,
          y: data[index].y !== void 0 ? data[index].y : defaultY,
          dataset: {
            index,
            series
          }
        }, data[index], index, series, ...args]);
        const barTip = me.callback("getBarTextTip", me, [renderData, data[index], index, series, ...args]);
        if (barTip) {
          renderData.dataset.btip = barTip;
        } else {
          delete renderData.dataset.btip;
        }
        unscaledSvgGroups.push(renderData);
      }
    }
    return unscaledSvgGroups;
  }
  //endregion
};
//region Config
__publicField(Histogram, "type", "histogram");
__publicField(Histogram, "$name", "Histogram");
__publicField(Histogram, "properties", {
  refreshSuspended: 0
});
Histogram.initClass();
Histogram._$name = "Histogram";

// ../Core/lib/Core/widget/graph/Scale.js
var ns2 = "http://www.w3.org/2000/svg";
var Scale = class extends Widget {
  static get configurable() {
    return {
      scalePoints: null,
      // Padding after the max scale point.
      // Expressed as the share of the height.
      scaleMaxPadding: 0.1,
      /**
       * Configure as `true` to create a horizontal scale. Scales are vertical by default.
       * @config {Boolean}
       */
      horizontal: false,
      /**
       * Side to align the scale to. Defaults to `bottom` for {@link #config-horizontal} Scales
       * and `right` for vertical Scales.
       * @config {String}
       */
      align: {
        value: false,
        $config: {
          merge: "replace"
        }
      },
      element: {
        children: [{
          ns: ns2,
          tag: "svg",
          reference: "svgElement",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "none",
          children: [{
            ns: ns2,
            tag: "g",
            reference: "scaledSvgGroup",
            children: [{
              ns: ns2,
              tag: "path",
              reference: "pathElement"
            }]
          }, {
            ns: ns2,
            tag: "g",
            reference: "unscaledSvgGroup"
          }]
        }]
      },
      monitorResize: true
    };
  }
  //endregion
  //region Init
  construct(config) {
    super.construct(config);
    this.scheduleRefresh = this.createOnFrame(this.refresh, [], this, true);
    this.refresh();
  }
  changeAlign(align) {
    if (!align) {
      align = this.horizontal ? "bottom" : "right";
    }
    return align;
  }
  updateAlign(align, oldAlign) {
    this.element.classList.remove(`b-align-${oldAlign}`);
    this.element.classList.add(`b-align-${align}`);
  }
  updateHorizontal(horizontal, oldHorizontal) {
    this.element.classList.remove(`b-scale-${oldHorizontal ? "horizontal" : "vertical"}`);
    this.element.classList.add(`b-scale-${horizontal ? "horizontal" : "vertical"}`);
  }
  onElementResize() {
    super.onElementResize(...arguments);
    this.scheduleRefresh();
  }
  // Must exist from the start because configuration setters call it.
  // Once configured, will be replaced with a function which schedules a refresh for the next animation frame.
  scheduleRefresh() {
  }
  refresh() {
    var _a2;
    if (!this.scalePoints) {
      return;
    }
    const me = this, {
      horizontal,
      width,
      height,
      align,
      scalePoints,
      scaleMaxPadding
    } = me, scaleMax = (_a2 = scalePoints[scalePoints.length - 1]) == null ? void 0 : _a2.value, path = [], labels = [];
    const posFactor = 1 / (scaleMax + scaleMaxPadding * scaleMax);
    me.scaledSvgGroup.setAttribute("transform", `scale(${horizontal ? width : 1} ${horizontal ? 1 : height})`);
    for (const point of scalePoints) {
      const isLabelStep = Boolean(point.text), pos = posFactor * point.value;
      if (isLabelStep) {
        const label = {
          ns: ns2,
          tag: "text",
          className: "b-scale-tick-label",
          html: point.text,
          dataset: {
            tick: point.value
          }
        };
        if (horizontal) {
          label.x = `${pos * 100}%`;
          label.y = align === "top" ? "1.6em" : height - 12;
        } else {
          label.x = align === "left" ? "12" : `${width - 12}`;
          label.y = `${(1 - pos) * 100}%`;
        }
        labels.push(label);
      }
      if (horizontal) {
        if (align === "top") {
          path.push(`M${pos},0 L${pos},${isLabelStep ? 10 : 5}`);
        } else {
          path.push(`M${pos},${height} L${pos},${height - (isLabelStep ? 10 : 5)}`);
        }
      } else {
        if (align === "left") {
          path.push(`M0,${1 - pos} L${isLabelStep ? 10 : 5},${1 - pos}`);
        } else {
          path.push(`M${width},${1 - pos} L${width - (isLabelStep ? 10 : 5)},${1 - pos}`);
        }
      }
    }
    me.pathElement.setAttribute("d", path.join(""));
    DomSync.syncChildren({
      domConfig: { children: labels }
    }, me.unscaledSvgGroup);
  }
  //endregion
};
//region Config
__publicField(Scale, "$name", "Scale");
__publicField(Scale, "type", "scale");
Scale.initClass();
Scale._$name = "Scale";

// ../Core/lib/Core/widget/util/AvatarRendering.js
var _AvatarRendering = class _AvatarRendering extends Base {
  static get configurable() {
    return {
      /**
       * Element used to listen for load errors. Normally the owning widgets own element.
       * @config {HTMLElement}
       */
      element: null,
      /**
       * Prefix prepended to a supplied color to create a CSS class applied when showing initials.
       * @config {String}
       * @default
       */
      colorPrefix: "b-sch-",
      /**
       * A tooltip config object to enable using a custom tooltip for the avatars. Listen for `beforeShow` and set
       * your html there.
       * @config {TooltipConfig}
       */
      tooltip: null,
      size: null
    };
  }
  doDestroy() {
    var _a2;
    (_a2 = this.tooltip) == null ? void 0 : _a2.destroy();
    super.doDestroy();
  }
  updateElement(element) {
    EventHelper.on({
      element,
      delegate: ".b-resource-image",
      error: "onImageErrorEvent",
      thisObj: this,
      capture: true
    });
  }
  changeTooltip(config) {
    return Tooltip.new({
      forElement: this.element,
      forSelector: ".b-resource-avatar",
      cls: "b-resource-avatar-tooltip"
    }, config);
  }
  static get failedUrls() {
    if (!this._failedUrls) {
      this._failedUrls = /* @__PURE__ */ new Set();
    }
    return this._failedUrls;
  }
  /**
   * Returns a DOM config object containing a resource avatar, icon or resource initials. Display priority in that
   * order.
   * @param {AvatarConfig|AvatarConfig[]} options A single avatar config object or an array of the same.
   * @returns {DomConfig}
   */
  getResourceAvatar(options) {
    if (Array.isArray(options)) {
      return options.map((item) => this.getResourceAvatar(item));
    }
    const { initials, color, iconCls, imageUrl, defaultImageUrl, dataset = {}, resourceRecord, alt: alt2 = StringHelper.encodeHtml(resourceRecord == null ? void 0 : resourceRecord.name) } = options, config = this.getImageConfig(initials, color, imageUrl, defaultImageUrl, dataset, alt2) || this.getIconConfig(iconCls, dataset) || this.getResourceInitialsConfig(initials, color, dataset), { size } = this;
    Object.assign(config.style, {
      ...size ? { height: size, width: size } : void 0
    });
    return config;
  }
  getImageConfig(initials, color, imageUrl, defaultImageUrl, dataset, alt2) {
    imageUrl = _AvatarRendering.failedUrls.has(imageUrl) ? defaultImageUrl : imageUrl || defaultImageUrl;
    if (imageUrl) {
      return {
        tag: "img",
        draggable: "false",
        loading: "lazy",
        class: {
          "b-resource-avatar": 1,
          "b-resource-image": 1
        },
        style: {},
        alt: alt2,
        elementData: {
          defaultImageUrl,
          imageUrl,
          initials,
          color,
          dataset
        },
        src: imageUrl,
        dataset
      };
    }
  }
  getIconConfig(iconCls, dataset) {
    if (iconCls) {
      return iconCls && {
        tag: "i",
        style: {},
        class: {
          "b-resource-avatar": 1,
          "b-resource-icon": 1,
          [iconCls]: 1
        },
        dataset
      };
    }
  }
  getResourceInitialsConfig(initials, color, dataset) {
    const namedColor = DomHelper.isNamedColor(color) && color, hexColor = !namedColor && color, { size } = this;
    return {
      tag: "div",
      class: {
        "b-resource-avatar": 1,
        "b-resource-initials": 1,
        [`${this.colorPrefix}${namedColor}`]: namedColor
      },
      style: {
        backgroundColor: hexColor || null,
        ...size ? { height: size, width: size } : void 0
      },
      children: [initials],
      dataset
    };
  }
  onImageErrorEvent({ target }) {
    if (!target.matches(".b-resource-avatar")) {
      return;
    }
    const { defaultImageUrl, initials, color, imageUrl, dataset } = target.elementData;
    if (defaultImageUrl && !target.src.endsWith(defaultImageUrl.replace(/^[./]*/gm, ""))) {
      target.src = defaultImageUrl;
    } else {
      const initialsEl = DomHelper.createElement(this.getResourceInitialsConfig(initials, color, dataset));
      initialsEl.elementData = target.elementData;
      target.parentElement.replaceChild(initialsEl, target);
    }
    _AvatarRendering.failedUrls.add(imageUrl);
  }
};
__publicField(_AvatarRendering, "$name", "AvatarRendering");
var AvatarRendering = _AvatarRendering;
AvatarRendering._$name = "AvatarRendering";

// ../Core/bundle/entry.thin.js
if (window && !window.bryntum) {
  window.bryntum = {};
}

// ../Engine/lib/Engine/vendor/later/later.js
var diffSecond = (date, diff) => {
  return new Date(
    date.getFullYear(),
    date.getMonth(),
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds() + diff,
    date.getMilliseconds()
  );
};
var later = function() {
  "use strict";
  var later2 = {
    version: "1.2.0"
  };
  if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function(searchElement) {
      "use strict";
      if (this == null) {
        throw new TypeError();
      }
      var t = Object(this);
      var len = t.length >>> 0;
      if (len === 0) {
        return -1;
      }
      var n = 0;
      if (arguments.length > 1) {
        n = Number(arguments[1]);
        if (n != n) {
          n = 0;
        } else if (n != 0 && n != Infinity && n != -Infinity) {
          n = (n > 0 || -1) * Math.floor(Math.abs(n));
        }
      }
      if (n >= len) {
        return -1;
      }
      var k = n >= 0 ? n : Math.max(len - Math.abs(n), 0);
      for (; k < len; k++) {
        if (k in t && t[k] === searchElement) {
          return k;
        }
      }
      return -1;
    };
  }
  if (!String.prototype.trim) {
    String.prototype.trim = function() {
      return this.replace(/^\s+|\s+$/g, "");
    };
  }
  later2.array = {};
  later2.array.sort = function(arr, zeroIsLast) {
    arr.sort(function(a, b) {
      return +a - +b;
    });
    if (zeroIsLast && arr[0] === 0) {
      arr.push(arr.shift());
    }
  };
  later2.array.next = function(val, values, extent) {
    var cur, zeroIsLargest = extent[0] !== 0, nextIdx = 0;
    for (var i = values.length - 1; i > -1; --i) {
      cur = values[i];
      if (cur === val) {
        return cur;
      }
      if (cur > val || cur === 0 && zeroIsLargest && extent[1] > val) {
        nextIdx = i;
        continue;
      }
      break;
    }
    return values[nextIdx];
  };
  later2.array.nextInvalid = function(val, values, extent) {
    var min2 = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min2 !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;
    while (next === (values[i] || zeroVal)) {
      next++;
      if (next > max) {
        next = min2;
      }
      i++;
      if (i === len) {
        i = 0;
      }
      if (next === start) {
        return void 0;
      }
    }
    return next;
  };
  later2.array.prev = function(val, values, extent) {
    var cur, len = values.length, zeroIsLargest = extent[0] !== 0, prevIdx = len - 1;
    for (var i = 0; i < len; i++) {
      cur = values[i];
      if (cur === val) {
        return cur;
      }
      if (cur < val || cur === 0 && zeroIsLargest && extent[1] < val) {
        prevIdx = i;
        continue;
      }
      break;
    }
    return values[prevIdx];
  };
  later2.array.prevInvalid = function(val, values, extent) {
    var min2 = extent[0], max = extent[1], len = values.length, zeroVal = values[len - 1] === 0 && min2 !== 0 ? max : 0, next = val, i = values.indexOf(val), start = next;
    while (next === (values[i] || zeroVal)) {
      next--;
      if (next < min2) {
        next = max;
      }
      i--;
      if (i === -1) {
        i = len - 1;
      }
      if (next === start) {
        return void 0;
      }
    }
    return next;
  };
  later2.day = later2.D = {
    name: "day",
    range: 86400,
    val: function(d) {
      return d.D || (d.D = later2.date.getDate.call(d));
    },
    isValid: function(d, val) {
      return later2.D.val(d) === (val || later2.D.extent(d)[1]);
    },
    extent: function(d) {
      if (d.DExtent)
        return d.DExtent;
      var month2 = later2.M.val(d), max = later2.DAYS_IN_MONTH[month2 - 1];
      if (month2 === 2 && later2.dy.extent(d)[1] === 366) {
        max = max + 1;
      }
      return d.DExtent = [1, max];
    },
    start: function(d) {
      return d.DStart || (d.DStart = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d)));
    },
    end: function(d) {
      return d.DEnd || (d.DEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d)));
    },
    next: function(d, val) {
      val = val > later2.D.extent(d)[1] ? 1 : val;
      var month2 = later2.date.nextRollover(d, val, later2.D, later2.M), DMax = later2.D.extent(month2)[1];
      val = val > DMax ? 1 : val || DMax;
      return later2.date.next(later2.Y.val(month2), later2.M.val(month2), val);
    },
    prev: function(d, val) {
      var month2 = later2.date.prevRollover(d, val, later2.D, later2.M), DMax = later2.D.extent(month2)[1];
      return later2.date.prev(later2.Y.val(month2), later2.M.val(month2), val > DMax ? DMax : val || DMax);
    }
  };
  later2.dayOfWeekCount = later2.dc = {
    name: "day of week count",
    range: 604800,
    val: function(d) {
      return d.dc || (d.dc = Math.floor((later2.D.val(d) - 1) / 7) + 1);
    },
    isValid: function(d, val) {
      return later2.dc.val(d) === val || val === 0 && later2.D.val(d) > later2.D.extent(d)[1] - 7;
    },
    extent: function(d) {
      return d.dcExtent || (d.dcExtent = [1, Math.ceil(later2.D.extent(d)[1] / 7)]);
    },
    start: function(d) {
      return d.dcStart || (d.dcStart = later2.date.next(later2.Y.val(d), later2.M.val(d), Math.max(1, (later2.dc.val(d) - 1) * 7 + 1 || 1)));
    },
    end: function(d) {
      return d.dcEnd || (d.dcEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), Math.min(later2.dc.val(d) * 7, later2.D.extent(d)[1])));
    },
    next: function(d, val) {
      val = val > later2.dc.extent(d)[1] ? 1 : val;
      var month2 = later2.date.nextRollover(d, val, later2.dc, later2.M), dcMax = later2.dc.extent(month2)[1];
      val = val > dcMax ? 1 : val;
      var next = later2.date.next(later2.Y.val(month2), later2.M.val(month2), val === 0 ? later2.D.extent(month2)[1] - 6 : 1 + 7 * (val - 1));
      if (next.getTime() <= d.getTime()) {
        month2 = later2.M.next(d, later2.M.val(d) + 1);
        return later2.date.next(later2.Y.val(month2), later2.M.val(month2), val === 0 ? later2.D.extent(month2)[1] - 6 : 1 + 7 * (val - 1));
      }
      return next;
    },
    prev: function(d, val) {
      var month2 = later2.date.prevRollover(d, val, later2.dc, later2.M), dcMax = later2.dc.extent(month2)[1];
      val = val > dcMax ? dcMax : val || dcMax;
      return later2.dc.end(later2.date.prev(later2.Y.val(month2), later2.M.val(month2), 1 + 7 * (val - 1)));
    }
  };
  later2.dayOfWeek = later2.dw = later2.d = {
    name: "day of week",
    range: 86400,
    val: function(d) {
      return d.dw || (d.dw = later2.date.getDay.call(d) + 1);
    },
    isValid: function(d, val) {
      return later2.dw.val(d) === (val || 7);
    },
    extent: function() {
      return [1, 7];
    },
    start: function(d) {
      return later2.D.start(d);
    },
    end: function(d) {
      return later2.D.end(d);
    },
    next: function(d, val) {
      val = val > 7 ? 1 : val || 7;
      return later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val - later2.dw.val(d)) + (val <= later2.dw.val(d) ? 7 : 0));
    },
    prev: function(d, val) {
      val = val > 7 ? 7 : val || 7;
      return later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val - later2.dw.val(d)) + (val >= later2.dw.val(d) ? -7 : 0));
    }
  };
  later2.dayOfYear = later2.dy = {
    name: "day of year",
    range: 86400,
    val: function(d) {
      return d.dy || (d.dy = Math.ceil(1 + (later2.D.start(d).getTime() - later2.Y.start(d).getTime()) / later2.DAY));
    },
    isValid: function(d, val) {
      return later2.dy.val(d) === (val || later2.dy.extent(d)[1]);
    },
    extent: function(d) {
      var year = later2.Y.val(d);
      return d.dyExtent || (d.dyExtent = [1, year % 4 ? 365 : 366]);
    },
    start: function(d) {
      return later2.D.start(d);
    },
    end: function(d) {
      return later2.D.end(d);
    },
    next: function(d, val) {
      val = val > later2.dy.extent(d)[1] ? 1 : val;
      var year = later2.date.nextRollover(d, val, later2.dy, later2.Y), dyMax = later2.dy.extent(year)[1];
      val = val > dyMax ? 1 : val || dyMax;
      return later2.date.next(later2.Y.val(year), later2.M.val(year), val);
    },
    prev: function(d, val) {
      var year = later2.date.prevRollover(d, val, later2.dy, later2.Y), dyMax = later2.dy.extent(year)[1];
      val = val > dyMax ? dyMax : val || dyMax;
      return later2.date.prev(later2.Y.val(year), later2.M.val(year), val);
    }
  };
  later2.hour = later2.h = {
    name: "hour",
    range: 3600,
    val: function(d) {
      return d.h || (d.h = later2.date.getHour.call(d));
    },
    isValid: function(d, val) {
      return later2.h.val(d) === val;
    },
    extent: function() {
      return [0, 23];
    },
    start: function(d) {
      return d.hStart || (d.hStart = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d)));
    },
    end: function(d) {
      return d.hEnd || (d.hEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d)));
    },
    next: function(d, val) {
      val = val > 23 ? 0 : val;
      var next = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val <= later2.h.val(d) ? 1 : 0), val);
      if (!later2.date.isUTC && next.getTime() <= d.getTime()) {
        next = later2.date.next(later2.Y.val(next), later2.M.val(next), later2.D.val(next), val + 1);
      }
      return next;
    },
    prev: function(d, val) {
      val = val > 23 ? 23 : val;
      return later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val >= later2.h.val(d) ? -1 : 0), val);
    }
  };
  later2.minute = later2.m = {
    name: "minute",
    range: 60,
    val: function(d) {
      return d.m || (d.m = later2.date.getMin.call(d));
    },
    isValid: function(d, val) {
      return later2.m.val(d) === val;
    },
    extent: function(d) {
      return [0, 59];
    },
    start: function(d) {
      return d.mStart || (d.mStart = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d), later2.m.val(d)));
    },
    end: function(d) {
      return d.mEnd || (d.mEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d), later2.m.val(d)));
    },
    next: function(d, val) {
      var m = later2.m.val(d), s = later2.s.val(d), inc = val > 59 ? 60 - m : val <= m ? 60 - m + val : val - m, next = new Date(d.getTime() + inc * later2.MIN - s * later2.SEC);
      if (!later2.date.isUTC && next.getTime() <= d.getTime()) {
        next = new Date(d.getTime() + (inc + 120) * later2.MIN - s * later2.SEC);
      }
      return next;
    },
    prev: function(d, val) {
      val = val > 59 ? 59 : val;
      return later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d) + (val >= later2.m.val(d) ? -1 : 0), val);
    }
  };
  later2.month = later2.M = {
    name: "month",
    range: 2629740,
    val: function(d) {
      return d.M || (d.M = later2.date.getMonth.call(d) + 1);
    },
    isValid: function(d, val) {
      return later2.M.val(d) === (val || 12);
    },
    extent: function() {
      return [1, 12];
    },
    start: function(d) {
      return d.MStart || (d.MStart = later2.date.next(later2.Y.val(d), later2.M.val(d)));
    },
    end: function(d) {
      return d.MEnd || (d.MEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d)));
    },
    next: function(d, val) {
      val = val > 12 ? 1 : val || 12;
      return later2.date.next(later2.Y.val(d) + (val > later2.M.val(d) ? 0 : 1), val);
    },
    prev: function(d, val) {
      val = val > 12 ? 12 : val || 12;
      return later2.date.prev(later2.Y.val(d) - (val >= later2.M.val(d) ? 1 : 0), val);
    }
  };
  later2.second = later2.s = {
    name: "second",
    range: 1,
    val: function(d) {
      return d.s || (d.s = later2.date.getSec.call(d));
    },
    isValid: function(d, val) {
      return later2.s.val(d) === val;
    },
    extent: function() {
      return [0, 59];
    },
    start: function(d) {
      return d;
    },
    end: function(d) {
      return d;
    },
    next: function(d, val) {
      var s = later2.s.val(d), inc = val > 59 ? 60 - s : val <= s ? 60 - s + val : val - s, next = new Date(d.getTime() + inc * later2.SEC);
      if (!later2.date.isUTC && next.getTime() <= d.getTime()) {
        next = new Date(d.getTime() + (inc + 7200) * later2.SEC);
      }
      return next;
    },
    prev: function(d, val, cache) {
      val = val > 59 ? 59 : val;
      return later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d), later2.h.val(d), later2.m.val(d) + (val >= later2.s.val(d) ? -1 : 0), val);
    }
  };
  later2.time = later2.t = {
    name: "time",
    range: 1,
    val: function(d) {
      return d.t || (d.t = later2.h.val(d) * 3600 + later2.m.val(d) * 60 + later2.s.val(d));
    },
    isValid: function(d, val) {
      return later2.t.val(d) === val;
    },
    extent: function() {
      return [0, 86399];
    },
    start: function(d) {
      return d;
    },
    end: function(d) {
      return d;
    },
    next: function(d, val) {
      val = val > 86399 ? 0 : val;
      var next = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val <= later2.t.val(d) ? 1 : 0), 0, 0, val);
      if (!later2.date.isUTC && next.getTime() < d.getTime()) {
        next = later2.date.next(later2.Y.val(next), later2.M.val(next), later2.D.val(next), later2.h.val(next), later2.m.val(next), val + 7200);
      }
      return next;
    },
    prev: function(d, val) {
      val = val > 86399 ? 86399 : val;
      return later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (val >= later2.t.val(d) ? -1 : 0), 0, 0, val);
    }
  };
  later2.weekOfMonth = later2.wm = {
    name: "week of month",
    range: 604800,
    val: function(d) {
      return d.wm || (d.wm = (later2.D.val(d) + (later2.dw.val(later2.M.start(d)) - 1) + (7 - later2.dw.val(d))) / 7);
    },
    isValid: function(d, val) {
      return later2.wm.val(d) === (val || later2.wm.extent(d)[1]);
    },
    extent: function(d) {
      return d.wmExtent || (d.wmExtent = [1, (later2.D.extent(d)[1] + (later2.dw.val(later2.M.start(d)) - 1) + (7 - later2.dw.val(later2.M.end(d)))) / 7]);
    },
    start: function(d) {
      return d.wmStart || (d.wmStart = later2.date.next(later2.Y.val(d), later2.M.val(d), Math.max(later2.D.val(d) - later2.dw.val(d) + 1, 1)));
    },
    end: function(d) {
      return d.wmEnd || (d.wmEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), Math.min(later2.D.val(d) + (7 - later2.dw.val(d)), later2.D.extent(d)[1])));
    },
    next: function(d, val) {
      val = val > later2.wm.extent(d)[1] ? 1 : val;
      var month2 = later2.date.nextRollover(d, val, later2.wm, later2.M), wmMax = later2.wm.extent(month2)[1];
      val = val > wmMax ? 1 : val || wmMax;
      return later2.date.next(later2.Y.val(month2), later2.M.val(month2), Math.max(1, (val - 1) * 7 - (later2.dw.val(month2) - 2)));
    },
    prev: function(d, val) {
      var month2 = later2.date.prevRollover(d, val, later2.wm, later2.M), wmMax = later2.wm.extent(month2)[1];
      val = val > wmMax ? wmMax : val || wmMax;
      return later2.wm.end(later2.date.next(later2.Y.val(month2), later2.M.val(month2), Math.max(1, (val - 1) * 7 - (later2.dw.val(month2) - 2))));
    }
  };
  later2.weekOfYear = later2.wy = {
    name: "week of year (ISO)",
    range: 604800,
    val: function(d) {
      if (d.wy)
        return d.wy;
      var wThur = later2.dw.next(later2.wy.start(d), 5), YThur = later2.dw.next(later2.Y.prev(wThur, later2.Y.val(wThur) - 1), 5);
      return d.wy = 1 + Math.ceil((wThur.getTime() - YThur.getTime()) / later2.WEEK);
    },
    isValid: function(d, val) {
      return later2.wy.val(d) === (val || later2.wy.extent(d)[1]);
    },
    extent: function(d) {
      if (d.wyExtent)
        return d.wyExtent;
      var year = later2.dw.next(later2.wy.start(d), 5), dwFirst = later2.dw.val(later2.Y.start(year)), dwLast = later2.dw.val(later2.Y.end(year));
      return d.wyExtent = [1, dwFirst === 5 || dwLast === 5 ? 53 : 52];
    },
    start: function(d) {
      return d.wyStart || (d.wyStart = later2.date.next(later2.Y.val(d), later2.M.val(d), later2.D.val(d) - (later2.dw.val(d) > 1 ? later2.dw.val(d) - 2 : 6)));
    },
    end: function(d) {
      return d.wyEnd || (d.wyEnd = later2.date.prev(later2.Y.val(d), later2.M.val(d), later2.D.val(d) + (later2.dw.val(d) > 1 ? 8 - later2.dw.val(d) : 0)));
    },
    next: function(d, val) {
      val = val > later2.wy.extent(d)[1] ? 1 : val;
      var wyThur = later2.dw.next(later2.wy.start(d), 5), year = later2.date.nextRollover(wyThur, val, later2.wy, later2.Y);
      if (later2.wy.val(year) !== 1) {
        year = later2.dw.next(year, 2);
      }
      var wyMax = later2.wy.extent(year)[1], wyStart = later2.wy.start(year);
      val = val > wyMax ? 1 : val || wyMax;
      return later2.date.next(later2.Y.val(wyStart), later2.M.val(wyStart), later2.D.val(wyStart) + 7 * (val - 1));
    },
    prev: function(d, val) {
      var wyThur = later2.dw.next(later2.wy.start(d), 5), year = later2.date.prevRollover(wyThur, val, later2.wy, later2.Y);
      if (later2.wy.val(year) !== 1) {
        year = later2.dw.next(year, 2);
      }
      var wyMax = later2.wy.extent(year)[1], wyEnd = later2.wy.end(year);
      val = val > wyMax ? wyMax : val || wyMax;
      return later2.wy.end(later2.date.next(later2.Y.val(wyEnd), later2.M.val(wyEnd), later2.D.val(wyEnd) + 7 * (val - 1)));
    }
  };
  later2.year = later2.Y = {
    name: "year",
    range: 31556900,
    val: function(d) {
      return d.Y || (d.Y = later2.date.getYear.call(d));
    },
    isValid: function(d, val) {
      return later2.Y.val(d) === val;
    },
    extent: function() {
      return [1970, 2099];
    },
    start: function(d) {
      return d.YStart || (d.YStart = later2.date.next(later2.Y.val(d)));
    },
    end: function(d) {
      return d.YEnd || (d.YEnd = later2.date.prev(later2.Y.val(d)));
    },
    next: function(d, val) {
      return val > later2.Y.val(d) && val <= later2.Y.extent()[1] ? later2.date.next(val) : later2.NEVER;
    },
    prev: function(d, val) {
      return val < later2.Y.val(d) && val >= later2.Y.extent()[0] ? later2.date.prev(val) : later2.NEVER;
    }
  };
  later2.fullDate = later2.fd = {
    name: "full date",
    range: 1,
    val: function(d) {
      return d.fd || (d.fd = d.getTime());
    },
    isValid: function(d, val) {
      return later2.fd.val(d) === val;
    },
    extent: function() {
      return [0, 3250368e7];
    },
    start: function(d) {
      return d;
    },
    end: function(d) {
      return d;
    },
    next: function(d, val) {
      return later2.fd.val(d) < val ? new Date(val) : later2.NEVER;
    },
    prev: function(d, val) {
      return later2.fd.val(d) > val ? new Date(val) : later2.NEVER;
    }
  };
  later2.modifier = {};
  later2.modifier.after = later2.modifier.a = function(constraint, values) {
    var value = values[0];
    return {
      name: "after " + constraint.name,
      range: (constraint.extent(/* @__PURE__ */ new Date())[1] - value) * constraint.range,
      val: constraint.val,
      isValid: function(d, val) {
        return this.val(d) >= value;
      },
      extent: constraint.extent,
      start: constraint.start,
      end: constraint.end,
      next: function(startDate, val) {
        if (val != value)
          val = constraint.extent(startDate)[0];
        return constraint.next(startDate, val);
      },
      prev: function(startDate, val) {
        val = val === value ? constraint.extent(startDate)[1] : value - 1;
        return constraint.prev(startDate, val);
      }
    };
  };
  later2.modifier.before = later2.modifier.b = function(constraint, values) {
    var value = values[values.length - 1];
    return {
      name: "before " + constraint.name,
      range: constraint.range * (value - 1),
      val: constraint.val,
      isValid: function(d, val) {
        return this.val(d) < value;
      },
      extent: constraint.extent,
      start: constraint.start,
      end: constraint.end,
      next: function(startDate, val) {
        val = val === value ? constraint.extent(startDate)[0] : value;
        return constraint.next(startDate, val);
      },
      prev: function(startDate, val) {
        val = val === value ? value - 1 : constraint.extent(startDate)[1];
        return constraint.prev(startDate, val);
      }
    };
  };
  later2.compile = function(schedDef) {
    var constraints = [], constraintsLen = 0, tickConstraint;
    for (var key in schedDef) {
      var nameParts = key.split("_"), name = nameParts[0], mod = nameParts[1], vals = schedDef[key], constraint = mod ? later2.modifier[mod](later2[name], vals) : later2[name];
      constraints.push({
        constraint,
        vals
      });
      constraintsLen++;
    }
    constraints.sort(function(a, b) {
      var ra = a.constraint.range, rb = b.constraint.range;
      return rb < ra ? -1 : rb > ra ? 1 : 0;
    });
    tickConstraint = constraints[constraintsLen - 1].constraint;
    function compareFn(dir) {
      return dir === "next" ? function(a, b) {
        return a.getTime() > b.getTime();
      } : function(a, b) {
        return b.getTime() > a.getTime();
      };
    }
    return {
      start: function(dir, startDate) {
        var next = startDate, nextVal = later2.array[dir], maxAttempts = 1e3, done;
        while (maxAttempts-- && !done && next) {
          done = true;
          for (var i = 0; i < constraintsLen; i++) {
            var constraint2 = constraints[i].constraint, curVal = constraint2.val(next), extent = constraint2.extent(next), newVal = nextVal(curVal, constraints[i].vals, extent);
            if (!constraint2.isValid(next, newVal)) {
              next = constraint2[dir](next, newVal);
              done = false;
              break;
            }
          }
        }
        if (next !== later2.NEVER) {
          next = dir === "next" ? tickConstraint.start(next) : tickConstraint.end(next);
        }
        return next;
      },
      end: function(dir, startDate) {
        var result, nextVal = later2.array[dir + "Invalid"], compare = compareFn(dir);
        for (var i = constraintsLen - 1; i >= 0; i--) {
          var constraint2 = constraints[i].constraint, curVal = constraint2.val(startDate), extent = constraint2.extent(startDate), newVal = nextVal(curVal, constraints[i].vals, extent), next;
          if (newVal !== void 0) {
            next = constraint2[dir](startDate, newVal);
            if (next && (!result || compare(result, next))) {
              result = next;
            }
          }
        }
        return result;
      },
      tick: function(dir, date) {
        return new Date(dir === "next" ? tickConstraint.end(date).getTime() + later2.SEC : tickConstraint.start(date).getTime() - later2.SEC);
      },
      // PATCH
      tickSafe: function(dir, date) {
        return dir === "next" ? diffSecond(tickConstraint.end(date), 1) : diffSecond(tickConstraint.start(date), -1);
      },
      // EOF PATCH
      tickStart: function(date) {
        return tickConstraint.start(date);
      }
    };
  };
  later2.schedule = function(sched) {
    if (!sched)
      throw new Error("Missing schedule definition.");
    if (!sched.schedules)
      throw new Error("Definition must include at least one schedule.");
    var schedules = [], schedulesLen = sched.schedules.length, exceptions = [], exceptionsLen = sched.exceptions ? sched.exceptions.length : 0;
    for (var i = 0; i < schedulesLen; i++) {
      schedules.push(later2.compile(sched.schedules[i]));
    }
    for (var j = 0; j < exceptionsLen; j++) {
      exceptions.push(later2.compile(sched.exceptions[j]));
    }
    function getInstances(dir, count, startDate, endDate, isRange) {
      var compare = compareFn(dir), loopCount = count, maxAttempts = 1e6, schedStarts = [], exceptStarts = [], next, end, results = [], isForward = dir === "next", lastResult, rStart = isForward ? 0 : 1, rEnd = isForward ? 1 : 0;
      startDate = startDate ? new Date(startDate) : /* @__PURE__ */ new Date();
      if (!startDate || !startDate.getTime())
        throw new Error("Invalid start date.");
      setNextStarts(dir, schedules, schedStarts, startDate);
      setRangeStarts(dir, exceptions, exceptStarts, startDate);
      while (maxAttempts-- && loopCount && (next = findNext(schedStarts, compare))) {
        if (endDate && compare(next, endDate)) {
          break;
        }
        if (exceptionsLen) {
          updateRangeStarts(dir, exceptions, exceptStarts, next);
          if (end = calcRangeOverlap(dir, exceptStarts, next)) {
            updateNextStarts(dir, schedules, schedStarts, end);
            continue;
          }
        }
        if (isRange) {
          var maxEndDate = calcMaxEndDate(exceptStarts, compare);
          end = calcEnd(dir, schedules, schedStarts, next, maxEndDate);
          var r = isForward ? [new Date(Math.max(startDate, next)), end ? new Date(endDate ? Math.min(end, endDate) : end) : void 0] : [end ? new Date(endDate ? Math.max(endDate, end.getTime() + later2.SEC) : end.getTime() + later2.SEC) : void 0, new Date(Math.min(startDate, next.getTime() + later2.SEC))];
          if (lastResult && r[rStart].getTime() === lastResult[rEnd].getTime()) {
            lastResult[rEnd] = r[rEnd];
            loopCount++;
          } else {
            lastResult = r;
            results.push(lastResult);
          }
          if (!end)
            break;
          updateNextStarts(dir, schedules, schedStarts, end);
        } else {
          results.push(isForward ? new Date(Math.max(startDate, next)) : getStart(schedules, schedStarts, next, endDate));
          tickStarts(dir, schedules, schedStarts, next);
        }
        loopCount--;
      }
      for (var i2 = 0, len = results.length; i2 < len; i2++) {
        var result = results[i2];
        results[i2] = Object.prototype.toString.call(result) === "[object Array]" ? [cleanDate(result[0]), cleanDate(result[1])] : cleanDate(result);
      }
      return results.length === 0 ? later2.NEVER : count === 1 ? results[0] : results;
    }
    function cleanDate(d) {
      if (d instanceof Date && !isNaN(d.valueOf())) {
        return new Date(d);
      }
      return void 0;
    }
    function setNextStarts(dir, schedArr, startsArr, startDate) {
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        startsArr[i2] = schedArr[i2].start(dir, startDate);
      }
    }
    function updateNextStarts(dir, schedArr, startsArr, startDate) {
      var compare = compareFn(dir);
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        if (startsArr[i2] && !compare(startsArr[i2], startDate)) {
          startsArr[i2] = schedArr[i2].start(dir, startDate);
        }
      }
    }
    function setRangeStarts(dir, schedArr, rangesArr, startDate) {
      var compare = compareFn(dir);
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        var nextStart = schedArr[i2].start(dir, startDate);
        if (!nextStart) {
          rangesArr[i2] = later2.NEVER;
        } else {
          rangesArr[i2] = [nextStart, schedArr[i2].end(dir, nextStart)];
        }
      }
    }
    function updateRangeStarts(dir, schedArr, rangesArr, startDate) {
      var compare = compareFn(dir);
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        if (rangesArr[i2] && !compare(rangesArr[i2][0], startDate)) {
          var nextStart = schedArr[i2].start(dir, startDate);
          if (!nextStart) {
            rangesArr[i2] = later2.NEVER;
          } else {
            rangesArr[i2] = [nextStart, schedArr[i2].end(dir, nextStart)];
          }
        }
      }
    }
    function tickStarts(dir, schedArr, startsArr, startDate) {
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        if (startsArr[i2] && startsArr[i2].getTime() === startDate.getTime()) {
          const newStart = schedArr[i2].start(dir, schedArr[i2].tick(dir, startDate));
          if (newStart !== later2.NEVER && newStart.getTime() === startsArr[i2].getTime()) {
            startsArr[i2] = schedArr[i2].start(dir, schedArr[i2].tickSafe(dir, startDate));
          } else {
            startsArr[i2] = newStart;
          }
        }
      }
    }
    function getStart(schedArr, startsArr, startDate, minEndDate) {
      var result;
      for (var i2 = 0, len = startsArr.length; i2 < len; i2++) {
        if (startsArr[i2] && startsArr[i2].getTime() === startDate.getTime()) {
          var start = schedArr[i2].tickStart(startDate);
          if (minEndDate && start < minEndDate) {
            return minEndDate;
          }
          if (!result || start > result) {
            result = start;
          }
        }
      }
      return result;
    }
    function calcRangeOverlap(dir, rangesArr, startDate) {
      var compare = compareFn(dir), result;
      for (var i2 = 0, len = rangesArr.length; i2 < len; i2++) {
        var range = rangesArr[i2];
        if (range && !compare(range[0], startDate) && (!range[1] || compare(range[1], startDate))) {
          if (!result || compare(range[1], result)) {
            result = range[1];
          }
        }
      }
      return result;
    }
    function calcMaxEndDate(exceptsArr, compare) {
      var result;
      for (var i2 = 0, len = exceptsArr.length; i2 < len; i2++) {
        if (exceptsArr[i2] && (!result || compare(result, exceptsArr[i2][0]))) {
          result = exceptsArr[i2][0];
        }
      }
      return result;
    }
    function calcEnd(dir, schedArr, startsArr, startDate, maxEndDate) {
      var compare = compareFn(dir), result;
      for (var i2 = 0, len = schedArr.length; i2 < len; i2++) {
        var start = startsArr[i2];
        if (start && start.getTime() === startDate.getTime()) {
          var end = schedArr[i2].end(dir, start);
          if (maxEndDate && (!end || compare(end, maxEndDate))) {
            return maxEndDate;
          }
          if (!result || compare(end, result)) {
            result = end;
          }
        }
      }
      return result;
    }
    function compareFn(dir) {
      return dir === "next" ? function(a, b) {
        return !b || a.getTime() > b.getTime();
      } : function(a, b) {
        return !a || b.getTime() > a.getTime();
      };
    }
    function findNext(arr, compare) {
      var next = arr[0];
      for (var i2 = 1, len = arr.length; i2 < len; i2++) {
        if (arr[i2] && compare(next, arr[i2])) {
          next = arr[i2];
        }
      }
      return next;
    }
    return {
      isValid: function(d) {
        return getInstances("next", 1, d, d) !== later2.NEVER;
      },
      next: function(count, startDate, endDate) {
        return getInstances("next", count || 1, startDate, endDate);
      },
      prev: function(count, startDate, endDate) {
        return getInstances("prev", count || 1, startDate, endDate);
      },
      nextRange: function(count, startDate, endDate) {
        return getInstances("next", count || 1, startDate, endDate, true);
      },
      prevRange: function(count, startDate, endDate) {
        return getInstances("prev", count || 1, startDate, endDate, true);
      }
    };
  };
  later2.setTimeout = function(fn2, sched) {
    var s = later2.schedule(sched), t;
    if (fn2) {
      scheduleTimeout();
    }
    function scheduleTimeout() {
      var now2 = Date.now(), next = s.next(2, now2);
      if (!next[0]) {
        t = void 0;
        return;
      }
      var diff = next[0].getTime() - now2;
      if (diff < 1e3) {
        diff = next[1] ? next[1].getTime() - now2 : 1e3;
      }
      if (diff < 2147483647) {
        t = setTimeout(fn2, diff);
      } else {
        t = setTimeout(scheduleTimeout, 2147483647);
      }
    }
    return {
      isDone: function() {
        return !t;
      },
      clear: function() {
        clearTimeout(t);
      }
    };
  };
  later2.setInterval = function(fn2, sched) {
    if (!fn2) {
      return;
    }
    var t = later2.setTimeout(scheduleTimeout, sched), done = t.isDone();
    function scheduleTimeout() {
      if (!done) {
        fn2();
        t = later2.setTimeout(scheduleTimeout, sched);
      }
    }
    return {
      isDone: function() {
        return t.isDone();
      },
      clear: function() {
        done = true;
        t.clear();
      }
    };
  };
  later2.date = {};
  later2.date.timezone = function(useLocalTime) {
    later2.date.build = useLocalTime ? function(Y, M, D, h, m, s) {
      return new Date(Y, M, D, h, m, s);
    } : function(Y, M, D, h, m, s) {
      return new Date(Date.UTC(Y, M, D, h, m, s));
    };
    var get = useLocalTime ? "get" : "getUTC", d = Date.prototype;
    later2.date.getYear = d[get + "FullYear"];
    later2.date.getMonth = d[get + "Month"];
    later2.date.getDate = d[get + "Date"];
    later2.date.getDay = d[get + "Day"];
    later2.date.getHour = d[get + "Hours"];
    later2.date.getMin = d[get + "Minutes"];
    later2.date.getSec = d[get + "Seconds"];
    later2.date.isUTC = !useLocalTime;
  };
  later2.date.UTC = function() {
    later2.date.timezone(false);
  };
  later2.date.localTime = function() {
    later2.date.timezone(true);
  };
  later2.date.UTC();
  later2.SEC = 1e3;
  later2.MIN = later2.SEC * 60;
  later2.HOUR = later2.MIN * 60;
  later2.DAY = later2.HOUR * 24;
  later2.WEEK = later2.DAY * 7;
  later2.DAYS_IN_MONTH = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  later2.NEVER = 0;
  later2.date.next = function(Y, M, D, h, m, s) {
    return later2.date.build(Y, M !== void 0 ? M - 1 : 0, D !== void 0 ? D : 1, h || 0, m || 0, s || 0);
  };
  later2.date.nextRollover = function(d, val, constraint, period) {
    var cur = constraint.val(d), max = constraint.extent(d)[1];
    return (val || max) <= cur || val > max ? new Date(period.end(d).getTime() + later2.SEC) : period.start(d);
  };
  later2.date.prev = function(Y, M, D, h, m, s) {
    var len = arguments.length;
    M = len < 2 ? 11 : M - 1;
    D = len < 3 ? later2.D.extent(later2.date.next(Y, M + 1))[1] : D;
    h = len < 4 ? 23 : h;
    m = len < 5 ? 59 : m;
    s = len < 6 ? 59 : s;
    return later2.date.build(Y, M, D, h, m, s);
  };
  later2.date.prevRollover = function(d, val, constraint, period) {
    var cur = constraint.val(d);
    return val >= cur || !val ? period.start(period.prev(d, period.val(d) - 1)) : period.start(d);
  };
  later2.parse = {};
  later2.parse.cron = function(expr, hasSeconds) {
    var NAMES = {
      JAN: 1,
      FEB: 2,
      MAR: 3,
      APR: 4,
      MAY: 5,
      JUN: 6,
      JUL: 7,
      AUG: 8,
      SEP: 9,
      OCT: 10,
      NOV: 11,
      DEC: 12,
      SUN: 1,
      MON: 2,
      TUE: 3,
      WED: 4,
      THU: 5,
      FRI: 6,
      SAT: 7
    };
    var REPLACEMENTS = {
      "* * * * * *": "0/1 * * * * *",
      "@YEARLY": "0 0 1 1 *",
      "@ANNUALLY": "0 0 1 1 *",
      "@MONTHLY": "0 0 1 * *",
      "@WEEKLY": "0 0 * * 0",
      "@DAILY": "0 0 * * *",
      "@HOURLY": "0 * * * *"
    };
    var FIELDS = {
      s: [0, 0, 59],
      m: [1, 0, 59],
      h: [2, 0, 23],
      D: [3, 1, 31],
      M: [4, 1, 12],
      Y: [6, 1970, 2099],
      d: [5, 1, 7, 1]
    };
    function getValue(value, offset, max) {
      return isNaN(value) ? NAMES[value] || null : Math.min(+value + (offset || 0), max || 9999);
    }
    function cloneSchedule(sched) {
      var clone = {}, field;
      for (field in sched) {
        if (field !== "dc" && field !== "d") {
          clone[field] = sched[field].slice(0);
        }
      }
      return clone;
    }
    function add(sched, name, min2, max, inc) {
      var i = min2;
      if (!sched[name]) {
        sched[name] = [];
      }
      while (i <= max) {
        if (sched[name].indexOf(i) < 0) {
          sched[name].push(i);
        }
        i += inc || 1;
      }
      sched[name].sort(function(a, b) {
        return a - b;
      });
    }
    function addHash(schedules, curSched, value, hash) {
      if (curSched.d && !curSched.dc || curSched.dc && curSched.dc.indexOf(hash) < 0) {
        schedules.push(cloneSchedule(curSched));
        curSched = schedules[schedules.length - 1];
      }
      add(curSched, "d", value, value);
      add(curSched, "dc", hash, hash);
    }
    function addWeekday(s, curSched, value) {
      var except1 = {}, except2 = {};
      if (value === 1) {
        add(curSched, "D", 1, 3);
        add(curSched, "d", NAMES.MON, NAMES.FRI);
        add(except1, "D", 2, 2);
        add(except1, "d", NAMES.TUE, NAMES.FRI);
        add(except2, "D", 3, 3);
        add(except2, "d", NAMES.TUE, NAMES.FRI);
      } else {
        add(curSched, "D", value - 1, value + 1);
        add(curSched, "d", NAMES.MON, NAMES.FRI);
        add(except1, "D", value - 1, value - 1);
        add(except1, "d", NAMES.MON, NAMES.THU);
        add(except2, "D", value + 1, value + 1);
        add(except2, "d", NAMES.TUE, NAMES.FRI);
      }
      s.exceptions.push(except1);
      s.exceptions.push(except2);
    }
    function addRange(item, curSched, name, min2, max, offset) {
      var incSplit = item.split("/"), inc = +incSplit[1], range = incSplit[0];
      if (range !== "*" && range !== "0") {
        var rangeSplit = range.split("-");
        min2 = getValue(rangeSplit[0], offset, max);
        max = getValue(rangeSplit[1], offset, max) || max;
      }
      add(curSched, name, min2, max, inc);
    }
    function parse(item, s, name, min2, max, offset) {
      var value, split2, schedules = s.schedules, curSched = schedules[schedules.length - 1];
      if (item === "L") {
        item = min2 - 1;
      }
      if ((value = getValue(item, offset, max)) !== null) {
        add(curSched, name, value, value);
      } else if ((value = getValue(item.replace("W", ""), offset, max)) !== null) {
        addWeekday(s, curSched, value);
      } else if ((value = getValue(item.replace("L", ""), offset, max)) !== null) {
        addHash(schedules, curSched, value, min2 - 1);
      } else if ((split2 = item.split("#")).length === 2) {
        value = getValue(split2[0], offset, max);
        addHash(schedules, curSched, value, getValue(split2[1]));
      } else {
        addRange(item, curSched, name, min2, max, offset);
      }
    }
    function isHash(item) {
      return item.indexOf("#") > -1 || item.indexOf("L") > 0;
    }
    function itemSorter(a, b) {
      return isHash(a) && !isHash(b) ? 1 : a - b;
    }
    function parseExpr(expr2) {
      var schedule = {
        schedules: [{}],
        exceptions: []
      }, components = expr2.replace(/(\s)+/g, " ").split(" "), field, f, component, items2;
      for (field in FIELDS) {
        f = FIELDS[field];
        component = components[f[0]];
        if (component && component !== "*" && component !== "?") {
          items2 = component.split(",").sort(itemSorter);
          var i, length = items2.length;
          for (i = 0; i < length; i++) {
            parse(items2[i], schedule, field, f[1], f[2], f[3]);
          }
        }
      }
      return schedule;
    }
    function prepareExpr(expr2) {
      var prepared = expr2.toUpperCase();
      return REPLACEMENTS[prepared] || prepared;
    }
    var e = prepareExpr(expr);
    return parseExpr(hasSeconds ? e : "0 " + e);
  };
  later2.parse.recur = function() {
    var schedules = [], exceptions = [], cur, curArr = schedules, curName, values, every2, modifier, applyMin, applyMax, i, last;
    function add(name, min2, max) {
      name = modifier ? name + "_" + modifier : name;
      if (!cur) {
        curArr.push({});
        cur = curArr[0];
      }
      if (!cur[name]) {
        cur[name] = [];
      }
      curName = cur[name];
      if (every2) {
        values = [];
        for (i = min2; i <= max; i += every2) {
          values.push(i);
        }
        last = {
          n: name,
          x: every2,
          c: curName.length,
          m: max
        };
      }
      values = applyMin ? [min2] : applyMax ? [max] : values;
      var length = values.length;
      for (i = 0; i < length; i += 1) {
        var val = values[i];
        if (curName.indexOf(val) < 0) {
          curName.push(val);
        }
      }
      values = every2 = modifier = applyMin = applyMax = 0;
    }
    return {
      schedules,
      exceptions,
      on: function() {
        values = arguments[0] instanceof Array ? arguments[0] : arguments;
        return this;
      },
      every: function(x) {
        every2 = x || 1;
        return this;
      },
      after: function(x) {
        modifier = "a";
        values = [x];
        return this;
      },
      before: function(x) {
        modifier = "b";
        values = [x];
        return this;
      },
      first: function() {
        applyMin = 1;
        return this;
      },
      last: function() {
        applyMax = 1;
        return this;
      },
      time: function() {
        for (var i2 = 0, len = values.length; i2 < len; i2++) {
          var split2 = values[i2].split(":");
          if (split2.length < 3)
            split2.push(0);
          values[i2] = +split2[0] * 3600 + +split2[1] * 60 + +split2[2];
        }
        add("t");
        return this;
      },
      second: function() {
        add("s", 0, 59);
        return this;
      },
      minute: function() {
        add("m", 0, 59);
        return this;
      },
      hour: function() {
        add("h", 0, 23);
        return this;
      },
      dayOfMonth: function() {
        add("D", 1, applyMax ? 0 : 31);
        return this;
      },
      dayOfWeek: function() {
        add("d", 1, 7);
        return this;
      },
      onWeekend: function() {
        values = [1, 7];
        return this.dayOfWeek();
      },
      onWeekday: function() {
        values = [2, 3, 4, 5, 6];
        return this.dayOfWeek();
      },
      dayOfWeekCount: function() {
        add("dc", 1, applyMax ? 0 : 5);
        return this;
      },
      dayOfYear: function() {
        add("dy", 1, applyMax ? 0 : 366);
        return this;
      },
      weekOfMonth: function() {
        add("wm", 1, applyMax ? 0 : 5);
        return this;
      },
      weekOfYear: function() {
        add("wy", 1, applyMax ? 0 : 53);
        return this;
      },
      month: function() {
        add("M", 1, 12);
        return this;
      },
      year: function() {
        add("Y", 1970, 2450);
        return this;
      },
      fullDate: function() {
        for (var i2 = 0, len = values.length; i2 < len; i2++) {
          values[i2] = values[i2].getTime();
        }
        add("fd");
        return this;
      },
      customModifier: function(id, vals) {
        var custom = later2.modifier[id];
        if (!custom)
          throw new Error("Custom modifier " + id + " not recognized!");
        modifier = id;
        values = arguments[1] instanceof Array ? arguments[1] : [arguments[1]];
        return this;
      },
      customPeriod: function(id) {
        var custom = later2[id];
        if (!custom)
          throw new Error("Custom time period " + id + " not recognized!");
        add(id, custom.extent(/* @__PURE__ */ new Date())[0], custom.extent(/* @__PURE__ */ new Date())[1]);
        return this;
      },
      startingOn: function(start) {
        return this.between(start, last.m);
      },
      between: function(start, end) {
        cur[last.n] = cur[last.n].splice(0, last.c);
        every2 = last.x;
        add(last.n, start, end);
        return this;
      },
      and: function() {
        cur = curArr[curArr.push({}) - 1];
        return this;
      },
      except: function() {
        curArr = exceptions;
        cur = null;
        return this;
      }
    };
  };
  later2.parse.text = function(str) {
    var recur = later2.parse.recur, pos = 0, input = "", error;
    var TOKENTYPES = {
      eof: /^$/,
      fullDate: /^(\d\d\d\d-\d\d-\d\dt\d\d:\d\d:\d\d)\b/,
      rank: /^((\d\d\d\d)|([2-5]?1(st)?|[2-5]?2(nd)?|[2-5]?3(rd)?|(0|[1-5]?[4-9]|[1-5]0|1[1-3])(th)?))\b/,
      time: /^((([0]?[1-9]|1[0-2]):[0-5]\d(\s)?(am|pm))|(([0]?\d|1\d|2[0-3]):[0-5]\d))\b/,
      dayName: /^((sun|mon|tue(s)?|wed(nes)?|thu(r(s)?)?|fri|sat(ur)?)(day)?)\b/,
      monthName: /^(jan(uary)?|feb(ruary)?|ma((r(ch)?)?|y)|apr(il)?|ju(ly|ne)|aug(ust)?|oct(ober)?|(sept|nov|dec)(ember)?)\b/,
      yearIndex: /^(\d\d\d\d)\b/,
      every: /^every\b/,
      after: /^after\b/,
      before: /^before\b/,
      second: /^(s|sec(ond)?(s)?)\b/,
      minute: /^(m|min(ute)?(s)?)\b/,
      hour: /^(h|hour(s)?)\b/,
      day: /^(day(s)?( of the month)?)\b/,
      dayInstance: /^day instance\b/,
      dayOfWeek: /^day(s)? of the week\b/,
      dayOfYear: /^day(s)? of the year\b/,
      weekOfYear: /^week(s)?( of the year)?\b/,
      weekOfMonth: /^week(s)? of the month\b/,
      weekday: /^weekday\b/,
      weekend: /^weekend\b/,
      month: /^month(s)?\b/,
      year: /^year(s)?\b/,
      between: /^between (the)?\b/,
      start: /^(start(ing)? (at|on( the)?)?)\b/,
      at: /^(at|@)\b/,
      and: /^(,|and\b)/,
      except: /^(except\b)/,
      also: /(also)\b/,
      first: /^(first)\b/,
      last: /^last\b/,
      "in": /^in\b/,
      of: /^of\b/,
      onthe: /^on the\b/,
      on: /^on\b/,
      through: /(-|^(to|through)\b)/
    };
    var NAMES = {
      jan: 1,
      feb: 2,
      mar: 3,
      apr: 4,
      may: 5,
      jun: 6,
      jul: 7,
      aug: 8,
      sep: 9,
      oct: 10,
      nov: 11,
      dec: 12,
      sun: 1,
      mon: 2,
      tue: 3,
      wed: 4,
      thu: 5,
      fri: 6,
      sat: 7,
      "1st": 1,
      fir: 1,
      "2nd": 2,
      sec: 2,
      "3rd": 3,
      thi: 3,
      "4th": 4,
      "for": 4
    };
    function t(start, end, text, type) {
      return {
        startPos: start,
        endPos: end,
        text,
        type
      };
    }
    function peek(expected) {
      var scanTokens = expected instanceof Array ? expected : [expected], whiteSpace = /\s+/, token, curInput, m, scanToken, start, len;
      scanTokens.push(whiteSpace);
      start = pos;
      while (!token || token.type === whiteSpace) {
        len = -1;
        curInput = input.substring(start);
        token = t(start, start, input.split(whiteSpace)[0]);
        var i, length = scanTokens.length;
        for (i = 0; i < length; i++) {
          scanToken = scanTokens[i];
          m = scanToken.exec(curInput);
          if (m && m.index === 0 && m[0].length > len) {
            len = m[0].length;
            token = t(start, start + len, curInput.substring(0, len), scanToken);
          }
        }
        if (token.type === whiteSpace) {
          start = token.endPos;
        }
      }
      return token;
    }
    function scan(expectedToken) {
      var token = peek(expectedToken);
      pos = token.endPos;
      return token;
    }
    function parseThroughExpr(tokenType) {
      var start = +parseTokenValue(tokenType), end = checkAndParse(TOKENTYPES.through) ? +parseTokenValue(tokenType) : start, nums = [];
      for (var i = start; i <= end; i++) {
        nums.push(i);
      }
      return nums;
    }
    function parseRanges(tokenType) {
      var nums = parseThroughExpr(tokenType);
      while (checkAndParse(TOKENTYPES.and)) {
        nums.push.apply(nums, parseThroughExpr(tokenType));
      }
      if (tokenType === TOKENTYPES.dayName) {
        nums.sort((a, b) => a - b);
      }
      return nums;
    }
    function parseEvery(r) {
      var num, period, start, end;
      if (checkAndParse(TOKENTYPES.weekend)) {
        r.on(NAMES.sun, NAMES.sat).dayOfWeek();
      } else if (checkAndParse(TOKENTYPES.weekday)) {
        r.on(NAMES.mon, NAMES.tue, NAMES.wed, NAMES.thu, NAMES.fri).dayOfWeek();
      } else {
        num = parseTokenValue(TOKENTYPES.rank);
        r.every(num);
        period = parseTimePeriod(r);
        if (checkAndParse(TOKENTYPES.start)) {
          num = parseTokenValue(TOKENTYPES.rank);
          r.startingOn(num);
          parseToken(period.type);
        } else if (checkAndParse(TOKENTYPES.between)) {
          start = parseTokenValue(TOKENTYPES.rank);
          if (checkAndParse(TOKENTYPES.and)) {
            end = parseTokenValue(TOKENTYPES.rank);
            r.between(start, end);
          }
        }
      }
    }
    function parseOnThe(r) {
      if (checkAndParse(TOKENTYPES.first)) {
        r.first();
      } else if (checkAndParse(TOKENTYPES.last)) {
        r.last();
      } else {
        r.on(parseRanges(TOKENTYPES.rank));
      }
      parseTimePeriod(r);
    }
    function parseScheduleExpr(str2) {
      pos = 0;
      input = str2;
      error = -1;
      var r = recur();
      while (pos < input.length && error < 0) {
        var token = parseToken([TOKENTYPES.every, TOKENTYPES.after, TOKENTYPES.before, TOKENTYPES.onthe, TOKENTYPES.on, TOKENTYPES.of, TOKENTYPES["in"], TOKENTYPES.at, TOKENTYPES.and, TOKENTYPES.except, TOKENTYPES.also]);
        switch (token.type) {
          case TOKENTYPES.every:
            parseEvery(r);
            break;
          case TOKENTYPES.after:
            if (peek(TOKENTYPES.time).type !== void 0) {
              r.after(parseTokenValue(TOKENTYPES.time));
              r.time();
            } else if (peek(TOKENTYPES.fullDate).type !== void 0) {
              r.after(parseTokenValue(TOKENTYPES.fullDate));
              r.fullDate();
            } else {
              r.after(parseTokenValue(TOKENTYPES.rank));
              parseTimePeriod(r);
            }
            break;
          case TOKENTYPES.before:
            if (peek(TOKENTYPES.time).type !== void 0) {
              r.before(parseTokenValue(TOKENTYPES.time));
              r.time();
            } else if (peek(TOKENTYPES.fullDate).type !== void 0) {
              r.before(parseTokenValue(TOKENTYPES.fullDate));
              r.fullDate();
            } else {
              r.before(parseTokenValue(TOKENTYPES.rank));
              parseTimePeriod(r);
            }
            break;
          case TOKENTYPES.onthe:
            parseOnThe(r);
            break;
          case TOKENTYPES.on:
            r.on(parseRanges(TOKENTYPES.dayName)).dayOfWeek();
            break;
          case TOKENTYPES.of:
            r.on(parseRanges(TOKENTYPES.monthName)).month();
            break;
          case TOKENTYPES["in"]:
            r.on(parseRanges(TOKENTYPES.yearIndex)).year();
            break;
          case TOKENTYPES.at:
            r.on(parseTokenValue(TOKENTYPES.time)).time();
            while (checkAndParse(TOKENTYPES.and)) {
              r.on(parseTokenValue(TOKENTYPES.time)).time();
            }
            break;
          case TOKENTYPES.and:
            break;
          case TOKENTYPES.also:
            r.and();
            break;
          case TOKENTYPES.except:
            r.except();
            break;
          default:
            error = pos;
        }
      }
      return {
        schedules: r.schedules,
        exceptions: r.exceptions,
        error
      };
    }
    function parseTimePeriod(r) {
      var timePeriod = parseToken([TOKENTYPES.second, TOKENTYPES.minute, TOKENTYPES.hour, TOKENTYPES.dayOfYear, TOKENTYPES.dayOfWeek, TOKENTYPES.dayInstance, TOKENTYPES.day, TOKENTYPES.month, TOKENTYPES.year, TOKENTYPES.weekOfMonth, TOKENTYPES.weekOfYear]);
      switch (timePeriod.type) {
        case TOKENTYPES.second:
          r.second();
          break;
        case TOKENTYPES.minute:
          r.minute();
          break;
        case TOKENTYPES.hour:
          r.hour();
          break;
        case TOKENTYPES.dayOfYear:
          r.dayOfYear();
          break;
        case TOKENTYPES.dayOfWeek:
          r.dayOfWeek();
          break;
        case TOKENTYPES.dayInstance:
          r.dayOfWeekCount();
          break;
        case TOKENTYPES.day:
          r.dayOfMonth();
          break;
        case TOKENTYPES.weekOfMonth:
          r.weekOfMonth();
          break;
        case TOKENTYPES.weekOfYear:
          r.weekOfYear();
          break;
        case TOKENTYPES.month:
          r.month();
          break;
        case TOKENTYPES.year:
          r.year();
          break;
        default:
          error = pos;
      }
      return timePeriod;
    }
    function checkAndParse(tokenType) {
      var found = peek(tokenType).type === tokenType;
      if (found) {
        scan(tokenType);
      }
      return found;
    }
    function parseToken(tokenType) {
      var t2 = scan(tokenType);
      if (t2.type) {
        t2.text = convertString(t2.text, tokenType);
      } else {
        error = pos;
      }
      return t2;
    }
    function parseTokenValue(tokenType) {
      return parseToken(tokenType).text;
    }
    function convertString(str2, tokenType) {
      var output = str2;
      switch (tokenType) {
        case TOKENTYPES.time:
          var parts = str2.split(/(:|am|pm)/), hour2 = parts[3] === "pm" && parts[0] < 12 ? parseInt(parts[0], 10) + 12 : parts[0], min2 = parts[2].trim();
          output = (hour2.length === 1 ? "0" : "") + hour2 + ":" + min2;
          break;
        case TOKENTYPES.rank:
          output = parseInt(/^\d+/.exec(str2)[0], 10);
          break;
        case TOKENTYPES.monthName:
        case TOKENTYPES.dayName:
          output = NAMES[str2.substring(0, 3)];
          break;
        case TOKENTYPES.fullDate:
          output = new Date(str2.toUpperCase());
          break;
      }
      return output;
    }
    return parseScheduleExpr(str.toLowerCase());
  };
  return later2;
}();
later.date.localTime();
var later_default = later;

// ../chronograph/src/collection/Iterator.js
function split(iterable) {
  const gen1Pending = [];
  const gen2Pending = [];
  let iterator;
  const gen1 = function* () {
    if (!iterator)
      iterator = iterable[Symbol.iterator]();
    while (true) {
      if (gen1Pending.length) {
        yield* gen1Pending;
        gen1Pending.length = 0;
      }
      if (!iterator)
        break;
      const { value, done } = iterator.next();
      if (done) {
        iterator = null;
        iterable = null;
        break;
      }
      gen2Pending.push(value);
      yield value;
    }
  };
  const gen2 = function* () {
    if (!iterator)
      iterator = iterable[Symbol.iterator]();
    while (true) {
      if (gen2Pending.length) {
        yield* gen2Pending;
        gen2Pending.length = 0;
      }
      if (!iterator)
        break;
      const { value, done } = iterator.next();
      if (done) {
        iterator = null;
        iterable = null;
        break;
      }
      gen1Pending.push(value);
      yield value;
    }
  };
  return [gen1(), gen2()];
}
function* inBatchesBySize(iterator, batchSize) {
  if (batchSize < 0)
    throw new Error("Batch size needs to a natural number");
  batchSize = batchSize | 0;
  const runningBatch = [];
  for (const el of iterator) {
    if (runningBatch.length === batchSize) {
      yield runningBatch;
      runningBatch.length = 0;
    }
    runningBatch.push(el);
  }
  if (runningBatch.length > 0)
    yield runningBatch;
}
function* filter(iterator, func) {
  let i = 0;
  for (const el of iterator) {
    if (func(el, i++))
      yield el;
  }
}
function* drop(iterator, howMany) {
  let i = 0;
  for (const el of iterator) {
    if (++i > howMany)
      yield el;
  }
}
function every(iterator, func) {
  let i = 0;
  for (const el of iterator) {
    if (!func(el, i++))
      return false;
  }
  return true;
}
function some(iterator, func) {
  let i = 0;
  for (const el of iterator) {
    if (func(el, i++))
      return true;
  }
  return false;
}
function* map(iterator, func) {
  let i = 0;
  for (const el of iterator)
    yield func(el, i++);
}
function reduce(iterator, func, initialAcc) {
  let i = 0;
  let acc = initialAcc;
  for (const el of iterator) {
    acc = func(acc, el, i++);
  }
  return acc;
}
function* uniqueOnly(iterator) {
  const seen = /* @__PURE__ */ new Set();
  for (const el of iterator) {
    if (!seen.has(el)) {
      seen.add(el);
      yield el;
    }
  }
}
function* uniqueOnlyBy(iterator, func) {
  const seen = /* @__PURE__ */ new Set();
  for (const el of iterator) {
    const uniqueBy = func(el);
    if (!seen.has(uniqueBy)) {
      seen.add(uniqueBy);
      yield el;
    }
  }
}
function* takeWhile(iterator, func) {
  let i = 0;
  for (const el of iterator) {
    if (func(el, i++))
      yield el;
    else
      return;
  }
}
function* concatIterable(iteratorsProducer) {
  for (const iterator of iteratorsProducer)
    yield* iterator;
}
var ChainedIteratorClass = class _ChainedIteratorClass {
  constructor(iterable) {
    this.iterable = void 0;
    if (!iterable)
      throw new Error("Require an iterable instance for chaining");
    this.iterable = iterable;
  }
  derive(iterable) {
    this.iterable = void 0;
    return new _ChainedIteratorClass(iterable);
  }
  copy() {
    const [iter1, iter2] = split(this.iterable);
    this.iterable = iter2;
    return new _ChainedIteratorClass(iter1);
  }
  split() {
    const [iter1, iter2] = split(this.iterable);
    return [new _ChainedIteratorClass(iter1), this.derive(iter2)];
  }
  inBatchesBySize(batchSize) {
    return this.derive(inBatchesBySize(this.iterable, batchSize));
  }
  filter(func) {
    return this.derive(filter(this.iterable, func));
  }
  drop(howMany) {
    return this.derive(drop(this.iterable, howMany));
  }
  map(func) {
    return this.derive(map(this.iterable, func));
  }
  reduce(func, initialAcc) {
    return reduce(this, func, initialAcc);
  }
  concat() {
    return this.derive(concatIterable(this.iterable));
  }
  uniqueOnly() {
    return this.derive(uniqueOnly(this.iterable));
  }
  uniqueOnlyBy(func) {
    return this.derive(uniqueOnlyBy(this.iterable, func));
  }
  every(func) {
    return every(this, func);
  }
  some(func) {
    return some(this, func);
  }
  takeWhile(func) {
    return this.derive(takeWhile(this.iterable, func));
  }
  *[Symbol.iterator]() {
    let iterable = this.iterable;
    if (!iterable)
      throw new Error("Chained iterator already exhausted or used to derive the new one");
    this.iterable = void 0;
    yield* iterable;
    iterable = void 0;
  }
  toArray() {
    return Array.from(this);
  }
  sort(order) {
    return Array.from(this).sort(order);
  }
  toSet() {
    return new Set(this);
  }
  toMap() {
    return new Map(this);
  }
  // toMap<K, V> () : T extends [ K, V ] ? Map<K, V> : never  {
  //     return new Map<K, V>(this.iterable as (T extends [ K, V ] ? Iterable<T> : never)) as (T extends [ K, V ] ? Map<K, V> : never)
  // }
  flush() {
    for (const element of this) {
    }
  }
  memoize() {
    return new MemoizedIteratorClass(this);
  }
};
var ChainedIterator = (iterator) => new ChainedIteratorClass(iterator);
var CI = ChainedIterator;
var MemoizedIteratorClass = class extends ChainedIteratorClass {
  constructor() {
    super(...arguments);
    this.elements = [];
    this.$iterator = void 0;
  }
  set iterable(iterable) {
    this.$iterable = iterable;
  }
  get iterable() {
    return this;
  }
  derive(iterable) {
    return new ChainedIteratorClass(iterable);
  }
  *[Symbol.iterator]() {
    const elements = this.elements;
    if (this.$iterable) {
      if (!this.$iterator)
        this.$iterator = this.$iterable[Symbol.iterator]();
      let iterator = this.$iterator;
      let alreadyConsumed = elements.length;
      if (alreadyConsumed > 0)
        yield* elements;
      while (true) {
        if (elements.length > alreadyConsumed) {
          for (let i = alreadyConsumed; i < elements.length; i++)
            yield elements[i];
          alreadyConsumed = elements.length;
        }
        if (!iterator)
          break;
        const { value, done } = iterator.next();
        if (done) {
          iterator = this.$iterator = null;
          this.$iterable = null;
        } else {
          elements.push(value);
          alreadyConsumed++;
          yield value;
        }
      }
    } else {
      yield* elements;
    }
  }
};
var MemoizedIterator = (iterator) => new MemoizedIteratorClass(iterator);
var MI = MemoizedIterator;

// ../chronograph/src/class/Mixin.js
var MixinInstanceOfProperty = Symbol("MixinIdentity");
var MixinStateProperty = Symbol("MixinStateProperty");
var MixinWalkDepthState = class {
  constructor() {
    this.baseEl = void 0;
    this.sourceEl = void 0;
    this.$elementsByTopoLevel = void 0;
    this.$topoLevels = void 0;
    this.linearizedByTopoLevelsSource = MI(this.linearizedByTopoLevels());
  }
  static new(props) {
    const me = new this();
    props && Object.assign(me, props);
    return me;
  }
  get topoLevels() {
    if (this.$topoLevels !== void 0)
      return this.$topoLevels;
    return this.$topoLevels = this.buildTopoLevels();
  }
  buildTopoLevels() {
    return Array.from(this.elementsByTopoLevel.keys()).sort((level1, level2) => level1 - level2);
  }
  get elementsByTopoLevel() {
    if (this.$elementsByTopoLevel !== void 0)
      return this.$elementsByTopoLevel;
    return this.$elementsByTopoLevel = this.buildElementsByTopoLevel();
  }
  getOrCreateLevel(map2, topoLevel) {
    let elementsAtLevel = map2.get(topoLevel);
    if (!elementsAtLevel) {
      elementsAtLevel = [];
      map2.set(topoLevel, elementsAtLevel);
    }
    return elementsAtLevel;
  }
  buildElementsByTopoLevel() {
    let maxTopoLevel = 0;
    const baseElements = this.baseEl ? CI(this.baseEl.walkDepthState.elementsByTopoLevel.values()).concat().toSet() : /* @__PURE__ */ new Set();
    const map2 = CI(this.sourceEl.requirements).map((mixin2) => mixin2.walkDepthState.elementsByTopoLevel).concat().reduce((elementsByTopoLevel, [topoLevel, mixins]) => {
      if (topoLevel > maxTopoLevel)
        maxTopoLevel = topoLevel;
      this.getOrCreateLevel(elementsByTopoLevel, topoLevel).push(mixins);
      return elementsByTopoLevel;
    }, /* @__PURE__ */ new Map());
    this.getOrCreateLevel(map2, maxTopoLevel + 1).push([this.sourceEl]);
    return CI(map2).map(([level, elements]) => {
      return [level, CI(elements).concat().uniqueOnly().filter((mixin2) => !baseElements.has(mixin2)).sort((mixin1, mixin2) => mixin1.id - mixin2.id)];
    }).toMap();
  }
  *linearizedByTopoLevels() {
    yield* CI(this.topoLevels).map((level) => this.elementsByTopoLevel.get(level)).concat();
  }
};
var MIXIN_ID = 1;
var identity = (a) => class extends a {
};
var ZeroBaseClass = class {
};
var MixinState = class {
  constructor() {
    this.id = MIXIN_ID++;
    this.requirements = [];
    this.baseClass = ZeroBaseClass;
    this.identitySymbol = void 0;
    this.mixinLambda = identity;
    this.walkDepthState = void 0;
    this.$minimalClass = void 0;
    this.name = "";
  }
  static new(props) {
    const me = new this();
    props && Object.assign(me, props);
    me.walkDepthState = MixinWalkDepthState.new({ sourceEl: me, baseEl: getMixinState(me.baseClass) });
    const mixinLambda = me.mixinLambda;
    const symbol = me.identitySymbol = Symbol(mixinLambda.name);
    const mixinLambdaWrapper = Object.assign(function(base) {
      const extendedClass = mixinLambda(base);
      extendedClass.prototype[symbol] = true;
      return extendedClass;
    }, {
      [MixinInstanceOfProperty]: symbol,
      [MixinStateProperty]: me
    });
    Object.defineProperty(mixinLambdaWrapper, Symbol.hasInstance, { value: isInstanceOfStatic });
    me.mixinLambda = mixinLambdaWrapper;
    return me;
  }
  get minimalClass() {
    if (this.$minimalClass !== void 0)
      return this.$minimalClass;
    return this.$minimalClass = this.buildMinimalClass();
  }
  // get hash () : MixinHash {
  //     if (this.$hash !== '') return this.$hash
  //
  //     return this.$hash = this.buildHash()
  // }
  // buildHash () : MixinHash {
  //     return String.fromCharCode(...this.walkDepthState.linearizedByTopoLevelsSource.map(mixin => mixin.id))
  // }
  getBaseClassMixinId(baseClass) {
    const constructor = this.constructor;
    const mixinId = constructor.baseClassesIds.get(baseClass);
    if (mixinId !== void 0)
      return mixinId;
    const newId = MIXIN_ID++;
    constructor.baseClassesIds.set(baseClass, newId);
    return newId;
  }
  buildMinimalClass() {
    const self2 = this.constructor;
    let baseCls = this.baseClass;
    const minimalClassConstructor = this.walkDepthState.linearizedByTopoLevelsSource.reduce((acc, mixin2) => {
      const { cls, hash } = acc;
      const nextHash = hash + String.fromCharCode(mixin2.id);
      let wrapperCls = self2.minimalClassesByLinearHash.get(nextHash);
      if (!wrapperCls) {
        wrapperCls = mixin2.mixinLambda(cls);
        mixin2.name = wrapperCls.name;
        self2.minimalClassesByLinearHash.set(nextHash, wrapperCls);
      }
      acc.cls = wrapperCls;
      acc.hash = nextHash;
      return acc;
    }, { cls: baseCls, hash: String.fromCharCode(this.getBaseClassMixinId(baseCls)) }).cls;
    const minimalClass = Object.assign(minimalClassConstructor, {
      [MixinInstanceOfProperty]: this.identitySymbol,
      [MixinStateProperty]: this,
      mix: this.mixinLambda,
      derive: (base) => Mixin([minimalClass, base], (base2) => class extends base2 {
      }),
      $: this,
      toString: this.toString.bind(this)
    });
    Object.defineProperty(minimalClass, Symbol.hasInstance, { value: isInstanceOfStatic });
    return minimalClass;
  }
  toString() {
    return this.walkDepthState.linearizedByTopoLevelsSource.reduce((acc, mixin2) => `${mixin2.name}(${acc})`, this.baseClass.name);
  }
};
MixinState.minimalClassesByLinearHash = /* @__PURE__ */ new Map();
MixinState.baseClassesIds = /* @__PURE__ */ new Map();
var isMixinClass = (func) => {
  return Object.getPrototypeOf(func.prototype).constructor.hasOwnProperty(MixinStateProperty);
};
var getMixinState = (func) => {
  return Object.getPrototypeOf(func.prototype).constructor[MixinStateProperty];
};
var mixin = (required, mixinLambda) => {
  let baseClass;
  if (required.length > 0) {
    const lastRequirement = required[required.length - 1];
    if (!isMixinClass(lastRequirement) && lastRequirement !== ZeroBaseClass)
      baseClass = lastRequirement;
  }
  const requirements = [];
  required.forEach((requirement, index) => {
    const mixinState2 = requirement[MixinStateProperty];
    if (mixinState2 !== void 0) {
      const currentBaseClass = mixinState2.baseClass;
      if (currentBaseClass !== ZeroBaseClass) {
        if (baseClass) {
          if (baseClass !== currentBaseClass) {
            const currentIsSub = currentBaseClass.prototype.isPrototypeOf(baseClass.prototype);
            const currentIsSuper = baseClass.prototype.isPrototypeOf(currentBaseClass.prototype);
            if (!currentIsSub && !currentIsSuper)
              throw new Error("Base class mismatch");
            baseClass = currentIsSuper ? currentBaseClass : baseClass;
          }
        } else
          baseClass = currentBaseClass;
      }
      requirements.push(mixinState2);
    } else {
      if (index !== required.length - 1)
        throw new Error("Base class should be provided as the last element of the requirements array");
    }
  });
  const mixinState = MixinState.new({
    requirements,
    mixinLambda,
    baseClass: baseClass || ZeroBaseClass
  });
  return mixinState.minimalClass;
};
var isInstanceOfStatic = function(instance) {
  return Boolean(instance && instance[this[MixinInstanceOfProperty]]);
};
var isInstanceOf = (instance, func) => {
  return Boolean(instance && instance[func[MixinInstanceOfProperty]]);
};
var Mixin = mixin;

// ../chronograph/src/class/Base.js
var Base2 = class {
  /**
   * This method applies its 1st argument (if any) to the current instance using `Object.assign()`.
   *
   * Supposed to be overridden in the subclasses to customize the instance creation process.
   *
   * @param props
   */
  initialize(props) {
    props && Object.assign(this, props);
  }
  /**
   * This is a type-safe static constructor method, accepting a single argument, with the object, corresponding to the
   * class properties. It will generate a compilation error, if unknown property is provided.
   *
   * For example:
   *
   * ```ts
   * class MyClass extends Base {
   *     prop     : string
   * }
   *
   * const instance : MyClass = MyClass.new({ prop : 'prop', wrong : 11 })
   * ```
   *
   * will produce:
   *
   * ```plaintext
   * TS2345: Argument of type '{ prop: string; wrong: number; }' is not assignable to parameter of type 'Partial<MyClass>'.
   * Object literal may only specify known properties, and 'wrong' does not exist in type 'Partial<MyClass>'
   * ```
   *
   * The only thing this constructor does is create an instance and call the [[initialize]] method on it, forwarding
   * the first argument. The customization of instance is supposed to be performed in that method.
   *
   * @param props
   */
  static new(props) {
    const instance = new this();
    instance.initialize(props);
    return instance;
  }
};

// ../Engine/lib/Engine/scheduling/Types.js
var TimeUnit;
(function(TimeUnit2) {
  TimeUnit2["Millisecond"] = "millisecond";
  TimeUnit2["Second"] = "second";
  TimeUnit2["Minute"] = "minute";
  TimeUnit2["Hour"] = "hour";
  TimeUnit2["Day"] = "day";
  TimeUnit2["Week"] = "week";
  TimeUnit2["Month"] = "month";
  TimeUnit2["Quarter"] = "quarter";
  TimeUnit2["Year"] = "year";
})(TimeUnit || (TimeUnit = {}));
var ProjectConstraintResolution;
(function(ProjectConstraintResolution2) {
  ProjectConstraintResolution2["Honor"] = "honor";
  ProjectConstraintResolution2["Ignore"] = "ignore";
  ProjectConstraintResolution2["Conflict"] = "conflict";
})(ProjectConstraintResolution || (ProjectConstraintResolution = {}));
var ConstraintType;
(function(ConstraintType2) {
  ConstraintType2["MustStartOn"] = "muststarton";
  ConstraintType2["MustFinishOn"] = "mustfinishon";
  ConstraintType2["StartNoEarlierThan"] = "startnoearlierthan";
  ConstraintType2["StartNoLaterThan"] = "startnolaterthan";
  ConstraintType2["FinishNoEarlierThan"] = "finishnoearlierthan";
  ConstraintType2["FinishNoLaterThan"] = "finishnolaterthan";
  ConstraintType2["AsSoonAsPossible"] = "assoonaspossible";
  ConstraintType2["AsLateAsPossible"] = "aslateaspossible";
})(ConstraintType || (ConstraintType = {}));
var SchedulingMode;
(function(SchedulingMode2) {
  SchedulingMode2["Normal"] = "Normal";
  SchedulingMode2["FixedDuration"] = "FixedDuration";
  SchedulingMode2["FixedEffort"] = "FixedEffort";
  SchedulingMode2["FixedUnits"] = "FixedUnits";
})(SchedulingMode || (SchedulingMode = {}));
var DependencyValidationResult;
(function(DependencyValidationResult2) {
  DependencyValidationResult2[DependencyValidationResult2["NoError"] = 0] = "NoError";
  DependencyValidationResult2[DependencyValidationResult2["CyclicDependency"] = 1] = "CyclicDependency";
  DependencyValidationResult2[DependencyValidationResult2["DuplicatingDependency"] = 2] = "DuplicatingDependency";
})(DependencyValidationResult || (DependencyValidationResult = {}));
var DependencyType;
(function(DependencyType2) {
  DependencyType2[DependencyType2["StartToStart"] = 0] = "StartToStart";
  DependencyType2[DependencyType2["StartToEnd"] = 1] = "StartToEnd";
  DependencyType2[DependencyType2["EndToStart"] = 2] = "EndToStart";
  DependencyType2[DependencyType2["EndToEnd"] = 3] = "EndToEnd";
})(DependencyType || (DependencyType = {}));
var DependenciesCalendar;
(function(DependenciesCalendar2) {
  DependenciesCalendar2["Project"] = "Project";
  DependenciesCalendar2["FromEvent"] = "FromEvent";
  DependenciesCalendar2["ToEvent"] = "ToEvent";
})(DependenciesCalendar || (DependenciesCalendar = {}));
var ProjectType;
(function(ProjectType2) {
  ProjectType2[ProjectType2["SchedulerBasic"] = 1] = "SchedulerBasic";
  ProjectType2[ProjectType2["SchedulerPro"] = 2] = "SchedulerPro";
  ProjectType2[ProjectType2["Gantt"] = 3] = "Gantt";
})(ProjectType || (ProjectType = {}));
var Direction;
(function(Direction2) {
  Direction2["Forward"] = "Forward";
  Direction2["Backward"] = "Backward";
  Direction2["None"] = "None";
})(Direction || (Direction = {}));
var isEqualEffectiveDirection = (a, b) => {
  if (a && !b || !a && b)
    return false;
  if (!a && !b)
    return true;
  return a.direction === b.direction && (a.kind === "own" && b.kind === "own" || a.kind === "enforced" && b.kind === "enforced" && a.enforcedBy === b.enforcedBy || a.kind === "inherited" && b.kind === "inherited" && a.inheritedFrom === b.inheritedFrom);
};
var ConstraintIntervalSide;
(function(ConstraintIntervalSide2) {
  ConstraintIntervalSide2["Start"] = "Start";
  ConstraintIntervalSide2["End"] = "End";
})(ConstraintIntervalSide || (ConstraintIntervalSide = {}));

// ../Engine/lib/Engine/util/Constants.js
var MIN_DATE = /* @__PURE__ */ new Date(-864e13);
var MAX_DATE = /* @__PURE__ */ new Date(864e13);
var isDateFinite = (date) => {
  if (!date)
    return false;
  const time = date.getTime();
  return time !== MIN_DATE.getTime() && time !== MAX_DATE.getTime();
};

// ../Engine/lib/Engine/util/Types.js
var EdgeInclusion;
(function(EdgeInclusion2) {
  EdgeInclusion2[EdgeInclusion2["Left"] = 0] = "Left";
  EdgeInclusion2[EdgeInclusion2["Right"] = 1] = "Right";
})(EdgeInclusion || (EdgeInclusion = {}));

// ../Engine/lib/Engine/calendar/CalendarCache.js
var CalendarIteratorResult;
(function(CalendarIteratorResult2) {
  CalendarIteratorResult2[CalendarIteratorResult2["FullRangeIterated"] = 0] = "FullRangeIterated";
  CalendarIteratorResult2[CalendarIteratorResult2["StoppedByIterator"] = 1] = "StoppedByIterator";
  CalendarIteratorResult2[CalendarIteratorResult2["MaxCacheExtendCyclesReached"] = 2] = "MaxCacheExtendCyclesReached";
  CalendarIteratorResult2[CalendarIteratorResult2["MaxRangeReached"] = 3] = "MaxRangeReached";
})(CalendarIteratorResult || (CalendarIteratorResult = {}));
var CalendarCache = class {
  constructor(config) {
    this.cacheFilledStartDate = MAX_DATE;
    this.cacheFilledEndDate = MIN_DATE;
    this.intervalsCachingChunkDuration = 30;
    this.intervalsCachingChunkUnit = TimeUnit.Day;
    this.maxCacheExtendCycles = 1e3;
    this.maxRange = 5 * 365 * 24 * 60 * 60 * 1e3;
    config && Object.assign(this, config);
  }
  includeWrappingRangeFrom(cache, startDate, endDate) {
    cache.ensureCacheFilledForInterval(startDate, endDate);
    this.intervalCache.includeWrappingRange(cache.intervalCache, startDate, endDate);
  }
  // after this method, we guarantee, that for every point between `startDate` and `endDate` (_inclusive_)
  // we'll have a final representation of the cache, that is, we'll be able to get an interval to which this point belongs
  // _both_ for forward and backward directions
  ensureCacheFilledForInterval(startDate, endDate) {
    const cacheFilledStartDateN = this.cacheFilledStartDate.getTime();
    const cacheFilledEndDateN = this.cacheFilledEndDate.getTime();
    if (cacheFilledStartDateN !== MAX_DATE.getTime()) {
      const startDateN = startDate.getTime();
      const endDateN = endDate.getTime();
      if (cacheFilledStartDateN <= startDateN && endDateN <= cacheFilledEndDateN)
        return;
      if (endDateN <= cacheFilledStartDateN) {
        endDate = new Date(cacheFilledStartDateN - 1);
      } else if (startDateN >= cacheFilledEndDateN) {
        startDate = new Date(cacheFilledEndDateN);
      } else if (cacheFilledStartDateN <= startDateN && startDateN <= cacheFilledEndDateN) {
        startDate = new Date(cacheFilledEndDateN + 1);
      } else if (cacheFilledStartDateN <= endDateN && endDateN <= cacheFilledEndDateN) {
        endDate = new Date(cacheFilledStartDateN - 1);
      } else {
        this.ensureCacheFilledForInterval(startDate, new Date(cacheFilledStartDateN - 1));
        this.ensureCacheFilledForInterval(new Date(cacheFilledEndDateN + 1), endDate);
        return;
      }
    }
    if (cacheFilledStartDateN === MAX_DATE.getTime() || startDate.getTime() < cacheFilledEndDateN) {
      this.cacheFilledStartDate = startDate;
    }
    if (cacheFilledEndDateN === MIN_DATE.getTime() || cacheFilledEndDateN < endDate.getTime()) {
      this.cacheFilledEndDate = endDate;
    }
    this.fillCache(startDate, endDate);
  }
  fillCache(_1, _2) {
    throw new Error("Abstract method");
  }
  clear() {
    this.cacheFilledStartDate = MAX_DATE;
    this.cacheFilledEndDate = MIN_DATE;
    this.intervalCache.clear();
  }
  /**
   * The core iterator method of the calendar cache.
   *
   * @param options The options for iterator. Should contain at least one of the `startDate`/`endDate` properties
   * which indicates what timespan to examine for availability intervals. If one of boundaries is not provided
   * iterator function should return `false` at some point, to avoid infinite loops.
   *
   * Another recognized option is `isForward`, which indicates the direction in which to iterate through the timespan.
   *
   * Another recognized option is `maxRange`, which indicates the maximum timespan for this iterator (in milliseconds). When iterator
   * exceeds this timespan, the iteration is stopped and [[CalendarIteratorResult.MaxRangeReached]] value is returned.
   * Default value is 5 years.
   *
   * @param func The iterator function to call. It will be called for every distinct set of availability intervals, found
   * in the given timespan. All the intervals, which are "active" for current interval are collected in the 3rd argument
   * for this function. If iterator returns `false` (checked with `===`) the iteration stops.
   *
   * @param scope The scope (`this` value) to execute the iterator in.
   */
  forEachAvailabilityInterval(options, func, scope) {
    var _a2;
    scope = scope || this;
    const startDate = options.startDate;
    const endDate = options.endDate;
    const startDateN = startDate && startDate.getTime();
    const endDateN = endDate && endDate.getTime();
    const maxRange = (_a2 = options.maxRange) != null ? _a2 : this.maxRange;
    const isForward = options.isForward !== false;
    if (isForward ? !startDate : !endDate) {
      throw new Error("At least `startDate` or `endDate` is required, depending from the `isForward` option");
    }
    const intervalCache = this.intervalCache;
    let cacheCursorDate = isForward ? startDate : endDate;
    let cursorDate = isForward ? startDate : endDate;
    const rangeStart = cursorDate.getTime();
    for (let cycle = 1; cycle < this.maxCacheExtendCycles; cycle++) {
      if (isForward) {
        this.ensureCacheFilledForInterval(cacheCursorDate, endDate || DateHelper.add(cacheCursorDate, this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit));
      } else {
        this.ensureCacheFilledForInterval(startDate || DateHelper.add(cacheCursorDate, -this.intervalsCachingChunkDuration, this.intervalsCachingChunkUnit), cacheCursorDate);
      }
      let interval = intervalCache.getIntervalOf(cursorDate, isForward ? EdgeInclusion.Left : EdgeInclusion.Right);
      while (interval) {
        const intervalStartDate = interval.startDate;
        const intervalEndDate = interval.endDate;
        if (isForward && endDateN && intervalStartDate.getTime() >= endDateN || !isForward && startDateN && intervalEndDate.getTime() <= startDateN) {
          return CalendarIteratorResult.FullRangeIterated;
        }
        if (isForward && intervalStartDate.getTime() - rangeStart >= maxRange || !isForward && rangeStart - intervalEndDate.getTime() >= maxRange) {
          return CalendarIteratorResult.MaxRangeReached;
        }
        if (isForward && intervalStartDate.getTime() >= this.cacheFilledEndDate.getTime() || !isForward && intervalEndDate.getTime() <= this.cacheFilledStartDate.getTime()) {
          break;
        }
        cursorDate = isForward ? intervalEndDate : intervalStartDate;
        const countFrom = startDateN && intervalStartDate.getTime() < startDateN ? startDate : intervalStartDate;
        const countTill = endDateN && intervalEndDate.getTime() > endDateN ? endDate : intervalEndDate;
        if (func.call(scope, countFrom, countTill, interval.cacheInterval) === false) {
          return CalendarIteratorResult.StoppedByIterator;
        }
        interval = isForward ? intervalCache.getNextInterval(interval) : intervalCache.getPrevInterval(interval);
      }
      if (isForward && cursorDate.getTime() === MAX_DATE.getTime() || !isForward && cursorDate.getTime() === MIN_DATE.getTime()) {
        return CalendarIteratorResult.FullRangeIterated;
      }
      cacheCursorDate = isForward ? this.cacheFilledEndDate : this.cacheFilledStartDate;
    }
    return CalendarIteratorResult.MaxCacheExtendCyclesReached;
  }
};

// ../Engine/lib/Engine/util/StripDuplicates.js
var stripDuplicates = (array) => Array.from(new Set(array));

// ../Engine/lib/Engine/calendar/CalendarCacheInterval.js
var CalendarCacheInterval = class _CalendarCacheInterval {
  constructor(config) {
    this.intervals = [];
    config && Object.assign(this, config);
    if (!this.calendar)
      throw new Error("Required attribute `calendar` is missing");
  }
  includeInterval(interval) {
    if (this.intervals.indexOf(interval) == -1) {
      const copy = this.intervals.slice();
      copy.push(interval);
      return new _CalendarCacheInterval({ intervals: copy, calendar: this.calendar });
    } else
      return this;
  }
  combineWith(interval) {
    return new _CalendarCacheInterval({ intervals: this.intervals.concat(interval.intervals), calendar: this.calendar });
  }
  /**
   * Returns the working status of this intervals set. It is determined as a working status
   * of the most prioritized interval (intervals are prioritized from child to parent)
   */
  getIsWorking() {
    if (this.isWorking != null)
      return this.isWorking;
    const intervals = this.intervals = this.normalizeIntervals(this.intervals);
    return this.isWorking = intervals[0].isWorking;
  }
  normalizeIntervals(intervals) {
    const filtered = stripDuplicates(intervals);
    filtered.sort((interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField());
    return filtered;
  }
};

// ../Engine/lib/Engine/calendar/CalendarCacheIntervalMultiple.js
var CalendarCacheIntervalMultiple = class _CalendarCacheIntervalMultiple {
  constructor(config) {
    this.intervalGroups = [];
    config && Object.assign(this, config);
  }
  combineWith(interval) {
    const copy = this.intervalGroups.slice();
    copy.push([interval.calendar, interval]);
    return new _CalendarCacheIntervalMultiple({ intervalGroups: copy });
  }
  getIsWorkingForEvery() {
    if (this.isWorkingForEvery != null)
      return this.isWorkingForEvery;
    for (let [_calendar, intervals] of this.getGroups()) {
      if (!intervals[0].isWorking)
        return this.isWorkingForEvery = false;
    }
    return this.isWorkingForEvery = true;
  }
  getIsWorkingForSome() {
    if (this.isWorkingForSome != null)
      return this.isWorkingForSome;
    for (let [_calendar, intervals] of this.getGroups()) {
      if (intervals[0].isWorking)
        return this.isWorkingForSome = true;
    }
    return this.isWorkingForSome = false;
  }
  getCalendars() {
    this.getGroups();
    return this.calendars;
  }
  isCalendarWorking(calendar) {
    return this.getCalendarsWorkStatus().get(calendar);
  }
  getCalendarsWorkStatus() {
    if (this.calendarsWorkStatus)
      return this.calendarsWorkStatus;
    const res = /* @__PURE__ */ new Map();
    for (let [calendar, intervals] of this.getGroups()) {
      res.set(calendar, intervals[0].isWorking);
    }
    return this.calendarsWorkStatus = res;
  }
  getCalendarsWorking() {
    if (this.calendarsWorking)
      return this.calendarsWorking;
    const calendars = [];
    for (let [calendar, intervals] of this.getGroups()) {
      if (intervals[0].isWorking)
        calendars.push(calendar);
    }
    return this.calendarsWorking = calendars;
  }
  getCalendarsNonWorking() {
    if (this.calendarsNonWorking)
      return this.calendarsNonWorking;
    const calendars = [];
    for (let [calendar, intervals] of this.getGroups()) {
      if (!intervals[0].isWorking)
        calendars.push(calendar);
    }
    return this.calendarsNonWorking = calendars;
  }
  getGroups() {
    if (this.intervalsByCalendar)
      return this.intervalsByCalendar;
    const calendars = this.calendars = [];
    const intervalsByCalendar = /* @__PURE__ */ new Map();
    this.intervalGroups.forEach(([calendar, interval]) => {
      let data = intervalsByCalendar.get(calendar);
      if (!data) {
        calendars.push(calendar);
        data = [];
        intervalsByCalendar.set(calendar, data);
      }
      data.push.apply(data, interval.intervals);
    });
    intervalsByCalendar.forEach((intervals, calendar) => {
      const unique = stripDuplicates(intervals);
      unique.sort(
        // sort in decreasing order
        (interval1, interval2) => interval2.getPriorityField() - interval1.getPriorityField()
      );
      intervalsByCalendar.set(calendar, unique);
    });
    return this.intervalsByCalendar = intervalsByCalendar;
  }
};

// ../Engine/lib/Engine/util/BinarySearch.js
var binarySearch = (value, array, comparator = (a, b) => a - b) => {
  let left = 0;
  let right = array.length;
  while (left < right) {
    const mid = (left + right) / 2 | 0;
    const compare = comparator(value, array[mid]);
    if (compare === 0)
      return { found: true, index: mid };
    else if (compare < 0)
      right = mid;
    else
      left = mid + 1;
  }
  return { found: false, index: right };
};

// ../Engine/lib/Engine/calendar/SortedMap.js
var IndexPosition;
(function(IndexPosition2) {
  IndexPosition2[IndexPosition2["Exact"] = 0] = "Exact";
  IndexPosition2[IndexPosition2["Next"] = 1] = "Next";
})(IndexPosition || (IndexPosition = {}));
var SortedMap = class {
  constructor(comparator) {
    this.keys = [];
    this.values = [];
    this.comparator = comparator || ((a, b) => a - b);
  }
  set(key, value) {
    const search = binarySearch(key, this.keys, this.comparator);
    if (search.found) {
      this.values[search.index] = value;
    } else {
      this.keys.splice(search.index, 0, key);
      this.values.splice(search.index, 0, value);
    }
    return search.index;
  }
  // you need to know what you are doing when using this method
  insertAt(index, key, value) {
    this.keys.splice(index, 0, key);
    this.values.splice(index, 0, value);
  }
  setValueAt(index, value) {
    this.values[index] = value;
  }
  get(key) {
    const search = binarySearch(key, this.keys, this.comparator);
    return search.found ? this.values[search.index] : void 0;
  }
  getEntryAt(index) {
    return index < this.keys.length ? { key: this.keys[index], value: this.values[index] } : void 0;
  }
  getKeyAt(index) {
    return this.keys[index];
  }
  getValueAt(index) {
    return this.values[index];
  }
  delete(key) {
    const search = binarySearch(key, this.keys, this.comparator);
    if (search.found)
      this.deleteAt(search.index);
  }
  size() {
    return this.keys.length;
  }
  deleteAt(index) {
    this.keys.splice(index, 1);
    this.values.splice(index, 1);
  }
  indexOfKey(key) {
    const search = binarySearch(key, this.keys, this.comparator);
    return {
      found: search.found ? IndexPosition.Exact : IndexPosition.Next,
      index: search.index
    };
  }
  map(func) {
    const keys = this.keys;
    const values = this.values;
    const result = [];
    for (let i = 0; i < keys.length; i++)
      result.push(func(values[i], keys[i], i));
    return result;
  }
  getAllEntries() {
    return this.map((value, key) => {
      return { value, key };
    });
  }
  clear() {
    this.keys.length = 0;
    this.values.length = 0;
  }
};

// ../Engine/lib/Engine/calendar/IntervalCache.js
var IntervalCache = class {
  constructor(config) {
    this.points = new SortedMap((a, b) => a.getTime() - b.getTime());
    this.leftInfinityKey = MIN_DATE;
    this.rightInfinityKey = MAX_DATE;
    Object.assign(this, config);
    if (this.emptyInterval === void 0 || !this.combineIntervalsFn)
      throw new Error("All of `emptyPoint`, `combineIntervalsFn` are required");
    this.points.set(this.leftInfinityKey, this.emptyInterval);
  }
  size() {
    return this.points.size();
  }
  indexOf(date) {
    return this.points.indexOfKey(date);
  }
  getDateAt(index) {
    return this.points.getKeyAt(index);
  }
  getPointAt(index) {
    return this.points.getValueAt(index);
  }
  getIntervalOf(date, edgeInclusion = EdgeInclusion.Left) {
    let { found, index } = this.indexOf(date);
    let startDateIndex;
    if (edgeInclusion === EdgeInclusion.Left) {
      startDateIndex = found === IndexPosition.Exact ? index : index - 1;
    } else {
      startDateIndex = index - 1;
    }
    return this.getIntervalWithStartDateIndex(startDateIndex);
  }
  getPrevInterval(interval) {
    if (interval.startDateIndex === 0)
      return null;
    return this.getIntervalWithStartDateIndex(interval.startDateIndex - 1);
  }
  getNextInterval(interval) {
    if (interval.startDateIndex >= this.size() - 1)
      return null;
    return this.getIntervalWithStartDateIndex(interval.startDateIndex + 1);
  }
  getIntervalWithStartDateIndex(startDateIndex) {
    return {
      startDateIndex,
      startDate: this.getDateAt(startDateIndex),
      endDate: startDateIndex + 1 < this.size() ? this.getDateAt(startDateIndex + 1) : this.rightInfinityKey,
      cacheInterval: this.getPointAt(startDateIndex)
    };
  }
  addInterval(startDate, endDate, extendInterval) {
    const points = this.points;
    const { found, index } = points.indexOfKey(startDate);
    let curIndex;
    let lastUpdatedPoint;
    if (found == IndexPosition.Exact) {
      const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(index));
      points.setValueAt(index, inclusion);
      curIndex = index + 1;
    } else {
      const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(index - 1));
      points.insertAt(index, startDate, inclusion);
      curIndex = index + 1;
    }
    while (curIndex < points.size()) {
      const curDate = points.getKeyAt(curIndex);
      if (curDate.getTime() >= endDate.getTime())
        break;
      const inclusion = extendInterval(lastUpdatedPoint = points.getValueAt(curIndex));
      points.setValueAt(curIndex, inclusion);
      curIndex++;
    }
    if (curIndex === points.size()) {
      points.insertAt(points.size(), endDate, this.emptyInterval);
    } else {
      const curDate = points.getKeyAt(curIndex);
      if (curDate.getTime() === endDate.getTime()) {
      } else {
        points.insertAt(curIndex, endDate, lastUpdatedPoint);
      }
    }
  }
  includeWrappingRange(intervalCache, startDate, endDate) {
    let interval = intervalCache.getIntervalOf(startDate);
    while (interval) {
      this.addInterval(interval.startDate, interval.endDate, (existingInterval) => this.combineIntervalsFn(existingInterval, interval.cacheInterval));
      if (interval.endDate.getTime() > endDate.getTime())
        break;
      interval = intervalCache.getNextInterval(interval);
    }
  }
  getSummary() {
    return this.points.map((label, date) => {
      return { label, date };
    });
  }
  clear() {
    this.points.clear();
    this.points.set(this.leftInfinityKey, this.emptyInterval);
  }
};

// ../Engine/lib/Engine/calendar/CalendarCacheMultiple.js
var CalendarCacheMultiple = class extends CalendarCache {
  constructor(config) {
    super(config);
    this.calendarCaches = stripDuplicates(this.calendarCaches);
    this.intervalCache = new IntervalCache({
      emptyInterval: new CalendarCacheIntervalMultiple(),
      combineIntervalsFn: (interval1, interval2) => {
        return interval1.combineWith(interval2);
      }
    });
  }
  fillCache(startDate, endDate) {
    this.calendarCaches.forEach((calendarCache) => {
      calendarCache.fillCache(startDate, endDate);
      this.includeWrappingRangeFrom(calendarCache, startDate, endDate);
    });
  }
};
var COMBINED_CALENDARS_CACHE = /* @__PURE__ */ new Map();
var combineCalendars = (calendars) => {
  const uniqueOnly2 = stripDuplicates(calendars);
  if (uniqueOnly2.length === 0)
    throw new Error("No calendars to combine");
  uniqueOnly2.sort((calendar1, calendar2) => {
    if (calendar1.internalId < calendar2.internalId)
      return -1;
    else
      return 1;
  });
  const hash = uniqueOnly2.map((calendar) => calendar.internalId + "/").join("");
  const versionsHash = uniqueOnly2.map((calendar) => calendar.version + "/").join("");
  let cached = COMBINED_CALENDARS_CACHE.get(hash);
  let res;
  if (cached && cached.versionsHash === versionsHash)
    res = cached.cache;
  else {
    res = new CalendarCacheMultiple({ calendarCaches: uniqueOnly2.map((calendar) => calendar.calendarCache) });
  }
  return res;
};

// ../Engine/lib/Engine/calendar/CalendarCacheSingle.js
var CalendarCacheSingle = class extends CalendarCache {
  constructor(config) {
    super(config);
    this.staticIntervalsCached = false;
    if (!this.unspecifiedTimeInterval)
      throw new Error("Required attribute `unspecifiedTimeInterval` is missing");
    this.intervalCache = new IntervalCache({
      emptyInterval: new CalendarCacheInterval({
        intervals: [this.unspecifiedTimeInterval],
        calendar: this.calendar
      }),
      combineIntervalsFn: (interval1, interval2) => {
        return interval1.combineWith(interval2);
      }
    });
  }
  fillCache(startDate, endDate) {
    var _a2;
    if (!this.staticIntervalsCached) {
      this.cacheStaticIntervals();
      this.staticIntervalsCached = true;
    }
    if (this.parentCache)
      this.includeWrappingRangeFrom(this.parentCache, startDate, endDate);
    const startDateN = startDate.getTime();
    const endDateN = endDate.getTime();
    const timeZone = this.calendar.ignoreTimeZone ? null : (_a2 = this.calendar.project) == null ? void 0 : _a2.timeZone;
    if (startDateN > endDateN)
      throw new Error("Invalid cache fill interval");
    const NEVER = later_default.NEVER;
    this.forEachRecurrentInterval((interval) => {
      const startSchedule = interval.getStartDateSchedule();
      const endSchedule = interval.getEndDateSchedule();
      let wrappingStartDate = startSchedule.prev(1, startDate);
      let wrappingEndDate;
      if (endSchedule === "EOD") {
        const nextEndDate = startSchedule.next(1, endDate);
        if (nextEndDate !== NEVER) {
          wrappingEndDate = DateHelper.getStartOfNextDay(nextEndDate, true);
        } else {
          wrappingEndDate = NEVER;
        }
      } else {
        wrappingEndDate = endSchedule.next(1, endDate);
      }
      if (wrappingStartDate !== NEVER && wrappingStartDate.getTime() === startDateN) {
        const wrappingStartDates = startSchedule.prev(2, startDate);
        if (wrappingStartDates !== NEVER && wrappingStartDates.length === 2)
          wrappingStartDate = wrappingStartDates[1];
      }
      if (wrappingEndDate !== NEVER && wrappingEndDate.getTime() === endDateN) {
        const wrappingEndDates = endSchedule.next(2, endDate);
        if (wrappingEndDates !== NEVER && wrappingEndDates.length === 2)
          wrappingEndDate = wrappingEndDates[1];
      }
      const startDates = startSchedule.next(Infinity, wrappingStartDate !== NEVER ? wrappingStartDate : startDate, wrappingEndDate !== NEVER ? new Date(wrappingEndDate.getTime() - 1) : endDate);
      if (startDates === NEVER)
        return;
      const endDates = endSchedule === "EOD" ? startDates.map((date) => DateHelper.getStartOfNextDay(date, true)) : endSchedule.next(Infinity, new Date(startDates[0].getTime() + 1), wrappingEndDate !== NEVER ? wrappingEndDate : endDate);
      if (endDates === NEVER)
        return;
      if (endDates.length > startDates.length) {
        endDates.length = startDates.length;
      } else if (endDates.length < startDates.length) {
        startDates.length = endDates.length;
      }
      startDates.forEach((startDate2, index) => {
        let recStartDate = startDate2;
        let recEndDate = endDates[index];
        if (timeZone != null) {
          recStartDate = TimeZoneHelper.toTimeZone(recStartDate, timeZone);
          recEndDate = TimeZoneHelper.toTimeZone(recEndDate, timeZone);
        }
        this.intervalCache.addInterval(recStartDate, recEndDate, (existingCacheInterval) => existingCacheInterval.includeInterval(interval));
      });
    });
  }
  clear() {
    this.staticIntervalsCached = false;
    super.clear();
  }
  cacheStaticIntervals() {
    this.forEachStaticInterval((interval) => {
      var _a2;
      const timeZone = (_a2 = this.calendar.project) == null ? void 0 : _a2.timeZone;
      let { startDate, endDate } = interval;
      if (timeZone != null) {
        startDate = TimeZoneHelper.toTimeZone(startDate, timeZone);
        endDate = TimeZoneHelper.toTimeZone(endDate, timeZone);
      }
      this.intervalCache.addInterval(startDate, endDate, (existingCacheInterval) => existingCacheInterval.includeInterval(interval));
    });
  }
  forEachStaticInterval(func) {
    this.intervalStore.forEach((interval) => {
      if (interval.isStatic())
        func(interval);
    });
  }
  forEachRecurrentInterval(func) {
    this.intervalStore.forEach((interval) => {
      if (interval.isRecurrent())
        func(interval);
    });
  }
};

// ../Engine/lib/Engine/quark/AbstractPartOfProjectGenericMixin.js
var AbstractPartOfProjectGenericMixin = class extends Mixin([], (base) => {
  const superProto = base.prototype;
  class AbstractPartOfProjectGenericMixin2 extends base {
    async commitAsync() {
      return this.project.commitAsync();
    }
    set project(project) {
      this.$project = project;
    }
    get project() {
      return this.$project;
    }
    calculateProject() {
      throw new Error("Implement me");
    }
    /**
     * The method to set the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    setProject(project) {
      return this.project = project;
    }
    /**
     * The method to get the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    getProject() {
      if (this.project)
        return this.project;
      return this.setProject(this.calculateProject());
    }
    /**
     * Convenience method to get the instance of the assignment store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    getAssignmentStore() {
      const project = this.getProject();
      return project == null ? void 0 : project.assignmentStore;
    }
    /**
     * Convenience method to get the instance of the dependency store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    getDependencyStore() {
      const project = this.getProject();
      return project == null ? void 0 : project.dependencyStore;
    }
    /**
     * Convenience method to get the instance of the event store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    getEventStore() {
      const project = this.getProject();
      return project == null ? void 0 : project.eventStore;
    }
    /**
     * Convenience method to get the instance of the resource store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    getResourceStore() {
      const project = this.getProject();
      return project == null ? void 0 : project.resourceStore;
    }
    /**
     * Convenience method to get the instance of the calendar manager store in the [[AbstractProjectMixin|project]] instance, this entity belongs to.
     */
    getCalendarManagerStore() {
      const project = this.getProject();
      return project == null ? void 0 : project.calendarManagerStore;
    }
  }
  return AbstractPartOfProjectGenericMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/mixin/AbstractPartOfProjectStoreMixin.js
var AbstractPartOfProjectStoreMixin = class extends Mixin([
  AbstractPartOfProjectGenericMixin,
  Store
], (base) => {
  const superProto = base.prototype;
  class AbstractPartOfProjectStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.isLoadingData = false;
      this.disableHasLoadedDataToCommitFlag = false;
    }
    static get $name() {
      return "AbstractPartOfProjectStoreMixin";
    }
    //region Async event triggering
    // NOTE: Tested in Scheduler (EventStore.t.js)
    construct(config = {}) {
      config.asyncEvents = {
        add: true,
        remove: true,
        removeAll: true,
        change: true,
        refresh: true,
        replace: true,
        move: true,
        update: true
      };
      return superProto.construct.call(this, config);
    }
    // Override for event triggering, to allow triggering events before and after some async operation.
    // The "before" events are prefix, the "after" are not.
    trigger(eventName, param) {
      const me = this, { asyncEvents, project } = me, asyncEvent = asyncEvents == null ? void 0 : asyncEvents[eventName], asyncAction = asyncEvent && (asyncEvent === true || asyncEvent[param.action]);
      if (!asyncAction) {
        return superProto.trigger.call(me, eventName, param);
      }
      superProto.trigger.call(me, `${eventName}PreCommit`, { ...param });
      if (!project || project.isEngineReady() && !project.isWritingData) {
        superProto.trigger.call(me, eventName, param);
      } else if (!me.eventsSuspended && project) {
        if (!project.dataReadyDetacher) {
          project.queuedDataReadyEvents = [];
          project.dataReadyDetacher = project.ion({
            dataReady() {
              this.queuedDataReadyEvents.forEach(([superProto2, scope, eventName2, param2]) => {
                superProto2.trigger.call(scope, eventName2, param2);
              });
              project.queuedDataReadyEvents = null;
              project.dataReadyDetacher();
              project.dataReadyDetacher = null;
            },
            once: true
          });
        }
        project.queuedDataReadyEvents.push([superProto, me, eventName, param]);
      }
      return true;
    }
    //endregion
    calculateProject() {
      return this.project;
    }
    setStoreData(data) {
      var _a2;
      if (this.project && !(this.syncDataOnLoad || this.disableHasLoadedDataToCommitFlag)) {
        this.project.hasLoadedDataToCommit = true;
      }
      this.isLoadingData = true;
      superProto.setStoreData.call(this, data);
      this.isLoadingData = false;
      (_a2 = this.project) == null ? void 0 : _a2.trigger("storeRefresh", { store: this });
    }
    // Override to postpone auto commits to after project commit, makes sure records are unmodified after commit
    async doAutoCommit() {
      if (this.suspendCount <= 0 && this.project && !this.project.isEngineReady()) {
        await this.project.commitAsync();
      }
      superProto.doAutoCommit.call(this);
    }
    async addAsync(records, silent) {
      const result = this.add(records, silent);
      await this.project.commitAsync();
      return result;
    }
    async insertAsync(index, records, silent) {
      const result = this.insert(index, records, silent);
      await this.project.commitAsync();
      return result;
    }
    async loadDataAsync(data) {
      this.data = data;
      await this.project.commitAsync();
    }
    performFilter() {
      var _a2;
      if (this.project && (this.isLoadingData || ((_a2 = this.rootNode) == null ? void 0 : _a2.isLoading))) {
        this.project.commitAsync().then(() => this.filter());
      }
      return super.performFilter(...arguments);
    }
  }
  return AbstractPartOfProjectStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/mixin/AbstractPartOfProjectModelMixin.js
var AbstractPartOfProjectModelMixin = class extends Mixin([AbstractPartOfProjectGenericMixin, Model], (base) => {
  const superProto = base.prototype;
  class AbstractPartOfProjectModelMixin2 extends base {
    joinStore(store) {
      let joinedProject = null;
      if (isInstanceOf(store, AbstractPartOfProjectStoreMixin)) {
        const project = store.getProject();
        if (project && !this.getProject()) {
          this.setProject(project);
          joinedProject = project;
        }
      }
      superProto.joinStore.call(this, store);
      if (joinedProject && !joinedProject.isRepopulatingStores)
        this.joinProject();
    }
    unjoinStore(store, isReplacing = false) {
      superProto.unjoinStore.call(this, store, isReplacing);
      const { project } = this;
      const isLeavingProjectStore = isInstanceOf(store, AbstractPartOfProjectStoreMixin) && !store.isFillingFromMaster && project === (store.isChained && store.project ? store.masterStore.project : store.project);
      if (project && !project.isDestroying && !project.isRepopulatingStores && isLeavingProjectStore) {
        this.leaveProject(isReplacing);
        this.setProject(null);
      }
      if (isLeavingProjectStore)
        this.graph = null;
    }
    /**
     * Template method, which is called when model is joining the project (through joining some store that
     * has already joined the project)
     */
    joinProject() {
    }
    /**
     * Template method, which is called when model is leaving the project (through leaving some store usually)
     */
    leaveProject(isReplacing = false) {
    }
    calculateProject() {
      const store = this.stores.find((s) => isInstanceOf(s, AbstractPartOfProjectStoreMixin) && !!s.getProject());
      return store == null ? void 0 : store.getProject();
    }
    async setAsync(fieldName, value, silent) {
      var _a2;
      const result = this.set(fieldName, value, silent);
      await ((_a2 = this.project) == null ? void 0 : _a2.commitAsync());
      return result;
    }
    async getAsync(fieldName) {
      var _a2;
      await ((_a2 = this.project) == null ? void 0 : _a2.commitAsync());
      return this.get(fieldName);
    }
    get isStmRestoring() {
      const project = this.getProject();
      return (project == null ? void 0 : project.isRestoringData) || (project == null ? void 0 : project.stm.isRestoring) || false;
    }
  }
  return AbstractPartOfProjectModelMixin2;
}) {
};

// ../Engine/lib/Engine/calendar/CalendarIntervalMixin.js
var CalendarIntervalMixin = class extends Mixin([AbstractPartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CalendarIntervalMixin2 extends base {
    static get fields() {
      return [
        "name",
        { name: "startDate", type: "date" },
        { name: "endDate", type: "date" },
        "recurrentStartDate",
        "recurrentEndDate",
        "cls",
        "iconCls",
        { name: "isWorking", type: "boolean", defaultValue: false },
        { name: "priority", type: "number" }
      ];
    }
    getCalendar() {
      return this.stores[0].calendar;
    }
    resetPriority() {
      this.priorityField = null;
      this.getCalendar().getDepth();
    }
    // not just `getPriority` to avoid clash with auto-generated getter in the subclasses
    getPriorityField() {
      if (this.priorityField != null)
        return this.priorityField;
      let base2 = 1e4 + this.getCalendar().getDepth() * 100;
      let priority = this.priority;
      if (priority == null) {
        priority = this.isRecurrent() ? 20 : 30;
      }
      return this.priorityField = base2 + priority;
    }
    /**
     * Whether this interval is recurrent (both [[recurrentStartDate]] and [[recurrentEndDate]] are present and parsed correctly
     * by the `later` library)
     */
    isRecurrent() {
      return Boolean(this.recurrentStartDate && this.recurrentEndDate && this.getStartDateSchedule() && this.getEndDateSchedule());
    }
    /**
     * Whether this interval is static - both [[startDate]] and [[endDate]] are present.
     */
    isStatic() {
      return Boolean(this.startDate && this.endDate);
    }
    /**
     * Helper method to parse [[recurrentStartDate]] and [[recurrentEndDate]] field values.
     * @param {Object|String} schedule Recurrence schedule
     * @returns {Object} Processed schedule ready to be used by later.schedule() method.
     * @private
     */
    parseDateSchedule(value) {
      let schedule = value;
      if (value && value !== Object(value)) {
        schedule = later_default.parse.text(value);
        if (schedule !== Object(schedule) || schedule.error >= 0) {
          try {
            schedule = JSON.parse(value);
          } catch (e) {
            return null;
          }
        }
      }
      return schedule;
    }
    getStartDateSchedule() {
      if (this.startDateSchedule)
        return this.startDateSchedule;
      const schedule = this.parseDateSchedule(this.recurrentStartDate);
      return this.startDateSchedule = later_default.schedule(schedule);
    }
    getEndDateSchedule() {
      if (this.endDateSchedule)
        return this.endDateSchedule;
      if (this.recurrentEndDate === "EOD")
        return "EOD";
      const schedule = this.parseDateSchedule(this.recurrentEndDate);
      return this.endDateSchedule = later_default.schedule(schedule);
    }
  }
  return CalendarIntervalMixin2;
}) {
};

// ../Engine/lib/Engine/calendar/CalendarIntervalStore.js
var CalendarIntervalStore = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class CalendarIntervalStore2 extends base {
    constructor() {
      super(...arguments);
      this.disableHasLoadedDataToCommitFlag = true;
    }
    static get defaultConfig() {
      return {
        modelClass: CalendarIntervalMixin
      };
    }
  }
  return CalendarIntervalStore2;
}) {
};

// ../Engine/lib/Engine/calendar/UnspecifiedTimeIntervalModel.js
var UnspecifiedTimeIntervalModel = class extends Mixin([CalendarIntervalMixin], (base) => {
  const superProto = base.prototype;
  class UnspecifiedTimeIntervalModel2 extends base {
    getCalendar() {
      return this.calendar;
    }
    // NOTE: See parent class implementation for further comments
    getPriorityField() {
      if (this.priorityField != null)
        return this.priorityField;
      return this.priorityField = this.getCalendar().getDepth();
    }
  }
  return UnspecifiedTimeIntervalModel2;
}) {
};

// ../Engine/lib/Engine/quark/CorePartOfProjectGenericMixin.js
var CorePartOfProjectGenericMixin = class extends Mixin([AbstractPartOfProjectGenericMixin], (base) => {
  const superProto = base.prototype;
  class CorePartOfProjectGenericMixin2 extends base {
    //region Store getters
    get eventStore() {
      var _a2;
      return (_a2 = this.project) == null ? void 0 : _a2.eventStore;
    }
    get resourceStore() {
      var _a2;
      return (_a2 = this.project) == null ? void 0 : _a2.resourceStore;
    }
    get assignmentStore() {
      var _a2;
      return (_a2 = this.project) == null ? void 0 : _a2.assignmentStore;
    }
    get dependencyStore() {
      var _a2;
      return (_a2 = this.project) == null ? void 0 : _a2.dependencyStore;
    }
    get calendarManagerStore() {
      var _a2;
      return (_a2 = this.project) == null ? void 0 : _a2.calendarManagerStore;
    }
    //endregion
    //region Entity getters
    /**
     * Convenience method to get the instance of event by its id.
     */
    getEventById(id) {
      var _a2;
      return (_a2 = this.eventStore) == null ? void 0 : _a2.getById(id);
    }
    /**
     * Convenience method to get the instance of dependency by its id.
     */
    getDependencyById(id) {
      var _a2;
      return (_a2 = this.dependencyStore) == null ? void 0 : _a2.getById(id);
    }
    /**
     * Convenience method to get the instance of resource by its id.
     */
    getResourceById(id) {
      var _a2;
      return (_a2 = this.resourceStore) == null ? void 0 : _a2.getById(id);
    }
    /**
     * Convenience method to get the instance of assignment by its id.
     */
    getAssignmentById(id) {
      var _a2;
      return (_a2 = this.assignmentStore) == null ? void 0 : _a2.getById(id);
    }
    /**
     * Convenience method to get the instance of calendar by its id.
     */
    getCalendarById(id) {
      var _a2;
      return (_a2 = this.calendarManagerStore) == null ? void 0 : _a2.getById(id);
    }
  }
  return CorePartOfProjectGenericMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/AbstractCalendarMixin.js
var AbstractCalendarMixin = class extends Mixin([AbstractPartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CalendarMixin extends base {
    constructor() {
      super(...arguments);
      this.version = 1;
    }
    static get fields() {
      return [
        { name: "version", type: "number" },
        "name",
        { name: "unspecifiedTimeIsWorking", type: "boolean", defaultValue: true },
        { name: "intervals", type: "store", subStore: true },
        "cls",
        "iconCls"
      ];
    }
    get intervalStoreClass() {
      return CalendarIntervalStore;
    }
    get intervalStore() {
      return this.meta.intervalsStore;
    }
    // Not a typo, name is generated from the fields name = intervals
    initIntervalsStore(config) {
      config.storeClass = this.intervalStoreClass;
      config.modelClass = this.getDefaultConfiguration().calendarIntervalModelClass || this.intervalStoreClass.defaultConfig.modelClass;
      config.calendar = this;
    }
    // this method is called when the new value for the `intervals` field of this model is assigned
    // the type of the `intervals` field is "store" that's why this magic
    processIntervalsStoreData(intervals) {
      this.bumpVersion();
    }
    isDefault() {
      const project = this.getProject();
      if (project) {
        return this === project.defaultCalendar;
      }
      return false;
    }
    getDepth() {
      return this.childLevel + 1;
    }
    /**
     * The core iterator method of the calendar.
     *
     * @param options The options for iterator. Should contain at least one of the `startDate`/`endDate` properties
     * which indicates what timespan to examine for availability intervals. If one of boundaries is not provided
     * iterator function should return `false` at some point, to avoid infinite loops.
     *
     * Another recognized option is `isForward`, which indicates the direction in which to iterate through the timespan.
     *
     * @param func The iterator function to call. It will be called for every distinct set of availability intervals, found
     * in the given timespan. All the intervals, which are "active" for current interval are collected in the 3rd argument
     * for this function - [[CalendarCacheInterval|calendarCacheInterval]]. If iterator returns `false` (checked with `===`)
     * the iteration stops.
     *
     * @param scope The scope (`this` value) to execute the iterator in.
     */
    forEachAvailabilityInterval(options, func, scope) {
      var _a2, _b;
      const maxRange = (_b = options.maxRange) != null ? _b : (_a2 = this.getProject()) == null ? void 0 : _a2.maxCalendarRange;
      if (maxRange) {
        options = { ...options, maxRange };
      }
      return this.calendarCache.forEachAvailabilityInterval(options, func, scope);
    }
    /**
     * This method starts at the given `date` and moves forward or backward in time, depending on `isForward`.
     * It stops moving as soon as it accumulates the `durationMs` milliseconds of working time and returns the date
     * at which it has stopped and remaining duration - the [[AccumulateWorkingTimeResult]] object.
     *
     * Normally, the remaining duration will be 0, indicating the full `durationMs` has been accumulated.
     * However, sometimes, calendar might not be able to accumulate enough working time due to various reasons,
     * like if it does not contain enough working time - this case will be indicated with remaining duration bigger than 0.
     *
     * @param date
     * @param durationMs
     * @param isForward
     */
    accumulateWorkingTime(date, durationMs, isForward) {
      var _a2, _b, _c;
      if (durationMs === 0)
        return { finalDate: new Date(date), remainingDurationInMs: 0 };
      if (isNaN(durationMs))
        throw new Error("Invalid duration");
      let finalDate = date;
      const adjustDurationToDST = (_c = (_b = (_a2 = this.getProject()) == null ? void 0 : _a2.adjustDurationToDST) != null ? _b : this.adjustDurationToDST) != null ? _c : false;
      this.forEachAvailabilityInterval(isForward ? { startDate: date, isForward: true } : { endDate: date, isForward: false }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        let result = true;
        if (calendarCacheInterval.getIsWorking()) {
          let diff = intervalEndDate.getTime() - intervalStartDate.getTime();
          if (durationMs <= diff) {
            if (adjustDurationToDST) {
              const dstDiff = isForward ? intervalStartDate.getTimezoneOffset() - new Date(intervalStartDate.getTime() + durationMs).getTimezoneOffset() : new Date(intervalEndDate.getTime() - durationMs).getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
              durationMs -= dstDiff * 60 * 1e3;
            }
            finalDate = isForward ? new Date(intervalStartDate.getTime() + durationMs) : new Date(intervalEndDate.getTime() - durationMs);
            durationMs = 0;
            result = false;
          } else {
            if (adjustDurationToDST) {
              const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
              diff += dstDiff * 60 * 1e3;
            }
            finalDate = isForward ? intervalEndDate : intervalStartDate;
            durationMs -= diff;
          }
        }
        return result;
      });
      return { finalDate: new Date(finalDate), remainingDurationInMs: durationMs };
    }
    /**
     * Calculate the working time duration between the 2 dates, in milliseconds.
     *
     * @param {Date} startDate
     * @param {Date} endDate
     * @param {Boolean} [allowNegative] Method ignores negative values by default, returning 0. Set to true to get
     * negative duration.
     */
    calculateDurationMs(startDate, endDate, allowNegative = false) {
      var _a2, _b, _c;
      let duration = 0;
      const multiplier = startDate.getTime() <= endDate.getTime() || !allowNegative ? 1 : -1;
      if (multiplier < 0) {
        [startDate, endDate] = [endDate, startDate];
      }
      const adjustDurationToDST = (_c = (_b = (_a2 = this.getProject()) == null ? void 0 : _a2.adjustDurationToDST) != null ? _b : this.adjustDurationToDST) != null ? _c : false;
      this.forEachAvailabilityInterval({ startDate, endDate }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (calendarCacheInterval.getIsWorking()) {
          duration += intervalEndDate.getTime() - intervalStartDate.getTime();
          if (adjustDurationToDST) {
            const dstDiff = intervalStartDate.getTimezoneOffset() - intervalEndDate.getTimezoneOffset();
            duration += dstDiff * 60 * 1e3;
          }
        }
      });
      return duration * multiplier;
    }
    /**
     * Calculate the end date of the time interval which starts at `startDate` and has `durationMs` working time duration
     * (in milliseconds).
     *
     * @param startDate
     * @param durationMs
     */
    calculateEndDate(startDate, durationMs) {
      const isForward = durationMs >= 0;
      const res = this.accumulateWorkingTime(startDate, Math.abs(durationMs), isForward);
      return res.remainingDurationInMs === 0 ? res.finalDate : null;
    }
    /**
     * Calculate the start date of the time interval which ends at `endDate` and has `durationMs` working time duration
     * (in milliseconds).
     *
     * @param endDate
     * @param durationMs
     */
    calculateStartDate(endDate, durationMs) {
      const isForward = durationMs <= 0;
      const res = this.accumulateWorkingTime(endDate, Math.abs(durationMs), isForward);
      return res.remainingDurationInMs === 0 ? res.finalDate : null;
    }
    /**
     * Returns the earliest point at which a working period of time starts, following the given date.
     * Can be the date itself, if it comes on the working time.
     *
     * @param date The date after which to skip the non-working time.
     * @param isForward Whether the "following" means forward in time or backward.
     */
    skipNonWorkingTime(date, isForward = true) {
      let workingDate;
      const res = this.forEachAvailabilityInterval(isForward ? { startDate: date, isForward: true } : { endDate: date, isForward: false }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (calendarCacheInterval.getIsWorking()) {
          workingDate = isForward ? intervalStartDate : intervalEndDate;
          return false;
        }
      });
      if (res === CalendarIteratorResult.MaxRangeReached || res === CalendarIteratorResult.FullRangeIterated)
        return "empty_calendar";
      return workingDate ? new Date(workingDate) : new Date(date);
    }
    /**
     * This method adds a single [[CalendarIntervalMixin]] to the internal collection of the calendar
     */
    addInterval(interval) {
      return this.addIntervals([interval]);
    }
    /**
     * This method adds an array of [[CalendarIntervalMixin]] to the internal collection of the calendar
     */
    addIntervals(intervals) {
      this.bumpVersion();
      return this.intervalStore.add(intervals);
    }
    /**
     * This method removes a single [[CalendarIntervalMixin]] from the internal collection of the calendar
     */
    removeInterval(interval) {
      return this.removeIntervals([interval]);
    }
    /**
     * This method removes an array of [[CalendarIntervalMixin]] from the internal collection of the calendar
     */
    removeIntervals(intervals) {
      this.bumpVersion();
      return this.intervalStore.remove(intervals);
    }
    /**
     * This method removes all intervals from the internal collection of the calendar
     */
    clearIntervals(silent) {
      if (!silent) {
        this.bumpVersion();
      }
      return this.intervalStore.removeAll(silent);
    }
    bumpVersion() {
      this.clearCache();
      this.version++;
    }
    get calendarCache() {
      if (this.$calendarCache !== void 0)
        return this.$calendarCache;
      const unspecifiedTimeInterval = new UnspecifiedTimeIntervalModel({
        isWorking: this.unspecifiedTimeIsWorking
      });
      unspecifiedTimeInterval.calendar = this;
      return this.$calendarCache = new CalendarCacheSingle({
        calendar: this,
        unspecifiedTimeInterval,
        intervalStore: this.intervalStore,
        parentCache: this.parent && !this.parent.isRoot ? this.parent.calendarCache : null
      });
    }
    clearCache() {
      this.$calendarCache && this.$calendarCache.clear();
      this.$calendarCache = void 0;
    }
    resetPriorityOfAllIntervals() {
      this.traverse((calendar) => {
        calendar.intervalStore.forEach((interval) => interval.resetPriority());
      });
    }
    insertChild(child, before, silent) {
      let res = superProto.insertChild.call(this, ...arguments);
      if (!Array.isArray(res)) {
        res = [res];
      }
      res.forEach((r) => {
        r.bumpVersion();
        r.resetPriorityOfAllIntervals();
      });
      return res;
    }
    joinProject() {
      superProto.joinProject.call(this);
      this.intervalStore.setProject(this.getProject());
    }
    leaveProject() {
      superProto.leaveProject.call(this);
      this.intervalStore.setProject(null);
      this.clearCache();
    }
    doDestroy() {
      this.leaveProject();
      this.intervalStore.destroy();
      super.doDestroy();
    }
    isDayHoliday(day2) {
      const startDate = DateHelper.clearTime(day2), endDate = DateHelper.getNext(day2, TimeUnit.Day);
      let hasWorkingTime = false;
      this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (_intervalStartDate, _intervalEndDate, calendarCacheInterval) => {
        hasWorkingTime = calendarCacheInterval.getIsWorking();
        return !hasWorkingTime;
      });
      return !hasWorkingTime;
    }
    getDailyHolidaysRanges(startDate, endDate) {
      const result = [];
      startDate = DateHelper.clearTime(startDate);
      while (startDate < endDate) {
        if (this.isDayHoliday(startDate)) {
          result.push({
            startDate,
            endDate: DateHelper.getStartOfNextDay(startDate, true, true)
          });
        }
        startDate = DateHelper.getNext(startDate, TimeUnit.Day);
      }
      return result;
    }
    /**
     * Returns working time ranges between the provided dates.
     * @param {Date} startDate Start of the period to get ranges from.
     * @param {Date} endDate End of the period to get ranges from.
     */
    getWorkingTimeRanges(startDate, endDate, maxRange) {
      const result = [];
      this.forEachAvailabilityInterval({ startDate, endDate, isForward: true, maxRange }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (calendarCacheInterval.getIsWorking()) {
          const entry = calendarCacheInterval.intervals[0];
          result.push({
            name: entry.name,
            startDate: intervalStartDate,
            endDate: intervalEndDate
          });
        }
      });
      return result;
    }
    /**
     * Returns non-working time ranges between the provided dates.
     * @param {Date} startDate Start of the period to get ranges from.
     * @param {Date} endDate End of the period to get ranges from.
     */
    getNonWorkingTimeRanges(startDate, endDate, maxRange) {
      const result = [];
      this.forEachAvailabilityInterval({ startDate, endDate, isForward: true, maxRange }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
        if (!calendarCacheInterval.getIsWorking()) {
          const entry = calendarCacheInterval.intervals[0];
          result.push({
            name: entry.name,
            iconCls: entry.iconCls,
            cls: entry.cls,
            startDate: intervalStartDate,
            endDate: intervalEndDate
          });
        }
      });
      return result;
    }
    /**
     * Checks if there is a working time interval in the provided time range (or when just startDate is provided,
     * checks if the date is contained inside a working time interval in this calendar)
     * @param startDate
     * @param [endDate]
     * @param [fullyContained] Pass true to check if the range is fully covered by a single continuous working time block
     */
    isWorkingTime(startDate, endDate, fullyContained) {
      if (fullyContained) {
        let found;
        const res = this.forEachAvailabilityInterval({ startDate, endDate, isForward: true }, (intervalStartDate, intervalEndDate, calendarCacheInterval) => {
          if (calendarCacheInterval.getIsWorking() && intervalStartDate <= startDate && intervalEndDate >= endDate) {
            found = true;
            return false;
          }
        });
        if (res === CalendarIteratorResult.MaxRangeReached || res === CalendarIteratorResult.FullRangeIterated)
          return false;
        return found;
      } else {
        const workingTimeStart = this.skipNonWorkingTime(startDate);
        return workingTimeStart && workingTimeStart !== "empty_calendar" ? endDate ? workingTimeStart < endDate : workingTimeStart.getTime() === startDate.getTime() : false;
      }
    }
  }
  return CalendarMixin;
}) {
};

// ../Engine/lib/Engine/quark/model/AbstractHasAssignmentsMixin.js
var AbstractHasAssignmentsMixin = class extends Mixin([AbstractPartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class HasAssignmentsMixin extends base {
    /**
     * If a given resource is assigned to this task, returns a [[BaseAssignmentMixin]] instance for it.
     * Otherwise returns `null`
     */
    getAssignmentFor(resource) {
      var _a2;
      for (const assignment of (_a2 = this.assigned) != null ? _a2 : []) {
        if (assignment.resource === resource)
          return assignment;
      }
      return null;
    }
    isAssignedTo(resource) {
      return Boolean(this.getAssignmentFor(resource));
    }
    /**
     * A method which assigns a resource to the current event
     */
    async assign(resource) {
      const assignmentCls = this.project.assignmentStore.modelClass;
      this.addAssignment(new assignmentCls({
        event: this,
        resource
      }));
      return this.commitAsync();
    }
    /**
     * A method which unassigns a resource from the current event
     */
    async unassign(resource) {
      const assignment = this.getAssignmentFor(resource);
      this.removeAssignment(assignment);
      return this.commitAsync();
    }
    leaveProject() {
      if (this.isInActiveTransaction && this.assigned) {
        const eventStore = this.getEventStore();
        this.assigned.forEach((assignment) => eventStore.assignmentsForRemoval.add(assignment));
      }
      superProto.leaveProject.call(this, ...arguments);
    }
    remove() {
      if (this.parent) {
        const eventStore = this.getEventStore();
        superProto.remove.call(this);
        eventStore && eventStore.afterEventRemoval();
      } else {
        return superProto.remove.call(this);
      }
    }
    // template methods, overridden in scheduling modes mixins
    // should probably be named something like "onEventAssignmentAdded"
    // should be a listener for the `add` event of the assignment store instead
    addAssignment(assignment) {
      this.getProject().assignmentStore.add(assignment);
      return assignment;
    }
    // should be a listener for the `remove` event of the assignment store instead
    removeAssignment(assignment) {
      this.getProject().assignmentStore.remove(assignment);
      return assignment;
    }
  }
  return HasAssignmentsMixin;
}) {
};

// ../Engine/lib/Engine/quark/model/mixin/CorePartOfProjectModelMixin.js
var CorePartOfProjectModelMixin = class extends Mixin([
  AbstractPartOfProjectModelMixin,
  CorePartOfProjectGenericMixin,
  Model
], (base) => {
  const superProto = base.prototype;
  class CorePartOfProjectModelMixin2 extends base {
    constructor() {
      super(...arguments);
      this.$isCalculating = false;
      this.$changed = {};
      this.$beforeChange = {};
    }
    get isInActiveTransaction() {
      return true;
    }
    // Invalidate record upon joining project, leads to a buffered commit
    joinProject() {
      this.invalidate();
    }
    // Trigger a buffered commit when leaving the project
    leaveProject(isReplacing = false) {
      var _a2;
      superProto.leaveProject.call(this, isReplacing);
      (_a2 = this.project) == null ? void 0 : _a2.bufferedCommitAsync();
    }
    /**
     * Invalidates this record, queueing it for calculation on project commit.
     */
    invalidate() {
      var _a2;
      (_a2 = this.project) == null ? void 0 : _a2.invalidate(this);
    }
    /**
     * Used to retrieve the proposed (before 'dataReady') or current (after 'dataReady') value for a field.
     * If there is no proposed change, it is functionally equal to a normal `record.get()` call.
     */
    getCurrentOrProposed(fieldName) {
      var _a2;
      if (fieldName in this.$changed && this.$changed[fieldName] !== true) {
        return this.$changed[fieldName];
      }
      return (_a2 = this.get(fieldName)) != null ? _a2 : null;
    }
    /**
     * Determines if the specified field has a value or not, value can be either current or proposed.
     */
    hasCurrentOrProposed(fieldName) {
      return fieldName in this.$changed && this.$changed[fieldName] != true || this.get(fieldName) != null;
    }
    /**
     * Propose changes, to be considered during calculation. Also invalidates the record.
     */
    propose(changes) {
      var _a2;
      if (this.project || ((_a2 = this.recurringTimeSpan) == null ? void 0 : _a2.project)) {
        const keys = Object.keys(changes);
        for (let i = 0; i < keys.length; i++) {
          const key = keys[i];
          this.$changed[key] = changes[key];
        }
        this.invalidate();
      } else {
        this.set(changes);
      }
    }
    /**
     * Similar to propose, but with more options. Mostly used by buckets, since they need data to update early.
     */
    setChanged(field, value, invalidate = true, setData = false) {
      const me = this;
      me.$changed[field] = value;
      if (setData) {
        if (!(field in me.$beforeChange)) {
          me.$beforeChange[field] = me.get(field);
        }
        me.setData(field, value);
      }
      invalidate && me.invalidate();
    }
    /**
     * Hook called before project refresh, override and calculate required changes in subclasses
     */
    calculateInvalidated() {
    }
    /**
     * Called after project refresh, before dataReady. Announce updated data
     */
    finalizeInvalidated(silent = false) {
      const me = this;
      me.$isCalculating = true;
      if (!silent) {
        me.setData(me.$beforeChange);
        me.set(me.$changed);
      } else {
        me.setData(me.$changed);
      }
      me.$changed = {};
      me.$beforeChange = {};
      me.$isCalculating = false;
    }
  }
  return CorePartOfProjectModelMixin2;
}) {
};

// ../Engine/lib/Engine/util/Functions.js
var isNotNumber = (value) => Number(value) !== value;
var CIFromSetOrArrayOrValue = (value) => {
  if (value instanceof Set || value instanceof Array)
    return CI(value);
  return CI([value]);
};
var delay = (value) => new Promise((resolve) => setTimeout(resolve, value));
var format = (format2, ...values) => {
  return format2.replace(/{(\d+)}/g, (match, number) => typeof values[number] !== "undefined" ? values[number] : match);
};

// ../Engine/lib/Engine/quark/store/AbstractAssignmentStoreMixin.js
var AbstractAssignmentStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractAssignmentStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.assignmentsForRemoval = /* @__PURE__ */ new Set();
      this.allAssignmentsForRemoval = false;
    }
    remove(records, silent) {
      this.assignmentsForRemoval = CIFromSetOrArrayOrValue(records).toSet();
      const res = superProto.remove.call(this, records, silent);
      this.assignmentsForRemoval.clear();
      return res;
    }
    removeAll(silent) {
      this.allAssignmentsForRemoval = true;
      const res = superProto.removeAll.call(this, silent);
      this.allAssignmentsForRemoval = false;
      return res;
    }
  }
  return AbstractAssignmentStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/AbstractCalendarManagerStoreMixin.js
var AbstractCalendarManagerStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractCalendarManagerStoreMixin2 extends base {
    // special handling to destroy calendar models as part of destroying this store
    doDestroy() {
      var _a2;
      const records = [];
      if (!((_a2 = this.rootNode) == null ? void 0 : _a2.isDestroyed)) {
        this.traverse((record) => records.push(record));
      }
      super.doDestroy();
      records.forEach((record) => record.destroy());
    }
  }
  return AbstractCalendarManagerStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/AbstractDependencyStoreMixin.js
var AbstractDependencyStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractDependencyStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.dependenciesForRemoval = /* @__PURE__ */ new Set();
      this.allDependenciesForRemoval = false;
    }
    remove(records, silent) {
      this.dependenciesForRemoval = CIFromSetOrArrayOrValue(records).toSet();
      const res = superProto.remove.call(this, records, silent);
      this.dependenciesForRemoval.clear();
      return res;
    }
    removeAll(silent) {
      this.allDependenciesForRemoval = true;
      const res = superProto.removeAll.call(this, silent);
      this.allDependenciesForRemoval = false;
      return res;
    }
  }
  return AbstractDependencyStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/AbstractEventStoreMixin.js
var dataAddRemoveActions2 = {
  splice: 1,
  clear: 1
};
var AbstractEventStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractEventStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.assignmentsForRemoval = /* @__PURE__ */ new Set();
      this.dependenciesForRemoval = /* @__PURE__ */ new Set();
    }
    // we need `onDataChange` for `syncDataOnLoad` option to work
    onDataChange(event) {
      var _a2;
      const isAddRemove = dataAddRemoveActions2[event.action];
      super.onDataChange(event);
      if (isAddRemove && ((_a2 = event.removed) == null ? void 0 : _a2.length))
        this.afterEventRemoval();
    }
    // it seems `onDataChange` is not triggered for `remove` with `silent` flag
    remove(records, silent) {
      const res = superProto.remove.call(this, records, silent);
      this.afterEventRemoval();
      return res;
    }
    // it seems `onDataChange` is not triggered for `TreeStore#removeAll()`
    removeAll(silent) {
      const res = superProto.removeAll.call(this, silent);
      this.afterEventRemoval();
      return res;
    }
    onNodeRemoveChild(parent, children, index, flags) {
      const removed = superProto.onNodeRemoveChild.call(this, ...arguments);
      this.afterEventRemoval();
      return removed;
    }
    afterEventRemoval() {
      const { assignmentsForRemoval, dependenciesForRemoval } = this;
      if (!assignmentsForRemoval)
        return;
      const assignmentStore = this.getAssignmentStore();
      if (assignmentStore && !assignmentStore.allAssignmentsForRemoval && assignmentsForRemoval.size) {
        const toRemove = [...assignmentsForRemoval].filter((assignment) => !assignmentStore.assignmentsForRemoval.has(assignment));
        toRemove.length > 0 && assignmentStore.remove(toRemove);
      }
      assignmentsForRemoval.clear();
      const dependencyStore = this.getDependencyStore();
      if (dependencyStore && !dependencyStore.allDependenciesForRemoval && dependenciesForRemoval.size) {
        const toRemove = [...dependenciesForRemoval].filter((dependency) => !dependencyStore.dependenciesForRemoval.has(dependency));
        toRemove.length > 0 && dependencyStore.remove(toRemove);
      }
      dependenciesForRemoval.clear();
    }
    processRecord(eventRecord, isDataset = false) {
      var _a2;
      if (!((_a2 = this.project) == null ? void 0 : _a2.isRepopulatingStores)) {
        const existingRecord = this.getById(eventRecord.id);
        const isReplacing = existingRecord && existingRecord !== eventRecord;
        if (isReplacing && existingRecord.assigned) {
          for (const assignment of existingRecord.assigned) {
            assignment.event = eventRecord;
          }
        }
      }
      return eventRecord;
    }
  }
  return AbstractEventStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/AbstractResourceStoreMixin.js
var dataAddRemoveActions3 = {
  splice: 1,
  clear: 1
};
var AbstractResourceStoreMixin = class extends Mixin([AbstractPartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class AbstractResourceStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.assignmentsForRemoval = /* @__PURE__ */ new Set();
    }
    // we need `onDataChange` for `syncDataOnLoad` option to work
    onDataChange(event) {
      var _a2;
      const isAddRemove = dataAddRemoveActions3[event.action];
      super.onDataChange(event);
      if (isAddRemove && ((_a2 = event.removed) == null ? void 0 : _a2.length))
        this.afterResourceRemoval();
    }
    // it seems `onDataChange` is not triggered for `remove` with `silent` flag
    remove(records, silent) {
      const res = superProto.remove.call(this, records, silent);
      this.afterResourceRemoval();
      return res;
    }
    // it seems `onDataChange` is not triggered for `TreeStore#removeAll()`
    removeAll(silent) {
      const res = superProto.removeAll.call(this, silent);
      this.afterResourceRemoval();
      return res;
    }
    afterResourceRemoval() {
      const assignmentStore = this.getAssignmentStore();
      if (assignmentStore && !assignmentStore.allAssignmentsForRemoval) {
        const assignmentsForRemoval = [...this.assignmentsForRemoval].filter((assignment) => !assignmentStore.assignmentsForRemoval.has(assignment));
        assignmentsForRemoval.length > 0 && assignmentStore.remove(assignmentsForRemoval);
      }
      this.assignmentsForRemoval.clear();
    }
    processRecord(resourceRecord, isDataset = false) {
      const existingRecord = this.getById(resourceRecord.id);
      const isReplacing = existingRecord && existingRecord !== resourceRecord;
      if (isReplacing) {
        for (const assignment of existingRecord.assigned || []) {
          assignment.resource = resourceRecord;
        }
      }
      return resourceRecord;
    }
  }
  return AbstractResourceStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreEventMixin.js
var CoreEventMixin = class extends Mixin([CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreEventMixin2 extends base {
    constructor() {
      super(...arguments);
      this._startDate = null;
      this._endDate = null;
      this._duration = null;
    }
    // Proper engine defines these fields since they enter graph, thus we need them
    static get fields() {
      return [
        { name: "startDate", type: "date" },
        { name: "endDate", type: "date" },
        { name: "duration", type: "number" },
        { name: "durationUnit", type: "durationunit", defaultValue: "day" }
      ];
    }
    // Getters return current or proposed value
    get startDate() {
      var _a2, _b;
      return (_b = (_a2 = this._startDate) != null ? _a2 : this.get("startDate")) != null ? _b : null;
    }
    get endDate() {
      var _a2, _b;
      return (_b = (_a2 = this._endDate) != null ? _a2 : this.get("endDate")) != null ? _b : null;
    }
    get duration() {
      var _a2, _b;
      return (_b = (_a2 = this._duration) != null ? _a2 : this.get("duration")) != null ? _b : null;
    }
    // Route all setting through applyXX (setStartDate, startDate = , set('startDate'), batching)
    set startDate(value) {
      this.proposeStartDate(value);
    }
    set endDate(value) {
      this.proposeEndDate(value);
    }
    set duration(value) {
      this.proposeDuration(value);
    }
    //region Edge case normalization
    inSet(field, value, silent, fromRelationUpdate, skipAccessors) {
      const me = this;
      if (me.project && !me.project.isWritingData && typeof field !== "string" && !skipAccessors) {
        if ("startDate" in field && !("startDate" in me.$changed)) {
          me.$changed.startDate = true;
          me.invalidate();
        }
        if ("endDate" in field && !("endDate" in me.$changed)) {
          me.$changed.endDate = true;
          me.invalidate();
        }
      }
      return superProto.inSet.call(me, field, value, silent, fromRelationUpdate, skipAccessors);
    }
    //endregion
    //region StartDate
    getStartDate() {
      return this.startDate;
    }
    proposeStartDate(startDate, keepDuration = !("endDate" in this.$changed)) {
      var _a2;
      if (this.inSetting || (startDate == null ? void 0 : startDate.getTime()) !== ((_a2 = this.startDate) == null ? void 0 : _a2.getTime())) {
        this._startDate = startDate;
        this.propose({ startDate, keepDuration });
      }
    }
    async setStartDate(startDate, keepDuration = true) {
      var _a2;
      this.proposeStartDate(startDate, keepDuration);
      return (_a2 = this.project) == null ? void 0 : _a2.commitAsync();
    }
    //endregion
    //region EndDate
    getEndDate() {
      return this.endDate;
    }
    proposeEndDate(endDate, keepDuration = false) {
      var _a2;
      if (this.inSetting || (endDate == null ? void 0 : endDate.getTime()) !== ((_a2 = this.endDate) == null ? void 0 : _a2.getTime())) {
        this._endDate = endDate;
        this.propose({ endDate, keepDuration });
      }
    }
    async setEndDate(endDate, keepDuration = false) {
      var _a2;
      this.proposeEndDate(endDate, keepDuration);
      return (_a2 = this.project) == null ? void 0 : _a2.commitAsync();
    }
    //endregion
    //region Duration
    getDuration() {
      return this.duration;
    }
    proposeDuration(duration, unit, keepStart = true) {
      this._duration = duration;
      this.propose({ duration, keepStart });
      if (unit)
        this.propose({ durationUnit: unit });
    }
    async setDuration(duration, unit, keepStart = true) {
      var _a2;
      this.proposeDuration(duration, unit, keepStart);
      return (_a2 = this.project) == null ? void 0 : _a2.commitAsync();
    }
    getDurationUnit() {
      return this.durationUnit;
    }
    //endregion
    // When joining as part of inline data, store is available. If joining through load, it is passed
    joinProject() {
      var _a2, _b;
      const me = this;
      const changed = me.$changed;
      const startDate = me.getCurrentOrProposed("startDate");
      const endDate = me.getCurrentOrProposed("endDate");
      const duration = me.getCurrentOrProposed("duration");
      if (startDate != null)
        changed.startDate = me._startDate = startDate;
      if (endDate != null)
        changed.endDate = me._endDate = endDate;
      if (duration != null)
        changed.duration = me._duration = duration;
      if (me.eventStore && !me.eventStore.isLoadingData) {
        const unresolved = (_a2 = me.assignmentStore) == null ? void 0 : _a2.storage.findItem("event", null);
        if (unresolved) {
          const cachedAssignments = (_b = me.assignmentStore) == null ? void 0 : _b.storage.findItem("eventId", me.id);
          if (cachedAssignments) {
            for (const assignment of cachedAssignments) {
              assignment.setChanged("event", me);
            }
          } else {
            for (const assignment of unresolved) {
              if (assignment.getCurrentOrProposed("event") === me.id) {
                assignment.setChanged("event", me);
              }
            }
          }
        }
      }
      superProto.joinProject.call(me);
    }
    // Mimic how proper engine applies values
    applyValue(useProp, key, value, skipAccessors, field) {
      var _a2;
      if ((this.project || ((_a2 = this.recurringTimeSpan) == null ? void 0 : _a2.project)) && field) {
        const { name } = field;
        if (name === "startDate" || name == "duration" || name === "endDate") {
          useProp = true;
          this["_" + name] = value;
        }
        if (skipAccessors) {
          useProp = false;
        }
      }
      superProto.applyValue.call(this, useProp, key, value, skipAccessors, field);
    }
    // Catch changes from batches etc. In which case it is sometimes expected for data to be available directly
    afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
      if (!this.$isCalculating && !skipAccessors) {
        this.setData({
          startDate: this.getCurrentOrProposed("startDate"),
          endDate: this.getCurrentOrProposed("endDate"),
          duration: this.getCurrentOrProposed("duration"),
          durationUnit: this.getCurrentOrProposed("durationUnit")
        });
      }
      superProto.afterChange.call(this, toSet, wasSet, silent, fromRelationUpdate, skipAccessors);
    }
    // Normalizes dates & duration
    calculateInvalidated() {
      var _a2, _b;
      const me = this;
      const changed = me.$changed;
      const changedStart = "startDate" in changed;
      const changedEnd = "endDate" in changed;
      const changedDuration = "duration" in changed;
      const { startDate, endDate, duration, keepDuration, keepStart } = changed;
      let calculate = null;
      if (changedStart && !changedEnd && !changedDuration) {
        if (startDate === null) {
          changed.endDate = null;
        } else if (me.hasCurrentOrProposed("endDate") && startDate > me.getCurrentOrProposed("endDate") && !keepDuration) {
          changed.endDate = startDate;
          changed.duration = 0;
        } else if (me.hasCurrentOrProposed("duration") && (keepDuration || !me.hasCurrentOrProposed("endDate"))) {
          calculate = "endDate";
        } else if (me.hasCurrentOrProposed("endDate")) {
          calculate = "duration";
        }
      } else if (!changedStart && changedEnd && !changedDuration) {
        if (endDate === null) {
          changed.startDate = null;
        } else if (me.hasCurrentOrProposed("startDate") && !keepDuration && endDate !== true && endDate < me.getCurrentOrProposed("startDate")) {
          changed.startDate = endDate;
          changed.duration = 0;
        } else if (me.hasCurrentOrProposed("duration") && (keepDuration || !me.hasCurrentOrProposed("startDate"))) {
          calculate = "startDate";
        } else if (me.hasCurrentOrProposed("startDate")) {
          calculate = "duration";
        }
      } else if (!changedStart && !changedEnd && changedDuration) {
        if (duration === null) {
          changed.endDate = null;
        } else if (me.hasCurrentOrProposed("startDate") && (keepStart || !me.hasCurrentOrProposed("endDate"))) {
          if (keepStart && changed.duration < 0) {
            changed.duration = 0;
          }
          calculate = "endDate";
        } else if (me.hasCurrentOrProposed("endDate")) {
          calculate = "startDate";
        }
      } else if (changedStart && changedEnd && !changedDuration) {
        if (startDate === null && endDate === null) {
          changed.duration = null;
        } else {
          calculate = "duration";
        }
      } else if (changedStart && !changedEnd && changedDuration) {
        calculate = "endDate";
      } else if (!changedStart && changedEnd && changedDuration) {
        calculate = "startDate";
      } else if (changedStart && changedEnd && changedDuration) {
        if (duration == null) {
          calculate = "duration";
        } else if (startDate == null) {
          calculate = "startDate";
        } else {
          calculate = "endDate";
        }
      }
      const currentOrProposedStartDate = me.getCurrentOrProposed("startDate");
      const currentOrProposedEndDate = me.getCurrentOrProposed("endDate");
      const currentOrProposedDuration = me.getCurrentOrProposed("duration");
      const currentOrProposedDurationUnit = me.getCurrentOrProposed("durationUnit");
      const adjustDurationToDST = (_b = (_a2 = me.getProject()) == null ? void 0 : _a2.adjustDurationToDST) != null ? _b : false;
      switch (calculate) {
        case "startDate":
          const newStartDate = DateHelper.add(currentOrProposedEndDate, -currentOrProposedDuration, currentOrProposedDurationUnit);
          if (adjustDurationToDST) {
            const dstDiff = currentOrProposedEndDate.getTimezoneOffset() - newStartDate.getTimezoneOffset();
            newStartDate.setTime(newStartDate.getTime() - dstDiff * 60 * 1e3);
          }
          changed.startDate = newStartDate;
          break;
        case "endDate":
          const newEndDate = DateHelper.add(currentOrProposedStartDate, currentOrProposedDuration, currentOrProposedDurationUnit);
          if (adjustDurationToDST) {
            const dstDiff = currentOrProposedStartDate.getTimezoneOffset() - newEndDate.getTimezoneOffset();
            newEndDate.setTime(newEndDate.getTime() - dstDiff * 60 * 1e3);
          }
          changed.endDate = newEndDate;
          break;
        case "duration":
          let newDuration = DateHelper.diff(currentOrProposedStartDate, currentOrProposedEndDate, "millisecond");
          if (adjustDurationToDST) {
            const dstDiff = currentOrProposedStartDate.getTimezoneOffset() - currentOrProposedEndDate.getTimezoneOffset();
            newDuration += dstDiff * 60 * 1e3;
          }
          changed.duration = DateHelper.as(currentOrProposedDurationUnit, newDuration, "millisecond");
          break;
      }
      if ("startDate" in changed && changed.startDate !== true)
        this._startDate = changed.startDate;
      if ("endDate" in changed && changed.endDate !== true)
        this._endDate = changed.endDate;
      if ("duration" in changed && changed.duration !== true)
        this._duration = changed.duration;
      if (changed.startDate === true)
        delete changed.startDate;
      if (changed.endDate === true)
        delete changed.endDate;
      delete changed.keepDuration;
      delete changed.keepStart;
    }
  }
  return CoreEventMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreResourceMixin.js
var CoreResourceMixin = class extends Mixin([CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreResourceMixin2 extends base {
    get assigned() {
      var _a2;
      return (_a2 = this.project) == null ? void 0 : _a2.assignmentStore.getResourcesAssignments(this);
    }
    joinProject() {
      var _a2;
      if (this.resourceStore && !this.resourceStore.isLoadingData) {
        (_a2 = this.assignmentStore) == null ? void 0 : _a2.query((a) => a.get("resource") === this.id).forEach((unresolved) => unresolved.setChanged("resource", this));
      }
      superProto.joinProject.call(this);
    }
    leaveProject(isReplacing = false) {
      var _a2;
      if (this.assigned && !isReplacing && !((_a2 = this.resourceStore) == null ? void 0 : _a2.isLoadingData)) {
        const resourceStore = this.resourceStore;
        this.assigned.forEach((assignment) => resourceStore.assignmentsForRemoval.add(assignment));
      }
      superProto.leaveProject.call(this);
    }
    applyValue(useProp, key, value, skipAccessor, field) {
      if ((field == null ? void 0 : field.name) === "id") {
        this.assigned.forEach((assignment) => {
          assignment.set("resourceId", value);
        });
      }
      superProto.applyValue.call(this, useProp, key, value, skipAccessor, field);
    }
  }
  return CoreResourceMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreAssignmentMixin.js
function asId(recordOrId) {
  return (recordOrId == null ? void 0 : recordOrId.isModel) ? recordOrId.id : recordOrId;
}
var CoreAssignmentMixin = class extends Mixin([CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreAssignmentMixin2 extends base {
    // Fields declared in the Model way, existing decorators all assume ChronoGraph is used
    static get fields() {
      return [
        // isEqual required to properly detect changed resource / event
        { name: "resource", isEqual: (a, b) => a === b, persist: false },
        { name: "event", isEqual: (a, b) => a === b, persist: false }
      ];
    }
    // Resolve early + update indices to have buckets ready before commit
    setChanged(field, value, invalidate) {
      const { assignmentStore, eventStore, resourceStore, project } = this;
      let update = false;
      if (field === "event") {
        const event = isInstanceOf(value, CoreEventMixin) ? value : eventStore == null ? void 0 : eventStore.$master.getById(value);
        if (event)
          update = true;
        value = event || value;
      }
      if (field === "resource") {
        const resource = isInstanceOf(value, CoreResourceMixin) ? value : resourceStore == null ? void 0 : resourceStore.$master.getById(value);
        if (resource)
          update = true;
        value = resource || value;
      }
      superProto.setChanged.call(this, field, value, invalidate, true);
      if (assignmentStore && update && !project.isPerformingCommit && !assignmentStore.isLoadingData && !(resourceStore == null ? void 0 : resourceStore.isLoadingData) && !assignmentStore.skipInvalidateIndices) {
        assignmentStore.invalidateIndices();
      }
    }
    // Resolve event and resource when joining project
    joinProject() {
      superProto.joinProject.call(this);
      this.setChanged("event", this.get("event"));
      this.setChanged("resource", this.get("resource"));
    }
    // Resolved resource & event as part of commit
    // Normally done earlier in setChanged, but stores might not have been available yet at that point
    calculateInvalidated() {
      var _a2, _b;
      let { event = this.event, resource = this.resource } = this.$changed;
      if (event !== null && !isInstanceOf(event, CoreEventMixin)) {
        const resolved = (_a2 = this.eventStore) == null ? void 0 : _a2.getById(event);
        if (resolved)
          this.setChanged("event", resolved, false);
      }
      if (resource !== null && !isInstanceOf(resource, CoreResourceMixin)) {
        const resolved = (_b = this.resourceStore) == null ? void 0 : _b.getById(resource);
        if (resolved)
          this.setChanged("resource", resolved, false);
      }
    }
    // resourceId and eventId required to be available for new datasets
    finalizeInvalidated(silent) {
      const changed = this.$changed;
      if ("resource" in changed) {
        changed.resourceId = asId(changed.resource);
      }
      if ("event" in changed) {
        changed.eventId = asId(changed.event);
      }
      superProto.finalizeInvalidated.call(this, silent);
    }
    //region Event
    set event(event) {
      this.setChanged("event", event);
      this.setChanged("eventId", asId(event));
    }
    get event() {
      const event = this.get("event");
      return (event == null ? void 0 : event.id) != null ? event : null;
    }
    //endregion
    //region Resource
    set resource(resource) {
      this.setChanged("resource", resource);
      this.setChanged("resourceId", asId(resource));
    }
    get resource() {
      const resource = this.get("resource");
      return (resource == null ? void 0 : resource.id) != null ? resource : null;
    }
  }
  return CoreAssignmentMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/mixin/CorePartOfProjectStoreMixin.js
var CorePartOfProjectStoreMixin = class extends Mixin([
  AbstractPartOfProjectStoreMixin,
  CorePartOfProjectGenericMixin,
  Store
], (base) => {
  const superProto = base.prototype;
  class CorePartOfProjectStoreMixin2 extends base {
    setProject(project) {
      const result = superProto.setProject.call(this, project);
      if (project)
        this.joinProject(project);
      return result;
    }
    joinProject(project) {
    }
    onCommitAsync() {
    }
  }
  return CorePartOfProjectStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/CoreAssignmentStoreMixin.js
var emptySet = /* @__PURE__ */ new Set();
var CoreAssignmentStoreMixin = class extends Mixin([AbstractAssignmentStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class CoreAssignmentStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.skipInvalidateIndices = false;
    }
    static get defaultConfig() {
      return {
        modelClass: CoreAssignmentMixin,
        storage: {
          extraKeys: [
            { property: "event", unique: false },
            { property: "resource", unique: false },
            { property: "eventId", unique: false }
          ]
        }
      };
    }
    set data(value) {
      this.allAssignmentsForRemoval = true;
      super.data = value;
      this.allAssignmentsForRemoval = false;
    }
    getEventsAssignments(event) {
      return this.storage.findItem("event", event, true) || emptySet;
    }
    getResourcesAssignments(resource) {
      return this.storage.findItem("resource", resource.$original, true) || emptySet;
    }
    updateIndices() {
      this.storage.rebuildIndices();
    }
    invalidateIndices() {
      this.storage.invalidateIndices();
    }
    afterLoadData() {
      this.eventStore && this.linkAssignments(this.eventStore, "event");
      this.resourceStore && this.linkAssignments(this.resourceStore, "resource");
    }
    // Link events/resources to assignments, called when those stores are populated or joined to project
    linkAssignments(store, modelName) {
      store = store.masterStore || store;
      const unresolved = this.count && this.storage.findItem(modelName, null, true);
      if (unresolved) {
        for (const assignment of unresolved) {
          const record = store.getById(assignment.getCurrentOrProposed(modelName));
          if (record)
            assignment.setChanged(modelName, record);
        }
        this.invalidateIndices();
      }
    }
    // Unlink events/resources from assignments, called when those stores are cleared
    unlinkAssignments(modelName) {
      this.forEach((assignment) => {
        var _a2, _b, _c;
        return assignment.setChanged(modelName, (_c = (_b = (_a2 = assignment[modelName]) == null ? void 0 : _a2.id) != null ? _b : assignment == null ? void 0 : assignment.getData(modelName)) != null ? _c : assignment[modelName + "Id"]);
      });
      this.invalidateIndices();
    }
    onCommitAsync() {
      this.updateIndices();
    }
  }
  return CoreAssignmentStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreCalendarMixin.js
var CoreCalendarMixin = class extends Mixin([AbstractCalendarMixin, CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreCalendarMixin2 extends base {
  }
  return CoreCalendarMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/CoreCalendarManagerStoreMixin.js
var CoreCalendarManagerStoreMixin = class extends Mixin([AbstractCalendarManagerStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class CoreCalendarManagerStoreMixin2 extends base {
    static get defaultConfig() {
      return {
        tree: true,
        modelClass: CoreCalendarMixin
      };
    }
  }
  return CoreCalendarManagerStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreDependencyMixin.js
var CoreDependencyMixin = class extends Mixin([CorePartOfProjectModelMixin], (base) => {
  const superProto = base.prototype;
  class CoreDependencyMixin2 extends base {
    static get fields() {
      return [
        { name: "fromEvent", isEqual: (a, b) => a === b, persist: false },
        { name: "toEvent", isEqual: (a, b) => a === b, persist: false }
      ];
    }
    // Resolve early + update indices to have buckets ready before commit
    setChanged(field, value, invalidate) {
      var _a2, _b, _c;
      let update = false;
      if (field === "fromEvent" || field === "toEvent") {
        const event = isInstanceOf(value, CoreEventMixin) ? value : (_a2 = this.eventStore) == null ? void 0 : _a2.getById(value);
        if (event)
          update = true;
        value = event || value;
      }
      superProto.setChanged.call(this, field, value, invalidate, true);
      if (update && !this.project.isPerformingCommit && !((_b = this.dependencyStore) == null ? void 0 : _b.isLoadingData)) {
        (_c = this.dependencyStore) == null ? void 0 : _c.invalidateIndices();
      }
    }
    // Resolve events when joining project
    joinProject() {
      superProto.joinProject.call(this);
      this.setChanged("fromEvent", this.get("fromEvent"));
      this.setChanged("toEvent", this.get("toEvent"));
    }
    // Resolved events as part of commit
    // Normally done earlier in setChanged, but stores might not have been available yet at that point
    calculateInvalidated() {
      var _a2, _b;
      let { fromEvent, toEvent } = this.$changed;
      if (fromEvent !== null && !isInstanceOf(fromEvent, CoreEventMixin)) {
        const resolved = (_a2 = this.eventStore) == null ? void 0 : _a2.getById(fromEvent);
        if (resolved)
          this.$changed.fromEvent = resolved;
      }
      if (toEvent !== null && !isInstanceOf(toEvent, CoreEventMixin)) {
        const resolved = (_b = this.eventStore) == null ? void 0 : _b.getById(toEvent);
        if (resolved)
          this.$changed.toEvent = resolved;
      }
    }
    //region Events
    // Not using "propose" mechanism from CoreEventMixin, because buckets are expected to be up to date right away
    set fromEvent(fromEvent) {
      this.setChanged("fromEvent", fromEvent);
    }
    get fromEvent() {
      const fromEvent = this.get("fromEvent");
      return (fromEvent == null ? void 0 : fromEvent.id) != null ? fromEvent : null;
    }
    set toEvent(toEvent) {
      this.setChanged("toEvent", toEvent);
    }
    get toEvent() {
      const toEvent = this.get("toEvent");
      return (toEvent == null ? void 0 : toEvent.id) != null ? toEvent : null;
    }
  }
  return CoreDependencyMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/CoreDependencyStoreMixin.js
var emptySet2 = /* @__PURE__ */ new Set();
var CoreDependencyStoreMixin = class extends Mixin([AbstractDependencyStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class CoreDependencyStoreMixin2 extends base {
    constructor() {
      super(...arguments);
      this.dependenciesForRemoval = /* @__PURE__ */ new Set();
      this.allDependenciesForRemoval = false;
    }
    static get defaultConfig() {
      return {
        modelClass: CoreDependencyMixin,
        storage: {
          extraKeys: [
            { property: "fromEvent", unique: false },
            { property: "toEvent", unique: false }
          ]
        }
      };
    }
    getIncomingDepsForEvent(event) {
      return this.storage.findItem("toEvent", event) || emptySet2;
    }
    getOutgoingDepsForEvent(event) {
      return this.storage.findItem("fromEvent", event) || emptySet2;
    }
    set data(value) {
      this.allDependenciesForRemoval = true;
      super.data = value;
      this.allDependenciesForRemoval = false;
    }
    updateIndices() {
      this.storage.rebuildIndices();
    }
    invalidateIndices() {
      this.storage.invalidateIndices();
    }
    onCommitAsync() {
      this.updateIndices();
    }
  }
  return CoreDependencyStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreHasAssignmentsMixin.js
var CoreHasAssignmentsMixin = class extends Mixin([CoreEventMixin, AbstractHasAssignmentsMixin], (base) => {
  const superProto = base.prototype;
  class CoreHasAssignmentsMixin2 extends base {
    get assigned() {
      var _a2, _b;
      return (_b = (_a2 = this.project) == null ? void 0 : _a2.assignmentStore.getEventsAssignments(this)) != null ? _b : this.$cachedAssignments;
    }
    leaveProject(isReplacing = false) {
      this.$cachedAssignments = this.assigned;
      super.leaveProject(isReplacing);
    }
    applyValue(useProp, key, value, skipAccessor, field) {
      var _a2;
      if (key === "id") {
        (_a2 = this.assigned) == null ? void 0 : _a2.forEach((assignment) => assignment.set("eventId", value));
      }
      superProto.applyValue.call(this, useProp, key, value, skipAccessor, field);
    }
    copy(newId = null, deep = null) {
      const copy = superProto.copy.call(this, newId, deep);
      if (ObjectHelper.isObject(deep) && !deep.skipFieldIdentifiers || !ObjectHelper.isObject(deep)) {
        copy.$cachedAssignments = this.assigned;
      }
      return copy;
    }
  }
  return CoreHasAssignmentsMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/CoreHasDependenciesMixin.js
var CoreHasDependenciesMixin = class extends Mixin([CoreEventMixin], (base) => {
  const superProto = base.prototype;
  class CoreHasDependenciesMixin2 extends base {
    get outgoingDeps() {
      return this.project.dependencyStore.getOutgoingDepsForEvent(this);
    }
    get incomingDeps() {
      return this.project.dependencyStore.getIncomingDepsForEvent(this);
    }
    leaveProject() {
      const eventStore = this.eventStore;
      if (this.outgoingDeps) {
        this.outgoingDeps.forEach((dependency) => eventStore.dependenciesForRemoval.add(dependency));
      }
      if (this.incomingDeps) {
        this.incomingDeps.forEach((dependency) => eventStore.dependenciesForRemoval.add(dependency));
      }
      superProto.leaveProject.call(this);
    }
  }
  return CoreHasDependenciesMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/SchedulerCoreEvent.js
var SchedulerCoreEvent = class extends Mixin([
  CoreEventMixin,
  CoreHasAssignmentsMixin,
  CoreHasDependenciesMixin
], (base) => {
  const superProto = base.prototype;
  class SchedulerCoreEvent2 extends base {
  }
  return SchedulerCoreEvent2;
}) {
};

// ../Engine/lib/Engine/quark/store/CoreEventStoreMixin.js
var CoreEventStoreMixin = class extends Mixin([AbstractEventStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class CoreEventStoreMixin2 extends base {
    static get defaultConfig() {
      return {
        modelClass: SchedulerCoreEvent
      };
    }
    joinProject() {
      var _a2;
      (_a2 = this.assignmentStore) == null ? void 0 : _a2.linkAssignments(this, "event");
    }
    afterLoadData() {
      var _a2;
      this.afterEventRemoval();
      (_a2 = this.assignmentStore) == null ? void 0 : _a2.linkAssignments(this, "event");
    }
  }
  return CoreEventStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/store/CoreResourceStoreMixin.js
var CoreResourceStoreMixin = class extends Mixin([AbstractResourceStoreMixin, CorePartOfProjectStoreMixin], (base) => {
  const superProto = base.prototype;
  class CoreResourceStoreMixin2 extends base {
    static get defaultConfig() {
      return {
        modelClass: CoreResourceMixin
      };
    }
    joinProject() {
      var _a2;
      (_a2 = this.assignmentStore) == null ? void 0 : _a2.linkAssignments(this, "resource");
    }
    afterLoadData() {
      var _a2;
      (_a2 = this.assignmentStore) == null ? void 0 : _a2.linkAssignments(this, "resource");
    }
    clear(removing) {
      var _a2;
      superProto.clear.call(this, removing);
      (_a2 = this.assignmentStore) == null ? void 0 : _a2.unlinkAssignments("resource");
    }
  }
  return CoreResourceStoreMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/AbstractProjectMixin.js
var EventsWrapper = class extends Mixin([], Events_default) {
};
var DelayableWrapper = class extends Mixin([], Delayable_default) {
};
var AbstractProjectMixin = class extends Mixin([
  EventsWrapper,
  DelayableWrapper,
  Model
], (base) => {
  const superProto = base.prototype;
  class AbstractProjectMixin2 extends base {
    constructor() {
      super(...arguments);
      this.isRestoringData = false;
    }
    get isRepopulatingStores() {
      return false;
    }
    get isInitialCommit() {
      return !this.isInitialCommitPerformed || this.hasLoadedDataToCommit;
    }
    construct(config = {}) {
      this.isInitialCommitPerformed = false;
      this.isLoadingInlineData = false;
      this.isWritingData = false;
      this.hasLoadedDataToCommit = false;
      const silenceInitialCommit = "silenceInitialCommit" in config ? config.silenceInitialCommit : true;
      const adjustDurationToDST = "adjustDurationToDST" in config ? config.adjustDurationToDST : false;
      this.maxCalendarRange = "maxCalendarRange" in config ? config.maxCalendarRange : 15768e7;
      delete config.maxCalendarRange;
      delete config.silenceInitialCommit;
      delete config.adjustDurationToDST;
      superProto.construct.call(this, config);
      this.silenceInitialCommit = silenceInitialCommit;
      this.adjustDurationToDST = adjustDurationToDST;
    }
    // Template method called when a stores dataset is replaced. Implemented in SchedulerBasicProjectMixin
    repopulateStore(store) {
    }
    // Template method called when replica should be repopulated. Implemented in SchedulerBasicProjectMixin
    repopulateReplica() {
    }
    deferUntilRepopulationIfNeeded(deferId, func, args) {
      func(...args);
    }
    // Template method called when a store is attached to the project
    attachStore(store) {
    }
    // Template method called when a store is detached to the project
    detachStore(store) {
    }
    async commitAsync() {
      throw new Error("Abstract method called");
    }
    // Different implementations for Core and Basic engines
    isEngineReady() {
      throw new Error("Abstract method called");
    }
    getStm() {
      throw new Error("Abstract method called");
    }
  }
  return AbstractProjectMixin2;
}) {
};

// ../Engine/lib/Engine/quark/model/scheduler_core/SchedulerCoreProjectMixin.js
var DelayableWrapper2 = class extends Mixin([], Delayable_default) {
};
var SchedulerCoreProjectMixin = class extends Mixin([
  AbstractProjectMixin,
  CorePartOfProjectGenericMixin,
  DelayableWrapper2,
  Model
], (base) => {
  const superProto = base.prototype;
  class SchedulerCoreProjectMixin2 extends base {
    static get configurable() {
      return {
        stm: {},
        eventStore: {},
        assignmentStore: {},
        resourceStore: {},
        dependencyStore: {},
        calendarManagerStore: {},
        eventModelClass: SchedulerCoreEvent,
        assignmentModelClass: CoreAssignmentMixin,
        resourceModelClass: CoreResourceMixin,
        dependencyModelClass: CoreDependencyMixin,
        calendarModelClass: CoreCalendarMixin,
        eventStoreClass: CoreEventStoreMixin,
        assignmentStoreClass: CoreAssignmentStoreMixin,
        resourceStoreClass: CoreResourceStoreMixin,
        dependencyStoreClass: CoreDependencyStoreMixin,
        calendarManagerStoreClass: CoreCalendarManagerStoreMixin,
        assignmentsData: null,
        calendarsData: null,
        dependenciesData: null,
        eventsData: null,
        resourcesData: null
      };
    }
    //endregion
    //region Init
    construct(config = {}) {
      var _a2;
      const me = this;
      me.$invalidated = /* @__PURE__ */ new Set();
      me.isPerformingCommit = false;
      me.silenceInitialCommit = true;
      me.ongoing = Promise.resolve();
      if (config.eventStore && !config.assignmentStore) {
        const eventStore = config.eventStore.masterStore || config.eventStore;
        const assignmentStore = eventStore.assignmentStore || ((_a2 = eventStore.crudManager) == null ? void 0 : _a2.assignmentStore);
        if (assignmentStore == null ? void 0 : assignmentStore.isAssignmentStore) {
          config.assignmentStore = assignmentStore;
          me.isSharingAssignmentStore = true;
        }
      }
      superProto.construct.call(me, config);
      me.defaultCalendar = new me.calendarManagerStore.modelClass({
        unspecifiedTimeIsWorking: me.unspecifiedTimeIsWorking
      });
      me.defaultCalendar.project = me;
      const { calendarsData, eventsData, dependenciesData, resourcesData, assignmentsData } = me;
      const hasInlineData = Boolean(calendarsData || eventsData || dependenciesData || resourcesData || assignmentsData);
      if (hasInlineData) {
        me.loadInlineData({
          calendarsData,
          eventsData,
          dependenciesData,
          resourcesData,
          assignmentsData
        });
        delete me.calendarsData;
        delete me.eventsData;
        delete me.dependenciesData;
        delete me.resourcesData;
        delete me.assignmentsData;
      } else {
        me.bufferedCommitAsync();
      }
    }
    doDestroy() {
      var _a2, _b, _c, _d, _e, _f;
      const me = this;
      (_a2 = me.eventStore) == null ? void 0 : _a2.destroy();
      (_b = me.dependencyStore) == null ? void 0 : _b.destroy();
      (_c = me.assignmentStore) == null ? void 0 : _c.destroy();
      (_d = me.resourceStore) == null ? void 0 : _d.destroy();
      (_e = me.calendarManagerStore) == null ? void 0 : _e.destroy();
      me.defaultCalendar.destroy();
      (_f = me.stm) == null ? void 0 : _f.destroy();
      superProto.doDestroy.call(this);
    }
    /**
     * This method loads the "raw" data into the project. The loading is basically happening by
     * assigning the individual data entries to the `data` property of the corresponding store.
     *
     * @param data
     */
    async loadInlineData(data) {
      const me = this;
      me.isLoadingInlineData = true;
      if (data.calendarsData) {
        me.calendarManagerStore.data = data.calendarsData;
      }
      if (data.resourcesData) {
        me.resourceStore.data = data.resourcesData;
      }
      if (data.assignmentsData) {
        me.assignmentStore.data = data.assignmentsData;
      }
      if (data.eventsData) {
        me.eventStore.data = data.eventsData;
      }
      if (data.tasksData) {
        me.eventStore.data = data.tasksData;
      }
      if (data.dependenciesData) {
        me.dependencyStore.data = data.dependenciesData;
      }
      await me.commitLoad();
      me.isLoadingInlineData = false;
      return;
    }
    //endregion
    //region Join
    async commitLoad() {
      await this.commitAsync();
      if (!this.isDestroyed)
        this.trigger("load");
    }
    joinStoreRecords(store) {
      const fn2 = (record) => {
        record.setProject(this);
        record.joinProject();
      };
      if (store.rootNode) {
        store.rootNode.traverse(fn2);
      } else {
        store.forEach(fn2);
      }
    }
    unJoinStoreRecords(store) {
      const fn2 = (record) => {
        record.leaveProject();
        record.setProject(this);
      };
      if (store.rootNode) {
        store.rootNode.traverse((node) => {
          if (node !== store.rootNode)
            fn2(node);
        });
      } else {
        store.forEach(fn2);
      }
    }
    //endregion
    //region EventStore
    resolveStoreAndModelClass(name, config) {
      const storeClass = (config == null ? void 0 : config.storeClass) || this[`${name}StoreClass`];
      let modelClass = config == null ? void 0 : config.modelClass;
      if (!modelClass) {
        if (this.getDefaultConfiguration()[`${name}ModelClass`] !== storeClass.getDefaultConfiguration().modelClass) {
          modelClass = storeClass.getDefaultConfiguration().modelClass;
        } else {
          modelClass = this[`${name}ModelClass`];
        }
      }
      return { storeClass, modelClass };
    }
    setEventStore(eventStore) {
      this.eventStore = eventStore;
    }
    changeEventStore(eventStore, oldStore) {
      const me = this, { stm } = me;
      me.detachStore(oldStore);
      if (!(eventStore instanceof Store)) {
        const { storeClass, modelClass } = me.resolveStoreAndModelClass("event", eventStore);
        eventStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm
        }, eventStore));
      } else {
        eventStore.project = me;
        stm.addStore(eventStore);
        me.joinStoreRecords(eventStore);
      }
      if (oldStore && stm.hasStore(oldStore)) {
        stm.removeStore(oldStore);
        me.unJoinStoreRecords(oldStore);
        const { assignmentsForRemoval } = oldStore;
        assignmentsForRemoval.forEach((assignment) => {
          const oldEvent = assignment.event;
          if (oldEvent) {
            const newEvent = eventStore.getById(oldEvent.id);
            if (newEvent) {
              assignment.event = newEvent;
              assignmentsForRemoval.delete(assignment);
            }
          }
        });
        oldStore.afterEventRemoval();
      }
      eventStore.setProject(me);
      return eventStore;
    }
    updateEventStore(eventStore, oldStore) {
      this.attachStore(eventStore);
      this.trigger("eventStoreChange", { store: eventStore });
    }
    //endregion
    //region AssignmentStore
    setAssignmentStore(assignmentStore) {
      this.assignmentStore = assignmentStore;
    }
    changeAssignmentStore(assignmentStore, oldStore) {
      const me = this, { stm } = me;
      me.detachStore(oldStore);
      if (oldStore && stm.hasStore(oldStore)) {
        stm.removeStore(oldStore);
        me.unJoinStoreRecords(oldStore);
      }
      if (!(assignmentStore instanceof Store)) {
        const { storeClass, modelClass } = me.resolveStoreAndModelClass("assignment", assignmentStore);
        assignmentStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm
        }, assignmentStore));
      } else {
        assignmentStore.project = me;
        stm.addStore(assignmentStore);
        me.joinStoreRecords(assignmentStore);
      }
      assignmentStore.setProject(me);
      return assignmentStore;
    }
    updateAssignmentStore(assignmentStore, oldStore) {
      this.attachStore(assignmentStore);
      this.trigger("assignmentStoreChange", { store: assignmentStore });
    }
    //endregion
    //region ResourceStore
    setResourceStore(resourceStore) {
      this.resourceStore = resourceStore;
    }
    changeResourceStore(resourceStore, oldStore) {
      const me = this, { stm } = me;
      me.detachStore(oldStore);
      if (!(resourceStore instanceof Store)) {
        const { storeClass, modelClass } = me.resolveStoreAndModelClass("resource", resourceStore);
        resourceStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm
        }, resourceStore));
      } else {
        resourceStore.project = me;
        stm.addStore(resourceStore);
        me.joinStoreRecords(resourceStore);
      }
      if (oldStore && stm.hasStore(oldStore)) {
        stm.removeStore(oldStore);
        me.unJoinStoreRecords(oldStore);
        const { assignmentsForRemoval } = oldStore;
        assignmentsForRemoval.forEach((assignment) => {
          const oldResource = assignment.resource;
          if (oldResource) {
            const newResource = resourceStore.getById(oldResource.id);
            if (newResource) {
              assignment.resource = newResource;
              assignmentsForRemoval.delete(assignment);
            }
          }
        });
        oldStore.afterResourceRemoval();
      }
      resourceStore.setProject(me);
      return resourceStore;
    }
    updateResourceStore(resourceStore, oldStore) {
      this.attachStore(resourceStore);
      this.trigger("resourceStoreChange", { store: resourceStore });
    }
    //endregion
    //region DependencyStore
    setDependencyStore(dependencyStore) {
      this.dependencyStore = dependencyStore;
    }
    changeDependencyStore(dependencyStore, oldStore) {
      const me = this;
      me.detachStore(oldStore);
      if (!(dependencyStore instanceof Store)) {
        const { storeClass, modelClass } = me.resolveStoreAndModelClass("dependency", dependencyStore);
        dependencyStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm: me.stm
        }, dependencyStore));
      } else {
        dependencyStore.project = me;
        me.stm.addStore(dependencyStore);
        me.joinStoreRecords(dependencyStore);
      }
      return dependencyStore;
    }
    updateDependencyStore(dependencyStore, oldStore) {
      this.attachStore(dependencyStore);
      this.trigger("dependencyStoreChange", { store: dependencyStore });
    }
    //endregion
    //region CalendarManagerStore
    setCalendarManagerStore(calendarManagerStore) {
      this.calendarManagerStore = calendarManagerStore;
    }
    changeCalendarManagerStore(calendarManagerStore, oldStore) {
      const me = this;
      me.detachStore(oldStore);
      if (!(calendarManagerStore instanceof Store)) {
        const storeClass = (calendarManagerStore == null ? void 0 : calendarManagerStore.storeClass) || me.calendarManagerStoreClass;
        const modelClass = (calendarManagerStore == null ? void 0 : calendarManagerStore.modelClass) || storeClass.getDefaultConfiguration().modelClass || me.calendarModelClass;
        calendarManagerStore = new storeClass(ObjectHelper.assign({
          modelClass,
          project: me,
          stm: me.stm
        }, calendarManagerStore));
      } else {
        me.stm.addStore(calendarManagerStore);
      }
      calendarManagerStore.setProject(me);
      return calendarManagerStore;
    }
    updateCalendarManagerStore(calendarManagerStore, oldStore) {
      this.attachStore(calendarManagerStore);
      this.trigger("calendarManagerStoreChange", { store: calendarManagerStore });
    }
    //endregion
    //region Calendar
    get calendar() {
      return this.$calendar || this.defaultCalendar;
    }
    set calendar(calendar) {
      this.$calendar = calendar;
    }
    get effectiveCalendar() {
      return this.calendar;
    }
    //endregion
    //region Add records
    async addEvent(event) {
      this.eventStore.add(event);
      return this.commitAsync();
    }
    async addAssignment(assignment) {
      this.assignmentStore.add(assignment);
      return this.commitAsync();
    }
    async addResource(resource) {
      this.resourceStore.add(resource);
      return this.commitAsync();
    }
    async addDependency(dependency) {
      this.dependencyStore.add(dependency);
      return this.commitAsync();
    }
    //endregion
    //region Auto commit
    // Buffer commitAsync using setTimeout. Not using `buffer` on purpose, for performance reasons and to better
    // mimic how graph does it
    bufferedCommitAsync() {
      if (!this.hasPendingAutoCommit) {
        this.setTimeout({
          fn: "commitAsync",
          delay: 10
        });
      }
    }
    get hasPendingAutoCommit() {
      return this.hasTimeout("commitAsync");
    }
    unScheduleAutoCommit() {
      this.clearTimeout("commitAsync");
    }
    //endregion
    //region Commit
    async commitAsync() {
      if (this.isPerformingCommit)
        return this.ongoing;
      return this.ongoing = this.doCommitAsync();
    }
    async doCommitAsync() {
      const me = this;
      me.isPerformingCommit = true;
      me.unScheduleAutoCommit();
      await delay(0);
      if (!me.isDestroyed) {
        for (const record of me.$invalidated) {
          record.calculateInvalidated();
        }
        const { isInitialCommit, silenceInitialCommit } = me;
        const silenceCommit = isInitialCommit && silenceInitialCommit;
        me.assignmentStore.onCommitAsync();
        me.dependencyStore.onCommitAsync();
        me.isInitialCommitPerformed = true;
        me.hasLoadedDataToCommit = false;
        me.isPerformingCommit = false;
        const stores = [me.assignmentStore, me.dependencyStore, me.eventStore, me.resourceStore, me.calendarManagerStore];
        stores.forEach((store) => {
          var _a2;
          return (_a2 = store.suspendAutoCommit) == null ? void 0 : _a2.call(store);
        });
        me.isWritingData = true;
        me.trigger("refresh", { isInitialCommit, isCalculated: true });
        if (silenceCommit) {
          for (const record of me.$invalidated) {
            record.finalizeInvalidated(true);
          }
        } else {
          for (const record of me.$invalidated) {
            record.beginBatch(true);
            record.finalizeInvalidated();
          }
          for (const record of me.$invalidated) {
            record.endBatch(false, true);
          }
        }
        me.isWritingData = false;
        me.$invalidated.clear();
        me.trigger("dataReady");
        stores.forEach((store) => {
          var _a2;
          return (_a2 = store.resumeAutoCommit) == null ? void 0 : _a2.call(store);
        });
        me.trigger("commitFinalized");
        return true;
      }
    }
    async propagateAsync() {
      return this.commitAsync();
    }
    // Called when a record invalidates itself, queues it for calculation
    invalidate(record) {
      this.$invalidated.add(record);
      this.bufferedCommitAsync();
    }
    // this does not account for possible scheduling conflicts
    async isValidDependency() {
      return true;
    }
    //endregion
    //region STM
    getStm() {
      return this.stm;
    }
    /**
     * State tracking manager instance the project relies on
     */
    set stm(stm) {
      stm = this.$stm = new StateTrackingManager(ObjectHelper.assign({
        disabled: true
      }, stm));
      stm.ion({
        // Propagate on undo/redo
        restoringStop: async () => {
          stm.disable();
          await this.commitAsync();
          if (!this.isDestroyed) {
            stm.enable();
            this.trigger("stateRestoringDone");
          }
        }
      });
    }
    get stm() {
      return this.$stm;
    }
    //endregion
    isEngineReady() {
      return !this.hasPendingAutoCommit && !this.isPerformingCommit && this.isInitialCommitPerformed;
    }
  }
  SchedulerCoreProjectMixin2.applyConfigs = true;
  return SchedulerCoreProjectMixin2;
}) {
};

// lib/TaskBoard/feature/TaskBoardFeature.js
var TaskBoardFeature = class extends InstancePlugin.mixin(Factoryable_default) {
  // This makes all feature config changes after initialization recompose TaskBoard
  onConfigChange(args) {
    if (!this.isConfiguring && !this.isDestroying) {
      this.client.recompose();
    }
    super.onConfigChange(args);
  }
};
__publicField(TaskBoardFeature, "factoryable", {});
__publicField(TaskBoardFeature, "configurable", {});
TaskBoardFeature._$name = "TaskBoardFeature";

// lib/TaskBoard/feature/ColumnDrag.js
var ColumnDrag = class extends TaskBoardFeature {
  initialCompose() {
    const me = this;
    me.draggable = ColumnZone.new({
      dragRootElement: me.disabled ? null : me.client.bodyWrapElement,
      dropRootElement: me.client.bodyWrapElement,
      owner: me,
      internalListeners: {
        beforeDragStart: "onBeforeDragStart",
        dragStart: "onDragStart",
        thisObj: me
      }
    }, me.draggable);
  }
  doDestroy() {
    var _a2;
    (_a2 = this.draggable) == null ? void 0 : _a2.destroy();
    super.doDestroy();
  }
  doDisable(disable) {
    super.doDisable(disable);
    if (this.draggable) {
      this.draggable.dragRootElement = disable ? null : this.client.bodyWrapElement;
    }
  }
  movePrev(columnRecord) {
    const { columns } = this.client;
    columns.move(columnRecord, columns.getPrev(columnRecord));
  }
  moveNext(columnRecord) {
    const { columns } = this.client, beforeIndex = Math.min(columns.indexOf(columnRecord) + 2, columns.count);
    columns.move(columnRecord, columns.getAt(beforeIndex));
  }
  populateColumnHeaderMenu({ items: items2, columnRecord }) {
    const { client } = this, { columns, rtl } = client;
    if (!client.readOnly && !this.disabled) {
      items2.moveColumnLeft = {
        text: "L{TaskBoard.moveColumnLeft}",
        icon: "b-fw-icon b-icon-left",
        disabled: columnRecord === columns[rtl ? "last" : "first"],
        weight: 200,
        onItem: () => this["move" + (rtl ? "Next" : "Prev")](columnRecord)
      };
      items2.moveColumnRight = {
        text: "L{TaskBoard.moveColumnRight}",
        icon: "b-fw-icon b-icon-right",
        disabled: columnRecord === columns[rtl ? "first" : "last"],
        weight: 300,
        onItem: () => this["move" + (rtl ? "Prev" : "Next")](columnRecord)
      };
    }
  }
  onBeforeDragStart({ drag, event }) {
    return this.client.trigger("beforeColumnDrag", { drag, event, columnRecord: drag.columnRecord });
  }
  onDragStart({ drag, event }) {
    return this.client.trigger("columnDragStart", { drag, event, columnRecord: drag.columnRecord });
  }
};
__publicField(ColumnDrag, "$name", "ColumnDrag");
__publicField(ColumnDrag, "type", "columnDrag");
__publicField(ColumnDrag, "pluginConfig", {
  after: ["initialCompose", "populateColumnHeaderMenu"]
});
ColumnDrag.initClass();
var ColumnZone = class extends Base.mixin(Draggable_default, Droppable_default, Events_default) {
  static get configurable() {
    return {
      dragSelector: ".b-taskboard-column-header, .b-taskboard-column-header *",
      dragItemSelector: ".b-taskboard-column-header",
      // Column has multiple parts (header + one element per swimlane), going to add cls manually to them
      draggingItemCls: null,
      dragProxy: {
        type: "default",
        async open(drag) {
          const { owner } = this, {
            itemElement,
            startEvent,
            columnRecord
          } = drag, taskBoard = owner.owner.client, headerBounds = Rectangle.from(itemElement, owner.dragRootElement), proxyOffset = EventHelper.getClientPoint(startEvent).getDelta(headerBounds), proxy = DomHelper.createElement({
            className: "b-taskboard-column-drag-proxy",
            parent: owner.dragRootElement,
            style: {
              // Using fixed top, only draggable horizontally
              top: headerBounds.y,
              // Offset from cursor to be positioned over original column
              left: EventHelper.getClientPoint(startEvent).translate(proxyOffset[0], 0).x,
              // Need a fixed width on the proxy, since columns width might be flexed etc
              width: itemElement.getBoundingClientRect().width
            },
            // Don't want it being removed while dragging
            retainElement: true
          }), elements = [itemElement, ...taskBoard.getColumnElements(columnRecord)];
          Object.assign(drag, {
            proxy,
            elements,
            proxyOffset
          });
          elements.forEach((element, i) => {
            const columnClone = element.cloneNode(true), bounds = element.getBoundingClientRect();
            element.originalWidth = bounds.width;
            element.originalHeight = bounds.height;
            if (element.matches(".b-taskboard-column")) {
              const swimlane = element.closest(".b-taskboard-swimlane"), header = DomSync.getChild(swimlane, "header"), body = DomSync.getChild(swimlane, "body"), swimlaneClone = swimlane.cloneNode(), headerClone = header == null ? void 0 : header.cloneNode(true), bodyClone = body.cloneNode();
              let height = swimlane.getBoundingClientRect().height;
              if (i === elements.length - 1) {
                const paddingBottom = DomHelper.getStyleValue(element.parentElement, "padding-bottom");
                height -= parseFloat(paddingBottom);
              }
              swimlaneClone.style.flex = `0 0 ${height}px`;
              headerClone && swimlaneClone.appendChild(headerClone);
              bodyClone.appendChild(columnClone);
              swimlaneClone.appendChild(bodyClone);
              proxy.appendChild(swimlaneClone);
            } else {
              proxy.appendChild(columnClone);
            }
            element.classList.add("b-drag-original");
          });
        },
        dragMove({ proxy, event, proxyOffset }) {
          const position = EventHelper.getClientPoint(event).translate(proxyOffset[0], 0);
          proxy.style.left = `${position.x}px`;
        }
      }
    };
  }
  setupDragContext(event) {
    const result = super.setupDragContext(event), { client } = this.owner;
    result.scrollManager = client.scrollManager;
    result.monitoringConfig = {
      scrollables: [{
        element: client.bodyElement,
        direction: "horizontal"
      }]
    };
    return result;
  }
  // Populate the drag context early, to have something to take decisions on in beforeDragStart listeners
  startDrag(drag) {
    drag.columnRecord = this.owner.client.resolveColumnRecord(drag.itemElement);
    return super.startDrag(drag);
  }
  dragStart(drag) {
    this.owner.client.suspendResponsiveness();
    drag.wasStarted = true;
  }
  dragEnter(drag) {
    if (!drag.itemElement.matches(this.dragItemSelector)) {
      return false;
    }
    if (!drag.dropIndicators) {
      drag.dropIndicators = drag.elements.map((element, i) => DomHelper.createElement({
        className: "b-taskboard-column-drop-indicator",
        elementData: {
          dropIndicator: true,
          // Tag along the element, to be able to return the drop indicator to its position for
          // invalid drop targets. NOTE: Currently not used
          element
        },
        // Use same size as dragged column had originally
        style: {
          width: element.originalWidth,
          height: element.originalHeight
        }
      }));
      this.insertDropIndicators(drag, drag.columnRecord);
    }
  }
  insertDropIndicators(drag, beforeColumnRecord) {
    const { client } = this.owner, insertAt = client.columns.indexOf(beforeColumnRecord);
    drag.dropIndicators.forEach((dropIndicator, i) => {
      var _a2, _b;
      if (i === 0) {
        const headerContainer = DomSync.getChild(client.bodyElement, "header"), actualHeaders = [...headerContainer.children];
        ArrayHelper.remove(actualHeaders, dropIndicator);
        headerContainer.insertBefore(dropIndicator, actualHeaders[insertAt]);
      } else {
        const swimlaneRecord = (_b = (_a2 = client.swimlanes) == null ? void 0 : _a2.getAt(i - 1)) != null ? _b : { domId: "default" }, swimlaneBody = DomSync.getChild(client.getSwimlaneElement(swimlaneRecord), "body"), actualColumns = [...swimlaneBody.children];
        ArrayHelper.remove(actualColumns, dropIndicator);
        swimlaneBody.insertBefore(dropIndicator, actualColumns[insertAt]);
      }
    });
  }
  updateValidity(drag, valid) {
    drag.proxy.classList.toggle("b-invalid", !valid);
    drag.dropIndicators.forEach((dropIndicator) => dropIndicator.classList.toggle("b-invalid", !valid));
    drag.invalid = !valid;
  }
  dragMove(drag) {
    var _a2;
    const { client } = this.owner, documentRoot = client.documentRoot, proxyBounds = Rectangle.from(drag.proxy, void 0, true), overElement = documentRoot.elementFromPoint(proxyBounds.center.x, proxyBounds.y), columnHeaderElement = overElement == null ? void 0 : overElement.closest(".b-taskboard-column-header");
    if (drag.invalid) {
      drag.valid = false;
    }
    if (!((_a2 = overElement == null ? void 0 : overElement.elementData) == null ? void 0 : _a2.dropIndicator) && columnHeaderElement) {
      const targetBounds = Rectangle.from(columnHeaderElement);
      let beforeColumn = client.resolveColumnRecord(columnHeaderElement);
      if (proxyBounds.center.x > targetBounds.center.x) {
        beforeColumn = client.columns.getNext(beforeColumn);
      }
      this.insertDropIndicators(drag, beforeColumn);
      const shouldTrigger = drag.beforeColumn !== beforeColumn;
      drag.beforeColumn = beforeColumn;
      if (shouldTrigger) {
        const result = client.trigger("columnDrag", { drag, columnRecord: drag.columnRecord, beforeColumn });
        this.updateValidity(drag, result !== false);
      }
    }
  }
  async dragDrop(drag) {
    const { client } = this.owner, { columns } = client, {
      columnRecord,
      beforeColumn,
      elements,
      dropIndicators,
      proxy
    } = drag;
    if (drag.invalid || await client.trigger("beforeColumnDrop", { drag, columnRecord, beforeColumn }) === false) {
      drag.valid = false;
    } else {
      drag.finalizer = new Promise((resolve) => {
        function commit() {
          proxy.remove();
          dropIndicators.forEach((dropIndicator) => dropIndicator.remove());
          elements.forEach((element) => element.classList.remove("b-drag-original"));
          client.suspendDomTransition();
          beforeColumn !== void 0 && columns.move(columnRecord, beforeColumn);
          client.resumeDomTransition();
          client.trigger("columnDrop", { drag, columnRecord, beforeColumn });
          client.trigger("columnDragEnd", { drag, columnRecord, beforeColumn });
          client.resumeResponsiveness();
          resolve();
        }
        proxy.classList.add("b-dropping");
        DomHelper.alignTo(
          proxy,
          Rectangle.from(dropIndicators[0], void 0, true)
        );
        if (DomHelper.getPropertyTransitionDuration(proxy, "transform")) {
          EventHelper.onTransitionEnd({
            element: proxy,
            property: "transform",
            handler: commit,
            thisObj: client
          });
        } else {
          commit();
        }
      });
    }
  }
  dragLeave(drag) {
  }
  doAbort(drag) {
    const { client } = this.owner, { dropIndicators, proxy, columnRecord, elements } = drag;
    if (proxy) {
      let finalizeAbort = function() {
        proxy.remove();
        dropIndicators.forEach((dropIndicator) => dropIndicator.remove());
        elements.forEach((element) => element.classList.remove("b-drag-original"));
        client.trigger("columnDragAbortFinalized");
      };
      proxy.classList.add("b-dropping");
      dropIndicators.forEach((dropIndicator, i) => {
        const original = drag.elements[i];
        dropIndicator.classList.remove("b-invalid");
        original.parentElement.insertBefore(dropIndicator, original);
      });
      DomHelper.alignTo(
        proxy,
        Rectangle.from(dropIndicators[0], void 0, true)
      );
      if (DomHelper.getPropertyTransitionDuration(proxy, "transform")) {
        EventHelper.onTransitionEnd({
          element: proxy,
          property: "transform",
          handler: finalizeAbort,
          thisObj: client
          // For timer cleanup
        });
      } else {
        finalizeAbort();
      }
    }
    client.trigger("columnDragAbort", { drag, columnRecord });
    if (drag.wasStarted) {
      client.trigger("columnDragEnd", { drag, columnRecord });
    }
  }
  dragEnd(drag) {
    if (!drag.valid || drag.aborted) {
      this.doAbort(drag);
    }
  }
};
ColumnDrag._$name = "ColumnDrag";

// lib/TaskBoard/feature/ColumnHeaderMenu.js
var ColumnHeaderMenu = class extends ContextMenuBase {
  static get pluginConfig() {
    const config = super.pluginConfig;
    config.chain.push(...["populateColumnHeaderMenu", "populateColumnHeader", "onColumnHeaderClick"]);
    return config;
  }
  //region Events
  /**
   * This event fires on the owning TaskBoard before the menu is shown for a column header.
   * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.
   *
   * Returning `false` from a listener prevents the menu from being shown.
   *
   * @event columnHeaderMenuBeforeShow
   * @on-owner
   * @preventable
   * @param {TaskBoard.view.TaskBoard} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Object<string,MenuItemConfig>} items Menu item configs
   * @param {TaskBoard.model.ColumnModel} columnRecord The column
   * @on-owner
   */
  /**
   * This event fires on the owning TaskBoard after the context menu is shown for a column header.
   * @event cellMenuShow
   * @on-owner
   * @param {TaskBoard.view.TaskBoard} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Object<string,MenuItemConfig>} items Menu item configs
   * @param {TaskBoard.model.ColumnModel} columnRecord The column
   * @on-owner
   */
  /**
   * This event fires on the owning TaskBoard when an item is selected in the column header menu.
   * @event cellMenuItem
   * @on-owner
   * @param {TaskBoard.view.TaskBoard} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   * @param {TaskBoard.model.ColumnModel} columnRecord The column
   * @on-owner
   */
  /**
   * This event fires on the owning TaskBoard when a check item is toggled in the column header menu.
   * @event cellMenuToggleItem
   * @on-owner
   * @param {TaskBoard.view.TaskBoard} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   * @param {TaskBoard.model.ColumnModel} columnRecord The column
   * @param {Boolean} checked Checked or not
   * @on-owner
   */
  //endregion
  //region Type assertions
  changeItems(items2) {
    ObjectHelper.assertObject(items2, "features.columnHeaderMenu.items");
    return items2;
  }
  changeProcessItems(fn2) {
    ObjectHelper.assertFunction(fn2, "features.columnHeaderMenu.processItems");
    return fn2;
  }
  //endregion
  // Inject a "button" into column headers
  populateColumnHeader({ columnHeaderConfig }) {
    if (!this.disabled) {
      columnHeaderConfig.children.padder.children.menu = {
        tag: "button",
        class: {
          "b-column-header-button": 1,
          "b-taskboard-column-header-menu-button": 1,
          "b-fw-icon": 1,
          "b-icon-menu-horizontal": 1
        }
      };
    }
  }
  // Populate menu events with taskboard specifics
  getDataFromEvent(event) {
    return ObjectHelper.assign(super.getDataFromEvent(event), event.taskBoardData);
  }
  // Add default menu items
  populateColumnHeaderMenu({ items: items2, columnRecord }) {
    const { client } = this;
    if (!client.readOnly) {
      items2.addTask = {
        text: "L{TaskBoard.addTask}",
        icon: "b-fw-icon b-icon-add",
        weight: 100,
        onItem() {
          client.addTask(columnRecord);
        }
      };
    }
  }
  // Detect "button" click
  onColumnHeaderClick(args) {
    const { event } = args;
    if (event.target.matches(".b-column-header-button")) {
      this.showContextMenu(event, { target: event.target, align: "t90-b90" });
    }
  }
  doDisable(disable) {
    super.doDisable(disable);
    !this.isConfiguring && this.client.recompose();
  }
  get showMenu() {
    return true;
  }
};
__publicField(ColumnHeaderMenu, "$name", "ColumnHeaderMenu");
__publicField(ColumnHeaderMenu, "type", "columnHeaderMenu");
__publicField(ColumnHeaderMenu, "configurable", {
  /**
   * A function called before displaying the menu that allows manipulations of its items.
   * Returning `false` from this function prevents the menu from being shown.
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *   features         : {
   *       columnHeaderMenu : {
   *           processItems({ columnRecord, items }) {
   *              // Push an extra item for the todo column
   *              if (columnRecord.id === 'todo') {
   *                  items.finishAll = {
   *                      text : 'Finish all',
   *                      icon : 'b-fa-fw b-fa-check'
   *                      onItem({ columnRecord }) {
   *                          columnRecord.tasks.forEach(taskRecord => taskRecord.status = 'done');
   *                      }
   *                  };
   *               }
   *           }
   *       }
   *   }
   * });
   * ```
   *
   * @config {Function}
   * @param {Object} context An object with information about the menu being shown
   * @param {TaskBoard.model.ColumnModel} context.columnRecord The column for which the menu will be shown
   * @param {Object<String,MenuItemConfig|Boolean>} context.items An object containing the
   *   {@link Core.widget.MenuItem menu item} configs keyed by their id
   * @param {Event} context.event The DOM event object that triggered the show
   * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown
   * @preventable
   */
  processItems: null,
  /**
   * This is a preconfigured set of items used to create the default context menu.
   *
   * The `items` provided by this feature are listed in the intro section of this class. You can configure
   * existing items by passing a configuration object to the keyed items.
   *
   * To remove existing items, set corresponding keys `null`:
   *
   * ```javascript
   * const scheduler = new Scheduler({
   *     features : {
   *         columnHeaderMenu : {
   *             items : {
   *                 addTask : null
   *             }
   *         }
   *     }
   * });
   * ```
   *
   * See the class description for more examples.
   *
   * @config {Object<string,MenuItemConfig|Boolean|null>} items
   */
  items: null,
  menu: {
    anchor: true
  },
  type: "columnHeader",
  triggerEvent: false
  /**
   * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
   * @config {Object<String,String>>} keyMap
   */
  /**
   * @hideconfigs type, triggerEvent
   */
});
TaskBoardFeature.register(ColumnHeaderMenu.type, ColumnHeaderMenu);
ColumnHeaderMenu._$name = "ColumnHeaderMenu";

// lib/TaskBoard/feature/ColumnToolbars.js
var ColumnToolbars = class extends TaskBoardFeature {
  constructor() {
    super(...arguments);
    // Holds exising toolbars, keyed by location, column and swimlane
    __publicField(this, "columnMap", /* @__PURE__ */ new Map());
  }
  doDestroy() {
    for (const [, toolbar] of this.columnMap) {
      toolbar.destroy();
    }
    super.doDestroy();
  }
  //region Type assertions
  changeTopItems(items2) {
    ObjectHelper.assertObject(items2, "features.columnToolbars.topItems");
    return items2;
  }
  changeBottomItems(items2) {
    ObjectHelper.assertObject(items2, "features.columnToolbars.bottomItems");
    return items2;
  }
  changeProcessItems(fn2) {
    ObjectHelper.assertFunction(fn2, "features.columnToolbars.processItems");
    return fn2;
  }
  //endregion
  //region Toolbars
  // removeToolbar(location) {
  //     const columnMap = this.columnMap;
  //
  //     for (const [key, toolbar] of columnMap) {
  //         if (key.startsWith(location)) {
  //             toolbar.destroy();
  //             columnMap.delete(toolbar);
  //         }
  //     }
  // }
  //
  // changeTopItems(items, old) {
  //     if (old && !items) {
  //         this.removeToolbar('top');
  //     }
  //
  //     return items;
  // }
  //
  // changeBottomItems(items, old) {
  //     if (old && !items) {
  //         this.removeToolbar('items');
  //     }
  //
  //     return items;
  // }
  // Creates or retrieves a toolbar instance for the requested column/swimlane intersection
  getToolbar(location, columnRecord, swimlaneRecord) {
    var _a2, _b;
    const me = this, { columnMap, client, namedItems } = me, items2 = me[`${location}Items`], key = `${location}_._${columnRecord.domId}_._${(_a2 = swimlaneRecord == null ? void 0 : swimlaneRecord.domId) != null ? _a2 : "default"}`;
    let toolbar = columnMap.get(key);
    if (!toolbar) {
      const clonedItems = {};
      ObjectHelper.getTruthyKeys(items2).map((ref) => {
        const namedItem = namedItems[ref], item = items2[ref];
        clonedItems[ref] = ObjectHelper.merge(
          // Default listeners + decorate with records
          {
            internalListeners: {
              click: "onClick",
              change: "onChange",
              thisObj: me
            },
            columnRecord,
            swimlaneRecord
          },
          // Merge with any matched named item
          namedItem,
          // And any supplied config
          item
        );
      });
      if (((_b = me.processItems) == null ? void 0 : _b.call(me, { items: clonedItems, location, columnRecord, swimlaneRecord })) === false) {
        return null;
      }
      toolbar = client.add({
        type: "toolbar",
        cls: `b-taskboard-column-${location[0]}bar`,
        overflow: null,
        monitorResize: false,
        contentElMutationObserver: false,
        items: clonedItems,
        dataset: {
          role: `${location}-toolbar`,
          domTransition: true
        }
      });
      columnMap.set(key, toolbar);
    }
    return toolbar.element;
  }
  populateColumn({ columnConfig, columnRecord, swimlaneRecord }) {
    const me = this;
    if (!me.disabled) {
      if (ObjectHelper.getTruthyKeys(me.topItems).length) {
        DomHelper.merge(columnConfig, {
          children: {
            "tbar > body": me.getToolbar("top", columnRecord, swimlaneRecord)
          }
        });
      }
      if (ObjectHelper.getTruthyKeys(me.bottomItems).length) {
        columnConfig.children.bbar = me.getToolbar("bottom", columnRecord, swimlaneRecord);
      }
    }
  }
  removeColumnToolbar(location, columnId, swimlaneId) {
    const { columnMap, client } = this, key = `${location}_._${columnId}_._${swimlaneId}`, toolbar = columnMap.get(key);
    if (toolbar) {
      client.remove(toolbar);
      client.setTimeout(() => toolbar.destroy(), 0);
      columnMap.delete(key);
    }
  }
  removeColumnToolbars(columnId, swimlaneId) {
    this.removeColumnToolbar("top", columnId, swimlaneId);
    this.removeColumnToolbar("bottom", columnId, swimlaneId);
  }
  onRemoveColumnElement({ columnId, swimlaneRecord }) {
    var _a2;
    this.removeColumnToolbars(columnId, (_a2 = swimlaneRecord.id) != null ? _a2 : "default");
  }
  onRemoveSwimlaneElement({ swimlaneId }) {
    for (const column of this.client.columns) {
      this.removeColumnToolbars(column.id, swimlaneId);
    }
  }
  //endregion
  //region Predefined items events
  onAddClick({ source }) {
    this.client.addTask(source.columnRecord, source.swimlaneRecord);
  }
  //endregion
  //region Generic events
  onChange({ source }) {
    this.trigger("itemChange", {
      item: source,
      columnRecord: source.columnRecord,
      swimlaneRecord: source.swimlaneRecord
    });
  }
  onClick({ source }) {
    this.trigger("itemClick", {
      item: source,
      columnRecord: source.columnRecord,
      swimlaneRecord: source.swimlaneRecord
    });
  }
  //endregion
};
__publicField(ColumnToolbars, "$name", "ColumnToolbars");
__publicField(ColumnToolbars, "type", "columnToolbars");
__publicField(ColumnToolbars, "configurable", {
  /**
   * Items to add to the top toolbar, in object format.
   *
   *
   * ```javascript
   * new TaskBoard({
   *    features : {
   *        columnToolbars : {
   *            topItems : {
   *                clearButton : {
   *                    icon    : 'b-fa-trash',
   *                    onClick : ...
   *                }
   *            }
   *        }
   *    }
   * });
   * ```
   *
   * @config {Object<String,ContainerItemConfig|Boolean|null>}
   */
  topItems: null,
  /**
   * Items to add to the bottom toolbar, in object format.
   *
   * To remove existing items, set corresponding keys to `null`.
   *
   * ```javascript
   * new TaskBoard({
   *    features : {
   *        columnToolbars : {
   *            bottomItems : {
   *                clearButton : {
   *                    icon    : 'b-fa-trash',
   *                    onClick : ...
   *                }
   *            }
   *        }
   *    }
   * });
   * ```
   *
   * @config {Object<String,ContainerItemConfig|Boolean|null>}
   */
  bottomItems: {
    addTask: true
  },
  // Predefined items that can be used in topItems and/or bottomItems
  namedItems: {
    addTask: {
      type: "button",
      icon: "b-icon-add",
      tooltip: "L{TaskBoard.addTask}",
      ariaLabel: "L{TaskBoard.addTask}",
      internalListeners: {
        click: "onAddClick"
      }
    }
  },
  /**
   * A function called before displaying the toolbar that allows manipulations of its items.
   * Returning `false` from this function prevents the menu being shown.
   *
   * ```javascript
   * features         : {
   *    columnToolbars : {
   *         processItems({ items, location, columnRecord, swimlaneRecord }) {
   *             // Add or hide existing items here as needed
   *             items.myAction = {
   *                 text   : 'Cool action',
   *                 icon   : 'b-fa-ban',
   *                 onClick : () => console.log(`Clicked button for ${columnRecord.text}`)
   *             };
   *
   *            if (columnRecord.id === 'done') {
   *                items.addTask = false
   *            }
   *         }
   *     }
   * },
   * ```
   *
   * @config {Function}
   * @param {Object} context An object with information about the toolbar being shown
   * @param {Object<String,ContainerItemConfig>} context.items An object containing the toolbar item configs keyed by ref
   * @param {'top'|'bottom'} context.location Toolbar location, "top" or "bottom"
   * @param {TaskBoard.model.ColumnModel} context.columnRecord Record representing toolbars column
   * @param {TaskBoard.model.SwimlaneModel} context.swimlaneRecord Record representing toolbars swimlane
   * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown
   * @preventable
   */
  processItems: null
});
__publicField(ColumnToolbars, "pluginConfig", {
  chain: ["populateColumn", "onRemoveColumnElement", "onRemoveSwimlaneElement"]
});
ColumnToolbars.initClass();
ColumnToolbars._$name = "ColumnToolbars";

// lib/TaskBoard/view/item/TaskItem.js
var TaskItem = class extends Base.mixin(Factoryable_default) {
  static getEditorConfig({ config, item }) {
    const editor = config.editor !== null && (config.editor || item.defaultEditor);
    if (typeof editor === "string") {
      return {
        type: editor
      };
    }
    return editor;
  }
};
__publicField(TaskItem, "factoryable", {});
__publicField(TaskItem, "configurable", {
  /**
   * Task field whose value item will act on (usually display it). Defaults to use the key in the items object.
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *    features : {
   *        taskItems : {
   *            items : {
   *                // Will use "prio" as its field
   *                prio  : { type : 'textitem' },
   *                // Will use "status" as its field
   *                state : { type : 'textitem', field : 'status' }
   *            }
   *        }
   *    }
   * });
   * ```
   *
   * @config {String} field
   * @category Common
   */
  /**
   * Style definition in string or object form.
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *    features : {
   *        taskItems : {
   *            items : {
   *                prio  : { type : 'textitem', style : { color : 'red' } }
   *            }
   *        }
   *    }
   * });
   * ```
   *
   * @config {String|Object} style
   * @category Common
   */
  /**
   * Specify `true` to hide the task item.
   *
   * @config {Boolean} hidden
   * @category Common
   */
  /**
   * Flex order, can be used to re-order task items.
   *
   * @config {Number} order
   * @default 1
   * @category Common
   */
  /**
   * CSS class to add.
   *
   * @config {String} cls
   * @category Common
   */
  /**
   * Widget type or config to use as the editor for this item. Used in the inline task editor.
   * Set to `null` to not use an editor for this item.
   *
   * @config {String|Object} editor
   * @default text
   * @category Common
   */
});
__publicField(TaskItem, "defaultEditor", { type: "text" });
TaskItem._$name = "TaskItem";

// lib/TaskBoard/feature/SimpleTaskEdit.js
var actions = {
  editNext: 1,
  cancel: 1,
  editPrevious: 1,
  complete: 1
};
var SimpleTaskEdit = class extends TaskBoardFeature {
  //region Type assertions
  changeAddNewAtEnd(addNewAtEnd) {
    ObjectHelper.assertBoolean(addNewAtEnd, "features.simpleTaskEdit.addNewAtEnd");
    return addNewAtEnd;
  }
  //endregion
  /**
   * Starts inline editing of the supplied task, optionally for a specific item on its card.
   * @on-owner
   * @param {TaskBoard.model.TaskModel} taskRecord Task record to edit
   * @param {HTMLElement} [element] Card element or card item element to edit. Resolves element from the passed record
   * if left out.
   * @returns {Boolean} Returns `true` if editing started, `false` if it did not.
   */
  editTask(taskRecord, element) {
    const me = this, taskBoard = me.client;
    if (!element) {
      element = taskBoard.getTaskElement(taskRecord);
    }
    const taskItem = taskBoard.resolveTaskItem(element), itemElement = taskItem.element, itemEditorConfig = TaskItem.getEditorConfig(taskItem);
    if (!itemEditorConfig) {
      return false;
    }
    if (me.disabled || taskRecord.readOnly || taskBoard.trigger("beforeSimpleTaskEdit", { simpleTaskEdit: me, taskRecord, field: taskItem.config.field }) === false) {
      return true;
    }
    element.focus();
    const editor = me.editor = Editor.new({
      owner: taskBoard,
      appendTo: itemElement.parentNode,
      scrollAction: "realign",
      cls: "b-simple-task-editor",
      completeKey: null,
      cancelKey: null,
      inputField: {
        autoSelect: true,
        name: taskItem.config.field,
        ...itemEditorConfig
      },
      align: {
        align: "c-c",
        allowTargetOut: false
      },
      internalListeners: {
        complete: "onEditorComplete",
        cancel: "onEditorCancel",
        finishEdit: "onEditorFinishEdit",
        thisObj: me
      }
    }, me.editorConfig);
    me.currentElement = itemElement;
    itemElement.classList.add("b-editing");
    const color = DomHelper.getStyleValue(itemElement, "color");
    editor.element.style.color = color;
    editor.inputField.element.style.color = color;
    editor.element.retainElement = true;
    taskBoard.getTaskElement(taskRecord).scrollIntoView({
      block: "nearest"
    });
    itemElement.scrollIntoView({
      block: "nearest"
    });
    editor.startEdit({
      target: taskItem.element,
      record: taskRecord,
      field: taskItem.config.field
    });
    return true;
  }
  // Edit previous task item
  async editPrevious(event) {
    const me = this, { client, editor } = me, taskRecord = editor.record, cardElement = client.getTaskElement(taskRecord), itemElements = Array.from(cardElement.querySelectorAll(".b-taskboard-taskitem.b-editable")), index = itemElements.indexOf(me.currentElement) - 1;
    if (await me.complete(event)) {
      if (index >= 0) {
        me.editTask(taskRecord, itemElements[index]);
      } else {
        const prevTaskRecord = client.getPreviousTask(taskRecord, false);
        if (prevTaskRecord) {
          const prevCardElement = client.getTaskElement(prevTaskRecord), prevItemElements = Array.from(prevCardElement.querySelectorAll(".b-taskboard-taskitem.b-editable"));
          me.editTask(prevTaskRecord, prevItemElements[prevItemElements.length - 1]);
        }
      }
    }
  }
  // Edit next task item
  async editNext(event) {
    const me = this, { client, editor } = me, taskRecord = editor.record, cardElement = client.getTaskElement(taskRecord), itemElements = Array.from(cardElement.querySelectorAll(".b-taskboard-taskitem.b-editable")), index = itemElements.indexOf(me.currentElement) + 1;
    if (await me.complete(event)) {
      if (index < itemElements.length) {
        me.editTask(taskRecord, itemElements[index]);
      } else {
        const nextTaskRecord = client.getNextTask(taskRecord, false);
        if (nextTaskRecord) {
          me.editTask(nextTaskRecord);
        } else if (me.addNewAtEnd) {
          client.addTask(client.getColumn(taskRecord), client.getSwimlane(taskRecord));
        }
      }
    }
  }
  complete(event) {
    return this.editor.completeEdit(null, event);
  }
  cancel(event) {
    this.editor.cancelEdit(event);
  }
  // Start editing when activating task (enter/dblclick)
  onActivateTask({ taskRecord, event }) {
    if (this.editTask(taskRecord, event.target)) {
      event.preventDefault();
    }
  }
  onEditorComplete({ source }) {
    this.client.trigger("simpleTaskEditComplete", { simpleTaskEdit: this, taskRecord: source.record, field: source.dataField });
  }
  onEditorCancel({ source }) {
    this.client.trigger("simpleTaskEditCancel", { simpleTaskEdit: this, taskRecord: source.record, field: source.dataField });
  }
  onEditorFinishEdit() {
    const me = this, { editor } = me;
    editor == null ? void 0 : editor.setTimeout(() => {
      if (me.editor === editor) {
        me.currentElement = null;
        me.editor = null;
      }
      editor.destroy();
    }, 0);
  }
  // All keyMap actions require that we are editing
  isActionAvailable({ actionName }) {
    if (actions[actionName]) {
      return Boolean(this.editor);
    }
  }
};
__publicField(SimpleTaskEdit, "$name", "SimpleTaskEdit");
__publicField(SimpleTaskEdit, "type", "simpleTaskEdit");
__publicField(SimpleTaskEdit, "configurable", {
  /**
   * Pressing `Enter` in last item on last task in a column adds a new task.
   * @config {Boolean}
   * @default
   */
  addNewAtEnd: true,
  /**
   * A configuration object for the {@link Core.widget.Editor} used by this feature. Useful when you want to
   * validate the value being set by the end user (see {@link Core.widget.Editor#event-beforeComplete}).
   *
   * @config {EditorConfig}
   */
  editorConfig: {},
  /**
   * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
   * @config {Object<String,String>}
   */
  keyMap: {
    Enter: "editNext",
    Escape: "cancel",
    "Ctrl+Enter": "complete",
    "Shift+Enter": "editPrevious"
  }
});
__publicField(SimpleTaskEdit, "pluginConfig", {
  assign: ["editTask"],
  before: ["onActivateTask"]
});
SimpleTaskEdit.initClass();
SimpleTaskEdit._$name = "SimpleTaskEdit";

// lib/TaskBoard/feature/SwimlaneDrag.js
var SwimlaneDrag = class extends TaskBoardFeature {
  initialCompose() {
    const me = this;
    me.draggable = SwimlaneZone.new({
      dragRootElement: me.disabled ? null : me.client.bodyWrapElement,
      dropRootElement: me.client.bodyWrapElement,
      owner: me
    }, me.draggable);
  }
  doDisable(disable) {
    super.doDisable(disable);
    if (this.draggable) {
      this.draggable.dragRootElement = disable ? null : this.client.bodyWrapElement;
    }
  }
};
__publicField(SwimlaneDrag, "$name", "SwimlaneDrag");
__publicField(SwimlaneDrag, "type", "swimlaneDrag");
__publicField(SwimlaneDrag, "pluginConfig", {
  after: ["initialCompose"]
});
SwimlaneDrag.initClass();
var SwimlaneZone = class extends Base.mixin(Draggable_default, Droppable_default) {
  static get configurable() {
    return {
      dragSelector: ".b-taskboard-swimlane-header, .b-taskboard-swimlane-header *",
      dragItemSelector: ".b-taskboard-swimlane-header",
      draggingItemCls: null,
      dragProxy: {
        type: "default",
        async open(drag) {
          const { owner } = this, {
            itemElement,
            startEvent
          } = drag, taskBoard = owner.owner.client, swimlaneRecord = taskBoard.resolveSwimlaneRecord(itemElement), swimlaneElement = taskBoard.getSwimlaneElement(swimlaneRecord), padding = DomHelper.getStyleValue(
            swimlaneElement.syncIdMap.body,
            ["padding-left", "padding-right"]
          ), bounds = Rectangle.from(swimlaneElement, owner.dragRootElement).deflate(
            0,
            parseFloat(padding["padding-right"]),
            0,
            parseFloat(padding["padding-left"])
          ), proxyOffset = EventHelper.getClientPoint(startEvent).getDelta(bounds), proxy = DomHelper.createElement({
            className: "b-taskboard-swimlane-drag-proxy",
            parent: owner.dragRootElement,
            style: {
              // Using fixed top, only draggable horizontally
              top: EventHelper.getClientPoint(startEvent).translate(0, proxyOffset[1]).y,
              // Offset from cursor to be positioned over original column
              left: bounds.x,
              // Need a fixed height on the proxy, since columns width might be flexed etc
              width: bounds.width
            },
            // Don't want it being removed while dragging
            retainElement: true
          });
          Object.assign(drag, {
            proxy,
            swimlaneRecord,
            swimlaneElement,
            proxyOffset,
            // Used to size dropIndicator
            bounds
          });
          const swimlaneClone = swimlaneElement.cloneNode(true);
          proxy.appendChild(swimlaneClone);
        },
        dragMove({ proxy, event, proxyOffset }) {
          const position = EventHelper.getClientPoint(event).translate(0, proxyOffset[1]);
          proxy.style.top = `${position.y}px`;
        }
      }
    };
  }
  setupDragContext(event) {
    const result = super.setupDragContext(event), { client } = this.owner;
    result.scrollManager = client.scrollManager;
    result.monitoringConfig = {
      scrollables: [{
        element: client.bodyElement,
        direction: "vertical"
      }]
    };
    return result;
  }
  dragStart(drag) {
  }
  dragEnter(drag) {
    if (!drag.itemElement.matches(this.dragItemSelector)) {
      return false;
    }
    if (!drag.dropIndicator) {
      const { bounds } = drag;
      drag.dropIndicator = DomHelper.createElement({
        className: "b-taskboard-swimlane-drop-indicator",
        elementData: {
          dropIndicator: true
        },
        // Use same size as dragged column had originally
        style: {
          width: bounds.width,
          height: bounds.height
        }
      });
      this.insertDropIndicator(drag.dropIndicator, drag.swimlaneRecord);
      drag.swimlaneElement.classList.add("b-drag-original");
    }
  }
  insertDropIndicator(dropIndicator, beforeSwimlaneRecord) {
    const { client } = this.owner;
    client.bodyElement.insertBefore(
      dropIndicator,
      beforeSwimlaneRecord && client.getSwimlaneElement(beforeSwimlaneRecord)
    );
  }
  async dragMove(drag) {
    var _a2;
    const { client } = this.owner, { documentRoot } = client, taskBoardBounds = Rectangle.from(client.element, void 0, true), proxyBounds = Rectangle.from(drag.proxy, void 0, true), overElement = proxyBounds.center.y > taskBoardBounds.bottom ? documentRoot.elementFromPoint(proxyBounds.x, proxyBounds.y) : documentRoot.elementFromPoint(proxyBounds.x, proxyBounds.center.y), swimlaneElement = overElement == null ? void 0 : overElement.closest(".b-taskboard-swimlane");
    if (!((_a2 = overElement == null ? void 0 : overElement.elementData) == null ? void 0 : _a2.dropIndicator) && swimlaneElement) {
      const targetBounds = Rectangle.from(swimlaneElement, void 0, true);
      let beforeSwimlane = client.resolveSwimlaneRecord(swimlaneElement);
      if (proxyBounds.center.y > targetBounds.center.y) {
        beforeSwimlane = client.swimlanes.getNext(beforeSwimlane);
      }
      this.insertDropIndicator(drag.dropIndicator, beforeSwimlane);
      drag.beforeSwimlane = beforeSwimlane;
    }
  }
  async dragDrop(drag) {
    const { client } = this.owner, { swimlanes } = client, {
      swimlaneRecord,
      beforeSwimlane,
      swimlaneElement,
      dropIndicator,
      proxy
    } = drag;
    function commit() {
      proxy.remove();
      dropIndicator.remove();
      swimlaneElement.classList.remove("b-drag-original");
      beforeSwimlane !== void 0 && swimlanes.move(swimlaneRecord, beforeSwimlane);
      client.trigger("dropSwimlane", { beforeSwimlane, drag });
    }
    proxy.classList.add("b-dropping");
    DomHelper.alignTo(
      proxy,
      Rectangle.from(dropIndicator, void 0, true)
    );
    if (DomHelper.getPropertyTransitionDuration(proxy, "transform")) {
      EventHelper.onTransitionEnd({
        element: proxy,
        property: "transform",
        handler: commit,
        thisObj: client
      });
    } else {
      commit();
    }
  }
  dragLeave(drag) {
  }
};
SwimlaneDrag._$name = "SwimlaneDrag";

// lib/TaskBoard/feature/TaskDrag.js
var cardSelector = ".b-taskboard-card, .b-taskboard-card-drop-indicator";
var indexOf = (element, ignoreOriginal = false) => DomHelper.children(element.parentElement, `.b-taskboard-card${ignoreOriginal ? ":not(.b-drag-original)" : ""}, .b-first-drop-indicator`).indexOf(element);
var hasChanged = (dropIndicators) => dropIndicators.some((dropIndicator, i) => {
  return (
    // Moved to another parent is a change (another column or another swimlane)
    dropIndicator.parentElement !== dropIndicator.elementData.initialParent || // Or if first drop indicator has changed index (the others follow it, no need to check)
    i === 0 && indexOf(dropIndicator, true) !== dropIndicator.elementData.initialIndex
  );
});
var TaskDrag = class extends TaskBoardFeature {
  initialCompose() {
    const me = this;
    me.draggable = TaskZone.new({
      dragRootElement: me.disabled ? null : me.client.bodyWrapElement,
      dropRootElement: me.client.bodyWrapElement,
      owner: me,
      [me.dragTouchStartDelay != null ? "dragTouchStartDelay" : void 0]: me.dragTouchStartDelay,
      internalListeners: {
        beforeDragStart: "onBeforeDragStart",
        dragStart: "onDragStart",
        thisObj: me
      }
    }, me.draggable);
  }
  doDestroy() {
    var _a2;
    super.doDestroy();
    (_a2 = this.draggable) == null ? void 0 : _a2.destroy();
  }
  doDisable(disable) {
    super.doDisable(disable);
    if (this.draggable) {
      this.draggable.dragRootElement = disable ? null : this.client.bodyWrapElement;
    }
  }
  onBeforeDragStart({ drag, event }) {
    return this.client.trigger("beforeTaskDrag", { drag, event, domEvent: event, taskRecords: drag.taskRecords });
  }
  onDragStart({ drag, event }) {
    return this.client.trigger("taskDragStart", { drag, event, domEvent: event, taskRecords: drag.taskRecords });
  }
};
__publicField(TaskDrag, "$name", "TaskDrag");
__publicField(TaskDrag, "type", "taskDrag");
__publicField(TaskDrag, "pluginConfig", {
  after: ["initialCompose"]
});
__publicField(TaskDrag, "configurable", {
  /**
   * Specify `true` to enable the old behavior of moving tasks in the store on drop.
   *
   * This behaviour was made opt in since it does not play well when sharing data with other components.
   *
   * <div class="note">
   * If you are sorting tasks by a field other than `weight` and want predictable results on drop, you should
   * enable this config.
   * </div>
   *
   * @config {Boolean}
   * @default
   */
  reorderTaskRecords: false,
  /**
   * The number of milliseconds that must elapse after a `touchstart` event before it is considered a drag. If
   * movement occurs before this time, the drag is aborted. This is to allow touch swipes and scroll gestures.
   * @config {Number}
   * @default 300
   */
  dragTouchStartDelay: null
});
TaskDrag.initClass();
var TaskZone = class extends Base.mixin(Draggable_default, Droppable_default, Events_default) {
  static get configurable() {
    return {
      dragSelector: ".b-taskboard-card:not(.b-readonly)",
      dragItemSelector: ".b-taskboard-card:not(.b-readonly)",
      // Accept drops on anything within the TaskBoard
      dropTargetSelector: ".b-taskboardbase",
      // We are going to allow dragging multiple cards, will need to add cls manually to all of them
      draggingItemCls: null,
      dragProxy: {
        type: "default",
        async open(drag) {
          const {
            itemElement,
            startEvent
          } = drag, taskBoard = this.owner.owner.client, columnEl = itemElement.closest(".b-taskboard-column"), taskRecord = taskBoard.resolveTaskRecord(itemElement), proxy = drag.proxy = DomHelper.createElement({
            // Add column classes too to get exact same styles applied
            className: "b-taskboard-drag-proxy " + columnEl.className,
            role: "presentation",
            // Don't want it being removed while dragging
            retainElement: true
          }), cardClones = [];
          let taskRecords;
          if (taskBoard.selectedTasks.includes(taskRecord)) {
            taskRecords = taskBoard.selectedTasks.filter((t) => !t.readOnly).sort((a, b) => a.parentIndex - b.parentIndex);
          } else {
            taskRecords = [taskRecord];
          }
          const taskElements = taskRecords.map((r) => taskBoard.getTaskElement(r));
          Object.assign(drag, {
            taskElements,
            // Store heights, cannot measure later when original tasks are hidden
            taskHeights: /* @__PURE__ */ new Map(),
            // Offset from cursor, ignoring page scroll = client coords
            proxyOffset: EventHelper.getClientPoint(startEvent).getDelta(Rectangle.from(itemElement, null, true))
          });
          taskElements.forEach((taskElement) => {
            var _a2;
            const { elementData } = taskElement, cardClone = taskElement.cloneNode(true), bounds = Rectangle.from(taskElement, itemElement);
            cardClone.style.width = bounds.width + "px";
            cardClone.style.height = bounds.height + "px";
            drag.taskHeights.set(taskElement, bounds.height);
            cardClone.style.left = bounds.x + "px";
            cardClone.style.top = bounds.y + "px";
            cardClone.taskElement = taskElement;
            cardClone.taskRecord = elementData.taskRecord;
            cardClone.originalColor = ((_a2 = elementData.swimlaneRecord) == null ? void 0 : _a2.color) || elementData.columnRecord.color;
            proxy.appendChild(cardClone);
            cardClones.push(cardClone);
          });
          taskElements.forEach((taskElement) => taskElement.classList.add("b-drag-original"));
          await AsyncHelper.animationFrame();
          cardClones.forEach((cardClone, i) => {
            if (i > 0) {
              cardClone.style.top = 30 + i * 20 + "px";
              cardClone.style.left = 40 + i * 5 + "px";
            } else {
              cardClone.style.top = 0;
              cardClone.style.left = 0;
            }
          });
        },
        dragMove({ proxy, event, proxyOffset }) {
          const { dragRootElement } = this.owner, parentBounds = dragRootElement.getBoundingClientRect(), position = EventHelper.getClientPoint(event).translate(
            proxyOffset[0] - parentBounds.left + dragRootElement.scrollLeft,
            proxyOffset[1] - parentBounds.top + dragRootElement.scrollTop
          );
          proxy.style.top = position.y + "px";
          proxy.style.left = position.x + "px";
        }
      }
    };
  }
  configureListeners(drag) {
    const listeners = super.configureListeners(drag);
    listeners.element = this.owner.client.rootElement;
    return listeners;
  }
  setupDragContext(event) {
    const result = super.setupDragContext(event), { client } = this.owner;
    result.scrollManager = client.scrollManager;
    result.monitoringConfig = {
      scrollables: [
        {
          element: ".b-taskboard-column-body",
          direction: "vertical"
        },
        {
          element: client.bodyElement,
          direction: "both"
        }
      ]
    };
    return result;
  }
  // Populate the drag context early, to have something to take decisions on in beforeDragStart listeners
  startDrag(drag) {
    const { itemElement } = drag, taskBoard = this.owner.client, taskRecord = taskBoard.resolveTaskRecord(itemElement);
    if (taskBoard.isSelected(taskRecord)) {
      drag.taskRecords = taskBoard.selectedTasks.slice().sort((a, b) => a.parentIndex - b.parentIndex);
    } else {
      drag.taskRecords = [taskRecord];
    }
    drag.initiatedFrom = taskRecord;
    return super.startDrag(drag);
  }
  dragStart(drag) {
    const { client } = this.owner, nextSibling = drag.itemElement;
    drag.wasStarted = true;
    drag.position = "after";
    drag.targetTaskRecord = drag.initiatedFrom;
    for (const taskRecord of drag.taskRecords) {
      taskRecord.instanceMeta(client).dragging = true;
    }
    client.bodyWrapElement.appendChild(drag.proxy);
    drag.dropIndicators = drag.taskElements.map((taskElement, i) => {
      return DomHelper.createElement({
        className: {
          "b-taskboard-card-drop-indicator": 1,
          "b-first-drop-indicator": i === 0
        },
        style: {
          height: drag.taskHeights.get(taskElement)
        },
        elementData: {
          dropIndicator: true,
          // To be able to detect if it has actually moved on drop
          initialParent: taskElement.parentElement,
          initialIndex: indexOf(taskElement),
          // Tag along the taskElement, to be able to return the drop indicator to its position for
          // invalid drop targets
          taskElement
        },
        retainElement: true,
        nextSibling
      });
    });
    client.element.classList.add("b-dragging-task");
  }
  dragEnter(drag) {
    if (!drag.itemElement.matches(this.dragItemSelector)) {
      return false;
    }
  }
  // Finds the first visible direct child in a parent element
  getFirstVisibleChild(parentElement) {
    for (const element of parentElement.children) {
      if (element.offsetParent) {
        return element;
      }
    }
  }
  // Convenience shortcut to not have to pass custom card selector on each call
  getCardAt(x, y) {
    return this.owner.client.getCardAt(x, y, cardSelector);
  }
  updateValidity(drag, valid) {
    drag.proxy.classList.toggle("b-invalid", !valid);
    drag.dropIndicators.forEach((dropIndicator) => dropIndicator.classList.toggle("b-invalid", !valid));
    drag.invalid = !valid;
  }
  dragMove(drag) {
    var _a2, _b, _c;
    const me = this, { client } = me.owner, { event: domEvent, dropIndicators } = drag, { clientX, clientY } = domEvent, overElement = client.documentRoot.elementFromPoint(clientX, clientY), columnElement = DomSync.getChild(overElement == null ? void 0 : overElement.closest(".b-taskboard-column"), "body.inner");
    if (drag.invalid) {
      drag.valid = false;
    }
    if (!overElement) {
      return;
    }
    if (columnElement) {
      const targetSwimlane = client.resolveSwimlaneRecord(overElement), targetColumn = client.resolveColumnRecord(overElement), tasksPerRow = targetColumn.tasksPerRow || (targetSwimlane == null ? void 0 : targetSwimlane.tasksPerRow) || client.tasksPerRow;
      let cardElement = overElement.closest(cardSelector), shouldTrigger = targetSwimlane !== drag.targetSwimlane || targetColumn !== drag.targetColumn;
      drag.targetSwimlane = targetSwimlane;
      drag.targetColumn = targetColumn;
      if (!cardElement) {
        const { cardGap } = client, columnRect = Rectangle.from(columnElement), topCard = me.getFirstVisibleChild(columnElement), top = (_a2 = topCard == null ? void 0 : topCard.getBoundingClientRect().top) != null ? _a2 : null;
        if (tasksPerRow === 1) {
          if (top !== null && clientY < top) {
            cardElement = topCard;
          } else {
            const centerX = columnRect.center.x, cardAbove = me.getCardAt(centerX, clientY - cardGap), cardBelow = me.getCardAt(centerX, clientY + cardGap);
            cardElement = cardAbove || cardBelow;
          }
        } else {
          const columnContentWidth = client.getColumnWidth(drag.targetColumn), columnPadding = (columnRect.width - columnContentWidth) / 2, innerColumnWidth = columnContentWidth / tasksPerRow, index = Math.floor((clientX - columnRect.left) / innerColumnWidth), centerX = columnRect.left + columnPadding + innerColumnWidth * (index + 0.5);
          if (top !== null && clientY < top) {
            cardElement = me.getCardAt(centerX, top);
          } else {
            const centerX2 = columnRect.center.x, cardBefore = me.getCardAt(centerX2 - cardGap, clientY), cardAfter = me.getCardAt(centerX2 + cardGap, clientY);
            cardElement = cardBefore || cardAfter;
          }
        }
      }
      if (!(cardElement == null ? void 0 : cardElement.elementData.dropIndicator)) {
        let insertBefore = false;
        if (cardElement) {
          const cardRect = Rectangle.from(cardElement), targetTaskRecord = client.resolveTaskRecord(cardElement);
          if (
            // If above center with single task per row
            tasksPerRow === 1 && clientY < cardRect.center.y || // Or left of center in multiple tasks per row
            tasksPerRow > 1 && clientX < cardRect.center.x
          ) {
            if (drag.position !== "before") {
              shouldTrigger = true;
            }
            insertBefore = cardElement;
            drag.position = "before";
          } else {
            if (drag.position !== "after") {
              shouldTrigger = true;
            }
            insertBefore = cardElement.nextElementSibling;
            drag.position = "after";
          }
          if (targetTaskRecord !== drag.targetTaskRecord) {
            shouldTrigger = true;
          }
          drag.targetTaskRecord = targetTaskRecord;
        } else {
          if (drag.position !== "last") {
            shouldTrigger = true;
          }
          drag.position = "last";
          drag.targetTaskRecord = null;
        }
        if (!((_b = insertBefore == null ? void 0 : insertBefore.elementData) == null ? void 0 : _b.dropIndicator)) {
          if (insertBefore === false) {
            dropIndicators.forEach((dropIndicator) => {
              columnElement == null ? void 0 : columnElement.appendChild(dropIndicator);
            });
          } else {
            dropIndicators.forEach((dropIndicator) => {
              ((insertBefore == null ? void 0 : insertBefore.parentElement) || columnElement).insertBefore(dropIndicator, insertBefore);
            });
          }
          drag.lastCardElement = cardElement;
        }
      }
      for (const card of drag.proxy.children) {
        if (!card.taskRecord.eventColor) {
          const color = ((_c = drag.targetSwimlane) == null ? void 0 : _c.color) || drag.targetColumn.color;
          if (card.originalColor) {
            card.classList.remove(`b-taskboard-color-${card.originalColor}`);
          }
          if (color) {
            card.originalColor = color;
            if (DomHelper.isNamedColor(color)) {
              card.classList.add(`b-taskboard-color-${color}`);
            } else {
              card.style.color = color;
            }
          }
        }
        if (drag.targetSwimlane) {
          card.dataset.lane = drag.targetSwimlane.id;
        }
        card.dataset.column = drag.targetColumn.id;
      }
      if (shouldTrigger) {
        const { taskRecords, targetTaskRecord, position } = drag, result = client.trigger(
          "taskDrag",
          { drag, taskRecords, targetSwimlane, targetColumn, targetTaskRecord, position, event: domEvent, domEvent }
        );
        me.updateValidity(drag, result !== false);
      }
    }
  }
  async dragDrop(drag) {
    const me = this, { client } = me.owner, {
      dropIndicators,
      taskRecords,
      targetSwimlane,
      targetColumn,
      targetTaskRecord,
      event: domEvent
    } = drag, event = { drag, domEvent, event: domEvent, taskRecords, targetSwimlane, targetColumn, targetTaskRecord }, changed = hasChanged(dropIndicators);
    if (!changed || !targetColumn || drag.invalid || await client.trigger("beforeTaskDrop", event) === false) {
      drag.valid = false;
    } else {
      drag.finalizer = new Promise((resolve) => {
        var _a2;
        const {
          columnField,
          swimlaneField
        } = client, { taskStore } = client.project, {
          proxy
        } = drag, columnRecords = targetColumn.tasks, swimlaneRecords = targetSwimlane ? columnRecords == null ? void 0 : columnRecords.filter((task) => task[swimlaneField] === targetSwimlane.id) : columnRecords, invalid = !columnRecords;
        let moveBefore;
        if (!invalid) {
          if (drag.targetTaskRecord) {
            if (drag.position === "before") {
              moveBefore = targetTaskRecord;
            } else if (drag.position === "after") {
              const index = swimlaneRecords.indexOf(targetTaskRecord);
              moveBefore = (_a2 = swimlaneRecords[index + 1]) != null ? _a2 : null;
            }
          } else if (swimlaneRecords.length) {
            moveBefore = null;
          }
        }
        function commit() {
          var _a3;
          proxy.remove();
          dropIndicators.forEach((dropIndicator) => {
            const { taskElement } = dropIndicator.elementData;
            dropIndicator.parentElement.insertBefore(taskElement, dropIndicator);
            dropIndicator.parentElement.syncIdMap[taskElement.elementData.taskId] = taskElement;
            taskElement.classList.remove("b-drag-original");
            dropIndicator.remove();
          });
          client.suspendDomTransition();
          if (!invalid) {
            let newWeight;
            if (moveBefore) {
              const tasksBelow = swimlaneRecords.slice(swimlaneRecords.indexOf(moveBefore)), taskAbove = swimlaneRecords[swimlaneRecords.indexOf(moveBefore) - 1];
              let weightDiff;
              if (taskAbove) {
                weightDiff = Math.max(1, Math.round((moveBefore.weight - taskAbove.weight) / 2));
                newWeight = taskAbove.weight + weightDiff;
              } else {
                newWeight = Math.max(1, Math.round(moveBefore.weight / 2));
              }
              while (((_a3 = tasksBelow[0]) == null ? void 0 : _a3.weight) === newWeight) {
                weightDiff = tasksBelow[1] ? Math.max(1, Math.round((tasksBelow[1].weight - newWeight) / 2)) : 50;
                newWeight = tasksBelow[0].weight = newWeight + weightDiff;
                tasksBelow.shift();
              }
            } else {
              newWeight = swimlaneRecords.length ? swimlaneRecords[swimlaneRecords.length - 1].weight + 100 : 100;
            }
            taskRecords.forEach((taskRecord) => {
              const toSet = {
                [columnField]: targetColumn.id,
                weight: newWeight
              };
              if (targetSwimlane) {
                toSet[swimlaneField] = targetSwimlane.id;
              }
              if (client.features.taskDrag.reorderTaskRecords && moveBefore !== void 0) {
                taskStore.move(taskRecord, moveBefore);
              }
              taskRecord.set(toSet);
            });
            if (!client.features.taskDrag.reorderTaskRecords && !client.taskSorterFn) {
              client.project.taskStore.sort();
            }
          }
          client.resumeDomTransition();
          client.trigger("taskDrop", { drag, event: domEvent, taskRecords, targetSwimlane, targetColumn, moveBefore, domEvent });
          client.trigger("taskDragEnd", { drag, taskRecords, domEvent });
          client.element.classList.remove("b-dragging-task");
          for (const taskRecord of taskRecords) {
            taskRecord.instanceMeta(client).dragging = false;
          }
          resolve();
        }
        const cardClones = Array.from(proxy.children);
        proxy.classList.add("b-pre-dropping");
        cardClones[0].offsetWidth;
        proxy.classList.add("b-dropping");
        cardClones.forEach((cardClone, i) => {
          const dropClone = dropIndicators[i];
          DomHelper.alignTo(
            cardClone,
            // Ignore page scroll when trying to align element in float root to element in taskboard
            Rectangle.from(dropClone, void 0, true)
          );
        });
        if (DomHelper.getPropertyTransitionDuration(cardClones[0], "transform")) {
          EventHelper.onTransitionEnd({
            element: cardClones[0],
            property: "transform",
            handler: commit,
            thisObj: client
            // For timer cleanup
          });
        } else {
          commit();
        }
      });
    }
  }
  dragLeave(drag) {
    drag.dropIndicators.forEach((dropIndicator) => {
      const { taskElement } = dropIndicator.elementData;
      taskElement.parentElement.insertBefore(dropIndicator, taskElement);
    });
  }
  doAbort(drag) {
    const { client } = this.owner, { dropIndicators, proxy, taskRecords } = drag;
    if (proxy) {
      let finalizeAbort = function() {
        proxy.remove();
        dropIndicators.forEach((dropIndicator) => {
          dropIndicator.elementData.taskElement.classList.remove("b-drag-original");
          dropIndicator.remove();
        });
        client.element.classList.remove("b-dragging-task");
        for (const taskRecord of taskRecords) {
          taskRecord.instanceMeta(client).dragging = false;
        }
        client.trigger("taskDragAbortFinalized");
      };
      const cardClones = Array.from(proxy.children);
      proxy.classList.add("b-dropping");
      dropIndicators.forEach((dropIndicator) => {
        const { taskElement } = dropIndicator.elementData;
        dropIndicator.classList.remove("b-invalid");
        taskElement.parentElement.insertBefore(dropIndicator, taskElement);
      });
      cardClones.forEach((cardClone, i) => {
        DomHelper.alignTo(
          cardClone,
          // Ignore page scroll when trying to align element in float root to element in taskboard
          Rectangle.from(dropIndicators[i], void 0, true)
        );
      });
      if (DomHelper.getPropertyTransitionDuration(cardClones[0], "transform")) {
        EventHelper.onTransitionEnd({
          element: cardClones[0],
          property: "transform",
          handler: finalizeAbort,
          thisObj: client
          // For timer cleanup
        });
      } else {
        finalizeAbort();
      }
    }
    client.trigger("taskDragAbort", { drag, taskRecords });
    if (drag.wasStarted) {
      client.trigger("taskDragEnd", { drag, taskRecords });
    }
  }
  dragEnd(drag) {
    if ((drag.started || drag.wasStarted) && (!drag.valid || drag.aborted)) {
      this.doAbort(drag);
    }
  }
};
TaskDrag._$name = "TaskDrag";

// lib/TaskBoard/feature/TaskDragSelect.js
var TaskDragSelect = class extends TaskBoardFeature {
  constructor() {
    super(...arguments);
    __publicField(this, "state", "idle");
  }
  //region Type assertions
  changeDragThreshold(threshold) {
    ObjectHelper.assertNumber(threshold, "features.taskDragSelect.dragThreshold");
    return threshold;
  }
  //endregion
  initializeDragSelect(event) {
    const me = this, { client } = me;
    me.bounds = Rectangle.from(
      client.bodyElement,
      /* ignorePageScroll = */
      true
    );
    me.element = DomHelper.createElement({
      tag: "div",
      className: "b-dragselect-rect"
    }, { returnAll: true })[0];
    client.floatRoot.appendChild(me.element);
    client.element.classList.add("b-dragselecting");
    const cardElements = Array.from(client.element.querySelectorAll(".b-taskboard-card:not(.b-dragging-item)"));
    me.cardRectangles = cardElements.flatMap((el) => {
      const record = client.resolveTaskRecord(el);
      return record ? {
        rectangle: Rectangle.from(
          el,
          /* ignorePageScroll = */
          true
        ),
        record
      } : [];
    });
    if (!event.ctrlKey) {
      client.deselectAll();
    }
    client.navigateable = false;
    me.state = "selecting";
  }
  // Select cards intersected by the selection marquee
  updateSelection() {
    const { cardRectangles, rectangle, client } = this;
    for (let i = 0, len = cardRectangles.length; i < len; i++) {
      const cardData = cardRectangles[i], shouldSelect = rectangle.intersect(cardData.rectangle, true);
      if (shouldSelect && !cardData.selected) {
        cardData.selected = true;
        client.selectTask(cardData.record, true);
      } else if (!shouldSelect && cardData.selected) {
        cardData.selected = false;
        client.deselectTask(cardData.record);
      }
    }
  }
  //region Listeners
  onColumnMouseDown({ event }) {
    const me = this;
    if (!me.disabled && event.button === 0) {
      me.state = "considering";
      me.startX = event.clientX;
      me.startY = event.clientY;
      me.mouseUpDetacher = EventHelper.on({
        element: document,
        mouseup: "onMouseUp",
        thisObj: me
      });
    }
  }
  onMouseMove({ event }) {
    const me = this, { startX, startY } = me, { clientX, clientY } = event;
    if (me.state === "considering") {
      const deltaX = Math.abs(clientX - startX), deltaY = Math.abs(clientY - startY);
      if (deltaX > me.dragThreshold || deltaY > me.dragThreshold) {
        me.initializeDragSelect(event);
      }
    }
    if (me.state === "selecting") {
      const { element, bounds } = me, x = Math.max(clientX, bounds.left), y = Math.max(clientY, bounds.top), left = Math.min(startX, x), top = Math.min(startY, y), width = Math.abs(startX - x), height = Math.abs(startY - y), rect = new Rectangle(left, top, width, height).constrainTo(bounds);
      DomHelper.setTranslateXY(element, rect.left, rect.top);
      element.style.width = rect.width + "px";
      element.style.height = rect.height + "px";
      me.rectangle = rect;
      me.updateSelection();
    }
  }
  onMouseUp() {
    var _a2, _b;
    const me = this, { client, state } = me;
    if (state === "selecting") {
      (_a2 = me.element) == null ? void 0 : _a2.remove();
      client.element.classList.remove("b-dragselecting");
      client.setTimeout(() => client.navigateable = true, 100);
    }
    if (state === "selecting" || state === "considering") {
      me.state = "idle";
      me.startX = me.startY = me.rectangle = me.bounds = null;
    }
    (_b = me.mouseUpDetacher) == null ? void 0 : _b.call(me);
  }
  //endregion
};
__publicField(TaskDragSelect, "$name", "TaskDragSelect");
__publicField(TaskDragSelect, "type", "taskDragSelect");
__publicField(TaskDragSelect, "configurable", {
  /**
   * The amount of pixels to move pointer/mouse before it counts as a drag select operation.
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *    features : {
   *        taskDragSelect : {
   *            dragThreshold : 10
   *        }
   *    }
   * });
   * ```
   *
   * @config {Number}
   * @default
   */
  dragThreshold: 5
});
__publicField(TaskDragSelect, "pluginConfig", {
  chain: ["onColumnMouseDown", "onMouseMove"]
});
TaskDragSelect.initClass();
TaskDragSelect._$name = "TaskDragSelect";

// lib/TaskBoard/widget/mixin/TaskBoardLinked.js
var TaskBoardLinked_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get taskBoard() {
      return this._taskBoard || this.up((widget) => widget.isTaskBoardBase) || Widget.query((widget) => widget.isTaskBoardBase);
    }
    changeTaskBoard(taskBoard) {
      if (taskBoard && !taskBoard.isTaskBoard) {
        throw new Error(`The taskBoard config only accepts an instance of TaskBoard or a subclass thereof`);
      }
      return taskBoard;
    }
  }, __publicField(_a2, "$name", "TaskBoardLinked"), __publicField(_a2, "configurable", {
    /**
     * Auto detected when used within a TaskBoard. If you add the widget elsewhere, it will try to find an instance
     * of TaskBoard on page. If that fails you have to supply this config to connect it to a TaskBoard manually.
     *
     * ```javascript
     * const taskBoard = new TaskBoard({});
     *
     * const picker = new ColumnPickerButton({
     *    taskBoard // Link it to the taskBoard instance created above
     * });
     * ```
     *
     * @config {TaskBoard.view.TaskBoard}
     * @category Common
     */
    taskBoard: null
  }), _a2;
};

// lib/TaskBoard/widget/base/ColorBoxCombo.js
var ColorBoxCombo = class extends Combo.mixin(TaskBoardLinked_default) {
  afterConstruct() {
    if (!this.showBoxForNoColor && !this.value) {
      this.element.classList.add("b-colorless");
    }
  }
  syncInputFieldValue(...args) {
    const me = this, { color } = me.record || {};
    let className = "b-colorbox";
    if (color) {
      if (DomHelper.isNamedColor(color)) {
        className += ` b-taskboard-color-${color}`;
      } else {
        me.colorBox.style.color = color;
      }
    }
    me.colorBox.className = className;
    if (!me.showBoxForNoColor) {
      me.element.classList.toggle("b-colorless", !color);
    }
    super.syncInputFieldValue(...args);
  }
  get innerElements() {
    return [
      {
        reference: "colorBox",
        className: "b-colorbox"
      },
      ...super.innerElements
    ];
  }
};
__publicField(ColorBoxCombo, "$name", "ColorBoxCombo");
__publicField(ColorBoxCombo, "type", "colorboxcombo");
__publicField(ColorBoxCombo, "configurable", {
  displayField: "text",
  valueField: "id",
  editable: false,
  showBoxForNoColor: false,
  listItemTpl({ text, color }) {
    let html = StringHelper.encodeHtml(text);
    if (color) {
      if (DomHelper.isNamedColor(color)) {
        html = `<div class="b-colorbox b-taskboard-color-${color}"></div>` + html;
      } else {
        html = `<div class="b-colorbox" style="color : ${color}"></div>` + html;
      }
    }
    return html;
  },
  picker: {
    cls: "b-colorbox-picker"
  }
});
ColorBoxCombo._$name = "ColorBoxCombo";

// lib/TaskBoard/widget/ColumnCombo.js
var ColumnCombo = class extends ColorBoxCombo {
  changeStore() {
    return this.taskBoard.columns.chain();
  }
};
__publicField(ColumnCombo, "$name", "ColumnCombo");
__publicField(ColumnCombo, "type", "columncombo");
ColumnCombo.initClass();
ColumnCombo._$name = "ColumnCombo";

// lib/TaskBoard/widget/ResourcesCombo.js
var ResourcesCombo = class extends Combo.mixin(TaskBoardLinked_default) {
  get innerElements() {
    if (this.peekConfig("multiSelect") || this._multiSelect) {
      return super.innerElements;
    }
    return [
      { reference: "avatarContainer" },
      this.inputElement
    ];
  }
  syncInputFieldValue(...args) {
    const me = this;
    if (!me.multiSelect) {
      const resourceRecord = me.record;
      if (resourceRecord) {
        DomSync.sync({
          targetElement: me.avatarContainer,
          domConfig: {
            className: "b-resourcescombo-avatar-container",
            children: [
              me.avatarRendering.getResourceAvatar({
                resourceRecord,
                initials: resourceRecord.initials,
                color: resourceRecord.color,
                iconCls: resourceRecord.iconCls,
                imageUrl: resourceRecord.image === false ? null : resourceRecord.imageUrl || (me.taskBoard.resourceImagePath || "") + (resourceRecord.image || ""),
                dataset: {
                  btip: StringHelper.encodeHtml(resourceRecord.name)
                }
              })
            ]
          }
        });
      }
    }
    super.syncInputFieldValue(...args);
  }
  changeStore() {
    return this.taskBoard.project.resourceStore.chain();
  }
  changeAvatarRendering(value, old) {
    old == null ? void 0 : old.destroy();
    if (value) {
      return new AvatarRendering({
        element: this.element
      });
    }
  }
};
__publicField(ResourcesCombo, "$name", "ResourcesCombo");
__publicField(ResourcesCombo, "type", "resourcescombo");
__publicField(ResourcesCombo, "configurable", {
  displayField: "name",
  valueField: "id",
  multiSelect: true,
  editable: false,
  listItemTpl(resourceRecord) {
    const { avatarRendering, taskBoard } = this.owner;
    return DomHelper.createElement(avatarRendering.getResourceAvatar({
      resourceRecord,
      initials: resourceRecord.initials,
      color: resourceRecord.color,
      iconCls: resourceRecord.iconCls,
      imageUrl: resourceRecord.image === false ? null : resourceRecord.imageUrl || (taskBoard.resourceImagePath || "") + (resourceRecord.image || "")
    })).outerHTML + StringHelper.encodeHtml(resourceRecord.name);
  },
  picker: {
    cls: "b-resources-picker"
  },
  chipView: {
    scrollable: null,
    itemTpl(resourceRecord) {
      const { avatarRendering, taskBoard } = this.owner;
      return DomHelper.createElement(avatarRendering.getResourceAvatar({
        resourceRecord,
        initials: resourceRecord.initials,
        color: resourceRecord.color,
        iconCls: resourceRecord.iconCls,
        imageUrl: resourceRecord.image === false ? null : resourceRecord.imageUrl || (taskBoard.resourceImagePath || "") + (resourceRecord.image || ""),
        dataset: {
          btip: StringHelper.encodeHtml(resourceRecord.name)
        }
      })).outerHTML;
    }
  },
  avatarRendering: {
    value: true,
    $config: "nullify"
  }
});
ResourcesCombo.initClass();
ResourcesCombo._$name = "ResourcesCombo";

// lib/TaskBoard/widget/SwimlaneCombo.js
var SwimlaneCombo = class extends ColorBoxCombo {
  changeStore() {
    return this.taskBoard.swimlanes.chain();
  }
};
__publicField(SwimlaneCombo, "$name", "SwimlaneCombo");
__publicField(SwimlaneCombo, "type", "swimlanecombo");
SwimlaneCombo.initClass();
SwimlaneCombo._$name = "SwimlaneCombo";

// lib/TaskBoard/widget/TaskColorPicker.js
var TaskColorPicker = class extends ColorPicker {
};
__publicField(TaskColorPicker, "$name", "TaskColorPicker");
__publicField(TaskColorPicker, "type", "taskcolorpicker");
__publicField(TaskColorPicker, "configurable", {
  // These are the colors available by default for TaskBoard
  colorClasses: [
    { color: "red", text: "Red" },
    { color: "pink", text: "Pink" },
    { color: "purple", text: "Purple" },
    { color: "deep-purple", text: "Deep purple" },
    { color: "indigo", text: "Indigo" },
    { color: "blue", text: "Blue" },
    { color: "light-blue", text: "Light blue" },
    { color: "cyan", text: "Cyan" },
    { color: "teal", text: "Teal" },
    { color: "green", text: "Green" },
    { color: "light-green", text: "Light green" },
    { color: "lime", text: "Lime" },
    { color: "yellow", text: "Yellow" },
    { color: "amber", text: "Amber" },
    { color: "orange", text: "Orange" },
    { color: "deep-orange", text: "Deep orange" }
  ],
  colorClassPrefix: "b-taskboard-background-color-",
  /**
   * @hideconfigs colors
   */
  colors: null
});
TaskColorPicker.initClass();
TaskColorPicker._$name = "TaskColorPicker";

// lib/TaskBoard/widget/TaskColorCombo.js
var TaskColorCombo = class extends ColorField {
};
__publicField(TaskColorCombo, "$name", "TaskColorCombo");
__publicField(TaskColorCombo, "type", "taskcolorcombo");
__publicField(TaskColorCombo, "configurable", {
  picker: {
    type: "taskcolorpicker"
  },
  name: "eventColor",
  clearable: true
});
TaskColorCombo.initClass();
TaskColorCombo._$name = "TaskColorCombo";

// lib/TaskBoard/widget/TaskEditor.js
var TaskEditor = class extends Popup.mixin(TaskBoardLinked_default) {
  changeItems(items2, old) {
    const { taskBoard } = this, { column, swimlane, resources } = items2;
    if (taskBoard) {
      if (column) {
        if (!column.name) {
          column.name = taskBoard.columnField;
        }
        if (!column.label) {
          column.label = StringHelper.capitalize(taskBoard.columnField);
        }
      }
      if (swimlane) {
        if (!taskBoard.swimlaneField || !taskBoard.swimlanes) {
          items2.swimlane = null;
        } else {
          if (!swimlane.name) {
            swimlane.name = taskBoard.swimlaneField;
          }
          if (!swimlane.label) {
            swimlane.label = StringHelper.capitalize(taskBoard.swimlaneField);
          }
        }
      }
      if (!taskBoard.project.resourceStore.count) {
        items2.resources = null;
      }
      if (taskBoard.project.eventStore.usesSingleAssignment && resources) {
        resources.multiSelect = false;
      }
    } else {
      items2.column = items2.swimlane = items2.resources = null;
    }
    return super.changeItems(items2, old);
  }
  processItemsObject(items2, namedItems, result) {
    for (const ref in items2) {
      const item = items2[ref];
      if (item && !("name" in item)) {
        item.name = ref;
      }
    }
    return super.processItemsObject(items2, namedItems, result);
  }
  updateAutoUpdateRecord(autoUpdate) {
    this.bbar.hidden = autoUpdate;
  }
  updateRecord(record) {
    super.updateRecord(record);
    if (record) {
      this.element.dataset.taskId = record.id;
    }
  }
  onSaveClick() {
    const me = this, { record, owner } = me, { resources, ...values } = me.values;
    if (me.isValid) {
      if ((owner == null ? void 0 : owner.trigger("beforeSave", { record, values: me.values, editor: me })) === false) {
        return;
      }
      owner == null ? void 0 : owner.trigger("save", { record, values: me.values, editor: me });
      me.close();
      record.set(values);
      if (resources) {
        record.resources = resources;
      }
    }
  }
  onCancelClick() {
    var _a2, _b;
    const me = this;
    if (((_a2 = me.owner) == null ? void 0 : _a2.trigger("beforeCancel", { editor: me })) === false) {
      return;
    }
    (_b = me.owner) == null ? void 0 : _b.trigger("cancel", { editor: me });
    me.close();
  }
  onInternalKeyDown(event) {
    const me = this;
    if (me.saveAndCloseOnEnter && !me.readOnly && event.key === "Enter") {
      event.preventDefault();
      if (me.autoUpdateRecord) {
        if (me.isValid) {
          event.target.blur();
          me.close();
        }
      } else {
        me.onSaveClick();
      }
    }
    super.onInternalKeyDown(event);
  }
};
__publicField(TaskEditor, "$name", "TaskEditor");
__publicField(TaskEditor, "type", "taskboardtaskeditor");
__publicField(TaskEditor, "configurable", {
  /**
   * Center the editor in browser viewport space. Defaults to true for desktop browsers using a pointer device
   * @config {Boolean}
   * @default
   * @category Common
   */
  centered: true,
  /**
   * Show an opaque mask below the editor when shown.
   *
   * Clicking the mask closes the editor.
   *
   * @config {Boolean}
   * @default true
   * @category Common
   */
  modal: { closeOnMaskTap: true },
  /**
   * Shows a tool used to close the editor in the header.
   * @config {Boolean}
   * @default
   * @category Common
   */
  closable: true,
  /**
   * By default the editor automatically updates the edited task when a field is changed. Set this to `false`
   * to show Save / Cancel buttons and take manual control of the updating.
   *
   * @config {Boolean}
   * @default
   * @category Common
   */
  autoUpdateRecord: true,
  /**
   * Update fields if the {@link #config-record} changes
   * @config {Boolean}
   */
  autoUpdateFields: true,
  /**
   * True to save and close the editor if ENTER is pressed.
   * (The save part only applies when configured with `autoUpdateRecord : false`)
   *
   * @config {Boolean}
   * @default
   * @category Common
   */
  saveAndCloseOnEnter: true,
  draggable: {
    handleSelector: ".b-panel-header"
  },
  autoShow: false,
  anchor: true,
  closeAction: "destroy",
  scrollAction: "realign",
  title: "L{TaskBoard.editTask}",
  defaults: {
    labelWidth: "30%"
  },
  width: "30em",
  items: {
    name: { type: "text", label: "L{TaskBoard.name}", weight: 100 },
    description: { type: "textarea", label: "L{TaskBoard.description}", height: "5em", weight: 200 },
    resources: { type: "resourcescombo", label: "L{TaskBoard.resources}", weight: 300 },
    color: { type: "taskcolorcombo", label: "L{TaskBoard.color}", name: "eventColor", weight: 400 },
    column: { type: "columncombo", weight: 500 },
    swimlane: { type: "swimlanecombo", weight: 600 }
  },
  bbar: {
    hidden: true,
    items: {
      saveButton: { text: "L{TaskBoard.save}", onClick: "up.onSaveClick", weight: 100 },
      cancelButton: { text: "L{TaskBoard.cancel}", onClick: "up.onCancelClick", weight: 200 }
    }
  },
  // We want to maximize on phones and tablets
  maximizeOnMobile: true
});
TaskEditor.initClass();
TaskEditor._$name = "TaskEditor";

// lib/TaskBoard/feature/TaskEdit.js
var TaskEdit = class extends TaskBoardFeature {
  constructor() {
    super(...arguments);
    __publicField(this, "editor", null);
  }
  doDestroy() {
    var _a2;
    (_a2 = this.editor) == null ? void 0 : _a2.destroy();
  }
  //region Type assertions
  changeEditorConfig(editorConfig) {
    ObjectHelper.assertObject(editorConfig, "features.taskEdit.editorConfig");
    return editorConfig;
  }
  changeEditorType(editorType) {
    ObjectHelper.assertString(editorType, "features.taskEdit.editorType");
    return editorType;
  }
  changeItems(items2) {
    ObjectHelper.assertObject(items2, "features.taskEdit.items");
    return items2;
  }
  changeProcessItems(processItems) {
    ObjectHelper.assertFunction(processItems, "features.taskEdit.processItems");
    return processItems;
  }
  //endregion
  /**
   * Edit the supplied task in the task editor.
   *
   * ```javascript
   * taskBoard.editTask(taskStore.first);
   * ```
   *
   * @param {TaskBoard.model.TaskModel} taskRecord Task to edit
   * @param {HTMLElement} [element] Optionally an element to align to, by default it tries to resolve one from the
   * supplied task when the editor is configured to not be centered.
   * @on-owner
   * @category Common
   */
  async editTask(taskRecord, element = null) {
    var _a2, _b;
    const me = this, { client } = me, columnRecord = client.getColumn(taskRecord), swimlaneRecord = client.swimlaneField && ((_a2 = client.swimlanes) == null ? void 0 : _a2.getById(taskRecord.getValue(client.swimlaneField)));
    if (me.disabled) {
      return;
    }
    if (await client.trigger("beforeTaskEdit", { taskRecord }) === false) {
      return;
    }
    if (me.isEditing) {
      me.cancelEdit();
    }
    const editorClass = Widget.resolveType(me.editorType), combinedItems = editorClass.mergeConfigs(editorClass.$meta.config.items, me.items), processResult = (_b = me.processItems) == null ? void 0 : _b.call(me, { items: combinedItems, taskRecord, columnRecord, swimlaneRecord });
    if (processResult === false) {
      return;
    }
    const editor = me.editor = editorClass.new({
      items: combinedItems,
      owner: client,
      readOnly: taskRecord.readOnly
    }, me.editorConfig);
    client.trigger("beforeTaskEditShow", { taskRecord, editor });
    editor.record = taskRecord;
    if (editor.centered || !BrowserHelper.isHoverableDevice) {
      editor.show();
    } else {
      Scroller.scrollIntoView(element != null ? element : client.getTaskElement(taskRecord));
      editor.showBy(element != null ? element : client.getTaskElement(taskRecord));
    }
    editor.isVisible && editor.ion({
      hide: me.onEditorHide,
      thisObj: me
    });
  }
  cancelEdit() {
  }
  onActivateTask({ taskRecord, event }) {
    if (!event.defaultPrevented) {
      this.editTask(taskRecord);
    }
  }
  populateTaskMenu({ items: items2, taskRecord }) {
    if (!this.client.readOnly && !this.disabled) {
      items2.editTask = {
        text: "L{TaskBoard.editTask}",
        icon: "b-fw-icon b-icon-edit",
        weight: 100,
        onItem: () => this.editTask(taskRecord),
        disabled: taskRecord.readOnly
      };
    }
  }
  onEditorHide() {
    var _a2;
    (_a2 = this.client.getTaskElement(this.editor.record)) == null ? void 0 : _a2.focus();
  }
};
__publicField(TaskEdit, "$name", "TaskEdit");
__publicField(TaskEdit, "type", "taskEdit");
__publicField(TaskEdit, "configurable", {
  /**
   * Type of widget to use as the editor. Should point to a subclass of {@link TaskBoard.widget.TaskEditor} or
   * a widget mimicking its API.
   * @config {String}
   * @default
   * @category Customization
   */
  editorType: "taskboardtaskeditor",
  /**
   * Config object merged with the default configuration of the editor (by default a
   * {@link TaskBoard.widget.TaskEditor}).
   *
   * Can be used to configure any aspect of the editor:
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *     features : {
   *         taskEdit : {
   *             editorConfig : {
   *                 modal    : false,
   *                 centered : false
   *             }
   *         }
   *     }
   * });
   * ```
   * To customize the items in the editor, using {@link #config-items} is preferable.
   * @config {TaskEditorConfig}
   * @category Customization
   */
  editorConfig: {},
  /**
   * Items definition passed on to the configured editor (by default a {@link TaskBoard.widget.TaskEditor}).
   *
   * Can be used to add new items or modify and remove predefined items. To remove, supply `null` as the value.
   *
   * @config {Object<String,ContainerItemConfig|Boolean|null>}
   * @category Customization
   */
  items: {},
  /**
   * A function called before displaying the editor that allows manipulation of its items.
   * Returning `false` from this function prevents the editor from being shown.
   *
   * ```javascript
   * features         : {
   *    taskEdit : {
   *         processItems({ items, taskRecord, columnRecord, swimlaneRecord }) {
   *             // Manipulate existing items here as needed
   *             items.name.label = taskRecord.type === 'task' ? 'Task' : 'Issue';
   *
   *            // Remove column field when editing tasks that are done
   *            if (columnRecord.id === 'done') {
   *                items.column = false
   *            }
   *         }
   *     }
   * },
   * ```
   *
   * @config {Function}
   * @param {Object} context An object with information about the editor being shown
   * @param {Object<String,ContainerItemConfig>} context.items An object containing the editor item configs keyed by ref
   * @param {TaskBoard.model.TaskModel} context.taskRecord Record representing task being edited
   * @param {TaskBoard.model.ColumnModel} context.columnRecord Record representing tasks column
   * @param {TaskBoard.model.SwimlaneModel} context.swimlaneRecord Record representing tasks swimlane
   * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown
   * @preventable
   */
  processItems: null
  // /**
  //  * The event that shall trigger showing the editor. Defaults to `eventdblclick`, set to `` or null to disable editing of existing events.
  //  * @config {String}
  //  * @default
  //  * @category Editor
  //  */
  // triggerEvent : 'eventdblclick',
  // /**
  //  * Specify `true` to put the editor in read only mode.
  //  * @config {Boolean}
  //  * @default false
  //  */
  // readOnly : null,
});
__publicField(TaskEdit, "pluginConfig", {
  assign: ["editTask"],
  chain: ["onActivateTask", "populateTaskMenu"]
});
TaskEdit.initClass();
TaskEdit._$name = "TaskEdit";

// lib/TaskBoard/feature/TaskMenu.js
var TaskMenu = class extends ContextMenuBase {
  static get pluginConfig() {
    const config = super.pluginConfig;
    config.chain.push("populateTaskMenu");
    return config;
  }
  //region Type assertions
  changeItems(items2) {
    ObjectHelper.assertObject(items2, "features.taskMenu.items");
    return items2;
  }
  changeProcessItems(processItems) {
    ObjectHelper.assertFunction(processItems, "features.taskMenu.processItems");
    return processItems;
  }
  //endregion
  //region Events
  /**
   * This event fires on the owning TaskBoard before the context menu is shown for a task.
   * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.
   *
   * Returning `false` from a listener prevents the menu from being shown.
   *
   * @event taskMenuBeforeShow
   * @on-owner
   * @preventable
   * @param {TaskBoard.view.TaskBoard} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Object<string,MenuItemConfig>} items Menu item configs
   * @param {TaskBoard.model.TaskModel} taskRecord The task
   * @on-owner
   */
  /**
   * This event fires on the owning TaskBoard after the context menu is shown for a task.
   * @event taskMenuShow
   * @on-owner
   * @param {TaskBoard.view.TaskBoard} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Object<string,MenuItemConfig>} items Menu item configs
   * @param {TaskBoard.model.TaskModel} taskRecord The task
   * @on-owner
   */
  /**
   * This event fires on the owning TaskBoard when an item is selected in the task context menu.
   * @event taskMenuItem
   * @on-owner
   * @param {TaskBoard.view.TaskBoard} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   * @param {TaskBoard.model.TaskModel} taskRecord The task
   * @on-owner
   */
  /**
   * This event fires on the owning TaskBoard when a check item is toggled in the task context menu.
   * @event taskMenuToggleItem
   * @on-owner
   * @param {TaskBoard.view.TaskBoard} source The grid
   * @param {Core.widget.Menu} menu The menu
   * @param {Core.widget.MenuItem} item Selected menu item
   * @param {TaskBoard.model.TaskModel} taskRecord The task
   * @param {Boolean} checked Checked or not
   * @on-owner
   */
  //endregion
  updateTriggerEvent(triggerEvent) {
    this.detachListeners("triggerEvent");
    if (triggerEvent) {
      this.client.ion({
        name: "triggerEvent",
        [triggerEvent]: "onTriggerEvent",
        thisObj: this
      });
    }
  }
  doDisable(disable) {
    super.doDisable(disable);
    !this.isConfiguring && this.client.recompose();
  }
  onTriggerEvent({ event }) {
    this.internalShowContextMenu(event);
  }
  /**
   * Show the context menu for a specific task, aligned to its card. Optionally aligned to an element in the card, using the supplied CSS selector.
   *
   * @param {TaskBoard.model.TaskModel} taskRecord Task to show the menu for
   * @param {String} [selector] CSS selector, to align to a specific element in the task's card
   */
  showMenuFor(taskRecord, selector = ".b-taskboard-task-menu") {
    const targetElement = this.client.getTaskElement(taskRecord), buttonElement = targetElement.querySelector(selector), eventParams = { taskRecord, columnRecord: this.client.getColumn(taskRecord), targetElement };
    let alignSpec = null;
    if (buttonElement) {
      eventParams.targetElement = buttonElement;
      alignSpec = {
        target: buttonElement
      };
    }
    this.showContextMenu(eventParams, alignSpec);
  }
  showContextMenu(eventParams, ...args) {
    if (!this.client.isSelected(eventParams.taskRecord)) {
      this.client.selectTask(eventParams.taskRecord);
    }
    super.showContextMenu(eventParams, ...args);
  }
  getDataFromEvent(event) {
    return ObjectHelper.assign(super.getDataFromEvent(event), event.taskBoardData);
  }
  populateTaskMenu({ items: items2, taskRecord }) {
    var _a2;
    const { client, disabled } = this;
    if (!client.readOnly && !disabled) {
      const { columnField, swimlaneField, selectedTasks } = client, { resourceStore, eventStore } = client.project, isSelected = selectedTasks.includes(taskRecord);
      items2.column = {
        text: `L{TaskBoard.changeColumn} ${columnField}`,
        icon: "b-fw-icon b-icon-move-left-right",
        weight: 300,
        disabled: taskRecord.readOnly,
        menu: client.columns.map((col) => ({
          ref: col.id,
          text: StringHelper.encodeHtml(col.text),
          cls: "b-column-menu-item",
          isColumn: true,
          checked: taskRecord.getValue(columnField) === col.id,
          // Close menu when task is moved to a new column, looks weird to keep it open
          closeParent: true
        })),
        onItem({ item }) {
          if (item.isColumn) {
            taskRecord.setValue(columnField, item.ref);
            item.parent.items.forEach((sibling) => {
              if (sibling !== item) {
                sibling.checked = false;
              }
            });
          }
        }
      };
      if (((_a2 = client.swimlanes) == null ? void 0 : _a2.count) && swimlaneField) {
        items2.swimlane = {
          text: StringHelper.xss`L{TaskBoard.changeSwimlane} ${swimlaneField}`,
          icon: "b-fw-icon b-icon-move-up-down",
          weight: 400,
          disabled: taskRecord.readOnly,
          menu: client.swimlanes.map((lane) => ({
            ref: lane.id,
            text: StringHelper.encodeHtml(lane.text),
            isSwimlane: true,
            checked: taskRecord.getValue(swimlaneField) === lane.id,
            // Close menu when task is moved to a new swimlane, looks weird to keep it open
            closeParent: true
          })),
          onItem({ item }) {
            if (item.isSwimlane) {
              taskRecord.setValue(swimlaneField, item.ref);
              item.parent.items.forEach((sibling) => {
                if (sibling !== item) {
                  sibling.checked = false;
                }
              });
            }
          }
        };
      }
      if (resourceStore.count) {
        items2.resources = {
          text: "L{TaskBoard.resources}",
          icon: "b-fw-icon b-icon-user",
          weight: 200,
          disabled: taskRecord.readOnly,
          menu: resourceStore.map(
            (resource) => {
              var _a3;
              const avatar = (_a3 = this.avatarRendering) == null ? void 0 : _a3.getResourceAvatar({
                resourceRecord: resource,
                initials: resource.initials,
                color: resource.color,
                iconCls: resource.iconCls,
                imageUrl: resource.imageUrl || (client.resourceImagePath || "") + (resource.image || "")
              });
              return {
                ref: resource.id,
                cls: "b-resource-menu-item",
                text: avatar ? {
                  className: "b-resource-menu-item-inner",
                  children: [
                    avatar,
                    StringHelper.encodeHtml(resource.name)
                  ]
                } : StringHelper.encodeHtml(resource.name),
                resource,
                checked: taskRecord.resources.includes(resource),
                // Only allow single pick in single assignment mode
                toggleGroup: eventStore.usesSingleAssignment ? "single" : null
              };
            }
          ),
          onItem({ item }) {
            if (item.resource) {
              taskRecord[item.checked ? "assign" : "unassign"](item.resource);
            }
          }
        };
      }
      items2.removeTask = {
        text: isSelected && selectedTasks.length > 1 ? "L{TaskBoard.removeTasks}" : "L{TaskBoard.removeTask}",
        icon: "b-fw-icon b-icon-trash",
        cls: "b-separator",
        weight: 500,
        disabled: taskRecord.readOnly,
        onItem: () => client.removeTask(isSelected ? selectedTasks : taskRecord)
      };
    }
  }
  get showMenu() {
    return true;
  }
  updateShowAvatars(value) {
    var _a2;
    (_a2 = this.avatarRendering) == null ? void 0 : _a2.destroy();
    if (value) {
      this.avatarRendering = new AvatarRendering({
        element: this.client.element
      });
    }
  }
};
__publicField(TaskMenu, "$name", "TaskMenu");
__publicField(TaskMenu, "type", "taskMenu");
__publicField(TaskMenu, "configurable", {
  /**
   * A function called before displaying the menu that allows manipulations of its items.
   * Returning `false` from this function prevents the menu from being shown.
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *   features         : {
   *       taskMenu : {
   *           processItems({ taskRecord, items }) {
   *              // Add a custom menu item for tasks with progress greater than 90
   *              if (taskRecord.progress > 90) {
   *                  items.close = {
   *                      text : 'Close',
   *                      icon : 'b-fa-fw b-fa-check',
   *                      onItem({ taskRecord }) {
   *                          taskRecord.done = true;
   *                      }
   *                  }
   *              }
   *           }
   *       }
   *   }
   * });
   * ```
   *
   * @config {Function}
   * @param {Object} context An object with information about the menu being shown
   * @param {TaskBoard.model.TaskModel} context.taskRecord The task for which the menu will be shown
   * @param {Object<string,MenuItemConfig|Boolean>} context.items An object containing the
   *   {@link Core.widget.MenuItem menu item} configs keyed by their id
   * @param {Event} context.event The DOM event object that triggered the show
   * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown
   * @preventable
   */
  processItems: null,
  /**
   * This is a preconfigured set of items used to create the default context menu.
   *
   * The `items` provided by this feature are listed in the intro section of this class. You can configure
   * existing items by passing a configuration object to the keyed items.
   *
   * To remove existing items, set corresponding keys to `null`:
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *     features : {
   *         taskMenu : {
   *             items : {
   *                 editTask : null
   *             }
   *         }
   *     }
   * });
   * ```
   *
   * See the feature config in the above example for details.
   *
   * @config {Object<string,MenuItemConfig|Boolean|null>} items
   */
  items: null,
  type: "task",
  /**
   * The mouse / touch gesture which should show this context menu (e.g. 'taskClick' or 'taskContextMenu').
   * Set to `false` to never trigger it from UI.
   * @default
   * @config {String|Boolean}
   */
  triggerEvent: "taskContextMenu",
  /**
   * Show avatars/initials in the resource picker menu
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *     features : {
   *         taskMenu : {
   *             showAvatars : false
   *         }
   *     }
   * });
   * ```
   *
   * @config {Boolean}
   * @default true
   */
  showAvatars: {
    value: true,
    $config: "nullify"
  },
  menu: {
    align: "t90-b90",
    anchor: true
  }
  /**
   * See {@link #keyboard-shortcuts Keyboard shortcuts} for details
   * @config {Object<string,string>} keyMap
   */
  /**
   * @hideconfigs type
   */
});
TaskBoardFeature.register(TaskMenu.type, TaskMenu);
TaskMenu._$name = "TaskMenu";

// lib/TaskBoard/feature/TaskTooltip.js
var TaskTooltip = class extends TaskBoardFeature {
  //region Type assertions
  changeTemplate(template) {
    ObjectHelper.assertFunction(template, "features.taskTooltip.template");
    return template;
  }
  //endregion
  doDisable(disable) {
    super.doDisable(disable);
    if (this._tooltip) {
      this.tooltip.disabled = disable;
    }
  }
  changeTooltip(tooltip, oldTooltip) {
    const me = this, { client } = me;
    ObjectHelper.assertObject(tooltip, "features.taskTooltip.tooltip");
    oldTooltip == null ? void 0 : oldTooltip.destroy();
    if (tooltip) {
      return new Tooltip(ObjectHelper.assign({
        axisLock: "flexible",
        cls: "b-taskboard-tooltip",
        forSelector: ".b-taskboardbase:not(.b-draghelper-active) .b-taskboard-card",
        scrollAction: "realign",
        forElement: client.element,
        showOnHover: true,
        hoverDelay: 0,
        hideDelay: 100,
        anchorToTarget: true,
        allowOver: Boolean(me.config.items || me.config.tools),
        getHtml: me.getTipHtml.bind(me),
        disabled: me.disabled,
        textContent: false
      }, tooltip));
    }
  }
  getTipHtml({ tip, activeTarget }) {
    const { client } = this, taskRecord = client.resolveTaskRecord(activeTarget), columnRecord = client.resolveColumnRecord(activeTarget), swimlaneRecord = client.resolveSwimlaneRecord(activeTarget);
    if (this.template) {
      return this.template({ tip, taskRecord, columnRecord, swimlaneRecord, activeTarget });
    }
    const children = [
      {
        class: "b-taskboard-tooltip-title",
        text: taskRecord.name
      },
      {
        class: "b-taskboard-tooltip-label",
        text: StringHelper.capitalize(client.columnField)
      },
      {
        class: "b-taskboard-tooltip-value",
        text: columnRecord.text
      }
    ];
    if (swimlaneRecord) {
      children.push(
        {
          class: "b-taskboard-tooltip-label",
          text: StringHelper.capitalize(client.swimlaneField)
        },
        {
          class: "b-taskboard-tooltip-value",
          text: swimlaneRecord.text
        }
      );
    }
    if (taskRecord.resources.length) {
      children.push(
        {
          class: "b-taskboard-tooltip-label",
          text: this.L("L{TaskBoard.resources}")
        },
        {
          class: "b-taskboard-tooltip-value",
          text: taskRecord.resources.map((resourceRecord) => resourceRecord.name).join(", ")
        }
      );
    }
    return {
      children
    };
  }
  render() {
    this.getConfig("tooltip");
  }
};
__publicField(TaskTooltip, "$name", "TaskTooltip");
__publicField(TaskTooltip, "type", "taskTooltip");
__publicField(TaskTooltip, "configurable", {
  /**
   * Tooltip config object used to override the defaults, see {@link Core.widget.Tooltip#configs} for available
   * configs.
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *     features : {
   *         taskTooltip : {
   *             tooltip : {
   *                 hoverDelay : 100,
   *                 hideDelay  : 500
   *             }
   *         }
   *     }
   * });
   * ```
   *
   * @config {TooltipConfig}
   */
  tooltip: {
    value: {},
    // Lazy, pulled in on render to have element available
    $config: ["lazy", "nullify"]
  },
  /**
   * Function used to populate the tooltip, supply your own to override the default contents of the tooltip.
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *     features : {
   *         taskTooltip : {
   *             template({ taskRecord }) {
   *                 return `<b>${taskRecord.name}</b>`
   *             }
   *         }
   *     }
   * });
   * ```
   *
   * @param {Object} tipData
   * @param {TaskBoard.model.TaskModel} tipData.taskRecord Hovered task
   * @param {TaskBoard.model.ColumnModel} tipData.columnRecord The task's column
   * @param {TaskBoard.model.SwimlaneModel} tipData.swimlaneRecord The task's swimlane (if used)
   * @returns {String|DomConfig} Return an HTML string or a DOM config object
   * @config {Function}
   */
  template: null
});
__publicField(TaskTooltip, "pluginConfig", {
  chain: ["render"]
});
TaskTooltip.initClass();
TaskTooltip._$name = "TaskTooltip";

// lib/TaskBoard/model/ColumnModel.js
var ColumnModel = class extends Model {
  /**
   * Get the tasks in this column in visual order.
   * @property {TaskBoard.model.TaskModel[]}
   * @readonly
   */
  get tasks() {
    return this.taskBoard.getColumnTasks(this, true);
  }
  get taskBoard() {
    return this.firstStore.taskBoard;
  }
  /**
   * Collapse this column.
   *
   * Uses a transition by default, await the call to be certain that it has finished.
   *
   * @category Expand/collapse
   * @returns {Promise} A promise which is resolved when the column is collapsed
   */
  async collapse() {
    return this.taskBoard.collapse(this);
  }
  /**
   * Expand this column.
   *
   * Uses a transition by default, await the call to be certain that it has finished.
   *
   * @category Expand/collapse
   * @returns {Promise} A promise which is resolved when the column is expanded
   */
  async expand() {
    return this.taskBoard.expand(this);
  }
};
__publicField(ColumnModel, "$name", "ColumnModel");
__publicField(ColumnModel, "fields", [
  /**
   * This column's unique id, used to match a task to a column (which field on a task to match is specified using
   * then {@link TaskBoard.view.TaskBoardBase#config-columnField} config on TaskBoard).
   * @field {String|Number} id
   */
  /**
   * Text displayed in the column header.
   * @field {String} text
   */
  "text",
  /**
   * A tooltip string to show when hovering the column header
   * @field {String} tooltip
   */
  "tooltip",
  /**
   * Color, named colors are applied as a `b-taskboard-color-{color}` (for example `b-taskboard-color-red`) CSS
   * class to the column. Colors specified as hex, `rgb()` etc. are applied as `style.color` to the column.
   *
   * By default it does not visually affect the UI, but it applies a color to the column that applications can
   * leverage using `currentColor` to style it in the desired way.
   *
   * Using named colors:
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *     columns : [
   *         { id : 'todo', text : 'Todo', color : 'orange', tooltip : 'These are items to be done' }
   *     ]
   * });
   * ```
   *
   * Will result in:
   *
   * ```html
   * <div class="b-taskboard-column b-taskboard-color-orange">
   * ```
   *
   * Which can the be used for example like:
   *
   * ```css
   * .b-taskboard-column-header {
   *     border-left : 5px solid currentColor; // where currentColor is the color defined by b-taskboard-color-orange
   * }
   * ```
   *
   * Using non-named colors:
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *     columns : [
   *         { id : 'todo', text : 'Todo', color : 'hsl(229deg 66% 42%)' }
   *     ]
   * });
   * ```
   *
   * Will result in:
   *
   * ```html
   * <div class="b-taskboard-column" style="color: hsl(229deg 66% 42%)">
   * ```
   *
   * Predefined named colors (actual color might vary by theme):
   * <div class="b-colorbox b-inline b-taskboard-color-red"></div>red,
   * <div class="b-colorbox b-inline b-taskboard-color-pink"></div>pink,
   * <div class="b-colorbox b-inline b-taskboard-color-purple"></div>purple,
   * <div class="b-colorbox b-inline b-taskboard-color-deep-purple"></div>deep-purple,
   * <div class="b-colorbox b-inline b-taskboard-color-indigo"></div>indigo,
   * <div class="b-colorbox b-inline b-taskboard-color-blue"></div>blue,
   * <div class="b-colorbox b-inline b-taskboard-color-light-blue"></div>light-blue,
   * <div class="b-colorbox b-inline b-taskboard-color-cyan"></div>cyan,
   * <div class="b-colorbox b-inline b-taskboard-color-teal"></div>teal,
   * <div class="b-colorbox b-inline b-taskboard-color-green"></div>green,
   * <div class="b-colorbox b-inline b-taskboard-color-light-green"></div>light-green,
   * <div class="b-colorbox b-inline b-taskboard-color-lime"></div>lime,
   * <div class="b-colorbox b-inline b-taskboard-color-yellow"></div>yellow,
   * <div class="b-colorbox b-inline b-taskboard-color-amber"></div>amber,
   * <div class="b-colorbox b-inline b-taskboard-color-orange"></div>orange,
   * <div class="b-colorbox b-inline b-taskboard-color-deep-orange"></div>deep-orange
   *
   * @field {String} color
   */
  { name: "color", type: "string" },
  /**
   * Number of tasks per row to display in this column. Leave blank to use the setting from the
   * {@link TaskBoard.view.TaskBoardBase#config-tasksPerRow} config on TaskBoard.
   * @field {Number} tasksPerRow
   */
  "tasksPerRow",
  /**
   * Allow collapsing this column
   * @field {Boolean} collapsible=true
   */
  { name: "collapsible", type: "boolean", defaultValue: true },
  /**
   * Collapsed (`true`) or expanded (`false`)
   *
   * To expand or collapse, use {@link #function-expand} and  {@link #function-collapse} functions.
   *
   * @field {Boolean} collapsed
   * @readonly
   */
  { name: "collapsed", type: "boolean" },
  /**
   * Set to `true` to hide the column, `false` to show it again.
   * @field {Boolean} hidden
   */
  { name: "hidden", type: "boolean" },
  /**
   * Column width in px.
   * @field {Number} width
   */
  { name: "width", type: "number" },
  /**
   * Column flex, affects width.
   * @field {Number} flex
   */
  { name: "flex", type: "number" },
  /**
   * Column min-width in px. To override the default min-width specified in CSS.
   * @field {Number} minWidth
   */
  { name: "minWidth", type: "number" }
]);
ColumnModel._$name = "ColumnModel";

// ../Scheduler/lib/Scheduler/model/mixin/ProjectModelCommon.js
var ProjectModelCommon_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Model) {
    static get configurable() {
      return {
        // Documented in Gantt/Scheduler/SchedulerPro version of ./model/ProjectModel since types differ
        assignments: null,
        dependencies: null,
        resources: null,
        timeRanges: null
      };
    }
    // Project is a Model which triggers events, therefore it can define event handlers using `onEvent` syntax. Event
    // handler can be a string (for another instance property), or a function. Therefore, it is impossible to tell them
    // apart and project model can not expose fields.
    // https://github.com/bryntum/support/issues/7457
    static get autoExposeFields() {
      return false;
    }
    //region Inline data
    get assignments() {
      return this.assignmentStore.allRecords;
    }
    updateAssignments(assignments) {
      this.assignmentStore.data = assignments;
    }
    get dependencies() {
      return this.dependencyStore.allRecords;
    }
    updateDependencies(dependencies) {
      this.dependencyStore.data = dependencies;
    }
    get resources() {
      return this.resourceStore.allRecords;
    }
    updateResources(resources) {
      this.resourceStore.data = resources;
    }
    get timeRanges() {
      return this.timeRangeStore.allRecords;
    }
    getTimeRanges(startDate, endDate) {
      const store = this.timeRangeStore, ret = [];
      for (const timeSpan of store) {
        if (timeSpan.isRecurring) {
          ret.push(...timeSpan.getOccurrencesForDateRange(startDate, endDate));
        } else if (timeSpan.startDate < endDate && startDate < timeSpan.endDate) {
          ret.push(timeSpan);
        }
      }
      return ret;
    }
    updateTimeRanges(timeRanges) {
      this.timeRangeStore.data = timeRanges;
    }
    getResourceTimeRanges(startDate, endDate) {
      const store = this.resourceTimeRangeStore, ret = [];
      for (const timeSpan of store) {
        if (timeSpan.isRecurring) {
          ret.push(...timeSpan.getOccurrencesForDateRange(startDate, endDate));
        } else if (timeSpan.startDate < endDate && (!timeSpan.endDate || startDate < timeSpan.endDate)) {
          ret.push(timeSpan);
        }
      }
      return ret;
    }
    //endregion
  }, __publicField(_a2, "$name", "ProjectModelCommon"), _a2;
};

// ../Scheduler/lib/Scheduler/model/mixin/TimeZonedDatesMixin.js
var dateFieldsToConvert = {
  startDate: 1,
  endDate: 1,
  constraintDate: 1,
  deadlineDate: 1
};
var TimeZonedDatesMixin_default = (Target) => {
  var _a2;
  return _a2 = class extends Target {
    get timeZone() {
      return this.getData("timeZone");
    }
    set timeZone(timeZone) {
      this.setData("timeZone", timeZone);
    }
    setLocalDate(field, date) {
      const me = this;
      me.set(field, me.timeZone != null ? TimeZoneHelper.toTimeZone(date, me.timeZone) : date, true);
      me.setData(field, me[field]);
    }
    getLocalDate(field) {
      if (this.timeZone != null && this[field]) {
        return TimeZoneHelper.fromTimeZone(this[field], this.timeZone);
      }
      return this[field];
    }
    applyChangeset(rawChanges) {
      if (this.timeZone != null) {
        for (const field in dateFieldsToConvert) {
          if (rawChanges[field]) {
            this.setLocalDate(field, new Date(rawChanges[field]));
            delete rawChanges[field];
          }
        }
      }
      return super.applyChangeset(...arguments);
    }
    getFieldPersistentValue(field) {
      var _a3, _b;
      if (this.timeZone != null) {
        const fieldName = (_b = (_a3 = field == null ? void 0 : field.field) != null ? _a3 : field == null ? void 0 : field.name) != null ? _b : field;
        if (dateFieldsToConvert[fieldName]) {
          return this.getLocalDate(fieldName);
        }
      }
      return super.getFieldPersistentValue(field);
    }
    // Converts current record into a timeZone
    convertToTimeZone(timeZone) {
      const me = this, metaModified = { ...me.meta.modified }, convertFields = { ...dateFieldsToConvert };
      if (me.isTask && !me.manuallyScheduled) {
        delete convertFields.startDate;
        delete convertFields.endDate;
      }
      for (const field in convertFields) {
        if (me[field] != null) {
          convertFields[field] = me[field];
          if (me.timeZone != null) {
            convertFields[field] = me.getLocalDate(field);
            if (metaModified[field]) {
              metaModified[field] = TimeZoneHelper.fromTimeZone(metaModified[field], me.timeZone);
            }
          }
        } else {
          delete convertFields[field];
        }
      }
      me.timeZone = timeZone;
      for (const field in convertFields) {
        me.setLocalDate(field, convertFields[field], false);
        convertFields[field] = 1;
        if (me.timeZone != null && metaModified[field]) {
          metaModified[field] = TimeZoneHelper.toTimeZone(metaModified[field], me.timeZone);
        }
      }
      me.clearChanges(true, true, convertFields);
      if (!ObjectHelper.isEmpty(metaModified)) {
        me.meta.modified = metaModified;
        me.stores.forEach((store) => store.modified.add(me));
      }
    }
  }, __publicField(_a2, "$name", "TimeZonedDatesMixin"), __publicField(_a2, "fields", [
    /**
     * The current timeZone this record is converted to. Used internally to keep track of time zone conversions.
     *
     * Can also be used to create a new record with dates in a specific non-local timezone. That is useful for
     * example when replacing a store dataset. That would be interpreted as a new load, and all dates would be
     * converted to the configured timezone.
     *
     * If specifically set to `null` when adding a new record to a Store, the new record's dates will be converted
     * to the Project's configured timezone.
     *
     * For more information about timezone conversion, se {@link Scheduler.model.ProjectModel#config-timeZone}.
     *
     * This field will not {@link Core.data.field.DataField#config-persist} by default.
     *
     * @field {String|Number|null} timeZone
     * @category Advanced
     */
    {
      name: "timeZone",
      persist: false
    }
  ]), _a2;
};

// ../Scheduler/lib/Scheduler/model/TimeSpan.js
var TimeSpan = class extends Model.mixin(TimeZonedDatesMixin_default) {
  //endregion
  //region Init
  construct(data, ...args) {
    const me = this;
    if (data == null ? void 0 : data.fullDuration) {
      const { magnitude, unit } = data.fullDuration;
      data.duration = magnitude;
      data.unit = unit;
      delete data.fullDuration;
    }
    super.construct(data, ...args);
    me.normalize();
    if (me.startDateMS && me.endDateMS && me.startDateMS > me.endDateMS) {
      console.error(`startDate > endDate for ${me.constructor.$name} record with id: ${me.id}`);
    }
  }
  //endregion
  //region Date normalization
  internalCalculateStartDate(endDate, duration, durationUnit) {
    return DateHelper.add(endDate, -duration, durationUnit);
  }
  internalCalculateEndDate(startDate, duration, durationUnit) {
    return DateHelper.add(startDate, duration, durationUnit);
  }
  internalCalculateDuration(startDate, endDate, durationUnit) {
    return DateHelper.as(durationUnit, DateHelper.diff(startDate, endDate, "h"), "h");
  }
  // Separate fn to allow calling later with specific values (used by Baseline)
  internalNormalize(startDate, endDate, duration, durationUnit) {
    const me = this, hasDuration = duration != null;
    if (startDate && endDate && !hasDuration) {
      me.setData("duration", me.internalCalculateDuration(startDate, endDate, durationUnit));
    } else if (startDate && !endDate && hasDuration) {
      me.setData("endDate", me.internalCalculateEndDate(startDate, duration, durationUnit));
    } else if (!startDate && endDate && hasDuration) {
      me.setData("startDate", me.internalCalculateStartDate(endDate, duration, durationUnit));
    }
  }
  normalize() {
    this.internalNormalize(
      this.startDate,
      this.endDate,
      this.duration,
      this.durationUnit || this.constructor.defaultValues.durationUnit
      // Default might not be applied yet
    );
  }
  //endregion
  //region Getters & Setters
  /**
   * Returns the event store this event is part of, if any.
   *
   * @property {Scheduler.data.EventStore}
   * @readonly
   * @category Misc
   * @typings ignore
   */
  get eventStore() {
    var _a2;
    const me = this;
    if (me.isOccurrence) {
      return me.recurringTimeSpan.eventStore;
    }
    if (!me._eventStore) {
      me._eventStore = (_a2 = me.stores) == null ? void 0 : _a2.find((s) => s.isEventStore);
    }
    return me._eventStore;
  }
  updateInternalCls(cls) {
    if (this._cls) {
      this._cls.value = cls;
    } else {
      this._cls = new DomClassList(cls);
    }
  }
  set internalCls(cls) {
    this.updateInternalCls(cls);
    this.set("cls", this._cls.value);
  }
  get internalCls() {
    const { cls } = this;
    if (cls == null ? void 0 : cls.isDomClassList) {
      return cls;
    }
    this.updateInternalCls(cls);
    this.setData("cls", this._cls.value);
    return this._cls;
  }
  get cls() {
    if (!this._cls) {
      this._cls = new DomClassList(super.get("cls"));
    }
    return this._cls;
  }
  set cls(cls) {
    this.internalCls = cls;
  }
  get startDate() {
    return this.get("startDate");
  }
  set startDate(date) {
    this.setStartDate(date);
  }
  get endDate() {
    return this.get("endDate");
  }
  set endDate(date) {
    this.setEndDate(date);
  }
  get endingDate() {
    const me = this, {
      endDate,
      startDate
    } = me;
    if (endDate) {
      return endDate;
    }
    return DateHelper.add(startDate, me.duration, me.durationUnit);
  }
  get duration() {
    return this.get("duration");
  }
  set duration(duration) {
    this.setDuration(duration, this.durationUnit);
  }
  get durationUnit() {
    return this.get("durationUnit");
  }
  /**
   * Sets duration and durationUnit in one go. Only allowed way to change durationUnit, the durationUnit field is
   * readonly after creation
   * @param {Number} duration Duration value
   * @param {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} durationUnit Unit for
   * specified duration value, see {@link #field-durationUnit} for valid values
   * @category Scheduling
   */
  setDuration(duration, durationUnit = this.durationUnit) {
    duration = parseFloat(duration);
    this.set({
      duration,
      durationUnit,
      ...this.updateDatesFromDuration(duration, durationUnit)
    });
  }
  updateDatesFromDuration(magnitude, unit, startDate = this.startDate, endDate = this.endDate) {
    const result = {};
    if (startDate) {
      result.endDate = this.internalCalculateEndDate(startDate, magnitude, unit);
    } else if (endDate) {
      result.startDate = this.internalCalculateStartDate(endDate, magnitude, unit);
    }
    return result;
  }
  /**
   * Returns duration of the event in given unit. This is a wrapper for {@link Core.helper.DateHelper#function-getDurationInUnit-static}
   * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} unit
   * @param {Boolean} [doNotRound]
   * @private
   * @returns {Number}
   */
  getDurationInUnit(unit, doNotRound) {
    const me = this;
    if (me.startDate && me.endDate) {
      return DateHelper.getDurationInUnit(me.startDate, me.endDate, unit, doNotRound);
    } else {
      return DateHelper.as(unit, me.duration, me.durationUnit);
    }
  }
  get fullDuration() {
    return new Duration({
      unit: this.durationUnit,
      magnitude: this.duration
    });
  }
  set fullDuration(duration) {
    if (typeof duration === "string") {
      duration = DateHelper.parseDuration(duration, true, this.durationUnit);
    }
    this.setDuration(duration.magnitude, duration.unit);
  }
  /**
   * Sets the range start date
   *
   * @param {Date} date The new start date
   * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
   * Defaults to `true`
   * @category Scheduling
   */
  setStartDate(date, keepDuration = true) {
    const me = this, toSet = {
      startDate: date
    };
    if (date) {
      let calcEndDate;
      if (keepDuration) {
        calcEndDate = me.duration != null;
      } else {
        if (me.endDate) {
          toSet.duration = me.internalCalculateDuration(date, me.endDate, me.durationUnit);
          if (toSet.duration < 0) {
            throw new Error("Negative duration");
          }
        } else {
          calcEndDate = me.duration != null;
        }
      }
      if (calcEndDate) {
        toSet.endDate = me.internalCalculateEndDate(date, me.duration, me.durationUnit);
      }
    } else {
      toSet.duration = null;
    }
    me.set(toSet);
  }
  /**
   * Sets the range end date
   *
   * @param {Date} date The new end date
   * @param {Boolean} keepDuration Pass `true` to keep the duration of the task ("move" the event), `false` to change the duration ("resize" the event).
   * Defaults to `false`
   * @category Scheduling
   */
  setEndDate(date, keepDuration = false) {
    const me = this, toSet = {
      endDate: date
    };
    if (date) {
      let calcStartDate;
      if (keepDuration === true) {
        calcStartDate = me.duration != null;
      } else {
        if (me.startDate) {
          toSet.duration = me.internalCalculateDuration(me.startDate, date, me.durationUnit);
          if (toSet.duration < 0)
            throw new Error("Negative duration");
        } else {
          calcStartDate = this.duration != null;
        }
      }
      if (calcStartDate) {
        toSet.startDate = me.internalCalculateStartDate(date, me.duration, me.durationUnit);
      }
    }
    me.set(toSet);
  }
  /**
   * Sets the event start and end dates
   *
   * @param {Date} start The new start date
   * @param {Date} end The new end date
   * @param {Boolean} [silent] Pass `true` to not trigger events
   * @category Scheduling
   */
  setStartEndDate(start, end, silent) {
    if (start > end) {
      throw new Error("Start date must be less or equal to end date");
    }
    this.set({
      startDate: start,
      endDate: end
    }, null, silent);
  }
  /**
   * Returns an array of dates in this range. If the range starts/ends not at the beginning of day, the whole day will be included.
   * @readonly
   * @property {Date[]}
   * @category Scheduling
   */
  get dates() {
    const dates = [], startDate = DateHelper.startOf(this.startDate, "day"), endDate = this.endDate;
    for (let date = startDate; date < endDate; date = DateHelper.add(date, 1, "day")) {
      dates.push(date);
    }
    return dates;
  }
  get startDateMS() {
    var _a2;
    return (_a2 = this.batching && this.hasBatchedChange("startDate") ? this.get("startDate") : this.startDate) == null ? void 0 : _a2.getTime();
  }
  get endDateMS() {
    var _a2;
    return (_a2 = this.batching && this.hasBatchedChange("endDate") ? this.get("endDate") : this.endDate) == null ? void 0 : _a2.getTime();
  }
  /**
   * Returns the duration of this Event in milliseconds.
   * @readonly
   * @property {Number}
   * @category Scheduling
   */
  get durationMS() {
    const { endDateMS, startDateMS } = this;
    if (endDateMS && startDateMS) {
      return endDateMS - startDateMS;
    }
    return DateHelper.asMilliseconds(this.duration || 0, this.durationUnit);
  }
  /**
   * Returns true if record is a milestone.
   * @readonly
   * @property {Boolean}
   * @category Scheduling
   */
  get isMilestone() {
    return this.duration === 0;
  }
  inSetNormalize(field) {
    if (typeof field !== "string") {
      let { startDate, endDate, duration, durationUnit = this.durationUnit } = field;
      if (typeof startDate === "string") {
        startDate = this.getFieldDefinition("startDate").convert(startDate);
      }
      if (typeof endDate === "string") {
        endDate = this.getFieldDefinition("endDate").convert(endDate);
      }
      if ("duration" in field) {
        if (startDate && !endDate) {
          endDate = this.internalCalculateEndDate(startDate, duration, durationUnit);
        }
        if (!startDate && endDate) {
          startDate = this.internalCalculateStartDate(endDate, duration, durationUnit);
        }
      } else if (startDate && endDate) {
        duration = this.internalCalculateDuration(startDate, endDate, durationUnit);
      }
      const fieldOrClone = Object.isFrozen(field) ? ObjectHelper.clone(field) : field;
      startDate && (fieldOrClone.startDate = startDate);
      endDate && (fieldOrClone.endDate = endDate);
      duration != null && (fieldOrClone.duration = duration);
      return fieldOrClone;
    }
  }
  fieldToKeys(field, value) {
    var _a2, _b;
    const result = super.fieldToKeys(field, value);
    if (result.fullDuration) {
      const { magnitude, unit } = result.fullDuration;
      result.duration = magnitude;
      result.durationUnit = unit;
    }
    if (!this.isEventModel && !this.isTaskModel) {
      if (("duration" in result || result.durationUnit) && !(result.startDate && result.endDate)) {
        Object.assign(
          result,
          this.updateDatesFromDuration(
            (_a2 = result.duration) != null ? _a2 : this.duration,
            (_b = result.durationUnit) != null ? _b : this.durationUnit,
            result.startDate,
            result.endDate
          )
        );
      }
    }
    return result;
  }
  inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly, triggerBeforeUpdate) {
    var _a2;
    const me = this;
    if (!skipAccessors) {
      field = me.inSetNormalize(field) || field;
    }
    const result = super.inSet(field, value, silent, fromRelationUpdate, skipAccessors, validOnly, triggerBeforeUpdate);
    if (!((_a2 = me.project) == null ? void 0 : _a2.isWritingData) && field.startDate && field.endDate) {
      let invalid;
      if (field.startDate instanceof Date && field.endDate instanceof Date) {
        invalid = field.startDate > field.endDate;
      } else if (me.fieldMap.startDate.convert(field.startDate) > me.fieldMap.endDate.convert(field.endDate)) {
        invalid = true;
      }
      if (invalid) {
        console.error(`startDate > endDate for ${me.constructor.$name} record with id: ${me.id}`);
      }
    }
    return result;
  }
  // Cls requires special handling since it is converted to a DomClassList
  applyValue(useProp, key, value, skipAccessors, field) {
    if (key === "cls") {
      this.updateInternalCls(value);
    }
    super.applyValue(useProp, key, value, skipAccessors, field);
  }
  //endregion
  //region Iteration
  /**
   * Iterates over the {@link #property-dates}
   * @param {Function} func The function to call for each date
   * @param {Object} thisObj `this` reference for the function
   * @category Scheduling
   */
  forEachDate(func, thisObj) {
    return this.dates.forEach(func.bind(thisObj));
  }
  //endregion
  /**
   * Checks if the range record has both start and end dates set and start <= end
   *
   * @property {Boolean}
   * @category Scheduling
   */
  get isScheduled() {
    const { startDateMS, endDateMS } = this;
    return endDateMS - startDateMS >= 0;
  }
  // Simple check if end date is greater than start date
  get isValid() {
    const { startDate, endDate } = this;
    return !startDate || !endDate || endDate - startDate >= 0;
  }
  /**
   * Shift the dates for the date range by the passed amount and unit
   * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} unit The unit to shift by, see {@link Core.helper.DateHelper}
   * for more information on valid formats.
   * @param {Number} amount The amount to shift
   */
  shift(amount, unit = this.durationUnit) {
    if (typeof amount === "string") {
      const u = amount;
      amount = unit;
      unit = u;
    }
    return this.setStartDate(DateHelper.add(this.startDate, amount, unit, true), true);
  }
  /**
   * Returns the WBS code of this model (e.g '2.1.3'). Only relevant when part of a tree store, as in the Gantt chart.
   * @property {String}
   * @category Parent & children
   */
  get wbsCode() {
    return this._wbsCode || this.indexPath.join(".");
  }
  set wbsCode(value) {
    this._wbsCode = value;
  }
  fullCopy() {
    return this.copy.apply(this, arguments);
  }
  intersects(timeSpan) {
    return this.intersectsRange(timeSpan.startDate, timeSpan.endDate);
  }
  intersectsRange(start, end) {
    const myStart = this.startDate, myEnd = this.endDate;
    return myStart && myEnd && DateHelper.intersectSpans(myStart, myEnd, start, end);
  }
  /**
   * Splits this event into two pieces at the desired position.
   *
   * @param {Number|String} splitPoint The duration point at which to split this event.
   *
   * If less then `1`, this indicates the relative position at which it will be split.
   * 0.5 means cut it in half.
   *
   * If greater than `1`, this indicates the new duration in the current duration units of this event before the split.
   *
   * If this is a string, it will be a duration description as described in
   * {@link Core.helper.DateHelper#function-parseDuration-static}, for example `'15 min'`
   *
   * @returns {Scheduler.model.TimeSpan} The newly created split section of the timespan
   * @category Scheduling
   */
  split(splitPoint = 0.5) {
    const me = this, clone = me.copy(), {
      fullDuration,
      eventStore,
      assignmentStore
    } = me, oldDuration = new Duration(fullDuration), cloneDuration = new Duration(fullDuration);
    let ownNewDuration, unitsChanged;
    if (typeof splitPoint === "string") {
      ownNewDuration = new Duration(splitPoint);
      if (ownNewDuration.unit === oldDuration.unit) {
        cloneDuration.magnitude -= ownNewDuration.magnitude;
      } else {
        cloneDuration.magnitude = DateHelper.as(ownNewDuration.unit, oldDuration) - ownNewDuration.magnitude;
        cloneDuration.unit = ownNewDuration.unit;
        unitsChanged = true;
      }
    } else {
      ownNewDuration = new Duration(splitPoint > 1 ? splitPoint : me.duration * splitPoint, me.durationUnit);
      cloneDuration.magnitude -= ownNewDuration.magnitude;
    }
    clone.startDate = DateHelper.add(me.startDate, ownNewDuration.magnitude, ownNewDuration.unit);
    if (unitsChanged) {
      clone.fullDuration = cloneDuration;
      me.fullDuration = ownNewDuration;
    } else {
      clone.duration = cloneDuration.magnitude;
      me.duration = ownNewDuration.magnitude;
    }
    if (eventStore) {
      eventStore.add(clone);
      if (assignmentStore && !eventStore.usesSingleAssignment) {
        assignmentStore.add(
          me.assignments.map((assignment) => {
            const clonedData = Object.assign({}, assignment.data, {
              eventId: clone.id,
              // From engine
              event: null,
              resource: null
            });
            delete clonedData.id;
            return clonedData;
          })
        );
      }
    }
    return clone;
  }
  toICSString(icsEventConfig = {}) {
    if (!this.isScheduled) {
      return "";
    }
    const {
      startDate,
      endDate
    } = this, timestamp = icsEventConfig.DTSTAMP || DateHelper.format(/* @__PURE__ */ new Date(), "uu");
    delete icsEventConfig.DTSTAMP;
    let startEnd = {};
    if (this.allDay) {
      startEnd = {
        "DTSTART;VALUE=DATE": DateHelper.format(startDate, "u"),
        "DTEND;VALUE=DATE": DateHelper.format(endDate, "u")
      };
    } else {
      startEnd = {
        DTSTART: DateHelper.format(startDate, "uu"),
        DTEND: DateHelper.format(endDate, "uu")
      };
    }
    const version = VersionHelper.scheduler && VersionHelper.getVersion("scheduler") || VersionHelper.calendar && VersionHelper.getVersion("calendar") || "", icsWrapConfig = {
      BEGIN: "VCALENDAR",
      VERSION: "2.0",
      CALSCALE: "GREGORIAN",
      PRODID: `-//Bryntum AB//Bryntum Scheduler ${version} //EN`,
      END: "VCALENDAR"
    }, eventConfig = {
      BEGIN: "VEVENT",
      UID: this.id + "@bryntum.com",
      CLASS: "PUBLIC",
      SUMMARY: this.name,
      DTSTAMP: timestamp,
      ...startEnd,
      ...this.recurrenceRule ? { RRULE: this.recurrenceRule } : {},
      ...icsEventConfig,
      END: "VEVENT"
    }, icsItems = Object.keys(icsWrapConfig).map((key) => `${key}:${icsWrapConfig[key]}`), eventItems = Object.keys(eventConfig).map((key) => `${key}:${eventConfig[key]}`);
    icsItems.splice(icsItems.length - 1, 0, ...eventItems);
    return icsItems.join("\n");
  }
  /**
   * Triggers a download of this time span in ICS format (for import in Outlook etc.)
   *
   * ```javascript
   * timeSpan.downloadAsICS({
   *      LOCATION : timeSpan.location
   *  });
   * ```
   * @param {Object<String,String>} [icsEventConfig] A config object with properties to be added in to `BEGIN:VEVENT`
   * section of the exported event.
   * @category Misc
   */
  exportToICS(icsEventConfig) {
    if (this.isScheduled) {
      const blob = new Blob([this.toICSString(icsEventConfig)], { type: "text/calendar" });
      BrowserHelper.downloadBlob(blob, (this.name || "Event") + ".ics");
    }
  }
  /**
   * Defines if the given event field should be manually editable in UI.
   * You can override this method to provide your own logic.
   *
   * By default the method defines all the event fields as editable.
   *
   * @param {String} fieldName Name of the field
   * @returns {Boolean} Returns `true` if the field is editable, `false` if it is not and `undefined` if the model has no such field.
   */
  isEditable(fieldName) {
    return this.getFieldDefinition(fieldName) ? true : void 0;
  }
  isFieldModified(fieldName) {
    if (fieldName === "fullDuration") {
      return super.isFieldModified("duration") || super.isFieldModified("durationUnit");
    }
    return super.isFieldModified(fieldName);
  }
};
__publicField(TimeSpan, "$name", "TimeSpan");
//region Field definitions
__publicField(TimeSpan, "fields", [
  /**
   * The start date of a time span (or Event / Task).
   *
   * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a
   * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and
   * change the dateFormat for this field.
   *
   * Note that the field always returns a `Date`.
   *
   * @field {Date} startDate
   * @accepts {String|Date}
   * @category Scheduling
   */
  {
    name: "startDate",
    type: "date"
  },
  /**
   * The end date of a time span (or Event / Task).
   *
   * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a
   * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and
   * change the dateFormat for this field.
   *
   * Note that the field always returns a `Date`.
   *
   * @field {Date} endDate
   * @accepts {String|Date}
   * @category Scheduling
   */
  {
    name: "endDate",
    type: "date"
  },
  /**
   * The numeric part of the timespan's duration (the number of units).
   * @field {Number} duration
   * @category Scheduling
   */
  {
    name: "duration",
    type: "number",
    allowNull: true,
    internal: true
  },
  /**
   * The unit part of the TimeSpan duration, defaults to "d" (days). Valid values are:
   *
   * - "millisecond" - Milliseconds
   * - "second" - Seconds
   * - "minute" - Minutes
   * - "hour" - Hours
   * - "day" - Days
   * - "week" - Weeks
   * - "month" - Months
   * - "quarter" - Quarters
   * - "year"- Years
   *
   * This field is readonly after creation, to change durationUnit use #setDuration().
   * @field {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'} durationUnit
   * @category Scheduling
   */
  {
    type: "durationunit",
    name: "durationUnit",
    defaultValue: "d",
    internal: true
  },
  /**
   * Calculated field which encapsulates the duration's magnitude and unit. This field will not be persisted,
   * setting it will update the {@link #field-duration} and {@link #field-durationUnit} fields.
   *
   * @field {DurationConfig|Core.data.Duration} fullDuration
   * @category Scheduling
   */
  {
    name: "fullDuration",
    persist: false,
    column: {
      type: "duration"
    },
    useProp: true
  },
  /**
   * An encapsulation of the CSS classes to add to the rendered time span element.
   *
   * Always returns a {@link Core.helper.util.DomClassList}, but may still be treated as a string. For
   * granular control of adding and removing individual classes, it is recommended to use the
   * {@link Core.helper.util.DomClassList} API.
   *
   * @field {Core.helper.util.DomClassList} cls
   * @accepts {Core.helper.util.DomClassList|String|String[]|Object}
   *
   * @category Styling
   */
  {
    name: "cls",
    defaultValue: "",
    internal: true
  },
  /**
   * CSS class specifying an icon to apply to the rendered time span element.
   * **Note**: In case event is a milestone, using `iconCls` with dependency feature might slightly decrease
   * performance because feature will refer to the DOM to get exact size of the element.
   * @field {String} iconCls
   * @category Styling
   */
  {
    name: "iconCls",
    internal: true
  },
  /**
   * A CSS style string (applied to `style.cssText`) or object (applied to `style`)
   * ```
   * record.style = 'color: red;font-weight: 800';
   * ```
   *
   * @field {String} style
   * @category Styling
   */
  {
    name: "style",
    type: "object",
    internal: true
  },
  /**
   * The name of the time span (or Event / Task)
   * @field {String} name
   * @category Common
   */
  {
    name: "name",
    type: "string",
    defaultValue: ""
  }
]);
TimeSpan._$name = "TimeSpan";

// ../Scheduler/lib/Scheduler/data/util/recurrence/RecurrenceDayRuleEncoder.js
var dayParseRegExp = /^([+-]?[0-9])?(SU|MO|TU|WE|TH|FR|SA)$/;
var days = ["SU", "MO", "TU", "WE", "TH", "FR", "SA"];
var RecurrenceDayRuleEncoder = class extends Base {
  static decodeDay(rawDay) {
    let parsedDay, result;
    if (parsedDay = dayParseRegExp.exec(rawDay)) {
      result = [days.indexOf(parsedDay[2])];
      if (parsedDay[1]) {
        parsedDay[1] = parseInt(parsedDay[1], 10);
        result.push(parsedDay[1]);
      }
    }
    return result;
  }
  static encodeDay(day2) {
    let position;
    if (Array.isArray(day2)) {
      [day2, position] = day2;
    }
    return (position ? position.toString() : "") + days[day2];
  }
  // Turns days values provided as an array of strings (like [`-1MO`, `SU`, `+3FR`])
  // into an array of [ dayIndex, position ] elements, where:
  //
  // - `dayIndex` - zero-based week day index value (0 - Sunday, 1 - Monday, 2 - Tuesday, etc.)
  // - `position` - (optional) 1-based position of the day (integer value (can be both positive and negative))
  static decode(rawDays) {
    const result = [];
    let parsedDay;
    if (rawDays) {
      for (let i = 0; i < rawDays.length; i++) {
        if (parsedDay = this.decodeDay(rawDays[i])) {
          result.push(parsedDay);
        }
      }
    }
    return result;
  }
  static encode(days2) {
    const result = [];
    let day2;
    if (days2) {
      for (let i = 0; i < days2.length; i++) {
        if (day2 = this.encodeDay(days2[i])) {
          result.push(day2);
        }
      }
    }
    return result;
  }
};
RecurrenceDayRuleEncoder._$name = "RecurrenceDayRuleEncoder";

// ../Scheduler/lib/Scheduler/data/util/recurrence/AbstractRecurrenceIterator.js
var frequencyToUnitRe = /ly$/i;
var frequencyToUnit = (frequency) => {
  const result = frequency.replace(frequencyToUnitRe, "");
  return result === "DAI" ? "DAY" : result;
};
var fn = (date, counter, isFirst, timeSpan) => timeSpan.buildOccurrence(date, isFirst);
var captureLastOccurrence = (date) => lastOccurrenceDate = date;
var lastOccurrenceDate;
var AbstractRecurrenceIterator = class extends Base {
  static processIterationConfig(config) {
    const { recurrence } = config, {
      frequency,
      interval,
      timeSpan,
      endDate: until,
      count
    } = recurrence;
    if (!config.syncingStartDate && !timeSpan.meta.isSyncedWithRule) {
      const intervalEndDate = DateHelper.add(timeSpan.startDate, interval, frequencyToUnit(frequency)), endDate2 = DateHelper.min(
        intervalEndDate,
        config.endDate || intervalEndDate
      );
      this.forEachDate({
        syncingStartDate: true,
        startDate: timeSpan.startDate,
        endDate: endDate2,
        recurrence,
        fn
      });
    }
    const timeSpanStart = timeSpan.startDate;
    let {
      startDate = timeSpanStart,
      endDate = until
    } = config;
    if (startDate < timeSpanStart) {
      startDate = timeSpanStart;
    }
    if (until) {
      if (!endDate || endDate > until) {
        endDate = until;
      }
    } else if (count && startDate > timeSpanStart) {
      this.forEachDate({
        recurrence,
        fn: captureLastOccurrence
      });
      if (!endDate || endDate > lastOccurrenceDate) {
        endDate = new Date(lastOccurrenceDate.getTime() + 1);
      }
    }
    const earliestVisibleDate = startDate;
    if (!config.startOnly) {
      startDate = new Date(DateHelper.max(DateHelper.add(startDate, -interval, frequencyToUnit(frequency)), timeSpanStart));
    }
    return Object.assign({
      extraArgs: [],
      // Only check start date for time spans with 0 duration
      startOnly: !Boolean(timeSpan.durationMS)
    }, config, {
      startDate,
      endDate,
      timeSpan,
      timeSpanStart,
      earliestVisibleDate,
      endDateMS: endDate == null ? void 0 : endDate.getTime(),
      timeSpanStartMS: timeSpanStart.getTime(),
      earliestVisibleDateMS: earliestVisibleDate.getTime(),
      durationMS: timeSpan.durationMS,
      spansStart: startDate <= timeSpanStart && endDate > timeSpanStart
    });
  }
  static getOccurrenceIndex(event) {
    if (event.isOccurrence) {
      return DateHelper.diff(event.recurringTimeSpan.startDate, event.startDate, frequencyToUnit(event.recurringTimeSpan.recurrence.frequency));
    }
  }
  /**
   * Returns Nth occurrence of a week day in the provided period of time.
   * @param  {Date} startDate Period start date.
   * @param  {Date} endDate   Period end date.
   * @param  {Number} day    Week day (0 - Sunday, 1 - Monday, 2 - Tuesday, etc.)
   * @param  {Number} index  Index to find.
   * @returns {Date}           Returns the found date or null if there is no `index`th entry.
   * @private
   */
  static getNthDayInPeriod(startDate, endDate, day2, index) {
    let result, sign, borderDate;
    if (index) {
      if (index > 0) {
        sign = 1;
        borderDate = startDate;
      } else {
        sign = -1;
        borderDate = endDate;
      }
      const delta = day2 - borderDate.getDay();
      if (sign * delta < 0) {
        index += sign;
      }
      result = new Date(borderDate);
      result.setDate(borderDate.getDate() + (index - sign) * 7 + delta);
      if (result < startDate || result > endDate) {
        result = null;
      }
    }
    return result;
  }
  static buildDate(year, month2, date) {
    const dt = new Date(year, month2, date);
    if (dt.getFullYear() === year && dt.getMonth() === month2 && dt.getDate() === date) {
      return dt;
    }
  }
  static isValidPosition(position) {
    return Boolean(position);
  }
  static forEachDateAtPositions(dates, positions, fn2, scope) {
    const datesLength = dates.length, processed = {};
    for (let i = 0; i < positions.length; i++) {
      const index = positions[i];
      if (this.isValidPosition(index)) {
        const date = index > 0 ? dates[index - 1] : dates[datesLength + index];
        if (date && !processed[date.getTime()]) {
          processed[date.getTime()] = true;
          if (fn2.call(scope, date) === false) {
            return false;
          }
        }
      }
    }
  }
  static isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan) {
    return (startOnly ? occurrenceDate >= earliestVisibleDate : occurrenceDate.valueOf() + durationMS > earliestVisibleDate) && !timeSpan.hasException(occurrenceDate);
  }
  // Slightly faster version of ^, used by Daily & Weekly iterators
  static isInViewMS(startOnly, occurenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan) {
    return (startOnly ? occurrenceDateMS >= earliestVisibleDateMS : occurrenceDateMS + durationMS > earliestVisibleDateMS) && !timeSpan.hasException(occurenceDate);
  }
};
__publicField(AbstractRecurrenceIterator, "frequency", "NONE");
__publicField(AbstractRecurrenceIterator, "MAX_OCCURRENCES_COUNT", 1e6);
AbstractRecurrenceIterator._$name = "AbstractRecurrenceIterator";

// ../Scheduler/lib/Scheduler/data/util/recurrence/DailyRecurrenceIterator.js
var DailyRecurrenceIterator = class extends AbstractRecurrenceIterator {
  /**
   * Iterates over the passed date range, calling the passed callback on each date on which
   * starts a recurring event which matches the passed recurrence rule and overlaps the start and end dates
   * and is not an {@link Scheduler.model.mixin.RecurringTimeSpan#field-exceptionDates exceptionDate}
   * in the recurring event.
   * @param {Object} config An object which describes how to iterate.
   * @param {Date} config.startDate The point in time to begin iteration.
   * @param {Date} config.endDate The point in time to end iteration.
   * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range
   * will be visited. Pass `true` to only visit occurrences which *start* in the date range.
   * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.
   * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.
   * @param {Date} config.fn.date The occurrence date.
   * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.
   * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.
   * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.
   */
  static forEachDate(config) {
    const {
      startOnly,
      startDate,
      endDate,
      endDateMS,
      timeSpan,
      timeSpanStart,
      earliestVisibleDateMS,
      durationMS,
      spansStart,
      recurrence,
      fn: fn2,
      extraArgs,
      scope = this
    } = this.processIterationConfig(config), { interval } = recurrence, delay2 = startDate - timeSpanStart, intervalDuration = interval * 864e5, delayInIntervals = Math.floor(delay2 / intervalDuration);
    let { count } = recurrence, counter = 0, occurrenceDate = DateHelper.add(timeSpanStart, delayInIntervals * interval, "day"), occurrenceDateMS = occurrenceDate.getTime();
    if (!endDate && !count) {
      count = this.MAX_OCCURRENCES_COUNT;
    }
    while (!endDateMS || occurrenceDateMS < endDateMS) {
      const inView = this.isInViewMS(startOnly, occurrenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan);
      counter++;
      if (inView && (endDateMS && occurrenceDateMS > endDateMS || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
        break;
      }
      occurrenceDate = DateHelper.add(occurrenceDate, interval, "day");
      occurrenceDateMS = occurrenceDate.getTime();
    }
  }
};
__publicField(DailyRecurrenceIterator, "frequency", "DAILY");
DailyRecurrenceIterator._$name = "DailyRecurrenceIterator";

// ../Scheduler/lib/Scheduler/data/util/recurrence/WeeklyRecurrenceIterator.js
var WeeklyRecurrenceIterator = class extends AbstractRecurrenceIterator {
  /**
   * Iterates over the passed date range, calling the passed callback on each date on which
   * starts an event which matches the passed recurrence rule and overlaps the start and end dates.
   * @param {Object} config An object which describes how to iterate.
   * @param {Date} config.startDate The point in time to begin iteration.
   * @param {Date} config.endDate The point in time to end iteration.
   * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range
   * will be visited. Pass `true` to only visit occurrences which *start* in the date range.
   * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.
   * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.
   * @param {Date} config.fn.date The occurrence date.
   * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.
   * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.
   * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.
   */
  static forEachDate(config) {
    const {
      startOnly,
      startDate,
      endDateMS,
      timeSpan,
      timeSpanStart,
      timeSpanStartMS,
      earliestVisibleDateMS,
      durationMS,
      spansStart,
      recurrence,
      fn: fn2,
      extraArgs,
      scope = this
    } = this.processIterationConfig(config), {
      interval,
      days: days2
    } = recurrence, { weekStartDay } = DateHelper, startHours = timeSpanStart.getHours(), startMinutes = timeSpanStart.getMinutes(), startSeconds = timeSpanStart.getSeconds(), startMS = timeSpanStart.getMilliseconds();
    let counter = 0, { count } = recurrence, weekDays = RecurrenceDayRuleEncoder.decode(days2), weekStartDate, occurrenceDate;
    if (!(weekDays == null ? void 0 : weekDays.length)) {
      weekDays = [[timeSpanStart.getDay()]];
    }
    if (weekStartDay > 0) {
      for (let i = 0; i < weekDays.length; i++) {
        if (weekStartDay > weekDays[i][0]) {
          weekDays[i][0] = 7 - weekStartDay - weekDays[i][0];
        } else {
          weekDays[i][0] -= weekStartDay;
        }
      }
    }
    weekDays.sort((a, b) => a[0] - b[0]);
    weekStartDate = DateHelper.getNext(count || interval > 1 ? timeSpanStart : startDate, "week", 0);
    if (!endDateMS && !count) {
      count = this.MAX_OCCURRENCES_COUNT;
    }
    while (!endDateMS || weekStartDate.getTime() < endDateMS) {
      for (let i = 0; i < weekDays.length; i++) {
        occurrenceDate = new Date(
          weekStartDate.getFullYear(),
          weekStartDate.getMonth(),
          weekStartDate.getDate() + weekDays[i][0],
          startHours,
          startMinutes,
          startSeconds,
          startMS
        );
        const occurrenceDateMS = occurrenceDate.getTime();
        if (occurrenceDateMS >= timeSpanStartMS) {
          const inView = this.isInViewMS(startOnly, occurrenceDate, occurrenceDateMS, earliestVisibleDateMS, durationMS, timeSpan);
          counter++;
          if (inView && (endDateMS && occurrenceDateMS >= endDateMS || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
            return;
          }
        }
      }
      weekStartDate = DateHelper.getNext(weekStartDate, "week", interval);
    }
  }
};
__publicField(WeeklyRecurrenceIterator, "frequency", "WEEKLY");
WeeklyRecurrenceIterator._$name = "WeeklyRecurrenceIterator";

// ../Scheduler/lib/Scheduler/data/util/recurrence/MonthlyRecurrenceIterator.js
var MonthlyRecurrenceIterator = class extends AbstractRecurrenceIterator {
  static getNthDayOfMonth(date, dayNum) {
    const daysInMonth = DateHelper.daysInMonth(date);
    let result = null;
    if (dayNum && Math.abs(dayNum) <= daysInMonth) {
      result = new Date(date.getFullYear(), date.getMonth(), dayNum < 0 ? daysInMonth + dayNum + 1 : dayNum);
    }
    return result;
  }
  static isValidPosition(position) {
    return position && Math.abs(position) > 0 && Math.abs(position) <= 31;
  }
  /**
   * Iterates over the passed date range, calling the passed callback on each date on which
   * starts an event which matches the passed recurrence rule and overlaps the start and end dates.
   * @param {Object} config An object which describes how to iterate.
   * @param {Date} config.startDate The point in time to begin iteration.
   * @param {Date} config.endDate The point in time to end iteration.
   * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range
   * will be visited. Pass `true` to only visit occurrences which *start* in the date range.
   * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.
   * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.
   * @param {Date} config.fn.date The occurrence date.
   * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.
   * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.
   * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.
   */
  static forEachDate(config) {
    const {
      startOnly,
      startDate,
      endDate,
      timeSpan,
      timeSpanStart,
      earliestVisibleDate,
      durationMS,
      spansStart,
      recurrence,
      fn: fn2,
      extraArgs,
      scope = this
    } = this.processIterationConfig(config), {
      interval,
      days: days2,
      count,
      positions
    } = recurrence, weekDays = RecurrenceDayRuleEncoder.decode(days2), hasPositions = positions && positions.length, processedDate = {};
    let { monthDays } = recurrence, counter = 0, weekDayPosition, monthStartDate, monthEndDate, dates, occurrenceDate, i;
    monthStartDate = DateHelper.startOf(count || interval > 1 ? timeSpanStart : startDate, "month");
    monthEndDate = new Date(DateHelper.getNext(monthStartDate, "month", 1) - 1);
    if (!(monthDays && monthDays.length) && !(weekDays && weekDays.length)) {
      monthDays = [timeSpanStart.getDate()];
    }
    if (weekDays && weekDays.length) {
      weekDays.forEach((day2) => {
        if (day2[1]) {
          weekDayPosition = weekDayPosition || {};
          weekDayPosition[day2[0]] = day2[1];
        }
      });
    }
    while ((!endDate || endDate > monthStartDate) && (!count || counter < count)) {
      dates = [];
      if (weekDays && weekDays.length) {
        weekDays.forEach((day2) => {
          const weekDay = day2[0];
          let from = 1, till = 53;
          if (day2[1]) {
            from = till = day2[1];
          }
          for (i = from; i <= till; i++) {
            if (occurrenceDate = this.getNthDayInPeriod(monthStartDate, monthEndDate, weekDay, i)) {
              occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);
              if (!processedDate[occurrenceDate.getTime()]) {
                processedDate[occurrenceDate.getTime()] = true;
                dates.push(occurrenceDate);
              }
            }
          }
        });
        dates.sort((a, b) => a - b);
        if (!hasPositions) {
          for (i = 0; i < dates.length; i++) {
            occurrenceDate = dates[i];
            if (occurrenceDate >= timeSpanStart) {
              const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);
              counter++;
              if (inView && (endDate && occurrenceDate >= endDate || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
                return false;
              }
            }
          }
        }
      } else {
        const sortedMonthDates = [];
        for (i = 0; i < monthDays.length; i++) {
          if ((occurrenceDate = this.getNthDayOfMonth(monthStartDate, monthDays[i])) && !processedDate[occurrenceDate.getTime()]) {
            processedDate[occurrenceDate.getTime()] = true;
            sortedMonthDates.push(occurrenceDate);
          }
        }
        sortedMonthDates.sort((a, b) => a - b);
        for (i = 0; i < sortedMonthDates.length; i++) {
          occurrenceDate = DateHelper.copyTimeValues(sortedMonthDates[i], timeSpanStart);
          if (hasPositions) {
            dates.push(occurrenceDate);
          } else if (occurrenceDate >= timeSpanStart) {
            const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);
            counter++;
            if (inView && (endDate && occurrenceDate > endDate || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
              return;
            }
          }
        }
      }
      if (hasPositions && dates.length) {
        this.forEachDateAtPositions(dates, positions, (occurrenceDate2) => {
          if (occurrenceDate2 >= timeSpanStart) {
            const inView = startOnly ? occurrenceDate2 >= earliestVisibleDate : occurrenceDate2.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate2);
            counter++;
            if (inView && (!endDate || occurrenceDate2 <= endDate) && // return false if it's time to stop recurring
            (fn2.apply(scope, [occurrenceDate2, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
              return false;
            }
          }
        });
      }
      monthStartDate = DateHelper.getNext(monthStartDate, "month", interval);
      monthEndDate = new Date(DateHelper.getNext(monthStartDate, "month", 1) - 1);
    }
  }
};
__publicField(MonthlyRecurrenceIterator, "frequency", "MONTHLY");
MonthlyRecurrenceIterator._$name = "MonthlyRecurrenceIterator";

// ../Scheduler/lib/Scheduler/data/util/recurrence/YearlyRecurrenceIterator.js
var YearlyRecurrenceIterator = class extends AbstractRecurrenceIterator {
  /**
   * Iterates over the passed date range, calling the passed callback on each date on which
   * starts an event which matches the passed recurrence rule and overlaps the start and end dates.
   * @param {Object} config An object which describes how to iterate.
   * @param {Date} config.startDate The point in time to begin iteration.
   * @param {Date} config.endDate The point in time to end iteration.
   * @param {Boolean} [config.startOnly] By default, all occurrences which intersect the date range
   * will be visited. Pass `true` to only visit occurrences which *start* in the date range.
   * @param {Scheduler.model.RecurrenceModel} config.recurrence The point in time to end iteration.
   * @param {Function} config.fn The function to call for each date which matches the recurrence in the date range.
   * @param {Date} config.fn.date The occurrence date.
   * @param {Number} config.fn.counter A counter of how many dates have been visited in this iteration.
   * @param {Boolean} config.fn.isFirst A flag which is `true` if the date is the first occurrence in the specified recurrence rule.
   * @param {Array} [config.extraArgs] Extra arguments to pass to the callback after the `isFirst` argument.
   */
  static forEachDate(config) {
    const {
      startOnly,
      startDate,
      endDate,
      timeSpan,
      timeSpanStart,
      earliestVisibleDate,
      durationMS,
      spansStart,
      recurrence,
      fn: fn2,
      extraArgs,
      scope = this
    } = this.processIterationConfig(config), {
      interval,
      days: days2,
      count,
      positions
    } = recurrence, weekDays = RecurrenceDayRuleEncoder.decode(days2), hasPositions = positions && positions.length, processedDate = {};
    let { months } = recurrence, counter = 0, i, occurrenceDate, dates, yearStartDate, yearEndDate, weekDayPosition;
    yearStartDate = DateHelper.startOf(count || interval > 1 ? timeSpanStart : startDate, "year");
    yearEndDate = new Date(DateHelper.getNext(yearStartDate, "year", 1) - 1);
    months && months.sort((a, b) => a - b);
    if (!(months && months.length) && !(weekDays && weekDays.length)) {
      months = [timeSpanStart.getMonth() + 1];
    }
    if (weekDays && weekDays.length) {
      weekDays.forEach((day2) => {
        if (day2[1]) {
          weekDayPosition = weekDayPosition || {};
          weekDayPosition[day2[0]] = day2[1];
        }
      });
    }
    while ((!endDate || endDate > yearStartDate) && (!count || counter < count)) {
      dates = [];
      if (weekDays && weekDays.length) {
        weekDays.forEach((day2) => {
          const weekDay = day2[0];
          let from = 1, till = 53;
          if (day2[1]) {
            from = till = day2[1];
          }
          for (i = from; i <= till; i++) {
            if (occurrenceDate = this.getNthDayInPeriod(yearStartDate, yearEndDate, weekDay, i)) {
              occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);
              if (!processedDate[occurrenceDate.getTime()]) {
                processedDate[occurrenceDate.getTime()] = true;
                dates.push(occurrenceDate);
              }
            }
          }
        });
        dates.sort((a, b) => a - b);
        if (!hasPositions) {
          for (i = 0; i < dates.length; i++) {
            occurrenceDate = dates[i];
            if (occurrenceDate >= timeSpanStart) {
              const inView = this.isInView(startOnly, occurrenceDate, earliestVisibleDate, durationMS, timeSpan);
              counter++;
              if (inView && (endDate && occurrenceDate >= endDate || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
                return;
              }
            }
          }
        }
      } else {
        for (i = 0; i < months.length; i++) {
          if (occurrenceDate = this.buildDate(yearStartDate.getFullYear(), months[i] - 1, timeSpanStart.getDate())) {
            occurrenceDate = DateHelper.copyTimeValues(occurrenceDate, timeSpanStart);
            if (!processedDate[occurrenceDate.getTime()]) {
              processedDate[occurrenceDate.getTime()] = true;
              if (hasPositions) {
                dates.push(occurrenceDate);
              } else if (occurrenceDate >= timeSpanStart) {
                const inView = startOnly ? occurrenceDate >= earliestVisibleDate : occurrenceDate.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate);
                counter++;
                if (inView && (endDate && occurrenceDate >= endDate || fn2.apply(scope, [occurrenceDate, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count)) {
                  return;
                }
              }
            }
          }
        }
      }
      if (hasPositions && dates.length) {
        this.forEachDateAtPositions(dates, positions, (occurrenceDate2) => {
          if (occurrenceDate2 >= timeSpanStart) {
            const inView = startOnly ? occurrenceDate2 >= earliestVisibleDate : occurrenceDate2.valueOf() + durationMS > earliestVisibleDate && !timeSpan.hasException(occurrenceDate2);
            counter++;
            if (inView && (!endDate || occurrenceDate2 < endDate)) {
              if (fn2.apply(scope, [occurrenceDate2, counter, counter === 1 && spansStart, timeSpan, ...extraArgs]) === false || count && counter >= count) {
                return false;
              }
            }
          }
        });
      }
      yearStartDate = DateHelper.getNext(yearStartDate, "year", interval);
      yearEndDate = new Date(DateHelper.getNext(yearStartDate, "year", 1) - 1);
    }
  }
};
__publicField(YearlyRecurrenceIterator, "frequency", "YEARLY");
YearlyRecurrenceIterator._$name = "YearlyRecurrenceIterator";

// ../Scheduler/lib/Scheduler/model/RecurrenceModel.js
var recurrenceIterators = {};
[DailyRecurrenceIterator, WeeklyRecurrenceIterator, MonthlyRecurrenceIterator, YearlyRecurrenceIterator].forEach((it) => {
  recurrenceIterators[it.frequency] = it;
});
function convertStringOfIntegerItemsValue(value) {
  if (value) {
    if (typeof value == "string") {
      value = value.split(",").map((item) => parseInt(item, 10));
    }
  } else {
    value = null;
  }
  return value;
}
function convertStringOfItemsValue(value) {
  if (value) {
    if (typeof value == "string") {
      value = value.split(",");
    }
  } else {
    value = null;
  }
  return value;
}
function isEqualAsString(value1, value2) {
  return String(value1) === String(value2);
}
function convertInteger(value) {
  if (this.defaultValue && value === void 0) {
    return this.defaultValue;
  }
  if (this.allowNull && value == null) {
    return null;
  }
  value = parseInt(value);
  return isNaN(value) ? void 0 : value;
}
var RecurrenceModel = class extends Model {
  static get $name() {
    return "RecurrenceModel";
  }
  /**
   * Indicates that this is a `RecurrenceModel` class instance
   * (allows to avoid using `instanceof`).
   * @property {Boolean}
   * @readonly
   */
  get isRecurrenceModel() {
    return true;
  }
  //region Fields
  static get fields() {
    return [
      /**
       * Field defines the recurrence frequency. Supported values are: `DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY`.
       * @field {'DAILY'|'WEEKLY'|'MONTHLY'|'YEARLY'} frequency
       */
      { name: "frequency", defaultValue: "DAILY" },
      /**
       * Field defines how often the recurrence repeats.
       * For example, if the recurrence is weekly its interval is 2, then the timespan repeats every two weeks.
       * @field {Number} interval
       */
      { name: "interval", defaultValue: 1, convert: convertInteger },
      /**
       * End date of the recurrence. Specifies when the recurrence ends.
       * The value is optional, the recurrence can as well be stopped using {@link #field-count} field value.
       * @field {Date} endDate
       */
      { name: "endDate", type: "date" },
      /**
       * Specifies the number of occurrences after which the recurrence ends.
       * The value includes the associated timespan itself so values less than 2 make no sense.
       * The field is optional, the recurrence as well can be stopped using {@link #field-endDate} field value.
       * @field {Number} count
       */
      { name: "count", allowNull: true, convert: convertInteger },
      /**
       * Specifies days of the week on which the timespan should occur.
       * An array of string values `SU`, `MO`, `TU`, `WE`, `TH`, `FR`, `SA`
       * corresponding to Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, and Saturday days of the week.
       * Each value can also be preceded by a positive (+n) or negative (-n) integer.
       * If present, this indicates the nth occurrence of a specific day within the monthly or yearly recurrence.
       *
       * **Not applicable** for daily {@link #field-frequency}.
       * @field {String[]} days
       */
      {
        name: "days",
        convert: convertStringOfItemsValue,
        isEqual: isEqualAsString
      },
      /**
       * Specifies days of the month on which the timespan should occur.
       * An array of integer values (-31..-1 - +1..+31, negative values mean counting backwards from the month end).
       * **Applicable only** for monthly {@link #field-frequency}.
       * @field {Number[]} monthDays
       */
      {
        name: "monthDays",
        convert: convertStringOfIntegerItemsValue,
        isEqual: isEqualAsString
      },
      /**
       * Specifies months of the year on which the timespan should occur.
       * An array of integer values (1 - 12).
       * **Applicable only** for yearly {@link #field-frequency}.
       * @field {Number[]} months
       */
      {
        name: "months",
        convert: convertStringOfIntegerItemsValue,
        isEqual: isEqualAsString
      },
      /**
       * The positions to include in the recurrence. The values operate on a set of recurrence instances **in one interval** of the recurrence rule.
       * An array of integer values (valid values are 1 to 366 or -366 to -1, negative values mean counting backwards from the end of the built list of occurrences).
       * **Not applicable** for daily {@link #field-frequency}.
       * @field {Number} positions
       */
      {
        name: "positions",
        convert: convertStringOfIntegerItemsValue,
        isEqual: isEqualAsString
      }
    ];
  }
  get dateFormat() {
    return this._dateFormat || "YYYYMMDDTHHmmss";
  }
  set dateFormat(format2) {
    this._dateFormat = format2;
  }
  get recurrenceIterator() {
    return recurrenceIterators[this.frequency];
  }
  /**
   * The timespan this recurrence is associated with.
   * @property {Scheduler.model.TimeSpan}
   */
  get timeSpan() {
    return this._timeSpan;
  }
  set timeSpan(value) {
    this._timeSpan = value;
  }
  /**
   * The recurrence rule. A string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10) described format
   * ("RRULE" expression).
   * @property {String}
   */
  get rule() {
    const me = this, result = [];
    if (me.frequency) {
      result.push(`FREQ=${me.frequency}`);
      if (me.interval > 1) {
        result.push(`INTERVAL=${me.interval}`);
      }
      if (me.days && me.days.length) {
        result.push("BYDAY=" + me.days.join(","));
      }
      if (me.monthDays && me.monthDays.length) {
        result.push("BYMONTHDAY=" + me.monthDays.join(","));
      }
      if (me.months && me.months.length) {
        result.push("BYMONTH=" + me.months.join(","));
      }
      if (me.count) {
        result.push(`COUNT=${me.count}`);
      }
      if (me.endDate) {
        result.push("UNTIL=" + DateHelper.format(me.endDate, me.dateFormat));
      }
      if (me.positions && me.positions.length) {
        result.push("BYSETPOS=" + me.positions.join(","));
      }
    }
    return result.join(";");
  }
  set rule(rule) {
    const me = this, values = {
      frequency: null,
      interval: null,
      count: null,
      endDate: null,
      days: null,
      monthDays: null,
      months: null,
      positions: null
    };
    me.beginBatch();
    if (rule) {
      const parts = rule.split(";");
      for (let i = 0, len = parts.length; i < len; i++) {
        const part = parts[i].split("="), value = part[1];
        switch (part[0]) {
          case "FREQ":
            values.frequency = value;
            break;
          case "INTERVAL":
            values.interval = value;
            break;
          case "COUNT":
            values.count = value;
            values.until = null;
            break;
          case "UNTIL":
            if (value) {
              values.endDate = DateHelper.parse(value, me.dateFormat);
            } else {
              values.endDate = null;
            }
            values.count = null;
            break;
          case "BYDAY":
            values.days = value;
            break;
          case "BYMONTHDAY":
            values.monthDays = value;
            break;
          case "BYMONTH":
            values.months = value;
            break;
          case "BYSETPOS":
            values.positions = value;
            break;
        }
      }
    }
    me.set(values);
    if (rule) {
      me.sanitize();
    }
    me.endBatch();
  }
  construct(data = {}) {
    const me = this, { rule, timeSpan } = data;
    me._suspendedTimeSpanNotifying = 0;
    delete data.timeSpan;
    delete data.rule;
    super.construct(...arguments);
    if (rule) {
      me.suspendTimeSpanNotifying();
      me.rule = rule;
      me.resumeTimeSpanNotifying();
    }
    me.timeSpan = timeSpan;
  }
  /**
   * Iterate occurrences for the owning timespan across the specified date range. This method can be called even
   * if the timespan is not yet a member of a store, however, the occurrences returned will not be cached across
   * subsequent calls to this method.
   * @param {Date} startDate The start date of the iteration.
   * @param {Date} endDate The end date of the iteration.
   * @param {Function} fn The function to call for each occurrence.
   * @param {Scheduler.model.TimeSpan} fn.occurrence The occurrence.
   * @param {Boolean} fn.first A flag which is `true` for the first occurrence of this recurrence.
   * @param {Number} fn.counter A counter of how many dates have been visited in this iteration.
   * @param {Date} fn.date The occurrence date.
   * @internal
   */
  forEachOccurrence(startDate, endDate, fn2) {
    if (this.timeSpan.startDate) {
      this.recurrenceIterator.forEachDate({
        recurrence: this,
        startDate,
        endDate,
        fn(date, counter, first, timeSpan) {
          return fn2(timeSpan.buildOccurrence(date, first), first, counter, date);
        }
      });
    }
  }
  /**
   * Cleans up fields that do not makes sense for the current {@link #field-frequency} value.
   * @private
   */
  sanitize() {
    var _a2, _b;
    const me = this, timeSpanStartDate = (_a2 = me.timeSpan) == null ? void 0 : _a2.startDate, values = {};
    me.isSanitizing = true;
    switch (me.frequency) {
      case "DAILY":
        values.positions = null;
        values.days = null;
        values.monthDays = null;
        values.months = null;
        break;
      case "WEEKLY": {
        values.positions = null;
        values.monthDays = null;
        values.months = null;
        const { days: days2 } = me;
        if (timeSpanStartDate && (days2 == null ? void 0 : days2.length) === 1 && days2[0] === RecurrenceDayRuleEncoder.encodeDay(timeSpanStartDate.getDay())) {
          values.days = null;
        }
        break;
      }
      case "MONTHLY": {
        if ((_b = me.monthDays) == null ? void 0 : _b.length) {
          values.positions = null;
          values.days = null;
        }
        values.months = null;
        const { monthDays } = me;
        if (timeSpanStartDate && (monthDays == null ? void 0 : monthDays.length) === 1 && monthDays[0] === timeSpanStartDate.getDate()) {
          values.monthDays = null;
        }
        break;
      }
      case "YEARLY": {
        values.monthDays = null;
        const { months } = me;
        if (timeSpanStartDate && (months == null ? void 0 : months.length) === 1 && months[0] === timeSpanStartDate.getMonth() + 1) {
          values.months = null;
        }
        break;
      }
    }
    me.set(values);
    me.isSanitizing = false;
  }
  copy(...args) {
    const result = super.copy(...args);
    result.dateFormat = this.dateFormat;
    result.timeSpan = this.timeSpan;
    return result;
  }
  afterChange(toSet, wasSet, silent) {
    const result = super.afterChange(toSet, wasSet, silent), { timeSpan } = this;
    if (!this.isSanitizing) {
      this.sanitize();
    }
    if (timeSpan) {
      timeSpan.sanitizeRecurrenceData(this);
      if (!this.isTimeSpanNotifyingSuspended) {
        timeSpan.onRecurrenceChanged();
      }
    }
    return result;
  }
  set(field, value, ...args) {
    const values = typeof field === "object" ? field : { [field]: value };
    if (values.count) {
      values.endDate = null;
    } else if (values.endDate) {
      values.count = null;
    }
    super.set(values, void 0, ...args);
  }
  get isTimeSpanNotifyingSuspended() {
    return Boolean(this._suspendedTimeSpanNotifying);
  }
  suspendTimeSpanNotifying() {
    this._suspendedTimeSpanNotifying++;
  }
  resumeTimeSpanNotifying() {
    if (this._suspendedTimeSpanNotifying)
      this._suspendedTimeSpanNotifying--;
  }
};
RecurrenceModel._$name = "RecurrenceModel";

// ../Scheduler/lib/Scheduler/model/mixin/RecurringTimeSpan.js
function convertExceptionDatesValue(value) {
  const result = {}, { dateFormat } = this;
  if (value) {
    value = typeof value == "string" ? value.split(",") : ArrayHelper.asArray(value);
    value.forEach((item) => {
      if (typeof item == "string") {
        item = DateHelper.parse(item, dateFormat);
      }
      if (!isNaN(item)) {
        result[DateHelper.makeKey(item)] = 1;
      }
    });
  }
  return result;
}
function serializeExceptionDatesValue(value) {
  const result = [], { dateFormat } = this;
  for (const date in value) {
    if (value[date]) {
      result.push(DateHelper.format(DateHelper.parseKey(date), dateFormat));
    }
  }
  return result;
}
var emptyArray10 = [];
var RecurringTimeSpan_default = (Target) => class RecurringTimeSpan extends (Target || TimeSpan) {
  static get $name() {
    return "RecurringTimeSpan";
  }
  /**
   * Returns `true` if this timespan supports recurring.
   * @property {Boolean}
   * @category Recurrence
   */
  get supportsRecurring() {
    return true;
  }
  static get fields() {
    return [
      /**
       * The timespan recurrence rule. A string in [RFC-5545](https://tools.ietf.org/html/rfc5545#section-3.3.10)
       * described format ("RRULE" expression).
       * @field {String} recurrenceRule
       * @category Scheduling
       */
      {
        name: "recurrenceRule",
        internal: true
      },
      /**
       * A string (either a single date or multiple dates separated by comma) or an array of strings containing
       * the timespan exception dates. The dates that must be skipped when generating occurrences for a repeating
       * timespan. This is used to modify only individual occurrences of the timespan so the further regenerations
       * won't create another copy of this occurrence again.
       *
       * ```javascript
       * {
       *     id: 7,
       *     startDate: '2021-10-12T14:00:00',
       *     endDate: '2021-10-12T15:00:00',
       *     name: 'Lunch',
       *     resourceId: 'hotel',
       *     recurrenceRule: 'FREQ=DAILY;COUNT=5',
       *     exceptionDates: ['2021-10-14']
       * }
       * ```
       *
       * Use {@link #function-addExceptionDate} method to add an individual entry to the dates array:
       *
       * ```javascript
       * // Break the link between the occurrence and its base.
       * // This also adds the occurrence date as an exception date
       * // so that the base timespan knows that this date should be skipped when regenerating its occurrences.
       * occurrence.recurringTimeSpan = null;
       *
       * // now the occurrence is an individual record that can be changed & persisted freely
       * occurrence.setStartEndDate(new Date(2018, 6, 2), new Date(2018, 6, 3));
       * ```
       * **Note:** The dates in this field get automatically removed when the event changes its {@link Scheduler.model.TimeSpan#field-startDate start date}.
       *
       * @field {String|String[]} exceptionDates
       * @category Scheduling
       */
      {
        name: "exceptionDates",
        convert: convertExceptionDatesValue,
        serialize: serializeExceptionDatesValue,
        internal: true
      }
    ];
  }
  /**
   * Override of {@link Core/data/Model}'s method. If an {@link #property-isOccurrence}
   * is passed, it is detached from its parent recurring event. If it still has a recurrence
   * then the recurring event is changed to stop at the occurrence date. If it has no recurrence
   * an exception is added at the occurrence date.
   * @category Recurrence
   */
  remove() {
    if (this.isOccurrence) {
      const me = this, { recurringTimeSpan } = me;
      me.cancelBatch();
      recurringTimeSpan.beginBatch();
      me.detachFromRecurringEvent();
      recurringTimeSpan.endBatch();
    } else {
      return super.remove(...arguments);
    }
  }
  get eventStore() {
    var _a2, _b;
    let result = this.isOccurrence && ((_a2 = this.recurringEvent) == null ? void 0 : _a2.eventStore) || super.eventStore;
    if (!result && ((_b = this.firstStore) == null ? void 0 : _b.isRecurringTimeSpansMixin)) {
      result = this.firstStore;
    }
    return result;
  }
  /**
   * Name of the class representing the recurrence model, defaults to {@link Scheduler.model.RecurrenceModel}
   * @property {String}
   * @category Recurrence
   */
  get recurrenceModel() {
    return this._recurrenceModel || RecurrenceModel;
  }
  set recurrenceModel(model) {
    this._recurrenceModel = model;
  }
  /**
   * Sets a recurrence for the timespan with a given frequency, interval, and end.
   * @param {RecurrenceModelConfig|String|Scheduler.model.RecurrenceModel} recurrence A data object for an instance of
   * {@link Scheduler.model.RecurrenceModel}. May also be the frequency string: `DAILY`, `WEEKLY`, `MONTHLY`, or
   * `YEARLY`.
   *
   * ```javascript
   * // repeat the event every other week till Jan 2 2039
   * event.setRecurrence({
   *     frequency : "WEEKLY",
   *     interval  : 2,
   *     endDate   : new Date(2039, 0, 2)
   * });
   * ```
   *
   * Also a {@link Scheduler.model.RecurrenceModel recurrence model} can be provided as the only argument for this
   * method:
   *
   * ```javascript
   * const recurrence = new RecurrenceModel({ frequency : 'DAILY', interval : 5 });
   *
   * event.setRecurrence(recurrence);
   * ```
   *
   * or
   *
   * ```javascript
   * event.setRecurrence("WEEKLY", 2, new Date(2039, 0, 2));
   * ```
   * @param {Number} [interval] The interval between occurrences (instances of this recurrence). For example, a daily
   * recurrence with an interval of 2 occurs every other day. Must be greater than 0.
   * @param {Number|Date} [recurrenceEnd] The end of the recurrence. The value can be specified by a date or by a
   * maximum count of occurrences (has to greater than 1, since 1 means the event itself).
   * @category Recurrence
   */
  setRecurrence(recurrence, interval, recurrenceEnd) {
    const me = this;
    let recurrenceRule;
    if (recurrence) {
      if (!recurrence.isRecurrenceModel) {
        if (typeof recurrence === "string") {
          recurrence = {
            frequency: recurrence
          };
          if (interval) {
            recurrence.interval = interval;
          }
          if (recurrenceEnd) {
            if (recurrenceEnd instanceof Date) {
              recurrence.endDate = recurrenceEnd;
            } else {
              recurrence.count = recurrenceEnd;
            }
          }
        }
        recurrence = new me.recurrenceModel(recurrence);
      }
      recurrence.timeSpan = me;
      recurrenceRule = recurrence.rule;
    }
    me.recurrence = recurrence;
    me.recurrenceRule = recurrenceRule;
  }
  /**
   * The recurrence model used for the timespan.
   * @property {Scheduler.model.RecurrenceModel}
   * @category Recurrence
   */
  get recurrence() {
    const me = this, rule = me.recurrenceRule;
    if (!me._recurrence && rule) {
      me._recurrence = new me.recurrenceModel({ rule, timeSpan: me, id: `${me.id}-recurrence` });
    }
    return me._recurrence;
  }
  set recurrence(recurrence) {
    const me = this;
    me._recurrence = recurrence;
    if (recurrence) {
      recurrence.timeSpan = me;
      me.recurrenceRule = recurrence.rule;
    } else {
      if (me.isOccurrence) {
        me.setData("recurrenceRule", null);
      } else {
        me.recurrenceRule = null;
      }
    }
  }
  /**
   * Indicates if the timespan is recurring.
   * @property {Boolean}
   * @readonly
   * @category Recurrence
   */
  get isRecurring() {
    return Boolean(!this.isOccurrence && this.recurrence);
  }
  /**
   * Indicates if the timespan is an occurrence of another recurring timespan.
   * @property {Boolean}
   * @readonly
   * @category Recurrence
   */
  get isOccurrence() {
    return Boolean(this.recurringTimeSpan);
  }
  /**
   * The "main" timespan this model is an occurrence of. For non-occurrences returns `null`.
   * @property {Scheduler.model.TimeSpan}
   * @readonly
   * @internal
   * @category Recurrence
   */
  get recurringTimeSpan() {
    return this._recurringTimeSpan;
  }
  get isPersistable() {
    return super.isPersistable && (!this.supportsRecurring || !this.isOccurrence);
  }
  set recurringTimeSpan(recurringTimeSpan) {
    this._recurringTimeSpan = recurringTimeSpan;
  }
  /**
   * Returns the occurrences of this event over the specified time range. If the first
   * occurrence is in the time range `*this*` record is included in that position.
   * @param {Date} startDate The start date of the range for which to include occurrences.
   * @param {Date} [endDate] The end date of the range for which to include occurrences.
   * Defaults to the startDate.
   * @returns {Scheduler.model.TimeSpan[]} The array of occurrences which occur over the specified range.
   * @category Recurrence
   */
  getOccurrencesForDateRange(startDate, endDate = startDate) {
    return this.eventStore.getOccurrencesForTimeSpan(this, startDate, endDate);
  }
  /**
   * Array of this recurring timespan's cached occurrences. __Not including the owning recurring
   * event__.
   *
   * Empty if the timespan is not recurring.
   *
   * __Note that this is an internal accessor and is cleared whenever changes are made to the
   * owning recurring event__.
   * @property {Scheduler.model.TimeSpan[]}
   * @readonly
   * @internal
   * @category Recurrence
   */
  get occurrences() {
    if (this.isRecurring) {
      const result = [];
      this.occurrenceMap.forEach((occurrence) => {
        if (occurrence !== this) {
          result.push(occurrence);
        }
      });
      return result;
    }
    return emptyArray10;
  }
  /**
   * A Map, keyed by each date an occurrence intersects, of occurrences of this event.
   * @property {Map}
   * @readonly
   * @internal
   * @category Recurrence
   */
  get occurrenceMap() {
    return this._occurrencesMap || (this._occurrencesMap = /* @__PURE__ */ new Map());
  }
  /**
   * Removes an occurrence from this recurring timespan's cached occurrences.
   * @param dateOrTimeSpan occurrence date or occurrence TimeSpan
   * @internal
   * @category Recurrence
   */
  removeOccurrence(dateOrTimeSpan, eventStore = this.eventStore) {
    const date = dateOrTimeSpan.isTimeSpan ? dateOrTimeSpan.occurrenceDate : dateOrTimeSpan;
    eventStore == null ? void 0 : eventStore.globalOccurrences.delete(this.createRecurrenceKey(date));
    this.occurrenceMap.delete(DateHelper.makeKey(date));
  }
  /**
   * Removes all cached occurrences on or after the passed date from this recurring timespan's cached occurrences.
   * @internal
   * @category Recurrence
   */
  removeOccurrencesFrom(date) {
    this.occurrenceMap.forEach((occurrence, dateKey) => {
      if (DateHelper.parseKey(dateKey) >= date) {
        this.removeOccurrence(occurrence);
      }
    });
  }
  /**
   * Removes this recurring timespan's cached occurrences.
   * @internal
   * @category Recurrence
   */
  removeOccurrences(eventStore) {
    [this, ...this.occurrences].forEach((occurrence) => this.removeOccurrence(occurrence, eventStore));
  }
  /**
   * The method is triggered when the timespan recurrence settings get changed.
   * It updates the {@link #field-recurrenceRule} field in this case.
   * @internal
   * @category Recurrence
   */
  onRecurrenceChanged() {
    var _a2;
    this.recurrenceRule = ((_a2 = this.recurrence) == null ? void 0 : _a2.rule) || null;
  }
  sanitizeRecurrenceData(recurrence = this.recurrence) {
    if (recurrence.endDate) {
      const endDate = DateHelper.clearTime(recurrence.endDate), { exceptionDates } = this;
      this.removeOccurrencesFrom(endDate);
      if (exceptionDates) {
        for (const dateKey in exceptionDates) {
          const exceptionDate = DateHelper.parseKey(dateKey);
          if (exceptionDate >= endDate) {
            delete exceptionDates[dateKey];
          }
        }
      }
    }
  }
  /**
   * The original {@lScheduler.model.TimeSpan#field-startDate startDate} of this event before any modifications
   * took place. Used by {@link #function-removeOccurrence} and {@link #function-detachFromRecurringEvent}
   * @internal
   * @readonly
   * @category Recurrence
   */
  get occurrenceDate() {
    var _a2;
    return ((_a2 = this.meta.modified) == null ? void 0 : _a2.startDate) || this.startDate;
  }
  /**
   * If this event is an {@link #property-isOccurrence occurrence} of a recurring event, then this
   * property yields its zero-based occurrence index in the sequence.
   * @property {Number}
   * @readonly
   * @category Recurrence
   */
  get occurrenceIndex() {
    return AbstractRecurrenceIterator.getOccurrenceIndex(this);
  }
  /**
   * Builds an occurrence of this recurring event by cloning the timespan data.
   * The method is used internally by the __RecurringTimeSpans__ mixin.
   * Override it if you need to customize the generated occurrences.
   *
   * If the date requested is the start date of the event sequence, `this`
   * record is returned. All runs of recurring events begin with the base record.
   * @param  {Date} occurrenceDate The occurrence start date.
   * @param  {Boolean} isFirst `true` if this is the first occurrence.
   * @returns {Scheduler.model.TimeSpan} The occurrence.
   * @internal
   * @category Recurrence
   */
  buildOccurrence(occurrenceDate, isFirst) {
    var _a2;
    const me = this, {
      occurrenceMap,
      recurrence,
      meta
    } = me, globalOccurrences = (_a2 = me.eventStore) == null ? void 0 : _a2.globalOccurrences, occurrenceKey = DateHelper.makeKey(occurrenceDate), id = me.createRecurrenceKey(occurrenceDate, occurrenceKey), onStartDate = !(occurrenceDate - me.startDate), { fieldMap } = me.constructor;
    let occurrence = globalOccurrences == null ? void 0 : globalOccurrences.get(id), { duration } = me;
    if (me.endDate && (me.allDay || !duration)) {
      duration = DateHelper.as(me.durationUnit, me.endDate.getTime() - me.startDate.getTime());
    }
    const occurrenceEndDate = duration !== void 0 ? DateHelper.add(occurrenceDate, duration, me.durationUnit) : void 0;
    if (!occurrence) {
      if (isFirst || onStartDate) {
        occurrence = me;
        if (!onStartDate) {
          me.setStartEndDate(occurrenceDate, occurrenceEndDate, true);
          recurrence.suspendTimeSpanNotifying();
          recurrence.sanitize();
          recurrence.resumeTimeSpanNotifying();
        }
        meta.isSyncedWithRule = true;
      } else {
        occurrence = me.copy(
          {
            [fieldMap.id.dataSource]: id,
            [fieldMap.startDate.dataSource]: occurrenceDate,
            [fieldMap.endDate.dataSource]: occurrenceEndDate,
            [fieldMap.duration.dataSource]: duration,
            constraintDate: null,
            constraintType: null
          },
          { creatingOccurrence: true }
        );
        occurrence.recurringTimeSpan = me;
      }
      globalOccurrences == null ? void 0 : globalOccurrences.set(id, occurrence);
      occurrenceMap.set(occurrenceKey, occurrence);
    }
    return occurrence;
  }
  createRecurrenceKey(date = this.startDate, dateKey = null) {
    return `_generated:${this.id}:${dateKey || DateHelper.makeKey(date)}`;
  }
  // Converts this occurrence to a new "master" event
  convertToRealEvent(wasSet, silent) {
    var _a2;
    if (!this.isOccurrence) {
      return;
    }
    const me = this, {
      recurringTimeSpan,
      resource,
      occurrenceIndex,
      recurrence
    } = me, count = recurrence && recurringTimeSpan.recurrence.count, newResource = ((_a2 = wasSet == null ? void 0 : wasSet.resourceRecords) == null ? void 0 : _a2.value) || me.data.newResource;
    recurringTimeSpan.beginBatch();
    me.detachFromRecurringEvent();
    me.clearChanges();
    me.setData("id", me.generateId(recurringTimeSpan.eventStore));
    if (newResource) {
      delete me.data.resourceId;
    }
    recurringTimeSpan.eventStore.add(me, silent);
    if (count) {
      me.recurrence.count = count - occurrenceIndex;
    }
    if (newResource || resource) {
      me.assign(newResource || resource);
    }
    if (newResource) {
      delete me.data.resourceRecords;
    }
    if (wasSet) {
      delete wasSet.resourceRecords;
    }
    recurringTimeSpan.endBatch();
  }
  afterChange(toSet, wasSet, silent, ...args) {
    const me = this, { eventStore } = me;
    if ("recurrenceRule" in wasSet) {
      me._recurrence = null;
      eventStore == null ? void 0 : eventStore.recurringEvents[wasSet.recurrenceRule.value ? "add" : "delete"](me);
    }
    if (me.isOccurrence) {
      me.convertToRealEvent(wasSet, silent);
    } else if ("newExceptionDate" in wasSet) {
      me.meta.modified.exceptionDates = true;
      delete me.meta.modified.newExceptionDate;
      me.removeOccurrence(wasSet.newExceptionDate.value);
    }
    return super.afterChange(toSet, wasSet, silent, ...args);
  }
  /**
   * Detaches an occurrence from its owning recurring event so that it can be added to the eventStore
   * either as an exception, or as the start of a new recurring sequence.
   * @internal
   * @category Recurrence
   */
  detachFromRecurringEvent() {
    const me = this, { recurringTimeSpan, occurrenceDate, startDate } = me;
    me.recurringTimeSpan = null;
    recurringTimeSpan.addExceptionDate(occurrenceDate);
    if (me.recurrenceRule) {
      recurringTimeSpan.recurrence.endDate = DateHelper.add(startDate, -1, "minute");
    }
  }
  /**
   * The setter used by Model#inSet when {@link #function-addExceptionDate} is called.
   * Adding an exception must trigger change processing in a recurring event, so it must
   * be changed through a {@link Core.data.Model#function-set} call. Also, the change must be batchable
   * with other changes.
   * @private
   * @readonly
   * @category Recurrence
   */
  set newExceptionDate(date) {
    if (date) {
      const exceptionDates = this.exceptionDates || (this.exceptionDates = {});
      exceptionDates[DateHelper.makeKey(date)] = 1;
    }
  }
  /**
   * Adds an exception date that should be skipped when generating occurrences for the timespan.
   * The methods adds an entry to the array kept in {@link #field-exceptionDates} field.
   * @param {Date} date Exception date.
   * @internal
   * @category Recurrence
   */
  addExceptionDate(newExceptionDate) {
    return this.set({
      newExceptionDate
    });
  }
  /**
   * Does this recurring event have an exception on the passed date.
   * @param {Date} date The date to find an exception for.
   * @returns {Boolean} `true` if the event has an exception starting on the passed date.
   * @category Recurrence
   */
  hasException(date) {
    var _a2;
    return (_a2 = this.exceptionDates) == null ? void 0 : _a2[DateHelper.makeKey(date)];
  }
};

// ../Scheduler/lib/Scheduler/model/ResourceTimeRangeModel.js
var ResourceTimeRangeModel = class extends TimeSpan.mixin(RecurringTimeSpan_default) {
  get domId() {
    return `${this.constructor.domIdPrefix}-${this.id}`;
  }
  //endregion
  // Used internally to differentiate between Event and ResourceTimeRange
  get isResourceTimeRange() {
    return true;
  }
  // To match EventModel API
  get resources() {
    return this.resource ? [this.resource] : [];
  }
  // To match EventModel API
  get $linkedResources() {
    return this.resources;
  }
};
__publicField(ResourceTimeRangeModel, "$name", "ResourceTimeRangeModel");
//region Fields
__publicField(ResourceTimeRangeModel, "fields", [
  /**
   * Id of the resource this time range is associated with
   * @field {String|Number} resourceId
   */
  "resourceId",
  /**
   * Controls this time range's primary color, defaults to using current themes default time range color.
   * @field {String} timeRangeColor
   */
  "timeRangeColor"
]);
__publicField(ResourceTimeRangeModel, "relations", {
  /**
   * The associated resource, retrieved using a relation to a ResourceStore determined by the value assigned
   * to `resourceId`. The relation also lets you access all time ranges on a resource through
   * `ResourceModel#timeRanges`.
   * @member {Scheduler.model.ResourceModel} resource
   */
  resource: {
    foreignKey: "resourceId",
    foreignStore: "resourceStore",
    relatedCollectionName: "timeRanges",
    nullFieldOnRemove: true
  }
});
__publicField(ResourceTimeRangeModel, "domIdPrefix", "resourcetimerange");
ResourceTimeRangeModel._$name = "ResourceTimeRangeModel";

// ../Scheduler/lib/Scheduler/data/mixin/RecurringTimeSpansMixin.js
var emptyArray11 = Object.freeze([]);
var RecurringTimeSpansMixin_default = (Target) => class RecurringTimeSpansMixin extends (Target || Base) {
  static get $name() {
    return "RecurringTimeSpansMixin";
  }
  construct(...args) {
    const me = this;
    me.globalOccurrences = /* @__PURE__ */ new Map();
    me.recurringEvents = /* @__PURE__ */ new Set();
    super.construct(...args);
  }
  // Override to refreshRecurringEventsCache on initial load
  afterLoadData() {
    this.globalOccurrences.clear();
    this.refreshRecurringEventsCache("clear");
    this.refreshRecurringEventsCache("splice", this.storage.allValues);
    super.afterLoadData && super.afterLoadData();
  }
  /**
   * Responds to mutations of the underlying storage Collection.
   *
   * Maintain indices for fast finding of events by date.
   * @param {Object} event
   * @private
   */
  onDataChange({ action, added, removed, replaced }) {
    this.refreshRecurringEventsCache(action, added, removed, replaced);
    super.onDataChange(...arguments);
  }
  refreshRecurringEventsCache(action, added = emptyArray11, removed = emptyArray11, replaced) {
    const me = this, { recurringEvents } = me, replacedCount = replaced == null ? void 0 : replaced.length;
    switch (action) {
      case "clear":
        recurringEvents.clear();
        break;
      case "splice": {
        if (replacedCount) {
          added = added.slice();
          removed = removed.slice();
          for (let i = 0; i < replacedCount; i++) {
            removed.push(replaced[i][0]);
            added.push(replaced[i][1]);
          }
        }
        const addedCount = added.length, removedCount = removed.length;
        if (removedCount && recurringEvents.size) {
          for (let i = 0; i < removedCount; i++) {
            recurringEvents.delete(removed[i]);
          }
        }
        if (addedCount) {
          for (let i = 0; i < addedCount; i++) {
            const newEvent = added[i];
            if (newEvent.isRecurring) {
              recurringEvents.add(newEvent);
            }
          }
        }
        break;
      }
    }
  }
  getById(id) {
    let result = super.getById(id);
    if (!result) {
      result = this.globalOccurrences.get(this.modelClass.asId(id));
    }
    return result;
  }
  onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
    const isRecurrenceRelatedFieldChange = !silent && this.isRecurrenceRelatedFieldChange(record, wasSet);
    if (isRecurrenceRelatedFieldChange) {
      record.removeOccurrences();
    }
    super.onModelChange(...arguments);
    if (isRecurrenceRelatedFieldChange) {
      const event = { action: "batch", records: this.storage.values };
      this.trigger("refresh", event);
      this.trigger("change", event);
    }
  }
  /**
   * The method restricts which field modifications should trigger timespan occurrences building.
   * By default, any field change of a recurring timespan causes the rebuilding.
   * @param  {Scheduler.model.TimeSpan} timeSpan The modified timespan.
   * @param  {Object} wasSet Object containing the change set.
   * @returns {Boolean} `True` if the fields modification should trigger the timespan occurrences rebuilding.
   * @internal
   * @category Recurrence
   */
  isRecurrenceRelatedFieldChange(timeSpan, wasSet) {
    return timeSpan.isRecurring || "recurrenceRule" in wasSet;
  }
  /**
   * Builds occurrences for the provided timespan across the provided date range.
   * @private
   * @category Recurrence
   */
  getOccurrencesForTimeSpan(timeSpan, startDate, endDate) {
    const result = [];
    if (timeSpan.isRecurring) {
      timeSpan.recurrence.forEachOccurrence(startDate, endDate, (r) => result.push(r));
    }
    return result;
  }
  set data(data) {
    this.globalOccurrences.clear();
    super.data = data;
  }
  /**
   * Returns all the recurring timespans.
   * @returns {Scheduler.model.TimeSpan[]} Array of recurring events.
   * @category Recurrence
   */
  getRecurringTimeSpans() {
    return [...this.recurringEvents];
  }
};

// ../Scheduler/lib/Scheduler/data/ResourceTimeRangeStore.js
var ResourceTimeRangeStore = class extends AjaxStore.mixin(RecurringTimeSpansMixin_default) {
  static get defaultConfig() {
    return {
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 500,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 500,
      /**
       * This store should be linked to a ResourceStore to link the time ranges to resources
       * @config {Scheduler.data.ResourceStore}
       */
      resourceStore: null,
      modelClass: ResourceTimeRangeModel,
      storeId: "resourceTimeRanges"
    };
  }
  set resourceStore(store) {
    this._resourceStore = store;
    if (!this.isConfiguring) {
      this.initRelations(true);
    }
  }
  get resourceStore() {
    return this._resourceStore;
  }
  // Matching signature in EventStore to allow reusage of SchedulerStores#onInternalEventStoreChange()
  getResourcesForEvent(resourceTimeRange) {
    return [resourceTimeRange.resource];
  }
  /**
   * Get resource time ranges intersecting the specified date range for a resource.
   *
   * The result is sorted by `startDate`.
   *
   * @param {Object} options Options
   * @param {Scheduler.model.ResourceModel} options.resourceRecord Resource record
   * @param {Date} options.startDate Start date of the range
   * @param {Date} options.endDate End date of the range
   * @returns {Scheduler.model.ResourceTimeRangeModel[]}
   */
  getRanges({ resourceRecord, startDate, endDate }) {
    const rangesInDateRange = resourceRecord.timeRanges.flatMap((range) => {
      if (range.supportsRecurring) {
        return range.getOccurrencesForDateRange(startDate, endDate);
      }
      if (range.intersectsRange(startDate, endDate)) {
        return range;
      }
      return [];
    });
    return rangesInDateRange.sort((span1, span2) => span1.startDate - span2.startDate);
  }
};
__publicField(ResourceTimeRangeStore, "$name", "ResourceTimeRangeStore");
ResourceTimeRangeStore._$name = "ResourceTimeRangeStore";

// ../Scheduler/lib/Scheduler/data/plugin/StoreTimeZonePlugin.js
var StoreTimeZonePlugin = class extends InstancePlugin {
  get timeZone() {
    return this.client.project.timeZone;
  }
  // Overrides a Store's processRecord function to be able to convert records added by a dataset
  // before they are processed by the engine
  processRecord(record, isDataSet) {
    if (isDataSet || this.client.isLoadingData || record.timeZone !== void 0) {
      this.convertRecordToTimeZone(record);
    }
  }
  convertRecordToTimeZone(record, timeZone = this.timeZone) {
    var _a2, _b;
    if (record.timeZone !== timeZone) {
      record.$ignoreChange = true;
      if ((_a2 = record.baselines) == null ? void 0 : _a2.count) {
        for (const bl of record.baselines) {
          if (record.timeZone !== bl.timeZone) {
            bl.timeZone = record.timeZone;
          }
          bl.convertToTimeZone(timeZone);
        }
      }
      if ((_b = record.occurrences) == null ? void 0 : _b.length) {
        for (const o of record.occurrences) {
          if (record.timeZone !== o.timeZone) {
            o.timeZone = record.timeZone;
          }
          o.convertToTimeZone(timeZone);
        }
      }
      record.convertToTimeZone(timeZone);
      record.$ignoreChange = false;
    }
  }
  beforeSyncRecord({ record }) {
    if (record.timeZone != null) {
      record.$restoreTimeZone = record.timeZone;
      record.convertToTimeZone();
    }
  }
  afterSyncRecord({ record }) {
    if (record.$restoreTimeZone) {
      record.convertToTimeZone(record.$restoreTimeZone);
      record.$restoreTimeZone = null;
    }
  }
};
__publicField(StoreTimeZonePlugin, "$name", "storeTimeZonePlugin");
__publicField(StoreTimeZonePlugin, "pluginConfig", {
  before: ["processRecord"],
  assign: ["beforeSyncRecord", "afterSyncRecord"]
});
StoreTimeZonePlugin._$name = "StoreTimeZonePlugin";

// ../Scheduler/lib/Scheduler/model/mixin/ProjectModelTimeZoneMixin.js
var ProjectModelTimeZoneMixin_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Model) {
    get _storesWithDates() {
      return [this.taskStore, this.timeRangeStore, this.resourceTimeRangeStore].filter((s) => s);
    }
    plugStore(store) {
      if (!store.hasPlugin(StoreTimeZonePlugin)) {
        store.addPlugins(StoreTimeZonePlugin);
      }
    }
    unplugStore(store) {
      var _a3;
      (_a3 = store.plugins.storeTimeZonePlugin) == null ? void 0 : _a3.destroy();
    }
    attachStore(store) {
      super.attachStore(store);
      if (store && this.timeZone != null && this._storesWithDates.includes(store)) {
        this.plugStore(store);
        this.convertStoresToTimeZone([store]);
      }
    }
    detachStore(store) {
      super.detachStore(store);
      if (store && !store.isDestroyed && this.timeZone != null) {
        this.convertStoresToTimeZone([store], null);
        this.unplugStore(store);
      }
    }
    relayStoreChange({ source, action, records, replaced }) {
      const me = this;
      if (me.timeZone != null && me._storesWithDates.includes(source)) {
        if (["add", "replace"].includes(action)) {
          if (!(records == null ? void 0 : records.length) && (replaced == null ? void 0 : replaced.length)) {
            records = replaced;
          }
          if (records.length) {
            records.forEach((record) => record.timeZone = me.timeZone);
          }
        }
      }
    }
    convertStoresToTimeZone(stores, timeZone = this.timeZone) {
      var _a3;
      const me = this, stmAutoRecord = (_a3 = me.stm) == null ? void 0 : _a3.autoRecord;
      if (stmAutoRecord) {
        me.stm.autoRecord = false;
      }
      for (const store of stores) {
        store == null ? void 0 : store.forEach((r) => store.plugins.storeTimeZonePlugin.convertRecordToTimeZone(r, timeZone));
      }
      if (stmAutoRecord) {
        me.stmAutoRecord = stmAutoRecord;
      }
    }
    updateTimeZone(timeZone, oldTimeZone) {
      const me = this, isConfiguring = me._isConfiguringTimeZone || me.isConfiguring;
      me.trigger("beforeTimeZoneChange", {
        timeZone,
        oldTimeZone,
        isConfiguring
      });
      me.calendarManagerStore.forEach((calendar) => calendar.bumpVersion());
      me._storesWithDates.forEach((store) => me.plugStore(store));
      me.convertStoresToTimeZone(me._storesWithDates);
      if (me.startDate) {
        const startDate = oldTimeZone != null ? TimeZoneHelper.fromTimeZone(me.startDate, oldTimeZone) : me.startDate;
        me.startDate = timeZone != null ? TimeZoneHelper.toTimeZone(startDate, timeZone) : startDate;
      }
      me.ignoreRecordChanges = true;
      me.commitAsync().then(() => {
        if (!me.isDestroyed) {
          me.trigger("timeZoneChange", {
            timeZone,
            oldTimeZone,
            isConfiguring
          });
        }
        delete me._isConfiguringTimeZone;
      });
    }
  }, __publicField(_a2, "$name", "ProjectModelTimeZoneMixin"), __publicField(_a2, "configurable", {
    /**
     * Set to a IANA time zone (i.e. `Europe/Stockholm`) or a UTC offset in minutes (i.e. `-120`). This will
     * convert all events, tasks and time ranges to the specified time zone or offset. It will also affect the
     * displayed timeline's headers as well at the start and end date of it.
     *
     * There is currently no built-in time zone support in JavaScript which means that the converted dates
     * technically still are in the local system time zone, but adjusted to match the configured time zone.
     *
     * ### DST
     * If a IANA time zone is provided, there will be support for DST. But if local system time zone has DST that
     * will affect the time zone conversion at the exact hour when the local system time zone switches DST on and
     * off.
     *
     * *For example:*
     * 1. The local system time zone is `Europe/Stockholm` (which is UTC+1 or UTC+2 when DST).
     * 2. The date `2022-03-27T07:00:00Z` (which is UTC) is converted to `America/Chicago` (which is UTC-6 or UTC-5
     *    when DST).
     * 3. The converted JS date will be created from `2022-03-27T02:00:00` which is exactly the hour when
     *    `Europe/Stockholm` adds an DST hour. This has the effect that the converted date shows up incorrectly as
     *    `2022-03-27T03:00` instead.
     *
     * If a UTC offset is provided, there is no DST support at all.
     *
     * ### Editing
     * If creating new records or editing existing record dates, the dates will be interpreted as in the selected
     * time zone.
     *
     * If you want to create new records with dates that either should be interpreted as local system time zone or
     * from any other time zone, specify the {@link Scheduler.model.mixin.TimeZonedDatesMixin#field-timeZone} field
     * on the record.
     *
     * ### Saving
     * When saving or syncing data, the dates will be restored to local system time and converted to JSON
     * ISO formatted.
     *
     * @prp {String|Number} [timeZone]
     * @category Advanced
     */
    timeZone: {
      // Don't ingest the config eagerly because it relies on project being present.
      // Lazy means it waits for ingestion until timeZone property is referenced.
      $config: "lazy",
      value: null
    }
  }), _a2;
};

// ../Scheduler/lib/Scheduler/model/TimeRangeModel.js
var TimeRangeModel = class extends TimeSpan.mixin(RecurringTimeSpan_default) {
  /**
   * @hidefields children, parentId, parentIndex
   */
  afterConstruct() {
    if (!this.endDate) {
      this.endDate = this.startDate;
    }
    super.afterConstruct();
  }
};
__publicField(TimeRangeModel, "$name", "TimeRangeModel");
TimeRangeModel._$name = "TimeRangeModel";

// ../Scheduler/lib/Scheduler/data/TimeRangeStore.js
var TimeRangeStore = class extends AjaxStore.mixin(RecurringTimeSpansMixin_default) {
};
__publicField(TimeRangeStore, "$name", "TimeRangeStore");
__publicField(TimeRangeStore, "defaultConfig", {
  /**
   * CrudManager must load stores in the correct order. Lowest first.
   * @private
   */
  loadPriority: 500,
  /**
   * CrudManager must sync stores in the correct order. Lowest first.
   * @private
   */
  syncPriority: 500,
  modelClass: TimeRangeModel,
  storeId: "timeRanges"
});
TimeRangeStore._$name = "TimeRangeStore";

// ../Scheduler/lib/Scheduler/model/mixin/ProjectModelMixin.js
var ProjectModelMixin_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Model).mixin(
    ProjectModelCommon_default,
    ProjectModelTimeZoneMixin_default
  ) {
    static get $name() {
      return "ProjectModelMixin";
    }
    //region Config
    static get defaultConfig() {
      return {
        /**
         * State tracking manager instance the project relies on
         * @member {Core.data.stm.StateTrackingManager} stm
         * @category Advanced
         */
        /**
         * Configuration options to provide to the STM manager
         *
         * @config {StateTrackingManagerConfig|Core.data.stm.StateTrackingManager}
         * @category Advanced
         */
        stm: {},
        timeRangeModelClass: TimeRangeModel,
        resourceTimeRangeModelClass: ResourceTimeRangeModel,
        /**
         * The constructor to create a time range store instance with. Should be a class subclassing the
         * {@link Scheduler.data.TimeRangeStore}
         * @config {Scheduler.data.TimeRangeStore|Object}
         * @typings {typeof TimeRangeStore|object}
         * @category Models & Stores
         */
        timeRangeStoreClass: TimeRangeStore,
        /**
         * The constructor to create a resource time range store instance with. Should be a class subclassing the
         * {@link Scheduler.data.ResourceTimeRangeStore}
         * @config {Scheduler.data.ResourceTimeRangeStore|Object}
         * @typings {typeof ResourceTimeRangeStore|object}
         * @category Models & Stores
         */
        resourceTimeRangeStoreClass: ResourceTimeRangeStore,
        /**
         * The initial data, to fill the {@link #property-timeRangeStore timeRangeStore} with.
         * Should be an array of {@link Scheduler.model.TimeSpan TimeSpan} or its configuration objects.
         *
         * @config {Scheduler.model.TimeSpan[]} [timeRangesData]
         * @category Legacy inline data
         */
        /**
         * The initial data, to fill the {@link #property-resourceTimeRangeStore resourceTimeRangeStore} with.
         * Should be an array of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModel} or it's
         * configuration objects.
         *
         * @config {Scheduler.model.ResourceTimeRangeModel[]} [resourceTimeRangesData]
         * @category Legacy inline data
         */
        eventStore: {},
        assignmentStore: {},
        dependencyStore: {},
        resourceStore: {},
        timeRangesData: null,
        resourceTimeRangesData: null
      };
    }
    //endregion
    //region Properties
    /**
     * Get or set data of project stores. The returned data is identical to what
     * {@link #function-toJSON} returns:
     *
     * ```javascript
     *
     * const data = scheduler.project.inlineData;
     *
     * // data:
     * {
     *     eventsData             : [...],
     *     resourcesData          : [...],
     *     dependenciesData       : [...],
     *     assignmentsData        : [...],
     *     resourceTimeRangesData : [...],
     *     timeRangesData         : [...]
     * }
     *
     *
     * // Plug it back in later
     * scheduler.project.inlineData = data;
     * ```
     *
     * @property {Object}
     * @category Inline data
     */
    get inlineData() {
      return StringHelper.safeJsonParse(super.json);
    }
    set inlineData(inlineData) {
      this.json = inlineData;
    }
    //endregion
    //region Functions
    /**
     * Accepts a "data package" consisting of data for the projects stores, which is then loaded into the stores.
     *
     * The package can hold data for `EventStore`, `AssignmentStore`, `ResourceStore`, `DependencyStore`,
     * `TimeRangeStore` and `ResourceTimeRangeStore`. It uses the same format as when creating a project with inline
     * data:
     *
     * ```javascript
     * await project.loadInlineData({
     *     eventsData             : [...],
     *     resourcesData          : [...],
     *     assignmentsData        : [...],
     *     dependenciesData       : [...],
     *     resourceTimeRangesData : [...],
     *     timeRangesData         : [...]
     * });
     * ```
     *
     * After populating the stores it commits the project, starting its calculations. By awaiting `loadInlineData()` you
     * can be sure that project calculations are finished.
     *
     * @function loadInlineData
     * @param {Object} dataPackage A data package as described above
     * @fires load
     * @async
     * @category Inline data
     */
    /**
     * Project changes (CRUD operations to records in its stores) are automatically committed on a buffer to the
     * underlying graph based calculation engine. The engine performs it calculations async.
     *
     * By calling this function, the commit happens right away. And by awaiting it you are sure that project
     * calculations are finished and that references between records are up to date.
     *
     * The returned promise is resolved with an object. If that object has `rejectedWith` set, there has been a conflict and the calculation failed.
     *
     * ```javascript
     * // Move an event in time
     * eventStore.first.shift(1);
     *
     * // Trigger calculations directly and wait for them to finish
     * const result = await project.commitAsync();
     *
     * if (result.rejectedWith) {
     *     // there was a conflict during the scheduling
     * }
     * ```
     *
     * @async
     * @function commitAsync
     * @category Common
     */
    //endregion
    //region Init
    construct(config = {}) {
      super.construct(...arguments);
      if (config.timeRangesData) {
        this.timeRangeStore.data = config.timeRangesData;
      }
      if (config.resourceTimeRangesData) {
        this.resourceTimeRangeStore.data = config.resourceTimeRangesData;
      }
    }
    afterConstruct() {
      super.afterConstruct();
      const me = this;
      !me.timeRangeStore.stm && me.stm.addStore(me.timeRangeStore);
      !me.resourceTimeRangeStore.stm && me.stm.addStore(me.resourceTimeRangeStore);
    }
    //endregion
    //region Attaching stores
    // Attach to a store, relaying its change events
    attachStore(store) {
      if (store) {
        store.ion({
          name: store.$$name,
          change: "relayStoreChange",
          thisObj: this
        });
      }
      super.attachStore(store);
    }
    // Detach a store, stop relaying its change events
    detachStore(store) {
      if (store) {
        this.detachListeners(store.$$name);
        super.detachStore(store);
      }
    }
    relayStoreChange(event) {
      super.relayStoreChange(event);
      return this.trigger("change", { store: event.source, ...event, source: this });
    }
    updateTimeRangeStore(store, oldStore) {
      this.detachStore(oldStore);
      this.attachStore(store);
      if (oldStore) {
        oldStore.project = null;
      }
      if (store) {
        store.project = this;
      }
    }
    setTimeRangeStore(store) {
      this.timeRangeStore = store;
    }
    changeTimeRangeStore(store) {
      if (store && !store.isStore) {
        store = this.timeRangeStoreClass.new({
          modelClass: this.timeRangeModelClass
        }, store);
      }
      return store;
    }
    updateResourceTimeRangeStore(store, oldStore) {
      this.detachStore(oldStore);
      this.attachStore(store);
      if (oldStore) {
        oldStore.project = null;
      }
      if (store) {
        store.project = this;
      }
    }
    changeResourceTimeRangeStore(store) {
      if (store && !store.isStore) {
        store = this.resourceTimeRangeStoreClass.new({
          modelClass: this.resourceTimeRangeModelClass
        }, store);
      }
      return store;
    }
    setResourceTimeRangeStore(store) {
      this.resourceTimeRangeStore = store;
    }
    //endregion
    //region Inline data
    get events() {
      return this.eventStore.allRecords;
    }
    updateEvents(events) {
      this.eventStore.data = events;
    }
    get resourceTimeRanges() {
      return this.resourceTimeRangeStore.allRecords;
    }
    updateResourceTimeRanges(resourceTimeRanges) {
      this.resourceTimeRangeStore.data = resourceTimeRanges;
    }
    async loadInlineData(data) {
      this.isLoadingInlineData = true;
      if (data.resourceTimeRangesData) {
        this.resourceTimeRangeStore.data = data.resourceTimeRangesData;
      }
      if (data.timeRangesData) {
        this.timeRangeStore.data = data.timeRangesData;
      }
      return super.loadInlineData(data);
    }
    //endregion
    //region JSON
    /**
     * Returns the data from the records of the projects stores, in a format that can be consumed by `loadInlineData()`.
     *
     * Used by JSON.stringify to correctly convert this record to json.
     *
     *
     * ```javascript
     * const project = new ProjectModel({
     *     eventsData             : [...],
     *     resourcesData          : [...],
     *     assignmentsData        : [...],
     *     dependenciesData       : [...],
     *     resourceTimeRangesData : [...],
     *     timeRangesData         : [...]
     * });
     *
     * const json = project.toJSON();
     *
     * // json:
     * {
     *     eventsData             : [...],
     *     resourcesData          : [...],
     *     dependenciesData       : [...],
     *     assignmentsData        : [...],
     *     resourceTimeRangesData : [...],
     *     timeRangesData         : [...]
     * }
     * ```
     *
     * Output can be consumed by `loadInlineData()`:
     *
     * ```javascript
     * const json = project.toJSON();
     *
     * // Plug it back in later
     * project.loadInlineData(json);
     * ```
     *
     * @returns {Object}
     * @category Inline data
     */
    toJSON() {
      const me = this, result = {
        eventsData: me.eventStore.toJSON(),
        resourcesData: me.resourceStore.toJSON(),
        dependenciesData: me.dependencyStore.toJSON(),
        timeRangesData: me.timeRangeStore.toJSON(),
        resourceTimeRangesData: me.resourceTimeRangeStore.toJSON()
      };
      if (!me.eventStore.usesSingleAssignment) {
        result.assignmentsData = me.assignmentStore.toJSON();
      }
      return result;
    }
    /**
     * Get or set project data (records from its stores) as a JSON string.
     *
     * Get a JSON string:
     *
     * ```javascript
     * const project = new ProjectModel({
     *     eventsData             : [...],
     *     resourcesData          : [...],
     *     assignmentsData        : [...],
     *     dependenciesData       : [...],
     *     resourceTimeRangesData : [...],
     *     timeRangesData         : [...]
     * });
     *
     * const jsonString = project.json;
     *
     * // jsonString:
     * '{"eventsData":[...],"resourcesData":[...],...}'
     * ```
     *
     * Set a JSON string (to populate the project stores):
     *
     * ```javascript
     * project.json = '{"eventsData":[...],"resourcesData":[...],...}'
     * ```
     *
     * @property {String}
     * @category Inline data
     */
    get json() {
      return super.json;
    }
    changeJson(json) {
      if (typeof json === "string") {
        json = StringHelper.safeJsonParse(json);
      }
      return json;
    }
    updateJson(json) {
      json && this.loadInlineData(json);
    }
    //endregion
    afterChange(toSet, wasSet) {
      super.afterChange(...arguments);
      if (wasSet.calendar) {
        this.trigger("calendarChange");
      }
    }
    doDestroy() {
      this.timeRangeStore.destroy();
      this.resourceTimeRangeStore.destroy();
      super.doDestroy();
    }
  }, __publicField(_a2, "configurable", {
    /**
     * Project data as a JSON string, used to populate its stores.
     *
     * ```javascript
     * const project = new ProjectModel({
     *     json : '{"eventsData":[...],"resourcesData":[...],...}'
     * }
     * ```
     *
     * @config {String}
     * @category Inline data
     */
    json: null,
    /**
     * The {@link Core.data.Store store} holding the time ranges information.
     *
     * See also {@link Scheduler.model.TimeSpan}
     *
     * @member {Core.data.Store} timeRangeStore
     * @category Models & Stores
     */
    /**
     * A {@link Core.data.Store} instance or a config object.
     * @config {Core.data.Store|StoreConfig}
     * @category Models & Stores
     */
    timeRangeStore: {
      value: {},
      $config: "nullify"
    },
    /**
     * The {@link Scheduler.data.ResourceTimeRangeStore store} holding the resource time ranges information.
     *
     * See also {@link Scheduler.model.ResourceTimeRangeModel}
     *
     * @member {Scheduler.data.ResourceTimeRangeStore} resourceTimeRangeStore
     * @category Models & Stores
     */
    /**
     * A {@link Scheduler.data.ResourceTimeRangeStore} instance or a config object.
     * @config {Scheduler.data.ResourceTimeRangeStore|ResourceTimeRangeStoreConfig}
     * @category Models & Stores
     */
    resourceTimeRangeStore: {
      value: {},
      $config: "nullify"
    },
    // Documented in Scheduler/SchedulerPro versions of model/ProjectModel since types differ
    events: null,
    resourceTimeRanges: null
  }), _a2;
};

// ../Scheduler/lib/Scheduler/model/mixin/ProjectCurrentConfig.js
var ProjectCurrentConfig_default = (Target) => class ProjectCurrentConfig extends Target {
  // This function is not meant to be called by any code other than Base#getCurrentConfig().
  // It extracts the current configs/fields for the project, with special handling for inline data
  getCurrentConfig(options) {
    const me = this, result = super.getCurrentConfig(options);
    if (result) {
      for (const storeName of ["eventStore", "resourceStore", "assignmentStore", "dependencyStore", "timeRangeStore", "resourceTimeRangeStore"]) {
        const store = me[storeName];
        if (store) {
          if (store.count) {
            result[store.id + "Data"] = store.getInlineData(options);
          }
          const storeState = store.getCurrentConfig(options);
          if (storeState && Object.keys(storeState).length > 0) {
            result[storeName] = Object.assign(result[storeName] || {}, storeState);
          } else if (result[storeName] && Object.keys(result[storeName]).length === 0) {
            delete result[storeName];
          }
        }
      }
      if (me.taskStore.isTaskStore) {
        delete result.eventModelClass;
        delete result.eventStoreClass;
        delete result.children;
      }
      return result;
    }
  }
};

// ../Scheduler/lib/Scheduler/data/util/ModelPersistencyManager.js
var ModelPersistencyManager = class extends Base {
  // region Event attachers
  set eventStore(newEventStore) {
    const me = this;
    me.eventStoreDetacher && me.eventStoreDetacher();
    me._eventStore = newEventStore;
    if (newEventStore && newEventStore.autoCommit) {
      me.eventStoreDetacher = newEventStore.ion({
        beforecommit: me.onEventStoreBeforeSync,
        thisObj: me,
        detachable: true,
        // Just in case
        prio: 100
      });
    }
  }
  get eventStore() {
    return this._eventStore;
  }
  set resourceStore(newResourceStore) {
    const me = this;
    me.resourceStoreDetacher && me.resourceStoreDetacher();
    me._resourceStore = newResourceStore;
    if (newResourceStore && newResourceStore.autoCommit) {
      me.resourceStoreDetacher = newResourceStore.ion({
        beforecommit: me.onResourceStoreBeforeSync,
        thisObj: me,
        detachable: true,
        // Just in case
        prio: 100
      });
    }
  }
  get resourceStore() {
    return this._resourceStore;
  }
  set assignmentStore(newAssignmentStore) {
    const me = this;
    me.assignmentStoreDetacher && me.assignmentStoreDetacher();
    me._assignmentStore = newAssignmentStore;
    if (newAssignmentStore && newAssignmentStore.autoSync) {
      me.assignmentStoreDetacher = newAssignmentStore.ion({
        beforecommit: me.onAssignmentStoreBeforeSync,
        thisObj: me,
        detachable: true,
        // Just in case
        prio: 100
      });
    }
  }
  get assignmentStore() {
    return this._assignmentStore;
  }
  set dependencyStore(newDependencyStore) {
    const me = this;
    me.dependencyStoreDetacher && me.dependencyStoreDetacher();
    me._dependencyStore = newDependencyStore;
    if (newDependencyStore && newDependencyStore.autoSync) {
      me.dependencyStoreDetacher = newDependencyStore.ion({
        beforecommit: me.onDependencyStoreBeforeSync,
        thisObj: me,
        detachable: true,
        // Just in case
        prio: 100
      });
    }
  }
  get dependencyStore() {
    return this._dependencyStore;
  }
  // endregion
  // region Event handlers
  onEventStoreBeforeSync({ changes }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }
  onResourceStoreBeforeSync({ changes }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }
  onAssignmentStoreBeforeSync({ changes }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }
  onDependencyStoreBeforeSync({ changes }) {
    const me = this;
    me.removeNonPersistableRecordsToCreate(changes);
    return me.shallContinueSync(changes);
  }
  // endregion
  // region Management rules
  removeNonPersistableRecordsToCreate(changes) {
    const recordsToCreate = changes.added || [];
    let r, i;
    for (i = recordsToCreate.length - 1; i >= 0; --i) {
      r = recordsToCreate[i];
      if (!r.isPersistable) {
        recordsToCreate.splice(recordsToCreate.indexOf(r), 1);
      }
    }
    if (recordsToCreate.length === 0) {
      changes.added.length = 0;
    }
  }
  shallContinueSync(options) {
    return Boolean(options.added && options.added.length > 0 || options.modified && options.modified.length > 0 || options.removed && options.removed.length > 0);
  }
  // endregion
};
ModelPersistencyManager._$name = "ModelPersistencyManager";

// ../Scheduler/lib/Scheduler/model/mixin/EventModelMixin.js
var oneDayMS = 1e3 * 60 * 60 * 24;
var EventModelMixin_default = (Target) => class EventModelMixin extends Target {
  static get $name() {
    return "EventModelMixin";
  }
  // Flag checked by EventStore to make sure it uses a valid subclass
  static get isEventModel() {
    return true;
  }
  /**
   * Set value for the specified field(s), triggering engine calculations immediately. See
   * {@link Core.data.Model#function-set Model#set()} for arguments.
   *
   * ```javascript
   * eventRecord.set('duration', 4);
   * // eventRecord.endDate is not yet calculated
   *
   * await eventRecord.setAsync('duration', 4);
   * // eventRecord.endDate is calculated
   * ```
   *
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} [value] Value to set
   * @param {Boolean} [silent=false] Set to true to not trigger events. If event is recurring, occurrences won't be updated
   * automatically.
   * @function setAsync
   * @category Editing
   * @async
   */
  //region Fields
  static get fields() {
    return [
      /**
       * The start date of a time span (or Event / Task).
       *
       * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a
       * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and
       * change the dateFormat for this field.
       *
       * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable}
       * for details.
       *
       * Note that the field always returns a `Date`.
       *
       * Also note that modifying the `startDate` at runtime will move the event in time, without affecting its
       * duration (with reservation for other scheduling logic affecting the duration). If you want to change the
       * `startDate` and `duration`, use {@link Scheduler/model/TimeSpan#function-setStartDate} instead (passing
       * `false` as the second argument).
       *
       * @field {Date} startDate
       * @accepts {String|Date}
       * @category Scheduling
       */
      /**
       * The end date of a time span (or Event / Task).
       *
       * Uses {@link Core/helper/DateHelper#property-defaultFormat-static DateHelper.defaultFormat} to convert a
       * supplied string to a Date. To specify another format, either change that setting or subclass TimeSpan and
       * change the dateFormat for this field.
       *
       * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable} for details.
       *
       * Note that the field always returns a `Date`.
       *
       * @field {Date} endDate
       * @accepts {String|Date}
       * @category Scheduling
       */
      /**
       * The numeric part of the timespan's duration (the number of units).
       *
       * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable}
       * for details.
       *
       * @field {Number} duration
       * @category Scheduling
       */
      /**
       * Calculated field which encapsulates the duration's magnitude and unit. This field will not be persisted,
       * setting it will update the {@link #field-duration} and
       * {@link Scheduler.model.TimeSpan#field-durationUnit} fields.
       *
       * UI fields representing this data field are disabled for summary tasks. See {@link #function-isEditable}
       * for details.
       *
       * @field {DurationConfig|Core.data.Duration} fullDuration
       * @category Scheduling
       */
      /**
       * The unique identifier of a task (mandatory)
       * @field {String|Number} id
       * @category Common
       */
      /**
       * Id of the resource this event is associated with (only usable for single assignments). We recommend
       * using assignments in an AssignmentStore over this approach. Internally any Event using `resourceId`
       * will have an assignment in AssignmentStore generated.
       * @field {String|Number} resourceId
       * @category Common
       */
      {
        name: "resourceId",
        internal: true
      },
      /**
       * Ids of the resources this event is associated with (can be used for for multiple assignments).
       * Any event using `resourceIds` will have assignments in AssignmentStore generated automatically.
       * It only applies if is configured with `perist: true`.
       * ```javascript
       *   class CustomEventModel extends EventModel {
       *       static get $name() {
       *           return 'CustomEventModel';
       *       }
       *
       *       static get fields() {
       *           return [
       *               { name : 'resourceIds', persist : true }
       *           ];
       *       }
       *   };
       *
       *   const
       *       resources   = [
       *           { id : 'r1', name : 'Celia' },
       *           { id : 'r2', name : 'Lee' },
       *           { id : 'r3', name : 'Macy' },
       *           { id : 'r4', name : 'Madison' }
       *       ],
       *       events      = [
       *           {
       *               id          : 1,
       *               resourceIds : ['r1', 'r2']
       *               ...
       *           },
       *           {
       *               id          : 2,
       *               resourceIds : ['r3', 'r4']
       *               ...
       *           }
       *       ];
       *
       *   const scheduler = new Scheduler({
       *       ...
       *       eventStore : {
       *           modelClass : CustomEventModel,
       *           data       : events
       *       },
       *       ...
       *   });
       * ```
       * @field {String[]|Number[]} resourceIds
       * @category Common
       */
      {
        name: "resourceIds",
        type: "array",
        persist: false,
        internal: true
      },
      /**
       * The array of {@link Scheduler.model.ResourceModel resources} which are assigned to this event.
       * @field {Scheduler.model.ResourceModel[]} resources
       * @category Common
       */
      {
        name: "resources",
        column: {
          type: "resourceassignment"
        },
        persist: false,
        internal: true,
        useProp: true
      },
      /**
       * Specify false to prevent the event from being dragged (if EventDrag feature is used)
       * @field {Boolean} draggable
       * @default true
       * @category Interaction
       */
      {
        name: "draggable",
        type: "boolean",
        persist: false,
        defaultValue: true,
        internal: true
      },
      /**
       * Specify `false` to prevent the event from being resized (if EventResize feature is used). You can also
       * specify `'start'` or `'end'` to only allow resizing in one direction
       * @field {Boolean|String} resizable
       * @default true
       * @category Interaction
       */
      {
        name: "resizable",
        persist: false,
        defaultValue: true,
        internal: true
      },
      // true, false, 'start' or 'end'
      /**
       * A field marking event as all day(s) spanning event.
       * For example, a holiday day may be represented by a `startDate`, and the `allDay` flag.
       * @field {Boolean} allDay
       * @category Scheduling
       */
      {
        name: "allDay",
        type: "boolean",
        defaultValue: false
      },
      /**
       * Controls this events appearance, see Schedulers
       * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventStyle eventStyle config} for
       * available options.
       * @field {'plain'|'border'|'colored'|'hollow'|'line'|'dashed'|'minimal'|'rounded'|'calendar'|'interday'|null} eventStyle
       * @category Styling
       */
      {
        name: "eventStyle",
        internal: true
      },
      /**
       * Controls the primary color of the event. For available standard colors, see
       * {@link #typedef-EventColor}.
       * @field {EventColor|String|null} eventColor
       * @category Styling
       */
      {
        name: "eventColor",
        internal: true
      },
      /**
       * Width (in px) to use for this milestone when using Scheduler#milestoneLayoutMode 'data'.
       * @field {Number} milestoneWidth
       * @category Styling
       */
      {
        name: "milestoneWidth",
        internal: true
      },
      /**
       * Set this field to `false` to opt out of {@link Scheduler.feature.StickyEvents sticky event content}
       * (keeping event text in view while scrolling).
       * @field {Boolean} stickyContents
       * @category Styling
       */
      {
        name: "stickyContents",
        internal: true
      }
    ];
  }
  //endregion
  //region Id change
  updateAssignmentEventIds() {
    this.assigned.forEach((assignment) => {
      assignment.eventId = this.id;
    });
  }
  syncId(value) {
    super.syncId(value);
    this.updateAssignmentEventIds();
  }
  //endregion
  // This method is used by the `autoUpdateRecord` mode of the resource assignment field
  // here we route the resources update to the correct setter
  setValue(fieldName, value) {
    var _a2;
    if (fieldName === "resource" && !this.usesSingleAssignment) {
      this.resources = (_a2 = ArrayHelper.asArray(value)) != null ? _a2 : [];
    } else {
      return super.setValue(fieldName, value);
    }
  }
  //region Resources
  /**
   * Returns all resources assigned to an event.
   *
   * @property {Scheduler.model.ResourceModel[]}
   * @category Assignments & Resources
   * @readonly
   */
  get resources() {
    return this.assignments.reduce((resources, { resource }) => {
      resource && resources.push(resource.$original);
      return resources;
    }, []);
  }
  set resources(resources) {
    var _a2;
    resources = ArrayHelper.asArray(resources);
    const me = this, newResourceIds = resources.map(me.constructor.asId);
    if (me.usesSingleAssignment) {
      me.set("resourceId", newResourceIds[0]);
    } else if ((_a2 = me.fieldMap) == null ? void 0 : _a2.resourceIds.persist) {
      me.resourceIds = newResourceIds;
    } else {
      const existingResourceIds = me.assignments.map((a) => a.resource.id), { onlyInA: toAdd, onlyInB: toRemove } = ArrayHelper.delta(newResourceIds, existingResourceIds);
      me.assignmentStore.add(toAdd.map((resourceId) => ({ resource: resourceId, event: me })));
      me.assignmentStore.remove(toRemove.map((resourceId) => me.assignments.find((a) => a.resource.id === resourceId)));
    }
  }
  /**
   * Iterate over all associated resources
   * @private
   * @category Assignments & Resources
   */
  forEachResource(fn2, thisObj = this) {
    for (const resource of this.resources) {
      if (fn2.call(thisObj, resource) === false) {
        return;
      }
    }
  }
  /**
   * Returns either the resource associated with this event (when called w/o `resourceId`) or resource
   * with specified id.
   *
   * @param {String} [resourceId] To retrieve a specific resource
   * @returns {Scheduler.model.ResourceModel}
   * @category Assignments & Resources
   */
  getResource(resourceId) {
    if (resourceId == null) {
      return this.resource;
    }
    return this.resourceStore ? this.resourceStore.getById(resourceId) : null;
  }
  //endregion
  //region Dates
  get startDate() {
    var _a2;
    let dt;
    if (this.isOccurrence) {
      dt = this.get("startDate");
    } else {
      dt = (_a2 = this._startDate) != null ? _a2 : super.startDate;
    }
    if (this.allDay) {
      dt = this.constructor.getAllDayStartDate(dt);
    }
    return dt;
  }
  set startDate(startDate) {
    if (this.batching) {
      this._startDate = startDate;
      this.set({ startDate });
    } else {
      super.startDate = startDate;
    }
  }
  get endDate() {
    var _a2;
    let dt;
    if (this.isOccurrence) {
      dt = this.get("endDate");
    } else {
      dt = (_a2 = this._endDate) != null ? _a2 : super.endDate;
    }
    if (this.allDay) {
      dt = this.constructor.getAllDayEndDate(dt);
    }
    return dt;
  }
  set endDate(endDate) {
    if (this.batching) {
      this._endDate = endDate;
      this.set({ endDate });
    } else {
      super.endDate = endDate;
    }
  }
  // Cannot use `convert` method because it might be disabled by `useRawData : true` and we always need to calculate
  // that value
  get wrapStartDate() {
    return this.startDate;
  }
  set wrapStartDate(value) {
  }
  get wrapEndDate() {
    return this.endDate;
  }
  set wrapEndDate(value) {
  }
  /**
   * Shift the dates for the date range by the passed amount and unit
   * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} unit The unit to shift by, see {@link Core.helper.DateHelper}
   * for more information on valid formats.
   * @param {Number} amount The amount to shift
   * @returns {Promise} A promise which is resolved when shift calculations are done
   * @async
   * @method shift
   * @category Scheduling
   */
  //endregion
  //region Is
  // Used internally to differentiate between Event and ResourceTimeRange
  get isEvent() {
    return true;
  }
  /**
   * Returns true if event can be drag and dropped
   * @property {Boolean}
   * @category Editing
   */
  get isDraggable() {
    return !this.readOnly && this.draggable;
  }
  /**
   * Returns true if event can be resized, but can additionally return 'start' or 'end' indicating how this event can
   * be resized.
   *
   * Milestones and parent events (that are not manuallyScheduled) cannot be resized.
   *
   * @property {Boolean|String}
   * @readonly
   * @category Editing
   */
  get isResizable() {
    return !this.isMilestone && (!this.isParent || this.manuallyScheduled) && this.resizable;
  }
  /**
   * Returns false if the event is not persistable. By default it always is, override this getter if you need
   * custom logic.
   *
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isPersistable() {
    return super.isPersistable && !this.isCreating;
  }
  endBatch(silent, skipAccessors, triggerBeforeUpdate) {
    const me = this, wasPersistable = me.isPersistable;
    super.endBatch(silent, skipAccessors, triggerBeforeUpdate);
    if (me.isPersistable && !wasPersistable && !me.ignoreBag && me.assigned) {
      for (const assignment of me.assigned) {
        assignment.stores.forEach(
          (s) => s.updateModifiedBagForRecord(assignment)
        );
      }
    }
  }
  get isCreating() {
    return super.isCreating;
  }
  set isCreating(value) {
    var _a2, _b;
    super.isCreating = value;
    (_a2 = this.assignmentStore) == null ? void 0 : _a2.suspendAutoCommit();
    this.assignments.forEach((record) => record.isCreating = value);
    (_b = this.assignmentStore) == null ? void 0 : _b.resumeAutoCommit();
  }
  //endregion
  //region Single assignment compatibility
  get usesSingleAssignment() {
    return !this.eventStore || this.eventStore.usesSingleAssignment;
  }
  copy(...args) {
    const copy = super.copy(...args);
    if (!this.usesSingleAssignment) {
      copy.resourceId = null;
    }
    return copy;
  }
  /**
   * Override persistable getter to prevent sending resourceId when using multiple resource assignment mode
   * https://github.com/bryntum/support/issues/1345
   * @private
   */
  get persistableData() {
    const data = super.persistableData;
    if (!this.usesSingleAssignment) {
      delete data.resourceId;
    }
    return data;
  }
  /**
   * Returns the first assigned resource, or assigns a resource
   * @member {Scheduler.model.ResourceModel} resource
   * @category Assignments & Resources
   */
  get resource() {
    const { resources } = this;
    return resources.length ? resources[0] : null;
  }
  set resource(resourceRecord) {
    this.resourceId = this.constructor.asId(resourceRecord);
  }
  get resourceId() {
    var _a2;
    return this.usesSingleAssignment ? this.get("resourceId") : (_a2 = this.assignments[0]) == null ? void 0 : _a2.resourceId;
  }
  set resourceId(resourceId) {
    this.applyResourceId(resourceId);
  }
  get resourceIds() {
    var _a2, _b, _c;
    if ((_a2 = this.fieldMap) == null ? void 0 : _a2.resourceIds.persist) {
      return this.get("resourceIds");
    } else {
      return (_c = (_b = this.resources) == null ? void 0 : _b.map((r) => r.id)) != null ? _c : [];
    }
  }
  set resourceIds(ids) {
    this.set("resourceIds", ids);
  }
  // Resources + any links to any of them
  get $linkedResources() {
    var _a2, _b;
    return (_b = (_a2 = this.resources) == null ? void 0 : _a2.flatMap((resourceRecord) => [
      resourceRecord,
      ...resourceRecord.$links
    ])) != null ? _b : [];
  }
  applyResourceId(resourceId, fromApplyValue = false) {
    var _a2, _b;
    const me = this, { eventStore, assignments } = me;
    if (eventStore) {
      const assignmentStore = eventStore.assignmentStore || ((_a2 = eventStore.crudManager) == null ? void 0 : _a2.assignmentStore);
      if (resourceId != null) {
        if (!me.meta.skipEnforcingSingleAssignment) {
          eventStore.usesSingleAssignment = true;
        }
        if ((assignments == null ? void 0 : assignments.length) && resourceId !== assignments[0].resourceId) {
          const eventsSuspended = Boolean(eventStore.eventsSuspended);
          eventsSuspended && assignmentStore.suspendEvents();
          assignments[0].resource = resourceId;
          eventsSuspended && assignmentStore.resumeEvents();
        } else {
          assignmentStore.assignEventToResource(me, resourceId);
        }
      } else if (me.usesSingleAssignment || ((_b = me.resourceIds) == null ? void 0 : _b.length)) {
        assignmentStore.remove(assignments);
      }
    } else if (!fromApplyValue) {
      me.set({ resourceId });
    }
  }
  applyResourceIds(resourceIds, fromApplyValue = false) {
    var _a2;
    const me = this, { eventStore, assignments } = me;
    if (me.fieldMap["resourceIds"].persist === false) {
      return false;
    }
    resourceIds = [...new Set(resourceIds)];
    if (eventStore) {
      const assignmentStore = eventStore.assignmentStore || ((_a2 = eventStore.crudManager) == null ? void 0 : _a2.assignmentStore);
      if (resourceIds == null ? void 0 : resourceIds.length) {
        if (assignments == null ? void 0 : assignments.length) {
          const eventsSuspended = Boolean(eventStore.eventsSuspended);
          eventsSuspended && assignmentStore.suspendEvents();
          assignments.forEach((assignment) => {
            const resourceIdToUpdate = resourceIds.find((resourceId) => !assignments.some((a) => a.resourceId === resourceId));
            if (resourceIdToUpdate) {
              assignment.resource = resourceIdToUpdate;
            }
          });
          const { onlyInA: toAdd, onlyInB: toRemove } = ArrayHelper.delta(resourceIds, assignments.map((assignment) => assignment.resourceId));
          assignmentStore.add(toAdd.map((resourceId) => ({ resource: resourceId, event: me })));
          assignmentStore.remove(toRemove.map((resourceId) => assignments.find((a) => a.resource.id === resourceId)));
          eventsSuspended && assignmentStore.resumeEvents();
        } else {
          assignmentStore.add(resourceIds.map((resourceId) => ({ resource: resourceId, event: me })));
        }
      } else {
        assignmentStore.remove(assignments);
      }
    } else if (!fromApplyValue) {
      me.set({ resourceIds });
    }
  }
  // Special handling of setting resourceId and resourceIds, creates assignment
  applyValue(useProp, mapping, value, skipAccessors, field) {
    if (field && !this.meta.isAssigning) {
      const { eventStore } = this;
      switch (field.name) {
        case "resourceId":
          eventStore && (eventStore.isAssigning = true);
          this.applyResourceId(value, true);
          break;
        case "resourceIds":
          eventStore && (eventStore.isAssigning = true);
          this.applyResourceIds(value, true);
          break;
      }
      eventStore && (eventStore.isAssigning = false);
    }
    super.applyValue(useProp, mapping, value, skipAccessors, field);
  }
  //endregion
  //region Assignment
  /**
   * Returns all assignments for the event. Event must be part of the store for this method to work.
   * @property {Scheduler.model.AssignmentModel[]}
   * @readonly
   * @category Assignments & Resources
   */
  get assignments() {
    return [...this.assigned || []];
  }
  /**
   * Assigns this event to the specified resource.
   *
   * *Note:* The event must be part of an EventStore for this to work. If the EventStore uses single assignment
   * (loaded using resourceId) existing assignments will always be removed.
   *
   * @param {Scheduler.model.ResourceModel|String|Number|Scheduler.model.ResourceModel[]|String[]|Number[]} resource A new resource for this event, either as a full
   *        Resource record or an id (or an array of such).
   * @param {Boolean} [removeExistingAssignments] `true` to first remove existing assignments
   * @typings removeExistingAssignments -> {Boolean||Number}
   * @category Assignments & Resources
   * @typings async
   */
  assign(resource, removeExistingAssignments = false) {
    const { eventStore } = this;
    if (eventStore && !eventStore.usesSingleAssignment) {
      eventStore.assignEventToResource(this, resource, removeExistingAssignments);
    } else {
      this.resourceId = this.constructor.asId(resource);
      if (!eventStore) {
        this.meta.skipEnforcingSingleAssignment = true;
      }
    }
  }
  /**
   * Unassigns this event from the specified resource
   *
   * @param {Scheduler.model.ResourceModel|String|Number} [resource] The resource to unassign from.
   * @category Assignments & Resources
   * @typings async
   */
  unassign(resource, removingResource = false) {
    var _a2;
    const me = this;
    resource = me.constructor.asId(resource);
    me.meta.removingResource = removingResource;
    (_a2 = me.eventStore) == null ? void 0 : _a2.unassignEventFromResource(me, resource);
    me.meta.removingResource = null;
  }
  /**
   * Reassigns an event from an old resource to a new resource
   *
   * @param {Scheduler.model.ResourceModel|String|Number} oldResourceId A resource to unassign from or its id
   * @param {Scheduler.model.ResourceModel|String|Number} newResourceId A resource to assign to or its id
   * @category Assignments & Resources
   */
  reassign(oldResourceId, newResourceId) {
    this.eventStore && this.eventStore.reassignEventFromResourceToResource(this, oldResourceId, newResourceId);
  }
  /**
   * Returns true if this event is assigned to a certain resource.
   *
   * @param {Scheduler.model.ResourceModel|String|Number} resource The resource to query for
   * @returns {Boolean}
   * @category Assignments & Resources
   */
  isAssignedTo(resource) {
    const resourceId = this.constructor.asId(resource);
    return this.assignments.some((assignment) => assignment.resourceId === resourceId);
  }
  //endregion
  //region Dependencies
  /**
   * Returns all predecessor dependencies of this event
   *
   * @readonly
   * @property {Scheduler.model.DependencyBaseModel[]}
   * @category Dependencies
   */
  get predecessors() {
    var _a2;
    return [...(_a2 = this.incomingDeps) != null ? _a2 : []];
  }
  /**
   * Returns all successor dependencies of this event
   *
   * @readonly
   * @property {Scheduler.model.DependencyBaseModel[]}
   * @category Dependencies
   *
   */
  get successors() {
    var _a2;
    return [...(_a2 = this.outgoingDeps) != null ? _a2 : []];
  }
  get dependencies() {
    var _a2, _b;
    return [...(_a2 = this.incomingDeps) != null ? _a2 : [], ...(_b = this.outgoingDeps) != null ? _b : []];
  }
  //endregion
  normalize() {
  }
  inSetNormalize() {
  }
  /**
   * The "main" event this model is an occurrence of.
   * Returns `null` for non-occurrences.
   * @property {Scheduler.model.EventModel}
   * @alias #Scheduler.model.mixin.RecurringTimeSpan#property-recurringTimeSpan
   * @readonly
   * @category Scheduling
   */
  get recurringEvent() {
    return this.recurringTimeSpan;
  }
  /**
   * Flag which indicates that this event is an interday event. This means that it spans
   * an entire day or multiple days.
   *
   * This is essentially used by the Calendar package to determine if an event should
   * go into the all day zone of a DayView.
   *
   * @property {Boolean}
   * @readonly
   * @category Scheduling
   */
  get isInterDay() {
    const { durationMS } = this;
    if (durationMS >= oneDayMS || !durationMS && this.allDay) {
      return true;
    }
    const {
      endDate,
      startDate
    } = this, eventStartMidnight = DateHelper.clearTime(startDate);
    if (startDate && endDate) {
      eventStartMidnight.setDate(eventStartMidnight.getDate() + 1);
      return (endDate || DateHelper.add(startDate, durationMS)) > eventStartMidnight;
    }
  }
  //region All day statics
  static getAllDayStartDate(dt) {
    if (dt && dt.isEvent) {
      dt = dt.get("startDate");
    }
    if (dt) {
      dt = DateHelper.clearTime(dt, true);
    }
    return dt;
  }
  static getAllDayEndDate(dt) {
    if (dt && dt.isEvent) {
      dt = dt.get("endDate");
    }
    if (dt && (dt.getHours() > 0 || dt.getMinutes() > 0 || dt.getSeconds() > 0 || dt.getMilliseconds() > 0)) {
      dt = DateHelper.getNext(dt, "d", 1);
    }
    return dt;
  }
  static getAllDayDisplayStartDate(dt) {
    if (dt && dt.isEvent) {
      dt = dt.get("startDate");
    }
    return DateHelper.clearTime(dt, true);
  }
  static getAllDayDisplayEndDate(startDate, endDate) {
    if (startDate && startDate.isEvent) {
      endDate = startDate.get("endDate");
      startDate = startDate.get("startDate");
    }
    if (endDate) {
      startDate = this.constructor.getAllDayDisplayStartDate(startDate);
      if (DateHelper.clearTime(endDate, true).valueOf() === endDate.valueOf()) {
        endDate = DateHelper.add(endDate, DateHelper.DAY, -1);
      } else if (startDate.valueOf() !== endDate.valueOf()) {
        endDate = DateHelper.clearTime(endDate, true);
      }
    }
    return endDate;
  }
  /**
   * Defines if the given event field should be manually editable in UI.
   * You can override this method to provide your own logic.
   *
   * By default, the method defines {@link #field-endDate}, {@link #field-duration} and {@link #field-fullDuration}
   * fields editable for leaf events only (in case the event is part of a tree store) and all other fields as
   * editable.
   *
   * @param {String} fieldName Name of the field
   * @returns {Boolean} Returns `true` if the field is editable, `false` if it is not and `undefined` if the event has
   * no such field.
   * @category Editing
   */
  isEditable(fieldName) {
    switch (fieldName) {
      case "endDate":
      case "duration":
      case "fullDuration":
        return this.isLeaf;
    }
    return super.isEditable(fieldName);
  }
  //endregion
};

// ../Scheduler/lib/Scheduler/data/mixin/PartOfProject.js
var PartOfProject_default = (Target) => class PartOfProject extends (Target || Base) {
  /**
   * Returns the project this entity belongs to.
   *
   * @member {Scheduler.model.ProjectModel} project
   * @readonly
   * @category Project
   */
  /**
   * Returns the event store of the project this entity belongs to.
   *
   * @member {Scheduler.data.EventStore} eventStore
   * @readonly
   * @category Project
   */
  /**
   * Returns the dependency store of the project this entity belongs to.
   *
   * @member {Scheduler.data.DependencyStore} dependencyStore
   * @readonly
   * @category Project
   */
  /**
   * Returns the assignment store of the project this entity belongs to.
   *
   * @member {Scheduler.data.AssignmentStore} assignmentStore
   * @readonly
   * @category Project
   */
  /**
   * Returns the resource store of the project this entity belongs to.
   *
   * @member {Scheduler.data.ResourceStore} resourceStore
   * @readonly
   * @category Project
   */
  static get $name() {
    return "PartOfProject";
  }
};

// ../Scheduler/lib/Scheduler/model/EventModel.js
var EngineMixin = SchedulerCoreEvent;
var EventModel = class extends EngineMixin.derive(TimeSpan).mixin(
  RecurringTimeSpan_default,
  PartOfProject_default,
  EventModelMixin_default
) {
  static get $name() {
    return "EventModel";
  }
};
EventModel.exposeProperties();
EventModel._$name = "EventModel";

// ../Scheduler/lib/Scheduler/model/DependencyBaseModel.js
var canonicalDependencyTypes = [
  "SS",
  "SF",
  "FS",
  "FF"
];
var DependencyBaseModel = class _DependencyBaseModel extends Model {
  static get $name() {
    return "DependencyBaseModel";
  }
  /**
   * Set value for the specified field(s), triggering engine calculations immediately. See
   * {@link Core.data.Model#function-set Model#set()} for arguments.
   **
   * ```javascript
   * dependency.set('from', 2);
   * // dependency.fromEvent is not yet up to date
   *
   * await dependency.setAsync('from', 2);
   * // dependency.fromEvent is up to date
   * ```
   *
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} [value] Value to set
   * @param {Boolean} [silent=false] Set to true to not trigger events
   * automatically.
   * @function setAsync
   * @category Editing
   * @async
   */
  //region Fields
  /**
   * An enumerable object, containing names for the dependency types integer constants.
   * - 0 StartToStart
   * - 1 StartToEnd
   * - 2 EndToStart
   * - 3 EndToEnd
   * @property {Object}
   * @readonly
   * @category Dependency
   */
  static get Type() {
    return {
      StartToStart: 0,
      StartToEnd: 1,
      EndToStart: 2,
      EndToEnd: 3
    };
  }
  static get fields() {
    return [
      // 3 mandatory fields
      /**
       * From event, id of source event
       * @field {String|Number} from
       * @category Dependency
       */
      { name: "from" },
      /**
       * To event, id of target event
       * @field {String|Number} to
       * @category Dependency
       */
      { name: "to" },
      /**
       * Dependency type, see static property {@link #property-Type-static}
       * @field {Number} type=2
       * @category Dependency
       */
      { name: "type", type: "int", defaultValue: 2 },
      /**
       * CSS class to apply to lines drawn for the dependency
       * @field {String} cls
       * @category Styling
       */
      { name: "cls", defaultValue: "" },
      /**
       * Bidirectional, drawn with arrows in both directions
       * @field {Boolean} bidirectional
       * @category Dependency
       */
      { name: "bidirectional", type: "boolean" },
      /**
       * Start side on source (top, left, bottom, right)
       * @field {'top'|'left'|'bottom'|'right'} fromSide
       * @category Dependency
       */
      { name: "fromSide", type: "string" },
      /**
       * End side on target (top, left, bottom, right)
       * @field {'top'|'left'|'bottom'|'right'} toSide
       * @category Dependency
       */
      { name: "toSide", type: "string" },
      /**
       * The magnitude of this dependency's lag (the number of units).
       * @field {Number} lag
       * @category Dependency
       */
      { name: "lag", type: "number", allowNull: true, defaultValue: 0 },
      /**
       * The units of this dependency's lag, defaults to "d" (days). Valid values are:
       *
       * - "ms" (milliseconds)
       * - "s" (seconds)
       * - "m" (minutes)
       * - "h" (hours)
       * - "d" (days)
       * - "w" (weeks)
       * - "M" (months)
       * - "y" (years)
       *
       * This field is readonly after creation, to change `lagUnit` use {@link #function-setLag setLag()}.
       * @field {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} lagUnit
       * @category Dependency
       * @readonly
       */
      {
        name: "lagUnit",
        type: "string",
        defaultValue: "d"
      },
      { name: "highlighted", persist: false, internal: true }
    ];
  }
  // fromEvent/toEvent defined in CoreDependencyMixin in engine
  /**
   * Gets/sets the source event of the dependency.
   *
   * Accepts multiple formats but always returns an {@link Scheduler.model.EventModel}.
   *
   * **NOTE:** This is not a proper field but rather an alias, it will be serialized but cannot be remapped. If you
   * need to remap, consider using {@link #field-from} instead.
   *
   * @field {Scheduler.model.EventModel} fromEvent
   * @accepts {String|Number|Scheduler.model.EventModel}
   * @category Dependency
   */
  /**
   * Gets/sets the target event of the dependency.
   *
   * Accepts multiple formats but always returns an {@link Scheduler.model.EventModel}.
   *
   * **NOTE:** This is not a proper field but rather an alias, it will be serialized but cannot be remapped. If you
   * need to remap, consider using {@link #field-to} instead.
   *
   * @field {Scheduler.model.EventModel} toEvent
   * @accepts {String|Number|Scheduler.model.EventModel}
   * @category Dependency
   */
  //endregion
  //region Init
  construct(data) {
    const from = data[this.fieldMap.from.dataSource], to = data[this.fieldMap.to.dataSource];
    if (from != null) {
      data.fromEvent = from;
    }
    if (to != null) {
      data.toEvent = to;
    }
    super.construct(...arguments);
  }
  //endregion
  get eventStore() {
    var _a2;
    return this.eventStore || ((_a2 = this.unjoinedStores[0]) == null ? void 0 : _a2.eventStore);
  }
  set from(value) {
    const { fromEvent } = this;
    if ((fromEvent == null ? void 0 : fromEvent.isModel) && fromEvent.id === value) {
      this.set("from", value);
    } else {
      this.fromEvent = value;
    }
  }
  get from() {
    return this.get("from");
  }
  set to(value) {
    const { toEvent } = this;
    if ((toEvent == null ? void 0 : toEvent.isModel) && toEvent.id === value) {
      this.set("to", value);
    } else {
      this.toEvent = value;
    }
  }
  get to() {
    return this.get("to");
  }
  /**
   * Alias to dependency type, but when set resets {@link #field-fromSide} & {@link #field-toSide} to null as well.
   *
   * @property {Number}
   * @category Dependency
   */
  get hardType() {
    return this.getHardType();
  }
  set hardType(type) {
    this.setHardType(type);
  }
  /**
   * Returns dependency hard type, see {@link #property-hardType}.
   *
   * @returns {Number}
   * @category Dependency
   */
  getHardType() {
    return this.get("type");
  }
  /**
   * Sets dependency {@link #field-type} and resets {@link #field-fromSide} and {@link #field-toSide} to null.
   *
   * @param {Number} type
   * @category Dependency
   */
  setHardType(type) {
    let result;
    if (type !== this.hardType) {
      result = this.set({
        type,
        fromSide: null,
        toSide: null
      });
    }
    return result;
  }
  get lag() {
    return this.get("lag");
  }
  set lag(lag) {
    this.setLag(lag);
  }
  /**
   * Sets lag and lagUnit in one go. Only allowed way to change lagUnit, the lagUnit field is readonly after creation
   * @param {Number|String|Object} lag The lag value. May be just a numeric magnitude, or a full string descriptor eg '1d'
   * @param {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} [lagUnit] Unit for numeric lag value, see
   * {@link #field-lagUnit} for valid values
   * @category Dependency
   */
  setLag(lag, lagUnit = this.lagUnit) {
    if (arguments.length === 1) {
      if (typeof lag === "number") {
        this.lag = lag;
      } else {
        lag = DateHelper.parseDuration(lag);
        this.set({
          lag: lag.magnitude,
          lagUnit: lag.unit
        });
      }
      return;
    }
    lag = parseFloat(lag);
    this.set({
      lag,
      lagUnit
    });
  }
  getLag() {
    if (this.lag) {
      return `${this.lag < 0 ? "-" : "+"}${Math.abs(this.lag)}${DateHelper.getShortNameOfUnit(this.lagUnit)}`;
    }
    return "";
  }
  /**
   * Property which encapsulates the lag's magnitude and units. An object which contains two properties:
   * @property {Core.data.Duration}
   * @property {Number} fullLag.magnitude The magnitude of the duration
   * @property {'ms'|'s'|'m'|'h'|'d'|'w'|'M'|'y'} fullLag.unit The unit in which the duration is measured, eg
   * `'d'` for days
   * @category Dependency
   */
  get fullLag() {
    return new Duration({
      unit: this.lagUnit,
      magnitude: this.lag
    });
  }
  set fullLag(lag) {
    if (typeof lag === "string") {
      this.setLag(lag);
    } else {
      this.setLag(lag.magnitude, lag.unit);
    }
  }
  /**
   * Returns true if the linked events have been persisted (e.g. neither of them are 'phantoms')
   *
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isPersistable() {
    const me = this, { stores, unjoinedStores } = me, store = stores[0];
    let result;
    if (store) {
      const { fromEvent, toEvent } = me, crudManager = store.crudManager;
      result = fromEvent && (crudManager || !fromEvent.hasGeneratedId) && toEvent && (crudManager || !toEvent.hasGeneratedId);
    } else {
      result = Boolean(unjoinedStores[0]);
    }
    return result && super.isPersistable;
  }
  getDateRange() {
    const { fromEvent, toEvent } = this;
    if ((fromEvent == null ? void 0 : fromEvent.isScheduled) && (toEvent == null ? void 0 : toEvent.isScheduled)) {
      const Type = _DependencyBaseModel.Type;
      let sourceDate, targetDate;
      switch (this.type) {
        case Type.StartToStart:
          sourceDate = fromEvent.startDateMS;
          targetDate = toEvent.startDateMS;
          break;
        case Type.StartToEnd:
          sourceDate = fromEvent.startDateMS;
          targetDate = toEvent.endDateMS;
          break;
        case Type.EndToEnd:
          sourceDate = fromEvent.endDateMS;
          targetDate = toEvent.endDateMS;
          break;
        case Type.EndToStart:
          sourceDate = fromEvent.endDateMS;
          targetDate = toEvent.startDateMS;
          break;
        default:
          throw new Error("Invalid dependency type: " + this.type);
      }
      return {
        start: Math.min(sourceDate, targetDate),
        end: Math.max(sourceDate, targetDate)
      };
    }
    return null;
  }
  /**
   * Applies given CSS class to dependency, the value doesn't persist
   *
   * @param {String} cls
   * @category Dependency
   */
  highlight(cls) {
    var _a2, _b;
    const classes = (_b = (_a2 = this.highlighted) == null ? void 0 : _a2.split(" ")) != null ? _b : [];
    if (!classes.includes(cls)) {
      this.highlighted = classes.concat(cls).join(" ");
    }
  }
  /**
   * Removes given CSS class from dependency if applied, the value doesn't persist
   *
   * @param {String} cls
   * @category Dependency
   */
  unhighlight(cls) {
    const { highlighted } = this;
    if (highlighted) {
      const classes = highlighted.split(" "), index = classes.indexOf(cls);
      if (index >= 0) {
        classes.splice(index, 1);
        this.highlighted = classes.join(" ");
      }
    }
  }
  /**
   * Checks if the given CSS class is applied to dependency.
   *
   * @param {String} cls
   * @returns {Boolean}
   * @category Dependency
   */
  isHighlightedWith(cls) {
    return this.highlighted && this.highlighted.split(" ").includes(cls);
  }
  getConnectorString(raw) {
    const rawValue = canonicalDependencyTypes[this.type];
    if (raw) {
      return rawValue;
    }
    if (this.type === _DependencyBaseModel.Type.EndToStart) {
      return "";
    }
    return rawValue;
  }
  // getConnectorStringFromType(type, raw) {
  //     const rawValue = canonicalDependencyTypes[type];
  //
  //     if (raw) {
  //         return rawValue;
  //     }
  //
  //     // FS => empty string; it's the default
  //     if (type === DependencyBaseModel.Type.EndToStart) {
  //         return '';
  //     }
  //
  //     const locale = LocaleManager.locale;
  //
  //     // See if there is a local version of SS, SF or FF
  //     if (locale) {
  //         const localized = locale.Scheduler && locale.Scheduler[rawValue];
  //         if (localized) {
  //             return localized;
  //         }
  //     }
  //
  //     return rawValue;
  // }
  // getConnectorString(raw) {
  //     return this.getConnectorStringFromType(this.type);
  // }
  // * getConnectorStringGenerator(raw) {
  //     return this.getConnectorStringFromType(yield this.$.type);
  // }
  toString() {
    return `${this.from}${this.getConnectorString()}${this.getLag()}`;
  }
  /**
   * Returns `true` if the dependency is valid. It is considered valid if it has a valid type and both from and to
   * events are set and pointing to different events.
   *
   * @property {Boolean}
   * @typings ignore
   * @category Editing
   */
  get isValid() {
    const { fromEvent, toEvent, type } = this;
    return typeof type === "number" && fromEvent && toEvent && fromEvent !== toEvent;
  }
  get fromEventName() {
    var _a2;
    return ((_a2 = this.fromEvent) == null ? void 0 : _a2.name) || "";
  }
  get toEventName() {
    var _a2;
    return ((_a2 = this.toEvent) == null ? void 0 : _a2.name) || "";
  }
  //region STM hooks
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    var _a2;
    if (!super.shouldRecordFieldChange(fieldName, oldValue, newValue)) {
      return false;
    }
    if (fieldName === "from" || fieldName === "to" || fieldName === "fromEvent" || fieldName === "toEvent") {
      const eventStore = (_a2 = this.project) == null ? void 0 : _a2.eventStore;
      if (eventStore && eventStore.oldIdMap[oldValue] === eventStore.getById(newValue)) {
        return false;
      }
    }
    return true;
  }
  //endregion
};
DependencyBaseModel.exposeProperties();
DependencyBaseModel._$name = "DependencyBaseModel";

// ../Scheduler/lib/Scheduler/model/DependencyModel.js
var EngineMixin2 = CoreDependencyMixin;
var DependencyModel = class extends PartOfProject_default(EngineMixin2.derive(DependencyBaseModel)) {
  static get $name() {
    return "DependencyModel";
  }
  // Determines the type of dependency based on fromSide and toSide
  getTypeFromSides(fromSide, toSide, rtl) {
    const types = DependencyBaseModel.Type, startSide = rtl ? "right" : "left", endSide = rtl ? "left" : "right";
    if (fromSide === startSide) {
      return toSide === startSide ? types.StartToStart : types.StartToEnd;
    }
    return toSide === endSide ? types.EndToEnd : types.EndToStart;
  }
};
DependencyModel.exposeProperties();
DependencyModel._$name = "DependencyModel";

// ../Grid/lib/Grid/data/GridRowModel.js
var GridRowModel = class extends Model {
  static get fields() {
    return [
      /**
       * Icon for row (used automatically in tree, feel free to use it in renderer in other cases)
       * @field {String} iconCls
       * @category Styling
       */
      {
        name: "iconCls",
        internal: true
      },
      /**
       * CSS class (or several classes divided by space) to append to row elements
       * @field {String} cls
       * @category Styling
       */
      {
        name: "cls",
        internal: true
      },
      /**
       * Used by the default implementation of {@link Grid.view.GridBase#config-getRowHeight} to determine row
       * height. Set it to use another height than the default for a the records row.
       * @field {Number} rowHeight
       * @category Styling
       */
      {
        name: "rowHeight",
        internal: true
      },
      /**
       * A link to use for this record when rendered into a {@link Grid.column.TreeColumn}.
       * @field {String} href
       * @category Tree
       */
      {
        name: "href",
        internal: true
      },
      /**
       * The target to use if this tree node provides a value for the {@link #field-href} field.
       * @field {'_self'|'_blank'|'_parent'|'_top'|null} target
       * @category Tree
       */
      {
        name: "target",
        internal: true
      }
    ];
  }
};
GridRowModel.exposeProperties();
GridRowModel._$name = "GridRowModel";

// ../Scheduler/lib/Scheduler/model/mixin/ResourceModelMixin.js
var ResourceModelMixin_default = (Target) => class ResourceModelMixin extends Target {
  static get $name() {
    return "ResourceModelMixin";
  }
  // Flag checked by ResourceStore to make sure it uses a valid subclass
  static get isResourceModel() {
    return true;
  }
  /**
   * Set value for the specified field(s), triggering engine calculations immediately. See
   * {@link Core.data.Model#function-set Model#set()} for arguments.
   *
   * This does not matter much on the resource itself, but is of importance when manipulating its references:
   *
   * ```javascript
   * assignment.set('resourceId', 2);
   * // resource.assignments is not yet up to date
   *
   * await assignment.setAsync('resourceId', 2);
   * // resource.assignments is up to date
   * ```
   *
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} [value] Value to set
   * @param {Boolean} [silent=false] Set to true to not trigger events
   * automatically.
   * @function setAsync
   * @category Editing
   * @async
   */
  //region Fields
  static get fields() {
    return [
      /**
       * Unique identifier
       * @field {String|Number} id
       * @category Common
       */
      /**
       * Get or set resource name
       * @field {String} name
       * @category Common
       */
      { name: "name", type: "string", persist: true },
      /**
       * Controls the primary color used for events assigned to this resource. Can be overridden per event using
       * EventModels {@link Scheduler.model.mixin.EventModelMixin#field-eventColor eventColor config}. Also, see
       * Schedulers {@link Scheduler.view.mixin.TimelineEventRendering#config-eventColor eventColor config}.
       *
       * For available standard colors, see
       * {@link Scheduler.model.mixin.EventModelMixin#typedef-EventColor}.
       *
       * @field {EventColor} eventColor
       * @category Styling
       */
      "eventColor",
      /**
       * Controls the style used for events assigned to this resource. Can be overridden per event using
       * EventModels {@link Scheduler/model/mixin/EventModelMixin#field-eventStyle eventStyle config}. See Schedulers
       * {@link Scheduler.view.mixin.TimelineEventRendering#config-eventStyle eventStyle config} for available
       * options.
       * @field {String} eventStyle
       * @category Styling
       */
      "eventStyle",
      /**
       * Fully qualified image URL, used by `ResourceInfoColumn` and vertical modes `ResourceHeader` to display a miniature image
       * for the resource.
       * @field {String} imageUrl
       * @category Styling
       */
      "imageUrl",
      /**
       * Image name relative to {@link Scheduler/view/mixin/SchedulerEventRendering#config-resourceImagePath},
       * used by `ResourceInfoColumn` and vertical modes `ResourceHeader` to display a miniature image
       * for the resource.
       * Set value to `false` to disable image display.
       * @field {String|Boolean} image
       * @category Styling
       */
      "image",
      /**
       * Control how much space to leave between the first event/last event and the resources edge (top/bottom
       * margin within the resource row in horizontal mode, left/right margin within the resource column in
       * vertical mode), in px.
       *
       * It's also possible to set different values for top/left and bottom/right
       * by assigning  an object to `resourceMargin` with `start` (margin top in horizontal mode,
       * margin left in vertical mode) and `end` (margin bottom / margin right) properties:
       * ```javascript
       * scheduler = new Scheduler({
       *     resourceMargin : {
       *         start : 15,
       *         end   : 1
       *     }
       * });
       * ```
       *
       * @field {Number|ResourceMarginConfig} resourceMargin
       * @category Layout
       */
      "resourceMargin",
      /**
       * Margin between stacked event bars for this resource, in px.
       * @field {Number} barMargin
       * @category Layout
       */
      { name: "barMargin", type: "number" },
      /**
       * Base height of this resource, in px. When unset, Schedulers configured rowHeight is used.
       *
       * This value is used in horizontal mode to determine row height. When stacking, it is used as input for
       * calculating the actual row height:
       *
       * ```javascript
       * row.height = (resource.rowHeight - (resourceMargin.start + resourceMargin.end)) * overlap count - barMargin * (overlap count - 1)
       * ```
       *
       * When packing or overlapping, it is used as the actual row height.
       *
       * @field {Number} rowHeight
       * @category Layout
       */
      /**
       * Base width of this resource, in px. If not set, the `columnWidth` specified in
       * the Scheduler's configured {@link Scheduler.view.Scheduler#config-resourceColumns} is used.
       *
       * This value is used in vertical mode to determine column width.
       *
       * @field {Number} columnWidth
       * @category Layout
       */
      /**
       * Specify this to use a resource specific event layout in horizontal mode, see
       * {@link Scheduler.view.mixin.SchedulerEventRendering#config-eventLayout} for options.
       *
       * When unset (the default) Schedulers setting is used.
       *
       * @field {'stack'|'pack'|'mixed'|'none'} eventLayout
       * @category Layout
       */
      "eventLayout"
    ];
  }
  //endregion
  //region Id change
  updateAssignmentResourceIds() {
    this.assigned.forEach((assignment) => {
      assignment.resourceId = this.id;
    });
  }
  syncId(value) {
    super.syncId(value);
    this.updateAssignmentResourceIds();
  }
  //endregion
  //region Getters
  // Documented in Scheduler.model.ResourceModel, SchedulerPro.model.ResourceModel, Gantt.model.ResourceModel
  get events() {
    return this.assignments.reduce((events, assignment) => {
      if (assignment.event) {
        events.push(assignment.event);
      }
      return events;
    }, []);
  }
  /**
   * Returns all assignments for the resource
   *
   * @property {Scheduler.model.AssignmentModel[]}
   * @category Common
   */
  get assignments() {
    return this.assigned ? [...this.assigned] : [];
  }
  set assignments(assignments) {
    this.assignmentStore.remove(this.assignments);
    assignments.forEach((assignment) => {
      assignment.resource = this;
    });
  }
  /**
   * Returns an array of events, associated with this resource
   *
   * @deprecated 5.3.6 Use the events property instead
   *
   * @returns {Scheduler.model.EventModel[]}
   */
  getEvents() {
    VersionHelper.deprecate("scheduler", "6.0.0", "getEvents() is deprecated, use the events property instead");
    return this.events;
  }
  /**
   * Returns `true` if the resource can be persisted.
   * In a flat store, a resource is always considered persistable. In a tree store, a resource is considered
   * persistable if its parent node is persistable.
   *
   * @property {Boolean}
   * @readonly
   * @category Editing
   */
  get isPersistable() {
    return super.isPersistable && (!this.parent || this.parent.isPersistable);
  }
  //endregion
  /**
   * Unassigns this Resource from all its Events
   */
  unassignAll() {
    this.assignments && this.assignmentStore.remove(this.assignments);
  }
  /**
   * Returns the initials (first letter of the first & last space-separated word in the name) or an empty string
   * if this resource has no name. You can override this method in a ResourceModel subclass to provide your own implementation
   *
   * @property {String}
   * @readonly
   * @category Common
   */
  get initials() {
    const { name = "" } = this;
    if (!name) {
      return "";
    }
    const names = name.split(" "), firstInitial = names[0][0], lastInitial = names.length > 1 ? names[names.length - 1][0] : "";
    return firstInitial + lastInitial;
  }
  isWorkingTime(date) {
    var _a2, _b;
    const calendar = this.effectiveCalendar || ((_a2 = this.project) == null ? void 0 : _a2.calendar);
    return !calendar || ((_b = calendar.isWorkingTime) == null ? void 0 : _b.call(calendar, date));
  }
};

// ../Scheduler/lib/Scheduler/model/ResourceModel.js
var EngineMixin3 = CoreResourceMixin;
var ResourceModel = class extends ResourceModelMixin_default(PartOfProject_default(EngineMixin3.derive(GridRowModel))) {
};
/**
 * Get associated events
 *
 * @member {Scheduler.model.EventModel[]} events
 * @readonly
 * @category Common
 */
__publicField(ResourceModel, "$name", "ResourceModel");
ResourceModel.exposeProperties();
ResourceModel._$name = "ResourceModel";

// ../Scheduler/lib/Scheduler/model/mixin/AssignmentModelMixin.js
var AssignmentModelMixin_default = (Target) => class AssignmentModelMixin extends Target {
  static get $name() {
    return "AssignmentModelMixin";
  }
  /**
   * Set value for the specified field(s), triggering engine calculations immediately. See
   * {@link Core.data.Model#function-set Model#set()} for arguments.
   *
   * ```javascript
   * assignment.set('resourceId', 2);
   * // assignment.resource is not yet resolved
   *
   * await assignment.setAsync('resourceId', 2);
   * // assignment.resource is resolved
   * ```
   *
   * @param {String|Object} field The field to set value for, or an object with multiple values to set in one call
   * @param {*} [value] Value to set
   * @param {Boolean} [silent=false] Set to true to not trigger events
   * automatically.
   * @function setAsync
   * @category Editing
   * @async
   */
  //region Fields
  static get fields() {
    return [
      /**
       * Id for the resource to assign to
       * @field {String|Number} resourceId
       * @category Common
       */
      "resourceId",
      /**
       * Id for the event to assign
       * @field {String|Number} eventId
       * @category Common
       */
      "eventId",
      /**
       * Specify `false` to opt out of drawing dependencies from/to this assignment
       * @field {Boolean} drawDependencies
       * @category Common
       */
      { name: "drawDependencies", type: "boolean" },
      "event",
      "resource"
    ];
  }
  //endregion
  construct(data, ...args) {
    data = data || {};
    const { fieldMap } = this, eventIdField = fieldMap.eventId.dataSource, resourceIdField = fieldMap.resourceId.dataSource, eventField = fieldMap.event.dataSource, resourceField = fieldMap.resource.dataSource, eventId = data[eventIdField], resourceId = data[resourceIdField], event = data[eventField], resource = data[resourceField];
    if (eventId != null) {
      data[eventField] = eventId;
    } else if (event != null) {
      data[eventIdField] = event.isModel ? event.id : event;
    }
    if (resourceId != null) {
      data[resourceField] = resourceId;
    } else if (resource != null) {
      data[resourceIdField] = resource.isModel ? resource.id : resource;
    }
    super.construct(data, ...args);
  }
  //region Event & resource
  /**
   * A key made up from the event id and the id of the resource assigned to.
   * @property eventResourceKey
   * @readonly
   * @internal
   */
  get eventResourceKey() {
    return this.buildEventResourceKey(this.event, this.resource);
  }
  buildEventResourceKey(event, resource) {
    let eventKey, resourceKey;
    if (event) {
      eventKey = event.isModel ? event.id : event;
    } else {
      eventKey = this.internalId;
    }
    if (resource) {
      resourceKey = resource.isModel ? resource.id : resource;
    } else {
      resourceKey = this.internalId;
    }
    return `${eventKey}-${resourceKey}`;
  }
  buildIndexKey({ event, resource }) {
    return this.buildEventResourceKey(event, resource);
  }
  set(field, value, ...args) {
    var _a2, _b;
    const toSet = this.fieldToKeys(field, value);
    if ("resource" in toSet) {
      if (((_a2 = toSet.resource) == null ? void 0 : _a2.id) !== void 0) {
        toSet.resourceId = toSet.resource.id;
      }
    } else if ("resourceId" in toSet && this.constructor.isProAssignmentModel) {
      toSet.resource = toSet.resourceId;
    }
    if ("event" in toSet) {
      if (((_b = toSet.event) == null ? void 0 : _b.id) !== void 0) {
        toSet.eventId = toSet.event.id;
      }
    } else if ("eventId" in toSet && this.constructor.isProAssignmentModel) {
      toSet.event = toSet.eventId;
    }
    return super.set(toSet, null, ...args);
  }
  afterChange(toSet, wasSet, silent, fromRelationUpdate, skipAccessors) {
    var _a2, _b;
    const me = this;
    if (!me.constructor.isProAssignmentModel && (wasSet == null ? void 0 : wasSet.resourceId) && ((_a2 = me.resource) == null ? void 0 : _a2.id) !== wasSet.resourceId.value) {
      me.resource = wasSet.resourceId.value;
    } else if (me.constructor.isProAssignmentModel && ((_b = me.project) == null ? void 0 : _b.propagatingSyncChanges) && (wasSet == null ? void 0 : wasSet.eventId) && !(wasSet == null ? void 0 : wasSet.event) && (toSet.event.value === wasSet.eventId.value || toSet.event.value.id === wasSet.eventId.value)) {
      delete wasSet.eventId;
      delete me.meta.modified.eventId;
    }
    return super.afterChange(...arguments);
  }
  // Settings resourceId relays to `resource`. Underlying data will be updated in `afterChange()` above
  set resourceId(value) {
    const { resource } = this;
    if ((resource == null ? void 0 : resource.isModel) && resource.id === value) {
      this.set("resourceId", value);
    } else {
      this.resource = value;
    }
  }
  get resourceId() {
    var _a2, _b;
    return (_b = (_a2 = this.resource) == null ? void 0 : _a2.id) != null ? _b : this.get("resourceId");
  }
  // Same for event as for resourceId
  set eventId(value) {
    const { event } = this;
    if ((event == null ? void 0 : event.isModel) && event.id === value) {
      this.set("eventId", value);
    } else {
      this.event = value;
    }
  }
  get eventId() {
    var _a2, _b;
    return (_b = (_a2 = this.event) == null ? void 0 : _a2.id) != null ? _b : this.get("eventId");
  }
  /**
   * Convenience property to get the name of the associated event.
   * @property {String}
   * @readonly
   */
  get eventName() {
    var _a2;
    return (_a2 = this.event) == null ? void 0 : _a2.name;
  }
  /**
   * Convenience property to get the name of the associated resource.
   * @property {String}
   * @readonly
   */
  get resourceName() {
    var _a2;
    return (_a2 = this.resource) == null ? void 0 : _a2.name;
  }
  /**
   * Returns the resource associated with this assignment.
   *
   * @returns {Scheduler.model.ResourceModel} Instance of resource
   */
  getResource() {
    return this.resource;
  }
  //endregion
  // Convenience getter to not have to check `instanceof AssignmentModel`
  get isAssignment() {
    return true;
  }
  /**
   * Returns true if the Assignment can be persisted (e.g. task and resource are not 'phantoms')
   *
   * @property {Boolean}
   */
  get isPersistable() {
    var _a2;
    const {
      event,
      resource,
      unjoinedStores,
      assignmentStore
    } = this, crudManager = assignmentStore == null ? void 0 : assignmentStore.crudManager;
    let result;
    if (assignmentStore) {
      result = this.isValid && event.isPersistable && (crudManager || !event.hasGeneratedId && !resource.hasGeneratedId);
    } else {
      result = !this.isPhantom && Boolean(unjoinedStores[0]);
    }
    return result && super.isPersistable && !((_a2 = this.event) == null ? void 0 : _a2.isCreating);
  }
  get isValid() {
    return this.resource != null && this.event != null;
  }
  /**
   * Returns a textual representation of this assignment (e.g. Mike 50%).
   * @returns {String}
   */
  toString() {
    if (this.resourceName) {
      return `${this.resourceName} ${Math.round(this.units)}%`;
    }
    return "";
  }
  //region STM hooks
  shouldRecordFieldChange(fieldName, oldValue, newValue) {
    var _a2, _b;
    if (!super.shouldRecordFieldChange(fieldName, oldValue, newValue)) {
      return false;
    }
    if (fieldName === "event" || fieldName === "eventId") {
      const eventStore = (_a2 = this.project) == null ? void 0 : _a2.eventStore;
      if (eventStore && eventStore.oldIdMap[oldValue] === eventStore.getById(newValue)) {
        return false;
      }
    }
    if (fieldName === "resource" || fieldName === "resourceId") {
      const resourceStore = (_b = this.project) == null ? void 0 : _b.resourceStore;
      if (resourceStore && resourceStore.oldIdMap[oldValue] === resourceStore.getById(newValue)) {
        return false;
      }
    }
    return true;
  }
  //endregion
};

// ../Scheduler/lib/Scheduler/model/AssignmentModel.js
var EngineMixin4 = CoreAssignmentMixin;
var AssignmentModel = class extends AssignmentModelMixin_default(PartOfProject_default(EngineMixin4.derive(Model))) {
  // NOTE: Leave field defs at top to be picked up by jsdoc
  /**
   * Id for event to assign. Can be used as an alternative to `eventId`, but please note that after
   * load it will be populated with the actual event and not its id. This field is not persistable.
   * @field {Scheduler.model.EventModel} event
   * @accepts {String|Number|Scheduler.model.EventModel}
   * @typings {String||Number||Scheduler.model.EventModel||Scheduler.model.TimeSpan}
   * @category Common
   */
  /**
   * Id for resource to assign to. Can be used as an alternative to `resourceId`, but please note that after
   * load it will be populated with the actual resource and not its id. This field is not persistable.
   * @field {Scheduler.model.ResourceModel} resource
   * @accepts {String|Number|Scheduler.model.ResourceModel}
   * @category Common
   */
  static get $name() {
    return "AssignmentModel";
  }
};
AssignmentModel.exposeProperties();
AssignmentModel._$name = "AssignmentModel";

// ../Scheduler/lib/Scheduler/data/mixin/EventStoreMixin.js
var EventStoreMixin_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    /**
     * Add events to the store.
     *
     * NOTE: Dates, durations and references (assignments, resources) on the events are determined async by a calculation
     * engine. Thus they cannot be directly accessed after using this function.
     *
     * For example:
     *
     * ```javascript
     * eventStore.add({ startDate, duration });
     * // endDate is not yet calculated
     * ```
     *
     * To guarantee data is in a calculated state, wait for calculations for finish:
     *
     * ```javascript
     * eventStore.add({ startDate, duration });
     * await eventStore.project.commitAsync();
     * // endDate is calculated
     * ```
     *
     * Alternatively use `addAsync()` instead:
     *
     * ```javascript
     * await eventStore.addAsync({ startDate, duration });
     * // endDate is calculated
     * ```
     *
     * @param {Scheduler.model.EventModel|Scheduler.model.EventModel[]|EventModelConfig|EventModelConfig[]} records
     * Array of records/data or a single record/data to add to store
     * @param {Boolean} [silent] Specify `true` to suppress events
     * @returns {Scheduler.model.EventModel[]} Added records
     * @function add
     * @category CRUD
     */
    /**
     * Add events to the store and triggers calculations directly after. Await this function to have up to date data on
     * the added events.
     *
     * ```javascript
     * await eventStore.addAsync({ startDate, duration });
     * // endDate is calculated
     * ```
     *
     * @param {Scheduler.model.EventModel|Scheduler.model.EventModel[]|EventModelConfig|EventModelConfig[]} records
     * Array of records/data or a single record/data to add to store
     * @param {Boolean} [silent] Specify `true` to suppress events
     * @returns {Scheduler.model.EventModel[]} Added records
     * @function addAsync
     * @category CRUD
     * @async
     */
    /**
     * Applies a new dataset to the EventStore. Use it to plug externally fetched data into the store.
     *
     * NOTE: Dates, durations and relations (assignments, resources) on the events are determined async by a calculation
     * engine. Thus they cannot be directly accessed after assigning the new dataset.
     *
     * For example:
     *
     * ```javascript
     * eventStore.data = [{ startDate, duration }];
     * // eventStore.first.endDate is not yet calculated
     * ```
     *
     * To guarantee data is in a calculated state, wait for calculations for finish:
     *
     * ```javascript
     * eventStore.data = [{ startDate, duration }];
     * await eventStore.project.commitAsync();
     * // eventStore.first.endDate is calculated
     * ```
     *
     * Alternatively use `loadDataAsync()` instead:
     *
     * ```javascript
     * await eventStore.loadDataAsync([{ startDate, duration }]);
     * // eventStore.first.endDate is calculated
     * ```
     *
     * @member {EventModelConfig[]} data
     * @category Records
     */
    /**
     * Applies a new dataset to the EventStore and triggers calculations directly after. Use it to plug externally
     * fetched data into the store.
     *
     * ```javascript
     * await eventStore.loadDataAsync([{ startDate, duration }]);
     * // eventStore.first.endDate is calculated
     * ```
     *
     * @param {EventModelConfig[]} data Array of EventModel data objects
     * @function loadDataAsync
     * @category CRUD
     * @async
     */
    /**
     * Class used to represent records. Defaults to class EventModel.
     * @member {Scheduler.model.EventModel} modelClass
     * @typings {typeof EventModel}
     * @category Records
     */
    static get defaultConfig() {
      return {
        /**
         * CrudManager must load stores in the correct order. Lowest first.
         * @private
         */
        loadPriority: 100,
        /**
         * CrudManager must sync stores in the correct order. Lowest first.
         * @private
         */
        syncPriority: 200,
        storeId: "events",
        /**
         * Configure with `true` to also remove the event when removing the last assignment from the linked
         * AssignmentStore. This config has not effect when using EventStore in legacy `resourceId`-mode.
         * @config {Boolean}
         * @default
         * @category Common
         */
        removeUnassignedEvent: true,
        /**
         * Configure with `true` to force single-resource mode, an event can only be assigned to a single resource.
         * If not provided, the mode will be inferred from
         *
         * 1. presence of an assignment store (i.e. multi-assignment)
         * 2. presence of `resourceId` in the event store data (i.e. single assignment mode)
         * @config {Boolean}
         * @category Common
         */
        singleAssignment: null
      };
    }
    //region Init & destroy
    construct(config) {
      super.construct(config);
      this.autoTree = true;
      if (this.singleAssignment) {
        this.usesSingleAssignment = true;
      }
      if (!this.modelClass.isEventModel) {
        throw new Error("The model for the EventStore must subclass EventModel");
      }
    }
    //endregion
    //region Events records, iteration etc.
    set filtersFunction(filtersFunction) {
      super.filtersFunction = filtersFunction;
    }
    get filtersFunction() {
      const result = super.filtersFunction;
      if (result && result !== FunctionHelper.returnTrue) {
        return (r) => r.isCreating || result(r);
      }
      return result;
    }
    /**
     * Returns a `Map`, keyed by `YYYY-MM-DD` date keys containing event counts for all the days
     * between the passed `startDate` and `endDate`. Occurrences of recurring events are included.
     *
     * Example:
     *
     * ```javascript
     *  eventCounts = eventStore.getEventCounts({
     *      startDate : scheduler.timeAxis.startDate,
     *      endDate   : scheduler.timeAxis.endDate
     *  });
     * ```
     *
     * @param {Object} options An options object determining which events to return
     * @param {Date} options.startDate The start date for the range of events to include.
     * @param {Date} [options.endDate] The end date for the range of events to include.
     * @category Events
     */
    getEventCounts(options) {
      const me = this, {
        filtersFunction,
        added
      } = me, result = me.getEvents({
        ...options,
        storeFilterFn: me.isFiltered ? me.reapplyFilterOnAdd ? filtersFunction : (eventRecord) => added.includes(eventRecord) ? me.indexOf(eventRecord) > -1 : filtersFunction(eventRecord) : null,
        dateMap: options.dateMap || true
      });
      result.forEach((value, key) => result.set(key, value.length));
      return result;
    }
    /**
     * Calls the supplied iterator function once for every scheduled event, providing these arguments
     * - event : the event record
     * - startDate : the event start date
     * - endDate : the event end date
     *
     * Returning false cancels the iteration.
     *
     * @param {Function} fn iterator function
     * @param {Object} [thisObj] `this` reference for the function
     * @category Events
     */
    forEachScheduledEvent(fn2, thisObj = this) {
      this.forEach((event) => {
        const { startDate, endDate } = event;
        if (startDate && endDate) {
          return fn2.call(thisObj, event, startDate, endDate);
        }
      });
    }
    /**
     * Returns an object defining the earliest start date and the latest end date of all the events in the store.
     *
     * @returns {Object} An object with 'startDate' and 'endDate' properties (or null values if data is missing).
     * @category Events
     */
    getTotalTimeSpan() {
      let earliest = new Date(9999, 0, 1), latest = /* @__PURE__ */ new Date(0);
      this.forEach((event) => {
        if (event.startDate) {
          earliest = DateHelper.min(event.startDate, earliest);
        }
        if (event.endDate) {
          latest = DateHelper.max(event.endDate, latest);
        }
      });
      earliest = earliest < new Date(9999, 0, 1) ? earliest : null;
      latest = latest > /* @__PURE__ */ new Date(0) ? latest : null;
      return this.lastTotalTimeSpan = {
        startDate: earliest || null,
        endDate: latest || earliest || null
      };
    }
    /**
     * Checks if given event record is persistable. By default it always is, override EventModels `isPersistable` if you
     * need custom logic.
     *
     * @param {Scheduler.model.EventModel} event
     * @returns {Boolean}
     * @category Events
     */
    isEventPersistable(event) {
      return event.isPersistable;
    }
    //endregion
    //region Resource
    /**
     * Checks if a date range is allocated or not for a given resource.
     *
     * Note that when asked to check a 0 duration range, any 0 duration events at the same point in time will be
     * considered overlapping.
     *
     * @param {Date} start The start date
     * @param {Date} end The end date
     * @param {Scheduler.model.EventModel|null} excludeEvent An event to exclude from the check (or null)
     * @param {Scheduler.model.ResourceModel} resource The resource
     * @returns {Boolean} True if the timespan is available for the resource
     * @category Resource
     */
    isDateRangeAvailable(start, end, excludeEvent, resource) {
      if (resource.data.generatedParent) {
        return false;
      }
      const allEvents = new Set(this.getEventsForResource(resource));
      if (excludeEvent == null ? void 0 : excludeEvent.isAssignment) {
        const currentEvent = excludeEvent.event, resources = currentEvent.resources;
        resources.forEach((resource2) => {
          if (resource2.id !== excludeEvent.resourceId) {
            this.getEventsForResource(resource2).forEach((event) => allEvents.add(event));
          }
        });
      }
      if (excludeEvent) {
        const eventToRemove = excludeEvent.isAssignment ? excludeEvent.event : excludeEvent;
        allEvents.delete(eventToRemove);
      }
      const all = Array.from(allEvents);
      if (start.getTime() === end.getTime()) {
        return !all.some(
          (event) => event.isScheduled && (event.duration === 0 ? event.startDate.getTime() === start.getTime() : DateHelper.intersectSpans(start, end, event.startDate, event.endDate))
        );
      }
      return !all.some((event) => event.isScheduled && DateHelper.intersectSpans(start, end, event.startDate, event.endDate));
    }
    /**
     * Filters the events associated with a resource, based on the function provided. An array will be returned for those
     * events where the passed function returns true.
     * @param {Scheduler.model.ResourceModel} resource
     * @param {Function} fn The function
     * @param {Object} [thisObj] `this` reference for the function
     * @returns {Scheduler.model.EventModel[]} the events in the time span
     * @private
     * @category Resource
     */
    filterEventsForResource(resource, fn2, thisObj = this) {
      return resource.getEvents(this).filter(fn2.bind(thisObj));
    }
    /**
     * Returns all resources assigned to an event.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @returns {Scheduler.model.ResourceModel[]}
     * @category Resource
     */
    getResourcesForEvent(event) {
      if (event.isOccurrence) {
        event = event.recurringTimeSpan;
      }
      return this.assignmentStore.getResourcesForEvent(event);
    }
    /**
     * Returns all events assigned to a resource.
     * *NOTE:* this does not include occurrences of recurring events. Use the
     * {@link Scheduler/data/mixin/GetEventsMixin#function-getEvents} API to include occurrences of recurring events.
     * @param {Scheduler.model.ResourceModel|String|Number} resource Resource or resource id.
     * @returns {Scheduler.model.EventModel[]}
     * @category Resource
     */
    getEventsForResource(resource) {
      return this.assignmentStore.getEventsForResource(resource);
    }
    //endregion
    //region Assignment
    /**
     * Returns all assignments for a given event.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @returns {Scheduler.model.AssignmentModel[]}
     * @category Assignment
     */
    getAssignmentsForEvent(event) {
      return this.assignmentStore.getAssignmentsForEvent(event) || [];
    }
    /**
     * Returns all assignments for a given resource.
     *
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @returns {Scheduler.model.AssignmentModel[]}
     * @category Assignment
     */
    getAssignmentsForResource(resource) {
      return this.assignmentStore.getAssignmentsForResource(resource) || [];
    }
    /**
     * Creates and adds assignment record for a given event and a resource.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @param {Scheduler.model.ResourceModel|String|Number|Scheduler.model.ResourceModel[]|String[]|Number[]} resource The resource(s) to assign to the event
     * @param {Boolean} [removeExistingAssignments] `true` to first remove existing assignments
     * @returns {Scheduler.model.AssignmentModel[]} An array with the created assignment(s)
     * @category Assignment
     */
    assignEventToResource(event, resource, removeExistingAssignments = false) {
      return this.assignmentStore.assignEventToResource(event, resource, void 0, removeExistingAssignments);
    }
    /**
     * Removes assignment record for a given event and a resource.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @category Assignment
     */
    unassignEventFromResource(event, resource) {
      this.assignmentStore.unassignEventFromResource(event, resource);
    }
    /**
     * Reassigns an event from an old resource to a new resource
     *
     * @param {Scheduler.model.EventModel}    event    An event or id of the event to reassign
     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} oldResource A resource or id to unassign from
     * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} newResource A resource or id to assign to
     * @category Assignment
     */
    reassignEventFromResourceToResource(event, oldResource, newResource) {
      const me = this, newResourceId = Model.asId(newResource), assignment = me.assignmentStore.getAssignmentForEventAndResource(event, oldResource);
      if (assignment) {
        assignment.resourceId = newResourceId;
      } else {
        me.assignmentStore.assignEventToResource(event, newResource);
      }
    }
    /**
     * Checks whether an event is assigned to a resource.
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @returns {Boolean}
     * @category Assignment
     */
    isEventAssignedToResource(event, resource) {
      return this.assignmentStore.isEventAssignedToResource(event, resource);
    }
    /**
     * Removes all assignments for given event
     *
     * @param {Scheduler.model.EventModel|String|Number} event
     * @category Assignment
     */
    removeAssignmentsForEvent(event) {
      this.assignmentStore.removeAssignmentsForEvent(event);
    }
    /**
     * Removes all assignments for given resource
     *
     * @param {Scheduler.model.ResourceModel|String|Number} resource
     * @category Assignment
     */
    removeAssignmentsForResource(resource) {
      this.assignmentStore.removeAssignmentsForResource(resource);
    }
    //endregion
    /**
     * Appends a new record to the store
     * @param {Scheduler.model.EventModel} record The record to append to the store
     * @category CRUD
     */
    append(record) {
      return this.add(record);
    }
    //region Project
    get project() {
      return super.project;
    }
    set project(project) {
      var _a3;
      super.project = project;
      this.detachListeners("project");
      if (project) {
        if ((_a3 = project.assignmentStore) == null ? void 0 : _a3.isAssignmentStore) {
          this.attachToAssignmentStore(project.assignmentStore);
        }
        project.ion({
          name: "project",
          assignmentStoreChange: "onProjectAssignmentStoreChange",
          thisObj: this,
          prio: 200
          // Before UI updates
        });
      }
    }
    //endregion
    //region resource ids
    get usesResourceIds() {
      var _a3, _b;
      return (_b = (_a3 = this.modelClass.fieldMap) == null ? void 0 : _a3.resourceIds.persist) != null ? _b : false;
    }
    //endregion
    //region Single assignment
    get usesSingleAssignment() {
      if (this.isChained) {
        return this.masterStore.usesSingleAssignment;
      }
      return this._usesSingleAssignment;
    }
    set usesSingleAssignment(value) {
      this._usesSingleAssignment = value;
      const { assignmentStore } = this;
      if ((assignmentStore == null ? void 0 : assignmentStore.isStore) && !assignmentStore.hasGenerateIdOverride) {
        assignmentStore.modelClass.generateId = function() {
          if (this.singleAssignmentIdCounter == null) {
            this.singleAssignmentIdCounter = 0;
          }
          return `a-${++this.singleAssignmentIdCounter}`;
        };
        assignmentStore.hasGenerateIdOverride = true;
      }
    }
    processRecords(eventRecords) {
      var _a3;
      const { assignmentStore } = this, assignmentsToAdd = [];
      if (assignmentStore) {
        assignmentStore.skipInvalidateIndices = true;
      }
      eventRecords = super.processRecords(eventRecords, assignmentStore && !((_a3 = this.stm) == null ? void 0 : _a3.isRestoring) && ((eventRecord) => {
        const resourceId = eventRecord.get("resourceId");
        if (!eventRecord.reassignedFromReplace && resourceId != null) {
          if (!assignmentStore.includesAssignment(eventRecord.id, resourceId)) {
            assignmentsToAdd.push({
              id: assignmentStore.modelClass.generateId(""),
              resourceId,
              eventId: eventRecord.id
            });
          }
        }
        eventRecord.reassignedFromReplace = false;
      }) || void 0);
      if (assignmentStore) {
        assignmentStore.storage.invalidateIndices();
        assignmentStore.skipInvalidateIndices = false;
        assignmentStore.add(assignmentsToAdd);
      }
      return eventRecords;
    }
    joinRecordsToStore(records) {
      const { assignmentStore } = this;
      if (assignmentStore) {
        assignmentStore.skipInvalidateIndices = true;
        super.joinRecordsToStore(records);
        assignmentStore.storage.invalidateIndices();
        assignmentStore.skipInvalidateIndices = false;
      } else {
        super.joinRecordsToStore(records);
      }
    }
    processRecord(eventRecord, isDataset = false) {
      var _a3, _b;
      eventRecord = super.processRecord(eventRecord, isDataset);
      const me = this, assignmentStore = (_b = me.assignmentStore) != null ? _b : (_a3 = me.crudManager) == null ? void 0 : _a3.assignmentStore, resourceId = eventRecord.get("resourceId"), { resourceIds } = eventRecord;
      if ((resourceIds == null ? void 0 : resourceIds.length) && eventRecord.meta.skipEnforcingSingleAssignment !== false && me.usesResourceIds) {
        if (assignmentStore) {
          assignmentStore.add(resourceIds.filter((resourceId2) => !assignmentStore.some((a) => a.eventId === eventRecord.id && a.resourceId === resourceId2)).map((resourceId2) => ({ resource: resourceId2, event: eventRecord })));
        } else {
          me.$processResourceIds = true;
        }
      } else if (resourceId != null && !eventRecord.meta.skipEnforcingSingleAssignment) {
        const existingRecord = me.getById(eventRecord.id), isReplacing = existingRecord && existingRecord !== eventRecord && !isDataset;
        if (isReplacing) {
          const assignmentSet = assignmentStore.storage.findItem("eventId", eventRecord.id);
          if (assignmentSet == null ? void 0 : assignmentSet.size) {
            const assignment = assignmentSet.values().next().value;
            assignment.resource = resourceId;
            eventRecord.reassignedFromReplace = true;
          }
        } else {
          me.$processResourceIds = true;
        }
        me.usesSingleAssignment = true;
      }
      return eventRecord;
    }
    processResourceIds() {
      var _a3, _b, _c;
      const me = this, assignmentStore = (_b = me.assignmentStore) != null ? _b : (_a3 = me.crudManager) == null ? void 0 : _a3.assignmentStore;
      if (me.$processResourceIds && (assignmentStore == null ? void 0 : assignmentStore.isAssignmentStore) && !(((_c = me.project) == null ? void 0 : _c.isSharingAssignmentStore) && me.isChained)) {
        const assignments = [];
        me.forEach((eventRecord) => {
          const { resourceId, resourceIds, id: eventId } = eventRecord;
          if (resourceId != null) {
            assignments.push({
              id: assignmentStore.modelClass.generateId(""),
              resourceId,
              eventId
            });
          } else if (resourceIds == null ? void 0 : resourceIds.length) {
            resourceIds.forEach((rId) => {
              assignments.push({
                id: assignmentStore.modelClass.generateId(""),
                resourceId: rId,
                eventId
              });
            });
          }
        }, me, { includeFilteredOutRecords: true });
        assignmentStore.useRawData = {
          disableDefaultValue: true,
          disableDuplicateIdCheck: true,
          disableTypeConversion: true
        };
        assignmentStore.usesSingleAssignment = false;
        assignmentStore.verifyNoGeneratedIds = false;
        assignmentStore.data = assignments;
        assignmentStore.usesSingleAssignment = true;
        me.$processResourceIds = false;
      }
    }
    loadData() {
      super.loadData(...arguments);
      this.processResourceIds();
    }
    // Optionally remove unassigned events
    onBeforeRemoveAssignment({ records }) {
      var _a3;
      const me = this;
      if (me.removeUnassignedEvent && !me.isRemoving && !me.isSettingData && !((_a3 = me.stm) == null ? void 0 : _a3.isRestoring) && !me.usesSingleAssignment && // Do not remove unassigned events when syncing data, new assignments etc. might be synced afterwards
      !me.assignmentStore.isSyncingDataOnLoad && !me.resourceStore.isSyncingDataOnLoad) {
        const toRemove = /* @__PURE__ */ new Set();
        records.forEach((assignmentRecord) => {
          const { event } = assignmentRecord;
          if (event && !event.isRemoved && event.assignments.every((a) => records.includes(a))) {
            toRemove.add(event);
          }
        });
        if (toRemove.size) {
          me.remove([...toRemove]);
        }
      }
    }
    onProjectAssignmentStoreChange({ store }) {
      this.attachToAssignmentStore(store);
    }
    attachToAssignmentStore(assignmentStore) {
      const me = this;
      me.detachListeners("assignmentStore");
      if (assignmentStore) {
        me.processResourceIds();
        assignmentStore.ion({
          name: "assignmentStore",
          // Adding an assignment in single assignment mode should set events resourceId if needed,
          // otherwise it should set events resourceIds (if persistable)
          addPreCommit({ records }) {
            if (!me.isSettingData && !me.isAssigning) {
              if (me.usesSingleAssignment) {
                records.forEach((assignment) => {
                  const { event } = assignment;
                  if ((event == null ? void 0 : event.isEvent) && event.resourceId !== assignment.resourceId) {
                    event.meta.isAssigning = true;
                    event.set("resourceId", assignment.resourceId);
                    event.meta.isAssigning = false;
                  }
                });
              } else if (me.usesResourceIds) {
                records.forEach((assignment) => {
                  var _a3;
                  const { event } = assignment;
                  if (event == null ? void 0 : event.isEvent) {
                    event.meta.isAssigning = true;
                    const resourceIds = (_a3 = event.resourceIds) != null ? _a3 : [];
                    if (!resourceIds.includes(assignment.resourceId)) {
                      event.resourceIds = [...resourceIds, assignment.resourceId];
                    }
                    event.meta.isAssigning = false;
                  }
                });
              }
            }
          },
          // Called both for remove and removeAll
          beforeRemove: "onBeforeRemoveAssignment",
          // Removing an assignment in single assignment mode should set events resourceId to null,
          // otherwise it should set events resourceIds to an empty array
          removePreCommit({ records }) {
            if (!me.isSettingData && !me.isAssigning) {
              if (me.usesSingleAssignment) {
                records.forEach((assignment) => {
                  var _a3;
                  (_a3 = me.getById(assignment.eventId)) == null ? void 0 : _a3.set("resourceId", null);
                });
              } else if (me.usesResourceIds) {
                records.forEach(({ event, resourceId }) => {
                  const resourceIds = event.resourceIds.slice(), indexToRemove = resourceIds == null ? void 0 : resourceIds.indexOf(resourceId);
                  if (indexToRemove >= 0) {
                    resourceIds.splice(indexToRemove, 1);
                    event.resourceIds = resourceIds;
                  }
                });
              }
            }
          },
          removeAllPreCommit() {
            if (!me.isSettingData && !me.isAssigning) {
              if (me.usesSingleAssignment) {
                me.allRecords.forEach((eventRecord) => eventRecord.set("resourceId", null));
              } else if (me.usesResourceIds) {
                me.allRecords.forEach((eventRecord) => {
                  eventRecord.resourceIds = [];
                });
              }
            }
          },
          // Keep events resourceId and resourceIds in sync with assignment on changes
          update({ record, changes }) {
            if ("resourceId" in changes) {
              const { event } = record;
              if (me.usesSingleAssignment) {
                event.meta.isAssigning = true;
                event.set("resourceId", changes.resourceId.value);
                event.meta.isAssigning = false;
              } else if (me.usesResourceIds) {
                event.meta.isAssigning = true;
                const resourceIds = event.resourceIds.slice(), indexToRemove = resourceIds == null ? void 0 : resourceIds.indexOf(changes.resourceId.oldValue);
                if (indexToRemove >= 0) {
                  resourceIds.splice(indexToRemove, 1);
                }
                if (!(resourceIds == null ? void 0 : resourceIds.includes(changes.resourceId.value))) {
                  resourceIds.push(changes.resourceId.value);
                  event.resourceIds = resourceIds;
                }
                event.meta.isAssigning = false;
              }
            }
          },
          // Keep events resourceIds in sync with assignment on dataset loading
          change({ action, records }) {
            if (action === "dataset" && me.usesResourceIds) {
              records.forEach(({ event, resourceId }) => {
                var _a3;
                const resourceIds = (_a3 = event.resourceIds) != null ? _a3 : [];
                if (!resourceIds.includes(resourceId)) {
                  resourceIds.push(resourceId);
                  event.meta.isAssigning = true;
                  event.setData("resourceIds", resourceIds);
                  event.meta.isAssigning = false;
                }
              });
            }
          },
          thisObj: me
        });
      }
    }
    set data(data) {
      this.isSettingData = true;
      if (this.usesSingleAssignment && !this.syncDataOnLoad && !this.isChained) {
        this.assignmentStore.removeAll(true);
      }
      super.data = data;
      this.isSettingData = false;
    }
    // Override trigger to decorate update/change events with a flag if resourceId was the only thing changed, in which
    // case the change most likely can be ignored since the assignment will also change
    trigger(eventName, params) {
      var _a3;
      const { changes } = params || {};
      if (changes && "resourceId" in changes && Object.keys(changes).length === 1 && !((_a3 = this.stm) == null ? void 0 : _a3.isRestoring)) {
        params.isAssign = true;
      }
      return super.trigger(...arguments);
    }
    remove(records, ...args) {
      var _a3, _b;
      const result = super.remove(records, ...args);
      if (result.length && this.usesSingleAssignment) {
        for (const eventRecord of result) {
          if (!eventRecord.isOccurrence) {
            (_b = this.assignmentStore || ((_a3 = this.crudManager) == null ? void 0 : _a3.assignmentStore)) == null ? void 0 : _b.remove(eventRecord.assignments, true);
          }
        }
      }
      return result;
    }
    //endregion
  }, __publicField(_a2, "$name", "EventStoreMixin"), _a2;
};

// ../Scheduler/lib/Scheduler/data/mixin/GetEventsMixin.js
var returnTrue2 = () => true;
var notRecurring = (event) => !event.isRecurring;
var GetEventsMixin_default = (Target) => {
  var _a2;
  return _a2 = class extends Target {
    /**
     * Returns an array of events for the date range specified by the `startDate` and `endDate` options.
     *
     * By default, for any date, this includes any event which *intersects* that date.
     *
     * To only include events that are fully contained *within* the date range, pass the `allowPartial`
     * option as `false`.
     *
     * By default, any occurrences of recurring events are included in the resulting array (not applicable in Gantt). If
     * that is not required, pass the `includeOccurrences` option as `false`. **Note that if `includeOccurrences` is
     * `true`, the start date and end date options are mandatory. The method must know what range of occurrences needs
     * to be generated and returned.**
     *
     * Example:
     *
     * ```javascript
     *  visibleEvents = eventStore.getEvents({
     *      resourceRecord : myResource,
     *      startDate      : scheduler.timeAxis.startDate,
     *      endDate        : scheduler.timeAxis.endDate
     *  });
     * ```
     *
     * @param {Object} options An options object determining which events to return
     * @param {Date} [options.date] If only one date is required, pass this option instead of the
     * `startDate` and `endDate` options.
     * @param {Date} options.startDate The start date for the range of events to include.
     * @param {Date} [options.endDate] The end date for the range of events to include.
     * @param {Scheduler.model.ResourceModel} [options.resourceRecord] Pass a resource to only return events assigned to
     *   this resource. Not supported when using the `dateMap` option (see below)
     * @param {Function} [options.filter] A function to filter out events which are not required.
     * @param {Boolean} [options.ignoreFilters] By default, store filters are honoured. Pass this
     * as `true` to include filtered out events.
     * @param {Boolean} [options.includeOccurrences=true] Occurrences of recurring events are included by default.
     * @param {Boolean} [options.allowPartial=true] Events which start before or after the range, but *intersect* the
     *   range are included by default.
     * @param {Boolean} [options.startOnly] Pass `true` to only include events which *start on* each date in the range.
     * @param {Boolean} [options.onlyAssigned] Pass `true` to only include events that are assigned to a resource
     * @param {Boolean|Map} [options.dateMap] Populates the passed `Map`, or if passed as `true`, creates and
     * returns a new `Map`. The keys are `YYYY-MM-DD` date strings and the entries are arrays of
     * {@link Scheduler.model.EventModel EventModel}s.
     * @returns {Scheduler.model.EventModel[]|Map} Events which match the passed configuration.
     * @category Events
     */
    getEvents({
      filter: filter2,
      date,
      startDate,
      // Events which intersect the startDate/endDate
      endDate,
      // will be returned
      startOnly,
      // Only events which start on each date will be returned
      includeOccurrences,
      // Interpolate occurrences into the returned event set
      allowPartial,
      // Include events which *intersect* the date range
      onlyAssigned = false,
      // Only include events that are assigned to a resource
      dateMap = false,
      // Return a Map keyed by date each value being an array of events
      dayTime = null,
      // Private option. Select which date index to look up events in depending on the date
      // we are examining in the date iteration process. Some callers may want to use
      // different indices depending on the stage through the date iteration.
      // See Calendar package for usage.
      getDateIndex
    }) {
      const me = this, options = arguments[0], {
        lastDateRange,
        added,
        filtersFunction
      } = me, passedFilter = filter2;
      if (onlyAssigned) {
        options.filter = passedFilter ? (e) => passedFilter(e) && e.resources.length : (e) => e.resources.length;
      }
      if (!("startDate" in options)) {
        startDate = options.startDate = date;
      }
      if (!("includeOccurrences" in options)) {
        includeOccurrences = options.includeOccurrences = true;
      }
      if (!("allowPartial" in options)) {
        allowPartial = options.allowPartial = !startOnly;
      }
      options.storeFilterFn = me.isFiltered && !options.ignoreFilters ? me.reapplyFilterOnAdd ? filtersFunction : (eventRecord) => added.includes(eventRecord) ? me.indexOf(eventRecord) > -1 : filtersFunction(eventRecord) : null;
      if (!endDate) {
        if (startDate) {
          endDate = options.endDate = DateHelper.clearTime(startDate);
          endDate.setDate(endDate.getDate() + 1);
        } else {
          if (includeOccurrences) {
            throw new Error("getEvents MUST be passed startDate and endDate if recurring occurrences are requested");
          }
          options.dateFilter = returnTrue2;
        }
      }
      if (!options.dateFilter) {
        if (startOnly) {
          options.dateFilter = (e) => {
            const eventStartDate = e.hasBatchedChange("startDate") ? e.get("startDate") : e.startDate;
            return eventStartDate && !(DateHelper.clearTime(eventStartDate) - startDate);
          };
        } else if (allowPartial) {
          options.dateFilter = (e) => {
            const eventStartDate = e.hasBatchedChange("startDate") ? e.get("startDate") : e.startDate, eventEndDate = e.hasBatchedChange("endDate") ? e.get("endDate") : e.endDate || eventStartDate, isMilestone = !(eventStartDate - eventEndDate);
            return eventStartDate && (isMilestone ? DateHelper.betweenLesserEqual(eventStartDate, startDate, endDate) : DateHelper.intersectSpans(eventStartDate, eventEndDate, startDate, endDate));
          };
        } else {
          options.dateFilter = (e) => {
            const eventStartDate = e.hasBatchedChange("startDate") ? e.get("startDate") : e.startDate, eventEndDate = e.hasBatchedChange("endDate") ? e.get("endDate") : e.endDate || eventStartDate;
            return eventStartDate && eventStartDate >= startDate && eventEndDate <= endDate;
          };
        }
      }
      const newDateRange = {
        startDate,
        endDate
      };
      me.processConfiguredListeners();
      me.trigger("loadDateRange", {
        old: lastDateRange || {},
        new: Objects.clone(newDateRange),
        changed: Boolean(!lastDateRange || (lastDateRange.startDate - newDateRange.startDate || lastDateRange.endDate - newDateRange.endDate))
      });
      me.lastDateRange = Objects.clone(newDateRange);
      return dateMap ? me.getEventsAsMap(options) : me.getEventsAsArray(options);
    }
    /**
     * Internal implementation for {@link #function-getEvents} to use when not using dateMap.
     * @private
     */
    getEventsAsArray({
      filter: filter2,
      date,
      resourceRecord,
      startDate = date,
      // Events which intersect the startDate/endDate
      endDate,
      // will be returned
      startOnly,
      // Only events which start on each date will be returned
      includeOccurrences = true,
      // Interpolate occurrences into the returned event set
      dayTime = null,
      // Injected by the getEvents master method
      dateFilter,
      storeFilterFn,
      // Private option. Select which date index to look up events in depending on the date
      // we are examining in the date iteration process. Some callers may want to use
      // different indices depending on the stage through the date iteration.
      // See Calendar package for usage.
      getDateIndex
    }) {
      const me = this, events = [], count = storeFilterFn ? me.count : me.allCount;
      if (count) {
        let candidateEvents = resourceRecord ? me.getEventsForResource(resourceRecord) : null;
        if (!resourceRecord) {
          const dateIndex = me.useDayIndex(dayTime), eventSet = /* @__PURE__ */ new Set(), indexName = startOnly ? "startDate" : "date";
          me.recurringEvents.forEach((e) => {
            if (dateIndex.dayTime.startOfDay(e.startDate) <= startDate) {
              eventSet.add(e);
            }
          });
          for (const date2 = new Date(startDate); date2 < endDate; date2.setDate(date2.getDate() + 1)) {
            const coincidingEvents = dateIndex.get(getDateIndex ? getDateIndex(date2) : indexName, date2);
            coincidingEvents == null ? void 0 : coincidingEvents.forEach((e) => eventSet.add(e));
          }
          candidateEvents = [...eventSet];
        }
        if (storeFilterFn) {
          candidateEvents = candidateEvents.filter(storeFilterFn);
        }
        for (let i = 0, { length } = candidateEvents; i < length; i++) {
          const e = candidateEvents[i];
          if (includeOccurrences && e.isRecurring) {
            events.push.apply(events, e.getOccurrencesForDateRange(startDate, endDate).filter(dateFilter));
          } else if (dateFilter(e)) {
            events.push(e);
          }
        }
      }
      return filter2 ? events.filter(filter2) : events;
    }
    /**
     * Internal implementation for {@link #function-getEvents} to use when using dateMap.
     * @private
     */
    getEventsAsMap({
      filter: passedFilter,
      date,
      resourceRecord,
      // Not supported yet. Will add if ever requested.
      startDate = date,
      // Events which intersect the startDate/endDate
      endDate,
      // will be returned
      startOnly,
      // Only events which start on each date will be returned
      includeOccurrences = true,
      // Interpolate occurrences into the returned event set
      dateMap,
      // Return a Map keyed by date each value being an array of events
      dayTime = null,
      storeFilterFn,
      // Private option. Select which date index to look up events in depending on the date
      // we are examining in the date iteration process. Some callers may want to use
      // different indices depending on the stage through the date iteration.
      // See Calendar package for usage.
      getDateIndex
    }) {
      var _a3;
      const me = this;
      if (dateMap == null ? void 0 : dateMap.clear) {
        dateMap.clear();
      } else {
        dateMap = /* @__PURE__ */ new Map();
      }
      if (me.count) {
        const dateIndex = me.useDayIndex(dayTime), indexName = startOnly ? "startDate" : "date", recurringEvents = [], filter2 = (e) => (!passedFilter || passedFilter(e)) && (!storeFilterFn || storeFilterFn(e)), baseEventFilter = (e) => notRecurring(e) && filter2(e);
        dayTime = dateIndex.dayTime;
        if (resourceRecord) {
          throw new Error("Querying for events for a resource and returning a date-keyed Map is not supported");
        } else {
          (_a3 = me.recurringEvents) == null ? void 0 : _a3.forEach((e) => {
            if (dayTime.startOfDay(e.startDate) < endDate) {
              recurringEvents.push(e);
            }
          });
          for (const date2 = new Date(startDate); date2 < endDate; date2.setDate(date2.getDate() + 1)) {
            let [coincidingEvents, key] = dateIndex.get(getDateIndex ? getDateIndex(date2) : indexName, date2, true);
            if (coincidingEvents == null ? void 0 : coincidingEvents.size) {
              coincidingEvents = [...coincidingEvents].filter(baseEventFilter);
              if (coincidingEvents.length) {
                (dateMap.get(key) || dateMap.set(key, []).get(key)).push(...coincidingEvents);
              }
            }
          }
        }
        for (let i = 0, { length } = recurringEvents; i < length; i++) {
          const e = recurringEvents[i], occurrences = (includeOccurrences ? e.getOccurrencesForDateRange(startDate, endDate) : [e]).filter(filter2), lastDate = DateHelper.add(endDate, 1, "day");
          for (let bucket, i2 = 0, { length: length2 } = occurrences; i2 < length2; i2++) {
            const occurrence = occurrences[i2], date2 = dayTime.startOfDay(occurrence.startDate), indexName2 = getDateIndex ? getDateIndex(date2) : startOnly ? "startDate" : "date", lastIntersectingDate = indexName2 === "startDate" || !occurrence.durationMS ? DateHelper.add(date2, 1, "day") : DateHelper.min(occurrence.endDate || DateHelper.add(occurrence.startDate, occurrence.duration, occurrence.durationUnit), lastDate);
            for (; date2 < lastIntersectingDate; date2.setDate(date2.getDate() + 1)) {
              const key = dayTime.dateKey(date2);
              (bucket = dateMap.get(key)) || dateMap.set(key, bucket = []);
              bucket.push(occurrence);
            }
          }
        }
      }
      return dateMap;
    }
  }, __publicField(_a2, "$name", "GetEventsMixin"), _a2;
};

// ../Scheduler/lib/Scheduler/data/util/EventDayIndex.js
var indexNameMap = {
  date: "_dateIndex",
  startDate: "_startDateIndex"
};
var indexProps = Object.values(indexNameMap);
var emptyArray12 = Object.freeze([]);
var { MILLIS_PER_DAY: MILLIS_PER_DAY2 } = DayTime;
var EventDayIndex = class {
  constructor(store, dayTime) {
    this.dayTime = dayTime || DayTime.MIDNIGHT;
    this.store = store;
    this.users = [this.dayTime];
  }
  /**
   * Adds an event record to the specified index (either "startDate" or "date") for a given `date`.
   * @param {String} indexName The index to which the event record is to be added (either "startDate" or "date").
   * @param {Date|Number} date A date for which the event record overlaps. The {@link Core.util.DayTime#function-dateKey}
   * method is used to convert this date to a "YYYY-MM-DD" key for the index.
   * @param {Scheduler.model.EventModel} eventRecord The event record.
   * @private
   */
  add(indexName, date, eventRecord) {
    const index = this[indexNameMap[indexName]], key = this.dayTime.dateKey(date), entry = index[key] || (index[key] = /* @__PURE__ */ new Set());
    entry.add(eventRecord);
  }
  /**
   * Adds an event record to all indexes for all dates which the event overlaps.
   * @param {Scheduler.model.EventModel} eventRecord The event record.
   * @private
   */
  addEvent(eventRecord) {
    var _a2, _b, _c;
    let dateMS = (_a2 = this.dayTime.startOfDay(eventRecord.startDate)) == null ? void 0 : _a2.getTime(), endDateMS;
    if (dateMS) {
      endDateMS = (_c = (_b = eventRecord.endDate) == null ? void 0 : _b.getTime()) != null ? _c : dateMS;
      this.add("startDate", dateMS, eventRecord);
      do {
        this.add("date", dateMS, eventRecord);
        dateMS += MILLIS_PER_DAY2;
      } while (dateMS < endDateMS);
    }
  }
  /**
   * Clear this index.
   */
  clear() {
    indexProps.forEach((name) => this[name] = /* @__PURE__ */ Object.create(null));
  }
  /**
   * Returns an object that has properties named by the {@link Core.util.DayTime#function-dateKey} method, or the
   * array of event records if a `date` is specified, or the event record array and the date key in a 2-element array
   * if `returnKey` is `true`.
   * @param {String} indexName The name of the desired index (either 'date' or 'startDate').
   * @param {Number|Date} date The date as a `Date` or the millisecond UTC epoch. When passed, this method will return
   * the array of event records for this date.
   * @param {Boolean} [returnKey] Specify `true` to return the date key along with the event record array.
   * @returns {Object|Scheduler.model.EventModel[]}
   */
  get(indexName, date, returnKey) {
    !this.initialized && this.initialize();
    let ret = this[indexNameMap[indexName]], key;
    if (date) {
      key = this.dayTime.dateKey(date);
      ret = returnKey ? [ret[key], key] : ret[key];
    }
    return ret;
  }
  /**
   * Called when this index is first used. Once called, further store changes will be used to maintain this index.
   * @private
   */
  initialize() {
    this.initialized = true;
    this.clear();
    this.sync("splice", this.store.storage.allValues);
  }
  invalidate() {
    this.initialized = false;
    indexProps.forEach((name) => this[name] = null);
  }
  /**
   * Returns `true` if the given `dayTime` matches this index.
   * @param {Core.util.DayTime} dayTime
   * @returns {Boolean}
   */
  matches(dayTime) {
    return this.dayTime.startShift === dayTime.startShift;
  }
  /**
   * Removes an event record from the specified index (either "startDate" or "date") for a given `date`.
   * @param {String} indexName The index to which the event record is to be removed (either "startDate" or "date").
   * @param {Date|Number} date A date for which the event record overlaps. The {@link Core.util.DayTime#function-dateKey}
   * method is used to convert this date to a "YYYY-MM-DD" key for the index.
   * @param {Scheduler.model.EventModel} eventRecord The event record.
   * @private
   */
  remove(indexName, date, eventRecord) {
    const index = this[indexNameMap[indexName]], key = this.dayTime.dateKey(date), entry = index[key];
    if (entry) {
      entry.delete(eventRecord);
    }
  }
  /**
   * Removes an event record from all indexes for all dates which the event overlaps.
   * @param {Scheduler.model.EventModel} eventRecord The event record.
   * @param {Date} startDate The start date for the event. This may be different from the `startDate` of the given
   * `eventRecord` when the event is rescheduled.
   * @param {Date} endDate The end date for the event. This may be different from the `endDate` of the given
   * `eventRecord` when the event is rescheduled.
   * @private
   */
  removeEvent(eventRecord, startDate, endDate) {
    var _a2, _b;
    let dateMS = (_a2 = this.dayTime.startOfDay(startDate)) == null ? void 0 : _a2.getTime(), endDateMS;
    if (dateMS) {
      endDateMS = (_b = endDate == null ? void 0 : endDate.getTime()) != null ? _b : dateMS;
      this.remove("startDate", dateMS, eventRecord);
      do {
        this.remove("date", dateMS, eventRecord);
        dateMS += MILLIS_PER_DAY2;
      } while (dateMS < endDateMS);
    }
  }
  sync(action, added, removed, replaced, wasSet) {
    var _a2, _b;
    added = added || emptyArray12;
    removed = removed || emptyArray12;
    const me = this, addedCount = added.length, removedCount = removed.length, replacedCount = replaced == null ? void 0 : replaced.length;
    let i, newEvent, outgoingEvent;
    if (!me.initialized) {
      return;
    }
    switch (action) {
      case "clear":
        me.clear();
        break;
      case "splice":
        if (replacedCount) {
          added = added.slice();
          removed = removed.slice();
          for (i = 0; i < replacedCount; i++) {
            removed.push(replaced[i][0]);
            added.push(replaced[i][1]);
          }
        }
        if (removedCount) {
          for (i = 0; i < removedCount; i++) {
            outgoingEvent = removed[i];
            me.removeEvent(outgoingEvent, outgoingEvent.startDate, outgoingEvent.endDate);
          }
        }
        if (addedCount) {
          for (i = 0; i < addedCount; i++) {
            newEvent = added[i];
            if (newEvent.isScheduled && !newEvent.isParent) {
              me.addEvent(newEvent);
            }
          }
        }
        break;
      case "reschedule":
        outgoingEvent = added[0];
        me.removeEvent(
          outgoingEvent,
          ((_a2 = wasSet.startDate) == null ? void 0 : _a2.oldValue) || outgoingEvent.startDate,
          ((_b = wasSet.endDate) == null ? void 0 : _b.oldValue) || outgoingEvent.endDate
        );
        me.sync("splice", added);
        break;
    }
  }
  /**
   * This method registers a `dayTime` instance with this index in the `users` array.
   * @param {Core.util.DayTime} dayTime The instance to register.
   */
  register(dayTime) {
    this.users.push(dayTime);
  }
  /**
   * This method unregisters a `dayTime` instance, removing it from the `users` array. This method returns `true` if
   * this was the last registered instance and this index is no longer needed.
   * @param {Core.util.DayTime} dayTime The instance to register.
   * @returns {Boolean}
   */
  unregister(dayTime) {
    const { users } = this, i = users.indexOf(dayTime);
    if (i > -1) {
      users.splice(i, 1);
    }
    return !users.length;
  }
};
var proto3 = EventDayIndex.prototype;
indexProps.forEach((name) => proto3[name] = null);
proto3.initialized = false;
EventDayIndex._$name = "EventDayIndex";

// ../Scheduler/lib/Scheduler/data/mixin/DayIndexMixin.js
var { MIDNIGHT } = DayTime;
var DayIndexMixin_default = (Target) => {
  var _a2;
  return _a2 = class extends Target {
    construct(config) {
      super.construct(config);
      this.dayIndices = null;
    }
    //region Keeping index in sync
    // Override to syncIndices on initial load
    afterLoadData() {
      var _a3;
      this.syncIndices("splice", this.storage.allValues);
      (_a3 = super.afterLoadData) == null ? void 0 : _a3.call(this);
    }
    /**
     * Responds to mutations of the underlying storage Collection.
     *
     * Maintain indices for fast finding of events by date.
     * @param {Object} event
     * @private
     */
    onDataChange({ action, added, removed, replaced }) {
      this.syncIndices(action, added, removed, replaced);
      super.onDataChange(...arguments);
    }
    onDataReplaced(action, data) {
      this.syncIndices("clear");
      this.syncIndices("splice", this.storage.values);
      super.onDataReplaced(action, data);
    }
    onModelChange(record, toSet, wasSet, silent, fromRelationUpdate) {
      if ("startDate" in wasSet || "endDate" in wasSet) {
        this.syncIndices("reschedule", [record], null, null, wasSet);
      }
      super.onModelChange(...arguments);
    }
    //endregion
    //region Index
    /**
     * Invalidates associated day indices.
     * @internal
     */
    invalidateDayIndices() {
      var _a3;
      (_a3 = this.dayIndices) == null ? void 0 : _a3.forEach((dayIndex) => dayIndex.invalidate());
    }
    /**
     * Registers a `DayTime` instance, creating an `EventDayIndex` for each distinct `startShift`. This index is
     * maintained until all instances with a matching `startShift` are {@link #function-unregisterDayIndex unregistered}.
     * @param {Core.util.DayTime} dayTime The instance to register.
     * @internal
     * @category Indexing
     */
    registerDayIndex(dayTime) {
      const me = this, dayIndices = me.dayIndices || (me.dayIndices = []);
      let dayIndex, i;
      for (i = 0; !dayIndex && i < dayIndices.length; ++i) {
        if (dayIndices[i].matches(dayTime)) {
          (dayIndex = dayIndices[i]).register(dayTime);
        }
      }
      !dayIndex && dayIndices.push(dayIndex = new EventDayIndex(me, dayTime));
      return dayIndex;
    }
    syncIndices(...args) {
      var _a3;
      (_a3 = this.dayIndices) == null ? void 0 : _a3.forEach((dayIndex) => dayIndex.sync(...args));
    }
    /**
     * Removes a registered `DayTime` instance. If this is the last instance registered to an `EventDayIndex`, that
     * index is removed.
     * @param {Core.util.DayTime} dayTime The instance to unregister.
     * @internal
     * @category Indexing
     */
    unregisterDayIndex(dayTime) {
      const me = this, { dayIndices } = me;
      for (let i = dayIndices == null ? void 0 : dayIndices.length; i-- > 0; ) {
        if (dayIndices[i].matches(dayTime)) {
          if (dayIndices[i].unregister(dayTime)) {
            dayIndices.splice(i, 1);
          }
          break;
        }
      }
    }
    /**
     * Returns the `EventDayIndex` to use for the given `DayTime` instance. This may be the primary instance or a
     * child instance created by {@link #function-registerDayIndex}.
     * @param {Core.util.DayTime} dayTime The `DayTime` of the desired index.
     * @returns {Scheduler.data.util.EventDayIndex}
     * @private
     * @category Indexing
     */
    useDayIndex(dayTime) {
      const me = this, { dayIndices } = me;
      dayTime = dayTime || MIDNIGHT;
      for (let i = 0; dayIndices && i < dayIndices.length; ++i) {
        if (dayIndices[i].matches(dayTime)) {
          return dayIndices[i];
        }
      }
      if (dayTime.startShift) {
        throw new Error(`No day index registered for ${dayTime} on ${me.id}`);
      }
      return me.registerDayIndex(MIDNIGHT);
    }
    //endregion
  }, __publicField(_a2, "$name", "DayIndexMixin"), _a2;
};

// ../Scheduler/lib/Scheduler/data/mixin/RecurringEventsMixin.js
var RecurringEventsMixin_default = (Target) => class RecurringEventsMixin extends RecurringTimeSpansMixin_default(Target || Base) {
  static get $name() {
    return "RecurringEventsMixin";
  }
  /**
   * Returns all the recurring events.
   *
   * **An alias for ** {@link Scheduler.data.mixin.RecurringTimeSpansMixin#function-getRecurringTimeSpans} method.
   *
   * @returns {Scheduler.model.EventModel[]} Array of recurring events.
   * @category Recurrence
   */
  getRecurringEvents() {
    return this.getRecurringTimeSpans();
  }
  isEventPersistable(event) {
    return super.isEventPersistable(event) && (!event.supportsRecurring || !event.isOccurrence);
  }
};

// ../Scheduler/lib/Scheduler/data/EventStore.js
var EngineMixin5 = PartOfProject_default(CoreEventStoreMixin.derive(AjaxStore));
var EventStore = class extends EngineMixin5.mixin(
  RecurringEventsMixin_default,
  EventStoreMixin_default,
  DayIndexMixin_default,
  GetEventsMixin_default
) {
  static get defaultConfig() {
    return {
      /**
       * Class used to represent records
       * @config {Scheduler.model.EventModel}
       * @typings {typeof EventModel}
       * @default
       * @category Common
       */
      modelClass: EventModel
    };
  }
};
__publicField(EventStore, "$name", "EventStore");
EventStore._$name = "EventStore";

// ../Scheduler/lib/Scheduler/data/mixin/DependencyStoreMixin.js
var DependencyStoreMixin_default = (Target) => class DependencyStoreMixin extends Target {
  static get $name() {
    return "DependencyStoreMixin";
  }
  /**
   * Add dependencies to the store.
   *
   * NOTE: References (fromEvent, toEvent) on the dependencies are determined async by a calculation engine. Thus they
   * cannot be directly accessed after using this function.
   *
   * For example:
   *
   * ```javascript
   * const [dependency] = dependencyStore.add({ from, to });
   * // dependency.fromEvent is not yet available
   * ```
   *
   * To guarantee references are set up, wait for calculations for finish:
   *
   * ```javascript
   * const [dependency] = dependencyStore.add({ from, to });
   * await dependencyStore.project.commitAsync();
   * // dependency.fromEvent is available (assuming EventStore is loaded and so on)
   * ```
   *
   * Alternatively use `addAsync()` instead:
   *
   * ```javascript
   * const [dependency] = await dependencyStore.addAsync({ from, to });
   * // dependency.fromEvent is available (assuming EventStore is loaded and so on)
   * ```
   *
   * @param {Scheduler.model.DependencyModel|Scheduler.model.DependencyModel[]|DependencyModelConfig|DependencyModelConfig[]} records
   * Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Scheduler.model.DependencyModel[]} Added records
   * @function add
   * @category CRUD
   */
  /**
   * Add dependencies to the store and triggers calculations directly after. Await this function to have up to date
   * references on the added dependencies.
   *
   * ```javascript
   * const [dependency] = await dependencyStore.addAsync({ from, to });
   * // dependency.fromEvent is available (assuming EventStore is loaded and so on)
   * ```
   *
   * @param {Scheduler.model.DependencyModel|Scheduler.model.DependencyModel[]|DependencyModelConfig|DependencyModelConfig[]} records
   * Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Scheduler.model.DependencyModel[]} Added records
   * @function addAsync
   * @category CRUD
   * @async
   */
  /**
   * Applies a new dataset to the DependencyStore. Use it to plug externally fetched data into the store.
   *
   * NOTE: References (fromEvent, toEvent) on the dependencies are determined async by a calculation engine. Thus
   * they cannot be directly accessed after assigning the new dataset.
   *
   * For example:
   *
   * ```javascript
   * dependencyStore.data = [{ from, to }];
   * // dependencyStore.first.fromEvent is not yet available
   * ```
   *
   * To guarantee references are available, wait for calculations for finish:
   *
   * ```javascript
   * dependencyStore.data = [{ from, to }];
   * await dependencyStore.project.commitAsync();
   * // dependencyStore.first.fromEvent is available
   * ```
   *
   * Alternatively use `loadDataAsync()` instead:
   *
   * ```javascript
   * await dependencyStore.loadDataAsync([{ from, to }]);
   * // dependencyStore.first.fromEvent is available
   * ```
   *
   * @member {DependencyModelConfig[]} data
   * @category Records
   */
  /**
   * Applies a new dataset to the DependencyStore and triggers calculations directly after. Use it to plug externally
   * fetched data into the store.
   *
   * ```javascript
   * await dependencyStore.loadDataAsync([{ from, to }]);
   * // dependencyStore.first.fromEvent is available
   * ```
   *
   * @param {DependencyModelConfig[]} data Array of DependencyModel data objects
   * @function loadDataAsync
   * @category CRUD
   * @async
   */
  static get defaultConfig() {
    return {
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 400,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 400,
      storeId: "dependencies"
    };
  }
  reduceEventDependencies(event, reduceFn, result, flat = true, depsGetterFn) {
    depsGetterFn = depsGetterFn || ((event2) => this.getEventDependencies(event2));
    event = ArrayHelper.asArray(event);
    event.reduce((result2, event2) => {
      if (event2.children && !flat) {
        event2.traverse((evt) => {
          result2 = depsGetterFn(evt).reduce(reduceFn, result2);
        });
      } else {
        result2 = depsGetterFn(event2).reduce(reduceFn, result2);
      }
    }, result);
    return result;
  }
  mapEventDependencies(event, fn2, filterFn, flat, depsGetterFn) {
    return this.reduceEventDependencies(event, (result, dependency) => {
      filterFn(dependency) && result.push(dependency);
      return result;
    }, [], flat, depsGetterFn);
  }
  mapEventPredecessors(event, fn2, filterFn, flat) {
    return this.reduceEventPredecessors(event, (result, dependency) => {
      filterFn(dependency) && result.push(dependency);
      return result;
    }, [], flat);
  }
  mapEventSuccessors(event, fn2, filterFn, flat) {
    return this.reduceEventSuccessors(event, (result, dependency) => {
      filterFn(dependency) && result.push(dependency);
      return result;
    }, [], flat);
  }
  /**
   * Returns all dependencies for a certain event (both incoming and outgoing)
   *
   * @param {Scheduler.model.EventModel} event
   * @returns {Scheduler.model.DependencyModel[]}
   */
  getEventDependencies(event) {
    return [].concat(event.predecessors || [], event.successors || []);
  }
  removeEventDependencies(event) {
    this.remove(this.getEventDependencies(event));
  }
  removeEventPredecessors(event) {
    this.remove(event.predecessors);
  }
  removeEventSuccessors(event, flat) {
    this.remove(event.successors);
  }
  getBySourceTargetId(key) {
    return this.records.find(
      (r) => key == this.constructor.makeDependencySourceTargetCompositeKey(r.from, r.to)
    );
  }
  /**
   * Returns dependency model instance linking tasks with given ids. The dependency can be forward (from 1st
   * task to 2nd) or backward (from 2nd to 1st).
   *
   * @param {Scheduler.model.EventModel|String} sourceEvent 1st event
   * @param {Scheduler.model.EventModel|String} targetEvent 2nd event
   * @returns {Scheduler.model.DependencyModel}
   */
  getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) {
    sourceEvent = Model.asId(sourceEvent);
    targetEvent = Model.asId(targetEvent);
    return this.getBySourceTargetId(this.constructor.makeDependencySourceTargetCompositeKey(sourceEvent, targetEvent));
  }
  /**
   * Returns a dependency model instance linking given events if such dependency exists in the store.
   * The dependency can be forward (from 1st event to 2nd) or backward (from 2nd to 1st).
   *
   * @param {Scheduler.model.EventModel|String} sourceEvent
   * @param {Scheduler.model.EventModel|String} targetEvent
   * @returns {Scheduler.model.DependencyModel}
   */
  getEventsLinkingDependency(sourceEvent, targetEvent) {
    return this.getDependencyForSourceAndTargetEvents(sourceEvent, targetEvent) || this.getDependencyForSourceAndTargetEvents(targetEvent, sourceEvent);
  }
  /**
   * Validation method used to validate a dependency. Override and return `true` to indicate that an
   * existing dependency between two tasks is valid. For a new dependency being created please see
   * {@link #function-isValidDependencyToCreate}.
   *
   * @param {Scheduler.model.DependencyModel|Scheduler.model.TimeSpan|Number|String} dependencyOrFromId The dependency
   * model, the from task/event or the id of the from task/event
   * @param {Scheduler.model.TimeSpan|Number|String} [toId] To task/event or id thereof if the first parameter is not
   * a dependency record
   * @param {Number} [type] Dependency {@link Scheduler.model.DependencyBaseModel#property-Type-static} if the first
   * parameter is not a dependency model instance.
   * @returns {Boolean}
   */
  async isValidDependency(dependencyOrFromId, toId, type) {
    let fromEvent = dependencyOrFromId, toEvent = toId;
    if (dependencyOrFromId == null) {
      return false;
    }
    if (dependencyOrFromId.isDependencyModel) {
      ({ fromEvent, toEvent } = dependencyOrFromId);
    }
    fromEvent = this.eventStore.getById(fromEvent);
    toEvent = this.eventStore.getById(toEvent);
    if (fromEvent && toEvent) {
      if (!fromEvent.project || !toEvent.project) {
        return false;
      }
      return this.project.isValidDependency(fromEvent, toEvent, type);
    }
    return dependencyOrFromId !== toId;
  }
  /**
   * Validation method used to validate a dependency while creating. Override and return `true` to indicate that
   * a new dependency is valid to be created.
   *
   * @param {Scheduler.model.TimeSpan|Number|String} fromId From event/task or id
   * @param {Scheduler.model.TimeSpan|Number|String} toId To event/task or id
   * @param {Number} type Dependency {@link Scheduler.model.DependencyBaseModel#property-Type-static}
   * @returns {Boolean}
   */
  isValidDependencyToCreate(fromId, toId, type) {
    return this.isValidDependency(fromId, toId, type);
  }
  /**
   * Returns all dependencies highlighted with the given CSS class
   *
   * @param {String} cls
   * @returns {Scheduler.model.DependencyBaseModel[]}
   */
  getHighlightedDependencies(cls) {
    return this.records.reduce((result, dep) => {
      if (dep.isHighlightedWith(cls))
        result.push(dep);
      return result;
    }, []);
  }
  static makeDependencySourceTargetCompositeKey(from, to) {
    return `source(${from})-target(${to})`;
  }
  //region Product neutral
  getTimeSpanDependencies(record) {
    return this.getEventDependencies(record);
  }
  //endregion
};

// ../Scheduler/lib/Scheduler/data/DependencyStore.js
var EngineMixin6 = PartOfProject_default(CoreDependencyStoreMixin.derive(AjaxStore));
var DependencyStore = class extends DependencyStoreMixin_default(EngineMixin6.derive(AjaxStore)) {
  static get defaultConfig() {
    return {
      modelClass: DependencyModel
    };
  }
};
DependencyStore._$name = "DependencyStore";

// ../Scheduler/lib/Scheduler/data/mixin/ResourceStoreMixin.js
var ResourceStoreMixin_default = (Target) => class ResourceStoreMixin extends (Target || Base) {
  static get $name() {
    return "ResourceStoreMixin";
  }
  get isResourceStore() {
    return true;
  }
  /**
   * Add resources to the store.
   *
   * NOTE: References (events, assignments) on the resources are determined async by a calculation engine. Thus they
   * cannot be directly accessed after using this function.
   *
   * For example:
   *
   * ```javascript
   * const [resource] = resourceStore.add({ id });
   * // resource.events is not yet available
   * ```
   *
   * To guarantee references are set up, wait for calculations for finish:
   *
   * ```javascript
   * const [resource] = resourceStore.add({ id });
   * await resourceStore.project.commitAsync();
   * // resource.events is available (assuming EventStore is loaded and so on)
   * ```
   *
   * Alternatively use `addAsync()` instead:
   *
   * ```javascript
   * const [resource] = await resourceStore.addAsync({ id });
   * // resource.events is available (assuming EventStore is loaded and so on)
   * ```
   *
   * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]|ResourceModelConfig|ResourceModelConfig[]} records
   * Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Scheduler.model.ResourceModel[]} Added records
   * @function add
   * @category CRUD
   */
  /**
   * Add resources to the store and triggers calculations directly after. Await this function to have up to date
   * references on the added resources.
   *
   * ```javascript
   * const [resource] = await resourceStore.addAsync({ id });
   * // resource.events is available (assuming EventStore is loaded and so on)
   * ```
   *
   * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]|ResourceModelConfig|ResourceModelConfig[]} records
   * Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Scheduler.model.ResourceModel[]} Added records
   * @function addAsync
   * @category CRUD
   * @async
   */
  /**
   * Applies a new dataset to the ResourceStore. Use it to plug externally fetched data into the store.
   *
   * NOTE: References (events, assignments) on the resources are determined async by a calculation engine. Thus
   * they cannot be directly accessed after assigning the new dataset.
   *
   * For example:
   *
   * ```javascript
   * resourceStore.data = [{ id }];
   * // resourceStore.first.events is not yet available
   * ```
   *
   * To guarantee references are available, wait for calculations for finish:
   *
   * ```javascript
   * resourceStore.data = [{ id }];
   * await resourceStore.project.commitAsync();
   * // resourceStore.first.events is available
   * ```
   *
   * Alternatively use `loadDataAsync()` instead:
   *
   * ```javascript
   * await resourceStore.loadDataAsync([{ id }]);
   * // resourceStore.first.events is available
   * ```
   *
   * @member {ResourceModelConfig[]} data
   * @category Records
   */
  /**
   * Applies a new dataset to the ResourceStore and triggers calculations directly after. Use it to plug externally
   * fetched data into the store.
   *
   * ```javascript
   * await resourceStore.loadDataAsync([{ id }]);
   * // resourceStore.first.events is available
   * ```
   *
   * @param {ResourceModelConfig[]} data Array of ResourceModel data objects
   * @function loadDataAsync
   * @category CRUD
   * @async
   */
  static get defaultConfig() {
    return {
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 200,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 100,
      storeId: "resources",
      autoTree: true
    };
  }
  construct(config) {
    super.construct(config);
    if (!this.modelClass.isResourceModel) {
      throw new Error("Model for ResourceStore must subclass ResourceModel");
    }
  }
  removeAll() {
    const result = super.removeAll(...arguments);
    result && this.assignmentStore.removeAll();
    return result;
  }
  // Apply id changes also to assignments (used to be handled automatically by relations earlier, but engine does not
  // care about ids so needed now)
  // problems:
  // 1. orientation/HorizontalRendering listens to assignment store changes and is trying to refresh view
  // When we update resource id on assignment, listener will be invoked and view will try to refresh. And it will
  // fail, because row is not updated yet. Flag is raised on resource store to make HorizontalRendering to skip
  // refreshing view in this particular case of resource id changing
  onRecordIdChange({ record, oldValue, value }) {
    super.onRecordIdChange({ record, oldValue, value });
    if (record.isFieldModified("id")) {
      this.isChangingId = true;
      record.updateAssignmentResourceIds();
      this.isChangingId = false;
    }
  }
  // Cache used by VerticalRendering, reset from there
  get allResourceRecords() {
    return this._allResourceRecords || (this._allResourceRecords = this.getAllDataRecords());
  }
  /**
   * Returns all resources that have no events assigned during the specified time range.
   * @param {Date} startDate Time range start date
   * @param {Date} endDate Time range end date
   * @returns {Scheduler.model.ResourceModel[]} Resources without events
   */
  getAvailableResources({ startDate, endDate }) {
    return this.query((resource) => this.eventStore.isDateRangeAvailable(startDate, endDate, null, resource));
  }
};

// ../Scheduler/lib/Scheduler/data/ResourceStore.js
var EngineMixin7 = PartOfProject_default(CoreResourceStoreMixin.derive(AjaxStore));
var ResourceStore = class extends ResourceStoreMixin_default(EngineMixin7) {
  static get defaultConfig() {
    return {
      modelClass: ResourceModel
    };
  }
};
ResourceStore._$name = "ResourceStore";

// ../Scheduler/lib/Scheduler/data/mixin/AssignmentStoreMixin.js
var AssignmentStoreMixin_default = (Target) => class AssignmentStoreMixin extends Target {
  static get $name() {
    return "AssignmentStoreMixin";
  }
  /**
   * Add assignments to the store.
   *
   * NOTE: References (event, resource) on the assignments are determined async by a calculation engine. Thus they
   * cannot be directly accessed after using this function.
   *
   * For example:
   *
   * ```javascript
   * const [assignment] = assignmentStore.add({ eventId, resourceId });
   * // assignment.event is not yet available
   * ```
   *
   * To guarantee references are set up, wait for calculations for finish:
   *
   * ```javascript
   * const [assignment] = assignmentStore.add({ eventId, resourceId });
   * await assignmentStore.project.commitAsync();
   * // assignment.event is available (assuming EventStore is loaded and so on)
   * ```
   *
   * Alternatively use `addAsync()` instead:
   *
   * ```javascript
   * const [assignment] = await assignmentStore.addAsync({ eventId, resourceId });
   * // assignment.event is available (assuming EventStore is loaded and so on)
   * ```
   *
   * @param {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]|AssignmentModelConfig|AssignmentModelConfig[]} records
   * Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Scheduler.model.AssignmentModel[]} Added records
   * @function add
   * @category CRUD
   */
  /**
   * Add assignments to the store and triggers calculations directly after. Await this function to have up to date
   * references on the added assignments.
   *
   * ```javascript
   * const [assignment] = await assignmentStore.addAsync({ eventId, resourceId });
   * // assignment.event is available (assuming EventStore is loaded and so on)
   * ```
   *
   * @param {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]|AssignmentModelConfig|AssignmentModelConfig[]} records
   * Array of records/data or a single record/data to add to store
   * @param {Boolean} [silent] Specify `true` to suppress events
   * @returns {Scheduler.model.AssignmentModel[]} Added records
   * @function addAsync
   * @category CRUD
   * @async
   */
  /**
   * Applies a new dataset to the AssignmentStore. Use it to plug externally fetched data into the store.
   *
   * NOTE: References (assignments, resources) on the assignments are determined async by a calculation engine. Thus
   * they cannot be directly accessed after assigning the new dataset.
   *
   * For example:
   *
   * ```javascript
   * assignmentStore.data = [{ eventId, resourceId }];
   * // assignmentStore.first.event is not yet available
   * ```
   *
   * To guarantee references are available, wait for calculations for finish:
   *
   * ```javascript
   * assignmentStore.data = [{ eventId, resourceId  }];
   * await assignmentStore.project.commitAsync();
   * // assignmentStore.first.event is available
   * ```
   *
   * Alternatively use `loadDataAsync()` instead:
   *
   * ```javascript
   * await assignmentStore.loadDataAsync([{ eventId, resourceId }]);
   * // assignmentStore.first.event is available
   * ```
   *
   * @member {AssignmentModelConfig[]} data
   * @category Records
   */
  /**
   * Applies a new dataset to the AssignmentStore and triggers calculations directly after. Use it to plug externally
   * fetched data into the store.
   *
   * ```javascript
   * await assignmentStore.loadDataAsync([{ eventId, resourceId }]);
   * // assignmentStore.first.event is available
   * ```
   *
   * @param {AssignmentModelConfig[]} data Array of AssignmentModel data objects
   * @function loadDataAsync
   * @category CRUD
   * @async
   */
  static get defaultConfig() {
    return {
      /**
       * CrudManager must load stores in the correct order. Lowest first.
       * @private
       */
      loadPriority: 300,
      /**
       * CrudManager must sync stores in the correct order. Lowest first.
       * @private
       */
      syncPriority: 300,
      storeId: "assignments"
    };
  }
  add(newAssignments, ...args) {
    var _a2;
    newAssignments = ArrayHelper.asArray(newAssignments);
    for (let i = 0; i < newAssignments.length; i++) {
      let assignment = newAssignments[i];
      if (!(assignment instanceof Model)) {
        newAssignments[i] = assignment = this.createRecord(assignment);
      }
      if (!this.isSyncingDataOnLoad && this.storage.findIndex("eventResourceKey", assignment.eventResourceKey, true) !== -1) {
        throw new Error(`Duplicate assignment Event: ${assignment.eventId} to resource: ${assignment.resourceId}`);
      }
      if ((_a2 = assignment.event) == null ? void 0 : _a2.isCreating) {
        assignment.isCreating = true;
      }
    }
    return super.add(newAssignments, ...args);
  }
  includesAssignment(eventId, resourceId) {
    return this.storage.findIndex("eventResourceKey", `${eventId}-${resourceId}`, true) !== -1;
  }
  setStoreData(data) {
    if (this.usesSingleAssignment) {
      throw new Error("Data loading into AssignmentStore (multi-assignment mode) cannot be combined EventStore data containing resourceId (single-assignment mode)");
    }
    super.setStoreData(data);
  }
  //region Init & destroy
  // This index fixes poor performance when you add large number of events to an event store with large number of
  // events - if cache is missing existing records are iterated n times.
  // https://github.com/bryntum/support/issues/3154#issuecomment-881336588
  set storage(storage) {
    super.storage = storage;
    this.storage.addIndex({
      property: "eventResourceKey",
      dependentOn: { event: true, resource: true },
      onDuplicate(assignment) {
        console.warn(`Duplicate assignment of event ${assignment.eventId} to resource ${assignment.resourceId}`);
      }
    });
  }
  get storage() {
    return this._storage || super.storage;
  }
  //endregion
  //region Stores
  // To not have to do instanceof checks
  get isAssignmentStore() {
    return true;
  }
  //endregion
  //region Recurrence
  /**
   * Returns a "fake" assignment used to identify a certain occurrence of a recurring event.
   * If passed the original event, it returns `originalAssignment`.
   * @param {Scheduler.model.AssignmentModel} originalAssignment
   * @param {Scheduler.model.EventModel} occurrence
   * @returns {Object} Temporary assignment
   * @internal
   */
  getOccurrence(originalAssignment, occurrence) {
    if (!originalAssignment || !(occurrence == null ? void 0 : occurrence.isOccurrence)) {
      return originalAssignment;
    }
    const me = this;
    return {
      id: `${occurrence.id}:a${originalAssignment.id}`,
      event: occurrence,
      resource: originalAssignment.resource,
      eventId: occurrence.id,
      resourceId: originalAssignment.resource.id,
      isAssignment: true,
      // This field is required to distinguish this fake assignment when event is being removed from UI
      isOccurrenceAssignment: true,
      // Not being an actual record, instanceMeta is stored on the store instead
      instanceMeta(instanceOrId) {
        return me.occurrenceInstanceMeta(this, instanceOrId);
      }
    };
  }
  // Per fake assignment instance meta, stored on store since fakes are always generated on demand
  occurrenceInstanceMeta(occurrenceAssignment, instanceOrId) {
    const me = this, instanceId = instanceOrId.id || instanceOrId, { id } = occurrenceAssignment;
    let { occurrenceMeta } = me;
    if (!occurrenceMeta) {
      occurrenceMeta = me.occurrenceMeta = {};
    }
    if (!occurrenceMeta[id]) {
      occurrenceMeta[id] = {};
    }
    return occurrenceMeta[id][instanceId] || (occurrenceMeta[id][instanceId] = {});
  }
  //endregion
  //region Mapping
  /**
   * Maps over event assignments.
   *
   * @param {Scheduler.model.EventModel} event
   * @param {Function} [fn]
   * @param {Function} [filterFn]
   * @returns {Scheduler.model.EventModel[]|Array}
   * @category Assignments
   */
  mapAssignmentsForEvent(event, fn2, filterFn) {
    event = this.eventStore.getById(event);
    const fnSet = Boolean(fn2), filterFnSet = Boolean(filterFn);
    if (fnSet || filterFnSet) {
      return event.assignments.reduce((result, assignment) => {
        const mapResult = fnSet ? fn2(assignment) : assignment;
        if (!filterFnSet || filterFn(mapResult)) {
          result.push(mapResult);
        }
        return result;
      }, []);
    }
    return event.assignments;
  }
  /**
   * Maps over resource assignments.
   *
   * @param {Scheduler.model.ResourceModel|Number|String} resource
   * @param {Function} [fn]
   * @param {Function} [filterFn]
   * @returns {Scheduler.model.ResourceModel[]|Array}
   * @category Assignments
   */
  mapAssignmentsForResource(resource, fn2, filterFn) {
    resource = this.resourceStore.getById(resource);
    const fnSet = Boolean(fn2), filterFnSet = Boolean(filterFn);
    if (fnSet || filterFnSet) {
      return resource.assignments.reduce((result, assignment) => {
        const mapResult = fnSet ? fn2(assignment) : assignment;
        if (!filterFnSet || filterFn(mapResult)) {
          result.push(mapResult);
        }
        return result;
      }, []);
    }
    return resource.assignments;
  }
  /**
   * Returns all assignments for a given event.
   *
   * @param {Scheduler.model.TimeSpan} event
   * @returns {Scheduler.model.AssignmentModel[]}
   * @category Assignments
   */
  getAssignmentsForEvent(event) {
    return event.assignments;
  }
  /**
   * Removes all assignments for given event
   *
   * @param {Scheduler.model.TimeSpan} event
   * @category Assignments
   */
  removeAssignmentsForEvent(event) {
    return this.remove(event.assignments);
  }
  /**
   * Returns all assignments for a given resource.
   *
   * @param {Scheduler.model.ResourceModel} resource
   * @returns {Scheduler.model.AssignmentModel[]}
   * @category Assignments
   */
  getAssignmentsForResource(resource) {
    resource = this.resourceStore.getById(resource);
    return resource.assignments;
  }
  /**
   * Removes all assignments for given resource
   *
   * @param {Scheduler.model.ResourceModel|*} resource
   * @category Assignments
   */
  removeAssignmentsForResource(resource) {
    this.remove(this.getAssignmentsForResource(resource));
  }
  /**
   * Returns all resources assigned to an event.
   *
   * @param {Scheduler.model.EventModel} event
   * @returns {Scheduler.model.ResourceModel[]}
   * @category Assignments
   */
  getResourcesForEvent(event) {
    return event.resources;
  }
  /**
   * Returns all events assigned to a resource
   *
   * @param {Scheduler.model.ResourceModel|String|Number} resource
   * @returns {Scheduler.model.TimeSpan[]}
   * @category Assignments
   */
  getEventsForResource(resource) {
    resource = this.resourceStore.getById(resource);
    return resource == null ? void 0 : resource.events;
  }
  /**
   * Creates and adds assignment record(s) for a given event and resource(s).
   *
   * @param {Scheduler.model.TimeSpan} event
   * @param {Scheduler.model.ResourceModel|Scheduler.model.ResourceModel[]} resources The resource(s) to assign to the event
   * @param {Function} [assignmentSetupFn] A hook function which takes an assignment as its argument and must return an assignment.
   * @param {Boolean} [removeExistingAssignments] `true` to remove assignments for other resources
   * @returns {Scheduler.model.AssignmentModel[]} An array with the created assignment(s)
   * @category Assign
   */
  assignEventToResource(event, resources, assignmentSetupFn = null, removeExistingAssignments = false) {
    var _a2, _b, _c;
    const me = this, toRemove = removeExistingAssignments ? new Set(event.assignments) : null;
    resources = ArrayHelper.asArray(resources).map((r) => {
      var _a3;
      return (_a3 = r.$original) != null ? _a3 : r;
    });
    if ((_a2 = me.eventStore) == null ? void 0 : _a2.usesSingleAssignment) {
      if ((_b = event.assignments) == null ? void 0 : _b.length) {
        if (!me.isEventAssignedToResource(event, resources[0])) {
          event.resource = resources[0];
        }
        return [];
      } else {
        event.resourceId = (_c = resources[0]) == null ? void 0 : _c.id;
      }
    }
    let newAssignments = [];
    me.suspendAutoCommit();
    resources.forEach((resource) => {
      var _a3;
      const existingAssignment = me.getAssignmentForEventAndResource(event, resource);
      if (!existingAssignment) {
        const assignment = {
          event,
          resource
        };
        newAssignments.push((_a3 = assignmentSetupFn == null ? void 0 : assignmentSetupFn(assignment)) != null ? _a3 : assignment);
      } else if (removeExistingAssignments) {
        toRemove.delete(existingAssignment);
      }
    });
    newAssignments = me.add(newAssignments);
    if (removeExistingAssignments) {
      me.remove(Array.from(toRemove));
    }
    me.resumeAutoCommit();
    return newAssignments;
  }
  /**
   * Removes assignment record for a given event and resource.
   *
   * @param {Scheduler.model.TimeSpan|String|Number} event
   * @param {Scheduler.model.ResourceModel|String|Number} [resources] The resource to unassign the event from. If omitted, all resources of the events will be unassigned
   * @returns {Scheduler.model.AssignmentModel|Scheduler.model.AssignmentModel[]}
   * @category Assign
   */
  unassignEventFromResource(event, resources) {
    const me = this, assignmentsToRemove = [];
    if (!resources) {
      return me.removeAssignmentsForEvent(event);
    }
    resources = ArrayHelper.asArray(resources);
    for (let i = 0; i < resources.length; i++) {
      if (me.isEventAssignedToResource(event, resources[i])) {
        assignmentsToRemove.push(me.getAssignmentForEventAndResource(event, resources[i]));
      }
    }
    return me.remove(assignmentsToRemove);
  }
  /**
   * Checks whether an event is assigned to a resource.
   *
   * @param {Scheduler.model.EventModel|String|Number} event Event record or id
   * @param {Scheduler.model.ResourceModel|String|Number} resource Resource record or id
   * @returns {Boolean}
   * @category Assignments
   */
  isEventAssignedToResource(event, resource) {
    return Boolean(this.getAssignmentForEventAndResource(event, resource));
  }
  /**
   * Returns an assignment record for a given event and resource
   *
   * @param {Scheduler.model.EventModel|String|Number} event The event or its id
   * @param {Scheduler.model.ResourceModel|String|Number} resource The resource or its id
   * @returns {Scheduler.model.AssignmentModel}
   * @category Assignments
   */
  getAssignmentForEventAndResource(event, resource) {
    let assignments;
    if (!(event = this.eventStore.getById(event)) || !(assignments = event.assignments) || // Also note that resources are looked for in the master store if chained, to handle dragging between
    // schedulers using chained versions of the same resource store. Needed since assignmentStore is shared and
    // might point to wrong resourceStore (can only point to one)
    !(resource = this.resourceStore.$master.getById(resource))) {
      return null;
    }
    return this.getOccurrence(assignments.find((a) => {
      var _a2;
      return ((_a2 = a.resource) == null ? void 0 : _a2.$original) === resource.$original;
    }), event);
  }
  //endregion
};

// ../Scheduler/lib/Scheduler/data/AssignmentStore.js
var EngineMixin8 = PartOfProject_default(CoreAssignmentStoreMixin.derive(AjaxStore));
var AssignmentStore = class extends AssignmentStoreMixin_default(EngineMixin8) {
  static get defaultConfig() {
    return {
      modelClass: AssignmentModel
    };
  }
};
__publicField(AssignmentStore, "$name", "AssignmentStore");
AssignmentStore._$name = "AssignmentStore";

// ../Scheduler/lib/Scheduler/model/ProjectModel.js
var EngineMixin9 = SchedulerCoreProjectMixin;
var ProjectModel = class extends ProjectCurrentConfig_default(ProjectModelMixin_default(EngineMixin9)) {
  static get $name() {
    return "ProjectModel";
  }
  //region Inline data configs & properties
  /**
   * @hidefields id, readOnly, children, parentId, parentIndex
   */
  /**
   * A flag, indicating whether the dates and duration calculations should adjust the result to DST time shift.
   *
   * @config {Boolean} adjustDurationToDST
   * @default false
   */
  /**
   * Get/set {@link #property-eventStore} data.
   *
   * Always returns an array of {@link Scheduler.model.EventModel EventModels} but also accepts an array of
   * its configuration objects as input.
   *
   * @member {Scheduler.model.EventModel[]} events
   * @accepts {Scheduler.model.EventModel[]|EventModelConfig[]}
   * @category Inline data
   */
  /**
   * Data use to fill the {@link #property-eventStore}. Should be an array of
   * {@link Scheduler.model.EventModel EventModels} or its configuration objects.
   *
   * @config {Scheduler.model.EventModel[]|EventModelConfig[]} events
   * @category Inline data
   */
  /**
   * Get/set {@link #property-resourceStore} data.
   *
   * Always returns an array of {@link Scheduler.model.ResourceModel ResourceModels} but also accepts an array
   * of its configuration objects as input.
   *
   * @member {Scheduler.model.ResourceModel[]} resources
   * @accepts {Scheduler.model.ResourceModel[]|ResourceModelConfig[]}
   * @category Inline data
   */
  /**
   * Data use to fill the {@link #property-resourceStore}. Should be an array of
   * {@link Scheduler.model.ResourceModel ResourceModels} or its configuration objects.
   *
   * @config {Scheduler.model.ResourceModel[]|ResourceModelConfig[]} resources
   * @category Inline data
   */
  /**
   * Get/set {@link #property-assignmentStore} data.
   *
   * Always returns an array of {@link Scheduler.model.AssignmentModel AssignmentModels} but also accepts an
   * array of its configuration objects as input.
   *
   * @member {Scheduler.model.AssignmentModel[]} assignments
   * @accepts {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]}
   * @category Inline data
   */
  /**
   * Data use to fill the {@link #property-assignmentStore}. Should be an array of
   * {@link Scheduler.model.AssignmentModel AssignmentModels} or its configuration objects.
   *
   * @config {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]} assignments
   * @category Inline data
   */
  /**
   * Get/set {@link #property-dependencyStore} data.
   *
   * Always returns an array of {@link Scheduler.model.DependencyModel DependencyModels} but also accepts an
   * array of its configuration objects as input.
   *
   * @member {Scheduler.model.DependencyModel[]} dependencies
   * @accepts {Scheduler.model.DependencyModel[]|DependencyModelConfig[]}
   * @category Inline data
   */
  /**
   * Data use to fill the {@link #property-dependencyStore}. Should be an array of
   * {@link Scheduler.model.DependencyModel DependencyModels} or its configuration objects.
   *
   * @config {Scheduler.model.DependencyModel[]|DependencyModelConfig[]} dependencies
   * @category Inline data
   */
  /**
   * Get/set {@link #property-timeRangeStore} data.
   *
   * Always returns an array of {@link Scheduler.model.TimeRangeModel TimeRangeModels} but also accepts an
   * array of its configuration objects as input.
   *
   * @member {Scheduler.model.TimeRangeModel[]} timeRanges
   * @accepts {Scheduler.model.TimeRangeModel[]|TimeRangeModelConfig[]}
   * @category Inline data
   */
  /**
   * Data use to fill the {@link #property-timeRangeStore}. Should be an array of
   * {@link Scheduler.model.TimeRangeModel TimeRangeModels} or its configuration objects.
   *
   * @config {Scheduler.model.TimeRangeModel[]|TimeRangeModelConfig[]} timeRanges
   * @category Inline data
   */
  /**
   * Get/set {@link #property-resourceTimeRangeStore} data.
   *
   * Always returns an array of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModels} but
   * also accepts an array of its configuration objects as input.
   *
   * @member {Scheduler.model.ResourceTimeRangeModel[]} resourceTimeRanges
   * @accepts {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]}
   * @category Inline data
   */
  /**
   * Data use to fill the {@link #property-resourceTimeRangeStore}. Should be an array
   * of {@link Scheduler.model.ResourceTimeRangeModel ResourceTimeRangeModels} or its configuration objects.
   *
   * @config {Scheduler.model.ResourceTimeRangeModel[]|ResourceTimeRangeModelConfig[]} resourceTimeRanges
   * @category Inline data
   */
  //endregion
  //region Legacy inline data configs & properties
  /**
   * The initial data, to fill the {@link #property-eventStore} with.
   * Should be an array of {@link Scheduler.model.EventModel EventModels} or its configuration objects.
   *
   * @config {Scheduler.model.EventModel[]|EventModelConfig[]} eventsData
   * @category Legacy inline data
   */
  /**
   * The initial data, to fill the {@link #property-dependencyStore} with.
   * Should be an array of {@link Scheduler.model.DependencyModel DependencyModels} or its configuration
   * objects.
   *
   * @config {Scheduler.model.DependencyModel[]|DependencyModelConfig[]} [dependenciesData]
   * @category Legacy inline data
   */
  /**
   * The initial data, to fill the {@link #property-resourceStore} with.
   * Should be an array of {@link Scheduler.model.ResourceModel ResourceModels} or its configuration objects.
   *
   * @config {Scheduler.model.ResourceModel[]|ResourceModelConfig[]} [resourcesData]
   * @category Legacy inline data
   */
  /**
   * The initial data, to fill the {@link #property-assignmentStore} with.
   * Should be an array of {@link Scheduler.model.AssignmentModel AssignmentModels} or its configuration
   * objects.
   *
   * @config {Scheduler.model.AssignmentModel[]|AssignmentModelConfig[]} [assignmentsData]
   * @category Legacy inline data
   */
  //endregion
  //region Store configs & properties
  /**
   * The {@link Scheduler.data.EventStore store} holding the events information.
   *
   * See also {@link Scheduler.model.EventModel}
   *
   * @member {Scheduler.data.EventStore} eventStore
   * @category Models & Stores
   */
  /**
   * An {@link Scheduler.data.EventStore} instance or a config object.
   * @config {Scheduler.data.EventStore|EventStoreConfig} eventStore
   * @category Models & Stores
   */
  /**
   * The {@link Scheduler.data.DependencyStore store} holding the dependencies information.
   *
   * See also {@link Scheduler.model.DependencyModel}
   *
   * @member {Scheduler.data.DependencyStore} dependencyStore
   * @category Models & Stores
   */
  /**
   * A {@link Scheduler.data.DependencyStore} instance or a config object.
   * @config {Scheduler.data.DependencyStore|DependencyStoreConfig} dependencyStore
   * @category Models & Stores
   */
  /**
   * The {@link Scheduler.data.ResourceStore store} holding the resources that can be assigned to the events in the event store.
   *
   * See also {@link Scheduler.model.ResourceModel}
   *
   * @member {Scheduler.data.ResourceStore} resourceStore
   * @category Models & Stores
   */
  /**
   * A {@link Scheduler.data.ResourceStore} instance or a config object.
   * @config {Scheduler.data.ResourceStore|ResourceStoreConfig} resourceStore
   * @category Models & Stores
   */
  /**
   * The {@link Scheduler.data.AssignmentStore store} holding the assignments information.
   *
   * See also {@link Scheduler.model.AssignmentModel}
   *
   * @member {Scheduler.data.AssignmentStore} assignmentStore
   * @category Models & Stores
   */
  /**
   * An {@link Scheduler.data.AssignmentStore} instance or a config object.
   * @config {Scheduler.data.AssignmentStore|AssignmentStoreConfig} assignmentStore
   * @category Models & Stores
   */
  //endregion
  //region Configs
  static get defaultConfig() {
    return {
      /**
       * The constructor of the event model class, to be used in the project. Will be set as the
       * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-eventStore}
       *
       * @config {Scheduler.model.EventModel}
       * @typings {typeof EventModel}
       * @category Models & Stores
       */
      eventModelClass: EventModel,
      /**
       * The constructor of the dependency model class, to be used in the project. Will be set as the
       * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-dependencyStore}
       *
       * @config {Scheduler.model.DependencyModel}
       * @typings {typeof DependencyModel}
       * @category Models & Stores
       */
      dependencyModelClass: DependencyModel,
      /**
       * The constructor of the resource model class, to be used in the project. Will be set as the
       * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-resourceStore}
       *
       * @config {Scheduler.model.ResourceModel}
       * @typings {typeof ResourceModel}
       * @category Models & Stores
       */
      resourceModelClass: ResourceModel,
      /**
       * The constructor of the assignment model class, to be used in the project. Will be set as the
       * {@link Core.data.Store#config-modelClass modelClass} property of the {@link #property-assignmentStore}
       *
       * @config {Scheduler.model.AssignmentModel}
       * @typings {typeof AssignmentModel}
       * @category Models & Stores
       */
      assignmentModelClass: AssignmentModel,
      /**
       * The constructor to create an event store instance with. Should be a class, subclassing the
       * {@link Scheduler.data.EventStore}
       * @config {Scheduler.data.EventStore|Object}
       * @typings {typeof EventStore|object}
       * @category Models & Stores
       */
      eventStoreClass: EventStore,
      /**
       * The constructor to create a dependency store instance with. Should be a class, subclassing the
       * {@link Scheduler.data.DependencyStore}
       * @config {Scheduler.data.DependencyStore|Object}
       * @typings {typeof DependencyStore|object}
       * @category Models & Stores
       */
      dependencyStoreClass: DependencyStore,
      /**
       * The constructor to create a resource store instance with. Should be a class, subclassing the
       * {@link Scheduler.data.ResourceStore}
       * @config {Scheduler.data.ResourceStore|Object}
       * @typings {typeof ResourceStore|object}
       * @category Models & Stores
       */
      resourceStoreClass: ResourceStore,
      /**
       * The constructor to create an assignment store instance with. Should be a class, subclassing the
       * {@link Scheduler.data.AssignmentStore}
       * @config {Scheduler.data.AssignmentStore|Object}
       * @typings {typeof AssignmentStore|object}
       * @category Models & Stores
       */
      assignmentStoreClass: AssignmentStore
    };
  }
  //endregion
  //region Events
  /**
   * Fired when the engine has finished its calculations and the results has been written back to the records.
   *
   * ```javascript
   * scheduler.project.on({
   *     dataReady() {
   *        console.log('Calculations finished');
   *     }
   * });
   *
   * scheduler.eventStore.first.duration = 10;
   *
   * // At some point a bit later it will log 'Calculations finished'
   * ```
   *
   * @event dataReady
   * @param {Scheduler.model.ProjectModel} source The project
   * @typings source -> {Scheduler.model.ProjectModel||any}
   * @param {Boolean} isInitialCommit Flag that shows if this commit is initial
   * @param {Set} records Set of all {@link Core.data.Model}s that were modified in the completed transaction.
   * Use the {@link Core.data.Model#property-modifications} property of each Model to identify
   * modified fields.
   */
  //endregion
  /**
   * Silences propagations caused by the project loading.
   *
   * Applying the loaded data to the project occurs in two basic stages:
   *
   * 1. Data gets into the engine graph which triggers changes propagation
   * 2. The changes caused by the propagation get written to related stores
   *
   * Setting this flag to `true` makes the component perform step 2 silently without triggering events causing reactions on those changes
   * (like sending changes back to the server if `autoSync` is enabled) and keeping stores in unmodified state.
   *
   * This is safe if the loaded data is consistent so propagation doesn't really do any adjustments.
   * By default the system treats the data as consistent so this option is `true`.
   *
   * ```js
   * new Scheduler({
   *     project : {
   *         // We want scheduling engine to recalculate the data properly
   *         // so then we could save it back to the server
   *         silenceInitialCommit : false
   *     }
   *     ...
   * })
   * ```
   *
   * @config {Boolean} silenceInitialCommit
   * @default true
   * @category Advanced
   */
  construct(...args) {
    super.construct(...args);
    if (VersionHelper.isTestEnv) {
      globalThis.bryntum.testProject = this;
    }
    this.modelPersistencyManager = this.createModelPersistencyManager();
  }
  /**
   * Creates and returns model persistency manager
   *
   * @returns {Scheduler.data.util.ModelPersistencyManager}
   * @internal
   */
  createModelPersistencyManager() {
    return new ModelPersistencyManager({
      eventStore: this,
      resourceStore: this.resourceStore,
      assignmentStore: this.assignmentStore,
      dependencyStore: this.dependencyStore
    });
  }
  doDestroy() {
    this.modelPersistencyManager.destroy();
    super.doDestroy();
  }
  // To comply with TaskBoards expectations
  get taskStore() {
    return this.eventStore;
  }
};
ProjectModel.applyConfigs = true;
ProjectModel.initClass();
ProjectModel._$name = "ProjectModel";

// ../Scheduler/lib/Scheduler/crud/mixin/AbstractCrudManagerValidation.js
var AbstractCrudManagerValidation_default = (Target) => class AbstractCrudManagerValidation extends Target {
  static get $name() {
    return "AbstractCrudManagerValidation";
  }
  static get configurable() {
    return {
      /**
       * This config validates the response structure for requests made by the Crud Manager.
       * When `true`, the Crud Manager checks every parsed response structure for errors
       * and if the response format is invalid, a warning is logged to the browser console.
       *
       * The config is intended to help developers implementing backend integration.
       *
       * @config {Boolean}
       * @default
       * @category CRUD
       */
      validateResponse: true,
      /**
       * When `true` treats parsed responses without `success` property as successful.
       * In this mode a parsed response is treated as invalid if it has explicitly set `success : false`.
       * @config {Boolean}
       * @default
       * @category CRUD
       */
      skipSuccessProperty: true,
      crudLoadValidationWarningPrefix: "CrudManager load response error(s):",
      crudSyncValidationWarningPrefix: "CrudManager sync response error(s):",
      supportShortSyncResponseNote: 'Note: Please consider enabling "supportShortSyncResponse" option to allow less detailed sync responses (https://bryntum.com/products/scheduler/docs/api/Scheduler/crud/AbstractCrudManagerMixin#config-supportShortSyncResponse)',
      disableValidationNote: 'Note: To disable this validation please set the "validateResponse" config to false'
    };
  }
  get crudLoadValidationMandatoryStores() {
    return [];
  }
  getStoreLoadResponseWarnings(storeInfo, responded, expectedResponse) {
    const messages = [], { storeId } = storeInfo, mandatoryStores = this.crudLoadValidationMandatoryStores, result = { [storeId]: {} };
    if (responded) {
      if (!responded.rows) {
        messages.push(`- "${storeId}" store section should have a "rows" property with an array of the store records.`);
        result[storeId].rows = ["..."];
      }
    } else if (mandatoryStores == null ? void 0 : mandatoryStores.includes(storeId)) {
      messages.push(`- No "${storeId}" store section found. It should contain the store data.`);
      result[storeId].rows = ["..."];
    }
    if (messages.length) {
      Object.assign(expectedResponse, result);
    }
    return messages;
  }
  getLoadResponseWarnings(response) {
    const messages = [], expectedResponse = {};
    if (!this.skipSuccessProperty) {
      expectedResponse.success = true;
    }
    this.forEachCrudStore((store, storeId, storeInfo) => {
      messages.push(...this.getStoreLoadResponseWarnings(storeInfo, response == null ? void 0 : response[storeId], expectedResponse));
    });
    if (messages.length) {
      messages.push("Please adjust your response to look like this:\n" + JSON.stringify(expectedResponse, null, 4).replace(/"\.\.\."/g, "..."));
      messages.push(this.disableValidationNote);
    }
    return messages;
  }
  validateLoadResponse(response) {
    const messages = this.getLoadResponseWarnings(response);
    if (messages.length) {
      console.warn(this.crudLoadValidationWarningPrefix + "\n" + messages.join("\n"));
    }
  }
  getStoreSyncResponseWarnings(storeInfo, requested, responded, expectedResponse) {
    const messages = [], missingRows = [], missingRemoved = [], { storeId } = storeInfo, result = { [storeId]: {} }, phantomIdField = storeInfo.phantomIdField || this.phantomIdField, { modelClass } = storeInfo.store, { idField } = modelClass, respondedRows = (responded == null ? void 0 : responded.rows) || [], respondedRemoved = (responded == null ? void 0 : responded.removed) || [];
    let showSupportShortSyncResponseNote = false;
    if (requested == null ? void 0 : requested.added) {
      missingRows.push(
        ...requested.added.filter((record) => {
          return !respondedRows.find((row) => row[phantomIdField] == record[phantomIdField]) && !respondedRemoved.find((row) => row[phantomIdField] == record[phantomIdField] || row[idField] == record[phantomIdField]);
        }).map((record) => ({ [phantomIdField]: record[phantomIdField], [idField]: "..." }))
      );
      if (missingRows.length) {
        const missingIds = missingRows.map((row) => "#" + row[phantomIdField]).join(", ");
        messages.push(`- "${storeId}" store "rows" section should mention added record(s) ${missingIds} sent in the request. It should contain the added records identifiers (both phantom and "real" ones assigned by the backend).`);
      }
    }
    if (this.supportShortSyncResponse) {
      if (!missingRows.length && responded) {
        if (typeof responded !== "object" || Array.isArray(responded)) {
          messages.push(`- "${storeId}" store section should be an Object.`);
          result[storeId]["..."] = "...";
        }
        if (responded.rows && !Array.isArray(responded.rows)) {
          messages.push(`- "${storeId}" store "rows" section should be an array`);
          missingRows.push("...");
        }
        if (responded.removed && !Array.isArray(responded.removed)) {
          messages.push(`- "${storeId}" store "removed" section should be an array:`);
          missingRemoved.push("...");
        }
      }
    } else {
      if (requested == null ? void 0 : requested.updated) {
        const missingUpdatedRows = requested.updated.filter((record) => !respondedRows.find((row) => row[idField] == record[idField])).map((record) => ({ [idField]: record[idField] }));
        missingRows.push(...missingUpdatedRows);
        if (missingUpdatedRows.length) {
          const missingIds = missingUpdatedRows.map((row) => "#" + row[idField]).join(", ");
          messages.push(`- "${storeId}" store "rows" section should mention updated record(s) ${missingIds} sent in the request. It should contain the updated record identifiers.`);
          showSupportShortSyncResponseNote = true;
        }
      }
      if (missingRows.length) {
        missingRows.push("...");
      }
      if (requested == null ? void 0 : requested.removed) {
        missingRemoved.push(
          ...requested.removed.filter((record) => !respondedRows.find((row) => row[idField] == record[idField])).map((record) => ({ [idField]: record[idField] }))
        );
        if (missingRemoved.length) {
          const missingIds = missingRemoved.map((row) => "#" + row[idField]).join(", ");
          messages.push(`- "${storeId}" store "removed" section should mention removed record(s) ${missingIds} sent in the request. It should contain the removed record identifiers.`);
          result[storeId].removed = missingRemoved;
          missingRemoved.push("...");
          showSupportShortSyncResponseNote = true;
        }
      }
    }
    if (missingRows.length) {
      result[storeId].rows = missingRows;
    }
    if (!messages.length) {
      delete result[storeId];
    }
    Object.assign(expectedResponse, result);
    return { messages, showSupportShortSyncResponseNote };
  }
  getSyncResponseWarnings(response, requestDesc) {
    const messages = [], expectedResponse = {}, request = requestDesc.pack;
    if (!this.skipSuccessProperty) {
      expectedResponse.success = true;
    }
    let showSupportShortSyncResponseNote = false;
    this.forEachCrudStore((store, storeId, storeInfo) => {
      const warnings = this.getStoreSyncResponseWarnings(storeInfo, request == null ? void 0 : request[storeId], response[storeId], expectedResponse);
      showSupportShortSyncResponseNote = showSupportShortSyncResponseNote || warnings.showSupportShortSyncResponseNote;
      messages.push(...warnings.messages);
    });
    if (messages.length) {
      messages.push("Please adjust your response to look like this:\n" + JSON.stringify(expectedResponse, null, 4).replace(/"\.\.\.":\s*"\.\.\."/g, ",,,").replace(/"\.\.\."/g, "..."));
      if (showSupportShortSyncResponseNote) {
        messages.push(this.supportShortSyncResponseNote);
      }
      messages.push(this.disableValidationNote);
    }
    return messages;
  }
  validateSyncResponse(response, request) {
    const messages = this.getSyncResponseWarnings(response, request);
    if (messages.length) {
      console.warn(this.crudSyncValidationWarningPrefix + "\n" + messages.join("\n"));
    }
  }
};

// ../Scheduler/lib/Scheduler/crud/AbstractCrudManagerMixin.js
var AbstractCrudManagerError = class extends Error {
};
var CrudManagerRequestError = class extends AbstractCrudManagerError {
  constructor(cfg = {}) {
    var _a2, _b;
    super(cfg.message || cfg.request && StringHelper.capitalize((_a2 = cfg.request) == null ? void 0 : _a2.type) + " failed" || "Crud Manager request failed");
    Object.assign(this, cfg);
    this.action = (_b = this.request) == null ? void 0 : _b.type;
  }
};
var storeSortFn = function(lhs, rhs, sortProperty) {
  if (lhs.store) {
    lhs = lhs.store;
  }
  if (rhs.store) {
    rhs = rhs.store;
  }
  lhs = lhs[sortProperty] || 0;
  rhs = rhs[sortProperty] || 0;
  return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
};
var storeLoadSortFn = function(lhs, rhs) {
  return storeSortFn(lhs, rhs, "loadPriority");
};
var storeSyncSortFn = function(lhs, rhs) {
  return storeSortFn(lhs, rhs, "syncPriority");
};
var AbstractCrudManagerMixin_default = (Target) => {
  var _a2;
  Target.$$meta = Target.$meta;
  const mixins = [];
  if (!Target.isEvents) {
    mixins.push(Events_default);
  }
  if (!Target.isDelayable) {
    mixins.push(Delayable_default);
  }
  mixins.push(AbstractCrudManagerValidation_default);
  return _a2 = class extends (Target || Base).mixin(...mixins) {
    /**
     * Fires before server response gets applied to the stores. Return `false` to prevent data applying.
     * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
     * @event beforeResponseApply
     * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.
     * @param {'sync'|'load'} requestType The request type (`sync` or `load`).
     * @param {Object} response The decoded server response object.
     */
    /**
     * Fires before loaded data get applied to the stores. Return `false` to prevent data applying.
     * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
     * @event beforeLoadApply
     * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.
     * @param {Object} response The decoded server response object.
     * @param {Object} options Options provided to the {@link #function-load} method.
     */
    /**
     * Fires before sync response data get applied to the stores. Return `false` to prevent data applying.
     * This event can be used for server data preprocessing. To achieve it user can modify the `response` object.
     * @event beforeSyncApply
     * @param {Scheduler.crud.AbstractCrudManager} source The CRUD manager.
     * @param {Object} response The decoded server response object.
     */
    static get $name() {
      return "AbstractCrudManagerMixin";
    }
    //region Default config
    static get defaultConfig() {
      return {
        /**
         * The server revision stamp.
         * The _revision stamp_ is a number which should be incremented after each server-side change.
         * This property reflects the current version of the data retrieved from the server and gets updated
         * after each {@link #function-load} and {@link #function-sync} call.
         * @property {Number}
         * @readonly
         * @category CRUD
         */
        crudRevision: null,
        /**
         * A list of registered stores whose server communication will be collected into a single batch.
         * Each store is represented by a _store descriptor_.
         * @member {CrudManagerStoreDescriptor[]} crudStores
         * @category CRUD
         */
        /**
         * Sets the list of stores controlled by the CRUD manager.
         *
         * When adding a store to the CrudManager, make sure the server response format is correct for `load`
         * and `sync` requests. Learn more in the
         * [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.
         *
         * Store can be provided by itself, its storeId or as a _store descriptor_.
         * @config {Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]}
         * @category CRUD
         */
        crudStores: [],
        /**
         * Name of a store property to retrieve store identifiers from. Make sure you have an instance of a
         * store to use it by id. Store identifier is used as a container name holding corresponding store data
         * while transferring them to/from the server. By default, `storeId` property is used. And in case a
         * container identifier has to differ this config can be used:
         *
         * ```javascript
         * class CatStore extends Store {
         *     static configurable = {
         *         // store id is "meow" but for sending/receiving store data
         *         // we want to have "cats" container in JSON, so we create a new property "storeIdForCrud"
         *         id             : 'meow',
         *         storeIdForCrud : 'cats'
         *     }
         * });
         *
         * // create an instance to use a store by id
         * new CatStore();
         *
         * class MyCrudManager extends CrudManager {
         *     ...
         *     crudStores           : ['meow'],
         *     // crud manager will get store identifier from "storeIdForCrud" property
         *     storeIdProperty  : 'storeIdForCrud'
         * });
         * ```
         * The `storeIdProperty` property can also be specified directly on a store:
         *
         * ```javascript
         * class CatStore extends Store {
         *     static configurable = {
         *         // storeId is "meow" but for sending/receiving store data
         *         // we want to have "cats" container in JSON
         *         id              : 'meow',
         *         // so we create a new property "storeIdForCrud"..
         *         storeIdForCrud  : 'cats',
         *         // and point CrudManager to use it as the store identifier source
         *         storeIdProperty  : 'storeIdForCrud'
         *     }
         * });
         *
         * class DogStore extends Store {
         *     static configurable = {
         *         // storeId is "dogs" and it will be used as a container name for the store data
         *         storeId : 'dogs',
         *         // id is set to get a store by identifier
         *         id      : 'dogs'
         *     }
         * });
         *
         * // create an instance to use a store by id
         * new CatStore();
         * new DogStore();
         *
         * class MyCrudManager extends CrudManager {
         *     ...
         *     crudStores : ['meow', 'dogs']
         * });
         * ```
         * @config {String}
         * @category CRUD
         */
        storeIdProperty: "storeId",
        crudFilterParam: "filter",
        /**
         * Sends request to the server.
         * @function sendRequest
         * @param {Object} request The request to send. An object having following properties:
         * @param {'load'|'sync'} request.type Request type, can be either `load` or `sync`
         * @param {String} request.data {@link #function-encode Encoded} request.
         * @param {Function} request.success Callback to be started on successful request transferring
         * @param {Function} request.failure Callback to be started on request transfer failure
         * @param {Object} request.thisObj `this` reference for the above `success` and `failure` callbacks
         * @returns {Promise} The request promise.
         * @abstract
         */
        /**
         * Cancels request to the server.
         * @function cancelRequest
         * @param {Promise} promise The request promise to cancel (a value returned by corresponding
         * {@link #function-sendRequest} call).
         * @param {Function} reject Reject handle of the corresponding promise
         * @abstract
         */
        /**
         * Encodes request to the server.
         * @function encode
         * @param {Object} request The request to encode.
         * @returns {String} The encoded request.
         * @abstract
         */
        /**
         * Decodes response from the server.
         * @function decode
         * @param {String} response The response to decode.
         * @returns {Object} The decoded response.
         * @abstract
         */
        transport: {},
        /**
         * When `true` forces the CRUD manager to process responses depending on their `type` attribute.
         * So `load` request may be responded with `sync` response for example.
         * Can be used for smart server logic allowing the server to decide when it's better to respond with a
         * complete data set (`load` response) or it's enough to return just a delta (`sync` response).
         * @config {Boolean}
         * @default
         * @category CRUD
         */
        trackResponseType: false,
        /**
         * When `true` the Crud Manager does not require all updated and removed records to be mentioned in the
         * *sync* response. In this case response should include only server side changes.
         *
         * **Please note that added records should still be mentioned in response to provide real identifier
         * instead of the phantom one.**
         * @config {Boolean}
         * @default
         * @category CRUD
         */
        supportShortSyncResponse: true,
        /**
         * Field name to be used to transfer a phantom record identifier.
         * @config {String}
         * @default
         * @category CRUD
         */
        phantomIdField: "$PhantomId",
        /**
         * Field name to be used to transfer a phantom parent record identifier.
         * @config {String}
         * @default
         * @category CRUD
         */
        phantomParentIdField: "$PhantomParentId",
        /**
         * Specify `true` to automatically call {@link #function-load} method on the next frame after creation.
         *
         * Called on the next frame to allow a Scheduler (or similar) linked to a standalone CrudManager to
         * register its stores before loading starts.
         *
         * @config {Boolean}
         * @default
         * @category CRUD
         */
        autoLoad: false,
        /**
         * The timeout in milliseconds to wait before persisting changes to the server.
         * Used when {@link #config-autoSync} is set to `true`.
         * @config {Number}
         * @default
         * @category CRUD
         */
        autoSyncTimeout: 100,
        /**
         * `true` to automatically persist store changes after edits are made in any of the stores monitored.
         * Please note that sync request will not be invoked immediately but only after
         * {@link #config-autoSyncTimeout} interval.
         * @config {Boolean}
         * @default
         * @category CRUD
         */
        autoSync: false,
        /**
         * `True` to reset identifiers (defined by `idField` config) of phantom records before submitting them
         * to the server.
         * @config {Boolean}
         * @default
         * @category CRUD
         */
        resetIdsBeforeSync: true,
        /**
         * @member {CrudManagerStoreDescriptor[]} syncApplySequence
         * An array of stores presenting an alternative sync responses apply order.
         * Each store is represented by a _store descriptor_.
         * @category CRUD
         */
        /**
         * An array of store identifiers sets an alternative sync responses apply order.
         * By default, the order in which sync responses are applied to the stores is the same as they
         * registered in. But in case of some tricky dependencies between stores this order can be changed:
         *
         *```javascript
         * class MyCrudManager extends CrudManager {
         *     // register stores (will be loaded in this order: 'store1' then 'store2' and finally 'store3')
         *     crudStores : ['store1', 'store2', 'store3'],
         *     // but we apply changes from server to them in an opposite order
         *     syncApplySequence : ['store3', 'store2', 'store1']
         * });
         *```
         * @config {String[]}
         * @category CRUD
         */
        syncApplySequence: [],
        orderedCrudStores: [],
        /**
         * `true` to write all fields from the record to the server.
         * If set to `false` it will only send the fields that were modified.
         * Note that any fields that have {@link Core/data/field/DataField#config-persist} set to `false` will
         * still be ignored and fields having {@link Core/data/field/DataField#config-alwaysWrite} set to `true`
         * will always be included.
         * @config {Boolean}
         * @default
         * @category CRUD
         */
        writeAllFields: false,
        crudIgnoreUpdates: 0,
        autoSyncSuspendCounter: 0,
        // Flag that shows if crud manager performed successful load request
        crudLoaded: false,
        applyingLoadResponse: false,
        applyingSyncResponse: false,
        callOnFunctions: true
      };
    }
    get isCrudManager() {
      return true;
    }
    //endregion
    //region Init
    construct(config = {}) {
      this._requestId = 0;
      this.activeRequests = {};
      this.crudStoresIndex = {};
      super.construct(config);
    }
    afterConstruct() {
      super.afterConstruct();
      if (this.autoLoad) {
        this._autoLoadPromise = this.doAutoLoad();
      }
    }
    //endregion
    //region Configs
    get loadUrl() {
      var _a3, _b;
      return (_b = (_a3 = this.transport) == null ? void 0 : _a3.load) == null ? void 0 : _b.url;
    }
    updateLoadUrl(url) {
      ObjectHelper.setPath(this, "transport.load.url", url);
    }
    get syncUrl() {
      var _a3, _b;
      return (_b = (_a3 = this.transport) == null ? void 0 : _a3.sync) == null ? void 0 : _b.url;
    }
    updateSyncUrl(url) {
      ObjectHelper.setPath(this, "transport.sync.url", url);
    }
    //endregion
    //region Store descriptors & index
    /**
     * Returns a registered store descriptor.
     * @param {String|Core.data.Store} storeId The store identifier or registered store instance.
     * @returns {CrudManagerStoreDescriptor} The descriptor of the store.
     * @category CRUD
     */
    getStoreDescriptor(storeId) {
      if (!storeId)
        return null;
      if (storeId instanceof Store)
        return this.crudStores.find((storeDesc) => storeDesc.store === storeId);
      if (typeof storeId === "object")
        return this.crudStoresIndex[storeId.storeId];
      return this.crudStoresIndex[storeId] || this.getStoreDescriptor(Store.getStore(storeId));
    }
    fillStoreDescriptor(descriptor) {
      const { store } = descriptor, {
        storeIdProperty = this.storeIdProperty,
        modelClass
      } = store;
      if (!descriptor.storeId) {
        descriptor.storeId = store[storeIdProperty] || store.id;
      }
      if (!descriptor.idField) {
        descriptor.idField = modelClass.idField;
      }
      if (!descriptor.phantomIdField) {
        descriptor.phantomIdField = modelClass.phantomIdField;
      }
      if (!descriptor.phantomParentIdField) {
        descriptor.phantomParentIdField = modelClass.phantomParentIdField;
      }
      if (!("writeAllFields" in descriptor)) {
        descriptor.writeAllFields = store.writeAllFields;
      }
      return descriptor;
    }
    updateCrudStoreIndex() {
      const crudStoresIndex = this.crudStoresIndex = {};
      this.crudStores.forEach((store) => store.storeId && (crudStoresIndex[store.storeId] = store));
    }
    //endregion
    //region Store collection (add, remove, get & iterate)
    /**
     * Returns a registered store.
     * @param {String} storeId Store identifier.
     * @returns {Core.data.Store} Found store instance.
     * @category CRUD
     */
    getCrudStore(storeId) {
      const storeDescriptor = this.getStoreDescriptor(storeId);
      return storeDescriptor == null ? void 0 : storeDescriptor.store;
    }
    forEachCrudStore(fn2, thisObj = this) {
      if (!fn2) {
        throw new Error("Iterator function must be provided");
      }
      this.crudStores.every(
        (store) => fn2.call(thisObj, store.store, store.storeId, store) !== false
      );
    }
    set crudStores(stores) {
      this._crudStores = [];
      this.addCrudStore(stores);
      for (const store of this._crudStores) {
        store.loadPriority = store.syncPriority = 0;
      }
    }
    get crudStores() {
      return this._crudStores;
    }
    get orderedCrudStores() {
      return this._orderedCrudStores;
    }
    set orderedCrudStores(stores) {
      return this._orderedCrudStores = stores;
    }
    set syncApplySequence(stores) {
      this._syncApplySequence = [];
      this.addStoreToApplySequence(stores);
    }
    get syncApplySequence() {
      return this._syncApplySequence;
    }
    internalAddCrudStore(store) {
      const me = this;
      let storeInfo;
      if (store instanceof Store) {
        storeInfo = { store };
      } else if (typeof store === "object") {
        if (!store.store) {
          store = {
            storeId: store.id,
            store: new Store(store)
          };
        }
        storeInfo = store;
      } else {
        storeInfo = { store: Store.getStore(store) };
      }
      me.fillStoreDescriptor(storeInfo);
      store = storeInfo.store;
      if (store.setCrudManager) {
        store.setCrudManager(me);
      } else {
        store.crudManager = me;
      }
      store.pageSize = null;
      if (me.loadUrl || me.syncUrl) {
        store.autoCommit = false;
        store.autoLoad = false;
        if (store.createUrl || store.updateUrl || store.deleteUrl || store.readUrl) {
          console.warn("You have configured an URL on a Store that is handled by a CrudManager that is also configured with an URL. The Store URL's should be removed.");
        }
      }
      me.bindCrudStoreListeners(store);
      return storeInfo;
    }
    /**
     * Adds a store to the collection.
     *
     *```javascript
     * // append stores to the end of collection
     * crudManager.addCrudStore([
     *     store1,
     *     // storeId
     *     'bar',
     *     // store descriptor
     *     {
     *         storeId : 'foo',
     *         store   : store3
     *     },
     *     {
     *         storeId         : 'bar',
     *         store           : store4,
     *         // to write all fields of modified records
     *         writeAllFields  : true
     *     }
     * ]);
     *```
     *
     * **Note:** Order in which stores are kept in the collection is very essential sometimes.
     * Exactly in this order the loaded data will be put into each store.
     *
     * When adding a store to the CrudManager, make sure the server response format is correct for `load` and `sync`
     * requests. Learn more in the [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.
     *
     * @param {Core.data.Store|String|CrudManagerStoreDescriptor|Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]} store
     * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.
     * @param {Number} [position] The relative position of the store. If `fromStore` is specified the position
     * will be taken relative to it. If not specified then store(s) will be appended to the end of collection.
     * Otherwise, it will be just a position in stores collection.
     *
     * ```javascript
     * // insert stores store4, store5 to the start of collection
     * crudManager.addCrudStore([ store4, store5 ], 0);
     * ```
     *
     * @param {String|Core.data.Store|CrudManagerStoreDescriptor} [fromStore] The store relative to which position
     * should be calculated. Can be defined as a store identifier, instance or descriptor (the result of
     * {@link #function-getStoreDescriptor} call).
     *
     * ```javascript
     * // insert store6 just before a store having storeId equal to 'foo'
     * crudManager.addCrudStore(store6, 0, 'foo');
     *
     * // insert store7 just after store3 store
     * crudManager.addCrudStore(store7, 1, store3);
     * ```
     * @category CRUD
     */
    addCrudStore(store, position, fromStore) {
      store = ArrayHelper.asArray(store);
      if (!(store == null ? void 0 : store.length)) {
        return;
      }
      const me = this, stores = store.map(me.internalAddCrudStore, me);
      if (typeof position === "undefined") {
        me.crudStores.push(...stores);
      } else {
        if (fromStore) {
          if (fromStore instanceof Store || typeof fromStore !== "object")
            fromStore = me.getStoreDescriptor(fromStore);
          position += me.crudStores.indexOf(fromStore);
        }
        me.crudStores.splice(position, 0, ...stores);
      }
      me.orderedCrudStores.push(...stores);
      me.updateCrudStoreIndex();
    }
    // Adds configured scheduler stores to the store collection ensuring correct order
    // unless they're already registered.
    addPrioritizedStore(store) {
      const me = this;
      if (!me.hasCrudStore(store)) {
        me.addCrudStore(store, ArrayHelper.findInsertionIndex(store, me.crudStores, storeLoadSortFn));
      }
      if (!me.hasApplySequenceStore(store)) {
        me.addStoreToApplySequence(store, ArrayHelper.findInsertionIndex(store, me.syncApplySequence, storeSyncSortFn));
      }
    }
    hasCrudStore(store) {
      var _a3;
      return (_a3 = this.crudStores) == null ? void 0 : _a3.some((s) => s === store || s.store === store || s.storeId === store);
    }
    /**
     * Removes a store from collection. If the store was registered in alternative sync sequence list
     * it will be removed from there as well.
     *
     * ```javascript
     * // remove store having storeId equal to "foo"
     * crudManager.removeCrudStore("foo");
     *
     * // remove store3
     * crudManager.removeCrudStore(store3);
     * ```
     *
     * @param {CrudManagerStoreDescriptor|String|Core.data.Store} store The store to remove. Either the store
     * descriptor, store identifier or store itself.
     * @category CRUD
     */
    removeCrudStore(store) {
      const me = this, stores = me.crudStores, foundStore = stores.find((s) => s === store || s.store === store || s.storeId === store);
      if (foundStore) {
        me.unbindCrudStoreListeners(foundStore.store);
        delete me.crudStoresIndex[foundStore.storeId];
        ArrayHelper.remove(stores, foundStore);
        if (me.syncApplySequence) {
          me.removeStoreFromApplySequence(store);
        }
      } else {
        throw new Error("Store not found in stores collection");
      }
    }
    //endregion
    //region Store listeners
    bindCrudStoreListeners(store) {
      store.ion({
        name: store.id,
        // When a tentatively added record gets confirmed as permanent, this signals a change
        addConfirmed: "onCrudStoreChange",
        change: "onCrudStoreChange",
        destroy: "onCrudStoreDestroy",
        thisObj: this
      });
    }
    unbindCrudStoreListeners(store) {
      this.detachListeners(store.id);
    }
    //endregion
    //region Apply sequence
    /**
     * Adds a store to the alternative sync responses apply sequence.
     * By default, the order in which sync responses are applied to the stores is the same as they registered in.
     * But this order can be changes either on construction step using {@link #config-syncApplySequence} option
     * or by calling this method.
     *
     * **Please note**, that if the sequence was not initialized before this method call then
     * you will have to do it yourself like this for example:
     *
     * ```javascript
     * // alternative sequence was not set for this crud manager
     * // so let's fill it with existing stores keeping the same order
     * crudManager.addStoreToApplySequence(crudManager.crudStores);
     *
     * // and now we can add our new store
     *
     * // we will load its data last
     * crudManager.addCrudStore(someNewStore);
     * // but changes to it will be applied first
     * crudManager.addStoreToApplySequence(someNewStore, 0);
     * ```
     * add registered stores to the sequence along with the store(s) you want to add
     *
     * @param {Core.data.Store|CrudManagerStoreDescriptor|Core.data.Store[]|CrudManagerStoreDescriptor[]} store The
     * store to add or its _descriptor_ (or array of stores or descriptors).
     * @param {Number} [position] The relative position of the store. If `fromStore` is specified the position
     * will be taken relative to it. If not specified then store(s) will be appended to the end of collection.
     * Otherwise, it will be just a position in stores collection.
     *
     * ```javascript
     * // insert stores store4, store5 to the start of sequence
     * crudManager.addStoreToApplySequence([ store4, store5 ], 0);
     * ```
     * @param {String|Core.data.Store|CrudManagerStoreDescriptor} [fromStore] The store relative to which position
     * should be calculated. Can be defined as a store identifier, instance or its descriptor (the result of
     * {@link #function-getStoreDescriptor} call).
     *
     * ```javascript
     * // insert store6 just before a store having storeId equal to 'foo'
     * crudManager.addStoreToApplySequence(store6, 0, 'foo');
     *
     * // insert store7 just after store3 store
     * crudManager.addStoreToApplySequence(store7, 1, store3);
     * ```
     * @category CRUD
     */
    addStoreToApplySequence(store, position, fromStore) {
      if (!store) {
        return;
      }
      store = ArrayHelper.asArray(store);
      const me = this, data = store.reduce((collection, store2) => {
        const s = me.getStoreDescriptor(store2);
        s && collection.push(s);
        return collection;
      }, []);
      if (typeof position === "undefined") {
        me.syncApplySequence.push(...data);
      } else {
        let pos = position;
        if (fromStore) {
          if (fromStore instanceof Store || typeof fromStore !== "object")
            fromStore = me.getStoreDescriptor(fromStore);
          pos += me.syncApplySequence.indexOf(fromStore);
        }
        me.syncApplySequence.splice(pos, 0, ...data);
      }
      const sequenceKeys = me.syncApplySequence.map(({ storeId }) => storeId);
      me.orderedCrudStores = [...me.syncApplySequence];
      me.crudStores.forEach((storeDesc) => {
        if (!sequenceKeys.includes(storeDesc.storeId)) {
          me.orderedCrudStores.push(storeDesc);
        }
      });
    }
    /**
     * Removes a store from the alternative sync sequence.
     *
     * ```javascript
     * // remove store having storeId equal to "foo"
     * crudManager.removeStoreFromApplySequence("foo");
     * ```
     *
     * @param {CrudManagerStoreDescriptor|String|Core.data.Store} store The store to remove. Either the store
     * descriptor, store identifier or store itself.
     * @category CRUD
     */
    removeStoreFromApplySequence(store) {
      const index = this.syncApplySequence.findIndex((s) => s === store || s.store === store || s.storeId === store);
      if (index > -1) {
        this.syncApplySequence.splice(index, 1);
        this.orderedCrudStores.splice(index, 1);
      }
    }
    hasApplySequenceStore(store) {
      return this.syncApplySequence.some((s) => s === store || s.store === store || s.storeId === store);
    }
    //endregion
    //region Events
    // Remove stores that are destroyed, to not try and apply response changes etc. to them
    onCrudStoreDestroy({ source: store }) {
      this.removeCrudStore(store);
    }
    onCrudStoreChange(event) {
      const me = this;
      if (me.crudIgnoreUpdates) {
        return;
      }
      if (me.crudStoreHasChanges(event == null ? void 0 : event.source)) {
        me.trigger("hasChanges");
        if (me.autoSync) {
          me.scheduleAutoSync();
        }
      } else {
        me.trigger("noChanges");
      }
    }
    /**
     * Suspends automatic sync upon store changes. Can be called multiple times (it uses an internal counter).
     * @category CRUD
     */
    suspendAutoSync() {
      this.autoSyncSuspendCounter++;
    }
    /**
     * Resumes automatic sync upon store changes. Will schedule a sync if the internal counter is 0.
     * @param {Boolean} [doSync=true] Pass `true` to schedule a sync after resuming (if there are pending
     * changes) and `false` to not persist the changes.
     * @category CRUD
     */
    resumeAutoSync(doSync = true) {
      const me = this;
      me.autoSyncSuspendCounter--;
      if (me.autoSyncSuspendCounter <= 0) {
        me.autoSyncSuspendCounter = 0;
        if (doSync && me.autoSync && me.crudStoreHasChanges()) {
          me.scheduleAutoSync();
        }
      }
    }
    get isAutoSyncSuspended() {
      return this.autoSyncSuspendCounter > 0;
    }
    scheduleAutoSync() {
      const me = this;
      if (!me.hasTimeout("autoSync") && !me.isAutoSyncSuspended) {
        me.setTimeout({
          name: "autoSync",
          fn: () => {
            me.sync().catch((error) => {
            });
          },
          delay: me.autoSyncTimeout
        });
      }
    }
    async triggerFailedRequestEvents(request, response, responseText, fetchOptions) {
      const { options, type: requestType } = request;
      this.trigger("requestFail", { requestType, response, responseText, responseOptions: fetchOptions });
      this.trigger(requestType + "Fail", { response, responseOptions: fetchOptions, responseText, options });
    }
    async internalOnResponse(request, responseText, fetchOptions) {
      const me = this, response = responseText ? me.decode(responseText) : null, { options, type: requestType } = request;
      if (responseText && !response) {
        console.error("Failed to parse response: " + responseText);
      }
      if (!response || (me.skipSuccessProperty ? response.success === false : !response.success)) {
        me.triggerFailedRequestEvents(request, response, responseText, fetchOptions);
      } else if (me.trigger("beforeResponseApply", { requestType, response }) !== false && me.trigger(`before${StringHelper.capitalize(requestType)}Apply`, { response, options }) !== false) {
        me.crudRevision = response.revision;
        await me.applyResponse(request, response, options);
        if (me.isDestroyed) {
          return;
        }
        me.trigger("requestDone", { requestType, response, responseOptions: fetchOptions });
        me.trigger(requestType, { response, responseOptions: fetchOptions, options });
        if (requestType === "load" || !me.crudStoreHasChanges()) {
          me.trigger("noChanges");
          if (requestType === "load") {
            me.emitCrudStoreEvents(request.pack.stores, "afterRequest");
          }
        }
      }
      return response;
    }
    //endregion
    //region Changes tracking
    /**
     * Suspends {@link #event-hasChanges} and {@link #event-noChanges} events.
     * @category CRUD
     */
    suspendChangeTracking() {
      this.crudIgnoreUpdates++;
    }
    /**
     * Resumes {@link #event-hasChanges} and {@link #event-noChanges} events. By default, it will check for changes
     * and if there are any, `hasChanges` or `noChanges` event will be triggered.
     * @param {Boolean} [skipChangeCheck]
     * @category CRUD
     */
    resumeChangeTracking(skipChangeCheck) {
      if (this.crudIgnoreUpdates && !--this.crudIgnoreUpdates && !skipChangeCheck) {
        this.onCrudStoreChange();
      }
    }
    /**
     * Returns `true` if changes tracking is suspended
     * @property {Boolean}
     * @readonly
     * @category CRUD
     */
    get isChangeTrackingSuspended() {
      return this.crudIgnoreUpdates > 0;
    }
    /**
     * Returns `true` if any of registered stores (or some particular store) has non persisted changes.
     *
     * ```javascript
     * // if we have any unsaved changes
     * if (crudManager.crudStoreHasChanges()) {
     *     // persist them
     *     crudManager.sync();
     * // otherwise
     * } else {
     *     alert("There are no unsaved changes...");
     * }
     * ```
     *
     * @param {String|Core.data.Store} [storeId] The store identifier or store instance to check changes for.
     * If not specified then will check changes for all of the registered stores.
     * @returns {Boolean} `true` if there are not persisted changes.
     * @category CRUD
     */
    crudStoreHasChanges(storeId) {
      return storeId ? this.isCrudStoreDirty(this.getCrudStore(storeId)) : this.crudStores.some((config) => this.isCrudStoreDirty(config.store));
    }
    isCrudStoreDirty(store) {
      return Boolean(store.changes);
    }
    //endregion
    //region Load
    doAutoLoad() {
      return this.load().catch((error) => {
      });
    }
    emitCrudStoreEvents(stores, eventName, eventParams) {
      const event = { action: "read" + eventName, ...eventParams };
      for (const store of this.crudStores) {
        if (stores.includes(store.storeId)) {
          store.store.trigger(eventName, event);
        }
      }
    }
    getLoadPackage(options) {
      const pack = {
        type: "load",
        requestId: this.requestId
      }, stores = this.crudStores, optionsCopy = Object.assign({}, options);
      delete optionsCopy.request;
      pack.stores = stores.map((store) => {
        var _a3;
        const opts = optionsCopy == null ? void 0 : optionsCopy[store.storeId], pageSize = store.pageSize || ((_a3 = store.store) == null ? void 0 : _a3.pageSize);
        if (opts || pageSize) {
          const params = Object.assign({
            storeId: store.storeId,
            page: 1
          }, opts);
          if (pageSize) {
            params.pageSize = pageSize;
          }
          store.currentPage = params.page;
          if (opts) {
            delete optionsCopy[store.storeId];
          }
          return params;
        }
        return store.storeId;
      });
      Object.assign(pack, optionsCopy);
      return pack;
    }
    loadCrudStore(store, data, options) {
      const rows = data == null ? void 0 : data.rows;
      if ((options == null ? void 0 : options.append) || (data == null ? void 0 : data.append)) {
        store.add(rows, false, { clean: true });
      } else {
        store.data = rows;
      }
      store.trigger("load", { data: rows });
    }
    loadDataToCrudStore(storeDesc, data, options) {
      const store = storeDesc.store, rows = data == null ? void 0 : data.rows;
      store.__loading = true;
      if (rows) {
        this.loadCrudStore(store, data, options, storeDesc);
      }
      store.__loading = false;
    }
    /**
     * Loads data to the Crud Manager
     * @param {Object} response A simple object representing the data.
     * The object structure matches the decoded `load` response structure:
     *
     * ```js
     * // load static data into crudManager
     * crudManager.loadCrudManagerData({
     *     success   : true,
     *     resources : {
     *         rows : [
     *             { id : 1, name : 'John' },
     *             { id : 2, name : 'Abby' }
     *         ]
     *     }
     * });
     * ```
     * @param {Object} [options] Extra data loading options.
     * @category CRUD
     */
    loadCrudManagerData(response, options = {}) {
      const me = this;
      me.trigger("beforeLoadCrudManagerData");
      me.suspendChangeTracking();
      me.crudStores.forEach((storeDesc) => {
        const storeId = storeDesc.storeId, data = response[storeId];
        if (data) {
          me.loadDataToCrudStore(storeDesc, data, options[storeId]);
        }
      });
      me.resumeChangeTracking(true);
      me.trigger("loadCrudManagerData");
    }
    /**
     * Returns true if the crud manager is currently loading data
     * @property {Boolean}
     * @readonly
     * @category CRUD
     */
    get isCrudManagerLoading() {
      return Boolean(this.activeRequests.load || this.applyingLoadResponse);
    }
    /**
     * Returns true if the crud manager is currently syncing data
     * @property {Boolean}
     * @readonly
     * @category CRUD
     */
    get isCrudManagerSyncing() {
      return Boolean(this.activeRequests.sync || this.applyingSyncResponse);
    }
    get isLoadingOrSyncing() {
      return Boolean(this.isCrudManagerLoading || this.isCrudManagerSyncing);
    }
    /**
     * Loads data to the stores registered in the crud manager. For example:
     *
     * ```javascript
     * crudManager.load(
     *     // here are request parameters
     *     {
     *         store1 : { append : true, page : 3, smth : 'foo' },
     *         store2 : { page : 2, bar : '!!!' }
     *     }
     * ).then(
     *     () => alert('OMG! It works!'),
     *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)
     * );
     * ```
     *
     * ** Note: ** If there is an incomplete load request in progress then system will try to cancel it by calling {@link #function-cancelRequest}.
     * @param {Object|String} [options] The request parameters or a URL.
     * @param {Object} [options.request] An object which contains options to merge
     * into the options which are passed to {@link Scheduler/crud/transport/AjaxTransport#function-sendRequest}.
     * ```javascript
     * {
     *     store1 : { page : 3, append : true, smth : 'foo' },
     *     store2 : { page : 2, bar : '!!!' },
     *     request : {
     *         params : {
     *             startDate : '2021-01-01'
     *         }
     *     }
     * },
     * ```
     *
     * Omitting request arg:
     * ```javascript
     * crudManager.load().then(
     *     () => alert('OMG! It works!'),
     *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)
     * );
     * ```
     *
     * When presented it should be an object where keys are store Ids and values are, in turn, objects
     * of parameters related to the corresponding store. These parameters will be transferred in each
     * store's entry in the `stores` property of the POST data.
     *
     * Additionally, for flat stores `append: true` can be specified to add loaded records to the existing records,
     * default is to remove corresponding store's existing records first.
     * **Please note** that for delta loading you can also use an {@link #config-trackResponseType alternative approach}.
     * @param {'sync'|'load'} [options.request.type] The request type. Either `load` or `sync`.
     * @param {String} [options.request.url] The URL for the request. Overrides the URL defined in the `transport`
     * object
     * @param {String} [options.request.data] The encoded _Crud Manager_ request data.
     * @param {Object} [options.request.params] An object specifying extra HTTP params to send with the request.
     * @param {Function} [options.request.success] A function to be started on successful request transferring.
     * @param {String} [options.request.success.rawResponse] `Response` object returned by the
     * [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
     * @param {Function} [options.request.failure] A function to be started on request transfer failure.
     * @param {String} [options.request.failure.rawResponse] `Response` object returned by the
     * [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
     * @param {Object} [options.request.thisObj] `this` reference for the above `success` and `failure` functions.
     * @returns {Promise} Promise, which is resolved if request was successful.
     * Both the resolve and reject functions are passed a `state` object. State object has following structure:
     *
     * ```
     * {
     *     cancelled       : Boolean, // **optional** flag, which is present when promise was rejected
     *     rawResponse     : String,  // raw response from ajax request, either response xml or text
     *     rawResponseText : String,  // raw response text as String from ajax request
     *     response        : Object,  // processed response in form of object
     *     options         : Object   // options, passed to load request
     * }
     * ```
     *
     * If promise was rejected by {@link #event-beforeLoad} event, `state` object will have the following structure:
     *
     * ```
     * {
     *     cancelled : true
     * }
     * ```
     * @category CRUD
     * @async
     */
    load(options) {
      if (typeof options === "string") {
        options = {
          request: {
            url: options
          }
        };
      }
      const me = this, pack = me.getLoadPackage(options);
      me._autoLoadPromise = null;
      return new Promise((resolve, reject) => {
        if (me.trigger("beforeLoad", { pack }) !== false) {
          const { load } = me.activeRequests;
          if (load) {
            me.cancelRequest(load.desc, load.reject);
            me.trigger("loadCanceled", { pack });
          }
          const request = Objects.assign({
            id: pack.requestId,
            data: me.encode(pack),
            type: "load",
            success: me.onCrudRequestSuccess,
            failure: me.onCrudRequestFailure,
            thisObj: me
          }, options == null ? void 0 : options.request);
          me.activeRequests.load = {
            type: "load",
            options,
            pack,
            resolve,
            reject(...args) {
              request.success = request.failure = null;
              reject(...args);
            },
            id: pack.requestId,
            desc: me.sendRequest(request)
          };
          me.emitCrudStoreEvents(pack.stores, "loadStart");
          me.trigger("loadStart", { pack });
        } else {
          me.trigger("loadCanceled", { pack });
          reject({ cancelled: true });
        }
      });
    }
    getActiveCrudManagerRequest(requestType) {
      let request = this.activeRequests[requestType];
      if (!request && this.trackResponseType) {
        request = Object.values(this.activeRequests)[0];
      }
      return request;
    }
    //endregion
    //region Changes (prepare, process, get)
    prepareAddedRecordData(record, storeInfo) {
      const me = this, { store } = storeInfo, { isTree } = store, phantomIdField = storeInfo.phantomIdField || me.phantomIdField, phantomParentIdField = storeInfo.phantomParentIdField || me.phantomParentIdField, subStoreFields = store.modelClass.allFields.filter((field) => field.subStore), cls = record.constructor, data = Object.assign(record.persistableData, {
        [phantomIdField]: record.id
      });
      if (isTree) {
        const { parent } = record;
        if (parent && !parent.isRoot && parent.isPhantom) {
          data[phantomParentIdField] = parent.id;
        }
      }
      if (me.resetIdsBeforeSync) {
        ObjectHelper.deletePath(data, cls.idField);
      }
      subStoreFields.forEach((field) => {
        const subStore = record.get(field.name);
        if (subStore.allCount) {
          data[field.dataSource] = {
            added: subStore.getRange().map((record2) => me.prepareAddedRecordData(record2, { store: subStore }))
          };
        }
      });
      return data;
    }
    prepareAdded(list, storeInfo) {
      return list.filter((record) => record.isValid).map((record) => this.prepareAddedRecordData(record, storeInfo));
    }
    prepareUpdated(list, storeInfo) {
      const { store } = storeInfo, { isTree } = store, writeAllFields = storeInfo.writeAllFields || storeInfo.writeAllFields !== false && this.writeAllFields, phantomParentIdField = storeInfo.phantomParentIdField || this.phantomParentIdField, subStoreFields = store.modelClass.allFields.filter((field) => field.subStore);
      if (storeInfo.store.tree) {
        const rootNode = storeInfo.store.rootNode;
        list = list.filter((record) => record !== rootNode);
      }
      return list.filter((record) => record.isValid).reduce((data, record) => {
        let recordData;
        if (writeAllFields) {
          recordData = record.persistableData;
        } else {
          recordData = record.modificationDataToWrite;
        }
        if (isTree) {
          const { parent } = record;
          if (parent && !parent.isRoot && parent.isPhantom) {
            recordData[phantomParentIdField] = parent.id;
          }
        }
        subStoreFields.forEach((field) => {
          const subStore = record.get(field.name);
          recordData[field.dataSource] = this.getCrudStoreChanges({ store: subStore });
        });
        if (!ObjectHelper.isEmpty(recordData)) {
          data.push(recordData);
        }
        return data;
      }, []);
    }
    prepareRemoved(list) {
      return list.map((record) => {
        const cls = record.constructor;
        return ObjectHelper.setPath({}, cls.idField, record.id);
      });
    }
    getCrudStoreChanges(storeDescriptor) {
      const { store } = storeDescriptor;
      let { added = [], modified: updated = [], removed = [] } = store.changes || {}, result;
      if (added.length)
        added = this.prepareAdded(added, storeDescriptor);
      if (updated.length)
        updated = this.prepareUpdated(updated, storeDescriptor);
      if (removed.length)
        removed = this.prepareRemoved(removed);
      if (added.length || updated.length || removed.length) {
        result = {};
        if (added.length)
          result.added = added;
        if (updated.length)
          result.updated = updated;
        if (removed.length)
          result.removed = removed;
      }
      return result;
    }
    getChangesetPackage() {
      const { changes } = this;
      return changes || this.forceSync ? {
        type: "sync",
        requestId: this.requestId,
        revision: this.crudRevision,
        ...changes
      } : null;
    }
    //endregion
    //region Apply
    /**
     * Returns current changes as an object consisting of added/modified/removed arrays of records for every
     * managed store, keyed by each store's `id`. Returns `null` if no changes exist. Format:
     *
     * ```javascript
     * {
     *     resources : {
     *         added    : [{ name : 'New guy' }],
     *         modified : [{ id : 2, name : 'Mike' }],
     *         removed  : [{ id : 3 }]
     *     },
     *     events : {
     *         modified : [{  id : 12, name : 'Cool task' }]
     *     },
     *     ...
     * }
     * ```
     *
     * @property {Object}
     * @readonly
     * @category CRUD
     */
    get changes() {
      const data = {};
      this.crudStores.forEach((store) => {
        const changes = this.getCrudStoreChanges(store);
        if (changes) {
          data[store.storeId] = changes;
        }
      });
      return Object.keys(data).length > 0 ? data : null;
    }
    getRowsToApplyChangesTo({ store, storeId }, storeResponse, storePack) {
      var _a3, _b;
      const me = this, { modelClass } = store, idDataSource = modelClass.idField, {
        updated: requestUpdated,
        removed: requestRemoved
      } = storePack || {};
      let rows, removed, remote;
      if (storeResponse) {
        remote = true;
        const respondedIds = {};
        rows = ((_a3 = storeResponse.rows) == null ? void 0 : _a3.slice()) || [];
        removed = ((_b = storeResponse.removed) == null ? void 0 : _b.slice()) || [];
        [...rows, ...removed].forEach((responseRecord) => {
          const id = ObjectHelper.getPath(responseRecord, idDataSource);
          respondedIds[id] = true;
        });
        if (me.supportShortSyncResponse) {
          requestUpdated == null ? void 0 : requestUpdated.forEach((data) => {
            const id = ObjectHelper.getPath(data, idDataSource);
            if (!respondedIds[id]) {
              rows.push({ [idDataSource]: id });
            }
          });
          requestRemoved == null ? void 0 : requestRemoved.forEach((data) => {
            const id = ObjectHelper.getPath(data, idDataSource);
            if (!respondedIds[id]) {
              removed.push({ [idDataSource]: id });
            }
          });
        }
      } else if (requestUpdated || requestRemoved) {
        remote = false;
        rows = requestUpdated;
        removed = requestRemoved;
      }
      rows = (rows == null ? void 0 : rows.length) ? rows : null;
      removed = (removed == null ? void 0 : removed.length) ? removed : null;
      return {
        rows,
        removed,
        remote
      };
    }
    applyChangesToStore(storeDesc, storeResponse, storePack) {
      var _a3;
      const me = this, phantomIdField = storeDesc.phantomIdField || me.phantomIdField, { store } = storeDesc, idField = store.modelClass.getFieldDataSource("id"), subStoreFields = store.modelClass.allFields.filter((field) => field.subStore), { rows, removed, remote } = me.getRowsToApplyChangesTo(storeDesc, storeResponse, storePack), added = [], updated = [];
      if (rows) {
        for (const data of rows) {
          if (store.getById((_a3 = data[phantomIdField]) != null ? _a3 : data[idField])) {
            updated.push(data);
          } else {
            added.push(data);
          }
        }
      }
      const extraLogEntries = [];
      if (updated.length && subStoreFields.length) {
        updated.forEach((updateData) => {
          var _a4, _b, _c;
          const record = store.getById((_a4 = updateData[phantomIdField]) != null ? _a4 : updateData[idField]), recordRequest = ((_b = storePack.added) == null ? void 0 : _b.find((t) => t[phantomIdField] == updateData[phantomIdField])) || ((_c = storePack.updated) == null ? void 0 : _c.find((t) => t[idField] == updateData[idField]));
          const extraLogInfo = {};
          subStoreFields.forEach((field) => {
            const store2 = record.get(field.name);
            me.applyChangesToStore(
              { store: store2 },
              updateData[field.dataSource],
              recordRequest == null ? void 0 : recordRequest[field.dataSource]
            );
            extraLogInfo[field.dataSource] = "foo";
            delete updateData[field.dataSource];
          });
          extraLogEntries.push([record, extraLogInfo]);
        });
      }
      const log = store.applyChangeset({ removed, added, updated }, null, phantomIdField, remote, true);
      extraLogEntries.forEach(([record, logEntry]) => Object.assign(log.get(record.id), logEntry));
      return log;
    }
    applySyncResponse(response, request) {
      var _a3;
      const me = this, stores = me.orderedCrudStores;
      me.applyingChangeset = me.applyingSyncResponse = true;
      me.suspendChangeTracking();
      for (const store of stores) {
        me.applyChangesToStore(store, response[store.storeId], (_a3 = request == null ? void 0 : request.pack) == null ? void 0 : _a3[store.storeId]);
      }
      me.resumeChangeTracking(true);
      me.applyingChangeset = me.applyingSyncResponse = false;
    }
    applyLoadResponse(response, options) {
      this.applyingLoadResponse = true;
      this.loadCrudManagerData(response, options);
      this.applyingLoadResponse = false;
    }
    async applyResponse(request, response, options) {
      const me = this, responseType = me.trackResponseType && response.type || request.type;
      switch (responseType) {
        case "load":
          if (me.validateResponse) {
            me.validateLoadResponse(response);
          }
          me.applyLoadResponse(response, options);
          break;
        case "sync":
          if (me.validateResponse) {
            me.validateSyncResponse(response, request);
          }
          me.applySyncResponse(response, request);
          break;
      }
    }
    /**
     * Applies a set of changes, as an object keyed by store id, to the affected stores. This function is intended
     * to use in apps that handle their own data syncing, it is not needed when using the CrudManager approach.
     *
     * Example of a changeset:
     * ```javascript
     * project.applyChangeset({
     *     events : {
     *         added : [
     *             { id : 10, name : 'Event 10', startDate : '2022-06-07' }
     *         ],
     *         updated : [
     *             { id : 5, name : 'Changed' }
     *         ],
     *         removed : [
     *             { id : 1 }
     *         ]
     *     },
     *     resources : { ... },
     *     ...
     * });
     * ```
     *
     * Optionally accepts a `transformFn` to convert an incoming changeset to the expected format.
     * See {@link Core/data/Store#function-applyChangeset} for more details.
     *
     * @param {Object} changes Changeset to apply, an object keyed by store id where each value follows the
     * format described in {@link Core/data/Store#function-applyChangeset}
     * @param {Function} [transformFn] Optional function used to preprocess a changeset per store in a different
     * format, should return an object with the format expected by {@link Core/data/Store#function-applyChangeset}
     * @param {String} [phantomIdField] Field used by the backend when communicating a record being assigned a
     * proper id instead of a phantom id
     */
    applyChangeset(changes, transformFn = null, phantomIdField, logChanges = false) {
      const me = this, log = logChanges ? /* @__PURE__ */ new Map() : void 0;
      me.suspendAutoSync();
      me.suspendChangeTracking();
      for (const { store, phantomIdField: phantomIdField2 } of me.orderedCrudStores) {
        if (changes[store.id]) {
          const storeLog = store.applyChangeset(
            changes[store.id],
            transformFn,
            phantomIdField2 || me.phantomIdField,
            // mark this changeset as remote to enforce it
            true,
            logChanges
          );
          if (storeLog) {
            log.set(store.id, storeLog);
          }
        }
      }
      me.resumeChangeTracking(true);
      me.resumeAutoSync(false);
      return log;
    }
    //endregion
    /**
     * Generates unique request identifier.
     * @internal
     * @template
     * @returns {Number} The request identifier.
     * @category CRUD
     */
    get requestId() {
      return Number.parseInt(`${Date.now()}${this._requestId++}`);
    }
    /**
     * Persists changes made on the registered stores to the server and/or receives changes made on the backend.
     * Usage:
     *
     * ```javascript
     * // persist and run a callback on request completion
     * crud.sync().then(
     *     () => console.log("Changes saved..."),
     *     ({ response, cancelled }) => console.log(`Error: ${cancelled ? 'Cancelled' : response.message}`)
     * );
     * ```
     *
     * ** Note: ** If there is an incomplete sync request in progress then system will queue the call and delay it
     * until previous request completion.
     * In this case {@link #event-syncDelayed} event will be fired.
     *
     * ** Note: ** Please take a look at {@link #config-autoSync} config. This option allows to persist changes
     * automatically after any data modification.
     *
     * ** Note: ** By default a sync request is only sent if there are any local {@link #property-changes}. To
     * always send a request when calling this function, configure {@link #config-forceSync} as `true`.
     *
     * @returns {Promise} Promise, which is resolved if request was successful.
     * Both the resolve and reject functions are passed a `state` object. State object has the following structure:
     * ```
     * {
     *     cancelled       : Boolean, // **optional** flag, which is present when promise was rejected
     *     rawResponse     : String,  // raw response from ajax request, either response xml or text
     *     rawResponseText : String,  // raw response text as String from ajax request
     *     response        : Object,  // processed response in form of object
     * }
     * ```
     * If promise was rejected by the {@link #event-beforeSync} event, `state` object will have this structure:
     * ```
     * {
     *     cancelled : true
     * }
     * ```
     * @category CRUD
     * @async
     */
    sync() {
      const me = this;
      me.clearTimeout("autoSync");
      if (me.activeRequests.sync) {
        me.trigger("syncDelayed");
        return me.activeSyncPromise = me.activeSyncPromise.finally(() => me.sync());
      }
      return me.activeSyncPromise = new Promise((resolve, reject) => {
        const pack = me.getChangesetPackage();
        if (!pack) {
          resolve(null);
          return;
        }
        if (me.trigger("beforeSync", { pack }) !== false) {
          me.trigger("syncStart", { pack });
          me.activeRequests.sync = {
            type: "sync",
            pack,
            resolve,
            reject,
            id: pack.requestId,
            desc: me.sendRequest({
              id: pack.requestId,
              data: me.encode(pack),
              type: "sync",
              success: me.onCrudRequestSuccess,
              failure: me.onCrudRequestFailure,
              thisObj: me
            })
          };
        } else {
          me.trigger("syncCanceled", { pack });
          reject({ cancelled: true });
        }
      }).catch((error) => {
        if (error && !error.cancelled) {
          throw error;
        }
        return error;
      });
    }
    async onCrudRequestSuccess(rawResponse, fetchOptions, request) {
      const me = this, {
        type: requestType,
        id: requestId
      } = request;
      if (me.isDestroyed)
        return;
      let responseText = "";
      request = me.activeRequests[requestType];
      try {
        responseText = await rawResponse.text();
      } catch (e) {
      }
      if (me.isDestroyed)
        return;
      if ((request == null ? void 0 : request.id) !== requestId) {
        throw new Error(`Interleaved ${requestType} operation detected`);
      }
      me.activeRequests[requestType] = null;
      const response = await me.internalOnResponse(request, responseText, fetchOptions);
      if (me.isDestroyed)
        return;
      if (!response || (me.skipSuccessProperty ? (response == null ? void 0 : response.success) === false : !(response == null ? void 0 : response.success))) {
        const error = {
          rawResponse,
          response,
          request
        };
        if (response == null ? void 0 : response.message) {
          error.message = response.message;
        }
        request.reject(new CrudManagerRequestError(error));
      }
      me["crud" + StringHelper.capitalize(request.type) + "ed"] = true;
      request.resolve({ response, rawResponse, responseText, request });
    }
    async onCrudRequestFailure(rawResponse, fetchOptions, request) {
      var _a3;
      const me = this;
      if (me.isDestroyed)
        return;
      request = me.activeRequests[request.type];
      const signal = (_a3 = fetchOptions == null ? void 0 : fetchOptions.abortController) == null ? void 0 : _a3.signal, wasAborted = Boolean(signal == null ? void 0 : signal.aborted);
      if (!wasAborted) {
        let response, responseText = "";
        try {
          responseText = await rawResponse.text();
          response = me.decode(responseText);
        } catch (e) {
        }
        if (me.isDestroyed)
          return;
        me.triggerFailedRequestEvents(request, response, responseText, fetchOptions);
        if (me.isDestroyed)
          return;
        request.reject(new CrudManagerRequestError({
          rawResponse,
          request
        }));
      }
      me.activeRequests[request.type] = null;
    }
    /**
     * Accepts all changes in all stores, resets the modification tracking:
     * * Clears change tracking for all records
     * * Clears added
     * * Clears modified
     * * Clears removed
     * Leaves the store in an "unmodified" state.
     * @category CRUD
     */
    acceptChanges() {
      this.crudStores.forEach((store) => store.store.acceptChanges());
    }
    /**
     * Reverts all changes in all stores and re-inserts any records that were removed locally. Any new uncommitted
     * records will be removed.
     * @category CRUD
     */
    revertChanges() {
      this.revertCrudStoreChanges();
    }
    revertCrudStoreChanges() {
      const { usesSingleAssignment } = this.eventStore;
      this.orderedCrudStores.forEach(({ store }) => (!store.isAssignmentStore || !usesSingleAssignment) && store.revertChanges());
    }
    /**
     * Removes all stores and cancels active requests.
     * @category CRUD
     * @internal
     */
    doDestroy() {
      const me = this, { load, sync } = me.activeRequests;
      load && me.cancelRequest(load.desc, load.reject);
      sync && me.cancelRequest(sync.desc, sync.reject);
      while (me.crudStores.length > 0) {
        me.removeCrudStore(me.crudStores[0]);
      }
      super.doDestroy && super.doDestroy();
    }
  }, __publicField(_a2, "configurable", {
    /**
     * Convenience shortcut to set only the url to load from, when you do not need to supply any other config
     * options in the `load` section of the `transport` config.
     *
     * Using `loadUrl`:
     * ```javascript
     * {
     *     loadUrl : 'read.php
     * }
     * ```
     *
     * Equals the following `transport` config:
     * ```javascript
     * {
     *     transport : {
     *         load : {
     *             url : 'read.php'
     *         }
     *     }
     * }
     * ```
     *
     * When read at runtime, it will return the value from `transport.load.url`.
     *
     * @prp {String}
     */
    loadUrl: null,
    /**
     * Convenience shortcut to set only the url to sync to, when you do not need to supply any other config
     * options in the `sync` section of the `transport` config.
     *
     * Using `loadUrl`:
     * ```javascript
     * {
     *     syncUrl : 'sync.php
     * }
     * ```
     *
     * Equals the following `transport` config:
     * ```javascript
     * {
     *     transport : {
     *         load : {
     *             url : 'sync.php'
     *         }
     *     }
     * }
     * ```
     *
     * When read at runtime, it will return the value from `transport.sync.url`.
     *
     * @prp {String}
     */
    syncUrl: null,
    /**
     * Specify as `true` to force sync requests to be sent when calling `sync()`, even if there are no local
     * changes. Useful in a polling scenario, to keep client up to date with the backend.
     * @prp {Boolean}
     */
    forceSync: null
  }), __publicField(_a2, "delayable", {
    // Postponed to next frame, to allow Scheduler created after CrudManager to inject its stores
    // (timeRanges, resourceTimeRanges)
    doAutoLoad: "raf"
  }), _a2;
};

// ../Scheduler/lib/Scheduler/crud/transport/AjaxTransport.js
var AjaxTransport_default = (Target) => class AjaxTransport extends (Target || Base) {
  static get $name() {
    return "AjaxTransport";
  }
  /**
   * Configuration of the AJAX requests used by _Crud Manager_ to communicate with a server-side.
   *
   * ```javascript
   * transport : {
   *     load : {
   *         url       : 'http://mycool-server.com/load.php',
   *         // HTTP request parameter used to pass serialized "load"-requests
   *         paramName : 'data',
   *         // pass extra HTTP request parameter
   *         params    : {
   *             foo : 'bar'
   *         }
   *     },
   *     sync : {
   *         url     : 'http://mycool-server.com/sync.php',
   *         // specify Content-Type for requests
   *         headers : {
   *             'Content-Type' : 'application/json'
   *         }
   *     }
   * }
   *```
   * Since the class uses Fetch API you can use
   * any its [Request interface](https://developer.mozilla.org/en-US/docs/Web/API/Request) options:
   *
   * ```javascript
   * transport : {
   *     load : {
   *         url         : 'http://mycool-server.com/load.php',
   *         // HTTP request parameter used to pass serialized "load"-requests
   *         paramName   : 'data',
   *         // pass few Fetch API options
   *         method      : 'GET',
   *         credentials : 'include',
   *         cache       : 'no-cache'
   *     },
   *     sync : {
   *         url         : 'http://mycool-server.com/sync.php',
   *         // specify Content-Type for requests
   *         headers     : {
   *             'Content-Type' : 'application/json'
   *         },
   *         credentials : 'include'
   *     }
   * }
   *```
   *
   * An object where you can set the following possible properties:
   * @config {Object} transport
   * @property {Object} [transport.load] Load requests configuration:
   * @property {String} [transport.load.url] URL to request for data loading.
   * @property {String} [transport.load.method='GET'] HTTP method to be used for load requests.
   * @property {String} [transport.load.paramName='data'] Name of the parameter that will contain a serialized `load`
   * request. The value is mandatory for requests using `GET` method (default for `load`) so if the value is not
   * provided `data` string is used as default.
   * This value is optional for HTTP methods like `POST` and `PUT`, the request body will be used for data
   * transferring in these cases.
   * @property {Object} [transport.load.params] An object containing extra HTTP parameters to pass to the server when
   * sending a `load` request.
   *
   * ```javascript
   * transport : {
   *     load : {
   *         url       : 'http://mycool-server.com/load.php',
   *         // HTTP request parameter used to pass serialized "load"-requests
   *         paramName : 'data',
   *         // pass extra HTTP request parameter
   *         // so resulting URL will look like: http://mycool-server.com/load.php?userId=123456&data=...
   *         params    : {
   *             userId : '123456'
   *         }
   *     },
   *     ...
   * }
   * ```
   * @property {Object<String,String>} [transport.load.headers] An object containing headers to pass to each server request.
   *
   * ```javascript
   * transport : {
   *     load : {
   *         url       : 'http://mycool-server.com/load.php',
   *         // HTTP request parameter used to pass serialized "load"-requests
   *         paramName : 'data',
   *         // specify Content-Type for "load" requests
   *         headers   : {
   *             'Content-Type' : 'application/json'
   *         }
   *     },
   *     ...
   * }
   * ```
   * @property {Object} [transport.load.fetchOptions] **DEPRECATED:** Any Fetch API options can be simply defined on
   * the upper configuration level:
   * ```javascript
   * transport : {
   *     load : {
   *         url          : 'http://mycool-server.com/load.php',
   *         // HTTP request parameter used to pass serialized "load"-requests
   *         paramName    : 'data',
   *         // Fetch API options
   *         method       : 'GET',
   *         credentials  : 'include'
   *     },
   *     ...
   * }
   * ```
   * @property {Object} [transport.load.requestConfig] **DEPRECATED:** The config options can be defined on the upper
   * configuration level.
   * @property {Object} [transport.sync] Sync requests (`sync` in further text) configuration:
   * @property {String} [transport.sync.url] URL to request for `sync`.
   * @property {String} [transport.sync.method='POST'] HTTP request method to be used for `sync`.
   * @property {String} [transport.sync.paramName=undefined] Name of the parameter in which `sync` data will be
   * transferred. This value is optional for requests using methods like `POST` and `PUT`, the request body will be
   * used for data transferring in this case (default for `sync`). And the value is mandatory for requests using `GET`
   * method (if the value is not provided `data` string will be used as fallback).
   * @property {Object} [transport.sync.params] HTTP parameters to pass with an HTTP request handling `sync`.
   *
   * ```javascript
   * transport : {
   *     sync : {
   *         url    : 'http://mycool-server.com/sync.php',
   *         // extra HTTP request parameter
   *         params : {
   *             userId : '123456'
   *         }
   *     },
   *     ...
   * }
   * ```
   * @property {Object<String,String>} [transport.sync.headers] HTTP headers to pass with an HTTP request handling `sync`.
   *
   * ```javascript
   * transport : {
   *     sync : {
   *         url     : 'http://mycool-server.com/sync.php',
   *         // specify Content-Type for "sync" requests
   *         headers : {
   *             'Content-Type' : 'application/json'
   *         }
   *     },
   *     ...
   * }
   * ```
   * @property {Object} [transport.sync.fetchOptions] **DEPRECATED:** Any Fetch API options can be simply defined on
   * the upper configuration level:
   * ```javascript
   * transport : {
   *     sync : {
   *         url         : 'http://mycool-server.com/sync.php',
   *         credentials : 'include'
   *     },
   *     ...
   * }
   * ```
   * @property {Object} [transport.sync.requestConfig] **DEPRECATED:** The config options can be defined on the upper
   * configuration level.
   * @category CRUD
   */
  static get defaultMethod() {
    return {
      load: "GET",
      sync: "POST"
    };
  }
  /**
   * Cancels a sent request.
   * @param {Promise} requestPromise The Promise object wrapping the Request to be cancelled.
   * The _requestPromise_ is the value returned from the corresponding {@link #function-sendRequest} call.
   * @category CRUD
   */
  cancelRequest(requestPromise, reject) {
    var _a2;
    (_a2 = requestPromise.abort) == null ? void 0 : _a2.call(requestPromise);
    if (!this.isDestroying) {
      reject({ cancelled: true });
    }
  }
  shouldUseBodyForRequestData(packCfg, method, paramName) {
    return !(method === "HEAD" || method === "GET") && !paramName;
  }
  /**
   * Sends a _Crud Manager_ request to the server.
   * @param {Object} request The request configuration object having following properties:
   * @param {'load'|'sync'} request.type The request type. Either `load` or `sync`.
   * @param {String} request.url The URL for the request. Overrides the URL defined in the `transport` object
   * @param {String} request.data The encoded _Crud Manager_ request data.
   * @param {Object} request.params An object specifying extra HTTP params to send with the request.
   * @param {Function} request.success A function to be started on successful request transferring.
   * @param {String} request.success.rawResponse `Response` object returned by the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
   * @param {Function} request.failure A function to be started on request transfer failure.
   * @param {String} request.failure.rawResponse `Response` object returned by the [fetch api](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API).
   * @param {Object} request.thisObj `this` reference for the above `success` and `failure` functions.
   * @returns {Promise} The fetch Promise object.
   * @fires beforeSend
   * @async
   * @category CRUD
   */
  sendRequest(request) {
    const me = this, { data } = request, transportConfig = me.transport[request.type] || {}, requestConfig = Objects.assign({}, transportConfig, transportConfig.requestConfig);
    if (request.url) {
      requestConfig.url = request.url;
    }
    requestConfig.method = requestConfig.method || AjaxTransport.defaultMethod[request.type];
    requestConfig.params = Objects.assign(requestConfig.params || {}, request.params);
    let { paramName } = requestConfig;
    if (me.shouldUseBodyForRequestData(transportConfig, requestConfig.method, paramName)) {
      requestConfig.body = data;
      requestConfig.headers = requestConfig.headers || {};
      requestConfig.headers["Content-Type"] = requestConfig.headers["Content-Type"] || "application/json";
    } else {
      paramName = paramName || "data";
      requestConfig.params[paramName] = data;
    }
    if (!requestConfig.url) {
      throw new Error("Trying to request without URL specified");
    }
    delete requestConfig.requestConfig;
    delete requestConfig.paramName;
    let ajaxPromise, resultPromise;
    function performSend() {
      requestConfig.queryParams = requestConfig.params;
      delete requestConfig.params;
      let cancelled = false;
      const fetchOptions = Objects.assign({}, requestConfig, requestConfig.fetchOptions);
      ajaxPromise = AjaxHelper.fetch(requestConfig.url, fetchOptions);
      return ajaxPromise.catch((error) => {
        var _a2, _b;
        ajaxPromise.done = true;
        (_a2 = me.trigger) == null ? void 0 : _a2.call(me, "responseReceived", { success: false });
        const signal = (_b = fetchOptions.abortController) == null ? void 0 : _b.signal;
        if (signal) {
          cancelled = signal.aborted;
          if (!cancelled) {
            console.warn(error);
          }
        }
        return { error, cancelled };
      }).then((response) => {
        var _a2;
        ajaxPromise.done = true;
        (_a2 = me.trigger) == null ? void 0 : _a2.call(me, "responseReceived", { success: Boolean(response == null ? void 0 : response.ok) });
        const callback = (response == null ? void 0 : response.ok) ? request.success : request.failure;
        return callback == null ? void 0 : callback.call(request.thisObj || me, response, fetchOptions, request);
      });
    }
    const beforeSendResult = me.trigger("beforeSend", {
      params: requestConfig.params,
      requestType: request.type,
      requestConfig,
      config: request
    });
    if (Objects.isPromise(beforeSendResult)) {
      resultPromise = beforeSendResult.then(performSend);
    } else {
      resultPromise = performSend();
    }
    resultPromise.abort = () => {
      var _a2;
      if (!ajaxPromise.done) {
        (_a2 = ajaxPromise.abort) == null ? void 0 : _a2.call(ajaxPromise);
      }
    };
    return resultPromise;
  }
};

// ../Scheduler/lib/Scheduler/crud/encoder/JsonEncoder.js
var JsonEncoder_default = (Target) => class JsonEncoder extends (Target || Base) {
  static get $name() {
    return "JsonEncoder";
  }
  static get defaultConfig() {
    return {
      /**
       * Configuration of the JSON encoder used by the _Crud Manager_.
       *
       * @config {Object}
       * @property {Object} encoder.requestData Static data to send with the data request.
       *
       * ```js
       * new CrudManager({
       *     // add static "foo" property to all requests data
       *     encoder : {
       *         requestData : {
       *             foo : 'Bar'
       *         }
       *     },
       *     ...
       * });
       * ```
       *
       * The above snippet will result adding "foo" property to all requests data:
       *
       * ```json
       *     {
       *         "requestId"   : 756,
       *         "type"        : "load",
       *
       *         "foo"         : "Bar",
       *
       *         "stores"      : [
       *             ...
       * ```
       * @category CRUD
       */
      encoder: {}
    };
  }
  /**
   * Encodes a request object to _JSON_ encoded string. If encoding fails (due to circular structure), it returns null.
   * Supposed to be overridden in case data provided by the _Crud Manager_ has to be transformed into format requested by server.
   * @param {Object} requestData The request to encode.
   * @returns {String} The encoded request.
   * @category CRUD
   */
  encode(requestData) {
    var _a2;
    requestData = Object.assign({}, (_a2 = this.encoder) == null ? void 0 : _a2.requestData, requestData);
    return StringHelper.safeJsonStringify(requestData);
  }
  /**
   * Decodes (parses) a _JSON_ response string to an object. If parsing fails, it returns null.
   * Supposed to be overridden in case data provided by server has to be transformed into format requested by the _Crud Manager_.
   * @param {String} responseText The response text to decode.
   * @returns {Object} The decoded response.
   * @category CRUD
   */
  decode(responseText) {
    return StringHelper.safeJsonParse(responseText);
  }
};

// ../Scheduler/lib/Scheduler/data/mixin/ProjectCrudManager.js
var ProjectCrudManager_default = (Target) => class ProjectCrudManager extends (Target || Base).mixin(AbstractCrudManagerMixin_default, AjaxTransport_default, JsonEncoder_default) {
  //region Config
  static get defaultConfig() {
    return {
      project: null
    };
  }
  startConfigure(config) {
    this.getConfig("project");
    super.startConfigure(config);
    this._changesToClear = /* @__PURE__ */ new Map();
  }
  async doAutoLoad() {
    const { project } = this;
    if (project) {
      await project.commitAsync();
    }
    return super.doAutoLoad();
  }
  applyProjectResponse(response) {
    const me = this, { project } = me;
    me.applyingProjectResponse = true;
    const startDateField = project.fieldMap.startDate, endDateField = project.fieldMap.endDate, startDate = ObjectHelper.getPath(response, startDateField.dataSource), endDate = ObjectHelper.getPath(response, endDateField.dataSource);
    if (typeof startDate === "string") {
      ObjectHelper.setPath(response, startDateField.dataSource, startDateField.convert(startDate));
    }
    if (typeof endDate === "string") {
      ObjectHelper.setPath(response, endDateField.dataSource, endDateField.convert(endDate));
    }
    project.setByDataSource(response);
    me._changesToClear.set(me, response);
    me.applyingProjectResponse = false;
  }
  loadCrudManagerData(response, options = {}) {
    const me = this, { project } = me;
    me.suspendChangeTracking();
    super.loadCrudManagerData(...arguments);
    if (response == null ? void 0 : response.project) {
      if (project.delayEnteringReplica && project.hasDataInStores) {
        project.ion({
          recordsUnlinked: () => {
            me.suspendChangeTracking();
            me.applyProjectResponse(response.project);
            me.resumeChangeTracking();
          },
          once: true
        });
      } else {
        me.applyProjectResponse(response.project);
      }
    }
    me.resumeChangeTracking();
  }
  async sync() {
    const { project } = this;
    this.suspendAutoSync();
    if (project) {
      await project.commitAsync();
    }
    if (this.isDestroying) {
      return;
    }
    this.resumeAutoSync(false);
    return super.sync();
  }
  async applyResponse(request, response, options) {
    var _a2, _b, _c, _d, _e, _f;
    const me = this;
    if (me.isDestroyed || ((_a2 = me.project) == null ? void 0 : _a2.isDestroyed)) {
      return;
    }
    me.trigger("beforeApplyResponse");
    await super.applyResponse(request, response, options);
    if ((response == null ? void 0 : response.project) || me.supportShortSyncResponse && ((_b = request == null ? void 0 : request.pack) == null ? void 0 : _b.project)) {
      me.applyProjectResponse(response.project || ((_c = request == null ? void 0 : request.pack) == null ? void 0 : _c.project));
    }
    if (me.project) {
      let requestType = request.type;
      if (me.trackResponseType) {
        requestType = response.type || requestType;
      }
      const propagationFlag = `propagating${StringHelper.capitalize(requestType)}Changes`;
      me.suspendAutoSync();
      me[propagationFlag] = true;
      const loud = me.project.isInitialCommit && !me.project.silenceInitialCommit;
      await me.project.commitAsync();
      me[propagationFlag] = false;
      (_d = me.resumeAutoSync) == null ? void 0 : _d.call(me, loud);
      (_e = me.commitRespondedChanges) == null ? void 0 : _e.call(me);
    }
    (_f = me.trigger) == null ? void 0 : _f.call(me, "applyResponse");
  }
  applySyncResponse(...args) {
    var _a2;
    const me = this, stmDisabled = (_a2 = me.project) == null ? void 0 : _a2.stm.disabled;
    if (stmDisabled === false && me.ignoreRemoteChangesInSTM) {
      me.project.stm.disable();
    }
    super.applySyncResponse(...args);
    if (stmDisabled === false) {
      me.project.stm.enable();
    }
  }
  shouldClearRecordFieldChange(record, field, value) {
    const oldValue = record.getValue(field);
    field = record.getFieldDefinition(field);
    return (field == null ? void 0 : field.isEqual) ? field.isEqual(oldValue, value) : ObjectHelper.isEqual(oldValue, value);
  }
  commitRespondedChanges() {
    this._changesToClear.forEach((changes, record) => {
      Object.entries(changes).forEach(([key, value]) => {
        if (this.shouldClearRecordFieldChange(record, key, value)) {
          delete record.meta.modified[key];
        }
      });
    });
    this._changesToClear.clear();
  }
  applyChangesToStore(storeDesc, storeResponse, storePack, ...rest) {
    const changesMap = super.applyChangesToStore(storeDesc, storeResponse, storePack, ...rest);
    if (changesMap.size && this.project) {
      for (const [id, changes] of changesMap) {
        const record = storeDesc.store.getById(id);
        record && this._changesToClear.set(record, changes);
      }
    }
    return changesMap;
  }
};

// lib/TaskBoard/model/TaskModel.js
var TaskModel = class extends EventModel {
};
__publicField(TaskModel, "$name", "TaskModel");
__publicField(TaskModel, "fields", [
  /**
   * Task status, for example for linking to a column on the TaskBoard.
   *
   * @field {String} status
   */
  "status",
  /**
   * Task priority, for example for linking to a swimlane on the TaskBoard.
   *
   * @field {String|Number} prio
   */
  "prio",
  /**
   * Task description, by default shown in tasks body.
   *
   * @field {String} description
   */
  "description",
  /**
   * Color, named colors are applied as a `b-taskboard-color-{color}` (for example `b-taskboard-color-red`) CSS
   * class to the tasks card. Colors specified as hex, `rgb()` etc. are applied as `style.color` to the card.
   *
   * If no color is specified, any color defined on the {@link TaskBoard/model/ColumnModel#field-color column} or
   * {@link TaskBoard/model/SwimlaneModel#field-color swimlane} will apply instead.
   *
   * By default it does not visually affect the UI, but it applies a color to the task that applications can
   * leverage using `currentColor` to style it in the desired way.
   *
   * Using named colors:
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *     project {
   *         tasksData : [
   *             { id : 1, name : 'Important task', eventColor : 'red' }
   *         ]
   *     }
   * });
   * ```
   *
   * Will result in:
   *
   * ```html
   * <div class="b-taskboard-card b-taskboard-color-red">
   * ```
   *
   * Which can the be used for example like:
   *
   * ```css
   * .b-taskboard-card {
   *     // currentColor is the color defined by b-red
   *     border-left : 5px solid currentColor;
   * }
   * ```
   *
   * Using non-named colors:
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *     project {
   *         tasksData : [
   *             { id : 1, name : 'Important task', eventColor : '#ff0000' }
   *         ]
   *     }
   * });
   * ```
   *
   * Will result in:
   *
   * ```html
   * <div class="b-taskboard-card" style="color: #ff0000">
   * ```
   *
   * Predefined named colors (actual color might vary by theme):
   * <div class="b-colorbox b-inline b-taskboard-color-red"></div>red,
   * <div class="b-colorbox b-inline b-taskboard-color-pink"></div>pink,
   * <div class="b-colorbox b-inline b-taskboard-color-purple"></div>purple,
   * <div class="b-colorbox b-inline b-taskboard-color-deep-purple"></div>deep-purple,
   * <div class="b-colorbox b-inline b-taskboard-color-indigo"></div>indigo,
   * <div class="b-colorbox b-inline b-taskboard-color-blue"></div>blue,
   * <div class="b-colorbox b-inline b-taskboard-color-light-blue"></div>light-blue,
   * <div class="b-colorbox b-inline b-taskboard-color-cyan"></div>cyan,
   * <div class="b-colorbox b-inline b-taskboard-color-teal"></div>teal,
   * <div class="b-colorbox b-inline b-taskboard-color-green"></div>green,
   * <div class="b-colorbox b-inline b-taskboard-color-light-green"></div>light-green,
   * <div class="b-colorbox b-inline b-taskboard-color-lime"></div>lime,
   * <div class="b-colorbox b-inline b-taskboard-color-yellow"></div>yellow,
   * <div class="b-colorbox b-inline b-taskboard-color-amber"></div>amber,
   * <div class="b-colorbox b-inline b-taskboard-color-orange"></div>orange,
   * <div class="b-colorbox b-inline b-taskboard-color-deep-orange"></div>deep-orange,
   * <div class="b-colorbox b-inline b-taskboard-color-gray"></div>gray,
   * <div class="b-colorbox b-inline b-taskboard-color-light-gray"></div>light-gray
   *
   * @field {'red'|'pink'|'purple'|'deep-purple'|'indigo'|'blue'|'light-blue'|'cyan'|'teal'|'green'|'light-green'|'lime'|'yellow'|'amber'|'orange'|'deep-orange'|'gray'|'light-gray'|String|null} eventColor
   */
  "eventColor",
  /**
   * Task weight, used by default to determine its index in a column. Higher weights are displayed further down.
   *
   * The weight is applied as a default sorter to the {@link TaskBoard/store/TaskStore}.
   *
   * When no weights are defined, task order is determined by store order.
   *
   * @field {Number} weight
   */
  { name: "weight", type: "number" },
  /**
   * Set to `true` to make the task read-only, preventing it from being edited in the UI.
   *
   * See the class description above for a live demo.
   *
   * @field {Boolean} readOnly
   */
  { name: "readOnly", type: "boolean" }
]);
TaskModel._$name = "TaskModel";

// lib/TaskBoard/store/TaskStore.js
var TaskStore = class extends EventStore {
  afterLoadData() {
    const { records } = this;
    if (this.autoAssignWeight && !records.some((r) => r.weight != null)) {
      for (let i = 0; i < records.length; i++) {
        records[i].setData("weight", (i + 1) * 100);
      }
    }
  }
};
__publicField(TaskStore, "configurable", {
  autoAssignWeight: true,
  storeId: "tasks",
  /**
   * Class used to represent records, defaults to {@link TaskBoard.model.TaskModel}
   * @config {TaskBoard.model.TaskModel}
   * @typings {typeof TaskModel}
   * @category Common
   */
  modelClass: TaskModel,
  /**
   * Configure with `true` to also remove the event when removing the last assignment from the linked
   * AssignmentStore.
   *
   * Defaults to `false` for TaskBoard since it is unexpected that a tasks disappears when unassigning the last
   * resource from it.
   *
   * @config {Boolean}
   * @default
   * @category Common
   */
  removeUnassignedEvent: false,
  /**
   * Initial sorters, format is `[{ field: 'name', ascending: false }, ...]`.
   *
   * By default the TaskStore is sorted by `weight`, tasks with higher weights are displayed further down.
   *
   * @config {Sorter[]|String[]}
   * @category Common
   */
  sorters: [
    { field: "weight", ascending: true }
  ]
});
TaskStore._$name = "TaskStore";

// lib/TaskBoard/model/ProjectModel.js
var ProjectModel2 = class extends ProjectModel.mixin(ProjectCrudManager_default) {
  construct(config) {
    if (config.tasks) {
      config.eventsData = config.tasks;
    }
    if (config.tasksData) {
      config.eventsData = config.tasksData;
    }
    if (config.taskStore) {
      config.eventStore = config.taskStore;
    }
    if (config.taskModelClass) {
      config.eventModelClass = config.taskModelClass;
    }
    if (config.taskStoreClass) {
      config.eventStoreClass = config.taskStoreClass;
    }
    super.construct(config);
    const me = this;
    me.addPrioritizedStore(me.assignmentStore);
    me.addPrioritizedStore(me.resourceStore);
    me.addPrioritizedStore(me.taskStore);
  }
  get taskStore() {
    return this.eventStore;
  }
  set taskStore(store) {
    this.eventStore = store;
  }
  get tasksData() {
    return this.eventsData;
  }
  set tasksData(data) {
    this.eventsData = data;
  }
  get tasks() {
    return this.eventsData;
  }
  set tasks(data) {
    this.events = data;
  }
  /**
   * Returns the data from the records of the projects stores, in a format that can be consumed by `loadInlineData()`.
   *
   * Used by JSON.stringify to correctly convert this project to json.
   *
   * ```javascript
   * const project = new ProjectModel({
   *     tasksData       : [...],
   *     resourcesData   : [...],
   *     assignmentsData : [...]
   * });
   *
   * const json = project.toJSON();
   *
   * // Result:
   * {
   *     taskData : [...],
   *     resourcesData : [...],
   *     assignmentsData : [...]
   * }
   * ```
   *
   * Output can be consumed by `loadInlineData()`:
   *
   * ```javascript
   * const json = project.toJSON();
   *
   * // Plug it back in later
   * project.loadInlineData(json);
   * ```
   *
   * @returns {Object}
   * @category JSON
   */
  toJSON() {
    const { taskStore, assignmentStore, resourceStore } = this, result = {
      tasksData: taskStore.toJSON()
    };
    if (assignmentStore == null ? void 0 : assignmentStore.count) {
      result.assignmentsData = assignmentStore.toJSON();
    }
    if (resourceStore == null ? void 0 : resourceStore.count) {
      result.resourcesData = resourceStore.toJSON();
    }
    return result;
  }
};
__publicField(ProjectModel2, "configurable", {
  /**
   * Get/set {@link #property-taskStore} data.
   *
   * Always returns an array of {@link TaskBoard.model.TaskModel} but also accepts an array of
   * its configuration objects as input.
   *
   * @member {TaskBoard.model.TaskModel[]} tasks
   * @accepts {TaskBoard.model.TaskModel[]|TaskModelConfig[]}
   * @category Inline data
   */
  /**
   * The initial data, to fill the {@link #property-taskStore} with. Should be an array of
   * {@link TaskBoard.model.TaskModel} or its configuration objects.
   *
   * @config {TaskBoard.model.TaskModel[]|TaskModelConfig[]} tasks
   * @category Inline data
   */
  /**
   * The initial data, to fill the {@link #property-taskStore} with.
   * Should be an array of {@link TaskBoard.model.TaskModel} instances or its configuration objects.
   *
   * @config {TaskBoard.model.TaskModel[]|TaskModelConfig[]} tasksData
   * @category Legacy inline data
   */
  /**
   * The {@link TaskBoard.store.TaskStore store} holding the tasks information.
   *
   * See also {@link TaskBoard.model.TaskModel}
   *
   * @member {TaskBoard.store.TaskStore} taskStore
   * @category Models & Stores
   */
  /**
   * An {@link TaskBoard.store.TaskStore} instance or a config object.
   * @config {TaskStoreConfig|TaskBoard.store.TaskStore} taskStore
   * @category Models & Stores
   */
  /**
   * @hideconfigs timeRanges
   *              timeRangeStore,
   *              timeRangesData,
   *              timeRangeStoreClass,
   *              resourceTimeRanges,
   *              resourceTimeRangeStore,
   *              resourceTimeRangesData,
   *              resourceTimeRangeStoreClass,
   *              eventStoreClass,
   *              eventModelClass
   */
  /**
   * @hideproperties timeRangeStore,
   *                 resourceTimeRangeStore
   */
  eventStoreClass: TaskStore,
  eventModelClass: TaskModel,
  /**
   * The constructor to create a task store instance with.
   * Should be a class, subclassing the {@link TaskBoard.store.TaskStore}.
   * @config {TaskBoard.store.TaskStore}
   * @typings {typeof TaskStore}
   * @category Models & Stores
   */
  taskStoreClass: TaskStore,
  /**
   * The constructor of the task model class, to be used in the project.
   * Will be set as the {@link Core.data.Store#config-modelClass modelClass}
   * property of the {@link #property-taskStore}.
   * @config {TaskBoard.model.TaskModel}
   * @typings {typeof TaskModel}
   * @category Models & Stores
   */
  taskModelClass: TaskModel
});
ProjectModel2._$name = "ProjectModel";

// lib/TaskBoard/model/SwimlaneModel.js
var SwimlaneModel = class extends Model {
  get taskBoard() {
    return this.firstStore.taskBoard;
  }
  /**
   * Collapse this swimlane.
   *
   * Uses a transition by default, await the call to be certain that it has finished.
   *
   * @category Expand/collapse
   * @returns {Promise} A promise which is resolved when the column is collapsed
   */
  async collapse() {
    this.taskBoard.collapse(this);
  }
  /**
   * Expand this swimlane.
   *
   * Uses a transition by default, await the call to be certain that it has finished.
   *
   * @category Expand/collapse
   * @returns {Promise} A promise which is resolved when the column is expanded
   */
  async expand() {
    return this.taskBoard.expand(this);
  }
  /**
   * Get tasks in this swimlane.
   * @property {TaskBoard.model.TaskModel[]}
   * @readonly
   */
  get tasks() {
    return [...this.taskBoard.getSwimlaneTasks(this) || []];
  }
};
__publicField(SwimlaneModel, "$name", "SwimlaneModel");
__publicField(SwimlaneModel, "fields", [
  /**
   * The swimlane's unique id, used to match a task to a swimlane (which field on a task to match is specified
   * using then {@link TaskBoard.view.TaskBoardBase#config-swimlaneField} config on TaskBoard).
   * @field {String|Number} id
   */
  /**
   * Text displayed in the swimlane header.
   * @field {String} text
   */
  { name: "text", type: "string" },
  /**
   * Color, named colors are applied as a `b-taskboard-color-{color}` (for example `b-taskboard-color-red`) CSS
   * class to the swimlane. Colors specified as hex, `rgb()` etc. are applied as `style.color` to the swilane.
   *
   * By default it does not visually affect the UI, but it applies a color to the swimlane that applications can
   * leverage using `currentColor` to style it in the desired way.
   *
   * Using named colors:
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *     swimlanes : [
   *         { id : 'high', text : 'High', color : 'red' }
   *     ]
   * });
   * ```
   *
   * Will result in:
   *
   * ```html
   * <div class="b-taskboard-swimlane b-taskboard-color-red">
   * ```
   *
   * Which can the be used for example like:
   *
   * ```css
   * .b-taskboard-swimlane-header {
   *     border-left : 5px solid currentColor; // where currentColor is the color defined by b-red
   * }
   * ```
   *
   * Using non-named colors:
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *     swimlanes : [
   *         { id : 'high', text : 'High', color : 'hsl(229deg 66% 42%)' }
   *     ]
   * });
   * ```
   *
   * Will result in:
   *
   * ```html
   * <div class="b-taskboard-swimlane" style="color: hsl(229deg 66% 42%)">
   * ```
   *
   * Predefined named colors (actual color might vary by theme):
   * <div class="b-colorbox b-inline b-taskboard-color-red"></div>red,
   * <div class="b-colorbox b-inline b-taskboard-color-pink"></div>pink,
   * <div class="b-colorbox b-inline b-taskboard-color-purple"></div>purple,
   * <div class="b-colorbox b-inline b-taskboard-color-deep-purple"></div>deep-purple,
   * <div class="b-colorbox b-inline b-taskboard-color-indigo"></div>indigo,
   * <div class="b-colorbox b-inline b-taskboard-color-blue"></div>blue,
   * <div class="b-colorbox b-inline b-taskboard-color-light-blue"></div>light-blue,
   * <div class="b-colorbox b-inline b-taskboard-color-cyan"></div>cyan,
   * <div class="b-colorbox b-inline b-taskboard-color-teal"></div>teal,
   * <div class="b-colorbox b-inline b-taskboard-color-green"></div>green,
   * <div class="b-colorbox b-inline b-taskboard-color-light-green"></div>light-green,
   * <div class="b-colorbox b-inline b-taskboard-color-lime"></div>lime,
   * <div class="b-colorbox b-inline b-taskboard-color-yellow"></div>yellow,
   * <div class="b-colorbox b-inline b-taskboard-color-amber"></div>amber,
   * <div class="b-colorbox b-inline b-taskboard-color-orange"></div>orange,
   * <div class="b-colorbox b-inline b-taskboard-color-deep-orange"></div>deep-orange
   *
   * @field {String} color
   */
  { name: "color", type: "string" },
  /**
   * Allow collapsing this swimlane
   * @field {Boolean} collapsible=true
   */
  { name: "collapsible", type: "boolean", defaultValue: true },
  /**
   * Collapsed (true) or expanded (False).
   *
   * To expand or collapse, use TaskBoards {@link TaskBoard.view.mixin.ExpandCollapse#function-expand} and
   * {@link TaskBoard.view.mixin.ExpandCollapse#function-collapse} functions.
   *
   * @field {Boolean} collapsed
   * @readonly
   */
  { name: "collapsed", type: "boolean" },
  /**
  * Set to `true` to hide the swimlane, `false` to show it again.
  * @field {Boolean} hidden
  */
  { name: "hidden", type: "boolean" },
  /**
   * Swimlane height in px.
   * @field {Number} height
   */
  { name: "height", type: "number" },
  /**
   * Swimlane flex, affects height.
   * @field {Number} flex
   */
  { name: "flex", type: "number" },
  /**
   * Number of tasks per row to display in this swimlane. Leave blank to use the setting from the
   * {@link TaskBoard.view.TaskBoardBase#config-tasksPerRow} config on TaskBoard.
   * @field {Number} tasksPerRow
   */
  "tasksPerRow"
]);
SwimlaneModel._$name = "SwimlaneModel";

// lib/TaskBoard/view/mixin/ExpandCollapse.js
var ExpandCollapse_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    //endregion
    //region Type assertions
    changeShowCollapseInHeader(showCollapseInHeader) {
      ObjectHelper.assertBoolean(showCollapseInHeader, "showCollapseInHeader");
      return showCollapseInHeader;
    }
    //endregion
    //region Events
    /**
     * Triggered when a column is expanded.
     *
     * @event columnExpand
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.ColumnModel} columnRecord Column record
     */
    /**
     * Triggered when a column is collapsed.
     *
     * @event columnCollapse
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.ColumnModel} columnRecord Column record
     */
    /**
     * Triggered when the column collapsed state is toggled.
     *
     * @event columnToggle
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.ColumnModel} columnRecord Column record
     * @param {Boolean} collapse `true` if the column is being collapsed.
     */
    /**
     * Triggered when a swimlane is expanded.
     *
     * @event swimlaneExpand
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record
     */
    /**
     * Triggered when a swimlane is collapsed.
     *
     * @event swimlaneCollapse
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record
     */
    /**
     * Triggered when the swimlane collapsed state is toggled.
     *
     * @event swimlaneToggle
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record
     * @param {Boolean} collapse `true` if the column is being collapsed.
     */
    //endregion
    //region Toggling
    /**
     * Collapse a swimlane or column.
     *
     * Await the call to be certain that the collapse transition has ended.
     *
     * ```javascript
     * await taskBoard.collapse(taskBoard.columns.first);
     * ```
     *
     * @param {TaskBoard.model.SwimlaneModel|TaskBoard.model.ColumnModel} record Swimlane or column
     * @category Expand & collapse
     */
    async collapse(record) {
      return this.toggleCollapse(record, true);
    }
    /**
     * Expand a swimlane or column.
     *
     * Await the call to be certain that the expand transition has ended.
     *
     * ```javascript
     * await taskBoard.expand(taskBoard.columns.first);
     * ```
     *
     * @param {TaskBoard.model.SwimlaneModel|TaskBoard.model.ColumnModel} record Swimlane or column
     * @category Expand & collapse
     */
    async expand(record) {
      return this.toggleCollapse(record, false);
    }
    /**
     * Expand or collapse a swimlane or column.
     *
     * Await the call to be certain that the expand/collapse transition has ended.
     *
     * ```javascript
     * // Toggle
     * await taskBoard.toggleCollapse(taskBoard.columns.first);
     * // Force collapse
     * await taskBoard.toggleCollapse(taskBoard.columns.first, true);
     * // Force expand
     * await taskBoard.toggleCollapse(taskBoard.columns.first, false);
     * ```
     *
     * @param {TaskBoard.model.SwimlaneModel|TaskBoard.model.ColumnModel} record Swimlane or column
     * @param {Boolean} [collapse] Specify to force a certain state, leave out to toggle
     * @category Expand & collapse
     * @fires columnCollapse
     * @fires columnExpand
     * @fires columnToggle
     * @fires swimlaneCollapse
     * @fires swimlaneExpand
     * @fires swimlaneToggle
     */
    async toggleCollapse(record, collapse = !record.collapsed) {
      if (record.isSwimlaneModel) {
        await this.toggleSwimlaneCollapse(record, collapse);
      } else {
        await this.toggleColumnCollapse(record, collapse);
      }
    }
    async toggleSwimlaneCollapse(swimlaneRecord, collapse = !swimlaneRecord.collapsed) {
      return new Promise((resolve) => {
        const me = this, swimlaneElement = me.getSwimlaneElement(swimlaneRecord), swimlaneBody = DomSync.getChild(swimlaneElement, "body");
        if (collapse) {
          swimlaneBody.style.height = `${swimlaneBody.getBoundingClientRect().height}px`;
        }
        EventHelper.onTransitionEnd({
          element: swimlaneBody,
          property: "height",
          handler() {
            if (collapse) {
              swimlaneElement.style.height = "";
            } else {
              swimlaneBody.style.height = "";
              swimlaneElement.style.height = `${swimlaneRecord.height}px`;
            }
            swimlaneElement.classList.remove(collapse ? "b-collapsing" : "b-expanding");
            me.recompose.flush();
            resolve();
          },
          thisObj: me
        });
        swimlaneElement.classList.add(collapse ? "b-collapsing" : "b-expanding");
        me.suspendDomTransition();
        swimlaneRecord.collapsed = collapse;
        me.trigger(`swimlane${collapse ? "Collapse" : "Expand"}`, { swimlaneRecord });
        me.trigger("swimlaneToggle", { swimlaneRecord, collapse });
        me.resumeDomTransition();
      });
    }
    async toggleColumnCollapse(columnRecord, collapse = !columnRecord.collapsed) {
      return new Promise((resolve) => {
        var _a3, _b;
        const me = this, { documentRoot } = me, columnElements = me.getColumnElements(columnRecord), headerElement = DomSync.getChild(me.bodyElement, `header.${columnRecord.domId}`), hasFixedWidth = columnRecord.width && !columnRecord.flex, cardElements = documentRoot.querySelectorAll(`.b-taskboard-card[data-column="${columnRecord.domId}"]`), cardWidth = `${(_a3 = cardElements[0]) == null ? void 0 : _a3.getBoundingClientRect().width}px`, columnWidth = `${(_b = columnElements[0]) == null ? void 0 : _b.getBoundingClientRect().width}px`;
        cardElements.forEach((card) => {
          if (collapse) {
            card.style.width = cardWidth;
          }
        });
        columnElements.unshift(headerElement);
        columnElements.forEach((element) => {
          if (collapse) {
            if (!hasFixedWidth) {
              element.style.width = columnWidth;
            }
            element.classList.add("b-collapsing");
          } else {
            element.classList.add("b-expanding");
          }
        });
        EventHelper.onTransitionEnd({
          element: headerElement,
          property: "width",
          handler() {
            cardElements.forEach((card) => {
              if (!collapse) {
                card.style.width = "";
              }
            });
            columnElements.forEach((element) => {
              if (!collapse) {
                if (!hasFixedWidth) {
                  element.style.width = "";
                }
                element.classList.remove("b-expanding");
              } else {
                element.classList.remove("b-collapsing");
              }
            });
            me.recompose.flush();
            me.scrollable.syncOverflowState();
            resolve();
          },
          thisObj: me
        });
        headerElement.offsetWidth;
        me.suspendDomTransition();
        columnRecord.collapsed = collapse;
        me.trigger(`column${collapse ? "Collapse" : "Expand"}`, { columnRecord });
        me.trigger("columnToggle", { columnRecord, collapse });
        me.resumeDomTransition();
      });
    }
    //endregion
    //region Rendering
    // Inject expander icon + expand/collapsed state cls in column headers
    populateColumnHeader(args) {
      var _a3;
      (_a3 = super.populateColumnHeader) == null ? void 0 : _a3.call(this, args);
      const { showCollapseInHeader, collapseTitle, hasSwimlanes, showCollapseTooltip } = this, { columnRecord, columnHeaderConfig } = args, { text, collapsed, collapsible } = columnRecord;
      DomHelper.merge(columnHeaderConfig, {
        class: {
          "b-collapsed": collapsed,
          "b-rotate-title": collapsed && !collapseTitle && !hasSwimlanes
        },
        style: {
          minWidth: collapsed ? null : columnRecord.minWidth
        },
        children: {
          padder: {
            children: {
              expander: showCollapseInHeader && collapsible && {
                tag: "button",
                class: {
                  "b-taskboard-column-expander": 1,
                  "b-fw-icon": 1,
                  "b-icon-expand-column": 1
                },
                dataset: {
                  btip: showCollapseTooltip ? StringHelper.xss`${this.L(collapsed ? "L{TaskBoard.expand}" : "L{TaskBoard.collapse}", text)}` : null
                }
              }
            }
          }
        }
      });
    }
    // Inject expand/collapsed state cls in columns
    populateColumn(args) {
      var _a3;
      (_a3 = super.populateColumn) == null ? void 0 : _a3.call(this, args);
      const { columnRecord, columnConfig } = args, { collapsed } = columnRecord;
      columnConfig.class["b-collapsed"] = collapsed;
      if (collapsed) {
        columnConfig.style.minWidth = null;
      }
    }
    // Inject expander icon + expand/collapsed state cls in swimlanes
    populateSwimlane(args) {
      var _a3;
      (_a3 = super.populateColumn) == null ? void 0 : _a3.call(this, args);
      const { swimlaneRecord, swimlaneConfig } = args;
      if (swimlaneRecord) {
        const { showCollapseInHeader, showCollapseTooltip } = this, { text, collapsed, collapsible } = swimlaneRecord;
        DomHelper.merge(swimlaneConfig, {
          class: {
            "b-collapsed": collapsed,
            "b-collapsible": collapsible
          },
          children: {
            header: {
              children: {
                title: {
                  children: {
                    // Before text
                    "expander > text": showCollapseInHeader && collapsible && {
                      tag: "button",
                      class: {
                        "b-taskboard-swimlane-expander": 1,
                        "b-icon": 1,
                        "b-icon-expand-row": 1
                      },
                      dataset: {
                        btip: showCollapseTooltip ? StringHelper.xss`${this.L(collapsed ? "L{TaskBoard.expand}" : "L{TaskBoard.collapse}", text)}` : null
                      }
                    }
                  }
                }
              }
            },
            body: {
              [collapsed ? "inert" : null]: true
            }
          }
        });
      }
    }
    //endregion
    //region Listeners
    onColumnHeaderClick({ event, columnRecord }) {
      if (event.target.matches(".b-taskboard-column-expander") || columnRecord.collapsed) {
        this.toggleCollapse(columnRecord);
      }
    }
    onColumnClick({ columnRecord }) {
      if (columnRecord.collapsed) {
        this.toggleCollapse(columnRecord);
      }
    }
    onSwimlaneHeaderClick({ swimlaneRecord }) {
      this.toggleCollapse(swimlaneRecord);
    }
    //endregion
  }, //region Config
  __publicField(_a2, "$name", "ExpandCollapse"), __publicField(_a2, "configurable", {
    /**
     * Show an icon to expand/collapse columns and swimlanes in their headers.
     *
     * Programmatic expand/collapse works independently of this setting, it only affects the UI.
     *
     * @config {Boolean}
     * @default
     * @category Common
     */
    showCollapseInHeader: true,
    /**
     * Specify `true` to hide the column title instead of rotating it on collapse.
     *
     * Used by default with swimlanes, since the title will overlap the swimlane header otherwise.
     *
     * @config {Boolean}
     * @default
     * @category Misc
     */
    collapseTitle: false,
    /**
     * By default, a tooltip showing `Expand XX`/`Collapse XX` is shown when hovering the expand/collapse icon for
     * a column or swimlane. To disable the tooltip, set this to `false`.
     * @prp {Boolean}
     * @default
     * @category Misc
     */
    showCollapseTooltip: true
  }), _a2;
};

// lib/TaskBoard/view/mixin/ResponsiveCards.js
var ResponsiveCards_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    constructor() {
      super(...arguments);
      //endregion
      //region Suspend/resume responsiveness
      __publicField(this, "responsivenessSuspended", 0);
    }
    get widgetClass() {
    }
    //endregion
    //region Type assertions
    changeCardSizes(cardSizes) {
      ObjectHelper.assertArray(cardSizes, "cardSizes");
      return cardSizes;
    }
    suspendResponsiveness() {
      this.responsivenessSuspended++;
    }
    resumeResponsiveness() {
      this.responsivenessSuspended--;
    }
    //endregion
    //region Calculate card size
    // Get a card size entity, very similar to a responsive level in Grid
    getCardSize(columnRecord, swimlaneRecord) {
      const me = this, { cardSizes } = me, perRow = me.getTasksPerRow(columnRecord, swimlaneRecord), columnWidth = me.getColumnWidth(columnRecord), cardWidth = (columnWidth - me.cardGap * (perRow - 1)) / perRow;
      return (cardSizes == null ? void 0 : cardSizes.find((size) => cardWidth < size.maxWidth)) || (cardSizes == null ? void 0 : cardSizes[cardSizes.length - 1]);
    }
    // Get the last reported width for a column, set by the ResizeObserver
    getColumnWidth(columnRecord) {
      return columnRecord.instanceMeta(this).width;
    }
    // Number of tasks per row to render for the requested column / swimlane intersection.
    // Prio order is columns config, swimlanes config and lastly taskboards config
    getTasksPerRow(columnRecord, swimlaneRecord) {
      return columnRecord.tasksPerRow || (swimlaneRecord == null ? void 0 : swimlaneRecord.tasksPerRow) || this.tasksPerRow;
    }
    //endregion
    //region ResizeObserver
    // ResizeObserver callback for column size changes
    onChildResize(entries) {
      const me = this;
      if (me.recompose.suspended || me.responsivenessSuspended) {
        return;
      }
      let shouldRecompose = false;
      for (const entry of entries) {
        const { target, contentRect } = entry;
        if (target.observedWidth !== contentRect.width) {
          const columnRecord = me.resolveColumnRecord(target), columnElements = columnRecord && me.columns.includes(columnRecord) && me.getColumnElements(columnRecord);
          if (!columnRecord || columnRecord.collapsed || columnRecord.hidden || !columnElements) {
            return;
          }
          columnRecord.instanceMeta(me).width = target.observedWidth = contentRect.width;
          for (const columnElement of columnElements) {
            const swimlaneRecord = me.resolveSwimlaneRecord(columnElement), cardSize = me.getCardSize(columnRecord, swimlaneRecord);
            if (cardSize && columnElement.elementData.cardSize !== cardSize.name) {
              shouldRecompose = true;
            }
          }
        }
      }
      if (shouldRecompose) {
        me.recompose.now();
        me.scrollable.syncOverflowState();
      }
    }
    // ResizeObserver used to monitor column size, observing set up in domSyncCallback
    changeResizeObserver(observer, oldObserver) {
      oldObserver == null ? void 0 : oldObserver.disconnect();
      return this.isDestroying || !ResizeObserver ? null : new ResizeObserver(this.onChildResize.bind(this));
    }
    //endregion
    //region Rendering
    populateColumn(args) {
      var _a3;
      (_a3 = super.populateColumn) == null ? void 0 : _a3.call(this, args);
      const { columnRecord, swimlaneRecord, columnConfig } = args, cardSize = args.cardSize = this.getCardSize(columnRecord, swimlaneRecord);
      if (cardSize) {
        columnConfig.class[`b-${cardSize.name}-cards`] = cardSize;
        columnConfig.elementData.cardSize = cardSize.name;
      }
    }
    //endregion
  }, //region Config
  __publicField(_a2, "$name", "ResponsiveCards"), __publicField(_a2, "configurable", {
    /**
     * An array of {@link CardSize} objects to use as responsive levels based on card widths.
     *
     * By default, the following levels are defined:
     *
     * | Width | Name   | Cls            | Avatars | Items                       |
     * |-------|--------|----------------|---------|-----------------------------|
     * | < 50  | micro  | b-micro-cards  | 1       | Only resource avatars shown |
     * | < 75  | tiny   | b-tiny-cards   | 1       | Body text hidden            |
     * | < 175 | small  | b-small-cards  | 2       | Body text hidden            |
     * | < 300 | medium | b-medium-cards | 3       |                             |
     * | > 300 | large  | b-large-cards  | 7       |                             |
     *
     * @config {CardSize}
     * @category Common
     */
    cardSizes: [
      {
        maxWidth: 50,
        name: "micro",
        maxAvatars: 1,
        headerItems: {
          text: null
        },
        bodyItems: {
          text: null
        }
      },
      {
        maxWidth: 75,
        name: "tiny",
        maxAvatars: 1,
        bodyItems: {
          text: null
        }
      },
      {
        maxWidth: 175,
        name: "small",
        maxAvatars: 2,
        bodyItems: {
          text: null
        }
      },
      { maxWidth: 250, name: "medium", maxAvatars: 3 },
      { name: "large", maxAvatars: 7 }
    ],
    resizeObserver: {
      value: true,
      $config: ["nullify"]
    }
  }), _a2;
};

// lib/TaskBoard/view/mixin/TaskBoardColumns.js
var transitionChangeActions = {
  remove: 1,
  move: 1,
  update: 1,
  filter: 1
};
var TaskBoardColumns_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    //endregion
    //region Type assertions
    changeAutoGenerateColumns(autoGenerateColumns) {
      ObjectHelper.assertBoolean(autoGenerateColumns, "autoGenerateColumns");
      return autoGenerateColumns;
    }
    changeColumnField(columnField) {
      ObjectHelper.assertString(columnField, "columnField");
      return columnField;
    }
    //endregion
    //region Config - columnField
    updateColumnField(field, old) {
      if (old) {
        const { storage } = this.project.taskStore;
        if (old !== this.swimlaneField) {
          storage.removeIndex(old);
        }
        storage.addIndex({ property: field, unique: false });
      }
      this.shouldAutoGenerateColumns = field && this.autoGenerateColumns;
    }
    //endregion
    //region Config - columns
    changeColumns(columns) {
      return Store.from(columns, { objectify: true, modelClass: ColumnModel }, (column) => {
        if (typeof column === "string") {
          return { id: column, text: StringHelper.capitalize(column) };
        }
        return column;
      });
    }
    updateColumns(columns) {
      this.detachListeners("columns");
      if (columns) {
        (columns.$store || columns).taskBoard = this;
        columns.ion({
          change: "onColumnsChange",
          refresh: "onColumnsChange",
          thisObj: this
        });
      }
    }
    get columns() {
      const me = this, { taskStore } = me.project;
      if (me.shouldAutoGenerateColumns && taskStore.count) {
        me.columns = taskStore.getDistinctValues(me.columnField).sort();
        me.shouldAutoGenerateColumns = false;
      }
      return me._columns;
    }
    onColumnsChange({ action }) {
      if (action === "add" || action === "remove" || action === "removeAll" || action === "update") {
        this.project.taskStore.storage.invalidateIndices();
      }
      if (transitionChangeActions[action]) {
        const options = {};
        if (action === "update" || action === "remove") {
          options.addTransition = { width: 1, opacity: 1 };
          options.removeTransition = { width: 1, opacity: 1 };
        }
        this.recomposeWithDomTransition(options);
      } else {
        this.recompose();
      }
    }
    //endregion
    //region Data
    getColumnTasks(columnRecord, inVisualOrder = false) {
      const me = this, { taskStore } = me.project, set = taskStore.storage.findItem(me.columnField, columnRecord.id), tasks = set ? [...set] : [];
      if (inVisualOrder && set) {
        if (me.swimlanes) {
          const { swimlaneField } = me, swimlanes = me.swimlanes.map((r) => r.id);
          tasks.sort((a, b) => {
            const swimlaneDelta = swimlanes.indexOf(a[swimlaneField]) - swimlanes.indexOf(b[swimlaneField]);
            if (swimlaneDelta !== 0) {
              return swimlaneDelta;
            }
            if (a.weight != null || b.weight != null) {
              return a.weight - b.weight;
            }
            return taskStore.indexOf(a) - taskStore.indexOf(b);
          });
          if (swimlanes.length && swimlaneField) {
            return tasks.filter((task) => swimlanes.includes(task[swimlaneField]));
          }
        } else {
          tasks.sort((a, b) => a.weight - b.weight);
        }
      }
      return tasks;
    }
    getColumn(taskRecord) {
      return this.columns.getById(taskRecord.getValue(this.columnField));
    }
    // Next task in the same column as supplied task
    getNextTask(taskRecord, wrap = true) {
      const columnRecord = this.getColumn(taskRecord), columnTasks = columnRecord.tasks;
      let nextTaskIndex = columnTasks.indexOf(taskRecord) + 1;
      if (nextTaskIndex === columnTasks.length) {
        if (wrap) {
          nextTaskIndex = 0;
        } else {
          return null;
        }
      }
      return columnTasks[nextTaskIndex];
    }
    // Prev task in the same column as supplied task
    getPreviousTask(taskRecord, wrap = true) {
      const columnRecord = this.getColumn(taskRecord), columnTasks = columnRecord.tasks;
      let prevTaskIndex = columnTasks.indexOf(taskRecord) - 1;
      if (prevTaskIndex < 0) {
        if (wrap) {
          prevTaskIndex = columnTasks.length - 1;
        } else {
          return null;
        }
      }
      return columnTasks[prevTaskIndex];
    }
    //endregion
  }, //region Config
  __publicField(_a2, "$name", "TaskBoardColumns"), __publicField(_a2, "configurable", {
    /**
     * Store containing the TaskBoard columns.
     *
     * @member {Core.data.Store} columns
     * @category Common
     */
    /**
     * Store containing the TaskBoard columns. A tasks {@link #config-columnField} is matched against the `id` of a
     * column to determine in which column it is displayed.
     *
     * Accepts an array of column records/objects/strings, a store instance, a store id or a store config object
     * used to create a new store.
     *
     * When supplying an array, a store configured with {Core.data.mixin.StoreProxy#config-objectify} is
     * automatically created. Using that config allows for a nicer interaction syntax with the columns:
     *
     * ```javascript
     * // Without objectify:
     * taskBoard.columns.getById('done').text = 'Finished';
     *
     * // With objectify:
     * taskBoard.columns.done.text = 'Finished';
     * ```
     *
     * When supplying strings, the raw string will be used as the columns `id` and a capitalized version of it is
     * used as the columns text:
     *
     * ```javascript
     * taskBoard = new TaskBoard({
     *    columns : [
     *        'doing',
     *        'done'
     *    ]
     * });
     * ```
     *
     * Is equivalent to:
     *
     * ```javascript
     * taskBoard = new TaskBoard({
     *    columns : [
     *        { id : 'doing', text : 'Doing' },
     *        { id : 'done', text : 'Done' }
     *    ]
     * });
     * ```
     *
     * @config {TaskBoard.model.ColumnModel[]|ColumnModelConfig[]|String[]|Core.data.Store|String|StoreConfig}
     * @category Common
     */
    columns: {},
    /**
     * Set to `true` to auto generate columns when {@link #config-columns} is undefined.
     *
     * A column will be created for each distinct value of {@link #config-columnField} on the tasks. The columns
     * will be sorted in alphabetical order. The following snippet will yield two columns, Q1 and Q2:
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *    columnField : 'quarter',
     *
     *    autoGenerateColumns : true,
     *
     *    project : {
     *        tasksData : [
     *            { id : 1, name : 'Inform tenants', quarter : 'Q1' },
     *            { id : 2, name : 'Renovate roofs', quarter : 'Q2' }
     *        ]
     *    }
     * });
     * ```
     *
     * @config {Boolean}
     * @category Advanced
     */
    autoGenerateColumns: false,
    /**
     * Field on a task record used to determine which column the task belongs to.
     *
     * ```javascript
     * taskBoard.columnField = 'category';
     * ```
     *
     * @member {String} columnField
     * @category Common
     */
    /**
     * Field on a task record used to determine which column the task belongs to.
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *    columnField : 'status',
     *
     *    columns : [
     *        'todo',
     *        'done'
     *    ],
     *
     *    project : {
     *        tasksData : [
     *            // Linked using the status field, to the done column
     *            { id : 1, name : 'Fun task', status : 'done' }
     *        ]
     *    }
     * });
     * ```
     *
     * @config {String}
     * @category Common
     */
    columnField: null
  }), __publicField(_a2, "properties", {
    shouldAutoGenerateColumns: false
  }), _a2;
};

// lib/TaskBoard/view/mixin/TaskBoardDom.js
var TaskBoardDom_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    //endregion
    //region Resolve record from element
    /**
     * Retrieves a task record corresponding to the supplied element. Has to be a `.b-taskboard-card` element or
     * descendant thereof.
     *
     * ```javascript
     * const taskRecord = taskBoard.resolveTaskRecord(taskElement);
     * ```
     *
     * @param {HTMLElement} element
     * @returns {TaskBoard.model.TaskModel}
     * @category DOM
     */
    resolveTaskRecord(element) {
      var _a3;
      element = element.closest(".b-taskboard-card");
      return element && this.project.taskStore.getById((_a3 = element.elementData) == null ? void 0 : _a3.taskId);
    }
    /**
     * Retrieves a column record resolved from the supplied element. Has to be a `.b-taskboard-column` element or
     * descendant thereof (such as a card).
     *
     * ```javascript
     * const columnRecord = taskBoard.resolveColumnRecord(taskElement);
     * ```
     *
     * @param {HTMLElement} element
     * @returns {TaskBoard.model.ColumnModel}
     * @category DOM
     */
    resolveColumnRecord(element) {
      var _a3;
      element = element.closest(".b-taskboard-column, .b-taskboard-column-header");
      return element && this.columns.getById((_a3 = element.elementData) == null ? void 0 : _a3.columnId);
    }
    /**
     * Retrieves a swimlane record resolved from the supplied element. Has to be a `.b-taskboard-swimlane` element or
     * descendant thereof.
     *
     * ```javascript
     * const swimlaneRecord = taskBoard.resolveSwimlaneRecord(taskElement);
     * ```
     *
     * @param {HTMLElement} element
     * @returns {TaskBoard.model.SwimlaneModel}
     * @category DOM
     */
    resolveSwimlaneRecord(element) {
      var _a3;
      element = element.closest(".b-taskboard-swimlane");
      return element && ((_a3 = this.swimlanes) == null ? void 0 : _a3.getById(element.elementData.laneId));
    }
    //endregion
    //region Get element from record
    /**
     * Retrieves the task element (card) corresponding to the supplied task record.
     *
     * ```javascript
     * const cardElement = taskBoard.getTaskElement(taskRecord);
     * ```
     *
     * @param {TaskBoard.model.TaskModel} taskRecord
     * @returns {HTMLElement}
     * @category DOM
     */
    getTaskElement(taskRecord) {
      const taskColumnElement = this.getTaskColumnElement(taskRecord);
      return taskColumnElement && DomSync.getChild(taskColumnElement, `body.inner.${taskRecord.domId}`);
    }
    /**
     * Retrieves the element for the column that holds the supplied task record.
     *
     * ```javascript
     * const columnElement = taskBoard.getColumnElement(taskRecord);
     * ```
     *
     * @param {TaskBoard.model.TaskModel} taskRecord
     * @returns {HTMLElement}
     * @category DOM
     */
    getTaskColumnElement(taskRecord) {
      const columnRecord = this.columns.getById(taskRecord.getValue(this.columnField));
      return columnRecord && DomSync.getChild(this.getTaskSwimlaneElement(taskRecord), `body.${columnRecord.domId}`);
    }
    /**
     * Retrieves the element for the swimlane that holds the supplied task record.
     *
     * ```javascript
     * const swimlaneElement = taskBoard.getTaskSwimlaneElement(taskRecord);
     * ```
     *
     * @param {TaskBoard.model.TaskModel} taskRecord
     * @returns {HTMLElement}
     * @category DOM
     */
    getTaskSwimlaneElement(taskRecord) {
      var _a3, _b;
      const laneId = ((_a3 = this.swimlanes) == null ? void 0 : _a3.count) ? (_b = this.swimlanes.getById(taskRecord.getValue(this.swimlaneField))) == null ? void 0 : _b.domId : "default";
      return DomSync.getChild(this.bodyElement, laneId);
    }
    /**
     * Retrieves the element for the supplied swimlane.
     *
     * ```javascript
     * const swimlaneElement = taskBoard.getSwimlaneElement(taskBoard.swimlanes.first);
     * ```
     *
     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord
     * @returns {HTMLElement}
     * @category DOM
     */
    getSwimlaneElement(swimlaneRecord) {
      return DomSync.getChild(this.bodyElement, swimlaneRecord.domId);
    }
    /**
     * Retrieves the element for the supplied swimlane / column intersection.
     *
     * ```javascript
     * const element = taskBoard.getSwimlaneColumnElement(taskBoard.swimlanes.first, taskBoard.columns.last);
     * ```
     *
     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord
     * @param {TaskBoard.model.ColumnModel} columnRecord
     * @returns {HTMLElement}
     * @category DOM
     */
    getSwimlaneColumnElement(swimlaneRecord, columnRecord) {
      if (swimlaneRecord) {
        return DomSync.getChild(this.getSwimlaneElement(swimlaneRecord), `body.${columnRecord.domId}`);
      } else {
        return this.getColumnElement(columnRecord);
      }
    }
    /**
     * Retrieves the element for the supplied column.
     *
     * Only applicable when not using swimlanes. If you are using swimlanes, see {@link #function-getColumnElements}.
     *
     * @param {TaskBoard.model.ColumnModel} columnRecord
     * @returns {HTMLElement}
     * @category DOM
     */
    getColumnElement(columnRecord) {
      var _a3;
      return (_a3 = this.getColumnElements(columnRecord)) == null ? void 0 : _a3[0];
    }
    /**
     * Retrieves the elements for the supplied column. When using swimlanes, a column has one element per swimlane.
     *
     * @param {TaskBoard.model.ColumnModel} columnRecord
     * @returns {HTMLElement}
     * @category DOM
     */
    getColumnElements(columnRecord) {
      var _a3;
      if ((_a3 = this.swimlanes) == null ? void 0 : _a3.count) {
        return this.swimlanes.reduce((result, lane) => {
          if (!lane.hidden) {
            result.push(this.getSwimlaneColumnElement(lane, columnRecord));
          }
          return result;
        }, []);
      }
      return [this.getSwimlaneColumnElement({ domId: "default" }, columnRecord)];
    }
    /**
     * Retrieves the header element for the supplied column.
     *
     * @param {TaskBoard.model.ColumnModel} columnRecord
     * @returns {HTMLElement}
     * @category DOM
     */
    getColumnHeaderElement(columnRecord) {
      return DomSync.getChild(this.bodyElement, `header.${columnRecord.domId}`);
    }
    //endregion
    //region Position based
    /**
     * Get the card element at (x, y)
     * @param {Number} x
     * @param {Number} y
     * @param {String} cardSelector
     * @returns {HTMLElement}
     * @internal
     */
    getCardAt(x, y, cardSelector2 = ".b-taskboard-card") {
      var _a3;
      return (_a3 = this.documentRoot.elementFromPoint(x, y)) == null ? void 0 : _a3.closest(cardSelector2);
    }
    //endregion
    //region Cached measurements
    cacheCSSVar(name, defaultValue2) {
      const me = this;
      let size = me[`_${name}`];
      if (size == null) {
        const value = me.css[name];
        size = DomHelper.measureSize(value || defaultValue2, me.element);
        if (value) {
          me[`_${name}`] = size;
        }
      }
      return size;
    }
    // Cached card gap
    get cardGap() {
      return this.cacheCSSVar("cardGap", "1em");
    }
    //endregion
  }, //region Config
  __publicField(_a2, "$name", "TaskBoardDom"), _a2;
};

// lib/TaskBoard/view/mixin/TaskBoardDomEvents.js
var TaskBoardDomEvents_default = (Target) => {
  var _a2, _hoveredCardElement;
  return _a2 = class extends (Target || Base) {
    constructor() {
      super(...arguments);
      __privateAdd(this, _hoveredCardElement, null);
    }
    get widgetClass() {
    }
    //endregion
    //region Events
    /**
     * Triggered when a card is clicked.
     *
     * ```javascript
     * taskBoard.on('taskClick', ({ taskRecord }) => {
     *    Toast.show(`Clicked on ${taskRecord.name}`);
     * });
     * ```
     *
     * @event taskClick
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.TaskModel} taskRecord Task record
     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column
     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)
     * @param {MouseEvent} event Browser event
     */
    /**
     * Triggered when a card is double clicked
     *
     * ```javascript
     * taskBoard.on('taskDblClick', ({ taskRecord }) => {
     *    Toast.show(`Double clicked on ${taskRecord.name}`);
     * });
     * ```
     *
     * @event taskDblClick
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.TaskModel} taskRecord Task record
     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column
     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)
     * @param {MouseEvent} event Browser event
     */
    /**
     * Triggered when the mouse enters a card
     *
     * ```javascript
     * taskBoard.on('taskMouseEnter', ({ taskRecord }) => {
     *    Toast.show(`Mouse entered ${taskRecord.name}`);
     * });
     * ```
     *
     * @event taskMouseEnter
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.TaskModel} taskRecord Task record
     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column
     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)
     * @param {MouseEvent} event Browser event
     */
    /**
     * Triggered when the mouse leaves a card
     *
     * ```javascript
     * taskBoard.on('taskMouseLeave', ({ taskRecord }) => {
     *    Toast.show(`Mouse left ${taskRecord.name}`);
     * });
     * ```
     *
     * @event taskMouseLeave
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.TaskModel} taskRecord Task record
     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column
     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)
     * @param {MouseEvent} event Browser event
     */
    /**
     * Triggered when a task is "activated" by pressing `Enter` or double clicking it.
     *
     * By default this leads to the task editor being shown.
     *
     * ```javascript
     * taskBoard.on('activateTask', ({ taskRecord }) => {
     *    Toast.show(`Activated ${taskRecord.name}`);
     * });
     * ```
     *
     * @event activateTask
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.TaskModel} taskRecord Task record
     * @param {MouseEvent} event Browser event
     */
    /**
     * Triggered when a task is rendered.
     *
     * This happens on initial render, when a task is added or when the task element is updated.
     *
     * Listening to this event allows you to manipulate the tasks element directly after it has been updated. Please
     * note that we strongly recommend using a `taskRenderer` to manipulate the DomConfig used to update the task for
     * most scenarios.
     *
     * If you listen for this event and manipulate the element in some way, you should also listen for
     * `removeTaskElement` and revert/clean up the changes there.
     *
     * @event renderTask
     * @param {TaskBoard.view.TaskBoard} source TaskBoard instance
     * @param {TaskBoard.model.TaskModel} taskRecord Task being rendered
     * @param {Boolean} isRefresh `true` if the element was updated, `false` if it was added
     * @param {HTMLElement} element Tasks element
     */
    /**
     * Triggered when all tasks in the task board are rendered
     * @event renderTasks
     * @param {TaskBoard.view.TaskBoard} source TaskBoard instance
     * @param {TaskBoard.model.TaskModel[]} taskRecords Tasks being rendered
     */
    /**
     * Triggered when a tasks element is removed.
     *
     * This happens when a task is removed or when it is move to another swimlane / column (in which case a `renderTask`
     * event is triggered for the new element).
     *
     * If you used listener for `renderTask` to alter the element of tasks, you should also listen for this event to
     * clean that modification up.
     *
     * @event removeTaskElement
     * @param {TaskBoard.view.TaskBoard} source TaskBoard instance
     * @param {String|Number} taskId Id of the task (not the record itself since it might be removed)
     * @param {HTMLElement} element Tasks element
     */
    /**
     * Triggered when a swimlane header is clicked.
     *
     * ```javascript
     * taskBoard.on('swimlaneHeaderClick', ({ swimlaneRecord }) => {
     *    Toast.show(`Clicked on ${swimlaneRecord.text}`);
     * });
     * ```
     *
     * @event swimlaneHeaderClick
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record
     * @param {MouseEvent} event Browser event
     */
    /**
     * Triggered when a swimlane header is double-clicked.
     *
     * ```javascript
     * taskBoard.on('swimlaneHeaderDblClick', ({ swimlaneRecord }) => {
     *    Toast.show(`Double-clicked on ${swimlaneRecord.text}`);
     * });
     * ```
     *
     * @event swimlaneHeaderDblClick
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record
     * @param {MouseEvent} event Browser event
     */
    /**
     * Triggered when a swimlane header is right-clicked.
     *
     * ```javascript
     * taskBoard.on('swimlaneHeaderContextMenu', ({ swimlaneRecord }) => {
     *    Toast.show(`Right-clicked on ${swimlaneRecord.text}`);
     * });
     * ```
     *
     * @event swimlaneHeaderContextMenu
     * @param {TaskBoard.view.TaskBoard} source This TaskBoard
     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record
     * @param {MouseEvent} event Browser event
     */
    //endregion
    //region Triggering
    // Sets the domListeners up, all relayed to triggerDomEvent()
    changeDomListeners(domListeners) {
      if (domListeners) {
        for (const eventName in this.domEvents) {
          domListeners[eventName] = "triggerDomEvent";
        }
      }
      return domListeners;
    }
    // Resolve records from the passed event
    resolveEvent(event) {
      const { target } = event, taskRecord = this.resolveTaskRecord(target), columnRecord = this.resolveColumnRecord(target), swimlaneRecord = this.resolveSwimlaneRecord(target);
      return { taskRecord, columnRecord, swimlaneRecord, event };
    }
    // "Re-trigger" a dom event as one of ours, populated with records and prefixed with either 'task'  or 'column'
    // depending on event target
    triggerDomEvent(event) {
      const me = this, args = me.resolveEvent(event), name = me.domEvents[event.type], { target } = event;
      if (me.isScrolling || target.closest(".b-widget") !== me._element) {
        return;
      }
      event.taskBoardData = args;
      let result;
      if (args.taskRecord) {
        const eventName = `task${StringHelper.capitalize(name)}`;
        result = me.trigger(eventName, args);
        if (eventName === me.activateTaskEvent && !event.defaultPrevented) {
          me.trigger("activateTask", { taskRecord: args.taskRecord, event });
        }
      } else if (args.columnRecord) {
        if (target.closest(".b-taskboard-column-header")) {
          result = me.trigger(`columnHeader${StringHelper.capitalize(name)}`, args);
        } else {
          result = me.trigger(`column${StringHelper.capitalize(name)}`, args);
        }
      } else if (args.swimlaneRecord) {
        if (target.closest(".b-taskboard-swimlane-header")) {
          result = me.trigger(`swimlaneHeader${StringHelper.capitalize(name)}`, args);
        } else {
          result = me.trigger(`swimlane${StringHelper.capitalize(name)}`, args);
        }
      }
      if (result === false) {
        return;
      }
      me.trigger(name, args);
      if ((name === "mouseOver" || name === "mouseOut") && args.taskRecord) {
        const cardElement = target.closest(".b-taskboard-card");
        if (name === "mouseOver" && cardElement !== __privateGet(me, _hoveredCardElement)) {
          __privateSet(me, _hoveredCardElement, cardElement);
          me.trigger("taskMouseEnter", args);
        }
        if (name === "mouseOut" && !cardElement.contains(event.relatedTarget)) {
          __privateSet(me, _hoveredCardElement, null);
          me.trigger("taskMouseLeave", args);
        }
      }
    }
    // Called as DomSync syncs elements
    domSyncCallback({ action, domConfig, lastDomConfig, targetElement: element, syncId, jsx }) {
      var _a3, _b, _c, _d, _e, _f;
      const me = this, { elementType } = (_a3 = domConfig == null ? void 0 : domConfig.elementData) != null ? _a3 : {}, isRefresh = action === "reuseOwnElement", { reactComponent } = this;
      if (jsx && this.processTaskItemContent) {
        this.processTaskItemContent({
          jsx,
          targetElement: element,
          reactComponent,
          domConfig
        });
        return;
      }
      if (domConfig) {
        if (elementType === "task") {
          const { taskId } = domConfig.elementData, taskRecord = me.project.taskStore.getById(taskId);
          if (action === "newElement") {
            (_b = me.cardIntersectionObserver) == null ? void 0 : _b.observe(element);
          }
          if (action === "newElement" || action === "reuseOwnElement") {
            (!me.isVirtualized || taskRecord.instanceMeta(me).intersects) && me.trigger("renderTask", { taskRecord, element, isRefresh });
          } else if (action === "removeElement") {
            (_c = me.cardIntersectionObserver) == null ? void 0 : _c.unobserve(element);
            me.trigger("removeTaskElement", { taskId, element });
          }
        } else if (elementType === "column") {
          const { columnId, laneId } = domConfig.elementData, columnRecord = me.columns.getById(columnId), swimlaneRecord = laneId != null && ((_d = me.swimlanes) == null ? void 0 : _d.getById(laneId));
          if (action === "newElement" || action === "reuseOwnElement") {
            me.trigger("renderColumn", { columnRecord, swimlaneRecord, element, isRefresh });
          } else if (action === "removeElement") {
            me.trigger("removeColumnElement", { columnId, swimlaneRecord, element });
          }
        } else if (elementType === "swimlane") {
          const { laneId } = domConfig.elementData, swimlaneRecord = laneId != null && laneId !== "default" && ((_e = me.swimlanes) == null ? void 0 : _e.getById(laneId));
          if (laneId !== "default") {
            if (action === "newElement" || action === "reuseOwnElement") {
              me.trigger("renderSwimlane", { swimlaneRecord, element, isRefresh });
            } else if (action === "removeElement") {
              me.trigger("removeSwimlaneElement", { swimlaneId: laneId, element });
            }
          }
        } else if (((_f = domConfig.class) == null ? void 0 : _f["b-taskboard-column-header-padder"]) && me.resizeObserver) {
          if (action === "newElement") {
            if (!element.isResizeObserved) {
              me.resizeObserver.observe(element);
              element.isResizeObserved = true;
            }
          }
          if (action === "removeElement") {
            if (element.isResizeObserved) {
              me.resizeObserver.unobserve(element);
              delete element.isResizeObserved;
            }
          }
        }
      }
    }
    //endregion
    //region Chainable handlers
    onClick() {
    }
    onMouseMove() {
    }
    onMouseUp() {
    }
    onTaskMouseDown() {
    }
    onTaskClick() {
    }
    onTaskDblClick() {
    }
    onTaskContextMenu() {
    }
    onColumnMouseDown() {
    }
    onColumnHeaderClick(...args) {
      super.onColumnHeaderClick(...args);
    }
    onSwimlaneHeaderClick(...args) {
      super.onSwimlaneHeaderClick(...args);
    }
    onActivateTask() {
    }
    //endregion
  }, _hoveredCardElement = new WeakMap(), //region Config
  __publicField(_a2, "$name", "TaskBoardDomEvents"), __publicField(_a2, "configurable", {
    /**
     * The name of the event that should activate a task and trigger editing (if an editing feature is active).
     * Available options are: 'taskClick', 'taskDblClick' or null (disable)
     * @default
     * @config {'taskClick'|'taskDblClick'|null}
     * @category Advanced
     */
    activateTaskEvent: "taskDblClick",
    domEvents: {
      click: "click",
      dblclick: "dblClick",
      mouseup: "mouseUp",
      mousedown: "mouseDown",
      mousemove: "mouseMove",
      mouseover: "mouseOver",
      mouseout: "mouseOut",
      keydown: "keyDown",
      contextmenu: "contextMenu"
    },
    domListeners: {}
  }), _a2;
};

// lib/TaskBoard/view/mixin/TaskBoardScroll.js
var TaskBoardScroll_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    //endregion
    //region Scroll tracking
    onInternalPaint({ firstPaint }) {
      if (firstPaint) {
        const me = this;
        EventHelper.on({
          element: me.element,
          scroll() {
            me.isScrolling = true;
            me.onScrollEnd();
          },
          capture: true,
          thisObj: me
        });
      }
    }
    onScrollEnd() {
      this.isScrolling = false;
      if (this.recomposeOnScrollEnd) {
        this.recompose();
        this.recomposeOnScrollEnd = false;
      }
    }
    //endregion
    //region Type assertions
    changeScrollOptions(scrollOptions) {
      ObjectHelper.assertObject(scrollOptions, "scrollOptions");
      return scrollOptions;
    }
    //endregion
    //region Scroll to
    /**
     * Scroll specified swimlane into view.
     *
     * ```javascript
     * taskBoard.scrollToSwimlane('high');
     * taskBoard.scrollToSwimlane(taskBoard.swimlanes.last);
     * ```
     *
     * @param {TaskBoard.model.SwimlaneModel|Number|String} swimlaneOrId Swimlane or its id
     * @param {BryntumScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}
     * @category Scrolling
     */
    async scrollToSwimlane(swimlaneOrId, options = this.scrollOptions) {
      const swimlane = this.swimlanes.getById(swimlaneOrId), swimlaneElement = swimlane && this.getSwimlaneElement(swimlane);
      if (swimlaneElement) {
        options = ObjectHelper.assign({
          x: false,
          animate: (options == null ? void 0 : options.animate) || (options == null ? void 0 : options.behavior) === "smooth"
        }, options);
        return Scroller.scrollIntoView(swimlaneElement, options, this.rtl);
      }
    }
    /**
     * Scroll specified column into view.
     *
     * ```javascript
     * taskBoard.scrollToColumn('backlog');
     * taskBoard.scrollToColumn(taskBoard.columns.first);
     * ```
     *
     * @param {TaskBoard.model.ColumnModel|Number|String} columnOrId Column or its id
     * @param {BryntumScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}
     * @category Scrolling
     */
    async scrollToColumn(columnOrId, options = this.scrollOptions) {
      const column = this.columns.getById(columnOrId), columnElement = column && this.getColumnHeaderElement(column);
      if (columnElement) {
        options = ObjectHelper.assign({
          animate: (options == null ? void 0 : options.animate) || (options == null ? void 0 : options.behavior) === "smooth",
          y: false
        }, options);
        return Scroller.scrollIntoView(columnElement, options, this.rtl);
      }
    }
    /**
     * Scroll to the intersection between specified swimlane and column.
     *
     * ```javascript
     * taskBoard.scrollToIntersection('high', 'done');
     * taskBoard.scrollToIntersection(taskBoard.swimlanes.low, taskBoard.columns.todo);
     * ```
     *
     * @param {TaskBoard.model.SwimlaneModel|Number|String} swimlaneOrId Swimlane or its id
     * @param {TaskBoard.model.ColumnModel|Number|String} columnOrId Column or its id
     * @param {BryntumScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}
     * @category Scrolling
     */
    async scrollToIntersection(swimlaneOrId, columnOrId, options = this.scrollOptions) {
      const swimlane = this.swimlanes.getById(swimlaneOrId), column = this.columns.getById(columnOrId), target = swimlane && column && this.getSwimlaneColumnElement(swimlane, column);
      if (target) {
        options = ObjectHelper.assign({
          animate: (options == null ? void 0 : options.animate) || (options == null ? void 0 : options.behavior) === "smooth",
          edgeOffset: 10
        }, options);
        return Scroller.scrollIntoView(target, options, this.rtl);
      }
    }
    /**
     * Scroll the specified task into view.
     *
     * ```javascript
     * taskBoard.scrollToTask(10);
     * taskBoard.scrollToTask(taskStore.first);
     * ```
     *
     * @param {TaskBoard.model.TaskModel|Number|String} taskOrId
     * @param {BryntumScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}
     * @category Scrolling
     */
    async scrollToTask(taskOrId, options = this.scrollOptions) {
      const me = this, taskRecord = me.project.taskStore.getById(taskOrId), taskElement = taskRecord && me.getTaskElement(taskRecord);
      if (taskElement) {
        const edgeOffset = { start: 10, end: 10, top: 10, bottom: 10 };
        if (me.stickyHeaders) {
          if (me.hasSwimlanes) {
            edgeOffset.top += me.getTaskSwimlaneElement(taskRecord).syncIdMap.header.offsetHeight;
          }
          edgeOffset.top += me.bodyElement.syncIdMap.header.offsetHeight;
        }
        if (me.isVirtualized && !me.getTaskHeight) {
          taskElement.scrollIntoView();
          await new Promise((resolve, reject) => {
            const detach = me.ion({
              renderTask({ taskRecord: renderedTaskRecord }) {
                if (renderedTaskRecord === taskRecord) {
                  detach();
                  resolve();
                }
              },
              expires: {
                delay: 200,
                alt: reject
              }
            });
          });
        }
        options = ObjectHelper.assign({
          animate: (options == null ? void 0 : options.animate) || (options == null ? void 0 : options.behavior) === "smooth",
          edgeOffset
        }, options);
        return Scroller.scrollIntoView(taskElement, options, me.rtl);
      }
    }
    //endregion
  }, //region Config
  __publicField(_a2, "$name", "TaskBoardScroll"), __publicField(_a2, "configurable", {
    /**
     * Default scroll options, see the options for {@link Core.helper.util.Scroller#function-scrollIntoView}
     *
     * Defaults to:
     *
     * ```javascript
     * scrollOptions : {
     *     animate   : true,
     *     block     : 'nearest',
     *     highlight : true
     * }
     * ```
     *
     * Can be overridden per call for all scroll functions.
     *
     * @config {BryntumScrollOptions}
     * @category Advanced
     */
    scrollOptions: {
      animate: true,
      block: "nearest",
      highlight: true
    },
    testConfig: {
      scrollOptions: {
        animate: false,
        block: "nearest"
      }
    }
  }), __publicField(_a2, "delayable", {
    onScrollEnd: VersionHelper.isTestEnv ? 300 : 100
  }), _a2;
};

// lib/TaskBoard/view/mixin/TaskBoardStores.js
var TaskBoardStores_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    //endregion
    //#region Inline data
    get assignments() {
      return this.project.assignmentStore.records;
    }
    updateAssignments(records) {
      this.project.assignmentStore.data = records;
    }
    get resources() {
      return this.project.resourceStore.records;
    }
    updateResources(records) {
      this.project.resourceStore.data = records;
    }
    get tasks() {
      return this.project.taskStore.records;
    }
    updateTasks(records) {
      this.project.taskStore.data = records;
    }
    //#endregion
    //region Type assertions
    changeNewTaskDefaults(newTaskDefaults) {
      ObjectHelper.assertObject(newTaskDefaults, "newTaskDefaults");
      return newTaskDefaults;
    }
    //endregion
    //region Project
    changeProject(project) {
      if (project && !project.isModel) {
        project = this.projectModelClass.new(project);
      }
      this.attachToProject(project);
      return project;
    }
    attachToProject(project) {
      const me = this;
      me.bindCrudManager(project);
      if (project) {
        const { taskStore } = project;
        if (taskStore) {
          const { storage } = taskStore;
          storage.addIndex({ property: me.columnField, unique: false });
          if (me.swimlaneField) {
            storage.addIndex({ property: me.swimlaneField, unique: false });
          }
          Reflect.defineProperty(taskStore.$master.modelClass.prototype, "columnSwimlaneIntersection", {
            get() {
              return this.buildIndexKey({
                [me.columnField]: this[me.columnField],
                [me.swimlaneField]: this[me.swimlaneField]
              });
            }
          });
          taskStore.$master.modelClass.prototype.buildIndexKey = function(data) {
            var _a3;
            return `${data[me.columnField]}-/-${((_a3 = me.swimlanes) == null ? void 0 : _a3.count) && data[me.swimlaneField] || "default"}`;
          };
          storage.addIndex({ property: "columnSwimlaneIntersection", unique: false, dependentOn: { [me.swimlaneField]: true, [me.columnField]: true } });
        }
        me.attachToProjectStore(project.taskStore, {
          change: "onTaskStoreChange",
          changePreCommit: "onTaskStoreEarlyChange",
          refresh: "onTaskStoreRefresh"
        });
        me.attachToProjectStore(project.assignmentStore);
        me.attachToProjectStore(project.resourceStore);
      }
    }
    // Most store changes leads to a recompose, with exception of some TaskStore changes that are transitioned
    attachToProjectStore(store, listenersConfig = {}) {
      this.detachListeners(store.$name);
      store == null ? void 0 : store.ion({
        name: store.$name,
        change: "recompose",
        refresh: "recompose",
        thisObj: this,
        ...listenersConfig
      });
    }
    //endregion
    //region Listeners
    onTaskStoreEarlyChange({ action }) {
      if (action === "add") {
        this.recomposeWithDomTransition({
          addTransition: {
            height: 1,
            opacity: 1
          }
        });
      }
    }
    onTaskStoreChange({ action, changes }) {
      const { columnField, swimlaneField } = this;
      if (action === "remove" || action === "filter" || action === "update" && (changes[columnField] || swimlaneField && changes[swimlaneField])) {
        this.recomposeWithDomTransition({
          removeTransition: {
            height: 1,
            opacity: 1
          }
        });
      } else {
        this.recompose();
      }
    }
    onTaskStoreRefresh({ action }) {
      if (action === "sort") {
        !this.taskSorterFn && this.recomposeWithDomTransition();
      } else {
        this.recompose();
      }
    }
    //endregion
    //region Utility
    /**
     * Add a new task to the specified column / swimlane intersection (swimlane is optional), scroll it into view and
     * start editing it (if an editing feature is enabled).
     *
     * By default the task is created using the data defined in the {@link #config-newTaskDefaults} combined with values
     * for the `columnField`, the `swimlaneField` and a generated `weight` to place it last. To override these or to
     * supply your own values for any field, pass the `taskData` argument.
     *
     * If project is configured to auto sync changes to backend, the sync request will be awaited before editing starts.
     *
     * @param {TaskBoard.model.ColumnModel} columnRecord Column to add the task to
     * @param {TaskBoard.model.ColumnModel} [swimlaneRecord] Swimlane to add the task to
     * @param {Object} [taskData] Data for the new task
     * @category Common
     */
    async addTask(columnRecord, swimlaneRecord = null, taskData = {}) {
      var _a3;
      const me = this, {
        swimlaneField,
        swimlanes,
        project
      } = me, columnBody = me.getColumnElement(columnRecord).syncIdMap.body, lastCard = columnBody.lastElementChild, data = {
        [me.columnField]: columnRecord.id,
        name: me.L("L{TaskBoard.newTaskName}"),
        weight: ((_a3 = project.taskStore.max("weight")) != null ? _a3 : 0) + 100,
        ...me.newTaskDefaults,
        ...taskData
      };
      let suspended = false;
      if (swimlaneField) {
        if (swimlaneRecord) {
          data[swimlaneField] = swimlaneRecord.id;
        } else if (swimlanes == null ? void 0 : swimlanes.count) {
          data[swimlaneField] = swimlanes.first.id;
        }
      }
      if (lastCard && lastCard.offsetTop + lastCard.offsetHeight > columnBody.clientHeight - 100) {
        me.suspendDomTransition();
        suspended = true;
      }
      const synced = project.autoSync && project.await("sync", false), [taskRecord] = project.taskStore.add(data);
      me.recompose.now();
      if (me.useDomTransition && !me.domTransitionSuspended) {
        await me.await("transitionedRecompose", false);
      }
      if (me.isDestroyed) {
        return;
      }
      await me.scrollToTask(taskRecord, ObjectHelper.assign({}, me.scrollOptions, { highlight: false, block: "nearest" }));
      if (me.isDestroyed) {
        return;
      }
      if (synced) {
        await synced;
        if (me.isDestroyed) {
          return;
        }
        me.recompose.now();
      }
      suspended && me.resumeDomTransition();
      if (me.features.simpleTaskEdit) {
        me.editTask(taskRecord);
      }
      return taskRecord;
    }
    /**
     * Removes one or more tasks from the linked task store (and thus the TaskBoard).
     *
     * First fires a `'beforeTaskRemove'` event, which is preventable and async. Return `false` or a promise that
     * resolves to `false` from a listener to prevent the operation.
     *
     * ```javascript
     * taskBoard.on({
     *     async beforeRemoveTask() {
     *         const result = await askForConfirmation();
     *         return result;
     *     }
     * });
     *
     * taskBoard.remove(myTask);
     * ```
     *
     * @param {TaskBoard.model.TaskModel|TaskBoard.model.TaskModel[]} taskRecord A single task or an array thereof to
     * remove from the task store.
     * @returns {Boolean} Returns `true` if the tasks were removed, `false` if the operation was prevented.
     * @category Common
     */
    async removeTask(taskRecord) {
      const taskRecords = ArrayHelper.asArray(taskRecord);
      if (await this.trigger("beforeTaskRemove", { taskRecords }) !== false) {
        this.project.taskStore.remove(taskRecords);
        return true;
      }
      return false;
    }
    //endregion
  }, //region Config
  __publicField(_a2, "$name", "TaskBoardStores"), __publicField(_a2, "configurable", {
    projectModelClass: ProjectModel2,
    /**
     * The {@link TaskBoard.model.ProjectModel} instance, containing the data visualized by the TaskBoard.
     * @member {TaskBoard.model.ProjectModel} project
     * @accepts {TaskBoard.model.ProjectModel|ProjectModelConfig} project
     * @category Common
     */
    /**
     * A {@link TaskBoard.model.ProjectModel#configs project config object} or an instance that holds all stores and
     * data used by the TaskBoard.
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *     project : {
     *         // Use a custom task model
     *         taskModelClass : MyTaskModel,
     *
     *         // Supply inline data
     *         tasksData : [
     *             { id : 1, name: 'Task 1', ... },
     *             ...
     *         ]
     * });
     * ```
     *
     * Project has built-in crud manager functionality to handle syncing with a backend:
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *     project : {
     *         transport : {
     *             load : {
     *                 url : 'data/data.json'
     *             }
     *     },
     *     autoLoad : true
     * });
     *
     * Also has built-in state tracking manager functionality to handle undo/redo:
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *     stm : {
     *         autoRecord : true,
     *         disabled   : false
     *     }
     * });
     *
     * @config {TaskBoard.model.ProjectModel|ProjectModelConfig}
     * @category Data
     */
    project: {},
    /**
     * Inline {@link Scheduler.model.AssignmentModel assignments}, will be loaded into an internally created
     * {@link Scheduler.data.AssignmentStore}  as a part of a {@link TaskBoard.model.ProjectModel project}.
     * @prp {Scheduler.model.AssignmentModel[]|Object[]} assignments
     * @category Data
     */
    assignments: null,
    /**
     * Inline {@link Scheduler.model.ResourceModel resources}, will be loaded into an internally created
     * {@link Scheduler.data.ResourceStore} as a part of a {@link TaskBoard.model.ProjectModel project}.
     * @prp {Scheduler.model.ResourceModel[]|Object[]} resources
     * @category Data
     */
    resources: null,
    /**
     * Inline {@link TaskBoard.model.TaskModel tasks}, will be loaded into an internally created
     * {@link TaskBoard.store.TaskStore} as a part of a {@link TaskBoard.model.ProjectModel project}.
     * @prp {TaskBoard.model.TaskModel[]|Object[]} tasks
     * @category Data
     */
    tasks: null,
    /**
     * Default values to apply to task records created by task boards features (such as the column header menu and
     * the column toolbar)
     *
     * @config {TaskModelConfig}
     * @category Data
     */
    newTaskDefaults: {},
    loadMaskDefaults: {
      useTransition: true,
      showDelay: 100
    },
    /**
     * TaskBoard does not use a sync mask by default. If you want one, see
     * {@link Core.mixin.LoadMaskable#config-syncMask} for configuration options.
     *
     * @config {String|Object|null}
     * @default null
     * @category Masking
     */
    syncMask: null
  }), _a2;
};

// lib/TaskBoard/view/mixin/TaskBoardSwimlanes.js
var TaskBoardSwimlanes_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    //endregion
    //region Type assertions
    changeAutoGenerateSwimlanes(autoGenerateSwimlanes) {
      ObjectHelper.assertBoolean(autoGenerateSwimlanes, "autoGenerateSwimlanes");
      return autoGenerateSwimlanes;
    }
    changeSwimlaneField(swimlaneField) {
      ObjectHelper.assertString(swimlaneField, "swimlaneField");
      return swimlaneField;
    }
    //endregion
    //region Config - swimlaneField
    updateSwimlaneField(field, old) {
      if (!this.isConfiguring) {
        const { storage } = this.project.taskStore;
        if (old && old !== this.columnField) {
          storage.removeIndex(old);
        }
        storage.addIndex({ property: field, unique: false });
      }
      this.shouldAutoGenerateSwimlanes = field && this.autoGenerateSwimlanes;
    }
    //endregion
    //region Config - swimlanes
    changeSwimlanes(swimlanes) {
      return Store.from(swimlanes, { objectify: true, modelClass: SwimlaneModel }, (lane) => {
        if (typeof lane === "string") {
          return { id: lane, text: StringHelper.capitalize(lane) };
        }
        return lane;
      });
    }
    updateSwimlanes(swimlanes) {
      this.detachListeners("swimlanes");
      if (swimlanes) {
        (swimlanes.$store || swimlanes).taskBoard = this;
        swimlanes.ion({
          change: "onSwimlanesChange",
          refresh: "onSwimlanesChange",
          thisObj: this
        });
      }
    }
    get swimlanes() {
      const me = this, { taskStore } = me.project;
      if (me.shouldAutoGenerateSwimlanes && taskStore.count) {
        me.swimlanes = taskStore.getDistinctValues(me.swimlaneField).sort();
        me.shouldAutoGenerateSwimlanes = false;
      }
      return me._swimlanes;
    }
    onSwimlanesChange({ action }) {
      if (action === "add" || action === "remove" || action === "removeAll" || action === "update") {
        this.project.taskStore.storage.invalidateIndices();
      }
      if (action === "remove" || action === "update" || action === "filter") {
        const options = {};
        if (action === "update") {
          options.addTransition = { height: 1, opacity: 1 };
          options.removeTransition = { height: 1, opacity: 1 };
        }
        this.recomposeWithDomTransition(options);
        return;
      }
      this.recompose();
    }
    //endregion
    //region Data
    get hasSwimlanes() {
      var _a3;
      return Boolean(this.swimlaneField && ((_a3 = this.swimlanes) == null ? void 0 : _a3.count));
    }
    getSwimlaneTasks(swimlaneRecord) {
      return this.project.taskStore.storage.findItem(this.swimlaneField, swimlaneRecord.id);
    }
    getSwimlane(taskRecord) {
      var _a3;
      return this.swimlaneField && ((_a3 = this.swimlanes) == null ? void 0 : _a3.getById(taskRecord.getValue(this.swimlaneField)));
    }
    //endregion
  }, //region Config
  __publicField(_a2, "$name", "TaskBoardSwimlanes"), __publicField(_a2, "configurable", {
    /**
     * Store containing the TaskBoard swimlanes.
     *
     * @member {Core.data.Store} swimlanes
     * @category Common
     */
    /**
     * Store containing the TaskBoard swimlanes. A tasks {@link #config-swimlaneField} is matched against the `id`
     * of a swimlane to determine in which swimlane it is displayed.
     *
     * Accepts an array of swimlane records/objects, a store instance, a store id or a store config object used to
     * create a new store.
     *
     * When supplying an array, a store configured with {@link Core.data.mixin.StoreProxy#config-objectify} is
     * automatically created. Using that config allows for a nicer interaction syntax with the swimlanes:
     *
     * ```javascript
     * // Without objectify:
     * taskBoard.swimlanes.getById('highprio').text = 'Important!';
     *
     * // With objectify:
     * taskBoard.swimlanes.done.text = 'Finished';
     * ```
     *
     * When supplying strings, the raw string will be used as the swimlanes `id` and a capitalized version of it is
     * used as the swimlanes text:
     *
     * ```javascript
     * taskBoard = new TaskBoard({
     *    swimlanes : [
     *        'high',
     *        'low'
     *    ]
     * });
     * ```
     *
     * Is equivalent to:
     *
     * ```javascript
     * taskBoard = new TaskBoard({
     *    swimlanes : [
     *        { id : 'high', text : 'High' },
     *        { id : 'low', text : 'Low' }
     *    ]
     * });
     * ```
     *
     * @config {TaskBoard.model.SwimlaneModel[]|SwimlaneModelConfig[]|Core.data.Store|String|StoreConfig}
     * @category Common
     */
    swimlanes: {},
    /**
     * Set to `true` to auto generate swimlanes when {@link #config-swimlanes} is undefined.
     *
     * A swimlane will be created for each distinct value of {@link #config-swimlaneField} on the tasks. The
     * swimlanes will be sorted in alphabetical order. The following snippet will yield two swimlanes, Q1 and Q2:
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *    swimlaneField : 'quarter',
     *
     *    autoGenerateSwimlanes : true,
     *
     *    project : {
     *        tasksData : [
     *            { id : 1, name : 'Inform tenants', quarter : 'Q1' },
     *            { id : 2, name : 'Renovate roofs', quarter : 'Q2' }
     *        ]
     *    }
     * });
     * ```
     *
     * @config {Boolean}
     * @category Advanced
     */
    autoGenerateSwimlanes: false,
    /**
     * Field on a task record used to determine which swimlane the task belongs to.
     *
     * ```javascript
     * taskBoard.swimlaneField = 'category';
     * ```
     *
     * @member {String} swimlaneField
     * @category Common
     */
    /**
     * Field on a task record used to determine which swimlane the task belongs to.
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *    // Use the "prio" field of tasks to determie which swimlane a task belongs to
     *    swimlaneField : 'prio',
     *
     *    swimlanes : [
     *        'high',
     *        'low'
     *    ],
     *
     *    project : {
     *        tasksData : [
     *            // Linked using the prio field, to the high swimlane
     *            { id : 1, name : 'Fun task', prio : 'high' }
     *        ]
     *    }
     * });
     * ```
     *
     * @config {String}
     * @category Common
     */
    swimlaneField: null
  }), __publicField(_a2, "properties", {
    shouldAutoGenerateSwimlanes: false
  }), _a2;
};

// lib/TaskBoard/view/mixin/TaskBoardVirtualization.js
var TaskBoardVirtualization_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    //endregion
    //region Type assertions and changers/updaters
    changeVirtualize(virtualize) {
      ObjectHelper.assertBoolean(virtualize, "virtualize");
      return virtualize;
    }
    updateVirtualize(virtualize) {
      var _a3;
      const me = this;
      (_a3 = me.cardIntersectionObserver) == null ? void 0 : _a3.disconnect();
      me.cardIntersectionObserver = null;
      if (virtualize) {
        me.cardIntersectionObserver = new IntersectionObserver((entries) => {
          for (const entry of entries) {
            me.onCardIntersection(entry.target, entry.isIntersecting, entry);
          }
        });
      }
      if (!this.isConfiguring && !this.isDestroying) {
        this.refreshVirtualizedCards();
      }
    }
    refreshVirtualizedCards() {
      const me = this;
      me.recompose.now();
      if (me.cardIntersectionObserver) {
        for (const taskElement of me.element.querySelectorAll(".b-taskboard-card")) {
          me.cardIntersectionObserver.observe(taskElement);
        }
      }
    }
    changeGetTaskHeight(getTaskHeight) {
      getTaskHeight && ObjectHelper.assertFunction(getTaskHeight, "getTaskHeight");
      return getTaskHeight;
    }
    updateGetTaskHeight(fn2) {
      if (!this.isConfiguring && !this.isDestroying) {
        this.refreshVirtualizedCards();
      }
    }
    //endregion
    compose(domConfig) {
      domConfig.class["b-virtualized"] = this.isVirtualized;
      return super.compose(domConfig);
    }
    get isVirtualized() {
      return Boolean(this.cardIntersectionObserver);
    }
    // Flag cards as in view or out of view when their elements are intersecting the viewport (or not anymore)
    onCardIntersection(cardElement, isIntersecting, entry) {
      const me = this, { taskRecord } = cardElement.elementData, instanceMeta = taskRecord.instanceMeta(me), wasIntersecting = instanceMeta.intersects;
      if (wasIntersecting !== isIntersecting) {
        instanceMeta.intersects = isIntersecting;
        if (!isIntersecting && wasIntersecting) {
          instanceMeta.lastHeight = entry.boundingClientRect.height;
        }
        if (!me.isScrolling || me.drawOnScroll) {
          me.queueColumnRecompose(me.getColumn(taskRecord), me.getSwimlane(taskRecord));
        }
        if (me.isScrolling) {
          me.recomposeOnScrollEnd = true;
        }
      }
    }
    //region Rendering
    // Creates a DOM config for the outline of a single card
    renderCardOutline(taskRecord, columnRecord, swimlaneRecord) {
      var _a3;
      const me = this, { id, domId, weight } = taskRecord;
      return {
        id: `${me.id}-card-${domId}`,
        class: {
          "b-taskboard-card": true,
          "b-out-of-view": true
        },
        tabIndex: 0,
        dataset: {
          task: domId,
          column: columnRecord.id,
          lane: swimlaneRecord == null ? void 0 : swimlaneRecord.id,
          weight,
          domTransition: true
        },
        elementData: {
          elementType: "task",
          taskId: id,
          taskRecord,
          columnRecord,
          swimlaneRecord
        },
        style: {
          height: ((_a3 = me.getTaskHeight) == null ? void 0 : _a3.call(me, taskRecord)) || taskRecord.instanceMeta(me).lastHeight
        }
      };
    }
    // Overrides renderCard in TaskBoardBase, rendering outlines for cards out of view
    renderCard(taskRecord, columnRecord, swimlaneRecord) {
      const { isVirtualized } = this, meta = taskRecord.instanceMeta(this);
      if (isVirtualized && !meta.dragging && !meta.intersects && !this.isSelected(taskRecord)) {
        return this.renderCardOutline(taskRecord, columnRecord, swimlaneRecord);
      }
    }
    //endregion
  }, //region Config
  __publicField(_a2, "$name", "TaskBoardVirtualization"), __publicField(_a2, "configurable", {
    /**
     * The function is called for each task as part of the render loop, and is expected to return the height in
     * pixels for the task. Using this function is only recommended when using partial virtualized rendering, see
     * the {@link #config-virtualize} setting.
     *
     * How the height is determined is up to the application, it could for example return a fixed value:
     *
     * ```javascript
     * taskBoard = new TaskBoard({
     *     getTaskHeight() {
     *         return 150;
     *     }
     * }
     * ```
     *
     * Or get the height from data:
     *
     * ```javascript
     * taskBoard = new TaskBoard({
     *     getTaskHeight(taskRecord) {
     *         return taskRecord.myTaskHeight;
     *     }
     * }
     * ```
     *
     * Or use some custom application logic:
     *
     * ```javascript
     * taskBoard = new TaskBoard({
     *     getTaskHeight(taskRecord) {
     *         if (taskRecord.isCollapsed) {
     *             return 20;
     *         }
     *
     *         return taskRecord.myTaskHeight;
     *     }
     * }
     * ```
     *
     * @prp {Function}
     * @param {TaskBoard.model.TaskModel} taskRecord The task record
     * @return {Number} The height of the task in pixels
     * @category Advanced
     */
    getTaskHeight: null,
    /**
     * By turning on this setting you enable partial virtualized rendering for the board, which reduces initial
     * rendering time and makes interaction less sluggish when using thousands of tasks. The tradeoff is that
     * scrolling in most cases will be slower.
     *
     * For a nice UX, it is strongly recommended to also implement a {@link #config-getTaskHeight} function. Without
     * it, the height of tasks out of view will be unknown and the behaviour when scrolling will be less than ideal.
     *
     * <div class="note">Note that for normal datasets (depending on machine, but roughly <1000 tasks) performance
     * might be better without partial virtualized rendering, since it adds some overhead.</div>
     *
     * <div class="note">Also note that as part of the optimizations for partial virtualized rendering, the inner
     * element in columns that contain cards is absolutely positioned. This leads to column not being able to
     * automatically shrink wrap the cards, you will have to set a height on the swimlane (or task board if not
     * using swimlanes) to size things correctly.</div>
     *
     * @prp {Boolean}
     */
    virtualize: {
      value: null,
      $config: "nullify"
    },
    /**
     * Whether to draw cards on scroll, or only when scrolling ends.
     *
     * Only applies when using partial virtualized rendering (see {@link #config-getTaskHeight}).
     *
     * Setting this to `false` will boost scroll performance, but cards scrolled into view will be empty outlines
     * until scrolling ends.
     *
     * @prp {Boolean}
     */
    drawOnScroll: true
  }), _a2;
};

// lib/TaskBoard/view/item/TextItem.js
var TextItem = class extends TaskItem {
  static render({ domConfig, value, taskRecord, config }) {
    if (config.field === "id" && taskRecord.hasGeneratedId) {
      domConfig.class["b-generated-id"] = 1;
      domConfig.text = "\u273B";
    } else {
      domConfig.text = taskRecord.getFieldDefinition(config.field).print(value);
    }
  }
};
__publicField(TextItem, "$name", "TextItem");
__publicField(TextItem, "type", "text");
TextItem.initClass();
TextItem._$name = "TextItem";

// lib/TaskBoard/view/item/ResourceAvatarsItem.js
var ResourceAvatarsItem = class extends TaskItem {
  static render({ taskBoard, domConfig, config, taskRecord, cardSize }) {
    var _a2, _b;
    const maxAvatars = (_b = (_a2 = cardSize == null ? void 0 : cardSize.maxAvatars) != null ? _a2 : config.maxAvatars) != null ? _b : 7, { resourceImagePath } = taskBoard, { resources } = taskRecord, hasOverflow = resources.length > maxAvatars, overflowCount = resources.length - maxAvatars + 1, lastResource = resources[maxAvatars];
    let { avatarRendering } = taskBoard;
    if (!avatarRendering) {
      avatarRendering = taskBoard.avatarRendering = new AvatarRendering({
        element: taskBoard.element,
        colorPrefix: "b-taskboard-background-color-"
      });
    }
    if (!taskBoard.project.resourceStore.count) {
      return false;
    }
    ObjectHelper.merge(domConfig, {
      class: {
        "b-overlap": config.overlap
      },
      children: [
        // "Normal" avatars
        ...resources.sort((a, b) => a.name.localeCompare(b.name)).slice(0, maxAvatars - (hasOverflow ? 1 : 0)).map((resource, i) => ({
          class: {
            "b-taskboard-resource-avatar-wrap": 1
          },
          dataset: {
            resourceId: resource.id
          },
          children: [
            avatarRendering.getResourceAvatar({
              resourceRecord: resource,
              imageUrl: resource.image === false ? null : resource.imageUrl || resource.image && (resourceImagePath || "") + resource.image,
              initials: resource.initials,
              color: resource.eventColor,
              dataset: {
                btip: StringHelper.encodeHtml(resource.name)
              }
            })
          ]
        })),
        // Overflow indicating avatar
        hasOverflow && {
          class: {
            "b-taskboard-resource-avatar-overflow": 1
          },
          dataset: {
            resourceId: "$overflow",
            btip: resources.slice(-overflowCount).map((r) => StringHelper.encodeHtml(r.name)).join(", "),
            count: overflowCount
          },
          children: [
            avatarRendering.getResourceAvatar({
              resourceRecord: lastResource,
              imageUrl: lastResource.image === false ? null : lastResource.imageUrl || lastResource.image && resourceImagePath + lastResource.image,
              initials: lastResource.initials
            })
          ]
        }
      ],
      syncOptions: {
        syncIdField: "resourceId"
      }
    });
  }
  static onClick({ source: taskBoard, taskRecord, event }) {
    const element = event.target.closest(".b-resource-avatar, .b-taskboard-resource-avatar-overflow");
    if (element) {
      if (element.matches(".b-resource-avatar")) {
        const resourceRecord = taskBoard.project.resourceStore.getById(element.dataset.resourceId);
        taskBoard.trigger("resourceAvatarClick", { resourceRecord, taskRecord, element, event });
      } else {
        taskBoard.trigger("resourceAvatarOverflowClick", { taskRecord, element, event });
      }
      return false;
    }
  }
};
__publicField(ResourceAvatarsItem, "$name", "ResourceAvatarsItem");
__publicField(ResourceAvatarsItem, "type", "resourceAvatars");
/**
 * Maximum avatars to display by default. The last avatar will render an overflow indicator if the task has more
 * resources assigned.
 *
 * ```javascript
 * const taskBoard = new TaskBoard({
 *     headerItems : {
 *         resources : {
 *             type       : 'resourceAvatars',
 *             maxAvatars : 5
 *         }
 *     }
 * });
 * ```
 *
 * Overridden by card size based settings, see {@link TaskBoard.view.mixin.ResponsiveCards}.
 *
 * @config {Number} maxAvatars
 * @default 7
 * @category Common
 */
/**
 * Specify `true` to slightly overlap avatars for tasks that have multiple resources assigned. By default, they are
 * displayed side by side.
 *
 * ```javascript
 * const taskBoard = new TaskBoard({
 *     headerItems : {
 *         resources : {
 *             overlap : true
 *         }
 *     }
 * });
 * ```
 *
 * @config {Boolean} overlap
 */
/**
 * Widget type or config to use as the editor for this item. Used in the inline task editor.
 *
 * Defaults to use a {@link TaskBoard.widget.ResourcesCombo}.
 *
 * @config {String|Object} editor
 * @default resourcescombo
 * @category Common
 */
__publicField(ResourceAvatarsItem, "defaultEditor", { type: "resourcescombo", pickerWidth: "13em" });
ResourceAvatarsItem.initClass();
ResourceAvatarsItem._$name = "ResourceAvatarsItem";

// lib/TaskBoard/view/mixin/TaskItems.js
var fieldLess = {
  resourceAvatars: 1,
  separator: 1,
  taskMenu: 1
};
var taskItemSelector = ".b-taskboard-taskitem";
var afterRe2 = /\s*<\s*/;
var beforeRe2 = /\s*>\s*/;
var TaskItems_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    //endregion
    //region Type assertions
    changeProcessItems(processItems) {
      ObjectHelper.assertFunction(processItems, "processItems");
      return processItems;
    }
    //endregion
    // region Configuring items
    mergeItems(items2, old) {
      if (old && items2) {
        items2 = ObjectHelper.mergeItems(old, items2);
      }
      return items2;
    }
    // Needed to allow reconfiguring on the fly (for responsive)
    changeHeaderItems(items2, old) {
      ObjectHelper.assertObject(items2, "headerItems");
      return this.mergeItems(items2, old);
    }
    // Needed to allow reconfiguring on the fly (for responsive)
    changeBodyItems(items2, old) {
      ObjectHelper.assertObject(items2, "bodyItems");
      return this.mergeItems(items2, old);
    }
    // Needed to allow reconfiguring on the fly (for responsive)
    changeFooterItems(items2, old) {
      ObjectHelper.assertObject(items2, "footerItems");
      return this.mergeItems(items2, old);
    }
    //endregion
    //region Rendering
    // Render items to header, body or footer of the supplied task
    renderItems(taskRecord, items2, target, cardSize) {
      for (const key in items2) {
        const config = items2[key];
        if (config && !config.hidden) {
          if (!("field" in config)) {
            if (key.includes(">")) {
              [config.field] = key.split(beforeRe2);
            } else if (key.includes("<")) {
              [, config.field] = key.split(afterRe2);
            } else {
              config.field = key;
            }
          }
          const { field } = config, value = taskRecord.getValue(field);
          if (value != null || fieldLess[config.type] || config.renderNull) {
            const item = TaskItem.resolveType(config.type), typeCls = `b-taskboard-${StringHelper.hyphenate(config.type)}`, domConfig = {
              class: {
                "b-taskboard-taskitem": 1,
                [typeCls]: 1,
                [config.cls]: config.cls,
                "b-editable": !taskRecord.readOnly && item.getEditorConfig({ config, item })
              },
              dataset: {
                role: `item-${field}`,
                field,
                ref: key
              },
              elementData: {
                item,
                taskRecord,
                config
              },
              style: {
                order: config.order,
                style: config.style
              }
            }, result = item.render({ taskBoard: this, domConfig, value, config, taskRecord, cardSize });
            if (result !== false) {
              target.children[key] = domConfig;
            }
          }
        }
      }
    }
    // Hook into card rendering
    populateCard(args) {
      var _a3;
      (_a3 = super.populateCard) == null ? void 0 : _a3.call(this, args);
      const me = this, { processItems } = me, { taskRecord, cardConfig, cardSize } = args, {
        headerItems: sizeHeaderItems,
        bodyItems: sizeBodyItems,
        footerItems: sizeFooterItems
      } = cardSize || {}, { header, body, footer } = cardConfig.children;
      let { headerItems, bodyItems, footerItems } = me;
      if (sizeHeaderItems || processItems) {
        headerItems = ObjectHelper.clone(headerItems);
      }
      if (sizeBodyItems || processItems) {
        bodyItems = ObjectHelper.clone(bodyItems);
      }
      if (sizeFooterItems || processItems) {
        footerItems = ObjectHelper.clone(footerItems);
      }
      sizeHeaderItems && ObjectHelper.merge(headerItems, sizeHeaderItems);
      sizeBodyItems && ObjectHelper.merge(bodyItems, sizeBodyItems);
      sizeFooterItems && ObjectHelper.merge(footerItems, sizeFooterItems);
      processItems == null ? void 0 : processItems({ headerItems, bodyItems, footerItems, taskRecord, cardSize });
      me.renderItems(taskRecord, headerItems, header, cardSize);
      me.renderItems(taskRecord, bodyItems, body, cardSize);
      me.renderItems(taskRecord, footerItems, footer, cardSize);
    }
    //endregion
    //region Listeners
    resolveTaskItem(element) {
      const taskItemElement = element.closest(taskItemSelector) || element.querySelector(`:scope > * > ${taskItemSelector}, :scope > ${taskItemSelector}`);
      if (taskItemElement) {
        return {
          ...taskItemElement.elementData,
          element: taskItemElement
        };
      }
      return null;
    }
    // Relay clicks to items
    onTaskClick(args) {
      var _a3;
      const taskItem = this.resolveTaskItem(args.event.target);
      if (taskItem) {
        const { config, item } = taskItem;
        (_a3 = item.onClick) == null ? void 0 : _a3.call(item, {
          config,
          ...args
        });
      }
      super.onTaskClick(args);
    }
    // Relay double clicks to items
    onTaskDblClick(args) {
      var _a3;
      const taskItem = this.resolveTaskItem(args.event.target);
      if (taskItem) {
        const { config, item } = taskItem;
        (_a3 = item.onDblClick) == null ? void 0 : _a3.call(item, {
          config,
          ...args
        });
      }
      super.onTaskDblClick(args);
    }
    //endregion
  }, //region Config
  __publicField(_a2, "$name", "TaskItems"), __publicField(_a2, "configurable", {
    /**
     * Items in card header.
     *
     * As an object keyed by field names, values are {@link TaskBoard/view/item/TaskItem#configs TaskItem configs}.
     *
     * Reassigning this property merges the supplied object with the configured items:
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *    headerItems : {
     *        status : { type : 'text' }
     *    }
     * });
     *
     * taskBoard.headerItems = {
     *     status : { hidden : true },
     *     tags   : { type : 'tags' }
     * };
     *
     * // Results in:
     * //
     * // headerItems = {
     * //     status : { type : 'text', hidden: true }
     * //     tags   : { type : 'tags' }
     * // }
     * }
     * ```
     *
     * @member {Object<String,TaskItemOptions>} headerItems
     * @category Task content
     */
    /**
     * Items to add to each card's header.
     *
     * Supplied keys are used to bind to a field on the {@link TaskBoard/model/TaskModel task record}, supplied
     * values are used to configure the {@link TaskBoard/view/item/TaskItem#configs items}.
     *
     * You are always required to supply a `type`, see the docs for each item type for more information on available
     * configs.
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *    headerItems : {
     *        status : { type : 'text' }
     *    }
     * });
     * ```
     *
     * For more information, see the {@link #class-description class description} above.
     *
     * @config {Object<String,TaskItemOptions>}
     * @category Task content
     */
    headerItems: {
      value: {
        text: { type: "text", field: "name" }
      },
      $config: {
        merge: "items"
      }
    },
    /**
     * Items to add to each card's body.
     *
     * As an object keyed by field names, values are {@link TaskBoard/view/item/TaskItem#configs TaskItem configs}.
     *
     * Reassigning this property merges the supplied object with the configured items:
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *    bodyItems : {
     *        status : { type : 'text' }
     *    }
     * });
     *
     * taskBoard.bodyItems = {
     *     status : { hidden : true },
     *     tags   : { type : 'tags' }
     * };
     *
     * // Results in:
     * //
     * // bodyItems = {
     * //     status : { type : 'text', hidden: true }
     * //     tags   : { type : 'tags' }
     * // }
     * }
     * ```
     *
     * @member {Object<String,TaskItemOptions>} bodyItems
     * @category Task content
     */
    /**
     * Items to add to each card's body.
     *
     * Supplied keys are used to bind to a field on the {@link TaskBoard/model/TaskModel task record}, supplied
     * values are used to configure the {@link TaskBoard/view/item/TaskItem#configs items}.
     *
     * You are always required to supply a `type`, see the docs for each item type for more information on available
     * configs.
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *    bodyItems : {
     *        status : { type : 'text' }
     *    }
     * });
     * ```
     *
     * For more information, see the {@link #class-description class description} above.
     *
     * @config {Object<String,TaskItemOptions>}
     * @category Task content
     */
    bodyItems: {
      value: {
        text: { type: "text", field: "description" }
      },
      $config: {
        merge: "items"
      }
    },
    /**
     * Items in card footer.
     *
     * As an object keyed by field names, values are {@link TaskBoard/view/item/TaskItem#configs TaskItem configs}.
     *
     * Reassigning this property merges the supplied object with the configured items:
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *    footerItems : {
     *        status : { type : 'text' }
     *    }
     * });
     *
     * taskBoard.footerItems = {
     *     status : { hidden : true },
     *     tags   : { type : 'tags' }
     * };
     *
     * // Results in:
     * //
     * // footerItems = {
     * //     status : { type : 'text', hidden: true }
     * //     tags   : { type : 'tags' }
     * // }
     * }
     * ```
     *
     * @member {Object<String,TaskItemOptions>} footerItems
     * @category Task content
     */
    /**
     * Items to add to each card's footer.
     *
     * Supplied keys are used to bind to a field on the {@link TaskBoard/model/TaskModel task record}, supplied
     * values are used to configure the {@link TaskBoard/view/item/TaskItem#configs items}.
     *
     * You are always required to supply a `type`, see the docs for each item type for more information on available
     * configs.
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *    footerItems : {
     *        status : { type : 'text' }
     *    }
     * });
     * ```
     *
     * For more information, see the {@link #class-description class description} above.
     *
     * @config {Object<String,TaskItemOptions>}
     * @category Task content
     */
    footerItems: {
      value: {
        resourceAvatars: { type: "resourceAvatars", field: "resources" }
      },
      $config: {
        merge: "items"
      }
    },
    /**
     * A function called on each render before adding items to a tasks card, allowing runtime manipulation of them.
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *     processItems({ bodyItems, taskRecord }) {
     *        // Remove the progress item for done tasks
     *        if (taskRecord.status === 'done') {
     *            bodyItems.progress = null;
     *        }
     *     }
     * });
     * ```
     *
     * NOTE: The function is only intended for manipulating the passed items, you should not update the passed
     * `taskRecord` in it since updating records triggers another round of rendering.
     *
     * @config {Function}
     * @param {Object} context
     * @param {Object<String,TaskItemOptions>} context.headerItems Item config objects for the task header, keyed by ref
     * @param {Object<String,TaskItemOptions>} context.bodyItems Item config objects for the task body, keyed by ref
     * @param {Object<String,TaskItemOptions>} context.footerItems Item config objects for the task footer, keyed by ref
     * @param {TaskBoard.model.TaskModel} context.taskRecord Record representing task to be rendered
     * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown
     * @category Task content
     */
    processItems: null
  }), _a2;
};

// lib/TaskBoard/view/mixin/TaskNavigation.js
var navigationActions = ["navigateDown", "navigateLeft", "navigateUp", "navigateRight", "activate"];
var TaskNavigation_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    //endregion
    //region Utility
    getTaskNear(x, y) {
      var _a3, _b, _c;
      const { documentRoot } = this, gap = DomHelper.measureSize(
        this.css.cardGap || "1em",
        this.bodyElement.querySelector(".b-taskboard-swimlane-body .b-taskboard-column")
      );
      let task = (_a3 = documentRoot.elementFromPoint(x, y)) == null ? void 0 : _a3.closest(".b-taskboard-card");
      if (!task) {
        task = (_b = documentRoot.elementFromPoint(x, y - gap)) == null ? void 0 : _b.closest(".b-taskboard-card");
      }
      if (!task) {
        task = (_c = documentRoot.elementFromPoint(x, y + gap)) == null ? void 0 : _c.closest(".b-taskboard-card");
      }
      return task;
    }
    //endregion
    //region Navigation
    focusAndOptionallySelect(taskElement, forceSelect) {
      if (taskElement) {
        const me = this, currentlyFocusedTask = me.resolveTaskRecord(document.activeElement);
        if (forceSelect && currentlyFocusedTask && !me.isSelected(currentlyFocusedTask)) {
          me.selectTask(currentlyFocusedTask, true);
        }
        if (me.selectOnNavigation || forceSelect) {
          const taskToFocus = me.resolveTaskRecord(taskElement);
          if (!me.isSelected(taskToFocus)) {
            me.selectTask(taskToFocus, forceSelect);
          } else if (forceSelect) {
            me.deselectTask(currentlyFocusedTask);
          }
        }
        taskElement.focus();
      }
    }
    // To task at same Y in next column
    navigateNext(keyEvent, select) {
      const me = this, { taskRecord, swimlaneRecord, columnRecord } = keyEvent.taskBoardData, taskElement = me.getTaskElement(taskRecord);
      let found = null, nextColumnRecord = columnRecord;
      do {
        nextColumnRecord = me.columns.getNext(nextColumnRecord, true);
        if (!nextColumnRecord.hidden) {
          const nextColumnElement = me.getSwimlaneColumnElement(swimlaneRecord, nextColumnRecord), x = Rectangle.from(nextColumnElement, null, true).center.x, y = Rectangle.from(taskElement, null, true).center.y;
          found = me.getTaskNear(x, y);
        }
      } while (!found && nextColumnRecord !== columnRecord);
      me.focusAndOptionallySelect(found, select);
    }
    // To task at same Y in prev column
    navigatePrev(keyEvent, select) {
      const me = this, { taskRecord, swimlaneRecord, columnRecord } = keyEvent.taskBoardData, taskElement = me.getTaskElement(taskRecord);
      let found = null, prevColumnRecord = columnRecord;
      do {
        prevColumnRecord = me.columns.getPrev(prevColumnRecord, true);
        if (!prevColumnRecord.hidden) {
          const prevColumnElement = me.getSwimlaneColumnElement(swimlaneRecord, prevColumnRecord), x = Rectangle.from(prevColumnElement, null, true).center.x, y = Rectangle.from(taskElement, null, true).center.y;
          found = me.getTaskNear(x, y);
        }
      } while (!found && prevColumnRecord !== columnRecord);
      me.focusAndOptionallySelect(found, select);
    }
    // Right navigates to next column for LTR and previous for RTL
    navigateRight(event, select = false) {
      this["navigate" + (this.rtl ? "Prev" : "Next")](event, select);
    }
    // Left navigates to previous column for LTR and next for RTL
    navigateLeft(event, select = false) {
      this["navigate" + (this.rtl ? "Next" : "Prev")](event, select);
    }
    // Find next task in same column (might be in next swimlane)
    navigateDown(keyEvent, select = false) {
      const { taskRecord } = keyEvent.taskBoardData, nextTask = this.getNextTask(taskRecord, true);
      this.focusAndOptionallySelect(this.getTaskElement(nextTask), select);
    }
    // Find prev task in same column (might be in prev swimlane)
    navigateUp(keyEvent, select = false) {
      const { taskRecord } = keyEvent.taskBoardData, prevTask = this.getPreviousTask(taskRecord, true);
      this.focusAndOptionallySelect(this.getTaskElement(prevTask), select);
    }
    // Activate (show editor)
    activate(event) {
      const { taskRecord } = this.resolveEvent(event);
      taskRecord && this.trigger("activateTask", { taskRecord, event });
    }
    isActionAvailable({ action, event }) {
      const taskBoardData = this.resolveEvent(event);
      event.taskBoardData = taskBoardData;
      if (action === "activate" && taskBoardData.taskRecord && event.target !== this.getTaskElement(taskBoardData.taskRecord)) {
        return false;
      }
      return Boolean((this.navigateable || !navigationActions.includes(action)) && (taskBoardData == null ? void 0 : taskBoardData.taskRecord));
    }
    //endregion
  }, //region Config
  __publicField(_a2, "$name", "TaskNavigation"), __publicField(_a2, "configurable", {
    // Documented on TaskBoard
    keyMap: {
      ArrowDown: "navigateDown",
      ArrowLeft: "navigateLeft",
      ArrowUp: "navigateUp",
      ArrowRight: "navigateRight",
      Enter: "activate"
    },
    navigateable: true,
    /**
     * Configure with `true` to change the default behaviour of keyboard navigation from moving focus to selecting
     * tasks:
     *
     * ```javascript
     * const taskBoard = new TaskBoard({
     *     selectOnNavigation : true
     * });
     * ```
     *
     * @config {Boolean|String}
     * @default
     * @category Selection
     */
    selectOnNavigation: false
  }), _a2;
};

// lib/TaskBoard/view/mixin/TaskSelection.js
var TaskSelection_default = (Target) => {
  var _a2;
  return _a2 = class extends (Target || Base) {
    get widgetClass() {
    }
    //endregion
    //region Type assertions
    changeSelectedTasks(selectedTasks) {
      ObjectHelper.assertArray(selectedTasks, "selectedTasks");
      return selectedTasks.filter((task) => {
        var _a3;
        return ((_a3 = this.isTaskSelectable) == null ? void 0 : _a3.call(this, task)) !== false;
      });
    }
    //endregion
    //region Programmatic selection
    toggleTaskSelection(taskRecord, add = false, forceSelect = null) {
      const me = this;
      if (forceSelect == null) {
        if (me.isSelected(taskRecord)) {
          if (!add) {
            me.selectTask(taskRecord, false);
          } else {
            me.deselectTask(taskRecord);
          }
        } else {
          me.selectTask(taskRecord, add);
        }
      } else if (forceSelect) {
        me.selectTask(taskRecord, add);
      } else {
        me.deselectTask(taskRecord);
      }
    }
    /**
     * Select the supplied task, deselecting any previously selected by default.
     * @param {TaskBoard.model.TaskModel} taskRecord Task to select
     * @param {Boolean} [add] Specify `true` to add to selection instead of replacing it
     * @category Selection
     */
    selectTask(taskRecord, add = false) {
      var _a3;
      const { selectedTasks } = this, event = {
        action: "select",
        select: [taskRecord]
      };
      if (((_a3 = this.isTaskSelectable) == null ? void 0 : _a3.call(this, taskRecord)) === false) {
        return;
      }
      if (!add) {
        event.deselect = selectedTasks.slice();
        selectedTasks.length = 0;
      }
      ArrayHelper.include(selectedTasks, taskRecord);
      this.triggerSelectionChange(event);
      this.recompose();
    }
    /**
     * Deselect the supplied task.
     * @param {TaskBoard.model.TaskModel} taskRecord
     * @category Selection
     */
    deselectTask(taskRecord) {
      ArrayHelper.remove(this.selectedTasks, taskRecord);
      this.triggerSelectionChange({
        action: "deselect",
        deselect: [taskRecord]
      });
      this.recompose();
    }
    /**
     * Deselect all tasks.
     * @category Selection
     */
    deselectAll() {
      const { selectedTasks } = this;
      if (selectedTasks.length) {
        const deselect = selectedTasks.slice();
        selectedTasks.length = 0;
        this.triggerSelectionChange({
          action: "deselect",
          deselect
        });
        this.recompose();
      }
    }
    /**
     * Check if the supplied task is selected or not
     * @param {TaskBoard.model.TaskModel} taskRecord
     * @returns {Boolean} Returns `true` if it is selected, `false` if not
     * @category Selection
     */
    isSelected(taskRecord) {
      return this.selectedTasks.includes(taskRecord);
    }
    triggerSelectionChange(event) {
      this.trigger("selectionChange", Object.assign({
        selection: this.selectedTasks,
        select: [],
        deselect: []
      }, event));
    }
    //endregion
    //region Listeners
    onTaskClick(bryntumEvent) {
      super.onTaskClick(bryntumEvent);
      const { event, taskRecord } = bryntumEvent;
      if (!event.defaultPrevented) {
        this.toggleTaskSelection(taskRecord, event.ctrlKey);
      }
    }
    keyboardSelect(keyEvent) {
      if (!DomHelper.isEditable(keyEvent.target)) {
        const { taskRecord } = this.resolveEvent(keyEvent);
        if (taskRecord) {
          this.toggleTaskSelection(taskRecord, false);
          return true;
        }
      }
      return false;
    }
    keyboardToggleSelect(keyEvent) {
      const { taskRecord } = this.resolveEvent(keyEvent);
      if (taskRecord) {
        this.toggleTaskSelection(taskRecord, true);
      }
    }
    onClick(event) {
      super.onClick(event);
      if (!event.taskRecord && this.navigateable) {
        this.deselectAll();
      }
    }
    selectUp(event) {
      this.navigateUp(event, true);
    }
    selectDown(event) {
      this.navigateDown(event, true);
    }
    selectLeft(event) {
      this.navigateLeft(event, true);
    }
    selectRight(event) {
      this.navigateRight(event, true);
    }
    //endregion
    //region Rendering
    populateCard(args) {
      var _a3;
      (_a3 = super.populateCard) == null ? void 0 : _a3.call(this, args);
      const { taskRecord, cardConfig } = args;
      cardConfig.class["b-selected"] = this.isSelected(taskRecord);
    }
    populateBody(args) {
      var _a3;
      (_a3 = super.populateBody) == null ? void 0 : _a3.call(this, args);
      const { bodyConfig } = args;
      bodyConfig.class["b-has-selection"] = Boolean(this.selectedTasks.length);
    }
    //endregion
  }, //region Config
  __publicField(_a2, "$name", "TaskSelection"), __publicField(_a2, "configurable", {
    /**
     * Selected tasks.
     * @prp {TaskBoard.model.TaskModel[]} selectedTasks
     * @category Common
     */
    selectedTasks: [],
    /**
     * A template method (empty by default) allowing you to control if a task can be selected or not.
     *
     * ```javascript
     * new TaskBoard({
     *     isTaskSelectable(taskRecord) {
     *         return taskRecord.status !== 'done';
     *     }
     * })
     * ```
     *
     * @param {TaskBoard.model.TaskModel} taskRecord The task record
     * @returns {Boolean} `true` if the task can be selected, otherwise `false`
     * @prp {Function}
     * @category Selection
     */
    isTaskSelectable: null,
    keyMap: {
      " ": "keyboardSelect",
      "Ctrl+ ": "keyboardToggleSelect",
      "Shift+ArrowDown": "selectDown",
      "Shift+ArrowLeft": "selectLeft",
      "Shift+ArrowUp": "selectUp",
      "Shift+ArrowRight": "selectRight"
    }
  }), _a2;
};

// lib/TaskBoard/view/item/ImageItem.js
var ImageItem = class extends TaskItem {
  static render({ domConfig, value, config }) {
    if (value) {
      Object.assign(domConfig, {
        tag: "img",
        src: (config.baseUrl || "") + value,
        draggable: false
      });
    }
  }
};
__publicField(ImageItem, "$name", "ImageItem");
__publicField(ImageItem, "type", "image");
/**
 * Url prepended to this items value.
 *
 * ```javascript
 * const taskBoard = new TaskBoard({
 *    bodyItems : {
 *        picture : { type : 'image', baseUrl : 'images/' }
 *    },
 *
 *    project : {
 *        tasksData : [
 *            { id : 1, name : 'Task #1', picture : 'photo.jpg' },
 *            { id : 2, name : 'Task #2', picture : 'image.jpg' }
 *        ]
 *    }
 * });
 *
 * // Card for task #1 will render image "images/photo.jpg"
 * // Card for task #2 will render image "images/image.jpg"
 * ```
 *
 * @config {String} baseUrl
 * @category Common
 */
/**
 * Widget type or config to use as the editor for this item. Used in the inline task editor.
 *
 * ImageItems are un-editable by default.
 *
 * @config {String|Object} editor
 * @default null
 * @category Common
 */
__publicField(ImageItem, "defaultEditor", null);
ImageItem.initClass();
ImageItem._$name = "ImageItem";

// lib/TaskBoard/view/item/JsxItem.js
var JsxItem = class extends TaskItem {
  static render({ domConfig, config, taskRecord, value }) {
    domConfig.retainChildren = true;
    domConfig.children = [config.jsx({ value, taskRecord, config })];
  }
};
__publicField(JsxItem, "$name", "JsxItem");
__publicField(JsxItem, "type", "jsx");
/**
 * Function used to generate JSX item content.
 *
 * Return a React Element (JSX) from the function:
 *
 * ```javascript
 * import MyJsxItem from './MyJsxItem.js';
 *
 * const taskBoard = new TaskBoard({
 *    bodyItems : {
 *        prio : {
 *          type : 'jsx',
 *          jsx  : ({ taskRecord }) => <MyJsxItem taskRecord={taskRecord} />
 *        }
 *    }
 * });
 * ```
 *
 * @config {Function} jsx
 * @param {TaskBoard.model.TaskModel} taskRecord Task record
 * @param {JsxItemConfig} config Item config
 * @param {Object} value Value of the configured field
 * @returns React Element (JSX)
 * @category Common
 */
/**
 * Widget type or config to use as the editor for this item. Used in the inline task editor.
 *
 * JsxItems are un-editable by default.
 *
 * @config {String|Object} editor
 * @default null
 * @category Common
 */
__publicField(JsxItem, "defaultEditor", null);
JsxItem.initClass();
JsxItem._$name = "JsxItem";

// lib/TaskBoard/view/item/ProgressItem.js
var ProgressItem = class extends TaskItem {
  static render({ domConfig, value, config }) {
    const percent = Math.round(100 * value / (config.max || 100)) + "%";
    domConfig.children = [
      {
        class: "b-taskboard-progress-outline",
        dataset: {
          percent
        },
        children: [
          {
            class: "b-taskboard-progress-progress",
            style: {
              width: percent
            },
            dataset: {
              percent
            }
          }
        ]
      }
    ];
    domConfig.dataset.percent = domConfig.dataset.btip = percent;
  }
};
__publicField(ProgressItem, "$name", "ProgressItem");
__publicField(ProgressItem, "type", "progress");
__publicField(ProgressItem, "configurable", {
  /**
   * Max value, at which the bar is full.
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *    bodyItems : {
   *        progress : { type : 'progress', max : 10 }
   *    },
   *
   *    project : {
   *        tasksData : [
   *            { id : 1, name : 'Task #1', progress : 9 }
   *        ]
   *    }
   * });
   *
   * // Task #1 bar is 9/10 filled
   * ```
   *
   * @config {Number} max
   * @default 100
   * @category Common
   */
});
/**
 * Widget type or config to use as the editor for this item. Used in the inline task editor.
 *
 * ProgressItems are un-editable by default.
 *
 * @config {String|Object} editor
 * @default null
 * @category Common
 */
__publicField(ProgressItem, "defaultEditor", null);
ProgressItem.initClass();
ProgressItem._$name = "ProgressItem";

// lib/TaskBoard/view/item/RatingItem.js
var RatingItem = class extends TaskItem {
  static render({ domConfig, value, config }) {
    const { max = value } = config;
    domConfig.children = [];
    for (let i = 0; i < max; i++) {
      domConfig.children.push({
        tag: "i",
        class: {
          "b-icon b-icon-star": 1,
          "b-filled": i < value
        }
      });
    }
  }
};
__publicField(RatingItem, "$name", "RatingItem");
__publicField(RatingItem, "type", "rating");
/**
 * Max rating.
 *
 * ```javascript
 * const taskBoard = new TaskBoard({
 *    bodyItems : {
 *       grade : { type : 'ratingitem', max : 5 }
 *    },
 *
 *    project : {
 *        tasksData : [
 *            { id : 1, name : 'Task #1', grade : 3 }
 *        ]
 *    }
 * });
 *
 * // Card for task #1 will render 3 full stars and 2 faded,
 * // for a total of 5 stars
 * ```
 *
 * @config {Number} max
 * @category Common
 */
/**
 * Widget type or config to use as the editor for this item. Used in the inline task editor.
 *
 * RatingItems are un-editable by default.
 *
 * @config {String|Object} editor
 * @default null
 * @category Common
 */
__publicField(RatingItem, "defaultEditor", null);
RatingItem.initClass();
RatingItem._$name = "RatingItem";

// lib/TaskBoard/view/item/SeparatorItem.js
var SeparatorItem = class extends TaskItem {
  static render({ domConfig }) {
    domConfig.tag = "hr";
  }
};
__publicField(SeparatorItem, "$name", "SeparatorItem");
__publicField(SeparatorItem, "type", "separator");
/**
 * @hideconfigs editor
 */
__publicField(SeparatorItem, "defaultEditor", null);
SeparatorItem.initClass();
SeparatorItem._$name = "SeparatorItem";

// lib/TaskBoard/widget/TagCombo.js
var TagCombo = class extends Combo.mixin(TaskBoardLinked_default) {
  afterConfigure() {
    var _a2;
    const me = this;
    if (!((_a2 = me.store) == null ? void 0 : _a2.count) && me.taskBoard && me.name) {
      const { name, separator } = me, tags = [];
      me.taskBoard.project.taskStore.forEach((task) => {
        const taskTags = task[name];
        if (taskTags) {
          if (typeof taskTags === "string") {
            tags.push(...taskTags.split(separator));
          } else {
            tags.push(...taskTags);
          }
        }
      });
      me.items = [...new Set(tags)].sort();
    }
  }
  changeValue(value, old) {
    this.$expectsString = false;
    if (this.separator && typeof value === "string") {
      value = value.split(this.separator);
      this.$expectsString = true;
    }
    super.changeValue(value, old);
  }
  get value() {
    const value = super.value;
    if (this.$expectsString) {
      return value.join(this.separator);
    }
    return value;
  }
  set value(value) {
    super.value = value;
  }
};
__publicField(TagCombo, "$name", "TagCombo");
__publicField(TagCombo, "type", "tagcombo");
__publicField(TagCombo, "configurable", {
  multiSelect: true,
  editable: false,
  /**
   * Separator used to split a string into tags. Required if data format uses a single string to represent tags.
   * @config {String}
   * @default
   */
  separator: ",",
  picker: {
    cls: "b-tag-picker"
  },
  chipView: {
    closable: false
  }
});
TagCombo.initClass();
TagCombo._$name = "TagCombo";

// lib/TaskBoard/view/item/TagsItem.js
var TagsItem = class extends TaskItem {
  static render({ domConfig, value, config }) {
    let tags;
    if (value) {
      if (typeof value === "string") {
        tags = value.split(config.separator || ",").map((str) => ({ text: str }));
      } else if (Array.isArray(value)) {
        tags = value.map((entry) => {
          if (typeof entry === "string") {
            return { text: entry };
          } else {
            return {
              text: config.textProperty && entry[config.textProperty],
              cls: config.clsProperty && entry[config.clsProperty]
            };
          }
        });
      }
      if (tags) {
        domConfig.children = tags.map((tag) => {
          const cls = "cls" in tag ? tag.cls : DomHelper.makeValidId(tag.text, "-").toLowerCase();
          return {
            class: {
              "b-taskboard-tags-tag": 1,
              [cls]: Boolean(cls)
            },
            text: tag.text
          };
        });
      }
    }
  }
};
__publicField(TagsItem, "$name", "TagsItem");
__publicField(TagsItem, "type", "tags");
/**
 * Property used to determine the text for the tag. It is plucked from an array of objects that is used as the value
 * for this item.
 *
 * ```javascript
 * const taskBoard = new TaskBoard({
 *    bodyItems : {
 *       tags : { type : 'TagsItem', textProperty : 'title' }
 *    },
 *
 *    project : {
 *        tasksData : [{
 *            id : 1,
 *            name : 'Issue #1',
 *            tags : [
 *                { title : 'bug', color : 'orange' },
 *                { title : 'important', color : 'red' }
 *            ]
 *        }]
 *    }
 * });
 *
 * // Card for Issue #1 will render 2 tags, 'bug' and 'important'
 * ```
 *
 * @config {String} textProperty
 * @category Common
 */
/**
 * Property used to add a CSS class to each tag. It is plucked from an array of objects that is used as the value
 * for this item.
 *
 * ```javascript
 * const taskBoard = new TaskBoard({
 *    bodyItems : {
 *       tags : { type : 'TagsItem', clsProperty : 'color' }
 *    },
 *
 *    project : {
 *        tasksData : [{
 *            id : 1,
 *            name : 'Issue #1',
 *            tags : [
 *                { title : 'bug', color : 'orange' },
 *                { title : 'important', color : 'red' }
 *            ]
 *        }]
 *    }
 * });
 *
 * // Card for Issue #1 will render 2 tags, one with cls 'orange' and one with cls 'red'
 * ```
 *
 * @config {String} clsProperty
 * @category Common
 */
/**
 * Property used to split a value string into tags.
 *
 * ```javascript
 * const taskBoard = new TaskBoard({
 *    bodyItems : {
 *       tags : { type : 'TagsItem', separator : ';' }
 *    },
 *
 *    project : {
 *        tasksData : [{
 *            id : 1,
 *            name : 'Issue #1',
 *            tags : 'bug;important'
 *        }]
 *    }
 * });
 *
 * // Card for Issue #1 will render 2 tags, 'bug' and 'important'
 * ```
 *
 * @config {String} separator
 * @default ,
 * @category Common
 */
/**
 * Widget type or config to use as the editor for this item. Used in the inline task editor.
 *
 * Defaults to use a {@link TaskBoard.widget.TagCombo}.
 *
 * @config {String|Object} editor
 * @default tagcombo
 * @category Common
 */
__publicField(TagsItem, "defaultEditor", { type: "tagcombo", pickerWidth: "10em" });
TagsItem.initClass();
TagsItem._$name = "TagsItem";

// lib/TaskBoard/view/item/TemplateItem.js
var TemplateItem = class extends TaskItem {
  static render({ domConfig, value, config, taskRecord }) {
    const html = config.template({ taskRecord, config, value });
    if (typeof html === "string") {
      domConfig.html = html;
    } else if (ObjectHelper.isObject(html)) {
      ObjectHelper.merge(domConfig, html);
    } else if (Array.isArray(html)) {
      domConfig.children = html;
    }
  }
};
__publicField(TemplateItem, "$name", "TemplateItem");
__publicField(TemplateItem, "type", "template");
/**
 * Template function used to generate task content.
 *
 * Return an HTML string or a DomConfig object from the function:
 *
 * ```javascript
 * const taskBoard = new TaskBoard({
 *    bodyItems : {
 *        prio : {
 *          type     : 'template',
 *          template : ({ taskRecord }) => `<i class="b-fa b-fa-tarffic-light"></i> ${taskRecord.prio}`
 *        }
 *    }
 * });
 * ```
 *
 * @config {Function} template
 * @param {TaskBoard.model.TaskModel} taskRecord Task record
 * @param {TemplateItemConfig} config Item config
 * @param {Object} value Value of the configured field
 * @returns {String|DomConfig|DomConfig[]} HTML string, DomConfig or DomConfig array
 * @category Common
 */
/**
 * Widget type or config to use as the editor for this item. Used in the inline task editor.
 *
 * TemplateItems are un-editable by default.
 *
 * @config {String|Object} editor
 * @default null
 * @category Common
 */
/**
 * Specify as `true` to render the template item even if the backing field's value is `null` or `undefined`. Useful
 * for example to display some custom string for null values ("Empty", "Unset" etc).
 *
 * ```javascript
 * const taskBoard = new TaskBoard({
 *    footerItems : {
 *        category : {
 *          type       : 'template',
 *          renderNull : true,
 *          template   : ({ value }) => value ? value : 'Empty'
 *        }
 *    }
 * });
 * ```
 *
 * @config {Boolean} renderNull
 * @default false
 * @category Common
 */
__publicField(TemplateItem, "defaultEditor", null);
TemplateItem.initClass();
TemplateItem._$name = "TemplateItem";

// lib/TaskBoard/view/item/TodoListItem.js
var TodoListItem = class extends TaskItem {
  static render({ domConfig, value, config, taskRecord }) {
    if (value) {
      const {
        textField = "text",
        checkedField = "checked",
        clsField = "cls",
        checkedIcon = "b-icon b-icon-checked",
        uncheckedIcon = "b-icon b-icon-unchecked"
      } = config;
      if (this.firstRender !== false) {
        const dataField = taskRecord.getFieldDefinition(config.field);
        if (!dataField.isArrayDataField) {
          throw new Error('TodoListItem has to be mapped to a field with `type : "array"`');
        }
      }
      domConfig.children = value.map((todo, index) => ({
        class: {
          "b-taskboard-todolist-todo": 1,
          [todo[clsField]]: todo[clsField],
          "b-checked": todo[checkedField]
        },
        children: {
          icon: {
            tag: "i",
            class: todo[checkedField] ? checkedIcon : uncheckedIcon
          },
          text: {
            tag: "span",
            text: todo[textField]
          }
        },
        elementData: {
          index
        }
      }));
      this.firstRender = false;
    }
  }
  static onClick({ source: taskBoard, taskRecord, event, config }) {
    const element = event.target.closest(".b-taskboard-todolist-todo");
    if (element && !taskRecord.readOnly) {
      const { checkedField = "checked", field } = config, { index } = element.elementData, clone = taskRecord.getValue(field).slice(), todo = clone[index];
      todo[checkedField] = !todo[checkedField];
      taskRecord.setValue(field, clone);
      taskBoard.trigger("todoToggle", { taskRecord, todo, checked: todo[checkedField], element, event });
      event.preventDefault();
    }
  }
  // Prevent editor from opening when dbl clicking a todo item
  static onDblClick({ event }) {
    event.preventDefault();
  }
};
__publicField(TodoListItem, "$name", "TodoListItem");
__publicField(TodoListItem, "type", "todoList");
/**
 * Name of a property on a todo item to display as its text.
 *
 * @config {String} textField
 * @category Common
 * @default text
 */
/**
 * Name of a property on a todo item to use for the checkbox. The property is expected to be a boolean.
 *
 * @config {String} checkedField
 * @category Common
 * @default checked
 */
/**
 * Name of a property on a todo item whose value will be added as a CSS class to the todo item.
 *
 * @config {String} clsField
 * @category Common
 * @default cls
 */
// private for now:
// checkedIcon
// uncheckedIcon
/**
 * @hideconfigs editor
 */
__publicField(TodoListItem, "defaultEditor", null);
TodoListItem.initClass();
TodoListItem._$name = "TodoListItem";

// ../Scheduler/lib/Scheduler/crud/mixin/CrudManagerView.js
var CrudManagerView_default = (Target) => {
  var _a2;
  return _a2 = class extends Target.mixin(LoadMaskable_default) {
    static get $name() {
      return "CrudManagerView";
    }
    //region Init
    afterConstruct() {
      super.afterConstruct();
      const { crudManager, project } = this;
      if (this.loadMask && (crudManager || project).isCrudManagerLoading) {
        this.onCrudManagerLoadStart();
      }
    }
    //endregion
    /**
     * Applies the {@link Scheduler.crud.mixin.CrudManagerView#config-syncMask} as the
     * {@link Core.widget.Widget#config-masked mask} for this widget.
     * @internal
     */
    applySyncMask() {
      const { syncMask } = this;
      if (syncMask) {
        this.masked = Mask.mergeConfigs(this.loadMaskDefaults, syncMask);
      }
    }
    /**
     * Hooks up crud manager listeners
     * @private
     * @category Store
     */
    bindCrudManager(crudManager) {
      this.detachListeners("crudManager");
      let additionalListeners = {};
      if (!this.isTaskBoardBase) {
        additionalListeners = {
          beforeApplyResponse: "onCrudManagerBeforeApplyResponse",
          applyResponse: "onCrudManagerApplyResponse",
          beforeLoadCrudManagerData: "onCrudManagerBeforeLoadCrudManagerData",
          loadCrudManagerData: "onCrudManagerLoadCrudManagerData"
        };
      }
      crudManager == null ? void 0 : crudManager.ion({
        name: "crudManager",
        loadStart: "onCrudManagerLoadStart",
        beforeSend: "onCrudManagerBeforeSend",
        load: "onCrudManagerLoad",
        loadCanceled: "onCrudManagerLoadCanceled",
        syncStart: "onCrudManagerSyncStart",
        sync: "onCrudManagerSync",
        syncCanceled: "onCrudManagerSyncCanceled",
        requestFail: "onCrudManagerRequestFail",
        responseReceived: "onAjaxTransportResponseReceived",
        ...additionalListeners,
        thisObj: this
      });
    }
    onCrudManagerBeforeSend({ params }) {
      var _a3;
      (_a3 = this.applyStartEndParameters) == null ? void 0 : _a3.call(this, params);
    }
    onCrudManagerLoadStart() {
      var _a3;
      this.applyLoadMask();
      (_a3 = this.toggleEmptyText) == null ? void 0 : _a3.call(this);
    }
    onCrudManagerSyncStart() {
      this.applySyncMask();
    }
    onCrudManagerBeforeApplyResponse() {
      this.suspendRefresh();
    }
    onCrudManagerApplyResponse() {
      this.resumeRefresh(true);
    }
    onCrudManagerBeforeLoadCrudManagerData() {
      if (!this.crudManager.applyingLoadResponse) {
        this.suspendRefresh();
      }
    }
    async onCrudManagerLoadCrudManagerData() {
      if (!this.crudManager.applyingLoadResponse) {
        await this.project.commitAsync();
        !this.isDestroyed && this.resumeRefresh(true);
      }
    }
    onCrudManagerRequestFinalize(successful = true, requestType, response) {
      var _a3;
      const me = this;
      if (successful) {
        (_a3 = me.toggleEmptyText) == null ? void 0 : _a3.call(me);
      } else {
        if (!me.masked) {
          me.applyLoadMask();
        }
        me.applyMaskError(
          `<div class="b-grid-load-failure">
                    <div class="b-grid-load-fail">${me.L(`L{GridBase.${requestType}FailedMessage}`)}</div>
                    ${response && response.message ? `<div class="b-grid-load-fail">${me.L("L{CrudManagerView.serverResponseLabel}")} ${response.message}</div>` : ""}
                </div>`
        );
      }
    }
    onCrudManagerLoadCanceled() {
      this.onCrudManagerRequestFinalize(true, "load");
    }
    onCrudManagerSyncCanceled() {
      this.onCrudManagerRequestFinalize(true, "sync");
    }
    onCrudManagerLoad() {
      this.onCrudManagerRequestFinalize(true, "load");
    }
    onCrudManagerSync() {
      this.onCrudManagerRequestFinalize(true, "sync");
    }
    onCrudManagerRequestFail({ requestType, response }) {
      this.onCrudManagerRequestFinalize(false, requestType, response);
    }
    onAjaxTransportResponseReceived() {
      const me = this;
      if (me.clearMaskDelay != null) {
        me.setTimeout(() => me.masked = null, me.clearMaskDelay);
      } else {
        me.masked = null;
      }
    }
    get widgetClass() {
    }
  }, __publicField(_a2, "config", {
    clearMaskDelay: null,
    // Test environment may be in a poll wait for mask to disappear.
    // Hiding the mask immediately, before the load sequence ends releases it too early
    testConfig: {
      clearMaskDelay: 0
    }
  }), _a2;
};

// lib/TaskBoard/localization/En.js
var locale3 = {
  localeName: "En",
  localeDesc: "English (US)",
  localeCode: "en-US",
  GridBase: {
    loadFailedMessage: "Data loading failed!",
    syncFailedMessage: "Data synchronization failed!"
  },
  CrudManagerView: {
    serverResponseLabel: "Server response:"
  },
  TaskBoard: {
    column: "column",
    columns: "columns",
    Columns: "Columns",
    swimlane: "swimlane",
    swimlanes: "swimlanes",
    Swimlanes: "Swimlanes",
    task: "task",
    tasks: "tasks",
    addTask: "Add L{TaskBoard.task}",
    cancel: "Cancel",
    changeColumn: "Change L{TaskBoard.column}",
    changeSwimlane: "Change L{TaskBoard.swimlane}",
    collapse: (text) => `Collapse ${text}`,
    color: "Color",
    description: "Description",
    editTask: "Edit L{TaskBoard.task}",
    expand: (text) => `Expand ${text}`,
    filterColumns: "Filter L{TaskBoard.columns}",
    filterSwimlanes: "Filter L{TaskBoard.swimlanes}",
    filterTasks: "Filter L{TaskBoard.tasks}",
    moveColumnLeft: "Move L{TaskBoard.column} left",
    moveColumnRight: "Move L{TaskBoard.column} right",
    name: "Name",
    newTaskName: "New L{TaskBoard.task}",
    removeTask: "Remove L{TaskBoard.task}",
    removeTasks: "Remove L{TaskBoard.tasks}",
    resources: "Resources",
    save: "Save",
    scrollToColumn: "Scroll to L{TaskBoard.column}",
    scrollToSwimlane: "Scroll to L{TaskBoard.swimlane}",
    zoom: "Zoom"
  },
  TodoListField: {
    add: "Add",
    newTodo: "New todo"
  },
  UndoRedo: {
    UndoLastAction: "Undo",
    RedoLastAction: "Redo"
  }
};
var En_default2 = LocaleHelper.publishLocale(locale3);

// lib/TaskBoard/view/TaskBoardBase.js
var weightSorter = (a, b) => a.weight - b.weight;
var TaskBoardBase = class extends Panel.mixin(
  Pluggable_default,
  State_default,
  Featureable_default,
  Styleable_default,
  CrudManagerView_default,
  ExpandCollapse_default,
  Responsive_default,
  ResponsiveCards_default,
  TaskBoardColumns_default,
  TaskBoardDom_default,
  TaskBoardDomEvents_default,
  TaskBoardScroll_default,
  TaskBoardStores_default,
  TaskBoardSwimlanes_default,
  TaskBoardVirtualization_default,
  TaskItems_default,
  TaskNavigation_default,
  TaskSelection_default
) {
  constructor() {
    super(...arguments);
    __publicField(this, "isInitiallyComposed", false);
    __publicField(this, "domTransitionSuspended", 0);
    __publicField(this, "columnRecomposeQueue", /* @__PURE__ */ new Map());
  }
  //endregion
  //region Overrides
  onPaintOverride() {
  }
  onInternalPaint(...args) {
    if (this.onPaintOverride()) {
      return;
    }
    super.onInternalPaint(...args);
  }
  //endregion
  //region Type assertions and changers/updaters
  changeResourceImagePath(resourceImagePath) {
    ObjectHelper.assertString(resourceImagePath, "resourceImagePath");
    return resourceImagePath;
  }
  changeUseDomTransition(useDomTransition) {
    ObjectHelper.assertBoolean(useDomTransition, "useDomTransition");
    return useDomTransition;
  }
  changeStickyHeaders(stickyHeaders) {
    ObjectHelper.assertBoolean(stickyHeaders, "stickyHeaders");
    return stickyHeaders;
  }
  changeScrollManager(scrollManager, oldScrollManager) {
    oldScrollManager == null ? void 0 : oldScrollManager.destroy();
    if (scrollManager) {
      return ScrollManager.new({
        element: this.element,
        owner: this
      }, scrollManager);
    }
    return null;
  }
  changeShowCountInHeader(showCountInHeader) {
    ObjectHelper.assertBoolean(showCountInHeader, "showCountInHeader");
    return showCountInHeader;
  }
  changeTasksPerRow(tasksPerRow) {
    ObjectHelper.assertNumber(tasksPerRow, "tasksPerRow");
    return tasksPerRow;
  }
  changeSwimlaneRenderer(swimlaneRenderer) {
    ObjectHelper.assertFunction(swimlaneRenderer, "swimlaneRenderer");
    return swimlaneRenderer;
  }
  changeTaskRenderer(taskRenderer) {
    ObjectHelper.assertFunction(taskRenderer, "taskRenderer");
    return taskRenderer;
  }
  changeTaskSorterFn(fn2) {
    if (fn2 === true) {
      return weightSorter;
    }
    fn2 && ObjectHelper.assertFunction(fn2, "taskSorterFn");
    return fn2;
  }
  //endregion
  //region Recompose columns
  // Queue a column for recomposition on next frame
  queueColumnRecompose(columnRecord, swimlaneRecord) {
    this.columnRecomposeQueue.set(`${columnRecord.id}.-.${swimlaneRecord == null ? void 0 : swimlaneRecord.id}`, { columnRecord, swimlaneRecord });
    this.recomposeColumns();
  }
  // RAF function to recompose all queued columns
  recomposeColumns() {
    for (const [, { columnRecord, swimlaneRecord }] of this.columnRecomposeQueue) {
      this.recomposeColumn(columnRecord, swimlaneRecord);
    }
    this.columnRecomposeQueue.clear();
  }
  // Recompose a single column / swimlane intersection
  recomposeColumn(columnRecord, swimlaneRecord) {
    const element = this.getSwimlaneColumnElement(swimlaneRecord, columnRecord), domConfig = DomHelper.normalizeChildren(this.renderColumn(swimlaneRecord, columnRecord));
    domConfig.onlyChildren = true;
    DomSync.sync({
      targetElement: element,
      domConfig,
      callback: this.domSyncCallback,
      syncOptions: {
        syncIdField: "column",
        releaseThreshold: 0
      }
    });
  }
  //endregion
  //region Render
  // Creates a DOM config for a single card, calling any configured taskRenderer() in the process
  renderCard(taskRecord, columnRecord, swimlaneRecord) {
    var _a2, _b, _c;
    const overriddenCard = super.renderCard(taskRecord, columnRecord, swimlaneRecord);
    if (overriddenCard) {
      return overriddenCard;
    }
    const me = this, { id, domId, eventColor, weight } = taskRecord, color = eventColor || (swimlaneRecord == null ? void 0 : swimlaneRecord.color) || columnRecord.color, namedColor = DomHelper.isNamedColor(color) ? color : null, cardSize = me.getCardSize(columnRecord, swimlaneRecord), cardConfig = {
      id: `${me.id}-card-${domId}`,
      class: {
        "b-taskboard-card": true,
        [`b-taskboard-color-${namedColor}`]: namedColor,
        "b-readonly": taskRecord.readOnly,
        ...taskRecord.cls
      },
      tabIndex: 0,
      dataset: {
        task: domId,
        column: columnRecord.id,
        lane: swimlaneRecord == null ? void 0 : swimlaneRecord.id,
        weight,
        domTransition: true
      },
      style: {
        color: namedColor ? null : color,
        height: (_b = (_a2 = me.getTaskHeight) == null ? void 0 : _a2.call(me, taskRecord)) != null ? _b : null
      },
      elementData: {
        elementType: "task",
        taskId: id,
        taskRecord,
        columnRecord,
        swimlaneRecord
      },
      children: {
        header: {
          tag: "header",
          class: {
            "b-taskboard-card-header": 1
          },
          children: {},
          syncOptions: {
            syncIdField: "role"
          }
        },
        body: {
          tag: "section",
          class: {
            "b-taskboard-card-body": 1
          },
          children: {},
          syncOptions: {
            syncIdField: "role"
          }
        },
        footer: {
          tag: "footer",
          class: {
            "b-taskboard-card-footer": 1
          },
          children: {},
          syncOptions: {
            syncIdField: "role"
          }
        }
      }
    }, { children } = cardConfig, { header, body, footer } = children;
    me.populateCard({
      taskRecord,
      columnRecord,
      swimlaneRecord,
      cardConfig,
      cardSize
    });
    (_c = me.taskRenderer) == null ? void 0 : _c.call(me, {
      taskRecord,
      columnRecord,
      swimlaneRecord,
      cardConfig,
      cardSize
    });
    if (header.html == null && header.text == null && (!header.children || Object.keys(header.children).length === 0)) {
      children.header = null;
    }
    if (body.html == null && body.text == null && (!body.children || Object.keys(body.children).length === 0)) {
      children.body = null;
    }
    if (footer.html == null && footer.text == null && (!footer.children || Object.keys(footer.children).length === 0)) {
      children.footer = null;
    }
    return cardConfig;
  }
  renderColumnHeader(columnRecord) {
    var _a2, _b, _c;
    const me = this, { text, id, domId, width, flex, minWidth, color, tooltip } = columnRecord, namedColor = DomHelper.isNamedColor(color) ? color : null, columnHeaderConfig = {
      id: `${me.id}-column-header-${domId}`,
      class: {
        "b-taskboard-column-header": 1,
        "b-fixed-width": width && !flex,
        [`b-taskboard-color-${namedColor}`]: namedColor,
        "b-last": columnRecord === this.columns.last
      },
      style: {
        color: namedColor ? null : color,
        width,
        flex,
        minWidth
      },
      children: {
        padder: {
          class: {
            "b-taskboard-column-header-padder": 1
          },
          children: {
            title: {
              class: {
                "b-taskboard-column-title": 1
              },
              dataset: {
                btip: tooltip
              },
              children: [
                {
                  tag: "span",
                  class: "b-column-title-text",
                  text
                },
                me.showCountInHeader && {
                  tag: "span",
                  class: {
                    "b-taskboard-column-count": 1
                  },
                  html: `(${(_b = (_a2 = me.getColumnTasks(columnRecord)) == null ? void 0 : _a2.length) != null ? _b : 0})`
                }
              ]
            }
          }
        }
      },
      dataset: {
        column: domId,
        domTransition: true
      },
      elementData: {
        elementType: "columnHeader",
        columnId: id
      }
    };
    Tooltip.showOverflow = true;
    me.populateColumnHeader({
      columnRecord,
      columnHeaderConfig
    });
    (_c = me.columnHeaderRenderer) == null ? void 0 : _c.call(me, {
      columnRecord,
      columnHeaderConfig
    });
    return columnHeaderConfig;
  }
  renderColumn(swimlaneRecord, columnRecord) {
    var _a2, _b, _c;
    const me = this, {
      taskSorterFn,
      stretchCards,
      columnField,
      swimlaneField
    } = me, {
      width,
      flex,
      id,
      domId,
      minWidth,
      color
    } = columnRecord, { taskStore } = me.project, tasks = taskStore.isTree ? taskStore.query(
      (r) => r[columnField] === id && (!swimlaneField || !swimlaneRecord || r[swimlaneField] === swimlaneRecord.id)
      // Might have no lanes
    ) : Array.from(taskStore.storage.findItem(
      "columnSwimlaneIntersection",
      `${columnRecord.id}-/-${(_a2 = swimlaneRecord == null ? void 0 : swimlaneRecord.id) != null ? _a2 : "default"}`
    ) || []), perRow = me.getTasksPerRow(columnRecord, swimlaneRecord), elementId = `${me.id}-column-${(_b = swimlaneRecord == null ? void 0 : swimlaneRecord.domId) != null ? _b : "default"}-${domId}`, namedColor = DomHelper.isNamedColor(color) ? color : null, columnConfig = {
      id: elementId,
      class: {
        "b-taskboard-column": 1,
        "b-fixed-width": width && !flex,
        [`b-${perRow}-task${perRow > 1 ? "s" : ""}-per-row`]: 1,
        "b-inline": perRow > 1,
        [`b-taskboard-color-${namedColor}`]: namedColor,
        "b-last": columnRecord === this.columns.last
      },
      style: {
        color: namedColor ? null : color,
        width,
        flex,
        minWidth
      },
      dataset: {
        column: domId,
        lane: swimlaneRecord == null ? void 0 : swimlaneRecord.id,
        domTransition: true
      },
      elementData: {
        elementType: "column",
        columnId: id,
        laneId: swimlaneRecord == null ? void 0 : swimlaneRecord.id
      },
      // Cards
      children: {
        body: {
          id: `${elementId}-body`,
          class: {
            "b-taskboard-column-body": 1
          },
          dataset: {
            role: "body",
            domTransition: true
          },
          children: [
            {
              class: {
                "b-taskboard-column-body-inner": 1
              },
              style: {
                "grid-template-columns": `repeat(${stretchCards ? Math.min(perRow, tasks.length) : perRow}, 1fr)`
              },
              dataset: {
                role: "inner",
                domTransition: true
              },
              children: (() => {
                if (taskSorterFn) {
                  tasks.sort(taskSorterFn);
                } else {
                  tasks.sort((a, b) => taskStore.indexOf(a) - taskStore.indexOf(b));
                }
                return tasks.map((taskRecord) => me.renderCard(taskRecord, columnRecord, swimlaneRecord));
              })(),
              syncOptions: {
                syncIdField: "task",
                releaseThreshold: me.isVirtualized ? 1e3 : 0
              }
            }
          ],
          syncOptions: {
            syncIdField: "role"
          }
        }
      },
      syncOptions: {
        syncIdField: "role"
      }
    };
    me.populateColumn({
      columnRecord,
      swimlaneRecord,
      columnConfig
    });
    (_c = me.columnRenderer) == null ? void 0 : _c.call(me, {
      columnRecord,
      swimlaneRecord,
      columnConfig
    });
    return columnConfig;
  }
  renderSwimlane(swimlaneRecord) {
    var _a2, _b, _c;
    const me = this, { showCountInHeader, columns } = me, {
      id = "default",
      domId = "default",
      text,
      height,
      flex,
      color
    } = swimlaneRecord || {}, elementId = `${me.id}-swimlane-${domId}`, namedColor = DomHelper.isNamedColor(color) ? color : null, swimlaneConfig = {
      id: elementId,
      class: {
        "b-taskboard-swimlane": 1,
        "b-fixed-height": height && !flex,
        "b-last": !swimlaneRecord || swimlaneRecord === me.swimlanes.last,
        [`b-taskboard-color-${namedColor}`]: namedColor
      },
      style: {
        color: namedColor ? null : color,
        height,
        flex
      },
      dataset: {
        lane: domId,
        domTransition: true
      },
      elementData: {
        elementType: "swimlane",
        laneId: id
      },
      children: {
        // If a lane is defined, it has a header
        header: swimlaneRecord && {
          id: `${elementId}-header`,
          tag: "header",
          class: {
            "b-taskboard-swimlane-header": 1
          },
          dataset: {
            role: "header",
            domTransition: "preserve-padding"
          },
          children: {
            title: {
              class: {
                "b-taskboard-swimlane-title": 1
              },
              children: {
                text,
                count: showCountInHeader && {
                  tag: "span",
                  class: {
                    "b-taskboard-swimlane-count": 1
                  },
                  text: `(${(_b = (_a2 = me.getSwimlaneTasks(swimlaneRecord)) == null ? void 0 : _a2.size) != null ? _b : 0})`
                }
              }
            }
          }
        },
        // Lane or no lane, there is always a body to contain columns
        body: {
          id: `${elementId}-body`,
          class: {
            "b-taskboard-swimlane-body": 1
          },
          dataset: {
            role: "body",
            domTransition: true
          },
          // Columns within the lane
          children: columns.map(
            (column) => !column.hidden && me.renderColumn(swimlaneRecord, column)
          ),
          syncOptions: {
            syncIdField: "column",
            releaseThreshold: 0
          }
        }
      },
      syncOptions: {
        syncIdField: "role"
      }
    };
    me.populateSwimlane({
      swimlaneRecord,
      swimlaneConfig
    });
    (_c = me.swimlaneRenderer) == null ? void 0 : _c.call(me, {
      swimlaneRecord,
      swimlaneConfig
    });
    return swimlaneConfig;
  }
  // Creates a DOM config for the entire TaskBoard, rendered to panels body
  get bodyConfig() {
    const me = this, {
      /* eslint-disable no-unused-vars */
      stickyHeaders,
      showCountInHeader,
      columns,
      columnField,
      swimlaneField,
      tasksPerRow,
      headerItems,
      bodyItems,
      footerItems,
      selectedTasks,
      showCollapseInHeader,
      showCollapseTooltip,
      taskSorterFn,
      stretchCards
      /* eslint-enable no-unused-vars */
    } = me;
    if (!me.rendered) {
      me.setTimeout(() => me.recompose(), 0);
      return {
        // Required by panel, it expects a bodyElement reference
        reference: "bodyElement",
        // Listeners are only set up on first sync, has to go here (not internalListeners no purpose, these are
        // EventHelper listeners)
        // eslint-disable-next-line bryntum/no-listeners-in-lib
        listeners: ObjectHelper.assign({ thisObj: me }, me.domListeners)
      };
    }
    const bodyConfig = {
      // Save some processing by not cloning the config, it is regenerated on every compose anyway
      skipClone: true,
      reference: "bodyElement",
      class: {
        "b-taskboard-body": 1,
        "b-sticky-headers": stickyHeaders
      },
      children: [
        // Column headers
        {
          tag: "header",
          id: `${me.id}-column-headers`,
          class: {
            "b-taskboard-column-headers": 1
          },
          children: columns.map((column) => !column.hidden && me.renderColumnHeader(column)),
          dataset: {
            lane: "header",
            domTransition: true
          },
          syncOptions: {
            syncIdField: "column"
          }
        }
      ],
      syncOptions: {
        syncIdField: "lane",
        releaseThreshold: 0,
        ignoreRefs: "children"
        // References in "children" should not be hoisted to the panel
      }
    };
    let { swimlanes } = me;
    if (!(swimlanes == null ? void 0 : swimlanes.count)) {
      swimlanes = [null];
    }
    for (const lane of swimlanes) {
      if (!(lane == null ? void 0 : lane.hidden)) {
        bodyConfig.children.push(me.renderSwimlane(lane));
      }
    }
    me.populateBody({
      bodyConfig
    });
    me.isComposed = true;
    return bodyConfig;
  }
  // For chaining, to decorate dom config
  populateCard(args) {
    var _a2;
    (_a2 = super.populateCard) == null ? void 0 : _a2.call(this, args);
  }
  populateColumn(args) {
    var _a2;
    (_a2 = super.populateColumn) == null ? void 0 : _a2.call(this, args);
  }
  populateColumnHeader(args) {
    var _a2;
    (_a2 = super.populateColumnHeader) == null ? void 0 : _a2.call(this, args);
  }
  populateSwimlane(args) {
    var _a2;
    (_a2 = super.populateSwimlane) == null ? void 0 : _a2.call(this, args);
  }
  populateBody(args) {
    var _a2;
    (_a2 = super.populateBody) == null ? void 0 : _a2.call(this, args);
  }
  afterRecompose() {
    super.afterRecompose();
    const me = this;
    if (!me.isInitiallyComposed && me.isComposed) {
      me.isInitiallyComposed = true;
      me.initialCompose();
    }
    if (me.project.taskStore.count > 0) {
      me.trigger("renderTasks", { taskRecords: me.project.taskStore.allRecords });
    }
    me.transitionRecompose = null;
  }
  // For chaining, replaces render() since we don't do full compose on render
  initialCompose() {
    this.trigger("initialCompose");
  }
  // For chaining, to react to element changes
  onRenderColumn() {
  }
  onRemoveColumnElement() {
  }
  onRenderSwimlane() {
  }
  onRemoveSwimlaneElement() {
  }
  //endregion
  //region Transition - experimental
  // Prevent dom transitions until resumed
  suspendDomTransition() {
    this.domTransitionSuspended++;
  }
  // Resume dom transitions
  resumeDomTransition() {
    this.domTransitionSuspended--;
  }
  // Recompose transitioning dom
  recomposeWithDomTransition(options) {
    const me = this;
    if (me.useDomTransition && !me.domTransitionSuspended) {
      me.transitionRecompose = {
        selector: "[data-dom-transition]",
        duration: 300,
        element: me._bodyElement,
        // _ needed to not flush recompose if we are dirty
        ...options
      };
    }
    if (me.recompose.suspended) {
      me._recomposeQueued = true;
    } else {
      me.recompose();
    }
  }
  resumeRecompose() {
    super.resumeRecompose();
    if (this._recomposeQueued) {
      this._recomposeQueued = null;
      this.recompose();
    }
  }
  //endregion
  //region Extract configs
  // This function is not meant to be called by any code other than Base#getCurrentConfig().
  // It extracts the current configs for the task board, with special handling for columns
  getCurrentConfig(options) {
    const result = super.getCurrentConfig(options);
    if (result.columns) {
      delete result.columns.modelClass;
    }
    return result;
  }
  //endregion
  // Expected by CrudManagerView
  refresh() {
    this.recompose();
  }
};
//region Config
__publicField(TaskBoardBase, "$name", "TaskBoardBase");
__publicField(TaskBoardBase, "type", "taskboardbase");
__publicField(TaskBoardBase, "featureable", {
  factory: TaskBoardFeature
});
__publicField(TaskBoardBase, "configurable", {
  /** @hideconfigs autoUpdateRecord, defaultFocus, trapFocus, showTooltipWhenDisabled */
  /** @hideproperties firstItem, lastItem, cellInfo, visibleChildCount */
  /** @hidefunctions getAt */
  layout: "vbox",
  /**
   * An object containing Feature configuration objects (or `true` if no configuration is required)
   * keyed by the Feature class name in all lowercase.
   * @config {Object}
   * @category Common
   */
  features: true,
  /**
   * An empty function by default, but provided so that you can override it. This function is called each time
   * a task is rendered into the task board. It allows you to manipulate the DOM config object used for the card
   * before it is synced to DOM, thus giving you control over styling and contents.
   *
   * NOTE: The function is intended for formatting, you should not update records in it since updating records
   * triggers another round of rendering.
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *    taskRenderer({ taskRecord, cardConfig }) {
   *        // Add an icon to all tasks header
   *        cardConfig.children.header.children.icon = {
   *            tag   : 'i',
   *            class : 'b-fa b-fa-beer'
   *        }
   *    }
   * });
   * ```
   *
   * For more information, see the [Customize task contents guide](#TaskBoard/guides/customization/taskcontents.md).
   *
   * @config {Function}
   * @param {Object} detail An object containing the information needed to render a task.
   * @param {TaskBoard.model.TaskModel} detail.taskRecord The task record.
   * @param {TaskBoard.model.ColumnModel} detail.columnRecord The column the task will be displayed in.
   * @param {TaskBoard.model.SwimlaneModel} detail.swimlaneRecord The swimlane the task will be displayed in.
   * @param {DomConfig} detail.cardConfig DOM config object for the cards element
   * @returns {void}
   * @category Task content
   */
  taskRenderer: null,
  /**
   * An empty function by default, but provided so that you can override it. This function is called each time
   * a swimlane is rendered into the task board. It allows you to manipulate the DOM config object used for the
   * swimlane before it is synced to DOM, thus giving you control over styling and contents.
   *
   * ```javascript
   * const taskBoard = new TaskBoard({
   *    swimlaneRenderer({ swimlaneRecord, swimlaneConfig }) {
   *        // Add an icon to all swimlane headers
   *        swimlaneConfig.children.header.children.icon = {
   *            tag   : 'i',
   *            class : 'b-fa b-fa-dog'
   *        }
   *    }
   * });
   * ```
   *
   * @config {Function}
   * @param {Object} detail An object containing the information needed to render a swimlane.
   * @param {TaskBoard.model.SwimlaneModel} detail.swimlaneRecord The swimlane.
   * @param {DomConfig} detail.swimlaneConfig DOM config object for the swimlane
   * @returns {void}
   * @category Advanced
   */
  swimlaneRenderer: null,
  /**
   * Controls how many cards are rendered to a row in each column. Can be controlled on a per column basis by
   * setting {@link TaskBoard.model.ColumnModel#field-tasksPerRow}
   *
   * ```javascript
   * new TaskBoard({
   *   tasksPerRow : 3
   * });
   * ```
   *
   * @config {Number}
   * @category Common
   */
  tasksPerRow: 1,
  /**
   * Setting this will cause cards to expand to share the available width if there are fewer than
   * {@link #config-tasksPerRow}.
   *
   * By default, the {@link #config-tasksPerRow} always applies, and if it is 3, then a single
   * card in a column will be 33% of the available width.
   *
   * To have fewer cards than the {@link #config-tasksPerRow} evenly share available column width,
   * configure this as `true`;
   * @prp {Boolean}
   * @category Common
   */
  stretchCards: null,
  /**
   * Show task count for a column in its header, appended after the title
   *
   * ```javascript
   * new TaskBoard({
   *   showCountInHeader : false
   * });
   * ```
   *
   * @config {Boolean}
   * @default
   * @category Common
   */
  showCountInHeader: true,
  /**
   * Makes column and swimlane headers sticky
   *
   * ```javascript
   * new TaskBoard({
   *   stickyHeaders : true
   * });
   * ```
   *
   * @config {Boolean}
   * @default
   * @category Common
   */
  stickyHeaders: false,
  /**
   * Experimental, animate actions that cannot be animated using CSS transitions. Currently includes:
   * * Programmatically moving tasks
   * * Moving tasks using the task editor
   * * Adding tasks
   * * Removing tasks
   * * Sorting tasks
   * * Hiding/showing/filtering columns
   * * Hiding/showing/filtering swimlanes
   *
   * ```javascript
   * new TaskBoard({
   *   useDomTransition : true
   * });
   * ```
   * **NOTE**: This flag is not supported for Lightning Web Components
   * @config {Boolean}
   * @category Experimental
   */
  useDomTransition: false,
  /**
   * Path to load resource images from. Used by the for example the resource picker in the task editor and by the
   * ResourceAvatars task item. Set this to display miniature images for each resource using their `image` field.
   *
   * **NOTE**: The path should end with a `/`:
   *
   * ```javascript
   * new TaskBoard({
   *   resourceImagePath : 'images/resources/'
   * });
   * ```
   *
   * @config {String}
   * @category Common
   */
  resourceImagePath: null,
  /**
   * CSS variable prefix, appended to the keys used in {@link #config-css}.
   *
   * Normally you do not need to change this value.
   *
   * @default
   * @config {String}
   * @category CSS
   */
  cssVarPrefix: "taskboard",
  /**
   * Configuration values for the {@link Core.util.ScrollManager} class. It is used to manage column/body
   * scrolling during task, column or swimlane drag.
   * ```javascript
   * new TaskBoard({
   *     scrollManager : {
   *         zoneWidth   : 100, // increase zone size
   *         scrollSpeed : 3    // and scroll speed
   *     }
   * })
   * ```
   * @config {ScrollManagerConfig}
   * @category Scrolling
   */
  scrollManager: {
    value: {},
    $config: ["nullify", "lazy"]
  },
  /**
   * Allows sorting tasks in the UI independent of how they are sorted in the task store.
   *
   * Specify `true` to force sorting tasks by {@link TaskBoard/model/TaskModel#field-weight}.
   *
   * Supply a [sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)
   * function to force a custom sort order.
   *
   * This is likely something you will want to use if combining TaskBoard with other products, sharing the
   * project. Without this, sorting tasks in for example Gantt will also rearrange the cards on the board.
   *
   * As described above it accepts either a boolean or a Function, but it always returns a sorter function.
   *
   * @prp {Function} taskSorterFn
   * @accepts {Boolean|Function}
   * @config {Function}
   * @param {TaskBoard.model.TaskModel} first The first task to compare
   * @param {TaskBoard.model.TaskModel} second The second task to compare
   * @returns {Number} Return `1` if first task is greater than second task, `-1` if the opposite is true or `0`
   * if they are equal
   * @category Advanced
   */
  taskSorterFn: null,
  /**
   * See {@link TaskBoard.view.TaskBoard#keyboard-shortcuts Keyboard shortcuts} for details
   * @config {Object<String,String>} keyMap
   * @category Common
   */
  contentElMutationObserver: false,
  textContent: false,
  // We can scroll in both axes.
  // Scrollable also syncs the b-horizontal-overflow and b-vertical-overflow classes
  // to allow styles to depend upon overflow state.
  scrollable: true
});
__publicField(TaskBoardBase, "delayable", {
  recomposeColumns: "raf"
});
TaskBoardBase.initClass();
VersionHelper.setVersion("taskboard", "5.6.2");
TaskBoardBase._$name = "TaskBoardBase";

// lib/TaskBoard/view/item/TaskMenuItem.js
var TaskMenuItem = class extends TaskItem {
  static render({ taskBoard, domConfig }) {
    if (!taskBoard.features.taskMenu || taskBoard.features.taskMenu.disabled) {
      return false;
    }
    domConfig.tag = "button";
    domConfig.class["b-icon b-icon-menu-horizontal"] = 1;
  }
  static onClick({ source: taskBoard, event }) {
    var _a2;
    (_a2 = taskBoard.features.taskMenu) == null ? void 0 : _a2.showContextMenu(event, { target: event.target });
  }
};
__publicField(TaskMenuItem, "$name", "TaskMenuItem");
__publicField(TaskMenuItem, "type", "taskMenu");
/**
 * @hideconfigs editor
 */
__publicField(TaskMenuItem, "defaultEditor", null);
TaskMenuItem.initClass();
TaskMenuItem._$name = "TaskMenuItem";

// lib/TaskBoard/view/TaskBoard.js
var TaskBoard = class extends TaskBoardBase {
};
__publicField(TaskBoard, "$name", "TaskBoard");
__publicField(TaskBoard, "type", "taskboard");
__publicField(TaskBoard, "configurable", {
  //region Hidden members
  /**
   * @hideconfigs crudManager, crudManagerClass, contentElementCls, htmlCls, defaults, hideWhenEmpty, itemCls, items, layout, layoutStyle, lazyItems, namedItems, textContent, content, html, defaultBindProperty, monitorResize, ripple, tooltip, tag, textAlign, preventTooltipOnTouch
   */
  /**
   * @hideproperties $name, isSettingValues, isValid, items, layout, record, values, content, contentElement, focusElement, html, overflowElement, layoutStyle, tooltip, scrollable
   */
  /**
   * @hidefunctions attachTooltip, isOfTypeName, mixin, optionalL, callback, resolveCallback, add, getWidgetById, insert, processWidgetConfig, remove, removeAll, construct, doDestroy, updateLocalization, compose, eachAncestor, eachWidget, query, queryAll, L
   */
  /**
   * @event beforeSetRecord
   * @hide
   */
  //endregion
  features: {
    columnHeaderMenu: true,
    columnToolbars: true,
    taskDrag: true,
    taskDragSelect: true,
    taskEdit: true,
    taskMenu: true
  }
});
TaskBoard.initClass();
TaskBoard._$name = "TaskBoard";

// lib/TaskBoard/widget/ColumnFilterField.js
var ColumnFilterField = class extends FilterField.mixin(TaskBoardLinked_default) {
};
__publicField(ColumnFilterField, "$name", "ColumnFilterField");
__publicField(ColumnFilterField, "type", "columnfilterfield");
__publicField(ColumnFilterField, "configurable", {
  /**
   * @hideconfigs store, filterFunction
   */
  store: "this.taskBoard.columns",
  /**
   * The ColumnModel field name to filter by, defaults to `'text'`.
   * @config {String}
   * @default
   * @category Common
   */
  field: "text",
  /**
   * Label, defaults to a localized version of `'Filter columns'`.
   *
   * Content is determined by the `TaskBoard.filterColumns` key in the applied locale.
   *
   * @config {String}
   * @category Label
   */
  label: "L{TaskBoard.filterColumns}",
  width: "20em",
  triggers: {
    filter: {
      cls: "b-icon b-icon-filter",
      align: "start"
    }
  }
});
ColumnFilterField.initClass();
ColumnFilterField._$name = "ColumnFilterField";

// lib/TaskBoard/widget/ColumnPickerButton.js
var ColumnPickerButton = class extends Button.mixin(TaskBoardLinked_default) {
  onToggleColumn({ item }) {
    item.column.hidden = !item.checked;
  }
  // Populate menu before each show to make sure it is up to date
  onMenuBeforeShow(info) {
    super.onMenuBeforeShow(info);
    info.source.items = this.taskBoard.columns.map((column) => ({
      ref: column.id,
      text: StringHelper.encodeHtml(column.text),
      checked: !column.hidden,
      column,
      onItem: "up.onToggleColumn"
    }));
  }
};
__publicField(ColumnPickerButton, "$name", "ColumnPickerButton");
__publicField(ColumnPickerButton, "type", "columnpickerbutton");
__publicField(ColumnPickerButton, "configurable", {
  text: "L{TaskBoard.Columns}",
  icon: "b-icon-picker",
  pressedIcon: "b-icon-picker-rotated",
  iconAlign: "end",
  menuIcon: null,
  // items null needed to not be considered an object holding menu items
  menu: { items: null }
});
ColumnPickerButton.initClass();
ColumnPickerButton._$name = "ColumnPickerButton";

// lib/TaskBoard/widget/ColumnScrollButton.js
var ColumnScrollButton = class extends Button.mixin(TaskBoardLinked_default) {
  onClickColumn({ item }) {
    this.setTimeout(() => {
      var _a2;
      return (_a2 = this.taskBoard) == null ? void 0 : _a2.scrollToColumn(item.column);
    }, 100);
  }
  changeMenu(menu) {
    if (menu) {
      menu = this.taskBoard.columns.map((column) => ({
        ref: column.id,
        text: StringHelper.encodeHtml(column.text),
        column,
        onItem: "up.onClickColumn"
      }));
    }
    return super.changeMenu(menu);
  }
};
__publicField(ColumnScrollButton, "$name", "ColumnScrollButton");
__publicField(ColumnScrollButton, "type", "columnscrollbutton");
__publicField(ColumnScrollButton, "configurable", {
  text: "L{TaskBoard.scrollToColumn}",
  icon: "b-icon-picker",
  pressedIcon: "b-icon-picker-rotated",
  iconAlign: "end",
  menuIcon: null,
  menu: []
});
ColumnScrollButton.initClass();
ColumnScrollButton._$name = "ColumnScrollButton";

// ../Scheduler/lib/Scheduler/widget/ProjectCombo.js
var ProjectCombo = class extends Combo {
  static get $name() {
    return "ProjectCombo";
  }
  static get type() {
    return "projectcombo";
  }
  static get configurable() {
    return {
      /**
       * Project to reconfigure when picking an item.
       * @config {Scheduler.model.ProjectModel}
       * @category Common
       */
      project: null,
      /**
       * Field used as projects title.
       * @config {String}
       * @default
       * @category Common
       */
      displayField: "title",
      /**
       * Field used as projects load url.
       * @config {String}
       * @default
       * @category Common
       */
      valueField: "url",
      highlightExternalChange: false,
      editable: false
    };
  }
  updateProject(project) {
    var _a2;
    if ((_a2 = project.transport.load) == null ? void 0 : _a2.url) {
      this.value = project.transport.load.url;
    }
  }
  onChange({ value, userAction }) {
    if (userAction && this.project) {
      this.project.transport.load.url = value;
      this.project.load();
    }
  }
};
ProjectCombo.initClass();
ProjectCombo._$name = "ProjectCombo";

// lib/TaskBoard/widget/ProjectCombo.js
var ProjectCombo2 = class extends ProjectCombo.mixin(TaskBoardLinked_default) {
  updateTaskBoard(taskBoard) {
    if (taskBoard) {
      this.project = taskBoard.project;
    }
  }
  afterConfigure() {
    if (!this._taskBoard) {
      this.updateTaskBoard(this.taskBoard);
    }
  }
};
__publicField(ProjectCombo2, "$name", "ProjectCombo");
__publicField(ProjectCombo2, "type", "taskboardprojectcombo");
__publicField(ProjectCombo2, "configurable", {
  /**
   * Project to reconfigure when picking an item. Resolved automatically if a TaskBoard is configured or detected.
   * @config {TaskBoard.model.ProjectModel}
   * @category Common
   */
  project: null
});
ProjectCombo2.initClass();
ProjectCombo2._$name = "ProjectCombo";

// lib/TaskBoard/widget/SwimlaneFilterField.js
var SwimlaneFilterField = class extends FilterField.mixin(TaskBoardLinked_default) {
};
__publicField(SwimlaneFilterField, "$name", "SwimlaneFilterField");
__publicField(SwimlaneFilterField, "type", "swimlanefilterfield");
__publicField(SwimlaneFilterField, "configurable", {
  store: "this.taskBoard.swimlanes",
  field: "text",
  label: "L{TaskBoard.filterSwimlanes}",
  width: "20em",
  triggers: {
    filter: {
      cls: "b-icon b-icon-filter",
      align: "start"
    }
  }
});
SwimlaneFilterField.initClass();
SwimlaneFilterField._$name = "SwimlaneFilterField";

// lib/TaskBoard/widget/SwimlanePickerButton.js
var SwimlanePickerButton = class extends Button.mixin(TaskBoardLinked_default) {
  onToggleSwimlane({ item }) {
    item.swimlane.hidden = !item.checked;
  }
  // Populate menu before each show to make sure it is up to date
  onMenuBeforeShow(info) {
    super.onMenuBeforeShow(info);
    info.source.items = this.taskBoard.swimlanes.map((swimlane) => ({
      ref: swimlane.id,
      text: StringHelper.encodeHtml(swimlane.text),
      checked: !swimlane.hidden,
      swimlane,
      onItem: "up.onToggleSwimlane"
    }));
  }
};
__publicField(SwimlanePickerButton, "$name", "SwimlanePickerButton");
__publicField(SwimlanePickerButton, "type", "swimlanepickerbutton");
__publicField(SwimlanePickerButton, "configurable", {
  text: "L{TaskBoard.Swimlanes}",
  icon: "b-icon-picker",
  pressedIcon: "b-icon-picker-rotated",
  iconAlign: "end",
  menuIcon: null,
  // items null needed to not be considered an object holding menu items
  menu: { items: null }
});
SwimlanePickerButton.initClass();
SwimlanePickerButton._$name = "SwimlanePickerButton";

// lib/TaskBoard/widget/SwimlaneScrollButton.js
var SwimlaneScrollButton = class extends Button.mixin(TaskBoardLinked_default) {
  onClickSwimlane({ item }) {
    this.setTimeout(() => {
      var _a2;
      return (_a2 = this.taskBoard) == null ? void 0 : _a2.scrollToSwimlane(item.swimlane);
    }, 100);
  }
  changeMenu(menu) {
    if (menu) {
      menu = this.taskBoard.swimlanes.map((swimlane) => ({
        ref: swimlane.id,
        text: StringHelper.encodeHtml(swimlane.text),
        swimlane,
        onItem: "up.onClickSwimlane"
      }));
    }
    return super.changeMenu(menu);
  }
};
__publicField(SwimlaneScrollButton, "$name", "SwimlaneScrollButton");
__publicField(SwimlaneScrollButton, "type", "swimlanescrollbutton");
__publicField(SwimlaneScrollButton, "configurable", {
  text: "L{TaskBoard.scrollToSwimlane}",
  icon: "b-icon-picker",
  pressedIcon: "b-icon-picker-rotated",
  iconAlign: "end",
  menuIcon: null,
  menu: []
});
SwimlaneScrollButton.initClass();
SwimlaneScrollButton._$name = "SwimlaneScrollButton";

// lib/TaskBoard/widget/TaskFilterField.js
var TaskFilterField = class extends FilterField.mixin(TaskBoardLinked_default) {
};
__publicField(TaskFilterField, "$name", "TaskFilterField");
__publicField(TaskFilterField, "type", "taskfilterfield");
__publicField(TaskFilterField, "configurable", {
  store: "this.taskBoard.project.taskStore",
  field: "name",
  label: "L{TaskBoard.filterTasks}",
  width: "20em",
  triggers: {
    filter: {
      cls: "b-icon b-icon-filter",
      align: "start"
    }
  }
});
TaskFilterField.initClass();
TaskFilterField._$name = "TaskFilterField";

// lib/TaskBoard/widget/TodoListField.js
var TodoListField = class extends Field {
  compose() {
    const { editableItems } = this;
    return {
      class: {
        "b-editable": editableItems
      }
    };
  }
  changeList(list) {
    return Widget.create(ObjectHelper.assign({
      // List does not support remapping out of the box
      itemTpl: (record) => StringHelper.xss`<div class="b-todo-text">${record.getValue(this.textField)}</div><i class='b-todo-edit b-icon b-icon-edit' data-noselect></i>`
    }, list));
  }
  updateList(list) {
    list.ion({
      item: "onItemClick",
      thisObj: this
    });
    list.ion({
      selectionChange: "onSelectionChange",
      thisObj: this
    });
  }
  changeAddButton(button) {
    const result = Widget.create(button);
    this.ariaElement = result.element;
    return result;
  }
  updateAddButton(button) {
    button.ion({
      click: "onAddClick",
      thisObj: this
    });
  }
  get childItems() {
    return [this.list, this.addButton];
  }
  get inputElement() {
    return this.list.element;
  }
  get innerElements() {
    return super.innerElements.concat(this.addButton.element);
  }
  changeValue(value) {
    value = value || [];
    let autoUpdate = false;
    this.eachAncestor((a) => {
      if (a.autoUpdateRecord) {
        autoUpdate = true;
        return false;
      }
    });
    this.originalValue = autoUpdate ? value : ObjectHelper.clone(value);
    if (value) {
      value = ObjectHelper.clone(value);
      value.forEach((v, i) => {
        v.id = i + 1;
        v.originalIndex = i;
      });
    }
    return value;
  }
  updateValue(value) {
    if (value) {
      const me = this;
      me.list.items = value;
      me.isSettingValue = true;
      me.list.selected.values = value.filter((v) => v[me.checkedField]);
      me.isSettingValue = false;
    }
  }
  get value() {
    return this.originalValue.slice();
  }
  set value(value) {
    super.value = value;
  }
  // Cant be invalid currently
  get isValid() {
    return true;
  }
  // Edit a todo item, using overlaid editor
  editItem(record, element) {
    const me = this, editor = new Editor({
      appendTo: me.element,
      owner: me,
      cls: "b-todo-editor",
      inputField: {
        type: "text",
        triggers: {
          remove: {
            cls: "b-todo-remove b-icon-trash",
            handler() {
              me.removeItem(record);
              editor.cancelEdit();
            }
          }
        }
      },
      // Above modal
      style: "z-index : 20000",
      internalListeners: {
        complete({ value }) {
          me.originalValue[record.originalIndex][me.textField] = value;
          me.triggerFieldChange({ value: me.value, userAction: true });
        },
        finishEdit() {
          editor.destroy();
        },
        thisObj: me
      }
    });
    editor.startEdit({
      target: element,
      record,
      field: me.textField
    });
  }
  // Remove a todo item, updating both the list and the original value
  removeItem(record) {
    const me = this, { originalIndex } = record;
    me.list.store.forEach((r) => {
      if (r.parentIndex > record.parentIndex) {
        r.originalIndex--;
      }
    });
    me.list.store.remove(record);
    me.originalValue.splice(originalIndex, 1);
    me.triggerFieldChange({ value: me.value, userAction: true });
  }
  // Lists selection model is used to check/uncheck todo items. React on changes here
  onSelectionChange() {
    const me = this, { list } = me;
    if (!me.isSettingValue) {
      me.originalValue.forEach((v, i) => {
        const listRecord = list.store.getAt(i);
        if (listRecord) {
          v[me.checkedField] = list.selected.includes(listRecord);
        }
      });
      me.triggerFieldChange({ value: me.value, userAction: true });
    }
  }
  // Clicked on a list item, react if it is on the edit icon
  onItemClick({ record, event }) {
    if (event.target.matches(".b-todo-edit")) {
      this.editItem(record, event.target.closest(".b-list-item"));
    }
  }
  // Clicked the add button, add to original value and then plug it back in to not have to care about syncing it with
  // lists store
  onAddClick() {
    const me = this;
    me.originalValue.push({
      [me.textField]: me.L("L{newTodo}"),
      [me.checkedField]: false
    });
    me.value = me.originalValue;
    me.triggerFieldChange({ value: me.value, userAction: true });
  }
};
__publicField(TodoListField, "$name", "TodoListField");
__publicField(TodoListField, "type", "todolistfield");
__publicField(TodoListField, "alias", "todolist");
__publicField(TodoListField, "configurable", {
  /**
   * Name of a property on a todo item to display as its text.
   *
   * @config {String}
   * @category Common
   * @default
   */
  textField: "text",
  /**
   * Name of a property on a todo item to use for the checkbox. The property is expected to be a boolean.
   *
   * @config {String}
   * @category Common
   * @default
   */
  checkedField: "checked",
  /**
   * Configure as `false` to hide the per item edit button and the add item button. Users can still check/uncheck
   * items.
   *
   * @config {Boolean}
   * @default
   */
  editableItems: true,
  list: {
    type: "list",
    multiSelect: true,
    store: {
      fields: []
    },
    itemIconTpl() {
      return `<i class="b-todo-checkbox b-icon"></i>`;
    }
  },
  addButton: {
    type: "button",
    cls: "b-todo-add",
    icon: "b-icon-add",
    text: "L{TodoListField.add}"
  },
  role: null
});
TodoListField.initClass();
TodoListField._$name = "TodoListField";

// lib/TaskBoard/widget/UndoRedo.js
var UndoRedo = class extends UndoRedoBase.mixin(TaskBoardLinked_default) {
  construct() {
    super.construct(...arguments);
    this.stm = this.taskBoard.project.stm;
  }
};
__publicField(UndoRedo, "$name", "UndoRedo");
__publicField(UndoRedo, "type", "taskboardundoredo");
UndoRedo.initClass();
UndoRedo._$name = "UndoRedo";

// lib/TaskBoard/widget/ZoomSlider.js
var ZoomSlider = class extends Slider.mixin(TaskBoardLinked_default) {
  calculateValue(input) {
    return this.max - input + 1;
  }
  afterConstruct() {
    this.value = this.calculateValue(this.taskBoard.tasksPerRow);
  }
  onInput({ value }) {
    this.taskBoard.tasksPerRow = this.calculateValue(value);
  }
  updateValue(value) {
    super.updateValue(value);
    this.onInput({ value });
  }
  getTooltipHtml(value) {
    const tasksPerRow = this.calculateValue(value);
    return `${tasksPerRow} card${tasksPerRow === 1 ? "" : "s"} per row`;
  }
};
__publicField(ZoomSlider, "$name", "ZoomSlider");
__publicField(ZoomSlider, "type", "zoomslider");
__publicField(ZoomSlider, "configurable", {
  text: "L{TaskBoard.zoom}",
  max: 10,
  min: 1,
  // Override default to avoid hitting updater, value set in afterConstruct
  value: null,
  showValue: false
});
ZoomSlider.initClass();
ZoomSlider._$name = "ZoomSlider";

// ../Scheduler/lib/Scheduler/crud/AbstractCrudManager.js
var AbstractCrudManager = class extends Base.mixin(AbstractCrudManagerMixin_default) {
  //region Default config
  /**
   * The server revision stamp.
   * The _revision stamp_ is a number which should be incremented after each server-side change.
   * This property reflects the current version of the data retrieved from the server and gets updated after each
   * {@link Scheduler/crud/AbstractCrudManagerMixin#function-load} and {@link Scheduler/crud/AbstractCrudManagerMixin#function-sync} call.
   * @property {Number}
   * @readonly
   */
  get revision() {
    return this.crudRevision;
  }
  set revision(value) {
    this.crudRevision = value;
  }
  /**
   * Get or set data of {@link #property-crudStores} as a JSON string.
   *
   * Get a JSON string:
   * ```javascript
   *
   * const jsonString = scheduler.crudManager.json;
   *
   * // returned jsonString:
   * '{"eventsData":[...],"resourcesData":[...],...}'
   *
   * // object representation of the returned jsonString:
   * {
   *     resourcesData    : [...],
   *     eventsData       : [...],
   *     assignmentsData  : [...],
   *     dependenciesData : [...],
   *     timeRangesData   : [...],
   *     // data from other stores
   * }
   * ```
   *
   * Set a JSON string (to populate the CrudManager stores):
   *
   * ```javascript
   * scheduler.crudManager.json = '{"eventsData":[...],"resourcesData":[...],...}'
   * ```
   *
   * @property {String}
   */
  get json() {
    return StringHelper.safeJsonStringify(this);
  }
  set json(json) {
    if (typeof json === "string") {
      json = StringHelper.safeJsonParse(json);
    }
    this.forEachCrudStore((store) => {
      const dataName = `${store.storeId}Data`;
      if (json[dataName]) {
        store.data = json[dataName];
      }
    });
  }
  static get defaultConfig() {
    return {
      /**
       * Sets the list of stores controlled by the CRUD manager.
       *
       * When adding a store to the CrudManager, make sure the server response format is correct for `load` and `sync` requests.
       * Learn more in the [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.
       *
       * Store can be provided as in instance, using its `storeId` or as an {@link #typedef-CrudManagerStoreDescriptor}
       * object.
       * @config {Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]}
       */
      stores: null
      /**
       * Encodes request to the server.
       * @function encode
       * @param {Object} request The request to encode.
       * @returns {String} The encoded request.
       * @abstract
       */
      /**
       * Decodes response from the server.
       * @function decode
       * @param {String} response The response to decode.
       * @returns {Object} The decoded response.
       * @abstract
       */
    };
  }
  //endregion
  //region Init
  construct(config = {}) {
    if (config.stores) {
      config.crudStores = config.stores;
      delete config.stores;
    }
    super.construct(config);
  }
  //endregion
  //region inline data
  /**
   * Returns the data from all CrudManager `crudStores` in a format that can be consumed by `inlineData`.
   *
   * Used by JSON.stringify to correctly convert this CrudManager to json.
   *
   * The returned data is identical to what {@link Scheduler/crud/AbstractCrudManager#property-inlineData} contains.
   *
   * ```javascript
   *
   * const json = scheduler.crudManager.toJSON();
   *
   * // json:
   * {
   *     eventsData : [...],
   *     resourcesData : [...],
   *     dependenciesData : [...],
   *     assignmentsData : [...],
   *     timeRangesData : [...],
   *     resourceTimeRangesData : [...],
   *     // ... other stores data
   * }
   * ```
   *
   * Output can be consumed by `inlineData`.
   *
   * ```javascript
   * const json = scheduler.crudManager.toJSON();
   *
   * // Plug it back in later
   * scheduler.crudManager.inlineData = json;
   * ```
   *
   * @function toJSON
   * @returns {Object}
   * @category JSON
   */
  toJSON() {
    const result = {};
    this.forEachCrudStore((store, storeId) => result[`${storeId}Data`] = store.toJSON());
    return result;
  }
  /**
   * Get or set data of CrudManager stores. The returned data is identical to what
   * {@link Scheduler/crud/AbstractCrudManager#function-toJSON} returns:
   *
   * ```javascript
   *
   * const data = scheduler.crudManager.inlineData;
   *
   * // data:
   * {
   *     eventsData : [...],
   *     resourcesData : [...],
   *     dependenciesData : [...],
   *     assignmentsData : [...],
   *     timeRangesData : [...],
   *     resourceTimeRangesData : [...],
   *     ... other stores data
   * }
   *
   *
   * // Plug it back in later
   * scheduler.crudManager.inlineData = data;
   * ```
   *
   * @property {Object}
   */
  get inlineData() {
    return this.toJSON();
  }
  set inlineData(data) {
    this.json = data;
  }
  //endregion
  //region Store collection (add, remove, get & iterate)
  set stores(stores) {
    if (stores !== this.crudStores) {
      this.crudStores = stores;
    }
  }
  /**
   * A list of registered stores whose server communication will be collected into a single batch.
   * Each store is represented by a _store descriptor_.
   * @member {CrudManagerStoreDescriptor[]} stores
   */
  get stores() {
    return this.crudStores;
  }
  //endregion
  /**
   * Returns true if the crud manager is currently loading data
   * @property {Boolean}
   * @readonly
   * @category CRUD
   */
  get isLoading() {
    return this.isCrudManagerLoading;
  }
  /**
   * Adds a store to the collection.
   *
   *```javascript
   * // append stores to the end of collection
   * crudManager.addStore([
   *     store1,
   *     // storeId
   *     'bar',
   *     // store descriptor
   *     {
   *         storeId : 'foo',
   *         store   : store3
   *     },
   *     {
   *         storeId         : 'bar',
   *         store           : store4,
   *         // to write all fields of modified records
   *         writeAllFields  : true
   *     }
   * ]);
   *```
   *
   * **Note:** Order in which stores are kept in the collection is very essential sometimes.
   * Exactly in this order the loaded data will be put into each store.
   *
   * When adding a store to the CrudManager, make sure the server response format is correct for `load` and `sync`
   * requests. Learn more in the [Working with data](#Scheduler/guides/data/crud_manager.md#loading-data) guide.
   *
   * @param {Core.data.Store|String|CrudManagerStoreDescriptor|Core.data.Store[]|String[]|CrudManagerStoreDescriptor[]} store
   * A store or list of stores. Each store might be specified by its instance, `storeId` or _descriptor_.
   * @param {Number} [position] The relative position of the store. If `fromStore` is specified the position will be
   * taken relative to it.
   * If not specified then store(s) will be appended to the end of collection.
   * Otherwise, it will be an index in stores collection.
   *
   * ```javascript
   * // insert stores store4, store5 to the start of collection
   * crudManager.addStore([ store4, store5 ], 0);
   * ```
   *
   * @param {String|Core.data.Store|CrudManagerStoreDescriptor} [fromStore] The store relative to which position
   * should be calculated. Can be defined as a store identifier, instance or descriptor (the result of
   * {@link Scheduler/crud/AbstractCrudManagerMixin#function-getStoreDescriptor} call).
   *
   * ```javascript
   * // insert store6 just before a store having storeId equal to 'foo'
   * crudManager.addStore(store6, 0, 'foo');
   *
   * // insert store7 just after store3 store
   * crudManager.addStore(store7, 1, store3);
   * ```
   */
  addStore(...args) {
    return this.addCrudStore(...args);
  }
  removeStore(...args) {
    return this.removeCrudStore(...args);
  }
  getStore(...args) {
    return this.getCrudStore(...args);
  }
  hasChanges(...args) {
    return this.crudStoreHasChanges(...args);
  }
  loadData(...args) {
    return this.loadCrudManagerData(...args);
  }
};
AbstractCrudManager._$name = "AbstractCrudManager";

// ../Scheduler/lib/Scheduler/data/CrudManager.js
var CrudManager = class extends AbstractCrudManager.mixin(ProjectCrudManager_default, AjaxTransport_default, JsonEncoder_default) {
  //region Config
  static get defaultConfig() {
    return {
      projectClass: ProjectModel,
      resourceStoreClass: ResourceStore,
      eventStoreClass: EventStore,
      assignmentStoreClass: AssignmentStore,
      dependencyStoreClass: DependencyStore,
      /**
       * A store with resources (or a config object).
       * @config {Scheduler.data.ResourceStore|ResourceStoreConfig}
       */
      resourceStore: {},
      /**
       * A store with events (or a config object).
       *
       * ```
       * crudManager : {
       *      eventStore {
       *          storeClass : MyEventStore
       *      }
       * }
       * ```
       * @config {Scheduler.data.EventStore|EventStoreConfig}
       */
      eventStore: {},
      /**
       * A store with assignments (or a config object).
       * @config {Scheduler.data.AssignmentStore|AssignmentStoreConfig}
       */
      assignmentStore: {},
      /**
       * A store with dependencies(or a config object).
       * @config {Scheduler.data.DependencyStore|DependencyStoreConfig}
       */
      dependencyStore: {},
      /**
       * A project that holds and links stores
       * @config {Scheduler.model.ProjectModel}
       */
      project: null
    };
  }
  //endregion
  buildProject() {
    return new this.projectClass(this.buildProjectConfig());
  }
  buildProjectConfig() {
    return ObjectHelper.cleanupProperties({
      eventStore: this.eventStore,
      resourceStore: this.resourceStore,
      assignmentStore: this.assignmentStore,
      dependencyStore: this.dependencyStore,
      resourceTimeRangeStore: this.resourceTimeRangeStore
    });
  }
  //region Stores
  set project(project) {
    const me = this;
    if (project !== me._project) {
      me.detachListeners("beforeDataReady");
      me.detachListeners("afterDataReady");
      me._project = project;
      if (project) {
        me.eventStore = project.eventStore;
        me.resourceStore = project.resourceStore;
        me.assignmentStore = project.assignmentStore;
        me.dependencyStore = project.dependencyStore;
        me.timeRangeStore = project.timeRangeStore;
        me.resourceTimeRangeStore = project.resourceTimeRangeStore;
        project.ion({
          name: "beforeDataReady",
          dataReady: () => me.suspendChangeTracking(),
          prio: 100,
          thisObj: me
        });
        project.ion({
          name: "afterDataReady",
          dataReady: () => me.resumeChangeTracking(),
          prio: -100,
          thisObj: me
        });
      }
      if (!me.eventStore) {
        me.eventStore = {};
      }
      if (!me.resourceStore) {
        me.resourceStore = {};
      }
      if (!me.assignmentStore) {
        me.assignmentStore = {};
      }
      if (!me.dependencyStore) {
        me.dependencyStore = {};
      }
    }
  }
  get project() {
    return this._project;
  }
  /**
   * Store for {@link Scheduler/feature/TimeRanges timeRanges} feature.
   * @property {Core.data.Store}
   */
  get timeRangeStore() {
    var _a2;
    return (_a2 = this._timeRangeStore) == null ? void 0 : _a2.store;
  }
  set timeRangeStore(store) {
    var _a2;
    this.setFeaturedStore("_timeRangeStore", store, (_a2 = this.project) == null ? void 0 : _a2.timeRangeStoreClass);
  }
  /**
   * Store for {@link Scheduler/feature/ResourceTimeRanges resourceTimeRanges} feature.
   * @property {Core.data.Store}
   */
  get resourceTimeRangeStore() {
    var _a2;
    return (_a2 = this._resourceTimeRangeStore) == null ? void 0 : _a2.store;
  }
  set resourceTimeRangeStore(store) {
    var _a2;
    this.setFeaturedStore("_resourceTimeRangeStore", store, (_a2 = this.project) == null ? void 0 : _a2.resourceTimeRangeStoreClass);
  }
  /**
   * Get/set the resource store bound to the CRUD manager.
   * @property {Scheduler.data.ResourceStore}
   */
  get resourceStore() {
    var _a2;
    return (_a2 = this._resourceStore) == null ? void 0 : _a2.store;
  }
  set resourceStore(store) {
    const me = this;
    me.setFeaturedStore("_resourceStore", store, me.resourceStoreClass);
  }
  /**
   * Get/set the event store bound to the CRUD manager.
   * @property {Scheduler.data.EventStore}
   */
  get eventStore() {
    var _a2;
    return (_a2 = this._eventStore) == null ? void 0 : _a2.store;
  }
  set eventStore(store) {
    const me = this;
    me.setFeaturedStore("_eventStore", store, me.eventStoreClass);
  }
  /**
   * Get/set the assignment store bound to the CRUD manager.
   * @property {Scheduler.data.AssignmentStore}
   */
  get assignmentStore() {
    var _a2;
    return (_a2 = this._assignmentStore) == null ? void 0 : _a2.store;
  }
  set assignmentStore(store) {
    this.setFeaturedStore("_assignmentStore", store, this.assignmentStoreClass);
  }
  /**
   * Get/set the dependency store bound to the CRUD manager.
   * @property {Scheduler.data.DependencyStore}
   */
  get dependencyStore() {
    var _a2;
    return (_a2 = this._dependencyStore) == null ? void 0 : _a2.store;
  }
  set dependencyStore(store) {
    this.setFeaturedStore("_dependencyStore", store, this.dependencyStoreClass);
  }
  setFeaturedStore(property, store, storeClass) {
    var _a2;
    const me = this, oldStore = (_a2 = me[property]) == null ? void 0 : _a2.store;
    if (oldStore !== store) {
      store = Store.getStore(store, (store == null ? void 0 : store.storeClass) || storeClass);
      if (oldStore) {
        me.removeStore(oldStore);
      }
      me[property] = store && { store } || null;
      me.addPrioritizedStore(me[property]);
    }
    return me[property];
  }
  getChangesetPackage() {
    var _a2, _b;
    const pack = super.getChangesetPackage();
    if (pack && (this.eventStore.usesSingleAssignment || ((_b = (_a2 = this.eventStore.modelClass.fieldMap) == null ? void 0 : _a2.resourceIds) == null ? void 0 : _b.persist))) {
      delete pack[this.assignmentStore.storeId];
      if (!this.crudStores.some((storeInfo) => pack[storeInfo.storeId])) {
        return null;
      }
    }
    return pack;
  }
  //endregion
  get crudLoadValidationMandatoryStores() {
    return [this._eventStore.storeId, this._resourceStore.storeId];
  }
};
__publicField(CrudManager, "$name", "CrudManager");
CrudManager._$name = "CrudManager";
export {
  AbstractAssignmentStoreMixin,
  AbstractCalendarManagerStoreMixin,
  AbstractCalendarMixin,
  AbstractCrudManager,
  AbstractCrudManagerMixin_default as AbstractCrudManagerMixin,
  AbstractCrudManagerValidation_default as AbstractCrudManagerValidation,
  AbstractDependencyStoreMixin,
  AbstractEventStoreMixin,
  AbstractHasAssignmentsMixin,
  AbstractPartOfProjectGenericMixin,
  AbstractPartOfProjectModelMixin,
  AbstractPartOfProjectStoreMixin,
  AbstractResourceStoreMixin,
  ActionBase,
  AddAction,
  AjaxHelper,
  AjaxStore,
  AjaxTransport_default as AjaxTransport,
  Animator,
  ArrayDataField,
  ArrayHelper,
  AssignmentModel,
  AssignmentModelMixin_default as AssignmentModelMixin,
  AssignmentStore,
  AssignmentStoreMixin_default as AssignmentStoreMixin,
  AsyncHelper,
  AvatarRendering,
  Badge_default as Badge,
  Bag,
  Base,
  BooleanCombo,
  BooleanDataField,
  BrowserHelper,
  Button,
  ButtonGroup,
  CI,
  CIFromSetOrArrayOrValue,
  CSSHelper,
  CalendarCache,
  CalendarCacheInterval,
  CalendarCacheIntervalMultiple,
  CalendarCacheMultiple,
  CalendarCacheSingle,
  CalendarIntervalMixin,
  CalendarIntervalStore,
  CalendarIteratorResult,
  CalendarPanel,
  Checkbox,
  ChipView,
  Base2 as ChronoMixinBase,
  ClickRepeater,
  Clipboardable_default as Clipboardable,
  CollapseTool,
  Collection,
  CollectionFilter,
  CollectionSorter,
  ColorBoxCombo,
  ColorField,
  ColorPicker,
  ColumnCombo,
  ColumnDrag,
  ColumnFilterField,
  ColumnHeaderMenu,
  ColumnModel,
  ColumnPickerButton,
  ColumnScrollButton,
  ColumnToolbars,
  Combo,
  Config,
  ConstraintIntervalSide,
  ConstraintType,
  Container,
  ContextMenuBase,
  CoreAssignmentMixin,
  CoreAssignmentStoreMixin,
  CoreCalendarManagerStoreMixin,
  CoreCalendarMixin,
  CoreDependencyMixin,
  CoreDependencyStoreMixin,
  CoreEventMixin,
  CoreEventStoreMixin,
  CoreHasAssignmentsMixin,
  CoreHasDependenciesMixin,
  CorePartOfProjectGenericMixin,
  CorePartOfProjectModelMixin,
  CorePartOfProjectStoreMixin,
  CoreResourceMixin,
  CoreResourceStoreMixin,
  CrudManager,
  CrudManagerView_default as CrudManagerView,
  DataField,
  DataGenerator,
  DateDataField,
  DateField,
  DateHelper,
  DatePicker,
  DateTimeField,
  DayTime,
  Delayable_default as Delayable,
  DelayableWrapper2 as DelayableWrapper,
  DemoBot,
  DependenciesCalendar,
  DependencyBaseModel,
  DependencyModel,
  DependencyStore,
  DependencyStoreMixin_default as DependencyStoreMixin,
  DependencyType,
  DependencyValidationResult,
  Direction,
  DisplayField,
  DomClassList,
  DomDataStore,
  DomHelper,
  DomSync,
  DragContext,
  DragHelper,
  DragProxy,
  DragTipProxy,
  Draggable_default as Draggable,
  Droppable_default as Droppable,
  Duration,
  DurationField,
  DynamicObject,
  EdgeInclusion,
  Editor,
  EventHelper,
  EventModel,
  EventModelMixin_default as EventModelMixin,
  EventStore,
  EventStoreMixin_default as EventStoreMixin,
  Events_default as Events,
  ExpandCollapse_default as ExpandCollapse,
  Factoryable_default as Factoryable,
  Featureable_default as Featureable,
  Fencible_default as Fencible,
  Field,
  FieldContainer,
  FieldFilterPicker,
  FieldFilterPickerGroup,
  FieldSet,
  FileField,
  FilePicker,
  FilterField,
  Finalizable_default as Finalizable,
  Formatter,
  Fullscreen,
  FunctionHelper,
  GetEventsMixin_default as GetEventsMixin,
  GlobalEvents_default as GlobalEvents,
  GridRowModel,
  Histogram,
  Hoverable_default as Hoverable,
  IdHelper,
  Identifiable_default as Identifiable,
  ImageItem,
  IndexPosition,
  InsertAction,
  InsertChildAction,
  InstancePlugin,
  IntegerDataField,
  IntervalCache,
  JsonEncoder_default as JsonEncoder,
  JsxItem,
  KeyMap_default as KeyMap,
  Label,
  Labelable_default as Labelable,
  Layout,
  List,
  LoadMaskable_default as LoadMaskable,
  LocaleHelper,
  LocaleManager_default as LocaleManager,
  Localizable_default as Localizable,
  MAX_DATE,
  MI,
  MIN_DATE,
  Mask,
  Menu,
  MenuItem,
  MessageDialog_default as MessageDialog,
  Minifiable_default as Minifiable,
  Model,
  ModelDataField,
  ModelLink_default as ModelLink,
  ModelStm_default as ModelStm,
  Month,
  Navigator,
  NumberDataField,
  NumberField,
  NumberFormat,
  ObjectDataField,
  ObjectHelper,
  Objects,
  Override,
  PagingToolbar,
  Panel,
  PanelCollapser,
  PanelCollapserOverlay,
  Parser_default as Parser,
  PartOfProject_default as PartOfProject,
  PasswordField,
  PickerField,
  Pluggable_default as Pluggable,
  Point,
  Popup,
  ProgressItem,
  ProjectCombo2 as ProjectCombo,
  ProjectConstraintResolution,
  ProjectCrudManager_default as ProjectCrudManager,
  ProjectModel2 as ProjectModel,
  ProjectModelCommon_default as ProjectModelCommon,
  ProjectModelMixin_default as ProjectModelMixin,
  ProjectModelTimeZoneMixin_default as ProjectModelTimeZoneMixin,
  ProjectType,
  Promissory,
  RTL_default as RTL,
  Radio,
  RadioGroup,
  RandomGenerator,
  RatingItem,
  Rectangle,
  RecurrenceModel,
  RecurringEventsMixin_default as RecurringEventsMixin,
  RecurringTimeSpan_default as RecurringTimeSpan,
  RecurringTimeSpansMixin_default as RecurringTimeSpansMixin,
  RemoveAction,
  RemoveAllAction,
  RemoveChildAction,
  Renderable,
  ResizeHelper,
  ResizeMonitor,
  ResourceAvatarsItem,
  ResourceModel,
  ResourceModelMixin_default as ResourceModelMixin,
  ResourceStore,
  ResourceStoreMixin_default as ResourceStoreMixin,
  ResourceTimeRangeModel,
  ResourceTimeRangeStore,
  ResourcesCombo,
  Responsive_default as Responsive,
  ResponsiveCards_default as ResponsiveCards,
  Ripple,
  Rotatable_default as Rotatable,
  Scale,
  SchedulerCoreEvent,
  SchedulerCoreProjectMixin,
  ProjectCombo as SchedulerProjectCombo,
  ProjectModel as SchedulerProjectModel,
  SchedulingMode,
  ScrollManager,
  Scroller,
  SeparatorItem,
  SimpleTaskEdit,
  SlideToggle,
  Slider,
  SortedMap,
  Splitter,
  State_default as State,
  StateBase,
  StateProvider,
  StateStorage,
  StateTrackingManager,
  Store,
  StoreCRUD_default as StoreCRUD,
  StoreChained_default as StoreChained,
  StoreChanges_default as StoreChanges,
  StoreDataField,
  StoreFilter_default as StoreFilter,
  StoreGroup_default as StoreGroup,
  StoreProxy_default as StoreProxy,
  StoreRelation_default as StoreRelation,
  StoreSearch_default as StoreSearch,
  StoreSort_default as StoreSort,
  StoreState_default as StoreState,
  StoreStm_default as StoreStm,
  StoreSum_default as StoreSum,
  StoreSync_default as StoreSync,
  StoreTree_default as StoreTree,
  StringDataField,
  StringHelper,
  Styleable_default as Styleable,
  SwimlaneCombo,
  SwimlaneDrag,
  SwimlaneFilterField,
  SwimlaneModel,
  SwimlanePickerButton,
  SwimlaneScrollButton,
  Tab,
  TabBar,
  TabPanel,
  TagCombo,
  TagsItem,
  TaskBoard,
  TaskBoardBase,
  TaskBoardColumns_default as TaskBoardColumns,
  TaskBoardDom_default as TaskBoardDom,
  TaskBoardDomEvents_default as TaskBoardDomEvents,
  TaskBoardFeature,
  TaskBoardLinked_default as TaskBoardLinked,
  TaskBoardScroll_default as TaskBoardScroll,
  TaskBoardStores_default as TaskBoardStores,
  TaskBoardSwimlanes_default as TaskBoardSwimlanes,
  TaskBoardVirtualization_default as TaskBoardVirtualization,
  TaskColorCombo,
  TaskColorPicker,
  TaskDrag,
  TaskDragSelect,
  TaskEdit,
  TaskEditor,
  TaskFilterField,
  TaskItem,
  TaskItems_default as TaskItems,
  TaskMenu,
  TaskModel,
  TaskNavigation_default as TaskNavigation,
  TaskSelection_default as TaskSelection,
  TaskStore,
  TaskTooltip,
  TemplateHelper,
  TemplateItem,
  TextAreaField,
  TextAreaPickerField,
  TextField,
  TextItem,
  TimeField,
  TimePicker,
  TimeRangeModel,
  TimeRangeStore,
  TimeSpan,
  TimeUnit,
  TimeZoneHelper,
  TimeZonedDatesMixin_default as TimeZonedDatesMixin,
  Toast,
  TodoListField,
  TodoListItem,
  Tool,
  Toolable_default as Toolable,
  Toolbar,
  Tooltip,
  Transaction,
  TreeNode_default as TreeNode,
  UndoRedo,
  UndoRedoBase,
  UnspecifiedTimeIntervalModel,
  UpdateAction,
  VersionHelper,
  WalkHelper,
  Wbs,
  WebSocketManager,
  Widget,
  WidgetHelper,
  XMLHelper,
  YearPicker,
  ZoomSlider,
  binarySearch,
  combineCalendars,
  delay,
  format,
  isDateFinite,
  isEqualEffectiveDirection,
  isNotNumber,
  later,
  stripDuplicates,
  unitMagnitudes
};
//# sourceMappingURL=taskboard.module.js.map
