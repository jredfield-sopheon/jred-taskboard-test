{
  "version": 3,
  "sources": ["../../lib/TaskBoard/feature/TaskBoardFeature.js", "../../lib/TaskBoard/feature/ColumnDrag.js", "../../lib/TaskBoard/feature/ColumnHeaderMenu.js", "../../lib/TaskBoard/feature/ColumnToolbars.js", "../../lib/TaskBoard/view/item/TaskItem.js", "../../lib/TaskBoard/feature/SimpleTaskEdit.js", "../../lib/TaskBoard/feature/SwimlaneDrag.js", "../../lib/TaskBoard/feature/TaskDrag.js", "../../lib/TaskBoard/feature/TaskDragSelect.js", "../../lib/TaskBoard/widget/mixin/TaskBoardLinked.js", "../../lib/TaskBoard/widget/base/ColorBoxCombo.js", "../../lib/TaskBoard/widget/ColumnCombo.js", "../../lib/TaskBoard/widget/ResourcesCombo.js", "../../lib/TaskBoard/widget/SwimlaneCombo.js", "../../lib/TaskBoard/widget/TaskColorPicker.js", "../../lib/TaskBoard/widget/TaskColorCombo.js", "../../lib/TaskBoard/widget/TaskEditor.js", "../../lib/TaskBoard/feature/TaskEdit.js", "../../lib/TaskBoard/feature/TaskMenu.js", "../../lib/TaskBoard/feature/TaskTooltip.js", "../../lib/TaskBoard/model/ColumnModel.js", "../../lib/TaskBoard/model/TaskModel.js", "../../lib/TaskBoard/store/TaskStore.js", "../../lib/TaskBoard/model/ProjectModel.js", "../../lib/TaskBoard/model/SwimlaneModel.js", "../../lib/TaskBoard/view/mixin/ExpandCollapse.js", "../../lib/TaskBoard/view/mixin/ResponsiveCards.js", "../../lib/TaskBoard/view/mixin/TaskBoardColumns.js", "../../lib/TaskBoard/view/mixin/TaskBoardDom.js", "../../lib/TaskBoard/view/mixin/TaskBoardDomEvents.js", "../../lib/TaskBoard/view/mixin/TaskBoardScroll.js", "../../lib/TaskBoard/view/mixin/TaskBoardStores.js", "../../lib/TaskBoard/view/mixin/TaskBoardSwimlanes.js", "../../lib/TaskBoard/view/mixin/TaskBoardVirtualization.js", "../../lib/TaskBoard/view/item/TextItem.js", "../../lib/TaskBoard/view/item/ResourceAvatarsItem.js", "../../lib/TaskBoard/view/mixin/TaskItems.js", "../../lib/TaskBoard/view/mixin/TaskNavigation.js", "../../lib/TaskBoard/view/mixin/TaskSelection.js", "../../lib/TaskBoard/view/item/ImageItem.js", "../../lib/TaskBoard/view/item/JsxItem.js", "../../lib/TaskBoard/view/item/ProgressItem.js", "../../lib/TaskBoard/view/item/RatingItem.js", "../../lib/TaskBoard/view/item/SeparatorItem.js", "../../lib/TaskBoard/widget/TagCombo.js", "../../lib/TaskBoard/view/item/TagsItem.js", "../../lib/TaskBoard/view/item/TemplateItem.js", "../../lib/TaskBoard/view/item/TodoListItem.js", "../../lib/TaskBoard/localization/En.js", "../../lib/TaskBoard/view/TaskBoardBase.js", "../../lib/TaskBoard/view/item/TaskMenuItem.js", "../../lib/TaskBoard/view/TaskBoard.js", "../../lib/TaskBoard/widget/ColumnFilterField.js", "../../lib/TaskBoard/widget/ColumnPickerButton.js", "../../lib/TaskBoard/widget/ColumnScrollButton.js", "../../lib/TaskBoard/widget/ProjectCombo.js", "../../lib/TaskBoard/widget/SwimlaneFilterField.js", "../../lib/TaskBoard/widget/SwimlanePickerButton.js", "../../lib/TaskBoard/widget/SwimlaneScrollButton.js", "../../lib/TaskBoard/widget/TaskFilterField.js", "../../lib/TaskBoard/widget/TodoListField.js", "../../lib/TaskBoard/widget/UndoRedo.js", "../../lib/TaskBoard/widget/ZoomSlider.js"],
  "sourcesContent": ["import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Factoryable from '../../Core/mixin/Factoryable.js';\n/**\n * @module TaskBoard/feature/TaskBoardFeature\n */\n/**\n * The abstract base class for TaskBoard features.\n *\n * @extends Core/mixin/InstancePlugin\n * @abstract\n */\nexport default class TaskBoardFeature extends InstancePlugin.mixin(Factoryable) {\n    static factoryable = {};\n    static configurable = {};\n    // This makes all feature config changes after initialization recompose TaskBoard\n    onConfigChange(args) {\n        if (!this.isConfiguring && !this.isDestroying) {\n            this.client.recompose();\n        }\n        super.onConfigChange(args);\n    }\n}\nTaskBoardFeature._$name = 'TaskBoardFeature';", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport Base from '../../Core/Base.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Draggable from '../../Core/mixin/Draggable.js';\nimport Droppable from '../../Core/mixin/Droppable.js';\nimport Events from '../../Core/mixin/Events.js';\n/**\n * @module TaskBoard/feature/ColumnDrag\n */\n/**\n * This feature allows users to drag columns on the TaskBoard to change the column order. Drag is initiated upon\n * mouse down in the column header. Try it out below!\n *\n * {@inlineexample TaskBoard/feature/ColumnDrag.js}\n *\n * Works just as well when using swimlanes:\n *\n * {@inlineexample TaskBoard/feature/ColumnDragSwimlanes.js}\n *\n * ## Drag events\n *\n * The different stages of a drag operation trigger different events, in order of appearance:\n *\n * | Event                           | Description                                                                    |\n * |---------------------------------|--------------------------------------------------------------------------------|\n * | {@link #event-beforeColumnDrag} | Preventable event fired before a drag starts                                   |\n * | {@link #event-columnDragStart}  | Fired when dragging starts                                                     |\n * | {@link #event-columnDrag}       | Fired when movement during a drag will lead to changes                         |\n * | {@link #event-beforeColumnDrop} | Preventable event fired before finalizing a valid drop. Allows async listeners |\n * | {@link #event-columnDrop}       | Fired after finalizing a valid drop                                            |\n * | {@link #event-columnDragAbort}  | Fired when a drag is aborted (ESC, drop out of bounds or by a listener)        |\n * | {@link #event-columnDragEnd}    | Fired when a started drag ends, no matter the outcome                          |\n *\n * This feature is **disabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype columnDrag\n * @feature\n */\nexport default class ColumnDrag extends TaskBoardFeature {\n    static $name = 'ColumnDrag';\n    static type = 'columnDrag';\n    static pluginConfig = {\n        after : ['initialCompose', 'populateColumnHeaderMenu']\n    };\n    initialCompose() {\n        const me = this;\n        // Cannot use configurable since bodyElement is not available yet when feature is pulled in\n        me.draggable = ColumnZone.new({\n            dragRootElement : me.disabled ? null : me.client.bodyWrapElement,\n            dropRootElement : me.client.bodyWrapElement,\n            owner           : me,\n            internalListeners : {\n                beforeDragStart : 'onBeforeDragStart',\n                dragStart       : 'onDragStart',\n                thisObj         : me\n            }\n        }, me.draggable);\n    }\n    doDestroy() {\n        this.draggable?.destroy();\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        super.doDisable(disable);\n        if (this.draggable) {\n            this.draggable.dragRootElement = disable ? null : this.client.bodyWrapElement;\n        }\n    }\n    movePrev(columnRecord) {\n        const { columns } = this.client;\n        columns.move(columnRecord, columns.getPrev(columnRecord));\n    }\n    moveNext(columnRecord) {\n        const\n            { columns } = this.client,\n            beforeIndex = Math.min(columns.indexOf(columnRecord) + 2, columns.count);\n        columns.move(columnRecord, columns.getAt(beforeIndex));\n    }\n    populateColumnHeaderMenu({ items, columnRecord }) {\n        const\n            { client }       = this,\n            { columns, rtl } = client;\n        if (!client.readOnly && !this.disabled) {\n            items.moveColumnLeft = {\n                text     : 'L{TaskBoard.moveColumnLeft}',\n                icon     : 'b-fw-icon b-icon-left',\n                disabled : columnRecord === columns[rtl ? 'last' : 'first'],\n                weight   : 200,\n                onItem   : () => this['move' + (rtl ? 'Next' : 'Prev')](columnRecord)\n            };\n            items.moveColumnRight = {\n                text     : 'L{TaskBoard.moveColumnRight}',\n                icon     : 'b-fw-icon b-icon-right',\n                disabled : columnRecord === columns[rtl ? 'first' : 'last'],\n                weight   : 300,\n                onItem   : () => this['move' + (rtl ? 'Prev' : 'Next')](columnRecord)\n            };\n        }\n    }\n    onBeforeDragStart({ drag, event }) {\n        /**\n         * Fires on the owning TaskBoard before column dragging starts. Return `false` to prevent the action\n         * @event beforeColumnDrag\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.ColumnModel} columnRecord Column to be dragged\n         */\n        return this.client.trigger('beforeColumnDrag', { drag, event, columnRecord : drag.columnRecord });\n    }\n    onDragStart({ drag, event }) {\n        /**\n         * Fires on the owning TaskBoard when column dragging starts\n         * @event columnDragStart\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.ColumnModel} columnRecord Column to be dragged\n         */\n        return this.client.trigger('columnDragStart', { drag, event, columnRecord : drag.columnRecord });\n    }\n}\nColumnDrag.initClass();\nclass ColumnZone extends Base.mixin(Draggable, Droppable, Events) {\n    static get configurable() {\n        return {\n            dragSelector     : '.b-taskboard-column-header, .b-taskboard-column-header *',\n            dragItemSelector : '.b-taskboard-column-header',\n            // Column has multiple parts (header + one element per swimlane), going to add cls manually to them\n            draggingItemCls : null,\n            dragProxy : {\n                type : 'default',\n                async open(drag) {\n                    const\n                        { owner }    = this,\n                        {\n                            itemElement,\n                            startEvent,\n                            columnRecord\n                        }            = drag,\n                        taskBoard    = owner.owner.client,\n                        headerBounds = Rectangle.from(itemElement, owner.dragRootElement),\n                        // Offset from cursor\n                        proxyOffset  = EventHelper.getClientPoint(startEvent).getDelta(headerBounds),\n                        // Drag proxy, positioned over column being dragged\n                        proxy        = DomHelper.createElement({\n                            className : 'b-taskboard-column-drag-proxy',\n                            parent    : owner.dragRootElement,\n                            style     : {\n                                // Using fixed top, only draggable horizontally\n                                top   : headerBounds.y,\n                                // Offset from cursor to be positioned over original column\n                                left  : EventHelper.getClientPoint(startEvent).translate(proxyOffset[0], 0).x,\n                                // Need a fixed width on the proxy, since columns width might be flexed etc\n                                width : itemElement.getBoundingClientRect().width\n                            },\n                            // Don't want it being removed while dragging\n                            retainElement : true\n                        }),\n                        // A column consists of multiple elements, a header and one \"column\" per swimlane (at least one)\n                        elements     = [itemElement, ...taskBoard.getColumnElements(columnRecord)];\n                    // Things we want to access later on drag\n                    Object.assign(drag, {\n                        proxy,\n                        elements,\n                        proxyOffset\n                    });\n                    // Clone all dragged column elements and put them in the proxy\n                    elements.forEach((element, i) => {\n                        const\n                            columnClone = element.cloneNode(true),\n                            bounds      = element.getBoundingClientRect();\n                        // Store size, used to size drop indicator later\n                        element.originalWidth = bounds.width;\n                        element.originalHeight = bounds.height;\n                        // Mimic element structure, swimlane > column (not fully mimicking it for now, should suffice)\n                        if (element.matches('.b-taskboard-column')) {\n                            const\n                                swimlane      = element.closest('.b-taskboard-swimlane'),\n                                header        = DomSync.getChild(swimlane, 'header'),\n                                body          = DomSync.getChild(swimlane, 'body'),\n                                swimlaneClone = swimlane.cloneNode(),\n                                headerClone   = header?.cloneNode(true),\n                                bodyClone     = body.cloneNode();\n                            let height = swimlane.getBoundingClientRect().height;\n                            // Last swimlane has bottom padding that we do not want in proxy\n                            if (i === elements.length - 1) {\n                                const paddingBottom = DomHelper.getStyleValue(element.parentElement, 'padding-bottom');\n                                height -= parseFloat(paddingBottom);\n                            }\n                            // Use fixed height on the swimlanes in the drag proxy, to have it exactly match the board.\n                            // Otherwise it would shrinkwrap\n                            swimlaneClone.style.flex = `0 0 ${height}px`;\n                            headerClone && swimlaneClone.appendChild(headerClone);\n                            bodyClone.appendChild(columnClone);\n                            swimlaneClone.appendChild(bodyClone);\n                            proxy.appendChild(swimlaneClone);\n                        }\n                        // Column header\n                        else {\n                            proxy.appendChild(columnClone);\n                        }\n                        // Hide original column after measuring it above\n                        element.classList.add('b-drag-original');\n                    });\n                },\n                dragMove({ proxy, event, proxyOffset }) {\n                    // Move along x-axis only\n                    const position = EventHelper.getClientPoint(event).translate(proxyOffset[0], 0);\n                    proxy.style.left = `${position.x}px`;\n                }\n            }\n        };\n    }\n    setupDragContext(event) {\n        const\n            result = super.setupDragContext(event),\n            { client } = this.owner;\n        result.scrollManager = client.scrollManager;\n        result.monitoringConfig = {\n            scrollables : [{\n                element   : client.bodyElement,\n                direction : 'horizontal'\n            }]\n        };\n        return result;\n    }\n    // Populate the drag context early, to have something to take decisions on in beforeDragStart listeners\n    startDrag(drag) {\n        drag.columnRecord = this.owner.client.resolveColumnRecord(drag.itemElement);\n        return super.startDrag(drag);\n    }\n    dragStart(drag) {\n        // Even though the size of other columns should not be affected, we might decide to animate in the future.\n        // Suspending responsiveness to not have it kick in if we do...\n        this.owner.client.suspendResponsiveness();\n        drag.wasStarted = true;\n    }\n    dragEnter(drag) {\n        // Only accept columns\n        if (!drag.itemElement.matches(this.dragItemSelector)) {\n            return false;\n        }\n        // Create drop indicators on first enter\n        if (!drag.dropIndicators) {\n            // Need one indicator for each part of the column\n            drag.dropIndicators = drag.elements.map((element, i) => DomHelper.createElement({\n                className   : 'b-taskboard-column-drop-indicator',\n                elementData : {\n                    dropIndicator : true,\n                    // Tag along the element, to be able to return the drop indicator to its position for\n                    // invalid drop targets. NOTE: Currently not used\n                    element\n                },\n                // Use same size as dragged column had originally\n                style : {\n                    width  : element.originalWidth,\n                    height : element.originalHeight\n                }\n            }));\n            this.insertDropIndicators(drag, drag.columnRecord);\n        }\n    }\n    insertDropIndicators(drag, beforeColumnRecord) {\n        // Figure out insertion index among headers, will use same index within swimlanes\n        const\n            { client } = this.owner,\n            insertAt   = client.columns.indexOf(beforeColumnRecord);\n        // Insert all drop indicators\n        drag.dropIndicators.forEach((dropIndicator, i) => {\n            // Header\n            if (i === 0) {\n                // Insert at correct place among column headers\n                const\n                    headerContainer = DomSync.getChild(client.bodyElement, 'header'),\n                    actualHeaders   = [...headerContainer.children];\n                ArrayHelper.remove(actualHeaders, dropIndicator);\n                headerContainer.insertBefore(dropIndicator, actualHeaders[insertAt]);\n            }\n            // Column\n            else {\n                // Insert it at correct place within corresponding swimlane\n                const\n                    // Get corresponding swimlane (default if swimlanes not used)\n                    swimlaneRecord = client.swimlanes?.getAt(i - 1) ?? { domId : 'default' },\n                    swimlaneBody   = DomSync.getChild(client.getSwimlaneElement(swimlaneRecord), 'body'),\n                    actualColumns  = [...swimlaneBody.children];\n                ArrayHelper.remove(actualColumns, dropIndicator);\n                swimlaneBody.insertBefore(dropIndicator, actualColumns[insertAt]);\n            }\n        });\n    }\n    updateValidity(drag, valid) {\n        drag.proxy.classList.toggle('b-invalid', !valid);\n        drag.dropIndicators.forEach(dropIndicator => dropIndicator.classList.toggle('b-invalid', !valid));\n        drag.invalid = !valid;\n    }\n    dragMove(drag) {\n        const\n            { client }          = this.owner,\n            documentRoot        = client.documentRoot,\n            proxyBounds         = Rectangle.from(drag.proxy, undefined, true),\n            // Check element under proxy top center, should get a column header (or a gap)\n            overElement         = documentRoot.elementFromPoint(proxyBounds.center.x, proxyBounds.y),\n            columnHeaderElement = overElement?.closest('.b-taskboard-column-header');\n        if (drag.invalid) {\n            drag.valid = false;\n        }\n        // If we are over the drop indicator or something not a column header, we do nothing\n        if (!overElement?.elementData?.dropIndicator && columnHeaderElement) {\n            const targetBounds = Rectangle.from(columnHeaderElement);\n            // Column that we are going to insert the dragged column before or after\n            let beforeColumn = client.resolveColumnRecord(columnHeaderElement);\n            // If beyond center, insert before next column\n            if (proxyBounds.center.x > targetBounds.center.x) {\n                beforeColumn = client.columns.getNext(beforeColumn);\n            }\n            this.insertDropIndicators(drag, beforeColumn);\n            // Only trigger if order will change\n            const shouldTrigger = drag.beforeColumn !== beforeColumn;\n            drag.beforeColumn = beforeColumn;\n            if (shouldTrigger) {\n                /**\n                 * Fires on the owning TaskBoard when a column is dragged, if the drag leads to a change compared to\n                 * the last columnDrag event.\n                 *\n                 * Returning `false` from a listener will flag the drag as invalid (by default turning the drop\n                 * indicator red)\n                 *\n                 * ```javascript\n                 * const taskBoard = new TaskBoard({\n                 *    listeners : {\n                 *        // Do not allow moving beyond last column\n                 *        columnDrag({ columnRecord, beforeColumn }) {\n                 *           return beforeColumn === null;\n                 *        }\n                 *    }\n                 * });\n                 * ```\n                 *\n                 * @event columnDrag\n                 * @on-owner\n                 * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                 * @param {TaskBoard.model.ColumnModel} columnRecord Column being dragged\n                 * @param {TaskBoard.model.ColumnModel} beforeColumn Insert before this column on drop, `null` if last\n                 */\n                const result = client.trigger('columnDrag', { drag, columnRecord : drag.columnRecord, beforeColumn });\n                this.updateValidity(drag, result !== false);\n            }\n        }\n    }\n    async dragDrop(drag) {\n        // Data part\n        const\n            { client }  = this.owner,\n            { columns } = client,\n            {\n                columnRecord,\n                beforeColumn,\n                elements,\n                dropIndicators,\n                proxy\n            }           = drag;\n        /**\n         * Fires on the owning TaskBoard when dropping a column, before the operation completes. Handles async\n         * listeners, returning `false` from one will abort the operation\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        async beforeColumnDrop({ columnRecord, beforeColumn }) {\n         *            // Show confirmation dialog\n         *            const result = await MessageDialog.confirm({\n         *                title   : 'Verify drop',\n         *                message : `Please confirm moving ${columnRecord.text} before ${beforeColumn.text}?`\n         *            });\n         *\n         *            // Returning false will abort the drop (if user pressed Cancel)\n         *            return result === MessageDialog.okButton;\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event beforeColumnDrop\n         * @preventable\n         * @async\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.ColumnModel} columnRecord Dropped column\n         * @param {TaskBoard.model.ColumnModel} beforeColumn Dropped before this column\n         */\n        if (drag.invalid || await client.trigger('beforeColumnDrop', { drag, columnRecord, beforeColumn }) === false) {\n            drag.valid = false;\n        }\n        else {\n            drag.finalizer = new Promise(resolve => {\n                function commit() {\n                    // Remove proxy & dropIndicator\n                    proxy.remove();\n                    dropIndicators.forEach(dropIndicator => dropIndicator.remove());\n                    // Restore original elements\n                    elements.forEach(element => element.classList.remove('b-drag-original'));\n                    // Update data\n                    client.suspendDomTransition();\n                    beforeColumn !== undefined && columns.move(columnRecord, beforeColumn);\n                    client.resumeDomTransition();\n                    /**\n                     * Fires on the owning TaskBoard when a column is successfully dropped (after the drop transition\n                     * has finished)\n                     * @event columnDrop\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.ColumnModel} columnRecord Dropped column\n                     * @param {TaskBoard.model.ColumnModel} beforeColumn Dropped before this column (`null` if last)\n                     * @param {TaskBoard.model.SwimlaneModel} targetSwimlane Dropped in this swimlane (if used)\n                     */\n                    client.trigger('columnDrop', { drag, columnRecord, beforeColumn });\n                    /**\n                     * Fires on the owning TaskBoard when a previously started drag operation ends, no matter the\n                     * outcome of it (whether valid, invalid or aborted)\n                     *\n                     * @event columnDragEnd\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.ColumnModel} columnRecord Affected column\n                     */\n                    client.trigger('columnDragEnd', { drag, columnRecord, beforeColumn });\n                    client.resumeResponsiveness();\n                    resolve();\n                }\n                // UI part\n                // We are dropping, this cls by default has a transition\n                proxy.classList.add('b-dropping');\n                // Move proxy to drop location, allowing it to transition there\n                DomHelper.alignTo(\n                    proxy,\n                    Rectangle.from(dropIndicators[0], undefined, true)\n                );\n                // Update record after the transition, to prevent too early redraw (which would ruin the transition)\n                if (DomHelper.getPropertyTransitionDuration(proxy, 'transform')) {\n                    EventHelper.onTransitionEnd({\n                        element  : proxy,\n                        property : 'transform',\n                        handler  : commit,\n                        thisObj  : client\n                    });\n                }\n                // Or right away if no transition is used\n                else {\n                    commit();\n                }\n            });\n        }\n    }\n    dragLeave(drag) {\n        // Doing nothing feels ok for now\n    }\n    doAbort(drag) {\n        const\n            { client }                                        = this.owner,\n            { dropIndicators, proxy, columnRecord, elements } = drag;\n        if (proxy) {\n            function finalizeAbort() {\n                // Remove proxy & dropIndicator\n                proxy.remove();\n                dropIndicators.forEach(dropIndicator => dropIndicator.remove());\n                // Restore original elements\n                elements.forEach(element => element.classList.remove('b-drag-original'));\n                client.trigger('columnDragAbortFinalized');\n            }\n            // Emulate a drop on abort, to get transitions\n            proxy.classList.add('b-dropping');\n            // Move drop indicators to where column originated\n            dropIndicators.forEach((dropIndicator, i) => {\n                const original = drag.elements[i];\n                dropIndicator.classList.remove('b-invalid'); // Looks better if not invalid on return to origin\n                original.parentElement.insertBefore(dropIndicator, original);\n            });\n            // Move proxy to original location, allowing it to transition there\n            DomHelper.alignTo(\n                proxy,\n                Rectangle.from(dropIndicators[0], undefined, true)\n            );\n            // Finalize after transition\n            if (DomHelper.getPropertyTransitionDuration(proxy, 'transform')) {\n                EventHelper.onTransitionEnd({\n                    element  : proxy,\n                    property : 'transform',\n                    handler  : finalizeAbort,\n                    thisObj  : client // For timer cleanup\n                });\n            }\n            // Or right away if no transition is used\n            else {\n                finalizeAbort();\n            }\n        }\n        /**\n         * Fires on the owning TaskBoard when a drag operation is aborted (invalid drop or aborted using ESC)\n         *\n         * @event columnDragAbort\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.ColumnModel} columnRecord Dragged column\n         */\n        client.trigger('columnDragAbort', { drag, columnRecord });\n        if (drag.wasStarted) {\n            // Documented in dragDrop()\n            client.trigger('columnDragEnd', { drag, columnRecord });\n        }\n    }\n    dragEnd(drag) {\n        // Move back to original location when drag was aborted\n        if (!drag.valid || drag.aborted) {\n            this.doAbort(drag);\n        }\n    }\n}\nColumnDrag._$name = 'ColumnDrag';", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport ContextMenuBase from '../../Core/feature/base/ContextMenuBase.js';\n/**\n * @module TaskBoard/feature/ColumnHeaderMenu\n */\n/**\n * Adds a menu button (`\u00B7\u00B7\u00B7`) to column headers, clicking it displays a menu. Items are populated by other features\n * and/or application code.\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenu.js}\n *\n * ## Default items\n *\n * These are the default items provided by TaskBoard features:\n *\n * | Reference         | Weight | Feature                              | Description                   |\n * |-------------------|--------|--------------------------------------|-------------------------------|\n * | `addTask `        | 100    | *This feature*                       | Add a new task to this column |\n * | `moveColumnLeft`  | 200    | {@link TaskBoard.feature.ColumnDrag} | Move column one step left     |\n * | `moveColumnRight` | 300    | {@link TaskBoard.feature.ColumnDrag} | Move column one step right    |\n *\n * Default items in the menu can be changed or removed and new items can be added. This is handled using the\n * {@link #config-items} config of the feature.\n *\n * ## Add items\n *\n * Add menu items for all column headers by adding a key (used as menu item {@link Core/widget/Widget#config-ref}) with\n * a {@link Core/widget/MenuItem#configs config object for a menu item} as the value to the {@link #config-items} config:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         columnHeaderMenu : {\n *             items : {\n *                 flagTasks : {\n *                     text : 'Flag task',\n *                     icon : 'b-fa-fw b-fa-flag',\n *                     onItem({ columnRecord }) {\n *                         columnRecord.tasks.forEach(taskRecord => taskRecord.flagged = true);\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenuAdd.js}\n *\n * ## Remove items\n *\n * To remove default items, configure them as `null` in the {@link #config-items} config:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         columnHeaderMenu : {\n *             items : {\n *                 moveColumnLeft  : null,\n *                 moveColumnRight : null\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenuRemove.js}\n *\n * ## Customize items\n *\n * To customize default items, supply a new config object for them in the {@link #config-items} config. It will merge\n * with the default config object:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         columnHeaderMenu : {\n *             items : {\n *                 // Change the text of the \"Add new task\" item\n *                 addTask : {\n *                     text : 'New card'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenuCustomize.js}\n *\n * ## Manipulating items at runtime\n *\n * Manipulate items for all columns or specific columns at runtime by supplying a {@link #config-processItems} function:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         columnHeaderMenu : {\n *             // Process items before menu is shown\n *             processItems({ columnRecord, items }) {\n *                  // Push an extra item for the done column\n *                  if (columnRecord.id === 'done') {\n *                      items.archive = {\n *                          text : 'Archive',\n *                          icon : 'b-fa-fw b-fa-archive',\n *                          onItem({ columnRecord }) {\n *                              columnRecord.tasks.forEach(taskRecord => taskRecord.archived = true);\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show \"Add new task\" for the todo column\n *                  if (columnRecord.id === 'todo') {\n *                      items.addTask = null;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">The `processItems` implementation my be an `async` function which `awaits` a result to\n * mutate the `items` object.</div>\n *\n * {@inlineexample TaskBoard/feature/ColumnHeaderMenuProcessItems.js}\n *\n * This feature is **enabled** by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys           | Action                 | Action description                                     |\n * |----------------|------------------------|--------------------------------------------------------|\n * | `Space`        | *showContextMenuByKey* | Shows context menu for currently focused column header |\n * | `Ctrl`+`Space` | *showContextMenuByKey* | Shows context menu for currently focused column header |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#TaskBoard/guides/customization/keymap.md).\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype columnHeaderMenu\n * @feature\n */\nexport default class ColumnHeaderMenu extends ContextMenuBase {\n    static $name = 'ColumnHeaderMenu';\n    static type = 'columnHeaderMenu';\n    static configurable = {\n        /**\n         * A function called before displaying the menu that allows manipulations of its items.\n         * Returning `false` from this function prevents the menu from being shown.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *   features         : {\n         *       columnHeaderMenu : {\n         *           processItems({ columnRecord, items }) {\n         *              // Push an extra item for the todo column\n         *              if (columnRecord.id === 'todo') {\n         *                  items.finishAll = {\n         *                      text : 'Finish all',\n         *                      icon : 'b-fa-fw b-fa-check'\n         *                      onItem({ columnRecord }) {\n         *                          columnRecord.tasks.forEach(taskRecord => taskRecord.status = 'done');\n         *                      }\n         *                  };\n         *               }\n         *           }\n         *       }\n         *   }\n         * });\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} context An object with information about the menu being shown\n         * @param {TaskBoard.model.ColumnModel} context.columnRecord The column for which the menu will be shown\n         * @param {Object<String,MenuItemConfig|Boolean>} context.items An object containing the\n         *   {@link Core.widget.MenuItem menu item} configs keyed by their id\n         * @param {Event} context.event The DOM event object that triggered the show\n         * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n         * @preventable\n         */\n        processItems : null,\n        /**\n         * This is a preconfigured set of items used to create the default context menu.\n         *\n         * The `items` provided by this feature are listed in the intro section of this class. You can configure\n         * existing items by passing a configuration object to the keyed items.\n         *\n         * To remove existing items, set corresponding keys `null`:\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         columnHeaderMenu : {\n         *             items : {\n         *                 addTask : null\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * See the class description for more examples.\n         *\n         * @config {Object<string,MenuItemConfig|Boolean|null>} items\n         */\n        items : null,\n        menu : {\n            anchor : true\n        },\n        type : 'columnHeader',\n        triggerEvent : false\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>>} keyMap\n         */\n        /**\n         * @hideconfigs type, triggerEvent\n         */\n    };\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n        config.chain.push(...['populateColumnHeaderMenu', 'populateColumnHeader', 'onColumnHeaderClick']);\n        return config;\n    }\n    //region Events\n    /**\n     * This event fires on the owning TaskBoard before the menu is shown for a column header.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event columnHeaderMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<string,MenuItemConfig>} items Menu item configs\n     * @param {TaskBoard.model.ColumnModel} columnRecord The column\n     * @on-owner\n     */\n    /**\n     * This event fires on the owning TaskBoard after the context menu is shown for a column header.\n     * @event cellMenuShow\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<string,MenuItemConfig>} items Menu item configs\n     * @param {TaskBoard.model.ColumnModel} columnRecord The column\n     * @on-owner\n     */\n    /**\n     * This event fires on the owning TaskBoard when an item is selected in the column header menu.\n     * @event cellMenuItem\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {TaskBoard.model.ColumnModel} columnRecord The column\n     * @on-owner\n     */\n    /**\n     * This event fires on the owning TaskBoard when a check item is toggled in the column header menu.\n     * @event cellMenuToggleItem\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {TaskBoard.model.ColumnModel} columnRecord The column\n     * @param {Boolean} checked Checked or not\n     * @on-owner\n     */\n    //endregion\n    //region Type assertions\n    changeItems(items) {\n        ObjectHelper.assertObject(items, 'features.columnHeaderMenu.items');\n        return items;\n    }\n    changeProcessItems(fn) {\n        ObjectHelper.assertFunction(fn, 'features.columnHeaderMenu.processItems');\n        return fn;\n    }\n    //endregion\n    // Inject a \"button\" into column headers\n    populateColumnHeader({ columnHeaderConfig }) {\n        if (!this.disabled) {\n            columnHeaderConfig.children.padder.children.menu = {\n                tag   : 'button',\n                class : {\n                    'b-column-header-button'                : 1,\n                    'b-taskboard-column-header-menu-button' : 1,\n                    'b-fw-icon'                             : 1,\n                    'b-icon-menu-horizontal'                : 1\n                }\n            };\n        }\n    }\n    // Populate menu events with taskboard specifics\n    getDataFromEvent(event) {\n        return ObjectHelper.assign(super.getDataFromEvent(event), event.taskBoardData);\n    }\n    // Add default menu items\n    populateColumnHeaderMenu({ items, columnRecord }) {\n        const { client } = this;\n        if (!client.readOnly) {\n            items.addTask = {\n                text   : 'L{TaskBoard.addTask}',\n                icon   : 'b-fw-icon b-icon-add',\n                weight : 100,\n                onItem() {\n                    client.addTask(columnRecord);\n                }\n            };\n        }\n    }\n    // Detect \"button\" click\n    onColumnHeaderClick(args) {\n        const { event } = args;\n        if (event.target.matches('.b-column-header-button')) {\n            this.showContextMenu(event, { target : event.target, align : 't90-b90' });\n        }\n    }\n    doDisable(disable) {\n        super.doDisable(disable);\n        !this.isConfiguring && this.client.recompose();\n    }\n    get showMenu() {\n        return true;\n    }\n}\n// Register this feature type with its Factory\nTaskBoardFeature.register(ColumnHeaderMenu.type, ColumnHeaderMenu);\nColumnHeaderMenu._$name = 'ColumnHeaderMenu';", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport '../../Core/widget/Toolbar.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardFeature from './TaskBoardFeature.js';\n/**\n * @module TaskBoard/feature/ColumnToolbars\n */\n/**\n * Adds toolbars to the top and/or bottom of each column. By default it adds a bottom toolbar containing a single button\n * for adding events to that column/swimlane:\n *\n * {@inlineexample TaskBoard/feature/ColumnToolbars.js}\n *\n * To add, remove or modify toolbar items for all columns, see {@link #config-topItems} and {@link #config-bottomItems}:\n *\n * {@inlineexample TaskBoard/feature/ColumnToolbarsAdd.js}\n *\n * To have per column/swimlane control over the items, see {@link #config-processItems}:\n *\n * {@inlineexample TaskBoard/feature/ColumnToolbarsProcess.js}\n *\n * In handlers for buttons etc, you can access which column/swimlane the action was taken in on the supplied `source`\n * param, using its `columnRecord` and `swimlaneRecord` properties:\n *\n * ```javascript\n * new TaskBoard({\n *    features : {\n *        columnToolbars : {\n *            topItems : {\n *                clearButton : {\n *                    icon    : 'b-fa-trash',\n *                    onClick({ source }) {\n *                        if (source.columnRecord) {\n *                            ...\n *                        }\n *                    }\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * This feature is **enabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype columnToolbars\n * @feature\n */\nexport default class ColumnToolbars extends TaskBoardFeature {\n    static $name = 'ColumnToolbars';\n    static type = 'columnToolbars';\n    static configurable = {\n        /**\n         * Items to add to the top toolbar, in object format.\n         *\n         *\n         * ```javascript\n         * new TaskBoard({\n         *    features : {\n         *        columnToolbars : {\n         *            topItems : {\n         *                clearButton : {\n         *                    icon    : 'b-fa-trash',\n         *                    onClick : ...\n         *                }\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Object<String,ContainerItemConfig|Boolean|null>}\n         */\n        topItems : null,\n        /**\n         * Items to add to the bottom toolbar, in object format.\n         *\n         * To remove existing items, set corresponding keys to `null`.\n         *\n         * ```javascript\n         * new TaskBoard({\n         *    features : {\n         *        columnToolbars : {\n         *            bottomItems : {\n         *                clearButton : {\n         *                    icon    : 'b-fa-trash',\n         *                    onClick : ...\n         *                }\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Object<String,ContainerItemConfig|Boolean|null>}\n         */\n        bottomItems : {\n            addTask : true\n        },\n        // Predefined items that can be used in topItems and/or bottomItems\n        namedItems : {\n            addTask : {\n                type              : 'button',\n                icon              : 'b-icon-add',\n                tooltip           : 'L{TaskBoard.addTask}',\n                ariaLabel         : 'L{TaskBoard.addTask}',\n                internalListeners : {\n                    click : 'onAddClick'\n                }\n            }\n        },\n        /**\n         * A function called before displaying the toolbar that allows manipulations of its items.\n         * Returning `false` from this function prevents the menu being shown.\n         *\n         * ```javascript\n         * features         : {\n         *    columnToolbars : {\n         *         processItems({ items, location, columnRecord, swimlaneRecord }) {\n         *             // Add or hide existing items here as needed\n         *             items.myAction = {\n         *                 text   : 'Cool action',\n         *                 icon   : 'b-fa-ban',\n         *                 onClick : () => console.log(`Clicked button for ${columnRecord.text}`)\n         *             };\n         *\n         *            if (columnRecord.id === 'done') {\n         *                items.addTask = false\n         *            }\n         *         }\n         *     }\n         * },\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} context An object with information about the toolbar being shown\n         * @param {Object<String,ContainerItemConfig>} context.items An object containing the toolbar item configs keyed by ref\n         * @param {'top'|'bottom'} context.location Toolbar location, \"top\" or \"bottom\"\n         * @param {TaskBoard.model.ColumnModel} context.columnRecord Record representing toolbars column\n         * @param {TaskBoard.model.SwimlaneModel} context.swimlaneRecord Record representing toolbars swimlane\n         * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n         * @preventable\n         */\n        processItems : null\n    };\n    // Holds exising toolbars, keyed by location, column and swimlane\n    columnMap = new Map();\n    static pluginConfig = {\n        chain : ['populateColumn', 'onRemoveColumnElement', 'onRemoveSwimlaneElement']\n    };\n    doDestroy() {\n        for (const [, toolbar] of this.columnMap) {\n            toolbar.destroy();\n        }\n        super.doDestroy();\n    }\n    //region Type assertions\n    changeTopItems(items) {\n        ObjectHelper.assertObject(items, 'features.columnToolbars.topItems');\n        return items;\n    }\n    changeBottomItems(items) {\n        ObjectHelper.assertObject(items, 'features.columnToolbars.bottomItems');\n        return items;\n    }\n    changeProcessItems(fn) {\n        ObjectHelper.assertFunction(fn, 'features.columnToolbars.processItems');\n        return fn;\n    }\n    //endregion\n    //region Toolbars\n    // removeToolbar(location) {\n    //     const columnMap = this.columnMap;\n    //\n    //     for (const [key, toolbar] of columnMap) {\n    //         if (key.startsWith(location)) {\n    //             toolbar.destroy();\n    //             columnMap.delete(toolbar);\n    //         }\n    //     }\n    // }\n    //\n    // changeTopItems(items, old) {\n    //     if (old && !items) {\n    //         this.removeToolbar('top');\n    //     }\n    //\n    //     return items;\n    // }\n    //\n    // changeBottomItems(items, old) {\n    //     if (old && !items) {\n    //         this.removeToolbar('items');\n    //     }\n    //\n    //     return items;\n    // }\n    // Creates or retrieves a toolbar instance for the requested column/swimlane intersection\n    getToolbar(location, columnRecord, swimlaneRecord) {\n        const\n            me                                = this,\n            { columnMap, client, namedItems } = me,\n            items                             = me[`${location}Items`],\n            key                               = `${location}_._${columnRecord.domId}_._${swimlaneRecord?.domId ?? 'default'}`;\n        let toolbar = columnMap.get(key);\n        if (!toolbar) {\n            const clonedItems = {};\n            // items allows configuring out using falsy value, only iterate the truthy ones\n            ObjectHelper.getTruthyKeys(items).map(ref => {\n                const\n                    // Could match a named item, to either be used as is or use reconfigured\n                    namedItem = namedItems[ref],\n                    // Item config or a truthy value to include a named item as is\n                    item      = items[ref];\n                clonedItems[ref] = ObjectHelper.merge(\n                    // Default listeners + decorate with records\n                    {\n                        internalListeners : {\n                            click   : 'onClick',\n                            change  : 'onChange',\n                            thisObj : me\n                        },\n                        columnRecord,\n                        swimlaneRecord\n                    },\n                    // Merge with any matched named item\n                    namedItem,\n                    // And any supplied config\n                    item\n                );\n            });\n            // Allow client code to alter items before adding them to the toolbar\n            if (me.processItems?.({ items : clonedItems, location, columnRecord, swimlaneRecord }) === false) {\n                return null;\n            }\n            // Create toolbar using the processed items\n            toolbar = client.add({\n                type                      : 'toolbar',\n                cls                       : `b-taskboard-column-${location[0]}bar`,\n                overflow                  : null,\n                monitorResize             : false,\n                contentElMutationObserver : false,\n                items                     : clonedItems,\n                dataset                   : {\n                    role          : `${location}-toolbar`,\n                    domTransition : true\n                }\n            });\n            columnMap.set(key, toolbar);\n        }\n        return toolbar.element;\n    }\n    populateColumn({ columnConfig, columnRecord, swimlaneRecord }) {\n        const me = this;\n        if (!me.disabled) {\n            // Add top toolbar, if it has items\n            if (ObjectHelper.getTruthyKeys(me.topItems).length) {\n                DomHelper.merge(columnConfig, {\n                    children : {\n                        'tbar > body' : me.getToolbar('top', columnRecord, swimlaneRecord)\n                    }\n                });\n            }\n            // Add bottom toolbar, if it has items\n            if (ObjectHelper.getTruthyKeys(me.bottomItems).length) {\n                columnConfig.children.bbar = me.getToolbar('bottom', columnRecord, swimlaneRecord);\n            }\n        }\n    }\n    removeColumnToolbar(location, columnId, swimlaneId) {\n        const\n            { columnMap, client } = this,\n            key                   = `${location}_._${columnId}_._${swimlaneId}`,\n            toolbar               = columnMap.get(key);\n        if (toolbar) {\n            client.remove(toolbar);\n            // Toolbar gets removed during a compose, which leads to a race condition with syncOverflowVisibility.\n            // Postpone destroy til after compose to avoid this\n            client.setTimeout(() => toolbar.destroy(), 0);\n            columnMap.delete(key);\n        }\n    }\n    removeColumnToolbars(columnId, swimlaneId) {\n        this.removeColumnToolbar('top', columnId, swimlaneId);\n        this.removeColumnToolbar('bottom', columnId, swimlaneId);\n    }\n    onRemoveColumnElement({ columnId, swimlaneRecord }) {\n        this.removeColumnToolbars(columnId, swimlaneRecord.id ?? 'default');\n    }\n    onRemoveSwimlaneElement({ swimlaneId }) {\n        for (const column of this.client.columns) {\n            this.removeColumnToolbars(column.id, swimlaneId);\n        }\n    }\n    //endregion\n    //region Predefined items events\n    onAddClick({ source }) {\n        this.client.addTask(source.columnRecord, source.swimlaneRecord);\n    }\n    //endregion\n    //region Generic events\n    onChange({ source }) {\n        this.trigger('itemChange', {\n            item           : source,\n            columnRecord   : source.columnRecord,\n            swimlaneRecord : source.swimlaneRecord\n        });\n    }\n    onClick({ source }) {\n        this.trigger('itemClick', {\n            item           : source,\n            columnRecord   : source.columnRecord,\n            swimlaneRecord : source.swimlaneRecord\n        });\n    }\n    //endregion\n}\nColumnToolbars.initClass();\nColumnToolbars._$name = 'ColumnToolbars';", "import Base from '../../../Core/Base.js';\nimport Factoryable from '../../../Core/mixin/Factoryable.js';\n/**\n * @module TaskBoard/view/item/TaskItem\n */\n/**\n * Config options for all TaskItems combined. See respective item classes for more information.\n * @typedef {Object} TaskItemOptions\n * @property {String} type Type of the item\n * @property {String} [field] Field to display in the item. Usually inferred from the key when supplying items\n * @property {String|Object} [style] Style definition in string or object form\n * @property {String} [cls] CSS class to add\n * @property {Number} [order] Flex order, can be used to re-order task items\n * @property {Boolean} [hidden] Specify `true` to hide the task item\n * @property {String|Object} [editor] Widget type or config to use as the editor for this item. Used in the inline task\n * editor. Set to `null` to not use an editor for this item\n * @property {String} [baseUrl] For `type : 'image'` - Url prepended to this items value\n * @property {Function} [template] For `type : 'template'` - Template function used to generate task content\n * @property {Number} [max] For `type : 'progress'` and `type : 'rating'` - Max value\n * @property {String} [textField] For `type : 'todoList'` - Name of a property on a todo item to display as its text\n * @property {String} [checkedField] For `type : 'todoList'` - Name of a property on a todo item to use for the checkbox\n * @property {String} [clsField] For `type : 'todoList'` - Name of a property on a todo item whose value will be added\n * as a CSS class to the todo item\n * @property {Number} [maxAvatars] For `type : 'resourceAvatars'` - Maximum avatars to display by default.\n * @property {Boolean} [overlap] For `type : 'resourceAvatars'` - Specify `true` to slightly overlap avatars for tasks\n * @property {String} [textProperty] For `type : 'tags'` - Property used to display the tag text\n * @property {String} [clsProperty] For `type : 'tags'` - Property used to add a CSS class to each tag\n * @property {String} [separator] For `type : 'tags'` - Property used to split a value string into tags\n */\n/**\n * Abstract base class for task items, lightweight \"widgets\" that can be added to tasks using the\n * {@link TaskBoard/view/TaskBoard#config-headerItems}, {@link TaskBoard/view/TaskBoard#config-bodyItems} and\n * {@link TaskBoard/view/TaskBoard#config-footerItems} configs.\n *\n * @abstract\n */\nexport default class TaskItem extends Base.mixin(Factoryable) {\n    static factoryable = {};\n    static configurable = {\n        /**\n         * Task field whose value item will act on (usually display it). Defaults to use the key in the items object.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    features : {\n         *        taskItems : {\n         *            items : {\n         *                // Will use \"prio\" as its field\n         *                prio  : { type : 'textitem' },\n         *                // Will use \"status\" as its field\n         *                state : { type : 'textitem', field : 'status' }\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {String} field\n         * @category Common\n         */\n        /**\n         * Style definition in string or object form.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    features : {\n         *        taskItems : {\n         *            items : {\n         *                prio  : { type : 'textitem', style : { color : 'red' } }\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {String|Object} style\n         * @category Common\n         */\n        /**\n         * Specify `true` to hide the task item.\n         *\n         * @config {Boolean} hidden\n         * @category Common\n         */\n        /**\n         * Flex order, can be used to re-order task items.\n         *\n         * @config {Number} order\n         * @default 1\n         * @category Common\n         */\n        /**\n         * CSS class to add.\n         *\n         * @config {String} cls\n         * @category Common\n         */\n        /**\n         * Widget type or config to use as the editor for this item. Used in the inline task editor.\n         * Set to `null` to not use an editor for this item.\n         *\n         * @config {String|Object} editor\n         * @default text\n         * @category Common\n         */\n    };\n    static defaultEditor = { type : 'text' };\n    static getEditorConfig({ config, item }) {\n        const editor = config.editor !== null && (config.editor || item.defaultEditor);\n        if (typeof editor === 'string') {\n            return {\n                type : editor\n            };\n        }\n        return editor;\n    }\n}\nTaskItem._$name = 'TaskItem';", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport TaskItem from '../view/item/TaskItem.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Editor from '../../Core/widget/Editor.js';\nconst actions = {\n    editNext     : 1,\n    cancel       : 1,\n    editPrevious : 1,\n    complete     : 1\n};\n/**\n * @module TaskBoard/feature/SimpleTaskEdit\n */\n/**\n * This feature allows inline editing of tasks. Double clicking an item starts editing it:\n *\n * {@inlineexample TaskBoard/feature/SimpleTaskEdit.js}\n *\n * Each {@link TaskBoard.view.item.TaskItem task item} can define an\n * {@link TaskBoard.view.item.TaskItem#config-editor}. To prevent an item from being edited inline, configure it with\n * `editor : null`:\n *\n * {@inlineexample TaskBoard/feature/SimpleTaskEditCustom.js}\n *\n * This feature is **disabled** by default.\n *\n * {@region Keyboard shortcuts}\n * The feature has the following default keyboard shortcuts:\n *\n * | Keys            | Action         | Action description                                                                   |\n * |-----------------|----------------|--------------------------------------------------------------------------------------|\n * | `Enter`         | *editNext*     | In an editor this will accept the change and start editing the next item on that card or the first item on the next card. By default it adds a new task when pressed on the last item of the last card in a column. This behaviour is configurable using the {@link #config-addNewAtEnd} config. |\n * | `Escape`        | *cancel*       | Cancels editing and reverts changes for that item which is currently being edited    |\n * | `Shift`+`Enter` | *editPrevious* | In an editor this will accept the change and start editing the previous item on that card or the last item on the previous card |\n * | `Ctrl`+`Enter`  | *complete*     | Accepts the edit and closes the editor                                               |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#TaskBoard/guides/customization/keymap.md).\n * {@endregion}\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype simpleTaskEdit\n * @feature\n */\nexport default class SimpleTaskEdit extends TaskBoardFeature {\n    static $name = 'SimpleTaskEdit';\n    static type = 'simpleTaskEdit';\n    static configurable = {\n        /**\n         * Pressing `Enter` in last item on last task in a column adds a new task.\n         * @config {Boolean}\n         * @default\n         */\n        addNewAtEnd : true,\n        /**\n         * A configuration object for the {@link Core.widget.Editor} used by this feature. Useful when you want to\n         * validate the value being set by the end user (see {@link Core.widget.Editor#event-beforeComplete}).\n         *\n         * @config {EditorConfig}\n         */\n        editorConfig : {},\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            Enter         : 'editNext',\n            Escape        : 'cancel',\n            'Ctrl+Enter'  : 'complete',\n            'Shift+Enter' : 'editPrevious'\n        }\n    };\n    static pluginConfig = {\n        assign : ['editTask'],\n        before : ['onActivateTask']\n    };\n    //region Type assertions\n    changeAddNewAtEnd(addNewAtEnd) {\n        ObjectHelper.assertBoolean(addNewAtEnd, 'features.simpleTaskEdit.addNewAtEnd');\n        return addNewAtEnd;\n    }\n    //endregion\n    /**\n     * Starts inline editing of the supplied task, optionally for a specific item on its card.\n     * @on-owner\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record to edit\n     * @param {HTMLElement} [element] Card element or card item element to edit. Resolves element from the passed record\n     * if left out.\n     * @returns {Boolean} Returns `true` if editing started, `false` if it did not.\n     */\n    editTask(taskRecord, element) {\n        const\n            me        = this,\n            taskBoard = me.client;\n        // Get element from record if none supplied\n        if (!element) {\n            element = taskBoard.getTaskElement(taskRecord);\n        }\n        const\n            // Get a task item from the element, will yield first task item when given the card element\n            taskItem         = taskBoard.resolveTaskItem(element),\n            itemElement      = taskItem.element,\n            itemEditorConfig = TaskItem.getEditorConfig(taskItem);\n        // Allow disabling editing for an item using `editor : null`\n        if (!itemEditorConfig) {\n            return false;\n        }\n        /**\n         * Fires on the owning TaskBoard before displaying an inline editor. Returning `false` stops the editor from\n         * being shown.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        beforeSimpleTaskEdit({ taskRecord }) {\n         *            // Some condition for which editing should be blocked...\n         *            if (taskRecord.disallowed) {\n         *                return false;\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event beforeSimpleTaskEdit\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source The task board\n         * @param {TaskBoard.feature.SimpleTaskEdit} simpleTaskEdit The simpleTaskEdit feature\n         * @param {TaskBoard.model.TaskModel} taskRecord The record about to be shown in the editor\n         * @param {String} field Field name being edited\n         */\n        // Give clients a shot at preventing editing\n        if (\n            me.disabled || taskRecord.readOnly ||\n            taskBoard.trigger('beforeSimpleTaskEdit', { simpleTaskEdit : me, taskRecord, field : taskItem.config.field }) === false\n        ) {\n            return true;\n        }\n        // Focus the card to ensure focus reverts to it when editor closes\n        element.focus();\n        const editor = me.editor = Editor.new({\n            owner        : taskBoard,\n            appendTo     : itemElement.parentNode,\n            scrollAction : 'realign',\n            cls          : 'b-simple-task-editor',\n            completeKey  : null,\n            cancelKey    : null,\n            inputField   : {\n                autoSelect : true,\n                name       : taskItem.config.field,\n                ...itemEditorConfig\n            },\n            align : {\n                align          : 'c-c',\n                allowTargetOut : false\n            },\n            internalListeners : {\n                complete   : 'onEditorComplete',\n                cancel     : 'onEditorCancel',\n                finishEdit : 'onEditorFinishEdit',\n                thisObj    : me\n            }\n        }, me.editorConfig);\n        // Store active element, to be able to navigate to next/prev later if requested\n        me.currentElement = itemElement;\n        // Add editing cls, will be cleared by recompose\n        itemElement.classList.add('b-editing');\n        // Match editor color to item color\n        const color = DomHelper.getStyleValue(itemElement, 'color');\n        editor.element.style.color = color;\n        editor.inputField.element.style.color = color;\n        // Don't want a recompose removing editor element\n        editor.element.retainElement = true;\n        // Scrolling card into view\n        taskBoard.getTaskElement(taskRecord).scrollIntoView({\n            block : 'nearest'\n        });\n        // And then item being edited. Two steps since first one won't do anything if card is already in view while item\n        // is not\n        itemElement.scrollIntoView({\n            block : 'nearest'\n        });\n        editor.startEdit({\n            target : taskItem.element,\n            record : taskRecord,\n            field  : taskItem.config.field\n        });\n        return true;\n    }\n    // Edit previous task item\n    async editPrevious(event) {\n        const\n            me                 = this,\n            { client, editor } = me,\n            taskRecord         = editor.record,\n            cardElement        = client.getTaskElement(taskRecord),\n            itemElements       = Array.from(cardElement.querySelectorAll('.b-taskboard-taskitem.b-editable')),\n            index              = itemElements.indexOf(me.currentElement) - 1;\n        if (await me.complete(event)) {\n            // More items on the card, edit prev item\n            if (index >= 0) {\n                me.editTask(taskRecord, itemElements[index]);\n            }\n            // No more items\n            else {\n                const prevTaskRecord = client.getPreviousTask(taskRecord, false);\n                // Edit last item of prev card\n                if (prevTaskRecord) {\n                    const\n                        prevCardElement  = client.getTaskElement(prevTaskRecord),\n                        prevItemElements = Array.from(prevCardElement.querySelectorAll('.b-taskboard-taskitem.b-editable'));\n                    me.editTask(prevTaskRecord, prevItemElements[prevItemElements.length - 1]);\n                }\n            }\n        }\n    }\n    // Edit next task item\n    async editNext(event) {\n        const\n            me                 = this,\n            { client, editor } = me,\n            taskRecord         = editor.record,\n            cardElement        = client.getTaskElement(taskRecord),\n            itemElements       = Array.from(cardElement.querySelectorAll('.b-taskboard-taskitem.b-editable')),\n            index              = itemElements.indexOf(me.currentElement) + 1;\n        if (await me.complete(event)) {\n            // More items on the card, edit next item\n            if (index < itemElements.length) {\n                me.editTask(taskRecord, itemElements[index]);\n            }\n            // No more items\n            else {\n                const nextTaskRecord = client.getNextTask(taskRecord, false);\n                // Edit next card\n                if (nextTaskRecord) {\n                    me.editTask(nextTaskRecord);\n                }\n                // Or add a new card\n                else if (me.addNewAtEnd) {\n                    client.addTask(client.getColumn(taskRecord), client.getSwimlane(taskRecord));\n                }\n            }\n        }\n    }\n    complete(event) {\n        return this.editor.completeEdit(null, event);\n    }\n    cancel(event) {\n        this.editor.cancelEdit(event);\n    }\n    // Start editing when activating task (enter/dblclick)\n    onActivateTask({ taskRecord, event }) {\n        if (this.editTask(taskRecord, event.target)) {\n            // Block other actions (TaskEdit)\n            event.preventDefault();\n        }\n    }\n    onEditorComplete({ source }) {\n        /**\n         * Fires on the owning TaskBoard when inline editing of a field has successfully finished.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        simpleTaskEditComplete({ taskRecord, field }) {\n         *            Toast.show(`Finished editing ${field} of ${taskRecord.name}`);\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event simpleTaskEditComplete\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source The task board\n         * @param {TaskBoard.feature.SimpleTaskEdit} simpleTaskEdit The simpleTaskEdit feature\n         * @param {TaskBoard.model.TaskModel} taskRecord Record that was edited\n         * @param {String} field Field name being edited\n         */\n        this.client.trigger('simpleTaskEditComplete', { simpleTaskEdit : this, taskRecord : source.record, field : source.dataField  });\n    }\n    onEditorCancel({ source }) {\n        /**\n         * Fires on the owning TaskBoard when inline editing of a field is cancelled (by pressing ESC).\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        simpleTaskEditCancel({ taskRecord }) {\n         *            Toast.show(`Aborted editing of ${taskRecord.name}`);\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event simpleTaskEditCancel\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source The task board\n         * @param {TaskBoard.feature.SimpleTaskEdit} simpleTaskEdit The simpleTaskEdit feature\n         * @param {TaskBoard.model.TaskModel} taskRecord Record that was edited\n         * @param {String} field Field name being edited\n         */\n        this.client.trigger('simpleTaskEditCancel', { simpleTaskEdit : this, taskRecord : source.record, field : source.dataField  });\n    }\n    onEditorFinishEdit() {\n        // Have to store editor before the timeout, might get replaced by new\n        const\n            me = this,\n            { editor } = me;\n        editor?.setTimeout(() => {\n            // Don't retain the element if we did not start editing something else\n            if (me.editor === editor) {\n                me.currentElement = null;\n                me.editor = null;\n            }\n            editor.destroy();\n        }, 0);\n    }\n    // All keyMap actions require that we are editing\n    isActionAvailable({ actionName }) {\n        if (actions[actionName]) {\n            return Boolean(this.editor);\n        }\n    }\n}\nSimpleTaskEdit.initClass();\nSimpleTaskEdit._$name = 'SimpleTaskEdit';", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport Base from '../../Core/Base.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Draggable from '../../Core/mixin/Draggable.js';\nimport Droppable from '../../Core/mixin/Droppable.js';\n/**\n * @module TaskBoard/feature/SwimlaneDrag\n */\n/**\n * This feature allows users to drag drop swimlanes on the TaskBoard changing their order (by grabbing their header).\n *\n * {@inlineexample TaskBoard/feature/SwimlaneDrag.js}\n *\n * This feature is **disabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype swimlaneDrag\n * @feature\n */\nexport default class SwimlaneDrag extends TaskBoardFeature {\n    static $name = 'SwimlaneDrag';\n    static type = 'swimlaneDrag';\n    static pluginConfig = {\n        after : ['initialCompose']\n    };\n    initialCompose() {\n        const me     = this;\n        // Cannot use configurable since bodyElement is not available yet when feature is pulled in\n        me.draggable = SwimlaneZone.new({\n            dragRootElement : me.disabled ? null : me.client.bodyWrapElement,\n            dropRootElement : me.client.bodyWrapElement,\n            owner           : me\n        }, me.draggable);\n    }\n    doDisable(disable) {\n        super.doDisable(disable);\n        if (this.draggable) {\n            this.draggable.dragRootElement = disable ? null : this.client.bodyWrapElement;\n        }\n    }\n}\nSwimlaneDrag.initClass();\nclass SwimlaneZone extends Base.mixin(Draggable, Droppable) {\n    static get configurable() {\n        return {\n            dragSelector     : '.b-taskboard-swimlane-header, .b-taskboard-swimlane-header *',\n            dragItemSelector : '.b-taskboard-swimlane-header',\n            draggingItemCls : null,\n            dragProxy : {\n                type : 'default',\n                async open(drag) {\n                    const\n                        { owner }       = this,\n                        {\n                            itemElement,\n                            startEvent\n                        }               = drag,\n                        taskBoard       = owner.owner.client,\n                        swimlaneRecord  = taskBoard.resolveSwimlaneRecord(itemElement),\n                        swimlaneElement = taskBoard.getSwimlaneElement(swimlaneRecord),\n                        padding         = DomHelper.getStyleValue(\n                            swimlaneElement.syncIdMap.body,\n                            ['padding-left', 'padding-right']\n                        ),\n                        bounds          = Rectangle.from(swimlaneElement, owner.dragRootElement).deflate(\n                            0,\n                            parseFloat(padding['padding-right']),\n                            0,\n                            parseFloat(padding['padding-left'])\n                        ),\n                        // Offset from cursor\n                        proxyOffset     = EventHelper.getClientPoint(startEvent).getDelta(bounds),\n                        // Drag proxy, positioned over column being dragged\n                        proxy           = DomHelper.createElement({\n                            className : 'b-taskboard-swimlane-drag-proxy',\n                            parent    : owner.dragRootElement,\n                            style     : {\n                                // Using fixed top, only draggable horizontally\n                                top   : EventHelper.getClientPoint(startEvent).translate(0, proxyOffset[1]).y,\n                                // Offset from cursor to be positioned over original column\n                                left  : bounds.x,\n                                // Need a fixed height on the proxy, since columns width might be flexed etc\n                                width : bounds.width\n                            },\n                            // Don't want it being removed while dragging\n                            retainElement : true\n                        });\n                    // Things we want to access later on drag\n                    Object.assign(drag, {\n                        proxy,\n                        swimlaneRecord,\n                        swimlaneElement,\n                        proxyOffset,\n                        // Used to size dropIndicator\n                        bounds\n                    });\n                    // Clone all dragged column elements and put them in the proxy\n                    const swimlaneClone = swimlaneElement.cloneNode(true);\n                    proxy.appendChild(swimlaneClone);\n                },\n                dragMove({ proxy, event, proxyOffset }) {\n                    // Move along y-axis only\n                    const position = EventHelper.getClientPoint(event).translate(0, proxyOffset[1]);\n                    proxy.style.top = `${position.y}px`;\n                }\n            }\n        };\n    }\n    setupDragContext(event) {\n        const\n            result = super.setupDragContext(event),\n            { client } = this.owner;\n        result.scrollManager = client.scrollManager;\n        result.monitoringConfig = {\n            scrollables : [{\n                element   : client.bodyElement,\n                direction : 'vertical'\n            }]\n        };\n        return result;\n    }\n    dragStart(drag) {\n        // Trigger something...\n    }\n    dragEnter(drag) {\n        // Only accept swimlanes\n        if (!drag.itemElement.matches(this.dragItemSelector)) {\n            return false;\n        }\n        // Create drop indicators on first enter\n        if (!drag.dropIndicator) {\n            const { bounds } = drag;\n            // Need one indicator for each part of the column\n            drag.dropIndicator = DomHelper.createElement({\n                className   : 'b-taskboard-swimlane-drop-indicator',\n                elementData : {\n                    dropIndicator : true\n                },\n                // Use same size as dragged column had originally\n                style : {\n                    width  : bounds.width,\n                    height : bounds.height\n                }\n            });\n            this.insertDropIndicator(drag.dropIndicator, drag.swimlaneRecord);\n            drag.swimlaneElement.classList.add('b-drag-original');\n        }\n    }\n    insertDropIndicator(dropIndicator, beforeSwimlaneRecord) {\n        const { client } = this.owner;\n        client.bodyElement.insertBefore(\n            dropIndicator,\n            beforeSwimlaneRecord && client.getSwimlaneElement(beforeSwimlaneRecord)\n        );\n    }\n    async dragMove(drag) {\n        const\n            { client }       = this.owner,\n            { documentRoot } = client,\n            taskBoardBounds  = Rectangle.from(client.element, undefined, true),\n            proxyBounds      = Rectangle.from(drag.proxy, undefined, true),\n            // Check element under proxy left center, should get a swimlane (or a gap)\n            overElement      = proxyBounds.center.y > taskBoardBounds.bottom\n                ? documentRoot.elementFromPoint(proxyBounds.x, proxyBounds.y)\n                : documentRoot.elementFromPoint(proxyBounds.x, proxyBounds.center.y),\n            swimlaneElement  = overElement?.closest('.b-taskboard-swimlane');\n        // If we are over the drop indicator or something not a column header, we do nothing\n        if (!overElement?.elementData?.dropIndicator && swimlaneElement) {\n            const targetBounds = Rectangle.from(swimlaneElement, undefined, true);\n            // Column that we are going to insert the dragged column before or after\n            let beforeSwimlane = client.resolveSwimlaneRecord(swimlaneElement);\n            // If beyond center, insert before next column\n            if (proxyBounds.center.y > targetBounds.center.y) {\n                beforeSwimlane = client.swimlanes.getNext(beforeSwimlane);\n            }\n            this.insertDropIndicator(drag.dropIndicator, beforeSwimlane);\n            drag.beforeSwimlane = beforeSwimlane;\n        }\n    }\n    async dragDrop(drag) {\n        // Data part\n        const\n            { client }    = this.owner,\n            { swimlanes } = client,\n            {\n                swimlaneRecord,\n                beforeSwimlane,\n                swimlaneElement,\n                dropIndicator,\n                proxy\n            }             = drag;\n        function commit() {\n            // Remove proxy & dropIndicator\n            proxy.remove();\n            dropIndicator.remove();\n            // Restore original element\n            swimlaneElement.classList.remove('b-drag-original');\n            // Update data\n            beforeSwimlane !== undefined && swimlanes.move(swimlaneRecord, beforeSwimlane);\n            client.trigger('dropSwimlane', { beforeSwimlane, drag });\n        }\n        // UI part\n        // We are dropping, this cls by default has a transition\n        proxy.classList.add('b-dropping');\n        // Move proxy to drop location, allowing it to transition there\n        DomHelper.alignTo(\n            proxy,\n            Rectangle.from(dropIndicator, undefined, true)\n        );\n        // Update record after the transition, to prevent too early redraw (which would ruin the transition)\n        if (DomHelper.getPropertyTransitionDuration(proxy, 'transform')) {\n            EventHelper.onTransitionEnd({\n                element  : proxy,\n                property : 'transform',\n                handler  : commit,\n                thisObj  : client\n            });\n        }\n        // Or right away if no transition is used\n        else {\n            commit();\n        }\n    }\n    dragLeave(drag) {\n        // Doing nothing feels ok for now\n    }\n}\nSwimlaneDrag._$name = 'SwimlaneDrag';", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport Base from '../../Core/Base.js';\nimport AsyncHelper from '../../Core/helper/AsyncHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Draggable from '../../Core/mixin/Draggable.js';\nimport Droppable from '../../Core/mixin/Droppable.js';\nimport Events from '../../Core/mixin/Events.js';\n/**\n * @module TaskBoard/feature/TaskDrag\n */\nconst\n    cardSelector = '.b-taskboard-card, .b-taskboard-card-drop-indicator',\n    // Index of the specified card/drop indicator (other drop indicators excluded)\n    indexOf      = (element, ignoreOriginal = false) => DomHelper\n        .children(element.parentElement, `.b-taskboard-card${ignoreOriginal ? ':not(.b-drag-original)' : ''}, .b-first-drop-indicator`)\n        .indexOf(element),\n    // Check if any drop indicator has moved in a way that will lead to task changes\n    hasChanged   = dropIndicators => dropIndicators.some((dropIndicator, i) => {\n        return (\n            // Moved to another parent is a change (another column or another swimlane)\n            dropIndicator.parentElement !== dropIndicator.elementData.initialParent ||\n            // Or if first drop indicator has changed index (the others follow it, no need to check)\n            (i === 0 && indexOf(dropIndicator, true) !== dropIndicator.elementData.initialIndex)\n        );\n    });\n/**\n * This feature allows cards on the TaskBoard to be dragged across swimlanes and columns but also vertically in the\n * same column to change the order:\n *\n * {@inlineexample TaskBoard/feature/TaskDrag.js}\n *\n * When a task is dropped, its {@link TaskBoard.view.TaskBoard#config-columnField},\n * {@link TaskBoard.view.TaskBoard#config-swimlaneField} and/or {@link TaskBoard.model.TaskModel#field-weight} fields\n * are updated to reflect the new location.\n *\n * ## Drag events\n *\n * The different stages of a drag operation trigger different events, in order of appearance:\n *\n * | Event                         | Description                                                                    |\n * |-------------------------------|--------------------------------------------------------------------------------|\n * | {@link #event-beforeTaskDrag} | Preventable event fired before a drag starts                                   |\n * | {@link #event-taskDragStart}  | Fired when dragging starts                                                     |\n * | {@link #event-taskDrag}       | Fired when movement during a drag will lead to changes                         |\n * | {@link #event-beforeTaskDrop} | Preventable event fired before finalizing a valid drop. Allows async listeners |\n * | {@link #event-taskDrop}       | Fired after finalizing a valid drop                                            |\n * | {@link #event-taskDragAbort}  | Fired when a drag is aborted (ESC, drop out of bounds or by a listener)        |\n * | {@link #event-taskDragEnd}    | Fired when a started drag ends, no matter the outcome                          |\n *\n * The {@link #event-beforeTaskDrop} is useful for example to request user confirmation for a drop:\n *\n * {@inlineexample TaskBoard/feature/TaskDragEvents.js}\n *\n * This feature is **enabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskDrag\n * @feature\n */\nexport default class TaskDrag extends TaskBoardFeature {\n    static $name = 'TaskDrag';\n    static type = 'taskDrag';\n    static pluginConfig = {\n        after : ['initialCompose']\n    };\n    static configurable = {\n        /**\n         * Specify `true` to enable the old behavior of moving tasks in the store on drop.\n         *\n         * This behaviour was made opt in since it does not play well when sharing data with other components.\n         *\n         * <div class=\"note\">\n         * If you are sorting tasks by a field other than `weight` and want predictable results on drop, you should\n         * enable this config.\n         * </div>\n         *\n         * @config {Boolean}\n         * @default\n         */\n        reorderTaskRecords : false,\n        /**\n         * The number of milliseconds that must elapse after a `touchstart` event before it is considered a drag. If\n         * movement occurs before this time, the drag is aborted. This is to allow touch swipes and scroll gestures.\n         * @config {Number}\n         * @default 300\n         */\n        dragTouchStartDelay : null\n    };\n    initialCompose() {\n        const me = this;\n        // Cannot use configurable since bodyElement is not available yet when feature is pulled in\n        me.draggable = TaskZone.new({\n            dragRootElement                                                      : me.disabled ? null : me.client.bodyWrapElement,\n            dropRootElement                                                      : me.client.bodyWrapElement,\n            owner                                                                : me,\n            [me.dragTouchStartDelay != null ? 'dragTouchStartDelay' : undefined] : me.dragTouchStartDelay,\n            internalListeners                                                    : {\n                beforeDragStart : 'onBeforeDragStart',\n                dragStart       : 'onDragStart',\n                thisObj         : me\n            }\n        }, me.draggable);\n    }\n    doDestroy() {\n        super.doDestroy();\n        this.draggable?.destroy();\n    }\n    doDisable(disable) {\n        super.doDisable(disable);\n        if (this.draggable) {\n            this.draggable.dragRootElement = disable ? null : this.client.bodyWrapElement;\n        }\n    }\n    onBeforeDragStart({ drag, event }) {\n        /**\n         * Fires on the owning TaskBoard before task dragging starts. Return `false` to prevent the action\n         * @event beforeTaskDrag\n         * @preventable\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Tasks to be dragged\n         * @param {Event} domEvent The mouse event\n         */\n        return this.client.trigger('beforeTaskDrag', { drag, event, domEvent : event, taskRecords : drag.taskRecords });\n    }\n    onDragStart({ drag, event }) {\n        /**\n         * Fires on the owning TaskBoard when task dragging starts\n         * @event taskDragStart\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Tasks to be dragged\n         * @param {Event} domEvent The mouse event\n         */\n        return this.client.trigger('taskDragStart', { drag, event, domEvent : event, taskRecords : drag.taskRecords });\n    }\n}\nTaskDrag.initClass();\nclass TaskZone extends Base.mixin(Draggable, Droppable, Events) {\n    static get configurable() {\n        return {\n            dragSelector       : '.b-taskboard-card:not(.b-readonly)',\n            dragItemSelector   : '.b-taskboard-card:not(.b-readonly)',\n            // Accept drops on anything within the TaskBoard\n            dropTargetSelector : '.b-taskboardbase',\n            // We are going to allow dragging multiple cards, will need to add cls manually to all of them\n            draggingItemCls : null,\n            dragProxy : {\n                type : 'default',\n                async open(drag) {\n                    const\n                        {\n                            itemElement,\n                            startEvent\n                        }          = drag,\n                        taskBoard  = this.owner.owner.client,\n                        columnEl   = itemElement.closest('.b-taskboard-column'),\n                        taskRecord = taskBoard.resolveTaskRecord(itemElement),\n                        proxy      = drag.proxy = DomHelper.createElement({\n                            // Add column classes too to get exact same styles applied\n                            className     : 'b-taskboard-drag-proxy ' + columnEl.className,\n                            role          : 'presentation',\n                            // Don't want it being removed while dragging\n                            retainElement : true\n                        }),\n                        cardClones = [];\n                    let taskRecords;\n                    // If we have selected tasks, drag them only if drag starts from one of the selected\n                    if (taskBoard.selectedTasks.includes(taskRecord)) {\n                        taskRecords = taskBoard.selectedTasks.filter(t => !t.readOnly).sort((a, b) => a.parentIndex - b.parentIndex);\n                    }\n                    // Otherwise (no selection or dragging an unselected) only drag one\n                    else {\n                        taskRecords = [taskRecord];\n                    }\n                    const taskElements = taskRecords.map(r => taskBoard.getTaskElement(r));\n                    Object.assign(drag, {\n                        taskElements,\n                        // Store heights, cannot measure later when original tasks are hidden\n                        taskHeights : new Map(),\n                        // Offset from cursor, ignoring page scroll = client coords\n                        proxyOffset : EventHelper\n                            .getClientPoint(startEvent)\n                            .getDelta(Rectangle.from(itemElement, null, true))\n                    });\n                    // Clone all dragged cards and put them in the proxy\n                    taskElements.forEach(taskElement => {\n                        const\n                            { elementData } = taskElement,\n                            cardClone       = taskElement.cloneNode(true),\n                            bounds          = Rectangle.from(taskElement, itemElement);\n                        // Cards get their width from the column, need to apply the width to the proxy card\n                        cardClone.style.width = bounds.width + 'px';\n                        cardClone.style.height = bounds.height + 'px';\n                        drag.taskHeights.set(taskElement, bounds.height);\n                        // Position cards in the proxy to overlap their originals\n                        cardClone.style.left = bounds.x + 'px';\n                        cardClone.style.top = bounds.y + 'px';\n                        cardClone.taskElement = taskElement;\n                        cardClone.taskRecord = elementData.taskRecord;\n                        cardClone.originalColor = elementData.swimlaneRecord?.color || elementData.columnRecord.color;\n                        proxy.appendChild(cardClone);\n                        cardClones.push(cardClone);\n                    });\n                    // Hide original card after measuring it above (cannot be done in the same loop, others will get\n                    // wrong bounds)\n                    taskElements.forEach(taskElement => taskElement.classList.add('b-drag-original'));\n                    await AsyncHelper.animationFrame();\n                    // Now reposition the cards to their desired position within the proxy, transitioning them there\n                    cardClones.forEach((cardClone, i) => {\n                        if (i > 0) {\n                            cardClone.style.top = (30 + i * 20) + 'px';\n                            cardClone.style.left = (40 + i * 5) + 'px';\n                        }\n                        else {\n                            cardClone.style.top = 0;\n                            cardClone.style.left = 0;\n                        }\n                    });\n                },\n                dragMove({ proxy, event, proxyOffset }) {\n                    const\n                        { dragRootElement } = this.owner,\n                        // Parent coords relative to screen (client)\n                        parentBounds        = dragRootElement.getBoundingClientRect(),\n                        // Place proxy in client coords\n                        position            = EventHelper.getClientPoint(event).translate(\n                            proxyOffset[0] - parentBounds.left + dragRootElement.scrollLeft,\n                            proxyOffset[1] - parentBounds.top + dragRootElement.scrollTop\n                        );\n                    proxy.style.top = position.y + 'px';\n                    proxy.style.left = position.x + 'px';\n                    // Experimental, tilt proxy based on drag amount and direction\n                    // let delta = 0;\n                    //\n                    // if (proxy.lastClientX != null) {\n                    //     delta = event.clientX - proxy.lastClientX;\n                    // }\n                    //\n                    // proxy.lastClientX = event.clientX;\n                    //\n                    // proxy.style.transform = `rotate(${-delta / 10}deg)`;\n                    // proxy.style.transformOrigin = `${-proxyOffset[0]}px ${-proxyOffset[1]}px`;\n                }\n            }\n        };\n    }\n    configureListeners(drag) {\n        const listeners = super.configureListeners(drag);\n        // Listen to the events on the root element\n        listeners.element = this.owner.client.rootElement;\n        return listeners;\n    }\n    setupDragContext(event) {\n        const\n            result     = super.setupDragContext(event),\n            { client } = this.owner;\n        result.scrollManager = client.scrollManager;\n        result.monitoringConfig = {\n            scrollables : [\n                {\n                    element   : '.b-taskboard-column-body',\n                    direction : 'vertical'\n                },\n                {\n                    element   : client.bodyElement,\n                    direction : 'both'\n                }\n            ]\n        };\n        return result;\n    }\n    // Populate the drag context early, to have something to take decisions on in beforeDragStart listeners\n    startDrag(drag) {\n        const\n            { itemElement } = drag,\n            taskBoard       = this.owner.client,\n            taskRecord      = taskBoard.resolveTaskRecord(itemElement);\n        // If we have selected tasks, drag them only if drag starts from one of the selected\n        if (taskBoard.isSelected(taskRecord)) {\n            drag.taskRecords = taskBoard.selectedTasks.slice().sort((a, b) => a.parentIndex - b.parentIndex);\n        }\n        // Otherwise (no selection or dragging an unselected) only drag one\n        else {\n            drag.taskRecords = [taskRecord];\n        }\n        drag.initiatedFrom = taskRecord;\n        return super.startDrag(drag);\n    }\n    dragStart(drag) {\n        const\n            { client }  = this.owner,\n            // Insert dropIndicators next to task that drag was initiated on initially\n            nextSibling = drag.itemElement;\n        // Flag to determine if `taskDragEnd` should be triggered on later abort\n        drag.wasStarted = true;\n        // Initially positioned after task drag is initiated from\n        drag.position = 'after';\n        drag.targetTaskRecord = drag.initiatedFrom;\n        for (const taskRecord of drag.taskRecords) {\n            taskRecord.instanceMeta(client).dragging = true;\n        }\n        // Adding proxy here and not when it is created saves one layout\n        client.bodyWrapElement.appendChild(drag.proxy);\n        // Populate drop indicator with placeholders\n        drag.dropIndicators = drag.taskElements.map((taskElement, i) => {\n            return DomHelper.createElement({\n                className : {\n                    'b-taskboard-card-drop-indicator' : 1,\n                    'b-first-drop-indicator'          : i === 0\n                },\n                style : {\n                    height : drag.taskHeights.get(taskElement)\n                },\n                elementData : {\n                    dropIndicator : true,\n                    // To be able to detect if it has actually moved on drop\n                    initialParent : taskElement.parentElement,\n                    initialIndex  : indexOf(taskElement),\n                    // Tag along the taskElement, to be able to return the drop indicator to its position for\n                    // invalid drop targets\n                    taskElement\n                },\n                retainElement : true,\n                nextSibling\n            });\n        });\n        client.element.classList.add('b-dragging-task');\n    }\n    dragEnter(drag) {\n        // Only accept tasks\n        if (!drag.itemElement.matches(this.dragItemSelector)) {\n            return false;\n        }\n    }\n    // Finds the first visible direct child in a parent element\n    getFirstVisibleChild(parentElement) {\n        for (const element of parentElement.children) {\n            if (element.offsetParent) {\n                return element;\n            }\n        }\n    }\n    // Convenience shortcut to not have to pass custom card selector on each call\n    getCardAt(x, y) {\n        return this.owner.client.getCardAt(x, y, cardSelector);\n    }\n    updateValidity(drag, valid) {\n        drag.proxy.classList.toggle('b-invalid', !valid);\n        drag.dropIndicators.forEach(dropIndicator => dropIndicator.classList.toggle('b-invalid', !valid));\n        drag.invalid = !valid;\n    }\n    dragMove(drag) {\n        const\n            me                                   = this,\n            { client }                           = me.owner,\n            { event : domEvent, dropIndicators } = drag,\n            { clientX, clientY }                 = domEvent,\n            overElement                          = client.documentRoot.elementFromPoint(clientX, clientY),\n            columnElement                        = DomSync.getChild(overElement?.closest('.b-taskboard-column'), 'body.inner');\n        if (drag.invalid) {\n            drag.valid = false;\n        }\n        if (!overElement) {\n            return;\n        }\n        // Over something in a column or the column itself\n        if (columnElement) {\n            const\n                targetSwimlane = client.resolveSwimlaneRecord(overElement),\n                targetColumn   = client.resolveColumnRecord(overElement),\n                tasksPerRow    = targetColumn.tasksPerRow || targetSwimlane?.tasksPerRow || client.tasksPerRow;\n            let\n                cardElement   = overElement.closest(cardSelector),\n                // Should only trigger drag event when move actually affected something\n                shouldTrigger = targetSwimlane !== drag.targetSwimlane || targetColumn !== drag.targetColumn;\n            // Only resolve swimlane/column when over a column, that way target sticks even if mouse is moved outside\n            drag.targetSwimlane = targetSwimlane;\n            drag.targetColumn = targetColumn;\n            // Might be over gap between cards, check if there is card above or below the gap\n            if (!cardElement) {\n                const\n                    { cardGap } = client,\n                    columnRect  = Rectangle.from(columnElement),\n                    topCard     = me.getFirstVisibleChild(columnElement),\n                    top         = topCard?.getBoundingClientRect().top ?? null;\n                if (tasksPerRow === 1) {\n                    // Above top card, use it\n                    if (top !== null && clientY < top) {\n                        cardElement = topCard;\n                    }\n                    else {\n                        const\n                            centerX   = columnRect.center.x,\n                            // Check column center, one gap up\n                            cardAbove = me.getCardAt(centerX, clientY - cardGap),\n                            // And one gap down\n                            cardBelow = me.getCardAt(centerX, clientY + cardGap);\n                        // Pick one of them\n                        cardElement = cardAbove || cardBelow;\n                    }\n                }\n                else {\n                    // Determine which \"inner column\" mouse is over\n                    const\n                        columnContentWidth = client.getColumnWidth(drag.targetColumn),\n                        // Can calculate padding, avoids reading it from DOM\n                        columnPadding      = (columnRect.width - columnContentWidth) / 2,\n                        // Width of an \"inner column\", ignoring gap between cards which does not matter in this case.\n                        // An approximate center fits our purpose\n                        innerColumnWidth   = columnContentWidth / tasksPerRow,\n                        // \"Inner column\" index\n                        index              = Math.floor((clientX - columnRect.left) / innerColumnWidth),\n                        // That columns center\n                        centerX            = columnRect.left + columnPadding + innerColumnWidth * (index + 0.5);\n                    // Above top row, use card below us\n                    if (top !== null && clientY < top) {\n                        cardElement = me.getCardAt(centerX, top);\n                    }\n                    else {\n                        const\n                            centerX    = columnRect.center.x,\n                            // Check column center, one gap left\n                            cardBefore = me.getCardAt(centerX - cardGap, clientY),\n                            // And one gap right\n                            cardAfter  = me.getCardAt(centerX + cardGap, clientY);\n                        // Pick one of them\n                        cardElement = cardBefore || cardAfter;\n                    }\n                }\n            }\n            // If we are over the drop indicator, we do nothing\n            if (!cardElement?.elementData.dropIndicator) {\n                let insertBefore = false;\n                // If we found a card, we should either go above or below it\n                if (cardElement) {\n                    const\n                        cardRect         = Rectangle.from(cardElement),\n                        targetTaskRecord = client.resolveTaskRecord(cardElement);\n                    // Insert before\n                    if (\n                        // If above center with single task per row\n                        (tasksPerRow === 1 && clientY < cardRect.center.y) ||\n                        // Or left of center in multiple tasks per row\n                        (tasksPerRow > 1 && clientX < cardRect.center.x)\n                    ) {\n                        if (drag.position !== 'before') {\n                            shouldTrigger = true;\n                        }\n                        insertBefore = cardElement;\n                        drag.position = 'before';\n                    }\n                    // Insert after\n                    else {\n                        if (drag.position !== 'after') {\n                            shouldTrigger = true;\n                        }\n                        insertBefore = cardElement.nextElementSibling;\n                        drag.position = 'after';\n                    }\n                    if (targetTaskRecord !== drag.targetTaskRecord) {\n                        shouldTrigger = true;\n                    }\n                    drag.targetTaskRecord = targetTaskRecord;\n                }\n                // No card, either empty column or below cards. Either way we append the card to the column\n                else {\n                    if (drag.position !== 'last') {\n                        shouldTrigger = true;\n                    }\n                    drag.position = 'last';\n                    drag.targetTaskRecord = null;\n                }\n                if (!insertBefore?.elementData?.dropIndicator) {\n                    if (insertBefore === false) {\n                        dropIndicators.forEach(dropIndicator => {\n                            columnElement?.appendChild(dropIndicator);\n                        });\n                    }\n                    else {\n                        dropIndicators.forEach(dropIndicator => {\n                            (insertBefore?.parentElement || columnElement).insertBefore(dropIndicator, insertBefore);\n                        });\n                    }\n                    drag.lastCardElement = cardElement;\n                }\n            }\n            // Update dragged cards dataset/color cls in case it is used for styling (as we do in demos)\n            for (const card of drag.proxy.children) {\n                if (!card.taskRecord.eventColor) {\n                    const color = drag.targetSwimlane?.color || drag.targetColumn.color;\n                    if (card.originalColor) {\n                        card.classList.remove(`b-taskboard-color-${card.originalColor}`);\n                    }\n                    if (color) {\n                        card.originalColor = color;\n                        if (DomHelper.isNamedColor(color)) {\n                            card.classList.add(`b-taskboard-color-${color}`);\n                        }\n                        else {\n                            card.style.color = color;\n                        }\n                    }\n                }\n                if (drag.targetSwimlane) {\n                    card.dataset.lane = drag.targetSwimlane.id;\n                }\n                card.dataset.column = drag.targetColumn.id;\n            }\n            if (shouldTrigger) {\n                const\n                    { taskRecords, targetTaskRecord, position } = drag,\n                    /**\n                     * Fires on the owning TaskBoard when tasks are dragged, if the drag leads to any changes compared to\n                     * the last taskDrag event (moved to a new column or changed order within a column).\n                     *\n                     * Returning `false` from a listener will flag the drag as invalid (by default turning the drop\n                     * indicator red)\n                     *\n                     * @event taskDrag\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.TaskModel[]} taskRecords Dragged tasks\n                     * @param {TaskBoard.model.ColumnModel} targetColumn Currently over this column\n                     * @param {TaskBoard.model.SwimlaneModel} targetSwimlane Currently over this swimlane (if used)\n                     * @param {Event} domEvent The mouse event\n                     */\n                    result                                      = client.trigger(\n                        'taskDrag',\n                        { drag, taskRecords, targetSwimlane, targetColumn, targetTaskRecord, position, event : domEvent, domEvent }\n                    );\n                me.updateValidity(drag, result !== false);\n            }\n        }\n    }\n    async dragDrop(drag) {\n        const\n            me         = this,\n            { client } = me.owner,\n            {\n                dropIndicators,\n                taskRecords,\n                targetSwimlane,\n                targetColumn,\n                targetTaskRecord,\n                event : domEvent\n            }          = drag,\n            event      = { drag, domEvent, event : domEvent, taskRecords, targetSwimlane, targetColumn, targetTaskRecord },\n            // Check that drop will lead to changes for at least one dragged task\n            changed    = hasChanged(dropIndicators);\n        /**\n         * Fires on the owning TaskBoard when tasks are dropped, before the operation completes. Handles async\n         * listeners, returning `false` from one will abort the operation\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    listeners : {\n         *        async beforeTaskDrop({ taskRecords, targetColumn }) {\n         *            // Show confirmation dialog\n         *            const result = await MessageDialog.confirm({\n         *                title   : 'Verify drop',\n         *                message : `Please confirm moving ${taskRecords.map(t => `\"${t.name}\"`).join(', ')} to ${targetColumn.text}?`\n         *            });\n         *\n         *            // Returning false will abort the drop (if user pressed Cancel)\n         *            return result === MessageDialog.okButton;\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @event beforeTaskDrop\n         * @preventable\n         * @async\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Dropped tasks\n         * @param {TaskBoard.model.ColumnModel} targetColumn Dropped on this column\n         * @param {TaskBoard.model.SwimlaneModel} targetSwimlane Dropped in this swimlane (if used)\n         * @param {Event} domEvent The mouse event\n         */\n        if (!changed || !targetColumn || drag.invalid || await client.trigger('beforeTaskDrop', event) === false) {\n            drag.valid = false;\n        }\n        else {\n            drag.finalizer = new Promise(resolve => {\n                // Data part\n                const\n                    {\n                        columnField,\n                        swimlaneField\n                    }               = client,\n                    { taskStore }   = client.project,\n                    {\n                        proxy\n                    }               = drag,\n                    columnRecords   = targetColumn.tasks,\n                    swimlaneRecords = targetSwimlane\n                        ? columnRecords?.filter(task => task[swimlaneField] === targetSwimlane.id)\n                        : columnRecords,\n                    invalid         = !columnRecords;\n                let moveBefore;\n                if (!invalid) {\n                    // Dropped relative to another card?\n                    if (drag.targetTaskRecord) {\n                        // If before it, move to before it in store too\n                        if (drag.position === 'before') {\n                            moveBefore = targetTaskRecord;\n                        }\n                        // If after, move to before the next record\n                        else if (drag.position === 'after') {\n                            const index = swimlaneRecords.indexOf(targetTaskRecord);\n                            moveBefore = swimlaneRecords[index + 1] ?? null;\n                        }\n                    }\n                    // Dropped below all cards or in empty column, move to last in store which guarantees it is last in that column\n                    else if (swimlaneRecords.length) {\n                        moveBefore = null;\n                    }\n                }\n                function commit() {\n                    // Remove proxy & dropIndicators\n                    proxy.remove();\n                    dropIndicators.forEach(dropIndicator => {\n                        const { taskElement } = dropIndicator.elementData;\n                        // Move original element to the new destination\n                        dropIndicator.parentElement.insertBefore(taskElement, dropIndicator);\n                        // Make it available for syncing\n                        dropIndicator.parentElement.syncIdMap[taskElement.elementData.taskId] = taskElement;\n                        // And unflag it\n                        taskElement.classList.remove('b-drag-original');\n                        dropIndicator.remove();\n                    });\n                    client.suspendDomTransition();\n                    // Update data\n                    if (!invalid) {\n                        let newWeight;\n                        // Determine new weight\n                        if (moveBefore) {\n                            const\n                                // Successors, that might need to have their weight updated\n                                tasksBelow = swimlaneRecords.slice(swimlaneRecords.indexOf(moveBefore)),\n                                // Predecessor, we want to squeeze in after it weight-wise\n                                taskAbove = swimlaneRecords[swimlaneRecords.indexOf(moveBefore) - 1];\n                            let weightDiff;\n                            // We have a predecessor, put us between the card we \"replace\" and it to update as few\n                            // weights as possible\n                            if (taskAbove) {\n                                // Between tasks, down to 1 sized gaps\n                                weightDiff = Math.max(1, Math.round((moveBefore.weight - taskAbove.weight) / 2));\n                                newWeight = taskAbove.weight + weightDiff;\n                            }\n                            // First in column, put us between old first task and 0 in weight\n                            else {\n                                newWeight = Math.max(1, Math.round(moveBefore.weight / 2));\n                            }\n                            // Update weight for successors that have colliding weights.\n                            // New weight will be between current and next, to try and avoid having to change\n                            // multiple weights while also leaving gaps for future drops\n                            while (tasksBelow[0]?.weight === newWeight) {\n                                // Place halfway between this and next task\n                                weightDiff = tasksBelow[1]\n                                    ? Math.max(1, Math.round((tasksBelow[1].weight - newWeight) / 2))\n                                    : 50;\n                                newWeight = tasksBelow[0].weight = newWeight + weightDiff;\n                                tasksBelow.shift();\n                            }\n                        }\n                        // Last, add 100 to current lasts weight\n                        else {\n                            newWeight = swimlaneRecords.length\n                                ? swimlaneRecords[swimlaneRecords.length - 1].weight + 100\n                                : 100;\n                        }\n                        taskRecords.forEach(taskRecord => {\n                            const toSet = {\n                                [columnField] : targetColumn.id,\n                                weight        : newWeight\n                            };\n                            if (targetSwimlane) {\n                                toSet[swimlaneField] = targetSwimlane.id;\n                            }\n                            // Optionally reorder the store\n                            if (client.features.taskDrag.reorderTaskRecords && moveBefore !== undefined) {\n                                taskStore.move(taskRecord, moveBefore);\n                            }\n                            taskRecord.set(toSet);\n                        });\n                        // Reapply sorters if we are not reordering tasks and not overriding sort in the store on drop\n                        if (!client.features.taskDrag.reorderTaskRecords && !client.taskSorterFn) {\n                            client.project.taskStore.sort();\n                        }\n                    }\n                    client.resumeDomTransition();\n                    /**\n                     * Fires on the owning TaskBoard when tasks are successfully dropped (after the drop transition has\n                     * finished)\n                     * @event taskDrop\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.TaskModel[]} taskRecords Dropped tasks\n                     * @param {TaskBoard.model.ColumnModel} targetColumn Dropped on this column\n                     * @param {TaskBoard.model.SwimlaneModel} targetSwimlane Dropped in this swimlane (if used)\n                     * @param {Event} domEvent The mouse event\n                     */\n                    client.trigger('taskDrop', { drag, event : domEvent, taskRecords, targetSwimlane, targetColumn, moveBefore, domEvent });\n                    /**\n                     * Fires on the owning TaskBoard when a previously started drag operation ends, no matter the\n                     * outcome of it (whether valid, invalid or aborted)\n                     *\n                     * @event taskDragEnd\n                     * @on-owner\n                     * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n                     * @param {TaskBoard.model.TaskModel[]} taskRecords Affected tasks\n                     * @param {Event} domEvent The mouse event\n                     */\n                    client.trigger('taskDragEnd', { drag, taskRecords, domEvent });\n                    // Reading element here flushes the recompose\n                    client.element.classList.remove('b-dragging-task');\n                    // Reset flag after recompose to avoid flicker when virtualizing (to not first render outline)\n                    for (const taskRecord of taskRecords) {\n                        taskRecord.instanceMeta(client).dragging = false;\n                    }\n                    resolve();\n                }\n                // UI part\n                const cardClones = Array.from(proxy.children);\n                // Ugly \"hack\" to force the transforms used in the proxy to go away\n                proxy.classList.add('b-pre-dropping');\n                cardClones[0].offsetWidth;\n                // We are dropping, this cls by default has a transition\n                proxy.classList.add('b-dropping');\n                // Move proxy cards to drop locations, allowing them to transition there\n                cardClones.forEach((cardClone, i) => {\n                    const dropClone = dropIndicators[i];\n                    DomHelper.alignTo(\n                        cardClone,\n                        // Ignore page scroll when trying to align element in float root to element in taskboard\n                        Rectangle.from(dropClone, undefined, true)\n                    );\n                });\n                // Update record after the transition, to prevent too early redraw (which would ruin the transition)\n                if (DomHelper.getPropertyTransitionDuration(cardClones[0], 'transform')) {\n                    EventHelper.onTransitionEnd({\n                        element  : cardClones[0],\n                        property : 'transform',\n                        handler  : commit,\n                        thisObj  : client // For timer cleanup\n                    });\n                }\n                // Or right away if no transition is used\n                else {\n                    commit();\n                }\n            });\n        }\n    }\n    dragLeave(drag) {\n        // Move drop indicator to dragged cards origin, to indicate what will happen on invalid drop\n        drag.dropIndicators.forEach(dropIndicator => {\n            const { taskElement } = dropIndicator.elementData;\n            taskElement.parentElement.insertBefore(dropIndicator, taskElement);\n        });\n    }\n    doAbort(drag) {\n        const\n            { client }                             = this.owner,\n            { dropIndicators, proxy, taskRecords } = drag;\n        if (proxy) {\n            const cardClones = Array.from(proxy.children);\n            function finalizeAbort() {\n                // Remove proxy & dropIndicators\n                proxy.remove();\n                dropIndicators.forEach(dropIndicator => {\n                    dropIndicator.elementData.taskElement.classList.remove('b-drag-original');\n                    dropIndicator.remove();\n                });\n                client.element.classList.remove('b-dragging-task');\n                // Rest flag late to avoid flicker when virtualizing (to not first render outline)\n                for (const taskRecord of taskRecords) {\n                    taskRecord.instanceMeta(client).dragging = false;\n                }\n                client.trigger('taskDragAbortFinalized');\n            }\n            // Emulate drop to enable transitions\n            proxy.classList.add('b-dropping');\n            // Move drop indicators to where each task originated\n            dropIndicators.forEach(dropIndicator => {\n                const { taskElement } = dropIndicator.elementData;\n                dropIndicator.classList.remove('b-invalid'); // Looks better this way when returning to origin\n                taskElement.parentElement.insertBefore(dropIndicator, taskElement);\n            });\n            // Move proxy cards to original locations, allowing them to transition there\n            cardClones.forEach((cardClone, i) => {\n                DomHelper.alignTo(\n                    cardClone,\n                    // Ignore page scroll when trying to align element in float root to element in taskboard\n                    Rectangle.from(dropIndicators[i], undefined, true)\n                );\n            });\n            // Finalize after transition\n            if (DomHelper.getPropertyTransitionDuration(cardClones[0], 'transform')) {\n                EventHelper.onTransitionEnd({\n                    element  : cardClones[0],\n                    property : 'transform',\n                    handler  : finalizeAbort,\n                    thisObj  : client // For timer cleanup\n                });\n            }\n            // Or right away if no transition is used\n            else {\n                finalizeAbort();\n            }\n        }\n        /**\n         * Fires on the owning TaskBoard when a drag operation is aborted (invalid drop or aborted using ESC)\n         *\n         * @event taskDragAbort\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source Owning TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Dragged tasks\n         */\n        client.trigger('taskDragAbort', { drag, taskRecords });\n        if (drag.wasStarted) {\n            // Documented in dragDrop()\n            client.trigger('taskDragEnd', { drag, taskRecords });\n        }\n    }\n    dragEnd(drag) {\n        // Move all cards back to their original location when drag was aborted\n        // (ignore abort before drag was started, which might occur with touch dragging, since start is delayed)\n        if ((drag.started || drag.wasStarted) && (!drag.valid || drag.aborted)) {\n            this.doAbort(drag);\n        }\n    }\n}\nTaskDrag._$name = 'TaskDrag';", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport TaskBoardFeature from './TaskBoardFeature.js';\n/**\n * @module TaskBoard/feature/TaskDragSelect\n */\n/**\n * Enables users to click and drag to select cards on the TaskBoard (marquee selection).\n *\n * {@inlineexample TaskBoard/feature/TaskDragSelect.js}\n *\n * This feature is **enabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskDragSelect\n * @feature\n */\nexport default class TaskDragSelect extends TaskBoardFeature {\n    static $name =  'TaskDragSelect';\n    static type = 'taskDragSelect';\n    static configurable = {\n        /**\n         * The amount of pixels to move pointer/mouse before it counts as a drag select operation.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    features : {\n         *        taskDragSelect : {\n         *            dragThreshold : 10\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Number}\n         * @default\n         */\n        dragThreshold : 5\n    };\n    state = 'idle';\n    static pluginConfig = {\n        chain : ['onColumnMouseDown', 'onMouseMove']\n    };\n    //region Type assertions\n    changeDragThreshold(threshold) {\n        ObjectHelper.assertNumber(threshold, 'features.taskDragSelect.dragThreshold');\n        return threshold;\n    }\n    //endregion\n    initializeDragSelect(event) {\n        const\n            me         = this,\n            { client } = me;\n        me.bounds = Rectangle.from(client.bodyElement, /* ignorePageScroll = */ true);\n        me.element = DomHelper.createElement({\n            tag       : 'div',\n            className : 'b-dragselect-rect'\n        }, { returnAll : true })[0];\n        client.floatRoot.appendChild(me.element);\n        client.element.classList.add('b-dragselecting');\n        const cardElements = Array.from(client.element.querySelectorAll('.b-taskboard-card:not(.b-dragging-item)'));\n        // Since the dragselect element is in the floatRoot, we want to use viewport-based coordinates, so we pass\n        // ignorePageScroll=true when calling Rectangle.from():\n        me.cardRectangles = cardElements.flatMap(el => {\n            // Previously we could get here with the drag proxy among elements, that case is now prevented by the\n            // selector above, but safeguarding against similar cases in the future here\n            const record = client.resolveTaskRecord(el);\n            return record\n                ? {\n                    rectangle : Rectangle.from(el, /* ignorePageScroll = */ true),\n                    record\n                } : [];\n        });\n        if (!event.ctrlKey) {\n            client.deselectAll();\n        }\n        // No key processing during drag selection\n        client.navigateable = false;\n        me.state = 'selecting';\n    }\n    // Select cards intersected by the selection marquee\n    updateSelection() {\n        const { cardRectangles, rectangle, client } = this;\n        for (let i = 0, len = cardRectangles.length; i < len; i++) {\n            const\n                cardData     = cardRectangles[i],\n                shouldSelect = rectangle.intersect(cardData.rectangle, true);\n            if (shouldSelect && !cardData.selected) {\n                cardData.selected = true;\n                client.selectTask(cardData.record, true);\n            }\n            else if (!shouldSelect && cardData.selected) {\n                cardData.selected = false;\n                client.deselectTask(cardData.record);\n            }\n        }\n    }\n    //region Listeners\n    onColumnMouseDown({ event }) {\n        const me = this;\n        if (!me.disabled && event.button === 0) {\n            me.state = 'considering';\n            me.startX = event.clientX;\n            me.startY = event.clientY;\n            me.mouseUpDetacher = EventHelper.on({\n                element : document,\n                mouseup : 'onMouseUp',\n                thisObj : me\n            });\n        }\n    }\n    onMouseMove({ event }) {\n        const\n            me                   = this,\n            { startX, startY }   = me,\n            { clientX, clientY } = event;\n        if (me.state === 'considering') {\n            const\n                deltaX = Math.abs(clientX - startX),\n                deltaY = Math.abs(clientY - startY);\n            if (deltaX > me.dragThreshold || deltaY > me.dragThreshold) {\n                me.initializeDragSelect(event);\n            }\n        }\n        if (me.state === 'selecting') {\n            const\n                { element, bounds } = me,\n                x                   = Math.max(clientX, bounds.left),\n                y                   = Math.max(clientY, bounds.top),\n                left                = Math.min(startX, x),\n                top                 = Math.min(startY, y),\n                width               = Math.abs(startX - x),\n                height              = Math.abs(startY - y),\n                rect                = new Rectangle(left, top, width, height).constrainTo(bounds);\n            DomHelper.setTranslateXY(element, rect.left, rect.top);\n            element.style.width  = rect.width + 'px';\n            element.style.height = rect.height + 'px';\n            me.rectangle = rect;\n            me.updateSelection();\n        }\n    }\n    onMouseUp() {\n        const\n            me                = this,\n            { client, state } = me;\n        // Cards are selected during mouse move, no need to change selection here\n        if (state === 'selecting') {\n            me.element?.remove();\n            client.element.classList.remove('b-dragselecting');\n            // Navigator will react to the 'click' event which clears selection, bypass this with a short timeout\n            client.setTimeout(() => client.navigateable = true, 100);\n        }\n        if (state === 'selecting' || state === 'considering') {\n            me.state = 'idle';\n            me.startX = me.startY = me.rectangle = me.bounds = null;\n        }\n        me.mouseUpDetacher?.();\n    }\n    //endregion\n}\nTaskDragSelect.initClass();\nTaskDragSelect._$name = 'TaskDragSelect';", "import Base from '../../../Core/Base.js';\nimport Widget from '../../../Core/widget/Widget.js';\n/**\n * @module TaskBoard/widget/mixin/TaskBoardLinked\n */\n/**\n * Mixin that simplifies linking a widget to a {@link TaskBoard.view.TaskBoard}.\n *\n * @mixin\n */\nexport default Target => class TaskBoardLinked extends (Target || Base) {\n    static $name = 'TaskBoardLinked';\n    static configurable = {\n        /**\n         * Auto detected when used within a TaskBoard. If you add the widget elsewhere, it will try to find an instance\n         * of TaskBoard on page. If that fails you have to supply this config to connect it to a TaskBoard manually.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({});\n         *\n         * const picker = new ColumnPickerButton({\n         *    taskBoard // Link it to the taskBoard instance created above\n         * });\n         * ```\n         *\n         * @config {TaskBoard.view.TaskBoard}\n         * @category Common\n         */\n        taskBoard : null\n    };\n    get taskBoard() {\n        return this._taskBoard || this.up(widget => widget.isTaskBoardBase) || Widget.query(widget => widget.isTaskBoardBase);\n    }\n    changeTaskBoard(taskBoard) {\n        if (taskBoard && !taskBoard.isTaskBoard) {\n            throw new Error(`The taskBoard config only accepts an instance of TaskBoard or a subclass thereof`);\n        }\n        return taskBoard;\n    }\n};\n", "import DomHelper from '../../../Core/helper/DomHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport Combo from '../../../Core/widget/Combo.js';\nimport TaskBoardLinked from '../mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/base/ColorBoxCombo\n */\n/**\n * Abstract base class with functionality shared between {@link TaskBoard.widget.ColumnCombo} and\n * {@link TaskBoard.widget.SwimlaneCombo}.\n *\n * @extends Core/widget/Combo\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @abstract\n */\nexport default class ColorBoxCombo extends Combo.mixin(TaskBoardLinked) {\n    static $name = 'ColorBoxCombo';\n    static type = 'colorboxcombo';\n    static configurable = {\n        displayField      : 'text',\n        valueField        : 'id',\n        editable          : false,\n        showBoxForNoColor : false,\n        listItemTpl({ text, color }) {\n            let html = StringHelper.encodeHtml(text);\n            if (color) {\n                if (DomHelper.isNamedColor(color)) {\n                    html = `<div class=\"b-colorbox b-taskboard-color-${color}\"></div>` + html;\n                }\n                else {\n                    html = `<div class=\"b-colorbox\" style=\"color : ${color}\"></div>` + html;\n                }\n            }\n            return html;\n        },\n        picker : {\n            cls : 'b-colorbox-picker'\n        }\n    };\n    afterConstruct() {\n        if (!this.showBoxForNoColor && !this.value) {\n            this.element.classList.add('b-colorless');\n        }\n    }\n    syncInputFieldValue(...args) {\n        const\n            me        = this,\n            { color } = me.record || {};\n        let className = 'b-colorbox';\n        if (color) {\n            if (DomHelper.isNamedColor(color)) {\n                className += ` b-taskboard-color-${color}`;\n            }\n            else {\n                me.colorBox.style.color = color;\n            }\n        }\n        me.colorBox.className = className;\n        if (!me.showBoxForNoColor) {\n            me.element.classList.toggle('b-colorless', !color);\n        }\n        super.syncInputFieldValue(...args);\n    }\n    get innerElements() {\n        return [\n            {\n                reference : 'colorBox',\n                className : 'b-colorbox'\n            },\n            ...super.innerElements\n        ];\n    }\n}\nColorBoxCombo._$name = 'ColorBoxCombo';", "import ColorBoxCombo from './base/ColorBoxCombo.js';\n/**\n * @module TaskBoard/widget/ColumnCombo\n */\n/**\n * A combo populated with the {@link TaskBoard.view.TaskBoard#property-columns} of a {@link TaskBoard.view.TaskBoard}.\n * If a column has a {@link TaskBoard.model.ColumnModel#field-color} defined, that color will be displayed in the combo\n * and its picker.\n *\n * Used in {@link TaskBoard.widget.TaskEditor} to pick which column a task belongs to (\"Status\" below):\n *\n * {@inlineexample TaskBoard/widget/ColumnCombo.js}\n *\n * @extends TaskBoard/widget/base/ColorBoxCombo\n * @classtype columncombo\n * @inputfield\n */\nexport default class ColumnCombo extends ColorBoxCombo {\n    static $name = 'ColumnCombo';\n    static type = 'columncombo';\n    changeStore() {\n        return this.taskBoard.columns.chain();\n    }\n}\nColumnCombo.initClass();\nColumnCombo._$name = 'ColumnCombo';", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Combo from '../../Core/widget/Combo.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\nimport AvatarRendering from '../../Core/widget/util/AvatarRendering.js';\n/**\n * @module TaskBoard/widget/ResourcesCombo\n */\n/**\n * A combo populated with the resources of a {@link TaskBoard.view.TaskBoard taskboard\u00B4s}\n * {@link Scheduler.data.ResourceStore resource store}.\n *\n * Used in {@link TaskBoard.widget.TaskEditor} to assign resources to a task. Double-click a task to try it:\n *\n * {@inlineexample TaskBoard/widget/ResourcesCombo.js}\n *\n * @extends Core/widget/Combo\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype resourcescombo\n * @inputfield\n */\nexport default class ResourcesCombo extends Combo.mixin(TaskBoardLinked) {\n    static $name = 'ResourcesCombo';\n    static type = 'resourcescombo';\n    static configurable = {\n        displayField : 'name',\n        valueField   : 'id',\n        multiSelect  : true,\n        editable     : false,\n        listItemTpl(resourceRecord) {\n            const { avatarRendering, taskBoard } = this.owner;\n            return DomHelper.createElement(avatarRendering.getResourceAvatar({\n                resourceRecord,\n                initials : resourceRecord.initials,\n                color    : resourceRecord.color,\n                iconCls  : resourceRecord.iconCls,\n                imageUrl : resourceRecord.image === false ? null : (resourceRecord.imageUrl || ((taskBoard.resourceImagePath || '') + (resourceRecord.image || '')))\n            })).outerHTML + StringHelper.encodeHtml(resourceRecord.name);\n        },\n        picker : {\n            cls : 'b-resources-picker'\n        },\n        chipView : {\n            scrollable : null,\n            itemTpl(resourceRecord) {\n                const { avatarRendering, taskBoard } = this.owner;\n                return DomHelper.createElement(avatarRendering.getResourceAvatar({\n                    resourceRecord,\n                    initials : resourceRecord.initials,\n                    color    : resourceRecord.color,\n                    iconCls  : resourceRecord.iconCls,\n                    imageUrl : resourceRecord.image === false ? null : (resourceRecord.imageUrl || ((taskBoard.resourceImagePath || '') + (resourceRecord.image || ''))),\n                    dataset  : {\n                        btip : StringHelper.encodeHtml(resourceRecord.name)\n                    }\n                })).outerHTML;\n            }\n        },\n        avatarRendering : {\n            value   : true,\n            $config : 'nullify'\n        }\n    };\n    get innerElements() {\n        // See if we have an uningested truthy multiSelect configuration, or we have already set it.\n        if (this.peekConfig('multiSelect') || this._multiSelect) {\n            return super.innerElements;\n        }\n        // Add element that we can render an avatar into when not using a chipview\n        return [\n            { reference : 'avatarContainer' },\n            this.inputElement\n        ];\n    }\n    syncInputFieldValue(...args) {\n        const me = this;\n        // No chipview when not multi selecting, render single avatar\n        if (!me.multiSelect) {\n            const resourceRecord = me.record;\n            if (resourceRecord) {\n                DomSync.sync({\n                    targetElement : me.avatarContainer,\n                    domConfig     : {\n                        className : 'b-resourcescombo-avatar-container',\n                        children  : [\n                            me.avatarRendering.getResourceAvatar({\n                                resourceRecord,\n                                initials : resourceRecord.initials,\n                                color    : resourceRecord.color,\n                                iconCls  : resourceRecord.iconCls,\n                                imageUrl : resourceRecord.image === false ? null : (resourceRecord.imageUrl || ((me.taskBoard.resourceImagePath || '') + (resourceRecord.image || ''))),\n                                dataset  : {\n                                    btip : StringHelper.encodeHtml(resourceRecord.name)\n                                }\n                            })\n                        ]\n                    }\n                });\n            }\n        }\n        super.syncInputFieldValue(...args);\n    }\n    changeStore() {\n        return this.taskBoard.project.resourceStore.chain();\n    }\n    changeAvatarRendering(value, old) {\n        old?.destroy();\n        if (value) {\n            return new AvatarRendering({\n                element : this.element\n            });\n        }\n    }\n}\nResourcesCombo.initClass();\nResourcesCombo._$name = 'ResourcesCombo';", "import ColorBoxCombo from './base/ColorBoxCombo.js';\n/**\n * @module TaskBoard/widget/SwimlaneCombo\n */\n/**\n * A combo populated with the {@link TaskBoard.view.TaskBoard#property-swimlanes} of a {@link TaskBoard.view.TaskBoard}.\n * If a swimlane has a {@link TaskBoard.model.SwimlaneModel#field-color} defined, that color will be displayed in the\n * combo and its picker.\n *\n * Used in {@link TaskBoard.widget.TaskEditor} to pick which swimlane a task belongs to (\"Prio\" below):\n *\n * {@inlineexample TaskBoard/widget/ColumnCombo.js}\n *\n * @extends TaskBoard/widget/base/ColorBoxCombo\n * @classtype swimlanecombo\n * @inputfield\n */\nexport default class SwimlaneCombo extends ColorBoxCombo {\n    static $name = 'SwimlaneCombo';\n    static type = 'swimlanecombo';\n    changeStore() {\n        return this.taskBoard.swimlanes.chain();\n    }\n}\nSwimlaneCombo.initClass();\nSwimlaneCombo._$name = 'SwimlaneCombo';", "import ColorPicker from '../../Core/widget/ColorPicker.js';\n/**\n * @module TaskBoard/widget/TaskColorPicker\n */\n/**\n * A color picker that displays a list of available task colors which the user can select by using mouse or keyboard.\n * See {@link TaskBoard.model.TaskModel#field-eventColor} for default available colors.\n *\n * {@inlineexample TaskBoard/widget/TaskColorPicker.js}\n *\n * ```javascript\n * new TaskColorPicker({\n *    appendTo : 'container',\n *    width    : '10em',\n *    onColorSelected() {\n *        console.log(...arguments);\n *    }\n * });\n * ```\n *\n * @extends Core/widget/ColorPicker\n * @classtype colorpicker\n */\nexport default class TaskColorPicker extends ColorPicker {\n    static $name = 'TaskColorPicker';\n    static type = 'taskcolorpicker';\n    static configurable = {\n        // These are the colors available by default for TaskBoard\n        colorClasses : [\n            { color : 'red', text : 'Red' },\n            { color : 'pink', text : 'Pink' },\n            { color : 'purple', text : 'Purple' },\n            { color : 'deep-purple', text : 'Deep purple' },\n            { color : 'indigo', text : 'Indigo' },\n            { color : 'blue', text : 'Blue' },\n            { color : 'light-blue', text : 'Light blue' },\n            { color : 'cyan', text : 'Cyan' },\n            { color : 'teal', text : 'Teal' },\n            { color : 'green', text : 'Green' },\n            { color : 'light-green', text : 'Light green' },\n            { color : 'lime', text : 'Lime' },\n            { color : 'yellow', text : 'Yellow' },\n            { color : 'amber', text : 'Amber' },\n            { color : 'orange', text : 'Orange' },\n            { color : 'deep-orange', text : 'Deep orange' }\n        ],\n        colorClassPrefix : 'b-taskboard-background-color-',\n        /**\n         * @hideconfigs colors\n         */\n        colors : null\n    };\n}\nTaskColorPicker.initClass();\nTaskColorPicker._$name = 'TaskColorPicker';", "import ColorField from '../../Core/widget/ColorField.js';\nimport './TaskColorPicker.js';\n/**\n * @module TaskBoard/widget/TaskColorCombo\n */\n/**\n * A combo populated with predefined colors usable by a task, see {@link TaskBoard.model.TaskModel#field-eventColor}.\n *\n * Used in {@link TaskBoard.widget.TaskEditor} to pick a color for a task. Double click a task to try it:\n *\n * {@inlineexample TaskBoard/widget/TaskColorCombo.js}\n *\n * @extends Core/widget/ColorField\n * @classtype taskcolorcombo\n * @inputfield\n */\nexport default class TaskColorCombo extends ColorField {\n    static $name = 'TaskColorCombo';\n    static type = 'taskcolorcombo';\n    static configurable = {\n        picker : {\n            type : 'taskcolorpicker'\n        },\n        name      : 'eventColor',\n        clearable : true\n    };\n}\nTaskColorCombo.initClass();\nTaskColorCombo._$name = 'TaskColorCombo';", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Popup from '../../Core/widget/Popup.js';\nimport '../../Core/widget/TextAreaField.js';\nimport '../../Core/widget/TextField.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\nimport './ColumnCombo.js';\nimport './ResourcesCombo.js';\nimport './SwimlaneCombo.js';\nimport './TaskColorCombo.js';\n/**\n * @module TaskBoard/widget/TaskEditor\n */\n/**\n * Popup used to edit tasks. Normally displayed using the {@link TaskBoard.feature.TaskEdit TaskEdit feature}.\n *\n * By default, the editor live updates the task being edited. If you prefer to use buttons to save/cancel the edit,\n * set {@link #config-autoUpdateRecord} to `false`.\n *\n * ## Items\n *\n * By default, it displays the following items:\n *\n * | Ref         | Type                                                   | Weight | Comment                                                                   |\n * |-------------|--------------------------------------------------------|--------|---------------------------------------------------------------------------|\n * | name        | {@link Core.widget.TextField text}                     | 100    | Task {@link TaskBoard.model.TaskModel#field-name}                         |\n * | description | {@link Core.widget.TextAreaField textarea}             | 200    | Task {@link TaskBoard.model.TaskModel#field-description}                  |\n * | resources   | {@link TaskBoard.widget.ResourcesCombo resourcescombo} | 300    | Assigned resources                                                        |\n * | color       | {@link TaskBoard.widget.TaskColorCombo taskcolorcombo} | 400    | Task {@link TaskBoard.model.TaskModel#field-eventColor}                   |\n * | column      | {@link TaskBoard.widget.ColumnCombo columncombo}       | 500    | Bound to configured {@link TaskBoard.view.TaskBoard#config-columnField}   |\n * | swimlane    | {@link TaskBoard.widget.SwimlaneCombo swimlanecombo}   | 600    | Bound to configured {@link TaskBoard.view.TaskBoard#config-swimlaneField} |\n *\n * If configured with `autoUpdateRecord: false` it also displays a bottom toolbar with the following items:\n *\n * | Ref          | Type                              | Weight | Comment          |\n * |--------------|-----------------------------------|--------|------------------|\n * | saveButton   | {@link Core.widget.Button button} | 100    | Save             |\n * | cancelButton | {@link Core.widget.Button button} | 200    | Cancel           |\n *\n * ## Customization\n *\n * Popup and its items can be customized through the feature (see {@link TaskBoard.feature.TaskEdit} fore more info):\n *\n * {@inlineexample TaskBoard/widget/TaskEditorCustomized.js}\n *\n * Or by subclassing and instructing the feature to display the new editor:\n *\n * {@inlineexample TaskBoard/widget/TaskEditorSubclassed.js}\n *\n * @extends Core/widget/Popup\n * @classtype taskboardtaskeditor\n */\nexport default class TaskEditor extends Popup.mixin(TaskBoardLinked) {\n    static $name = 'TaskEditor';\n    static type = 'taskboardtaskeditor';\n    static configurable = {\n        /**\n         * Center the editor in browser viewport space. Defaults to true for desktop browsers using a pointer device\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        centered : true,\n        /**\n         * Show an opaque mask below the editor when shown.\n         *\n         * Clicking the mask closes the editor.\n         *\n         * @config {Boolean}\n         * @default true\n         * @category Common\n         */\n        modal : { closeOnMaskTap : true },\n        /**\n         * Shows a tool used to close the editor in the header.\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        closable : true,\n        /**\n         * By default the editor automatically updates the edited task when a field is changed. Set this to `false`\n         * to show Save / Cancel buttons and take manual control of the updating.\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        autoUpdateRecord : true,\n        /**\n         * Update fields if the {@link #config-record} changes\n         * @config {Boolean}\n         */\n        autoUpdateFields : true,\n        /**\n         * True to save and close the editor if ENTER is pressed.\n         * (The save part only applies when configured with `autoUpdateRecord : false`)\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        saveAndCloseOnEnter : true,\n        draggable : {\n            handleSelector : '.b-panel-header'\n        },\n        autoShow : false,\n        anchor : true,\n        closeAction : 'destroy',\n        scrollAction : 'realign',\n        title : 'L{TaskBoard.editTask}',\n        defaults : {\n            labelWidth : '30%'\n        },\n        width : '30em',\n        items : {\n            name        : { type : 'text', label : 'L{TaskBoard.name}', weight : 100 },\n            description : { type : 'textarea', label : 'L{TaskBoard.description}', height : '5em', weight : 200 },\n            resources   : { type : 'resourcescombo', label : 'L{TaskBoard.resources}', weight : 300 },\n            color       : { type : 'taskcolorcombo', label : 'L{TaskBoard.color}', name : 'eventColor', weight : 400 },\n            column      : { type : 'columncombo', weight : 500 },\n            swimlane    : { type : 'swimlanecombo', weight : 600 }\n        },\n        bbar : {\n            hidden : true,\n            items  : {\n                saveButton   : { text : 'L{TaskBoard.save}', onClick : 'up.onSaveClick', weight : 100 },\n                cancelButton : { text : 'L{TaskBoard.cancel}', onClick : 'up.onCancelClick', weight : 200 }\n            }\n        },\n        // We want to maximize on phones and tablets\n        maximizeOnMobile : true\n    };\n    changeItems(items, old) {\n        const\n            { taskBoard }                   = this,\n            { column, swimlane, resources } = items;\n        if (taskBoard) {\n            // Hook column field up to correct record field\n            if (column) {\n                if (!column.name) {\n                    column.name = taskBoard.columnField;\n                }\n                if (!column.label) {\n                    column.label = StringHelper.capitalize(taskBoard.columnField);\n                }\n            }\n            if (swimlane) {\n                // Take the swimlane field out if not using swimlanes\n                if (!taskBoard.swimlaneField || !taskBoard.swimlanes) {\n                    items.swimlane = null;\n                }\n                // Otherwise hook it up with correct record field\n                else {\n                    if (!swimlane.name) {\n                        swimlane.name = taskBoard.swimlaneField;\n                    }\n                    if (!swimlane.label) {\n                        swimlane.label = StringHelper.capitalize(taskBoard.swimlaneField);\n                    }\n                }\n            }\n            // Remove resources field if there are no resources\n            if (!taskBoard.project.resourceStore.count) {\n                items.resources = null;\n            }\n            // Prevent multi selection if using single assignment mode\n            if (taskBoard.project.eventStore.usesSingleAssignment && resources) {\n                resources.multiSelect = false;\n            }\n        }\n        else {\n            items.column = items.swimlane = items.resources = null;\n        }\n        return super.changeItems(items, old);\n    }\n    processItemsObject(items, namedItems, result) {\n        // Use ref as name if not explicitly set\n        for (const ref in items) {\n            const item = items[ref];\n            if (item && !('name' in item)) {\n                item.name = ref;\n            }\n        }\n        return super.processItemsObject(items, namedItems, result);\n    }\n    updateAutoUpdateRecord(autoUpdate) {\n        this.bbar.hidden = autoUpdate;\n    }\n    updateRecord(record) {\n        super.updateRecord(record);\n        if (record) {\n            // Tag along task id, mainly for tests\n            this.element.dataset.taskId = record.id;\n        }\n    }\n    onSaveClick() {\n        const\n            me                       = this,\n            { record, owner }        = me,\n            { resources, ...values } = me.values;\n        if (me.isValid) {\n            /**\n             * Fires on the owning TaskBoard when user clicks `Save`, before changes are saved.\n             * Returning `false` from a listener prevents saving and keeps the editor open.\n             * @event beforeSave\n             * @on-owner\n             * @preventable\n             * @param {TaskBoard.view.TaskBoard} source The taskboard\n             * @param {TaskBoard.widget.TaskEditor} editor The editor\n             * @param {TaskBoard.model.TaskModel} record The task record\n             * @param {Object} values The task editor field values\n             */\n            if (owner?.trigger('beforeSave', { record, values : me.values, editor : me }) === false) {\n                return;\n            }\n            /**\n             * Fires on the owning TaskBoard when user clicks `Save`, after changes are saved.\n             * @event save\n             * @on-owner\n             * @param {TaskBoard.view.TaskBoard} source The taskboard\n             * @param {TaskBoard.widget.TaskEditor} editor The editor\n             * @param {TaskBoard.model.TaskModel} record The task record\n             * @param {Object} values The task editor field values\n             */\n            owner?.trigger('save', { record, values : me.values, editor : me });\n            // Close first to avoid focus restoring issues if the edit element gets removed by the operations below\n            me.close();\n            record.set(values);\n            if (resources) {\n                // Does not work when passed through set, handle it separately\n                record.resources = resources;\n            }\n        }\n    }\n    onCancelClick() {\n        const me = this;\n        /**\n         * Fires on the owning TaskBoard when user clicks 'Cancel'.\n         * Returning `false` from a listener prevents canceling and keeps the editor open.\n         * @event beforeCancel\n         * @preventable\n         * @param {TaskBoard.view.TaskBoard} source The taskboard\n         * @param {TaskBoard.widget.TaskEditor} editor The editor\n         */\n        if (me.owner?.trigger('beforeCancel', { editor : me }) === false) {\n            return;\n        }\n        /**\n         * Fires on the owning TaskBoard when user clicks 'Cancel', after the editor closed.\n         * @event cancel\n         * @preventable\n         * @param {TaskBoard.view.TaskBoard} source The taskboard\n         * @param {TaskBoard.widget.TaskEditor} editor The editor\n         */\n        me.owner?.trigger('cancel', { editor : me });\n        me.close();\n    }\n    onInternalKeyDown(event) {\n        const me = this;\n        if (me.saveAndCloseOnEnter && !me.readOnly && event.key === 'Enter') {\n            // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden\n            event.preventDefault();\n            if (me.autoUpdateRecord) {\n                if (me.isValid) {\n                    // Blur to get a change event before closing, to be sure record is up to date\n                    event.target.blur();\n                    me.close();\n                }\n            }\n            else {\n                me.onSaveClick();\n            }\n        }\n        super.onInternalKeyDown(event);\n    }\n}\nTaskEditor.initClass();\nTaskEditor._$name = 'TaskEditor';", "import Widget from '../../Core/widget/Widget.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport TaskBoardFeature from './TaskBoardFeature.js';\nimport Scroller from '../../Core/helper/util/Scroller.js';\nimport '../widget/TaskEditor.js';\n// Ensure SlideToggle is present so that type : 'checkbox' can be switched out on mobile\nimport '../../Core/widget/SlideToggle.js';\n/**\n * @module TaskBoard/feature/TaskEdit\n */\n/**\n * This features allows the user to edit tasks in a popup editor that can either be shown centered on screen (the\n * default, double click a task to show the editor):\n *\n * {@inlineexample TaskBoard/feature/TaskEdit.js}\n *\n * Or anchored to a task:\n *\n * {@inlineexample TaskBoard/feature/TaskEditAnchored.js}\n *\n * ## Default items\n *\n * By default it displays the following items:\n *\n * | Ref           | Type                                                   | Weight | Comment                                                                   |\n * |---------------|--------------------------------------------------------|--------|---------------------------------------------------------------------------|\n * | `name`        | {@link Core.widget.TextField text}                     | 100    | Task {@link TaskBoard.model.TaskModel#field-name}                         |\n * | `description` | {@link Core.widget.TextAreaField textarea}             | 200    | Task {@link TaskBoard.model.TaskModel#field-description}                  |\n * | `resources`*  | {@link TaskBoard.widget.ResourcesCombo resourcescombo} | 300    | Assigned resources                                                        |\n * | `color`       | {@link TaskBoard.widget.TaskColorCombo taskcolorcombo} | 400    | Task {@link TaskBoard.model.TaskModel#field-eventColor}                   |\n * | `column`      | {@link TaskBoard.widget.ColumnCombo columncombo}       | 500    | Bound to configured {@link TaskBoard.view.TaskBoard#config-columnField}   |\n * | `swimlane`*   | {@link TaskBoard.widget.SwimlaneCombo swimlanecombo}   | 600    | Bound to configured {@link TaskBoard.view.TaskBoard#config-swimlaneField} |\n * <sup>*</sup> Only shown when using resources / swimlanes respectively\n *\n * You can modify or remove the default items and add new custom items to the editor either at config time by using the\n * {@link #config-items items config} or at runtime by using the {@link #config-processItems processItems config}.\n *\n * ## Customize when configuring\n *\n * The {@link #config-items items config} accepts an object keyed by item ref (as listed in the table above). This\n * object will be merged with default items and the end result will determine which items are shown and how they are\n * configured.\n *\n * ### To remove a default item\n *\n * Set a ref to `null` to remove the item from the editor:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            items : {\n *                // Remove the color field\n *                color : null\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskEditRemove.js}\n *\n * ### To modify a default item\n *\n * Supply an object with the configs you want to change for a ref to modify the corresponding field:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            items : {\n *                // Change label of the description field and move it to the bottom\n *                description : {\n *                    label : 'Comment',\n *                    weight : 700\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskEditModify.js}\n *\n * ### To add a custom item\n *\n * Supply a config object for the new item, using a ref that is not used by any default item:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            items : {\n *                // Change label of the description field and move it to the bottom\n *                deadline : {\n *                    type   : 'date',\n *                    label  : 'Deadline',\n *                    weight : 300,\n *                    name   : 'deadline' // Bound field. If it matches the ref (key) for the field, it can be left out\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskEditAdd.js}\n *\n * ## Customize at runtime\n *\n * By supplying a function to {@link #config-processItems} you gain runtime control over which items are shown and how\n * they are configured:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            processItems({ taskRecord, items }) {\n *                // Hide description for tasks that are done\n *                if (taskRecord.status === 'done') {\n *                    items.description = null;\n *                }\n *\n *                // Modify the label for the name field\n *                items.name.label = 'Title';\n *\n *                // Add a custom item for high prio tasks\n *                if (taskRecord.prio === 'high') {\n *                    items.severity = { type : 'number', name : 'severity', label : 'Severity' }\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * You can also use `processItems` to prevent the editor from being shown for certain tasks, by returning `false` from\n * the function.\n *\n * {@inlineexample TaskBoard/feature/TaskEditProcessItems.js}\n *\n * ## Customizing other aspects of the editor\n *\n * By supplying an {@link #config-editorConfig} you can customize other aspects of the editor, such as its size, how\n * it is anchored, its title etc.\n *\n * {@inlineexample TaskBoard/feature/TaskEditEditorConfig.js}\n *\n * This feature is **enabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskEdit\n * @feature\n */\nexport default class TaskEdit extends TaskBoardFeature {\n    static $name = 'TaskEdit';\n    static type = 'taskEdit';\n    static configurable = {\n        /**\n         * Type of widget to use as the editor. Should point to a subclass of {@link TaskBoard.widget.TaskEditor} or\n         * a widget mimicking its API.\n         * @config {String}\n         * @default\n         * @category Customization\n         */\n        editorType : 'taskboardtaskeditor',\n        /**\n         * Config object merged with the default configuration of the editor (by default a\n         * {@link TaskBoard.widget.TaskEditor}).\n         *\n         * Can be used to configure any aspect of the editor:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskEdit : {\n         *             editorConfig : {\n         *                 modal    : false,\n         *                 centered : false\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         * To customize the items in the editor, using {@link #config-items} is preferable.\n         * @config {TaskEditorConfig}\n         * @category Customization\n         */\n        editorConfig : {},\n        /**\n         * Items definition passed on to the configured editor (by default a {@link TaskBoard.widget.TaskEditor}).\n         *\n         * Can be used to add new items or modify and remove predefined items. To remove, supply `null` as the value.\n         *\n         * @config {Object<String,ContainerItemConfig|Boolean|null>}\n         * @category Customization\n         */\n        items : {},\n        /**\n         * A function called before displaying the editor that allows manipulation of its items.\n         * Returning `false` from this function prevents the editor from being shown.\n         *\n         * ```javascript\n         * features         : {\n         *    taskEdit : {\n         *         processItems({ items, taskRecord, columnRecord, swimlaneRecord }) {\n         *             // Manipulate existing items here as needed\n         *             items.name.label = taskRecord.type === 'task' ? 'Task' : 'Issue';\n         *\n         *            // Remove column field when editing tasks that are done\n         *            if (columnRecord.id === 'done') {\n         *                items.column = false\n         *            }\n         *         }\n         *     }\n         * },\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} context An object with information about the editor being shown\n         * @param {Object<String,ContainerItemConfig>} context.items An object containing the editor item configs keyed by ref\n         * @param {TaskBoard.model.TaskModel} context.taskRecord Record representing task being edited\n         * @param {TaskBoard.model.ColumnModel} context.columnRecord Record representing tasks column\n         * @param {TaskBoard.model.SwimlaneModel} context.swimlaneRecord Record representing tasks swimlane\n         * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n         * @preventable\n         */\n        processItems : null\n        // /**\n        //  * The event that shall trigger showing the editor. Defaults to `eventdblclick`, set to `` or null to disable editing of existing events.\n        //  * @config {String}\n        //  * @default\n        //  * @category Editor\n        //  */\n        // triggerEvent : 'eventdblclick',\n        // /**\n        //  * Specify `true` to put the editor in read only mode.\n        //  * @config {Boolean}\n        //  * @default false\n        //  */\n        // readOnly : null,\n    };\n    editor = null;\n    static pluginConfig = {\n        assign : ['editTask'],\n        chain  : ['onActivateTask', 'populateTaskMenu']\n    };\n    doDestroy() {\n        this.editor?.destroy();\n    }\n    //region Type assertions\n    changeEditorConfig(editorConfig) {\n        ObjectHelper.assertObject(editorConfig, 'features.taskEdit.editorConfig');\n        return editorConfig;\n    }\n    changeEditorType(editorType) {\n        ObjectHelper.assertString(editorType, 'features.taskEdit.editorType');\n        return editorType;\n    }\n    changeItems(items) {\n        ObjectHelper.assertObject(items, 'features.taskEdit.items');\n        return items;\n    }\n    changeProcessItems(processItems) {\n        ObjectHelper.assertFunction(processItems, 'features.taskEdit.processItems');\n        return processItems;\n    }\n    //endregion\n    /**\n     * Edit the supplied task in the task editor.\n     *\n     * ```javascript\n     * taskBoard.editTask(taskStore.first);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord Task to edit\n     * @param {HTMLElement} [element] Optionally an element to align to, by default it tries to resolve one from the\n     * supplied task when the editor is configured to not be centered.\n     * @on-owner\n     * @category Common\n     */\n    async editTask(taskRecord, element = null) {\n        const\n            me             = this,\n            { client }     = me,\n            columnRecord   = client.getColumn(taskRecord),\n            swimlaneRecord = client.swimlaneField && client.swimlanes?.getById(taskRecord.getValue(client.swimlaneField));\n        if (me.disabled) {\n            return;\n        }\n        /**\n         * Fires on the owning TaskBoard before a task is displayed in an editor.\n         *\n         * Returning `false` or a promise that resolves to `false` stops the default editing UI from being shown.\n         *\n         * ```javascript\n         * taskBoard.on({\n         *     beforeTaskEdit({ taskRecord }) {\n         *         return await userCanEdit(taskRecord);\n         *     }\n         * }\n         * ```\n         *\n         * @event beforeTaskEdit\n         * @param {TaskBoard.view.TaskBoard} source The owning TaskBoard\n         * @param {TaskBoard.model.TaskModel} taskRecord The record about to be shown in the task editor\n         * @on-owner\n         * @preventable\n         * @async\n         */\n        if (await client.trigger('beforeTaskEdit', { taskRecord }) === false) {\n            return;\n        }\n        if (me.isEditing) {\n            me.cancelEdit();\n        }\n        const\n            editorClass   = Widget.resolveType(me.editorType),\n            // Combine items defined on the feature with those defined on the editor\n            combinedItems = editorClass.mergeConfigs(editorClass.$meta.config.items, me.items),\n            // Allow user supplied fn to process the items, returning false will abort edit\n            processResult = me.processItems?.({ items : combinedItems, taskRecord, columnRecord, swimlaneRecord });\n        if (processResult === false) {\n            return;\n        }\n        const editor = me.editor = editorClass.new({\n            items    : combinedItems,\n            owner    : client,\n            readOnly : taskRecord.readOnly\n        }, me.editorConfig);\n        /**\n         * Fires on the owning TaskBoard when the editor for a task is available, but before it is populated with data\n         * and shown. Allows manipulating fields etc.\n         *\n         * ```javascript\n         * taskBoard.on({\n         *     beforeTaskEditShow({ taskRecord, editor }) {\n         *         editor.title = `Editing \"${taskRecord.name}\"`;\n         *     }\n         * }\n         * ```\n         *\n         * @event beforeTaskEditShow\n         * @on-owner\n         * @param {TaskBoard.view.TaskBoard} source The owning TaskBoard\n         * @param {TaskBoard.model.TaskModel} taskRecord The record about to be shown in the task editor\n         * @param {TaskBoard.widget.TaskEditor} editor The editor\n         */\n        client.trigger('beforeTaskEditShow', { taskRecord, editor });\n        editor.record = taskRecord;\n        if (editor.centered || !BrowserHelper.isHoverableDevice) {\n            editor.show();\n        }\n        else {\n            Scroller.scrollIntoView(element ?? client.getTaskElement(taskRecord));\n            editor.showBy(element ?? client.getTaskElement(taskRecord));\n        }\n        editor.isVisible && editor.ion({\n            hide    : me.onEditorHide,\n            thisObj : me\n        });\n    }\n    cancelEdit() {\n    }\n    onActivateTask({ taskRecord, event }) {\n        if (!event.defaultPrevented) {\n            this.editTask(taskRecord);\n        }\n    }\n    populateTaskMenu({ items, taskRecord }) {\n        if (!this.client.readOnly && !this.disabled) {\n            items.editTask = {\n                text     : 'L{TaskBoard.editTask}',\n                icon     : 'b-fw-icon b-icon-edit',\n                weight   : 100,\n                onItem   : () => this.editTask(taskRecord),\n                disabled : taskRecord.readOnly\n            };\n        }\n    }\n    onEditorHide() {\n        this.client.getTaskElement(this.editor.record)?.focus();\n    }\n}\nTaskEdit.initClass();\nTaskEdit._$name = 'TaskEdit';", "import TaskBoardFeature from './TaskBoardFeature.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport ContextMenuBase from '../../Core/feature/base/ContextMenuBase.js';\nimport AvatarRendering from '../../Core/widget/util/AvatarRendering.js';\n/**\n * @module TaskBoard/feature/TaskMenu\n */\n/**\n * Displays a context menu for tasks. Items are populated by other features and/or application code.\n *\n * {@inlineexample TaskBoard/feature/TaskMenu.js}\n *\n * You can optionally also use a {@link TaskBoard/view/item/TaskMenuItem} button to display the menu.\n *\n * ## Default items\n *\n * These are the default items provided by TaskBoard features:\n *\n * | Reference    | Weight | Feature                            | Description                                      |\n * |--------------|--------|------------------------------------|--------------------------------------------------|\n * | `editTask`   | 100    | {@link TaskBoard.feature.TaskEdit} | Open task editor. Hidden when read-only          |\n * | `resources`  | 200    | *This feature*                     | Assign/unassign resources. Hidden when read-only |\n * | `column`     | 300    | *This feature*                     | Move to column. Hidden when read-only            |\n * | `swimlane`   | 400    | *This feature*                     | Move to swimlane. Hidden when read-only          |\n * | `removeTask` | 500    | *This feature*                     | Remove task. Hidden when read-only               |\n *\n * Default items in the menu can be changed or removed and new items can be added. This is handled using the\n * {@link #config-items} config of the feature.\n *\n * ## Add items\n *\n * Add menu items for all tasks by adding a key (used as menu item {@link Core/widget/Widget#config-ref}) with a\n * {@link Core/widget/MenuItem#configs config object for a menu item} as the value to the {@link #config-items} config:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         taskMenu : {\n *             items : {\n *                 flagTask : {\n *                     text : 'Flag task',\n *                     icon : 'b-fa-fw b-fa-flag',\n *                     onItem({ taskRecord }) {\n *                         taskRecord.flagged = true;\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskMenuAdd.js}\n *\n * ## Remove items\n *\n * To remove default items, configure them as `null` in the {@link #config-items} config:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         taskMenu : {\n *             items : {\n *                 removeTask : null,\n *                 resources : null\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskMenuRemove.js}\n *\n * ## Customize items\n *\n * To customize default items, supply a new config object for them in the {@link #config-items} config. It will merge\n * with the default config object:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         taskMenu : {\n *             items : {\n *                 removeTask : {\n *                     text : 'Delete card'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/feature/TaskMenuCustomize.js}\n *\n * ## Manipulating items at runtime\n *\n * Manipulate items for all tasks or specific tasks at runtime by supplying a {@link #config-processItems} function:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     features : {\n *         taskMenu : {\n *             // Process items before menu is shown\n *             processItems({ taskRecord, items }) {\n *                  // Push an extra item for done tasks\n *                  if (taskRecord.status === 'done') {\n *                      items.archive = {\n *                          text : 'Archive',\n *                          icon : 'b-fa-fw b-fa-archive'\n *                          onItem({ taskRecord }) {\n *                              taskRecord.archived = true;\n *                          }\n *                      };\n *                  }\n *\n *                  // Do not show menu for low prio tasks\n *                  if (taskRecord.prio === 'low') {\n *                      return false;\n *                  }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">The `processItems` implementation my be an `async` function which `awaits` a result to\n * mutate the `items` object.</div>\n *\n * {@inlineexample TaskBoard/feature/TaskMenuProcessItems.js}\n *\n * This feature is **enabled** by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys           | Action                 | Action description                               |\n * |----------------|------------------------|--------------------------------------------------|\n * | `Space`        | *showContextMenuByKey* | Shows context menu for currently focused task    |\n * | `Ctrl`+`Space` | *showContextMenuByKey* | Shows context menu for currently focused task    |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#TaskBoard/guides/customization/keymap.md).\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskMenu\n * @feature\n */\nexport default class TaskMenu extends ContextMenuBase {\n    static $name = 'TaskMenu';\n    static type = 'taskMenu';\n    static configurable = {\n        /**\n         * A function called before displaying the menu that allows manipulations of its items.\n         * Returning `false` from this function prevents the menu from being shown.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *   features         : {\n         *       taskMenu : {\n         *           processItems({ taskRecord, items }) {\n         *              // Add a custom menu item for tasks with progress greater than 90\n         *              if (taskRecord.progress > 90) {\n         *                  items.close = {\n         *                      text : 'Close',\n         *                      icon : 'b-fa-fw b-fa-check',\n         *                      onItem({ taskRecord }) {\n         *                          taskRecord.done = true;\n         *                      }\n         *                  }\n         *              }\n         *           }\n         *       }\n         *   }\n         * });\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} context An object with information about the menu being shown\n         * @param {TaskBoard.model.TaskModel} context.taskRecord The task for which the menu will be shown\n         * @param {Object<string,MenuItemConfig|Boolean>} context.items An object containing the\n         *   {@link Core.widget.MenuItem menu item} configs keyed by their id\n         * @param {Event} context.event The DOM event object that triggered the show\n         * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n         * @preventable\n         */\n        processItems : null,\n        /**\n         * This is a preconfigured set of items used to create the default context menu.\n         *\n         * The `items` provided by this feature are listed in the intro section of this class. You can configure\n         * existing items by passing a configuration object to the keyed items.\n         *\n         * To remove existing items, set corresponding keys to `null`:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskMenu : {\n         *             items : {\n         *                 editTask : null\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * See the feature config in the above example for details.\n         *\n         * @config {Object<string,MenuItemConfig|Boolean|null>} items\n         */\n        items : null,\n        type : 'task',\n        /**\n         * The mouse / touch gesture which should show this context menu (e.g. 'taskClick' or 'taskContextMenu').\n         * Set to `false` to never trigger it from UI.\n         * @default\n         * @config {String|Boolean}\n         */\n        triggerEvent : 'taskContextMenu',\n        /**\n         * Show avatars/initials in the resource picker menu\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskMenu : {\n         *             showAvatars : false\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @default true\n         */\n        showAvatars : {\n            value   : true,\n            $config : 'nullify'\n        },\n        menu : {\n            align  : 't90-b90',\n            anchor : true\n        }\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<string,string>} keyMap\n         */\n        /**\n         * @hideconfigs type\n         */\n    };\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n        config.chain.push('populateTaskMenu');\n        return config;\n    }\n    //region Type assertions\n    changeItems(items) {\n        ObjectHelper.assertObject(items, 'features.taskMenu.items');\n        return items;\n    }\n    changeProcessItems(processItems) {\n        ObjectHelper.assertFunction(processItems, 'features.taskMenu.processItems');\n        return processItems;\n    }\n    //endregion\n    //region Events\n    /**\n     * This event fires on the owning TaskBoard before the context menu is shown for a task.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event taskMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<string,MenuItemConfig>} items Menu item configs\n     * @param {TaskBoard.model.TaskModel} taskRecord The task\n     * @on-owner\n     */\n    /**\n     * This event fires on the owning TaskBoard after the context menu is shown for a task.\n     * @event taskMenuShow\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<string,MenuItemConfig>} items Menu item configs\n     * @param {TaskBoard.model.TaskModel} taskRecord The task\n     * @on-owner\n     */\n    /**\n     * This event fires on the owning TaskBoard when an item is selected in the task context menu.\n     * @event taskMenuItem\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {TaskBoard.model.TaskModel} taskRecord The task\n     * @on-owner\n     */\n    /**\n     * This event fires on the owning TaskBoard when a check item is toggled in the task context menu.\n     * @event taskMenuToggleItem\n     * @on-owner\n     * @param {TaskBoard.view.TaskBoard} source The grid\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {TaskBoard.model.TaskModel} taskRecord The task\n     * @param {Boolean} checked Checked or not\n     * @on-owner\n     */\n    //endregion\n    updateTriggerEvent(triggerEvent) {\n        this.detachListeners('triggerEvent');\n        if (triggerEvent) {\n            this.client.ion({\n                name           : 'triggerEvent',\n                [triggerEvent] : 'onTriggerEvent',\n                thisObj        : this\n            });\n        }\n    }\n    doDisable(disable) {\n        super.doDisable(disable);\n        !this.isConfiguring && this.client.recompose();\n    }\n    onTriggerEvent({ event }) {\n        this.internalShowContextMenu(event);\n    }\n    /**\n     * Show the context menu for a specific task, aligned to its card. Optionally aligned to an element in the card, using the supplied CSS selector.\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord Task to show the menu for\n     * @param {String} [selector] CSS selector, to align to a specific element in the task's card\n     */\n    showMenuFor(taskRecord, selector = '.b-taskboard-task-menu') {\n        const\n            targetElement = this.client.getTaskElement(taskRecord),\n            buttonElement = targetElement.querySelector(selector),\n            eventParams   = { taskRecord, columnRecord : this.client.getColumn(taskRecord), targetElement };\n        let alignSpec = null;\n        if (buttonElement) {\n            eventParams.targetElement = buttonElement;\n            alignSpec = {\n                target : buttonElement\n            };\n        }\n        this.showContextMenu(eventParams, alignSpec);\n    }\n    showContextMenu(eventParams, ...args) {\n        if (!this.client.isSelected(eventParams.taskRecord)) {\n            this.client.selectTask(eventParams.taskRecord);\n        }\n        super.showContextMenu(eventParams, ...args);\n    }\n    getDataFromEvent(event) {\n        return ObjectHelper.assign(super.getDataFromEvent(event), event.taskBoardData);\n    }\n    populateTaskMenu({ items, taskRecord }) {\n        const { client, disabled } = this;\n        if (!client.readOnly && !disabled) {\n            const\n                { columnField, swimlaneField, selectedTasks } = client,\n                { resourceStore, eventStore }                 = client.project,\n                isSelected                                    = selectedTasks.includes(taskRecord);\n            items.column = {\n                text     : `L{TaskBoard.changeColumn} ${columnField}`,\n                icon     : 'b-fw-icon b-icon-move-left-right',\n                weight   : 300,\n                disabled : taskRecord.readOnly,\n                menu     : client.columns.map(col => ({\n                    ref         : col.id,\n                    text        : StringHelper.encodeHtml(col.text),\n                    cls         : 'b-column-menu-item',\n                    isColumn    : true,\n                    checked     : taskRecord.getValue(columnField) === col.id,\n                    // Close menu when task is moved to a new column, looks weird to keep it open\n                    closeParent : true\n                })),\n                onItem({ item }) {\n                    if (item.isColumn) {\n                        taskRecord.setValue(columnField, item.ref);\n                        item.parent.items.forEach(sibling => {\n                            if (sibling !== item) {\n                                sibling.checked = false;\n                            }\n                        });\n                    }\n                }\n            };\n            if (client.swimlanes?.count && swimlaneField) {\n                items.swimlane = {\n                    text     : StringHelper.xss`L{TaskBoard.changeSwimlane} ${swimlaneField}`,\n                    icon     : 'b-fw-icon b-icon-move-up-down',\n                    weight   : 400,\n                    disabled : taskRecord.readOnly,\n                    menu     : client.swimlanes.map(lane => ({\n                        ref         : lane.id,\n                        text        : StringHelper.encodeHtml(lane.text),\n                        isSwimlane  : true,\n                        checked     : taskRecord.getValue(swimlaneField) === lane.id,\n                        // Close menu when task is moved to a new swimlane, looks weird to keep it open\n                        closeParent : true\n                    })),\n                    onItem({ item }) {\n                        if (item.isSwimlane) {\n                            taskRecord.setValue(swimlaneField, item.ref);\n                            item.parent.items.forEach(sibling => {\n                                if (sibling !== item) {\n                                    sibling.checked = false;\n                                }\n                            });\n                        }\n                    }\n                };\n            }\n            if (resourceStore.count) {\n                items.resources = {\n                    text     : 'L{TaskBoard.resources}',\n                    icon     : 'b-fw-icon b-icon-user',\n                    weight   : 200,\n                    disabled : taskRecord.readOnly,\n                    menu     : resourceStore.map(resource => {\n                        const avatar = this.avatarRendering?.getResourceAvatar({\n                            resourceRecord : resource,\n                            initials       : resource.initials,\n                            color          : resource.color,\n                            iconCls        : resource.iconCls,\n                            imageUrl       : resource.imageUrl || ((client.resourceImagePath || '') + (resource.image || ''))\n                        });\n                        return {\n                            ref  : resource.id,\n                            cls  : 'b-resource-menu-item',\n                            text : avatar ? {\n                                className : 'b-resource-menu-item-inner',\n                                children  : [\n                                    avatar,\n                                    StringHelper.encodeHtml(resource.name)\n                                ]\n                            } : StringHelper.encodeHtml(resource.name),\n                            resource,\n                            checked     : taskRecord.resources.includes(resource),\n                            // Only allow single pick in single assignment mode\n                            toggleGroup : eventStore.usesSingleAssignment ? 'single' : null\n                        };\n                    }\n                    ),\n                    onItem({ item }) {\n                        if (item.resource) {\n                            taskRecord[item.checked ? 'assign' : 'unassign'](item.resource);\n                        }\n                    }\n                };\n            }\n            items.removeTask = {\n                text     : isSelected && selectedTasks.length > 1 ? 'L{TaskBoard.removeTasks}' : 'L{TaskBoard.removeTask}',\n                icon     : 'b-fw-icon b-icon-trash',\n                cls      : 'b-separator',\n                weight   : 500,\n                disabled : taskRecord.readOnly,\n                onItem   : () => client.removeTask(isSelected ? selectedTasks : taskRecord)\n            };\n        }\n    }\n    get showMenu() {\n        return true;\n    }\n    updateShowAvatars(value) {\n        this.avatarRendering?.destroy();\n        if (value) {\n            this.avatarRendering = new AvatarRendering({\n                element : this.client.element\n            });\n        }\n    }\n}\n// Register this feature type with its Factory\nTaskBoardFeature.register(TaskMenu.type, TaskMenu);\nTaskMenu._$name = 'TaskMenu';", "import ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport TaskBoardFeature from './TaskBoardFeature.js';\n/**\n * @module TaskBoard/feature/TaskTooltip\n */\n/**\n * Displays a tooltip when hovering a task. By default the tooltip displays:\n *\n * * task name\n * * task column\n * * task swimlane (if using swimlanes)\n * * names of assigned resources (if any)\n *\n * {@inlineexample TaskBoard/feature/TaskTooltip.js}\n *\n * To customize the contents, supply your own {@link #config-template}:\n *\n * {@inlineexample TaskBoard/feature/TaskTooltipTemplate.js}\n *\n * This feature is **disabled** by default.\n *\n * @extends TaskBoard/feature/TaskBoardFeature\n * @uninherit Core/Base\n * @uninherit Core/localization/Localizable\n * @classtype taskTooltip\n * @feature\n */\nexport default class TaskTooltip extends TaskBoardFeature {\n    static $name = 'TaskTooltip';\n    static type = 'taskTooltip';\n    static configurable = {\n        /**\n         * Tooltip config object used to override the defaults, see {@link Core.widget.Tooltip#configs} for available\n         * configs.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskTooltip : {\n         *             tooltip : {\n         *                 hoverDelay : 100,\n         *                 hideDelay  : 500\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {TooltipConfig}\n         */\n        tooltip : {\n            value : {},\n            // Lazy, pulled in on render to have element available\n            $config : ['lazy', 'nullify']\n        },\n        /**\n         * Function used to populate the tooltip, supply your own to override the default contents of the tooltip.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     features : {\n         *         taskTooltip : {\n         *             template({ taskRecord }) {\n         *                 return `<b>${taskRecord.name}</b>`\n         *             }\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @param {Object} tipData\n         * @param {TaskBoard.model.TaskModel} tipData.taskRecord Hovered task\n         * @param {TaskBoard.model.ColumnModel} tipData.columnRecord The task's column\n         * @param {TaskBoard.model.SwimlaneModel} tipData.swimlaneRecord The task's swimlane (if used)\n         * @returns {String|DomConfig} Return an HTML string or a DOM config object\n         * @config {Function}\n         */\n        template : null\n    };\n    static pluginConfig = {\n        chain : ['render']\n    };\n    //region Type assertions\n    changeTemplate(template) {\n        ObjectHelper.assertFunction(template, 'features.taskTooltip.template');\n        return template;\n    }\n    //endregion\n    doDisable(disable) {\n        super.doDisable(disable);\n        if (this._tooltip) {\n            this.tooltip.disabled = disable;\n        }\n    }\n    changeTooltip(tooltip, oldTooltip) {\n        const\n            me         = this,\n            { client } = me;\n        ObjectHelper.assertObject(tooltip, 'features.taskTooltip.tooltip');\n        oldTooltip?.destroy();\n        if (tooltip) {\n            return new Tooltip(ObjectHelper.assign({\n                axisLock       : 'flexible',\n                cls            : 'b-taskboard-tooltip',\n                forSelector    : '.b-taskboardbase:not(.b-draghelper-active) .b-taskboard-card',\n                scrollAction   : 'realign',\n                forElement     : client.element,\n                showOnHover    : true,\n                hoverDelay     : 0,\n                hideDelay      : 100,\n                anchorToTarget : true,\n                allowOver      : Boolean(me.config.items || me.config.tools),\n                getHtml        : me.getTipHtml.bind(me),\n                disabled       : me.disabled,\n                textContent    : false\n            }, tooltip));\n        }\n    }\n    getTipHtml({ tip, activeTarget }) {\n        const\n            { client }     = this,\n            taskRecord     = client.resolveTaskRecord(activeTarget),\n            columnRecord   = client.resolveColumnRecord(activeTarget),\n            swimlaneRecord = client.resolveSwimlaneRecord(activeTarget);\n        if (this.template) {\n            return this.template({ tip, taskRecord, columnRecord, swimlaneRecord, activeTarget });\n        }\n        const children = [\n            {\n                class : 'b-taskboard-tooltip-title',\n                text  : taskRecord.name\n            },\n            {\n                class : 'b-taskboard-tooltip-label',\n                text  : StringHelper.capitalize(client.columnField)\n            },\n            {\n                class : 'b-taskboard-tooltip-value',\n                text  : columnRecord.text\n            }\n        ];\n        if (swimlaneRecord) {\n            children.push(\n                {\n                    class : 'b-taskboard-tooltip-label',\n                    text  : StringHelper.capitalize(client.swimlaneField)\n                },\n                {\n                    class : 'b-taskboard-tooltip-value',\n                    text  : swimlaneRecord.text\n                }\n            );\n        }\n        if (taskRecord.resources.length) {\n            children.push(\n                {\n                    class : 'b-taskboard-tooltip-label',\n                    text  : this.L('L{TaskBoard.resources}')\n                },\n                {\n                    class : 'b-taskboard-tooltip-value',\n                    text  : taskRecord.resources.map(resourceRecord => resourceRecord.name).join(', ')\n                }\n            );\n        }\n        return {\n            children\n        };\n    }\n    render() {\n        // Element is now available, pull in tooltip to have it correctly wired up\n        this.getConfig('tooltip');\n    }\n}\nTaskTooltip.initClass();\nTaskTooltip._$name = 'TaskTooltip';", "import Model from '../../Core/data/Model.js';\n/**\n * @module TaskBoard/model/ColumnModel\n */\n/**\n * Represents a single column on a TaskBoard.\n *\n * When creating a TaskBoard, you supply an initial set of columns. These columns are either defined as plain strings,\n * ColumnModel data objects or ColumnModel records (or a mix thereof). When using strings, the string will be used as is\n * as the column's id and capitalized as its text.\n *\n * ```javascript\n * const doneColumn = new ColumnModel({\n *     id   : 'done',\n *     text : 'Done'\n * });\n *\n * const taskBoard = new TaskBoard({\n *     columns : [\n *         // String, equal to passing { id : 'todo', text : 'Todo' }\n *         'todo',\n *         // Data object, in this case with a fixed width and not collapsible from the UI\n *         { id : 'doing', text : 'Doing', width : 200, collapsible : false }\n *         // Record, not commonly used since it is easier to supply the data object directly\n *         doneColumn\n *     ]\n * });\n * ```\n *\n * @extends Core/data/Model\n * @uninherit Core/data/mixin/TreeNode\n */\nexport default class ColumnModel extends Model {\n    static $name = 'ColumnModel';\n    static fields = [\n        /**\n         * This column's unique id, used to match a task to a column (which field on a task to match is specified using\n         * then {@link TaskBoard.view.TaskBoardBase#config-columnField} config on TaskBoard).\n         * @field {String|Number} id\n         */\n        /**\n         * Text displayed in the column header.\n         * @field {String} text\n         */\n        'text',\n        /**\n         * A tooltip string to show when hovering the column header\n         * @field {String} tooltip\n         */\n        'tooltip',\n        /**\n         * Color, named colors are applied as a `b-taskboard-color-{color}` (for example `b-taskboard-color-red`) CSS\n         * class to the column. Colors specified as hex, `rgb()` etc. are applied as `style.color` to the column.\n         *\n         * By default it does not visually affect the UI, but it applies a color to the column that applications can\n         * leverage using `currentColor` to style it in the desired way.\n         *\n         * Using named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     columns : [\n         *         { id : 'todo', text : 'Todo', color : 'orange', tooltip : 'These are items to be done' }\n         *     ]\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-column b-taskboard-color-orange\">\n         * ```\n         *\n         * Which can the be used for example like:\n         *\n         * ```css\n         * .b-taskboard-column-header {\n         *     border-left : 5px solid currentColor; // where currentColor is the color defined by b-taskboard-color-orange\n         * }\n         * ```\n         *\n         * Using non-named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     columns : [\n         *         { id : 'todo', text : 'Todo', color : 'hsl(229deg 66% 42%)' }\n         *     ]\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-column\" style=\"color: hsl(229deg 66% 42%)\">\n         * ```\n         *\n         * Predefined named colors (actual color might vary by theme):\n         * <div class=\"b-colorbox b-inline b-taskboard-color-red\"></div>red,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-pink\"></div>pink,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-purple\"></div>purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-purple\"></div>deep-purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-indigo\"></div>indigo,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-blue\"></div>blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-blue\"></div>light-blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-cyan\"></div>cyan,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-teal\"></div>teal,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-green\"></div>green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-green\"></div>light-green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-lime\"></div>lime,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-yellow\"></div>yellow,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-amber\"></div>amber,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-orange\"></div>orange,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-orange\"></div>deep-orange\n         *\n         * @field {String} color\n         */\n        { name : 'color', type : 'string' },\n        /**\n         * Number of tasks per row to display in this column. Leave blank to use the setting from the\n         * {@link TaskBoard.view.TaskBoardBase#config-tasksPerRow} config on TaskBoard.\n         * @field {Number} tasksPerRow\n         */\n        'tasksPerRow',\n        /**\n         * Allow collapsing this column\n         * @field {Boolean} collapsible=true\n         */\n        { name : 'collapsible', type : 'boolean', defaultValue : true },\n        /**\n         * Collapsed (`true`) or expanded (`false`)\n         *\n         * To expand or collapse, use {@link #function-expand} and  {@link #function-collapse} functions.\n         *\n         * @field {Boolean} collapsed\n         * @readonly\n         */\n        { name : 'collapsed', type : 'boolean' },\n        /**\n         * Set to `true` to hide the column, `false` to show it again.\n         * @field {Boolean} hidden\n         */\n        { name : 'hidden', type : 'boolean' },\n        /**\n         * Column width in px.\n         * @field {Number} width\n         */\n        { name : 'width', type : 'number' },\n        /**\n         * Column flex, affects width.\n         * @field {Number} flex\n         */\n        { name : 'flex', type : 'number' },\n        /**\n         * Column min-width in px. To override the default min-width specified in CSS.\n         * @field {Number} minWidth\n         */\n        { name : 'minWidth', type : 'number' }\n    ];\n    /**\n     * Get the tasks in this column in visual order.\n     * @property {TaskBoard.model.TaskModel[]}\n     * @readonly\n     */\n    get tasks() {\n        return this.taskBoard.getColumnTasks(this, true);\n    }\n    get taskBoard() {\n        return this.firstStore.taskBoard;\n    }\n    /**\n     * Collapse this column.\n     *\n     * Uses a transition by default, await the call to be certain that it has finished.\n     *\n     * @category Expand/collapse\n     * @returns {Promise} A promise which is resolved when the column is collapsed\n     */\n    async collapse() {\n        return this.taskBoard.collapse(this);\n    }\n    /**\n     * Expand this column.\n     *\n     * Uses a transition by default, await the call to be certain that it has finished.\n     *\n     * @category Expand/collapse\n     * @returns {Promise} A promise which is resolved when the column is expanded\n     */\n    async expand() {\n        return this.taskBoard.expand(this);\n    }\n}\nColumnModel._$name = 'ColumnModel';", "import EventModel from '../../Scheduler/model/EventModel.js';\n/**\n * @module TaskBoard/model/TaskModel\n */\n/**\n * Represents a single task on your TaskBoard, usually added to a {@link TaskBoard/store/TaskStore}.\n *\n * ## Customizing Task fields\n *\n * The TaskModel has a few predefined fields as seen under Fields below. If you want to add new fields or change\n * existing fields, you can do that by subclassing this class:\n *\n * ```javascript\n * class MyTask extends TaskModel {\n *\n *     static get fields() {\n *         return [\n *            // Add a new field\n *            { name: 'myField', type : 'number', defaultValue : 0 }\n *         ];\n *     }\n *\n *     ...\n * }\n *\n * // Instances of your class now has getters / setters defined for your field\n * const task = new MyTask();\n * console.log(task.myField); // => 0\n * ```\n *\n * If you want to use other names for any predefined field in your data, you can reconfigure them as seen below:\n *\n * ```javascript\n * class MyTask extends TaskModel {\n *\n *     static get fields() {\n *         return [\n *            // Remap status -> state\n *            { name: 'status', dataSource : 'state' }\n *         ];\n *     }\n *\n *     ...\n * }\n * ```\n *\n * ## Configuring the Project to use a custom task model\n *\n * Here's how you configure the {@link TaskBoard/model/ProjectModel Project} to use a certain Model class:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     // Configure the project to use our custom task model and to load data remotely\n *     project : {\n *         taskModelClass : MyTask,\n *\n *         autoLoad  : true\n *         transport : {\n *             load : {\n *                 url : 'data/data.json'\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ## Read-only tasks\n *\n * A task can be flagged as read-only using the {@link #field-readOnly} field. This protects it from being edited in the\n * UI, but has no effect on the data layer.\n *\n * {@inlineexample TaskBoard/model/TaskModelReadOnly.js}\n *\n * Please refer to {@link Core/data/Model} for additional details.\n *\n * @extends Scheduler/model/EventModel\n */\nexport default class TaskModel extends EventModel {\n    static $name = 'TaskModel';\n    static fields = [\n        /**\n         * Task status, for example for linking to a column on the TaskBoard.\n         *\n         * @field {String} status\n         */\n        'status',\n        /**\n         * Task priority, for example for linking to a swimlane on the TaskBoard.\n         *\n         * @field {String|Number} prio\n         */\n        'prio',\n        /**\n         * Task description, by default shown in tasks body.\n         *\n         * @field {String} description\n         */\n        'description',\n        /**\n         * Color, named colors are applied as a `b-taskboard-color-{color}` (for example `b-taskboard-color-red`) CSS\n         * class to the tasks card. Colors specified as hex, `rgb()` etc. are applied as `style.color` to the card.\n         *\n         * If no color is specified, any color defined on the {@link TaskBoard/model/ColumnModel#field-color column} or\n         * {@link TaskBoard/model/SwimlaneModel#field-color swimlane} will apply instead.\n         *\n         * By default it does not visually affect the UI, but it applies a color to the task that applications can\n         * leverage using `currentColor` to style it in the desired way.\n         *\n         * Using named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     project {\n         *         tasksData : [\n         *             { id : 1, name : 'Important task', eventColor : 'red' }\n         *         ]\n         *     }\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-card b-taskboard-color-red\">\n         * ```\n         *\n         * Which can the be used for example like:\n         *\n         * ```css\n         * .b-taskboard-card {\n         *     // currentColor is the color defined by b-red\n         *     border-left : 5px solid currentColor;\n         * }\n         * ```\n         *\n         * Using non-named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     project {\n         *         tasksData : [\n         *             { id : 1, name : 'Important task', eventColor : '#ff0000' }\n         *         ]\n         *     }\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-card\" style=\"color: #ff0000\">\n         * ```\n         *\n         * Predefined named colors (actual color might vary by theme):\n         * <div class=\"b-colorbox b-inline b-taskboard-color-red\"></div>red,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-pink\"></div>pink,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-purple\"></div>purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-purple\"></div>deep-purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-indigo\"></div>indigo,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-blue\"></div>blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-blue\"></div>light-blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-cyan\"></div>cyan,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-teal\"></div>teal,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-green\"></div>green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-green\"></div>light-green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-lime\"></div>lime,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-yellow\"></div>yellow,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-amber\"></div>amber,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-orange\"></div>orange,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-orange\"></div>deep-orange,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-gray\"></div>gray,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-gray\"></div>light-gray\n         *\n         * @field {'red'|'pink'|'purple'|'deep-purple'|'indigo'|'blue'|'light-blue'|'cyan'|'teal'|'green'|'light-green'|'lime'|'yellow'|'amber'|'orange'|'deep-orange'|'gray'|'light-gray'|String|null} eventColor\n         */\n        'eventColor',\n        /**\n         * Task weight, used by default to determine its index in a column. Higher weights are displayed further down.\n         *\n         * The weight is applied as a default sorter to the {@link TaskBoard/store/TaskStore}.\n         *\n         * When no weights are defined, task order is determined by store order.\n         *\n         * @field {Number} weight\n         */\n        { name : 'weight', type : 'number' },\n        /**\n         * Set to `true` to make the task read-only, preventing it from being edited in the UI.\n         *\n         * See the class description above for a live demo.\n         *\n         * @field {Boolean} readOnly\n         */\n        { name : 'readOnly', type : 'boolean' }\n    ];\n}\nTaskModel._$name = 'TaskModel';", "import EventStore from '../../Scheduler/data/EventStore.js';\nimport TaskModel from '../model/TaskModel.js';\n/**\n * @module TaskBoard/data/TaskStore\n */\n/**\n * Store that holds the tasks of a TaskBoard. By default configured to use {@link TaskBoard.model.TaskModel} for its\n * records.\n *\n * Loaded and handled as a part of a {@link TaskBoard.model.ProjectModel project}. For example using inline data:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         // Data to load into the TaskStore\n *         tasksData : [\n *             { id : 1, name : 'Some task', status : 'todo', prio : 'low' }\n *         ]\n *     }\n * }\n * ```\n *\n * When loaded using the {@link Scheduler.data.mixin.ProjectCrudManager CrudManager} functionality of the project, it\n * is populated from the `'tasks'` property in the\n * response:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         transport : {\n *             load : {\n *                 url : 'load.php'\n *             }\n *         },\n *\n *         autoLoad : true\n *     }\n * }\n * ```\n *\n * Expected response format to populate the TaskStore:\n *\n * ```json\n * {\n *     \"success\"     : true,\n *     \"tasks\"       : {\n *         \"rows\" : [\n *             {\n *                 \"id\"     : 1,\n *                 \"name\"   : \"Important task\",\n *                 \"status\" : \"todo\",\n *                 \"prio\"   : \"high\"\n *             },\n *             ...\n *         ]\n *     }\n * }\n * ```\n *\n * @extends Scheduler/data/EventStore\n */\nexport default class TaskStore extends EventStore {\n    static configurable = {\n        autoAssignWeight : true,\n        storeId : 'tasks',\n        /**\n         * Class used to represent records, defaults to {@link TaskBoard.model.TaskModel}\n         * @config {TaskBoard.model.TaskModel}\n         * @typings {typeof TaskModel}\n         * @category Common\n         */\n        modelClass : TaskModel,\n        /**\n         * Configure with `true` to also remove the event when removing the last assignment from the linked\n         * AssignmentStore.\n         *\n         * Defaults to `false` for TaskBoard since it is unexpected that a tasks disappears when unassigning the last\n         * resource from it.\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        removeUnassignedEvent : false,\n        /**\n         * Initial sorters, format is `[{ field: 'name', ascending: false }, ...]`.\n         *\n         * By default the TaskStore is sorted by `weight`, tasks with higher weights are displayed further down.\n         *\n         * @config {Sorter[]|String[]}\n         * @category Common\n         */\n        sorters : [\n            { field : 'weight', ascending : true }\n        ]\n    };\n    afterLoadData() {\n        const { records } = this;\n        if (this.autoAssignWeight && !records.some(r => r.weight != null)) {\n            for (let i = 0; i < records.length; i++) {\n                records[i].setData('weight', (i + 1) * 100);\n            }\n        }\n    }\n}\nTaskStore._$name = 'TaskStore';", "import SchedulerProjectModel from '../../Scheduler/model/ProjectModel.js';\nimport ProjectCrudManager from '../../Scheduler/data/mixin/ProjectCrudManager.js';\nimport TaskStore from '../store/TaskStore.js';\nimport TaskModel from './TaskModel.js';\n/**\n * @module TaskBoard/model/ProjectModel\n */\n/**\n * This class represents a global project of your TaskBoard - a central place for all data.\n *\n * It holds and links the stores usually used by TaskBoard:\n *\n * - {@link TaskBoard.store.TaskStore}\n * - {@link Scheduler.data.ResourceStore}\n * - {@link Scheduler.data.AssignmentStore}\n *\n * ## Loading remote data\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         // Project configuration\n *     }\n * });\n * ```\n *\n * ## Loading inline data\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         // Project configuration\n *     }\n * });\n * ```\n *\n * ## Getting modifications\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     project : {\n *         // Project configuration\n *     }\n * });\n * ```\n *\n * ## Built-in StateTrackingManager\n *\n * The project also has a built-in {@link Core.data.stm.StateTrackingManager StateTrackingManager} (STM for short), that\n * handles undo/redo for the project stores (additional stores can also be added). You can enable it to track all\n * project store changes:\n *\n * ```javascript\n * // Turn on auto recording when you create your TaskBoard:\n * const taskBoard = new TaskBoard({\n *     project : {\n *         stm : {\n *             autoRecord : true\n *         }\n *     }\n * });\n *\n * // Undo a transaction\n * project.stm.undo();\n *\n * // Redo\n * project.stm.redo();\n * ```\n *\n * @extends Scheduler/model/ProjectModel\n * @mixes Scheduler/data/mixin/ProjectCrudManager\n *\n * @typings Scheduler.model.ProjectModel -> Scheduler.model.SchedulerProjectModel\n */\nexport default class ProjectModel extends SchedulerProjectModel.mixin(ProjectCrudManager) {\n    static configurable = {\n        /**\n         * Get/set {@link #property-taskStore} data.\n         *\n         * Always returns an array of {@link TaskBoard.model.TaskModel} but also accepts an array of\n         * its configuration objects as input.\n         *\n         * @member {TaskBoard.model.TaskModel[]} tasks\n         * @accepts {TaskBoard.model.TaskModel[]|TaskModelConfig[]}\n         * @category Inline data\n         */\n        /**\n         * The initial data, to fill the {@link #property-taskStore} with. Should be an array of\n         * {@link TaskBoard.model.TaskModel} or its configuration objects.\n         *\n         * @config {TaskBoard.model.TaskModel[]|TaskModelConfig[]} tasks\n         * @category Inline data\n         */\n        /**\n         * The initial data, to fill the {@link #property-taskStore} with.\n         * Should be an array of {@link TaskBoard.model.TaskModel} instances or its configuration objects.\n         *\n         * @config {TaskBoard.model.TaskModel[]|TaskModelConfig[]} tasksData\n         * @category Legacy inline data\n         */\n        /**\n         * The {@link TaskBoard.store.TaskStore store} holding the tasks information.\n         *\n         * See also {@link TaskBoard.model.TaskModel}\n         *\n         * @member {TaskBoard.store.TaskStore} taskStore\n         * @category Models & Stores\n         */\n        /**\n         * An {@link TaskBoard.store.TaskStore} instance or a config object.\n         * @config {TaskStoreConfig|TaskBoard.store.TaskStore} taskStore\n         * @category Models & Stores\n         */\n        /**\n         * @hideconfigs timeRanges\n         *              timeRangeStore,\n         *              timeRangesData,\n         *              timeRangeStoreClass,\n         *              resourceTimeRanges,\n         *              resourceTimeRangeStore,\n         *              resourceTimeRangesData,\n         *              resourceTimeRangeStoreClass,\n         *              eventStoreClass,\n         *              eventModelClass\n         */\n        /**\n         * @hideproperties timeRangeStore,\n         *                 resourceTimeRangeStore\n         */\n        eventStoreClass : TaskStore,\n        eventModelClass : TaskModel,\n        /**\n         * The constructor to create a task store instance with.\n         * Should be a class, subclassing the {@link TaskBoard.store.TaskStore}.\n         * @config {TaskBoard.store.TaskStore}\n         * @typings {typeof TaskStore}\n         * @category Models & Stores\n         */\n        taskStoreClass : TaskStore,\n        /**\n         * The constructor of the task model class, to be used in the project.\n         * Will be set as the {@link Core.data.Store#config-modelClass modelClass}\n         * property of the {@link #property-taskStore}.\n         * @config {TaskBoard.model.TaskModel}\n         * @typings {typeof TaskModel}\n         * @category Models & Stores\n         */\n        taskModelClass : TaskModel\n    };\n    construct(config) {\n        if (config.tasks) {\n            config.eventsData = config.tasks;\n        }\n        if (config.tasksData) {\n            config.eventsData = config.tasksData;\n        }\n        if (config.taskStore) {\n            config.eventStore = config.taskStore;\n        }\n        if (config.taskModelClass) {\n            config.eventModelClass = config.taskModelClass;\n        }\n        if (config.taskStoreClass) {\n            config.eventStoreClass = config.taskStoreClass;\n        }\n        super.construct(config);\n        const me = this;\n        me.addPrioritizedStore(me.assignmentStore);\n        me.addPrioritizedStore(me.resourceStore);\n        me.addPrioritizedStore(me.taskStore);\n    }\n    get taskStore() {\n        return this.eventStore;\n    }\n    set taskStore(store) {\n        this.eventStore = store;\n    }\n    get tasksData() {\n        return this.eventsData;\n    }\n    set tasksData(data) {\n        this.eventsData = data;\n    }\n    get tasks() {\n        return this.eventsData;\n    }\n    set tasks(data) {\n        this.events = data;\n    }\n    /**\n     * Returns the data from the records of the projects stores, in a format that can be consumed by `loadInlineData()`.\n     *\n     * Used by JSON.stringify to correctly convert this project to json.\n     *\n     * ```javascript\n     * const project = new ProjectModel({\n     *     tasksData       : [...],\n     *     resourcesData   : [...],\n     *     assignmentsData : [...]\n     * });\n     *\n     * const json = project.toJSON();\n     *\n     * // Result:\n     * {\n     *     taskData : [...],\n     *     resourcesData : [...],\n     *     assignmentsData : [...]\n     * }\n     * ```\n     *\n     * Output can be consumed by `loadInlineData()`:\n     *\n     * ```javascript\n     * const json = project.toJSON();\n     *\n     * // Plug it back in later\n     * project.loadInlineData(json);\n     * ```\n     *\n     * @returns {Object}\n     * @category JSON\n     */\n    toJSON() {\n        const\n            { taskStore, assignmentStore, resourceStore } = this,\n            result = {\n                tasksData : taskStore.toJSON()\n            };\n        if (assignmentStore?.count) {\n            result.assignmentsData = assignmentStore.toJSON();\n        }\n        if (resourceStore?.count) {\n            result.resourcesData = resourceStore.toJSON();\n        }\n        return result;\n    }\n}\nProjectModel._$name = 'ProjectModel';", "import Model from '../../Core/data/Model.js';\n/**\n * @module TaskBoard/model/SwimlaneModel\n */\n/**\n * Represents a single swimlane on a TaskBoard.\n *\n * When creating a TaskBoard, you can optionally supply an initial set of swimlanes. These are either defined as plain\n * strings, SwimlaneModel data objects or SwimlaneModel records (or a mix thereof). When using strings, the string will\n * be used as is as the swimlane's id and capitalized as its text.\n *\n * ```javascript\n * const highPrio = new SwimlaneModel({\n *     id   : 'high',\n *     text : 'High prio'\n * });\n *\n * const taskBoard = new TaskBoard({\n *     swimlanes : [\n *         // String, equal to passing { id : 'low', text : 'Low' }\n *         'low',\n *         // Data object, in this case with a fixed height and not collapsible from the UI\n *         { id : 'medium', text : 'Medium', height : 200, collapsible : false }\n *         // Record, not commonly used since it is easier to supply the data object directly\n *         highPrio\n *     ]\n * });\n * ```\n *\n * @extends Core/data/Model\n * @uninherit Core/data/mixin/TreeNode\n */\nexport default class SwimlaneModel extends Model {\n    static $name = 'SwimlaneModel';\n    static fields = [\n        /**\n         * The swimlane's unique id, used to match a task to a swimlane (which field on a task to match is specified\n         * using then {@link TaskBoard.view.TaskBoardBase#config-swimlaneField} config on TaskBoard).\n         * @field {String|Number} id\n         */\n        /**\n         * Text displayed in the swimlane header.\n         * @field {String} text\n         */\n        { name : 'text', type : 'string' },\n        /**\n         * Color, named colors are applied as a `b-taskboard-color-{color}` (for example `b-taskboard-color-red`) CSS\n         * class to the swimlane. Colors specified as hex, `rgb()` etc. are applied as `style.color` to the swilane.\n         *\n         * By default it does not visually affect the UI, but it applies a color to the swimlane that applications can\n         * leverage using `currentColor` to style it in the desired way.\n         *\n         * Using named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     swimlanes : [\n         *         { id : 'high', text : 'High', color : 'red' }\n         *     ]\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-swimlane b-taskboard-color-red\">\n         * ```\n         *\n         * Which can the be used for example like:\n         *\n         * ```css\n         * .b-taskboard-swimlane-header {\n         *     border-left : 5px solid currentColor; // where currentColor is the color defined by b-red\n         * }\n         * ```\n         *\n         * Using non-named colors:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     swimlanes : [\n         *         { id : 'high', text : 'High', color : 'hsl(229deg 66% 42%)' }\n         *     ]\n         * });\n         * ```\n         *\n         * Will result in:\n         *\n         * ```html\n         * <div class=\"b-taskboard-swimlane\" style=\"color: hsl(229deg 66% 42%)\">\n         * ```\n         *\n         * Predefined named colors (actual color might vary by theme):\n         * <div class=\"b-colorbox b-inline b-taskboard-color-red\"></div>red,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-pink\"></div>pink,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-purple\"></div>purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-purple\"></div>deep-purple,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-indigo\"></div>indigo,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-blue\"></div>blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-blue\"></div>light-blue,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-cyan\"></div>cyan,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-teal\"></div>teal,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-green\"></div>green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-light-green\"></div>light-green,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-lime\"></div>lime,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-yellow\"></div>yellow,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-amber\"></div>amber,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-orange\"></div>orange,\n         * <div class=\"b-colorbox b-inline b-taskboard-color-deep-orange\"></div>deep-orange\n         *\n         * @field {String} color\n         */\n        { name : 'color', type : 'string' },\n        /**\n         * Allow collapsing this swimlane\n         * @field {Boolean} collapsible=true\n         */\n        { name : 'collapsible', type : 'boolean', defaultValue : true },\n        /**\n         * Collapsed (true) or expanded (False).\n         *\n         * To expand or collapse, use TaskBoards {@link TaskBoard.view.mixin.ExpandCollapse#function-expand} and\n         * {@link TaskBoard.view.mixin.ExpandCollapse#function-collapse} functions.\n         *\n         * @field {Boolean} collapsed\n         * @readonly\n         */\n        { name : 'collapsed', type : 'boolean' },\n        /**\n        * Set to `true` to hide the swimlane, `false` to show it again.\n        * @field {Boolean} hidden\n        */\n        { name : 'hidden', type : 'boolean' },\n        /**\n         * Swimlane height in px.\n         * @field {Number} height\n         */\n        { name : 'height', type : 'number' },\n        /**\n         * Swimlane flex, affects height.\n         * @field {Number} flex\n         */\n        { name : 'flex', type : 'number' },\n        /**\n         * Number of tasks per row to display in this swimlane. Leave blank to use the setting from the\n         * {@link TaskBoard.view.TaskBoardBase#config-tasksPerRow} config on TaskBoard.\n         * @field {Number} tasksPerRow\n         */\n        'tasksPerRow'\n    ];\n    get taskBoard() {\n        return this.firstStore.taskBoard;\n    }\n    /**\n     * Collapse this swimlane.\n     *\n     * Uses a transition by default, await the call to be certain that it has finished.\n     *\n     * @category Expand/collapse\n     * @returns {Promise} A promise which is resolved when the column is collapsed\n     */\n    async collapse() {\n        this.taskBoard.collapse(this);\n    }\n    /**\n     * Expand this swimlane.\n     *\n     * Uses a transition by default, await the call to be certain that it has finished.\n     *\n     * @category Expand/collapse\n     * @returns {Promise} A promise which is resolved when the column is expanded\n     */\n    async expand() {\n        return this.taskBoard.expand(this);\n    }\n    /**\n     * Get tasks in this swimlane.\n     * @property {TaskBoard.model.TaskModel[]}\n     * @readonly\n     */\n    get tasks() {\n        return [...(this.taskBoard.getSwimlaneTasks(this) || [])];\n    }\n}\nSwimlaneModel._$name = 'SwimlaneModel';", "import Base from '../../../Core/Base.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n/**\n * @module TaskBoard/view/mixin/ExpandCollapse\n */\n/**\n * Mixin that handles expanding and collapsing swimlanes and columns on the TaskBoard.\n *\n * {@inlineexample TaskBoard/view/mixin/ExpandCollapse.js}\n *\n * Users can expand and collapse using the UI. To do it programmatically, see:\n *\n * * {@link #function-collapse collapse()}\n * * {@link #function-expand expand()}\n * * {@link #function-toggleCollapse toggleCollapse()}\n *\n * Each of them accepts a column or a swimlane to expand/collapse. For example\n *\n * ```javascript\n * taskBoard.collapse(taskBoard.columns.todo);\n * taskBoard.expand(taskBoard.swimlanes.high);\n * ```\n *\n * For convenience, the functions are also callable directly on columns/swimlanes:\n *\n * ```javascript\n * taskBoard.columns.todo.expand();\n * taskBoard.swimlanes.high.collapse();\n * ```\n *\n * Expanding/collapsing is by default transitioned, `await` the calls to be certain that the UI is up to date:\n *\n * ```javascript\n * await taskBoard.collapse(taskBoard.columns.todo);\n * await taskBoard.columns.todo.expand();\n * ```\n *\n * @mixin\n */\nexport default Target => class ExpandCollapse extends (Target || Base) {\n    //region Config\n    static $name = 'ExpandCollapse';\n    static configurable = {\n        /**\n         * Show an icon to expand/collapse columns and swimlanes in their headers.\n         *\n         * Programmatic expand/collapse works independently of this setting, it only affects the UI.\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        showCollapseInHeader : true,\n        /**\n         * Specify `true` to hide the column title instead of rotating it on collapse.\n         *\n         * Used by default with swimlanes, since the title will overlap the swimlane header otherwise.\n         *\n         * @config {Boolean}\n         * @default\n         * @category Misc\n         */\n        collapseTitle : false,\n        /**\n         * By default, a tooltip showing `Expand XX`/`Collapse XX` is shown when hovering the expand/collapse icon for\n         * a column or swimlane. To disable the tooltip, set this to `false`.\n         * @prp {Boolean}\n         * @default\n         * @category Misc\n         */\n        showCollapseTooltip : true\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions\n    changeShowCollapseInHeader(showCollapseInHeader) {\n        ObjectHelper.assertBoolean(showCollapseInHeader, 'showCollapseInHeader');\n        return showCollapseInHeader;\n    }\n    //endregion\n    //region Events\n    /**\n     * Triggered when a column is expanded.\n     *\n     * @event columnExpand\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record\n     */\n    /**\n     * Triggered when a column is collapsed.\n     *\n     * @event columnCollapse\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record\n     */\n    /**\n     * Triggered when the column collapsed state is toggled.\n     *\n     * @event columnToggle\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record\n     * @param {Boolean} collapse `true` if the column is being collapsed.\n     */\n    /**\n     * Triggered when a swimlane is expanded.\n     *\n     * @event swimlaneExpand\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record\n     */\n    /**\n     * Triggered when a swimlane is collapsed.\n     *\n     * @event swimlaneCollapse\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record\n     */\n    /**\n     * Triggered when the swimlane collapsed state is toggled.\n     *\n     * @event swimlaneToggle\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record\n     * @param {Boolean} collapse `true` if the column is being collapsed.\n     */\n    //endregion\n    //region Toggling\n    /**\n     * Collapse a swimlane or column.\n     *\n     * Await the call to be certain that the collapse transition has ended.\n     *\n     * ```javascript\n     * await taskBoard.collapse(taskBoard.columns.first);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|TaskBoard.model.ColumnModel} record Swimlane or column\n     * @category Expand & collapse\n     */\n    async collapse(record) {\n        return this.toggleCollapse(record, true);\n    }\n    /**\n     * Expand a swimlane or column.\n     *\n     * Await the call to be certain that the expand transition has ended.\n     *\n     * ```javascript\n     * await taskBoard.expand(taskBoard.columns.first);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|TaskBoard.model.ColumnModel} record Swimlane or column\n     * @category Expand & collapse\n     */\n    async expand(record) {\n        return this.toggleCollapse(record, false);\n    }\n    /**\n     * Expand or collapse a swimlane or column.\n     *\n     * Await the call to be certain that the expand/collapse transition has ended.\n     *\n     * ```javascript\n     * // Toggle\n     * await taskBoard.toggleCollapse(taskBoard.columns.first);\n     * // Force collapse\n     * await taskBoard.toggleCollapse(taskBoard.columns.first, true);\n     * // Force expand\n     * await taskBoard.toggleCollapse(taskBoard.columns.first, false);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|TaskBoard.model.ColumnModel} record Swimlane or column\n     * @param {Boolean} [collapse] Specify to force a certain state, leave out to toggle\n     * @category Expand & collapse\n     * @fires columnCollapse\n     * @fires columnExpand\n     * @fires columnToggle\n     * @fires swimlaneCollapse\n     * @fires swimlaneExpand\n     * @fires swimlaneToggle\n     */\n    async toggleCollapse(record, collapse = !record.collapsed) {\n        if (record.isSwimlaneModel) {\n            await this.toggleSwimlaneCollapse(record, collapse);\n        }\n        else {\n            await this.toggleColumnCollapse(record, collapse);\n        }\n    }\n    async toggleSwimlaneCollapse(swimlaneRecord, collapse = !swimlaneRecord.collapsed) {\n        return new Promise(resolve => {\n            const\n                me              = this,\n                swimlaneElement = me.getSwimlaneElement(swimlaneRecord),\n                swimlaneBody    = DomSync.getChild(swimlaneElement, 'body');\n            // Set a height on collapse, to transition down from -> 0\n            if (collapse) {\n                swimlaneBody.style.height = `${swimlaneBody.getBoundingClientRect().height}px`;\n            }\n            EventHelper.onTransitionEnd({\n                element  : swimlaneBody,\n                property : 'height',\n                handler() {\n                    if (collapse) {\n                        // Removing static height on swimlane element on collapse\n                        swimlaneElement.style.height = '';\n                    }\n                    else {\n                        // Remove that height on expand, after it has transitioned from 0 to it\n                        swimlaneBody.style.height = '';\n                        // Setting static height on swimlane element on expand\n                        swimlaneElement.style.height = `${swimlaneRecord.height}px`;\n                    }\n                    swimlaneElement.classList.remove(collapse ? 'b-collapsing' : 'b-expanding');\n                    // Make sure UI is up to date when promise is resolved\n                    me.recompose.flush();\n                    resolve();\n                },\n                thisObj : me\n            });\n            swimlaneElement.classList.add(collapse ? 'b-collapsing' : 'b-expanding');\n            me.suspendDomTransition();\n            // This will trigger the recompose\n            swimlaneRecord.collapsed = collapse;\n            me.trigger(`swimlane${collapse ? 'Collapse' : 'Expand'}`, { swimlaneRecord });\n            me.trigger('swimlaneToggle', { swimlaneRecord, collapse });\n            me.resumeDomTransition();\n        });\n    }\n    async toggleColumnCollapse(columnRecord, collapse = !columnRecord.collapsed) {\n        return new Promise(resolve => {\n            const\n                me               = this,\n                { documentRoot } = me,\n                columnElements   = me.getColumnElements(columnRecord),\n                headerElement    = DomSync.getChild(me.bodyElement, `header.${columnRecord.domId}`),\n                // For columns that already has a width specified we won't need to measure and apply current width\n                hasFixedWidth    = columnRecord.width && !columnRecord.flex,\n                cardElements     = documentRoot.querySelectorAll(`.b-taskboard-card[data-column=\"${columnRecord.domId}\"]`),\n                cardWidth        = `${cardElements[0]?.getBoundingClientRect().width}px`,\n                columnWidth      = `${columnElements[0]?.getBoundingClientRect().width}px`;\n            // Fix card widths on collapse, to not have their contents reflow during the collapse\n            cardElements.forEach(card => {\n                if (collapse) {\n                    card.style.width = cardWidth;\n                }\n            });\n            columnElements.unshift(headerElement);\n            columnElements.forEach(element => {\n                // Set a width on collapse, to transition down from -> 0\n                if (collapse) {\n                    if (!hasFixedWidth) {\n                        element.style.width = columnWidth;\n                    }\n                    element.classList.add('b-collapsing');\n                }\n                // Add cls to keep flex away a bit longer on expand\n                else {\n                    element.classList.add('b-expanding');\n                }\n            });\n            EventHelper.onTransitionEnd({\n                element  : headerElement,\n                property : 'width',\n                handler() {\n                    // Unfix card widths when fully expanded again\n                    cardElements.forEach(card => {\n                        if (!collapse) {\n                            card.style.width = '';\n                        }\n                    });\n                    // Remove that width on expand, after it has transitioned from 0 to it\n                    columnElements.forEach(element => {\n                        if (!collapse) {\n                            // Restore width and flex from css\n                            if (!hasFixedWidth) {\n                                element.style.width = '';\n                            }\n                            element.classList.remove('b-expanding');\n                        }\n                        else {\n                            element.classList.remove('b-collapsing');\n                        }\n                    });\n                    // Make sure UI is up to date when promise is resolved\n                    me.recompose.flush();\n                    // Scroller is not aware of that expanding/collapsing might change overflow state, inform it...\n                    me.scrollable.syncOverflowState();\n                    resolve();\n                },\n                thisObj : me\n            });\n            // Force browser to reevaluate, for transition to trigger\n            headerElement.offsetWidth;\n            me.suspendDomTransition();\n            // This will trigger the recompose\n            columnRecord.collapsed = collapse;\n            me.trigger(`column${collapse ? 'Collapse' : 'Expand'}`, { columnRecord });\n            me.trigger('columnToggle', { columnRecord, collapse });\n            me.resumeDomTransition();\n        });\n    }\n    //endregion\n    //region Rendering\n    // Inject expander icon + expand/collapsed state cls in column headers\n    populateColumnHeader(args) {\n        super.populateColumnHeader?.(args);\n        const\n            { showCollapseInHeader, collapseTitle, hasSwimlanes, showCollapseTooltip } = this,\n            { columnRecord, columnHeaderConfig }                                       = args,\n            { text, collapsed, collapsible }                                           = columnRecord;\n        DomHelper.merge(columnHeaderConfig, {\n            class : {\n                'b-collapsed'    : collapsed,\n                'b-rotate-title' : collapsed && !collapseTitle && !hasSwimlanes\n            },\n            style : {\n                minWidth : collapsed ? null : columnRecord.minWidth\n            },\n            children : {\n                padder : {\n                    children : {\n                        expander : showCollapseInHeader && collapsible && {\n                            tag   : 'button',\n                            class : {\n                                'b-taskboard-column-expander' : 1,\n                                'b-fw-icon'                   : 1,\n                                'b-icon-expand-column'        : 1\n                            },\n                            dataset : {\n                                btip : showCollapseTooltip\n                                    ? StringHelper.xss`${this.L(collapsed ? 'L{TaskBoard.expand}' : 'L{TaskBoard.collapse}', text)}`\n                                    : null\n                            }\n                        }\n                    }\n                }\n            }\n        });\n    }\n    // Inject expand/collapsed state cls in columns\n    populateColumn(args) {\n        super.populateColumn?.(args);\n        const\n            { columnRecord, columnConfig } = args,\n            { collapsed }                  = columnRecord;\n        columnConfig.class['b-collapsed'] = collapsed;\n        if (collapsed) {\n            columnConfig.style.minWidth = null;\n        }\n    }\n    // Inject expander icon + expand/collapsed state cls in swimlanes\n    populateSwimlane(args) {\n        super.populateColumn?.(args);\n        const { swimlaneRecord, swimlaneConfig } = args;\n        if (swimlaneRecord) {\n            const\n                { showCollapseInHeader, showCollapseTooltip } = this,\n                { text, collapsed, collapsible }              = swimlaneRecord;\n            DomHelper.merge(swimlaneConfig, {\n                class : {\n                    'b-collapsed'   : collapsed,\n                    'b-collapsible' : collapsible\n                },\n                children : {\n                    header : {\n                        children : {\n                            title : {\n                                children : {\n                                    // Before text\n                                    'expander > text' : showCollapseInHeader && collapsible && {\n                                        tag   : 'button',\n                                        class : {\n                                            'b-taskboard-swimlane-expander' : 1,\n                                            'b-icon'                        : 1,\n                                            'b-icon-expand-row'             : 1\n                                        },\n                                        dataset : {\n                                            btip : showCollapseTooltip\n                                                ? StringHelper.xss`${this.L(collapsed ? 'L{TaskBoard.expand}' : 'L{TaskBoard.collapse}', text)}`\n                                                : null\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    body : {\n                        [collapsed ? 'inert' : null] : true\n                    }\n                }\n            });\n        }\n    }\n    //endregion\n    //region Listeners\n    onColumnHeaderClick({ event, columnRecord }) {\n        if (event.target.matches('.b-taskboard-column-expander') || columnRecord.collapsed) {\n            this.toggleCollapse(columnRecord);\n        }\n    }\n    onColumnClick({ columnRecord }) {\n        if (columnRecord.collapsed) {\n            this.toggleCollapse(columnRecord);\n        }\n    }\n    onSwimlaneHeaderClick({ swimlaneRecord }) {\n        this.toggleCollapse(swimlaneRecord);\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module TaskBoard/view/mixin/ResponsiveCards\n */\n/**\n * An object that describes a card size level.\n *\n * @typedef {Object} CardSize\n * @property {String} name Level name, applied to the columns element as CSS class `b-[name]-cards`\n * @property {Number} maxWidth Express in px. This level applies above the previous levels maxWidth and up to this value\n * @property {Number} maxAvatars Max number of resource avatars to render, when that feature is used\n * @property {Object<String,TaskItemOptions>} headerItems A config object for items in a card's header, merges with\n * {@link TaskBoard.view.TaskBoard#config-headerItems} to determine items for this card size\n * @property {Object<String,TaskItemOptions>} bodyItems A config object for items in a card's header, merges with\n * {@link TaskBoard.view.TaskBoard#config-bodyItems} to determine items for this card size\n * @property {Object<String,TaskItemOptions>} footerItems A config object for items in a card's header, merges with\n * {@link TaskBoard.view.TaskBoard#config-footerItems} to determine items for this card size\n */\n/**\n * Mixin that allows responsive card behaviours.\n *\n * {@inlineexample TaskBoard/view/mixin/ResponsiveCards.js}\n *\n * It monitors column sizes using a ResizeObserver. When a columns width changes, it calculates the width of the cards\n * in that column based on the columns width and the configured number of tasks per row (see\n * {@link TaskBoard.view.TaskBoard#config-tasksPerRow}).\n *\n * The card width is then used to pick a {@link #config-cardSizes}, which applies CSS and might also affect task items.\n *\n * By default the following levels are defined:\n *\n * | Width | Name   | Cls            | Avatars | Items                       |\n * |-------|--------|----------------|---------|-----------------------------|\n * | < 50  | micro  | b-micro-cards  | 1       | Only resource avatars shown |\n * | < 75  | tiny   | b-tiny-cards   | 1       |                             |\n * | < 175 | small  | b-small-cards  | 1       |                             |\n * | < 300 | medium | b-medium-cards | 3       |                             |\n * | > 300 | large  | b-large-cards  | 7       |                             |\n *\n * If for example cards in a column are above 50px and below 75px wide, that column will have the `b-tiny-cards` CSS\n * class applied to its element. Use it to style the cards in a suitable way for your application, perhaps by applying\n * a smaller font size, hiding images etc.\n *\n * @mixin\n */\nexport default Target => class ResponsiveCards extends (Target || Base) {\n    //region Config\n    static $name = 'ResponsiveCards';\n    static configurable = {\n        /**\n         * An array of {@link CardSize} objects to use as responsive levels based on card widths.\n         *\n         * By default, the following levels are defined:\n         *\n         * | Width | Name   | Cls            | Avatars | Items                       |\n         * |-------|--------|----------------|---------|-----------------------------|\n         * | < 50  | micro  | b-micro-cards  | 1       | Only resource avatars shown |\n         * | < 75  | tiny   | b-tiny-cards   | 1       | Body text hidden            |\n         * | < 175 | small  | b-small-cards  | 2       | Body text hidden            |\n         * | < 300 | medium | b-medium-cards | 3       |                             |\n         * | > 300 | large  | b-large-cards  | 7       |                             |\n         *\n         * @config {CardSize}\n         * @category Common\n         */\n        cardSizes : [\n            {\n                maxWidth    : 50,\n                name        : 'micro',\n                maxAvatars  : 1,\n                headerItems : {\n                    text : null\n                },\n                bodyItems : {\n                    text : null\n                }\n            },\n            {\n                maxWidth   : 75,\n                name       : 'tiny',\n                maxAvatars : 1,\n                bodyItems  : {\n                    text : null\n                }\n            },\n            {\n                maxWidth   : 175,\n                name       : 'small',\n                maxAvatars : 2,\n                bodyItems  : {\n                    text : null\n                }\n            },\n            { maxWidth : 250, name : 'medium', maxAvatars : 3 },\n            { name : 'large', maxAvatars : 7 }\n        ],\n        resizeObserver : {\n            value   : true,\n            $config : ['nullify']\n        }\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions\n    changeCardSizes(cardSizes) {\n        ObjectHelper.assertArray(cardSizes, 'cardSizes');\n        return cardSizes;\n    }\n    //endregion\n    //region Suspend/resume responsiveness\n    responsivenessSuspended = 0;\n    suspendResponsiveness() {\n        this.responsivenessSuspended++;\n    }\n    resumeResponsiveness() {\n        this.responsivenessSuspended--;\n    }\n    //endregion\n    //region Calculate card size\n    // Get a card size entity, very similar to a responsive level in Grid\n    getCardSize(columnRecord, swimlaneRecord) {\n        const\n            me            = this,\n            { cardSizes } = me,\n            perRow        = me.getTasksPerRow(columnRecord, swimlaneRecord),\n            columnWidth   = me.getColumnWidth(columnRecord),\n            // Three cards on a row shares the column width with 2 gaps.\n            // Column padding is not measured and thus not part of calc\n            // |               |\n            // | \u2588 gap \u2588 gap \u2588 |\n            // |               |\n            cardWidth     = (columnWidth - me.cardGap * (perRow - 1)) / perRow;\n        return cardSizes?.find(size => cardWidth < size.maxWidth) || cardSizes?.[cardSizes.length - 1];\n    }\n    // Get the last reported width for a column, set by the ResizeObserver\n    getColumnWidth(columnRecord) {\n        return columnRecord.instanceMeta(this).width;\n    }\n    // Number of tasks per row to render for the requested column / swimlane intersection.\n    // Prio order is columns config, swimlanes config and lastly taskboards config\n    getTasksPerRow(columnRecord, swimlaneRecord) {\n        return columnRecord.tasksPerRow || swimlaneRecord?.tasksPerRow || this.tasksPerRow;\n    }\n    //endregion\n    //region ResizeObserver\n    // ResizeObserver callback for column size changes\n    onChildResize(entries) {\n        const me = this;\n        if (me.recompose.suspended || me.responsivenessSuspended) {\n            return;\n        }\n        // If any columns width changed enough for it to change card size level (medium -> large etc) we need to\n        // recompose to allow UI to react\n        let shouldRecompose = false;\n        for (const entry of entries) {\n            const { target, contentRect } = entry;\n            // Only care about width\n            if (target.observedWidth !== contentRect.width) {\n                const\n                    columnRecord   = me.resolveColumnRecord(target),\n                    // We are observing the headers, but need to calculate card size per column / swimlane intersection\n                    columnElements = columnRecord && me.columns.includes(columnRecord) && me.getColumnElements(columnRecord);\n                // Bail out when collapsing or hiding the column or if we did not get any record, which can happen\n                // during recompose when switching column set\n                if (!columnRecord || columnRecord.collapsed || columnRecord.hidden || !columnElements) {\n                    return;\n                }\n                // Cache width on element and column record (for easy lookup later)\n                columnRecord.instanceMeta(me).width = target.observedWidth = contentRect.width;\n                for (const columnElement of columnElements) {\n                    const\n                        swimlaneRecord = me.resolveSwimlaneRecord(columnElement),\n                        cardSize       = me.getCardSize(columnRecord, swimlaneRecord);\n                    // Was the size change enough to take us to a new card size level?\n                    if (cardSize && columnElement.elementData.cardSize !== cardSize.name) {\n                        shouldRecompose = true;\n                    }\n                }\n            }\n        }\n        if (shouldRecompose) {\n            me.recompose.now();\n            me.scrollable.syncOverflowState();\n        }\n    }\n    // ResizeObserver used to monitor column size, observing set up in domSyncCallback\n    changeResizeObserver(observer, oldObserver) {\n        oldObserver?.disconnect();\n        // Resize observer could be set to null for FireFox testing\n        return this.isDestroying || !ResizeObserver ? null : new ResizeObserver(this.onChildResize.bind(this));\n    }\n    //endregion\n    //region Rendering\n    populateColumn(args) {\n        super.populateColumn?.(args);\n        const\n            { columnRecord, swimlaneRecord, columnConfig } = args,\n            // Tag cardSize along with args, to be reachable from renderer\n            cardSize = args.cardSize                       = this.getCardSize(columnRecord, swimlaneRecord);\n        if (cardSize) {\n            columnConfig.class[`b-${cardSize.name}-cards`] = cardSize;\n            columnConfig.elementData.cardSize = cardSize.name;\n        }\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport Store from '../../../Core/data/Store.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport ColumnModel from '../../model/ColumnModel.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardColumns\n */\nconst transitionChangeActions = {\n    remove : 1,\n    move   : 1,\n    update : 1,\n    filter : 1\n};\n/**\n * Mixin that handles columns for the TaskBoard.\n *\n * @mixin\n */\nexport default Target => class TaskBoardColumns extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardColumns';\n    static configurable = {\n        /**\n         * Store containing the TaskBoard columns.\n         *\n         * @member {Core.data.Store} columns\n         * @category Common\n         */\n        /**\n         * Store containing the TaskBoard columns. A tasks {@link #config-columnField} is matched against the `id` of a\n         * column to determine in which column it is displayed.\n         *\n         * Accepts an array of column records/objects/strings, a store instance, a store id or a store config object\n         * used to create a new store.\n         *\n         * When supplying an array, a store configured with {Core.data.mixin.StoreProxy#config-objectify} is\n         * automatically created. Using that config allows for a nicer interaction syntax with the columns:\n         *\n         * ```javascript\n         * // Without objectify:\n         * taskBoard.columns.getById('done').text = 'Finished';\n         *\n         * // With objectify:\n         * taskBoard.columns.done.text = 'Finished';\n         * ```\n         *\n         * When supplying strings, the raw string will be used as the columns `id` and a capitalized version of it is\n         * used as the columns text:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *    columns : [\n         *        'doing',\n         *        'done'\n         *    ]\n         * });\n         * ```\n         *\n         * Is equivalent to:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *    columns : [\n         *        { id : 'doing', text : 'Doing' },\n         *        { id : 'done', text : 'Done' }\n         *    ]\n         * });\n         * ```\n         *\n         * @config {TaskBoard.model.ColumnModel[]|ColumnModelConfig[]|String[]|Core.data.Store|String|StoreConfig}\n         * @category Common\n         */\n        columns : {},\n        /**\n         * Set to `true` to auto generate columns when {@link #config-columns} is undefined.\n         *\n         * A column will be created for each distinct value of {@link #config-columnField} on the tasks. The columns\n         * will be sorted in alphabetical order. The following snippet will yield two columns, Q1 and Q2:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    columnField : 'quarter',\n         *\n         *    autoGenerateColumns : true,\n         *\n         *    project : {\n         *        tasksData : [\n         *            { id : 1, name : 'Inform tenants', quarter : 'Q1' },\n         *            { id : 2, name : 'Renovate roofs', quarter : 'Q2' }\n         *        ]\n         *    }\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @category Advanced\n         */\n        autoGenerateColumns : false,\n        /**\n         * Field on a task record used to determine which column the task belongs to.\n         *\n         * ```javascript\n         * taskBoard.columnField = 'category';\n         * ```\n         *\n         * @member {String} columnField\n         * @category Common\n         */\n        /**\n         * Field on a task record used to determine which column the task belongs to.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    columnField : 'status',\n         *\n         *    columns : [\n         *        'todo',\n         *        'done'\n         *    ],\n         *\n         *    project : {\n         *        tasksData : [\n         *            // Linked using the status field, to the done column\n         *            { id : 1, name : 'Fun task', status : 'done' }\n         *        ]\n         *    }\n         * });\n         * ```\n         *\n         * @config {String}\n         * @category Common\n         */\n        columnField : null\n    };\n    static properties = {\n        shouldAutoGenerateColumns : false\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions\n    changeAutoGenerateColumns(autoGenerateColumns) {\n        ObjectHelper.assertBoolean(autoGenerateColumns, 'autoGenerateColumns');\n        return autoGenerateColumns;\n    }\n    changeColumnField(columnField) {\n        ObjectHelper.assertString(columnField, 'columnField');\n        return columnField;\n    }\n    //endregion\n    //region Config - columnField\n    updateColumnField(field, old) {\n        if (old) {\n            const { storage } = this.project.taskStore;\n            if (old !== this.swimlaneField) {\n                storage.removeIndex(old);\n            }\n            storage.addIndex({ property : field, unique : false });\n        }\n        this.shouldAutoGenerateColumns = field && this.autoGenerateColumns;\n    }\n    //endregion\n    //region Config - columns\n    changeColumns(columns) {\n        return Store.from(columns, { objectify : true, modelClass : ColumnModel }, column => {\n            if (typeof column === 'string') {\n                return { id : column, text : StringHelper.capitalize(column) };\n            }\n            return column;\n        });\n    }\n    updateColumns(columns) {\n        this.detachListeners('columns');\n        if (columns) {\n            // Link to us to be able to retrieve tasks in visual order\n            // $store is the store instance of an objectified store\n            (columns.$store || columns).taskBoard = this;\n            columns.ion({\n                change  : 'onColumnsChange',\n                refresh : 'onColumnsChange',\n                thisObj : this\n            });\n        }\n    }\n    get columns() {\n        const\n            me            = this,\n            { taskStore } = me.project;\n        // If there are no columns defined but we have a column field configured and we have tasks loaded, generate\n        // columns from the tasks\n        if (me.shouldAutoGenerateColumns && taskStore.count) {\n            me.columns = taskStore.getDistinctValues(me.columnField).sort();\n            me.shouldAutoGenerateColumns = false;\n        }\n        return me._columns;\n    }\n    onColumnsChange({ action }) {\n        // CRUD invalidates column/swimlane intersection index\n        if (action === 'add' || action === 'remove' || action === 'removeAll' || action === 'update') {\n            this.project.taskStore.storage.invalidateIndices();\n        }\n        if (transitionChangeActions[action]) {\n            const options = {};\n            if (action === 'update' || action === 'remove') {\n                options.addTransition = { width : 1, opacity : 1 };\n                options.removeTransition = { width : 1, opacity : 1 };\n            }\n            this.recomposeWithDomTransition(options);\n        }\n        else {\n            this.recompose();\n        }\n    }\n    //endregion\n    //region Data\n    getColumnTasks(columnRecord, inVisualOrder = false) {\n        const\n            me            = this,\n            { taskStore } = me.project,\n            set           = taskStore.storage.findItem(me.columnField, columnRecord.id),\n            tasks         = set ? [...set] : [];\n        if (inVisualOrder && set) {\n            if (me.swimlanes) {\n                const\n                    { swimlaneField } = me,\n                    swimlanes         = me.swimlanes.map(r => r.id);\n                tasks.sort((a, b) => {\n                    // First sort by swimlane\n                    const swimlaneDelta = swimlanes.indexOf(a[swimlaneField]) - swimlanes.indexOf(b[swimlaneField]);\n                    if (swimlaneDelta !== 0) {\n                        return swimlaneDelta;\n                    }\n                    // And within a swimlane sort by weight order\n                    if (a.weight != null || b.weight != null) {\n                        return a.weight - b.weight;\n                    }\n                    // Fall back to store order\n                    return taskStore.indexOf(a) - taskStore.indexOf(b);\n                });\n                // Only include tasks for available swimlanes, if used\n                if (swimlanes.length && swimlaneField) {\n                    return tasks.filter(task => swimlanes.includes(task[swimlaneField]));\n                }\n            }\n            else {\n                // Sort by weight within column\n                tasks.sort((a, b) => a.weight - b.weight);\n            }\n        }\n        return tasks;\n    }\n    getColumn(taskRecord) {\n        return this.columns.getById(taskRecord.getValue(this.columnField));\n    }\n    // Next task in the same column as supplied task\n    getNextTask(taskRecord, wrap = true) {\n        const\n            columnRecord = this.getColumn(taskRecord),\n            columnTasks  = columnRecord.tasks;\n        let nextTaskIndex = columnTasks.indexOf(taskRecord) + 1;\n        if (nextTaskIndex === columnTasks.length) {\n            if (wrap) {\n                nextTaskIndex = 0;\n            }\n            else {\n                return null;\n            }\n        }\n        return columnTasks[nextTaskIndex];\n    }\n    // Prev task in the same column as supplied task\n    getPreviousTask(taskRecord, wrap = true) {\n        const\n            columnRecord = this.getColumn(taskRecord),\n            columnTasks  = columnRecord.tasks;\n        let prevTaskIndex = columnTasks.indexOf(taskRecord) - 1;\n        if (prevTaskIndex < 0) {\n            if (wrap) {\n                prevTaskIndex = columnTasks.length - 1;\n            }\n            else {\n                return null;\n            }\n        }\n        return columnTasks[prevTaskIndex];\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport DomSync from '../../../Core/helper/DomSync.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardDom\n */\n/**\n * Mixin that handles resolving elements from records and vice versa.\n *\n * ```javascript\n * // Resolve task record from an element\n * const task = taskBoard.resolveTaskRecord(someElement);\n *\n * // Get tasks element\n * const element = taskBoard.getTaskElement(taskBoard.taskStore.first);\n * ```\n *\n * @mixin\n */\nexport default Target => class TaskBoardDom extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardDom';\n    get widgetClass() {}\n    //endregion\n    //region Resolve record from element\n    /**\n     * Retrieves a task record corresponding to the supplied element. Has to be a `.b-taskboard-card` element or\n     * descendant thereof.\n     *\n     * ```javascript\n     * const taskRecord = taskBoard.resolveTaskRecord(taskElement);\n     * ```\n     *\n     * @param {HTMLElement} element\n     * @returns {TaskBoard.model.TaskModel}\n     * @category DOM\n     */\n    resolveTaskRecord(element) {\n        element = element.closest('.b-taskboard-card');\n        // If element is a drop indicator, it wont have elementData\n        return element && this.project.taskStore.getById(element.elementData?.taskId);\n    }\n    /**\n     * Retrieves a column record resolved from the supplied element. Has to be a `.b-taskboard-column` element or\n     * descendant thereof (such as a card).\n     *\n     * ```javascript\n     * const columnRecord = taskBoard.resolveColumnRecord(taskElement);\n     * ```\n     *\n     * @param {HTMLElement} element\n     * @returns {TaskBoard.model.ColumnModel}\n     * @category DOM\n     */\n    resolveColumnRecord(element) {\n        element = element.closest('.b-taskboard-column, .b-taskboard-column-header');\n        // Headers are b-taskboard-column but without elementData, for now\n        return element && this.columns.getById(element.elementData?.columnId);\n    }\n    /**\n     * Retrieves a swimlane record resolved from the supplied element. Has to be a `.b-taskboard-swimlane` element or\n     * descendant thereof.\n     *\n     * ```javascript\n     * const swimlaneRecord = taskBoard.resolveSwimlaneRecord(taskElement);\n     * ```\n     *\n     * @param {HTMLElement} element\n     * @returns {TaskBoard.model.SwimlaneModel}\n     * @category DOM\n     */\n    resolveSwimlaneRecord(element) {\n        element = element.closest('.b-taskboard-swimlane');\n        return element && this.swimlanes?.getById(element.elementData.laneId);\n    }\n    //endregion\n    //region Get element from record\n    /**\n     * Retrieves the task element (card) corresponding to the supplied task record.\n     *\n     * ```javascript\n     * const cardElement = taskBoard.getTaskElement(taskRecord);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getTaskElement(taskRecord) {\n        const taskColumnElement = this.getTaskColumnElement(taskRecord);\n        return taskColumnElement && DomSync.getChild(taskColumnElement, `body.inner.${taskRecord.domId}`);\n    }\n    /**\n     * Retrieves the element for the column that holds the supplied task record.\n     *\n     * ```javascript\n     * const columnElement = taskBoard.getColumnElement(taskRecord);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getTaskColumnElement(taskRecord) {\n        const columnRecord = this.columns.getById(taskRecord.getValue(this.columnField));\n        return columnRecord && DomSync.getChild(this.getTaskSwimlaneElement(taskRecord), `body.${columnRecord.domId}`);\n    }\n    /**\n     * Retrieves the element for the swimlane that holds the supplied task record.\n     *\n     * ```javascript\n     * const swimlaneElement = taskBoard.getTaskSwimlaneElement(taskRecord);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getTaskSwimlaneElement(taskRecord) {\n        // When not using swimlanes, we still create one called 'default'\n        const laneId = this.swimlanes?.count\n            ? this.swimlanes.getById(taskRecord.getValue(this.swimlaneField))?.domId\n            : 'default';\n        return DomSync.getChild(this.bodyElement, laneId);\n    }\n    /**\n     * Retrieves the element for the supplied swimlane.\n     *\n     * ```javascript\n     * const swimlaneElement = taskBoard.getSwimlaneElement(taskBoard.swimlanes.first);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getSwimlaneElement(swimlaneRecord) {\n        // Get a swimlane element, does not query DOM and is thus cheap\n        return DomSync.getChild(this.bodyElement, swimlaneRecord.domId);\n    }\n    /**\n     * Retrieves the element for the supplied swimlane / column intersection.\n     *\n     * ```javascript\n     * const element = taskBoard.getSwimlaneColumnElement(taskBoard.swimlanes.first, taskBoard.columns.last);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord\n     * @param {TaskBoard.model.ColumnModel} columnRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getSwimlaneColumnElement(swimlaneRecord, columnRecord) {\n        // Called with a swimlaneRecord (public API)\n        if (swimlaneRecord) {\n            // Get the column element for specified column / swimlane intersection, does not query DOM and is thus cheap\n            return DomSync.getChild(this.getSwimlaneElement(swimlaneRecord), `body.${columnRecord.domId}`);\n        }\n        // Called without, happens internally when not using swimlanes - to have simpler code paths\n        else {\n            return this.getColumnElement(columnRecord);\n        }\n    }\n    /**\n     * Retrieves the element for the supplied column.\n     *\n     * Only applicable when not using swimlanes. If you are using swimlanes, see {@link #function-getColumnElements}.\n     *\n     * @param {TaskBoard.model.ColumnModel} columnRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getColumnElement(columnRecord) {\n        return this.getColumnElements(columnRecord)?.[0];\n    }\n    /**\n     * Retrieves the elements for the supplied column. When using swimlanes, a column has one element per swimlane.\n     *\n     * @param {TaskBoard.model.ColumnModel} columnRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getColumnElements(columnRecord) {\n        // A column can span multiple swimlanes, it will have one element per swimlane.\n        // If we have multiple swimlanes, iterate them and retrieve column elements.\n        // This approach avoids querying DOM and is thus cheap\n        if (this.swimlanes?.count) {\n            return this.swimlanes.reduce((result, lane) => {\n                if (!lane.hidden) {\n                    result.push(this.getSwimlaneColumnElement(lane, columnRecord));\n                }\n                return result;\n            }, []);\n        }\n        // No swimlanes, still return as array for consistency\n        return [this.getSwimlaneColumnElement({ domId : 'default' }, columnRecord)];\n    }\n    /**\n     * Retrieves the header element for the supplied column.\n     *\n     * @param {TaskBoard.model.ColumnModel} columnRecord\n     * @returns {HTMLElement}\n     * @category DOM\n     */\n    getColumnHeaderElement(columnRecord) {\n        return DomSync.getChild(this.bodyElement, `header.${columnRecord.domId}`);\n    }\n    //endregion\n    //region Position based\n    /**\n     * Get the card element at (x, y)\n     * @param {Number} x\n     * @param {Number} y\n     * @param {String} cardSelector\n     * @returns {HTMLElement}\n     * @internal\n     */\n    getCardAt(x, y, cardSelector = '.b-taskboard-card') {\n        return this.documentRoot.elementFromPoint(x, y)?.closest(cardSelector);\n    }\n    //endregion\n    //region Cached measurements\n    cacheCSSVar(name, defaultValue) {\n        const me = this;\n        let size = me[`_${name}`];\n        if (size == null) {\n            const value = me.css[name];\n            size  = DomHelper.measureSize(value || defaultValue, me.element);\n            if (value) {\n                me[`_${name}`] = size;\n            }\n        }\n        return size;\n    }\n    // Cached card gap\n    get cardGap() {\n        return this.cacheCSSVar('cardGap', '1em');\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardDomEvents\n */\n/**\n * Mixin that handles dom events (click etc) for the TaskBoard and its columns and cards.\n *\n * {@inlineexample TaskBoard/view/mixin/TaskBoardDomEvents.js}\n *\n * Snippet showing two ways to add listeners:\n *\n * ```javascript\n * // Listener defined as part of config\n * const taskBoard = new TaskBoard({\n *     listeners : {\n *        taskClick({ taskRecord }) {\n *            Toast.show(`Clicked on ${taskRecord.name}`);\n *        }\n *     }\n * });\n *\n * // Listener added at runtime\n * taskBoard.on('taskDblClick', ({ taskRecord }) => { ... });\n * ```\n *\n * @mixin\n */\nexport default Target => class TaskBoardDomEvents extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardDomEvents';\n    static configurable = {\n        /**\n         * The name of the event that should activate a task and trigger editing (if an editing feature is active).\n         * Available options are: 'taskClick', 'taskDblClick' or null (disable)\n         * @default\n         * @config {'taskClick'|'taskDblClick'|null}\n         * @category Advanced\n         */\n        activateTaskEvent : 'taskDblClick',\n        domEvents : {\n            click       : 'click',\n            dblclick    : 'dblClick',\n            mouseup     : 'mouseUp',\n            mousedown   : 'mouseDown',\n            mousemove   : 'mouseMove',\n            mouseover   : 'mouseOver',\n            mouseout    : 'mouseOut',\n            keydown     : 'keyDown',\n            contextmenu : 'contextMenu'\n        },\n        domListeners : {}\n    };\n    #hoveredCardElement = null;\n    get widgetClass() {}\n    //endregion\n    //region Events\n    /**\n     * Triggered when a card is clicked.\n     *\n     * ```javascript\n     * taskBoard.on('taskClick', ({ taskRecord }) => {\n     *    Toast.show(`Clicked on ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event taskClick\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when a card is double clicked\n     *\n     * ```javascript\n     * taskBoard.on('taskDblClick', ({ taskRecord }) => {\n     *    Toast.show(`Double clicked on ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event taskDblClick\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when the mouse enters a card\n     *\n     * ```javascript\n     * taskBoard.on('taskMouseEnter', ({ taskRecord }) => {\n     *    Toast.show(`Mouse entered ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event taskMouseEnter\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when the mouse leaves a card\n     *\n     * ```javascript\n     * taskBoard.on('taskMouseLeave', ({ taskRecord }) => {\n     *    Toast.show(`Mouse left ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event taskMouseLeave\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column record for the tasks column\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record for the tasks swimlane (if used)\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when a task is \"activated\" by pressing `Enter` or double clicking it.\n     *\n     * By default this leads to the task editor being shown.\n     *\n     * ```javascript\n     * taskBoard.on('activateTask', ({ taskRecord }) => {\n     *    Toast.show(`Activated ${taskRecord.name}`);\n     * });\n     * ```\n     *\n     * @event activateTask\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when a task is rendered.\n     *\n     * This happens on initial render, when a task is added or when the task element is updated.\n     *\n     * Listening to this event allows you to manipulate the tasks element directly after it has been updated. Please\n     * note that we strongly recommend using a `taskRenderer` to manipulate the DomConfig used to update the task for\n     * most scenarios.\n     *\n     * If you listen for this event and manipulate the element in some way, you should also listen for\n     * `removeTaskElement` and revert/clean up the changes there.\n     *\n     * @event renderTask\n     * @param {TaskBoard.view.TaskBoard} source TaskBoard instance\n     * @param {TaskBoard.model.TaskModel} taskRecord Task being rendered\n     * @param {Boolean} isRefresh `true` if the element was updated, `false` if it was added\n     * @param {HTMLElement} element Tasks element\n     */\n    /**\n     * Triggered when all tasks in the task board are rendered\n     * @event renderTasks\n     * @param {TaskBoard.view.TaskBoard} source TaskBoard instance\n     * @param {TaskBoard.model.TaskModel[]} taskRecords Tasks being rendered\n     */\n    /**\n     * Triggered when a tasks element is removed.\n     *\n     * This happens when a task is removed or when it is move to another swimlane / column (in which case a `renderTask`\n     * event is triggered for the new element).\n     *\n     * If you used listener for `renderTask` to alter the element of tasks, you should also listen for this event to\n     * clean that modification up.\n     *\n     * @event removeTaskElement\n     * @param {TaskBoard.view.TaskBoard} source TaskBoard instance\n     * @param {String|Number} taskId Id of the task (not the record itself since it might be removed)\n     * @param {HTMLElement} element Tasks element\n     */\n    /**\n     * Triggered when a swimlane header is clicked.\n     *\n     * ```javascript\n     * taskBoard.on('swimlaneHeaderClick', ({ swimlaneRecord }) => {\n     *    Toast.show(`Clicked on ${swimlaneRecord.text}`);\n     * });\n     * ```\n     *\n     * @event swimlaneHeaderClick\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when a swimlane header is double-clicked.\n     *\n     * ```javascript\n     * taskBoard.on('swimlaneHeaderDblClick', ({ swimlaneRecord }) => {\n     *    Toast.show(`Double-clicked on ${swimlaneRecord.text}`);\n     * });\n     * ```\n     *\n     * @event swimlaneHeaderDblClick\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Triggered when a swimlane header is right-clicked.\n     *\n     * ```javascript\n     * taskBoard.on('swimlaneHeaderContextMenu', ({ swimlaneRecord }) => {\n     *    Toast.show(`Right-clicked on ${swimlaneRecord.text}`);\n     * });\n     * ```\n     *\n     * @event swimlaneHeaderContextMenu\n     * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n     * @param {TaskBoard.model.SwimlaneModel} swimlaneRecord Swimlane record\n     * @param {MouseEvent} event Browser event\n     */\n    //endregion\n    //region Triggering\n    // Sets the domListeners up, all relayed to triggerDomEvent()\n    changeDomListeners(domListeners) {\n        if (domListeners) {\n            for (const eventName in this.domEvents) {\n                domListeners[eventName] = 'triggerDomEvent';\n            }\n        }\n        return domListeners;\n    }\n    // Resolve records from the passed event\n    resolveEvent(event) {\n        const\n            { target }     = event,\n            taskRecord     = this.resolveTaskRecord(target),\n            columnRecord   = this.resolveColumnRecord(target),\n            swimlaneRecord = this.resolveSwimlaneRecord(target);\n        return { taskRecord, columnRecord, swimlaneRecord, event };\n    }\n    // \"Re-trigger\" a dom event as one of ours, populated with records and prefixed with either 'task'  or 'column'\n    // depending on event target\n    triggerDomEvent(event) {\n        const\n            me         = this,\n            args       = me.resolveEvent(event),\n            name       = me.domEvents[event.type],\n            { target } = event;\n        // Bail out for fields on a card, or if we are scrolling (_element to not trigger a recompose)\n        if (me.isScrolling || target.closest('.b-widget') !== me._element) {\n            return;\n        }\n        // Decorate the event for easy access later\n        event.taskBoardData = args;\n        let result;\n        // Trigger taskDblClick or columnDblClick, depending on what was resolved\n        if (args.taskRecord) {\n            const eventName = `task${StringHelper.capitalize(name)}`;\n            result = me.trigger(eventName, args);\n            if (eventName === me.activateTaskEvent && !event.defaultPrevented) {\n                me.trigger('activateTask', { taskRecord : args.taskRecord, event });\n            }\n        }\n        else if (args.columnRecord) {\n            if (target.closest('.b-taskboard-column-header')) {\n                result = me.trigger(`columnHeader${StringHelper.capitalize(name)}`, args);\n            }\n            else {\n                result = me.trigger(`column${StringHelper.capitalize(name)}`, args);\n            }\n        }\n        else if (args.swimlaneRecord) {\n            if (target.closest('.b-taskboard-swimlane-header')) {\n                result = me.trigger(`swimlaneHeader${StringHelper.capitalize(name)}`, args);\n            }\n            else {\n                result = me.trigger(`swimlane${StringHelper.capitalize(name)}`, args);\n            }\n        }\n        // Allow returning false from taskClick, onTaskClick etc. to prevent triggering 'click'\n        if (result === false) {\n            return;\n        }\n        me.trigger(name, args);\n        // Conjure up mouseEnter and mouseLeave events from mouseOver/mouseOut\n        if ((name === 'mouseOver' || name === 'mouseOut') && args.taskRecord) {\n            const cardElement = target.closest('.b-taskboard-card');\n            if (name === 'mouseOver' && cardElement !== me.#hoveredCardElement) {\n                me.#hoveredCardElement = cardElement;\n                me.trigger('taskMouseEnter', args);\n            }\n            if (name === 'mouseOut' && !cardElement.contains(event.relatedTarget)) {\n                me.#hoveredCardElement = null;\n                me.trigger('taskMouseLeave', args);\n            }\n        }\n    }\n    // Called as DomSync syncs elements\n    domSyncCallback({ action, domConfig, lastDomConfig, targetElement : element, syncId, jsx }) {\n        const\n            me              = this,\n            { elementType } = domConfig?.elementData ?? {},\n            isRefresh       = action === 'reuseOwnElement',\n            { reactComponent } = this;\n        if (jsx && this.processTaskItemContent) {\n            this.processTaskItemContent({\n                jsx,\n                targetElement : element,\n                reactComponent,\n                domConfig\n            });\n            return;\n        }\n        // Safeguard against other non dom synced elements being cleaned up\n        if (domConfig) {\n            // Card element synced\n            if (elementType === 'task') {\n                const\n                    { taskId } = domConfig.elementData,\n                    taskRecord = me.project.taskStore.getById(taskId);\n                if (action === 'newElement') {\n                    me.cardIntersectionObserver?.observe(element);\n                }\n                if (action === 'newElement' || action === 'reuseOwnElement') {\n                    (!me.isVirtualized || taskRecord.instanceMeta(me).intersects) && me.trigger('renderTask', { taskRecord, element, isRefresh });\n                }\n                else if (action === 'removeElement') {\n                    me.cardIntersectionObserver?.unobserve(element);\n                    me.trigger('removeTaskElement', { taskId, element });\n                }\n            }\n            // Column\n            else if (elementType === 'column') {\n                const\n                    { columnId, laneId } = domConfig.elementData,\n                    columnRecord         = me.columns.getById(columnId),\n                    swimlaneRecord       = laneId != null && me.swimlanes?.getById(laneId);\n                if (action === 'newElement' || action === 'reuseOwnElement') {\n                    me.trigger('renderColumn', { columnRecord, swimlaneRecord, element, isRefresh });\n                }\n                else if (action === 'removeElement') {\n                    me.trigger('removeColumnElement', { columnId, swimlaneRecord, element });\n                }\n            }\n            // Swimlane\n            else if (elementType === 'swimlane') {\n                const\n                    { laneId }     = domConfig.elementData,\n                    swimlaneRecord = laneId != null && laneId !== 'default' && me.swimlanes?.getById(laneId);\n                // Using swimlanes is optional\n                if (laneId !== 'default') {\n                    if (action === 'newElement' || action === 'reuseOwnElement') {\n                        me.trigger('renderSwimlane', { swimlaneRecord, element, isRefresh });\n                    }\n                    else if (action === 'removeElement') {\n                        me.trigger('removeSwimlaneElement', { swimlaneId : laneId, element });\n                    }\n                }\n            }\n            // Column header padder, for resize monitoring\n            else if (domConfig.class?.['b-taskboard-column-header-padder'] && me.resizeObserver) {\n                if (action === 'newElement') {\n                    if (!element.isResizeObserved) {\n                        me.resizeObserver.observe(element);\n                        element.isResizeObserved = true;\n                    }\n                }\n                if (action === 'removeElement') {\n                    if (element.isResizeObserved) {\n                        me.resizeObserver.unobserve(element);\n                        delete element.isResizeObserved;\n                    }\n                }\n            }\n        }\n    }\n    //endregion\n    //region Chainable handlers\n    onClick() {}\n    onMouseMove() {}\n    onMouseUp() {}\n    onTaskMouseDown() {}\n    onTaskClick() {}\n    onTaskDblClick() {}\n    onTaskContextMenu() {}\n    onColumnMouseDown() {}\n    onColumnHeaderClick(...args) {\n        super.onColumnHeaderClick(...args);\n    }\n    onSwimlaneHeaderClick(...args) {\n        super.onSwimlaneHeaderClick(...args);\n    }\n    onActivateTask() {}\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\nimport Scroller from '../../../Core/helper/util/Scroller.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardScroll\n */\n/**\n * Mixin that handles scrolling to tasks, columns and swimlanes.\n *\n * {@inlineexample TaskBoard/view/mixin/TaskBoardScroll.js}\n *\n * @mixin\n */\nexport default Target => class TaskBoardScroll extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardScroll';\n    static configurable = {\n        /**\n         * Default scroll options, see the options for {@link Core.helper.util.Scroller#function-scrollIntoView}\n         *\n         * Defaults to:\n         *\n         * ```javascript\n         * scrollOptions : {\n         *     animate   : true,\n         *     block     : 'nearest',\n         *     highlight : true\n         * }\n         * ```\n         *\n         * Can be overridden per call for all scroll functions.\n         *\n         * @config {BryntumScrollOptions}\n         * @category Advanced\n         */\n        scrollOptions : {\n            animate   : true,\n            block     : 'nearest',\n            highlight : true\n        },\n        testConfig : {\n            scrollOptions : {\n                animate : false,\n                block   : 'nearest'\n            }\n        }\n    };\n    get widgetClass() {}\n    static delayable = {\n        onScrollEnd : VersionHelper.isTestEnv ? 300 : 100\n    };\n    //endregion\n    //region Scroll tracking\n    onInternalPaint({ firstPaint }) {\n        if (firstPaint) {\n            const me = this;\n            EventHelper.on({\n                element : me.element,\n                scroll() {\n                    me.isScrolling = true;\n                    me.onScrollEnd();\n                },\n                capture : true,\n                thisObj : me\n            });\n        }\n    }\n    onScrollEnd() {\n        this.isScrolling = false;\n        if (this.recomposeOnScrollEnd) {\n            this.recompose();\n            this.recomposeOnScrollEnd = false;\n        }\n    }\n    //endregion\n    //region Type assertions\n    changeScrollOptions(scrollOptions) {\n        ObjectHelper.assertObject(scrollOptions, 'scrollOptions');\n        return scrollOptions;\n    }\n    //endregion\n    //region Scroll to\n    /**\n     * Scroll specified swimlane into view.\n     *\n     * ```javascript\n     * taskBoard.scrollToSwimlane('high');\n     * taskBoard.scrollToSwimlane(taskBoard.swimlanes.last);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|Number|String} swimlaneOrId Swimlane or its id\n     * @param {BryntumScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}\n     * @category Scrolling\n     */\n    async scrollToSwimlane(swimlaneOrId, options = this.scrollOptions) {\n        const\n            swimlane        = this.swimlanes.getById(swimlaneOrId),\n            swimlaneElement = swimlane && this.getSwimlaneElement(swimlane);\n        if (swimlaneElement) {\n            options = ObjectHelper.assign({\n                x       : false,\n                animate : options?.animate || options?.behavior === 'smooth'\n            }, options);\n            return Scroller.scrollIntoView(swimlaneElement, options, this.rtl);\n        }\n    }\n    /**\n     * Scroll specified column into view.\n     *\n     * ```javascript\n     * taskBoard.scrollToColumn('backlog');\n     * taskBoard.scrollToColumn(taskBoard.columns.first);\n     * ```\n     *\n     * @param {TaskBoard.model.ColumnModel|Number|String} columnOrId Column or its id\n     * @param {BryntumScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}\n     * @category Scrolling\n     */\n    async scrollToColumn(columnOrId, options = this.scrollOptions) {\n        const\n            column        = this.columns.getById(columnOrId),\n            columnElement = column && this.getColumnHeaderElement(column);\n        if (columnElement) {\n            // Only scroll in the X axis.\n            options = ObjectHelper.assign({\n                animate : options?.animate || options?.behavior === 'smooth',\n                y       : false\n            }, options);\n            return Scroller.scrollIntoView(columnElement, options, this.rtl);\n        }\n    }\n    /**\n     * Scroll to the intersection between specified swimlane and column.\n     *\n     * ```javascript\n     * taskBoard.scrollToIntersection('high', 'done');\n     * taskBoard.scrollToIntersection(taskBoard.swimlanes.low, taskBoard.columns.todo);\n     * ```\n     *\n     * @param {TaskBoard.model.SwimlaneModel|Number|String} swimlaneOrId Swimlane or its id\n     * @param {TaskBoard.model.ColumnModel|Number|String} columnOrId Column or its id\n     * @param {BryntumScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}\n     * @category Scrolling\n     */\n    async scrollToIntersection(swimlaneOrId, columnOrId, options = this.scrollOptions) {\n        const\n            swimlane = this.swimlanes.getById(swimlaneOrId),\n            column   = this.columns.getById(columnOrId),\n            target   = swimlane && column && this.getSwimlaneColumnElement(swimlane, column);\n        if (target) {\n            options = ObjectHelper.assign({\n                animate    : options?.animate || options?.behavior === 'smooth',\n                edgeOffset : 10\n            }, options);\n            return Scroller.scrollIntoView(target, options, this.rtl);\n        }\n    }\n    /**\n     * Scroll the specified task into view.\n     *\n     * ```javascript\n     * taskBoard.scrollToTask(10);\n     * taskBoard.scrollToTask(taskStore.first);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel|Number|String} taskOrId\n     * @param {BryntumScrollOptions} [options] Scroll options, see {@link #config-scrollOptions}\n     * @category Scrolling\n     */\n    async scrollToTask(taskOrId, options = this.scrollOptions) {\n        const\n            me          = this,\n            taskRecord  = me.project.taskStore.getById(taskOrId),\n            taskElement = taskRecord && me.getTaskElement(taskRecord);\n        if (taskElement) {\n            const edgeOffset = { start : 10, end : 10, top : 10, bottom : 10 };\n            // Make sure we don't end up under column or swimlane headers when using sticky headers\n            if (me.stickyHeaders) {\n                if (me.hasSwimlanes) {\n                    edgeOffset.top += me.getTaskSwimlaneElement(taskRecord).syncIdMap.header.offsetHeight;\n                }\n                edgeOffset.top += me.bodyElement.syncIdMap.header.offsetHeight;\n            }\n            if (me.isVirtualized && !me.getTaskHeight) {\n                // Rely on native scrolling for cards at an unknown position, due to unknown heights of cards above it.\n                // Native scrolling is able to somewhat compensate for changing heights during the scroll (seems to\n                // always scroll it slightly intersecting the view, no matter which settings)\n                taskElement.scrollIntoView();\n                // Wait until the task is rendered\n                await new Promise((resolve, reject) => {\n                    const detach = me.ion({\n                        renderTask({ taskRecord : renderedTaskRecord }) {\n                            if (renderedTaskRecord === taskRecord) {\n                                detach();\n                                resolve();\n                            }\n                        },\n                        expires : {\n                            delay : 200,\n                            alt   : reject\n                        }\n                    });\n                });\n            }\n            options = ObjectHelper.assign({\n                animate : options?.animate || options?.behavior === 'smooth',\n                edgeOffset\n            }, options);\n            return Scroller.scrollIntoView(taskElement, options, me.rtl);\n        }\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport ProjectModel from '../../model/ProjectModel.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardStores\n */\n/**\n * Mixin that handles TaskBoards stores, managed by a {@link TaskBoard.model.ProjectModel project}.\n *\n * @mixin\n */\nexport default Target => class TaskBoardStores extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardStores';\n    static configurable = {\n        projectModelClass : ProjectModel,\n        /**\n         * The {@link TaskBoard.model.ProjectModel} instance, containing the data visualized by the TaskBoard.\n         * @member {TaskBoard.model.ProjectModel} project\n         * @accepts {TaskBoard.model.ProjectModel|ProjectModelConfig} project\n         * @category Common\n         */\n        /**\n         * A {@link TaskBoard.model.ProjectModel#configs project config object} or an instance that holds all stores and\n         * data used by the TaskBoard.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     project : {\n         *         // Use a custom task model\n         *         taskModelClass : MyTaskModel,\n         *\n         *         // Supply inline data\n         *         tasksData : [\n         *             { id : 1, name: 'Task 1', ... },\n         *             ...\n         *         ]\n         * });\n         * ```\n         *\n         * Project has built-in crud manager functionality to handle syncing with a backend:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     project : {\n         *         transport : {\n         *             load : {\n         *                 url : 'data/data.json'\n         *             }\n         *     },\n         *     autoLoad : true\n         * });\n         *\n         * Also has built-in state tracking manager functionality to handle undo/redo:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     stm : {\n         *         autoRecord : true,\n         *         disabled   : false\n         *     }\n         * });\n         *\n         * @config {TaskBoard.model.ProjectModel|ProjectModelConfig}\n         * @category Data\n         */\n        project : {},\n        /**\n         * Inline {@link Scheduler.model.AssignmentModel assignments}, will be loaded into an internally created\n         * {@link Scheduler.data.AssignmentStore}  as a part of a {@link TaskBoard.model.ProjectModel project}.\n         * @prp {Scheduler.model.AssignmentModel[]|Object[]} assignments\n         * @category Data\n         */\n        assignments : null,\n        /**\n         * Inline {@link Scheduler.model.ResourceModel resources}, will be loaded into an internally created\n         * {@link Scheduler.data.ResourceStore} as a part of a {@link TaskBoard.model.ProjectModel project}.\n         * @prp {Scheduler.model.ResourceModel[]|Object[]} resources\n         * @category Data\n         */\n        resources : null,\n        /**\n         * Inline {@link TaskBoard.model.TaskModel tasks}, will be loaded into an internally created\n         * {@link TaskBoard.store.TaskStore} as a part of a {@link TaskBoard.model.ProjectModel project}.\n         * @prp {TaskBoard.model.TaskModel[]|Object[]} tasks\n         * @category Data\n         */\n        tasks : null,\n        /**\n         * Default values to apply to task records created by task boards features (such as the column header menu and\n         * the column toolbar)\n         *\n         * @config {TaskModelConfig}\n         * @category Data\n         */\n        newTaskDefaults : {},\n        loadMaskDefaults : {\n            useTransition : true,\n            showDelay     : 100\n        },\n        /**\n         * TaskBoard does not use a sync mask by default. If you want one, see\n         * {@link Core.mixin.LoadMaskable#config-syncMask} for configuration options.\n         *\n         * @config {String|Object|null}\n         * @default null\n         * @category Masking\n         */\n        syncMask : null\n    };\n    get widgetClass() {}\n    //endregion\n    //#region Inline data\n    get assignments() {\n        return this.project.assignmentStore.records;\n    }\n    updateAssignments(records) {\n        this.project.assignmentStore.data = records;\n    }\n    get resources() {\n        return this.project.resourceStore.records;\n    }\n    updateResources(records) {\n        this.project.resourceStore.data = records;\n    }\n    get tasks() {\n        return this.project.taskStore.records;\n    }\n    updateTasks(records) {\n        this.project.taskStore.data = records;\n    }\n    //#endregion\n    //region Type assertions\n    changeNewTaskDefaults(newTaskDefaults) {\n        ObjectHelper.assertObject(newTaskDefaults, 'newTaskDefaults');\n        return newTaskDefaults;\n    }\n    //endregion\n    //region Project\n    changeProject(project) {\n        if (project && !project.isModel) {\n            project = this.projectModelClass.new(project);\n        }\n        this.attachToProject(project);\n        return project;\n    }\n    attachToProject(project) {\n        const me = this;\n        // Enable masking with CrudManagerView\n        me.bindCrudManager(project);\n        if (project) {\n            const { taskStore } = project;\n            // Set up indices for the configured columnField & optional swimlaneField, for faster lookups\n            if (taskStore) {\n                const { storage } = taskStore;\n                storage.addIndex({ property : me.columnField, unique : false });\n                if (me.swimlaneField) {\n                    storage.addIndex({ property : me.swimlaneField, unique : false });\n                }\n                // For quicker lookup of tasks in a swimlane/column intersection\n                Reflect.defineProperty(taskStore.$master.modelClass.prototype, 'columnSwimlaneIntersection', {\n                    get() {\n                        return this.buildIndexKey({\n                            [me.columnField]   : this[me.columnField],\n                            [me.swimlaneField] : this[me.swimlaneField]\n                        });\n                    }\n                });\n                taskStore.$master.modelClass.prototype.buildIndexKey = function(data) {\n                    return `${data[me.columnField]}-/-${(me.swimlanes?.count && data[me.swimlaneField]) || 'default'}`;\n                };\n                storage.addIndex({ property : 'columnSwimlaneIntersection', unique : false, dependentOn : { [me.swimlaneField] : true, [me.columnField] : true } });\n            }\n            // Setup store listeners, mostly just recompose\n            me.attachToProjectStore(project.taskStore, {\n                change          : 'onTaskStoreChange',\n                changePreCommit : 'onTaskStoreEarlyChange',\n                refresh         : 'onTaskStoreRefresh'\n            });\n            me.attachToProjectStore(project.assignmentStore);\n            me.attachToProjectStore(project.resourceStore);\n        }\n    }\n    // Most store changes leads to a recompose, with exception of some TaskStore changes that are transitioned\n    attachToProjectStore(store, listenersConfig = {}) {\n        this.detachListeners(store.$name);\n        store?.ion({\n            name    : store.$name,\n            change  : 'recompose',\n            refresh : 'recompose',\n            thisObj : this,\n            ...listenersConfig\n        });\n    }\n    //endregion\n    //region Listeners\n    onTaskStoreEarlyChange({ action }) {\n        if (action === 'add') {\n            this.recomposeWithDomTransition({\n                addTransition : {\n                    height  : 1,\n                    opacity : 1\n                }\n            });\n        }\n    }\n    onTaskStoreChange({ action, changes }) {\n        const { columnField, swimlaneField } = this;\n        // Task removal and column/swimlane changes are transitioned\n        if (\n            action === 'remove' ||\n            action === 'filter' ||\n            (action === 'update' && (changes[columnField] || (swimlaneField && changes[swimlaneField])))\n        ) {\n            this.recomposeWithDomTransition({\n                removeTransition : {\n                    height  : 1,\n                    opacity : 1\n                }\n            });\n        }\n        else {\n            this.recompose();\n        }\n    }\n    onTaskStoreRefresh({ action }) {\n        if (action === 'sort') {\n            // Ignore sort if we override it anyway\n            !this.taskSorterFn && this.recomposeWithDomTransition();\n        }\n        else {\n            this.recompose();\n        }\n    }\n    //endregion\n    //region Utility\n    /**\n     * Add a new task to the specified column / swimlane intersection (swimlane is optional), scroll it into view and\n     * start editing it (if an editing feature is enabled).\n     *\n     * By default the task is created using the data defined in the {@link #config-newTaskDefaults} combined with values\n     * for the `columnField`, the `swimlaneField` and a generated `weight` to place it last. To override these or to\n     * supply your own values for any field, pass the `taskData` argument.\n     *\n     * If project is configured to auto sync changes to backend, the sync request will be awaited before editing starts.\n     *\n     * @param {TaskBoard.model.ColumnModel} columnRecord Column to add the task to\n     * @param {TaskBoard.model.ColumnModel} [swimlaneRecord] Swimlane to add the task to\n     * @param {Object} [taskData] Data for the new task\n     * @category Common\n     */\n    async addTask(columnRecord, swimlaneRecord = null, taskData = {}) {\n        const\n            me         = this,\n            {\n                swimlaneField,\n                swimlanes,\n                project\n            }          = me,\n            columnBody = me.getColumnElement(columnRecord).syncIdMap.body,\n            lastCard   = columnBody.lastElementChild,\n            data       = {\n                [me.columnField] : columnRecord.id,\n                name             : me.L('L{TaskBoard.newTaskName}'),\n                weight           : (project.taskStore.max('weight') ?? 0) + 100,\n                ...me.newTaskDefaults,\n                ...taskData\n            };\n        let suspended = false;\n        if (swimlaneField) {\n            if (swimlaneRecord) {\n                data[swimlaneField] = swimlaneRecord.id;\n            }\n            else if (swimlanes?.count) {\n                data[swimlaneField] = swimlanes.first.id;\n            }\n        }\n        // If add is likely to cause a scroll, opt out of add transition and only animated the scroll\n        if (lastCard && lastCard.offsetTop + lastCard.offsetHeight > columnBody.clientHeight - 100) {\n            me.suspendDomTransition();\n            suspended = true;\n        }\n        const\n            // A sync will be scheduled on the add below if using autoSync, catch that\n            synced       = project.autoSync && project.await('sync', false),\n            [taskRecord] = project.taskStore.add(data);\n        // To have new tasks element available when trying to scroll to it\n        me.recompose.now();\n        // Await transition used when adding tasks, to be certain task is at correct pos\n        if (me.useDomTransition && !me.domTransitionSuspended) {\n            await me.await('transitionedRecompose', false);\n        }\n        if (me.isDestroyed) {\n            return;\n        }\n        // Await scroll to make sure inline editing works as expected\n        await me.scrollToTask(taskRecord, ObjectHelper.assign({}, me.scrollOptions, { highlight : false, block : 'nearest' }));\n        if (me.isDestroyed) {\n            return;\n        }\n        // Await any autoSync that we caught above\n        if (synced) {\n            await synced;\n            if (me.isDestroyed) {\n                return;\n            }\n            // Sync likely assigned a new id, make sure we are using that in DOM right away\n            me.recompose.now();\n        }\n        suspended && me.resumeDomTransition();\n        if (me.features.simpleTaskEdit) {\n            me.editTask(taskRecord);\n        }\n        return taskRecord;\n    }\n    /**\n     * Removes one or more tasks from the linked task store (and thus the TaskBoard).\n     *\n     * First fires a `'beforeTaskRemove'` event, which is preventable and async. Return `false` or a promise that\n     * resolves to `false` from a listener to prevent the operation.\n     *\n     * ```javascript\n     * taskBoard.on({\n     *     async beforeRemoveTask() {\n     *         const result = await askForConfirmation();\n     *         return result;\n     *     }\n     * });\n     *\n     * taskBoard.remove(myTask);\n     * ```\n     *\n     * @param {TaskBoard.model.TaskModel|TaskBoard.model.TaskModel[]} taskRecord A single task or an array thereof to\n     * remove from the task store.\n     * @returns {Boolean} Returns `true` if the tasks were removed, `false` if the operation was prevented.\n     * @category Common\n     */\n    async removeTask(taskRecord) {\n        const taskRecords = ArrayHelper.asArray(taskRecord);\n        /**\n         * Triggered when one or more tasks are to be removed by a call to `removeTask()`.\n         *\n         * The UI routes through `removeTask()` (currently only the task menu offers task removal), this event can be\n         * used to add a confirmation flow or similar to those actions.\n         *\n         * Return `false` or a promise that resolves to `false` in a listener to prevent removal.\n         *\n         * ```javascript\n         * taskBoard.on({\n         *     async beforeRemoveTask() {\n         *         const result = await askForConfirmation();\n         *         return result;\n         *     }\n         * });\n         * ```\n         *\n         * @event beforeTaskRemove\n         * @param {TaskBoard.view.TaskBoard} source This TaskBoard\n         * @param {TaskBoard.model.TaskModel[]} taskRecords Task records to be removed\n         * @preventable\n         * @async\n         */\n        if (await this.trigger('beforeTaskRemove', { taskRecords }) !== false) {\n            this.project.taskStore.remove(taskRecords);\n            return true;\n        }\n        return false;\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport Store from '../../../Core/data/Store.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport SwimlaneModel from '../../model/SwimlaneModel.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardSwimlanes\n */\n/**\n * Mixin that handles swimlanes for the TaskBoard.\n *\n * @mixin\n */\nexport default Target => class TaskBoardSwimlanes extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardSwimlanes';\n    static configurable = {\n        /**\n         * Store containing the TaskBoard swimlanes.\n         *\n         * @member {Core.data.Store} swimlanes\n         * @category Common\n         */\n        /**\n         * Store containing the TaskBoard swimlanes. A tasks {@link #config-swimlaneField} is matched against the `id`\n         * of a swimlane to determine in which swimlane it is displayed.\n         *\n         * Accepts an array of swimlane records/objects, a store instance, a store id or a store config object used to\n         * create a new store.\n         *\n         * When supplying an array, a store configured with {@link Core.data.mixin.StoreProxy#config-objectify} is\n         * automatically created. Using that config allows for a nicer interaction syntax with the swimlanes:\n         *\n         * ```javascript\n         * // Without objectify:\n         * taskBoard.swimlanes.getById('highprio').text = 'Important!';\n         *\n         * // With objectify:\n         * taskBoard.swimlanes.done.text = 'Finished';\n         * ```\n         *\n         * When supplying strings, the raw string will be used as the swimlanes `id` and a capitalized version of it is\n         * used as the swimlanes text:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *    swimlanes : [\n         *        'high',\n         *        'low'\n         *    ]\n         * });\n         * ```\n         *\n         * Is equivalent to:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *    swimlanes : [\n         *        { id : 'high', text : 'High' },\n         *        { id : 'low', text : 'Low' }\n         *    ]\n         * });\n         * ```\n         *\n         * @config {TaskBoard.model.SwimlaneModel[]|SwimlaneModelConfig[]|Core.data.Store|String|StoreConfig}\n         * @category Common\n         */\n        swimlanes : {},\n        /**\n         * Set to `true` to auto generate swimlanes when {@link #config-swimlanes} is undefined.\n         *\n         * A swimlane will be created for each distinct value of {@link #config-swimlaneField} on the tasks. The\n         * swimlanes will be sorted in alphabetical order. The following snippet will yield two swimlanes, Q1 and Q2:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    swimlaneField : 'quarter',\n         *\n         *    autoGenerateSwimlanes : true,\n         *\n         *    project : {\n         *        tasksData : [\n         *            { id : 1, name : 'Inform tenants', quarter : 'Q1' },\n         *            { id : 2, name : 'Renovate roofs', quarter : 'Q2' }\n         *        ]\n         *    }\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @category Advanced\n         */\n        autoGenerateSwimlanes : false,\n        /**\n         * Field on a task record used to determine which swimlane the task belongs to.\n         *\n         * ```javascript\n         * taskBoard.swimlaneField = 'category';\n         * ```\n         *\n         * @member {String} swimlaneField\n         * @category Common\n         */\n        /**\n         * Field on a task record used to determine which swimlane the task belongs to.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    // Use the \"prio\" field of tasks to determie which swimlane a task belongs to\n         *    swimlaneField : 'prio',\n         *\n         *    swimlanes : [\n         *        'high',\n         *        'low'\n         *    ],\n         *\n         *    project : {\n         *        tasksData : [\n         *            // Linked using the prio field, to the high swimlane\n         *            { id : 1, name : 'Fun task', prio : 'high' }\n         *        ]\n         *    }\n         * });\n         * ```\n         *\n         * @config {String}\n         * @category Common\n         */\n        swimlaneField : null\n    };\n    static properties = {\n        shouldAutoGenerateSwimlanes : false\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions\n    changeAutoGenerateSwimlanes(autoGenerateSwimlanes) {\n        ObjectHelper.assertBoolean(autoGenerateSwimlanes, 'autoGenerateSwimlanes');\n        return autoGenerateSwimlanes;\n    }\n    changeSwimlaneField(swimlaneField) {\n        ObjectHelper.assertString(swimlaneField, 'swimlaneField');\n        return swimlaneField;\n    }\n    //endregion\n    //region Config - swimlaneField\n    updateSwimlaneField(field, old) {\n        if (!this.isConfiguring) {\n            const { storage } = this.project.taskStore;\n            if (old && old !== this.columnField) {\n                storage.removeIndex(old);\n            }\n            storage.addIndex({ property : field, unique : false });\n        }\n        this.shouldAutoGenerateSwimlanes = field && this.autoGenerateSwimlanes;\n    }\n    //endregion\n    //region Config - swimlanes\n    changeSwimlanes(swimlanes) {\n        return Store.from(swimlanes, { objectify : true, modelClass : SwimlaneModel }, lane => {\n            if (typeof lane === 'string') {\n                return { id : lane, text : StringHelper.capitalize(lane) };\n            }\n            return lane;\n        });\n    }\n    updateSwimlanes(swimlanes) {\n        this.detachListeners('swimlanes');\n        if (swimlanes) {\n            // Link to us to be able to retrieve tasks in visual order\n            // $store is the store instance of an objectified store\n            (swimlanes.$store || swimlanes).taskBoard = this;\n            swimlanes.ion({\n                change  : 'onSwimlanesChange',\n                refresh : 'onSwimlanesChange',\n                thisObj : this\n            });\n        }\n    }\n    get swimlanes() {\n        const\n            me            = this,\n            { taskStore } = me.project;\n        // If there are no swimlanes defined but we have a swimlane field configured and we have tasks loaded, generate\n        // swimlanes from the tasks\n        if (me.shouldAutoGenerateSwimlanes && taskStore.count) {\n            me.swimlanes = taskStore.getDistinctValues(me.swimlaneField).sort();\n            me.shouldAutoGenerateSwimlanes = false;\n        }\n        return me._swimlanes;\n    }\n    onSwimlanesChange({ action }) {\n        // CRUD invalidates column/swimlane intersection index\n        if (action === 'add' || action === 'remove' || action === 'removeAll' || action === 'update') {\n            this.project.taskStore.storage.invalidateIndices();\n        }\n        if (action === 'remove' ||  action === 'update' || action === 'filter') {\n            const options = {};\n            if (action === 'update') {\n                options.addTransition = { height : 1, opacity : 1 };\n                options.removeTransition = { height : 1, opacity : 1 };\n            }\n            this.recomposeWithDomTransition(options);\n            return;\n        }\n        this.recompose();\n    }\n    //endregion\n    //region Data\n    get hasSwimlanes() {\n        return Boolean(this.swimlaneField && this.swimlanes?.count);\n    }\n    getSwimlaneTasks(swimlaneRecord) {\n        return this.project.taskStore.storage.findItem(this.swimlaneField, swimlaneRecord.id);\n    }\n    getSwimlane(taskRecord) {\n        return this.swimlaneField && this.swimlanes?.getById(taskRecord.getValue(this.swimlaneField));\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module TaskBoard/view/mixin/TaskBoardVirtualization\n */\n/**\n * Mixin that handles partial virtualization for the TaskBoard.\n * See class docs for {@link TaskBoard/view/TaskBoard} for more information.\n *\n * @mixin\n */\nexport default Target => class TaskBoardVirtualization extends (Target || Base) {\n    //region Config\n    static $name = 'TaskBoardVirtualization';\n    static configurable = {\n        /**\n         * The function is called for each task as part of the render loop, and is expected to return the height in\n         * pixels for the task. Using this function is only recommended when using partial virtualized rendering, see\n         * the {@link #config-virtualize} setting.\n         *\n         * How the height is determined is up to the application, it could for example return a fixed value:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *     getTaskHeight() {\n         *         return 150;\n         *     }\n         * }\n         * ```\n         *\n         * Or get the height from data:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *     getTaskHeight(taskRecord) {\n         *         return taskRecord.myTaskHeight;\n         *     }\n         * }\n         * ```\n         *\n         * Or use some custom application logic:\n         *\n         * ```javascript\n         * taskBoard = new TaskBoard({\n         *     getTaskHeight(taskRecord) {\n         *         if (taskRecord.isCollapsed) {\n         *             return 20;\n         *         }\n         *\n         *         return taskRecord.myTaskHeight;\n         *     }\n         * }\n         * ```\n         *\n         * @prp {Function}\n         * @param {TaskBoard.model.TaskModel} taskRecord The task record\n         * @return {Number} The height of the task in pixels\n         * @category Advanced\n         */\n        getTaskHeight : null,\n        /**\n         * By turning on this setting you enable partial virtualized rendering for the board, which reduces initial\n         * rendering time and makes interaction less sluggish when using thousands of tasks. The tradeoff is that\n         * scrolling in most cases will be slower.\n         *\n         * For a nice UX, it is strongly recommended to also implement a {@link #config-getTaskHeight} function. Without\n         * it, the height of tasks out of view will be unknown and the behaviour when scrolling will be less than ideal.\n         *\n         * <div class=\"note\">Note that for normal datasets (depending on machine, but roughly <1000 tasks) performance\n         * might be better without partial virtualized rendering, since it adds some overhead.</div>\n         *\n         * <div class=\"note\">Also note that as part of the optimizations for partial virtualized rendering, the inner\n         * element in columns that contain cards is absolutely positioned. This leads to column not being able to\n         * automatically shrink wrap the cards, you will have to set a height on the swimlane (or task board if not\n         * using swimlanes) to size things correctly.</div>\n         *\n         * @prp {Boolean}\n         */\n        virtualize : {\n            value   : null,\n            $config : 'nullify'\n        },\n        /**\n         * Whether to draw cards on scroll, or only when scrolling ends.\n         *\n         * Only applies when using partial virtualized rendering (see {@link #config-getTaskHeight}).\n         *\n         * Setting this to `false` will boost scroll performance, but cards scrolled into view will be empty outlines\n         * until scrolling ends.\n         *\n         * @prp {Boolean}\n         */\n        drawOnScroll : true\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions and changers/updaters\n    changeVirtualize(virtualize) {\n        ObjectHelper.assertBoolean(virtualize, 'virtualize');\n        return virtualize;\n    }\n    updateVirtualize(virtualize) {\n        const me = this;\n        me.cardIntersectionObserver?.disconnect();\n        me.cardIntersectionObserver = null;\n        if (virtualize) {\n            // Observes cards coming into / out of view.\n            // Elements to observe are added from TaskBoardDomEvents#domSyncCallback\n            me.cardIntersectionObserver = new IntersectionObserver(entries => {\n                for (const entry of entries) {\n                    me.onCardIntersection(entry.target, entry.isIntersecting, entry);\n                }\n            });\n        }\n        // Allow toggling at runtime (mainly for bigdataset demo)\n        if (!this.isConfiguring && !this.isDestroying) {\n            this.refreshVirtualizedCards();\n        }\n    }\n    refreshVirtualizedCards() {\n        const me = this;\n        me.recompose.now();\n        if (me.cardIntersectionObserver) {\n            for (const taskElement of me.element.querySelectorAll('.b-taskboard-card')) {\n                me.cardIntersectionObserver.observe(taskElement);\n            }\n        }\n    }\n    changeGetTaskHeight(getTaskHeight) {\n        getTaskHeight && ObjectHelper.assertFunction(getTaskHeight, 'getTaskHeight');\n        return getTaskHeight;\n    }\n    updateGetTaskHeight(fn) {\n        // Allow toggling at runtime (mainly for bigdataset demo)\n        if (!this.isConfiguring && !this.isDestroying) {\n            this.refreshVirtualizedCards();\n        }\n    }\n    //endregion\n    compose(domConfig) {\n        domConfig.class['b-virtualized'] = this.isVirtualized;\n        return super.compose(domConfig);\n    }\n    get isVirtualized() {\n        return Boolean(this.cardIntersectionObserver);\n    }\n    // Flag cards as in view or out of view when their elements are intersecting the viewport (or not anymore)\n    onCardIntersection(cardElement, isIntersecting, entry) {\n        const\n            me              = this,\n            { taskRecord }  = cardElement.elementData,\n            instanceMeta    = taskRecord.instanceMeta(me),\n            wasIntersecting = instanceMeta.intersects;\n        if (wasIntersecting !== isIntersecting) {\n            instanceMeta.intersects = isIntersecting;\n            if (!isIntersecting && wasIntersecting) {\n                instanceMeta.lastHeight = entry.boundingClientRect.height;\n            }\n            // Recompose affected column right away if not scrolling, or if configured to draw on scroll\n            if (!me.isScrolling || me.drawOnScroll) {\n                me.queueColumnRecompose(me.getColumn(taskRecord), me.getSwimlane(taskRecord));\n            }\n            // Always do a full recompose when scrolling ends, to have all lastDomConfigs up to date\n            if (me.isScrolling) {\n                me.recomposeOnScrollEnd = true;\n            }\n        }\n    }\n    //region Rendering\n    // Creates a DOM config for the outline of a single card\n    renderCardOutline(taskRecord, columnRecord, swimlaneRecord) {\n        const\n            me                    = this,\n            { id, domId, weight } = taskRecord;\n        return {\n            id    : `${me.id}-card-${domId}`,\n            class : {\n                'b-taskboard-card' : true,\n                'b-out-of-view'    : true\n            },\n            tabIndex : 0,\n            dataset  : {\n                task          : domId,\n                column        : columnRecord.id,\n                lane          : swimlaneRecord?.id,\n                weight,\n                domTransition : true\n            },\n            elementData : {\n                elementType : 'task',\n                taskId      : id,\n                taskRecord,\n                columnRecord,\n                swimlaneRecord\n            },\n            style : {\n                height : me.getTaskHeight?.(taskRecord) || taskRecord.instanceMeta(me).lastHeight\n            }\n        };\n    }\n    // Overrides renderCard in TaskBoardBase, rendering outlines for cards out of view\n    renderCard(taskRecord, columnRecord, swimlaneRecord) {\n        const\n            { isVirtualized } = this,\n            meta              = taskRecord.instanceMeta(this);\n        // Render outlines for cards out of view when using virtualization\n        if (isVirtualized && !meta.dragging && !meta.intersects && !this.isSelected(taskRecord)) {\n            return this.renderCardOutline(taskRecord, columnRecord, swimlaneRecord);\n        }\n    }\n    //endregion\n};\n", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/TextItem\n */\n/**\n * Item that displays the value of the configured {@link #config-field} in a XSS safe way.\n *\n * {@inlineexample TaskBoard/view/item/TextItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype text\n */\nexport default class TextItem extends TaskItem {\n    static $name = 'TextItem';\n    static type = 'text';\n    static render({ domConfig, value, taskRecord, config }) {\n        // Special handling when bound to id\n        if (config.field === 'id' && taskRecord.hasGeneratedId) {\n            domConfig.class['b-generated-id'] = 1;\n            domConfig.text = '\u273B';\n        }\n        else {\n            domConfig.text = taskRecord.getFieldDefinition(config.field).print(value);\n        }\n    }\n}\nTextItem.initClass();\nTextItem._$name = 'TextItem';", "import TaskItem from './TaskItem.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport AvatarRendering from '../../../Core/widget/util/AvatarRendering.js';\n/**\n * @module TaskBoard/view/item/ResourceAvatarsItem\n */\n/**\n * Item displaying avatars or initials for a tasks assigned resources.\n *\n * {@inlineexample TaskBoard/view/item/ResourceAvatarsItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype resourceAvatars\n */\nexport default class ResourceAvatarsItem extends TaskItem {\n    static $name = 'ResourceAvatarsItem';\n    static type = 'resourceAvatars';\n    /**\n     * Maximum avatars to display by default. The last avatar will render an overflow indicator if the task has more\n     * resources assigned.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *     headerItems : {\n     *         resources : {\n     *             type       : 'resourceAvatars',\n     *             maxAvatars : 5\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * Overridden by card size based settings, see {@link TaskBoard.view.mixin.ResponsiveCards}.\n     *\n     * @config {Number} maxAvatars\n     * @default 7\n     * @category Common\n     */\n    /**\n     * Specify `true` to slightly overlap avatars for tasks that have multiple resources assigned. By default, they are\n     * displayed side by side.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *     headerItems : {\n     *         resources : {\n     *             overlap : true\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * @config {Boolean} overlap\n     */\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * Defaults to use a {@link TaskBoard.widget.ResourcesCombo}.\n     *\n     * @config {String|Object} editor\n     * @default resourcescombo\n     * @category Common\n     */\n    static defaultEditor = { type : 'resourcescombo', pickerWidth : '13em' };\n    static render({ taskBoard, domConfig, config, taskRecord, cardSize }) {\n        const\n            maxAvatars            = cardSize?.maxAvatars ?? config.maxAvatars ?? 7,\n            { resourceImagePath } = taskBoard,\n            { resources }         = taskRecord,\n            hasOverflow           = resources.length > maxAvatars,\n            overflowCount         = resources.length - maxAvatars + 1,\n            lastResource          = resources[maxAvatars];\n        let { avatarRendering } = taskBoard;\n        if (!avatarRendering) {\n            avatarRendering = taskBoard.avatarRendering = new AvatarRendering({\n                element     : taskBoard.element,\n                colorPrefix : 'b-taskboard-background-color-'\n            });\n        }\n        if (!taskBoard.project.resourceStore.count) {\n            return false;\n        }\n        ObjectHelper.merge(domConfig, {\n            class : {\n                'b-overlap' : config.overlap\n            },\n            children : [\n                // \"Normal\" avatars\n                ...resources\n                    // Want a stable order for resource to not move around on changes\n                    .sort((a, b) => a.name.localeCompare(b.name))\n                    .slice(0, maxAvatars - (hasOverflow ? 1 : 0)) // -1 for the overflow indicator\n                    .map((resource, i) => ({\n                        class : {\n                            'b-taskboard-resource-avatar-wrap' : 1\n                        },\n                        dataset : {\n                            resourceId : resource.id\n                        },\n                        children : [\n                            avatarRendering.getResourceAvatar({\n                                resourceRecord : resource,\n                                imageUrl       : resource.image === false ? null : (resource.imageUrl || resource.image && ((resourceImagePath || '') + resource.image)),\n                                initials       : resource.initials,\n                                color          : resource.eventColor,\n                                dataset        : {\n                                    btip : StringHelper.encodeHtml(resource.name)\n                                }\n                            })\n                        ]\n                    })),\n                // Overflow indicating avatar\n                hasOverflow && {\n                    class : {\n                        'b-taskboard-resource-avatar-overflow' : 1\n                    },\n                    dataset : {\n                        resourceId : '$overflow',\n                        btip       : resources.slice(-overflowCount).map(r => StringHelper.encodeHtml(r.name)).join(', '),\n                        count      : overflowCount\n                    },\n                    children : [\n                        avatarRendering.getResourceAvatar({\n                            resourceRecord : lastResource,\n                            imageUrl       : lastResource.image === false ? null : (lastResource.imageUrl || lastResource.image && (resourceImagePath + lastResource.image)),\n                            initials       : lastResource.initials\n                        })\n                    ]\n                }\n            ],\n            syncOptions : {\n                syncIdField : 'resourceId'\n            }\n        });\n    }\n    static onClick({ source : taskBoard, taskRecord, event }) {\n        const element = event.target.closest('.b-resource-avatar, .b-taskboard-resource-avatar-overflow');\n        if (element) {\n            if (element.matches('.b-resource-avatar')) {\n                const resourceRecord = taskBoard.project.resourceStore.getById(element.dataset.resourceId);\n                taskBoard.trigger('resourceAvatarClick', { resourceRecord, taskRecord, element, event });\n            }\n            else {\n                taskBoard.trigger('resourceAvatarOverflowClick', { taskRecord, element, event });\n            }\n            return false;\n        }\n    }\n}\nResourceAvatarsItem.initClass();\nResourceAvatarsItem._$name = 'ResourceAvatarsItem';", "import Base from '../../../Core/Base.js';\nimport TaskItem from '../item/TaskItem.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\n// Items used by default\nimport '../item/TextItem.js';\nimport '../item/ResourceAvatarsItem.js';\n/**\n * @module TaskBoard/view/mixin/TaskItems\n */\nconst\n    fieldLess        = {\n        resourceAvatars : 1,\n        separator       : 1,\n        taskMenu        : 1\n    },\n    taskItemSelector = '.b-taskboard-taskitem',\n    afterRe          = /\\s*<\\s*/,\n    beforeRe         = /\\s*>\\s*/;\n/**\n * Mixin that allows adding multiple predefined items (sort of like task widgets) to tasks:\n *\n * {@inlineexample TaskBoard/view/mixin/TaskItems.js}\n *\n * You can pick from the following item types:\n *\n * * {@link TaskBoard/view/item/ImageItem image}\n * * {@link TaskBoard/view/item/JsxItem jsx}\n * * {@link TaskBoard/view/item/ProgressItem progress}\n * * {@link TaskBoard/view/item/RatingItem rating}\n * * {@link TaskBoard/view/item/ResourceAvatarsItem resourceAvatars}\n * * {@link TaskBoard/view/item/SeparatorItem separator}\n * * {@link TaskBoard/view/item/TagsItem tags}\n * * {@link TaskBoard/view/item/TemplateItem template}\n * * {@link TaskBoard/view/item/TextItem text}\n * * {@link TaskBoard/view/item/TodoListItem todoList}\n *\n * All of which are included in this demo:\n *\n * {@inlineexample TaskBoard/view/mixin/TaskItemsAll.js}\n *\n * ## Configuring which items to use\n *\n * Task cards are divided into three sections, header, body and footer. Each section can hold items. The following items\n * are defined by default:\n *\n * | Section     | Key             | Type                                                            | Bound to           |\n * |-------------|-----------------|-----------------------------------------------------------------|--------------------|\n * | headerItems | text            | {@link TaskBoard/view/item/TextItem text}                       | name               |\n * | bodyItems   | text            | {@link TaskBoard/view/item/TextItem text}                       | description        |\n * | footerItems | resourceAvatars | {@link TaskBoard/view/item/ResourceAvatarsItem resourceAvatars} | assigned resources |\n *\n * Add items to tasks by supplying the {@link #config-bodyItems bodyItems config} (the other sections work the same):\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     bodyItems : {\n *         // Will use \"prio\" as its field\n *         prio  : { type : 'text' },\n *         // Will use \"status\" as its field\n *         state : { type : 'text', field : 'status' }\n *     }\n * });\n * ```\n *\n * The items you supply are merged with the predefined items (as listed in the table above).\n *\n * The only always required config for new items is `type`, which determines what kind of task item to use. Which other\n * configs you can use depends on the item type.\n *\n * By default, the key in the `items` object will be used to link the item to a field on a task. You can override the\n * default by using the `field` config. Note that, in most cases, if the value of the backing field is `null` or\n * `undefined`, the item will not be rendered.\n *\n * To rearrange items, specify the {@link TaskBoard/view/item/TaskItem#config-order} config of each item. Applied as\n * flex order.\n *\n * You can also add items to a tasks header and footer, using {@link #config-headerItems} and\n * {@link #config-footerItems}.\n *\n * ## Manipulating items per task\n *\n * You can manipulate which items are shown for a task by supplying a {@link #config-processItems} function. It will be\n * called during rendering for each task and in it you can manipulate the passed `bodyItems` object. Set a property of\n * it to `null` to remove that item for that task:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     bodyItems : {\n *         progress  : { type : 'progress' }\n *     },\n *\n *     processItems({ taskRecord, bodyItems }) {\n *         if (taskRecord.status === 'done') {\n *             bodyItems.progress = null;\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample TaskBoard/view/mixin/TaskItemsProcessItems.js}\n *\n * @mixin\n */\nexport default Target => class TaskItems extends (Target || Base) {\n    //region Config\n    static $name = 'TaskItems';\n    static configurable = {\n        /**\n         * Items in card header.\n         *\n         * As an object keyed by field names, values are {@link TaskBoard/view/item/TaskItem#configs TaskItem configs}.\n         *\n         * Reassigning this property merges the supplied object with the configured items:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    headerItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         *\n         * taskBoard.headerItems = {\n         *     status : { hidden : true },\n         *     tags   : { type : 'tags' }\n         * };\n         *\n         * // Results in:\n         * //\n         * // headerItems = {\n         * //     status : { type : 'text', hidden: true }\n         * //     tags   : { type : 'tags' }\n         * // }\n         * }\n         * ```\n         *\n         * @member {Object<String,TaskItemOptions>} headerItems\n         * @category Task content\n         */\n        /**\n         * Items to add to each card's header.\n         *\n         * Supplied keys are used to bind to a field on the {@link TaskBoard/model/TaskModel task record}, supplied\n         * values are used to configure the {@link TaskBoard/view/item/TaskItem#configs items}.\n         *\n         * You are always required to supply a `type`, see the docs for each item type for more information on available\n         * configs.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    headerItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         * ```\n         *\n         * For more information, see the {@link #class-description class description} above.\n         *\n         * @config {Object<String,TaskItemOptions>}\n         * @category Task content\n         */\n        headerItems : {\n            value : {\n                text : { type : 'text', field : 'name' }\n            },\n            $config : {\n                merge : 'items'\n            }\n        },\n        /**\n         * Items to add to each card's body.\n         *\n         * As an object keyed by field names, values are {@link TaskBoard/view/item/TaskItem#configs TaskItem configs}.\n         *\n         * Reassigning this property merges the supplied object with the configured items:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    bodyItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         *\n         * taskBoard.bodyItems = {\n         *     status : { hidden : true },\n         *     tags   : { type : 'tags' }\n         * };\n         *\n         * // Results in:\n         * //\n         * // bodyItems = {\n         * //     status : { type : 'text', hidden: true }\n         * //     tags   : { type : 'tags' }\n         * // }\n         * }\n         * ```\n         *\n         * @member {Object<String,TaskItemOptions>} bodyItems\n         * @category Task content\n         */\n        /**\n         * Items to add to each card's body.\n         *\n         * Supplied keys are used to bind to a field on the {@link TaskBoard/model/TaskModel task record}, supplied\n         * values are used to configure the {@link TaskBoard/view/item/TaskItem#configs items}.\n         *\n         * You are always required to supply a `type`, see the docs for each item type for more information on available\n         * configs.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    bodyItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         * ```\n         *\n         * For more information, see the {@link #class-description class description} above.\n         *\n         * @config {Object<String,TaskItemOptions>}\n         * @category Task content\n         */\n        bodyItems : {\n            value : {\n                text : { type : 'text', field : 'description' }\n            },\n            $config : {\n                merge : 'items'\n            }\n        },\n        /**\n         * Items in card footer.\n         *\n         * As an object keyed by field names, values are {@link TaskBoard/view/item/TaskItem#configs TaskItem configs}.\n         *\n         * Reassigning this property merges the supplied object with the configured items:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    footerItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         *\n         * taskBoard.footerItems = {\n         *     status : { hidden : true },\n         *     tags   : { type : 'tags' }\n         * };\n         *\n         * // Results in:\n         * //\n         * // footerItems = {\n         * //     status : { type : 'text', hidden: true }\n         * //     tags   : { type : 'tags' }\n         * // }\n         * }\n         * ```\n         *\n         * @member {Object<String,TaskItemOptions>} footerItems\n         * @category Task content\n         */\n        /**\n         * Items to add to each card's footer.\n         *\n         * Supplied keys are used to bind to a field on the {@link TaskBoard/model/TaskModel task record}, supplied\n         * values are used to configure the {@link TaskBoard/view/item/TaskItem#configs items}.\n         *\n         * You are always required to supply a `type`, see the docs for each item type for more information on available\n         * configs.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    footerItems : {\n         *        status : { type : 'text' }\n         *    }\n         * });\n         * ```\n         *\n         * For more information, see the {@link #class-description class description} above.\n         *\n         * @config {Object<String,TaskItemOptions>}\n         * @category Task content\n         */\n        footerItems : {\n            value : {\n                resourceAvatars : { type : 'resourceAvatars', field : 'resources' }\n            },\n            $config : {\n                merge : 'items'\n            }\n        },\n        /**\n         * A function called on each render before adding items to a tasks card, allowing runtime manipulation of them.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     processItems({ bodyItems, taskRecord }) {\n         *        // Remove the progress item for done tasks\n         *        if (taskRecord.status === 'done') {\n         *            bodyItems.progress = null;\n         *        }\n         *     }\n         * });\n         * ```\n         *\n         * NOTE: The function is only intended for manipulating the passed items, you should not update the passed\n         * `taskRecord` in it since updating records triggers another round of rendering.\n         *\n         * @config {Function}\n         * @param {Object} context\n         * @param {Object<String,TaskItemOptions>} context.headerItems Item config objects for the task header, keyed by ref\n         * @param {Object<String,TaskItemOptions>} context.bodyItems Item config objects for the task body, keyed by ref\n         * @param {Object<String,TaskItemOptions>} context.footerItems Item config objects for the task footer, keyed by ref\n         * @param {TaskBoard.model.TaskModel} context.taskRecord Record representing task to be rendered\n         * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n         * @category Task content\n         */\n        processItems : null\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions\n    changeProcessItems(processItems) {\n        ObjectHelper.assertFunction(processItems, 'processItems');\n        return processItems;\n    }\n    //endregion\n    // region Configuring items\n    mergeItems(items, old) {\n        if (old && items) {\n            items = ObjectHelper.mergeItems(old, items);\n        }\n        return items;\n    }\n    // Needed to allow reconfiguring on the fly (for responsive)\n    changeHeaderItems(items, old) {\n        ObjectHelper.assertObject(items, 'headerItems');\n        return this.mergeItems(items, old);\n    }\n    // Needed to allow reconfiguring on the fly (for responsive)\n    changeBodyItems(items, old) {\n        ObjectHelper.assertObject(items, 'bodyItems');\n        return this.mergeItems(items, old);\n    }\n    // Needed to allow reconfiguring on the fly (for responsive)\n    changeFooterItems(items, old) {\n        ObjectHelper.assertObject(items, 'footerItems');\n        return this.mergeItems(items, old);\n    }\n    //endregion\n    //region Rendering\n    // Render items to header, body or footer of the supplied task\n    renderItems(taskRecord, items, target, cardSize) {\n        for (const key in items) {\n            const config = items[key];\n            if (config && !config.hidden) {\n                // Defaults to use the key as the field, but allows overriding it using the field config\n                if (!('field' in config)) {\n                    if (key.includes('>')) {\n                        [config.field] = key.split(beforeRe);\n                    }\n                    else if (key.includes('<')) {\n                        [, config.field] = key.split(afterRe);\n                    }\n                    else {\n                        config.field = key;\n                    }\n                }\n                const\n                    { field } = config,\n                    value     = taskRecord.getValue(field);\n                // Most fields render nothing if they have no value, some are excluded from that logic (separator etc)\n                if (value != null || fieldLess[config.type] || config.renderNull) {\n                    const\n                        // TaskItem implements factoryable, we are not using instances but rather static items to avoid\n                        // creating one instance per card. Thus we only use the lookup functionality of factoryable\n                        item      = TaskItem.resolveType(config.type),\n                        typeCls   = `b-taskboard-${StringHelper.hyphenate(config.type)}`,\n                        // Base DomConfig, shared by all task items\n                        domConfig = {\n                            class : {\n                                'b-taskboard-taskitem' : 1,\n                                [typeCls]              : 1,\n                                [config.cls]           : config.cls,\n                                'b-editable'           : !taskRecord.readOnly && item.getEditorConfig({ config, item })\n                            },\n                            dataset : {\n                                role : `item-${field}`,\n                                field,\n                                ref  : key\n                            },\n                            elementData : {\n                                item,\n                                taskRecord,\n                                config\n                            },\n                            style : {\n                                order : config.order,\n                                style : config.style\n                            }\n                        },\n                        // Call items (static) renderer, further populating the DomConfig from above\n                        result    = item.render({ taskBoard : this, domConfig, value, config, taskRecord, cardSize });\n                    // Returning false from an items renderer prevents it from being shown\n                    if (result !== false) {\n                        target.children[key] = domConfig;\n                    }\n                }\n            }\n        }\n    }\n    // Hook into card rendering\n    populateCard(args) {\n        super.populateCard?.(args);\n        const\n            me                                   = this,\n            { processItems }                     = me,\n            { taskRecord, cardConfig, cardSize } = args,\n            {\n                headerItems : sizeHeaderItems,\n                bodyItems   : sizeBodyItems,\n                footerItems : sizeFooterItems\n            }                                    = cardSize || {},\n            { header, body, footer }             = cardConfig.children;\n        let { headerItems, bodyItems, footerItems } = me;\n        // Items are shared between all cards, clone before processing to only affect the set for this card\n        if (sizeHeaderItems || processItems) {\n            headerItems = ObjectHelper.clone(headerItems);\n        }\n        if (sizeBodyItems || processItems) {\n            bodyItems = ObjectHelper.clone(bodyItems);\n        }\n        if (sizeFooterItems || processItems) {\n            footerItems = ObjectHelper.clone(footerItems);\n        }\n        // Apply any card size specific items\n        sizeHeaderItems && ObjectHelper.merge(headerItems, sizeHeaderItems);\n        sizeBodyItems && ObjectHelper.merge(bodyItems, sizeBodyItems);\n        sizeFooterItems && ObjectHelper.merge(footerItems, sizeFooterItems);\n        // Allow app a shot at processing the items before they are shown. Can be used to add or remove items and\n        // manipulate configs\n        processItems?.({ headerItems, bodyItems, footerItems, taskRecord, cardSize });\n        // Render items into card header, body and footer\n        me.renderItems(taskRecord, headerItems, header, cardSize);\n        me.renderItems(taskRecord, bodyItems, body, cardSize);\n        me.renderItems(taskRecord, footerItems, footer, cardSize);\n    }\n    //endregion\n    //region Listeners\n    resolveTaskItem(element) {\n        // First look up, if inside an item. Then looks down, in case given a card or similar\n        const taskItemElement = element.closest(taskItemSelector) || element.querySelector(`:scope > * > ${taskItemSelector}, :scope > ${taskItemSelector}`);\n        if (taskItemElement) {\n            return {\n                ...taskItemElement.elementData,\n                element : taskItemElement\n            };\n        }\n        return null;\n    }\n    // Relay clicks to items\n    onTaskClick(args) {\n        const taskItem = this.resolveTaskItem(args.event.target);\n        if (taskItem) {\n            const { config, item  } = taskItem;\n            item.onClick?.({\n                config,\n                ...args\n            });\n        }\n        super.onTaskClick(args);\n    }\n    // Relay double clicks to items\n    onTaskDblClick(args) {\n        const taskItem = this.resolveTaskItem(args.event.target);\n        if (taskItem) {\n            const { config, item  } = taskItem;\n            item.onDblClick?.({\n                config,\n                ...args\n            });\n        }\n        super.onTaskDblClick(args);\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\n/**\n * @module TaskBoard/view/mixin/TaskNavigation\n */\nconst navigationActions = ['navigateDown', 'navigateLeft', 'navigateUp', 'navigateRight', 'activate'];\n/**\n * Mixin that handles keyboard navigation for the TaskBoard.\n *\n * See {@link TaskBoard.view.TaskBoard#keyboard-shortcuts} for information on keyboard navigation.\n *\n * @mixin\n */\nexport default Target => class TaskNavigation extends (Target || Base) {\n    //region Config\n    static $name = 'TaskNavigation';\n    static configurable = {\n        // Documented on TaskBoard\n        keyMap : {\n            ArrowDown  : 'navigateDown',\n            ArrowLeft  : 'navigateLeft',\n            ArrowUp    : 'navigateUp',\n            ArrowRight : 'navigateRight',\n            Enter      : 'activate'\n        },\n        navigateable : true,\n        /**\n         * Configure with `true` to change the default behaviour of keyboard navigation from moving focus to selecting\n         * tasks:\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *     selectOnNavigation : true\n         * });\n         * ```\n         *\n         * @config {Boolean|String}\n         * @default\n         * @category Selection\n         */\n        selectOnNavigation : false\n    };\n    get widgetClass() {}\n    //endregion\n    //region Utility\n    getTaskNear(x, y) {\n        const\n            { documentRoot } = this,\n            gap              = DomHelper.measureSize(\n                this.css.cardGap || '1em',\n                this.bodyElement.querySelector('.b-taskboard-swimlane-body .b-taskboard-column')\n            );\n        let task = documentRoot.elementFromPoint(x, y)?.closest('.b-taskboard-card');\n        // Nothing there, might have hit a gap, look up\n        if (!task) {\n            task = documentRoot.elementFromPoint(x, y - gap)?.closest('.b-taskboard-card');\n        }\n        // Still nothing, look down\n        if (!task) {\n            task = documentRoot.elementFromPoint(x, y + gap)?.closest('.b-taskboard-card');\n        }\n        return task;\n    }\n    //endregion\n    //region Navigation\n    focusAndOptionallySelect(taskElement, forceSelect) {\n        if (taskElement) {\n            const\n                me                   = this,\n                currentlyFocusedTask = me.resolveTaskRecord(document.activeElement);\n            // If a task is focused but not selected and we navigate away from it holding SPACE we want that task to\n            // become selected in addition to the newly focused task\n            if (forceSelect && currentlyFocusedTask && !me.isSelected(currentlyFocusedTask)) {\n                me.selectTask(currentlyFocusedTask, true);\n            }\n            // When configured with `selectOnNavigation : true` we should move the selection. If user holds SHIFT we\n            // should always extend it\n            if (me.selectOnNavigation || forceSelect) {\n                const taskToFocus = me.resolveTaskRecord(taskElement);\n                // Newly focused task is not selected, always select it (optionally extending the selection)\n                if (!me.isSelected(taskToFocus)) {\n                    me.selectTask(taskToFocus, forceSelect);\n                }\n                // Newly focused task already selected, deselect current if SHIFT is pressed (to allow extending and\n                // shrinking selection holding SHIFT)\n                else if (forceSelect) {\n                    me.deselectTask(currentlyFocusedTask);\n                }\n            }\n            // Always move focus\n            taskElement.focus();\n        }\n    }\n    // To task at same Y in next column\n    navigateNext(keyEvent, select) {\n        const\n            me                                           = this,\n            { taskRecord, swimlaneRecord, columnRecord } = keyEvent.taskBoardData,\n            taskElement                                  = me.getTaskElement(taskRecord);\n        let\n            found = null,\n            nextColumnRecord = columnRecord;\n        do {\n            nextColumnRecord = me.columns.getNext(nextColumnRecord, true);\n            if (!nextColumnRecord.hidden) {\n                const\n                    nextColumnElement = me.getSwimlaneColumnElement(swimlaneRecord, nextColumnRecord),\n                    x                 = Rectangle.from(nextColumnElement, null, true).center.x,\n                    y                 = Rectangle.from(taskElement, null, true).center.y;\n                found = me.getTaskNear(x, y);\n            }\n        }\n        while (!found && nextColumnRecord !== columnRecord);\n        me.focusAndOptionallySelect(found, select);\n    }\n    // To task at same Y in prev column\n    navigatePrev(keyEvent, select) {\n        const\n            me                                           = this,\n            { taskRecord, swimlaneRecord, columnRecord } = keyEvent.taskBoardData,\n            taskElement                                  = me.getTaskElement(taskRecord);\n        let\n            found = null,\n            prevColumnRecord = columnRecord;\n        do {\n            prevColumnRecord = me.columns.getPrev(prevColumnRecord, true);\n            if (!prevColumnRecord.hidden) {\n                const\n                    prevColumnElement = me.getSwimlaneColumnElement(swimlaneRecord, prevColumnRecord),\n                    x                 = Rectangle.from(prevColumnElement, null, true).center.x,\n                    y                 = Rectangle.from(taskElement, null, true).center.y;\n                found = me.getTaskNear(x, y);\n            }\n        }\n        while (!found && prevColumnRecord !== columnRecord);\n        me.focusAndOptionallySelect(found, select);\n    }\n    // Right navigates to next column for LTR and previous for RTL\n    navigateRight(event, select = false) {\n        this['navigate' + (this.rtl ? 'Prev' : 'Next')](event, select);\n    }\n    // Left navigates to previous column for LTR and next for RTL\n    navigateLeft(event, select = false) {\n        this['navigate' + (this.rtl ? 'Next' : 'Prev')](event, select);\n    }\n    // Find next task in same column (might be in next swimlane)\n    navigateDown(keyEvent, select = false) {\n        const\n            { taskRecord } = keyEvent.taskBoardData,\n            nextTask       = this.getNextTask(taskRecord, true);\n        this.focusAndOptionallySelect(this.getTaskElement(nextTask), select);\n    }\n    // Find prev task in same column (might be in prev swimlane)\n    navigateUp(keyEvent, select = false) {\n        const\n            { taskRecord } = keyEvent.taskBoardData,\n            prevTask       = this.getPreviousTask(taskRecord, true);\n        this.focusAndOptionallySelect(this.getTaskElement(prevTask), select);\n    }\n    // Activate (show editor)\n    activate(event) {\n        const { taskRecord } = this.resolveEvent(event);\n        // Only care about ENTER on a task\n        taskRecord && this.trigger('activateTask', { taskRecord, event });\n    }\n    isActionAvailable({ action, event }) {\n        const taskBoardData = this.resolveEvent(event);\n        event.taskBoardData = taskBoardData;\n        // Block activating if a task item has focus (eg. a button in the card)\n        if (action === 'activate' && taskBoardData.taskRecord && event.target !== this.getTaskElement(taskBoardData.taskRecord)) {\n            return false;\n        }\n        return Boolean((this.navigateable || !navigationActions.includes(action)) && taskBoardData?.taskRecord);\n    }\n    //endregion\n};\n", "import Base from '../../../Core/Base.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module TaskBoard/view/mixin/TaskSelection\n */\n/**\n * Mixin that handles card selection for the TaskBoard.\n *\n * By default tasks can be selected using mouse clicks and the keyboard. To enable marquee selection, see\n * {@link TaskBoard.feature.TaskDragSelect}.\n *\n * ## Mouse selection\n *\n * Select and deselect cards using the mouse, using a modifier key to do multi selection:\n *\n * * Click on a card to focus and select it, deselecting any previously selected card.\n * * `CMD`/`CTRL` + click on a card to add or remove it from the selection.\n *\n * See {@link TaskBoard.view.TaskBoard#keyboard-shortcuts} for more information on selecting cards using the keyboard.\n *\n * @mixin\n */\nexport default Target => class TaskSelection extends (Target || Base) {\n    //region Config\n    static $name = 'TaskSelection';\n    static configurable = {\n        /**\n         * Selected tasks.\n         * @prp {TaskBoard.model.TaskModel[]} selectedTasks\n         * @category Common\n         */\n        selectedTasks : [],\n        /**\n         * A template method (empty by default) allowing you to control if a task can be selected or not.\n         *\n         * ```javascript\n         * new TaskBoard({\n         *     isTaskSelectable(taskRecord) {\n         *         return taskRecord.status !== 'done';\n         *     }\n         * })\n         * ```\n         *\n         * @param {TaskBoard.model.TaskModel} taskRecord The task record\n         * @returns {Boolean} `true` if the task can be selected, otherwise `false`\n         * @prp {Function}\n         * @category Selection\n         */\n        isTaskSelectable : null,\n        keyMap : {\n            ' '                : 'keyboardSelect',\n            'Ctrl+ '           : 'keyboardToggleSelect',\n            'Shift+ArrowDown'  : 'selectDown',\n            'Shift+ArrowLeft'  : 'selectLeft',\n            'Shift+ArrowUp'    : 'selectUp',\n            'Shift+ArrowRight' : 'selectRight'\n        }\n    };\n    get widgetClass() {}\n    //endregion\n    //region Type assertions\n    changeSelectedTasks(selectedTasks) {\n        ObjectHelper.assertArray(selectedTasks, 'selectedTasks');\n        return selectedTasks.filter(task => this.isTaskSelectable?.(task) !== false);\n    }\n    //endregion\n    //region Programmatic selection\n    toggleTaskSelection(taskRecord, add = false, forceSelect = null) {\n        const me = this;\n        // Toggle\n        if (forceSelect == null) {\n            if (me.isSelected(taskRecord)) {\n                // Clicked on a selected task without modifier key, select only it\n                if (!add) {\n                    me.selectTask(taskRecord, false);\n                }\n                // Using modifier key, deselect instead\n                else {\n                    me.deselectTask(taskRecord);\n                }\n            }\n            else {\n                me.selectTask(taskRecord, add);\n            }\n        }\n        // Force select\n        else if (forceSelect) {\n            me.selectTask(taskRecord, add);\n        }\n        // Force deselect\n        else {\n            me.deselectTask(taskRecord);\n        }\n    }\n    /**\n     * Select the supplied task, deselecting any previously selected by default.\n     * @param {TaskBoard.model.TaskModel} taskRecord Task to select\n     * @param {Boolean} [add] Specify `true` to add to selection instead of replacing it\n     * @category Selection\n     */\n    selectTask(taskRecord, add = false) {\n        const\n            { selectedTasks } = this,\n            event             = {\n                action : 'select',\n                select : [taskRecord]\n            };\n        // Abort if not selectable\n        if (this.isTaskSelectable?.(taskRecord) === false) {\n            return;\n        }\n        if (!add) {\n            event.deselect = selectedTasks.slice();\n            selectedTasks.length = 0;\n        }\n        ArrayHelper.include(selectedTasks, taskRecord);\n        this.triggerSelectionChange(event);\n        this.recompose();\n    }\n    /**\n     * Deselect the supplied task.\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @category Selection\n     */\n    deselectTask(taskRecord) {\n        ArrayHelper.remove(this.selectedTasks, taskRecord);\n        this.triggerSelectionChange({\n            action   : 'deselect',\n            deselect : [taskRecord]\n        });\n        this.recompose();\n    }\n    /**\n     * Deselect all tasks.\n     * @category Selection\n     */\n    deselectAll() {\n        const { selectedTasks } = this;\n        if (selectedTasks.length) {\n            const deselect = selectedTasks.slice();\n            selectedTasks.length = 0;\n            this.triggerSelectionChange({\n                action : 'deselect',\n                deselect\n            });\n            this.recompose();\n        }\n    }\n    /**\n     * Check if the supplied task is selected or not\n     * @param {TaskBoard.model.TaskModel} taskRecord\n     * @returns {Boolean} Returns `true` if it is selected, `false` if not\n     * @category Selection\n     */\n    isSelected(taskRecord) {\n        return this.selectedTasks.includes(taskRecord);\n    }\n    triggerSelectionChange(event) {\n        /**\n         * Triggered when task selection changes.\n         *\n         * @event selectionChange\n         * @param {TaskBoard.view.TaskBoard} source TaskBoard instance\n         * @param {'select'|'deselect'} action Either 'select' or 'deselect', depending on operation\n         * @param {TaskBoard.model.TaskModel[]} selection All currently selected tasks\n         * @param {TaskBoard.model.TaskModel[]} select Tasks selected by the operation\n         * @param {TaskBoard.model.TaskModel[]} deselect Tasks deselected by the operation\n         */\n        this.trigger('selectionChange', Object.assign({\n            selection : this.selectedTasks,\n            select    : [],\n            deselect  : []\n        }, event));\n    }\n    //endregion\n    //region Listeners\n    onTaskClick(bryntumEvent) {\n        super.onTaskClick(bryntumEvent);\n        const { event, taskRecord } = bryntumEvent;\n        if (!event.defaultPrevented) {\n            this.toggleTaskSelection(taskRecord, event.ctrlKey);\n        }\n    }\n    keyboardSelect(keyEvent) {\n        if (!DomHelper.isEditable(keyEvent.target)) {\n            const { taskRecord } = this.resolveEvent(keyEvent);\n            if (taskRecord) {\n                this.toggleTaskSelection(taskRecord, false);\n                return true;\n            }\n        }\n        return false;\n    }\n    keyboardToggleSelect(keyEvent) {\n        const { taskRecord } = this.resolveEvent(keyEvent);\n        if (taskRecord) {\n            this.toggleTaskSelection(taskRecord, true);\n        }\n    }\n    onClick(event) {\n        super.onClick(event);\n        if (!event.taskRecord && this.navigateable) {\n            this.deselectAll();\n        }\n    }\n    selectUp(event) {\n        this.navigateUp(event, true);\n    }\n    selectDown(event) {\n        this.navigateDown(event, true);\n    }\n    selectLeft(event) {\n        this.navigateLeft(event, true);\n    }\n    selectRight(event) {\n        this.navigateRight(event, true);\n    }\n    //endregion\n    //region Rendering\n    populateCard(args) {\n        super.populateCard?.(args);\n        const { taskRecord, cardConfig } = args;\n        cardConfig.class['b-selected'] = this.isSelected(taskRecord);\n    }\n    populateBody(args) {\n        super.populateBody?.(args);\n        const { bodyConfig } = args;\n        bodyConfig.class['b-has-selection'] = Boolean(this.selectedTasks.length);\n    }\n    //endregion\n};\n", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/ImageItem\n */\n/**\n * Item displaying an image.\n *\n * Loaded from the configured {@link #config-field}, optionally prepended with a {@link #config-baseUrl}.\n *\n * {@inlineexample TaskBoard/view/item/ImageItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype image\n */\nexport default class ImageItem extends TaskItem {\n    static $name = 'ImageItem';\n    static type = 'image';\n    /**\n     * Url prepended to this items value.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *        picture : { type : 'image', baseUrl : 'images/' }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [\n     *            { id : 1, name : 'Task #1', picture : 'photo.jpg' },\n     *            { id : 2, name : 'Task #2', picture : 'image.jpg' }\n     *        ]\n     *    }\n     * });\n     *\n     * // Card for task #1 will render image \"images/photo.jpg\"\n     * // Card for task #2 will render image \"images/image.jpg\"\n     * ```\n     *\n     * @config {String} baseUrl\n     * @category Common\n     */\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * ImageItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n    static defaultEditor = null;\n    static render({ domConfig, value, config }) {\n        // Skip drawing when `image === false` or not assigned\n        if (value) {\n            Object.assign(domConfig, {\n                tag       : 'img',\n                src       : (config.baseUrl || '') + value,\n                draggable : false\n            });\n        }\n    }\n}\nImageItem.initClass();\nImageItem._$name = 'ImageItem';", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/JsxItem\n */\n/**\n * Item displaying content generated by a React (JSX) component\n *\n * {@note}JsxItem can only be used in React applications.{/@note}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype jsx\n */\nexport default class JsxItem extends TaskItem {\n    static $name = 'JsxItem';\n    static type = 'jsx';\n    /**\n     * Function used to generate JSX item content.\n     *\n     * Return a React Element (JSX) from the function:\n     *\n     * ```javascript\n     * import MyJsxItem from './MyJsxItem.js';\n     *\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *        prio : {\n     *          type : 'jsx',\n     *          jsx  : ({ taskRecord }) => <MyJsxItem taskRecord={taskRecord} />\n     *        }\n     *    }\n     * });\n     * ```\n     *\n     * @config {Function} jsx\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {JsxItemConfig} config Item config\n     * @param {Object} value Value of the configured field\n     * @returns React Element (JSX)\n     * @category Common\n     */\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * JsxItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n    static defaultEditor = null;\n    static render({ domConfig, config, taskRecord, value }) {\n        domConfig.retainChildren = true;\n        domConfig.children = [config.jsx({ value, taskRecord, config })];\n    }\n}\nJsxItem.initClass();\nJsxItem._$name = 'JsxItem';", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/ProgressItem\n */\n/**\n * Item displaying a progress bar.\n *\n * Progress is determined by the value of the configured {@link #config-field}. A max value (defaults to 100) can be\n * configured using the {@link #config-max} config.\n *\n * {@inlineexample TaskBoard/view/item/ProgressItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype progress\n */\nexport default class ProgressItem extends TaskItem {\n    static $name = 'ProgressItem';\n    static type = 'progress';\n    static configurable = {\n        /**\n         * Max value, at which the bar is full.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    bodyItems : {\n         *        progress : { type : 'progress', max : 10 }\n         *    },\n         *\n         *    project : {\n         *        tasksData : [\n         *            { id : 1, name : 'Task #1', progress : 9 }\n         *        ]\n         *    }\n         * });\n         *\n         * // Task #1 bar is 9/10 filled\n         * ```\n         *\n         * @config {Number} max\n         * @default 100\n         * @category Common\n         */\n    };\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * ProgressItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n    static defaultEditor = null;\n    static render({ domConfig, value, config }) {\n        const percent = Math.round(100 * value / (config.max || 100)) + '%';\n        domConfig.children = [\n            {\n                class   : 'b-taskboard-progress-outline',\n                dataset : {\n                    percent\n                },\n                children : [\n                    {\n                        class : 'b-taskboard-progress-progress',\n                        style : {\n                            width : percent\n                        },\n                        dataset : {\n                            percent\n                        }\n                    }\n                ]\n            }\n        ];\n        domConfig.dataset.percent = domConfig.dataset.btip = percent;\n    }\n}\nProgressItem.initClass();\nProgressItem._$name = 'ProgressItem';", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/RatingItem\n */\n/**\n * Item displaying a star rating.\n *\n * Rating is determined by the value of the configured {@link #config-field}. A max rating can be configured using the\n * {@link #config-max} config.\n *\n * {@inlineexample TaskBoard/view/item/RatingItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype rating\n */\nexport default class RatingItem extends TaskItem {\n    static $name = 'RatingItem';\n    static type = 'rating';\n    /**\n     * Max rating.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *       grade : { type : 'ratingitem', max : 5 }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [\n     *            { id : 1, name : 'Task #1', grade : 3 }\n     *        ]\n     *    }\n     * });\n     *\n     * // Card for task #1 will render 3 full stars and 2 faded,\n     * // for a total of 5 stars\n     * ```\n     *\n     * @config {Number} max\n     * @category Common\n     */\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * RatingItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n    static defaultEditor = null;\n    static render({ domConfig, value, config }) {\n        const { max = value } = config;\n        domConfig.children = [];\n        for (let i = 0; i < max; i++) {\n            domConfig.children.push({\n                tag   : 'i',\n                class : {\n                    'b-icon b-icon-star' : 1,\n                    'b-filled'           : i < value\n                }\n            });\n        }\n    }\n}\nRatingItem.initClass();\nRatingItem._$name = 'RatingItem';", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/SeparatorItem\n */\n/**\n * Item displaying a horizontal divider.\n *\n * {@inlineexample TaskBoard/view/item/SeparatorItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype separator\n */\nexport default class SeparatorItem extends TaskItem {\n    static $name = 'SeparatorItem';\n    static type = 'separator';\n    /**\n     * @hideconfigs editor\n     */\n    static defaultEditor = null;\n    static render({ domConfig }) {\n        domConfig.tag = 'hr';\n    }\n}\nSeparatorItem.initClass();\nSeparatorItem._$name = 'SeparatorItem';", "import Combo from '../../Core/widget/Combo.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/TagCombo\n */\n/**\n * A combo for picking tags. Works well to edit fields displayed by a {@link TaskBoard/view/item/TagsItem}, if data\n * uses strings to represent tags:\n *\n * {@inlineexample TaskBoard/widget/TagCombo.js}\n *\n * Consumes and outputs and array of strings, or if configured with a {@link #config-separator} a single string.\n *\n * If not seeded with any items/store, it tries to extract tags from the task store by collecting distinct values for\n * the field it is linked to (by {@link #config-name}).\n *\n * @extends Core/widget/Combo\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype tagcombo\n * @inputfield\n */\nexport default class TagCombo extends Combo.mixin(TaskBoardLinked) {\n    static $name = 'TagCombo';\n    static type = 'tagcombo';\n    static configurable = {\n        multiSelect : true,\n        editable    : false,\n        /**\n         * Separator used to split a string into tags. Required if data format uses a single string to represent tags.\n         * @config {String}\n         * @default\n         */\n        separator : ',',\n        picker : {\n            cls : 'b-tag-picker'\n        },\n        chipView : {\n            closable : false\n        }\n    };\n    afterConfigure() {\n        const me = this;\n        // Populate with tags from the task store\n        if (!me.store?.count && me.taskBoard && me.name) {\n            const\n                { name, separator } = me,\n                tags                = [];\n            me.taskBoard.project.taskStore.forEach(task => {\n                const taskTags = task[name];\n                if (taskTags) {\n                    if (typeof taskTags === 'string') {\n                        tags.push(...taskTags.split(separator));\n                    }\n                    else {\n                        tags.push(...taskTags);\n                    }\n                }\n            });\n            me.items = [...new Set(tags)].sort();\n        }\n    }\n    changeValue(value, old) {\n        this.$expectsString = false;\n        if (this.separator && typeof value === 'string') {\n            value = value.split(this.separator);\n            this.$expectsString = true;\n        }\n        super.changeValue(value, old);\n    }\n    get value() {\n        const value = super.value;\n        if (this.$expectsString) {\n            return value.join(this.separator);\n        }\n        return value;\n    }\n    set value(value) {\n        super.value = value;\n    }\n}\nTagCombo.initClass();\nTagCombo._$name = 'TagCombo';", "import TaskItem from './TaskItem.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport '../../widget/TagCombo.js';\n/**\n * @module TaskBoard/view/item/TagsItem\n */\n/**\n * Item displaying tags, either from string split into tags, an array of strings or by plucking a value from an array of\n * objects.\n *\n * Using a string, split into tags using the configured {@link #config-separator}:\n *\n * {@inlineexample TaskBoard/view/item/TagsItem.js}\n *\n * Using an array of strings, each entry is turned into a tag:\n *\n * {@inlineexample TaskBoard/view/item/TagsItemStringArray.js}\n *\n * Using an array of objects, gives you the most control over the tags. Requires configuring a\n * {@link #config-textProperty} and optionally a {@link #config-clsProperty}:\n *\n * {@inlineexample TaskBoard/view/item/TagsItemObjectArray.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype tags\n */\nexport default class TagsItem extends TaskItem {\n    static $name = 'TagsItem';\n    static type = 'tags';\n    /**\n     * Property used to determine the text for the tag. It is plucked from an array of objects that is used as the value\n     * for this item.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *       tags : { type : 'TagsItem', textProperty : 'title' }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [{\n     *            id : 1,\n     *            name : 'Issue #1',\n     *            tags : [\n     *                { title : 'bug', color : 'orange' },\n     *                { title : 'important', color : 'red' }\n     *            ]\n     *        }]\n     *    }\n     * });\n     *\n     * // Card for Issue #1 will render 2 tags, 'bug' and 'important'\n     * ```\n     *\n     * @config {String} textProperty\n     * @category Common\n     */\n    /**\n     * Property used to add a CSS class to each tag. It is plucked from an array of objects that is used as the value\n     * for this item.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *       tags : { type : 'TagsItem', clsProperty : 'color' }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [{\n     *            id : 1,\n     *            name : 'Issue #1',\n     *            tags : [\n     *                { title : 'bug', color : 'orange' },\n     *                { title : 'important', color : 'red' }\n     *            ]\n     *        }]\n     *    }\n     * });\n     *\n     * // Card for Issue #1 will render 2 tags, one with cls 'orange' and one with cls 'red'\n     * ```\n     *\n     * @config {String} clsProperty\n     * @category Common\n     */\n    /**\n     * Property used to split a value string into tags.\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *       tags : { type : 'TagsItem', separator : ';' }\n     *    },\n     *\n     *    project : {\n     *        tasksData : [{\n     *            id : 1,\n     *            name : 'Issue #1',\n     *            tags : 'bug;important'\n     *        }]\n     *    }\n     * });\n     *\n     * // Card for Issue #1 will render 2 tags, 'bug' and 'important'\n     * ```\n     *\n     * @config {String} separator\n     * @default ,\n     * @category Common\n     */\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * Defaults to use a {@link TaskBoard.widget.TagCombo}.\n     *\n     * @config {String|Object} editor\n     * @default tagcombo\n     * @category Common\n     */\n    static defaultEditor = { type : 'tagcombo', pickerWidth : '10em' };\n    static render({ domConfig, value, config }) {\n        let tags;\n        if (value) {\n            if (typeof value === 'string') {\n                tags = value.split(config.separator || ',').map(str => ({ text : str }));\n            }\n            else if (Array.isArray(value)) {\n                tags = value.map(entry => {\n                    if (typeof entry === 'string') {\n                        return { text : entry };\n                    }\n                    else {\n                        return {\n                            text : config.textProperty && entry[config.textProperty],\n                            cls  : config.clsProperty && entry[config.clsProperty]\n                        };\n                    }\n                });\n            }\n            if (tags) {\n                domConfig.children = tags.map(tag => {\n                    const cls = ('cls' in tag) ? tag.cls : DomHelper.makeValidId(tag.text, '-').toLowerCase();\n                    return {\n                        class : {\n                            'b-taskboard-tags-tag' : 1,\n                            [cls]                  : Boolean(cls)\n                        },\n                        text : tag.text\n                    };\n                });\n            }\n        }\n    }\n}\nTagsItem.initClass();\nTagsItem._$name = 'TagsItem';", "import ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/TemplateItem\n */\n/**\n * Item displaying content generated by a template function, see {@link #config-template}\n *\n * {@inlineexample TaskBoard/view/item/TemplateItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype template\n */\nexport default class TemplateItem extends TaskItem {\n    static $name = 'TemplateItem';\n    static type = 'template';\n    /**\n     * Template function used to generate task content.\n     *\n     * Return an HTML string or a DomConfig object from the function:\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    bodyItems : {\n     *        prio : {\n     *          type     : 'template',\n     *          template : ({ taskRecord }) => `<i class=\"b-fa b-fa-tarffic-light\"></i> ${taskRecord.prio}`\n     *        }\n     *    }\n     * });\n     * ```\n     *\n     * @config {Function} template\n     * @param {TaskBoard.model.TaskModel} taskRecord Task record\n     * @param {TemplateItemConfig} config Item config\n     * @param {Object} value Value of the configured field\n     * @returns {String|DomConfig|DomConfig[]} HTML string, DomConfig or DomConfig array\n     * @category Common\n     */\n    /**\n     * Widget type or config to use as the editor for this item. Used in the inline task editor.\n     *\n     * TemplateItems are un-editable by default.\n     *\n     * @config {String|Object} editor\n     * @default null\n     * @category Common\n     */\n    /**\n     * Specify as `true` to render the template item even if the backing field's value is `null` or `undefined`. Useful\n     * for example to display some custom string for null values (\"Empty\", \"Unset\" etc).\n     *\n     * ```javascript\n     * const taskBoard = new TaskBoard({\n     *    footerItems : {\n     *        category : {\n     *          type       : 'template',\n     *          renderNull : true,\n     *          template   : ({ value }) => value ? value : 'Empty'\n     *        }\n     *    }\n     * });\n     * ```\n     *\n     * @config {Boolean} renderNull\n     * @default false\n     * @category Common\n     */\n    static defaultEditor = null;\n    static render({ domConfig, value, config, taskRecord }) {\n        const html = config.template({ taskRecord, config, value });\n        if (typeof html === 'string') {\n            domConfig.html = html;\n        }\n        else if (ObjectHelper.isObject(html)) {\n            ObjectHelper.merge(domConfig, html);\n        }\n        else if (Array.isArray(html)) {\n            domConfig.children = html;\n        }\n    }\n}\nTemplateItem.initClass();\nTemplateItem._$name = 'TemplateItem';", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/TodoListItem\n */\n/**\n * Item displaying a list of todo items with associated checkboxes. It allows users to toggle the checkbox for each item\n * on the card to indicate if that item is completed or not. By adding a {@link TaskBoard/widget/TodoListField} to the\n * task editor users can also add, edit and remove todo items.\n *\n * {@inlineexample TaskBoard/view/item/TodoListItem.js}\n *\n * It consumes an array of objects representing todo items. For this item to work as indented, that array has to be\n * supplied by a task field using `type : 'array'`. It is also important to configure the {@link #config-textField} and\n * {@link #config-checkedField} to match properties of the objects in that array. This snippet illustrates a possible\n * setup:\n *\n * ```javascript\n * // Custom task model with a todo field of array type\n * class MyTask extends TaskModel {\n *     static fields = [\n *        { name : 'todo', type : 'array' }\n *     ];\n * }\n *\n * const taskBoard = new TaskBoard({\n *    project : {\n *        // Use the custom task model defined above\n *        taskModelClass : MyTask,\n *\n *        tasksData : [\n *            {\n *              id : 1,\n *              name : 'Order software',\n *              // The custom field, accepts an array\n *              todo : [\n *                  { title : 'Sketchup Pro', done : false },\n *                  { title : 'AutoCAD LT', done : true },\n *                  { title : 'Inventor', done : false }\n *              ]\n *            }\n *        ]\n *    },\n *\n *    bodyItems : {\n *        todo : {\n *            // Add a todo list item to card body\n *            type         : 'todoList',\n *            // Map text to the \"title\" field\n *            textField    : 'text',\n *            // Map checkbox to the \"done\" field\n *            checkedField : 'done'\n *        }\n *    }\n * });\n * ```\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype todoList\n */\nexport default class TodoListItem extends TaskItem {\n    static $name = 'TodoListItem';\n    static type = 'todoList';\n    /**\n     * Name of a property on a todo item to display as its text.\n     *\n     * @config {String} textField\n     * @category Common\n     * @default text\n     */\n    /**\n     * Name of a property on a todo item to use for the checkbox. The property is expected to be a boolean.\n     *\n     * @config {String} checkedField\n     * @category Common\n     * @default checked\n     */\n    /**\n     * Name of a property on a todo item whose value will be added as a CSS class to the todo item.\n     *\n     * @config {String} clsField\n     * @category Common\n     * @default cls\n     */\n    // private for now:\n    // checkedIcon\n    // uncheckedIcon\n    /**\n     * @hideconfigs editor\n     */\n    static defaultEditor = null;\n    static render({ domConfig, value, config, taskRecord }) {\n        if (value) {\n            const {\n                textField = 'text',\n                checkedField = 'checked',\n                clsField = 'cls',\n                checkedIcon = 'b-icon b-icon-checked',\n                uncheckedIcon = 'b-icon b-icon-unchecked'\n            } = config;\n            if (this.firstRender !== false) {\n                const dataField = taskRecord.getFieldDefinition(config.field);\n                if (!dataField.isArrayDataField) {\n                    throw new Error('TodoListItem has to be mapped to a field with `type : \"array\"`');\n                }\n            }\n            domConfig.children = value.map((todo, index) => ({\n                class : {\n                    'b-taskboard-todolist-todo' : 1,\n                    [todo[clsField]]            : todo[clsField],\n                    'b-checked'                 : todo[checkedField]\n                },\n                children : {\n                    icon : {\n                        tag   : 'i',\n                        class : todo[checkedField] ? checkedIcon : uncheckedIcon\n                    },\n                    text : {\n                        tag  : 'span',\n                        text : todo[textField]\n                    }\n                },\n                elementData : {\n                    index\n                }\n            }));\n            this.firstRender = false;\n        }\n    }\n    static onClick({ source : taskBoard, taskRecord, event, config }) {\n        const element = event.target.closest('.b-taskboard-todolist-todo');\n        if (element && !taskRecord.readOnly) {\n            const\n                { checkedField = 'checked', field } = config,\n                { index }                           = element.elementData,\n                // array fields has to be assigned a new array to detect a change, hence the slice\n                clone                               = taskRecord.getValue(field).slice(),\n                todo                                = clone[index];\n            // Toggle the mapped fields value\n            todo[checkedField] = !todo[checkedField];\n            // Assign the cloned array to the task record\n            taskRecord.setValue(field, clone);\n            taskBoard.trigger('todoToggle', { taskRecord, todo, checked : todo[checkedField], element, event });\n            // Don't want the click to select the task, feels a bit awkward when it does\n            event.preventDefault();\n        }\n    }\n    // Prevent editor from opening when dbl clicking a todo item\n    static onDblClick({ event }) {\n        event.preventDefault();\n    }\n}\nTodoListItem.initClass();\nTodoListItem._$name = 'TodoListItem';", "import LocaleHelper from '../../Core/localization/LocaleHelper.js';\nimport '../../Core/localization/En.js';\nconst locale = {\n    localeName : 'En',\n    localeDesc : 'English (US)',\n    localeCode : 'en-US',\n    GridBase : {\n        loadFailedMessage : 'Data loading failed!',\n        syncFailedMessage : 'Data synchronization failed!'\n    },\n    CrudManagerView : {\n        serverResponseLabel : 'Server response:'\n    },\n    TaskBoard : {\n        column           : 'column',\n        columns          : 'columns',\n        Columns          : 'Columns',\n        swimlane         : 'swimlane',\n        swimlanes        : 'swimlanes',\n        Swimlanes        : 'Swimlanes',\n        task             : 'task',\n        tasks            : 'tasks',\n        addTask          : 'Add L{TaskBoard.task}',\n        cancel           : 'Cancel',\n        changeColumn     : 'Change L{TaskBoard.column}',\n        changeSwimlane   : 'Change L{TaskBoard.swimlane}',\n        collapse         : text => `Collapse ${text}`,\n        color            : 'Color',\n        description      : 'Description',\n        editTask         : 'Edit L{TaskBoard.task}',\n        expand           : text => `Expand ${text}`,\n        filterColumns    : 'Filter L{TaskBoard.columns}',\n        filterSwimlanes  : 'Filter L{TaskBoard.swimlanes}',\n        filterTasks      : 'Filter L{TaskBoard.tasks}',\n        moveColumnLeft   : 'Move L{TaskBoard.column} left',\n        moveColumnRight  : 'Move L{TaskBoard.column} right',\n        name             : 'Name',\n        newTaskName      : 'New L{TaskBoard.task}',\n        removeTask       : 'Remove L{TaskBoard.task}',\n        removeTasks      : 'Remove L{TaskBoard.tasks}',\n        resources        : 'Resources',\n        save             : 'Save',\n        scrollToColumn   : 'Scroll to L{TaskBoard.column}',\n        scrollToSwimlane : 'Scroll to L{TaskBoard.swimlane}',\n        zoom             : 'Zoom'\n    },\n    TodoListField : {\n        add     : 'Add',\n        newTodo : 'New todo'\n    },\n    UndoRedo : {\n        UndoLastAction : 'Undo',\n        RedoLastAction : 'Redo'\n    }\n};\nexport default LocaleHelper.publishLocale(locale);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport Featureable from '../../Core/mixin/Featureable.js';\nimport Pluggable from '../../Core/mixin/Pluggable.js';\nimport State from '../../Core/mixin/State.js';\nimport ScrollManager from '../../Core/util/ScrollManager.js';\nimport Responsive from '../../Core/widget/mixin/Responsive.js';\nimport Styleable from '../../Core/widget/mixin/Styleable.js';\nimport Panel from '../../Core/widget/Panel.js';\nimport CrudManagerView from '../../Scheduler/crud/mixin/CrudManagerView.js';\nimport TaskBoardFeature from '../feature/TaskBoardFeature.js';\nimport ExpandCollapse from './mixin/ExpandCollapse.js';\nimport ResponsiveCards from './mixin/ResponsiveCards.js';\nimport TaskBoardColumns from './mixin/TaskBoardColumns.js';\nimport TaskBoardDom from './mixin/TaskBoardDom.js';\nimport TaskBoardDomEvents from './mixin/TaskBoardDomEvents.js';\nimport TaskBoardScroll from './mixin/TaskBoardScroll.js';\nimport TaskBoardStores from './mixin/TaskBoardStores.js';\nimport TaskBoardSwimlanes from './mixin/TaskBoardSwimlanes.js';\nimport TaskBoardVirtualization from './mixin/TaskBoardVirtualization.js';\nimport TaskItems from './mixin/TaskItems.js';\nimport TaskNavigation from './mixin/TaskNavigation.js';\nimport TaskSelection from './mixin/TaskSelection.js';\nimport '../localization/En.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\n/**\n * @module TaskBoard/view/TaskBoardBase\n */\nconst weightSorter = (a, b) => a.weight - b.weight;\n/**\n * A thin base class for {@link TaskBoard.view.TaskBoard}. Does not include any features by default, allowing smaller\n * custom-built bundles if used in place of {@link TaskBoard.view.TaskBoard}.\n *\n * **NOTE:** In most scenarios you probably want to use TaskBoard instead of TaskBoardBase.\n *\n * @extends Core/widget/Panel\n *\n * @mixes Core/mixin/Pluggable\n * @mixes Core/mixin/State\n * @mixes Core/widget/mixin/Responsive\n * @mixes Core/widget/mixin/Styleable\n * @mixes Scheduler/crud/mixin/CrudManagerView\n * @mixes TaskBoard/view/mixin/ExpandCollapse\n * @mixes TaskBoard/view/mixin/ResponsiveCards\n * @mixes TaskBoard/view/mixin/TaskBoardColumns\n * @mixes TaskBoard/view/mixin/TaskBoardDom\n * @mixes TaskBoard/view/mixin/TaskBoardDomEvents\n * @mixes TaskBoard/view/mixin/TaskBoardScroll\n * @mixes TaskBoard/view/mixin/TaskBoardStores\n * @mixes TaskBoard/view/mixin/TaskBoardSwimlanes\n * @mixes TaskBoard/view/mixin/TaskBoardVirtualization\n * @mixes TaskBoard/view/mixin/TaskItems\n * @mixes TaskBoard/view/mixin/TaskNavigation\n * @mixes TaskBoard/view/mixin/TaskSelection\n *\n * @features TaskBoard/feature/ColumnDrag\n * @features TaskBoard/feature/ColumnHeaderMenu\n * @features TaskBoard/feature/ColumnToolbars\n * @features TaskBoard/feature/SimpleTaskEdit\n * @features TaskBoard/feature/SwimlaneDrag\n * @features TaskBoard/feature/TaskDrag\n * @features TaskBoard/feature/TaskDragSelect\n * @features TaskBoard/feature/TaskEdit\n * @features TaskBoard/feature/TaskMenu\n * @features TaskBoard/feature/TaskTooltip\n * @widget\n */\nexport default class TaskBoardBase extends Panel.mixin(\n    Pluggable,\n    State,\n    Featureable,\n    Styleable,\n    CrudManagerView,\n    ExpandCollapse,\n    Responsive,\n    ResponsiveCards,\n    TaskBoardColumns,\n    TaskBoardDom,\n    TaskBoardDomEvents,\n    TaskBoardScroll,\n    TaskBoardStores,\n    TaskBoardSwimlanes,\n    TaskBoardVirtualization,\n    TaskItems,\n    TaskNavigation,\n    TaskSelection\n) {\n    //region Config\n    static $name = 'TaskBoardBase';\n    static type = 'taskboardbase';\n    static featureable = {\n        factory : TaskBoardFeature\n    };\n    static configurable = {\n        /** @hideconfigs autoUpdateRecord, defaultFocus, trapFocus, showTooltipWhenDisabled */\n        /** @hideproperties firstItem, lastItem, cellInfo, visibleChildCount */\n        /** @hidefunctions getAt */\n        layout : 'vbox',\n        /**\n         * An object containing Feature configuration objects (or `true` if no configuration is required)\n         * keyed by the Feature class name in all lowercase.\n         * @config {Object}\n         * @category Common\n         */\n        features : true,\n        /**\n         * An empty function by default, but provided so that you can override it. This function is called each time\n         * a task is rendered into the task board. It allows you to manipulate the DOM config object used for the card\n         * before it is synced to DOM, thus giving you control over styling and contents.\n         *\n         * NOTE: The function is intended for formatting, you should not update records in it since updating records\n         * triggers another round of rendering.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    taskRenderer({ taskRecord, cardConfig }) {\n         *        // Add an icon to all tasks header\n         *        cardConfig.children.header.children.icon = {\n         *            tag   : 'i',\n         *            class : 'b-fa b-fa-beer'\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * For more information, see the [Customize task contents guide](#TaskBoard/guides/customization/taskcontents.md).\n         *\n         * @config {Function}\n         * @param {Object} detail An object containing the information needed to render a task.\n         * @param {TaskBoard.model.TaskModel} detail.taskRecord The task record.\n         * @param {TaskBoard.model.ColumnModel} detail.columnRecord The column the task will be displayed in.\n         * @param {TaskBoard.model.SwimlaneModel} detail.swimlaneRecord The swimlane the task will be displayed in.\n         * @param {DomConfig} detail.cardConfig DOM config object for the cards element\n         * @returns {void}\n         * @category Task content\n         */\n        taskRenderer : null,\n        /**\n         * An empty function by default, but provided so that you can override it. This function is called each time\n         * a swimlane is rendered into the task board. It allows you to manipulate the DOM config object used for the\n         * swimlane before it is synced to DOM, thus giving you control over styling and contents.\n         *\n         * ```javascript\n         * const taskBoard = new TaskBoard({\n         *    swimlaneRenderer({ swimlaneRecord, swimlaneConfig }) {\n         *        // Add an icon to all swimlane headers\n         *        swimlaneConfig.children.header.children.icon = {\n         *            tag   : 'i',\n         *            class : 'b-fa b-fa-dog'\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} detail An object containing the information needed to render a swimlane.\n         * @param {TaskBoard.model.SwimlaneModel} detail.swimlaneRecord The swimlane.\n         * @param {DomConfig} detail.swimlaneConfig DOM config object for the swimlane\n         * @returns {void}\n         * @category Advanced\n         */\n        swimlaneRenderer : null,\n        /**\n         * Controls how many cards are rendered to a row in each column. Can be controlled on a per column basis by\n         * setting {@link TaskBoard.model.ColumnModel#field-tasksPerRow}\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   tasksPerRow : 3\n         * });\n         * ```\n         *\n         * @config {Number}\n         * @category Common\n         */\n        tasksPerRow : 1,\n        /**\n         * Setting this will cause cards to expand to share the available width if there are fewer than\n         * {@link #config-tasksPerRow}.\n         *\n         * By default, the {@link #config-tasksPerRow} always applies, and if it is 3, then a single\n         * card in a column will be 33% of the available width.\n         *\n         * To have fewer cards than the {@link #config-tasksPerRow} evenly share available column width,\n         * configure this as `true`;\n         * @prp {Boolean}\n         * @category Common\n         */\n        stretchCards : null,\n        /**\n         * Show task count for a column in its header, appended after the title\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   showCountInHeader : false\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        showCountInHeader : true,\n        /**\n         * Makes column and swimlane headers sticky\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   stickyHeaders : true\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         * @default\n         * @category Common\n         */\n        stickyHeaders : false,\n        /**\n         * Experimental, animate actions that cannot be animated using CSS transitions. Currently includes:\n         * * Programmatically moving tasks\n         * * Moving tasks using the task editor\n         * * Adding tasks\n         * * Removing tasks\n         * * Sorting tasks\n         * * Hiding/showing/filtering columns\n         * * Hiding/showing/filtering swimlanes\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   useDomTransition : true\n         * });\n         * ```\n         * **NOTE**: This flag is not supported for Lightning Web Components\n         * @config {Boolean}\n         * @category Experimental\n         */\n        useDomTransition : false,\n        /**\n         * Path to load resource images from. Used by the for example the resource picker in the task editor and by the\n         * ResourceAvatars task item. Set this to display miniature images for each resource using their `image` field.\n         *\n         * **NOTE**: The path should end with a `/`:\n         *\n         * ```javascript\n         * new TaskBoard({\n         *   resourceImagePath : 'images/resources/'\n         * });\n         * ```\n         *\n         * @config {String}\n         * @category Common\n         */\n        resourceImagePath : null,\n        /**\n         * CSS variable prefix, appended to the keys used in {@link #config-css}.\n         *\n         * Normally you do not need to change this value.\n         *\n         * @default\n         * @config {String}\n         * @category CSS\n         */\n        cssVarPrefix : 'taskboard',\n        /**\n         * Configuration values for the {@link Core.util.ScrollManager} class. It is used to manage column/body\n         * scrolling during task, column or swimlane drag.\n         * ```javascript\n         * new TaskBoard({\n         *     scrollManager : {\n         *         zoneWidth   : 100, // increase zone size\n         *         scrollSpeed : 3    // and scroll speed\n         *     }\n         * })\n         * ```\n         * @config {ScrollManagerConfig}\n         * @category Scrolling\n         */\n        scrollManager : {\n            value : {},\n            $config : ['nullify', 'lazy']\n        },\n        /**\n         * Allows sorting tasks in the UI independent of how they are sorted in the task store.\n         *\n         * Specify `true` to force sorting tasks by {@link TaskBoard/model/TaskModel#field-weight}.\n         *\n         * Supply a [sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n         * function to force a custom sort order.\n         *\n         * This is likely something you will want to use if combining TaskBoard with other products, sharing the\n         * project. Without this, sorting tasks in for example Gantt will also rearrange the cards on the board.\n         *\n         * As described above it accepts either a boolean or a Function, but it always returns a sorter function.\n         *\n         * @prp {Function} taskSorterFn\n         * @accepts {Boolean|Function}\n         * @config {Function}\n         * @param {TaskBoard.model.TaskModel} first The first task to compare\n         * @param {TaskBoard.model.TaskModel} second The second task to compare\n         * @returns {Number} Return `1` if first task is greater than second task, `-1` if the opposite is true or `0`\n         * if they are equal\n         * @category Advanced\n         */\n        taskSorterFn : null,\n        /**\n         * See {@link TaskBoard.view.TaskBoard#keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>} keyMap\n         * @category Common\n         */\n        contentElMutationObserver : false,\n        textContent : false,\n        // We can scroll in both axes.\n        // Scrollable also syncs the b-horizontal-overflow and b-vertical-overflow classes\n        // to allow styles to depend upon overflow state.\n        scrollable : true\n    };\n    isInitiallyComposed    = false;\n    domTransitionSuspended = 0;\n    columnRecomposeQueue   = new Map();\n    static delayable = {\n        recomposeColumns : 'raf'\n    };\n    //endregion\n    //region Overrides\n    onPaintOverride() {\n        // Internal procedure used for paint method overrides\n        // Not used in onInternalPaint() because it may be chained on instance and Override won't be applied\n    }\n    onInternalPaint(...args) {\n        if (this.onPaintOverride()) {\n            return;\n        }\n        super.onInternalPaint(...args);\n    }\n    //endregion\n    //region Type assertions and changers/updaters\n    changeResourceImagePath(resourceImagePath) {\n        ObjectHelper.assertString(resourceImagePath, 'resourceImagePath');\n        return resourceImagePath;\n    }\n    changeUseDomTransition(useDomTransition) {\n        ObjectHelper.assertBoolean(useDomTransition, 'useDomTransition');\n        return useDomTransition;\n    }\n    changeStickyHeaders(stickyHeaders) {\n        ObjectHelper.assertBoolean(stickyHeaders, 'stickyHeaders');\n        return stickyHeaders;\n    }\n    changeScrollManager(scrollManager, oldScrollManager) {\n        oldScrollManager?.destroy();\n        if (scrollManager) {\n            return ScrollManager.new({\n                element : this.element,\n                owner   : this\n            }, scrollManager);\n        }\n        return null;\n    }\n    changeShowCountInHeader(showCountInHeader) {\n        ObjectHelper.assertBoolean(showCountInHeader, 'showCountInHeader');\n        return showCountInHeader;\n    }\n    changeTasksPerRow(tasksPerRow) {\n        ObjectHelper.assertNumber(tasksPerRow, 'tasksPerRow');\n        return tasksPerRow;\n    }\n    changeSwimlaneRenderer(swimlaneRenderer) {\n        ObjectHelper.assertFunction(swimlaneRenderer, 'swimlaneRenderer');\n        return swimlaneRenderer;\n    }\n    changeTaskRenderer(taskRenderer) {\n        ObjectHelper.assertFunction(taskRenderer, 'taskRenderer');\n        return taskRenderer;\n    }\n    changeTaskSorterFn(fn) {\n        if (fn === true) {\n            return weightSorter;\n        }\n        fn && ObjectHelper.assertFunction(fn, 'taskSorterFn');\n        return fn;\n    }\n    //endregion\n    //region Recompose columns\n    // Queue a column for recomposition on next frame\n    queueColumnRecompose(columnRecord, swimlaneRecord) {\n        this.columnRecomposeQueue.set(`${columnRecord.id}.-.${swimlaneRecord?.id}`, { columnRecord, swimlaneRecord });\n        this.recomposeColumns();\n    }\n    // RAF function to recompose all queued columns\n    recomposeColumns() {\n        for (const [, { columnRecord, swimlaneRecord }] of this.columnRecomposeQueue) {\n            this.recomposeColumn(columnRecord, swimlaneRecord);\n        }\n        this.columnRecomposeQueue.clear();\n    }\n    // Recompose a single column / swimlane intersection\n    recomposeColumn(columnRecord, swimlaneRecord) {\n        const\n            element   = this.getSwimlaneColumnElement(swimlaneRecord, columnRecord),\n            domConfig = DomHelper.normalizeChildren(this.renderColumn(swimlaneRecord, columnRecord));\n        domConfig.onlyChildren = true;\n        DomSync.sync({\n            targetElement : element,\n            domConfig,\n            callback      : this.domSyncCallback,\n            syncOptions   : {\n                syncIdField      : 'column',\n                releaseThreshold : 0\n            }\n        });\n    }\n    //endregion\n    //region Render\n    // Creates a DOM config for a single card, calling any configured taskRenderer() in the process\n    renderCard(taskRecord, columnRecord, swimlaneRecord) {\n        // Allow mixins to fully control card rendering (used by TaskBoardVirtualization)\n        const overriddenCard = super.renderCard(taskRecord, columnRecord, swimlaneRecord);\n        if (overriddenCard) {\n            return overriddenCard;\n        }\n        const\n            me                                = this,\n            { id, domId, eventColor, weight } = taskRecord,\n            color                             = eventColor || swimlaneRecord?.color || columnRecord.color,\n            namedColor                        = DomHelper.isNamedColor(color) ? color : null,\n            cardSize                          = me.getCardSize(columnRecord, swimlaneRecord),\n            cardConfig                        = {\n                id    : `${me.id}-card-${domId}`,\n                class : {\n                    'b-taskboard-card'                  : true,\n                    [`b-taskboard-color-${namedColor}`] : namedColor,\n                    'b-readonly'                        : taskRecord.readOnly,\n                    ...taskRecord.cls\n                },\n                tabIndex : 0,\n                dataset  : {\n                    task          : domId,\n                    column        : columnRecord.id,\n                    lane          : swimlaneRecord?.id,\n                    weight,\n                    domTransition : true\n                },\n                style : {\n                    color  : namedColor ? null : color,\n                    height : me.getTaskHeight?.(taskRecord) ?? null\n                },\n                elementData : {\n                    elementType : 'task',\n                    taskId      : id,\n                    taskRecord,\n                    columnRecord,\n                    swimlaneRecord\n                },\n                children : {\n                    header : {\n                        tag   : 'header',\n                        class : {\n                            'b-taskboard-card-header' : 1\n                        },\n                        children    : {},\n                        syncOptions : {\n                            syncIdField : 'role'\n                        }\n                    },\n                    body : {\n                        tag   : 'section',\n                        class : {\n                            'b-taskboard-card-body' : 1\n                        },\n                        children    : {},\n                        syncOptions : {\n                            syncIdField : 'role'\n                        }\n                    },\n                    footer : {\n                        tag   : 'footer',\n                        class : {\n                            'b-taskboard-card-footer' : 1\n                        },\n                        children    : {},\n                        syncOptions : {\n                            syncIdField : 'role'\n                        }\n                    }\n                }\n            },\n            { children }             = cardConfig,\n            { header, body, footer } = children;\n        // Chained by features\n        me.populateCard({\n            taskRecord,\n            columnRecord,\n            swimlaneRecord,\n            cardConfig,\n            cardSize\n        });\n        // Supplied by app\n        me.taskRenderer?.({\n            taskRecord,\n            columnRecord,\n            swimlaneRecord,\n            cardConfig,\n            cardSize\n        });\n        // Remove unused parts of the card\n        if (header.html == null && header.text == null && (!header.children || Object.keys(header.children).length === 0)) {\n            children.header = null;\n        }\n        if (body.html == null && body.text == null && (!body.children || Object.keys(body.children).length === 0)) {\n            children.body = null;\n        }\n        if (footer.html == null && footer.text == null && (!footer.children || Object.keys(footer.children).length === 0)) {\n            children.footer = null;\n        }\n        return cardConfig;\n    }\n    renderColumnHeader(columnRecord) {\n        const\n            me                 = this,\n            { text, id, domId, width, flex, minWidth, color, tooltip } = columnRecord,\n            namedColor         = DomHelper.isNamedColor(color) ? color : null,\n            columnHeaderConfig = {\n                id    : `${me.id}-column-header-${domId}`,\n                class : {\n                    'b-taskboard-column-header'         : 1,\n                    'b-fixed-width'                     : width && !flex,\n                    [`b-taskboard-color-${namedColor}`] : namedColor,\n                    'b-last'                            : columnRecord === this.columns.last\n                },\n                style : {\n                    color : namedColor ? null : color,\n                    width,\n                    flex,\n                    minWidth\n                },\n                children : {\n                    padder : {\n                        class : {\n                            'b-taskboard-column-header-padder' : 1\n                        },\n                        children : {\n                            title : {\n                                class : {\n                                    'b-taskboard-column-title' : 1\n                                },\n                                dataset : {\n                                    btip : tooltip\n                                },\n                                children : [\n                                    {\n                                        tag   : 'span',\n                                        class : 'b-column-title-text',\n                                        text\n                                    },\n                                    me.showCountInHeader && {\n                                        tag   : 'span',\n                                        class : {\n                                            'b-taskboard-column-count' : 1\n                                        },\n                                        html : `(${me.getColumnTasks(columnRecord)?.length ?? 0})`\n                                    }\n                                ]\n                            }\n                        }\n                    }\n                },\n                dataset : {\n                    column        : domId,\n                    domTransition : true\n                },\n                elementData : {\n                    elementType : 'columnHeader',\n                    columnId    : id\n                }\n            };\n        Tooltip.showOverflow = true;\n        // Chained by features\n        me.populateColumnHeader({\n            columnRecord,\n            columnHeaderConfig\n        });\n        // Supplied by app\n        me.columnHeaderRenderer?.({\n            columnRecord,\n            columnHeaderConfig\n        });\n        return columnHeaderConfig;\n    }\n    renderColumn(swimlaneRecord, columnRecord) {\n        const\n            me            = this,\n            {\n                taskSorterFn,\n                stretchCards,\n                columnField,\n                swimlaneField\n            }             = me,\n            {\n                width,\n                flex,\n                id,\n                domId,\n                minWidth,\n                color\n            }             = columnRecord,\n            { taskStore } = me.project,\n            // Tasks in this column / swimlane intersection. Fetched using an index for better performance, except when\n            // using a tree store, since only the expended tasks are indexed then (only those are in storage)\n            tasks         = taskStore.isTree\n                ? taskStore.query(r =>\n                    r[columnField] === id &&\n                    (!swimlaneField || !swimlaneRecord || r[swimlaneField] === swimlaneRecord.id) // Might have no lanes\n                )\n                : Array.from(taskStore.storage.findItem(\n                    'columnSwimlaneIntersection',\n                    `${columnRecord.id}-/-${swimlaneRecord?.id ?? 'default'}`\n                ) || []),\n            perRow       = me.getTasksPerRow(columnRecord, swimlaneRecord),\n            elementId    = `${me.id}-column-${swimlaneRecord?.domId ?? 'default'}-${domId}`,\n            namedColor   = DomHelper.isNamedColor(color) ? color : null,\n            columnConfig = {\n                id    : elementId,\n                class : {\n                    'b-taskboard-column'                                 : 1,\n                    'b-fixed-width'                                      : width && !flex,\n                    [`b-${perRow}-task${perRow > 1 ? 's' : ''}-per-row`] : 1,\n                    'b-inline'                                           : perRow > 1,\n                    [`b-taskboard-color-${namedColor}`]                  : namedColor,\n                    'b-last'                                             : columnRecord === this.columns.last\n                },\n                style : {\n                    color : namedColor ? null : color,\n                    width,\n                    flex,\n                    minWidth\n                },\n                dataset : {\n                    column        : domId,\n                    lane          : swimlaneRecord?.id,\n                    domTransition : true\n                },\n                elementData : {\n                    elementType : 'column',\n                    columnId    : id,\n                    laneId      : swimlaneRecord?.id\n                },\n                // Cards\n                children : {\n                    body : {\n                        id    : `${elementId}-body`,\n                        class : {\n                            'b-taskboard-column-body' : 1\n                        },\n                        dataset : {\n                            role          : 'body',\n                            domTransition : true\n                        },\n                        children : [\n                            {\n                                class : {\n                                    'b-taskboard-column-body-inner' : 1\n                                },\n                                style : {\n                                    'grid-template-columns' : `repeat(${stretchCards ? Math.min(perRow, tasks.length) : perRow}, 1fr)`\n                                },\n                                dataset : {\n                                    role          : 'inner',\n                                    domTransition : true\n                                },\n                                children : (() => {\n                                    // Optionally force sort order\n                                    if (taskSorterFn) {\n                                        tasks.sort(taskSorterFn);\n                                    }\n                                    // Otherwise match store order, Set is unordered\n                                    else {\n                                        tasks.sort((a, b) => taskStore.indexOf(a) - taskStore.indexOf(b));\n                                    }\n                                    return tasks.map(taskRecord => me.renderCard(taskRecord, columnRecord, swimlaneRecord));\n                                })(),\n                                syncOptions : {\n                                    syncIdField      : 'task',\n                                    releaseThreshold : me.isVirtualized ? 1000 : 0\n                                }\n                            }\n                        ],\n                        syncOptions : {\n                            syncIdField : 'role'\n                        }\n                    }\n                },\n                syncOptions : {\n                    syncIdField : 'role'\n                }\n            };\n        // Chained by features\n        me.populateColumn({\n            columnRecord,\n            swimlaneRecord,\n            columnConfig\n        });\n        // Supplied by app\n        me.columnRenderer?.({\n            columnRecord,\n            swimlaneRecord,\n            columnConfig\n        });\n        return columnConfig;\n    }\n    renderSwimlane(swimlaneRecord) {\n        const\n            me                             = this,\n            { showCountInHeader, columns } = me,\n            {\n                id = 'default',\n                domId = 'default',\n                text,\n                height,\n                flex,\n                color\n            }                              = swimlaneRecord || {},\n            elementId                      = `${me.id}-swimlane-${domId}`,\n            namedColor                     = DomHelper.isNamedColor(color) ? color : null,\n            swimlaneConfig                 = {\n                id    : elementId,\n                class : {\n                    'b-taskboard-swimlane'              : 1,\n                    'b-fixed-height'                    : height && !flex,\n                    'b-last'                            : !swimlaneRecord || swimlaneRecord === me.swimlanes.last,\n                    [`b-taskboard-color-${namedColor}`] : namedColor\n                },\n                style : {\n                    color : namedColor ? null : color,\n                    height,\n                    flex\n                },\n                dataset : {\n                    lane          : domId,\n                    domTransition : true\n                },\n                elementData : {\n                    elementType : 'swimlane',\n                    laneId      : id\n                },\n                children : {\n                    // If a lane is defined, it has a header\n                    header : swimlaneRecord && {\n                        id    : `${elementId}-header`,\n                        tag   : 'header',\n                        class : {\n                            'b-taskboard-swimlane-header' : 1\n                        },\n                        dataset : {\n                            role          : 'header',\n                            domTransition : 'preserve-padding'\n                        },\n                        children : {\n                            title : {\n                                class : {\n                                    'b-taskboard-swimlane-title' : 1\n                                },\n                                children : {\n                                    text,\n                                    count : showCountInHeader && {\n                                        tag   : 'span',\n                                        class : {\n                                            'b-taskboard-swimlane-count' : 1\n                                        },\n                                        text : `(${me.getSwimlaneTasks(swimlaneRecord)?.size ?? 0})`\n                                    }\n                                }\n                            }\n                        }\n                    },\n                    // Lane or no lane, there is always a body to contain columns\n                    body : {\n                        id    : `${elementId}-body`,\n                        class : {\n                            'b-taskboard-swimlane-body' : 1\n                        },\n                        dataset : {\n                            role          : 'body',\n                            domTransition : true\n                        },\n                        // Columns within the lane\n                        children : columns.map(column =>\n                            !column.hidden && me.renderColumn(swimlaneRecord, column)\n                        ),\n                        syncOptions : {\n                            syncIdField      : 'column',\n                            releaseThreshold : 0\n                        }\n                    }\n                },\n                syncOptions : {\n                    syncIdField : 'role'\n                }\n            };\n        me.populateSwimlane({\n            swimlaneRecord,\n            swimlaneConfig\n        });\n        // Supplied by app\n        me.swimlaneRenderer?.({\n            swimlaneRecord,\n            swimlaneConfig\n        });\n        return swimlaneConfig;\n    }\n    // Creates a DOM config for the entire TaskBoard, rendered to panels body\n    get bodyConfig() {\n        const\n            me = this,\n            // Pull in configs that affect rendering, even if not used here to prime them\n            {\n                /* eslint-disable no-unused-vars */\n                stickyHeaders,\n                showCountInHeader,\n                columns,\n                columnField,\n                swimlaneField,\n                tasksPerRow,\n                headerItems,\n                bodyItems,\n                footerItems,\n                selectedTasks,\n                showCollapseInHeader,\n                showCollapseTooltip,\n                taskSorterFn,\n                stretchCards\n                /* eslint-enable no-unused-vars */\n            }  = me;\n        // On first compose, supply a minimal body to have element ready when features inject their contents on next\n        // compose. Allows us to avoid using hacks to pull features in early\n        if (!me.rendered) {\n            // Queue up another recompose after the minimal bootstrap, to render columns while loading\n            me.setTimeout(() => me.recompose(), 0);\n            return {\n                // Required by panel, it expects a bodyElement reference\n                reference : 'bodyElement',\n                // Listeners are only set up on first sync, has to go here (not internalListeners no purpose, these are\n                // EventHelper listeners)\n                // eslint-disable-next-line bryntum/no-listeners-in-lib\n                listeners : ObjectHelper.assign({ thisObj : me }, me.domListeners)\n            };\n        }\n        // We get here on second compose, features are now pulled in and we have an outer element ready\n        const bodyConfig = {\n            // Save some processing by not cloning the config, it is regenerated on every compose anyway\n            skipClone : true,\n            reference : 'bodyElement',\n            class     : {\n                'b-taskboard-body' : 1,\n                'b-sticky-headers' : stickyHeaders\n            },\n            children : [\n                // Column headers\n                {\n                    tag   : 'header',\n                    id    : `${me.id}-column-headers`,\n                    class : {\n                        'b-taskboard-column-headers' : 1\n                    },\n                    children : columns.map(column => !column.hidden && me.renderColumnHeader(column)),\n                    dataset  : {\n                        lane          : 'header',\n                        domTransition : true\n                    },\n                    syncOptions : {\n                        syncIdField : 'column'\n                    }\n                }\n            ],\n            syncOptions : {\n                syncIdField      : 'lane',\n                releaseThreshold : 0,\n                ignoreRefs       : 'children' // References in \"children\" should not be hoisted to the panel\n            }\n        };\n        let { swimlanes } = me;\n        // There is always a swimlane\n        if (!swimlanes?.count) {\n            swimlanes = [null];\n        }\n        // Swimlanes\n        for (const lane of swimlanes) {\n            if (!lane?.hidden) {\n                bodyConfig.children.push(me.renderSwimlane(lane));\n            }\n        }\n        me.populateBody({\n            bodyConfig\n        });\n        me.isComposed = true;\n        return bodyConfig;\n    }\n    // For chaining, to decorate dom config\n    populateCard(args) {\n        super.populateCard?.(args);\n    }\n    populateColumn(args) {\n        super.populateColumn?.(args);\n    }\n    populateColumnHeader(args) {\n        super.populateColumnHeader?.(args);\n    }\n    populateSwimlane(args) {\n        super.populateSwimlane?.(args);\n    }\n    populateBody(args) {\n        super.populateBody?.(args);\n    }\n    afterRecompose() {\n        super.afterRecompose();\n        const me = this;\n        if (!me.isInitiallyComposed && me.isComposed) {\n            me.isInitiallyComposed = true;\n            me.initialCompose();\n        }\n        if (me.project.taskStore.count > 0) {\n            me.trigger('renderTasks', { taskRecords : me.project.taskStore.allRecords });\n        }\n        me.transitionRecompose = null;\n    }\n    // For chaining, replaces render() since we don't do full compose on render\n    initialCompose() {\n        this.trigger('initialCompose');\n    }\n    // For chaining, to react to element changes\n    onRenderColumn() {}\n    onRemoveColumnElement() {}\n    onRenderSwimlane() {}\n    onRemoveSwimlaneElement() {}\n    //endregion\n    //region Transition - experimental\n    // Prevent dom transitions until resumed\n    suspendDomTransition() {\n        this.domTransitionSuspended++;\n    }\n    // Resume dom transitions\n    resumeDomTransition() {\n        this.domTransitionSuspended--;\n    }\n    // Recompose transitioning dom\n    recomposeWithDomTransition(options) {\n        const me = this;\n        if (me.useDomTransition && !me.domTransitionSuspended) {\n            me.transitionRecompose = {\n                selector : '[data-dom-transition]',\n                duration : 300,\n                element  : me._bodyElement, // _ needed to not flush recompose if we are dirty\n                ...options\n            };\n        }\n        // Transitioned recompose takes a bit of time, if we are requested to recompose again while it is ongoing,\n        // we queue up another recompose to run after the transition is done\n        if (me.recompose.suspended) {\n            me._recomposeQueued = true;\n        }\n        else {\n            me.recompose();\n        }\n    }\n    resumeRecompose() {\n        super.resumeRecompose();\n        // Kick of another recompose if needed, see comment in recomposeWithDomTransition() above\n        if (this._recomposeQueued) {\n            this._recomposeQueued = null;\n            this.recompose();\n        }\n    }\n    //endregion\n    //region Extract configs\n    // This function is not meant to be called by any code other than Base#getCurrentConfig().\n    // It extracts the current configs for the task board, with special handling for columns\n    getCurrentConfig(options) {\n        const result = super.getCurrentConfig(options);\n        if (result.columns) {\n            delete result.columns.modelClass;\n        }\n        return result;\n    }\n    //endregion\n    // Expected by CrudManagerView\n    refresh() {\n        this.recompose();\n    }\n}\nTaskBoardBase.initClass();\nVersionHelper.setVersion('taskboard', '5.6.2');\nTaskBoardBase._$name = 'TaskBoardBase';", "import TaskItem from './TaskItem.js';\n/**\n * @module TaskBoard/view/item/TaskMenuItem\n */\n/**\n * Item that adds a `\u00B7\u00B7\u00B7` button hooked up to display the {@link TaskBoard/feature/TaskMenu} on click.\n *\n * Requires the {@link TaskBoard/feature/TaskMenu} to work as intended.\n *\n * {@inlineexample TaskBoard/view/item/TaskMenuItem.js}\n *\n * @extends TaskBoard/view/item/TaskItem\n * @classtype taskMenu\n */\nexport default class TaskMenuItem extends TaskItem {\n    static $name = 'TaskMenuItem';\n    static type = 'taskMenu';\n    /**\n     * @hideconfigs editor\n     */\n    static defaultEditor = null;\n    static render({ taskBoard, domConfig }) {\n        if (!taskBoard.features.taskMenu || taskBoard.features.taskMenu.disabled) {\n            return false;\n        }\n        domConfig.tag = 'button';\n        domConfig.class['b-icon b-icon-menu-horizontal'] = 1;\n    }\n    static onClick({ source : taskBoard, event }) {\n        taskBoard.features.taskMenu?.showContextMenu(event, { target : event.target });\n    }\n}\nTaskMenuItem.initClass();\nTaskMenuItem._$name = 'TaskMenuItem';", "import TaskBoardBase from './TaskBoardBase.js';\nimport '../feature/ColumnHeaderMenu.js';\nimport '../feature/ColumnToolbars.js';\nimport '../feature/TaskDrag.js';\nimport '../feature/TaskDragSelect.js';\nimport '../feature/TaskEdit.js';\nimport '../feature/TaskMenu.js';\nimport './item/ImageItem.js';\nimport './item/JsxItem.js';\nimport './item/ProgressItem.js';\nimport './item/RatingItem.js';\nimport './item/ResourceAvatarsItem.js';\nimport './item/SeparatorItem.js';\nimport './item/TagsItem.js';\nimport './item/TaskMenuItem.js';\nimport './item/TemplateItem.js';\nimport './item/TodoListItem.js';\n/**\n * @module TaskBoard/view/TaskBoard\n */\n/**\n * A kanban board widget that allows you to visualize and mange tasks.\n *\n * {@inlineexample TaskBoard/view/TaskBoardBasic.js}\n *\n * ## Datalayer\n *\n * TaskBoards datalayer is based on Schedulers. It consumes a {@link TaskBoard.model.ProjectModel project} that holds\n * stores that in turn holds records. The stores used by default are:\n *\n * * {@link TaskBoard.store.TaskStore} - Store holding tasks, which are instances of {@link TaskBoard.model.TaskModel}\n * * {@link Scheduler.store.ResourceStore} - Holds resources, see {@link Scheduler.model.ResourceModel}\n * * {@link Scheduler.store.AssignmentStore} - Holds assignments, links between resources and tasks, see {@link Scheduler.model.AssignmentModel}\n *\n * Data can be supplied inline or loaded using the projects {@link Scheduler.data.mixin.ProjectCrudManager CrudManager}\n * capabilities. Example using inline data:\n *\n * {@frameworktabs}\n * {@js}\n *\n * ```javascript\n * new TaskBoard({\n *     project : {\n *         tasksData : [\n *             { id : 1, name : 'Try TaskBoard' }\n *         ]\n *     }\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     const project = useRef();\n *\n *     const [tasks] = useState([\n *          { id : 1, name : 'Try TaskBoard' }\n *     ]);\n *\n *     return (\n *         <>\n *             <BryntumProjectModel ref={project} tasks={tasks} />\n *             <BryntumTaskBoard project={project} />\n *         </>\n *     )\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n * ```html\n * <bryntum-project-model ref=\"project\" :tasks=\"tasks\" />\n * <bryntum-task-board :project=\"project\" />\n * ```\n *\n * ```javascript\n * export default {\n *    setup() {\n *      return {\n *         tasks : reactive([\n *             { id : 1, name : 'Try TaskBoard' }\n *         ])\n *      };\n *    }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n *\n * ```html\n * <bryntum-project-model #project [tasks]=\"tasks\"></bryntum-project-model>\n * <bryntum-task-board [project]=\"project\"></bryntum-task-board>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *     tasks = [\n *         { id : 1, name : 'Try TaskBoard' }\n *     ]\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * And using CrudManager to load remote data:\n *\n * {@frameworktabs}\n * {@js}\n *\n * ```javascript\n * new TaskBoard({\n *     project : {\n *         loadUrl : 'data/load.php',\n *         autoLoad : true\n *     }\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     const project = useRef();\n *\n *     return (\n *         <>\n *             <BryntumProjectModel ref={project} loadUrl=\"data/load.php\" />\n *             <BryntumTaskBoard project={project} />\n *         </>\n *     )\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n * ```html\n * <bryntum-project-model ref=\"project\" :load-url=\"loadUrl\" />\n * <bryntum-task-board :project=\"project\" />\n * ```\n *\n * ```javascript\n * export default {\n *    setup() {\n *      return {\n *         loadUrl : 'data/load.php'\n *      };\n *    }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n *\n * ```html\n * <bryntum-project-model #project [loadUrl]=\"loadUrl\"></bryntum-project-model>\n * <bryntum-task-board [project]=\"project\"></bryntum-task-board>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *     loadUrl = 'data/load.php'\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * ## Columns\n *\n * The tasks are displayed in columns. Which column a task belongs to is determined by the tasks value for the\n * configured {@link #config-columnField}. Columns can be defined as strings or as {@link TaskBoard.model.ColumnModel}\n * data objects, supplied to the {@link #config-columns columns config}. This snippet illustrates it:\n *\n * {@frameworktabs}\n * {@js}\n *\n * ```javascript\n * new TaskBoard({\n *     // The status field of tasks will be used to link a task to a column\n *     columnField : 'status',\n *\n *     // Columns as strings or objects\n *     columns : [\n *         'todo', // Will be displayed as Todo\n *         { id : 'done', text : 'Done!' }\n *     ],\n *\n *     // TaskBoard data\n *     project : {\n *         tasksData : [\n *             // Since we use the \"status\" field to determine column,\n *             // this task will belong to the \"done\" column\n *             { id : 1, name : 'Create mockup', status : 'done' },\n *             // And this one to \"todo\"\n *             { id : 2, name : 'Write docs', status : 'todo' }\n *         ]\n *     }\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     const project = useRef();\n *\n *     // TaskBoard data\n *     const [tasks] = useState([\n *         // Since we use the \"status\" field to determine column,\n *         // this task will belong to the \"done\" column\n *         { id : 1, name : 'Create mockup', status : 'done' },\n *        // And this one to \"todo\"\n *        { id : 2, name : 'Write docs', status : 'todo' }\n *     ]);\n *\n *     // Columns as strings or objects\n *     const columns = [\n *        'todo', // Will be displayed as Todo\n *         { id : 'done', text : 'Done!' }\n *     ];\n *\n *     // The status field of tasks will be used to link a task to a column\n *     const columnField = 'status';\n *\n *     return (\n *         <>\n *             <BryntumProjectModel ref={project} tasks={tasks} />\n *             <BryntumTaskBoard\n *                 project={project}\n *                 columns={columns}\n *                 columnField={columnField}\n *                 />\n *         </>\n *     )\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n * ```html\n * <bryntum-project-model ref=\"project\" :tasks=\"tasks\" />\n * <bryntum-task-board\n *     :project=\"project\"\n *     :columns=\"columns\"\n *     :columnField=\"columnField\"\n *     />\n * ```\n *\n * ```javascript\n * export default {\n *     setup() {\n *         return {\n *             // TaskBoard data\n *             tasks : reactive([\n *                 // Since we use the \"status\" field to determine column,\n *                 // this task will belong to the \"done\" column\n *                 { id : 1, name : 'Create mockup', status : 'done' },\n *                 // And this one to \"todo\"\n *                 { id : 2, name : 'Write docs', status : 'todo' }\n *             ]),\n *\n *             // Columns as strings or objects\n *             columns : [\n *                 'todo', // Will be displayed as Todo\n *                 { id : 'done', text : 'Done!' }\n *             ],\n *\n *             // The status field of tasks will be used to link a task to a column\n *             columnField : 'status'\n *         };\n *     }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n *\n * ```html\n * <bryntum-project-model #project [tasks]=\"tasks\"></bryntum-project-model>\n * <bryntum-task-board\n *     [project]=\"project\"\n *     [columns]=\"columns\"\n *     [columnField]=\"columnField\"\n *     >\n * </bryntum-task-board>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *     // TaskBoard data\n *     tasks = reactive([\n *         // Since we use the \"status\" field to determine column,\n *         // this task will belong to the \"done\" column\n *         { id : 1, name : 'Create mockup', status : 'done' },\n *         // And this one to \"todo\"\n *         { id : 2, name : 'Write docs', status : 'todo' }\n *     ])\n *\n *     // Columns as strings or objects\n *     columns = [\n *         'todo', // Will be displayed as Todo\n *         { id : 'done', text : 'Done!' }\n *     ]\n *\n *     // The status field of tasks will be used to link a task to a column\n *     columnField = 'status'\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * The supplied columns are loaded into an internal store, named {@link #property-columns}. You can use it at runtime\n * to access, add, remove and filter columns.\n *\n * ## Swimlanes\n *\n * The TaskBoard can optionally be divided into horizontal swimlanes.\n *\n * {@inlineexample TaskBoard/view/TaskBoardSwimlanes.js}\n *\n * They are defined and populated in a very similar manner to columns:\n *\n * {@frameworktabs}\n * {@js}\n *\n * ```javascript\n * new TaskBoard({\n *     // The prio field of tasks will be used to link a task to a swimlane\n *     swimlaneField : 'prio',\n *\n *     // Swimlanes as strings or objects\n *     swimlanes : [\n *         'low', // Will be displayed as Low\n *         { id : 'high', text : 'High!' }\n *     ],\n *\n *     // TaskBoard data\n *     project : {\n *         tasksData : [\n *             // Since we use the \"prio\" field to determine swimlane,\n *             // this task will belong to the \"high\" lane\n *             { id : 1, name : 'Create mockup', status : 'done', prio : 'high' },\n *\n *             // And this one to \"low\"\n *             { id : 2, name : 'Write docs', status : 'todo', prio : 'low' }\n *         ]\n *     }\n * });\n * ```\n *\n * {@endjs}\n * {@react}\n *\n * ```jsx\n * const App = props => {\n *     const project = useRef();\n *\n *     // TaskBoard data\n *     const [tasks] = useState([\n *         // Since we use the \"prio\" field to determine swimlane,\n *         // this task will belong to the \"high\" lane\n *         { id : 1, name : 'Create mockup', status : 'done', prio : 'high' },\n *\n *         // And this one to \"low\"\n *         { id : 2, name : 'Write docs', status : 'todo', prio : 'low' }\n *     ]);\n *\n *     // Swimlanes as strings or objects\n *     const swimlanes = [\n *        'low', // Will be displayed as Low\n *         { id : 'high', text : 'High!' }\n *     ];\n *\n *     // The prio field of tasks will be used to link a task to a swimlane\n *     const swimlaneField = 'prio';\n *\n *     return (\n *         <>\n *             <BryntumProjectModel ref={project} tasks={tasks} />\n *             <BryntumTaskBoard\n *                 project={project}\n *                 swimlanes={swimlanes}\n *                 swimlaneField={swimlaneField}\n *                 />\n *         </>\n *     )\n * }\n * ```\n *\n * {@endreact}\n * {@vue}\n *\n * ```html\n * <bryntum-project-model ref=\"project\" :tasks=\"tasks\" />\n * <bryntum-task-board\n *     :project=\"project\"\n *     :swimlanes=\"swimlanes\"\n *     :swimlaneField=\"swimlaneField\"\n *     />\n * ```\n *\n * ```javascript\n * export default {\n *     setup() {\n *         return {\n *             // TaskBoard data\n *             tasks : reactive([\n *                 // Since we use the \"prio\" field to determine swimlane,\n *                 // this task will belong to the \"high\" lane\n *                 { id : 1, name : 'Create mockup', status : 'done', prio : 'high' },\n *\n *                 // And this one to \"low\"\n *                 { id : 2, name : 'Write docs', status : 'todo', prio : 'low' }\n *             ]),\n *\n *             // Swimlanes as strings or objects\n *             swimlane : [\n *                 'low', // Will be displayed as Low\n *                 { id : 'high', text : 'High!' }\n *             ],\n *\n *             // The prio field of tasks will be used to link a task to a swimlane\n *             swimlanenField : 'prio'\n *         };\n *     }\n * }\n * ```\n *\n * {@endvue}\n * {@angular}\n *\n * ```html\n * <bryntum-project-model #project [tasks]=\"tasks\"></bryntum-project-model>\n * <bryntum-task-board\n *     [project]=\"project\"\n *     [swimlanes]=\"swimlanes\"\n *     [swimlaneField]=\"swimlaneField\"\n *     >\n * </bryntum-task-board>\n * ```\n *\n * ```typescript\n * export class AppComponent {\n *     // TaskBoard data\n *     tasks = [\n *         // Since we use the \"prio\" field to determine swimlane,\n *         // this task will belong to the \"high\" lane\n *         { id : 1, name : 'Create mockup', status : 'done', prio : 'high' },\n *\n *         // And this one to \"low\"\n *         { id : 2, name : 'Write docs', status : 'todo', prio : 'low' }\n *     ]\n *\n *     // Swimlanes as strings or objects\n *     swimlanes = [\n *         'low', // Will be displayed as Low\n *         { id : 'high', text : 'High!' }\n *     ]\n *\n *     // The prio field of tasks will be used to link a task to a swimlane\n *     swimlaneField = 'prio'\n *  }\n * ```\n *\n * {@endangular}\n * {@endframeworktabs}\n *\n * ## Task order\n *\n * The order of tasks in a column is determined by their order in the task store. By default the store is sorted by\n * {@link TaskBoard/model/TaskModel#field-weight}. Changing store sorting will rearrange the tasks:\n *\n * ```javascript\n * // Rearrange tasks by name\n * taskBoard.project.taskStore.sort('name');\n * ```\n *\n * When loading tasks that has no weights specified a generated weight (index * 100) will be silently assigned.\n *\n * Dragging and dropping tasks changes their weight and resorts the store. Note that if you want to sort by something\n * other than weight and still want a task to stay where it is dropped you will have to opt out of the default\n * behaviour by configuring {@link TaskBoard/feature/TaskDrag#config-reorderTaskRecords} as `true`.\n *\n * If you programmatically change a weight you have to manually sort the store for the task to move:\n *\n * ```javascript\n * // Programmatic change of weight requires resorting manually\n * taskBoard.project.taskStore.first.weight = 1000;\n * taskBoard.project.taskStore.sort();\n * ```\n *\n * ## Sharing a project\n *\n * When consuming a project from a different product (for example Gantt), you will likely want the cards on the board\n * to have a stable order no matter how data is sorted in the other product. This can be achieved by configuring a\n * {@link #config-taskSorterFn}, which is then applied on the UI layer to resort tasks before rendering their cards.\n * You can use it to enforce sorting by weight:\n *\n * ```javascript\n * // Shortcut to always enforce sorting by weight\n * const taskBoard = new TaskBoard({\n *    taskSorterFn : true\n * });\n * ```\n *\n * Or supply a custom [Array sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort)\n * function:\n *\n * ```javascript\n * // Custom sorting fn\n * const taskBoard = new TaskBoard({\n *    taskSorterFn(a, b) {\n *        return a.name.localeCompare(b.name);\n *    }\n * });\n * ```\n *\n * <div class=\"note\">\n * When consuming a non-TaskBoard project no weights will be assigned by default, make sure your data has weights if\n * you want stable task ordering.\n * </div>\n *\n * ## Customizing task content\n *\n * Task contents can be easily customized using {@link TaskBoard/view/mixin/TaskItems task items}, lightweight\n * \"widgets\" that can be added to a tasks header, body and footer.\n *\n * For more control over what gets rendered into a task, you can supply a {@link #config-taskRenderer} function. It is\n * called prior to updating the DOM for each task, allowing you to directly manipulate what ends up there.\n *\n * For more information see:\n *\n * * [Styling guide](#TaskBoard/guides/customization/styling.md)\n * * [Customize task contents guide](#TaskBoard/guides/customization/taskcontents.md)\n *\n * ## Large data sets\n *\n * Having a large number of cards rendered to DOM simultaneously can lead to poor performance. To address this issue,\n * TaskBoard supports partial virtualized rendering. This means that only the cards that are visible in the viewport\n * are fully rendered, cards outside the viewport are only outlined.\n *\n * When enabled, the board displays faster and is more responsive with big data sets, but it also means that scrolling\n * is more costly since cards coming into view has to be rendered. And since it is not fully virtualized, the board will\n * still be slow with very large data sets.\n *\n * <div class=\"note\">A Kanban board is best suited for using with a smaller set of tasks (hundreds rather than\n * thousands). Before enabling partial virtualized rendering we strongly recommend you consider restructuring the\n * application. Could it for example filter the tasks based on user, project or similar to work on a subset?</div>\n *\n * To enable partial virtualized rendering, the height of all tasks must be known. To communicate this to the TaskBoard,\n * implement a {@link #config-getTaskHeight getTaskHeight()} function. See its documentation for more information and\n * snippets.\n *\n * <div class=\"note\">Note that as part of the optimizations for partial virtualized rendering, the inner element in\n * columns that contain cards is absolutely positioned. This leads to column not being able to automatically shrink wrap\n * the cards, you will have to set a height on the swimlane (or task board if not using swimlanes) to size things\n * correctly.</div>\n *\n * {@region Keyboard shortcuts}\n * TaskBoard has the following default keyboard shortcuts:\n * <div class=\"compact\">\n *\n * | Keys                 | Action                 | Action description                                                         |\n * |----------------------|------------------------|----------------------------------------------------------------------------|\n * | `ArrowDown`          | *navigateDown*         | Moves focus to task below currently focused element                        |\n * | `ArrowLeft`          | *navigateLeft*         | Moves focus to task to the left of currently focused element               |\n * | `ArrowUp`            | *navigateUp*           | Moves focus to task above currently focused element                        |\n * | `ArrowRight`         | *navigateRight*        | Moves focus to task to the right of currently focused element              |\n * | `Enter`              | *activate*             | Show the Task Editor for currently focused task                            |\n * | `Space`              | *keyboardSelect*       | This selects or deselects the focused card (deselecting all others)        |\n * | `Ctrl`+`Space`       | *keyboardToggleSelect* | This selects or deselects the focused card, preserving any other selection |\n * | `Shift`+`ArrowDown`  | *selectDown*           | Hold `Shift` when keyboard navigating to extend selection                  |\n * | `Shift`+`ArrowLeft`  | *selectLeft*           | Hold `Shift` when keyboard navigating to extend selection                  |\n * | `Shift`+`ArrowUp`    | *selectUp*             | Hold `Shift` when keyboard navigating to extend selection                  |\n * | `Shift`+`ArrowRight` | *selectRight*          | Hold `Shift` when keyboard navigating to extend selection                  |\n *\n * </div>\n *\n * <div class=\"note\" style=\"font-size:0.9em\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * If you prefer for selection to always move with the arrow keys, see\n * {@link TaskBoard.view.mixin.TaskNavigation#config-selectOnNavigation}.\n *\n * The following TaskBoard features has their own keyboard shortcuts. Follow the links for details.\n * * {@link TaskBoard.feature.ColumnHeaderMenu#keyboard-shortcuts ColumnHeaderMenu}\n * * {@link TaskBoard.feature.SimpleTaskEdit#keyboard-shortcuts SimpleTaskEdit}\n * * {@link TaskBoard.feature.TaskMenu#keyboard-shortcuts TaskMenu}\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#TaskBoard/guides/customization/keymap.md).\n * {@endregion}\n *\n * ## Find out more\n *\n * * {@link TaskBoard.view.mixin.ExpandCollapse Expanding and collapsing columns and swimlanes}\n * * {@link TaskBoard.view.mixin.ResponsiveCards Responsive behaviour for cards}\n * * {@link TaskBoard.view.mixin.TaskBoardDom Resolving elements <-> records}\n * * {@link TaskBoard.view.mixin.TaskBoardDomEvents Handling card events}\n * * {@link TaskBoard.view.mixin.TaskBoardScroll Scrolling to tasks, columns and swimlanes}\n * * {@link TaskBoard.view.mixin.TaskItems Add content to task cards}\n * * {@link TaskBoard.view.mixin.TaskNavigation Keyboard navigation}\n * * {@link TaskBoard.view.mixin.TaskSelection Selection tasks using mouse and keyboard}\n *\n * @extends TaskBoard/view/TaskBoardBase\n * @classtype taskboard\n * @widget\n */\nexport default class TaskBoard extends TaskBoardBase {\n    static $name = 'TaskBoard';\n    static type = 'taskboard';\n    static configurable = {\n        //region Hidden members\n        /**\n         * @hideconfigs crudManager, crudManagerClass, contentElementCls, htmlCls, defaults, hideWhenEmpty, itemCls, items, layout, layoutStyle, lazyItems, namedItems, textContent, content, html, defaultBindProperty, monitorResize, ripple, tooltip, tag, textAlign, preventTooltipOnTouch\n         */\n        /**\n         * @hideproperties $name, isSettingValues, isValid, items, layout, record, values, content, contentElement, focusElement, html, overflowElement, layoutStyle, tooltip, scrollable\n         */\n        /**\n         * @hidefunctions attachTooltip, isOfTypeName, mixin, optionalL, callback, resolveCallback, add, getWidgetById, insert, processWidgetConfig, remove, removeAll, construct, doDestroy, updateLocalization, compose, eachAncestor, eachWidget, query, queryAll, L\n         */\n        /**\n         * @event beforeSetRecord\n         * @hide\n         */\n        //endregion\n        features : {\n            columnHeaderMenu : true,\n            columnToolbars   : true,\n            taskDrag         : true,\n            taskDragSelect   : true,\n            taskEdit         : true,\n            taskMenu         : true\n        }\n    };\n}\nTaskBoard.initClass();\nTaskBoard._$name = 'TaskBoard';", "import FilterField from '../../Core/widget/FilterField.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/ColumnFilterField\n */\n/**\n * A field that filters the columns of a linked {@link TaskBoard.view.TaskBoard} when typing into it.\n *\n * {@inlineexample TaskBoard/widget/ColumnFilterField.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'columnfilterfield' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new ColumnFilterField({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/FilterField\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype columnfilterfield\n * @widget\n */\nexport default class ColumnFilterField extends FilterField.mixin(TaskBoardLinked) {\n    static $name = 'ColumnFilterField';\n    static type = 'columnfilterfield';\n    static configurable = {\n        /**\n         * @hideconfigs store, filterFunction\n         */\n        store : 'this.taskBoard.columns',\n        /**\n         * The ColumnModel field name to filter by, defaults to `'text'`.\n         * @config {String}\n         * @default\n         * @category Common\n         */\n        field : 'text',\n        /**\n         * Label, defaults to a localized version of `'Filter columns'`.\n         *\n         * Content is determined by the `TaskBoard.filterColumns` key in the applied locale.\n         *\n         * @config {String}\n         * @category Label\n         */\n        label : 'L{TaskBoard.filterColumns}',\n        width : '20em',\n        triggers : {\n            filter : {\n                cls   : 'b-icon b-icon-filter',\n                align : 'start'\n            }\n        }\n    };\n}\nColumnFilterField.initClass();\nColumnFilterField._$name = 'ColumnFilterField';", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Button from '../../Core/widget/Button.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/ColumnPickerButton\n */\n/**\n * A button with a menu allowing the user to toggle which columns are shown on the {@link TaskBoard.view.TaskBoard}.\n *\n * {@inlineexample TaskBoard/widget/ColumnPickerButton.js}\n *\n * Click to display a menu populated with the columns held in {@link TaskBoard.view.TaskBoard#property-columns}.\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'columnpickerbutton' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new ColumnPickerButton({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/Button\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype columnpickerbutton\n * @widget\n */\nexport default class ColumnPickerButton extends Button.mixin(TaskBoardLinked) {\n    static $name = 'ColumnPickerButton';\n    static type = 'columnpickerbutton';\n    static configurable = {\n        text        : 'L{TaskBoard.Columns}',\n        icon        : 'b-icon-picker',\n        pressedIcon : 'b-icon-picker-rotated',\n        iconAlign   : 'end',\n        menuIcon    : null,\n        // items null needed to not be considered an object holding menu items\n        menu        : { items : null }\n    };\n    onToggleColumn({ item }) {\n        item.column.hidden = !item.checked;\n    }\n    // Populate menu before each show to make sure it is up to date\n    onMenuBeforeShow(info) {\n        super.onMenuBeforeShow(info);\n        info.source.items = this.taskBoard.columns.map(column => ({\n            ref     : column.id,\n            text    : StringHelper.encodeHtml(column.text),\n            checked : !column.hidden,\n            column,\n            onItem  : 'up.onToggleColumn'\n        }));\n    }\n}\nColumnPickerButton.initClass();\nColumnPickerButton._$name = 'ColumnPickerButton';", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Button from '../../Core/widget/Button.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/ColumnScrollButton\n */\n/**\n * A button with a menu allowing the user to pick a column to scroll to.\n *\n * {@inlineexample TaskBoard/widget/ColumnScrollButton.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'columnscrollbutton' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new ColumnScrollButton({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/Button\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype columnScrollButton\n * @widget\n */\nexport default class ColumnScrollButton extends Button.mixin(TaskBoardLinked) {\n    static $name = 'ColumnScrollButton';\n    static type = 'columnscrollbutton';\n    static configurable = {\n        text        : 'L{TaskBoard.scrollToColumn}',\n        icon        : 'b-icon-picker',\n        pressedIcon : 'b-icon-picker-rotated',\n        iconAlign   : 'end',\n        menuIcon    : null,\n        menu        : []\n    };\n    onClickColumn({ item }) {\n        this.setTimeout(() => this.taskBoard?.scrollToColumn(item.column), 100);\n    }\n    changeMenu(menu) {\n        // Nullified on destroy\n        if (menu) {\n            menu = this.taskBoard.columns.map(column => ({\n                ref    : column.id,\n                text   : StringHelper.encodeHtml(column.text),\n                column,\n                onItem : 'up.onClickColumn'\n            }));\n        }\n        return super.changeMenu(menu);\n    }\n}\nColumnScrollButton.initClass();\nColumnScrollButton._$name = 'ColumnScrollButton';", "import SchedulerProjectCombo from '../../Scheduler/widget/ProjectCombo.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/ProjectCombo\n */\n/**\n * Combo that allows picking a dataset to use for a {@link TaskBoard.model.ProjectModel}. Each item holds a title and\n * a load url to reconfigure the project with.\n *\n * {@inlineexample TaskBoard/widget/ProjectCombo.js}\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         {\n *             type : 'taskboardprojectcombo',\n *             items : [\n *                 { title : 'Important project', url : 'data/load.php?id=1' },\n *                 { title : 'Another project', url : 'data/load.php?id=2' }\n *             ]\n *         }\n *     ],\n *\n *     project : {\n *         transport : {\n *             load : {\n *                 url : 'data/load.php?id=1'\n *             }\n *         },\n *\n *         autoLoad : true\n *     }\n * });\n * ```\n *\n * @extends Scheduler/widget/ProjectCombo\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype taskboardprojectcombo\n * @widget\n *\n * @typings Scheduler.widget.ProjectCombo -> Scheduler.widget.SchedulerProjectCombo\n */\nexport default class ProjectCombo extends SchedulerProjectCombo.mixin(TaskBoardLinked) {\n    static $name = 'ProjectCombo';\n    static type = 'taskboardprojectcombo';\n    static configurable = {\n        /**\n         * Project to reconfigure when picking an item. Resolved automatically if a TaskBoard is configured or detected.\n         * @config {TaskBoard.model.ProjectModel}\n         * @category Common\n         */\n        project : null\n    };\n    updateTaskBoard(taskBoard) {\n        if (taskBoard) {\n            this.project = taskBoard.project;\n        }\n    }\n    afterConfigure() {\n        // Force linking to project if TaskBoard is auto detected\n        if (!this._taskBoard) {\n            this.updateTaskBoard(this.taskBoard);\n        }\n    }\n}\n// Register this widget type with its Factory\nProjectCombo.initClass();\nProjectCombo._$name = 'ProjectCombo';", "import FilterField from '../../Core/widget/FilterField.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/SwimlaneFilterField\n */\n/**\n * A field that filters the swimlanes of a linked {@link TaskBoard.view.TaskBoard} when typing into it.\n *\n * {@inlineexample TaskBoard/widget/SwimlaneFilterField.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'swimlanefilterfield' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new SwimlaneFilterField({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/FilterField\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype swimlanefilterfield\n * @widget\n */\nexport default class SwimlaneFilterField extends FilterField.mixin(TaskBoardLinked) {\n    static $name = 'SwimlaneFilterField';\n    static type = 'swimlanefilterfield';\n    static configurable = {\n        store : 'this.taskBoard.swimlanes',\n        field : 'text',\n        label : 'L{TaskBoard.filterSwimlanes}',\n        width : '20em',\n        triggers : {\n            filter : {\n                cls   : 'b-icon b-icon-filter',\n                align : 'start'\n            }\n        }\n    };\n}\nSwimlaneFilterField.initClass();\nSwimlaneFilterField._$name = 'SwimlaneFilterField';", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Button from '../../Core/widget/Button.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/SwimlanePickerButton\n */\n/**\n * A button with a menu allowing the user to toggle which swimlanes are shown on the {@link TaskBoard.view.TaskBoard}.\n *\n * {@inlineexample TaskBoard/widget/SwimlanePickerButton.js}\n *\n * Click to display a menu populated with the swimlanes held in {@link TaskBoard.view.TaskBoard#property-swimlanes}.\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'swimlanepickerbutton' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new SwimlanePickerButton({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/Button\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype swimlanepickerbutton\n * @widget\n */\nexport default class SwimlanePickerButton extends Button.mixin(TaskBoardLinked) {\n    static $name = 'SwimlanePickerButton';\n    static type = 'swimlanepickerbutton';\n    static configurable = {\n        text        : 'L{TaskBoard.Swimlanes}',\n        icon        : 'b-icon-picker',\n        pressedIcon : 'b-icon-picker-rotated',\n        iconAlign   : 'end',\n        menuIcon    : null,\n        // items null needed to not be considered an object holding menu items\n        menu        : { items : null }\n    };\n    onToggleSwimlane({ item }) {\n        item.swimlane.hidden = !item.checked;\n    }\n    // Populate menu before each show to make sure it is up to date\n    onMenuBeforeShow(info) {\n        super.onMenuBeforeShow(info);\n        info.source.items = this.taskBoard.swimlanes.map(swimlane => ({\n            ref     : swimlane.id,\n            text    : StringHelper.encodeHtml(swimlane.text),\n            checked : !swimlane.hidden,\n            swimlane,\n            onItem  : 'up.onToggleSwimlane'\n        }));\n    }\n}\nSwimlanePickerButton.initClass();\nSwimlanePickerButton._$name = 'SwimlanePickerButton';", "import StringHelper from '../../Core/helper/StringHelper.js';\nimport Button from '../../Core/widget/Button.js';\nimport '../../Core/widget/Menu.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/SwimlaneScrollButton\n */\n/**\n * A button with a menu allowing the user to pick a swimlane to scroll to.\n *\n * {@inlineexample TaskBoard/widget/SwimlaneScrollButton.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'swimlanescrollbutton' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new SwimlaneScrollButton({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/Button\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype swimlaneScrollButton\n * @widget\n */\nexport default class SwimlaneScrollButton extends Button.mixin(TaskBoardLinked) {\n    static $name = 'SwimlaneScrollButton';\n    static type = 'swimlanescrollbutton';\n    static configurable = {\n        text        : 'L{TaskBoard.scrollToSwimlane}',\n        icon        : 'b-icon-picker',\n        pressedIcon : 'b-icon-picker-rotated',\n        iconAlign   : 'end',\n        menuIcon    : null,\n        menu        : []\n    };\n    onClickSwimlane({ item }) {\n        this.setTimeout(() => this.taskBoard?.scrollToSwimlane(item.swimlane), 100);\n    }\n    changeMenu(menu) {\n        // Nullified on destroy\n        if (menu) {\n            menu = this.taskBoard.swimlanes.map(swimlane => ({\n                ref    : swimlane.id,\n                text   : StringHelper.encodeHtml(swimlane.text),\n                swimlane,\n                onItem : 'up.onClickSwimlane'\n            }));\n        }\n        return super.changeMenu(menu);\n    }\n}\nSwimlaneScrollButton.initClass();\nSwimlaneScrollButton._$name = 'SwimlaneScrollButton';", "import FilterField from '../../Core/widget/FilterField.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/TaskFilterField\n */\n/**\n * A field that filters the tasks of a linked {@link TaskBoard.view.TaskBoard} when typing into it.\n *\n * {@inlineexample TaskBoard/widget/TaskFilterField.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'taskfilterfield' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new TaskFilterField({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/FilterField\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype taskfilterfield\n * @widget\n */\nexport default class TaskFilterField extends FilterField.mixin(TaskBoardLinked) {\n    static $name = 'TaskFilterField';\n    static type = 'taskfilterfield';\n    static configurable = {\n        store : 'this.taskBoard.project.taskStore',\n        field : 'name',\n        label : 'L{TaskBoard.filterTasks}',\n        width : '20em',\n        triggers : {\n            filter : {\n                cls   : 'b-icon b-icon-filter',\n                align : 'start'\n            }\n        }\n    };\n}\nTaskFilterField.initClass();\nTaskFilterField._$name = 'TaskFilterField';", "import ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Editor from '../../Core/widget/Editor.js';\nimport Field from '../../Core/widget/Field.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport '../../Core/widget/List.js';\nimport '../../Core/widget/Button.js';\n/**\n * @module TaskBoard/widget/TodoListField\n */\n/**\n * A field that displays, and also lets users edit, a list of todo items. Each item has a checkbox to mark if the item\n * is completed or not and a button to edit its text/remove it. Designed to be used in the task editor, to work in\n * tandem with the {@link TaskBoard.view.item.TodoListItem}.\n *\n * {@inlineexample TaskBoard/widget/TodoListField.js}\n *\n * To hook it up, add it to the task editors items and link it to a field on your task model declared with\n * `type : 'array'`. The fields data is expected to be an array of objects. Configure {@link #config-textField} and\n * {@link #config-checkedField} to match the names used by the objects in your array.\n *\n * This snippet illustrates basic usage:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *    features : {\n *        taskEdit : {\n *            items : {\n *                todo : {\n *                    type         : 'todolist',\n *                    label        : 'Todo',\n *                    field        : 'todo',\n *                    // \"title\" property will be used as the todo item text\n *                    textField    : 'title',\n *                    // \"done\" property will drive the checkbox\n *                    checkedField : 'done'\n *                }\n *            }\n *        }\n *    },\n *\n *    project : {\n *        taskStore : {\n *            fields : [ { name : 'todo', type : 'array' } ]\n *        }\n *\n *        tasksData : [\n *            {\n *                id   : 1,\n *                name : 'Important task',\n *                todo : [\n *                    { title : 'Fix this', done : true },\n *                    { title : 'Fix that', done : false }\n *                ]\n *            }\n *        ]\n *    }\n * });\n * ```\n *\n * @extends Core/widget/Field\n * @classtype todolistfield\n * @classtypealias todolist\n * @inputfield\n */\nexport default class TodoListField extends Field {\n    static $name = 'TodoListField';\n    static type = 'todolistfield';\n    static alias = 'todolist';\n    static configurable = {\n        /**\n         * Name of a property on a todo item to display as its text.\n         *\n         * @config {String}\n         * @category Common\n         * @default\n         */\n        textField : 'text',\n        /**\n         * Name of a property on a todo item to use for the checkbox. The property is expected to be a boolean.\n         *\n         * @config {String}\n         * @category Common\n         * @default\n         */\n        checkedField : 'checked',\n        /**\n         * Configure as `false` to hide the per item edit button and the add item button. Users can still check/uncheck\n         * items.\n         *\n         * @config {Boolean}\n         * @default\n         */\n        editableItems : true,\n        list : {\n            type : 'list',\n            multiSelect : true,\n            store : {\n                fields : []\n            },\n            itemIconTpl() {\n                return `<i class=\"b-todo-checkbox b-icon\"></i>`;\n            }\n        },\n        addButton : {\n            type : 'button',\n            cls  : 'b-todo-add',\n            icon : 'b-icon-add',\n            text : 'L{TodoListField.add}'\n        },\n        role : null\n    };\n    compose() {\n        const { editableItems } = this;\n        return {\n            class : {\n                'b-editable' : editableItems\n            }\n        };\n    }\n    changeList(list) {\n        return Widget.create(ObjectHelper.assign({\n            // List does not support remapping out of the box\n            itemTpl : record => StringHelper.xss`<div class=\"b-todo-text\">${record.getValue(this.textField)}</div><i class='b-todo-edit b-icon b-icon-edit' data-noselect></i>`\n        }, list));\n    }\n    updateList(list) {\n        // Detect click on edit icon\n        list.ion({\n            item    : 'onItemClick',\n            thisObj : this\n        });\n        // Detect check/uncheck\n        list.ion({\n            selectionChange : 'onSelectionChange',\n            thisObj         : this\n        });\n    }\n    changeAddButton(button) {\n        const result = Widget.create(button);\n        this.ariaElement = result.element;\n        return result;\n    }\n    updateAddButton(button) {\n        button.ion({\n            click   : 'onAddClick',\n            thisObj : this\n        });\n    }\n    get childItems() {\n        return [this.list, this.addButton];\n    }\n    get inputElement() {\n        return this.list.element;\n    }\n    get innerElements() {\n        return super.innerElements.concat(this.addButton.element);\n    }\n    changeValue(value) {\n        value = value || [];\n        let autoUpdate = false;\n        // Auto update original array if we are used in an auto updating container\n        this.eachAncestor(a => {\n            if (a.autoUpdateRecord) {\n                autoUpdate = true;\n                return false;\n            }\n        });\n        // Original value (or a clone thereof if we are not live updating) is kept up to date on later modifications\n        this.originalValue = autoUpdate ? value : ObjectHelper.clone(value);\n        if (value) {\n            // Clone original value as our value, to not pollute the original value\n            value = ObjectHelper.clone(value);\n            value.forEach((v, i) => {\n                // id required by list\n                v.id = i + 1;\n                // map back to original value\n                v.originalIndex = i;\n            });\n        }\n        return value;\n    }\n    updateValue(value) {\n        if (value) {\n            const me = this;\n            // Populate the list with our value clone\n            me.list.items = value;\n            // Selection is used to check/uncheck items. Set flag to prevent updating original at this stage\n            me.isSettingValue = true;\n            me.list.selected.values = value.filter(v => v[me.checkedField]);\n            me.isSettingValue = false;\n        }\n    }\n    get value() {\n        // Always return a new array, required to flag array data field as modified / for UI to update\n        return this.originalValue.slice();\n    }\n    set value(value) {\n        super.value = value;\n    }\n    // Cant be invalid currently\n    get isValid() {\n        return true;\n    }\n    // Edit a todo item, using overlaid editor\n    editItem(record, element) {\n        const\n            me     = this,\n            // Always creating a new editor, destroyed when editing finishes\n            editor = new Editor({\n                appendTo   : me.element,\n                owner      : me,\n                cls        : 'b-todo-editor',\n                inputField : {\n                    type     : 'text',\n                    triggers : {\n                        remove : {\n                            cls : 'b-todo-remove b-icon-trash',\n                            handler() {\n                                me.removeItem(record);\n                                editor.cancelEdit();\n                            }\n                        }\n                    }\n                },\n                // Above modal\n                style             : 'z-index : 20000',\n                internalListeners : {\n                    complete({ value }) {\n                        me.originalValue[record.originalIndex][me.textField] = value;\n                        me.triggerFieldChange({ value : me.value, userAction : true });\n                    },\n                    finishEdit() {\n                        editor.destroy();\n                    },\n                    thisObj : me\n                }\n            });\n        // Start editing using configured field mapping\n        editor.startEdit({\n            target : element,\n            record,\n            field  : me.textField\n        });\n    }\n    // Remove a todo item, updating both the list and the original value\n    removeItem(record) {\n        const\n            me                = this,\n            { originalIndex } = record;\n        // Move following items up one notch to match position in originalValue after the splice below\n        me.list.store.forEach(r => {\n            if (r.parentIndex > record.parentIndex) {\n                r.originalIndex--;\n            }\n        });\n        me.list.store.remove(record);\n        me.originalValue.splice(originalIndex, 1);\n        me.triggerFieldChange({ value : me.value, userAction : true });\n    }\n    // Lists selection model is used to check/uncheck todo items. React on changes here\n    onSelectionChange() {\n        const\n            me       = this,\n            { list } = me;\n        if (!me.isSettingValue) {\n            me.originalValue.forEach((v, i) => {\n                const listRecord = list.store.getAt(i);\n                // Selection might change as a reaction to an item being removed = no listRecord\n                if (listRecord) {\n                    v[me.checkedField] = list.selected.includes(listRecord);\n                }\n            });\n            me.triggerFieldChange({ value : me.value, userAction : true });\n        }\n    }\n    // Clicked on a list item, react if it is on the edit icon\n    onItemClick({ record, event }) {\n        if (event.target.matches('.b-todo-edit')) {\n            this.editItem(record, event.target.closest('.b-list-item'));\n        }\n    }\n    // Clicked the add button, add to original value and then plug it back in to not have to care about syncing it with\n    // lists store\n    onAddClick() {\n        const me = this;\n        me.originalValue.push({\n            [me.textField]    : me.L('L{newTodo}'),\n            [me.checkedField] : false\n        });\n        me.value = me.originalValue;\n        me.triggerFieldChange({ value : me.value, userAction : true });\n    }\n}\nTodoListField.initClass();\nTodoListField._$name = 'TodoListField';", "import UndoRedoBase from '../../Core/widget/base/UndoRedoBase.js';\nimport '../../Core/widget/Combo.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/UndoRedo\n */\n/**\n * A widget encapsulating undo/redo functionality for the {@link TaskBoard.model.ProjectModel project} of a TaskBoard.\n *\n * To make use of this, the project must be configured with a\n * {@link Scheduler.model.mixin.ProjectModelMixin#config-stm State Tracking Manager}.\n *\n * If inserted into a TaskBoard (such as into a `tbar`, or `bbar`), the project of the that TaskBoard will be used.\n *\n * If this widget is to be used \"standalone\" (rendered into the DOM outside of a TaskBoard), this must be configured\n * with a reference the TaskBoard.\n *\n * There are three child widgets encapsulated which may be referenced through the {@link Core.widget.Container#property-widgetMap}:\n *\n * - `undoBtn` - The button which operates the undo operation\n * - `transactionsCombo` - A combobox into which is pushed the list of transactions,\n * - `redoBtn` - The button which operates the redo operation\n *\n * The transactionsCombo may be configured away if only the buttons are required:\n *\n * ```javascript\n * {\n *     type      : 'undoredo',\n *     items     : {\n *         transactionsCombo : null\n *     }\n * }\n * ```\n *\n * The example below illustrated how to embed an `undoredo` widget in the top toolbar of a TaskBoard:\n *\n * {@inlineexample TaskBoard/widget/UndoRedo.js}\n *\n * @demo TaskBoard/undo-redo\n *\n * @extends Core/widget/base/UndoRedoBase\n * @classtype taskboardundoredo\n * @widget\n */\nexport default class UndoRedo extends UndoRedoBase.mixin(TaskBoardLinked) {\n    static $name = 'UndoRedo';\n    static type = 'taskboardundoredo';\n    construct() {\n        super.construct(...arguments);\n        this.stm = this.taskBoard.project.stm;\n    }\n}\nUndoRedo.initClass();\nUndoRedo._$name = 'UndoRedo';", "import Slider from '../../Core/widget/Slider.js';\nimport TaskBoardLinked from './mixin/TaskBoardLinked.js';\n/**\n * @module TaskBoard/widget/ZoomSlider\n */\n/**\n * A slider that controls the {@link TaskBoard/view/TaskBoardBase#config-tasksPerRow} config of TaskBoard.\n *\n * {@inlineexample TaskBoard/widget/ZoomSlider.js}\n *\n * When used within a TaskBoard, it connects to it automatically:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({\n *     tbar : [\n *         { type : 'zoomslider' }\n *     ]\n * });\n * ```\n *\n * When used outside of a TaskBoard, it will query globally to find one but if there are multiple on page it might have\n * to be linked to one manually (see {@link TaskBoard/widget/mixin/TaskBoardLinked#config-taskBoard}:\n *\n * ```javascript\n * const taskBoard = new TaskBoard({});\n *\n * const picker = new ZoomSlider({\n *    taskBoard // Link it to the taskBoard instance created above\n * });\n * ```\n *\n * @extends Core/widget/Slider\n * @mixes TaskBoard/widget/mixin/TaskBoardLinked\n * @classtype zoomslider\n * @widget\n */\nexport default class ZoomSlider extends Slider.mixin(TaskBoardLinked) {\n    static $name = 'ZoomSlider';\n    static type = 'zoomslider';\n    static configurable = {\n        text : 'L{TaskBoard.zoom}',\n        max   : 10,\n        min   : 1,\n        // Override default to avoid hitting updater, value set in afterConstruct\n        value : null,\n        showValue : false\n    };\n    calculateValue(input) {\n        return this.max - input + 1;\n    }\n    afterConstruct() {\n        this.value = this.calculateValue(this.taskBoard.tasksPerRow);\n    }\n    onInput({ value }) {\n        this.taskBoard.tasksPerRow = this.calculateValue(value);\n    }\n    updateValue(value) {\n        super.updateValue(value);\n        this.onInput({ value });\n    }\n    getTooltipHtml(value) {\n        const tasksPerRow = this.calculateValue(value);\n        return `${tasksPerRow} card${tasksPerRow === 1 ? '' : 's'} per row`;\n    }\n}\nZoomSlider.initClass();\nZoomSlider._$name = 'ZoomSlider';"],
  "mappings": "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",
  "names": ["TaskBoardFeature", "InstancePlugin", "Factoryable_default", "args", "__publicField", "ColumnDrag", "me", "ColumnZone", "_a", "disable", "columnRecord", "columns", "beforeIndex", "items", "client", "rtl", "drag", "event", "Base", "Draggable_default", "Droppable_default", "Events_default", "owner", "itemElement", "startEvent", "taskBoard", "headerBounds", "Rectangle", "proxyOffset", "EventHelper", "proxy", "DomHelper", "elements", "element", "i", "columnClone", "bounds", "swimlane", "header", "DomSync", "body", "swimlaneClone", "headerClone", "bodyClone", "height", "paddingBottom", "position", "result", "beforeColumnRecord", "insertAt", "dropIndicator", "_b", "headerContainer", "actualHeaders", "ArrayHelper", "swimlaneRecord", "swimlaneBody", "actualColumns", "valid", "documentRoot", "proxyBounds", "overElement", "columnHeaderElement", "targetBounds", "beforeColumn", "shouldTrigger", "dropIndicators", "resolve", "commit", "finalizeAbort", "original", "ColumnHeaderMenu", "ContextMenuBase", "config", "ObjectHelper", "fn", "columnHeaderConfig", "ColumnToolbars", "toolbar", "location", "columnMap", "namedItems", "key", "clonedItems", "ref", "namedItem", "item", "columnConfig", "columnId", "swimlaneId", "column", "source", "TaskItem", "editor", "actions", "SimpleTaskEdit", "addNewAtEnd", "taskRecord", "taskItem", "itemEditorConfig", "Editor", "color", "cardElement", "itemElements", "index", "prevTaskRecord", "prevCardElement", "prevItemElements", "nextTaskRecord", "actionName", "SwimlaneDrag", "SwimlaneZone", "swimlaneElement", "padding", "beforeSwimlaneRecord", "taskBoardBounds", "beforeSwimlane", "swimlanes", "cardSelector", "indexOf", "ignoreOriginal", "hasChanged", "TaskDrag", "TaskZone", "columnEl", "cardClones", "taskRecords", "t", "a", "b", "taskElements", "r", "taskElement", "elementData", "cardClone", "AsyncHelper", "dragRootElement", "parentBounds", "listeners", "nextSibling", "parentElement", "x", "y", "_c", "domEvent", "clientX", "clientY", "columnElement", "targetSwimlane", "targetColumn", "tasksPerRow", "cardGap", "columnRect", "topCard", "top", "centerX", "cardAbove", "cardBelow", "columnContentWidth", "columnPadding", "innerColumnWidth", "cardBefore", "cardAfter", "insertBefore", "cardRect", "targetTaskRecord", "card", "columnField", "swimlaneField", "taskStore", "columnRecords", "swimlaneRecords", "task", "invalid", "moveBefore", "newWeight", "tasksBelow", "taskAbove", "weightDiff", "toSet", "dropClone", "TaskDragSelect", "threshold", "cardElements", "el", "record", "cardRectangles", "rectangle", "len", "cardData", "shouldSelect", "startX", "startY", "deltaX", "deltaY", "left", "width", "rect", "state", "TaskBoardLinked_default", "Target", "widget", "Widget", "ColorBoxCombo", "Combo", "className", "text", "html", "StringHelper", "ColumnCombo", "ResourcesCombo", "resourceRecord", "value", "old", "AvatarRendering", "avatarRendering", "SwimlaneCombo", "TaskColorPicker", "ColorPicker", "TaskColorCombo", "ColorField", "TaskEditor", "Popup", "resources", "autoUpdate", "values", "TaskEdit", "editorConfig", "editorType", "processItems", "editorClass", "combinedItems", "BrowserHelper", "Scroller", "TaskMenu", "triggerEvent", "selector", "targetElement", "buttonElement", "eventParams", "alignSpec", "disabled", "selectedTasks", "resourceStore", "eventStore", "isSelected", "col", "sibling", "lane", "resource", "avatar", "TaskTooltip", "template", "tooltip", "oldTooltip", "Tooltip", "tip", "activeTarget", "children", "ColumnModel", "Model", "TaskModel", "EventModel", "TaskStore", "EventStore", "records", "ProjectModel", "ProjectCrudManager_default", "store", "data", "assignmentStore", "SwimlaneModel", "ExpandCollapse_default", "showCollapseInHeader", "collapse", "columnElements", "headerElement", "hasFixedWidth", "cardWidth", "columnWidth", "collapseTitle", "hasSwimlanes", "showCollapseTooltip", "collapsed", "collapsible", "swimlaneConfig", "ResponsiveCards_default", "cardSizes", "perRow", "size", "entries", "shouldRecompose", "entry", "target", "contentRect", "cardSize", "observer", "oldObserver", "transitionChangeActions", "TaskBoardColumns_default", "autoGenerateColumns", "field", "storage", "Store", "action", "options", "inVisualOrder", "set", "tasks", "swimlaneDelta", "wrap", "columnTasks", "nextTaskIndex", "prevTaskIndex", "TaskBoardDom_default", "taskColumnElement", "laneId", "name", "defaultValue", "TaskBoardDomEvents_default", "_hoveredCardElement", "__privateAdd", "domListeners", "eventName", "__privateGet", "__privateSet", "domConfig", "lastDomConfig", "syncId", "jsx", "_d", "_e", "_f", "elementType", "isRefresh", "reactComponent", "taskId", "TaskBoardScroll_default", "firstPaint", "scrollOptions", "swimlaneOrId", "columnOrId", "taskOrId", "edgeOffset", "reject", "detach", "renderedTaskRecord", "VersionHelper", "TaskBoardStores_default", "newTaskDefaults", "project", "listenersConfig", "changes", "taskData", "columnBody", "lastCard", "suspended", "synced", "TaskBoardSwimlanes_default", "autoGenerateSwimlanes", "TaskBoardVirtualization_default", "virtualize", "getTaskHeight", "isIntersecting", "instanceMeta", "wasIntersecting", "id", "domId", "weight", "isVirtualized", "meta", "TextItem", "ResourceAvatarsItem", "maxAvatars", "resourceImagePath", "hasOverflow", "overflowCount", "lastResource", "fieldLess", "taskItemSelector", "afterRe", "beforeRe", "TaskItems_default", "typeCls", "cardConfig", "sizeHeaderItems", "sizeBodyItems", "sizeFooterItems", "footer", "headerItems", "bodyItems", "footerItems", "taskItemElement", "navigationActions", "TaskNavigation_default", "gap", "forceSelect", "currentlyFocusedTask", "taskToFocus", "keyEvent", "select", "found", "nextColumnRecord", "nextColumnElement", "prevColumnRecord", "prevColumnElement", "nextTask", "prevTask", "taskBoardData", "TaskSelection_default", "add", "deselect", "bryntumEvent", "bodyConfig", "ImageItem", "JsxItem", "ProgressItem", "percent", "RatingItem", "max", "SeparatorItem", "TagCombo", "separator", "tags", "taskTags", "TagsItem", "str", "tag", "cls", "TemplateItem", "TodoListItem", "textField", "checkedField", "clsField", "checkedIcon", "uncheckedIcon", "todo", "clone", "locale", "En_default", "LocaleHelper", "weightSorter", "TaskBoardBase", "Panel", "Pluggable_default", "State_default", "Featureable_default", "Styleable_default", "CrudManagerView_default", "Responsive_default", "useDomTransition", "stickyHeaders", "scrollManager", "oldScrollManager", "ScrollManager", "showCountInHeader", "swimlaneRenderer", "taskRenderer", "overriddenCard", "eventColor", "namedColor", "flex", "minWidth", "taskSorterFn", "stretchCards", "elementId", "TaskMenuItem", "TaskBoard", "ColumnFilterField", "FilterField", "ColumnPickerButton", "Button", "info", "ColumnScrollButton", "menu", "ProjectCombo", "SwimlaneFilterField", "SwimlanePickerButton", "SwimlaneScrollButton", "TaskFilterField", "TodoListField", "Field", "editableItems", "list", "button", "v", "originalIndex", "listRecord", "UndoRedo", "UndoRedoBase", "ZoomSlider", "Slider", "input"]
}
