{
  "version": 3,
  "sources": ["../../../Grid/lib/Grid/column/ActionColumn.js", "../../../Grid/lib/Grid/column/AggregateColumn.js", "../../../Grid/lib/Grid/column/PercentColumn.js", "../../../Grid/lib/Grid/column/RatingColumn.js", "../../../Grid/lib/Grid/column/TemplateColumn.js", "../../../Grid/lib/Grid/column/TimeColumn.js", "../../../Grid/lib/Grid/feature/CellCopyPaste.js", "../../../Grid/lib/Grid/feature/CellTooltip.js", "../../../Grid/lib/Grid/feature/ColumnRename.js", "../../../Grid/lib/Grid/feature/FillHandle.js", "../../../Grid/lib/Grid/feature/MergeCells.js", "../../../Grid/lib/Grid/feature/QuickFind.js", "../../../Grid/lib/Grid/feature/RowExpander.js", "../../../Grid/lib/Grid/feature/Search.js", "../../../Grid/lib/Grid/feature/StickyCells.js", "../../../Grid/lib/Grid/feature/experimental/FileDrop.js", "../../../Grid/lib/Grid/widget/GroupBar.js", "../../../Grid/lib/Grid/widget/TreeCombo.js", "../../../Grid/bundle/entry.thin.js"],
  "sourcesContent": ["import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\n/**\n * @module Grid/column/ActionColumn\n */\n/**\n * Config object for an action in an ActionColumn.\n * @typedef {Object} ActionConfig\n * @property {String} cls CSS Class for action icon\n * @property {Function|String|TooltipConfig} tooltip Tooltip text, or a config object which can reconfigure the shared\n * tooltip by setting boolean, numeric and string config values, or a function to return the tooltip text, passed the\n * row's `record`\n * @property {Function|Boolean} visible Boolean to define the action icon visibility or a callback function, passed the\n * row's `record`, to change it dynamically\n * @property {Function} onClick Callback to handle click action item event, passed the row's `record`\n * @property {Boolean} showForGroup Set to true to have action icon visible in group headers only when using the `group`\n * feature\n * @property {Function|String} renderer A render function, or the name of a function in the Grid's ownership tree used\n * to define the action element. Passed the row's `record`, expected to return an HTML string or a DOM config object.\n * **Note**: when specified, the `cls` action config is ignored. Make sure you add an action icon manually, for example:\n * ```javascript\n * {\n *      type    : 'action',\n *      text    : 'Increase amount',\n *      actions : [{\n *          cls      : 'b-fa b-fa-plus', // this line will be ignored\n *          renderer : ({ record }) => '<i class=\"b-action-item b-fa b-fa-plus\"></i> ' + record.name,\n *          onClick  : ({ record }) => {}\n *      }]\n * }\n * ```\n *\n * or\n *\n * ```javascript\n * {\n *      type    : 'action',\n *      text    : 'Increase amount',\n *      actions : [{\n *          cls      : 'b-fa b-fa-plus', // this line will be ignored\n *          renderer : 'up.renderAction' // Defined on the Grid\n *          onClick  : ({ record }) => {}\n *      }]\n * }\n * ```\n */\n/**\n * A column that displays actions as clickable icons in the cell.\n *\n * {@inlineexample Grid/column/ActionColumn.js}\n *\n * ```javascript\n * new TreeGrid({\n *     appendTo : document.body,\n *     columns  : [{\n *         type    : 'action',\n *         text    : 'Increase amount',\n *         actions : [{\n *             cls      : 'b-fa b-fa-plus',\n *             renderer : ({ action, record }) => `<i class=\"b-action-item ${action.cls} b-${record.enabled ? \"green\" : \"red\"}-class\"></i>`,\n *             visible  : ({ record }) => record.canAdd,\n *             tooltip  : ({ record }) => `<p class=\"b-nicer-than-default\">Add to ${record.name}</p>`,\n *             onClick  : ({ record }) => console.log(`Adding ${record.name}`)\n *         }, {\n *             cls     : 'b-fa b-fa-pencil',\n *             tooltip : 'Edit note',\n *             onClick : ({ record }) => console.log(`Editing ${record.name}`)\n *         }]\n *     }]\n * });\n * ```\n *\n * Actions may be placed in {@link Grid/feature/Group} headers, by setting `action.showForGroup` to `true`. Those\n * actions will not be shown on normal rows.\n *\n * @extends Grid/column/Column\n * @classtype action\n * @column\n */\nexport default class ActionColumn extends Column {\n    static type = 'action';\n    static fields = [\n        /**\n         * An array of action config objects, see {@link #typedef-ActionConfig} for details.\n         *\n         * ```javascript\n         * new Grid({\n         *     columns  : [{\n         *         type    : 'action',\n         *         text    : 'Actions',\n         *         actions : [{\n         *             cls      : 'b-fa b-fa-plus',\n         *             visible  : ({ record }) => record.canAdd,\n         *             onClick  : ({ record }) => console.log(`Adding ${record.name}`)\n         *         }, {\n         *             cls     : 'b-fa b-fa-pencil',\n         *             tooltip : 'Edit note',\n         *             onClick : ({ record }) => console.log(`Editing ${record.name}`)\n         *         }]\n         *     }]\n         * });\n         * ```\n         *\n         * @config {ActionConfig[]} actions List of action configs\n         * @category Common\n         */\n        { name : 'actions', type : 'array' },\n        /**\n         * Set true to hide disable actions in this column if the grid is {@link Core.widget.Widget#config-readOnly}\n         * @config {Boolean} disableIfGridReadOnly\n         * @default\n         * @category Common\n         */\n        { name : 'disableIfGridReadOnly', defaultValue : false }\n    ];\n    static defaults = {\n        /**\n         * Filtering by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} filterable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        filterable : false,\n        /**\n         * Grouping by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} groupable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        groupable : false,\n        /**\n         * Sorting by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} sortable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        sortable : false,\n        /**\n         * Editor for action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} editor\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        editor : false,\n        /**\n         * Searching by action column is not supported by default, because it has a custom renderer and uses HTML with icons as content.\n         * @config {Boolean} searchable\n         * @default false\n         * @category Interaction\n         * @hide\n         */\n        searchable : false,\n        /**\n         * By default, for action column this flag is switched to `true`, because the content of this column is always HTML.\n         * @config {Boolean} htmlEncode\n         * @default false\n         * @category Misc\n         * @hide\n         */\n        htmlEncode : false,\n        /**\n         * Set to `true` to allow the column to being drag-resized when the ColumnResize plugin is enabled.\n         * @config {Boolean} resizable\n         * @default false\n         * @category Interaction\n         */\n        resizable : false,\n        /**\n         * Column minimal width. If value is Number then minimal width is in pixels.\n         * @config {Number|String} minWidth\n         * @default 30\n         * @category Layout\n         */\n        minWidth : 30\n    };\n    get groupHeaderReserved() {\n        return true;\n    }\n    construct(config, store) {\n        const me = this;\n        super.construct(...arguments);\n        // use auto-size only as default behaviour\n        if (!config.width && !config.flex) {\n            me.grid.ion({ paint : 'updateAutoWidth', thisObj : me });\n        }\n        if (me.disableIfGridReadOnly) {\n            me.grid.element.classList.add('b-actioncolumn-readonly');\n        }\n        // If column is cloned, renderer is already set up\n        if (me.renderer !== me.internalRenderer) {\n            me.externalRenderer = me.renderer;\n            me.renderer = me.internalRenderer;\n        }\n    }\n    /**\n     * Renderer that displays action icon(s) in the cell.\n     * @private\n     */\n    internalRenderer({ grid, column, record, callExternalRenderer = true }) {\n        const\n            inGroupTitle = record && ('groupRowFor' in record.meta),\n            { subGrid }  = column;\n        if (callExternalRenderer) {\n            this.externalRenderer?.(...arguments);\n        }\n        return {\n            className : { 'b-action-ct' : 1 },\n            children  : column.actions?.map((actionConfig, index) => {\n                if ('visible' in actionConfig) {\n                    if ((typeof actionConfig.visible === 'function') && actionConfig.visible({ record }) === false) {\n                        return '';\n                    }\n                    if (actionConfig.visible === false) {\n                        return '';\n                    }\n                }\n                // check if an action allowed to be shown in case of using grouping\n                if ((inGroupTitle && !actionConfig.showForGroup) || (!inGroupTitle && actionConfig.showForGroup)) {\n                    return '';\n                }\n                const\n                    {\n                        tooltip,\n                        renderer\n                    }    = actionConfig,\n                    btip = (typeof tooltip === 'function' || tooltip?.startsWith?.('up.')) ? subGrid.callback(tooltip, subGrid, [{ record }]) : tooltip || '';\n                // handle custom renderer if it is specified\n                if (renderer) {\n                    const customRendererData = subGrid.callback(renderer, subGrid, [{\n                        index,\n                        record,\n                        column,\n                        tooltip : btip,\n                        action  : actionConfig\n                    }]);\n                    // take of set data-index to make onClick handler work stable\n                    if (typeof customRendererData === 'string') {\n                        return {\n                            tag     : 'span',\n                            dataset : {\n                                ...Tooltip.encodeConfig(btip),\n                                index\n                            },\n                            html : customRendererData\n                        };\n                    }\n                    else {\n                        customRendererData.dataset = customRendererData.dataset || {};\n                        customRendererData.dataset.index = index;\n                        return customRendererData;\n                    }\n                }\n                else {\n                    return {\n                        tag     : 'button',\n                        dataset : {\n                            ...Tooltip.encodeConfig(btip),\n                            index\n                        },\n                        'aria-label' : btip,\n                        className    : {\n                            'b-tool'           : 1,\n                            'b-action-item'    : 1,\n                            [actionConfig.cls] : actionConfig.cls\n                        }\n                    };\n                }\n            })\n        };\n    }\n    /**\n     * Handle icon click and call action handler.\n     * @private\n     */\n    onCellClick({ column, record, target }) {\n        if (column !== this || !target.classList.contains('b-action-item')) {\n            return;\n        }\n        let actionIndex = target.dataset.index;\n        // index may be set in a parent node if user used an html string in his custom renderer\n        // and we take care to set this property to support onClick handler\n        if (!actionIndex) {\n            actionIndex = target.parentElement.dataset && target.parentElement.dataset.index;\n        }\n        const\n            action        = column.actions?.[actionIndex],\n            actionHandler = action?.onClick;\n        if (actionHandler) {\n            this.callback(actionHandler, column, [{ record, action, target }]);\n        }\n    }\n    /**\n     * Update width for actions column to fit content.\n     * @private\n     */\n    updateAutoWidth() {\n        const\n            me           = this,\n            groupActions = [],\n            {\n                actions : oldActions\n            }            = me;\n        // header may be disabled, in that case we won't be able to calculate the width properly\n        if (!me.element) {\n            return;\n        }\n        const actions = me.actions = [];\n        // collect group and non group actions to check length later\n        oldActions?.forEach(actionOriginal => {\n            const action = { ...actionOriginal };\n            // remove possible visibility condition to make sure an action will exists in test HTML\n            delete action.visible;\n            // group actions shows in different row and never together with non group\n            if (action.showForGroup) {\n                delete action.showForGroup;\n                groupActions.push(action);\n            }\n            else {\n                actions.push(action);\n            }\n        });\n        // use longest actions length to calculate column width\n        if (groupActions.length > actions.length) {\n            me._actions = groupActions;\n        }\n        const actionsHtml = DomHelper.createElement(me.internalRenderer({ column : me, callExternalRenderer : false })).outerHTML;\n        me.width = DomHelper.measureText(actionsHtml, me.element, true, me.element.parentElement);\n        me.actions = oldActions;\n    }\n}\nColumnStore.registerColumnType(ActionColumn);\nActionColumn.exposeProperties();\nActionColumn._$name = 'ActionColumn';", "import ColumnStore from '../data/ColumnStore.js';\nimport NumberColumn from './NumberColumn.js';\n/**\n * @module Grid/column/AggregateColumn\n */\n/**\n * A column, which, when used as part of a {@link Grid.view.TreeGrid}, aggregates the values of this column's descendants using\n * a configured function which defaults to `sum`. The aggregate value is re-calculated after any change to the data,\n * and if you want aggregate values to be change-tracked, please set {@link #config-includeParentInChangeSet} to true.\n *\n * Default editor depends on the data field type. If it is a number, default editor is a {@link Core/widget/NumberField}.\n * Otherwise Default editor is a {@link Core/widget/TextField}.\n *\n * ```javascript\n * const grid = new TreeGrid({\n *     // Custom aggregation handler.\n *     // For test purposes, this just does \"sum\"\n *     myAggregator(...values) {\n *         let result = 0;\n *\n *         for (let i = 0, { length } = values; i < length; i++) {\n *             result += parseInt(args[i], 10);\n *         }\n *         return result;\n *     },\n *     columns : [\n *         { field : 'name', text : 'Name' },\n *\n *         // Will sum the ages of leaf nodes. This is the default.\n *         { type : 'aggregate', field : 'age', text : 'Age', renderer : ({ value }) => `<b>${value}<b>` },\n *\n *         // Will use AggregateColumn's built-in avg of scores of leaf nodes\n *         { type : 'aggregate', field : 'score', text : 'Score', function : 'avg' },\n *\n *         // Will use the grid's myAggregator function\n *         { type : 'aggregate', field : 'revenue', text : 'Revenue', function : 'up.myAggregator' },\n *     ]\n * });\n * ```\n *\n * @extends Grid/column/NumberColumn\n * @classtype aggregate\n * @column\n */\nexport default class AggregateColumn extends NumberColumn {\n    //region Config\n    static type = 'aggregate';\n    static fields = [\n        'function',\n        'includeParentInChangeSet'\n    ];\n    static get defaults() {\n        return {\n            /**\n             * Math Function name, or function name prepended by `\"up.\"` that is resolvable in an\n             * ancestor component (such as the owning Grid, or a height Container), or a function to\n             * use to aggregate child record values for this column, or a function.\n             *\n             * This Column is provided with a `sum` and `avg` function. The default function is `sum`\n             * which is used for the aggregation.\n             *\n             * The function is passed a set of child node values, each value in a separate argument\n             * and should return a single value based upon the value set passed.\n             * @config {'sum'|'avg'|'min'|'max'|Function}\n             * @param {Core.data.Model[]} records Records for aggregation\n             * @returns {*} Aggregated value\n             * @category Common\n             */\n            function : 'sum',\n            /**\n             * Set to `true` to include changes to parent (aggregate) rows in the store's modification tracking.\n             * @config {Boolean} includeParentInChangeSet\n             * @category Common\n             */\n            includeParentInChangeSet : false\n        };\n    }\n    construct(data, columnStore) {\n        const me = this;\n        me.configuredAlign = 'align' in data;\n        me.configuredEditor = 'editor' in data;\n        super.construct(...arguments);\n        const { grid } = columnStore;\n        // 'sum' is reserved by Summary feature, so we use a different name\n        if (me.function === 'sum') {\n            me.function = 'sumChildren';\n        }\n        if (grid) {\n            me.store = grid.store;\n        }\n    }\n    set store(store) {\n        const\n            me             = this,\n            storeListeners = {\n                update  : 'onRecordUpdate',\n                thisObj : me,\n                prio    : 1000\n            },\n            oldStore = me._store;\n        if (store !== oldStore) {\n            if (oldStore) {\n                oldStore.un(storeListeners);\n            }\n            me._store = store;\n            const\n                { modelClass } = store,\n                field = modelClass.fieldMap[me.field];\n            // It's *likely*, but not certain that this will be used for a numeric field.\n            // Use numeric defaults unless configured otherwise if so.\n            if (field && field.type === 'number') {\n                if (!me.configuredAlign) {\n                    me.align = 'end';\n                }\n                if (!me.configuredEditor) {\n                    me.editor = 'number';\n                }\n            }\n            store.ion(storeListeners);\n        }\n    }\n    canEdit(record) {\n        return record.isLeaf;\n    }\n    get store() {\n        return this._store;\n    }\n    sumChildren(...args) {\n        let result = 0;\n        for (let i = 0, { length } = args; i < length; i++) {\n            result += parseFloat(args[i] || 0, 10);\n        }\n        return result;\n    }\n    avg(...args) {\n        let result = 0;\n        const { length } = args;\n        for (let i = 0; i < length; i++) {\n            result += parseFloat(args[i] || 0, 10);\n        }\n        return result / length;\n    }\n    onRecordUpdate({ record, changes }) {\n        const\n            me = this,\n            { rowManager } = me.grid;\n        if (me.field in changes) {\n            if (record.isLeaf) {\n                record.bubble(rec => {\n                    const row = rowManager.getRowFor(rec);\n                    if (row) {\n                        const cellElement = row.getCell(me.field);\n                        if (cellElement) {\n                            row.renderCell(cellElement);\n                        }\n                    }\n                }, true);\n            }\n        }\n    }\n    getRawValue(record) {\n        let value;\n        const\n            me        = this,\n            { field } = me;\n        if (record.children?.length) {\n            const\n                fn       = me.function,\n                isMathFn = typeof fn === 'string' && typeof Math[fn] === 'function',\n                {\n                    handler,\n                    thisObj\n                } = isMathFn ? {\n                    handler : Math[fn],\n                    thisObj : Math\n                } : me.resolveCallback(fn);\n            // Gather all child node values before passing them to the aggregator function.\n            value = handler.apply(thisObj, record.children.map(r => me.getRawValue(r)));\n            if (me.includeParentInChangeSet) {\n                record.set(field, value, true);\n            }\n            else {\n                record.setData(field, value);\n            }\n        }\n        else {\n            value = record.getValue(field);\n        }\n        return value;\n    }\n    canFillValue() {\n        return false;\n    }\n}\nColumnStore.registerColumnType(AggregateColumn, true);\nAggregateColumn.exposeProperties();\nAggregateColumn._$name = 'AggregateColumn';", "import NumberColumn from './NumberColumn.js';\nimport ColumnStore from '../data/ColumnStore.js';\n/**\n * @module Grid/column/PercentColumn\n */\n/**\n * A column that display a basic progress bar.\n *\n * {@inlineexample Grid/column/PercentColumn.js}\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         { type: 'percent', text: 'Progress', data: 'progress' }\n *     ]\n * });\n * ```\n *\n * Default editor is a {@link Core.widget.NumberField NumberField}.\n *\n * @extends Grid/column/NumberColumn\n * @classtype percent\n * @column\n */\nexport default class PercentColumn extends NumberColumn {\n    static type = 'percent';\n    // Type to use when auto adding field\n    static fieldType = 'number';\n    static fields = ['showValue', 'lowThreshold'];\n    static get defaults() {\n        return {\n            min : 0,\n            max : 100,\n            /**\n             * Set to `true` to render the number value inside the bar, for example `'15%'`.\n             * @config {Boolean}\n             * @default\n             * @category Rendering\n             */\n            showValue : false,\n            /**\n             * When below this percentage the bar will have `b-low` CSS class added. By default it turns the bar red.\n             * @config {Number}\n             * @default\n             * @category Rendering\n             */\n            lowThreshold : 20,\n            htmlEncode      : false,\n            searchable      : false,\n            summaryRenderer : ({ sum }) => `${sum}%`,\n            fitMode         : false\n        };\n    }\n    constructor(config, store) {\n        super(...arguments);\n        this.internalCellCls = 'b-percent-bar-cell';\n    }\n    /**\n     * Renderer that displays a progress bar in the cell. If you create a custom renderer, and want to include the\n     * default markup you can call `defaultRenderer` from it.\n     *\n     * ```javascript\n     * new Grid({\n     *     columns: [\n     *         {\n     *             type: 'percent',\n     *             text : 'Percent',\n     *             field : 'percent',\n     *             renderer({ value }) {\n     *                 const domConfig = this.defaultRenderer();\n     *\n     *                 if (value > 100) {\n     *                     domConfig.className = b-percent-bar-outer over-allocated';\n     *                 }\n     *\n     *                 return domConfig;\n     *             }\n     *         }\n     *     ]\n     * }\n     * ```\n     *\n     * @param {Object} rendererData The data object passed to the renderer\n     * @param {Number} rendererData.value The value to display\n     * @returns {DomConfig} DomConfig object representing the default markup for the cells content\n     */\n    defaultRenderer({ value }) {\n        value = value || 0;\n        return {\n            className       : 'b-percent-bar-outer',\n            role            : 'progressbar',\n            'aria-valuemin' : 0,\n            'aria-valuemax' : 100,\n            'aria-valuenow' : value,\n            'aria-label'    : value + '%',\n            tabIndex        : 0,\n            children        : [\n                {\n                    tag       : 'div',\n                    className : {\n                        'b-percent-bar' : 1,\n                        'b-zero'        : value === 0,\n                        'b-low'         : value < this.lowThreshold\n                    },\n                    style : {\n                        width : value + '%'\n                    },\n                    children : [\n                        this.showValue ? {\n                            tag  : 'span',\n                            text : value + '%'\n                        } : undefined\n                    ]\n                }\n            ]\n        };\n    }\n    // Null implementation because the column width drives the width of its content.\n    // So the concept of sizing to content is invalid here.\n    resizeToFitContent() {}\n}\nPercentColumn.sum = 'average';\nColumnStore.registerColumnType(PercentColumn, true);\nPercentColumn._$name = 'PercentColumn';", "import NumberColumn from './NumberColumn.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\n/**\n * @module Grid/column/RatingColumn\n */\n/**\n * A column that displays a star rating. Click a start to set a value, shift+click to unset a single start from the end.\n * Clicking the first and only star toggles it.\n *\n * This column uses a custom widget as its editor, and it is not intended to be changed.\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         { type: 'rating', max : 10, field: 'rating' }\n *     ]\n * });\n * ```\n *\n * {@inlineexample Grid/column/RatingColumn.js}\n *\n * @extends Grid/column/NumberColumn\n * @classtype rating\n * @column\n */\nexport default class RatingColumn extends NumberColumn {\n    static $name = 'RatingColumn';\n    static type = 'rating';\n    // Type to use when auto adding field\n    static fieldType = 'number';\n    static fields = ['emptyIcon', 'filledIcon', 'editable'];\n    static get defaults() {\n        return {\n            min : 0,\n            max : 5,\n            /**\n             * The empty rating icon to show\n             * @config {String}\n             * @category Rendering\n             */\n            emptyIcon : 'b-icon b-icon-star',\n            /**\n             * The filled rating icon to show\n             * @config {String}\n             * @category Rendering\n             */\n            filledIcon : 'b-icon b-icon-star',\n            /**\n             * Allow user to click an icon to change the value\n             * @config {Boolean}\n             * @category Interaction\n             */\n            editable : true,\n            filterType : 'number',\n            searchable : false,\n            width      : '11.2em',\n            htmlEncode : false,\n            minWidth   : '11.2em',\n            editor     : false,\n            fitMode    : 'value'\n        };\n    }\n    /**\n     * Renderer that displays a number of stars in the cell. Also adds CSS class 'b-rating-cell' to the cell.\n     * @private\n     */\n    renderer({ value }) {\n        return {\n            className : {\n                'b-rating-cell-inner' : 1,\n                'b-not-editable'      : !this.editable\n            },\n            children : ArrayHelper.populate(this.max, i => {\n                const filled = i < value;\n                return {\n                    tag       : 'i',\n                    className : {\n                        'b-rating-icon'                             : true,\n                        'b-filled'                                  : filled,\n                        'b-empty'                                   : !filled,\n                        [filled ? this.filledIcon : this.emptyIcon] : true\n                    }\n                };\n            })\n        };\n    }\n    onCellClick({ grid, column, record, target, event }) {\n        if (target.classList.contains('b-rating-icon') && !grid.readOnly && column.editable) {\n            let starIndex = [].indexOf.call(target.parentNode.childNodes, target);\n            if (target.classList.contains('b-filled') && (event.metaKey || event.shiftKey)) {\n                starIndex = starIndex - 1;\n            }\n            // Clicking first star when it is only one removes it\n            if (record.getValue(column.field) === 1 && starIndex === 0) {\n                starIndex = -1;\n            }\n            record.set(column.field, starIndex + 1);\n        }\n    }\n}\nColumnStore.registerColumnType(RatingColumn, true);\nRatingColumn.exposeProperties();\nRatingColumn._$name = 'RatingColumn';", "import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\n/**\n * @module Grid/column/TemplateColumn\n */\n/**\n * A column that uses a template for cell content. Any function can be used as template, and the function is passed { value, record, field } properties.\n * It should return a string which will be rendered in the cell.\n *\n * Default editor is a {@link Core.widget.TextField TextField}.\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *         { type: 'template', field: 'age', template: ({value}) => `${value} years old` }\n *     ]\n * });\n * ```\n *\n * {@inlineexample Grid/column/TemplateColumn.js}\n *\n * @extends Grid/column/Column\n * @classtype template\n * @column\n */\nexport default class TemplateColumn extends Column {\n    static type = 'template';\n    static fields = [\n        /**\n         * Template function used to generate a value displayed in the cell. Called with arguments `{ value, record, field }`\n         *\n         * @config {Function} template\n         * @param {Object} data An object that contains data about the cell being rendered.\n         * @param {*} data.value The value (only present when you set a `field` on the column)\n         * @param {Core.data.Model} data.record The record representing the row\n         * @param {String} data.field The column field name\n         * @returns {DomConfig|String|null} String or DomConfig object representing the HTML markup\n         * @category Common\n         */\n        'template'\n    ];\n    static get defaults() {\n        return {\n            htmlEncode : false\n        };\n    }\n    constructor(config, store) {\n        super(...arguments);\n        const me = this;\n        if (!me.template) {\n            throw new Error('TemplateColumn needs a template');\n        }\n        if (typeof me.template !== 'function') {\n            throw new Error('TemplateColumn.template must be a function');\n        }\n    }\n    /**\n     * Renderer that uses a template for cell content.\n     * @private\n     */\n    renderer(renderData) {\n        // If it's a special row, such as a group row, we can't use the user's template\n        if (!renderData.record.isSpecialRow) {\n            return this.template({\n                value  : renderData.value,\n                record : renderData.record,\n                field  : this.field\n            });\n        }\n    }\n}\nColumnStore.registerColumnType(TemplateColumn, true);\nTemplateColumn.exposeProperties();\nTemplateColumn._$name = 'TemplateColumn';", "import Column from './Column.js';\nimport ColumnStore from '../data/ColumnStore.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\n/**\n * @module Grid/column/TimeColumn\n */\n/**\n * A column that displays a time in the specified format (see {@link Core.helper.DateHelper#function-format-static} for formatting options).\n *\n * Default editor is a {@link Core.widget.TimeField TimeField}.\n *\n * ```javascript\n * new Grid({\n *     appendTo : document.body,\n *\n *     columns : [\n *          { type: 'time', text: 'Start time', format: 'HH:mm:ss', data: 'start' }\n *     ]\n * });\n *```\n *\n * {@inlineexample Grid/column/TimeColumn.js}\n *\n * @extends Grid/column/Column\n * @classtype time\n * @column\n */\nexport default class TimeColumn extends Column {\n    //region Config\n    static type = 'time';\n    // Type to use when auto adding field\n    static fieldType = 'date';\n    static fields = ['format'];\n    static get defaults() {\n        return {\n            /**\n             * Time format\n             * @config {String}\n             * @category Common\n             * @default\n             */\n            format : 'LT',\n            minWidth : 140,\n            filterType : 'time'\n        };\n    }\n    //endregion\n    //region Display\n    /**\n     * Renderer that displays the time with the specified format. Also adds cls 'b-time-cell' to the cell.\n     * @private\n     */\n    defaultRenderer({ value }) {\n        return value ? this.formatValue(value) : '';\n    }\n    /**\n     * Group renderer that displays the time with the specified format.\n     * @private\n     */\n    groupRenderer({ cellElement, groupRowFor }) {\n        cellElement.innerHTML = this.formatValue(groupRowFor);\n    }\n    //endregion\n    //region Formatter\n    /**\n     * Used by both renderer and groupRenderer to do the actual formatting of the time\n     * @private\n     * @param value\n     * @returns {String}\n     */\n    formatValue(value) {\n        // Ideally we should be served a time, but if not make it easier for the user by parsing\n        if (typeof value === 'string') {\n            value = DateHelper.parse(value, this.format);\n        }\n        return DateHelper.format(value, this.format);\n    }\n    //endregion\n    //region Getters/Setters\n    /**\n     * Get/Set format for time displayed in cell and editor (see {@link Core.helper.DateHelper#function-format-static} for formatting options)\n     * @property {String}\n     */\n    set format(value) {\n        const { editor } = this;\n        this.set('format', value);\n        if (editor) {\n            editor.format = value;\n        }\n    }\n    get format() {\n        return  this.get('format');\n    }\n    get defaultEditor() {\n        return {\n            name   : this.field,\n            type   : 'time',\n            format : this.format\n        };\n    }\n    //endregion\n}\nColumnStore.registerColumnType(TimeColumn, true);\nTimeColumn.exposeProperties();\nTimeColumn._$name = 'TimeColumn';", "import CopyPasteBase from './base/CopyPasteBase.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nconst actions = {\n    cut   : 1,\n    copy  : 1,\n    paste : 1\n};\n/**\n * @module Grid/feature/CellCopyPaste\n */\n/**\n * Allows using `[Ctrl/CMD + C]`, `[Ctrl/CMD + X]` and `[Ctrl/CMD + V]` to cut, copy and paste cell or cell ranges. Also\n * makes cut, copy and paste actions available via the cell context menu.\n *\n * <div class=\"note\">\n * Requires {@link Grid/view/Grid#config-selectionMode selectionMode.cell} to be activated. Also, if the\n * {@link Grid/feature/CellEdit} feature is disabled, the {@link #config-copyOnly} config will default to `true` which\n * prevents cut and paste actions completely. Set {@link #config-copyOnly} to `false` to prevent this behaviour.\n * </div>\n *\n * This feature will work alongside with {@link Grid/feature/RowCopyPaste} but there is differences on functionality.\n * * When used together, context menu options will be detailed so the user will know to copy the cell or the row.\n * * They will also detect what type of selection is present at the moment. If there are only rows selected, only row\n *   alternatives are shown in the context menu and the keyboard shortcuts will be processed by RowCopyPaste.\n * * If there are only cells selected, there will be context menu options for both row and cell but keyboard shortcuts\n *   will be handled by CellCopyPaste.\n * * They do share clipboard, even if internal clipboard is used, so it is not possible to have rows and cells copied or\n *   cut at the same time.\n *\n * If the {@link https://developer.mozilla.org/en-US/docs/Web/API/Clipboard_API Clipboard API} is available, that will\n * be used. This enables copying and pasting between different Bryntum products or completely different applications.\n * Please note that only string values are supported.\n *\n * This feature is **disabled** by default\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         cellCopyPaste : true\n *     }\n * });\n * ```\n *\n * {@inlineexample Grid/feature/CellCopyPaste.js}\n *\n * ## Keyboard shortcuts\n * The feature has the following default keyboard shortcuts:\n *\n * | Keys       | Action  | Action description                                                                      |\n * |------------|---------|-----------------------------------------------------------------------------------------|\n * | `Ctrl`+`C` | *copy*  | Calls {@link #function-copy} which copies selected cell values into the clipboard.      |\n * | `Ctrl`+`X` | *cut*   | Calls {@link #function-cut} which cuts out selected cell values and saves in clipboard. |\n * | `Ctrl`+`V` | *paste* | Calls {@link #function-paste} which inserts string values from the clipboard.           |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [this guide](#Grid/guides/customization/keymap.md).\n *\n * @extends Grid/feature/base/CopyPasteBase\n * @classtype cellCopyPaste\n * @feature\n */\nexport default class CellCopyPaste extends CopyPasteBase {\n    static $name = 'CellCopyPaste';\n    static pluginConfig = {\n        chain : [\n            'populateCellMenu', 'afterSelectionModeChange'\n        ]\n    };\n    static configurable = {\n        useNativeClipboard : !VersionHelper.isTestEnv,\n        copyText  : 'L{copy}',\n        cutText   : 'L{cut}',\n        pasteText : 'L{paste}'\n    };\n    afterConstruct() {\n        super.afterConstruct();\n        this.afterSelectionModeChange();\n    }\n    afterSelectionModeChange() {\n        const me = this;\n        if (!me.client.selectionMode.cell) {\n            me.disabled = true;\n        }\n        else if (me._disabledBySelectionMode) {\n            me.disabled = false;\n            delete me._disabledBySelectionMode;\n        }\n    }\n    // Used in events to separate events from different features from each other\n    entityName = 'cell';\n    set copyOnly(value) {\n        this._copyOnly = value;\n    }\n    get copyOnly() {\n        // If celledit is disabled, cut and paste actions are disabled by default\n        if (this._copyOnly == null) {\n            return !this.client.features.cellEdit?.enabled;\n        }\n        return Boolean(this._copyOnly);\n    }\n    get canCopy() {\n        const { client } = this;\n        return Boolean(!this.disabled && client.selectedCells.length &&\n            (\n                !client._selectedRows.length ||\n                client.features.rowCopyPaste?.disabled ||\n                client.focusedCell && client.isCellSelected(client.focusedCell)\n            ));\n    }\n    get canCutPaste() {\n        return this.canCopy && !this.copyOnly && !this.client.features.cellEdit?.isEditing && !this.client.readOnly;\n    }\n    // Called from keyMap. Also used internally here\n    isActionAvailable({ actionName }) {\n        if (actions[actionName]) {\n            return this.canCopy && (actionName === 'copy' || this.canCutPaste);\n        }\n    }\n    /**\n     * Cuts selected cells to clipboard (native if accessible) to paste later\n     * @async\n     */\n    async cut() {\n        await this.copy(true);\n    }\n    /**\n     * Copies selected cells to clipboard (native if accessible) to paste later\n     * @async\n     */\n    async copy(isCut = false) {\n        if (typeof isCut != 'boolean') {\n            isCut = false; // If called by keymap, arguments[0] will be an event\n        }\n        const\n            me                = this,\n            { selectedCells } = me.client,\n            cells             = isCut ? selectedCells.filter(r => !r.record?.readOnly) : selectedCells;\n        if (cells) {\n            if ((isCut ? !me.canCutPaste : !me.canCopy)) {\n                return;\n            }\n            const copiedDataString = me.cellsToString(cells);\n            await me.writeToClipboard(copiedDataString, isCut, { cells });\n            if (isCut === true) {\n                for (const cell of cells) {\n                    if (!cell.column.readOnly) {\n                        cell.record.set(cell.column.field, null);\n                    }\n                }\n            }\n            /**\n             * Fires on the owning Grid after a copy action is performed.\n             * @event copy\n             * @on-owner\n             * @param {Grid.view.Grid} source Owner grid\n             * @param {Grid.util.Location[]} cells The cells about to be copied or cut\n             * @param {String} copiedDataString The concatenated data string that was copied or cut\n             * @param {Boolean} isCut `true` if this was a cut action\n             * @param {String} entityName 'cell' to distinguish this event from other copy events\n             */\n            me.client.trigger('copy', { cells, copiedDataString, isCut, entityName : me.entityName });\n        }\n    }\n    // Called from Clipboardable before writing to the clipboard\n    async beforeCopy({ data, isCut, cells }) {\n        /**\n         * Fires on the owning Grid before a copy action is performed, return `false` to prevent the action\n         * @event beforeCopy\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {Grid.util.Location[]} cells The cells about to be copied or cut\n         * @param {String} data The string data about to be copied or cut\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'cell' to distinguish this event from other beforeCopy events\n         */\n        return await this.client.trigger('beforeCopy', { cells, data, isCut, entityName : this.entityName });\n    }\n    /**\n     * Pastes string data into a cell or a range of cells. Either from native clipboard if that is accessible or from a\n     * fallback clipboard that is only available to the owner Grid.\n     *\n     * The string data will be split on `\\n` and `\\t` and put in different rows and columns accordingly.\n     *\n     * Note that there must be a selected cell to paste the data into.\n     * @async\n     */\n    async paste() {\n        const\n            me                     = this,\n            { client, entityName } = me,\n            targetCell             = client.selectedCells[0];\n        if (!me.canCutPaste || !targetCell) {\n            return;\n        }\n        const clipboardData = await me.readFromClipboard({}, true);\n        if (!clipboardData) {\n            return;\n        }\n        const { modifiedRecords, targetCells } = me.setFromStringData(clipboardData);\n        if (client.selectedCells.length === 1 && targetCells.length > 1) {\n            client.selectCellRange(targetCells[0], targetCells[targetCells.length - 1]);\n        }\n        /**\n         * Fires on the owning Grid after a paste action is performed.\n         * @event paste\n         * @on-owner\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {String} clipboardData The clipboardData that was pasted\n         * @param {Core.data.Model[]} modifiedRecords The records which have been modified due to the paste action\n         * @param {Grid.util.Location} targetCell The cell from which the paste will be started\n         * @param {String} entityName 'cell' to distinguish this event from other paste events\n         */\n        client.trigger('paste', { clipboardData, targetCell, modifiedRecords : [...modifiedRecords], entityName });\n    }\n    // Called from Clipboardable before finishing the clipboard read\n    async beforePaste({ data }) {\n        /**\n         * Fires on the owning Grid before a paste action is performed, return `false` to prevent the action\n         * @event beforePaste\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Grid.view.Grid} source Owner grid\n         * @param {String} clipboardData The clipboardData about to be pasted\n         * @param {Grid.util.Location} targetCell The cell from which the paste will be started\n         * @param {String} entityName 'cell' to distinguish this event from other beforePaste events\n         */\n        return await this.client.trigger('beforePaste', {\n            clipboardData : data, targetCell : this.client.selectedCell, entityName : this.entityName\n        });\n    }\n    populateCellMenu({ record, items }) {\n        const me = this;\n        if (me.canCopy) {\n            items.cutCell = {\n                text        : me.cutText,\n                localeClass : me,\n                icon        : 'b-icon b-icon-cut',\n                weight      : 115,\n                disabled    : record.readOnly || !me.canCutPaste,\n                onItem      : () => me.cut()\n            };\n            items.pasteCell = {\n                text        : me.pasteText,\n                localeClass : me,\n                icon        : 'b-icon b-icon-paste',\n                weight      : 120,\n                disabled    : record.readOnly || !me.canCutPaste || me.hasClipboardData() === false,\n                onItem      : () => me.paste()\n            };\n            items.copyCell = {\n                text        : me.copyText,\n                localeClass : me,\n                cls         : 'b-separator',\n                icon        : 'b-icon b-icon-copy',\n                weight      : 110,\n                onItem      : () => me.copy()\n            };\n        }\n    }\n}\nCellCopyPaste._$name = 'CellCopyPaste'; GridFeatureManager.registerFeature(CellCopyPaste);\n", "import Objects from '../../Core/helper/util/Objects.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\n/**\n * @module Grid/feature/CellTooltip\n */\n/**\n * Displays a tooltip when hovering cells.\n *\n * {@inlineexample Grid/feature/CellTooltip.js}\n *\n * To show contents when hovering a cell, you can specify a global {@link #config-tooltipRenderer} function for the\n * feature, you can also define a {@link Grid.column.Column#config-tooltipRenderer} for individual columns.\n *\n * ```javascript\n * // Column with its own tooltip renderer\n * {\n *   text            : 'Name',\n *   field           : 'name',\n *   tooltipRenderer : ({ record }) => `My name is\\xa0<b>${record.name}</b>`\n * }\n * ```\n *\n * Configuration properties passed into this feature are used to configure the {@link Core.widget.Tooltip} instance\n * used.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ## Showing async content\n * Showing remotely loaded content is super easy using the {@link #config-tooltipRenderer}:\n *\n * ```javascript\n * // Async tooltip with some custom settings\n * const grid = new Grid({\n *   features: {\n *     cellTooltip: {\n *       // Time that mouse needs to be over cell before tooltip is shown\n *       hoverDelay : 4000,\n *       // Time after mouse out to hide the tooltip, 0 = instantly\n *       hideDelay  : 0,\n *       // Async tooltip renderer, return a Promise which yields the text content\n *       tooltipRenderer({ record, tip }) {\n *         return fetch(`tip.php?id=${record.id}`).then(response => response.text())\n *       }\n *     }\n *   }\n * });\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @extendsconfigs Core/widget/Tooltip\n * @demo Grid/celltooltip\n * @classtype cellTooltip\n * @feature\n */\nexport default class CellTooltip extends InstancePlugin {\n    //region Config\n    static $name = 'CellTooltip';\n    static configurable = {\n        /**\n         * Function called to generate the HTML content for the cell tooltip.\n         * The function should return a string (your HTML), or a Promise yielding a string (for remotely loaded\n         * content)\n         * @prp {Function}\n         * @param {Object} context\n         * @param {HTMLElement} context.cellElement The cell element\n         * @param {Core.data.Model} context.record The row record\n         * @param {Grid.column.Column} context.column The column\n         * @param {Core.widget.Tooltip} context.tip The Tooltip instance\n         * @param {Grid.feature.CellTooltip} context.cellTooltip The feature\n         * @param {Event} context.event The raw DOM event\n         * @returns {String|Promise}\n         * @typings {String|Promise<String>}\n         */\n        tooltipRenderer : null\n    };\n    //endregion\n    // region Init\n    construct(grid, config) {\n        super.construct(grid, this.processConfig(config));\n    }\n    initTip() {\n        const me = this;\n        /**\n         * Returns the tooltip instance\n         * @member {Core.widget.Tooltip} tip\n         * @readonly\n         */\n        me.tip = Tooltip.new({\n            forElement        : me.client.element,\n            forSelector       : '.b-grid-row:not(.b-group-row) .b-grid-cell, .b-grid-merged-cells',\n            hoverDelay        : 1000,\n            trackMouse        : false,\n            cls               : 'b-celltooltip-tip',\n            getHtml           : me.getTooltipContent.bind(me),\n            internalListeners : {\n                pointerOver : 'onPointerOver',\n                thisObj     : me\n            },\n            // eslint-disable-next-line bryntum/no-listeners-in-lib\n            listeners : me.configuredListeners\n        }, me.initialConfig);\n        me.relayEvents(me.tip, ['beforeShow', 'show']);\n    }\n    onPointerOver({ target }) {\n        const column = this.client.getColumnFromElement(target);\n        // Veto onPointerOver if column's tooltipRenderer is false\n        return column.tooltipRenderer !== false && Boolean(column.tooltipRenderer || this.tooltipRenderer);\n    }\n    // CellTooltip feature handles special config cases, where user can supply a function to use as tooltipRenderer\n    // instead of a normal config object\n    processConfig(config) {\n        if (typeof config === 'function') {\n            return {\n                tooltipRenderer : config\n            };\n        }\n        return config;\n    }\n    // override setConfig to process config before applying it (used mainly from ReactGrid)\n    setConfig(config) {\n        super.setConfig(this.processConfig(config));\n    }\n    doDestroy() {\n        this.tip && this.tip.destroy();\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        if (!disable) {\n            this.initTip();\n        }\n        else if (this.tip) {\n            this.tip.destroy();\n            this.tip = null;\n        }\n        super.doDisable(disable);\n    }\n    //endregion\n    //region Content\n    /**\n     * Called from Tooltip to populate it with html.\n     * @private\n     */\n    getTooltipContent({ tip, activeTarget : cellElement, event }) {\n        const\n            me     = this,\n            record = me.client.getRecordFromElement(cellElement),\n            column = me.client.getColumnFromElement(cellElement),\n            arg    = { cellElement, record, column, event, tip, cellTooltip : me };\n        let result;\n        // If we have not changed context, we should not change content, unless we have a custom target selector (element within the cell)\n        if (!me.forSelector && record === me.lastRecord && record.generation === me.lastRecordGeneration && column === me.lastColumn) {\n            return me.tip._html;\n        }\n        me.lastRecord = record;\n        me.lastRecordGeneration = record.generation;\n        me.lastColumn = column;\n        // first, use columns tooltipRenderer if any\n        if (column.tooltipRenderer) {\n            result = column.tooltipRenderer(arg);\n        }\n        // secondly, try feature's renderer (specifying column.tooltipRenderer as false prevents tooltip in that column)\n        else if (me.tooltipRenderer && column.tooltipRenderer !== false) {\n            result = me.tooltipRenderer(arg);\n        }\n        // No caching of async requests\n        if (Objects.isPromise(result)) {\n            me.lastRecord = me.lastRecordGeneration = me.lastColumn = null;\n        }\n        // Tip should hide if no content is available\n        if (!result) {\n            tip.hide();\n        }\n        return result;\n    }\n    //endregion\n}\nCellTooltip._$name = 'CellTooltip'; GridFeatureManager.registerFeature(CellTooltip);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Editor from '../../Core/widget/Editor.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\n/**\n * @module Grid/feature/ColumnRename\n */\n/**\n * Allows user to rename columns by either right-clicking column header or using keyboard shortcuts when column header\n * is focused.\n *\n * To get notified about column renaming listen to `change` event on {@link Grid.data.ColumnStore columns} store.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * {@inlineexample Grid/feature/ColumnRename.js}\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys          | Action           | Action description                        |\n * |---------------|------------------|-------------------------------------------|\n * | `F2`          | *startEdit*      | Starts editing focused column header text |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @demo Grid/columns\n * @classtype columnRename\n * @feature\n */\nexport default class ColumnRename extends InstancePlugin {\n    static $name = 'ColumnRename';\n    static configurable = {\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            F2 : 'startEdit'\n        }\n    };\n    doDestroy() {\n        this.editor?.destroy();\n        super.doDestroy();\n    }\n    static get pluginConfig() {\n        return {\n            after : ['populateHeaderMenu']\n        };\n    }\n    populateHeaderMenu({ items, column }) {\n        items.rename = {\n            weight   : 215,\n            icon     : 'b-fw-icon b-icon-edit',\n            text     : this.L('L{rename}'),\n            disabled : column.readOnly,\n            onItem   : () => this.startEdit(column)\n        };\n    }\n    startEdit(column) {\n        if (column instanceof Event) {\n            // If started editing by key\n            column = this.client.getHeaderDataFromEvent(column)?.column;\n        }\n        if (column) {\n            if (column.readOnly) {\n                // return false to let keyMap know that we didn't handle this event\n                return false;\n            }\n            const { textWrapper } = column;\n            let { editor } = this;\n            if (!editor) {\n                this.editor = editor = new Editor({\n                    owner : this.client,\n                    align : {\n                        align : 't0-t0'\n                    }\n                });\n            }\n            editor.render(textWrapper);\n            editor.startEdit({\n                target : textWrapper,\n                record : column,\n                field  : 'text'\n            });\n        }\n    }\n}\nColumnRename._$name = 'ColumnRename'; GridFeatureManager.registerFeature(ColumnRename, false);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Location from '../../Grid/util/Location.js';\nimport GlobalEvents from '../../Core/GlobalEvents.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n/**\n * @module Grid/feature/FillHandle\n */\n/**\n * This feature adds a fill handle to a Grid range selection, which when dragged, fills the cells being dragged over\n * with values based on the values in the original selected range. This is similar to functionality normally seen in\n * various spreadsheet applications.\n *\n * {@inlineexample Grid/feature/FillHandle.js}\n *\n * Requires {@link Grid/view/Grid#config-selectionMode selectionMode.cell} to be activated.\n *\n * This feature is **disabled** by default\n *\n * ```javascript\n * const grid = new Grid({\n *     features : {\n *         fillHandle : true\n *     }\n * });\n * ```\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype fillHandle\n * @feature\n */\nexport default class FillHandle extends InstancePlugin.mixin(Delayable) {\n    static $name = 'FillHandle';\n    static configurable = {\n        /**\n         * Implement this function to be able to customize the value that cells will be filled with.\n         * Return `undefined` to use default calculations.\n         *\n         * ````javascript\n         * new Grid({\n         *    features : {\n         *        fillHandle : {\n         *           calculateFillValue({cell, column, range, record}) {\n         *              if(column.field === 'number') {\n         *                 return range.reduce(\n         *                    (sum, location) => sum + location.record[location.column.field]\n         *                 );\n         *              }\n         *           }\n         *        }\n         *    }\n         * });\n         * ````\n         *\n         * @param {Object} data Object containing information about current cell and fill value\n         * @param {Grid.util.Location} data.cell Current cell data\n         * @param {Grid.column.Column} data.column Current cell column\n         * @param {Grid.util.Location[]} data.range Range from where to calculate values\n         * @param {Core.data.Model} data.record Current cell record\n         * @returns {String|Number|Date} Value to fill current cell\n         * @config {Function}\n         */\n        calculateFillValue : null,\n        /**\n         * Set to `true` to enable the fill range to crop the original selected range. This clears the cells which were\n         * a part of the original selected range, but are no longer a part of the smaller range.\n         * @config {Boolean}\n         */\n        allowCropping : false\n    };\n    // Plugin configuration. This plugin chains/overrides some functions in Grid.\n    static pluginConfig = {\n        chain    : ['afterSelectionChange', 'onContentChange', 'afterColumnsChange', 'fixElementHeights'],\n        override : ['getCellDataFromEvent']\n    };\n    afterConstruct() {\n        super.afterConstruct();\n        if (!this.client.selectionMode.cell) {\n            this.disabled = true;\n        }\n        this._fillListeners = {};\n    }\n    delayable = {\n        handleSelection : 'raf'\n    };\n    onContentChange() {\n        this.handleSelection();\n    }\n    afterColumnsChange() {\n        this.handleSelection();\n    }\n    fixElementHeights() {\n        this.handleSelection();\n    }\n    getCellDataFromEvent(event, includeSingleAxisMatch) {\n        if (includeSingleAxisMatch) {\n            includeSingleAxisMatch = !event.target.classList.contains('b-fill-handle');\n        }\n        return this.overridden.getCellDataFromEvent(event, includeSingleAxisMatch);\n    }\n    // region Pattern recognition\n    findPatternsIn2dRange(range, horizontal, negative) {\n        const values = {};\n        // Converts a cellselector range to values per column or row\n        for (const cell of range) {\n            const id = horizontal ? cell.id : cell.columnId;\n            let value = cell.record.getValue(cell.column.field);\n            // If a number string, convert to number\n            if (value && typeof value === 'string' && !isNaN(value)) {\n                value = parseFloat(value);\n            }\n            if (!values[id]) {\n                values[id] = [];\n            }\n            values[id].push(value);\n        }\n        // Find patterns for each column or row in range\n        for (const rowOrCol in values) {\n            values[rowOrCol].pattern = this.findPatternsIn1dRange(values[rowOrCol], negative);\n        }\n        return values;\n    }\n    findPatternsIn1dRange(range, negative) {\n        const\n            lastValue = range[negative ? 0 : (range.length - 1)],\n            pattern   = {\n                next : () => lastValue,\n                lastValue\n            };\n        // If all values in same column/row is either number or date\n        if (range.every(val => typeof val === 'number') || range.every(val => val instanceof Date)) {\n            const diffs = range.map((val, ix) => val - range[ix - 1]);\n            diffs.shift(); // Removes initial NaN\n            // Found a repeating pattern\n            if (new Set(diffs).size === 1) {\n                pattern.increaseBy = diffs[0] * (negative ? -1 : 1);\n                pattern.next = () => {\n                    if (pattern.lastValue instanceof Date) {\n                        pattern.lastValue = new Date(pattern.lastValue.getTime() + pattern.increaseBy);\n                    }\n                    else {\n                        pattern.lastValue += pattern.increaseBy;\n                    }\n                    return pattern.lastValue;\n                };\n            }\n        }\n        // Else it's treated as a string value\n        else if (range.length > 1) {\n            pattern.stringPattern = [...range];\n            pattern.next = () => {\n                if (pattern.currentIndex === undefined) {\n                    pattern.currentIndex = 0;\n                }\n                else {\n                    pattern.currentIndex += 1;\n                    if (pattern.currentIndex >= pattern.stringPattern.length) {\n                        pattern.currentIndex = 0;\n                    }\n                }\n                return pattern.stringPattern[pattern.currentIndex];\n            };\n        }\n        return pattern;\n    }\n    // endregion\n    afterSelectionChange() {\n        const me = this;\n        if (me.client.readOnly) {\n            me.removeElements();\n            return;\n        }\n        // If selection isn't finished, wait for mouse up and then add fill elements\n        if (GlobalEvents.isMouseDown()) {\n            me.client.delayUntilMouseUp(() => me.handleSelection(true));\n            // Remove prev elements immediately in this case\n            me.removeElements();\n        }\n        // Otherwise, add fill elements immediately\n        else {\n            me.handleSelection(true);\n        }\n    }\n    /**\n     * Checks selection and sees to it that fill handle and border is drawn.\n     * Runs on next animation frame\n     * @internal\n     */\n    handleSelection() {\n        if (!this._isExtending) {\n            const range = this.rangeSelection;\n            if (range) {\n                this.drawFillHandleAndBorder(range[0], range[range.length - 1]);\n            }\n            else {\n                this.removeElements();\n            }\n        }\n    }\n    // region Mouse events\n    // On fillHandle mouse down only\n    onMouseDown(event) {\n        const { client } = this;\n        if (!client.readOnly) {\n            this._fillListeners.mouseMoveOrUp = EventHelper.on({\n                element   : globalThis,\n                mouseover : {\n                    handler : 'onMouseOver',\n                    element : client.selectionDragMouseEventListenerElement\n                },\n                mouseup : 'onMouseUp',\n                thisObj : this\n            });\n            event.preventDefault();\n            event.stopImmediatePropagation();\n            event.handled = true;\n        }\n    }\n    // Responsible for doing the filling\n    onMouseUp() {\n        const\n            me              = this,\n            {\n                client,\n                currentRange,\n                _isCropping\n            }               = me,\n            range           = me.rangeSelection,\n            selectionChange = range && currentRange && client.internalSelectRange(currentRange.from, currentRange.to),\n            selectedCells   = selectionChange?.selectedCells || [],\n            // For extending : Only modify cells that are not a part of original range\n            // For cropping  : Only clear cells that are not a part of new selection\n            extensionCells  = _isCropping ? me.croppingCells\n                : selectedCells.filter(cell => !range.some(sel => sel.equals(cell, true)));\n        delete me._isCropping; // Removing flag in case we bail out early\n        if (me._isExtending) {\n            client.disableScrollingCloseToEdges(client.items);\n            delete me._isExtending;\n        }\n        // If no extension, do nothing\n        if (!extensionCells?.length) {\n            me.handleSelection();\n            return;\n        }\n        client.suspendRefresh();\n        // If trimming (inverted extension), clear cells that where previously selected and not a part of new selection\n        if (_isCropping) {\n            extensionCells.forEach(cell => cell.record.set(cell.column.field, null, false, false, false, true));\n        }\n        // Extending cell values depending on pattern\n        else {\n            const\n                [firstCell] = extensionCells,\n                // If extensioncells has a record that is included in original selection, then we are dragging horizontally\n                horizontal  = range.some(sel => sel.record === firstCell.record),\n                // negative in this aspect, means dragging either upwards or to the left depending on horizontal or vertical\n                negative    = horizontal\n                    ? firstCell.columnIndex < range[0].columnIndex\n                    : firstCell.rowIndex < range[0].rowIndex,\n                patterns    = me.findPatternsIn2dRange(range, horizontal, negative),\n                changeMap   = new Map();\n            if (negative) {\n                extensionCells.reverse();\n            }\n            for (const cell of extensionCells) {\n                const { column, record } = cell;\n                if (!column.readOnly && column.canFillValue({ range, record, cell })) {\n                    let value   = me.calculateFillValue?.({ range, column, record, cell }),\n                        changed = changeMap.get(record);\n                    if (!changed) {\n                        changed = {};\n                        changeMap.set(record, changed);\n                    }\n                    if (value === undefined) {\n                        const pattern = patterns[horizontal ? cell.id : cell.columnId].pattern;\n                        value = pattern.next();\n                    }\n                    changed[column.field] = column.calculateFillValue?.({ value, record, range }) || value;\n                }\n            }\n            for (const [record, changes] of changeMap) {\n                record.set(changes, null, null, null, null, true);\n            }\n        }\n        client.resumeRefresh(true);\n        // Selects the extended area\n        client.performSelection(selectionChange);\n        delete me.currentRange;\n        me.handleSelection();\n    }\n    // The fill border and handle should refresh on mouse move\n    onMouseOver(event) {\n        const\n            me           = this,\n            {\n                client,\n                rangeSelection\n            }            = me,\n            first        = rangeSelection[0],\n            last         = rangeSelection[rangeSelection.length - 1],\n            cellData     = client.getCellDataFromEvent(event, true);\n        let cellSelector = cellData && client.normalizeCellContext(cellData.cellSelector);\n        if (cellSelector?._column?.region === first._column.region) {\n            const\n                equalOrSmaller = rangeSelection.some(cs => cs.equals(cellSelector, true));\n            let negative;\n            if (!me._isExtending) {\n                client.enableScrollingCloseToEdges(client.items);\n            }\n            if (equalOrSmaller) {\n                // If were smaller, were cropping (if it's allowed)\n                me._isCropping = me.allowCropping &&\n                    (cellSelector.rowIndex < last.rowIndex || cellSelector.columnIndex < last.columnIndex);\n            }\n            else {\n                // If cellSelector is on a row in range, endSelector should be current column but end/first row\n                if (cellSelector.rowIndex >= first.rowIndex && cellSelector.rowIndex <= last.rowIndex) {\n                    negative     = first.columnIndex > cellSelector.columnIndex;\n                    cellSelector = new Location({\n                        grid   : client,\n                        record : negative ? first.record : last.record,\n                        column : cellSelector.column\n                    });\n                }\n                // Else endSelector should be current row but end/first column\n                else {\n                    negative     = first.rowIndex > cellSelector.rowIndex;\n                    cellSelector = new Location({\n                        grid   : client,\n                        record : cellSelector.record,\n                        column : negative ? first.column : last.column\n                    });\n                }\n            }\n            // negative means that current mouse over cell is above or to the left\n            const\n                // If negative, draw from calculated mouse over cell\n                // otherwise, draw from top-left selection cell\n                from = negative ? cellSelector : first,\n                // If negative or were inside selection (but not cropping), draw to bottom-right selection cell\n                // otherwise, draw to calculated mouse over cell\n                to   = negative || (equalOrSmaller && !me._isCropping) ? last : cellSelector;\n            me.currentRange = { from, to };\n            // This flag is true even if were trimming\n            me._isExtending = true;\n            me.drawFillHandleAndBorder(from, to, true);\n        }\n    }\n    // endregion\n    // region Creating, updating and removing fillhandle and fillborder\n    drawFillHandleAndBorder(from, to, keepListeners = false) {\n        const\n            me        = this,\n            {\n                client,\n                currentRange,\n                _fillListeners\n            }         = me,\n            regionEl  = client.subGrids[from.column.region].element,\n            { x }     = Rectangle.from(from.cell || from.column.element, regionEl),\n            { right } = Rectangle.from(to.cell || to.column.element, regionEl),\n            { y }     = client.getRecordCoords(from.record, true),\n            bottom    = client.getRecordCoords(to.record, true).bottom - 1;\n        let {\n            borderElement,\n            handleElement\n        }             = me;\n        me.removeElements(keepListeners);\n        if (!borderElement) {\n            me.borderElement = borderElement = DomHelper.createElement({\n                className : 'b-fill-selection-border'\n            });\n            me.handleElement = handleElement = DomHelper.createElement({\n                className : 'b-fill-handle'\n            });\n        }\n        DomHelper.setRect(borderElement, { y, x, width : (right - x), height : (bottom - y) });\n        regionEl.appendChild(borderElement);\n        // If fill handle is drawn at right edge, put it to the left instead\n        DomHelper.setTopLeft(handleElement, bottom, right >= regionEl.scrollWidth ? x : right);\n        regionEl.appendChild(handleElement);\n        // Remove all previously cropping cls\n        me.toggleCroppingCls(false);\n        delete me.croppingCells;\n        // If were cropping, we should add cls class to the cells that will be \"shrunk\"\n        if (me._isCropping && me.rangeSelection?.length) {\n            const newCells = client.getRange(currentRange.from, currentRange.to);\n            me.croppingCells = me.rangeSelection.filter(sel => !newCells.some(cell => cell.equals(sel, true)));\n            me.toggleCroppingCls();\n        }\n        if (!_fillListeners.handleClick) {\n            _fillListeners.handleClick = EventHelper.on({\n                element   : client.rootElement,\n                delegate  : '.b-fill-handle',\n                mousedown : 'onMouseDown',\n                thisObj   : me\n            });\n        }\n        me.hasFillElements = true;\n    }\n    toggleCroppingCls(add = true) {\n        this.croppingCells?.forEach(sel => this.client.getCell(sel)?.classList.toggle('b-indicate-crop', add));\n    }\n    removeElements(keepListeners = false) {\n        const me = this;\n        me.handleElement?.remove();\n        me.borderElement?.remove();\n        if (!keepListeners) {\n            me.removeListeners();\n        }\n        me.hasFillElements = false;\n    }\n    // Detach listeners\n    removeListeners() {\n        const me = this;\n        for (const listener in me._fillListeners) {\n            me._fillListeners[listener]();\n        }\n        me._fillListeners = {};\n    }\n    // endregion\n    // Gets current selection range. Only allows for single range or single cell.\n    get rangeSelection() {\n        const\n            { client }        = this,\n            { selectedCells } = client,\n            range             = client._shiftSelectRange ?? (selectedCells.length === 1 && selectedCells);\n        // We only got one selected range, nothing else selected\n        // Only allow fill handle on single region selection\n        if (!client._selectedRows.length && range?.length && range.length === selectedCells.length &&\n            range.every(c1 => selectedCells.some(c2 => c1.equals(c2, true)) &&\n                c1._column.parent && c1._column.region === range[0]._column.region && client.store.isAvailable(c1.id)\n            )\n        ) {\n            return range;\n        }\n        return null;\n    }\n}\nFillHandle._$name = 'FillHandle'; GridFeatureManager.registerFeature(FillHandle);\n", "import ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport DomClassList from '../../Core/helper/util/DomClassList.js';\n/**\n * @module Grid/feature/MergeCells\n */\n// Maps DOM events to relayed events that need correct casing\nconst camelCase = {\n    mousedown   : 'mouseDown',\n    mousemove   : 'mouseMove',\n    mouseup     : 'mouseUp',\n    touchdown   : 'touchDown',\n    touchmove   : 'touchMove',\n    touchup     : 'touchUp',\n    pointerover : 'mouseOver',\n    mouseout    : 'mouseOut',\n    dblclick    : 'dblClick',\n    keydown     : 'keyDown',\n    keypress    : 'keyPress',\n    keyup       : 'keyUp',\n    contextmenu : 'contextMenu'\n};\n/**\n * This feature merges cells that have the same value in sorted (or {@link #config-sortedOnly optionally} any) columns\n * configured to {@link Grid/column/Column#config-mergeCells}.\n *\n * The content of merged cells is sticky for Grids with a single subgrid section when all columns fit in view (content\n * stays in view until the cell is scrolled fully out of view).\n *\n * {@note}\n * Support for sticky content is limited because of how <code>position: sticky</code> works. Grid\n * scrolls vertically in one element, and horizontally in another (to support multiple regions in the grid), and this\n * setup is not supported by current browsers implementation of sticky positioning\n * {/@note}\n *\n * Try scrolling in the demo below. As mentioned above, cells are by default merged only in sorted columns -  try\n * sorting by the other columns (\"City\" and \"Favorite food\" are configured to merge cells):\n *\n * {@inlineexample Grid/feature/MergeCells.js}\n *\n * By configuring the feature with `sortedOnly : false`, cells can be merged in any column:\n *\n * {@inlineexample Grid/feature/MergeCellsAll.js}\n *\n * This feature is **disabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype mergeCells\n * @feature\n */\nexport default class MergeCells extends InstancePlugin {\n    //region Config\n    static $name = 'MergeCells';\n    static configurable = {\n        /**\n         * By default, merged cells allow pointer events to pass through to the underlying row/cell, to allow selecting\n         * a row and editing an individual cell even when they are merged. Configure as `false` to allow merged cells to\n         * catch and react to the pointer events instead.\n         *\n         * ```javascript\n         * const grid = new Grid({\n         *     features : {\n         *         mergeCells : {\n         *             // Let merged cells react to pointer events\n         *             passthrough : false\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {Boolean}\n         */\n        passthrough : true,\n        /**\n         * Configure as `false` to allow merging cells in columns that are not sorted.\n         *\n         * {@note}\n         * Note that this will have a slight negative impact on performance, since cells in all columns configured to\n         * merge cells have to be iterated.\n         * {/@note}\n         *\n         * @config {Boolean}\n         * @default true\n         */\n        sortedOnly : true\n    };\n    // All current ranges (once rendered)\n    mergedRanges = [];\n    // Ranges indexed by row index & column id -> Each range included multiple times, for easy lookup\n    mergedMap    = {};\n    static get pluginConfig() {\n        return {\n            chain : [\n                'beforeRenderCell',\n                'afterRenderRow',\n                'bindStore',\n                'afterColumnsChange',\n                'afterRemove',\n                'afterToggleGroup',\n                'afterToggleSubGrid',\n                'handleEvent',\n                'populateHeaderMenu',\n                // 'setHoveredRow'\n                'afterSelectionChange'\n            ],\n            // Grid must perform its update *after* we do.\n            before : [\n                'onInternalResize'\n            ],\n            override : [\n                'getColumnFromElement',\n                'getRecordFromElement'\n            ]\n        };\n    };\n    //endregion\n    //region Init\n    afterConstruct() {\n        const\n            me         = this,\n            { client } = me;\n        // Each subgrid gets a merged cells container\n        client.eachSubGrid(subGrid => me.setupSubGrid(subGrid));\n        // Merged cells are synced after rows are updated\n        client.rowManager.ion({\n            renderDone : 'onRenderDone',\n            thisObj    : me\n        });\n        me.bindStore(client.store);\n    }\n    setupSubGrid(subGrid) {\n        // Element that will contain the merged cells\n        subGrid.$mergedCellsElement = DomHelper.createElement({\n            parent    : subGrid.element,\n            className : {\n                'b-grid-merged-cells-container' : 1\n            }\n        });\n        // Catch resizing region\n        subGrid.ion({\n            beforeInternalResize : 'refreshBounds',\n            thisObj              : this\n        });\n    }\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            // Flag to allow reset to redraw even though we are already disabled at this stage\n            this.isDisabling = true;\n            this.reset();\n            this.isDisabling = false;\n        }\n        super.doDisable(disable);\n    }\n    updatePassthrough(use) {\n        // Toggle CSS class that has `pointer-events : none`\n        this.client.element.classList.toggle('b-mergecells-passthrough', use);\n    }\n    updateSortedOnly(sortedOnly) {\n        if (!this.isConfiguring) {\n            this.reset(true, sortedOnly);\n        }\n    }\n    //endregion\n    //region Grid hooks\n    bindStore(store) {\n        this.detachListeners('store');\n        store.ion({\n            name    : 'store',\n            change  : 'onStoreChange',\n            // Call our refresh logic before grids\n            refresh : {\n                prio : 1,\n                fn   : 'onStoreRefresh'\n            },\n            thisObj : this\n        });\n    }\n    // Refresh all ranges when grid is resized\n    onInternalResize() {\n        this.refreshBounds();\n    }\n    // Get / create ranges before cell contents are rendered, redirecting the contents to the range\n    beforeRenderCell(renderData) {\n        const\n            me                              = this,\n            { column, record, cellElement } = renderData,\n            subGrid                         = me.client.subGrids[column.region];\n        // Only affect sorted columns configured to merge cells\n        if (!me.disabled && column.mergeCells && (column.isSorted || !me.sortedOnly) && !record.isSpecialRow && !subGrid.collapsed) {\n            const mergedRange = me.getMergeRange(record, column);\n            if (mergedRange?.use) {\n                // Flag the unmerged cell to allow styling it\n                cellElement.classList.add('b-merged-cell');\n                // Make sure it is empty\n                cellElement.innerHTML = '';\n                // Redirect output to the merged cell\n                renderData.cellElement = mergedRange.cellElement;\n            }\n        }\n    }\n    afterRenderRow({ row, oldId, oldHeight }) {\n        // Row reused for same record changed height\n        if (oldId === row.id && oldHeight !== row.height) {\n            this.heightChanged = true;\n        }\n    }\n    // Refresh all ranges when a column is resized (since it might affect their position and size)\n    afterColumnsChange({ action, changes, column }) {\n        if (this.disabled) {\n            return;\n        }\n        if (action === 'update' && changes.mergeCells && !column.mergeCells) {\n            // Remove all ranges for the column when mergeCells is set to false\n            for (const range of this.mergedRanges.slice()) {\n                if (range.column === column) {\n                    this.removeRange(range);\n                }\n            }\n            this.syncDom();\n            return;\n        }\n        this.refreshBounds();\n    }\n    // Remove might be transitioned, wait until it finishes before resetting (in the afterRemove hook)\n    afterRemove() {\n        !this.disabled && this.reset();\n    }\n    // Group collapsed or expanded\n    afterToggleGroup() {\n        !this.disabled && this.reset();\n    }\n    // SubGrid collapsed or expanded\n    afterToggleSubGrid() {\n        !this.disabled && this.reset();\n    }\n    // setHoveredRow(row) {\n    //     this.$hovered = row && this.mergedRanges.find(r => r.fromIndex <= row.dataIndex && r.toIndex >= row.dataIndex);\n    //\n    //     this.syncDom();\n    // }\n    // Selection changed, range is considered selected when all of its rows are selected (only in passthrough mode)\n    afterSelectionChange() {\n        if (!this.passthrough) {\n            const\n                { client } = this,\n                indices    = client.selectedRecords.map(r => client.store.indexOf(r));\n            let changed    = false;\n            for (const range of this.mergedRanges) {\n                let allSelected = true;\n                // Check if all records in the range are selected\n                for (let i = range.fromIndex; i <= range.toIndex && allSelected; i++) {\n                    allSelected = indices.includes(i);\n                }\n                if (range.isSelected !== allSelected) {\n                    range.isSelected = allSelected;\n                    changed = true;\n                }\n            }\n            // Only redraw if a range selection status changed\n            changed && this.syncDom();\n        }\n    }\n    //endregion\n    //region Grid overrides\n    // Extract record from merged cells\n    getRecordFromElement(element) {\n        if (element.elementData?.range) {\n            return this.client.store.getAt(element.elementData.range.fromIndex);\n        }\n        return this.overridden.getRecordFromElement(element);\n    }\n    // Extract column from merged cells\n    getColumnFromElement(element) {\n        if (element.elementData?.range) {\n            return element.elementData.range.column;\n        }\n        return this.overridden.getColumnFromElement(element);\n    }\n    //endregion\n    //region Header menu\n    // Allow toggling merging cells from the column header menu (unless column is explicitly disallowing it)\n    populateHeaderMenu({ column, items }) {\n        if (column.mergeable !== false) {\n            items.mergeCells = {\n                text     : 'L{MergeCells.mergeCells}',\n                icon     : `b-fw-icon ${column.mergeCells ? 'b-icon-checked' : 'b-icon-unchecked'}`,\n                tooltip  : 'L{MergeCells.menuTooltip}',\n                cls      : 'b-separator',\n                weight   : 500,\n                disabled : this.disabled,\n                onItem   : () => column.mergeCells = !column.mergeCells\n            };\n        }\n    }\n    //endregion\n    //region Relaying events\n    // Relay pointer events from the merged cell on grid\n    async handleEvent(event) {\n        if (!this.passthrough) {\n            const mergedCellsElement = event.target.closest('.b-grid-merged-cells');\n            if (mergedCellsElement) {\n                const\n                    { client }   = this,\n                    { range }    = mergedCellsElement.elementData,\n                    { cellEdit } = client.features,\n                    { column }   = range,\n                    type         = StringHelper.capitalize(camelCase[event.type] ?? event.type),\n                    eventData    = {\n                        grid        : client,\n                        records     : [],\n                        column,\n                        cellElement : mergedCellsElement.firstElementChild,\n                        target      : event.target,\n                        event\n                    };\n                for (let i = range.fromIndex; i <= range.toIndex; i++) {\n                    eventData.records.push(client.store.getAt(i));\n                }\n                client.trigger(`mergedCell${type}`, eventData);\n                // Cell editing, pass through to cell underneath even when not using passthrough mode\n                if (cellEdit?.triggerEvent.toLowerCase() === `cell${type}`.toLowerCase()) {\n                    const row = client.rowManager.getRowAt(event.clientY);\n                    await cellEdit.startEditing({ id : row.id, columnId : column.id });\n                }\n                // Select ranges rows when clicking the merged cell\n                else if (event.type === 'click') {\n                    this.onRangeClick({ range });\n                }\n            }\n        }\n    }\n    //endregion\n    //region Event listeners\n    // Select ranges rows when clicking a merged cell\n    onRangeClick({ range }) {\n        const records = [];\n        for (let i = range.fromIndex; i <= range.toIndex; i++) {\n            records.push(this.client.store.getAt(i));\n        }\n        this.client.selectedRecords = records;\n    }\n    // Reset when data changes\n    onStoreChange() {\n        !this.disabled && this.reset();\n    }\n    // Reset before grids refresh listener come into play, grid will redraw\n    onStoreRefresh({ action }) {\n        // filter & dataset triggers change too, handled above\n        if (action !== 'filter' && action !== 'dataset') {\n            !this.disabled && this.reset(false);\n        }\n    }\n    //endregion\n    //region Render\n    // Element is needed early since it is passed to column renderers, and syncing for each rendered cell would give a\n    // lot of overhead. Thus creating element directly instead\n    createRangeElement(range) {\n        const\n            parent = this.client.getSubGridFromColumn(range.column).$mergedCellsElement,\n            syncId = `${range.fromIndex}-@-${range.column.id}`;\n        // If there is already an element for the range (also if previously released), we grab that one.\n        // We are bending the rules of DomSync here by spawning the element early\n        let element = parent.syncIdMap?.[syncId] ?? parent.releasedIdMap?.[syncId];\n        // No longer considered released\n        if (parent.releasedIdMap) {\n            delete parent.releasedIdMap[syncId];\n        }\n        if (!element) {\n            element = DomHelper.createElement(this.createRangeDomConfig(range));\n        }\n        // New element or reusing released one, DomSync need to be made aware\n        DomSync.addChild(parent, element, syncId);\n        range.element = element;\n        range.cellElement = element.firstElementChild;\n        return element;\n    }\n    // Create a DomConfig object for the supplied range, used initially with DomHelper and thereafter with DomSync\n    createRangeDomConfig(range) {\n        const\n            { column, fromIndex, toIndex, top, left, right, width, height } = range,\n            { type } = column,\n            record = this.client.store.getAt(fromIndex),\n            domConfig = {\n                className : {\n                    'b-grid-merged-cells' : 1,\n                    // 'b-hover'             : this.$hovered === range,\n                    'b-selected'          : range.isSelected\n                },\n                elementData : {\n                    range\n                },\n                style : {\n                    top,\n                    left,\n                    right,\n                    height,\n                    width\n                },\n                dataset : {\n                    syncId   : `${fromIndex}-@-${column.id}`,\n                    fromIndex,\n                    toIndex,\n                    column   : column.field,\n                    columnId : column.id\n                },\n                children : [\n                    // Div for an actual cell\n                    {\n                        className : new DomClassList(this.client.cellCls).assign({\n                            [`b-${type?.toLowerCase()}-cell`] : type,\n                            [column.cellCls]                  : column.cellCls,\n                            [column.internalCellCls]          : column.internalCellCls\n                        }).assign(column.autoCls),\n                        // Don't touch cell children that might have been added by renderer\n                        keepChildren : true,\n                        // Tag along the range for easy resolving later\n                        elementData  : {\n                            range\n                        },\n                        // Dataset expected on cells\n                        dataset : {\n                            column   : column.field,\n                            columnId : column.id\n                        },\n                        // Size using configured row height, to at least have a chance of lining up with surrounding cells\n                        style : {\n                            height : this.client.rowManager.rowHeight\n                        }\n                    }\n                ]\n            };\n        // Allow application code a chance to affect the merged cell (intended for styling)\n        column.mergedRenderer?.({ domConfig, value : column.getRawValue(record), record, column, fromIndex, toIndex });\n        return domConfig;\n    }\n    buildMergedCellsConfig(fromIndex, toIndex, rows) {\n        const\n            me             = this,\n            { client }     = me,\n            { rowManager } = client;\n        // When exporting content we render rows to a document fragment one by one without RowManager. In\n        // order to draw ranges correctly in this case we need provide some meta information - list of row-like\n        // objects from which we can size for merged cell element, i.e. top, bottom, height, dataIndex\n        // Match grids row buffer, drawing ranges from the topmost row to the bottommost\n        fromIndex = fromIndex ?? rowManager.topRow?.dataIndex;\n        toIndex = toIndex ?? rowManager.bottomRow?.dataIndex;\n        const\n            // { locked = [], normal = [] }\n            domConfigMap = client.regions.reduce((map, region) => {\n                map[region] = {\n                    className : {\n                        'b-grid-merged-cells-container' : 1\n                    },\n                    children : []\n                };\n                return map;\n            }, {});\n        // Determine and update visible ranges\n        for (const range of me.mergedRanges) {\n            if (range.use && range.fromIndex <= toIndex && range.toIndex >= fromIndex) {\n                // Update the range, in case more of it has been scrolled into view\n                me.updateRange(range, me.heightChanged, rows);\n                // Create a DomConfig for it\n                domConfigMap[range.column.region].children.push(me.createRangeDomConfig(range));\n            }\n        }\n        return domConfigMap;\n    }\n    syncDom(force = false) {\n        const\n            me             = this,\n            { client }     = me,\n            { rowManager } = client;\n        // Bail out if we get here too early (happens in Scheduler) or are disabled\n        if (!force && !rowManager.topRow || me.disabled && !me.isDisabling) {\n            return;\n        }\n        const domConfigMap = this.buildMergedCellsConfig();\n        // Sync per subgrid\n        client.eachSubGrid(subGrid => {\n            DomSync.sync({\n                targetElement : subGrid.$mergedCellsElement,\n                syncIdField   : 'syncId',\n                domConfig     : domConfigMap[subGrid.region]\n            });\n        });\n        me.heightChanged = false;\n    }\n    // Called after rows are updated, sync visible ranges per subgrid\n    onRenderDone() {\n        this.syncDom();\n    }\n    //endregion\n    //region Ranges\n    // Remove range from list and index/column map, leaving no trace it since we don't know if it will ever\n    // come back (element will be released by DomSync)\n    removeRange(range) {\n        ArrayHelper.remove(this.mergedRanges, range);\n        for (let index = range.fromIndex; index <= range.toIndex; index++) {\n            delete this.mergedMap[`${index}-@-${range.column.id}`];\n        }\n    }\n    // Full reset, regenerating all ranges\n    reset(redraw = true, force = false) {\n        const\n            me        = this,\n            columns   = me.client.columns.visibleColumns.filter(c => c.mergeCells && (c.isSorted || !me.sortedOnly || force), true),\n            hadRanges = me.mergedRanges.length;\n        me.mergedRanges = [];\n        me.mergedMap = {};\n        if (redraw && !me.client.refreshSuspended) {\n            for (const row of me.client.rowManager.rows) {\n                for (const column of columns) {\n                    row.renderCell(row.getCell(column.id));\n                }\n            }\n            // Redraw, forcing it if all rows are gone\n            me.syncDom(hadRanges && !me.client.rowManager.rowCount);\n        }\n    }\n    // Refreshes existing ranges coords\n    refreshBounds() {\n        const\n            { mergedRanges } = this,\n            row              = this.client.rowManager.topRow,\n            boundsMap        = new Map(),\n            isRtl            = this.client.rtl;\n        for (const range of mergedRanges.slice()) {\n            const\n                { column }  = range,\n                cellElement = row.getCell(column.id);\n            // Column shown\n            if (cellElement) {\n                let { rowWidth, bounds } = boundsMap.get(column) ?? {};\n                if (!bounds) {\n                    // Temporarily cache bounds to avoid calculating them multiple times\n                    rowWidth = cellElement.parentElement.offsetWidth;\n                    bounds = Rectangle.from(cellElement, cellElement.parentElement);\n                    boundsMap.set(column, { rowWidth, bounds });\n                }\n                if (isRtl) {\n                    range.right = rowWidth - bounds.right;\n                }\n                else {\n                    range.left = bounds.left;\n                }\n                range.width = bounds.width;\n            }\n            // Column hidden or removed\n            else {\n                this.removeRange(range);\n            }\n        }\n        this.syncDom();\n    }\n    // Updates the range as user scrolls, until its start and end coords are fully known\n    // Rows argument is required to render merged cells on export. We provide row-like objects there\n    updateRange(range, force, rows = null) {\n        const\n            { store, rowManager }           = this.client,\n            { topRendered, bottomRendered } = range,\n            { rowOffsetHeight }             = rowManager;\n        let { fromIndex, toIndex } = range,\n            topRow, bottomRow;\n        force = rows ? rows.length > 0 : force;\n        // No need to update anything if bounds are correct already\n        if (!force && topRendered && bottomRendered) {\n            return;\n        }\n        if (!topRendered || force) {\n            if (rows) {\n                const index = rows.findIndex(row => row.dataIndex >= fromIndex);\n                topRow = rows[index];\n                fromIndex = topRow.dataIndex;\n            }\n            else {\n                do {\n                    topRow = rowManager.getRowById(store.getAt(fromIndex));\n                }\n                while (!topRow && fromIndex++ < toIndex);\n            }\n            // topRow is the actual topmost row in the range\n            range.topRendered = (fromIndex === range.fromIndex);\n            const rowsAbove = fromIndex - range.fromIndex;\n            range.top = topRow.top - rowsAbove * (rows ? topRow.offsetHeight : rowOffsetHeight);\n        }\n        if (!bottomRendered || force) {\n            if (rows) {\n                // We need to find last index, so we can just pick max between -1 and whatever we find\n                const index = rows.findIndex(row => row.dataIndex === toIndex);\n                bottomRow = rows[index === -1 ? rows.length - 1 : index];\n                fromIndex = bottomRow.dataIndex;\n            }\n            else {\n                do {\n                    bottomRow = rowManager.getRowById(store.getAt(toIndex));\n                }\n                while (!bottomRow && toIndex-- > fromIndex);\n            }\n            // bottomRow is the actual bottommost row in the range\n            range.bottomRendered = (toIndex === range.toIndex);\n            const rowsBelow = range.toIndex - toIndex;\n            range.bottom = bottomRow.bottom + rowsBelow * (rows ? bottomRow.offsetHeight : rowOffsetHeight);\n        }\n        range.height = range.bottom - range.top;\n    }\n    // Retrieve a range for the specified record / column, creating a new one if none found by walking upwards and\n    // downwards until a deviating value is found\n    getMergeRange(record, column) {\n        if (record.isSpecialRow) {\n            return;\n        }\n        const\n            me            = this,\n            { mergedMap } = me,\n            { store }     = me.client,\n            row           = me.client.rowManager.topRow,\n            columnId      = column.id,\n            index         = store.indexOf(record),\n            key           = `${index}-@-${columnId}`,\n            isRtl         = this.client.rtl;\n        let range = mergedMap[key];\n        if (!range) {\n            const value = column.getRawValue(record);\n            range = mergedMap[key] = {\n                column\n            };\n            me.mergedRanges.push(range);\n            // Search up until encountering different value\n            let earlierRecord, earlierValue, earlierIndex = index;\n            do {\n                earlierRecord = store.getAt(--earlierIndex);\n                earlierValue  = earlierRecord && column.getRawValue(earlierRecord);\n                if (earlierValue === value) {\n                    mergedMap[`${earlierIndex}-@-${columnId}`] = range;\n                }\n            } while (earlierRecord && !earlierRecord.isSpecialRow && earlierValue === value);\n            // And down\n            let laterRecord, laterValue, laterIndex = index;\n            do {\n                laterRecord = store.getAt(++laterIndex);\n                laterValue  = laterRecord && column.getRawValue(laterRecord);\n                if (laterValue === value) {\n                    mergedMap[`${laterIndex}-@-${columnId}`] = range;\n                }\n            } while (laterRecord && !laterRecord.isSpecialRow && laterValue === value);\n            range.fromIndex = earlierIndex + 1;\n            range.toIndex   = laterIndex - 1;\n            // We only care about ranges longer than 1 record\n            if (range.toIndex - range.fromIndex > 0) {\n                const\n                    cellElement = row.getCell(columnId),\n                    rowWidth    = cellElement.parentElement.offsetWidth,\n                    cellBounds  = Rectangle.from(cellElement, cellElement.parentElement);\n                if (isRtl) {\n                    range.right = rowWidth - cellBounds.right;\n                }\n                else {\n                    range.left = cellBounds.left;\n                }\n                range.width = cellBounds.width;\n                range.use = true;\n            }\n        }\n        if (!range.element && range.use) {\n            me.createRangeElement(range);\n        }\n        return range;\n    }\n    //endregion\n}\nMergeCells._$name = 'MergeCells'; GridFeatureManager.registerFeature(MergeCells);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nconst actions = {\n    goToNextHit      : 1,\n    goToPrevHit      : 1,\n    showFilterEditor : 1,\n    clearSearch      : 1\n};\n/**\n * @module Grid/feature/QuickFind\n */\n/**\n * Feature that allows the user to search in a column by focusing a cell and typing. Navigate between hits using the\n * keyboard, [f3] or [ctrl]/[cmd] + [g] moves to next, also pressing [shift] moves to previous.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ## Keyboard shortcuts\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys                | Action             | Action description                |\n * |---------------------|--------------------|-----------------------------------|\n * | `F3`                | *goToNextHit*      | Move focus to next search hit     |\n * | `Shift`+F3`         | *goToPrevHit*      | Move focus to previous search hit |\n * | `Ctrl`+`G`          | *goToNextHit*      | Move focus to next search hit     |\n * | `Ctrl`+`Shift`+`G`  | *goToPrevHit*      | Move focus to previous search hit |\n * | `Ctrl`+`Shift`+`F3` | *showFilterEditor* | Shows the filter editor           |\n * | `Escape`            | *clearSearch*      | Removes the search completely     |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * ```javascript\n * // enable QuickFind\n * let grid = new Grid({\n *   features: {\n *     quickFind: true\n *   }\n * });\n * ```\n *\n * // navigate to next hit programmatically\n * grid.features.quickFind.gotoNextHit();\n *\n * {@inlineexample Grid/feature/QuickFind.js}\n *\n * @demo Grid/quickfind\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype quickFind\n * @feature\n */\nexport default class QuickFind extends InstancePlugin {\n    //region Config\n    static $name = 'QuickFind';\n    static configurable = {\n        mode : 'header',\n        find : '',\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            F3             : 'gotoNextHit',\n            'Shift+F3'     : 'gotoPrevHit',\n            'Ctrl+g'       : 'gotoNextHit',\n            'Ctrl+Shift+g' : 'gotoPrevHit',\n            'Ctrl+Shift+f' : 'showFilterEditor',\n            Escape         : 'clearSearch',\n            //Private\n            Backspace : 'onBackspace'\n        }\n    };\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onElementKeyPress', 'onCellNavigate']\n        };\n    }\n    //endregion\n    //region Init\n    static get properties() {\n        return {\n            hitCls          : 'b-quick-hit',\n            hitCellCls      : 'b-quick-hit-cell',\n            hitCellBadgeCls : 'b-quick-hit-cell-badge',\n            hitTextCls      : 'b-quick-hit-text'\n        };\n    }\n    construct(grid, config) {\n        super.construct(grid, config);\n        Object.assign(this, {\n            grid,\n            treeWalker : grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)\n        });\n    }\n    isActionAvailable({ actionName }) {\n        if (actions[actionName]) {\n            const { focusedCell } = this.grid;\n            return !this.disabled && focusedCell?.record && !focusedCell.isActionable && this.find.length > 0;\n        }\n    }\n    doDisable(disable) {\n        if (disable) {\n            this.clear();\n        }\n        super.doDisable(disable);\n    }\n    get store() {\n        return this.grid.store;\n    }\n    //endregion\n    //region Show/hide QuickFind\n    /**\n     * Shows a \"searchfield\" in the header. Triggered automatically when you have a cell focused and start typing.\n     * @private\n     */\n    showQuickFind() {\n        const\n            me       = this,\n            { grid } = me,\n            header   = grid.getHeaderElement(me.columnId);\n        if (header) {\n            if (!me.headerField) {\n                const [element, field, badge] = DomHelper.createElement({\n                    tag       : 'div',\n                    className : 'b-quick-hit-header',\n                    children  : [\n                        { tag : 'div', className : 'b-quick-hit-field' },\n                        { tag : 'div', className : 'b-quick-hit-badge' }\n                    ]\n                }, { returnAll : true });\n                if (me.mode === 'header') {\n                    header.appendChild(element);\n                }\n                else {\n                    element.className += ' b-quick-hit-mode-grid';\n                    grid.element.appendChild(element);\n                }\n                me.headerField = {\n                    header    : element,\n                    field,\n                    badge,\n                    colHeader : header\n                };\n            }\n            me.headerField.field.innerHTML = me.find;\n            me.headerField.badge.innerHTML = me.found.length;\n            header.classList.add('b-quick-find-header');\n        }\n        if ((header || grid.hideHeaders) && !me.renderListenerInitialized) {\n            grid.rowManager.ion({\n                rendercell : me.renderCell,\n                thisObj    : me\n            });\n            me.renderListenerInitialized = true;\n        }\n    }\n    /**\n     * Hide the \"searchfield\" and remove highlighted hits. Called automatically when pressing [esc] or backspacing away\n     * the keywords.\n     * @private\n     */\n    hideQuickFind() {\n        const\n            me                    = this,\n            { grid, headerField } = me;\n        // rerender cells to remove quick-find markup\n        for (const hit of (me.prevFound || me.found)) {\n            const row = grid.getRowById(hit.id);\n            if (row) {\n                // Need to force replace quick finds markup\n                row.forceInnerHTML = true;\n                const cellElement = row.getCell(me.columnId);\n                cellElement._content = null;\n                row.renderCell(cellElement);\n                row.forceInnerHTML = false;\n            }\n        }\n        if (headerField) {\n            headerField.header.parentNode.removeChild(headerField.header);\n            headerField.colHeader.classList.remove('b-quick-find-header');\n            me.headerField = null;\n        }\n        if (me.renderListenerInitialized) {\n            grid.rowManager.un({ rendercell : me.renderCell }, me);\n            me.renderListenerInitialized = false;\n        }\n        grid.trigger('hideQuickFind');\n    }\n    //endregion\n    //region Search\n    /**\n     * Performs a search and highlights hits. If find is empty, QuickFind is closed.\n     * @param {String} find Text to search for\n     * @param {String} columnFieldOrId Column to search\n     */\n    search(find, columnFieldOrId = this.columnId, fromSplit = false) {\n        const\n            me       = this,\n            { grid } = me,\n            column   = grid.columns.getById(columnFieldOrId) || grid.columns.get(columnFieldOrId),\n            found    = me.store.findByField(column.field, find, column.mergeCells && column.isSorted);\n        let i = 1;\n        Object.assign(me, {\n            foundMap  : {},\n            prevFound : me.found,\n            found,\n            find,\n            columnId  : column.id,\n            findRe    : new RegExp(`(\\\\s+)?(${StringHelper.escapeRegExp(String(find))})(\\\\s+)?`, 'ig')\n        });\n        if (find) {\n            me.showQuickFind();\n        }\n        else {\n            me.hideQuickFind();\n        }\n        // clear old hits\n        for (const cellElement of DomHelper.children(grid.element, `.${me.hitCls}`)) {\n            cellElement.classList.remove(me.hitCls, me.hitCellCls);\n            if (cellElement._originalContent) {\n                cellElement.innerHTML = cellElement._originalContent;\n                cellElement._originalContent = null;\n            }\n        }\n        if (!found) {\n            return;\n        }\n        if (found.length > 0 && !fromSplit) {\n            me.gotoClosestHit(grid.focusedCell, found);\n        }\n        // highlight hits for visible cells\n        for (const hit of found) {\n            me.foundMap[hit.id] = i++;\n            const row = grid.getRowById(hit.data.id);\n            row?.renderCell(row.getCell(column.id));\n            // limit highlighted hits\n            if (i > 1000) {\n                break;\n            }\n        }\n        // Relay to other grids when splitting\n        grid.syncSplits?.(other => other.features.quickFind.search(find, columnFieldOrId, true));\n        grid.trigger('quickFind', { find, found });\n    }\n    /**\n     * Clears and closes QuickFind.\n     */\n    clear() {\n        if (this.find || this.found?.length) {\n            this.search('');\n        }\n    }\n    /**\n     * Number of results found\n     * @type {Number}\n     * @readonly\n     */\n    get foundCount() {\n        return this.found?.length ?? 0;\n    }\n    /**\n     * Found results (as returned by Store#findByField), an array in format { index: x, data: record }\n     * @member {StoreSearchResult[]} found\n     * @readonly\n     */\n    //endregion\n    //region Navigation\n    /**\n     * Go to specified hit.\n     * @param {Number} index\n     */\n    gotoHit(index) {\n        const nextHit = this.found[index];\n        if (nextHit) {\n            this.grid.focusCell({\n                columnId : this.columnId,\n                id       : nextHit.id\n            }, { doSelect : true });\n        }\n        return !!nextHit;\n    }\n    gotoClosestHit(focusedCell, found) {\n        const\n            focusedIndex = focusedCell ? this.grid.store.indexOf(focusedCell.id) : 0,\n            foundSorted  = found.slice().sort(\n                (a, b) => Math.abs(a.index - focusedIndex) - Math.abs(b.index - focusedIndex)\n            );\n        this.gotoHit(found.indexOf(foundSorted[0]));\n    }\n    /**\n     * Go to the first hit.\n     */\n    gotoFirstHit() {\n        this.gotoHit(0);\n    }\n    /**\n     * Go to the last hit.\n     */\n    gotoLastHit() {\n        this.gotoHit(this.found.length - 1);\n    }\n    /**\n     * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].\n     */\n    gotoNextHit() {\n        const\n            me           = this,\n            { grid }     = me,\n            // start from focused cell, or if focus has left grid use lastFocusedCell\n            currentId    = grid._focusedCell?.id ?? grid.lastFocusedCell?.id,\n            currentIndex = grid.store.indexOf(currentId) || 0,\n            nextHit      = me.found.find(hit => hit.index > currentIndex);\n        if (nextHit) {\n            grid.focusCell({\n                columnId : me.columnId,\n                id       : nextHit.id\n            }, { doSelect : true });\n        }\n        else {\n            me.gotoFirstHit();\n        }\n    }\n    /**\n     * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].\n     */\n    gotoPrevHit() {\n        const\n            me              = this,\n            { grid, found } = me,\n            currentId       = grid._focusedCell?.id ?? grid.lastFocusedCell?.id,\n            currentIndex    = grid.store.indexOf(currentId) || 0;\n        let prevHit;\n        if (!found.length) {\n            return;\n        }\n        for (let i = found.length - 1; i--; i >= 0) {\n            if (found[i].index < currentIndex) {\n                prevHit = found[i];\n                break;\n            }\n        }\n        if (prevHit) {\n            grid.focusCell({\n                columnId : me.columnId,\n                id       : prevHit.id\n            }, { doSelect : true });\n        }\n        else {\n            me.gotoLastHit();\n        }\n    }\n    //endregion\n    //region Render\n    /**\n     * Called from SubGrid when a cell is rendered.\n     * @private\n     */\n    renderCell({ cellElement, column, record }) {\n        const\n            me           = this,\n            { classList } = cellElement,\n            {\n                treeWalker,\n                findRe,\n                hitTextCls\n            }           = me,\n            hitIndex    = me.columnId === column.id && me.foundMap?.[record.id];\n        if (hitIndex) {\n            // highlight cell\n            classList.add(me.hitCls);\n            cellElement.isQuickHit = true;\n            cellElement._originalContent = cellElement.innerHTML;\n            // if features have added other stuff to the cell, value is in div.b-grid-cell-value\n            // highlight in cell if found in innerHTML\n            const inner = treeWalker.currentNode = DomHelper.down(cellElement, '.b-grid-cell-value,.b-tree-cell-value') || cellElement;\n            for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode);) {\n                const\n                    nodeToReplace = textNode,\n                    textContent   = textNode.nodeValue,\n                    newText       = ['<span>'];\n                // Move onto next text node before we replace the node with a highlight HTML sequence\n                textNode = treeWalker.nextNode();\n                let offset = findRe.lastIndex;\n                // Convert textContent into an innerHTML string which htmlEncodes the text and embeds\n                // a highlighting span which contains the target text.\n                for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {\n                    const\n                        preamble    = textContent.substring(offset, match.index),\n                        spaceBefore = match[1] ? '\\xa0' : '',\n                        v           = match[2],\n                        spaceAfter  = match[3] ? '\\xa0' : '';\n                    newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class=\"${hitTextCls}\">${v}</span>${spaceAfter}`);\n                    offset = findRe.lastIndex;\n                }\n                newText.push(StringHelper.encodeHtml(textContent.substring(offset)), '</span>');\n                // Insert a fragment with each match wrapped with a span.\n                nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(''), {\n                    fragment : true\n                }), nodeToReplace);\n                nodeToReplace.remove();\n            }\n            DomHelper.createElement({\n                parent    : cellElement,\n                className : me.hitCellBadgeCls,\n                text      : hitIndex\n            });\n        }\n    }\n    //endregion\n    //region Events\n    onBackspace(event) {\n        const me = this;\n        if (me.find) {\n            me.find = me.find.substr(0, me.find.length - 1);\n            me.search(me.find);\n            return true;\n        }\n        return false;\n    }\n    clearSearch() {\n        if (this.find) {\n            this.find = '';\n            this.search(this.find);\n            return true;\n        }\n        return false;\n    }\n    showFilterEditor() {\n        const\n            me = this,\n            { filter } = me.client.features;\n        if (filter && me.columnId && me.foundCount) {\n            me.clear();\n            filter.showFilterEditor(me.client.columns.getById(me.columnId), me.find);\n        }\n    }\n    /**\n     * Chained function called on grids keypress event. Handles input for \"searchfield\".\n     * @private\n     * @param event\n     */\n    onElementKeyPress(event) {\n        const\n            me              = this,\n            { grid }        = me,\n            { focusedCell } = grid;\n        // Only react to keystrokes on grid cell elements\n        if (!event.handled && !me.disabled && focusedCell?.record && !focusedCell.isActionable && event.key?.length === 1) {\n            const column = grid.columns.getById(grid._focusedCell.columnId);\n            // if trying to search in invalid column, it's a hard failure\n            if (column && column.searchable !== false) {\n                me.columnId = grid._focusedCell.columnId;\n                me.find += event.key;\n                me.search(me.find);\n            }\n        }\n    }\n    onCellNavigate(grid, fromCellSelector, toCellSelector) {\n        const\n            me    = this;\n        if (me.find && (!toCellSelector || toCellSelector.columnId !== me.columnId)) {\n            me.clear();\n        }\n    }\n    //endregion\n}\nQuickFind._$name = 'QuickFind'; GridFeatureManager.registerFeature(QuickFind);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport Widget from '../../Core/widget/Widget.js';\nimport Objects from '../../Core/helper/util/Objects.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport GlobalEvents from '../../Core/GlobalEvents.js';\nimport '../column/ActionColumn.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nconst actions = {\n    onTab      : 1,\n    onShiftTab : 1\n};\n/**\n * @module Grid/feature/RowExpander\n */\nconst storeRemoveActions = { remove : 1, filter : 1, dataset : 1, replace : 1 };\n/**\n * Enables expanding of Grid rows by either row click or double click, or by adding a separate Grid column which renders\n * a button that expands or collapses the row.\n *\n * {@inlineexample Grid/feature/RowExpander.js}\n *\n * The content of the expanded row body is rendered by providing either a {@link #config-renderer} function to the\n * rowExpander feature config:\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            renderer({record, region, expanderElement}){\n *                return htmlToBeExpanded;\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * Or a {@link #config-widget} configuration object:\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            widget : {\n *                type : 'detailGrid',\n *            },\n *            dataField : 'orderDetails'\n *        }\n *    }\n * });\n * ```\n *\n * {@inlineexample Grid/feature/RowExpanderWidget.js}\n *\n * <div class=\"note\">Note that if used in a Gantt, the Gant's `fixedRowHeight` must be set to `false`.</div>\n *\n * This feature is **disabled** by default\n *\n * ## Expand on click\n * Set {@link #config-triggerEvent} to a Grid cell event that should trigger row expanding and collapsing.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            triggerEvent: 'celldblclick',\n *            renderer...\n *        }\n *    }\n * });\n * ```\n *\n * ## Expander column position\n * The expander column can either be inserted before or after the existing Grid columns. If the Grid has multiple\n * regions the column will be added to the first region.\n *\n * Adjust expander column position to last in a specific Grid region by setting {@link #config-columnPosition}\n * to `last` and configuring the {@link #config-column} with a region name.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            column: {\n *                region: 'last'\n *            },\n *            columnPosition: 'last',\n *            renderer...\n *        }\n *    }\n * });\n * ```\n *\n * ## Record update\n * If the expander content depends on row record data, the expander can be re-rendered on record update by setting\n * {@link #config-refreshOnRecordChange} to `true`.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            refreshOnRecordChange: true,\n *            renderer...\n *        }\n *    }\n * });\n * ```\n *\n * ## Async\n * When the content of the row expander should be rendered async just see to it that you return a promise.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            async renderer({record, region, expanderElement}){\n *                return fetchFromBackendAndRenderData(record);\n *            }\n *        }\n *    }\n * });\n *```\n *\n * ## Multiple regions\n * When the Grid has more than one region, the {@link #config-renderer} function will be called once per region for each\n * expanding row.\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            renderer({ record, region }) {\n *                if(region === 'locked') {\n *                    return createRowExpander(record);\n *                }\n *\n *                return null;\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * If you are using the {@link #config-widget} configuration, you can provide a widget configuration object for each\n * region like so:\n *\n * ```javascript\n * new Grid({\n *    features : {\n *        rowExpander : {\n *            widget : {\n *                locked : {\n *                    type : 'detailGrid',\n *                    // If your widgets uses different data sources, out the dataField\n *                    //  property in the widget configuration object\n *                    dataField : 'orderDetails'\n *                },\n *                normal : {\n *                    type : 'summaryGrid',\n *                    dataField : 'sumDetails'\n *                }\n *            }\n *        }\n *    }\n * });\n * ```\n *\n * If you want your expanded content to span over all Grid regions, set the {@link #config-spanRegions} config to\n * `true`.\n *\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype rowExpander\n * @feature\n */\nexport default class RowExpander extends InstancePlugin.mixin(Delayable) {\n    //region Config\n    static $name = 'RowExpander';\n    // Cannot use `static properties = {}`, new Map/Set would pollute the prototype\n    static get properties() {\n        return {\n            // CSS classes\n            expanderBodyClass        : 'b-rowexpander-body',\n            expandedRowClass         : 'b-rowexpander-row-expanded',\n            shadowRootContainerClass : 'b-rowexpander-shadowroot-container',\n            // Map where the keys are the expanded records and values are an object\n            // {rowHeight, cellHeight, expandedBodyElements}\n            recordStateMap           : new Map(),\n            collapsingStateMap       : new Map()\n        };\n    }\n    static configurable = {\n        /**\n         * The implementation of this function is called each time the body of an expanded row is rendered. Either\n         * return an HTML string, a {@link Core.helper.DomHelper#typedef-DomConfig} object describing the markup or any\n         * Widget configuration object, like a Grid configuration object for example.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            renderer({record, region, expanderElement}){\n         *                return htmlToBeExpanded;\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * Or return a {@link Core.helper.DomHelper#typedef-DomConfig} object.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            renderer({record, region, expanderElement}){\n         *                return {\n         *                   tag       : 'form',\n         *                   className : 'expanded-row-form',\n         *                   children  : [\n         *                       {\n         *                           tag        : 'textarea',\n         *                           name       : 'description',\n         *                           className  : 'expanded-textarea'\n         *                       },\n         *                       {\n         *                           tag        : 'button',\n         *                           text       : 'Save',\n         *                           className  : 'expanded-save-button',\n         *                       }\n         *                   ]\n         *                };\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * Or return a Widget configuration object. What differs a Widget configuration object from a DomConfig object\n         * is the presence of the `type` property and the absence of a `tag` property.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            async renderer({record, region, expanderElement}){\n         *                const myData = await fetch('myURL');\n         *                return {\n         *                   type : 'grid',\n         *                   autoHeight : true,\n         *                   columns : [\n         *                       ...\n         *                   ],\n         *                   data : myData\n         *                };\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * It is also possible to add markup directly to the expanderElement.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            renderer({record, region, expanderElement}){\n         *                new UIComponent({\n         *                    appendTo: expanderElement,\n         *                    ...\n         *                });\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         * The renderer function can also be asynchronous.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            async renderer({record, region, expanderElement}){\n         *                return await awaitAsynchronousOperation();\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} renderData Object containing renderer parameters\n         * @param {Core.data.Model} renderData.record Record for the row\n         * @param {HTMLElement} renderData.expanderElement Expander body element\n         * @param {HTMLElement} renderData.rowElement Row element\n         * @param {String} renderData.region Grid region name\n         * @param {Grid.view.Grid} renderData.grid Grid instance\n         * @returns {String|DomConfig|null} Row expander body content\n         * @async\n         *\n         * @category Rendering\n         */\n        renderer : null,\n        /**\n         * The name of the Grid event that will toggle expander. Defaults to `null` but can be set to any event such\n         * as {@link Grid.view.mixin.GridElementEvents#event-cellDblClick} or\n         * {@link Grid.view.mixin.GridElementEvents#event-cellClick}.\n         *\n         * ```javascript\n         * features : {\n         *     rowExpander : {\n         *         triggerEvent : 'cellclick'\n         *     }\n         * }\n         * ```\n         *\n         * @config {String}\n         */\n        triggerEvent : null,\n        /**\n         * Provide a column config object to display a button with expand/collapse functionality.\n         * Shown by default, set to `null` to not include.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            column: {\n         *                // Use column config options here\n         *                region: 'last'\n         *            }\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * @config {ActionColumnConfig|Grid.column.ActionColumn}\n         */\n        column : {},\n        /**\n         * Makes the expand/collapse button column appear either as the first column (default or `first`) or as the\n         * last (set to `last`). Note that the column by default will be added to the first region, if the Grid\n         * has multiple regions. Use the {@link #config-column} config to change region.\n         * @config {String}\n         * @default\n         */\n        columnPosition : 'first',\n        /**\n         * If set to `true`, the RowExpander will, on record update, re-render an expanded row by calling the\n         * {@link #config-renderer} function or recreate the configured {@link #config-widget}.\n         * @config {Boolean}\n         * @default\n         */\n        refreshOnRecordChange : false,\n        /**\n         * Use this for customizing async {@link #config-renderer} loading indicator height.\n         * @config {Number}\n         * @defalt\n         */\n        loadingIndicatorHeight : 100,\n        /**\n         * Use this for customizing async {@link #config-renderer} loading indicator text.\n         * @config {String}\n         * @default Loading\n         */\n        loadingIndicatorText : 'L{loading}',\n        /**\n         * Use this to disable expand and collapse animations.\n         * @config {Boolean}\n         * @default\n         */\n        enableAnimations : true,\n        /**\n         * A widget configuration object that will be used to create a widget to render into the row expander body. Can\n         * be used instead of providing a {@link #config-renderer}.\n         *\n         * If the widget needs a store, it can be populated by use of the {@link #config-dataField} config. This will\n         * create a store from the expanded record's corresponding `dataField` value, which needs to be an array of\n         * objects or a store itself.\n         *\n         * ```javascript\n         * new Grid({\n         *    features : {\n         *        rowExpander : {\n         *            widget : {\n         *                type : 'detailGrid',\n         *            },\n         *            dataField : 'orderDetails'\n         *        }\n         *    }\n         * });\n         * ```\n         *\n         * If there is multiple regions, you can configure each region like so:\n         *\n         * ```javascript\n         * new Grid({\n         *     features : {\n         *         rowExpander : {\n         *             widget : {\n         *                 // The region name is the property, and its widget config the value\n         *                 left : {\n         *                    type : 'detailGrid',\n         *                    // If your widgets uses different data sources, put the dataField\n         *                    //  property in the widget configuration object\n         *                    dataField : 'orderDetails'\n         *                },\n         *                middle : {\n         *                    type : 'summaryGrid',\n         *                    dataField : 'sumDetails\n         *                },\n         *                // No expander here\n         *                right : null\n         *             }\n         *         }\n         *     }\n         * })\n         * ```\n         *\n         * @config {ContainerItemConfig}\n         */\n        widget : null,\n        /**\n         * Used together with {@link #config-widget} to populate the widget's Store from the expanded record's\n         * corresponding `dataField` value, which needs to be an array of objects or a store itself.\n         * @config {String}\n         */\n        dataField : null,\n        keyMap : {\n            // Private\n            Tab         : { handler : 'onTab', weight : 50 },\n            'Shift+Tab' : { handler : 'onShiftTab', weight : 50 }\n        },\n        /**\n         * When expanding a row and the expanded body element is not completely in view, setting this to `true` will\n         * automatically scroll the expanded row into view.\n         * @config {Boolean}\n         * @default\n         */\n        autoScroll : false,\n        /**\n         * When the Grid has multiple regions, setting this config to `true` changes how the expanded content is created\n         * and rendered. Instead of calling {@link #config-renderer} once per region (or one {@link #config-widget}\n         * per region) it will only create one expanded element which will span the full grid width regardless of Grid\n         * regions.\n         * @config {Boolean}\n         * @default\n         */\n        spanRegions : false\n    };\n    // Plugin configuration. This plugin chains/overrides some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain    : ['afterColumnsChange', 'beforeRenderRow', 'processRowHeight', 'bindStore', 'navigateUp'],\n            override : ['onGridBodyFocusIn', 'navigateDown', 'catchFocus', 'keyMapOnKeyDown']\n        };\n    }\n    //endregion\n    //region Init\n    afterConstruct() {\n        const\n            me         = this,\n            { client } = me;\n        if (!me.renderer && !me.widget) {\n            me.disabled = true;\n            console.warn('RowExpander requires either a widget config or implementing the renderer function.');\n            return;\n        }\n        if (client.isGanttBase && client.fixedRowHeight !== false) {\n            console.warn('When using RowExpander on a Gantt, the Gantt`s fixedRowHeight config must be set to false.');\n        }\n        if (me.widget) {\n            GlobalEvents.ion({\n                theme   : me.onThemeChange,\n                thisObj : me\n            });\n        }\n        // Bind initial store\n        me.bindStore(client.store);\n        if (me.triggerEvent) {\n            client.ion({ [me.triggerEvent] : 'onTriggerEvent', thisObj : me });\n        }\n        me.addColumn();\n    }\n    bindStore(store) {\n        const me = this;\n        me.recordStateMap.clear();\n        me.collapsingStateMap.clear();\n        me.detachListeners('clientStoreChange');\n        store.ion({\n            name    : 'clientStoreChange',\n            change  : me.onStoreChange,\n            thisObj : me\n        });\n    }\n    doDisable(disable) {\n        const { client } = this;\n        if (disable) {\n            this.recordStateMap.clear();\n            this.collapsingStateMap.clear();\n        }\n        if (!client.isConfiguring) {\n            client.rowManager.renderFromRow();\n        }\n        super.doDisable(disable);\n    }\n    changeLoadingIndicatorText(text) {\n        return text ? this.L(text) : text;\n    }\n    // Overrides onGridBodyFocusIn to ignore events on row expander body.\n    onGridBodyFocusIn(event) {\n        const me = this;\n        if (me.hasWidget ? !event.target.matches(`.${me.expanderBodyClass}, .${me.shadowRootContainerClass}`)\n            : !me.client.lastMousedownEvent?.target?.closest('.' + me.expanderBodyClass)\n        ) {\n            me.overridden.onGridBodyFocusIn(event);\n        }\n    }\n    // Override keyMap key down so to not acting on keydown inside nested grid\n    keyMapOnKeyDown({ target }) {\n        if (!this.hasWidget || !target.classList?.contains(this.shadowRootContainerClass)) {\n            this.overridden.keyMapOnKeyDown(...arguments);\n        }\n    }\n    get isAnimating() {\n        return this.client.isAnimating;\n    }\n    set isAnimating(value) {\n        const\n            { client }     = this,\n            wasAnimating   = client.isAnimating;\n        client.isAnimating = value;\n        if (client.isAnimating !== wasAnimating) {\n            client.element.classList.toggle('b-rowexpander-animating');\n        }\n    }\n    changeWidget(widget) {\n        if (widget && this.isWidgetConfig(widget)) {\n            return { [this.client.regions[0]] : widget };\n        }\n        return widget;\n    }\n    //endregion\n    //region Events\n    /**\n     * This event fires before row expand is started.\n     *\n     * Returning `false` from a listener prevents the RowExpander to expand the row.\n     *\n     * Note that this event fires when the RowExpander toggles the row, not when the actual row expander body is\n     * rendered. Most of the time this is synchronous, but in the case of a row that is not yet rendered into view by\n     * scrolling, it can happen much later.\n     *\n     * @event beforeExpand\n     * @preventable\n     * @async\n     * @param {Core.data.Model} record Record\n     */\n    /**\n     * This event fires before row collapse is started.\n     *\n     * Returning `false` from a listener prevents the RowExpander to collapse the row.\n     *\n     * Note that this event fires when the RowExpander toggles the row, not when the actual row expander body is\n     * rendered. Most of the time this is synchronous, but in the case of a row that is not yet rendered into view by\n     * scrolling, it can happen much later.\n     *\n     * @event beforeCollapse\n     * @preventable\n     * @async\n     * @param {Core.data.Model} record Record\n     */\n    /**\n     * This event fires when a row expand has finished expanding.\n     *\n     * Note that this event fires when actual row expander body is rendered, and not necessarily in immediate succession\n     * of an expand action. In the case of expanding a row that is not yet rendered into view by scrolling, it can happen\n     * much later.\n     *\n     * @event expand\n     * @param {Core.data.Model} record Record\n     * @param {Object} expandedElements An object with the Grid region name as property and the expanded body\n     * element as value\n     * @param {Core.widget.Widget} widget In case of expanding a Widget, this will be a reference to the instance\n     * created by the actual expansion. If there is multiple Grid regions, use the `widgets` param instead.\n     * @param {Object} widgets In case of expanding a Widget, this will be an object with the Grid region name as\n     * property and the reference to the widget instance created by the actual expansion\n     */\n    /**\n     * This event fires when a row has finished collapsing.\n     *\n     * @event collapse\n     * @param {Core.data.Model} record Record\n     */\n    //endregion\n    //region ExpanderColumn\n    afterColumnsChange() {\n        this.addColumn();\n    }\n    changeColumn(config) {\n        if (config == null) {\n            return config;\n        }\n        return {\n            type    : 'action',\n            actions : [{\n                cls     : 'b-icon b-icon-collapse-down',\n                tooltip : ({ record }) => this.L(this.recordStateMap.has(record) ? 'L{RowExpander.collapse}' : 'L{RowExpander.expand}'),\n                onClick : ({ record }) => this.toggleExpand(record)\n            }],\n            width    : 40,\n            hideable : false,\n            align    : 'center',\n            region   : this.client.regions[0],\n            ...config,\n            field    : 'expanderActionColumn'\n        };\n    }\n    // Called in construct and if grid columns change\n    addColumn() {\n        const\n            me          = this,\n            { column }  = me,\n            { columns } = me.client;\n        if (!me._isAddingExpanderColumn && column && (!me._expander || !columns.includes(me._expander))) {\n            me._isAddingExpanderColumn = true;\n            if (me.columnPosition === 'last') {\n                [me._expander] = columns.add(column);\n            }\n            else {\n                [me._expander] = columns.insert(0, column);\n            }\n            me._isAddingExpanderColumn = false;\n        }\n    }\n    //endregion\n    //region UI events\n    onTriggerEvent({ target }) {\n        // Only grid cell event is handled. Action-cell event has its own handler.\n        if (this.disabled || target?.closest('.b-action-cell') || !target.closest('.b-grid-cell')) {\n            return;\n        }\n        this.toggleExpand(this.client.getRecordFromElement(target));\n    }\n    /**\n     * Toggles expanded state.\n     * @private\n     * @param {Core.data.Model} record The record that should be toggled\n     * @category Internal\n     */\n    toggleExpand(record) {\n        if (record) {\n            if (this.recordStateMap.has(record)) {\n                this.collapse(record);\n            }\n            else {\n                this.expand(record);\n            }\n        }\n    }\n    onExpanderBodyResize(entries) {\n        for (const entry of entries) {\n            const\n                record      = this.client.store.getById(entry.target.dataset?.id),\n                recordState = record && this.recordStateMap.get(record);\n            if (recordState && !recordState.ignoreResize && !recordState.isAnimating) {\n                const oldHeight = recordState.expanderBodyHeight;\n                recordState.expanderBodyHeight = null; // Clears saved height to recalc in processRowHeight\n                if (this.processRowHeight(record, 0) !== oldHeight) {\n                    this.renderRowsWithAnimation(record);\n                }\n            }\n        }\n    }\n    //endregion\n    //region Rendering\n    get shouldSpanRegions() {\n        return this.spanRegions && this.client.regions.length > 1;\n    }\n    /**\n     * Listens to changes in the Grid Store. Will remove expand State data on Store removal.\n     * If the refreshOnRecordChange config is `true`, it will trigger a re-render of the expander.\n     * @private\n     * @param {String} action\n     * @param {Core.data.Store} source\n     * @param {Core.data.Model[]} records\n     * @category Internal\n     */\n    onStoreChange({ action, source, records, changes }) {\n        const\n            me                                     = this,\n            { recordStateMap, collapsingStateMap } = me,\n            changedKeys                            = changes && Object.keys(changes);\n        if (changedKeys?.length === 1 && source.modelClass.fieldMap[changedKeys[0]]?.type === 'store') {\n            return;\n        }\n        if (me.disabled) {\n            return;\n        }\n        if (action === 'removeAll') {\n            recordStateMap.clear();\n            collapsingStateMap.clear();\n        }\n        else if (storeRemoveActions[action]) {\n            for (const [record, state] of recordStateMap) {\n                if (!source.includes(record)) {\n                    me.destroyWidgets(state);\n                    recordStateMap.delete(record);\n                    collapsingStateMap.delete(record);\n                }\n            }\n        }\n        else if (me.refreshOnRecordChange && records?.length) {\n            if (action === 'update') {\n                const recordState = recordStateMap.get(records[0]);\n                if (recordState?.isCreated) {\n                    recordState.isCreated = false;\n                    me.client.rowManager.renderFromRecord(records[0]);\n                }\n            }\n            else if (action === 'updatemultiple') {\n                let topRecordIndex,\n                    topRecord;\n                for (const rec of records) {\n                    const recordState = recordStateMap.get(rec);\n                    if (recordState?.isCreated) {\n                        const index           = source.records.indexOf(rec);\n                        recordState.isCreated = false;\n                        if (!topRecord || topRecordIndex > index) {\n                            topRecordIndex = index;\n                            topRecord      = rec;\n                        }\n                    }\n                }\n                if (topRecord) {\n                    me.client.rowManager.renderFromRecord(topRecord);\n                }\n            }\n        }\n    }\n    // Implements grid.processRowHeight hook\n    processRowHeight(record, height) {\n        const\n            me                    = this,\n            { shouldSpanRegions } = me;\n        let recordState           = me.recordStateMap.get(record),\n            heightChanged         = false;\n        // If we have a recordState but no expanderBodyHeight, we should recalculate height.\n        if (recordState && !recordState.expanderBodyHeight) {\n            for (const region of me.client.regions) {\n                const height = recordState.expandedBodyElements[region]?.offsetHeight;\n                if (height > recordState.expanderBodyHeight) {\n                    recordState.expanderBodyHeight = height;\n                    heightChanged = true;\n                }\n            }\n        }\n        else if (!recordState && (recordState = me.collapsingStateMap.get(record)) && recordState.expanderBodyHeight) {\n            recordState.expanderBodyHeight = 0;\n            heightChanged = true;\n        }\n        if (heightChanged && me.enableAnimations && shouldSpanRegions) {\n            me.animateSpannedExpander(recordState);\n        }\n        return (recordState?.expanderBodyHeight ?? 0) + height;\n    }\n    // If we're using spanRegions, we need to force a CSS transition on the body elements height\n    animateSpannedExpander(state) {\n        const\n            me          = this,\n            bodyElement = state.expandedBodyElements[me.client.regions[0]],\n            rowElement  = me.client.rowManager.getRowById(state.record).element;\n        state.isAnimating = me.isAnimating = true;\n        state.ignoreResize = true;\n        // The bodyElement has no height per default, need to set one to get the CSS transition working\n        bodyElement.style.height = rowElement.offsetHeight - state.cellHeight + 'px';\n        bodyElement.offsetHeight; // Force DOM render\n        bodyElement.style.height = state.expanderBodyHeight + 'px';\n        me.waitForTransition(bodyElement, () => {\n            // Re-set no height\n            bodyElement.style.height = '';\n            if (!state.expanderBodyHeight) {\n                // If we're collapse, remove element\n                bodyElement.remove();\n            }\n            state.isAnimating = me.isAnimating = false;\n        });\n    }\n    /**\n     * Hooks on before row render to render or remove row expander content depending on record state.\n     * @private\n     * @category Internal\n     */\n    beforeRenderRow({ row, record }) {\n        const\n            me           = this,\n            { regions }  = me.client,\n            {\n                expandedRowClass,\n                collapsingStateMap,\n                shouldSpanRegions\n            }            = me,\n            // The map only contains record that are expanded\n            recordState  = me.recordStateMap.get(record);\n        row.cls.toggle('b-rowexpander-disabled', me.disabled);\n        // If current row is expanded\n        if (row.cls[expandedRowClass]) {\n            let collapsingState = collapsingStateMap.get(record);\n            if (collapsingState) {\n                const clearCollapse = () => {\n                    collapsingState = collapsingStateMap.get(record);\n                    // Make sure record still should be collapsed after animation is complete\n                    if (collapsingState) {\n                        collapsingStateMap.delete(record);\n                        me.removeExpander(row);\n                        me.destroyWidgets(collapsingState);\n                    }\n                };\n                // If animating a collapse, content should not be removed until animation is complete\n                if (me.enableAnimations && me.isAnimating) {\n                    me.waitForTransition(row, clearCollapse);\n                }\n                else {\n                    clearCollapse();\n                }\n            }\n            // Row is expanded but record should not be, remove expander\n            else if (!recordState) {\n                me.removeExpander(row);\n            }\n        }\n        else {\n            // Makes sure record should collapse no longer\n            collapsingStateMap.delete(record);\n        }\n        if (!me.disabled && recordState) {\n            // Expander content is created once, then reused.\n            if (!recordState.isCreated) {\n                recordState.ignoreResize = true; // Tells the resizeObserver to ignore this element right now\n                me.renderExpander(record, row, recordState);\n            }\n            row.cls.add(expandedRowClass);\n            regions.forEach((region, i) => {\n                const rowElement = row.getElement(region);\n                // isCreated means that the content has finished its creation process, which can be async\n                // If shouldSpanRegions, then we only do this on the first region\n                if (recordState.isCreated && (!shouldSpanRegions || i === 0)) {\n                    const\n                        bodyElement = recordState.expandedBodyElements[region],\n                        target      = shouldSpanRegions ? me.client.verticalScroller : rowElement;\n                    // If the bodyElement is connected to our target, we do not need to do anything\n                    if (bodyElement.parentElement !== target) {\n                        if (!shouldSpanRegions) {\n                            // If not, remove current content\n                            DomHelper.removeEachSelector(rowElement, '.' + me.expanderBodyClass);\n                        }\n                        // And add the created element\n                        target.appendChild(bodyElement);\n                        // Observe body element to refresh grid when the body element resizes\n                        me.observeResize(bodyElement);\n                    }\n                    if (shouldSpanRegions) {\n                        // Sync row top with expanded element top\n                        bodyElement.style.top = row.top + recordState.cellHeight + 'px';\n                    }\n                    recordState.ignoreResize = false;\n                    // Resolve the expand promise on next animation frame\n                    if (recordState.renderPromiseResolver && !recordState.isRenderingAsync) {\n                        me.delay(recordState.renderPromiseResolver);\n                        recordState.renderPromiseResolver = null;\n                    }\n                }\n                me.lockCellHeight(rowElement, recordState.cellHeight, false);\n            });\n            // If expander body is rendered not fully in view, it will be scrolled into view\n            if (me._shouldScrollIntoView && me.autoScroll) {\n                me._shouldScrollIntoView = false;\n                if (!DomHelper.isInView(recordState.expandedBodyElements[regions[0]], true)) {\n                    // Wait for rendering to complete, then scroll\n                    me.client.rowManager.ion({\n                        once       : true,\n                        thisObj    : me,\n                        renderDone : () => me.scrollRowIntoView(row, record)\n                    });\n                }\n            }\n        }\n    }\n    /**\n     * Scrolls expanded row into view. This function is called after rowManager has finished rendering.\n     * @private\n     * @category Internal\n     */\n    scrollRowIntoView(row, record) {\n        // If animating expand, need to wait for the animation to end before scrolling.\n        if (this.isAnimating) {\n            this.waitForTransition(row, () => this.client.scrollRowIntoView(record));\n        }\n        else {\n            this.client.scrollRowIntoView(record);\n        }\n    }\n    /**\n     * Waits for height transition on the provided rows element. Then calls provided function.\n     * @private\n     * @category Internal\n     */\n    waitForTransition(row, fn) {\n        const element = DomHelper.isElement(row) ? row : row.element;\n        EventHelper.onTransitionEnd({\n            element,\n            property : 'height',\n            handler  : fn,\n            thisObj  : this,\n            duration : DomHelper.getPropertyTransitionDuration(element, 'height') ?? 1\n        });\n    }\n    removeExpander(row) {\n        const me = this;\n        row.cls.remove(me.expandedRowClass);\n        for (const region of me.client.regions) {\n            const rowElement = row.getElement(region);\n            for (const child of rowElement.querySelectorAll('.' + me.expanderBodyClass)) {\n                me.unobserveResize(child);\n                child.remove();\n            }\n            // If this function is called after animation finished, we need to remove class `manually`\n            rowElement.classList.remove(me.expandedRowClass);\n            me.lockCellHeight(rowElement, null, false);\n            // If spanRegions, remove that element as well\n            if (me.shouldSpanRegions) {\n                row._spannedExpandedBodyElement?.remove?.();\n                row._spannedExpandedBodyElement = null;\n            }\n        }\n    }\n    destroyWidgets(state) {\n        for (const region of this.client.regions) {\n            state.widgets?.[region]?.destroy?.();\n        }\n    }\n    // Checks if a configuration object is a widget configuration object\n    isWidgetConfig(content) {\n        return content.type && !content.tag;\n    }\n    /**\n     * Creates expander element for each grid region and calls the renderer, also for each grid region.\n     * @private\n     * @param {Core.data.Model} record\n     * @param {Grid.row.Row} row\n     * @param {Object} recordState\n     * @category Internal\n     */\n    renderExpander(record, row, recordState) {\n        const\n            me                                           = this,\n            { client : grid, widget, shouldSpanRegions } = me,\n            cellHeight                                   = row.cells[0]?.offsetHeight,\n            { expandedBodyElements = {} }                = recordState,\n            renderPromises                               = [],\n            // Will be called sync or async depending on the implementation of the renderer function.\n            continueRendering                            = (content, expanderElement, region) => {\n                if (content != null) {\n                    if (typeof content === 'string') {\n                        // In case there is nodes already there\n                        const currentChildren = [...expanderElement.childNodes].map(n => expanderElement.removeChild(n));\n                        expanderElement.innerHTML = content;\n                        currentChildren.reverse().forEach(n => expanderElement.insertBefore(n, expanderElement.firstChild));\n                    }\n                    else if (me.isWidgetConfig(content)) {\n                        createWidget(content, expanderElement, region);\n                    }\n                    // Everything else will be treated as a dom config for now\n                    else {\n                        content = DomHelper.createElement(content);\n                        expanderElement.appendChild(content);\n                    }\n                }\n            },\n            createWidget = (widgetConfig, expanderElement, region) => {\n                const\n                    themeName           = DomHelper.getThemeInfo()?.name,\n                    shadowRootContainer = DomHelper.createElement({\n                        parent    : expanderElement,\n                        className : me.shadowRootContainerClass,\n                        style     : 'flex : 1'\n                    }),\n                    shadowRoot = shadowRootContainer._shadowRoot = shadowRootContainer.attachShadow({ mode : 'closed' });\n                renderPromises.push(DomHelper.cloneStylesIntoShadowRoot(shadowRoot).then(() => {\n                    if (grid.isDestroyed) {\n                        return;\n                    }\n                    const widgetDataField = widgetConfig.dataField ?? me.dataField;\n                    if (widgetDataField) {\n                        const fieldData = record.getValue(widgetDataField);\n                        // This path is used if field is a StoreDataField\n                        if (fieldData?.isStore) {\n                            widgetConfig.store = fieldData;\n                        }\n                        else if (grid.store[`${widgetDataField}Store`]) {\n                            const relatedStore = grid.store[`${widgetDataField}Store`];\n                            widgetConfig.store = relatedStore.chain(r => record.getValue(widgetDataField).includes(r));\n                        }\n                        else {\n                            widgetConfig.data = fieldData;\n                        }\n                    }\n                    if (themeName) {\n                        const\n                            { cls }  = widgetConfig,\n                            themeCls = `b-theme-${themeName.toLowerCase()}`;\n                        widgetConfig.cls = cls ? cls + ' ' + themeCls : themeCls;\n                    }\n                    if (!recordState.widgets) {\n                        recordState.widgets = {};\n                    }\n                    recordState.widgets[region] = expanderElement.widget = Widget.create(ObjectHelper.assign({\n                        appendTo       : shadowRoot,\n                        owner          : grid,\n                        flex           : 1,\n                        minHeight      : '5em',\n                        isNested       : true,\n                        expandedRecord : record\n                    }, widgetConfig));\n                    if (widgetDataField) {\n                        // If we have created a store, refresh expanded row on store changes\n                        expanderElement.widget.store.ion({\n                            change  : () => !row.isDestroyed && row.render(),\n                            thisObj : me\n                        });\n                    }\n                }).catch((href) => {\n                    throw new Error('Could not load stylesheet ' + href);\n                }));\n            };\n        // If another rendering of the same record is made while waiting for async, we should ignore it.\n        if (recordState.isRenderingAsync) {\n            return;\n        }\n        // class needed at this point to give the expander container correct height\n        row.addCls(me.expandedRowClass);\n        Object.assign(recordState, { cellHeight, expandedBodyElements, expanderBodyHeight : 0, loadingIndicators : [] });\n        for (const [i, region] of grid.regions.entries()) {\n            // If spanRegions, we only care about the first region\n            if (shouldSpanRegions && i > 0) {\n                break;\n            }\n            const\n                rowElement          = row.getElement(region);\n            let expanderBodyElement = expandedBodyElements[region],\n                renderResponse;\n            if (expanderBodyElement) {\n                // If there is one already, it's content needs to be removed\n                me.unobserveResize(expanderBodyElement);\n                expanderBodyElement.replaceChildren();\n            }\n            else {\n                // Create expand container\n                // Expander element needs to be in the DOM for appendTo to work correctly\n                expanderBodyElement = DomHelper.createElement({\n                    parent    : shouldSpanRegions ? grid.verticalScroller : rowElement,\n                    tabIndex  : -1,\n                    className : me.expanderBodyClass,\n                    style     : {\n                        top : shouldSpanRegions ? row.top + cellHeight : cellHeight + 'px'\n                    },\n                    dataset : {\n                        id : record.id\n                    }\n                });\n            }\n            if (shouldSpanRegions) {\n                row._spannedExpandedBodyElement = expanderBodyElement;\n            }\n            me.observeResize(expanderBodyElement);\n            if (widget?.[region]) {\n                createWidget(widget[region], expanderBodyElement, region);\n            }\n            else {\n                // The renderer can be async or sync\n                renderResponse = me.renderer?.({\n                    record,\n                    expanderElement : expanderBodyElement,\n                    rowElement,\n                    region,\n                    grid\n                });\n            }\n            if (Objects.isPromise(renderResponse)) {\n                renderPromises.push(renderResponse.then(content => continueRendering(content, expanderBodyElement, region)));\n            }\n            else {\n                continueRendering(renderResponse, expanderBodyElement, region);\n            }\n            expandedBodyElements[region] = expanderBodyElement;\n        }\n        // If we have async renderer, wait for all to complete\n        if (renderPromises.length) {\n            recordState.isRenderingAsync = true;\n            // Adding loading indicators when waiting for async content\n            me.showLoadingIndicators(recordState);\n            Promise.all(renderPromises).then(() => {\n                // One of the promises (createWidget) can, while resolving, add another promise to the array\n                // That's why we need to do this twice\n                Promise.all(renderPromises).then(() => {\n                    if (grid.isDestroyed) {\n                        return;\n                    }\n                    // Remove loading indicator\n                    recordState.loadingIndicators?.forEach(li => li.remove());\n                    recordState.loadingIndicators.length = 0;\n                    recordState.ignoreResize = false;\n                    recordState.isRenderingAsync = false;\n                    // Initiate a render if all current states is finished rendering, this code should be executed once\n                    // for each state\n                    for (const [, state] of me.recordStateMap) {\n                        if (state.isRenderingAsync) {\n                            return;\n                        }\n                    }\n                    // (?. since we might have been destroyed while waiting for promises)\n                    me.renderRowsWithAnimation?.(record, true);\n                });\n            });\n        }\n        recordState.isCreated = true;\n    }\n    showLoadingIndicators(recordState) {\n        for (const region in recordState.expandedBodyElements) {\n            recordState.loadingIndicators.push(DomHelper.createElement({\n                parent    : recordState.expandedBodyElements[region],\n                className : 'b-rowexpander-loading',\n                style     : {\n                    height : this.loadingIndicatorHeight + 'px'\n                },\n                children : [\n                    {\n                        tag       : 'i',\n                        className : 'b-icon b-icon-spinner'\n                    },\n                    this.loadingIndicatorText\n                ]\n            }));\n        }\n    }\n    /**\n     * Called when grid rows needs to re-render, for example on expand or collapse.\n     * Activates animations on grid, and deactivates them when they are completed.\n     * @private\n     * @param {Core.data.Model} record Record whose row was toggled\n     * @category Internal\n     */\n    renderRowsWithAnimation(record) {\n        const me = this;\n        if (me.enableAnimations) {\n            const row = me.client.rowManager.getRowById(record);\n            if (row) {\n                me.isAnimating = true;\n                if (me.collapsingStateMap.has(record)) {\n                    row.addCls('b-row-is-collapsing');\n                }\n                me.waitForTransition(row, () => {\n                    me.isAnimating = false;\n                    if (!row.isDestroyed) {\n                        row.removeCls?.('b-row-is-collapsing');\n                    }\n                });\n            }\n        }\n        return me.bufferedRenderer(record);\n    }\n    /**\n     * Collects a rendering call for each record, saves them in array and calls the delayed (RAF) rafRenderer function\n     * @private\n     * @param {Core.data.Model} record Record whose row was toggled\n     * @category Internal\n     */\n    bufferedRenderer(record) {\n        (this._bufferedRecords ?? (this._bufferedRecords = [])).push(record);\n        if (!this._rafPromise) {\n            this._rafPromise = new Promise(resolve => {\n                requestAnimationFrame(() => {\n                    this.internalRender?.(resolve);\n                    this._rafPromise = null;\n                });\n            });\n        }\n        return this._rafPromise;\n    }\n    /**\n     * Re-renders the grid from the topmost record of those saved in bufferedRenderer\n     * @private\n     * @category Internal\n     */\n    internalRender(resolvePromise) {\n        const\n            me                   = this,\n            { _bufferedRecords } = me,\n            { store }            = me.client;\n        me.recordStateMap.forEach((state, record) => {\n            if (state.renderPromiseResolver && state.isCreated && !_bufferedRecords.includes(record)) {\n                _bufferedRecords.push(record);\n            }\n        });\n        const [top] = _bufferedRecords.sort((a, b) => store.indexOf(a) - store.indexOf(b));\n        me.client.rowManager.renderFromRecord(top);\n        _bufferedRecords.length = 0;\n        // So that rendering is completed when promises are resolved\n        me.delay(resolvePromise);\n    }\n    /**\n     * Called when row is expanded. This function locks all cell's height to current height (before expanding).\n     * @private\n     * @param {HTMLElement} rowElement\n     * @param {Number} cellHeight The height to lock\n     * @param {Boolean} unlock To remove locked cell height when the row is collapsed\n     * @category Internal\n     */\n    lockCellHeight(rowElement, cellHeight, unlock) {\n        for (let a = 0; a < rowElement.children.length; a++) {\n            const child = rowElement.children[a];\n            // Should not lock expander element\n            if (!child.classList.contains(this.expanderBodyClass)) {\n                child.style.height = unlock ? '' : cellHeight + 'px';\n            }\n        }\n    }\n    //endregion\n    //region Public\n    /**\n     * Tells the RowExpander that the provided record should be expanded. If or when the record is rendered into view,\n     * the record will be expanded.\n     *\n     * Promise will resolve when the row gets expanded. Note that this can be much later than the actual expand call,\n     * depending on response times and if current record is in view or not.\n     *\n     * @param {Core.data.Model} record Record whose row should be expanded\n     * @category Common\n     */\n    async expand(record, fromSplit = false) {\n        const me = this;\n        if (me.disabled || me.recordStateMap.has(record) || await me.trigger('beforeExpand', { record }) === false) {\n            return;\n        }\n        let recordState;\n        return new Promise((resolve) => {\n            recordState = {\n                isCreated             : false,\n                renderPromiseResolver : resolve,\n                record\n            };\n            // Tells renderer that this record should be expanded\n            me.recordStateMap.set(record, recordState);\n            // In the event that we have expanded a record which is in collapsing animation state\n            me.collapsingStateMap.delete(record);\n            me._shouldScrollIntoView = true;\n            me.renderRowsWithAnimation(record);\n            // Propagate to splits\n            if (!fromSplit) {\n                me.client.syncSplits?.(other => other.features.rowExpander.expand(record, true));\n            }\n        }).then(() => {\n            me.trigger?.('expand', {\n                record,\n                expandedElements : recordState.expandedBodyElements,\n                widget           : recordState.widgets?.[me.client.regions[0]],\n                widgets          : recordState.widgets\n            });\n        });\n    }\n    /**\n     * Tells the RowExpander that the provided record should be collapsed. If the record is in view, it will be\n     * collapsed. If the record is not in view, it will simply not be expanded when rendered into view.\n     *\n     * @param {Core.data.Model} record Record whose row should be collapsed\n     * @category Common\n     */\n    async collapse(record, fromSplit = false) {\n        const\n            me          = this,\n            recordState = me.recordStateMap.get(record);\n        if (me.disabled || await me.trigger('beforeCollapse', { record }) === false) {\n            return;\n        }\n        // Unobserve resize\n        if (recordState?.expandedBodyElements) {\n            for (const region in recordState.expandedBodyElements) {\n                me.unobserveResize(recordState.expandedBodyElements[region]);\n            }\n        }\n        me.recordStateMap.delete(record);\n        me.collapsingStateMap.set(record, recordState);\n        await me.renderRowsWithAnimation(record);\n        me.trigger('collapse', { record });\n        // Propagate to splits\n        if (!fromSplit) {\n            me.client.syncSplits?.(other => other.features.rowExpander.collapse(record, true));\n        }\n    }\n    //endregion\n    // region Nested navigation\n    get hasWidget() {\n        return Boolean(this.widget) || [...this.recordStateMap.values()].some(state => state.widgets);\n    }\n    // Overrides the original, hence the if statement\n    navigateDown() {\n        if (!this.onKeyboardIn()) {\n            return this.overridden.navigateDown(...arguments);\n        }\n    }\n    // Chains the original\n    navigateUp() {\n        this.onKeyboardIn(true);\n    }\n    // Detects if focus is being reverted here by a nested grid, and focuses either the expanded row or the row below\n    catchFocus({ navigationDirection, source, editing }) {\n        const\n            { client }               = this,\n            { focusedCell, regions } = client;\n        for (let [record, state] of this.recordStateMap.entries()) {\n            for (const region in state.expandedBodyElements) {\n                if (state.expandedBodyElements[region].widget === source) {\n                    // If we're tab-editing, we should look for a nested grid in the region next to the source's region\n                    // If there is one, we should start editing there\n                    if (editing) {\n                        const nextRegion = regions[regions.indexOf(region) + (navigationDirection === 'down' ? 1 : -1)];\n                        if (nextRegion) {\n                            return this.startEditInWidget(state.widgets?.[nextRegion], navigationDirection === 'down');\n                        }\n                    }\n                    if (navigationDirection === 'down') {\n                        record = client.store.getNext(record, undefined, true);\n                    }\n                    let column;\n                    // If a column has been navigated to earlier, focus that\n                    if (!editing && focusedCell && !focusedCell._isDefaultFocus) {\n                        column = focusedCell.column;\n                    }\n                    // Else, get best candidate\n                    else {\n                        column = this.getNavigateableColumn(client, true, editing && navigationDirection === 'up');\n                    }\n                    // In case the cell we want to revert to is the one that was focused previously\n                    client._focusedCell = null;\n                    const cellContext = client.normalizeCellContext({ record, column });\n                    client.focusCell(cellContext);\n                    if (editing) {\n                        client.startEditing(cellContext);\n                    }\n                    return true;\n                }\n            }\n        }\n    }\n    // Detects if the user keyboard navigates either from the expanded row and down, or the row below the expanded row\n    // and up. If so, and there is a Grid in the expanded body, it starts to keyboard navigate there\n    onKeyboardIn(up) {\n        const\n            { focusedCell } = this.client,\n            state           = focusedCell && this.recordStateMap.get(focusedCell.record),\n            widget          = state?.expandedBodyElements?.[focusedCell?.column?.region]?.widget;\n        if (widget?.isGrid) {\n            let column;\n            // If a column has been navigated to earlier, focus that\n            if (widget.focusedCell && !widget.focusedCell._isDefaultFocus) {\n                column = widget.focusedCell.column;\n            }\n            // Else, get the best possible candidate\n            else {\n                column = this.getNavigateableColumn(widget);\n            }\n            // In case the cell we want to revert to is the one that was focused previously\n            widget._focusedCell = null;\n            widget.focusCell(widget.normalizeCellContext({ record : widget[`${up ? 'last' : 'first'}VisibleRow`], column }));\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Get the first column that is not the `checkboxSelectionColumn` and not the expander column.\n     * @param grid\n     * @param editable Also checks that the column has an `editor`\n     * @param reverse If `true`, this functions returns the last column which meets the requirements\n     * @private\n     */\n    getNavigateableColumn(grid, editable = true, reverse = false) {\n        const columns = reverse ? [...grid.columns.visibleColumns].reverse() : grid.columns.visibleColumns;\n        return columns.find(c =>\n            c !== grid.checkboxSelectionColumn &&\n            c !== grid.features.rowExpander?._expander &&\n            (!editable || c.editor)\n        ) ?? columns[0];\n    }\n    isActionAvailable({ actionName }) {\n        if (actions[actionName]) {\n            return !this.isDisabled && this.client.features.cellEdit?.isEditing;\n        }\n    }\n    onTab(previous) {\n        const\n            { client }   = this,\n            { cellEdit } = client.features;\n        // Tab:ing while cell editing\n        if (cellEdit?.enabled) {\n            const\n                { columns, regions } = client,\n                { activeRecord }     = cellEdit,\n                next                 = previous !== true,\n                nextCell             = cellEdit.getAdjacentEditableCell(client.focusedCell, next),\n                expandedRecord       = next ? activeRecord : (nextCell ? client.store.getById(nextCell.id) : null),\n                widgets              = expandedRecord && this.recordStateMap.get(expandedRecord)?.widgets;\n            // If the cell were trying to tab into is on a new row\n            // And the current row is expanded (or the next row if we're tab:ing backwards)\n            if (widgets && activeRecord?.id !== nextCell?.id) {\n                // Get that column's region\n                let nextRegion = (nextCell ? columns.getById(nextCell.columnId) : columns.visibleColumns[0]).region;\n                while (nextRegion) {\n                    // Is there a widget in that region?\n                    const widget = widgets[nextRegion];\n                    // Try to start editing the widget. If it works, we're done\n                    if (this.startEditInWidget(widget, next)) {\n                        return true;\n                    }\n                    // Otherwise, try the next (or previous) region\n                    nextRegion = regions[regions.indexOf(nextRegion) + (next ? 1 : -1)];\n                }\n            }\n        }\n        // KeyMap continues to call action handlers for this shortcut\n        return false;\n    }\n    startEditInWidget(widget, next = true) {\n        const { cellEdit } = this.client.features;\n        if (cellEdit?.enabled && widget?.features?.cellEdit?.enabled) {\n            cellEdit.finishEditing().then(() => {\n                const\n                    record = widget[`${next ? 'first' : 'last'}VisibleRow`],\n                    column = this.getNavigateableColumn(widget, true, !next);\n                widget.startEditing(widget.normalizeCellContext({ record, column }));\n            });\n            return true;\n        }\n    }\n    onShiftTab() {\n        return this.onTab(true);\n    }\n    // endregion\n    // Resize observe in own function for overridability\n    observeResize(element) {\n        const me = this;\n        if (!me.resizeObserver) {\n            me.resizeObserver = new ResizeObserver(entries => me.onExpanderBodyResize(entries));\n        }\n        me.resizeObserver.observe(element);\n    }\n    // Unobserves an observed element\n    unobserveResize(element) {\n        this.resizeObserver?.unobserve(element);\n    }\n    doDestroy() {\n        this.resizeObserver?.disconnect();\n        delete this.resizeObserver;\n        // destroy any nested widgets\n        for (const [, state] of this.recordStateMap) {\n            this.destroyWidgets(state);\n        }\n        super.doDestroy();\n    }\n    onThemeChange({ prev, theme }) {\n        for (const [, entry] of this.recordStateMap) {\n            Object.values(entry.expandedBodyElements).forEach(bodyElement => {\n                const shadowRootContainer = bodyElement.querySelector('.' + this.shadowRootContainerClass);\n                if (shadowRootContainer?._shadowRoot) {\n                    DomHelper.cloneStylesIntoShadowRoot(shadowRootContainer?._shadowRoot, true);\n                    bodyElement.widget?.element?.classList.remove(`b-theme-${prev}`);\n                    bodyElement.widget?.element?.classList.add(`b-theme-${theme}`);\n                }\n            });\n        }\n    }\n    /**\n     * Gets the corresponding expanded record from either a nested widget or an element in the expanded body.\n     * @param {HTMLElement|Core.widget.Widget} elementOrWidget\n     * @returns {Core.data.Model}\n     */\n    getExpandedRecord(elementOrWidget) {\n        for (const [rec, { widgets, expandedBodyElements }] of this.recordStateMap.entries()) {\n            if (widgets && elementOrWidget.isWidget) {\n                for (const region in widgets) {\n                    if (widgets[region] === elementOrWidget) {\n                        return rec;\n                    }\n                }\n                // Fallback if calling this function on paint\n                if (elementOrWidget.expandedRecord?.isModel) {\n                    return elementOrWidget.expandedRecord;\n                }\n            }\n            else {\n                for (const region in expandedBodyElements) {\n                    const curEl = expandedBodyElements[region];\n                    if (curEl === elementOrWidget || curEl.contains(elementOrWidget)) {\n                        return rec;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    /**\n     * Gets the expanded widget(s) for a specified record. The widget(s) will be returned as an object with region\n     * names as properties and the widgets as values.\n     * @param {Core.data.Model} record\n     * @returns {Core.widget.Widget}\n     */\n    getExpandedWidgets(record) {\n        return this.recordStateMap.get(record)?.widgets;\n    }\n}\nRowExpander._$name = 'RowExpander'; GridFeatureManager.registerFeature(RowExpander);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport DomDataStore from '../../Core/data/DomDataStore.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nconst actions = {\n    goToNextHit : 1,\n    goToPrevHit : 1\n};\n/**\n * @module Grid/feature/Search\n */\n/**\n * {@inlineexample Grid/feature/Search.js}\n *\n * Feature that allows the user to search the entire grid. Navigate between hits using the\n * keyboard, [F3] or [Ctrl/CMD + G] moves to next, also pressing [Shift] moves to previous.\n *\n * Note that this feature does not include a UI, please build your own and call appropriate methods in the feature.\n * For a demo implementation, see <a href=\"../examples/search/\" target=\"_blank\">Search example</a>.\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * ## Keyboard shortcuts\n *\n * This feature has the following default keyboard shortcuts:\n *\n * | Keys               | Action        | Action description                |\n * |--------------------|---------------|-----------------------------------|\n * | `F3`               | *goToNextHit* | Move focus to next search hit     |\n * | `Shift`+`F3`       | *goToPrevHit* | Move focus to previous search hit |\n * | `Ctrl`+`G`         | *goToNextHit* | Move focus to next search hit     |\n * | `Ctrl`+`Shift`+`G` | *goToPrevHit* | Move focus to previous search hit |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Grid/guides/customization/keymap.md)\n *\n * ```javascript\n * // enable Search\n * let grid = new Grid({\n *   features: {\n *     search: true\n *   }\n * });\n *\n * // perform search\n * grid.features.search.search('steve');\n * ```\n *\n * @demo Grid/search\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype search\n * @feature\n */\nexport default class Search extends Delayable(InstancePlugin) {\n    //region Init\n    static $name = 'Search';\n    static configurable = {\n        /**\n         * The maximum amount of search hits\n         * @config {Number}\n         * @default\n         */\n        limit : 1000,\n        /**\n         * Set to false to not show the search hit index numbers\n         * @config {Boolean}\n         * @default\n         */\n        showHitIndex : true,\n        /**\n         * See {@link #keyboard-shortcuts Keyboard shortcuts} for details\n         * @config {Object<String,String>}\n         */\n        keyMap : {\n            F3             : 'gotoNextHit',\n            'Ctrl+g'       : 'gotoNextHit',\n            'Shift+F3'     : 'gotoPrevHit',\n            'Ctrl+Shift+g' : 'gotoPrevHit'\n        }\n    };\n    static get properties() {\n        return {\n            hitCls          : 'b-search-hit',\n            hitCellCls      : 'b-search-hit-cell',\n            hitCellBadgeCls : 'b-search-hit-cell-badge',\n            hitTextCls      : 'b-search-hit-text'\n        };\n    }\n    construct(grid, config) {\n        super.construct(grid, config);\n        Object.assign(this, {\n            grid,\n            text       : '',\n            hitEls     : [],\n            treeWalker : grid.setupTreeWalker(grid.element, DomHelper.NodeFilter.SHOW_TEXT, () => DomHelper.NodeFilter.FILTER_ACCEPT)\n        });\n        // When new nodes appear due to node expand, include them in the search\n        grid.ion({\n            expandNode : 'onTreeNodeExpand',\n            thisObj    : this\n        });\n    }\n    isActionAvailable({ actionName }) {\n        if (actions[actionName]) {\n            return Boolean(this.text);\n        }\n    }\n    onTreeNodeExpand() {\n        if (this.text) {\n            this.requestAnimationFrame(this.search, [this.text, false, true]);\n        }\n    }\n    doDestroy() {\n        this.clear(true);\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        if (disable) {\n            this.clear();\n        }\n        super.doDisable(disable);\n    }\n    get store() {\n        return this.grid.store;\n    }\n    //endregion\n    //region Plugin config\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['populateCellMenu']\n        };\n    }\n    //endregion\n    //region Search\n    /**\n     * Performs a search and highlights hits.\n     * @param {String} text Text to search for\n     * @param {Boolean} [gotoHit] Go to first hit after search\n     * @param {Boolean} [reapply] Pass true to force search\n     * @param {String[]} [fields] An array of the fields to search for the value in\n     */\n    async search(text, gotoHit = true, reapply = false, fields, fromSplit = false) {\n        const me = this;\n        // empty search considered a clear\n        if (!text) {\n            return me.clear();\n        }\n        // searching for same thing again, do nothing\n        if (!reapply && text === me.text || me.disabled) {\n            return;\n        }\n        const\n            { grid, store } = me,\n            // Only search columns in use\n            columns         = grid.columns.visibleColumns.filter(col => col.searchable !== false),\n            formatters      = [];\n        fields      = fields || columns.map(col => {\n            // For date / number columns\n            formatters.push(col.formatValue?.bind(col));\n            return col.field;\n        });\n        const found = store.search(text, fields, formatters);\n        if (store.isTree && found.length) {\n            await grid.expandTo(found.map(hit => hit.id));\n        }\n        // Only include first result for merged cells in the count\n        for (const column of columns) {\n            if (column.mergeCells && column.isSorted) {\n                let prevValue = null,\n                    belongsTo = null;\n                for (const hit of found) {\n                    if (hit.field === column.field) {\n                        const value = hit.data[hit.field];\n                        if (value === prevValue) {\n                            hit.belongsTo = belongsTo;\n                        }\n                        prevValue = value;\n                        belongsTo = `${hit.field}-${hit.id}`;\n                    }\n                }\n            }\n        }\n        let i = 1;\n        Object.assign(me, {\n            foundMap  : {},\n            prevFound : me.found,\n            found,\n            text,\n            findRe    : new RegExp(`(\\\\s+)?(${StringHelper.escapeRegExp(String(text))})(\\\\s+)?`, 'ig')\n        });\n        me.clearHits();\n        if (!found) {\n            return;\n        }\n        // highlight hits for visible cells\n        for (const hit of found) {\n            // merged cells reuse the index of the first hit in the range\n            me.foundMap[`${hit.field}-${hit.id}`] = hit.belongsTo ? me.foundMap[hit.belongsTo] : i++;\n            // limit hits\n            if (i > me.limit) {\n                break;\n            }\n        }\n        if (!me.listenersInitialized) {\n            grid.rowManager.ion({\n                name       : 'renderCell',\n                renderCell : 'renderCell',\n                thisObj    : me\n            });\n            store.ion({\n                name                                : 'storeRefresh',\n                [`refresh${grid.asyncEventSuffix}`] : 'onStoreRefresh',\n                thisObj                             : me\n            });\n            me.listenersInitialized = true;\n        }\n        grid.refreshRows();\n        grid.trigger('search', { grid, find : text, found });\n        if (gotoHit && !me.isHitFocused && !fromSplit) {\n            me.gotoNextHit(true);\n        }\n        grid.syncSplits?.(other => other.features.search.search(text, gotoHit, reapply, fields, true));\n        return found;\n    }\n    clearHits() {\n        // Clear old hits\n        for (const cellElement of DomHelper.children(this.grid.element, '.' + this.hitCls)) {\n            cellElement.classList.remove(this.hitCls, this.hitCellCls);\n            // Rerender cell to remove search-hit-text\n            const row = DomDataStore.get(cellElement).row;\n            // Merged cells have no row, but they will be cleared anyway by their own DomSync call\n            if (row) {\n                // Need to force replace the markup\n                row.forceInnerHTML = true;\n                row.renderCell(cellElement);\n                row.forceInnerHTML = false;\n            }\n        }\n    }\n    /**\n     * Clears search results.\n     */\n    clear(silent = false) {\n        const\n            me       = this,\n            { grid } = me;\n        if (me.foundMap) {\n            delete me.foundMap;\n        }\n        me.text = null;\n        me.clearHits();\n        if (me.listenersInitialized) {\n            me.detachListeners('renderCell');\n            me.detachListeners('storeRefresh');\n            me.listenersInitialized = false;\n        }\n        if (!silent) {\n            grid.trigger('clearSearch', { grid });\n            // Propagate to other grids when splitting\n            grid.syncSplits?.(other => other.features.search.clear());\n        }\n    }\n    /**\n     * Number of results found\n     * @readonly\n     * @property {Number}\n     */\n    get foundCount() {\n        return this.found?.length ?? 0;\n    }\n    //endregion\n    //region Navigation\n    /**\n     * Returns true if focused row is a hit\n     * @property {Boolean}\n     * @readonly\n     */\n    get isHitFocused() {\n        const\n            me              = this,\n            { grid }        = me,\n            { focusedCell } = grid;\n        if (focusedCell?.cell?.contains(DomHelper.getActiveElement(grid.element))) {\n            const { rowIndex, column } = focusedCell;\n            return rowIndex !== -1 && me.found.some(hit =>\n                hit.index === rowIndex && column && hit.field === column.field\n            );\n        }\n    }\n    /**\n     * Select the next hit, scrolling it into view. Triggered with [f3] or [ctrl]/[cmd] + [g].\n     */\n    gotoNextHit(fromStart = false) {\n        const\n            me = this;\n        if (!me.found?.length) return;\n        const\n            { grid, store } = me,\n            fromCell        = grid.focusedCell || grid.lastFocusedCell,\n            currentIndex    = fromCell && fromStart !== true ? store.indexOf(fromCell.record, undefined, true) : -1,\n            nextHit         = me.found.findIndex(hit => hit.index > currentIndex);\n        if (nextHit !== -1) {\n            me.gotoHit(nextHit);\n        }\n    }\n    /**\n     * Select the previous hit, scrolling it into view. Triggered with [shift] + [f3] or [shift] + [ctrl]/[cmd] + [g].\n     */\n    gotoPrevHit() {\n        const\n            me        = this,\n            { store } = me;\n        if (!me.found?.length) return;\n        const\n            { grid, found } = me,\n            fromCell        = grid.focusedCell || grid.lastFocusedCell,\n            currentIndex    = fromCell ? store.indexOf(fromCell.record, undefined, true) : 0;\n        for (let i = found.length - 1; i--; i >= 0) {\n            const hit = found[i];\n            if (hit.index < currentIndex) {\n                me.gotoHit(i);\n                break;\n            }\n        }\n    }\n    /**\n     * Go to specified hit.\n     * @param {Number} index\n     */\n    gotoHit(index) {\n        const\n            { grid } = this,\n            nextHit  = this.found[index];\n        if (nextHit) {\n            grid.focusCell({\n                field : nextHit.field,\n                id    : nextHit.id\n            });\n        }\n        return Boolean(nextHit);\n    }\n    /**\n     * Go to the first hit.\n     */\n    gotoFirstHit() {\n        this.gotoHit(0);\n    }\n    /**\n     * Go to the last hit.\n     */\n    gotoLastHit() {\n        this.gotoHit(this.found.length - 1);\n    }\n    //endregion\n    //region Render\n    /**\n     * Called from SubGrid when a cell is rendered. Highlights search hits.\n     * @private\n     */\n    renderCell({ cellElement, column, record, value }) {\n        const\n            me       = this,\n            {\n                treeWalker,\n                findRe,\n                hitTextCls,\n                showHitIndex\n            }        = me,\n            hitIndex = me.foundMap?.[column.field + '-' + record.id];\n        if (hitIndex) {\n            // highlight cell\n            cellElement.classList.add(me.hitCls);\n            // Remove any previous hit badge\n            showHitIndex && cellElement.querySelector(`.${me.hitCellBadgeCls}`)?.remove();\n            // highlight in cell if found in innerHTML\n            const inner = DomHelper.down(cellElement, '.b-grid-cell-value,.b-tree-cell-value') || cellElement;\n            if (String(value).toLowerCase() === String(me.text).toLowerCase()) {\n                inner.innerHTML = `<span class=\"${me.hitTextCls}\">${inner.innerHTML}</span>${showHitIndex ? `<div class=\"${me.hitCellBadgeCls}\">${hitIndex}</div>` : ''}`;\n            }\n            // Replace every occurrence of the text in every descendant text node with a span\n            // encapsulating the matched string.\n            else {\n                treeWalker.currentNode = inner;\n                for (let textNode = treeWalker.nextNode(); textNode && inner.contains(textNode);) {\n                    const\n                        nodeToReplace = textNode,\n                        textContent   = textNode.nodeValue,\n                        newText       = ['<span>'];\n                    // Move onto next text node before we replace the node with a highlihght HTML sequence\n                    textNode = treeWalker.nextNode();\n                    let offset = findRe.lastIndex;\n                    // Convert textContent into an innerHTML string which htmlEncodes the text and embeds\n                    // a highlighting span which contains the target text.\n                    for (let match = findRe.exec(textContent); match; match = findRe.exec(textContent)) {\n                        const\n                            preamble    = textContent.substring(offset, match.index),\n                            spaceBefore = match[1] ? '\\xa0' : '',\n                            v           = match[2],\n                            spaceAfter  = match[3] ? '\\xa0' : '';\n                        newText.push(`${StringHelper.encodeHtml(preamble)}${spaceBefore}<span class=\"${hitTextCls}\">${StringHelper.encodeHtml(v)}</span>${spaceAfter}`);\n                        offset = findRe.lastIndex;\n                    }\n                    newText.push(StringHelper.encodeHtml(textContent.substring(offset)), '<span>');\n                    // Insert a fragment with each match wrapped with a span.\n                    nodeToReplace.parentNode.insertBefore(DomHelper.createElementFromTemplate(newText.join(''), {\n                        fragment : true\n                    }), nodeToReplace);\n                    nodeToReplace.remove();\n                }\n                if (showHitIndex) {\n                    DomHelper.createElement({\n                        parent    : cellElement,\n                        className : me.hitCellBadgeCls,\n                        text      : hitIndex\n                    });\n                }\n            }\n            me.hitEls.push(cellElement);\n        }\n    }\n    //endregion\n    //region Context menu\n    /**\n     * Add search menu item to cell context menu.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Core.data.Model} options.record Record for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateCellMenu({ column, record, items, cellElement }) {\n        const me = this;\n        if (column.searchable) {\n            items.search = {\n                text        : 'L{searchForValue}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-search',\n                cls         : 'b-separator',\n                weight      : 200,\n                disabled    : me.disabled,\n                onItem      : () => {\n                    let sel = globalThis.getSelection().toString();\n                    if (!sel) {\n                        sel = cellElement.innerText;\n                    }\n                    me.search(sel);\n                }\n            };\n        }\n    }\n    //endregion\n    //region Events\n    onStoreRefresh() {\n        this.search(this.text, false, true);\n    }\n    //endregion\n}\nSearch.featureClass = 'b-search';\nSearch._$name = 'Search'; GridFeatureManager.registerFeature(Search);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../feature/GridFeatureManager.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\n/**\n * @module Grid/feature/StickyCells\n */\n/**\n * A feature which pins configurable content from a grid row to the top of the grid\n * while the row scrolls off the top but is still visible.\n *\n * As soon as the row becomes too small to contain the content, it is unpinned, and\n * scrolls out naturally, and the following row's configured content becomes pinned.\n *\n * For example:\n *\n * ```javascript\n *     new Grid({\n *         features : {\n *             stickyCells : {\n *                 // Identifies elements to clone and pin to the grid top.\n *                 contentSelector : '.myClassName'\n *             }\n *         }\n *     });\n * ```\n *\n * This feature is **disabled** by default.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype stickyCells\n * @feature\n */\nexport default class StickyCells extends InstancePlugin {\n    //region Config\n    static get $name() {\n        return 'StickyCells';\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * A CSS selector which must identify the content within your grid row which you\n             * require to be pinned to the grid while the row if the topmost row, and remains visible.\n             * @config {String}\n             */\n            contentSelector : null,\n            currentTopRowCls : 'b-sticky-cells-current-top-row'\n        };\n    }\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            before : ['renderRows']\n        };\n    }\n    //endregion\n    //region Init\n    construct(grid, config) {\n        super.construct(grid, config);\n        // We cannot chain our client's onGridScroll because that is now a delayable injected method.\n        grid.ion({\n            scroll  : 'onGridScroll',\n            thisObj : this\n        });\n        Object.assign(this, DomHelper.createElement({\n            reference : 'element',\n            parent    : grid.element,\n            className : 'b-grid-sticky-row',\n            children  : [{\n                reference : 'contentElement',\n                className : 'b-grid-cell'\n            }]\n        }));\n        // Clean these classes from copied cell and row classLists\n        this.removeClasses = {\n            'b-focused'             : false,\n            'b-hover'               : false,\n            'b-selected'            : false,\n            [this.currentTopRowCls] : false\n        };\n    }\n    renderRows() {\n        // Do not leave stranded sticky row visible on data change\n        this.element.classList.add('b-hide-visibility');\n    }\n    onGridScroll() {\n        const\n            me = this,\n            {\n                client : grid,\n                element,\n                contentElement\n            } = me,\n            gridViewport  = Rectangle.client(grid.bodyContainer).roundPx(),\n            currentTopRow = grid.rowManager.getRowAt(gridViewport.y),\n            topRowChanged = currentTopRow !== me.currentTopRow;\n        if (currentTopRow) {\n            if (topRowChanged) {\n                if (me.currentTopRow) {\n                    me.currentTopRow.removeCls(me.currentTopRowCls);\n                    me.currentTopRow.removeCls('b-not-enough-height');\n                }\n                me.currentTopRow = currentTopRow;\n                currentTopRow.addCls(me.currentTopRowCls);\n                contentElement.innerHTML = '';\n                contentElement.appendChild(me.updateStickyContent());\n            }\n            // If the outgoing row is not too tall, and doesn't *need* the content\n            // pinning to the top, hide the sticky row, and make the source sticky\n            // elements pin themselves to the bottom of the cell using the b-not-enough-height\n            // class to switch them to align-self: flex-end\n            const notEnoughHeight = me.currentTopRow.bottom - me.client.scrollable.y <= me.stickyContentHeight;\n            me.element.classList[notEnoughHeight ? 'add' : 'remove']('b-hide-visibility');\n            me.currentTopRow[notEnoughHeight ? 'addCls' : 'removeCls']('b-not-enough-height');\n            // Keep sticky row aligned while constrained to the viewport.\n            // This keeps it pinned to the top.\n            gridViewport.y += me.stickyContentTop;\n            DomHelper.alignTo(element, me.stickyEls[0], { align : 't0-t0', constrainTo : gridViewport }, true);\n        }\n        me.lastProcessedTopRow = currentTopRow;\n    }\n    updateStickyContent() {\n        const\n            me            = this,\n            {\n                currentTopRow,\n                removeClasses\n            }             = me,\n            rowClasses   = {\n                'b-grid-sticky-row' : 1\n            },\n            cellClasses  = {},\n            stickyContent = me.stickyContent || (me.stickyContent = document.createDocumentFragment()),\n            stickyEls     = me.stickyEls || (me.stickyEls = []);\n        // Release the sticky state on the previous row's sticky elements\n        stickyEls.forEach(e => {\n            e.classList.remove('b-sticky-content-el');\n        });\n        // Collect the elements we need to clone from the current top row\n        stickyEls.length = 0;\n        currentTopRow.eachElement(rowEl => {\n            stickyEls.push(...rowEl.querySelectorAll(me.contentSelector));\n        });\n        // Clear the documentFragment which we use to hold our clones\n        while (stickyContent.firstChild) {\n            stickyContent.remove(stickyContent.firstChild);\n        }\n        me.stickyContentHeight = 0;\n        me.stickyContentTop = 0;\n        // Clone the selected elements and measure them for alignment.\n        stickyEls.map(e => {\n            // Collect the app classes that may be necessary on the cell and row elements.\n            e.closest('.b-grid-cell').classList.forEach(cls => cellClasses[cls] = 1);\n            e.closest('.b-grid-row').classList.forEach(cls => rowClasses[cls] = 1);\n            // Clean out grid's classes from the class sets.\n            Object.assign(cellClasses, removeClasses);\n            Object.assign(rowClasses,  removeClasses);\n            const eTop = e.offsetTop;\n            me.stickyContentTop = Math.max(me.stickyContentTop, eTop);\n            // We need to know how tall the sticky content is\n            e.style.alignSelf = 'flex-end';\n            me.stickyContentHeight = Math.max(me.stickyContentHeight, me.currentTopRow.height - e.offsetTop + eTop);\n            e.style.alignSelf = '';\n            const result = e.cloneNode(true);\n            // Tag the content al *after* cloning it.\n            e.classList.add('b-sticky-content-el');\n            stickyContent.appendChild(result);\n            return result;\n        });\n        cellClasses['b-focused'] = false;\n        DomHelper.syncClassList(me.contentElement, cellClasses);\n        DomHelper.syncClassList(me.element, rowClasses);\n        return stickyContent;\n    }\n}\nStickyCells._$name = 'StickyCells'; GridFeatureManager.registerFeature(StickyCells, false);\n", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../GridFeatureManager.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\n/**\n * @module Grid/feature/experimental/FileDrop\n */\n/**\n * An experimental feature that lets users drop files on a Widget. The widget fires an event when a file is dropped onto it.\n * In the event, you get access to the raw files as strings, that were parsed by calling `readAsBinaryString`.\n *\n * This feature is **disabled** by default.\n * For info on enabling it, see {@link Grid/view/mixin/GridFeatures}.\n *\n * NOTE: Currently only supports dropping one file at a time.\n *\n * @experimental\n * @extends Core/mixin/InstancePlugin\n * @classtype fileDrop\n * @feature\n */\nexport default class FileDrop extends InstancePlugin {\n    static $name = 'FileDrop';\n    construct(client, config) {\n        const me = this;\n        super.construct(client, config);\n        // Setup event listeners for dragging files onto the grid element\n        EventHelper.on({\n            element   : client.element,\n            thisObj   : me,\n            drop      : me.onFileDrop,\n            dragover  : me.onFileDragOver,\n            dragenter : me.onFileDragEnter,\n            dragleave : me.onFileDragLeave\n        });\n    }\n    onFileLoad(domEvent) {\n        this.client.trigger('fileDrop', {\n            file : this.file, domEvent\n        });\n    }\n    onFileDragEnter() {\n        // Mouse over styling while dragging a file\n        this.client.element.classList.add('b-dragging-file');\n    }\n    onFileDragOver(event) {\n        event.preventDefault();\n    }\n    onFileDragLeave(event) {\n        const { element } = this.client;\n        if (event.relatedTarget && !element.contains(event.relatedTarget)) {\n            this.client.element.classList.remove('b-dragging-file');\n        }\n    }\n    onFileDrop(domEvent) {\n        // Prevent default behavior (prevents the file from being opened)\n        domEvent.preventDefault();\n        const file = domEvent.dataTransfer.items[0].getAsFile();\n        /**\n         * Fired when a file is dropped on the widget element\n         * @event fileDrop\n         * @param {Grid.view.Grid} source The owning Grid instance\n         * @param {DataTransferItem} file The dropped file descriptor\n         * @param {DragEvent} domEvent The native DragEvent\n         * @on-owner\n         */\n        this.client.trigger('fileDrop', { file, domEvent });\n        this.onFileDragLeave(domEvent);\n    }\n}\nFileDrop._$name = 'FileDrop'; GridFeatureManager.registerFeature(FileDrop, false, 'Grid');\n", "import ChipView from '../../Core/widget/ChipView.js';\nimport Store from '../../Core/data/Store.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\n/**\n * @module Grid/widget/GroupBar\n */\n/**\n * A widget used to manage grouping of a tree with the {@link Grid.feature.TreeGroup} feature. Column headers can be\n * drag-dropped on this widget to regroup the data in the tree store. This widget only handles column-based grouping,\n * and doesn't handle custom group functions.\n *\n * ```javascript\n * const tree = new TreeGrid({\n *     appendTo : 'container',\n *     features : {\n *         treeGroup : {\n *             hideGroupedColumns : true,\n *             levels             : [\n *                 'manager',\n *                 'airline'\n *             ],\n *             parentRenderer : (field, data) => `${StringHelper.capitalize(field)}: ${data.name}`\n *         }\n *     },\n *\n *     columns : [\n *         {\n *             text  : 'Name',\n *             field : 'name',\n *             flex  : 3,\n *             type  : 'tree'\n *         },\n *         {\n *             text   : 'Airline',\n *             field  : 'airline',\n *             align  : 'center',\n *             flex   : 2,\n *         },\n *         {\n *             type  : 'check',\n *             text  : 'Domestic',\n *             field : 'domestic',\n *             align : 'left',\n *             flex  : 1\n *         },\n *         {\n *             type  : 'number',\n *             text  : 'Capacity',\n *             field : 'capacity',\n *             flex  : 1\n *         },\n *         {\n *             type  : 'number',\n *             text  : 'Crew',\n *             field : 'crew',\n *             flex  : 1\n *         }\n *     ],\n *\n *     tbar : [\n *         'Group by',\n *         {\n *             type : 'groupbar'\n *         }\n *     ]\n * ```\n * @classtype groupbar\n * @extends Core/widget/ChipView\n * @demo Grid/tree-grouping\n * @widget\n */\nexport default class GroupBar extends ChipView {\n    static type  = 'groupbar';\n    static $name = 'GroupBar';\n    static configurable = {\n        selectedCls : 'not-used',\n        itemTpl(record) {\n            return StringHelper.encodeHtml(StringHelper.capitalize(record.getValue(this.displayField)));\n        }\n    };\n    construct() {\n        super.construct(...arguments);\n        const treeGrid = this.treeGrid = this.up('gridbase', true);\n        if (!treeGrid) {\n            throw new Error('GroupBar must be used inside a Grid component');\n        }\n        treeGrid.ion({\n            paint   : this.onTreePaint,\n            once    : true,\n            thisObj : this\n        });\n    }\n    onTreePaint() {\n        const\n            me           = this,\n            { treeGrid } = me,\n            { treeGroup, columnReorder } = treeGrid.features;\n        if (!treeGroup) {\n            throw new Error('GroupBar widget requires the TreeGroup feature to be present');\n        }\n        columnReorder.usingGroupBarWidget = true;\n        me.store = new Store({\n            fields            : ['cls', 'ascending'],\n            internalListeners : {\n                add     : me.onStoreChanged,\n                remove  : me.onStoreChanged,\n                thisObj : me\n            }\n        });\n        treeGrid.ion({\n            treeGroupChange          : me.onTreeGroupChanged,\n            beforeColumnDropFinalize : me.onBeforeColumnDropFinalize,\n            columnDrag               : me.onColumnDrag,\n            columnDragStart          : me.onColumnDragStart,\n            columnDrop               : me.onColumnDrop,\n            thisObj                  : me\n        });\n        me.onTreeGroupChanged({ levels : treeGroup.levels });\n    }\n    onStoreChanged({ records }) {\n        const\n            me           = this,\n            { treeGrid } = me;\n        if (!me.treeGrid.isConstructing && records?.[0]?.cls !== 'b-drop-target') {\n            me.ignoreGroupChange               = true;\n            treeGrid.features.treeGroup.levels = me.store.map(({ field }) => field);\n            me.ignoreGroupChange               = false;\n        }\n    }\n    onTreeGroupChanged({ levels }) {\n        if (!this.ignoreGroupChange) {\n            if (levels.some(level => level instanceof Function && !level.fieldName)) {\n                throw new Error('GroupBar only supports column grouping');\n            }\n            this.store.data = (levels || []).map(level => {\n                level = level.fieldName || level;\n                return this.treeGrid.columns.get(level);\n            });\n        }\n    }\n    onColumnDragStart() {\n        this.store.add({ id : 'placeholder', cls : 'b-drop-target' }); \n    }\n    onColumnDrag({ context, column, event }) {\n        const overGroupBar = event.target.closest('.b-groupbar');\n        if (overGroupBar) {\n            context.valid = true;\n        }\n    }\n    onBeforeColumnDropFinalize({ column, event }) {\n        const droppedOnGroupBar = event.target.closest('.b-groupbar');\n        if (droppedOnGroupBar) {\n            if (!column.isTreeColumn) {\n                this.store.getById('placeholder').remove();\n                this.store.add(column);\n            }\n        }\n    }\n    onColumnDrop() {\n        this.store.getById('placeholder')?.remove();\n    }\n}\nGroupBar.initClass();\nGroupBar._$name = 'GroupBar';", "import Combo from '../../Core/widget/Combo.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport '../../Grid/view/TreeGrid.js';\n/**\n * @module Grid/widget/TreeCombo\n */\n/**\n * A powerful {@link Core/widget/Combo} box using a {@link Grid/view/TreeGrid} as its drop down widget. You can define\n * your own set of columns to display and use all the regular features of the Grid.\n *\n * {@inlineexample Grid/widget/TreeCombo.js}\n *\n * ```javascript\n * new TreeCombo({\n *     label    : 'Pick task(s)',\n *     width    : '30em',\n *     appendTo : document.body,\n *     picker   : {\n *         // Define the columns to show in the grid\n *         columns : [\n *             { type : 'tree', text : 'Tasks', field : 'name', flex : 1 },\n *             { text : 'Priority', field : 'prio' }\n *         ]\n *     },\n *     chipView : {\n *         // Render the chips in the combo field\n *         itemTpl(record) {\n *             return StringHelper.xss`${record.name}`;\n *         }\n *     },\n *     store : {\n *         fields     : [\n *             'prio'\n *         ],\n *         data : [\n *             {\n *                 name     : 'Development Tasks',\n *                 expanded : true,\n *                 children : [\n *                     { id : 1, name : 'Improve React docs', prio : 'High' },\n *                     { id : 2, name : 'Build Angular module', prio : 'Low' },\n *                     { id : 3, name : 'Creat Vue project', prio : 'Low' }\n *                 ]\n *             },\n *             { name : 'Customer meeting', prio : 'Normal' },\n *             {\n *                 name     : 'Customer Tasks',\n *                 expanded : true,\n *                 children : [\n *                     { id : 4, name : 'Intro meeting', prio : 'Normal' },\n *                     { id : 5, name : 'Build POC', prio : 'High' },\n *                     { id : 6, name : 'Documentation', prio : 'Low' }\n *                 ]\n *             }\n *         ]\n *     }\n * });\n * ```\n *\n * @extends Core/widget/Combo\n * @classtype treecombo\n * @inputfield\n */\nexport default class TreeCombo extends Combo {\n    static $name = 'TreeCombo';\n    static type = 'treecombo';\n    static configurable = {\n        multiSelect : true,\n        picker      : {\n            type                       : 'treegrid',\n            minWidth                   : '35em',\n            disableGridRowModelWarning : true,\n            selectionMode              : {\n                row                  : true,\n                rowCheckboxSelection : true\n            }\n        },\n        chipView : {\n            itemTpl(record) {\n                return StringHelper.xss`${record.name}`;\n            },\n            scrollable : {\n                overflowX : 'hidden-scroll'\n            }\n        }\n    };\n    changePicker(picker, oldPicker) {\n        picker = super.changePicker(picker, oldPicker);\n        picker?.ion({\n            selectionChange : 'onPickerSelectionChange',\n            thisObj         : this\n        });\n        return picker;\n    }\n    updateMultiSelect(multiSelect) {\n        super.updateMultiSelect(...arguments);\n        this.picker.selectionMode.multiSelect = multiSelect;\n    }\n    updateReadOnly(readOnly) {\n        super.updateReadOnly(...arguments);\n        this.picker.readOnly = readOnly;\n    }\n    get value() {\n        return super.value;\n    }\n    set value(value) {\n        // indicate we are setting the field value\n        this._settingValue = true;\n        super.value = value;\n        // select provided value enitres in the picker\n        this.picker.selectedRecords = value.map?.(val => this.store.getById(val)) || [];\n        this._settingValue = false;\n    }\n    onPickerSelectionChange({ selection }) {\n        // apply selection to value (if we aren't in the middle of value setting)\n        if (!this._settingValue) {\n            this.value = selection;\n        }\n    }\n}\nTreeCombo.initClass();\nTreeCombo._$name = 'TreeCombo';", "// column\nexport { default as ActionColumn } from '../lib/Grid/column/ActionColumn.js';\nexport { default as AggregateColumn } from '../lib/Grid/column/AggregateColumn.js';\nexport { default as CheckColumn } from '../lib/Grid/column/CheckColumn.js';\nexport { default as ColorColumn } from '../lib/Grid/column/ColorColumn.js';\nexport { default as Column } from '../lib/Grid/column/Column.js';\nexport { default as DateColumn } from '../lib/Grid/column/DateColumn.js';\nexport { default as NumberColumn } from '../lib/Grid/column/NumberColumn.js';\nexport { default as PercentColumn } from '../lib/Grid/column/PercentColumn.js';\nexport { default as RatingColumn } from '../lib/Grid/column/RatingColumn.js';\nexport { default as RowNumberColumn } from '../lib/Grid/column/RowNumberColumn.js';\nexport { default as TemplateColumn } from '../lib/Grid/column/TemplateColumn.js';\nexport { default as TimeColumn } from '../lib/Grid/column/TimeColumn.js';\nexport { default as TreeColumn } from '../lib/Grid/column/TreeColumn.js';\nexport { default as WidgetColumn } from '../lib/Grid/column/WidgetColumn.js';\n// data\nexport { default as ColumnStore } from '../lib/Grid/data/ColumnStore.js';\nexport { default as GridRowModel } from '../lib/Grid/data/GridRowModel.js';\n// feature\nexport { default as CellCopyPaste } from '../lib/Grid/feature/CellCopyPaste.js';\nexport { default as CellEdit } from '../lib/Grid/feature/CellEdit.js';\nexport { default as CellMenu } from '../lib/Grid/feature/CellMenu.js';\nexport { default as CellTooltip } from '../lib/Grid/feature/CellTooltip.js';\nexport { default as ColumnAutoWidth } from '../lib/Grid/feature/ColumnAutoWidth.js';\nexport { default as ColumnDragToolbar } from '../lib/Grid/feature/ColumnDragToolbar.js';\nexport { default as ColumnPicker } from '../lib/Grid/feature/ColumnPicker.js';\nexport { default as ColumnRename } from '../lib/Grid/feature/ColumnRename.js';\nexport { default as ColumnReorder } from '../lib/Grid/feature/ColumnReorder.js';\nexport { default as ColumnResize } from '../lib/Grid/feature/ColumnResize.js';\nexport { default as FillHandle } from '../lib/Grid/feature/FillHandle.js';\nexport { default as Filter } from '../lib/Grid/feature/Filter.js';\nexport { default as FilterBar } from '../lib/Grid/feature/FilterBar.js';\nexport { default as GridFeatureManager } from '../lib/Grid/feature/GridFeatureManager.js';\nexport { default as Group } from '../lib/Grid/feature/Group.js';\nexport { default as GroupSummary } from '../lib/Grid/feature/GroupSummary.js';\nexport { default as HeaderMenu } from '../lib/Grid/feature/HeaderMenu.js';\nexport { default as MergeCells } from '../lib/Grid/feature/MergeCells.js';\nexport { default as QuickFind } from '../lib/Grid/feature/QuickFind.js';\nexport { default as RegionResize } from '../lib/Grid/feature/RegionResize.js';\nexport { default as RowCopyPaste } from '../lib/Grid/feature/RowCopyPaste.js';\nexport { default as RowExpander } from '../lib/Grid/feature/RowExpander.js';\nexport { default as RowReorder } from '../lib/Grid/feature/RowReorder.js';\nexport { default as RowResize } from '../lib/Grid/feature/RowResize.js';\nexport { default as Search } from '../lib/Grid/feature/Search.js';\nexport { default as Sort } from '../lib/Grid/feature/Sort.js';\nexport { default as StickyCells } from '../lib/Grid/feature/StickyCells.js';\nexport { default as Stripe } from '../lib/Grid/feature/Stripe.js';\nexport { default as Split } from '../lib/Grid/feature/Split.js';\nexport { default as Summary } from '../lib/Grid/feature/Summary.js';\nexport { default as Tree } from '../lib/Grid/feature/Tree.js';\nexport { default as TreeGroup } from '../lib/Grid/feature/TreeGroup.js';\n// feature base\nexport { default as CopyPasteBase } from '../lib/Grid/feature/base/CopyPasteBase.js';\n// export feature\nexport { default as ExportDialog } from '../lib/Grid/view/export/ExportDialog.js';\nexport { default as Exporter } from '../lib/Grid/feature/export/exporter/Exporter.js';\nexport { default as ExportOrientationCombo } from '../lib/Grid/view/export/field/ExportOrientationCombo.js';\nexport { default as ExportRowsCombo } from '../lib/Grid/view/export/field/ExportRowsCombo.js';\nexport { default as MultiPageExporter } from '../lib/Grid/feature/export/exporter/MultiPageExporter.js';\nexport { default as MultiPageVerticalExporter } from '../lib/Grid/feature/export/exporter/MultiPageVerticalExporter.js';\nexport { default as PdfExport } from '../lib/Grid/feature/export/PdfExport.js';\nexport { default as Print } from '../lib/Grid/feature/export/Print.js';\nexport { default as PrintMixin } from '../lib/Grid/feature/export/mixin/PrintMixin.js';\nexport { default as SinglePageExporter } from '../lib/Grid/feature/export/exporter/SinglePageExporter.js';\nexport { FileFormat, Orientation, PaperFormat, RowsRange } from '../lib/Grid/feature/export/Utils.js';\n// feature experimental\nexport { default as ExcelExporter } from '../lib/Grid/feature/experimental/ExcelExporter.js';\nexport { default as FileDrop } from '../lib/Grid/feature/experimental/FileDrop.js';\n// row\nexport { default as Row } from '../lib/Grid/row/Row.js';\n// util\nexport { default as Location } from '../lib/Grid/util/Location.js';\nexport { default as TableExporter } from '../lib/Grid/util/TableExporter.js';\n// view\nexport { default as Bar } from '../lib/Grid/view/Bar.js';\nexport { default as Footer } from '../lib/Grid/view/Footer.js';\nexport { default as Grid } from '../lib/Grid/view/Grid.js';\nexport { default as GridBase } from '../lib/Grid/view/GridBase.js';\nexport { default as Header } from '../lib/Grid/view/Header.js';\nexport { default as RowManager } from '../lib/Grid/row/RowManager.js';\nexport { default as SubGrid } from '../lib/Grid/view/SubGrid.js';\nexport { default as TreeGrid } from '../lib/Grid/view/TreeGrid.js';\n// view mixin\nexport { default as GridElementEvents } from '../lib/Grid/view/mixin/GridElementEvents.js';\nexport { default as GridFeatures } from '../lib/Grid/view/mixin/GridFeatures.js';\nexport { default as GridResponsive } from '../lib/Grid/view/mixin/GridResponsive.js';\nexport { default as GridSelection } from '../lib/Grid/view/mixin/GridSelection.js';\nexport { default as GridState } from '../lib/Grid/view/mixin/GridState.js';\nexport { default as GridSubGrids } from '../lib/Grid/view/mixin/GridSubGrids.js';\n// widget\nexport { default as GridFieldFilterPicker } from '../lib/Grid/widget/GridFieldFilterPicker.js';\nexport { default as GridFieldFilterPickerGroup } from '../lib/Grid/widget/GridFieldFilterPickerGroup.js';\nexport { default as GroupBar } from '../lib/Grid/widget/GroupBar.js';\nexport { default as TreeCombo } from '../lib/Grid/widget/TreeCombo.js';\n\n\nimport GlobalEvents from '../lib/Core/GlobalEvents.js';\nimport BrowserHelper from '../lib/Core/helper/BrowserHelper.js';\nimport VersionHelper from '../lib/Core/helper/VersionHelper.js';\nimport Widget from '../lib/Core/widget/Widget.js';\nimport Toast from '../lib/Core/widget/Toast.js';\nimport Override from '../lib/Core/mixin/Override.js';\nimport DomHelper from '../lib/Core/helper/DomHelper.js';\nimport GridBase from '../lib/Grid/view/GridBase.js';\nimport RowManager from '../lib/Grid/row/RowManager.js';\n(() => {\n    //region Common\n    const\n        HOSTS            = [\n            'bryntum.com',\n            'cdpn.io',\n            'react-gantt.com',\n            'vue-gantt.com',\n            'vue-scheduler.com',\n            'react-scheduler.com',\n            'angular-scheduler.com',\n            'angular-calendar.com',\n            'vue-calendar.com',\n            'react-calendar.com',\n            'lmctfy.net',\n            'bryntum-dev-ed.develop.lightning.force.com'\n        ],\n        ONE_DAY          = 1000 * 60 * 60 * 24,\n        EXPIRING_CLASSES = [],\n        location = (globalThis || self).location;\n    if (!VersionHelper.isTestEnv && (HOSTS.some(host => location.host.includes(host)) || /\\/docs/.test(location.href))) {\n        return;\n    }\n    let initialized;\n    function initExpiryHelper(owner, baseClass) {\n        if (!initialized) {\n            initialized = true;\n            ExpiryHelper.construct({\n                widget : owner\n            });\n        }\n        // do not remove this line (used to distinguish trial bundles by regexp)\n        owner.__foo = 'THISISTRIAL';\n    }\n    //endregion\n    //region ExpiryHelper\n    class ExpiryHelper {\n        static construct(config) {\n            const\n                me            = this,\n                product       = 'taskboard',\n                productName   = 'TaskBoard',\n                version       = VersionHelper.getVersion(product),\n                callHomeDelay = VersionHelper.isTestEnv ? 3000 : 1000 * 60,\n                blockUrl      = BrowserHelper.queryString.blockUrl;\n            Object.assign(me, {\n                version,\n                product,\n                Product          : productName,\n                verifyUrl        : VersionHelper.isTestEnv ? blockUrl : 'https://bryntum.com/verify/',\n                blocked          : false,\n                lastVersionCheck : 0,\n                trialKey         : `b-${product}-trial-start`,\n                versionCheckKey  : `b-${product}-verify-date`\n            }, config);\n            if (!VersionHelper.isTestEnv) {\n                console.log(`Bryntum ${productName} Trial Version`);\n            }\n            me.cacheTrialStartTime();\n            if (me.isExpired) {\n                if (document.readyState === 'complete') {\n                    me.onTrialExpired();\n                }\n                else {\n                    document.addEventListener('readystatechange', () => {\n                        if (document.readyState === 'complete') {\n                            me.onTrialExpired();\n                        }\n                    });\n                }\n            }\n            // Call home to log trial usage, assuming localStorage access works reliably\n            // 1 min delay to be less easily detected\n            setTimeout(() => {\n                me.updateBlockedStatus();\n            }, callHomeDelay);\n        }\n        static cacheTrialStartTime() {\n            const\n                me         = this,\n                timeString = BrowserHelper.getLocalStorageItem(me.trialKey),\n                time       = Number(timeString);\n            if (time && !isNaN(time)) {\n                me.trialStartTime = time;\n            }\n            me.trialStartTime = me.trialStartTime || Date.now();\n            // First trial access, or no localstorage (no local storage meaning our expiration mechanism won't work. Only remote blocking will end the trial)\n            BrowserHelper.setLocalStorageItem(me.trialKey, me.trialStartTime);\n        }\n        static get isExpired() {\n            return this.blocked || (Date.now() - this.trialStartTime > ONE_DAY * 45) || window.bryntum?.[this.product]?.expired;\n        }\n        static updateBlockedStatus() {\n            const\n                me                  = this,\n                saveVersionCheckKey = () => BrowserHelper.setLocalStorageItem(me.versionCheckKey, Date.now());\n            me.lastVersionCheck = me.lastVersionCheck || BrowserHelper.getLocalStorageItem(me.versionCheckKey) || 0;\n            // Max 1 version check per session / day\n            if (me.lastVersionCheck && Date.now() - me.lastVersionCheck < ONE_DAY) {\n                return;\n            }\n            if (me.verifyUrl) {\n                const\n                    url    = encodeURIComponent(location.href),\n                    logUrl = `${me.verifyUrl}?id=${window.bryntum.license}&url=${url}`,\n                    img    = new Image();\n                img.onload = () => {\n                    // 2x2 image means trial is blocked due to violation\n                    if (img.naturalWidth === 2) {\n                        me.blockTrial();\n                    }\n                    else {\n                        // Just in case\n                        saveVersionCheckKey();\n                    }\n                };\n                img.onerror = () => {\n                    saveVersionCheckKey();\n                };\n                img.src = logUrl;\n            }\n            else {\n                saveVersionCheckKey();\n            }\n        }\n        static onTrialExpired() {\n            const rootEl = this.widget.rootElement;\n            if (!this.expirationShown) {\n                this.expirationShown = true;\n                if (!VersionHelper.isTestEnv) {\n                    console.warn(`Bryntum ${this.Product} trial version expired. Purchase a license at https://bryntum.com/store or contact us at https://bryntum.com/contact/ for licensing options.`);\n                }\n                rootEl.floatRoot && Toast.show({\n                    html        : `Psst! Your Bryntum ${this.Product} trial has expired. Please see <a href=\"https://bryntum.com/store\">our store</a> for licensing options`,\n                    timeout     : 20000,\n                    rootElement : rootEl\n                });\n            }\n            DomHelper.removeEachSelector(rootEl, '.b-sch-dependency');\n            DomHelper.forEachSelector(rootEl, '.b-container', element => {\n                const widget = Widget.fromElement(element, 'widget');\n                if (EXPIRING_CLASSES.some(cls => widget instanceof cls)) {\n                    this.maskExpiredWidget(widget);\n                }\n            });\n        }\n        static blockTrial() {\n            this.blocked = true;\n            // Get rid of version check timestamp\n            BrowserHelper.removeLocalStorageItem(this.versionCheckKey);\n            // To force expired state: Set a fake early trial timestamp\n            BrowserHelper.setLocalStorageItem(this.trialKey, 1);\n            this.onTrialExpired();\n        }\n        static maskExpiredWidget(widget) {\n            widget.mask({\n                text  : '<h3 style=\"margin:0\">Trial expired, <a href=\"https://bryntum.com/store\" style=\"margin:0 3px; color:inherit\">click here</a> to buy a license.</h3>',\n                icon  : 'b-fa b-fa-frown',\n                type  : 'trial',\n                cover : 'target'\n            });\n        }\n        static setWaterMark(element, {\n            darkColor = 'rgba(255, 255, 255, 0.03)',\n            lightColor = 'rgba(240, 240, 240, 0.54)'\n        } = {}) {\n            // Used for thumbnails\n            if (BrowserHelper.queryString.thumb != null) {\n                return;\n            }\n            const\n                color     = DomHelper.themeInfo?.name?.toLowerCase().endsWith('-dark') ? darkColor : lightColor,\n                svgString = `\n                   <svg xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" width=\"100%\" height=\"100%\" style=\"font-family:sans-serif;font-weight:900;fill:${color}\">\n                    <defs>\n                        <pattern id=\"company\" patternUnits=\"userSpaceOnUse\" width=\"400\" height=\"200\">\n                            <text y=\"30\" font-size=\"40\" id=\"name\">Bryntum</text>\n                            <text y=\"120\" x=\"200\" font-size=\"24\" id=\"trial\">Trial Version</text>\n                        </pattern>\n                        <pattern id=\"pattern\" xlink:href=\"#company\" patternTransform=\"rotate(-45)\">\n                            <use xlink:href=\"#name\" /><use xlink:href=\"#trial\" />\n                        </pattern>\n                    </defs>\n                    <rect width=\"100%\" height=\"100%\" fill=\"url(#pattern)\" />\n                </svg>`;\n            element.style.backgroundImage = `url('data:image/svg+xml;base64,${window.btoa(svgString)}')`;\n        };\n    }\n    //endregion\n    //region Common override\n    const applyBaseOverride = baseClass => {\n        EXPIRING_CLASSES.push(baseClass);\n        Override.apply(class {\n            static get target() {\n                return {\n                    class : baseClass\n                };\n            }\n            onPaintOverride() {\n                const\n                    me            = this,\n                    setWatermarks = () => {\n                        const targets = me.subGrids ? Object.values(me.subGrids) : [me];\n                        for (const target of targets) {\n                            if (target.element) {\n                                ExpiryHelper.setWaterMark(target.element);\n                            }\n                        }\n                    };\n                initExpiryHelper(me, baseClass);\n                setWatermarks();\n                // React to theme changes\n                GlobalEvents.on('theme', () => {\n                    setWatermarks();\n                });\n                if (ExpiryHelper.isExpired) {\n                    ExpiryHelper.maskExpiredWidget(me);\n                }\n            }\n        });\n    };\n    //endregion\n    if (typeof GridBase !== 'undefined') {\n        applyBaseOverride(GridBase);\n        Override.apply(class {\n            static get target() {\n                return {\n                    class : RowManager\n                };\n            }\n            matchRowCount() {\n                if (!ExpiryHelper.isExpired || this.grid?.isScheduler) {\n                    this._overridden.matchRowCount.apply(this, arguments);\n                }\n            }\n            renderRows() {\n                if (!ExpiryHelper.isExpired || this.grid?.isScheduler) {\n                    this._overridden.renderRows.apply(this, arguments);\n                }\n            }\n            renderFromRow() {\n                if (!ExpiryHelper.isExpired || this.grid?.isScheduler) {\n                    this._overridden.renderFromRow.apply(this, arguments);\n                }\n            }\n        });\n    }\n})();\n(() => {\n    // do not load analytics code for specific domains\n    const ignoreDomainRe = /(.force.com|.lightning.com|.salesforce.com|lmctfy.net|qa.bryntum.com|qa2.bryntum.com)/;\n    // document location might be null in firefox in salesforce\n    if (!document.location || ignoreDomainRe.test(document.location.href) || window.top !== window) {\n        return;\n    }\n    let id;\n    const websiteUrls = [\n        'bryntum.com',\n        'cdpn.io'\n    ];\n    const\n        products   = ['calendar', 'grid', 'gantt', 'scheduler', 'schedulerpro', 'taskboard'],\n        frameworks = ['angular', 'react', 'vue', 'ionic'];\n    websiteUrls.splice(0, 0, ...products.map(prod => frameworks.map(framework => `${framework}-${prod}`)).concat('bryntum.com').flat());\n    if (document.location.host.match(websiteUrls.join('|'))) {\n        id = 'G-1VY6776VJP';\n    }\n    else {\n        id = 'G-H465KZDH8S';\n    }\n    const newScript = document.createElement('script');\n    newScript.onload = function() {\n        window.dataLayer = window.dataLayer || [];\n        function gtag() {\n            window.dataLayer.push(arguments);\n        }\n        gtag('js', new Date());\n        gtag('config', id);\n    };\n    document.head.appendChild(newScript);\n    newScript.src = 'https://www.googletagmanager.com/gtag/js?id=' + id;\n})();\n"],
  "mappings": "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",
  "names": ["ActionColumn", "Column", "config", "store", "me", "grid", "column", "record", "callExternalRenderer", "_a", "_b", "inGroupTitle", "subGrid", "actionConfig", "index", "tooltip", "renderer", "btip", "customRendererData", "Tooltip", "target", "actionIndex", "action", "actionHandler", "groupActions", "oldActions", "actions", "actionOriginal", "actionsHtml", "DomHelper", "__publicField", "ColumnStore", "AggregateColumn", "NumberColumn", "data", "columnStore", "storeListeners", "oldStore", "modelClass", "field", "args", "result", "i", "length", "changes", "rowManager", "rec", "row", "cellElement", "value", "fn", "isMathFn", "handler", "thisObj", "r", "PercentColumn", "sum", "RatingColumn", "ArrayHelper", "filled", "event", "starIndex", "TemplateColumn", "renderData", "TimeColumn", "groupRowFor", "DateHelper", "editor", "CellCopyPaste", "CopyPasteBase", "client", "actionName", "isCut", "selectedCells", "cells", "copiedDataString", "cell", "entityName", "targetCell", "clipboardData", "modifiedRecords", "targetCells", "items", "VersionHelper", "GridFeatureManager", "CellTooltip", "InstancePlugin", "disable", "tip", "arg", "Objects", "ColumnRename", "textWrapper", "Editor", "FillHandle", "Delayable_default", "includeSingleAxisMatch", "range", "horizontal", "negative", "values", "id", "rowOrCol", "lastValue", "pattern", "val", "diffs", "ix", "GlobalEvents_default", "EventHelper", "currentRange", "_isCropping", "selectionChange", "extensionCells", "sel", "firstCell", "patterns", "changeMap", "changed", "rangeSelection", "first", "last", "cellData", "cellSelector", "equalOrSmaller", "cs", "Location", "from", "to", "keepListeners", "_fillListeners", "regionEl", "x", "Rectangle", "right", "y", "bottom", "borderElement", "handleElement", "newCells", "add", "listener", "c1", "c2", "camelCase", "MergeCells", "use", "sortedOnly", "mergedRange", "oldId", "oldHeight", "indices", "allSelected", "element", "mergedCellsElement", "cellEdit", "type", "StringHelper", "eventData", "records", "_c", "parent", "syncId", "DomSync", "fromIndex", "toIndex", "top", "left", "width", "height", "domConfig", "DomClassList", "rows", "domConfigMap", "map", "region", "force", "redraw", "columns", "c", "hadRanges", "mergedRanges", "boundsMap", "isRtl", "rowWidth", "bounds", "topRendered", "bottomRendered", "rowOffsetHeight", "topRow", "bottomRow", "rowsAbove", "rowsBelow", "mergedMap", "columnId", "key", "earlierRecord", "earlierValue", "earlierIndex", "laterRecord", "laterValue", "laterIndex", "cellBounds", "QuickFind", "focusedCell", "header", "badge", "headerField", "hit", "find", "columnFieldOrId", "fromSplit", "found", "other", "nextHit", "focusedIndex", "foundSorted", "a", "b", "currentId", "currentIndex", "prevHit", "classList", "treeWalker", "findRe", "hitTextCls", "hitIndex", "inner", "textNode", "nodeToReplace", "textContent", "newText", "offset", "match", "preamble", "spaceBefore", "v", "spaceAfter", "filter", "fromCellSelector", "toCellSelector", "storeRemoveActions", "RowExpander", "text", "wasAnimating", "widget", "entries", "entry", "recordState", "source", "recordStateMap", "collapsingStateMap", "changedKeys", "state", "topRecordIndex", "topRecord", "shouldSpanRegions", "heightChanged", "bodyElement", "rowElement", "regions", "expandedRowClass", "collapsingState", "clearCollapse", "child", "content", "cellHeight", "expandedBodyElements", "renderPromises", "continueRendering", "expanderElement", "currentChildren", "n", "createWidget", "widgetConfig", "themeName", "shadowRootContainer", "shadowRoot", "widgetDataField", "fieldData", "relatedStore", "cls", "themeCls", "Widget", "ObjectHelper", "href", "expanderBodyElement", "renderResponse", "li", "resolve", "resolvePromise", "_bufferedRecords", "unlock", "navigationDirection", "editing", "nextRegion", "cellContext", "up", "editable", "reverse", "previous", "activeRecord", "next", "nextCell", "expandedRecord", "widgets", "prev", "theme", "_d", "elementOrWidget", "curEl", "Search", "gotoHit", "reapply", "fields", "col", "formatters", "prevValue", "belongsTo", "DomDataStore", "silent", "rowIndex", "fromStart", "fromCell", "showHitIndex", "StickyCells", "contentElement", "gridViewport", "currentTopRow", "topRowChanged", "notEnoughHeight", "removeClasses", "rowClasses", "cellClasses", "stickyContent", "stickyEls", "e", "rowEl", "eTop", "FileDrop", "domEvent", "file", "GroupBar", "ChipView", "treeGrid", "treeGroup", "columnReorder", "Store", "levels", "level", "context", "TreeCombo", "Combo", "picker", "oldPicker", "multiSelect", "readOnly", "selection", "HOSTS", "EXPIRING_CLASSES", "location", "host", "initialized", "initExpiryHelper", "owner", "baseClass", "ExpiryHelper", "product", "productName", "version", "callHomeDelay", "blockUrl", "BrowserHelper", "timeString", "time", "saveVersionCheckKey", "url", "logUrl", "img", "rootEl", "Toast", "darkColor", "lightColor", "color", "svgString", "GridBase", "Override", "setWatermarks", "targets", "RowManager", "ignoreDomainRe", "websiteUrls", "products", "frameworks", "prod", "framework", "newScript", "gtag"]
}
