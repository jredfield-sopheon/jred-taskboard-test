{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/widget/panel/PanelCollapserOverlay.js"],
  "sourcesContent": ["import Animator from '../../util/Animator.js';\nimport PanelCollapser from './PanelCollapser.js';\nimport Delayable from '../../mixin/Delayable.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\nimport EventHelper from '../../helper/EventHelper.js';\nimport DomHelper from '../../helper/DomHelper.js';\nimport DomClassList from '../../helper/util/DomClassList.js';\n/**\n * @module Core/widget/panel/PanelCollapserOverlay\n */\nconst\n    { dockIsHorz } = PanelCollapser.maps,\n    collapseExposeEdge = {\n        top    : 0,\n        down   : 0,\n        left   : 1,\n        bottom : 2,\n        up     : 2,\n        right  : 3\n    },\n    translateByDir = {\n        up : {\n            from : `translate(0,0)`,\n            to   : 'translate(0,-100%)'\n        },\n        down : {\n            from : `translate(0,0)`,\n            to   : 'translate(0,100%)'\n        },\n        left : {\n            from : `translate(0,0)`,\n            to   : 'translate(-100%,0)'\n        },\n        right : {\n            from : `translate(0,0)`,\n            to   : 'translate(100%,0)'\n        }\n    };\n/**\n * A panel collapse implementation that adds the ability to reveal the collapsed panel as a floating overlay.\n *\n * @extends Core/widget/panel/PanelCollapser\n * @classtype overlay\n * @classtypealias panelcollapseroverlay\n */\nexport default class PanelCollapserOverlay extends PanelCollapser.mixin(Delayable) {\n    static $name = 'PanelCollapserOverlay';\n    static type = 'overlay';\n    static get configurable() {\n        return {\n            /**\n             * The number of milliseconds to wait once the mouse leaves a {@link Core.widget.Panel#config-revealed}\n             * panel before returning to an unrevealed state. Clicking outside the revealed panel will immediately\n             * return the panel to its collapsed state.\n             *\n             * This may be disabled by configuring {@link #config-autoClose} as `null`.\n             *\n             * If this value is negative, the panel will not automatically recollapse due to the mouse leaving, however,\n             * clicks outside the panel will still recollapse it.\n             *\n             * If this value is `null`, the panel will not automatically recollapse for either outside clicks or if\n             * the mouse leaves the panel.\n             * @config {Number}\n             * @default\n             */\n            autoCloseDelay : 1000,\n            /**\n             * By default, clicking outside the revealed overlay hides the revealed overlay.\n             *\n             * If the revealed overlay was shown using the {@link #property-recollapseTool}\n             * then moving the mouse outside of the revealed overlay hides the revealed overlay.\n             *\n             * Configure this as `false` to disable auto hiding, making overlayed\n             * state permanent, and changeable using the {@link #function-toggleReveal} method.\n             * @config {Boolean}\n             * @default\n             */\n            autoClose : true,\n            revealing : {\n                value   : null,\n                $config : null,\n                default : false\n            },\n            /**\n             * The reveal/hide tool which slides the collapsed panel over the top of the UI.\n             * @member {Core.widget.Tool} recollapseTool\n             */\n            /**\n             * The reveal/hide tool which slides the collapsed panel over the top of the UI.\n             *\n             * The `type` of this instance should not be changed but the tool instance can be\n             * configured in other ways via this config property.\n             * @config {ToolConfig|Core.widget.Tool}\n             */\n            recollapseTool : {\n                type       : 'collapsetool',\n                cls        : 'b-recollapse',\n                collapsify : 'overlay',\n                handler() {\n                    // NOTE: As a tool, our this pointer is the Panel so we use it to access the current collapser\n                    this.collapsible?.toggleReveal();\n                }\n            }\n        };\n    }\n    static get delayable() {\n        return {\n            doAutoClose : 0\n        };\n    }\n    doAutoClose() {\n        this.toggleReveal(false);\n    }\n    updateAutoCloseDelay(delay) {\n        const { doAutoClose } = this;\n        if (!(doAutoClose.suspended = delay == null || delay < 0)) {\n            doAutoClose.delay = delay;\n            doAutoClose.immediate = !delay;\n        }\n    }\n    changeRecollapseTool(tool) {\n        const\n            me = this,\n            { panel } = me;\n        if (me.isConfiguring || me.isDestroying || !panel || panel.isDestroying) {\n            return tool;\n        }\n        panel.tools = {\n            recollapse : tool\n        };\n    }\n    beforeCollapse(operation) {\n        if (super.beforeCollapse(operation) === false) {\n            return false;\n        }\n        if (this.panel.revealed) {\n            operation.animation = null;\n        }\n    }\n    applyHeaderDock(collapsed, flush = true) {\n        this.panel?.recompose();\n        super.applyHeaderDock(collapsed, flush);\n    }\n    collapseBegin(operation) {\n        const\n            me = this,\n            { collapseDir, innerElement } = me,\n            { animation } = operation,\n            { collapseTool, panel } = me;\n        me.configuredWidth = panel._lastWidth;\n        me.configuredHeight = panel._lastHeight;\n        me.applyHeaderDock(true);\n        // const innerElementRect = me.lockInnerSize();\n        me.lockInnerSize();\n        collapseTool?.element.classList.add('b-collapsed');\n        if (animation) {\n            panel.element.classList.add('b-collapsing');\n            animation.element = innerElement;\n            animation.transform = translateByDir[collapseDir];\n            operation.animation = Animator.run(animation);\n        }\n    }\n    onComplete(action) {\n        super.onComplete(action);\n        const\n            me          = this,\n            { panel }   = me,\n            { element } = panel;\n        me.autoCloseLeaveDetacher = me.autoCloseLeaveDetacher?.();\n        me.autoCloseClickDetacher = me.autoCloseClickDetacher?.();\n        // The act of hiding the revealed panel (\"unrevealing\") causes a mouseleave event (once the panel slides out\n        // from under the cursor) and that starts the autoClose timer. If the user then reveals the panel again within\n        // the 1sec delay (by default), the autoClose timer will still fire and unreveal the panel.\n        me.doAutoClose.cancel();\n        if (action === 'reveal' && me.autoClose) {\n            // Only listen for mouseleave to close if we contain focus.\n            // If we do not, then we have been revealed using the API from some other\n            // part of the UI, so mouseleave closing would not be appropriate.\n            if (panel.containsFocus) {\n                me.autoCloseLeaveDetacher = EventHelper.on({\n                    element,\n                    mouseenter : ev => {\n                        me.doAutoClose.cancel();\n                    },\n                    mouseleave : ev => {\n                        me.doAutoClose();\n                    }\n                });\n            }\n            me.autoCloseClickDetacher = EventHelper.on({\n                element   : document.body,\n                thisObj   : panel,\n                mousedown : ev => {\n                    // If it's a click outside of the revealed Panel, but *not* on the element which\n                    // was active when the reveal was done (because that's the toggle button)\n                    // then unreveal.\n                    if (!panel.owns(ev) && !me.revealer?.contains(ev.target) && me.autoCloseDelay != null) {\n                        me.doAutoClose.now();\n                    }\n                }\n            });\n        }\n    }\n    expandBegin(operation) {\n        const\n            me = this,\n            { animation } = operation,\n            { collapseDir, collapseTool, innerElement, panel } = me,\n            { element } = panel;\n        element.classList.remove('b-collapsed', 'b-collapsing');\n        me.restoreConfiguredSize();\n        me.lockInnerSize(false);\n        me.lockInnerSize();\n        collapseTool?.element.classList.remove('b-collapsed');\n        if (animation) {\n            element.classList.add('b-collapsed', 'b-expanding');\n            animation.element = innerElement;\n            animation.transform = {\n                from : translateByDir[collapseDir].to,\n                to   : translateByDir[collapseDir].from\n            };\n            operation.animation = Animator.run(animation);\n        }\n    }\n    expandEnd(operation) {\n        super.expandEnd(operation);\n        const { panel } = this;\n        if (operation.completed) {\n            panel.revealed = false;\n        }\n        panel.element.classList.remove('b-expanding');\n    }\n    expandRevert(operation) {\n        super.expandRevert(operation);\n        this.panel.element.classList.add('b-expanding');\n    }\n    get innerElement() {\n        return this.panel.overlayElement;\n    }\n    get innerSizeElement() {\n        return this.panel.element;\n    }\n    get toolsConfig() {\n        const\n            me = this,\n            { direction } = me,\n            config = super.toolsConfig,\n            tool = me.recollapseTool;\n        if (tool) {\n            return {\n                ...config,\n                recollapse : tool && ObjectHelper.assign({\n                    direction : direction.toLowerCase()\n                }, tool)\n            };\n        }\n        return config;\n    }\n    lockInnerSize(lock = true) {\n        const\n            me = this,\n            { panel } = me,\n            panelRect = lock && panel.rectangle(),  // must read this before we call super\n            inset = lock ? [0, 0, 0, 0] : '',\n            // now we can call super:\n            innerRect = super.lockInnerSize(lock);\n        // The panel overlay is visible because we switch to \"overflow:visible\" in collapsed state. By doing this,\n        // however, the header animation undesirably escapes as well. Fortunately, we can use the clip-path to hide\n        // this by only allowing the desired side to escape while all other sides remain clipped. Even more fortunate\n        // for us is that clip-path is expressed as an inset from the normal rectangle of the element (so we don't\n        // need to adjust it if the collapsed panel is resized), and further, unlike CSS path style, clip-path works\n        // for all elements not only absolutely positioned ones.\n        if (lock) {\n            inset[collapseExposeEdge[me.collapseDir]] = `-${panelRect[me.collapseDim] + 10}px`;\n        }\n        panel.element.style.clipPath = lock ? `inset(${inset.join(' ')})` : '';\n        return innerRect;\n    }\n    onOverlayTransitionDone(ev) {\n        const\n            me = this,\n            { panel } = me;\n        if (ev.srcElement === panel.overlayElement && me.revealing) {\n            me.revealing = false;\n            me.onComplete(panel.revealed ? 'reveal' : 'unreveal');\n        }\n    }\n    onRevealerClick() {\n        this.toggleReveal();\n    }\n    /**\n     * Toggles the revealed state of the Panel to match the passed boolean flag.\n     * @param {Boolean} [state]  If not specified, this method toggles current state. Otherwise, pass `true` to reveal\n     * the overlay, or `false` to hide it.\n     */\n    toggleReveal(state) {\n        const\n            { panel }   = this,\n            { element } = panel;\n        if (panel.collapsed) {\n            this.revealer = DomHelper.getActiveElement(element);\n            if (state == null) {\n                state = !panel.revealed;\n            }\n            if (panel.revealed !== state && panel.trigger('beforeToggleReveal', { reveal : state }) !== false) {\n                // This is essentially a hide, so move focus back to whence it came\n                if (!state && element.contains(this.revealer)) {\n                    panel.revertFocus(true);\n                }\n                this.revealing = true;\n                panel.revealed = state;\n            }\n        }\n    }\n    updateRevealing(value) {\n        const\n            me = this,\n            horzDirRe = /left|right/i,\n            { panel } = me,\n            dim = horzDirRe.test(me.collapseDir) ? 'height' : 'width';\n        if (panel) {\n            me.innerElement.style[dim] = '0px';\n            me.innerElement.style[`min-${dim}`] = '100%';\n            panel.element.classList[value ? 'add' : 'remove']('b-panel-overlay-revealing');\n        }\n    }\n    wrapCollapser(key, body) {\n        const\n            me = this,\n            { collapseDir, panel } = me,\n            { expandedHeaderDock, header, uiClassList } = panel,\n            recollapse = panel.tools?.recollapse,\n            [before, after] = me.splitHeaderItems({ as : 'element', dock : me.collapseDock }),\n            horz = dockIsHorz[expandedHeaderDock],\n            title = panel.hasHeader ? (panel.title || header?.title || '\\xA0') : null;\n        if (recollapse) {\n            recollapse.direction = collapseDir;\n        }\n        return [\n            'overlayElement',\n            {\n                class : {\n                    ...uiClassList,\n                    [`b-panel-overlay-header-${expandedHeaderDock}`] : 1,\n                    [`b-panel-overlay-${collapseDir}`]               : 1,\n                    [`b-${horz ? 'h' : 'v'}box`]                     : 1,\n                    'b-panel-overlay'                                : 1,\n                    'b-box-center'                                   : 1\n                },\n                // internalListeners is not correct for element listeners in domConfigs\n                listeners : {  // eslint-disable-line bryntum/no-listeners-in-lib\n                    transitionend    : ev => me.onOverlayTransitionDone(ev),\n                    transitioncancel : ev => me.onOverlayTransitionDone(ev)\n                },\n                children : {\n                    overlayHeaderElement : title && {\n                        tag   : 'header',\n                        class : new DomClassList({\n                            ...uiClassList,\n                            [`b-dock-${expandedHeaderDock}`] : 1,\n                            'b-panel-header'                 : 1,\n                            'b-panel-overlay-header'         : 1\n                        }, header?.cls),\n                        children : [\n                            ...before,\n                            {\n                                reference : 'overlayTitleElement',\n                                html      : title,\n                                class     : {\n                                    ...uiClassList,\n                                    [`b-align-${header?.titleAlign || 'start'}`] : 1,\n                                    'b-header-title'                             : 1\n                                }\n                            },\n                            ...after\n                        ]\n                    },\n                    [key] : body\n                }\n            }\n        ];\n    }\n}\n// Register this widget type with its Factory\nPanelCollapserOverlay.initClass();\nPanelCollapserOverlay._$name = 'PanelCollapserOverlay';"],
  "mappings": "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",
  "names": ["dockIsHorz", "PanelCollapser", "collapseExposeEdge", "translateByDir", "PanelCollapserOverlay", "Delayable_default", "_a", "delay", "doAutoClose", "tool", "me", "panel", "operation", "collapsed", "flush", "collapseDir", "innerElement", "animation", "collapseTool", "Animator", "action", "_b", "element", "EventHelper", "ev", "direction", "config", "ObjectHelper", "lock", "panelRect", "inset", "innerRect", "state", "DomHelper", "value", "horzDirRe", "dim", "key", "body", "expandedHeaderDock", "header", "uiClassList", "recollapse", "before", "after", "horz", "title", "DomClassList", "__publicField"]
}
