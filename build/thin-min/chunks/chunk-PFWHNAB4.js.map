{
  "version": 3,
  "sources": ["../../../../Scheduler/lib/Scheduler/column/DurationColumn.js", "../../../../Scheduler/lib/Scheduler/feature/base/DragBase.js", "../../../../Scheduler/lib/Scheduler/feature/EventResize.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/TaskEditTransactional.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/TransactionalFeature.js", "../../../../Scheduler/lib/Scheduler/feature/base/DragCreateBase.js", "../../../../Scheduler/lib/Scheduler/feature/base/TooltipBase.js", "../../../../Scheduler/lib/Scheduler/feature/AbstractTimeRanges.js", "../../../../Scheduler/lib/Scheduler/feature/ColumnLines.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyCreation.js", "../../../../Scheduler/lib/Scheduler/util/RectangularPathFinder.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyTooltip.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyGridCache.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/DependencyLineGenerator.js", "../../../../Scheduler/lib/Scheduler/feature/Dependencies.js", "../../../../Scheduler/lib/Scheduler/feature/EventFilter.js", "../../../../Scheduler/lib/Scheduler/feature/mixin/NonWorkingTimeMixin.js", "../../../../Scheduler/lib/Scheduler/feature/NonWorkingTime.js", "../../../../Scheduler/lib/Scheduler/feature/ScheduleTooltip.js", "../../../../Scheduler/lib/Scheduler/feature/TimeAxisHeaderMenu.js"],
  "sourcesContent": ["import ColumnStore from '../../Grid/data/ColumnStore.js';\nimport NumberColumn from '../../Grid/column/NumberColumn.js';\nimport Duration from '../../Core/data/Duration.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport '../../Core/widget/DurationField.js';\n/**\n * @module Scheduler/column/DurationColumn\n */\n/**\n * A column showing the task {@link Scheduler/model/TimeSpan#field-fullDuration duration}. Please note, this column\n * is preconfigured and expects its field to be of the {@link Core.data.Duration} type.\n *\n * The default editor is a {@link Core.widget.DurationField}. It parses time units, so you can enter \"4d\"\n * indicating 4 days duration, or \"4h\" indicating 4 hours, etc. The numeric magnitude can be either an integer or a\n * float value. Both \",\" and \".\" are valid decimal separators. For example, you can enter \"4.5d\" indicating 4.5 days\n * duration, or \"4,5h\" indicating 4.5 hours.\n *\n * {@inlineexample Scheduler/column/DurationColumn.js}\n *\n * @extends Grid/column/NumberColumn\n * @classtype duration\n * @column\n */\nexport default class DurationColumn extends NumberColumn {\n    compositeField = true;\n    //region Config\n    static get $name() {\n        return 'DurationColumn';\n    }\n    static get type() {\n        return 'duration';\n    }\n    static get isGanttColumn() {\n        return true;\n    }\n    static get fields() {\n        return [\n            /**\n             * Precision of displayed duration, defaults to use {@link Scheduler.view.Scheduler#config-durationDisplayPrecision}.\n             * Specify an integer value to override that setting, or `false` to use raw value\n             * @config {Number|Boolean} decimalPrecision\n             */\n            { name : 'decimalPrecision', defaultValue : 1 }\n        ];\n    }\n    static get defaults() {\n        return {\n            /**\n             * Min value\n             * @config {Number}\n             */\n            min : null,\n            /**\n             * Max value\n             * @config {Number}\n             */\n            max : null,\n            /**\n             * Step size for spin button clicks.\n             * @member {Number} step\n             */\n            /**\n             * Step size for spin button clicks. Also used when pressing up/down keys in the field.\n             * @config {Number}\n             * @default\n             */\n            step : 1,\n            /**\n             * Large step size, defaults to 10 * `step`. Applied when pressing SHIFT and stepping either by click or\n             * using keyboard.\n             * @config {Number}\n             * @default 10\n             */\n            largeStep : 0,\n            field         : 'fullDuration',\n            text          : 'L{Duration}',\n            instantUpdate : true,\n            // Undocumented, used by Filter feature to get type of the filter field\n            filterType    : 'duration',\n            sortable(durationEntity1, durationEntity2) {\n                const\n                    ms1 = durationEntity1.getValue(this.field),\n                    ms2 = durationEntity2.getValue(this.field);\n                return ms1 - ms2;\n            }\n        };\n    }\n    construct() {\n        super.construct(...arguments);\n        const sortFn = this.sortable;\n        this.sortable = (...args) => sortFn.call(this, ...args);\n    }\n    get defaultEditor() {\n        const { max, min, step, largeStep } = this;\n        // Remove any undefined configs, to allow config system to use default values instead\n        return ObjectHelper.cleanupProperties({\n            type : 'duration',\n            name : this.field,\n            max,\n            min,\n            step,\n            largeStep\n        });\n    }\n    //endregion\n    //region Internal\n    get durationUnitField() {\n        return `${this.field}Unit`;\n    }\n    roundValue(duration) {\n        const\n            nbrDecimals = typeof this.grid.durationDisplayPrecision === 'number' ? this.grid.durationDisplayPrecision : this.decimalPrecision,\n            multiplier  = Math.pow(10, nbrDecimals),\n            rounded     = Math.round(duration * multiplier) / multiplier;\n        return rounded;\n    }\n    formatValue(duration, durationUnit) {\n        if (duration instanceof Duration) {\n            durationUnit = duration.unit;\n            duration     = duration.magnitude;\n        }\n        duration = this.roundValue(duration);\n        return duration + ' ' + DateHelper.getLocalizedNameOfUnit(durationUnit, duration !== 1);\n    }\n    //endregion\n    //region Render\n    defaultRenderer({ value, record, isExport }) {\n        const\n            type          = typeof value,\n            durationValue = type === 'number' ? value : value?.magnitude,\n            durationUnit  = type === 'number' ? record.getValue(this.durationUnitField) : value?.unit;\n        // in case of bad input (for instance NaN, undefined or NULL value)\n        if (typeof durationValue !== 'number') {\n            return isExport ? '' : null;\n        }\n        return this.formatValue(durationValue, durationUnit);\n    }\n    //endregion\n    // Used with CellCopyPaste as fullDuration doesn't work via record.get\n    toClipboardString({ record }) {\n        return record.getValue(this.field).toString();\n    }\n    fromClipboardString({ string, record }) {\n        const duration = DateHelper.parseDuration(string, true, this.durationUnit);\n        if (duration && 'magnitude' in duration) {\n            return duration;\n        }\n        return record.fullDuration;\n    }\n    calculateFillValue({ value, record }) {\n        return this.fromClipboardString({ string : value, record });\n    }\n}\nColumnStore.registerColumnType(DurationColumn);\nDurationColumn._$name = 'DurationColumn';", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport DateHelper from '../../../Core/helper/DateHelper.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport DragHelper from '../../../Core/helper/DragHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport ClockTemplate from '../../tooltip/ClockTemplate.js';\nimport Tooltip from '../../../Core/widget/Tooltip.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\nimport Widget from '../../../Core/widget/Widget.js';\n/**\n * @module Scheduler/feature/base/DragBase\n */\n/**\n * Base class for EventDrag (Scheduler) and TaskDrag (Gantt) features. Contains shared code. Not to be used directly.\n *\n * @extends Core/mixin/InstancePlugin\n * @abstract\n */\nexport default class DragBase extends InstancePlugin {\n    //region Config\n    static get defaultConfig() {\n        return {\n            // documented on Schedulers EventDrag feature and Gantt's TaskDrag\n            tooltipTemplate : data => `\n                <div class=\"b-sch-tip-${data.valid ? 'valid' : 'invalid'}\">\n                    ${data.startClockHtml}\n                    ${data.endClockHtml}\n                    <div class=\"b-sch-tip-message\">${data.message}</div>\n                </div>\n            `,\n            /**\n             * Specifies whether or not to show tooltip while dragging event\n             * @prp {Boolean}\n             * @default\n             */\n            showTooltip : true,\n            /**\n             * When enabled, the event being dragged always \"snaps\" to the exact start date that it will have after drop.\n             * @config {Boolean}\n             * @default\n             */\n            showExactDropPosition : false,\n            /*\n             * The store from which the dragged items are mapped to the UI.\n             * In Scheduler's implementation of this base class, this will be\n             * an EventStore, in Gantt's implementations, this will be a TaskStore.\n             * Because both derive from this base, we must refer to it as this.store.\n             * @private\n             */\n            store : null,\n            /**\n             * An object used to configure the internal {@link Core.helper.DragHelper} class\n             * @config {DragHelperConfig}\n             */\n            dragHelperConfig : null,\n            tooltipCls : 'b-eventdrag-tooltip'\n        };\n    }\n    static get configurable() {\n        return {\n            /**\n             * Set to `false` to allow dragging tasks outside the client Scheduler.\n             * Useful when you want to drag tasks between multiple Scheduler instances\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToTimeline : true,\n            // documented on Schedulers EventDrag feature, not used for Gantt\n            constrainDragToResource : true,\n            constrainDragToTimeSlot : false,\n            /**\n             * Yields the {@link Core.widget.Tooltip} which tracks the event during a drag operation.\n             * @member {Core.widget.Tooltip} tip\n             */\n            /**\n             * A config object to allow customization of the {@link Core.widget.Tooltip} which tracks\n             * the event during a drag operation.\n             * @config {TooltipConfig}\n             */\n            tip : {\n                $config : ['lazy', 'nullify'],\n                value   : {\n                    align : {\n                        align          : 'b-t',\n                        allowTargetOut : true\n                    },\n                    autoShow                 : true,\n                    updateContentOnMouseMove : true\n                }\n            },\n            /**\n             * The `eventDrag`and `taskDrag` events are normally only triggered when the drag operation will lead to a\n             * change in date or assignment. By setting this config to `false`, that logic is bypassed to trigger events\n             * for each native mouse move event.\n             * @prp {Boolean}\n             */\n            throttleDragEvent : true\n        };\n    }\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onInternalPaint']\n        };\n    }\n    //endregion\n    //region Init\n    internalSnapToPosition(snapTo) {\n        const { dragData } = this;\n        this.snapToPosition?.({\n            assignmentRecord : dragData.assignmentRecord,\n            eventRecord      : dragData.eventRecord,\n            resourceRecord   : dragData.newResource || dragData.resourceRecord,\n            startDate        : dragData.startDate,\n            endDate          : dragData.endDate,\n            snapTo\n        });\n    }\n    buildDragHelperConfig() {\n        const\n            me                                  = this,\n            {\n                client,\n                constrainDragToTimeline,\n                constrainDragToResource,\n                constrainDragToTimeSlot,\n                dragHelperConfig = {}\n            }                                   = me,\n            { timeAxisViewModel, isHorizontal } = client,\n            lockY                               = isHorizontal ? constrainDragToResource : constrainDragToTimeSlot,\n            lockX                               = isHorizontal ? constrainDragToTimeSlot : constrainDragToResource;\n        // If implementer wants to allow users dragging outside the timeline element, setup the internal dropTargetSelector\n        if (me.externalDropTargetSelector) {\n            dragHelperConfig.dropTargetSelector = `.b-timeaxissubgrid,${me.externalDropTargetSelector}`;\n        }\n        return Objects.merge({\n            name                 : me.constructor.name, // useful when debugging with multiple draggers\n            positioning          : 'absolute',\n            lockX,\n            lockY,\n            minX                 : true, // Allows dropping with start before time axis\n            maxX                 : true, // Allows dropping with end after time axis\n            constrain            : false,\n            cloneTarget          : !constrainDragToTimeline,\n            // If we clone event dragged bars, we assume ownership upon drop so we can reuse the element and have animations\n            removeProxyAfterDrop : false,\n            dragWithin           : constrainDragToTimeline ? null : document.body,\n            hideOriginalElement  : true,\n            dropTargetSelector   : '.b-timelinebase',\n            // A CSS class added to drop target while dragging events\n            dropTargetCls : me.externalDropTargetSelector ? 'b-drop-target' : '',\n            outerElement   : client.timeAxisSubGridElement,\n            targetSelector : client.eventSelector,\n            scrollManager  : constrainDragToTimeline ? client.scrollManager : null,\n            createProxy    : el => me.createProxy(el),\n            snapCoordinates : ({ element, newX, newY }) => {\n                const\n                    { dragData }     = me,\n                    timeline         = this.currentOverClient;\n                // Snapping not supported when dragging outside a scheduler\n                if (me.constrainDragToTimeline && !me.constrainDragToTimeSlot && (me.showExactDropPosition || timeAxisViewModel.snap)) {\n                    const\n                        draggedEventRecord = dragData.draggedEntities[0].event || dragData.draggedEntities[0],\n                        coordinate         = me.getCoordinate(draggedEventRecord, element, [newX, newY]),\n                        //fillTicks and span features have different behaviours in rounding the new starDate while dragging, then snap feature needs to be forced to use the same date as fillTicks (if is active).\n                        snappedDate        = timeline.fillTicks && client.timeAxis.isContinuous ? dragData.startDate : timeAxisViewModel.getDateFromPosition(coordinate, 'round'),\n                        { calendar }       = draggedEventRecord;\n                    if (!calendar || snappedDate && calendar.isWorkingTime(snappedDate, DateHelper.add(snappedDate, draggedEventRecord.fullDuration))) {\n                        const snappedPosition = snappedDate && timeAxisViewModel.getPositionFromDate(snappedDate);\n                        if (snappedDate && snappedDate >= client.startDate && snappedPosition != null) {\n                            if (isHorizontal) {\n                                newX = snappedPosition;\n                            }\n                            else {\n                                newY = snappedPosition;\n                            }\n                        }\n                    }\n                }\n                const snapTo = { x : newX, y : newY };\n                me.internalSnapToPosition(snapTo);\n                return snapTo;\n            },\n            internalListeners : {\n                beforedragstart : 'onBeforeDragStart',\n                dragstart       : 'onDragStart',\n                afterdragstart  : 'onAfterDragStart',\n                drag            : 'onDrag',\n                drop            : 'onDrop',\n                abort           : 'onDragAbort',\n                abortFinalized  : 'onDragAbortFinalized',\n                reset           : 'onDragReset',\n                thisObj         : me\n            }\n        }, dragHelperConfig, {\n            isElementDraggable : (el, event) => {\n                return (!dragHelperConfig || !dragHelperConfig.isElementDraggable || dragHelperConfig.isElementDraggable(el, event)) &&\n                    me.isElementDraggable(el, event);\n            }\n        });\n    }\n    /**\n     * Called when scheduler is rendered. Sets up drag and drop and hover tooltip.\n     * @private\n     */\n    onInternalPaint({ firstPaint }) {\n        const\n            me         = this,\n            { client } = me;\n        me.drag?.destroy();\n        me.drag = DragHelper.new(me.buildDragHelperConfig());\n        if (firstPaint) {\n            client.rowManager.ion({\n                changeTotalHeight : () => me.updateYConstraint(me.dragData?.[`${client.scheduledEventName}Record`]),\n                thisObj           : me\n            });\n        }\n        if (me.showTooltip) {\n            me.clockTemplate = new ClockTemplate({\n                scheduler : client\n            });\n        }\n    }\n    doDestroy() {\n        this.drag?.destroy();\n        this.clockTemplate?.destroy();\n        this.tip?.destroy();\n        super.doDestroy();\n    }\n    get tipId() {\n        return `${this.client.id}-event-drag-tip`;\n    }\n    changeTip(tip, oldTip) {\n        const me = this;\n        if (tip) {\n            const result = Tooltip.reconfigure(oldTip, Tooltip.mergeConfigs({\n                forElement : me.element,\n                id         : me.tipId,\n                getHtml    : me.getTipHtml.bind(me),\n                cls        : me.tooltipCls,\n                owner      : me.client\n            }, tip), {\n                owner    : me.client,\n                defaults : {\n                    type : 'tooltip'\n                }\n            });\n            result.ion({ innerHtmlUpdate : 'updateDateIndicator', thisObj : me });\n            return result;\n        }\n        else {\n            oldTip?.destroy();\n        }\n    }\n    //endregion\n    //region Drag events\n    createProxy(element) {\n        const proxy = element.cloneNode(true);\n        delete proxy.id;\n        proxy.classList.add(`b-sch-${this.client.mode}`);\n        return proxy;\n    }\n    onBeforeDragStart({ context, event }) {\n        const\n            me             = this,\n            { client }     = me,\n            dragData       = me.getMinimalDragData(context, event),\n            eventRecord    = dragData?.[`${client.scheduledEventName}Record`],\n            resourceRecord = dragData.resourceRecord;\n        if (client.readOnly || me.disabled || !eventRecord || eventRecord.isDraggable === false || eventRecord.readOnly || resourceRecord?.readOnly) {\n            return false;\n        }\n        // Cache the date corresponding to the drag start point so that on drag, we can always\n        // perform the same calculation to then find the time delta without having to calculate\n        // the new start and end times from the position that the element is.\n        context.pointerStartDate = client.getDateFromXY([context.startClientX, context.startPageY], null, false);\n        const result = me.triggerBeforeEventDrag(\n            `before${client.capitalizedEventName}Drag`,\n            {\n                ...dragData,\n                event,\n                // to be deprecated\n                context : {\n                    ...context,\n                    ...dragData\n                }\n            }\n        ) !== false;\n        if (result) {\n            me.updateYConstraint(eventRecord, resourceRecord);\n            // Hook for features that need to react to drag starting, used by NestedEvents\n            client[`before${client.capitalizedEventName}DragStart`]?.(context, dragData);\n        }\n        return result;\n    }\n    onAfterDragStart({ context, event }) {}\n    /**\n     * Returns true if a drag operation is active\n     * @property {Boolean}\n     * @readonly\n     */\n    get isDragging() {\n        return this.drag?.isDragging;\n    }\n    // Checked by dependencies to determine if live redrawing is needed\n    get isActivelyDragging() {\n        return this.isDragging && !this.finalizing;\n    }\n    /**\n     * Triggered when dragging of an event starts. Initializes drag data associated with the event being dragged.\n     * @private\n     */\n    onDragStart({ context, event }) {\n        const\n            me     = this,\n            // When testing with Selenium, it simulates drag and drop with a single mousemove event, we might be over\n            // another client already\n            client = me.findClientFromTarget(event, context) ?? me.client;\n        me.currentOverClient = client;\n        me.drag.unifiedProxy = me.unifiedDrag;\n        me.onMouseOverNewTimeline(client, true);\n        const dragData = me.dragData = me.getDragData(context);\n        // Do not let DomSync reuse the element\n        me.suspendElementRedrawing(context.element);\n        if (me.showTooltip && me.tip) {\n            const tipTarget = dragData.context.dragProxy ? dragData.context.dragProxy.firstChild : context.element;\n            me.tip.showBy(tipTarget);\n        }\n        me.triggerDragStart(dragData);\n        // Hook for features that need to take action after drag starts\n        client[`after${client.capitalizedEventName}DragStart`]?.(context, dragData);\n        const\n            {\n                eventMenu,\n                taskMenu\n            }           = client.features,\n            menuFeature = eventMenu || taskMenu;\n        // If this is a touch action, hide the context menu which may have shown\n        menuFeature?.hideContextMenu?.(false);\n    }\n    updateDateIndicator() {\n        const\n            { startDate, endDate } = this.dragData,\n            { tip, clockTemplate } = this,\n            endDateElement         = tip.element.querySelector('.b-sch-tooltip-enddate');\n        clockTemplate.updateDateIndicator(tip.element, startDate);\n        endDateElement && clockTemplate.updateDateIndicator(endDateElement, endDate);\n    }\n    findClientFromTarget(event, context) {\n        let { target } = event;\n        // Can't detect target under a touch event\n        if (/^touch/.test(event.type)) {\n            const center = Rectangle.from(context.element, null, true).center;\n            target = DomHelper.elementFromPoint(center.x, center.y);\n        }\n        const client = Widget.fromElement(target, 'timelinebase');\n        // Do not allow drops on histogram widgets\n        return client?.isResourceHistogram ? null : client;\n    }\n    /**\n     * Triggered while dragging an event. Updates drag data, validation etc.\n     * @private\n     */\n    onDrag({ context, event }) {\n        const\n            me    = this,\n            dd    = me.dragData,\n            start = dd.startDate;\n        let client;\n        if (me.constrainDragToTimeline) {\n            client = me.client;\n        }\n        else {\n            client = me.findClientFromTarget(event, dd.context);\n        }\n        me.updateDragContext(context, event);\n        if (!client) {\n            return;\n        }\n        if (client !== me.currentOverClient) {\n            me.onMouseOverNewTimeline(client);\n        }\n        //this.checkShiftChange();\n        // Let product specific implementations trigger drag event (eventDrag, taskDrag)\n        if (dd.dirty || !me.throttleDragEvent) {\n            const valid = dd.valid;\n            me.triggerEventDrag(dd, start);\n            if (valid !== dd.valid) {\n                dd.context.valid = dd.externalDragValidity = dd.valid;\n            }\n        }\n        if (me.showTooltip && me.tip) {\n            // If we've an error message to show, force the tip to be visible\n            // even if the target is not in view.\n            me.tip.lastAlignSpec.allowTargetOut = !dd.valid;\n            me.tip.realign();\n        }\n    }\n    onMouseOverNewTimeline(newTimeline, initial) {\n        const\n            me                          = this,\n            { drag : { lockX, lockY } } = me,\n            scrollables                 = [];\n        me.currentOverClient.element.classList.remove('b-dragging-' + me.currentOverClient.scheduledEventName);\n        newTimeline.element.classList.add('b-dragging-' + newTimeline.scheduledEventName);\n        if (!initial) {\n            me.currentOverClient.scrollManager.stopMonitoring();\n        }\n        if (!lockX) {\n            scrollables.push({\n                element   : newTimeline.timeAxisSubGrid.scrollable.element,\n                direction : 'horizontal'\n            });\n        }\n        if (!lockY) {\n            scrollables.push({\n                element   : newTimeline.scrollable.element,\n                direction : 'vertical'\n            });\n        }\n        newTimeline.scrollManager.startMonitoring({\n            scrollables,\n            callback : me.drag.onScrollManagerScrollCallback\n        });\n        me.currentOverClient = newTimeline;\n    }\n    triggerBeforeEventDropFinalize(eventType, eventData, client) {\n        client.trigger(eventType, eventData);\n    }\n    /**\n     * Triggered when dropping an event. Finalizes the operation.\n     * @private\n     */\n    onDrop({ context, event }) {\n        const\n            me                    = this,\n            { currentOverClient, dragData } = me;\n        let modified = false;\n        // Stop monitoring early, to avoid scrolling during finalization\n        currentOverClient?.scrollManager.stopMonitoring();\n        me.tip?.hide();\n        context.valid = context.valid && me.isValidDrop(dragData);\n        // If dropping outside scheduler, we opt in on DragHelper removing the proxy element\n        me.drag.removeProxyAfterDrop = Boolean(dragData.externalDropTarget);\n        if (context.valid && dragData.startDate && dragData.endDate) {\n            let beforeDropTriggered = false;\n            dragData.finalize = async(valid) => {\n                if (beforeDropTriggered || dragData.async) {\n                    await me.finalize(valid);\n                }\n                else {\n                    // If user finalized operation synchronously in the beforeDropFinalize listener, just use\n                    // the valid param and carry on\n                    // but ignore it, if the context is already marked as invalid\n                    context.valid = context.valid && valid;\n                }\n            };\n            me.triggerBeforeEventDropFinalize(`before${currentOverClient.capitalizedEventName}DropFinalize`, {\n                context  : dragData,\n                domEvent : event\n            }, currentOverClient);\n            beforeDropTriggered = true;\n            // Allow implementer to take control of the flow, by returning false from this listener,\n            // to show a confirmation popup etc. This event is documented in EventDrag and TaskDrag\n            context.async = dragData.async;\n            // Internal validation, making sure all dragged records fit inside the view\n            if (!context.async && !dragData.externalDropTarget) {\n                modified = (dragData.startDate - dragData.origStart) !== 0 || dragData.newResource !== dragData.resourceRecord;\n            }\n        }\n        if (!context.async) {\n            me.finalize(dragData.valid && context.valid && modified);\n        }\n    }\n    onDragAbort({ context }) {\n        const me = this;\n        // Flag checked by dependencies feature, to live redraw during abort\n        me.isAborting = true;\n        // Stop monitoring early, to avoid scrolling during finalization\n        me.currentOverClient?.scrollManager.stopMonitoring();\n        me.client.currentOrientation.onDragAbort({ context, dragData : me.dragData });\n        // otherwise the event disappears on next refresh (#62)\n        me.resetDraggedElements();\n        me.tip?.hide();\n        // Trigger eventDragAbort / taskDragAbort depending on product\n        me.triggerDragAbort(me.dragData);\n    }\n    // Fired after any abort animation has completed (the point where we want to trigger redraw of progress lines etc)\n    onDragAbortFinalized({ context }) {\n        const me = this;\n        me.triggerDragAbortFinalized(me.dragData);\n        // Hook for features that need to react on drag abort, used by NestedEvents\n        me.client[`after${me.client.capitalizedEventName}DragAbortFinalized`]?.(context, me.dragData);\n        me.isAborting = false;\n    }\n    // For the drag across multiple schedulers, tell all involved scroll managers to stop monitoring\n    onDragReset({ source : dragHelper }) {\n        const\n            me              = this,\n            currentTimeline = me.currentOverClient;\n        if (dragHelper.context?.started) {\n            me.resetDraggedElements();\n            currentTimeline.trigger(`${currentTimeline.scheduledEventName}DragReset`);\n        }\n        currentTimeline?.element.classList.remove(`b-dragging-${currentTimeline.scheduledEventName}`);\n        me.dragData = null;\n    }\n    resetDraggedElements() {\n        const\n            { dragData }                     = this,\n            { eventBarEls, draggedEntities } = dragData;\n        this.resumeRecordElementRedrawing(dragData.record);\n        draggedEntities.forEach((record, i) => {\n            this.resumeRecordElementRedrawing(record);\n            eventBarEls[i].classList.remove(this.drag.draggingCls);\n            eventBarEls[i].retainElement = false;\n        });\n        // Code expects 1:1 ratio between eventBarEls & dragged assignments, but when dragging an event of a linked\n        // resource that is not the case, and we need to clean up some more\n        dragData.context.element.retainElement = false;\n    }\n    /**\n     * Triggered internally on invalid drop.\n     * @private\n     */\n    onInternalInvalidDrop(abort) {\n        const\n            me          = this,\n            { context } = me.drag;\n        me.tip?.hide();\n        me.triggerAfterDrop(me.dragData, false);\n        context.valid = false;\n        if (abort) {\n            me.drag.abort();\n        }\n    }\n    //endregion\n    //region Finalization & validation\n    /**\n     * Called on drop to update the record of the event being dropped.\n     * @private\n     * @param {Boolean} updateRecords Specify true to update the record, false to treat as invalid\n     */\n    async finalize(updateRecords) {\n        const\n            me                              = this,\n            { dragData, currentOverClient } = me,\n            clientEventTipFeature           = currentOverClient.features.taskTooltip || currentOverClient.features.eventTooltip;\n        // Drag could've been aborted by window blur event. If it is aborted - we have nothing to finalize.\n        if (!dragData || me.finalizing) {\n            return;\n        }\n        const { context, draggedEntities, externalDropTarget } = dragData;\n        let result;\n        me.finalizing = true;\n        draggedEntities.forEach((record, i) => {\n            me.resumeRecordElementRedrawing(record);\n            dragData.eventBarEls[i].classList.remove(me.drag.draggingCls);\n            dragData.eventBarEls[i].retainElement = false;\n        });\n        // Code expects 1:1 ratio between eventBarEls & dragged assignments, but when dragging an event of a linked\n        // resource that is not the case, and we need to clean up some more\n        context.element.retainElement = false;\n        if ((externalDropTarget && dragData.valid) || updateRecords) {\n            // updateRecords may or may not be async.\n            // We see if it returns a Promise.\n            result = me.updateRecords(dragData);\n            // If updateRecords is async, the calling DragHelper must know this and\n            // go into a awaitingFinalization state.\n            if (!externalDropTarget && Objects.isPromise(result)) {\n                context.async = true;\n                await result;\n            }\n            // If the finalize handler decided to change the dragData's validity...\n            if (!dragData.valid) {\n                me.onInternalInvalidDrop(true);\n            }\n            else {\n                if (context.async) {\n                    context.finalize();\n                }\n                if (externalDropTarget) {\n                    // Force a refresh early so that removed events will not temporary be visible while engine is\n                    // recalculating (the row below clears the 'b-hidden' CSS class of the original drag element)\n                    me.client.refreshRows(false);\n                }\n                me.triggerAfterDrop(dragData, true);\n            }\n        }\n        else {\n            me.onInternalInvalidDrop(context.async || dragData.async);\n        }\n        me.finalizing = false;\n        // Prevent event tooltip showing after a drag drop\n        if (clientEventTipFeature?.enabled) {\n            clientEventTipFeature.disabled = true;\n            currentOverClient.setTimeout(() => {\n                clientEventTipFeature.disabled = false;\n            }, 200);\n        }\n        return result;\n    }\n    //endregion\n    //region Drag data\n    getEventNewStartEndDates(eventRecord, timeDiff) {\n        // calculate and round new startDate based on actual timeDiff\n        let startDate = this.adjustStartDate(eventRecord.startDate, timeDiff);\n        let endDate;\n        // Use actual outcome for Pro, ignoring non-working time\n        if (eventRecord.graph) {\n            startDate = eventRecord.run('skipNonWorkingTime', startDate);\n            endDate   = eventRecord.run('calculateProjectedXDateWithDuration', startDate, true, eventRecord.duration);\n        }\n        else {\n            endDate = DateHelper.add(startDate, eventRecord.fullDuration);\n        }\n        return { startDate, endDate };\n    }\n    /**\n     * Updates drag data's dates and validity (calls #validatorFn if specified)\n     * @private\n     */\n    updateDragContext(info, event) {\n        const\n            me                  = this,\n            { drag }            = me,\n            dd                  = me.dragData,\n            client              = me.currentOverClient,\n            { isHorizontal }    = client,\n            [record]            = dd.draggedEntities,\n            eventRecord         = record.isAssignment ? record.event : record,\n            lastDragStartDate   = dd.startDate,\n            constrainToTimeSlot = me.constrainDragToTimeSlot || (isHorizontal ? drag.lockX : drag.lockY);\n        dd.browserEvent = event;\n        // getProductDragContext may switch valid flag, need to keep it here\n        Object.assign(dd, me.getProductDragContext(dd));\n        if (constrainToTimeSlot) {\n            dd.timeDiff = 0;\n        }\n        else {\n            let timeDiff;\n            // Time diff is calculated differently for continuous and non-continuous time axis\n            // (except if element starts and ends outside of view)\n            if (client.timeAxis.isContinuous || (dd.startsOutsideView && dd.endsOutsideView)) {\n                const\n                    timeAxisPosition = client.isHorizontal ? info.pageX ?? info.startPageX : info.pageY ?? info.startPageY,\n                    // Use the localized coordinates to ask the TimeAxisViewModel what date the mouse is at.\n                    // Pass allowOutOfRange as true in case we have dragged out of either side of the timeline viewport.\n                    pointerDate      = client.getDateFromCoordinate(timeAxisPosition, null, false, true);\n                timeDiff = dd.timeDiff = pointerDate - info.pointerStartDate;\n                if (timeDiff !== null) {\n                    Object.assign(dd, me.getEventNewStartEndDates(eventRecord, timeDiff));\n                    if (dd.valid) {\n                        dd.timeDiff = dd.startDate - dd.origStart;\n                    }\n                }\n            }\n            else {\n                const range = me.resolveStartEndDates(info.element);\n                // if dragging is out of timeAxis rect bounds, we will not be able to get dates\n                dd.valid = Boolean(range.startDate && range.endDate);\n                if (dd.valid) {\n                    timeDiff = range.startDate - dd.origStart;\n                }\n                if (timeDiff !== undefined) {\n                    // Use actual outcome for Pro, ignoring non-working time\n                    if (eventRecord.graph) {\n                        dd.startDate = eventRecord.run('skipNonWorkingTime', range.startDate);\n                        dd.endDate   = eventRecord.run('calculateProjectedXDateWithDuration', range.startDate, true, eventRecord.duration);\n                    }\n                    else {\n                        dd.startDate = range.startDate;\n                        dd.endDatee = range.endDate;\n                    }\n                }\n                dd.timeDiff = timeDiff;\n            }\n        }\n        const positionDirty = dd.dirty = dd.dirty || lastDragStartDate - dd.startDate !== 0;\n        if (dd.valid) {\n            // If it's fully outside, we don't allow them to drop it - the event would disappear from their control.\n            if (me.constrainDragToTimeline && (dd.endDate <= client.timeAxis.startDate || dd.startDate >= client.timeAxis.endDate)) {\n                dd.valid           = false;\n                dd.context.message = me.L('L{EventDrag.noDropOutsideTimeline}');\n            }\n            else if (positionDirty || dd.externalDropTarget) {\n                // Used to rely on faulty code above that would not be valid initially. With that changed we ignore\n                // checking validity here on drag start, which is detected by not having a pageX\n                const result = dd.externalDragValidity = !event || (info.pageX && me.checkDragValidity(dd, event));\n                if (!result || typeof result === 'boolean') {\n                    dd.valid           = result !== false;\n                    dd.context.message = '';\n                }\n                else {\n                    dd.valid           = result.valid !== false;\n                    dd.context.message = result.message;\n                }\n            }\n            else {\n                // Apply cached value from external drag validation\n                dd.valid = dd.externalDragValidity !== false && dd.externalDragValidity?.valid !== false;\n            }\n        }\n        else {\n            dd.valid = false;\n        }\n        dd.context.valid = dd.valid;\n    }\n    suspendRecordElementRedrawing(record, suspend = true) {\n        this.suspendElementRedrawing(this.getRecordElement(record), suspend);\n        record.instanceMeta(this.client).retainElement = suspend;\n    }\n    resumeRecordElementRedrawing(record) {\n        this.suspendRecordElementRedrawing(record, false);\n    }\n    suspendElementRedrawing(element, suspend = true) {\n        if (element) {\n            element.retainElement = suspend;\n        }\n    }\n    resumeElementRedrawing(element) {\n        this.suspendElementRedrawing(element, false);\n    }\n    /**\n     * Initializes drag data (dates, constraints, dragged events etc). Called when drag starts.\n     * @private\n     * @param info\n     * @returns {*}\n     */\n    getDragData(info) {\n        const\n            me                = this,\n            { client, drag }  = me,\n            productDragData   = me.setupProductDragData(info),\n            {\n                record,\n                eventBarEls,\n                draggedEntities\n            }                 = productDragData,\n            { startEvent }    = drag,\n            timespan          = record.isAssignment ? record.event : record,\n            origStart         = timespan.startDate,\n            origEnd           = timespan.endDate,\n            timeAxis          = client.timeAxis,\n            startsOutsideView = origStart < timeAxis.startDate,\n            endsOutsideView   = origEnd > timeAxis.endDate,\n            multiSelect       = client.isSchedulerBase ? client.multiEventSelect : client.selectionMode.multiSelect,\n            coordinate        = me.getCoordinate(timespan, info.element, [info.elementStartX, info.elementStartY]),\n            clientCoordinate  = me.getCoordinate(timespan, info.element, [info.startClientX, info.startClientY]);\n        me.suspendRecordElementRedrawing(record);\n        // prevent elements from being released when out of view\n        draggedEntities.forEach(record => me.suspendRecordElementRedrawing(record));\n        // Make sure the dragged event is selected (no-op for already selected)\n        // Preserve other selected events if ctrl/meta is pressed\n        if (record.isAssignment) {\n            client.selectAssignment(record, startEvent.ctrlKey && multiSelect);\n        }\n        else {\n            client.selectEvent(record, startEvent.ctrlKey && multiSelect);\n        }\n        const dragData = {\n            context : info,\n            ...productDragData,\n            sourceDate       : startsOutsideView ? origStart : client.getDateFromCoordinate(coordinate),\n            screenSourceDate : client.getDateFromCoordinate(clientCoordinate, null, false),\n            startDate : origStart,\n            endDate   : origEnd,\n            timeDiff  : 0,\n            origStart,\n            origEnd,\n            startsOutsideView,\n            endsOutsideView,\n            duration     : origEnd - origStart,\n            browserEvent : startEvent // So we can know if SHIFT/CTRL was pressed\n        };\n        eventBarEls.forEach(el => el.classList.remove('b-sch-event-hover', 'b-active'));\n        if (eventBarEls.length > 1) {\n            // RelatedElements are secondary elements moved by the same delta as the grabbed element\n            info.relatedElements = eventBarEls.slice(1);\n        }\n        return dragData;\n    }\n    //endregion\n    //region Constraints\n    // private\n    setupConstraints(constrainRegion, elRegion, tickSize, constrained) {\n        const\n            me        = this,\n            xTickSize = !me.showExactDropPosition && tickSize > 1 ? tickSize : 0,\n            yTickSize = 0;\n        // If `constrained` is false then we have no date constraints and should constrain mouse position to scheduling area\n        // else we have specified date constraints and so we should limit mouse position to smaller region inside of constrained region using offsets and width.\n        if (constrained) {\n            me.setXConstraint(constrainRegion.left, constrainRegion.right - elRegion.width, xTickSize);\n        }\n        // And if not constrained, release any constraints from the previous drag.\n        else {\n            // minX being true means allow the start to be before the time axis.\n            // maxX being true means allow the end to be after the time axis.\n            me.setXConstraint(true, true, xTickSize);\n        }\n        me.setYConstraint(constrainRegion.top, constrainRegion.bottom - elRegion.height, yTickSize);\n    }\n    updateYConstraint(eventRecord, resourceRecord) {\n        const\n            me          = this,\n            { client }  = me,\n            { context } = me.drag,\n            tickSize    = client.timeAxisViewModel.snapPixelAmount;\n        // If we're dragging when the vertical size is recalculated by the host grid,\n        // we must update our Y constraint unless we are locked in the Y axis.\n        if (context && !me.drag.lockY) {\n            let constrainRegion;\n            // This calculates a relative region which the DragHelper uses within its outerElement\n            if (me.constrainDragToTimeline) {\n                constrainRegion = client.getScheduleRegion(resourceRecord, eventRecord);\n            }\n            // Not constraining to timeline.\n            // Unusual configuration, but this must mean no Y constraining.\n            else {\n                me.setYConstraint(null, null, tickSize);\n                return;\n            }\n            me.setYConstraint(\n                constrainRegion.top,\n                constrainRegion.bottom - context.element.offsetHeight,\n                tickSize\n            );\n        }\n        else {\n            me.setYConstraint(null, null, tickSize);\n        }\n    }\n    setXConstraint(iLeft, iRight, iTickSize) {\n        const { drag } = this;\n        drag.minX = iLeft;\n        drag.maxX = iRight;\n    }\n    setYConstraint(iUp, iDown, iTickSize) {\n        const { drag } = this;\n        drag.minY = iUp;\n        drag.maxY = iDown;\n    }\n    //endregion\n    //region Other stuff\n    adjustStartDate(startDate, timeDiff) {\n        const rounded = this.client.timeAxis.roundDate(\n            new Date(startDate - 0 + timeDiff),\n            this.client.snapRelativeToEventStartDate ? startDate : false\n        );\n        return this.constrainStartDate(rounded);\n    }\n    resolveStartEndDates(draggedElement) {\n        const\n            timeline        = this.currentOverClient,\n            { timeAxis }    = timeline,\n            proxyRect       = Rectangle.from(draggedElement.querySelector(timeline.eventInnerSelector), timeline.timeAxisSubGridElement),\n            dd              = this.dragData,\n            [record]        = dd.draggedEntities,\n            eventRecord     = record.isAssignment ? record.event : record,\n            fillSnap        = timeline.fillTicks && timeline.snapRelativeToEventStartDate,\n            // Cannot calculate using `eventRecord.duration`, since it in Pro does not include non-working time\n            totalDurationMS = eventRecord.endDate - eventRecord.startDate;\n        // Non-continuous time axis will return null instead of date for a rectangle outside of the view unless\n        // told to estimate date.\n        // When using fillTicks, we need exact dates for calculations below\n        let {\n            start : startDate, end : endDate\n        } = timeline.getStartEndDatesFromRectangle(proxyRect, fillSnap ? null : 'round', totalDurationMS, true);\n        // if dragging is out of timeAxis rect bounds, we will not be able to get dates\n        if (startDate && endDate) {\n            // When filling ticks, proxy start does not represent actual start date.\n            // Need to compensate to get expected result\n            if (fillSnap) {\n                const\n                    // Events offset into the tick, in MS\n                    offsetMS = eventRecord.startDate - DateHelper.startOf(eventRecord.startDate, timeAxis.unit),\n                    // Proxy length in MS\n                    proxyMS  = endDate - startDate,\n                    // Part of proxy that is \"filled\" and needs to be removed\n                    offsetPx = (offsetMS / proxyMS) * proxyRect.width;\n                // Deflate top for vertical mode, left for horizontal mode\n                proxyRect.deflate(offsetPx, 0, 0, offsetPx);\n                const proxyStart = proxyRect.getStart(timeline.rtl, !timeline.isVertical);\n                // Get date from offset proxy start\n                startDate = timeline.getDateFromCoordinate(proxyStart, null, true);\n                // Snap relative to event start date\n                startDate = timeAxis.roundDate(startDate, eventRecord.startDate);\n            }\n            startDate = this.adjustStartDate(startDate, 0);\n            if (!dd.startsOutsideView) {\n                // Make sure we didn't target a start date that is filtered out, if we target last hour cell (e.g. 21:00) of\n                // the time axis, and the next tick is 08:00 following day. Trying to drop at end of 21:00 cell should target start of next cell\n                if (!timeAxis.dateInAxis(startDate, false)) {\n                    const tick = timeAxis.getTickFromDate(startDate);\n                    if (tick >= 0) {\n                        startDate = timeAxis.getDateFromTick(tick);\n                    }\n                }\n                endDate = startDate && DateHelper.add(startDate, totalDurationMS);\n            }\n            else if (!dd.endsOutsideView) {\n                startDate = endDate && DateHelper.add(endDate, -totalDurationMS);\n            }\n        }\n        return {\n            startDate,\n            endDate\n        };\n    }\n    //endregion\n    //region Dragtip\n    /**\n     * Gets html to display in tooltip while dragging event. Uses clockTemplate to display start & end dates.\n     */\n    getTipHtml() {\n        const\n            me                                      = this,\n            { dragData, client, tooltipTemplate }   = me,\n            { startDate, endDate, draggedEntities } = dragData,\n            startText                               = client.getFormattedDate(startDate),\n            endText                                 = client.getFormattedEndDate(endDate, startDate),\n            { valid, message, element, dragProxy }  = dragData.context,\n            tipTarget                               = dragProxy ? dragProxy.firstChild : element,\n            dragged                                 = draggedEntities[0],\n            // Scheduler always drags assignments\n            timeSpanRecord                          = dragged.isTask ? dragged : dragged.event;\n        // Keep align target up to date in case of derendering the target when\n        // dragged outside render window, and re-entry into the render window.\n        me.tip.lastAlignSpec.target = tipTarget;\n        return tooltipTemplate({\n            valid,\n            startDate,\n            endDate,\n            startText,\n            endText,\n            dragData,\n            message                                : message || '',\n            [client.scheduledEventName + 'Record'] : timeSpanRecord,\n            startClockHtml                         : me.clockTemplate.template({\n                date : startDate,\n                text : startText,\n                cls  : 'b-sch-tooltip-startdate'\n            }),\n            endClockHtml : timeSpanRecord.isMilestone\n                ? ''\n                : me.clockTemplate.template({\n                    date : endDate,\n                    text : endText,\n                    cls  : 'b-sch-tooltip-enddate'\n                })\n        });\n    }\n    //endregion\n    //region Configurable\n    // Constrain to time slot means lockX if we're horizontal, otherwise lockY\n    updateConstrainDragToTimeSlot(value) {\n        const axis = this.client.isHorizontal ? 'lockX' : 'lockY';\n        if (this.drag) {\n            this.drag[axis] = value;\n        }\n    }\n    // Constrain to resource means lockY if we're horizontal, otherwise lockX\n    updateConstrainDragToResource(constrainDragToResource) {\n        const me = this;\n        if (me.drag) {\n            const\n                { constrainDragToTimeSlot } = me,\n                { isHorizontal }            = me.client;\n            if (constrainDragToResource) {\n                me.constrainDragToTimeline = true;\n            }\n            me.drag.lockY = isHorizontal ? constrainDragToResource : constrainDragToTimeSlot;\n            me.drag.lockX = isHorizontal ? constrainDragToTimeSlot : constrainDragToResource;\n        }\n    }\n    updateConstrainDragToTimeline(constrainDragToTimeline) {\n        if (!this.isConfiguring) {\n            Object.assign(this.drag, {\n                cloneTarget   : !constrainDragToTimeline,\n                dragWithin    : constrainDragToTimeline ? null : document.body,\n                scrollManager : constrainDragToTimeline ? this.client.scrollManager : null\n            });\n        }\n    }\n    constrainStartDate(startDate) {\n        const\n            { dragData }        = this,\n            { dateConstraints } = dragData,\n            scheduleableRecord  = dragData.eventRecord || dragData.taskRecord || dragData.draggedEntities[0];\n        if (dateConstraints?.start) {\n            startDate = DateHelper.max(dateConstraints.start, startDate);\n        }\n        if (dateConstraints?.end) {\n            startDate = DateHelper.min(new Date(dateConstraints.end - scheduleableRecord.durationMS), startDate);\n        }\n        return startDate;\n    }\n    //endregion\n    //region Product specific, implemented in subclasses\n    getElementFromContext(context) {\n        return context.grabbed || context.dragProxy || context.element;\n    }\n    // Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.\n    getRelatedRecords(record) {\n        return [];\n    }\n    getMinimalDragData(info, event) {\n        // Can be overridden in subclass\n        return {};\n    }\n    // Check if element can be dropped at desired location\n    isValidDrop(dragData) {\n        throw new Error('Implement in subclass');\n    }\n    // Similar to the fn above but also calls validatorFn\n    checkDragValidity(dragData) {\n        throw new Error('Implement in subclass');\n    }\n    // Update records being dragged\n    updateRecords(context) {\n        throw new Error('Implement in subclass');\n    }\n    // Determine if an element can be dragged\n    isElementDraggable(el, event) {\n        throw new Error('Implement in subclass');\n    }\n    // Get coordinate for correct axis\n    getCoordinate(record, element, coord) {\n        throw new Error('Implement in subclass');\n    }\n    // Product specific drag data\n    setupProductDragData(info) {\n        throw new Error('Implement in subclass');\n    }\n    // Product specific data in drag context\n    getProductDragContext(dd) {\n        throw new Error('Implement in subclass');\n    }\n    getRecordElement(record) {\n        throw new Error('Implement in subclass');\n    }\n    //endregion\n}\nDragBase._$name = 'DragBase';", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Draggable from '../../Core/mixin/Draggable.js';\nimport Droppable from '../../Core/mixin/Droppable.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../tooltip/ClockTemplate.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport BrowserHelper from '../../Core/helper/BrowserHelper.js';\nimport TimeSpan from '../../Scheduler/model/TimeSpan.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\n/**\n * @module Scheduler/feature/EventResize\n */\nconst tipAlign = {\n    top    : 'b-t',\n    right  : 'b100-t100',\n    bottom : 't-b',\n    left   : 'b0-t0'\n};\n/**\n * Feature that allows resizing an event by dragging its end.\n *\n * By default it displays a tooltip with the new start and end dates, formatted using\n * {@link Scheduler/view/mixin/TimelineViewPresets#config-displayDateFormat}.\n *\n * ## Customizing the resize tooltip\n *\n * To show custom HTML in the tooltip, please see the {@link #config-tooltipTemplate} config. Example:\n *\n * ```javascript\n * eventResize : {\n *     // A minimal end date tooltip\n *     tooltipTemplate : ({ record, endDate }) => {\n *         return DateHelper.format(endDate, 'MMM D');\n *     }\n * }\n * ```\n *\n * This feature is **enabled** by default\n *\n * This feature is extended with a few overrides by the Gantt's `TaskResize` feature.\n *\n * This feature updates the event's `startDate` or `endDate` live in order to leverage the\n * rendering pathway to always yield a correct appearance. The changes are done in\n * {@link Core.data.Model#function-beginBatch batched} mode so that changes do not become\n * eligible for data synchronization or propagation until the operation is completed.\n *\n * {@inlineexample Scheduler/feature/EventResize.js}\n *\n * @demo Scheduler/basic\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype eventResize\n * @feature\n */\nexport default class EventResize extends InstancePlugin.mixin(Draggable, Droppable) {\n    //region Events\n    /**\n     * Fired on the owning Scheduler before resizing starts. Return `false` to prevent the action.\n     * @event beforeEventResize\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the resize starts within\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Fires on the owning Scheduler when event resizing starts\n     * @event eventResizeStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the resize starts within\n     * @param {MouseEvent} event Browser event\n     */\n    /**\n     * Fires on the owning Scheduler on each resize move event\n     * @event eventPartialResize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     * @param {Date} startDate\n     * @param {Date} endDate\n     * @param {HTMLElement} element\n     */\n    /**\n     * Fired on the owning Scheduler to allow implementer to prevent immediate finalization by setting\n     * `data.context.async = true` in the listener, to show a confirmation popup etc\n     *\n     * ```javascript\n     *  scheduler.on('beforeeventresizefinalize', ({context}) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // async code don't forget to call finalize\n     *          context.finalize();\n     *      }, 1000);\n     *  })\n     * ```\n     *\n     * @event beforeEventResizeFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Object} context\n     * @param {Scheduler.model.EventModel} context.eventRecord Event record being resized\n     * @param {Date} context.startDate New startDate (changed if resizing start side)\n     * @param {Date} context.endDate New endDate (changed if resizing end side)\n     * @param {Date} context.originalStartDate Start date before resize\n     * @param {Date} context.originalEndDate End date before resize\n     * @param {Boolean} context.async Set true to handle resize asynchronously (e.g. to wait for user confirmation)\n     * @param {Function} context.finalize Call this method to finalize resize. This method accepts one argument:\n     *                   pass `true` to update records, or `false`, to ignore changes\n     * @param {Event} event Browser event\n     */\n    /**\n     * Fires on the owning Scheduler after the resizing gesture has finished.\n     * @event eventResizeEnd\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Boolean} changed Shows if the record has been changed by the resize action\n     * @param {Scheduler.model.EventModel} eventRecord Event record being resized\n     */\n    //endregion\n    //region Config\n    static get $name() {\n        return 'EventResize';\n    }\n    static get configurable() {\n        return {\n            draggingItemCls : 'b-sch-event-wrap-resizing',\n            resizingItemInnerCls : 'b-sch-event-resizing',\n            /**\n             * Use left handle when resizing. Only applies when owning client's `direction` is 'horizontal'\n             * @config {Boolean}\n             * @default\n             */\n            leftHandle : true,\n            /**\n             * Use right handle when resizing. Only applies when owning client's `direction` is 'horizontal'\n             * @config {Boolean}\n             * @default\n             */\n            rightHandle : true,\n            /**\n             * Use top handle when resizing. Only applies when owning client's direction` is 'vertical'\n             * @config {Boolean}\n             * @default\n             */\n            topHandle : true,\n            /**\n             * Use bottom handle when resizing. Only applies when owning client's `direction` is 'vertical'\n             * @config {Boolean}\n             * @default\n             */\n            bottomHandle : true,\n            /**\n             * Resizing handle size to use instead of that determined by CSS\n             * @config {Number}\n             * @deprecated Since 5.2.7. The handle size is determined from responsive CSS. Will be removed in 6.0\n             */\n            handleSize : null,\n            /**\n             * Automatically shrink virtual handles when available space < handleSize. The virtual handles will\n             * decrease towards width/height 1, reserving space between opposite handles to for example leave room for\n             * dragging. To configure reserved space, see {@link #config-reservedSpace}.\n             * @config {Boolean}\n             * @default false\n             */\n            dynamicHandleSize : true,\n            /**\n             * Set to true to allow resizing to a zero-duration span\n             * @config {Boolean}\n             * @default false\n             */\n            allowResizeToZero : null,\n            /**\n             * Room in px to leave unoccupied by handles when shrinking them dynamically (see\n             * {@link #config-dynamicHandleSize}).\n             * @config {Number}\n             * @default\n             */\n            reservedSpace : 5,\n            /**\n             * Resizing handle size to use instead of that determined by CSS on touch devices\n             * @config {Number}\n             * @deprecated Since 5.2.7. The handle size is determined from responsive CSS. Will be removed in 6.0\n             */\n            touchHandleSize : null,\n            /**\n             * The amount of pixels to move pointer/mouse before it counts as a drag operation.\n             * @config {Number}\n             * @default\n             */\n            dragThreshold : 0,\n            dragTouchStartDelay : 0,\n            draggingClsSelector : '.b-timeline-base',\n            /**\n             * `false` to not show a tooltip while resizing\n             * @config {Boolean}\n             * @default\n             */\n            showTooltip : true,\n            /**\n             * true to see exact event length during resizing\n             * @config {Boolean}\n             * @default\n             */\n            showExactResizePosition : false,\n            /**\n             * An empty function by default, but provided so that you can perform custom validation on\n             * the item being resized. Return true if the new duration is valid, false to signal that it is not.\n             * @param {Object} context The resize context, contains the record & dates.\n             * @param {Scheduler.model.TimeSpan} context.record The record being resized.\n             * @param {Date} context.startDate The new start date.\n             * @param {Date} context.endDate The new start date.\n             * @param {Date} context.originalStartDate Start date before resize\n             * @param {Date} context.originalEndDate End date before resize\n             * @param {Event} event The browser Event object\n             * @returns {Boolean}\n             * @config {Function}\n             */\n            validatorFn : () => true,\n            /**\n             * `this` reference for the validatorFn\n             * @config {Object}\n             */\n            validatorFnThisObj : null,\n            /**\n             * Setting this property may change the configuration of the {@link #config-tip}, or\n             * cause it to be destroyed if `null` is passed.\n             *\n             * Reading this property returns the Tooltip instance.\n             * @member {Core.widget.Tooltip|TooltipConfig} tip\n             */\n            /**\n             * If a tooltip is required to illustrate the resize, specify this as `true`, or a config\n             * object for the {@link Core.widget.Tooltip}.\n             * @config {Core.widget.Tooltip|TooltipConfig}\n             */\n            tip : {\n                $config : ['lazy', 'nullify'],\n                value   : {\n                    autoShow                 : false,\n                    axisLock                 : true,\n                    trackMouse               : false,\n                    updateContentOnMouseMove : true,\n                    hideDelay                : 0\n                }\n            },\n            /**\n             * A template function returning the content to show during a resize operation.\n             *\n             * @config {Function} tooltipTemplate\n             * @param {Object} context A context object\n             * @param {Date} context.startDate New start date\n             * @param {Date} context.endDate New end date\n             * @param {Scheduler.model.TimeSpan} context.record The record being resized\n             * @param {String} context.startClockHtml Predefined HTML to show the start time\n             * @param {String} context.endClockHtml Predefined HTML to show the end time\n             * @returns {String} String representing the HTML markup\n             */\n            tooltipTemplate : context => `\n                <div class=\"b-sch-tip-${context.valid ? 'valid' : 'invalid'}\">\n                    ${context.startClockHtml}\n                    ${context.endClockHtml}\n                    <div class=\"b-sch-tip-message\">${context.message}</div>\n                </div>\n            `,\n            ignoreSelector : '.b-sch-terminal',\n            dragActiveCls  : 'b-resizing-event',\n            /**\n             * Locks the layout during drag resize, overriding the default behaviour that uses the same rendering\n             * pathway for drag resize as for already existing events.\n             *\n             * This more closely resembles the behaviour of versions prior to 4.2.0.\n             *\n             * Enabling this config also leads to cheaper resizing, only the resized event's resources are refreshed\n             * during the operation.\n             *\n             * {@note}Note that this will be the default behaviour starting with version 6.0.0{/@note}\n             *\n             * @config {Boolean}\n             */\n            lockLayout : VersionHelper.checkVersion('core', '6.0', '>=')\n        };\n    }\n    static get pluginConfig() {\n        return {\n            chain : ['render', 'onEventDataGenerated', 'isEventElementDraggable']\n        };\n    }\n    //endregion\n    //region Init & destroy\n    doDestroy() {\n        super.doDestroy();\n        this.dragging?.destroy();\n    }\n    render() {\n        const\n            me         = this,\n            { client } = me;\n        // Only active when in these items\n        me.dragSelector = me.dragItemSelector = client.eventSelector;\n        // Set up elements and listeners\n        me.dragRootElement = me.dropRootElement = client.timeAxisSubGridElement;\n        // Drag only in time dimension\n        me.dragLock = client.isVertical ? 'y' : 'x';\n    }\n    // Prevent event dragging when it happens over a resize handle\n    isEventElementDraggable(eventElement, eventRecord, el, event) {\n        const\n            me = this,\n            eventResizable = eventRecord?.resizable;\n        // ALLOW event drag:\n        // - if resizing is disabled or event is not resizable\n        // - if it's a milestone Milestones cannot be resized\n        if (me.disabled || !eventResizable || eventRecord.isMilestone) {\n            return true;\n        }\n        // not over the event handles\n        return ((eventResizable !== true && eventResizable !== 'start') || !me.isOverStartHandle(event, eventElement)) &&\n            ((eventResizable !== true && eventResizable !== 'end') || !me.isOverEndHandle(event, eventElement));\n    }\n    // Called for each event during render, allows manipulation of render data.\n    onEventDataGenerated({ eventRecord, wrapperCls, cls }) {\n        if (eventRecord === this.dragging?.context?.eventRecord) {\n            wrapperCls['b-active'] =\n                wrapperCls[this.draggingItemCls] =\n                wrapperCls['b-over-resize-handle'] =\n                cls['b-resize-handle'] =\n                cls[this.resizingItemInnerCls] = 1;\n        }\n    }\n    // Sneak a first peek at the drag event to put necessary date values into the context\n    onDragPointerMove(event) {\n        const\n            {\n                client,\n                dragging\n            }          = this,\n            {\n                visibleDateRange,\n                isHorizontal\n            }          = client,\n            rtl        = isHorizontal && client.rtl,\n            dimension  = isHorizontal ? 'X' : 'Y',\n            pageScroll = globalThis[`page${dimension}Offset`],\n            coord      = event[`page${dimension}`] + (dragging.context?.offset || 0),\n            clientRect = Rectangle.from(client.timeAxisSubGridElement, null, true),\n            startCoord = clientRect.getStart(rtl, isHorizontal),\n            endCoord   = clientRect.getEnd(rtl, isHorizontal);\n        let date = client.getDateFromCoord({ coord, local : false });\n        if (rtl) {\n            // If we're dragging off the start side, fix at the visible startDate\n            if (coord - pageScroll > startCoord) {\n                date = visibleDateRange.startDate;\n            }\n            // If we're dragging off the end side, fix at the visible endDate\n            else if (coord < endCoord) {\n                date = visibleDateRange.endDate;\n            }\n        }\n        // If we're dragging off the start side, fix at the visible startDate\n        else if (coord - pageScroll < startCoord) {\n            date = visibleDateRange.startDate;\n        }\n        // If we're dragging off the end side, fix at the visible endDate\n        else if (coord - pageScroll > endCoord) {\n            date = visibleDateRange.endDate;\n        }\n        dragging.clientStartCoord = startCoord;\n        dragging.clientEndCoord = endCoord;\n        dragging.date = date;\n        super.onDragPointerMove(event);\n    }\n    /**\n     * Returns true if a resize operation is active\n     * @property {Boolean}\n     * @readonly\n     */\n    get isResizing() {\n        return Boolean(this.dragging);\n    }\n    beforeDrag(drag) {\n        const\n            { client }     = this,\n            eventRecord    = client.resolveTimeSpanRecord(drag.itemElement),\n            resourceRecord = !client.isGanttBase && client.resolveResourceRecord(client.isVertical ? drag.startEvent : drag.itemElement);\n        // Events not part of project are transient records in a Gantt display store and not meant to be modified\n        if (this.disabled || client.readOnly || resourceRecord?.readOnly ||\n            (eventRecord && (eventRecord.readOnly || !(eventRecord.project || eventRecord.isOccurrence))) ||\n            super.beforeDrag(drag) === false) {\n            return false;\n        }\n        drag.mousedownDate = drag.date = client.getDateFromCoordinate(drag.event[`page${client.isHorizontal ? 'X' : 'Y'}`], null, false);\n        // trigger beforeEventResize or beforeTaskResize depending on product\n        return this.triggerBeforeResize(drag);\n    }\n    dragStart(drag) {\n        const\n            me             = this,\n            {\n                client,\n                tip\n            }              = me,\n            {\n                startEvent,\n                itemElement\n            }              = drag,\n            name           = client.scheduledEventName,\n            eventRecord    = client.resolveEventRecord(itemElement),\n            {\n                isBatchUpdating,\n                wrapStartDate,\n                wrapEndDate\n            } = eventRecord,\n            useEventBuffer = client.features.eventBuffer?.enabled,\n            eventStartDate = isBatchUpdating ? eventRecord.get('startDate') : eventRecord.startDate,\n            eventEndDate   = isBatchUpdating ? eventRecord.get('endDate') : eventRecord.endDate,\n            horizontal     = me.dragLock === 'x',\n            rtl            = horizontal && client.rtl,\n            draggingEnd    = me.isOverEndHandle(startEvent, itemElement),\n            toSet          = draggingEnd ? 'endDate' : 'startDate',\n            wrapToSet      = !useEventBuffer ? null : draggingEnd ? 'wrapEndDate' : 'wrapStartDate',\n            otherEnd       = draggingEnd ? 'startDate' : 'endDate',\n            setMethod      = draggingEnd ? 'setEndDate' : 'setStartDate',\n            setOtherMethod = draggingEnd ? 'setStartDate' : 'setEndDate',\n            elRect         = Rectangle.from(itemElement),\n            startCoord     = horizontal ? startEvent.clientX : startEvent.clientY,\n            endCoord       = draggingEnd ? elRect.getEnd(rtl, horizontal) : elRect.getStart(rtl, horizontal),\n            context        = drag.context = {\n                eventRecord,\n                element        : itemElement,\n                timespanRecord : eventRecord,\n                taskRecord     : eventRecord,\n                owner          : me,\n                valid          : true,\n                oldValue       : draggingEnd ? eventEndDate : eventStartDate,\n                startDate      : eventStartDate,\n                endDate        : eventEndDate,\n                offset         : useEventBuffer ? 0 : endCoord - startCoord,\n                edge           : horizontal ? (draggingEnd ? 'right' : 'left') : (draggingEnd ? 'bottom' : 'top'),\n                finalize       : me.finalize,\n                event          : drag.event,\n                // these two are public\n                originalStartDate : eventStartDate,\n                originalEndDate   : eventEndDate,\n                wrapStartDate,\n                wrapEndDate,\n                draggingEnd,\n                toSet,\n                wrapToSet,\n                otherEnd,\n                setMethod,\n                setOtherMethod\n            };\n        // The record must know that it is being resized.\n        eventRecord.meta.isResizing = true;\n        client.element.classList.add(...me.dragActiveCls.split(' '));\n        // During this batch we want the client's UI to update itself using the proposed changes\n        // Only if startDrag has not already done it\n        if (!client.listenToBatchedUpdates) {\n            client.beginListeningForBatchedUpdates();\n        }\n        // No changes must get through to data.\n        // Only if startDrag has not already started the batch\n        if (!isBatchUpdating) {\n            me.beginEventRecordBatch(eventRecord);\n        }\n        // Let products do their specific stuff\n        me.setupProductResizeContext(context, startEvent);\n        // Trigger eventResizeStart or taskResizeStart depending on product\n        // Subclasses (like EventDragCreate) won't actually fire this event.\n        me.triggerEventResizeStart(`${name}ResizeStart`, {\n            [`${name}Record`] : eventRecord,\n            event             : startEvent,\n            ...me.getResizeStartParams(context)\n        }, context);\n        // Scheduler renders assignments, Gantt renders Tasks\n        context.resizedRecord = client.resolveAssignmentRecord?.(context.element) || eventRecord;\n        if (tip) {\n            // Tip needs to be shown first for getTooltipTarget to be able to measure anchor size\n            tip.show();\n            tip.align = tipAlign[context.edge];\n            tip.showBy(me.getTooltipTarget(drag));\n        }\n    }\n    // Subclasses may override this\n    triggerBeforeResize(drag) {\n        const\n            { client }  = this,\n            eventRecord = client.resolveTimeSpanRecord(drag.itemElement);\n        return client.trigger(\n            `before${client.capitalizedEventName}Resize`,\n            {\n                [`${client.scheduledEventName}Record`] : eventRecord,\n                event                                  : drag.event,\n                ...this.getBeforeResizeParams({ event : drag.startEvent, element : drag.itemElement })\n            }\n        );\n    }\n    // Subclasses may override this\n    triggerEventResizeStart(eventType, event, context) {\n        this.client.trigger(eventType, event);\n        // Hook for features that needs to react on resize start\n        this.client[`after${StringHelper.capitalize(eventType)}`]?.(context, event);\n    }\n    triggerEventResizeEnd(eventType, event) {\n        this.client.trigger(eventType, event);\n    }\n    triggerEventPartialResize(eventType, event) {\n        // Trigger eventPartialResize or taskPartialResize depending on product\n        this.client.trigger(eventType, event);\n    }\n    triggerBeforeEventResizeFinalize(eventType, event) {\n        this.client.trigger(eventType, event);\n    }\n    dragEnter(drag) {\n        // We only respond to our own DragContexts\n        return drag.context?.owner === this;\n    }\n    resizeEventPartiallyInternal(eventRecord, context) {\n        const\n            { client } = this,\n            { toSet } = context;\n        if (client.features.eventBuffer?.enabled) {\n            if (toSet === 'startDate') {\n                const diff = context.startDate.getTime() - context.originalStartDate.getTime();\n                eventRecord.wrapStartDate = new Date(context.wrapStartDate.getTime() + diff);\n            }\n            else if (toSet === 'endDate') {\n                const diff = context.endDate.getTime() - context.originalEndDate.getTime();\n                eventRecord.wrapEndDate = new Date(context.wrapEndDate.getTime() + diff);\n            }\n        }\n        eventRecord.set(toSet, context[toSet]);\n    }\n    applyDateConstraints(date, eventRecord, context) {\n        const\n            minDate = context.dateConstraints?.start,\n            maxDate = context.dateConstraints?.end;\n        // Keep desired date within constraints\n        if (minDate || maxDate) {\n            date = DateHelper.constrain(date, minDate, maxDate);\n            context.snappedDate = DateHelper.constrain(context.snappedDate, minDate, maxDate);\n        }\n        return date;\n    }\n    // Override the draggable interface so that we can update the bar while dragging outside\n    // the Draggable's rootElement (by default it stops notifications when outside rootElement)\n    moveDrag(drag) {\n        const\n            me          = this,\n            {\n                client,\n                tip\n            }           = me,\n            horizontal  = me.dragLock === 'x',\n            dimension   = horizontal ? 'X' : 'Y',\n            name        = client.scheduledEventName,\n            {\n                visibleDateRange,\n                enableEventAnimations,\n                timeAxis,\n                weekStartDay\n            }           = client,\n            rtl         = horizontal && client.rtl,\n            {\n                resolutionUnit,\n                resolutionIncrement\n            }           = timeAxis,\n            {\n                event,\n                context\n            }           = drag,\n            {\n                eventRecord,\n                oldValue\n            }           = context,\n            offset      = context.offset * (rtl ? -1 : 1),\n            {\n                isOccurrence\n            }           = eventRecord,\n            eventStart  = eventRecord.get('startDate'),\n            eventEnd    = eventRecord.get('endDate'),\n            coord       = event[`client${dimension}`] + offset,\n            clientRect  = Rectangle.from(client.timeAxisSubGridElement, null, true),\n            startCoord  = clientRect.getStart(rtl, horizontal),\n            endCoord    = clientRect.getEnd(rtl, horizontal);\n        context.event = event;\n        // If this is the last move event recycled because of a scroll, refresh the date\n        if (event.isScroll) {\n            drag.date = client.getDateFromCoordinate(event[`page${dimension}`] + offset, null, false);\n        }\n        let crossedOver, avoidedZeroSize,\n            // Use the value set up in onDragPointerMove by default\n            { date } = drag,\n            {\n                toSet,\n                otherEnd,\n                draggingEnd\n            } = context;\n        if (rtl) {\n            // If we're dragging off the start side, fix at the visible startDate\n            if (coord > startCoord) {\n                date = drag.date = visibleDateRange.startDate;\n            }\n            // If we're dragging off the end side, fix at the visible endDate\n            else if (coord < endCoord) {\n                date = drag.date = visibleDateRange.endDate;\n            }\n        }\n        // If we're dragging off the start side, fix at the visible startDate\n        else if (coord < startCoord) {\n            date = drag.date = visibleDateRange.startDate;\n        }\n        // If we're dragging off the end side, fix at the visible endDate\n        else if (coord > endCoord) {\n            date = drag.date = visibleDateRange.endDate;\n        }\n        // Detect crossover which some subclasses might need to process\n        if (toSet === 'endDate') {\n            if (date < eventStart) {\n                crossedOver = -1;\n            }\n        }\n        else {\n            if (date > eventEnd) {\n                crossedOver = 1;\n            }\n        }\n        // If we dragged the dragged end over to the opposite side of the start end.\n        // Some subclasses allow this and need to respond. EventDragCreate does this.\n        if (crossedOver && me.onDragEndSwitch) {\n            me.onDragEndSwitch(context, date, crossedOver);\n            otherEnd = context.otherEnd;\n            toSet = context.toSet;\n        }\n        if (client.snapRelativeToEventStartDate) {\n            date = timeAxis.roundDate(date, oldValue);\n        }\n        // The displayed and eventual data value\n        context.snappedDate = DateHelper.round(date, timeAxis.resolution, null, weekStartDay);\n        const duration = DateHelper.diff(date, context[otherEnd], resolutionUnit) * (draggingEnd ? -1 : 1);\n        // Narrower than half resolutionIncrement will abort drag creation, set flag to have UI reflect this\n        if (me.isEventDragCreate) {\n            context.tooNarrow = duration < resolutionIncrement / 2;\n        }\n        // The mousepoint date means that the duration is less than resolutionIncrement resolutionUnits.\n        // Ensure that the dragged end is at least resolutionIncrement resolutionUnits from the other end.\n        else if (duration < resolutionIncrement) {\n            // Snap to zero if allowed\n            if (me.allowResizeToZero) {\n                context.snappedDate = date = context[otherEnd];\n            }\n            else {\n                const\n                    sign        = otherEnd === 'startDate' ? 1 : -1,\n                    snappedDate = timeAxis.roundDate(DateHelper.add(eventRecord.get(otherEnd), resolutionIncrement * sign, resolutionUnit));\n                // Only snap if dragging bigger; multiplying by sign handles reverse drag direction (leftward)\n                if ((snappedDate - oldValue) * sign < 0 || (date - oldValue) * sign > 0) {\n                    context.snappedDate = snappedDate;\n                }\n                else {\n                    // Fix snappedDate to stay on original date and prevent `date` making event smaller than starting value\n                    date = sign > 0 ? DateHelper.max(date, oldValue) : DateHelper.min(date, oldValue);\n                    context.snappedDate = oldValue;\n                }\n                avoidedZeroSize = true;\n            }\n        }\n        // take dateConstraints into account\n        date = me.applyDateConstraints(date, eventRecord, context);\n        // If the mouse move has changed the detected date\n        if (!context.date || date - context.date || avoidedZeroSize) {\n            context.date = date;\n            // The validityFn needs to see the proposed value.\n            // Consult our snap config to see if we should be dragging in snapped mode\n            context[toSet] = me.showExactResizePosition || client.timeAxisViewModel.snap ? context.snappedDate : date;\n            // Snapping would take it to zero size - this is not allowed in drag resizing.\n            context.valid = me.allowResizeToZero || context[toSet] - context[toSet === 'startDate' ? 'endDate' : 'startDate'] !== 0;\n            // If the date to push into the record is new...\n            if (eventRecord.get(toSet) - context[toSet]) {\n                context.valid = me.checkValidity(context, event);\n                context.message = '';\n                if (context.valid && typeof context.valid !== 'boolean') {\n                    context.message = context.valid.message;\n                    context.valid = context.valid.valid;\n                }\n                // If users returns nothing, that's interpreted as valid\n                context.valid = (context.valid !== false);\n                if (context.valid) {\n                    const partialResizeEvent = {\n                        [`${name}Record`] : eventRecord,\n                        startDate         : eventStart,\n                        endDate           : eventEnd,\n                        element           : drag.itemElement,\n                        context\n                    };\n                    // Update the event we are about to fire and the context *before* we update the record\n                    partialResizeEvent[toSet] = context[toSet];\n                    // Trigger eventPartialResize or taskPartialResize depending on product\n                    me.triggerEventPartialResize(`${name}PartialResize`, partialResizeEvent);\n                    // An occurrence must have a store to announce its batched changes through.\n                    // They must usually never have a store - they are transient, but we\n                    // need to update the UI.\n                    if (isOccurrence) {\n                        eventRecord.stores.push(client.eventStore);\n                    }\n                    // Update the eventRecord.\n                    // Use setter rather than accessor so that in a Project, the entity's\n                    // accessor doesn't propagate the change to the whole project.\n                    // Scheduler must not animate this.\n                    client.enableEventAnimations = false;\n                    this.resizeEventPartiallyInternal(eventRecord, context);\n                    client.enableEventAnimations = enableEventAnimations;\n                    if (isOccurrence) {\n                        eventRecord.stores.length = 0;\n                    }\n                }\n                // Flag drag created too narrow events as invalid late, want all code above to execute for them\n                // to get the proper size rendered\n                if (context.tooNarrow) {\n                    context.valid = false;\n                }\n            }\n        }\n        if (tip) {\n            // In case of edge flip (EventDragCreate), the align point may change\n            tip.align = tipAlign[context.edge];\n            tip.alignTo(me.getTooltipTarget(drag));\n        }\n        super.moveDrag(drag);\n    }\n    dragEnd(drag) {\n        const { context } = drag;\n        if (context) {\n            context.event = drag.event;\n        }\n        if (drag.aborted) {\n            context?.finalize(false);\n        }\n        // 062_resize.t.js specifies that if drag was not started but the mouse has moved,\n        // the eventresizestart and eventresizeend must fire\n        else if (!this.isEventDragCreate && !drag.started && !EventHelper.getPagePoint(drag.event).equals(EventHelper.getPagePoint(drag.startEvent))) {\n            this.dragStart(drag);\n            this.cleanup(drag.context, false);\n        }\n    }\n    async dragDrop({ context, event }) {\n        // Set the start/end date, whichever we were dragging\n        // to the correctly rounded value before updating.\n        context[context.toSet] = context.snappedDate;\n        const\n            {\n                client\n            } = this,\n            {\n                startDate,\n                endDate\n            } = context;\n        let modified;\n        this.tip?.hide();\n        context.valid = startDate && endDate && (this.allowResizeToZero || (endDate - startDate > 0)) && // Input sanity check\n            (context[context.toSet] - context.oldValue) && // Make sure dragged end changed\n            context.valid !== false;\n        if (context.valid) {\n            // Seems to be a valid resize operation, ask outside world if anyone wants to take control over the finalizing,\n            // to show a confirm dialog prior to applying the new values. Triggers beforeEventResizeFinalize or\n            // beforeTaskResizeFinalize depending on product\n            this.triggerBeforeEventResizeFinalize(`before${client.capitalizedEventName}ResizeFinalize`, { context, event, [`${client.scheduledEventName}Record`] : context.eventRecord });\n            modified = true;\n        }\n        // If a handler has set the async flag, it means that they are going to finalize\n        // the operation at some time in the future, so we should not call it.\n        if (!context.async) {\n            await context.finalize(modified);\n        }\n    }\n    // This is called with a thisObj of the context object\n    // We set \"me\" to the owner, and \"context\" to the thisObj so that it\n    // reads as if it were a method of this class.\n    async finalize(updateRecord) {\n        const\n            me      = this.owner,\n            context = this,\n            {\n                eventRecord,\n                oldValue,\n                toSet\n            }       = context,\n            {\n                snapRelativeToEventStartDate,\n                timeAxis\n            }       = me.client;\n        let wasChanged = false;\n        if (updateRecord) {\n            if (snapRelativeToEventStartDate) {\n                context[toSet] = context.snappedDate = timeAxis.roundDate(context.date, oldValue);\n            }\n            // Each product updates the record differently\n            wasChanged = await me.internalUpdateRecord(context, eventRecord);\n        }\n        else {\n            // Reverts the changes, a batchedUpdate event will fire which will reset the UI\n            me.cancelEventRecordBatch(eventRecord);\n            // Manually trigger redraw of occurrences since they are not part of any stores\n            if (eventRecord.isOccurrence) {\n                eventRecord.resources.forEach(resource => me.client.repaintEventsForResource(resource));\n            }\n        }\n        if (!me.isDestroyed) {\n            me.cleanup(context, wasChanged);\n        }\n    }\n    // This is always called on drop or abort.\n    cleanup(context, changed) {\n        const\n            me               = this,\n            { client }       = me,\n            {\n                element,\n                eventRecord\n            }                = context,\n            name             = client.scheduledEventName;\n        // The record must know that it is being resized.\n        eventRecord.meta.isResizing = false;\n        client.endListeningForBatchedUpdates();\n        me.tip?.hide();\n        me.unHighlightHandle(element);\n        client.element.classList.remove(...me.dragActiveCls.split(' '));\n        // if (dependencies) {\n        //     // When resizing is done and mouse is over element, we show terminals\n        //     if (element.matches(':hover')) {\n        //         dependencies.showTerminals(eventRecord, element);\n        //     }\n        // }\n        // Triggers eventResizeEnd or taskResizeEnd depending on product\n        me.triggerEventResizeEnd(`${name}ResizeEnd`, {\n            changed,\n            [`${name}Record`] : eventRecord,\n            ...me.getResizeEndParams(context)\n        });\n    }\n    async internalUpdateRecord(context, timespanRecord) {\n        const\n            { client }     = this,\n            { generation } = timespanRecord;\n        // Special handling of occurrences, they need normalization since that is not handled by engine at the moment\n        if (timespanRecord.isOccurrence) {\n            client.endListeningForBatchedUpdates();\n            // If >1 level deep, just unwind one level.\n            timespanRecord[timespanRecord.batching > 1 ? 'endBatch' : 'cancelBatch']();\n            timespanRecord.set(TimeSpan.prototype.inSetNormalize.call(timespanRecord, {\n                startDate : context.startDate,\n                endDate   : context.endDate\n            }));\n        }\n        else {\n            const toSet = {\n                [context.toSet] : context[context.toSet]\n            };\n            // Collect any changes (except the start/end date and duration) that happened during the resize operation\n            const batchChanges = Object.assign({}, timespanRecord.meta.batchChanges);\n            delete batchChanges[context.toSet];\n            delete batchChanges.duration;\n            // If we have the Engine available, consult it to calculate a corrected duration.\n            // Adjust the dragged date point to conform with the calculated duration.\n            if (timespanRecord.isEntity) {\n                const\n                    {\n                        startDate,\n                        endDate,\n                        draggingEnd\n                    } = context;\n                // Fix the duration according to the Entity's rules.\n                context.duration = toSet.duration = timespanRecord.run('calculateProjectedDuration', startDate, endDate);\n                // Fix the dragged date point according to the Entity's rules.\n                toSet[context.toSet] = timespanRecord.run('calculateProjectedXDateWithDuration', draggingEnd ? startDate : endDate, draggingEnd, context.duration);\n                const setOtherEnd = !timespanRecord[context.otherEnd];\n                // Set all values, start and end in case they had never been set\n                // ie, we're now scheduling a previously unscheduled event.\n                if (setOtherEnd) {\n                    toSet[context.otherEnd] = context[context.otherEnd];\n                }\n                // Update the record to its final correct state using *batched changes*\n                // These will *not* be propagated, it's just to force the dragged event bar\n                // into its corrected shape before the real changes which will propagate are applied below.\n                // We MUST do it like this because the final state may not be a net change if the changes\n                // got rejected, and in that case, the engine will not end up firing any change events.\n                timespanRecord.set(toSet);\n                // Quit listening for batchedUpdate *before* we cancel the batch so that the\n                // change events from the revert do not update the UI.\n                client.endListeningForBatchedUpdates();\n                this.cancelEventRecordBatch(timespanRecord);\n                // Clear estimated wrap date, exact wrap date will be calculated when referred to from renderer\n                if (client.features.eventBuffer?.enabled) {\n                    timespanRecord[context.wrapToSet] = null;\n                }\n                const promisesToWait = [];\n                // Really update the data after cancelling the batch\n                if (setOtherEnd) {\n                    promisesToWait.push(timespanRecord[context.setOtherMethod](toSet[context.otherEnd], false));\n                }\n                promisesToWait.push(timespanRecord[context.setMethod](toSet[context.toSet], false));\n                await Promise.all(promisesToWait);\n            }\n            else {\n                client.endListeningForBatchedUpdates();\n                this.cancelEventRecordBatch(timespanRecord);\n                timespanRecord[context.setMethod](toSet[context.toSet], false);\n            }\n            if (Object.keys(batchChanges).length) {\n                timespanRecord.set(batchChanges);\n            }\n        }\n        // wait for project data update\n        await client.project.commitAsync();\n        // If the record has been changed\n        return timespanRecord.generation !== generation;\n    }\n    onDragItemMouseMove(event) {\n        if (event.pointerType !== 'touch' && !this.handleSelector) {\n            this.checkResizeHandles(event);\n        }\n    }\n    /**\n     * Check if mouse is over a resize handle (virtual). If so, highlight.\n     * @private\n     * @param {MouseEvent} event\n     */\n    checkResizeHandles(event) {\n        const\n            me           = this,\n            { overItem } = me;\n        // mouse over a target element and allowed to resize?\n        if (overItem && !me.client.readOnly && (!me.allowResize || me.allowResize(overItem, event))) {\n            const eventRecord = me.client.resolveTimeSpanRecord(overItem);\n            if (eventRecord?.readOnly) {\n                return;\n            }\n            if (me.isOverAnyHandle(event, overItem)) {\n                me.highlightHandle(); // over handle\n            }\n            else {\n                me.unHighlightHandle(); // not over handle\n            }\n        }\n    }\n    onDragItemMouseLeave(event, oldOverItem) {\n        this.unHighlightHandle(oldOverItem);\n    }\n    /**\n     * Highlights handles (applies css that changes cursor).\n     * @private\n     */\n    highlightHandle() {\n        const\n            {\n                overItem : item,\n                client\n            }      = this,\n            handleTargetElement = item.syncIdMap?.[client.scheduledEventName] ?? item.querySelector(client.eventInnerSelector);\n        // over a handle, add cls to change cursor\n        handleTargetElement.classList.add('b-resize-handle');\n        item.classList.add('b-over-resize-handle');\n    }\n    /**\n     * Unhighlight handles (removes css).\n     * @private\n     */\n    unHighlightHandle(item = this.overItem) {\n        if (item) {\n            const\n                me    = this,\n                inner = item.syncIdMap?.[me.client.scheduledEventName] ?? item.querySelector(me.client.eventInnerSelector);\n            if (inner) {\n                inner.classList.remove('b-resize-handle', me.resizingItemInnerCls);\n            }\n            item.classList.remove('b-over-resize-handle', me.draggingItemCls);\n        }\n    }\n    isOverAnyHandle(event, target) {\n        return this.isOverStartHandle(event, target) || this.isOverEndHandle(event, target);\n    }\n    isOverStartHandle(event, target) {\n        return this.getHandleRect('start', event, target)?.contains(EventHelper.getPagePoint(event));\n    }\n    isOverEndHandle(event, target) {\n        return this.getHandleRect('end', event, target)?.contains(EventHelper.getPagePoint(event));\n    }\n    getHandleRect(side, event, eventEl) {\n        if (this.overItem) {\n            eventEl = event.target.closest(`.${this.client.eventCls}`) || eventEl.querySelector(`.${this.client.eventCls}`);\n            if (!eventEl) {\n                return;\n            }\n            const\n                me              = this,\n                start           = side === 'start',\n                { client }      = me,\n                rtl             = Boolean(client.rtl),\n                axis            = me.dragLock,\n                horizontal      = axis === 'x',\n                dim             = horizontal ? 'width' : 'height',\n                handleSpec      = `${horizontal ? (start && !rtl) ? 'left' : 'right' : start ? 'top' : 'bottom'}Handle`,\n                { offsetWidth } = eventEl,\n                timespanRecord  = client.resolveTimeSpanRecord(eventEl),\n                resizable       = timespanRecord?.isResizable,\n                eventRect       = Rectangle.from(eventEl),\n                result          = eventRect.clone(),\n                handleStyle     = globalThis.getComputedStyle(eventEl, ':before'),\n                // Larger draggable zones on pure touch devices with no mouse\n                touchHandleSize = (!me.handleSelector && !BrowserHelper.isHoverableDevice) ? me.touchHandleSize : undefined,\n                handleSize      = touchHandleSize || me.handleSize || parseFloat(handleStyle[dim]),\n                handleVisThresh = me.handleVisibilityThreshold || 2 * me.handleSize,\n                centerGap       = me.dynamicHandleSize ? me.reservedSpace / 2 : 0,\n                deflateArgs     = [0, 0, 0, 0];\n            // To decide if we are over a valid handle, we first check disabled state\n            // Then this.leftHandle/this.rightHandle/this.topHandle/this.bottomHandle\n            // Then whether there's enough event bar width to accommodate separate handles\n            // Then whether the event itself allows resizing at the specified side.\n            if (!me.disabled && me[handleSpec] && (offsetWidth >= handleVisThresh || me.dynamicHandleSize) && (resizable === true || resizable === side)) {\n                const oppositeEnd = (!horizontal && !start) || (horizontal && (rtl  === start));\n                if (oppositeEnd) {\n                    // Push handle start point to other end and clip result to other end\n                    result[axis] += (eventRect[dim] - handleSize);\n                    deflateArgs[horizontal ? 3 : 0] = eventRect[dim] / 2 + centerGap;\n                }\n                else {\n                    deflateArgs[horizontal ? 1 : 2] = eventRect[dim] / 2 + centerGap;\n                }\n                // Deflate the event bar rectangle to encapsulate 2px less than the side's own half\n                // so that we can constrain the handle zone to be inside its own half when bar is small.\n                eventRect.deflate(...deflateArgs);\n                result[dim] = handleSize;\n                // Constrain handle rectangles to each side so that they can never collide.\n                // Each handle is constrained into its own half.\n                result.constrainTo(eventRect);\n                // Zero sized handles cannot be hovered\n                if (result[dim]) {\n                    return result;\n                }\n            }\n        }\n    }\n    setupDragContext(event) {\n        const me = this;\n        // Only start a drag if we are over a handle zone.\n        if (me.overItem && me.isOverAnyHandle(event, me.overItem) && me.isElementResizable(me.overItem, event)) {\n            const result = super.setupDragContext(event);\n            result.scrollManager = me.client.scrollManager;\n            return result;\n        }\n    }\n    changeHandleSize() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Handle size is from CSS');\n    }\n    changeTouchHandleSize() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Handle size is from CSS');\n    }\n    changeTip(tip, oldTip) {\n        const me = this;\n        if (!me.showTooltip) {\n            return null;\n        }\n        if (tip) {\n            if (tip.isTooltip) {\n                tip.owner = me;\n            }\n            else {\n                tip = Tooltip.reconfigure(oldTip, Tooltip.mergeConfigs({\n                    id : me.tipId\n                }, tip, {\n                    getHtml : me.getTipHtml.bind(me),\n                    owner   : me.client\n                }, me.tip), {\n                    owner    : me,\n                    defaults : {\n                        type : 'tooltip'\n                    }\n                });\n            }\n            tip.ion({\n                innerhtmlupdate : 'updateDateIndicator',\n                thisObj         : me\n            });\n            me.clockTemplate = new ClockTemplate({\n                scheduler : me.client\n            });\n        }\n        else if (oldTip) {\n            oldTip.destroy();\n            me.clockTemplate?.destroy();\n        }\n        return tip;\n    }\n    //endregion\n    //region Events\n    isElementResizable(element, event) {\n        const\n            me             = this,\n            { client }     = me,\n            timespanRecord = client.resolveTimeSpanRecord(element);\n        if (client.readOnly) {\n            return false;\n        }\n        let resizable = timespanRecord?.isResizable;\n        // Not resizable if the mousedown is on a resizing handle of\n        // a percent bar.\n        const\n            handleHoldingElement = element?.syncIdMap[client.scheduledEventName] ?? element,\n            handleEl             = event.target.closest('[class$=\"-handle\"]');\n        if (!resizable || (handleEl && handleEl !== handleHoldingElement)) {\n            return false;\n        }\n        element = event.target.closest(me.dragSelector);\n        if (!element) {\n            return false;\n        }\n        const\n            startsOutside = element.classList.contains('b-sch-event-startsoutside'),\n            endsOutside   = element.classList.contains('b-sch-event-endsoutside');\n        if (resizable === true) {\n            if (startsOutside && endsOutside) {\n                return false;\n            }\n            else if (startsOutside) {\n                resizable = 'end';\n            }\n            else if (endsOutside) {\n                resizable = 'start';\n            }\n            else {\n                return me.isOverStartHandle(event, element) || me.isOverEndHandle(event, element);\n            }\n        }\n        if (\n            (startsOutside && resizable === 'start') ||\n            (endsOutside && resizable === 'end')\n        ) {\n            return false;\n        }\n        if (\n            (me.isOverStartHandle(event, element) && resizable === 'start') ||\n            (me.isOverEndHandle(event, element) && resizable === 'end')\n        ) {\n            return true;\n        }\n        return false;\n    }\n    updateDateIndicator() {\n        const\n            { clockTemplate } = this,\n            {\n                eventRecord,\n                draggingEnd,\n                snappedDate\n            }                 = this.dragging.context,\n            startDate         = draggingEnd ? eventRecord.get('startDate') : snappedDate,\n            endDate           = draggingEnd ? snappedDate : eventRecord.get('endDate'),\n            { element }       = this.tip;\n        clockTemplate.updateDateIndicator(element.querySelector('.b-sch-tooltip-startdate'), startDate);\n        clockTemplate.updateDateIndicator(element.querySelector('.b-sch-tooltip-enddate'), endDate);\n    }\n    getTooltipTarget({ itemElement, context }) {\n        const\n            me      = this,\n            { rtl } = me.client,\n            target  = Rectangle.from(itemElement, null, true);\n        if (me.dragLock === 'x') {\n            // Align to the dragged edge of the proxy, and then bump right so that the anchor aligns perfectly.\n            if ((!rtl && context.edge === 'right') || (rtl && context.edge === 'left')) {\n                target.x = target.right - 1;\n            }\n            else {\n                target.x -= me.tip.anchorSize[0] / 2;\n            }\n            target.width = me.tip.anchorSize[0] / 2;\n        }\n        else {\n            // Align to the dragged edge of the proxy, and then bump bottom so that the anchor aligns perfectly.\n            if (context.edge === 'bottom') {\n                target.y = target.bottom - 1;\n            }\n            target.height = me.tip.anchorSize[1] / 2;\n        }\n        return { target };\n    }\n    basicValidityCheck(context, event) {\n        return context.startDate &&\n            (context.endDate > context.startDate || this.allowResizeToZero) &&\n            this.validatorFn.call(this.validatorFnThisObj || this, context, event);\n    }\n    //endregion\n    //region Tooltip\n    getTipHtml({ tip }) {\n        const\n            me = this,\n            {\n                startDate,\n                endDate,\n                toSet,\n                snappedDate,\n                valid,\n                message = '',\n                timespanRecord\n            }  = me.dragging.context;\n        // Empty string hides the tip - we get called before the Resizer, so first call will be empty\n        if (!startDate || !endDate) {\n            return tip.html;\n        }\n        // Set whichever one we are moving\n        const tipData = {\n            record  : timespanRecord,\n            valid,\n            message,\n            startDate,\n            endDate,\n            [toSet] : snappedDate\n        };\n        // Format the two ends. This has to be done outside of the object initializer\n        // because they use properties that are only in the tipData object.\n        tipData.startText = me.client.getFormattedDate(tipData.startDate);\n        tipData.endText = me.client.getFormattedDate(tipData.endDate);\n        tipData.startClockHtml = me.clockTemplate.template({\n            date : tipData.startDate,\n            text : tipData.startText,\n            cls  : 'b-sch-tooltip-startdate'\n        });\n        tipData.endClockHtml = me.clockTemplate.template({\n            date : tipData.endDate,\n            text : tipData.endText,\n            cls  : 'b-sch-tooltip-enddate'\n        });\n        return me.tooltipTemplate(tipData);\n    }\n    //endregion\n    //region Product specific, may be overridden in subclasses\n    beginEventRecordBatch(eventRecord) {\n        eventRecord.beginBatch();\n    }\n    cancelEventRecordBatch(eventRecord) {\n        // Reverts the changes, a batchedUpdate event will fire which will reset the UI\n        eventRecord.cancelBatch();\n    }\n    getBeforeResizeParams(context) {\n        const { client } = this;\n        return {\n            resourceRecord : client.resolveResourceRecord(client.isVertical ? context.event : context.element)\n        };\n    }\n    getResizeStartParams(context) {\n        return {\n            resourceRecord : context.resourceRecord\n        };\n    }\n    getResizeEndParams(context) {\n        return {\n            resourceRecord : context.resourceRecord,\n            event          : context.event\n        };\n    }\n    setupProductResizeContext(context, event) {\n        const\n            { client }       = this,\n            { element }      = context,\n            eventRecord      = client.resolveEventRecord(element),\n            resourceRecord   = client.resolveResourceRecord?.(element),\n            assignmentRecord = client.resolveAssignmentRecord?.(element);\n        Object.assign(context, {\n            eventRecord,\n            taskRecord      : eventRecord,\n            resourceRecord,\n            assignmentRecord,\n            dateConstraints : client.getDateConstraints?.(resourceRecord, eventRecord)\n        });\n    }\n    checkValidity({ startDate, endDate, eventRecord, resourceRecord }) {\n        const { client } = this;\n        if (!client.allowOverlap) {\n            if (eventRecord.resources.some(resource => !client.isDateRangeAvailable(startDate, endDate, eventRecord, resource))) {\n                return {\n                    valid   : false,\n                    message : this.L('L{EventDrag.eventOverlapsExisting}')\n                };\n            }\n        }\n        return this.basicValidityCheck(...arguments);\n    }\n    get tipId() {\n        return `${this.client.id}-event-resize-tip`;\n    }\n    //endregion\n}\nEventResize._$name = 'EventResize'; GridFeatureManager.registerFeature(EventResize, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventResize, false, 'ResourceHistogram');\n", "import Base from '../../../Core/Base.js';\n/**\n * @module Scheduler/feature/mixin/TaskEditTransactional\n */\n/**\n * Mixin adding live updates support\n *\n * @mixin\n */\nexport default Target => class TaskEditTransactional extends (Target || Base) {\n    static get $name() {\n        return 'TaskEditTransactional';\n    }\n    captureStm(force) {\n        if (this.client.transactionalFeaturesEnabled) {\n            super.captureStm();\n            return this.startStmTransaction(force);\n        }\n        else {\n            super.captureStm(force);\n        }\n    }\n    freeStm(commitOrReject) {\n        if (this.hasStmCapture || !this.client.transactionalFeaturesEnabled) {\n            return super.freeStm(commitOrReject);\n        }\n    }\n    async startStmTransaction(startRecordingEarly) {\n        if (this.client.transactionalFeaturesEnabled) {\n            await this.startFeatureTransaction(startRecordingEarly);\n        }\n        else {\n            super.startStmTransaction();\n        }\n    }\n    commitStmTransaction() {\n        if (this.client.transactionalFeaturesEnabled) {\n            return this.finishFeatureTransaction();\n        }\n        else {\n            super.commitStmTransaction();\n        }\n    }\n    async rejectStmTransaction() {\n        if (this.client.transactionalFeaturesEnabled) {\n            this.rejectFeatureTransaction();\n        }\n        else {\n            await super.rejectStmTransaction();\n        }\n    }\n};\n", "import Base from '../../../Core/Base.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\nimport IdHelper from '../../../Core/helper/IdHelper.js';\n/**\n * @module Scheduler/feature/mixin/TransactionalFeature\n */\n/**\n * Feature defining methods to lock the view for a time of a user action\n * @internal\n * @mixin\n */\nexport default Target => class TransactionalFeature extends AttachToProjectMixin(Target || Base) {\n    static $name = 'TransactionalFeature';\n    //#region AttachToProjectMixin implementation\n    detachFromProject(project) {\n        this.rejectFeatureTransaction();\n        super.detachFromProject(project);\n    }\n    //#endregion\n    getStmCapture() {\n        const result = super.getStmCapture();\n        result._editorPromiseResolve = this._editorPromiseResolve;\n        return result;\n    }\n    applyStmCapture(stmCapture) {\n        super.applyStmCapture(stmCapture);\n        this._editorPromiseResolve = stmCapture._editorPromiseResolve;\n    }\n    async startFeatureTransaction() {\n        if (!this.client.transactionalFeaturesEnabled) {\n            return;\n        }\n        const\n            me          = this,\n            { project } = me.client,\n            { stm }     = project;\n        // Await previous promise chain to resolve\n        let chainResolved;\n        if (me.hasStmCapture) {\n            stm.startTransaction();\n        }\n        else {\n            chainResolved = project.queue(() => project.commitAsync());\n        }\n        project.queue(() => {\n            if (!me.hasStmCapture) {\n                me._stmInitiallyDisabled = stm.disabled;\n                me._stmInitiallyAutoRecord = stm.autoRecord;\n                if (stm.isRecording) {\n                    stm.stopTransaction();\n                }\n                else if (me._stmInitiallyDisabled) {\n                    stm.enable();\n                }\n                // Disable autoRecord to avoid finishing transaction after a timeout\n                stm.autoRecord = false;\n            }\n            if (!stm.isRecording) {\n                // We need to wrap cell editing into own transaction to be able to apply user changes last\n                stm.startTransaction();\n            }\n            me.trigger?.('featureTransactionStart');\n            // Put an empty promise to the queue to pause it\n            return new Promise(resolve => me._editorPromiseResolve = resolve);\n        });\n        await chainResolved;\n    }\n    rejectFeatureTransaction() {\n        if (!this.client.transactionalFeaturesEnabled) {\n            return;\n        }\n        const\n            me = this,\n            { stm } = me.client.project;\n        me._editorPromiseResolve?.();\n        me._editorPromiseResolve = null;\n        stm.isRecording && stm.rejectTransaction();\n        if (!me.hasStmCapture && me._stmInitiallyDisabled != null) {\n            stm.disabled = me._stmInitiallyDisabled;\n            stm.autoRecord = me._stmInitiallyAutoRecord;\n        }\n        me.trigger('featureTransactionReject');\n    }\n    async finishFeatureTransaction(afterApplyStashCallback) {\n        if (!this.client.transactionalFeaturesEnabled) {\n            return;\n        }\n        const\n            me            = this,\n            { project }   = me.client,\n            { stm }       = project;\n        // In case there is a commit pending, we need to wait to not suspend more events than we should\n        if (!project.isEngineReady()) {\n            await project.commitAsync();\n        }\n        const\n            transactionId = stm.stash(),\n            {\n                _stmInitiallyDisabled,\n                _stmInitiallyAutoRecord\n            }             = me,\n            // This id is used to help debugging concurrent promises\n            id            = IdHelper.generateId('featureTransaction');\n        me._editorPromiseResolve?.();\n        me._editorPromiseResolve = null;\n        if (!me.isDestroying) {\n            me.trigger('featureTransactionFinalizeStart', { id });\n        }\n        return project.queue(async() => {\n            stm?.applyStash(transactionId);\n            await afterApplyStashCallback?.();\n            await project.commitAsync?.();\n            if (stm.isRecording) {\n                stm.stopTransaction();\n            }\n            if (!me.hasStmCapture && stm && !stm.isDestroying && _stmInitiallyDisabled != null) {\n                stm.disabled = _stmInitiallyDisabled;\n                stm.autoRecord = _stmInitiallyAutoRecord;\n            }\n            me.trigger?.('featureTransactionFinalized', { id });\n        });\n    }\n};\n", "import EventResize from '../EventResize.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport Draggable from '../../../Core/mixin/Draggable.js';\nimport TaskEditStm from '../mixin/TaskEditStm.js';\nimport TaskEditTransactional from '../mixin/TaskEditTransactional.js';\nimport TransactionalFeature from '../mixin/TransactionalFeature.js';\n/**\n * @module Scheduler/feature/base/DragCreateBase\n */\nconst getDragCreateDragDistance = function(event) {\n    // Do not allow the drag to begin if the taskEdit feature (if present) is in the process\n    // of canceling. We must wait for it to have cleaned up its data manipulations before\n    // we can add the new, drag-created record\n    if (this.source?.client.features.taskEdit?._canceling) {\n        return false;\n    }\n    return EventHelper.getDistanceBetween(this.startEvent, event);\n};\n/**\n * Base class for EventDragCreate (Scheduler) and TaskDragCreate (Gantt) features. Contains shared code. Not to be used directly.\n *\n * @extends Scheduler/feature/EventResize\n */\nexport default class DragCreateBase extends EventResize.mixin(\n    TaskEditStm,\n    TransactionalFeature,\n    TaskEditTransactional\n) {\n    //region Config\n    static configurable = {\n        /**\n         * true to show a time tooltip when dragging to create a new event\n         * @config {Boolean}\n         * @default\n         */\n        showTooltip : true,\n        /**\n         * Number of pixels the drag target must be moved before dragging is considered to have started. Defaults to 2.\n         * @config {Number}\n         * @default\n         */\n        dragTolerance : 2,\n        // used by gantt to only allow one task per row\n        preventMultiple : false,\n        dragTouchStartDelay : 300,\n        /**\n         * `this` reference for the validatorFn\n         * @config {Object}\n         */\n        validatorFnThisObj : null,\n        tipTemplate : data => `\n            <div class=\"b-sch-tip-${data.valid ? 'valid' : 'invalid'}\">\n                ${data.startClockHtml}\n                ${data.endClockHtml}\n                <div class=\"b-sch-tip-message\">${data.message}</div>\n            </div>\n        `,\n        dragActiveCls : 'b-dragcreating'\n    };\n    static pluginConfig = {\n        chain  : ['render', 'onEventDataGenerated'],\n        before : ['onElementContextMenu']\n    };\n    construct(scheduler, config) {\n        if (config?.showTooltip === false) {\n            config.tip = null;\n        }\n        super.construct(...arguments);\n    }\n    //endregion\n    changeValidatorFn(validatorFn) {\n        // validatorFn property is used by the EventResize base to validate each mousemove\n        // We change the property name to createValidatorFn\n        this.createValidatorFn = validatorFn;\n    }\n    render() {\n        const\n            me         = this,\n            { client } = me;\n        // Set up elements and listeners\n        me.dragRootElement = me.dropRootElement = client.timeAxisSubGridElement;\n        // Drag only in time dimension\n        me.dragLock = client.isVertical ? 'y' : 'x';\n    }\n    onDragEndSwitch(context) {\n        const\n            { client }                = this,\n            { enableEventAnimations } = client,\n            {\n                eventRecord,\n                draggingEnd\n            }                         = context,\n            horizontal                = this.dragLock === 'x',\n            { initialDate }           = this.dragging;\n        // Setting the new opposite end should not animate\n        client.enableEventAnimations = false;\n        // Zero duration at the moment of the flip\n        eventRecord.set({\n            startDate : initialDate,\n            endDate   : initialDate\n        });\n        // We're switching to dragging the start\n        if (draggingEnd) {\n            Object.assign(context, {\n                endDate        : initialDate,\n                toSet          : 'startDate',\n                otherEnd       : 'endDate',\n                setMethod      : 'setStartDate',\n                setOtherMethod : 'setEndDate',\n                edge           : horizontal ? 'left' : 'top'\n            });\n        }\n        else {\n            Object.assign(context, {\n                startDate      : initialDate,\n                toSet          : 'endDate',\n                otherEnd       : 'startDate',\n                setMethod      : 'setEndDate',\n                setOtherMethod : 'setStartDate',\n                edge           : horizontal ? 'right' : 'bottom'\n            });\n        }\n        context.draggingEnd = this.draggingEnd = !draggingEnd;\n        client.enableEventAnimations = enableEventAnimations;\n    }\n    beforeDrag(drag) {\n        const\n            me                       = this,\n            result                   = super.beforeDrag(drag),\n            { pan, eventDragSelect } = me.client.features;\n        // Superclass's handler may also veto\n        if (result !== false && (\n            // used by gantt to only allow one task per row\n            (me.preventMultiple && !me.isRowEmpty(drag.rowRecord)) ||\n            me.disabled ||\n            // If Pan is enabled, it has right of way\n            (pan && !pan.disabled) ||\n            // If EventDragSelect is enabled, it has right of way\n            (eventDragSelect && !eventDragSelect.disabled)\n        )) {\n            return false;\n        }\n        // Prevent drag select if drag-creating, could collide otherwise\n        // (reset by GridSelection)\n        me.client.preventDragSelect = true;\n        return result;\n    }\n    startDrag(drag) {\n        const result = super.startDrag(drag);\n        // Returning false means operation is aborted.\n        if (result !== false) {\n            const { context } = drag;\n            // Date to flip around when changing direction\n            drag.initialDate = context.eventRecord.get(this.draggingEnd ? 'startDate' : 'endDate');\n            this.client.trigger('dragCreateStart', {\n                proxyElement   : drag.element,\n                eventElement   : drag.element,\n                eventRecord    : context.eventRecord,\n                resourceRecord : context.resourceRecord\n            });\n            // We are always dragging the exact edge of the event element.\n            drag.context.offset   = 0;\n            drag.context.oldValue = drag.mousedownDate;\n        }\n        return result;\n    }\n    // Used by our EventResize superclass to know whether the drag point is the end or the beginning.\n    isOverEndHandle() {\n        return this.draggingEnd;\n    }\n    setupDragContext(event) {\n        const { client } = this;\n        // Only mousedown on an empty cell can initiate drag-create\n        if (client.matchScheduleCell(event.target)) {\n            const resourceRecord = client.resolveResourceRecord(event)?.$original;\n            // And there must be a resource backing the cell.\n            if (resourceRecord && !resourceRecord.isSpecialRow) {\n                // Skip the EventResize's setupDragContext. We want the base one.\n                const\n                    result      = Draggable().prototype.setupDragContext.call(this, event),\n                    scrollables = [];\n                if (client.isVertical) {\n                    scrollables.push({\n                        element   : client.scrollable.element,\n                        direction : 'vertical'\n                    });\n                }\n                else {\n                    scrollables.push({\n                        element   : client.timeAxisSubGrid.scrollable.element,\n                        direction : 'horizontal'\n                    });\n                }\n                result.scrollManager = client.scrollManager;\n                result.monitoringConfig = { scrollables };\n                result.resourceRecord = result.rowRecord = resourceRecord;\n                // We use a special method to get the distance moved.\n                // If the TaskEdit feature is still in its canceling phase, then\n                // it returns false which inhibits the start of the drag-create\n                // until the cancelation is complete.\n                result.getDistance = getDragCreateDragDistance;\n                return result;\n            }\n        }\n    }\n    async dragDrop({ context, event }) {\n        // Set the start/end date, whichever we were dragging\n        // to the correctly rounded value before updating.\n        context[context.toSet] = context.snappedDate;\n        const\n            {\n                client\n            } = this,\n            {\n                startDate,\n                endDate,\n                eventRecord\n            } = context,\n            { generation } = eventRecord;\n        let modified;\n        this.tip?.hide();\n        // Handle https://github.com/bryntum/support/issues/3210.\n        // The issue arises when the mouseup arrives very quickly and the commit kicked off\n        // at event add has not yet completed. If it now completes *after* we finalize\n        // the drag, it will reset the event to its initial state.\n        // If that commit has in fact finished, this will be a no-op\n        await client.project.commitAsync();\n        // If the above commit in fact reset the event back to the initial state, we have to\n        // force the event rendering to bring it back to the currently known context state.\n        if (eventRecord.generation !== generation) {\n            context.eventRecord[context.toSet] = context.oldValue;\n            context.eventRecord[context.toSet] = context[context.toSet];\n        }\n        context.valid = startDate && endDate && (endDate - startDate > 0) && // Input sanity check\n            (context[context.toSet] - context.oldValue) && // Make sure dragged end changed\n            context.valid !== false;\n        if (context.valid) {\n            // Seems to be a valid drag-create operation, ask outside world if anyone wants to take control over the finalizing,\n            // to show a confirm dialog prior to finalizing the create.\n            client.trigger('beforeDragCreateFinalize', {\n                context,\n                event,\n                proxyElement   : context.element,\n                eventElement   : context.element,\n                eventRecord    : context.eventRecord,\n                resourceRecord : context.resourceRecord\n            });\n            modified = true;\n        }\n        // If a handler has set the async flag, it means that they are going to finalize\n        // the operation at some time in the future, so we should not call it.\n        if (!context.async) {\n            await context.finalize(modified);\n        }\n    }\n    updateDragTolerance(dragTolerance) {\n        this.dragThreshold = dragTolerance;\n    }\n    //region Tooltip\n    changeTip(tip, oldTip) {\n        return super.changeTip(!tip || tip.isTooltip ? tip : ObjectHelper.assign({\n            id : `${this.client.id}-drag-create-tip`\n        }, tip), oldTip);\n    }\n    //endregion\n    //region Finalize (create EventModel)\n    // this method is actually called on the `context` object,\n    // so `this` object inside might not be what you think (see `me = this.owner` below)\n    // not clear what was the motivation for such design\n    async finalize(doCreate) {\n        // only call this method once, do not re-enter\n        if (this.finalized) {\n            return;\n        }\n        this.finalized = true;\n        const\n            me                = this.owner,\n            context           = this,\n            completeFinalization = () => {\n                if (!me.isDestroyed) {\n                    me.client.trigger('afterDragCreate', {\n                        proxyElement   : context.element,\n                        eventElement   : context.element,\n                        eventRecord    : context.eventRecord,\n                        resourceRecord : context.resourceRecord\n                    });\n                    me.cleanup(context);\n                }\n            };\n        if (doCreate) {\n            // Call product specific implementation\n            await me.finalizeDragCreate(context);\n            completeFinalization();\n        }\n        // Aborting without going ahead with create - we must deassign and remove the event\n        else {\n            await me.cancelDragCreate(context);\n            me.onAborted?.(context);\n            completeFinalization();\n        }\n    }\n    async cancelDragCreate(context) {\n    }\n    async finalizeDragCreate(context) {\n        // EventResize base class applies final changes to the event record\n        await this.internalUpdateRecord(context, context.eventRecord);\n        const stmCapture = this.getStmCapture();\n        this.client?.trigger('dragCreateEnd', {\n            eventRecord    : context.eventRecord,\n            resourceRecord : context.resourceRecord,\n            event          : context.event,\n            eventElement   : context.element,\n            stmCapture\n        });\n        // Part of the Scheduler API. Triggered by its createEvent method.\n        // Auto-editing features can use this to edit new events.\n        // Note that this may be destroyed by a listener of the previous event.\n        this.client?.trigger('eventAutoCreated', {\n            eventRecord    : context.eventRecord,\n            resourceRecord : context.resourceRecord\n        });\n        return stmCapture.transferred;\n    }\n    cleanup(context) {\n        const\n            { client }      = this,\n            { eventRecord } = context;\n        // Base class's cleanup is not called, we have to clear this flag.\n        // The isCreating flag is only set if the event is to be handed off to the\n        // eventEdit feature and that feature then has responsibility for clearing it.\n        eventRecord.meta.isResizing = false;\n        client.endListeningForBatchedUpdates();\n        this.tip?.hide();\n        client.element.classList.remove(...this.dragActiveCls.split(' '));\n        context.element.parentElement.classList.remove('b-sch-dragcreating');\n    }\n    //endregion\n    //region Events\n    /**\n     * Prevent right click when drag creating\n     * @returns {Boolean}\n     * @private\n     */\n    onElementContextMenu() {\n        if (this.proxy) {\n            return false;\n        }\n    }\n    prepareCreateContextForFinalization(createContext, event, finalize, async = false) {\n        return {\n            ...createContext,\n            async,\n            event,\n            finalize\n        };\n    }\n    // Apply drag create \"proxy\" styling\n    onEventDataGenerated(renderData) {\n        if (this.dragging?.context?.eventRecord === renderData.eventRecord) {\n            // Allow custom styling for drag creation element\n            renderData.wrapperCls['b-sch-dragcreating'] = true;\n            // Styling when drag create will be aborted on drop (because it would yield zero duration)\n            renderData.wrapperCls['b-too-narrow'] = this.dragging.context.tooNarrow;\n        }\n    }\n    //endregion\n    //region Product specific, implemented in subclasses\n    // Empty implementation here. Only base EventResize class triggers this\n    triggerBeforeResize() {}\n    // Empty implementation here. Only base EventResize class triggers this\n    triggerEventResizeStart() {}\n    checkValidity(context, event) {\n        throw new Error('Implement in subclass');\n    }\n    handleBeforeDragCreate(dateTime, event) {\n        throw new Error('Implement in subclass');\n    }\n    isRowEmpty(rowRecord) {\n        throw new Error('Implement in subclass');\n    }\n    //endregion\n}\nDragCreateBase._$name = 'DragCreateBase';", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport Tooltip from '../../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../../tooltip/ClockTemplate.js';\n/**\n * @module Scheduler/feature/base/TooltipBase\n */\n/**\n * Base class for `EventTooltip` (Scheduler) and `TaskTooltip` (Gantt) features. Contains shared code. Not to be used directly.\n *\n * @extends Core/mixin/InstancePlugin\n * @extendsconfigs Core/widget/Tooltip\n */\nexport default class TooltipBase extends InstancePlugin {\n    //region Config\n    static get defaultConfig() {\n        return {\n            /**\n             * Specify true to have tooltip updated when mouse moves, if you for example want to display date at mouse\n             * position.\n             * @config {Boolean}\n             * @default\n             * @category Misc\n             */\n            autoUpdate : false,\n            /**\n             * The amount of time to hover before showing\n             * @config {Number}\n             * @default\n             */\n            hoverDelay : 250,\n            /**\n             * The time (in milliseconds) for which the Tooltip remains visible when the mouse leaves the target.\n             *\n             * May be configured as `false` to persist visible after the mouse exits the target element. Configure it\n             * as 0 to always retrigger `hoverDelay` even when moving mouse inside `fromElement`\n             * @config {Number}\n             * @default\n             */\n            hideDelay : 100,\n            template : null,\n            cls : null,\n            align : {\n                align : 'b-t'\n            },\n            clockTemplate : null,\n            // Set to true to update tooltip contents if record changes while tip is open\n            monitorRecordUpdate : null,\n            testConfig : {\n                hoverDelay : 0\n            }\n        };\n    }\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onInternalPaint']\n        };\n    }\n    //endregion\n    //region Events\n    /**\n     * Triggered before a tooltip is shown. Return `false` to prevent the action.\n     * @preventable\n     * @event beforeShow\n     * @param {Core.widget.Tooltip} source The tooltip being shown.\n     * @param {Scheduler.model.EventModel} source.eventRecord The event record.\n     */\n    /**\n     * Triggered after a tooltip is shown.\n     * @event show\n     * @param {Core.widget.Tooltip} source The tooltip.\n     * @param {Scheduler.model.EventModel} source.eventRecord The event record.\n     */\n    //endregion\n    //region Init\n    construct(client, config) {\n        const me = this;\n        // process initial config into an actual config object\n        config = me.processConfig(config);\n        super.construct(client, config);\n        // Default triggering selector is the client's inner element selector\n        if (!me.forSelector) {\n            me.forSelector = `${client.eventInnerSelector}:not(.b-dragproxy,.b-iscreating)`;\n        }\n        me.clockTemplate = new ClockTemplate({\n            scheduler : client\n        });\n        client.ion({\n            [`before${client.scheduledEventName}drag`] : () => {\n                // Using {} on purpose to not return the promise\n                me.tooltip?.hide();\n            }\n        });\n    }\n    // TooltipBase feature handles special config cases, where user can supply a function to use as template\n    // instead of a normal config object\n    processConfig(config) {\n        if (typeof config === 'function') {\n            return {\n                template : config\n            };\n        }\n        return config;\n    }\n    // override setConfig to process config before applying it (used mainly from ReactScheduler)\n    setConfig(config) {\n        super.setConfig(this.processConfig(config));\n    }\n    doDestroy() {\n        this.destroyProperties('clockTemplate', 'tooltip');\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        if (this.tooltip) {\n            this.tooltip.disabled = disable;\n        }\n        super.doDisable(disable);\n    }\n    //endregion\n    onInternalPaint({ firstPaint }) {\n        if (firstPaint) {\n            const\n                me             = this,\n                { client }     = me,\n                ignoreSelector = `:not(${[\n                    '.b-dragselecting',\n                    '.b-eventeditor-editing',\n                    '.b-taskeditor-editing',\n                    '.b-resizing-event',\n                    '.b-task-percent-bar-resizing-task',\n                    '.b-dragcreating',\n                    `.b-dragging-${client.scheduledEventName}`,\n                    '.b-creating-dependency',\n                    '.b-dragproxy'\n                ].join()})`;\n            me.tooltip?.destroy();\n            /**\n             * A reference to the tooltip instance, which will have a special `eventRecord` property that\n             * you can use to get data from the contextual event record to which this tooltip is related.\n             * @member {Core.widget.Tooltip} tooltip\n             * @readonly\n             * @category Misc\n             */\n            const tip = me.tooltip = new Tooltip({\n                axisLock          : 'flexible',\n                id                : me.tipId || `${me.client.id}-event-tip`,\n                cls               : me.tipCls,\n                forSelector       : `.b-timelinebase${ignoreSelector} .b-grid-body-container:not(.b-scrolling) ${me.forSelector}`,\n                scrollAction      : 'realign',\n                forElement        : client.timeAxisSubGridElement,\n                showOnHover       : true,\n                anchorToTarget    : true,\n                getHtml           : me.getTipHtml.bind(me),\n                disabled          : me.disabled,\n                // on Core/mixin/Events constructor, me.config.listeners is deleted and attributed its value to me.configuredListeners\n                // to then on processConfiguredListeners it set me.listeners to our TooltipBase\n                // but since we need our initial config.listeners to set to our internal tooltip, we leave processConfiguredListeners empty\n                // to avoid lost our listeners to apply for our internal tooltip here and force our feature has all Tooltip events firing\n                ...me.config,\n                internalListeners : me.configuredListeners\n            });\n            tip.ion({\n                innerhtmlupdate : 'updateDateIndicator',\n                overtarget      : 'onOverNewTarget',\n                show            : 'onTipShow',\n                hide            : 'onTipHide',\n                thisObj         : me\n            });\n            // Once instantiated, any Tooltip configs are relayed through the feature directly to the tip\n            Object.keys(tip.$meta.configs).forEach(name => {\n                Object.defineProperty(this, name, {\n                    set : v => tip[name] = v,\n                    get : () => tip[name]\n                });\n            });\n        }\n    }\n    //region Listeners\n    // leave configuredListeners alone until render time at which they are used on the tooltip\n    processConfiguredListeners() {}\n    addListener(...args) {\n        const\n            // Call super method to handle enable/disable feature events\n            defaultDetacher = super.addListener(...args),\n            // Add listener to the `tooltip` instance\n            tooltipDetacher = this.tooltip?.addListener(...args);\n        if (defaultDetacher || tooltipDetacher) {\n            return () => {\n                defaultDetacher?.();\n                tooltipDetacher?.();\n            };\n        }\n    }\n    removeListener(...args) {\n        super.removeListener(...args);\n        // Remove listener from the `tooltip` instance\n        this.tooltip?.removeListener(...args);\n    }\n    //endregion\n    updateDateIndicator() {\n        const\n            me             = this,\n            tip            = me.tooltip,\n            endDateElement = tip.element.querySelector('.b-sch-tooltip-enddate');\n        if (!me.record) {\n            return;\n        }\n        me.clockTemplate.updateDateIndicator(tip.element, me.record.startDate);\n        endDateElement && me.clockTemplate.updateDateIndicator(endDateElement, me.record.endDate);\n    }\n    resolveTimeSpanRecord(forElement) {\n        return this.client.resolveTimeSpanRecord(forElement);\n    }\n    getTipHtml({ tip, activeTarget }) {\n        const\n            me             = this,\n            { client }     = me,\n            recordProp     = me.recordType || `${client.scheduledEventName}Record`,\n            timeSpanRecord = me.resolveTimeSpanRecord(activeTarget);\n        // If user has mouseovered a fading away element of a deleted event,\n        // an event record will not be found. In this case the tip must hide.\n        // Instance of check is to not display while propagating\n        if (timeSpanRecord?.startDate instanceof Date) {\n            const\n                { startDate, endDate } = timeSpanRecord,\n                startText              = client.getFormattedDate(startDate),\n                endDateValue           = client.getDisplayEndDate(endDate, startDate),\n                endText                = client.getFormattedDate(endDateValue);\n            tip.eventRecord = timeSpanRecord;\n            return me.template({\n                tip,\n                // eventRecord for Scheduler, taskRecord for Gantt\n                [`${recordProp}`] : timeSpanRecord,\n                startDate,\n                endDate,\n                startText,\n                endText,\n                startClockHtml    : me.clockTemplate.template({\n                    date : startDate,\n                    text : startText,\n                    cls  : 'b-sch-tooltip-startdate'\n                }),\n                endClockHtml : timeSpanRecord.isMilestone ? '' : me.clockTemplate.template({\n                    date : endDateValue,\n                    text : endText,\n                    cls  : 'b-sch-tooltip-enddate'\n                })\n            });\n        }\n        else {\n            tip.hide();\n            return '';\n        }\n    }\n    get record() {\n        return this.tooltip.eventRecord;\n    }\n    onTipShow() {\n        const me = this;\n        if (me.monitorRecordUpdate && !me.updateListener) {\n            me.updateListener = me.client.eventStore.ion({\n                change  : me.onRecordUpdate,\n                buffer  : 300,\n                thisObj : me\n            });\n        }\n    }\n    onTipHide() {\n        // To not retain full project when changing project\n        this.tooltip.eventRecord = null;\n        this.updateListener?.();\n        this.updateListener = null;\n    }\n    onOverNewTarget({ newTarget }) {\n        const { tooltip } = this;\n        if (tooltip.isVisible) {\n            if (this.client.timeAxisSubGrid.scrolling || this.client.scrolling) {\n                tooltip.hide(false);\n            }\n            else {\n                tooltip.eventRecord = this.resolveTimeSpanRecord(newTarget);\n            }\n        }\n    }\n    onRecordUpdate({ record }) {\n        const { tooltip } = this;\n        // Make sure the record we are showing the tip for is still relevant\n        // If the change moved the element out from under the mouse, we will be hidden.\n        if (tooltip?.isVisible && record === this.record) {\n            tooltip.updateContent();\n            // If we were aligning to the event bar, realign to it.\n            if (tooltip.lastAlignSpec.aligningToElement) {\n                tooltip.realign();\n            }\n            // The pointer is still over the target (otherwise tooltip would be hidden)\n            // So invoke the tooltip's positioning\n            else {\n                tooltip.internalOnPointerOver(this.client.lastPointerEvent);\n            }\n        }\n    }\n}\nTooltipBase._$name = 'TooltipBase';", "import DragHelper from '../../Core/helper/DragHelper.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport ResizeHelper from '../../Core/helper/ResizeHelper.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../tooltip/ClockTemplate.js';\n/**\n * @module Scheduler/feature/AbstractTimeRanges\n */\n/**\n * Abstract base class, you should not use this class directly.\n * @abstract\n * @mixes Core/mixin/Delayable\n * @extends Core/mixin/InstancePlugin\n */\nexport default class AbstractTimeRanges extends InstancePlugin.mixin(Delayable) {\n    //region Config\n    /**\n     * Fired on the owning Scheduler or Gantt widget when a click happens on a time range header element\n     * @event timeRangeHeaderClick\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.TimeSpan} timeRangeRecord The record\n     * @param {MouseEvent} event DEPRECATED 5.3.0 Use `domEvent` instead\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler or Gantt widget when a double click happens on a time range header element\n     * @event timeRangeHeaderDblClick\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.TimeSpan} timeRangeRecord The record\n     * @param {MouseEvent} event DEPRECATED 5.3.0 Use `domEvent` instead\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler or Gantt widget when a right click happens on a time range header element\n     * @event timeRangeHeaderContextMenu\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.TimeSpan} timeRangeRecord The record\n     * @param {MouseEvent} event DEPRECATED 5.3.0 Use `domEvent` instead\n     * @param {MouseEvent} domEvent Browser event\n     */\n    static get defaultConfig() {\n        return {\n            // CSS class to apply to range elements\n            rangeCls : 'b-sch-range',\n            // CSS class to apply to line elements (0-duration time range)\n            lineCls : 'b-sch-line',\n            /**\n             * Set to `true` to enable dragging and resizing of range elements in the header. Only relevant when\n             * {@link #config-showHeaderElements} is `true`.\n             * @config {Boolean}\n             * @default\n             * @category Common\n             */\n            enableResizing : false,\n            /**\n             * A Boolean specifying whether to show tooltip while resizing range elements, or a\n             * {@link Core.widget.Tooltip} config object which is applied to the tooltip\n             * @config {Boolean|TooltipConfig}\n             * @default\n             * @category Common\n             */\n            showTooltip : true,\n            /**\n             * The Tooltip instance shown when hovering a TimeRange header element\n             * @member {Core.widget.Tooltip} hoverTooltip\n             * @readonly\n             */\n            /**\n             * A {@link Core.widget.Tooltip} config object which is applied to the tooltip shown when hovering a\n             * TimeRange header element\n             * @config {TooltipConfig}\n             * @category Common\n             */\n            hoverTooltip : null,\n            /**\n             * Template used to generate the tooltip contents when hovering a time range header element.\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *   features : {\n             *     timeRanges : {\n             *       tooltipTemplate({ timeRange }) {\n             *         return `${timeRange.name}`\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             *\n             * @config {Function} tooltipTemplate\n             * @param {Object} data Tooltip data\n             * @param {Scheduler.model.TimeSpan} data.timeRange\n             * @param {String} data.startClockHtml Predefined HTML to show the start time\n             * @param {String} data.endClockHtml Predefined HTML to show the end time\n             * @returns {String} String representing the HTML markup\n             * @category Common\n             */\n            tooltipTemplate : null,\n            dragTipTemplate : data => `\n                <div class=\"b-sch-tip-${data.valid ? 'valid' : 'invalid'}\">\n                    <div class=\"b-sch-tip-name\">${StringHelper.encodeHtml(data.name) || ''}</div>\n                    ${data.startClockHtml}\n                    ${data.endClockHtml || ''}\n                </div>\n            `,\n            baseCls : 'b-sch-timerange',\n            /**\n             * Function used to generate the HTML content for a time range header element.\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *   features : {\n             *     timeRanges : {\n             *       headerRenderer({ timeRange }) {\n             *         return `${timeRange.name}`\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             *\n             * @config {Function} headerRenderer\n             * @param {Object} data Render data\n             * @param {Scheduler.model.TimeSpan} data.timeRange\n             * @returns {String} String representing the HTML markup\n             *\n             * @category Common\n             */\n            headerRenderer : null,\n            /**\n             * Function used to generate the HTML content for a time range body element.\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *   features : {\n             *     timeRanges : {\n             *       bodyRenderer({ timeRange }) {\n             *         return `${timeRange.name}`\n             *       }\n             *     }\n             *   }\n             * });\n             * ```\n             *\n             * @config {Function} bodyRenderer\n             * @param {Object} data Render data\n             * @param {Scheduler.model.TimeSpan} data.timeRange\n             * @returns {String} String representing the HTML markup\n             *\n             * @category Common\n             */\n            bodyRenderer : null,\n            // a unique cls used by subclasses to get custom styling of the elements rendered\n            cls : null,\n            narrowThreshold : 80\n        };\n    }\n    static configurable = {\n        /**\n         * Set to `false` to not render range elements into the time axis header\n         * @prp {Boolean}\n         * @default\n         * @category Common\n         */\n        showHeaderElements : true\n    };\n    // Plugin configuration. This plugin chains some functions in Grid.\n    static pluginConfig = {\n        chain : [\n            'onInternalPaint',\n            'populateTimeAxisHeaderMenu',\n            'onSchedulerHorizontalScroll',\n            'afterScroll',\n            'onInternalResize'\n        ]\n    };\n    //endregion\n    //region Init & destroy\n    construct(client, config) {\n        const me = this;\n        super.construct(client, config);\n        if (client.isVertical) {\n            client.ion({\n                renderRows : me.onUIReady,\n                thisObj    : me,\n                once       : true\n            });\n        }\n        // Add a unique cls used by subclasses to get custom styling of the elements rendered\n        // This makes sure that each class only removed its own elements from the DOM\n        me.cls = me.cls || `b-sch-${me.constructor.$$name.toLowerCase()}`;\n        me.baseSelector = `.${me.baseCls}.${me.cls}`;\n        // header elements are required for interaction\n        if (me.enableResizing) {\n            me.showHeaderElements = true;\n        }\n    }\n    doDestroy() {\n        const me = this;\n        me.detachListeners('timeAxisViewModel');\n        me.detachListeners('timeAxis');\n        me.clockTemplate?.destroy();\n        me.tip?.destroy();\n        me.drag?.destroy();\n        me.resize?.destroy();\n        super.doDestroy();\n    }\n    doDisable(disable) {\n        this.renderRanges();\n        super.doDisable(disable);\n    }\n    setupTimeAxisViewModelListeners() {\n        const me = this;\n        me.detachListeners('timeAxisViewModel');\n        me.detachListeners('timeAxis');\n        me.client.timeAxisViewModel.ion({\n            name    : 'timeAxisViewModel',\n            update  : 'onTimeAxisViewModelUpdate',\n            thisObj : me\n        });\n        me.client.timeAxis.ion({\n            name          : 'timeAxis',\n            includeChange : 'renderRanges',\n            thisObj       : me\n        });\n        me.updateLineBuffer();\n    }\n    onUIReady() {\n        const\n            me         = this,\n            { client } = me;\n        // If timeAxisViewModel is swapped, re-setup listeners to new instance\n        client.ion({\n            timeAxisViewModelChange : me.setupTimeAxisViewModelListeners,\n            thisObj                 : me\n        });\n        me.setupTimeAxisViewModelListeners();\n        if (!client.hideHeaders) {\n            if (me.headerContainerElement) {\n                EventHelper.on({\n                    click       : me.onTimeRangeClick,\n                    dblclick    : me.onTimeRangeClick,\n                    contextmenu : me.onTimeRangeClick,\n                    delegate    : me.baseSelector,\n                    element     : me.headerContainerElement,\n                    thisObj     : me\n                });\n            }\n            if (me.enableResizing) {\n                me.drag = DragHelper.new({\n                    name               : 'rangeDrag',\n                    lockX              : client.isVertical,\n                    lockY              : client.isHorizontal,\n                    constrain          : true,\n                    outerElement       : me.headerContainerElement,\n                    targetSelector     : `${me.baseSelector}`,\n                    isElementDraggable : (el, event) => !client.readOnly && me.isElementDraggable(el, event),\n                    rtlSource          : client,\n                    internalListeners : {\n                        dragstart : 'onDragStart',\n                        drag      : 'onDrag',\n                        drop      : 'onDrop',\n                        reset     : 'onDragReset',\n                        abort     : 'onInvalidDrop',\n                        thisObj   : me\n                    }\n                }, me.dragHelperConfig);\n                me.resize = ResizeHelper.new({\n                    direction          : client.mode,\n                    targetSelector     : `${me.baseSelector}.b-sch-range`,\n                    outerElement       : me.headerContainerElement,\n                    isElementResizable : (el, event) => !el.matches('.b-dragging,.b-readonly') && !event.target.matches('.b-fa'),\n                    internalListeners  : {\n                        resizestart : 'onResizeStart',\n                        resizing    : 'onResizeDrag',\n                        resize      : 'onResize',\n                        cancel      : 'onInvalidResize',\n                        reset       : 'onResizeReset',\n                        thisObj     : me\n                    }\n                }, me.resizeHelperConfig);\n            }\n        }\n        me.renderRanges();\n        if (me.tooltipTemplate) {\n            me.hoverTooltip = new Tooltip(ObjectHelper.assign({\n                forElement : me.headerContainerElement,\n                getHtml({ activeTarget }) {\n                    const timeRange = me.resolveTimeRangeRecord(activeTarget);\n                    return me.tooltipTemplate({ timeRange });\n                },\n                forSelector : `.b-timelinebase:not(.b-dragging-timerange, .b-resizing-timerange) .${me.baseCls}${me.cls ? ('.' + me.cls) : ''}`\n            }, me.hoverTooltip));\n        }\n    }\n    //endregion\n    //region Draw\n    refresh() {\n        this._timeRanges = null;\n        this.renderRanges();\n    }\n    getDOMConfig(startDate, endDate) {\n        const\n            me            = this,\n            bodyConfigs   = [],\n            headerConfigs = [];\n        if (!me.disabled) {\n            // clear label rotation map cache here, used to prevent height calculations for every timeRange entry to\n            // speed up using recurrences\n            me._labelRotationMap = {};\n            for (const range of me.timeRanges) {\n                const result = me.renderRange(range, startDate, endDate);\n                if (result) {\n                    bodyConfigs.push(result.bodyConfig);\n                    headerConfigs.push(result.headerConfig);\n                }\n            }\n        }\n        return [bodyConfigs, headerConfigs];\n    }\n    renderRanges() {\n        const\n            me                   = this,\n            { client }           = me;\n        // Scheduler/Gantt might not yet be rendered\n        if (client.isPainted && !client.timeAxisSubGrid.collapsed) {\n            const\n                { headerContainerElement }   = me,\n                updatedBodyElements          = [],\n                [bodyConfigs, headerConfigs] = me.getDOMConfig();\n            if (!me.bodyCanvas) {\n                me.bodyCanvas = DomHelper.createElement({\n                    className     : `b-timeranges-canvas b-timeranges-body-canvas ${me.cls}-canvas b-sch-canvas`,\n                    parent        : client.timeAxisSubGridElement,\n                    retainElement : true\n                });\n            }\n            DomSync.sync({\n                targetElement : me.bodyCanvas,\n                domConfig     : {\n                    children     : bodyConfigs,\n                    onlyChildren : true,\n                    syncOptions  : {\n                        releaseThreshold : 0,\n                        syncIdField      : 'id'\n                    }\n                },\n                callback : me.showHeaderElements ? null : ({\n                    targetElement,\n                    action\n                }) => {\n                    // Might need to rotate label when not showing header elements\n                    if (action === 'reuseElement' || action === 'newElement' || action === 'reuseOwnElement') {\n                        // Collect all here, to not force reflows in the middle of syncing\n                        updatedBodyElements.push(targetElement);\n                    }\n                }\n            });\n            if (me.showHeaderElements && !me.headerCanvas) {\n                me.headerCanvas = DomHelper.createElement({\n                    className     : `b-timeranges-canvas b-timeranges-header-canvas ${me.cls}-canvas`,\n                    parent        : headerContainerElement,\n                    retainElement : true\n                });\n            }\n            if (me.headerCanvas) {\n                DomSync.sync({\n                    targetElement : me.headerCanvas,\n                    domConfig     : {\n                        onlyChildren : true,\n                        children     : headerConfigs,\n                        syncOptions  : {\n                            releaseThreshold : 0,\n                            syncIdField      : 'id'\n                        }\n                    }\n                });\n            }\n            // Rotate labels last, to not force reflows. First check if rotation is needed\n            for (const bodyElement of updatedBodyElements) {\n                me.cacheRotation(bodyElement.elementData.timeRange, bodyElement);\n            }\n            // Then apply rotation\n            for (const bodyElement of updatedBodyElements) {\n                me.applyRotation(bodyElement.elementData.timeRange, bodyElement);\n            }\n        }\n    }\n    // Implement in subclasses\n    get timeRanges() {\n        return [];\n    }\n    /**\n     * Based on this method result the feature decides whether the provided range should\n     * be rendered or not.\n     * The method checks that the range intersects the current viewport.\n     *\n     * Override the method to implement your custom range rendering vetoing logic.\n     * @param {Scheduler.model.TimeSpan} range Range to render.\n     * @param {Date} [startDate] Specifies view start date. Defaults to view visible range start\n     * @param {Date} [endDate] Specifies view end date. Defaults to view visible range end\n     * @returns {Boolean} `true` if the range should be rendered and `false` otherwise.\n     */\n    shouldRenderRange(\n        range,\n        startDate = this.client.visibleDateRange.startDate,\n        endDate   = this.client.visibleDateRange.endDate\n    ) {\n        const\n            { timeAxis }                                             = this.client,\n            { startDate : rangeStart, endDate : rangeEnd, duration } = range;\n        return Boolean(rangeStart && (timeAxis.isContinuous || timeAxis.isTimeSpanInAxis(range)) && DateHelper.intersectSpans(\n            startDate,\n            endDate,\n            rangeStart,\n            // Lines are included longer, to make sure label does not disappear\n            duration ? rangeEnd : DateHelper.add(rangeStart, this._lineBufferDurationMS)\n        ));\n    }\n    getRangeDomConfig(timeRange, minDate, maxDate, relativeTo = 0) {\n        const\n            me         = this,\n            { client } = me,\n            { rtl }    = client,\n            startPos   = client.getCoordinateFromDate(DateHelper.max(timeRange.startDate, minDate), {\n                respectExclusion : true\n            }) - relativeTo,\n            endPos     = timeRange.endDate ? client.getCoordinateFromDate(DateHelper.min(timeRange.endDate, maxDate), {\n                respectExclusion : true,\n                isEnd            : true\n            }) - relativeTo : startPos,\n            size       = Math.abs(endPos - startPos),\n            isRange    = size > 0,\n            translateX = rtl ? `calc(${startPos}px - 100%)` : `${startPos}px`;\n        return {\n            className : {\n                [me.baseCls]     : 1,\n                [me.cls]         : me.cls,\n                [me.rangeCls]    : isRange,\n                [me.lineCls]     : !isRange,\n                [timeRange.cls]  : timeRange.cls,\n                'b-narrow-range' : isRange && size < me.narrowThreshold,\n                'b-readonly'     : timeRange.readOnly,\n                'b-rtl'          : rtl\n            },\n            dataset : {\n                id : timeRange.id\n            },\n            elementData : {\n                timeRange\n            },\n            style : client.isVertical\n                ? `transform: translateY(${translateX}); ${isRange ? `height:${size}px` : ''};`\n                : `transform: translateX(${translateX}); ${isRange ? `width:${size}px` : ''};`\n        };\n    }\n    renderRange(timeRange, startDate, endDate) {\n        const\n            me           = this,\n            { client }   = me,\n            { timeAxis } = client;\n        if (me.shouldRenderRange(timeRange, startDate, endDate) && timeAxis.startDate) {\n            const\n                config     = me.getRangeDomConfig(timeRange, timeAxis.startDate, timeAxis.endDate),\n                icon       = timeRange.iconCls && StringHelper.xss`<i class=\"${timeRange.iconCls}\"></i>`,\n                name       = timeRange.name && StringHelper.encodeHtml(timeRange.name),\n                labelTpl   = (name || icon) ? `${icon || ''}<label>${name || '&nbsp;'}</label>` : '',\n                bodyConfig = {\n                    ...config,\n                    style : config.style + (timeRange.style || ''),\n                    html  : me.bodyRenderer ? me.bodyRenderer({ timeRange }) : (me.showHeaderElements && !me.showLabelInBody ? '' : labelTpl)\n                };\n            let headerConfig;\n            if (me.showHeaderElements) {\n                headerConfig = {\n                    ...config,\n                    html : (me.headerRenderer ? me.headerRenderer({ timeRange }) : (me.showLabelInBody ? '' : labelTpl))\n                };\n            }\n            return { bodyConfig, headerConfig };\n        }\n    }\n    // Cache label rotation to not have to calculate for each occurrence when using recurring timeranges\n    cacheRotation(range, bodyElement) {\n        // Lines have no label. Do not check label content to do not force DOM layout!\n        if ((!range.iconCls && !range.name) || !range.duration) {\n            return;\n        }\n        const label = bodyElement.firstElementChild;\n        if (label && !range.recurringTimeSpan) {\n            this._labelRotationMap[range.id] = this.client.isVertical\n                ? label.offsetHeight < bodyElement.offsetHeight\n                : label.offsetWidth > bodyElement.offsetWidth;\n        }\n    }\n    applyRotation(range, bodyElement) {\n        const rotate = this._labelRotationMap[range.recurringTimeSpan?.id ?? range.id];\n        bodyElement.firstElementChild?.classList.toggle('b-vertical', Boolean(rotate));\n    }\n    getBodyElementByRecord(idOrRecord) {\n        const id = typeof idOrRecord === 'string' ? idOrRecord : idOrRecord?.id;\n        return id != null && DomSync.getChild(this.bodyCanvas, id);\n    }\n    // Implement in subclasses\n    resolveTimeRangeRecord(el) {}\n    get headerContainerElement() {\n        const\n            me                                       = this,\n            { isVertical, timeView, timeAxisColumn } = me.client;\n        if (!me._headerContainerElement) {\n            // Render into the subGrid\u00B4s header element or the vertical timeaxis depending on mode\n            if (isVertical && timeView.element) {\n                me._headerContainerElement = timeView.element.parentElement;\n            }\n            else if (!isVertical) {\n                me._headerContainerElement = timeAxisColumn.element;\n            }\n        }\n        return me._headerContainerElement;\n    }\n    //endregion\n    //region Settings\n    get showHeaderElements() {\n        return !this.client.hideHeaders && this._showHeaderElements;\n    }\n    updateShowHeaderElements(show) {\n        const { client } = this;\n        if (!this.isConfiguring) {\n            client.element.classList.toggle('b-sch-timeranges-with-headerelements', Boolean(show));\n            this.renderRanges();\n        }\n    }\n    //endregion\n    //region Menu items\n    /**\n     * Adds menu items for the context menu, and may mutate the menu configuration.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateTimeAxisHeaderMenu({ column, items }) {}\n    //endregion\n    //region Events & hooks\n    onInternalPaint({ firstPaint }) {\n        if (firstPaint && this.client.isHorizontal) {\n            this.onUIReady();\n        }\n    }\n    onSchedulerHorizontalScroll() {\n        // Don't need a refresh, ranges are already available. Just need to draw those now in view\n        this.client.isHorizontal && this.renderRanges();\n    }\n    afterScroll() {\n        this.client.isVertical && this.renderRanges();\n    }\n    updateLineBuffer() {\n        const { timeAxisViewModel } = this.client;\n        // Lines have no duration, but we want them to be visible longer for the label to not suddenly disappear.\n        // We use a 300px buffer for that, recalculated as an amount of ms\n        this._lineBufferDurationMS = timeAxisViewModel.getDateFromPosition(300) - timeAxisViewModel.getDateFromPosition(0);\n    }\n    onInternalResize(element, newWidth, newHeight, oldWidth, oldHeight) {\n        if (this.client.isVertical && oldHeight !== newHeight) {\n            this.renderRanges();\n        }\n    }\n    onTimeAxisViewModelUpdate() {\n        this.updateLineBuffer();\n        this.refresh();\n    }\n    onTimeRangeClick(event) {\n        const timeRangeRecord = this.resolveTimeRangeRecord(event.target);\n        this.client.trigger(`timeRangeHeader${StringHelper.capitalize(event.type)}`, { event, domEvent : event, timeRangeRecord });\n    }\n    //endregion\n    //region Drag drop\n    showTip(context) {\n        const me = this;\n        if (me.showTooltip) {\n            me.clockTemplate = new ClockTemplate({\n                scheduler : me.client\n            });\n            me.tip = new Tooltip(ObjectHelper.assign({\n                id                       : `${me.client.id}-time-range-tip`,\n                cls                      : 'b-interaction-tooltip',\n                align                    : 'b-t',\n                autoShow                 : true,\n                updateContentOnMouseMove : true,\n                forElement               : context.element,\n                getHtml                  : () => me.getTipHtml(context.record, context.element)\n            }, me.showTooltip));\n        }\n    }\n    destroyTip() {\n        if (this.tip) {\n            this.tip.destroy();\n            this.tip = null;\n        }\n    }\n    isElementDraggable(el) {\n        el = el.closest(this.baseSelector + ':not(.b-resizing):not(.b-readonly)');\n        return el && !el.classList.contains('b-over-resize-handle');\n    }\n    onDragStart({ context }) {\n        const { client, drag } = this;\n        if (client.isVertical) {\n            drag.minY = 0;\n            // Moving the range, you can drag the start marker down until the end of the range hits the time axis end\n            drag.maxY = client.timeAxisViewModel.totalSize - context.element.offsetHeight;\n            // Setting min/max for X makes drag right of the header valid, but visually still constrained vertically\n            drag.minX = 0;\n            drag.maxX = Number.MAX_SAFE_INTEGER;\n        }\n        else {\n            drag.minX = 0;\n            // Moving the range, you can drag the start marker right until the end of the range hits the time axis end\n            drag.maxX = client.timeAxisViewModel.totalSize - context.element.offsetWidth;\n            // Setting min/max for Y makes drag below header valid, but visually still constrained horizontally\n            drag.minY = 0;\n            drag.maxY = Number.MAX_SAFE_INTEGER;\n        }\n        client.element.classList.add('b-dragging-timerange');\n    }\n    onDrop({ context }) {\n        this.client.element.classList.remove('b-dragging-timerange');\n    }\n    onInvalidDrop() {\n        this.drag.reset();\n        this.client.element.classList.remove('b-dragging-timerange');\n        this.destroyTip();\n    }\n    updateDateIndicator({ startDate, endDate }) {\n        const\n            me             = this,\n            { tip }        = me,\n            endDateElement = tip.element.querySelector('.b-sch-tooltip-enddate');\n        me.clockTemplate.updateDateIndicator(tip.element, startDate);\n        endDateElement && me.clockTemplate.updateDateIndicator(endDateElement, endDate);\n    }\n    onDrag({ context }) {\n        const\n            me         = this,\n            { client } = me,\n            box        = Rectangle.from(context.element),\n            startPos   = box.getStart(client.rtl, client.isHorizontal),\n            endPos     = box.getEnd(client.rtl, client.isHorizontal),\n            startDate  = client.getDateFromCoordinate(startPos, 'round', false),\n            endDate    = client.getDateFromCoordinate(endPos, 'round', false);\n        me.updateDateIndicator({ startDate, endDate });\n    }\n    onDragReset() {}\n    // endregion\n    // region Resize\n    onResizeStart() {\n        this.client.element.classList.add('b-resizing-timerange');\n        this.hoverTooltip?.hide();\n    }\n    onResizeDrag() {}\n    onResize() {}\n    onInvalidResize() {}\n    onResizeReset() {\n        this.client.element.classList.remove('b-resizing-timerange');\n    }\n    //endregion\n    //region Tooltip\n    /**\n     * Generates the html to display in the tooltip during drag drop.\n     *\n     */\n    getTipHtml(record, element) {\n        const\n            me         = this,\n            { client } = me,\n            box        = Rectangle.from(element),\n            startPos   = box.getStart(client.rtl, client.isHorizontal),\n            endPos     = box.getEnd(client.rtl, client.isHorizontal),\n            startDate  = client.getDateFromCoordinate(startPos, 'round', false),\n            endDate    = record.endDate && client.getDateFromCoordinate(endPos, 'round', false),\n            startText  = client.getFormattedDate(startDate),\n            endText    = endDate && client.getFormattedEndDate(endDate, startDate);\n        return me.dragTipTemplate({\n            name           : record.name || '',\n            startDate,\n            endDate,\n            startText,\n            endText,\n            startClockHtml : me.clockTemplate.template({\n                date : startDate,\n                text : startText,\n                cls  : 'b-sch-tooltip-startdate'\n            }),\n            endClockHtml : endText && me.clockTemplate.template({\n                date : endDate,\n                text : endText,\n                cls  : 'b-sch-tooltip-enddate'\n            })\n        });\n    }\n    //endregion\n}\nAbstractTimeRanges._$name = 'AbstractTimeRanges';", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport AttachToProjectMixin from '../../Scheduler/data/mixin/AttachToProjectMixin.js';\n/**\n * @module Scheduler/feature/ColumnLines\n */\nconst emptyObject = Object.freeze({});\n/**\n * Displays column lines for ticks, with a different styling for major ticks (by default they are darker). If this\n * feature is disabled, no lines are shown. If it's enabled, line are shown for the tick level which is set in current\n * ViewPreset. Please see {@link Scheduler.preset.ViewPreset#field-columnLinesFor} config for details.\n *\n * The lines are drawn as divs, with only visible lines available in DOM. The color and style of the lines are\n * determined by the css rules for `.b-column-line` and `.b-column-line-major`.\n *\n * For vertical mode, this features also draws vertical resource column lines if scheduler is configured with\n * `columnLines : true` (which is the default, see {@link Grid.view.GridBase#config-columnLines}).\n *\n * This feature is **enabled** by default\n *\n * {@inlineexample Scheduler/feature/ColumnLines.js}\n *\n * @demo Scheduler/basic\n *\n * @extends Core/mixin/InstancePlugin\n * @mixes Core/mixin/Delayable\n * @classtype columnLines\n * @feature\n */\nexport default class ColumnLines extends InstancePlugin.mixin(AttachToProjectMixin, Delayable) {\n    //region Config\n    static get $name() {\n        return 'ColumnLines';\n    }\n    static get delayable() {\n        return {\n            refresh : {\n                type              : 'raf',\n                cancelOutstanding : true\n            }\n        };\n    }\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            after : ['render', 'updateCanvasSize', 'internalOnVisibleDateRangeChange', 'onVisibleResourceRangeChange']\n        };\n    }\n    //endregion\n    //region Init & destroy\n    attachToResourceStore(resourceStore) {\n        const { client } = this;\n        super.attachToResourceStore(resourceStore);\n        if (client.isVertical) {\n            client.resourceStore.ion({\n                name : 'resourceStore',\n                group({ groupers }) {\n                    if (groupers.length === 0) {\n                        this.refresh();\n                    }\n                },\n                thisObj : this\n            });\n        }\n    }\n    doDisable(disable) {\n        super.doDisable(disable);\n        if (!this.isConfiguring) {\n            this.refresh();\n        }\n    }\n    //endregion\n    //region Draw\n    /**\n     * Draw lines when scheduler/gantt is rendered.\n     * @private\n     */\n    render() {\n        this.refresh();\n    }\n    getColumnLinesDOMConfig(startDate, endDate) {\n        const\n            me               = this,\n            { client }       = me,\n            { rtl }          = client,\n            m                = rtl ? -1 : 1,\n            {\n                timeAxisViewModel,\n                isHorizontal,\n                resourceStore,\n                variableColumnWidths\n            }                = client,\n            { columnConfig } = timeAxisViewModel;\n        const\n            linesForLevel      = timeAxisViewModel.columnLinesFor,\n            majorLinesForLevel = Math.max(linesForLevel - 1, 0),\n            start              = startDate.getTime(),\n            end                = endDate.getTime(),\n            domConfigs         = [],\n            dates              = new Set(),\n            dimension          = isHorizontal ? 'X' : 'Y';\n        if (!me.disabled) {\n            const addLineConfig = (tick, isMajor) => {\n                const tickStart = tick.start.getTime();\n                // Only start of tick matters.\n                // Each tick has an exact calculated start position along the time axis\n                // and carries a border on its left, so column lines follow from\n                // tick 1 (zero-based) onwards.\n                if (tickStart > start && tickStart < end && !dates.has(tickStart)) {\n                    dates.add(tickStart);\n                    domConfigs.push({\n                        role      : 'presentation',\n                        className : isMajor ? 'b-column-line-major' : 'b-column-line',\n                        style     : {\n                            transform : `translate${dimension}(${tick.coord * m}px)`\n                        },\n                        dataset : {\n                            line : isMajor ? `major-${tick.index}` : `line-${tick.index}`\n                        }\n                    });\n                }\n            };\n            // Collect configs for major lines\n            if (linesForLevel !== majorLinesForLevel) {\n                for (let i = 1; i <= columnConfig[majorLinesForLevel].length - 1; i++) {\n                    addLineConfig(columnConfig[majorLinesForLevel][i], true);\n                }\n            }\n            // And normal lines, skipping dates already occupied by major lines\n            for (let i = 1; i <= columnConfig[linesForLevel].length - 1; i++) {\n                addLineConfig(columnConfig[linesForLevel][i], false);\n            }\n            // Add vertical resource column lines, if grid is configured to show column lines\n            if (!isHorizontal && client.columnLines) {\n                const\n                    { columnWidth } = client.resourceColumns;\n                let {\n                    first : firstResource,\n                    last  : lastResource\n                }               = client.currentOrientation.getResourceRange(true);\n                let nbrGroupHeaders = 0;\n                if (firstResource > -1) {\n                    for (let i = firstResource; i < lastResource + 1; i++) {\n                        const\n                            resourceRecord = resourceStore.getAt(i);\n                        // Only add lines for group children\n                        if (resourceRecord.isGroupHeader) {\n                            lastResource++;\n                            nbrGroupHeaders++;\n                            continue;\n                        }\n                        const\n                            instanceMeta = resourceRecord.instanceMeta(resourceStore),\n                            left         = variableColumnWidths ? instanceMeta.insetStart + resourceRecord.columnWidth - 1 : (i - nbrGroupHeaders + 1) * columnWidth - 1,\n                            groupParent  = resourceRecord.groupParent?.get(client.resourceStore.id);\n                        domConfigs.push({\n                            className : {\n                                'b-column-line'            : 1,\n                                'b-resource-column-line'   : 1,\n                                'b-resource-group-divider' : resourceStore.isGrouped && groupParent?.groupChildren[groupParent?.groupChildren.length - 1] === resourceRecord\n                            },\n                            style : {\n                                transform : `translateX(${left * m}px)`\n                            },\n                            dataset : {\n                                line : `resource-${i}`\n                            }\n                        });\n                    }\n                }\n            }\n        }\n        return domConfigs;\n    }\n    /**\n     * Draw column lines that are in view\n     * @private\n     */\n    refresh() {\n        const\n            me                     = this,\n            { client }             = me,\n            { timeAxis }           = client,\n            { startDate, endDate } = client.visibleDateRange || emptyObject,\n            axisStart              = timeAxis.startDate;\n        // Early bailout for timeaxis without start date or when starting with schedule collapsed\n        if (!axisStart || !startDate || me.client.timeAxisSubGrid.collapsed) {\n            return;\n        }\n        if (!me.element) {\n            me.element = DomHelper.createElement({\n                parent    : client.timeAxisSubGridElement,\n                className : 'b-column-lines-canvas b-sch-canvas'\n            });\n        }\n        const domConfigs = me.getColumnLinesDOMConfig(startDate, endDate);\n        DomSync.sync({\n            targetElement : me.element,\n            domConfig     : {\n                onlyChildren : true,\n                children     : domConfigs,\n                syncOptions  : {\n                    // When zooming in and out we risk getting a lot of released lines if we do not limit it\n                    releaseThreshold : 4\n                }\n            },\n            syncIdField : 'line'\n        });\n    }\n    //endregion\n    //region Events\n    // Called when visible date range changes, for example from zooming, scrolling, resizing\n    internalOnVisibleDateRangeChange() {\n        this.refresh();\n    }\n    // Called when visible resource range changes, for example on scroll and resize\n    onVisibleResourceRangeChange({ firstResource, lastResource }) {\n        this.refresh();\n    }\n    updateCanvasSize() {\n        this.refresh();\n    }\n    //endregion\n}\nColumnLines._$name = 'ColumnLines'; GridFeatureManager.registerFeature(ColumnLines, true, ['Scheduler', 'Gantt', 'TimelineHistogram']);\n", "import Base from '../../../Core/Base.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\nimport Tooltip from '../../../Core/widget/Tooltip.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport VersionHelper from '../../../Core/helper/VersionHelper.js';\nimport DependencyBaseModel from '../../model/DependencyBaseModel.js';\n/**\n * @module Scheduler/feature/mixin/DependencyCreation\n */\n/**\n * Mixin for Dependencies feature that handles dependency creation (drag & drop from terminals which are shown on hover).\n * Requires {@link Core.mixin.Delayable} to be mixed in alongside.\n *\n * @mixin\n */\nexport default Target => class DependencyCreation extends (Target || Base) {\n    static get $name() {\n        return 'DependencyCreation';\n    }\n    //region Config\n    static configurable = {\n        /**\n         * `false` to require a drop on a target event bar side circle to define the dependency type.\n         * If dropped on the event bar, the `defaultValue` of the DependencyModel `type` field will be used to\n         * determine the target task side.\n         *\n         * @prp {Boolean}\n         * @default\n         * @category Dependency creation\n         */\n        allowDropOnEventBar : true,\n        /**\n         * Terminal diameter in px, overrides the default CSS value for it (which might depend on theme).\n         *\n         * {@note}\n         * Use an even number to avoid cropped terminals.\n         * {/@note}\n         *\n         * Also accepts a string value representing a CSS size, e.g. '1.5em'.\n         *\n         * @prp {Number|String}\n         * @category Dependency terminals\n         */\n        terminalSize : null,\n        /**\n         * Terminal offset from their initial position, in px. Positive values move terminals further away from the\n         * event bar, negative values inside the event bar.\n         *\n         * @prp {Number}\n         * @default 0\n         * @category Dependency terminals\n         */\n        terminalOffset : null,\n        /**\n         * Delay in ms before showing the terminals when hovering over an event bar.\n         *\n         * Can be used for a more \"stable\" UI, where the terminals are not shown immediately when hovering over an event\n         * bar and thus have fewer things moving when mouse is moved quickly over multiple event bars.\n         *\n         * @prp {Number}\n         * @default 0\n         * @category Dependency terminals\n         */\n        terminalShowDelay : 0,\n        /**\n         * Delay in ms before hiding the terminals when the mouse leaves an event bar or terminal.\n         *\n         * Can be used to make the UI more forgiving, accidentally leaving the event bar or terminal will not\n         * immediately hide the terminals.\n         *\n         * Can also be used to play a hide animation, set a `terminalHideDelay` that is longer than your animation's\n         * duration. The `b-hiding-terminals` CSS class is added to the event wrapper while the terminals are being\n         * hidden.\n         *\n         * @prp {Number}\n         * @default 0\n         * @category Dependency terminals\n         */\n        terminalHideDelay : 0\n    };\n    static get defaultConfig() {\n        return {\n            /**\n             * `false` to not show a tooltip while creating a dependency\n             * @config {Boolean}\n             * @default\n             * @category Dependency creation\n             */\n            showCreationTooltip : true,\n            /**\n             * A tooltip config object that will be applied to the dependency creation {@link Core.widget.Tooltip}\n             * @config {TooltipConfig}\n             * @category Dependency creation\n             */\n            creationTooltip : null,\n            /**\n             * A template function that will be called to generate the HTML contents of the dependency creation tooltip.\n             * You can return either an HTML string or a {@link DomConfig} object.\n             * @prp {Function} creationTooltipTemplate\n             * @param {Object} data Data about the dependency being created\n             * @param {Scheduler.model.TimeSpan} data.source The from event\n             * @param {Scheduler.model.TimeSpan} data.target The target event\n             * @param {String} data.fromSide The from side (start, end, top, bottom)\n             * @param {String} data.toSide The target side (start, end, top, bottom)\n             * @param {Boolean} data.valid The validity of the dependency\n             * @returns {String|DomConfig}\n             * @category Dependency creation\n             */\n            /**\n             * CSS class used for terminals\n             * @config {String}\n             * @default\n             * @category Dependency terminals\n             */\n            terminalCls : 'b-sch-terminal',\n            /**\n             * Where (on event bar edges) to display terminals. The sides are `'start'`, `'top'`,\n             * `'end'` and `'bottom'`\n             * @config {String[]}\n             * @category Dependency terminals\n             */\n            terminalSides : ['start', 'top', 'end', 'bottom'],\n            /**\n             * Set to `false` to not allow creating dependencies\n             * @config {Boolean}\n             * @default\n             * @category Dependency creation\n             */\n            allowCreate : true\n        };\n    }\n    //endregion\n    //region Init & destroy\n    construct(client, config) {\n        super.construct(client, config);\n        const me = this;\n        me.eventName = client.scheduledEventName;\n        client.ion({ readOnly : () => me.updateCreateListeners() });\n        me.updateCreateListeners();\n        me.chain(client, 'onElementTouchMove', 'onElementTouchMove');\n    }\n    doDestroy() {\n        const me = this;\n        me.detachListeners('view');\n        me.creationData = null;\n        me.pointerUpMoveDetacher?.();\n        me.creationTooltip?.destroy();\n        super.doDestroy();\n    }\n    updateCreateListeners() {\n        const me = this;\n        if (!me.client) {\n            return;\n        }\n        me.detachListeners('view');\n        if (me.isCreateAllowed) {\n            me.client.ion({\n                name                          : 'view',\n                [`${me.eventName}MouseEnter`] : 'onTimeSpanMouseEnter',\n                [`${me.eventName}MouseLeave`] : 'onTimeSpanMouseLeave',\n                thisObj                       : me\n            });\n        }\n    }\n    set allowCreate(value) {\n        this._allowCreate = value;\n        this.updateCreateListeners();\n    }\n    get allowCreate() {\n        return this._allowCreate;\n    }\n    get isCreateAllowed() {\n        return this.allowCreate && !this.client.readOnly && !this.disabled;\n    }\n    //endregion\n    //region Terminal settings\n    updateTerminalOffset(offset) {\n        this.client.whenVisible(() => {\n            this.client.foregroundCanvas.style.setProperty('--scheduler-dependency-terminal-offset', `${-offset}px`);\n        });\n    }\n    updateTerminalSize(size) {\n        if (typeof size === 'number') {\n            size = `${size}px`;\n        }\n        this.client.whenVisible(() => {\n            this.client.foregroundCanvas.style.setProperty('--scheduler-dependency-terminal-size', size ? `${size}` : null);\n        });\n    }\n    //endregion\n    //region Events\n    /**\n     * Show terminals when mouse enters event/task element\n     * @private\n     */\n    onTimeSpanMouseEnter({\n        event, source, [`${this.eventName}Record`]: record, [`${this.eventName}Element`]: element, resourceRecord\n    }) {\n        if (!record.isCreating && !record.readOnly) {\n            const\n                me                       = this,\n                { creationData, client } = me,\n                eventBarElement          = DomHelper.down(element, source.eventInnerSelector);\n            // When we enter a different event than the one we started on\n            if (record !== creationData?.source) {\n                const { parent } = record;\n                // Entered a nested event, hide terminals for its parent (in the drag-batches demo, events have a parent\n                // that is not added to the event store, ignore that)\n                if (record.isEventModel && parent && !parent.isRoot && client.eventStore.includes(parent)) {\n                    const parentElement = client.getElementFromEventRecord(parent, resourceRecord, true);\n                    // When Pro consumes a Gantt project, parents are not rendered\n                    parentElement && me.delayHideTerminals(parentElement);\n                }\n                me.delayShowTerminals(record, element);\n                if (creationData && event.target.closest(client.eventSelector)) {\n                    creationData.timeSpanElement = eventBarElement;\n                    me.onOverTargetEventBar(event);\n                }\n            }\n        }\n    }\n    /**\n     * Hide terminals when mouse leaves event/task element\n     * @private\n     */\n    onTimeSpanMouseLeave(event) {\n        const\n            me                                = this,\n            { creationData, client }          = me,\n            { eventRecord, event : domEvent } = event,\n            toEvent                           = domEvent.relatedTarget?.closest(client.eventSelector),\n            toEventRecord                     = toEvent?.elementData?.eventRecord ?? toEvent?.elementData?.taskRecord,\n            { parent }                        = eventRecord ?? {}, // No eventRecord in Gantt\n            element                           = event[`${me.eventName}Element`];\n        // Can happen when unhovering an occurrence during update\n        if (!domEvent) {\n            return;\n        }\n        // We cannot hide the terminals for non-trusted events because non-trusted means it's synthesized from a\n        // touchmove event and if the source element of a touchmove leaves the DOM, the touch gesture is ended.\n        if (domEvent.isTrusted || VersionHelper.isTestEnv || creationData) {\n            me.delayHideTerminals(element);\n        }\n        // Left a nested event, show terminals for its parent if we are over it now\n        if (parent && !parent.isRoot && client.eventStore.includes(parent)) {\n            const parentElement = client.getElementFromEventRecord(parent);\n            // When Pro consumes a Gantt project, parents are not rendered\n            parentElement && me.delayShowTerminals(parent, parentElement);\n        }\n        if (creationData) {\n            me.onOverNewTargetWhileCreating(domEvent.relatedTarget, !toEventRecord?.readOnly && !toEventRecord?.isOccurence ? toEventRecord : null, domEvent);\n        }\n    }\n    onTerminalMouseOver(event) {\n        this.clearTimeout(`hide-${event.target.closest(this.client.eventSelector).dataset.syncId}`);\n        if (this.creationData) {\n            this.onOverTargetEventBar(event);\n        }\n    }\n    /**\n     * Remove hover styling when mouse leaves terminal. Also hides terminals when mouse leaves one it and not creating a\n     * dependency.\n     * @private\n     */\n    onTerminalMouseOut(event) {\n        const\n            me                       = this,\n            { creationData, client } = me,\n            fromEvent                = event.target.closest(client.eventSelector),\n            toEvent                  = event.relatedTarget?.closest(client.eventSelector),\n            toEventRecord            = toEvent?.elementData?.eventRecord ?? toEvent?.elementData?.taskRecord;\n        if (toEvent !== fromEvent && fromEvent && !me.hasTimeout(`show-${fromEvent.dataset.syncId}`) && (!creationData || fromEvent !== creationData.timeSpanElement)) {\n            me.delayHideTerminals(fromEvent);\n            client.unhover(fromEvent, event);\n        }\n        if (creationData) {\n            me.onOverNewTargetWhileCreating(event.relatedTarget, !toEventRecord?.readOnly && !toEventRecord?.isOccurence ? toEventRecord : null, event);\n        }\n    }\n    /**\n     * Start creating a dependency when mouse is pressed over terminal\n     * @private\n     */\n    onTerminalPointerDown(event) {\n        const me = this;\n        // ignore non-left button clicks\n        if (event.button === 0 && !me.creationData) {\n            const\n                { client }             = me,\n                timeAxisSubGridElement = client.timeAxisSubGridElement,\n                terminalNode           = event.target,\n                timeSpanElement        = terminalNode.closest(client.eventInnerSelector),\n                viewBounds             = Rectangle.from(client.element, document.body);\n            event.stopPropagation();\n            me.creationData = {\n                sourceElement  : timeSpanElement,\n                source         : client.resolveTimeSpanRecord(timeSpanElement).$original,\n                fromSide       : terminalNode.dataset.side,\n                startPoint     : Rectangle.from(terminalNode, timeAxisSubGridElement).center,\n                startX         : event.pageX - viewBounds.x + client.scrollLeft,\n                startY         : event.pageY - viewBounds.y + client.scrollTop,\n                valid          : false,\n                sourceResource : client.resolveResourceRecord?.(event),\n                tooltip        : me.creationTooltip\n            };\n            me.pointerUpMoveDetacher = EventHelper.on({\n                pointerup : {\n                    element : client.element.getRootNode(),\n                    handler : 'onMouseUp',\n                    passive : false\n                },\n                pointermove : {\n                    element : timeAxisSubGridElement,\n                    handler : 'onMouseMove',\n                    passive : false\n                },\n                thisObj : me\n            });\n            // If root element is anything but Document (it could be Document Fragment or regular Node in case of LWC)\n            // then we should also add listener to document to cancel dependency creation\n            me.documentPointerUpDetacher = EventHelper.on({\n                pointerup : {\n                    element : document,\n                    handler : 'onDocumentMouseUp'\n                },\n                keydown : {\n                    element : document,\n                    handler : ({ key }) => {\n                        if (key === 'Escape') {\n                            me.abort();\n                        }\n                    }\n                },\n                thisObj : me\n            });\n        }\n    }\n    onElementTouchMove(event) {\n        super.onElementTouchMove?.(event);\n        if (this.connector) {\n            // Prevent touch scrolling while dragging a connector\n            event.preventDefault();\n        }\n    }\n    /**\n     * Update connector line showing dependency between source and target when mouse moves. Also check if mouse is over\n     * a valid target terminal\n     * @private\n     */\n    onMouseMove(event) {\n        const\n            me                              = this,\n            { client, creationData : data } = me,\n            viewBounds                      = Rectangle.from(client.element, document.body),\n            deltaX                          = (event.pageX - viewBounds.x + client.scrollLeft) - data.startX,\n            deltaY                          = (event.pageY - viewBounds.y + client.scrollTop) - data.startY,\n            length                          = Math.round(Math.sqrt(deltaX * deltaX + deltaY * deltaY)) - 3,\n            angle                           = Math.atan2(deltaY, deltaX);\n        let { connector } = me;\n        if (!connector) {\n            if (me.onRequestDragCreate(event) === false) {\n                return;\n            }\n            connector = me.connector;\n        }\n        connector.style.width     = `${length}px`;\n        connector.style.transform = `rotate(${angle}rad)`;\n        me.lastMouseMoveEvent = event;\n    }\n    onRequestDragCreate(event) {\n        const\n            me                              = this,\n            { client, creationData : data } = me;\n        /**\n         * Fired on the owning Scheduler/Gantt before a dependency creation drag operation starts. Return `false` to\n         * prevent it\n         * @event beforeDependencyCreateDrag\n         * @on-owner\n         * @param {Scheduler.model.TimeSpan} source The source task\n         */\n        if (client.trigger('beforeDependencyCreateDrag', { data, source : data.source }) === false) {\n            me.abort();\n            return false;\n        }\n        client.element.classList.add('b-creating-dependency');\n        me.createConnector(data.startPoint.x, data.startPoint.y);\n        /**\n         * Fired on the owning Scheduler/Gantt when a dependency creation drag operation starts\n         * @event dependencyCreateDragStart\n         * @on-owner\n         * @param {Scheduler.model.TimeSpan} source The source task\n         */\n        client.trigger('dependencyCreateDragStart', { data, source : data.source  });\n        if (me.showCreationTooltip) {\n            const tip = me.creationTooltip || (me.creationTooltip = me.createDragTooltip());\n            me.creationData.tooltip = tip;\n            tip.disabled = false;\n            tip.show();\n            tip.onMouseMove(event);\n        }\n        client.scrollManager.startMonitoring({\n            scrollables : [\n                {\n                    element   : client.timeAxisSubGrid.scrollable.element,\n                    direction : 'horizontal'\n                },\n                {\n                    element   : client.scrollable.element,\n                    direction : 'vertical'\n                }\n            ],\n            callback : () => me.lastMouseMoveEvent && me.onMouseMove(me.lastMouseMoveEvent)\n        });\n    }\n    onOverTargetEventBar(event) {\n        const\n            me                                                  = this,\n            { client, creationData: data, allowDropOnEventBar } = me,\n            { target }                                         = event;\n        let overEventRecord = client.resolveTimeSpanRecord(target).$original;\n        // use main event if a segment resolved\n        if (overEventRecord?.isEventSegment) {\n            overEventRecord = overEventRecord.event;\n        }\n        if (Objects.isPromise(data.valid) || (!allowDropOnEventBar && !target.classList.contains(me.terminalCls))) {\n            return;\n        }\n        if (overEventRecord !== data.source) {\n            me.onOverNewTargetWhileCreating(target, overEventRecord, event);\n        }\n    }\n    async onOverNewTargetWhileCreating(targetElement, overEventRecord, event) {\n        const\n            me                                                              = this,\n            { client, creationData : data, allowDropOnEventBar, connector } = me;\n        if (Objects.isPromise(data.valid)) {\n            return;\n        }\n        // stop target updating if dependency finalizing in progress\n        if (data.finalizing) {\n            return;\n        }\n        // Connector might not exist at this point because `pointerout` on the terminal might fire before `pointermove`\n        // on the time axis subgrid. This is difficult to reproduce, so shouldn't be triggered often.\n        // https://github.com/bryntum/support/issues/3116#issuecomment-894256799\n        if (!connector) {\n            return;\n        }\n        connector.classList.remove('b-valid', 'b-invalid');\n        data.timeSpanElement && DomHelper.removeClsGlobally(data.timeSpanElement, 'b-sch-terminal-active');\n        if (!overEventRecord || overEventRecord === data.source || (!allowDropOnEventBar && !targetElement.classList.contains(me.terminalCls))) {\n            data.target = data.toSide = null;\n            data.valid = false;\n            connector.classList.add('b-invalid');\n        }\n        else {\n            const\n                target     = data.target = overEventRecord,\n                { source } = data;\n            let toSide  = targetElement.dataset.side;\n            // If we allow dropping anywhere on a task, resolve target side based on the default type of the\n            // dependency model used\n            if (allowDropOnEventBar && !targetElement.classList.contains(me.terminalCls)) {\n                toSide = me.getTargetSideFromType(me.dependencyStore.modelClass.fieldMap.type.defaultValue || DependencyBaseModel.Type.EndToStart);\n            }\n            if (client.resolveResourceRecord) {\n                data.targetResource = client.resolveResourceRecord(event);\n            }\n            let dependencyType;\n            data.toSide = toSide;\n            const\n                fromSide       = data.fromSide,\n                updateValidity = valid => {\n                    if (!me.isDestroyed) {\n                        data.valid = valid;\n                        targetElement.classList.add(valid ? 'b-valid' : 'b-invalid');\n                        connector.classList.add(valid ? 'b-valid' : 'b-invalid');\n                        /**\n                         * Fired on the owning Scheduler/Gantt when asynchronous dependency validation completes\n                         * @event dependencyValidationComplete\n                         * @on-owner\n                         * @param {Scheduler.model.TimeSpan} source The source task\n                         * @param {Scheduler.model.TimeSpan} target The target task\n                         * @param {Number} dependencyType The dependency type, see {@link Scheduler.model.DependencyBaseModel#property-Type-static}\n                         */\n                        client.trigger('dependencyValidationComplete', {\n                            data,\n                            source,\n                            target,\n                            dependencyType\n                        });\n                    }\n                };\n            // NOTE: Top/Bottom sides are not taken into account due to\n            //       scheduler doesn't check for type value anyway, whereas\n            //       gantt will reject any other dependency types undefined in\n            //       DependencyBaseModel.Type enumeration.\n            switch (true) {\n                case fromSide === 'start' && toSide === 'start':\n                    dependencyType = DependencyBaseModel.Type.StartToStart;\n                    break;\n                case fromSide === 'start' && toSide === 'end':\n                    dependencyType = DependencyBaseModel.Type.StartToEnd;\n                    break;\n                case fromSide === 'end' && toSide === 'start':\n                    dependencyType = DependencyBaseModel.Type.EndToStart;\n                    break;\n                case fromSide === 'end' && toSide === 'end':\n                    dependencyType = DependencyBaseModel.Type.EndToEnd;\n                    break;\n            }\n            /**\n             * Fired on the owning Scheduler/Gantt when asynchronous dependency validation starts\n             * @event dependencyValidationStart\n             * @on-owner\n             * @param {Scheduler.model.TimeSpan} source The source task\n             * @param {Scheduler.model.TimeSpan} target The target task\n             * @param {Number} dependencyType The dependency type, see {@link Scheduler.model.DependencyBaseModel#property-Type-static}\n             */\n            client.trigger('dependencyValidationStart', {\n                data,\n                source,\n                target,\n                dependencyType\n            });\n            let valid = data.valid = me.dependencyStore.isValidDependency(source, target, dependencyType);\n            // Promise is returned when using the engine\n            if (Objects.isPromise(valid)) {\n                valid = await valid;\n                updateValidity(valid);\n            }\n            else {\n                updateValidity(valid);\n            }\n            const validityCls = valid ? 'b-valid' : 'b-invalid';\n            connector.classList.add(validityCls);\n            data.timeSpanElement?.querySelector(`.${me.terminalCls}[data-side=${toSide}]`)?.classList.add('b-sch-terminal-active', validityCls);\n        }\n        me.updateCreationTooltip();\n    }\n    /**\n     * Create a new dependency if mouse release over valid terminal. Hides connector\n     * @private\n     */\n    async onMouseUp() {\n        const\n            me   = this,\n            data = me.creationData;\n        data.finalizing = true;\n        me.pointerUpMoveDetacher?.();\n        if (data.valid) {\n            /**\n             * Fired on the owning Scheduler/Gantt when a dependency drag creation operation is about to finalize\n             *\n             * @event beforeDependencyCreateFinalize\n             * @on-owner\n             * @preventable\n             * @async\n             * @param {Scheduler.model.TimeSpan} source The source task\n             * @param {Scheduler.model.TimeSpan} target The target task\n             * @param {'start'|'end'|'top'|'bottom'} fromSide The from side (start / end / top / bottom)\n             * @param {'start'|'end'|'top'|'bottom'} toSide The to side (start / end / top / bottom)\n             */\n            const result = await me.client.trigger('beforeDependencyCreateFinalize', data);\n            if (result === false) {\n                data.valid = false;\n            }\n            // Await any async validation logic before continuing\n            else if (Objects.isPromise(data.valid)) {\n                data.valid = await data.valid;\n            }\n            if (data.valid) {\n                let dependency = me.createDependency(data);\n                if (dependency !== null) {\n                    if (Objects.isPromise(dependency)) {\n                        dependency = await dependency;\n                    }\n                    data.dependency = dependency;\n                    /**\n                     * Fired on the owning Scheduler/Gantt when a dependency drag creation operation succeeds\n                     * @event dependencyCreateDrop\n                     * @on-owner\n                     * @param {Scheduler.model.TimeSpan} source The source task\n                     * @param {Scheduler.model.TimeSpan} target The target task\n                     * @param {Scheduler.model.DependencyBaseModel} dependency The created dependency\n                     */\n                    me.client.trigger('dependencyCreateDrop', { data, source : data.source, target : data.target, dependency });\n                    me.doAfterDependencyDrop(data);\n                }\n            }\n            else {\n                me.doAfterDependencyDrop(data);\n            }\n        }\n        else {\n            data.valid = false;\n            me.doAfterDependencyDrop(data);\n        }\n        me.abort();\n    }\n    doAfterDependencyDrop(data) {\n        /**\n         * Fired on the owning Scheduler/Gantt after a dependency drag creation operation finished, no matter to outcome\n         * @event afterDependencyCreateDrop\n         * @on-owner\n         * @param {Scheduler.model.TimeSpan} source The source task\n         * @param {Scheduler.model.TimeSpan} target The target task\n         * @param {Scheduler.model.DependencyBaseModel} dependency The created dependency\n         */\n        this.client.trigger('afterDependencyCreateDrop', {\n            data,\n            ...data\n        });\n    }\n    onDocumentMouseUp({ target }) {\n        if (!this.client.timeAxisSubGridElement.contains(target)) {\n            this.abort();\n        }\n    }\n    /**\n     * Aborts dependency creation, removes proxy and cleans up listeners\n     * @category Dependency creation\n     */\n    abort() {\n        const\n            me                       = this,\n            { client, creationData } = me;\n        // Remove terminals from source and target events.\n        if (creationData) {\n            const { source, sourceResource, target, targetResource } = creationData;\n            if (source) {\n                const el = client.getElementFromEventRecord(source, sourceResource);\n                if (el) {\n                    me.hideTerminals(el);\n                }\n            }\n            if (target) {\n                const el = client.getElementFromEventRecord(target, targetResource);\n                if (el) {\n                    me.hideTerminals(el);\n                }\n            }\n        }\n        if (me.creationTooltip) {\n            me.creationTooltip.disabled = true;\n        }\n        me.creationData = me.lastMouseMoveEvent = null;\n        me.pointerUpMoveDetacher?.();\n        me.documentPointerUpDetacher?.();\n        me.removeConnector();\n    }\n    //endregion\n    //region Connector\n    /**\n     * Creates a connector line that visualizes dependency source & target\n     * @private\n     */\n    createConnector(x, y) {\n        const\n            me         = this,\n            { client } = me;\n        me.clearTimeout(me.removeConnectorTimeout);\n        me.connector = DomHelper.createElement({\n            parent    : client.timeAxisSubGridElement,\n            className : `${me.baseCls}-connector`,\n            style     : `left:${x}px;top:${y}px`\n        });\n        client.element.classList.add('b-creating-dependency');\n    }\n    createDragTooltip() {\n        const\n            me         = this,\n            { client } = me;\n        return me.creationTooltip = Tooltip.new({\n            id             : `${client.id}-dependency-drag-tip`,\n            cls            : 'b-sch-dependency-creation-tooltip',\n            loadingMsg     : '',\n            anchorToTarget : false,\n            // Keep tip visible until drag drop operation is finalized\n            forElement     : client.timeAxisSubGridElement,\n            trackMouse     : true,\n            // Do not constrain at all, want it to be able to go outside of the viewport to not get in the way\n            constrainTo    : null,\n            header : {\n                dock : 'right'\n            },\n            internalListeners : {\n                // Show initial content immediately\n                beforeShow : 'updateCreationTooltip',\n                thisObj    : me\n            }\n        }, me.creationTooltip);\n    }\n    /**\n     * Remove connector\n     * @private\n     */\n    removeConnector() {\n        const\n            me                    = this,\n            { connector, client } = me;\n        if (connector) {\n            connector.classList.add('b-removing');\n            connector.style.width = '0';\n            me.removeConnectorTimeout = me.setTimeout(() => {\n                connector.remove();\n                me.connector = null;\n            }, 200);\n        }\n        client.element.classList.remove('b-creating-dependency');\n        me.creationTooltip && me.creationTooltip.hide();\n        client.scrollManager.stopMonitoring();\n    }\n    //endregion\n    //region Terminals\n    delayShowTerminals(timeSpanRecord, element) {\n        const\n            me         = this,\n            { syncId } = element.dataset;\n        me.clearTimeout(`hide-${syncId}`);\n        me.clearTimeout(`show-${syncId}`);\n        element.classList.remove('b-hiding-terminals');\n        if (!me.terminalShowDelay) {\n            me.showTerminals(timeSpanRecord, element);\n        }\n        else {\n            me.setTimeout({\n                fn    : () => me.showTerminals(timeSpanRecord, element),\n                name  : `show-${syncId}`,\n                args  : [timeSpanRecord, element],\n                delay : me.terminalShowDelay\n            });\n        }\n    }\n    delayHideTerminals(element) {\n        const\n            me         = this,\n            { syncId } = element.dataset;\n        me.clearTimeout(`hide-${syncId}`);\n        me.clearTimeout(`show-${syncId}`);\n        element.classList.add('b-hiding-terminals');\n        if (!me.terminalHideDelay) {\n            me.hideTerminals(element);\n        }\n        else {\n            me.setTimeout({\n                fn    : () => me.hideTerminals(element),\n                name  : `hide-${syncId}`,\n                args  : [element],\n                delay : me.terminalHideDelay\n            });\n        }\n    }\n    /**\n     * Show terminals for specified event at sides defined in #terminalSides.\n     * @param {Scheduler.model.TimeSpan} timeSpanRecord Event/task to show terminals for\n     * @param {HTMLElement} [element] Event/task element, defaults to using the first element found for the task\n     * @category Dependency creation\n     */\n    showTerminals(timeSpanRecord, element = this.client.getElementFromEventRecord(timeSpanRecord)) {\n        const me = this;\n        // Record not part of project is a transient record in a display store, not meant to be manipulated\n        if (!me.isCreateAllowed || !timeSpanRecord.project || !element) {\n            return;\n        }\n        const\n            { client }          = me,\n            cls                 = me.terminalCls,\n            terminalsVisibleCls = `${cls}s-visible`;\n        if (me.showingTerminalsFor) {\n            me.hideTerminals(me.showingTerminalsFor);\n        }\n        // We operate on the event bar, not the wrap\n        element = DomHelper.down(element, me.client.eventInnerSelector);\n        // bail out if terminals already shown or if view is readonly\n        // do not draw new terminals if we are resizing event\n        if (!element.classList.contains(terminalsVisibleCls) && !client.element.classList.contains('b-resizing-event') && !client.readOnly) {\n            /**\n             * Fired on the owning Scheduler/Gantt before showing dependency terminals on a task or event. Return `false` to\n             * prevent it\n             * @event beforeShowTerminals\n             * @on-owner\n             * @param {Scheduler.model.TimeSpan} source The hovered task\n             */\n            if (client.trigger('beforeShowTerminals', { source : timeSpanRecord }) === false) {\n                return;\n            }\n            // create hover area expansion element\n            DomHelper.createElement({\n                parent    : element.closest(client.eventSelector),\n                className : 'b-sch-terminal-hover-area'\n            });\n            // create terminals for desired sides\n            me.terminalSides.forEach(side => {\n                // Allow code to use left for the start side and right for the end side\n                side = me.fixSide(side);\n                const terminal = DomHelper.createElement({\n                    parent    : element,\n                    className : `${cls} ${cls}-${side}`,\n                    dataset   : {\n                        side,\n                        feature : true\n                    }\n                });\n                terminal.detacher = EventHelper.on({\n                    element     : terminal,\n                    mouseover   : 'onTerminalMouseOver',\n                    mouseout    : 'onTerminalMouseOut',\n                    // Needs to be pointerdown to match DragHelper, otherwise will be preventing wrong event\n                    pointerdown : {\n                        handler : 'onTerminalPointerDown',\n                        capture : true\n                    },\n                    thisObj : me\n                });\n            });\n            element.classList.add(terminalsVisibleCls);\n            timeSpanRecord.internalCls.add(terminalsVisibleCls);\n        }\n    }\n    fixSide(side) {\n        if (side === 'left') {\n            return 'start';\n        }\n        if (side === 'right') {\n            return 'end';\n        }\n        return side;\n    }\n    /**\n     * Hide terminals for specified event\n     * @param {HTMLElement} eventElement Event element\n     * @category Dependency creation\n     */\n    hideTerminals(eventElement) {\n        // remove all terminals\n        const\n            me                  = this,\n            { client }          = me,\n            eventParams         = client.getTimeSpanMouseEventParams(eventElement),\n            timeSpanRecord      = eventParams?.[`${me.eventName}Record`],\n            terminalsVisibleCls = `${me.terminalCls}s-visible`;\n        eventElement.querySelector('.b-sch-terminal-hover-area')?.remove();\n        DomHelper.forEachSelector(eventElement, `> ${client.eventInnerSelector} > .${me.terminalCls}`, terminal => {\n            terminal.detacher?.();\n            terminal.remove();\n        });\n        DomHelper.down(eventElement, client.eventInnerSelector).classList.remove(terminalsVisibleCls);\n        timeSpanRecord?.internalCls.remove(terminalsVisibleCls);\n        eventElement.classList.remove('b-hiding-terminals');\n    }\n    //endregion\n    //region Dependency creation\n    /**\n     * Create a new dependency from source terminal to target terminal\n     * @internal\n     */\n    createDependency(data) {\n        const\n            { source, target, fromSide, toSide } = data,\n            type                                 = (fromSide === 'start' ? 0 : 2) + (toSide === 'end' ? 1 : 0);\n        const newDependency = this.dependencyStore.add({\n            from : source.id,\n            to   : target.id,\n            type,\n            fromSide,\n            toSide\n        });\n        return newDependency !== null ? newDependency[0] : null;\n    }\n    getTargetSideFromType(type) {\n        if (type === DependencyBaseModel.Type.StartToStart || type === DependencyBaseModel.Type.EndToStart) {\n            return 'start';\n        }\n        return 'end';\n    }\n    //endregion\n    //region Tooltip\n    /**\n     * Update dependency creation tooltip\n     * @private\n     */\n    updateCreationTooltip() {\n        const me = this;\n        if (!me.showCreationTooltip) {\n            return;\n        }\n        const\n            data          = me.creationData,\n            { valid }     = data,\n            tip           = me.creationTooltip,\n            { classList } = tip.element;\n        // Promise, when using engine\n        if (Objects.isPromise(valid)) {\n            classList.remove('b-invalid');\n            classList.add('b-checking');\n            return new Promise(resolve => valid.then(valid => {\n                data.valid = valid;\n                if (!tip.isDestroyed) {\n                    resolve(me.updateCreationTooltip());\n                }\n            }));\n        }\n        tip.html = me.creationTooltipTemplate(data);\n    }\n    creationTooltipTemplate(data) {\n        const\n            me                 = this,\n            { tooltip, valid } = data,\n            { classList }      = tooltip.element;\n        Object.assign(data, {\n            fromText : StringHelper.encodeHtml(data.source.name),\n            toText   : StringHelper.encodeHtml(data.target?.name ?? ''),\n            fromSide : data.fromSide,\n            toSide   : data.toSide || ''\n        });\n        let tipTitleIconClsSuffix,\n            tipTitleText;\n        classList.toggle('b-invalid', !valid);\n        classList.remove('b-checking');\n        // Valid\n        if (valid === true) {\n            tipTitleIconClsSuffix = 'valid';\n            tipTitleText          = me.L('L{Dependencies.valid}');\n        }\n        // Invalid\n        else {\n            tipTitleIconClsSuffix = 'invalid';\n            tipTitleText          = me.L('L{Dependencies.invalid}');\n        }\n        tooltip.title = `<i class=\"b-icon b-icon-${tipTitleIconClsSuffix}\"></i>${tipTitleText}`;\n        return {\n            children : [{\n                className : 'b-sch-dependency-tooltip',\n                children  : [\n                    { dataset : { ref : 'fromLabel' }, tag : 'label', text : me.L('L{Dependencies.from}') },\n                    { dataset : { ref : 'fromText' }, text : data.fromText },\n                    { dataset : { ref : 'fromBox' }, className : `b-sch-box b-${data.fromSide}` },\n                    { dataset : { ref : 'toLabel' }, tag : 'label', text : me.L('L{Dependencies.to}') },\n                    { dataset : { ref : 'toText' }, text : data.toText },\n                    { dataset : { ref : 'toBox' }, className : `b-sch-box b-${data.toSide}` }\n                ]\n            }]\n        };\n    }\n    //endregion\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            this.updateCreateListeners();\n        }\n        super.doDisable(disable);\n    }\n};\n", "import Base from '../../Core/Base.js';\nimport ArrayHelper from '../../Core/helper/ArrayHelper.js';\nimport WalkHelper from '../../Core/helper/WalkHelper.js';\n// Start adjusting if there is system scaling > 130%\nconst\n    THRESHOLD      = Math.min(1 / globalThis.devicePixelRatio, 0.75),\n    BOX_PROPERTIES = ['start', 'end', 'top', 'bottom'],\n    equalEnough    = (a, b) => Math.abs(a - b) < 0.1,\n    sideToSide     = {\n        l : 'left',\n        r : 'right',\n        t : 'top',\n        b : 'bottom'\n    };\n/**\n * @module Scheduler/util/RectangularPathFinder\n */\n/**\n * Class which finds rectangular path, i.e. path with 90 degrees turns, between two boxes.\n * @private\n */\nexport default class RectangularPathFinder extends Base {\n    static get configurable() {\n        return {\n            /**\n             * Default start connection side: 'left', 'right', 'top', 'bottom'\n             * @config {'top'|'bottom'|'left'|'right'}\n             * @default\n             */\n            startSide : 'right',\n            // /**\n            //  * Default start arrow size in pixels\n            //  * @config {Number}\n            //  * @default\n            //  */\n            // startArrowSize : 0,\n            /**\n             * Default start arrow staff size in pixels\n             * @config {Number}\n             * @default\n             */\n            startArrowMargin : 12,\n            /**\n             * Default starting connection point shift from box's arrow pointing side middle point\n             * @config {Number}\n             * @default\n             */\n            startShift : 0,\n            /**\n             * Default end arrow pointing direction, possible values are: 'left', 'right', 'top', 'bottom'\n             * @config {'top'|'bottom'|'left'|'right'}\n             * @default\n             */\n            endSide : 'left',\n            // /**\n            //  * Default end arrow size in pixels\n            //  * @config {Number}\n            //  * @default\n            //  */\n            // endArrowSize : 0,\n            /**\n             * Default end arrow staff size in pixels\n             * @config {Number}\n             * @default\n             */\n            endArrowMargin : 12,\n            /**\n             * Default ending connection point shift from box's arrow pointing side middle point\n             * @config {Number}\n             * @default\n             */\n            endShift : 0,\n            /**\n             * Start / End box vertical margin, the amount of pixels from top and bottom line of a box where drawing\n             * is prohibited\n             * @config {Number}\n             * @default\n             */\n            verticalMargin : 2,\n            /**\n             * Start / End box horizontal margin, the amount of pixels from left and right line of a box where drawing\n             * @config {Number}\n             * @default\n             */\n            horizontalMargin : 5,\n            /**\n             * Other rectangular areas (obstacles) to search path through\n             * @config {Object[]}\n             * @default\n             */\n            otherBoxes : null,\n            /**\n             * The owning Scheduler. Mandatory so that it can determin RTL state.\n             * @config {Scheduler.view.Scheduler}\n             * @private\n             */\n            client : {}\n        };\n    }\n    /**\n     * Returns list of horizontal and vertical segments connecting two boxes\n     * <pre>\n     *    |    | |  |    |       |\n     *  --+----+----+----*-------*---\n     *  --+=>Start  +----*-------*--\n     *  --+----+----+----*-------*--\n     *    |    | |  |    |       |\n     *    |    | |  |    |       |\n     *  --*----*-+-------+-------+--\n     *  --*----*-+         End <=+--\n     *  --*----*-+-------+-------+--\n     *    |    | |  |    |       |\n     * </pre>\n     * Path goes by lines (-=) and turns at intersections (+), boxes depicted are adjusted by horizontal/vertical\n     * margin and arrow margin, original boxes are smaller (path can't go at original box borders). Algorithm finds\n     * the shortest path with minimum amount of turns. In short it's mix of \"Lee\" and \"Dijkstra pathfinding\"\n     * with turns amount taken into account for distance calculation.\n     *\n     * The algorithm is not very performant though, it's O(N^2), where N is amount of\n     * points in the grid, but since the maximum amount of points in the grid might be up to 34 (not 36 since\n     * two box middle points are not permitted) that might be ok for now.\n     *\n     * @param {Object} lineDef An object containing any of the class configuration option overrides as well\n     *                         as `startBox`, `endBox`, `startHorizontalMargin`, `startVerticalMargin`,\n     *                         `endHorizontalMargin`, `endVerticalMargin` properties\n     * @param {Object} lineDef.startBox An object containing `start`, `end`, `top`, `bottom` properties\n     * @param {Object} lineDef.endBox   An object containing `start`, `end`, `top`, `bottom` properties\n     * @param {Number} lineDef.startHorizontalMargin Horizontal margin override for start box\n     * @param {Number} lineDef.startVerticalMargin   Vertical margin override for start box\n     * @param {Number} lineDef.endHorizontalMargin   Horizontal margin override for end box\n     * @param {Number} lineDef.endVerticalMargin     Vertical margin override for end box\n     *\n     *\n     * @returns {Object[]|Boolean} Array of line segments or false if path cannot be found\n     * @returns {Number} return.x1\n     * @returns {Number} return.y1\n     * @returns {Number} return.x2\n     * @returns {Number} return.y2\n     */\n    //\n    //@ignore\n    //@privateparam {Function[]|Function} noPathFallbackFn\n    //     A function or array of functions which will be tried in case a path can't be found\n    //     Each function will be given a line definition it might try to adjust somehow and return.\n    //     The new line definition returned will be tried to find a path.\n    //     If a function returns false, then next function will be called if any.\n    //\n    findPath(lineDef, noPathFallbackFn) {\n        const\n            me              = this,\n            originalLineDef = lineDef;\n        let lineDefFull,\n            startBox,\n            endBox,\n            startShift,\n            endShift,\n            startSide,\n            endSide,\n            // startArrowSize,\n            // endArrowSize,\n            startArrowMargin,\n            endArrowMargin,\n            horizontalMargin,\n            verticalMargin,\n            startHorizontalMargin,\n            startVerticalMargin,\n            endHorizontalMargin,\n            endVerticalMargin,\n            otherHorizontalMargin,\n            otherVerticalMargin,\n            otherBoxes,\n            connStartPoint, connEndPoint,\n            pathStartPoint, pathEndPoint,\n            gridStartPoint, gridEndPoint,\n            startGridBox, endGridBox,\n            grid, path, tryNum;\n        noPathFallbackFn = ArrayHelper.asArray(noPathFallbackFn);\n        for (tryNum = 0; lineDef && !path;) {\n            lineDefFull = Object.assign(me.config, lineDef);\n            startBox              = lineDefFull.startBox;\n            endBox                = lineDefFull.endBox;\n            startShift            = lineDefFull.startShift;\n            endShift              = lineDefFull.endShift;\n            startSide             = lineDefFull.startSide;\n            endSide               = lineDefFull.endSide;\n            // startArrowSize        = lineDefFull.startArrowSize;\n            // endArrowSize          = lineDefFull.endArrowSize;\n            startArrowMargin      = lineDefFull.startArrowMargin;\n            endArrowMargin        = lineDefFull.endArrowMargin;\n            horizontalMargin      = lineDefFull.horizontalMargin;\n            verticalMargin        = lineDefFull.verticalMargin;\n            startHorizontalMargin = lineDefFull.hasOwnProperty('startHorizontalMargin') ? lineDefFull.startHorizontalMargin : horizontalMargin;\n            startVerticalMargin   = lineDefFull.hasOwnProperty('startVerticalMargin') ? lineDefFull.startVerticalMargin : verticalMargin;\n            endHorizontalMargin   = lineDefFull.hasOwnProperty('endHorizontalMargin') ? lineDefFull.endHorizontalMargin : horizontalMargin;\n            endVerticalMargin     = lineDefFull.hasOwnProperty('endVerticalMargin') ? lineDefFull.endVerticalMargin : verticalMargin;\n            otherHorizontalMargin = lineDefFull.hasOwnProperty('otherHorizontalMargin') ? lineDefFull.otherHorizontalMargin : horizontalMargin;\n            otherVerticalMargin   = lineDefFull.hasOwnProperty('otherVerticalMargin') ? lineDefFull.otherVerticalMargin : verticalMargin;\n            otherBoxes            = lineDefFull.otherBoxes;\n            startSide = me.normalizeSide(startSide);\n            endSide   = me.normalizeSide(endSide);\n            connStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startBox, startSide, startShift);\n            connEndPoint   = me.getConnectionCoordinatesFromBoxSideShift(endBox, endSide, endShift);\n            startGridBox   = me.calcGridBaseBoxFromBoxAndDrawParams(startBox, startSide/*, startArrowSize*/, startArrowMargin, startHorizontalMargin, startVerticalMargin);\n            endGridBox     = me.calcGridBaseBoxFromBoxAndDrawParams(endBox, endSide/*, endArrowSize*/, endArrowMargin, endHorizontalMargin, endVerticalMargin);\n            // Iterate over points and merge those which are too close to each other (e.g. if difference is less than one\n            // over devicePixelRatio we won't even see this effect in GUI)\n            // https://github.com/bryntum/support/issues/3923\n            BOX_PROPERTIES.forEach(property => {\n                // We're talking subpixel precision here, so it doesn't really matter which value we choose\n                if (Math.abs(startGridBox[property] - endGridBox[property]) <= THRESHOLD) {\n                    endGridBox[property] = startGridBox[property];\n                }\n            });\n            if (me.shouldLookForPath(startBox, endBox, startGridBox, endGridBox)) {\n                otherBoxes     = otherBoxes?.map(box =>\n                    me.calcGridBaseBoxFromBoxAndDrawParams(box, false/*, 0*/, 0, otherHorizontalMargin, otherVerticalMargin)\n                );\n                pathStartPoint = me.getConnectionCoordinatesFromBoxSideShift(startGridBox, startSide, startShift);\n                pathEndPoint   = me.getConnectionCoordinatesFromBoxSideShift(endGridBox, endSide, endShift);\n                grid           = me.buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherBoxes);\n                gridStartPoint = me.convertDecartPointToGridPoint(grid, pathStartPoint);\n                gridEndPoint   = me.convertDecartPointToGridPoint(grid, pathEndPoint);\n                path           = me.findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide);\n            }\n            // Loop if\n            // - path is still not found\n            // - have no next line definition (which should be obtained from call to one of the functions from noPathFallbackFn array\n            // - have noPathFallBackFn array\n            // - current try number is less then noPathFallBackFn array length\n            for (lineDef = false; !path && !lineDef && noPathFallbackFn && tryNum < noPathFallbackFn.length; tryNum++) {\n                lineDef = (noPathFallbackFn[tryNum])(lineDefFull, originalLineDef);\n            }\n        }\n        if (path) {\n            path = me.prependPathWithArrowStaffSegment(path, connStartPoint/*, startArrowSize*/, startSide);\n            path = me.appendPathWithArrowStaffSegment(path, connEndPoint/*, endArrowSize*/, endSide);\n            path = me.optimizePath(path);\n        }\n        return path;\n    }\n    // Compares boxes relative position in the given direction.\n    //  0 - 1 is to the left/top of 2\n    //  1 - 1 overlaps with left/top edge of 2\n    //  2 - 1 is inside 2\n    // -2 - 2 is inside 1\n    //  3 - 1 overlaps with right/bottom edge of 2\n    //  4 - 1 is to the right/bottom of 2\n    static calculateRelativePosition(box1, box2, vertical = false) {\n        const\n            startProp = vertical ? 'top' : 'start',\n            endProp   = vertical ? 'bottom' : 'end';\n        let result;\n        if (box1[endProp] < box2[startProp]) {\n            result = 0;\n        }\n        else if (box1[endProp] <= box2[endProp] && box1[endProp] >= box2[startProp] && box1[startProp] < box2[startProp]) {\n            result = 1;\n        }\n        else if (box1[startProp] >= box2[startProp] && box1[endProp] <= box2[endProp]) {\n            result = 2;\n        }\n        else if (box1[startProp] < box2[startProp] && box1[endProp] > box2[endProp]) {\n            result = -2;\n        }\n        else if (box1[startProp] <= box2[endProp] && box1[endProp] > box2[endProp]) {\n            result = 3;\n        }\n        else {\n            result = 4;\n        }\n        return result;\n    }\n    // Checks if relative position of the original and marginized boxes is the same\n    static boxOverlapChanged(startBox, endBox, gridStartBox, gridEndBox, vertical = false) {\n        const\n            calculateOverlap = RectangularPathFinder.calculateRelativePosition,\n            originalOverlap  = calculateOverlap(startBox, endBox, vertical),\n            finalOverlap     = calculateOverlap(gridStartBox, gridEndBox, vertical);\n        return originalOverlap !== finalOverlap;\n    }\n    shouldLookForPath(startBox, endBox, gridStartBox, gridEndBox) {\n        let result = true;\n        // Only calculate overlap if boxes are narrow in horizontal direction\n        if (\n            // We refer to the original arrow margins because during lookup those might be nullified and we need some\n            // criteria to tell if events are too narrow\n            (startBox.end - startBox.start <= this.startArrowMargin || endBox.end - endBox.start <= this.endArrowMargin) &&\n            Math.abs(RectangularPathFinder.calculateRelativePosition(startBox, endBox, true)) === 2\n        ) {\n            result = !RectangularPathFinder.boxOverlapChanged(startBox, endBox, gridStartBox, gridEndBox);\n        }\n        return result;\n    }\n    getConnectionCoordinatesFromBoxSideShift(box, side, shift) {\n        let coords;\n        // Note that we deal with screen geometry here, not logical dependency sides\n        // Possible 'start' and 'end' have been resolved to box sides.\n        switch (side) {\n            case 'left':\n                coords = {\n                    x : box.start,\n                    y : (box.top + box.bottom) / 2 + shift\n                };\n                break;\n            case 'right':\n                coords = {\n                    x : box.end,\n                    y : (box.top + box.bottom) / 2 + shift\n                };\n                break;\n            case 'top':\n                coords = {\n                    x : (box.start + box.end) / 2 + shift,\n                    y : box.top\n                };\n                break;\n            case 'bottom':\n                coords = {\n                    x : (box.start + box.end) / 2 + shift,\n                    y : box.bottom\n                };\n                break;\n        }\n        return coords;\n    }\n    calcGridBaseBoxFromBoxAndDrawParams(box, side/*, arrowSize*/, arrowMargin, horizontalMargin, verticalMargin) {\n        let gridBox;\n        switch (this.normalizeSide(side)) {\n            case 'left':\n                gridBox = {\n                    start  : box.start - Math.max(/*arrowSize + */arrowMargin, horizontalMargin),\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + verticalMargin\n                };\n                break;\n            case 'right':\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + Math.max(/*arrowSize + */arrowMargin, horizontalMargin),\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + verticalMargin\n                };\n                break;\n            case 'top':\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - Math.max(/*arrowSize + */arrowMargin, verticalMargin),\n                    bottom : box.bottom + verticalMargin\n                };\n                break;\n            case 'bottom':\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + Math.max(/*arrowSize + */arrowMargin, verticalMargin)\n                };\n                break;\n            default:\n                gridBox = {\n                    start  : box.start - horizontalMargin,\n                    end    : box.end + horizontalMargin,\n                    top    : box.top - verticalMargin,\n                    bottom : box.bottom + verticalMargin\n                };\n        }\n        return gridBox;\n    }\n    normalizeSide(side) {\n        const { rtl } = this.client;\n        side => sideToSide[side] || side;\n        if (side === 'start') {\n            return rtl ? 'right' : 'left';\n        }\n        if (side === 'end') {\n            return rtl ? 'left' : 'right';\n        }\n        return side;\n    }\n    buildPathGrid(startGridBox, endGridBox, pathStartPoint, pathEndPoint, startSide, endSide, otherGridBoxes) {\n        let xs, ys,\n            y, x, ix, iy, xslen, yslen, ib, blen, box, permitted, point;\n        const\n            points       = {},\n            linearPoints = [];\n        xs = [\n            startGridBox.start,\n            (startSide === 'left' || startSide === 'right') ? (startGridBox.start + startGridBox.end) / 2 : pathStartPoint.x,\n            startGridBox.end,\n            endGridBox.start,\n            (endSide === 'left' || endSide === 'right') ? (endGridBox.start + endGridBox.end) / 2 : pathEndPoint.x,\n            endGridBox.end\n        ];\n        ys = [\n            startGridBox.top,\n            (startSide === 'top' || startSide === 'bottom') ? (startGridBox.top + startGridBox.bottom) / 2 : pathStartPoint.y,\n            startGridBox.bottom,\n            endGridBox.top,\n            (endSide === 'top' || endSide === 'bottom') ? (endGridBox.top + endGridBox.bottom) / 2 : pathEndPoint.y,\n            endGridBox.bottom\n        ];\n        if (otherGridBoxes) {\n            otherGridBoxes.forEach(box => {\n                xs.push(box.start, (box.start + box.end) / 2, box.end);\n                ys.push(box.top, (box.top + box.bottom) / 2, box.bottom);\n            });\n        }\n        xs = [...new Set(xs.sort((a, b) => a - b))];\n        ys = [...new Set(ys.sort((a, b) => a - b))];\n        for (iy = 0, yslen = ys.length; iy < yslen; ++iy) {\n            points[iy] = points[iy] || {};\n            y          = ys[iy];\n            for (ix = 0, xslen = xs.length; ix < xslen; ++ix) {\n                x = xs[ix];\n                permitted = (\n                    (x <= startGridBox.start || x >= startGridBox.end || y <= startGridBox.top || y >= startGridBox.bottom) &&\n                    (x <= endGridBox.start || x >= endGridBox.end || y <= endGridBox.top || y >= endGridBox.bottom)\n                );\n                if (otherGridBoxes) {\n                    for (ib = 0, blen = otherGridBoxes.length; permitted && ib < blen; ++ib) {\n                        box       = otherGridBoxes[ib];\n                        permitted = (x <= box.start || x >= box.end || y <= box.top || y >= box.bottom) ||\n                            // Allow point if it is a path start/end even if point is inside any box\n                            (x === pathStartPoint.x && y === pathStartPoint.y) ||\n                            (x === pathEndPoint.x && y === pathEndPoint.y);\n                    }\n                }\n                point = {\n                    distance : Number.MAX_SAFE_INTEGER,\n                    permitted,\n                    x,\n                    y,\n                    ix,\n                    iy\n                };\n                points[iy][ix] = point;\n                linearPoints.push(point);\n            }\n        }\n        return {\n            width  : xs.length,\n            height : ys.length,\n            xs,\n            ys,\n            points,\n            linearPoints\n        };\n    }\n    convertDecartPointToGridPoint(grid, point) {\n        const\n            x = grid.xs.indexOf(point.x),\n            y = grid.ys.indexOf(point.y);\n        return grid.points[y][x];\n    }\n    findPathOnGrid(grid, gridStartPoint, gridEndPoint, startSide, endSide) {\n        const me = this;\n        let path = false;\n        if (gridStartPoint.permitted && gridEndPoint.permitted) {\n            grid = me.waveForward(grid, gridStartPoint, 0);\n            path = me.collectPath(grid, gridEndPoint, endSide);\n        }\n        return path;\n    }\n    // Returns neighbors from Von Neiman ambit (see Lee pathfinding algorithm description)\n    getGridPointNeighbors(grid, gridPoint, predicateFn) {\n        const\n            ix     = gridPoint.ix,\n            iy     = gridPoint.iy,\n            result = [];\n        let neighbor;\n        // NOTE:\n        // It's important to push bottom neighbors first since this method is used\n        // in collectPath(), which recursively collects path from end to start node\n        // and if bottom neighbors are pushed first in result array then collectPath()\n        // will produce a line which is more suitable (pleasant looking) for our purposes.\n        if (iy < grid.height - 1) {\n            neighbor = grid.points[iy + 1][ix];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n        if (iy > 0) {\n            neighbor = grid.points[iy - 1][ix];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n        if (ix < grid.width - 1) {\n            neighbor = grid.points[iy][ix + 1];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n        if (ix > 0) {\n            neighbor = grid.points[iy][ix - 1];\n            (!predicateFn || predicateFn(neighbor)) && result.push(neighbor);\n        }\n        return result;\n    }\n    waveForward(grid, gridStartPoint, distance) {\n        const me = this;\n        // I use the WalkHelper here because a point on a grid and it's neighbors might be considered as a hierarchy.\n        // The point is the parent node, and it's neighbors are the children nodes. Thus the grid here is hierarchical\n        // data structure which can be walked. WalkHelper walks non-recursively which is exactly what I need as well.\n        WalkHelper.preWalkUnordered(\n            // Walk starting point - a node is a grid point and it's distance from the starting point\n            [gridStartPoint, distance],\n            // Children query function\n            // NOTE: It's important to fix neighbor distance first, before waving to a neighbor, otherwise waving might\n            //       get through a neighbor point setting it's distance to a value more than (distance + 1) whereas we,\n            //       at the children querying moment in time, already know that the possibly optimal distance is (distance + 1)\n            ([point, distance]) => me.getGridPointNeighbors(\n                grid,\n                point,\n                neighborPoint => neighborPoint.permitted && (neighborPoint.distance > distance + 1)\n            ).map(\n                neighborPoint => [neighborPoint, distance + 1] // Neighbor distance fixation\n            ),\n            // Walk step iterator function\n            ([point, distance]) => point.distance = distance // Neighbor distance applying\n        );\n        return grid;\n    }\n    collectPath(grid, gridEndPoint, endSide) {\n        const\n            me   = this,\n            path = [];\n        let pathFound = true,\n            neighbors,\n            lowestDistanceNeighbor,\n            xDiff, yDiff;\n        while (pathFound && gridEndPoint.distance) {\n            neighbors = me.getGridPointNeighbors(grid, gridEndPoint, point =>\n                point.permitted && (point.distance === gridEndPoint.distance - 1)\n            );\n            pathFound = neighbors.length > 0;\n            if (pathFound) {\n                // Prefer turnless neighbors first\n                neighbors = neighbors.sort((a, b) => {\n                    let xDiff, yDiff;\n                    xDiff = a.ix - gridEndPoint.ix;\n                    yDiff = a.iy - gridEndPoint.iy;\n                    const resultA = (\n                        ((endSide === 'left' || endSide === 'right') && yDiff === 0) ||\n                        ((endSide === 'top' || endSide === 'bottom') && xDiff === 0)\n                    ) ? -1 : 1;\n                    xDiff = b.ix - gridEndPoint.ix;\n                    yDiff = b.iy - gridEndPoint.iy;\n                    const resultB = (\n                        ((endSide === 'left' || endSide === 'right') && yDiff === 0) ||\n                        ((endSide === 'top' || endSide === 'bottom') && xDiff === 0)\n                    ) ? -1 : 1;\n                    if (resultA > resultB) return 1;\n                    if (resultA < resultB) return -1;\n                    // apply additional sorting to be sure to pick bottom path in IE\n                    if (resultA === resultB) return a.y > b.y ? -1 : 1;\n                });\n                lowestDistanceNeighbor = neighbors[0];\n                path.push({\n                    x1 : lowestDistanceNeighbor.x,\n                    y1 : lowestDistanceNeighbor.y,\n                    x2 : gridEndPoint.x,\n                    y2 : gridEndPoint.y\n                });\n                // Detecting new side, either xDiff or yDiff must be 0 (but not both)\n                xDiff = lowestDistanceNeighbor.ix - gridEndPoint.ix;\n                yDiff = lowestDistanceNeighbor.iy - gridEndPoint.iy;\n                switch (true) {\n                    case !yDiff && xDiff > 0:\n                        endSide = 'left';\n                        break;\n                    case !yDiff && xDiff < 0:\n                        endSide = 'right';\n                        break;\n                    case !xDiff && yDiff > 0:\n                        endSide = 'top';\n                        break;\n                    case !xDiff && yDiff < 0:\n                        endSide = 'bottom';\n                        break;\n                }\n                gridEndPoint = lowestDistanceNeighbor;\n            }\n        }\n        return pathFound && path.reverse() || false;\n    }\n    prependPathWithArrowStaffSegment(path, connStartPoint/*, startArrowSize*/, startSide) {\n        if (path.length > 0) {\n            const\n                firstSegment   = path[0],\n                prependSegment = {\n                    x2 : firstSegment.x1,\n                    y2 : firstSegment.y1\n                };\n            switch (startSide) {\n                case 'left':\n                    prependSegment.x1 = connStartPoint.x/* - startArrowSize*/;\n                    prependSegment.y1 = firstSegment.y1;\n                    break;\n                case 'right':\n                    prependSegment.x1 = connStartPoint.x/* + startArrowSize*/;\n                    prependSegment.y1 = firstSegment.y1;\n                    break;\n                case 'top':\n                    prependSegment.x1 = firstSegment.x1;\n                    prependSegment.y1 = connStartPoint.y/* - startArrowSize*/;\n                    break;\n                case 'bottom':\n                    prependSegment.x1 = firstSegment.x1;\n                    prependSegment.y1 = connStartPoint.y/* + startArrowSize*/;\n                    break;\n            }\n            path.unshift(prependSegment);\n        }\n        return path;\n    }\n    appendPathWithArrowStaffSegment(path, connEndPoint/*, endArrowSize*/, endSide) {\n        if (path.length > 0) {\n            const\n                lastSegment   = path[path.length - 1],\n                appendSegment = {\n                    x1 : lastSegment.x2,\n                    y1 : lastSegment.y2\n                };\n            switch (endSide) {\n                case 'left':\n                    appendSegment.x2 = connEndPoint.x/* - endArrowSize*/;\n                    appendSegment.y2 = lastSegment.y2;\n                    break;\n                case 'right':\n                    appendSegment.x2 = connEndPoint.x/* + endArrowSize*/;\n                    appendSegment.y2 = lastSegment.y2;\n                    break;\n                case 'top':\n                    appendSegment.x2 = lastSegment.x2;\n                    appendSegment.y2 = connEndPoint.y/* - endArrowSize*/;\n                    break;\n                case 'bottom':\n                    appendSegment.x2 = lastSegment.x2;\n                    appendSegment.y2 = connEndPoint.y/* + endArrowSize*/;\n                    break;\n            }\n            path.push(appendSegment);\n        }\n        return path;\n    }\n    optimizePath(path) {\n        const optPath = [];\n        let prevSegment,\n            curSegment;\n        if (path.length > 0) {\n            prevSegment = path.shift();\n            optPath.push(prevSegment);\n            while (path.length > 0) {\n                curSegment = path.shift();\n                // both segments are as good as equal\n                if (\n                    equalEnough(prevSegment.x1, curSegment.x1) && equalEnough(prevSegment.y1, curSegment.y1) &&\n                    equalEnough(prevSegment.x2, curSegment.x2) && equalEnough(prevSegment.y2, curSegment.y2)\n                ) {\n                    prevSegment = curSegment;\n                }\n                // both segments are horizontal or very nearly so\n                else if (equalEnough(prevSegment.y1, prevSegment.y2) && equalEnough(curSegment.y1, curSegment.y2)) {\n                    prevSegment.x2 = curSegment.x2;\n                }\n                // both segments are vertical or very nearly so\n                else if (equalEnough(prevSegment.x1, prevSegment.x2) && equalEnough(curSegment.x1, curSegment.x2)) {\n                    prevSegment.y2 = curSegment.y2;\n                }\n                // segments have different orientation (path turn)\n                else {\n                    optPath.push(curSegment);\n                    prevSegment = curSegment;\n                }\n            }\n        }\n        return optPath;\n    }\n}\nRectangularPathFinder._$name = 'RectangularPathFinder';", "import DateHelper from '../../../Core/helper/DateHelper.js';\nimport Tooltip from '../../../Core/widget/Tooltip.js';\n/**\n * @module Scheduler/feature/mixin/DependencyTooltip\n */\nconst\n    // Map dependency type to side of a box, for displaying an icon in the tooltip\n    fromBoxSide = [\n        'start',\n        'start',\n        'end',\n        'end'\n    ],\n    toBoxSide   = [\n        'start',\n        'end',\n        'start',\n        'end'\n    ];\n/**\n * Mixin that adds tooltip support to the {@link Scheduler/feature/Dependencies} feature.\n * @mixin\n */\nexport default Target => class DependencyTooltip extends Target {\n    static $name = 'DependencyTooltip';\n    static configurable = {\n        /**\n         * Set to `true` to show a tooltip when hovering a dependency line\n         * @config {Boolean}\n         * @default\n         * @category Dependency tooltip\n         */\n        showTooltip : true,\n        /**\n         * Set to `true` to show the lag in the tooltip\n         * @config {Boolean}\n         * @default\n         */\n        showLagInTooltip : false,\n        /**\n         * A template function allowing you to configure the contents of the tooltip shown when hovering a\n         * dependency line. You can return either an HTML string or a {@link DomConfig} object.\n         * @prp {Function} tooltipTemplate\n         * @param {Scheduler.model.DependencyBaseModel} dependency The dependency record\n         * @returns {String|DomConfig}\n         * @category Dependency tooltip\n         */\n        tooltipTemplate(dependency) {\n            const me = this;\n            return {\n                children : [{\n                    className : 'b-sch-dependency-tooltip',\n                    children  : [\n                        { tag : 'label', text : me.L('L{Dependencies.from}') },\n                        { text : dependency.fromEvent.name },\n                        { className : `b-sch-box b-${dependency.fromSide || fromBoxSide[dependency.type]}` },\n                        { tag : 'label', text : me.L('L{Dependencies.to}') },\n                        { text : dependency.toEvent.name },\n                        { className : `b-sch-box b-${dependency.toSide || toBoxSide[dependency.type]}` },\n                        me.showLagInTooltip && { tag : 'label', text : me.L('L{DependencyEdit.Lag}') },\n                        me.showLagInTooltip && { text : `${dependency.lag || 0} ${DateHelper.getLocalizedNameOfUnit(dependency.lagUnit, dependency.lag !== 1)}` }\n                    ]\n                }]\n            };\n        },\n        /**\n         * A tooltip config object that will be applied to the dependency hover tooltip. Can be used to for example\n         * customize delay\n         * @config {TooltipConfig}\n         * @category Dependency tooltip\n         */\n        tooltip : {\n            $config : 'nullify',\n            value : {}\n        }\n    };\n    changeTooltip(tooltip, old) {\n        const me = this;\n        old?.destroy();\n        if (!me.showTooltip || !tooltip) {\n            return null;\n        }\n        return Tooltip.new({\n            align          : 'b-t',\n            id             : `${me.client.id}-dependency-tip`,\n            forSelector    : `.b-timelinebase:not(.b-eventeditor-editing,.b-taskeditor-editing,.b-resizing-event,.b-dragcreating,.b-dragging-event,.b-creating-dependency) .${me.baseCls}`,\n            forElement     : me.client.timeAxisSubGridElement,\n            showOnHover    : true,\n            hoverDelay     : 0,\n            hideDelay      : 0,\n            anchorToTarget : false,\n            textContent    : false, // Skip max-width setting\n            trackMouse     : false,\n            getHtml        : me.getHoverTipHtml.bind(me)\n        }, tooltip);\n    }\n    /**\n     * Generates DomConfig content for the tooltip shown when hovering a dependency\n     * @param {Object} tooltipConfig\n     * @returns {DomConfig} DomConfig used as tooltips content\n     * @private\n     */\n    getHoverTipHtml({ activeTarget }) {\n        return this.tooltipTemplate(this.resolveDependencyRecord(activeTarget));\n    }\n};\n", "const ROWS_PER_CELL = 25;\n// Mixin that handles the dependency grid cache\n//\n// Grid cache explainer\n// \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// The purpose of the grid cache is to reduce the amount of dependencies we have to iterate over when drawing by\n// partitioning them into a virtual grid. With for example 10k deps we would have to iterate over all 10k on\n// each draw since any of them might be intersecting the view.\n//\n// The cells are horizontally based on ticks (50 per cell) and vertically on rows (also 50 per cell. Each cell\n// lists which dependencies intersect it. When drawing we only have to iterate over the dependencies for the\n// cells that intersect the viewport.\n//\n// The grid cache is populated when dependencies are drawn. Any change to deps, resources, events or assignments\n// clears the cache.\n//\n// The dependency drawn below will be included in the set that is considered for drawing if tickCell 0 or\n// tickCell 1 and rowCell 0 intersects the current view (it is thus represented twice in the grid cache)\n//\n//       tickCell 0           tickCell 1\n//       tick 0-49            tick 50-99\n//    \u250C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n// r r\u25020,0                 \u25021,0                  \u2502\n// o o\u2502     \u2502              \u2502                     \u2502\n// w w\u2502     \u2502     !!!!!!!!!\u2502!!!!!!!!!!!          \u2502\n// C  \u2502     \u2502     ! View   \u2502          !          \u2502\n// e 0\u2502     \u2502     ! port   \u2502          !          \u2502\n// l -\u2502     \u2502     !        \u2502          !          \u2502\n// l 4\u2502     \u2514\u2500\u2500\u2500\u2500\u2500!\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500!\u2500\u2500\u2500\u2500\u25BA     \u2502\n// 0 9\u2502           !        \u2502          !          \u2502\n//    \u251C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253C\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\n// r r\u25020,1        !        \u25021,1       !          \u2502\n// o o\u2502           !        \u2502          !          \u2502\n// w w\u2502           !!!!!!!!!\u2502!!!!!!!!!!!          \u2502\n// C  \u2502                    \u2502                     \u2502\n// e 5\u2502                    \u2502                     \u2502\n// l 0\u2502                    \u2502                     \u2502\n// l -\u2502                    \u2502                     \u2502\n// 1 9\u2502                    \u2502                     \u2502\n//   9\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n//               uo\u1D09\u0287\u0250\u0279\u0287sn\uA781\uA781\u1D09 \u0259\u0265\u0254\u0250\u0254 p\u1D09\u0279\u2141\nexport default Target => class DependencyGridCache extends Target {\n    static $name = 'DependencyGridCache';\n    gridCache = null;\n    // Dependencies that might intersect the current viewport and thus should be considered for drawing\n    getDependenciesToConsider(startMS, endMS, startIndex, endIndex) {\n        const\n            me            = this,\n            { gridCache } = me,\n            { timeAxis }  = me.client;\n        if (gridCache) {\n            const\n                dependencies = new Set(),\n                fromMSCell   = Math.floor((startMS - timeAxis.startMS) / me.MS_PER_CELL),\n                toMSCell     = Math.floor((endMS - timeAxis.startMS) / me.MS_PER_CELL),\n                fromRowCell  = Math.floor(startIndex / ROWS_PER_CELL),\n                toRowCell    = Math.floor(endIndex / ROWS_PER_CELL);\n            for (let i = fromMSCell; i <= toMSCell; i++) {\n                const msCell = gridCache[i];\n                if (msCell) {\n                    for (let j = fromRowCell; j <= toRowCell; j++) {\n                        const intersectingDependencies = msCell[j];\n                        if (intersectingDependencies) {\n                            for (let i = 0; i < intersectingDependencies.length; i++) {\n                                dependencies.add(intersectingDependencies[i]);\n                            }\n                        }\n                    }\n                }\n            }\n            return dependencies;\n        }\n    }\n    // A (single) dependency was drawn, we might want to store info about it in the grid cache\n    afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS) {\n        const me = this;\n        if (me.constructGridCache) {\n            const\n                { MS_PER_CELL } = me,\n                {\n                    startMS : timeAxisStartMS,\n                    endMS   : timeAxisEndMS\n                }               = me.client.timeAxis,\n                timeAxisCells   = Math.ceil((timeAxisEndMS - timeAxisStartMS) / MS_PER_CELL),\n                fromMSCell      = Math.floor((fromDateMS - timeAxisStartMS) / MS_PER_CELL),\n                toMSCell        = Math.floor((toDateMS - timeAxisStartMS) / MS_PER_CELL),\n                fromRowCell     = Math.floor(fromIndex / ROWS_PER_CELL),\n                toRowCell       = Math.floor(toIndex / ROWS_PER_CELL),\n                firstMSCell     = Math.min(fromMSCell, toMSCell),\n                lastMSCell      = Math.max(fromMSCell, toMSCell),\n                firstRowCell    = Math.min(fromRowCell, toRowCell),\n                lastRowCell     = Math.max(fromRowCell, toRowCell);\n            // Ignore dependencies fully outside of the time axis\n            if ((firstMSCell < 0 && lastMSCell < 0) || (firstMSCell > timeAxisCells && lastMSCell > timeAxisCells)) {\n                return;\n            }\n            // Cache from time axis start, to time axis end (\"cropping\" deps starting or ending outside)\n            const\n                startMSCell = Math.max(firstMSCell, 0),\n                endMSCell   = Math.min(lastMSCell, timeAxisCells);\n            for (let i = startMSCell; i <= endMSCell; i++) {\n                const msCell = me.gridCache[i] ?? (me.gridCache[i] = {});\n                for (let j = firstRowCell; j <= lastRowCell; j++) {\n                    const rowCell = msCell[j] ?? (msCell[j] = []);\n                    rowCell.push(dependency);\n                }\n            }\n        }\n    }\n    // All dependencies are about to be drawn, check if we need to build the grid cache\n    beforeDraw() {\n        const me = this;\n        if (!me.gridCache) {\n            const { visibleDateRange } = me.client;\n            me.constructGridCache = true;\n            // Adjust number of ms used in grid cache to match viewport\n            me.MS_PER_CELL = Math.max(visibleDateRange.endMS - visibleDateRange.startMS, 1000);\n            // Start with empty cache, will be populated as deps are drawn\n            me.gridCache = {};\n        }\n    }\n    // All dependencies are drawn, we no longer need to rebuild the cache\n    afterDraw() {\n        this.constructGridCache = false;\n    }\n    reset() {\n        this.gridCache = null;\n    }\n};\n", "import DependencyModel from '../../model/DependencyModel.js';\nimport RectangularPathFinder from '../../util/RectangularPathFinder.js';\nimport DomHelper from '../../../Core/helper/DomHelper.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../../Core/helper/util/Rectangle.js';\n// Determine a line segments drawing direction\nfunction drawingDirection(pointSet) {\n    if (pointSet.x1 === pointSet.x2) {\n        return pointSet.y2 > pointSet.y1 ? 'd' : 'u';\n    }\n    return pointSet.x2 > pointSet.x1 ? 'r' : 'l';\n}\n// Determine a line segments length\nfunction segmentLength(pointSet) {\n    return pointSet.x1 === pointSet.x2 ? pointSet.y2 - pointSet.y1 : pointSet.x2 - pointSet.x1;\n}\n// Define an arc to tie two line segments together\nfunction arc(pointSet, nextPointSet, radius) {\n    const\n        corner = drawingDirection(pointSet) + drawingDirection(nextPointSet),\n        // Flip x if this or next segment is drawn right to left\n        rx     = radius * (corner.includes('l') ? -1 : 1),\n        // Flip y if this or next segment is drawn bottom to top\n        ry     = radius * (corner.includes('u') ? -1 : 1),\n        // Positive (0) or negative (1) angle\n        sweep  = corner === 'ur' || corner === 'lu' || corner === 'dl' || corner === 'rd' ? 1 : 0;\n    return `a${rx},${ry} 0 0 ${sweep} ${rx},${ry}`;\n}\n// Define a line for a set of points, tying it together with the next set with an arc when applicable\nfunction line(pointSet, nextPointSet, location, radius, prevRadius) {\n    // Horizontal or vertical line\n    let line      = pointSet.x1 === pointSet.x2 ? 'v' : 'h',\n        useRadius = radius;\n    // Add an arc?\n    if (radius) {\n        const\n            // Length of this line segment\n            length     = segmentLength(pointSet),\n            // Length of the next one. Both are needed to determine max radius (half of the shortest delta)\n            nextLength = nextPointSet ? Math.abs(segmentLength(nextPointSet)) : Number.MAX_SAFE_INTEGER,\n            // Line direction\n            sign       = Math.sign(length);\n        // If we are not passed a radius from the previous line drawn, we use the configured radius. It is used to shorten\n        // this lines length to fit the arc that connects it to the previous line\n        if (prevRadius == null) {\n            prevRadius = radius;\n        }\n        // We cannot use a radius larger than half our or our successor's length, doing so would make the segment too long\n        // when the arc is created\n        if (Math.abs(length) < radius * 2 || nextLength < radius * 2) {\n            useRadius = Math.min(Math.abs(length), nextLength) / 2;\n        }\n        const\n            // Radius of neighbouring arcs, subtracted from length below...\n            subtract  = location === 'single' ? 0 : location === 'first' ? useRadius : location === 'between' ? prevRadius + useRadius : /*last*/ prevRadius,\n            // ...to produce the length of the line segment to draw\n            useLength = length - subtract * sign;\n        // Apply line segment length, unless it passed over 0 in which case we stick to 0\n        line += Math.sign(useLength) !== sign ? 0 : useLength;\n        // Add an arc if applicable\n        if (location !== 'last' && location !== 'single' && useRadius > 0) {\n            line += ` ${arc(pointSet, nextPointSet, useRadius)}`;\n        }\n    }\n    // Otherwise take a shorter code path\n    else {\n        line += segmentLength(pointSet);\n    }\n    return {\n        line,\n        currentRadius : radius !== useRadius ? useRadius : null\n    };\n}\n// Define an SVG path base on points from the path finder.\n// Each segment in the path can be joined by an arc\nfunction pathMapper(radius, points) {\n    const { length } = points;\n    if (!length) {\n        return '';\n    }\n    let currentRadius = null;\n    return `M${points[0].x1},${points[0].y1} ${points.map((pointSet, i) => {\n        // Segment placement among all segments, used to determine if an arc should be added\n        const\n            location =\n                length === 1 ? 'single'\n                    : i === length - 1 ? 'last'\n                        : i === 0 ? 'first'\n                            : 'between',\n            lineSpec = line(pointSet, points[i + 1], location, radius, currentRadius);\n        ({ currentRadius } = lineSpec);\n        return lineSpec.line;\n    }).join(' ')}`;\n}\n// Mixin that holds the code needed to generate DomConfigs for dependency lines\nexport default Target => class DependencyLineGenerator extends Target {\n    static $name = 'DependencyLineGenerator';\n    lineCache = {};\n    onSVGReady() {\n        const me = this;\n        me.pathFinder       = new RectangularPathFinder({\n            ...me.pathFinderConfig,\n            client : me.client\n        });\n        me.lineDefAdjusters = me.createLineDefAdjusters();\n        me.createMarker();\n    }\n    changeRadius(radius) {\n        if (radius !== null) {\n            ObjectHelper.assertNumber(radius, 'radius');\n        }\n        return radius;\n    }\n    resetAtRuntime() {\n        if (!this.isConfiguring) {\n            this.reset();\n        }\n    }\n    updateRadius() {\n        this.resetAtRuntime();\n    }\n    updateRenderer() {\n        this.resetAtRuntime();\n    }\n    changeClickWidth(width) {\n        if (width !== null) {\n            ObjectHelper.assertNumber(width, 'clickWidth');\n        }\n        return width;\n    }\n    updateClickWidth() {\n        this.resetAtRuntime();\n    }\n    updateDrawAroundParents() {\n        this.resetAtRuntime();\n    }\n    //region Marker\n    createMarker() {\n        const\n            me            = this,\n            { markerDef } = me,\n            svg           = this.client.svgCanvas,\n            // SVG markers has to use an id, we want the id to be per scheduler when using multiple\n            markerId      = markerDef ? `${me.client.id}-arrowEnd` : 'arrowEnd';\n        me.marker?.remove();\n        svg.style.setProperty('--scheduler-dependency-marker', `url(#${markerId})`);\n        me.marker = DomHelper.createElement({\n            parent        : svg,\n            id            : markerId, \n            tag           : 'marker',\n            className     : 'b-sch-dependency-arrow',\n            ns            : 'http://www.w3.org/2000/svg',\n            markerHeight  : 11,\n            markerWidth   : 11,\n            refX          : 8.5,\n            refY          : 3,\n            viewBox       : '0 0 9 6',\n            orient        : 'auto-start-reverse',\n            markerUnits   : 'userSpaceOnUse',\n            retainElement : true,\n            children      : [{\n                tag : 'path',\n                ns  : 'http://www.w3.org/2000/svg',\n                d   : me.markerDef ?? 'M3,0 L3,6 L9,3 z'\n            }]\n        });\n    }\n    updateMarkerDef() {\n        if (!this.isConfiguring) {\n            this.createMarker();\n        }\n    }\n    //endregion\n    //region DomConfig\n    getAssignmentElement(assignment) {\n        // If we are dragging an event, we need to use the proxy element\n        // (which is not the original element if we are not constrained to timeline)\n        const proxyElement = this.client.features.eventDrag?.getProxyElement?.(assignment);\n        return proxyElement || this.client.getElementFromAssignmentRecord(assignment);\n    }\n    // Generate a DomConfig for a dependency line between two assignments (tasks in Gantt)\n    getDomConfigs(dependency, fromAssignment, toAssignment, forceBoxes) {\n        const\n            me     = this,\n            key    = me.getDependencyKey(dependency, fromAssignment, toAssignment),\n            // Under certain circumstances (scrolling) we might be able to reuse the previous DomConfig.\n            cached = me.lineCache[key];\n        // Create line def if not cached, or we are live drawing and have event elements (dragging, transitioning etc)\n        if (me.constructLineCache || !cached || forceBoxes || (me.drawingLive && (me.getAssignmentElement(fromAssignment) || me.getAssignmentElement(toAssignment)))) {\n            const\n                lineDef     = me.prepareLineDef(dependency, fromAssignment, toAssignment, forceBoxes),\n                points      = lineDef && me.pathFinder.findPath(lineDef, me.lineDefAdjusters),\n                {\n                    client,\n                    clickWidth\n                }           = me,\n                { toEvent } = dependency;\n            if (points) {\n                const\n                    highlighted = me.highlighted.get(dependency),\n                    domConfig   = {\n                        tag     : 'path',\n                        ns      : 'http://www.w3.org/2000/svg',\n                        d       : pathMapper(me.radius ?? 0, points),\n                        role    : 'presentation',\n                        dataset : {\n                            syncId : key,\n                            depId  : dependency.id,\n                            fromId : fromAssignment.id,\n                            toId   : toAssignment.id\n                        },\n                        elementData : {\n                            dependency,\n                            points\n                        },\n                        class : {\n                            [me.baseCls]                                : 1,\n                            [dependency.cls]                            : dependency.cls,\n                            // Data highlight\n                            [dependency.highlighted]                    : dependency.highlighted,\n                            // Feature highlight\n                            [highlighted && [...highlighted].join(' ')] : highlighted,\n                            [me.noMarkerCls]                            : lineDef.hideMarker,\n                            'b-inactive'                                : dependency.active === false,\n                            'b-sch-bidirectional-line'                  : dependency.bidirectional,\n                            'b-readonly'                                : dependency.readOnly,\n                            // If target event is outside the view add special CSS class to hide marker (arrow)\n                            'b-sch-dependency-ends-outside' :\n                                (!toEvent.milestone && (toEvent.endDate <= client.startDate || client.endDate <= toEvent.startDate)) ||\n                                (toEvent.milestone && (toEvent.endDate < client.startDate || client.endDate < toEvent.startDate))\n                        }\n                    };\n                me.renderer?.({\n                    domConfig,\n                    points,\n                    dependencyRecord     : dependency,\n                    fromAssignmentRecord : fromAssignment,\n                    toAssignmentRecord   : toAssignment,\n                    fromBox              : lineDef.startBox,\n                    toBox                : lineDef.endBox,\n                    fromSide             : lineDef.startSide,\n                    toSide               : lineDef.endSide\n                });\n                const configs = [domConfig];\n                if (clickWidth > 1) {\n                    configs.push({\n                        ...domConfig, // Shallow on purpose, to not waste perf cloning deeply\n                        class : {\n                            ...domConfig.class,\n                            'b-click-area' : 1\n                        },\n                        dataset : {\n                            ...domConfig.dataset,\n                            syncId : `${domConfig.dataset.syncId}-click-area`\n                        },\n                        style : {\n                            strokeWidth : clickWidth\n                        }\n                    });\n                }\n                return me.lineCache[key] = configs;\n            }\n            // Nothing to draw or cache\n            return me.lineCache[key] = null;\n        }\n        return cached;\n    }\n    //endregion\n    //region Bounds\n    // Generates `otherBoxes` config for rectangular path finder, which push dependency line to the row boundary.\n    // It should be enough to return single box with top/bottom taken from row top/bottom and left/right taken from source\n    // box, extended by start arrow margin to both sides.\n    generateBoundaryBoxes(box, side) {\n        // We need two boxes for the bottom edge, because otherwise path cannot be found. Ideally that shouldn't be\n        // necessary. Other solution would be to adjust bottom by -1px, but that would make some dependency lines to take\n        // 1px different path on a row boundary, which doesn't look nice (but slightly more performant)\n        if (side === 'bottom') {\n            return [\n                {\n                    start  : box.left,\n                    end    : box.left + box.width / 2,\n                    top    : box.rowTop,\n                    bottom : box.rowBottom\n                },\n                {\n                    start  : box.left + box.width / 2,\n                    end    : box.right,\n                    top    : box.rowTop,\n                    bottom : box.rowBottom\n                }\n            ];\n        }\n        else {\n            return [\n                {\n                    start  : box.left - this.pathFinder.startArrowMargin,\n                    end    : box.right + this.pathFinder.startArrowMargin,\n                    top    : box.rowTop,\n                    bottom : box.rowBottom\n                }\n            ];\n        }\n    }\n    // Bounding box for an assignment, uses elements bounds if rendered\n    getAssignmentBounds(assignment) {\n        const\n            { client } = this,\n            element    = this.getAssignmentElement(assignment);\n        if (element && !client.isExporting) {\n            const rectangle = Rectangle.from(element, this.relativeTo);\n            if (client.isHorizontal) {\n                let row = client.getRowById(assignment.resource.id);\n                if (row) {\n                    // Outside its row? It is being dragged, resolve new row\n                    if (rectangle.y < row.top || rectangle.bottom > row.bottom) {\n                        const overRow = client.rowManager.getRowAt(rectangle.center.y, true);\n                        if (overRow) {\n                            row = overRow;\n                        }\n                    }\n                    rectangle.rowTop    = row.top;\n                    rectangle.rowBottom = row.bottom;\n                }\n                else {\n                    return client.getAssignmentEventBox(assignment, true);\n                }\n            }\n            return rectangle;\n        }\n        return client.isEngineReady && client.getAssignmentEventBox(assignment, true);\n    }\n    //endregion\n    //region Sides\n    getConnectorStartSide(timeSpanRecord) {\n        return this.client.currentOrientation.getConnectorStartSide(timeSpanRecord);\n    }\n    getConnectorEndSide(timeSpanRecord) {\n        return this.client.currentOrientation.getConnectorEndSide(timeSpanRecord);\n    }\n    getDependencyStartSide(dependency) {\n        const { fromEvent, type, fromSide } = dependency;\n        if (fromSide) {\n            return fromSide;\n        }\n        switch (true) {\n            case type === DependencyModel.Type.StartToEnd:\n            case type === DependencyModel.Type.StartToStart:\n                return this.getConnectorStartSide(fromEvent);\n            case type === DependencyModel.Type.EndToStart:\n            case type === DependencyModel.Type.EndToEnd:\n                return this.getConnectorEndSide(fromEvent);\n            default:\n                // Default value might not be applied yet when rendering early in Pro / Gantt\n                return this.getConnectorEndSide(fromEvent);\n        }\n    }\n    getDependencyEndSide(dependency) {\n        const { toEvent, type, toSide } = dependency;\n        if (toSide) {\n            return toSide;\n        }\n        // Fallback to view trait if dependency end side is not given /*or can be obtained from type*/\n        switch (true) {\n            case type === DependencyModel.Type.EndToEnd:\n            case type === DependencyModel.Type.StartToEnd:\n                return this.getConnectorEndSide(toEvent);\n            case type === DependencyModel.Type.EndToStart:\n            case type === DependencyModel.Type.StartToStart:\n                return this.getConnectorStartSide(toEvent);\n            default:\n                // Default value might not be applied yet when rendering early in Pro / Gantt\n                return this.getConnectorStartSide(toEvent);\n        }\n    }\n    //endregion\n    //region Line def\n    // An array of functions used to alter path config when no path found.\n    // It first tries to shrink arrow margins and secondly hides arrows entirely\n    createLineDefAdjusters() {\n        const { client } = this;\n        function shrinkArrowMargins(lineDef) {\n            const { barMargin } = client;\n            if (lineDef.startArrowMargin > barMargin || lineDef.endArrowMargin > barMargin) {\n                lineDef.startArrowMargin = lineDef.endArrowMargin = barMargin;\n                return lineDef;\n            }\n            return false;\n        }\n        function resetArrowMargins(lineDef) {\n            if (lineDef.startArrowMargin > 0 || lineDef.endArrowMargin > 0) {\n                lineDef.startArrowMargin = lineDef.endArrowMargin = 0;\n                return lineDef;\n            }\n            return false;\n        }\n        function shrinkHorizontalMargin(lineDef, originalLineDef) {\n            if (lineDef.horizontalMargin > 2) {\n                lineDef.horizontalMargin   = 1;\n                originalLineDef.hideMarker = true;\n                return lineDef;\n            }\n            return false;\n        }\n        const adjusters = [\n            shrinkArrowMargins,\n            resetArrowMargins,\n            shrinkHorizontalMargin\n        ];\n        // When using nested events, we first try calculating a new path by ignoring nested parent boxes\n        if (client.features.nestedEvents?.enabled) {\n            adjusters.unshift(lineDef => {\n                if (lineDef.otherBoxes.length) {\n                    lineDef.otherBoxes.length = lineDef.otherBoxes.nestedStart;\n                }\n                return lineDef;\n            });\n        }\n        return adjusters;\n    }\n    // Overridden in Gantt\n    adjustLineDef(dependency, lineDef) {\n        return lineDef;\n    }\n    // Prepare data to feed to the path finder\n    prepareLineDef(dependency, fromAssignment, toAssignment, forceBoxes) {\n        const\n            me             = this,\n            startSide      = me.getDependencyStartSide(dependency),\n            endSide        = me.getDependencyEndSide(dependency),\n            startRectangle = forceBoxes?.from ?? me.getAssignmentBounds(fromAssignment),\n            endRectangle   = forceBoxes?.to ?? me.getAssignmentBounds(toAssignment),\n            otherBoxes     = [];\n        if (!startRectangle || !endRectangle) {\n            return null;\n        }\n        let {\n            startArrowMargin,\n            verticalMargin\n        } = me.pathFinder;\n        if (me.client.isHorizontal) {\n            // Only add otherBoxes if assignments are in different resources\n            if (startRectangle.rowTop != null && startRectangle.rowTop !== endRectangle.rowTop) {\n                otherBoxes.push(...me.generateBoundaryBoxes(startRectangle, startSide));\n            }\n            // Generate other boxes for nested event parents if configured to do so\n            if (me.client.features.nestedEvents?.enabled && me.drawAroundParents) {\n                const\n                    { resourceStore } = me.client,\n                    fromResource      = fromAssignment.resource,\n                    toResource        = toAssignment.resource,\n                    fromIndex         = resourceStore.indexOf(fromResource),\n                    toIndex           = resourceStore.indexOf(toResource),\n                    minIndex          = Math.min(fromIndex, toIndex),\n                    maxIndex          = Math.max(fromIndex, toIndex);\n                otherBoxes.nestedStart = otherBoxes.length;\n                for (const assignment of me.client.assignmentStore) {\n                    // Ignore leaf assignments\n                    if (assignment !== fromAssignment && assignment !== toAssignment && assignment.event?.isParent && fromAssignment.event.parent !== assignment.event && toAssignment.event.parent !== assignment.event) {\n                        const currentIndex = resourceStore.indexOf(assignment.resource);\n                        // Only add otherBoxes for assignments whose row is intersected by the dependency line\n                        if (currentIndex >= minIndex && currentIndex <= maxIndex) {\n                            const assignmentBox          = me.getAssignmentBounds(assignment).inflate(startArrowMargin);\n                            // Flag to allow ignoring if no path can be found\n                            assignmentBox.isNestedParent = true;\n                            otherBoxes.push(assignmentBox);\n                        }\n                    }\n                }\n            }\n            // Do not change start arrow margin in case dependency is bidirectional\n            if (!dependency.bidirectional) {\n                if (/(top|bottom)/.test(startSide)) {\n                    startArrowMargin = me.client.barMargin / 2;\n                }\n                verticalMargin = me.client.barMargin / 2;\n            }\n        }\n        return me.adjustLineDef(dependency, {\n            startBox              : startRectangle,\n            endBox                : endRectangle,\n            otherBoxes,\n            startArrowMargin,\n            verticalMargin,\n            otherVerticalMargin   : 0,\n            otherHorizontalMargin : 0,\n            startSide,\n            endSide\n        });\n    }\n    //endregion\n    //region Cache\n    // All dependencies are about to be drawn, check if we need to build the line cache\n    beforeDraw() {\n        super.beforeDraw();\n        if (!Object.keys(this.lineCache).length) {\n            this.constructLineCache = true;\n        }\n    }\n    // All dependencies are drawn, we no longer need to rebuild the cache\n    afterDraw() {\n        super.afterDraw();\n        this.constructLineCache = false;\n    }\n    reset() {\n        super.reset();\n        this.lineCache = {};\n    }\n    //endregion\n};\n", "import DomSync from '../../Core/helper/DomSync.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport AttachToProjectMixin from '../data/mixin/AttachToProjectMixin.js';\nimport DependencyCreation from './mixin/DependencyCreation.js';\nimport DependencyGridCache from './mixin/DependencyGridCache.js';\nimport DependencyLineGenerator from './mixin/DependencyLineGenerator.js';\nimport DependencyTooltip from './mixin/DependencyTooltip.js';\nconst\n    eventNameMap = {\n        click       : 'Click',\n        dblclick    : 'DblClick',\n        contextmenu : 'ContextMenu'\n    },\n    emptyObject = Object.freeze({});\n/**\n * @module Scheduler/feature/Dependencies\n */\nconst collectLinkedAssignments = assignment => {\n    const result = [assignment];\n    if (assignment.resource?.hasLinks) {\n        // Fake linked assignments\n        result.push(...assignment.resource.$links.map(l => ({\n            id               : `${l.id}_${assignment.id}`,\n            resource         : l,\n            event            : assignment.event,\n            drawDependencies : assignment.drawDependencies\n        })));\n    }\n    return result;\n};\n/**\n * Feature that draws dependencies between events. Uses a {@link Scheduler.data.DependencyStore} to determine which\n * dependencies to draw, if none is defined one will be created automatically. Dependencies can also be specified as\n * `scheduler.dependencies`, see example below:\n *\n * {@inlineexample Scheduler/feature/Dependencies.js}\n *\n * Dependencies also work in vertical mode:\n *\n * {@inlineexample Scheduler/feature/DependenciesVertical.js}\n *\n * To customize the dependency tooltip, you can provide the {@link #config-tooltip} config and specify a\n * {@link Core.widget.Tooltip#config-getHtml} function. For example:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         dependencies : {\n *             tooltip : {\n *                 getHtml({ activeTarget }) {\n *                     const dependencyModel = scheduler.resolveDependencyRecord(activeTarget);\n *\n *                     if (!dependencyModel) return null;\n *\n *                     const { fromEvent, toEvent } = dependencyModel;\n *\n *                     return `${fromEvent.name} (${fromEvent.id}) -> ${toEvent.name} (${toEvent.id})`;\n *                 }\n *             }\n *         }\n *     }\n * }\n * ```\n *\n * ## Styling dependency lines\n *\n * You can easily customize the arrows drawn between events. To change all arrows, apply the following basic SVG CSS:\n *\n * ```css\n * .b-sch-dependency {\n *    stroke-width: 2;\n *    stroke : red;\n * }\n *\n * .b-sch-dependency-arrow {\n *     fill: red;\n * }\n * ```\n *\n * To style an individual dependency line, you can provide a [cls](#Scheduler/model/DependencyModel#field-cls) in your\n * data:\n *\n * ```json\n * {\n *     \"id\"   : 9,\n *     \"from\" : 7,\n *     \"to\"   : 8,\n *     \"cls\"  : \"special-dependency\"\n * }\n * ```\n *\n * ```scss\n * // Make line dashed\n * .b-sch-dependency {\n *    stroke-dasharray: 5, 5;\n * }\n * ```\n *\n * To customize the marker used for the lines (the arrow header), you can supply a SVG path definition to the\n * {@link #config-markerDef} config:\n *\n * {@inlineexample Scheduler/feature/DependenciesMarker.js}\n *\n * You can also specify a {@link #config-radius} to get lines with rounded \"corners\", for a less boxy look:\n *\n * {@inlineexample Scheduler/feature/DependenciesRadius.js}\n *\n * For advanced use cases, you can also manipulate the {@link DomConfig} used to create a dependency line in a\n * {@link #config-renderer} function.\n *\n * ## Adjusting terminals\n *\n * When hovering an event bar, terminals (connection points) for creating new dependencies are shown. By default, they\n * have a diameter of 12px and are positioned at the edge of the event bar. You can customize this by setting\n * {@link #config-terminalSize} and {@link #config-terminalOffset}. The example below uses larger terminals offset to\n * outside the event bar:\n *\n * {@inlineexample Scheduler/feature/DependenciesTerminals.js}\n *\n * This feature is **disabled** by default.\n * For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * @demo Scheduler/dependencies\n *\n * @extends Core/mixin/InstancePlugin\n * @mixes Core/mixin/Delayable\n * @mixes Scheduler/feature/mixin/DependencyCreation\n * @mixes Scheduler/feature/mixin/DependencyTooltip\n * @classtype dependencies\n * @feature\n */\nexport default class Dependencies extends InstancePlugin.mixin(\n    AttachToProjectMixin,\n    Delayable,\n    DependencyCreation,\n    DependencyGridCache,\n    DependencyLineGenerator,\n    DependencyTooltip\n) {\n    static $name = 'Dependencies';\n    /**\n     * Fired when dependencies are rendered\n     * @on-owner\n     * @event dependenciesDrawn\n     */\n    //region Config\n    static configurable = {\n        /**\n         * The CSS class to add to a dependency line when hovering over it\n         * @config {String}\n         * @default\n         * @private\n         */\n        overCls : 'b-sch-dependency-over',\n        /**\n         * The CSS class applied to dependency lines\n         * @config {String}\n         * @default\n         * @private\n         */\n        baseCls : 'b-sch-dependency',\n        /**\n         * The CSS class applied to a too narrow dependency line (to hide markers)\n         * @config {String}\n         * @default\n         * @private\n         */\n        noMarkerCls : 'b-sch-dependency-markerless',\n        /**\n         * SVG path definition used as marker (arrow head) for the dependency lines.\n         * Should fit in a viewBox that is 9 x 6.\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         dependencies : {\n         *             // Circular marker\n         *             markerDef : 'M 2,3 a 3,3 0 1,0 6,0 a 3,3 0 1,0 -6,0'\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * @config {String}\n         * @default 'M3,0 L3,6 L9,3 z'\n         */\n        markerDef : null,\n        /**\n         * Radius (in px) used to draw arcs where dependency line segments connect. Specify it to get a rounded look.\n         * The radius will during drawing be reduced as needed on a per segment basis to fit lines.\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         dependencies : {\n         *             // Round the corner where line segments connect, similar to 'border-radius: 5px'\n         *             radius : 5\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * <div class=\"note\">Using a radius slightly degrades dependency rendering performance. If your app displays\n         * a lot of dependencies, it might be worth taking this into account when deciding if you want to use radius\n         * or not</div>\n         *\n         * @config {Number}\n         */\n        radius : null,\n        /**\n         * Renderer function, supply one if you want to manipulate the {@link DomConfig} object used to draw a\n         * dependency line between two assignments.\n         *\n         * ```javascript\n         * const scheduler = new Scheduler({\n         *     features : {\n         *         dependencies : {\n         *             renderer({ domConfig, fromAssignmentRecord : from, toAssignmentRecord : to }) {\n         *                 // Add a custom CSS class to dependencies between important assignments\n         *                 domConfig.class.important = from.important || to.important;\n         *                 domConfig.class.veryImportant = from.important && to.important;\n         *             }\n         *         }\n         *     }\n         * }\n         * ```\n         *\n         * @prp {Function}\n         * @param {Object} renderData\n         * @param {DomConfig} renderData.domConfig that will be used to create the dependency line, can be manipulated by the renderer\n         * @param {Scheduler.model.DependencyModel} renderData.dependencyRecord The dependency being rendered\n         * @param {Scheduler.model.AssignmentModel} renderData.fromAssignmentRecord Drawing line from this assignment\n         * @param {Scheduler.model.AssignmentModel} renderData.toAssignmentRecord Drawing line to this assignment\n         * @param {Object[]} renderData.points A collection of points making up the line segments for the dependency line.\n         *   Read-only in the renderer, any manipulation should be done to `domConfig`\n         * @param {Core.helper.util.Rectangle} renderData.fromBox Bounds for the fromAssignment's element\n         * @param {Core.helper.util.Rectangle} renderData.toBox Bounds for the toAssignment's element\n         * @param {'top'|'right'|'bottom'|'left'} renderData.fromSide Drawn from this side of the fromAssignment\n         * @param {'top'|'right'|'bottom'|'left'} renderData.toSide Drawn to this side of the fromAssignment\n         * @returns {void}\n         *\n         * @category Rendering\n         */\n        renderer : null,\n        /**\n         * Specify `true` to highlight incoming and outgoing dependencies when hovering an event.\n         * @prp {Boolean}\n         */\n        highlightDependenciesOnEventHover : null,\n        /**\n         * Specify `false` to prevent dependencies from being drawn during scroll, for smoother scrolling in schedules\n         * with lots of dependencies. Dependencies will be drawn when scrolling stops instead.\n         * @prp {Boolean}\n         * @default\n         */\n        drawOnScroll : true,\n        /**\n         * The clickable/touchable width of the dependency line in pixels. Setting this to a number greater than 1 will\n         * draw an invisible but clickable line along the same path as the dependency line, making it easier to click.\n         * The tradeoff is that twice as many lines will be drawn, which can affect performance.\n         * @prp {Number}\n         */\n        clickWidth : null,\n        /**\n         * By default, the refresh of dependencies is buffered by 10 milliseconds so that multiple changes\n         * which may cause the dependency lines to become invalid are coalesced into one refresh. This is more\n         * efficient, but may mean the dependency lines may lag behind expectations when moving a pointer.\n         *\n         * Set this to `true` to update dependency lines immediately upon any change which causes them\n         * to require an update.\n         * @prp {Boolean}\n         * @default false\n         * @private\n         */\n        immediateRefresh : null,\n        /**\n         * *Experimental* - This setting only applies when using dependencies with the nested events feature. In such\n         * scenarios, enabling this config will cause the dependency lines to, when the algorithm determines it is\n         * possible, be drawn around parent events, instead of through them.\n         *\n         * {@note}\n         * Note that enabling this feature increases the complexity of dependency drawing, and it does have a negative\n         * impact on performance.\n         * {/@note}\n         *\n         * @prp {Boolean}\n         */\n        drawAroundParents : null\n    };\n    static delayable = {\n        doRefresh  : 10,\n        rafRefresh : 'raf'\n    };\n    static get pluginConfig() {\n        return {\n            chain  : ['render', 'onInternalPaint', 'onElementClick', 'onElementDblClick', 'onElementContextMenu', 'onElementMouseOver', 'onElementMouseOut', 'bindStore'],\n            assign : ['getElementForDependency', 'getElementsForDependency', 'resolveDependencyRecord']\n        };\n    };\n    domConfigs  = new Map();\n    drawingLive = false;\n    lastScrollX = null;\n    highlighted = new Map();\n    // Cached lookups\n    visibleResources = null;\n    usingLinks       = null;\n    visibleDateRange = null;\n    relativeTo       = null;\n    //endregion\n    //region Init & destroy\n    construct(client, config) {\n        super.construct(client, config);\n        const { scheduledEventName } = client;\n        client.ion({\n            svgCanvasCreated                            : 'onSVGReady',\n            // These events trigger live refresh behaviour\n            animationStart                              : 'refresh',\n            // eventDrag in Scheduler, taskDrag in Gantt\n            [scheduledEventName + 'DragStart']          : 'refresh',\n            [scheduledEventName + 'DragAbort']          : 'refresh',\n            [scheduledEventName + 'ResizeStart']        : 'refresh',\n            [scheduledEventName + 'SegmentDragStart']   : 'refresh',\n            [scheduledEventName + 'SegmentResizeStart'] : 'refresh',\n            // These events shift the surroundings to such extent that grid cache needs rebuilding to be sure that\n            // all dependencies are considered\n            timelineViewportResize                      : 'reset',\n            timeAxisViewModelUpdate                     : 'reset',\n            toggleNode                                  : 'reset',\n            thisObj                                     : this\n        });\n        client.rowManager.ion({\n            refresh           : 'reset', // For example when changing barMargin or rowHeight\n            changeTotalHeight : 'reset', // For example when collapsing groups\n            thisObj           : this\n        });\n        this.bindStore(client.store);\n    }\n    doDisable(disable) {\n        if (!this.isConfiguring) {\n            // Need a flag to clear dependencies when disabled, since drawing is otherwise disabled too\n            this._isDisabling = disable;\n            this.draw();\n            this._isDisabling = false;\n        }\n        super.doDisable(disable);\n    }\n    //endregion\n    //region RefreshTriggers\n    get rowStore() {\n        return this.client.isVertical ? this.client.resourceStore : this.client.store;\n    }\n    // React to replacing or refreshing a display store\n    bindStore(store) {\n        const me = this;\n        if (!me.client.isVertical) {\n            me.detachListeners('store');\n            if (me.client.usesDisplayStore) {\n                store?.ion({\n                    name    : 'store',\n                    refresh : 'onStoreRefresh',\n                    thisObj : me\n                });\n                me.reset();\n            }\n        }\n    }\n    onStoreRefresh() {\n        this.reset();\n    }\n    attachToProject(project) {\n        super.attachToProject(project);\n        project?.ion({\n            name            : 'project',\n            commitFinalized : 'reset',\n            thisObj         : this\n        });\n    }\n    attachToResourceStore(resourceStore) {\n        super.attachToResourceStore(resourceStore);\n        resourceStore?.ion({\n            name    : 'resourceStore',\n            change  : 'onResourceStoreChange',\n            refresh : 'onResourceStoreChange',\n            thisObj : this\n        });\n    }\n    onResourceStoreChange() {\n        // Might have added or removed links, need to re-cache the flag\n        this.usingLinks = null;\n        this.reset();\n    }\n    attachToEventStore(eventStore) {\n        super.attachToEventStore(eventStore);\n        eventStore?.ion({\n            name    : 'eventStore',\n            refresh : 'reset',\n            thisObj : this\n        });\n    }\n    attachToAssignmentStore(assignmentStore) {\n        super.attachToAssignmentStore(assignmentStore);\n        assignmentStore?.ion({\n            name    : 'assignmentStore',\n            refresh : 'reset',\n            thisObj : this\n        });\n    }\n    attachToDependencyStore(dependencyStore) {\n        super.attachToDependencyStore(dependencyStore);\n        dependencyStore?.ion({\n            name    : 'dependencyStore',\n            change  : 'reset',\n            refresh : 'reset',\n            thisObj : this\n        });\n    }\n    updateDrawOnScroll(drawOnScroll) {\n        const me = this;\n        me.detachListeners('scroll');\n        if (drawOnScroll) {\n            me.client.ion({\n                name             : 'scroll',\n                scroll           : 'doRefresh',\n                horizontalScroll : 'onHorizontalScroll',\n                prio             : -100, // After Scheduler draws on scroll, since we target elements\n                thisObj          : me\n            });\n        }\n        else {\n            me.client.scrollable.ion({\n                name      : 'scroll',\n                scrollEnd : 'draw',\n                thisObj   : me\n            });\n            me.client.timeAxisSubGrid.scrollable.ion({\n                name      : 'scroll',\n                scrollEnd : 'draw',\n                thisObj   : me\n            });\n        }\n    }\n    onHorizontalScroll({ subGrid, scrollX }) {\n        if (scrollX !== this.lastScrollX && subGrid === this.client.timeAxisSubGrid) {\n            this.lastScrollX = scrollX;\n            this.draw();\n        }\n    }\n    onInternalPaint() {\n        this.refresh();\n    }\n    //endregion\n    //region Dependency types\n    // Used by DependencyField\n    static getLocalizedDependencyType(type) {\n        return type ? this.L(`L{DependencyType.${type}}`) : '';\n    }\n    //endregion\n    //region Elements\n    getElementForDependency(dependency, fromAssignment, toAssignment) {\n        return this.getElementsForDependency(dependency, fromAssignment, toAssignment)[0];\n    }\n    // NOTE: If we ever make this public we should change it to use the syncIdMap. Currently not needed since only\n    // used in tests\n    getElementsForDependency(dependency, fromAssignment, toAssignment) {\n        // Selector targeting all instances of a dependency\n        let selector = `[data-dep-id=\"${dependency.id}\"]`;\n        // Optionally narrow it down to a single instance (assignment)\n        if (fromAssignment) {\n            selector += `[data-from-id=\"${fromAssignment.id}\"]`;\n        }\n        if (toAssignment) {\n            selector += `[data-to-id=\"${toAssignment.id}\"]`;\n        }\n        return Array.from(this.client.svgCanvas.querySelectorAll(selector));\n    }\n    /**\n     * Returns the dependency record for a DOM element\n     * @param {HTMLElement} element The dependency line element\n     * @returns {Scheduler.model.DependencyModel} The dependency record\n     */\n    resolveDependencyRecord(element) {\n        return element.elementData?.dependency;\n    }\n    isDependencyElement(element) {\n        return element.matches(`.${this.baseCls}`);\n    }\n    //endregion\n    //region DOM Events\n    onElementClick(event) {\n        const dependency = this.resolveDependencyRecord(event.target);\n        if (dependency) {\n            const eventName = eventNameMap[event.type];\n            /**\n             * Fires on the owning Scheduler/Gantt when a context menu event is registered on a dependency line.\n             * @event dependencyContextMenu\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            /**\n             * Fires on the owning Scheduler/Gantt when a click is registered on a dependency line.\n             * @event dependencyClick\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            /**\n             * Fires on the owning Scheduler/Gantt when a double click is registered on a dependency line.\n             * @event dependencyDblClick\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            this.client.trigger(`dependency${eventName}`, {\n                dependency,\n                event\n            });\n        }\n    }\n    onElementDblClick(event) {\n        return this.onElementClick(event);\n    }\n    onElementContextMenu(event) {\n        return this.onElementClick(event);\n    }\n    onElementMouseOver(event) {\n        const\n            me         = this,\n            dependency = me.resolveDependencyRecord(event.target);\n        if (dependency) {\n            /**\n             * Fires on the owning Scheduler/Gantt when the mouse moves over a dependency line.\n             * @event dependencyMouseOver\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            me.client.trigger('dependencyMouseOver', {\n                dependency,\n                event\n            });\n            if (me.overCls) {\n                me.highlight(dependency);\n            }\n        }\n    }\n    onElementMouseOut(event) {\n        const\n            me         = this,\n            dependency = me.resolveDependencyRecord(event.target);\n        if (dependency) {\n            /**\n             * Fires on the owning Scheduler/Gantt when the mouse moves out of a dependency line.\n             * @event dependencyMouseOut\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.model.DependencyModel} dependency\n             * @param {MouseEvent} event\n             */\n            me.client.trigger('dependencyMouseOut', {\n                dependency,\n                event\n            });\n            if (me.overCls) {\n                me.unhighlight(dependency);\n            }\n        }\n    }\n    //endregion\n    //region Export\n    // Export calls this fn to determine if a dependency should be included or not\n    isDependencyVisible(dependency) {\n        const\n            me           = this,\n            { rowStore } = me,\n            {\n                fromEvent,\n                toEvent\n            }            = dependency;\n        // Bail out early in case source or target doesn't exist\n        if (!fromEvent || !toEvent) {\n            return false;\n        }\n        const\n            fromResource = fromEvent.resource,\n            toResource   = toEvent.resource;\n        // Verify these are real existing Resources and not collapsed away (resource not existing in resource store)\n        if (!rowStore.isAvailable(fromResource) || !rowStore.isAvailable(toResource)) {\n            return false;\n        }\n        return fromEvent.isModel &&\n            !fromResource.instanceMeta(rowStore).hidden &&\n            !toResource.instanceMeta(rowStore).hidden;\n    }\n    //endregion\n    //region Highlight\n    updateHighlightDependenciesOnEventHover(enable) {\n        const me = this;\n        if (enable) {\n            const { client } = me;\n            client.ion({\n                name                                       : 'highlightOnHover',\n                [`${client.scheduledEventName}MouseEnter`] : params => me.highlightEventDependencies(params.eventRecord || params.taskRecord),\n                [`${client.scheduledEventName}MouseLeave`] : params => me.unhighlightEventDependencies(params.eventRecord || params.taskRecord),\n                thisObj                                    : me\n            });\n        }\n        else {\n            me.detachListeners('highlightOnHover');\n        }\n    }\n    highlight(dependency, cls = this.overCls) {\n        let classes = this.highlighted.get(dependency);\n        if (!classes) {\n            this.highlighted.set(dependency, classes = new Set());\n        }\n        classes.add(cls);\n        // Update element directly instead of refreshing and letting DomSync handle it,\n        // to optimize highlight performance with many dependencies on screen\n        for (const element of this.getElementsForDependency(dependency)) {\n            element.classList.add(cls);\n        }\n    }\n    unhighlight(dependency, cls = this.overCls) {\n        const classes = this.highlighted.get(dependency);\n        if (classes) {\n            classes.delete(cls);\n            if (!classes.size) {\n                this.highlighted.delete(dependency);\n            }\n        }\n        // Update element directly instead of refreshing and letting DomSync handle it,\n        // to optimize highlight performance with many dependencies on screen\n        for (const element of this.getElementsForDependency(dependency)) {\n            element.classList.remove(cls);\n        }\n    }\n    highlightEventDependencies(timespan, cls) {\n        timespan.dependencies.forEach(dep => this.highlight(dep, cls));\n    }\n    unhighlightEventDependencies(timespan, cls) {\n        timespan.dependencies.forEach(dep => this.unhighlight(dep, cls));\n    }\n    //endregion\n    //region Drawing\n    // Implemented in DependencyGridCache to return dependencies that might intersect the current viewport and thus\n    // should be considered for drawing. Fallback value here is used when there is no grid cache (which happens when it\n    // is reset. Also useful in case we want to have it configurable or opt out automatically for small datasets)\n    getDependenciesToConsider(startMS, endMS, startIndex, endIndex) {\n        const { eventStore } = this.project;\n        // Get records from grid cache\n        return super.getDependenciesToConsider?.(startMS, endMS, startIndex, endIndex) ??\n            // Falling back to using all valid deps (fix for not trying to draw conflicted deps)\n            this.project.dependencyStore.records.filter(d => d.isValid && !eventStore.isFiltered || (eventStore.isAvailable(d.fromEvent) && eventStore.isAvailable(d.toEvent)));\n    }\n    // String key used as syncId\n    getDependencyKey(dependency, fromAssignment, toAssignment) {\n        return `dep:${dependency.id};from:${fromAssignment.id};to:${toAssignment.id}`;\n    }\n    drawDependency(dependency, batch = false, forceBoxes = null) {\n        const\n            me           = this,\n            {\n                domConfigs,\n                client,\n                rowStore,\n                topIndex,\n                bottomIndex\n            }            = me,\n            {\n                useInitialAnimation\n            }            = client,\n            { idMap }    = rowStore,\n            {\n                startMS,\n                endMS\n            }            = me.visibleDateRange,\n            {\n                fromEvent,\n                toEvent\n            }            = dependency;\n        let fromAssigned = fromEvent.assigned,\n            toAssigned   = toEvent.assigned;\n        if (\n            // No point in trying to draw dep between unscheduled/non-existing events\n            fromEvent.isScheduled && toEvent.isScheduled &&\n            // Or unassigned ones\n            fromAssigned?.size && toAssigned?.size\n        ) {\n            // Add links, if used\n            if (me.usingLinks) {\n                fromAssigned = [...fromAssigned].flatMap(collectLinkedAssignments);\n                toAssigned = [...toAssigned].flatMap(collectLinkedAssignments);\n            }\n            for (const from of fromAssigned) {\n                for (const to of toAssigned) {\n                    const\n                        // Using direct lookup in idMap instead of indexOf() for performance.\n                        // Resource might be filtered out or not exist at all\n                        fromIndex  = idMap[from.resource?.id]?.index,\n                        toIndex    = idMap[to.resource?.id]?.index,\n                        fromDateMS = Math.min(fromEvent.startDateMS, toEvent.startDateMS),\n                        toDateMS   = Math.max(fromEvent.endDateMS, toEvent.endDateMS);\n                    // Draw only if dependency intersects view, unless it is part of an export\n                    if (\n                        client.isExporting || fromIndex != null && toIndex != null &&\n                        (from.drawDependencies !== false && to.drawDependencies !== false) &&\n                        (rowStore.isAvailable(from.resource) && (rowStore.isAvailable(to.resource))) && !(\n                            // Both ends above view\n                            (fromIndex < topIndex && toIndex < topIndex) ||\n                            // Both ends below view\n                            (fromIndex > bottomIndex && toIndex > bottomIndex) ||\n                            // Both ends before view\n                            (fromDateMS < startMS && toDateMS < startMS) ||\n                            // Both ends after view\n                            (fromDateMS > endMS && toDateMS > endMS)\n                        )\n                    ) {\n                        const\n                            key            = me.getDependencyKey(dependency, from, to),\n                            lineDomConfigs = me.getDomConfigs(dependency, from, to, forceBoxes);\n                        if (lineDomConfigs) {\n                            // Allow deps to match animation delay of their events (the bottommost one) when fading in\n                            if (useInitialAnimation) {\n                                lineDomConfigs[0].style = {\n                                    animationDelay : `${Math.max(fromIndex, toIndex) / 20 * 1000}ms`\n                                };\n                            }\n                            domConfigs.set(key, lineDomConfigs);\n                        }\n                        // No room to draw a line\n                        else {\n                            domConfigs.delete(key);\n                        }\n                    }\n                    // Give mixins a shot at running code after a dependency is drawn. Used by grid cache to cache the\n                    // dependency (when needed)\n                    me.afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS);\n                }\n            }\n        }\n        if (!batch) {\n            me.domSync();\n        }\n    }\n    // Hooks used by grid cache, to keep code in this file readable\n    afterDrawDependency(dependency, fromIndex, toIndex, fromDateMS, toDateMS) {\n        super.afterDrawDependency?.(dependency, fromIndex, toIndex, fromDateMS, toDateMS);\n    }\n    beforeDraw() {\n        super.beforeDraw?.();\n    }\n    afterDraw() {\n        super.afterDraw?.();\n    }\n    // Update DOM\n    domSync(targetElement = this.client.svgCanvas, batch = false) {\n        DomSync.sync({\n            targetElement,\n            domConfig : {\n                onlyChildren : true,\n                children     : Array.from(this.domConfigs.values()).flat()\n            },\n            syncIdField      : 'syncId',\n            releaseThreshold : 0,\n            strict           : true,\n            callback() {\n            }\n        });\n        if (batch) {\n            this.clearDomConfigs();\n        }\n    }\n    fillDrawingCache() {\n        const\n            me         = this,\n            { client } = me;\n        // Cache subgrid bounds for the duration of this draw call to not have to figure it out per dep\n        me.relativeTo = Rectangle.from(client.svgCanvas);\n        // Cache other lookups too\n        me.visibleResources = client.visibleResources;\n        me.visibleDateRange = client.visibleDateRange;\n        me.topIndex     = me.rowStore.indexOf(me.visibleResources.first);\n        me.bottomIndex  = me.rowStore.indexOf(me.visibleResources.last);\n        // Cache link lookup, to avoid semi-expensive flatMap calls in drawDependency\n        if (me.usingLinks == null) {\n            me.usingLinks = client.resourceStore.some(r => r.hasLinks);\n        }\n    }\n    clearDomConfigs() {\n        this.domConfigs.clear();\n    }\n    // Draw all dependencies intersecting the current viewport immediately\n    draw() {\n        const\n            me                  = this,\n            { client }          = me,\n            { visibleDateRange } = client;\n        if (client.refreshSuspended || !client.foregroundCanvas || !visibleDateRange || !client.isEngineReady || (me.disabled && !me._isDisabling) || client.isExporting) {\n            return;\n        }\n        me.fillDrawingCache();\n        me.clearDomConfigs();\n        // Nothing to draw if there are no rows or no ticks or we are disabled\n        if (client.firstVisibleRow && client.lastVisibleRow && client.timeAxis.count && !me.disabled &&\n            (visibleDateRange.endMS - visibleDateRange.startMS > 0)\n        ) {\n            const\n                {\n                    topIndex,\n                    bottomIndex\n                }                   = me,\n                dependencies        = me.getDependenciesToConsider(visibleDateRange.startMS, visibleDateRange.endMS, topIndex, bottomIndex);\n            // Give mixins a shot at doing something before deps are drawn. Used by grid cache to determine if\n            // the cache should be rebuilt\n            me.beforeDraw();\n            for (const dependency of dependencies) {\n                me.drawDependency(dependency, true);\n            }\n            // Give mixins a shot at doing something after all deps are drawn\n            me.afterDraw();\n        }\n        me.domSync();\n        client.trigger('dependenciesDrawn');\n    }\n    //endregion\n    //region Refreshing\n    // Performs a draw on next frame, not intended to be called directly, call refresh() instead\n    doRefresh() {\n        const\n            me                               = this,\n            { client }                       = me,\n            { scheduledEventName, features } = client;\n        me.draw();\n        // Refresh each frame during animations, during dragging & resizing  (if we have dependencies)\n        me.drawingLive = client.dependencyStore.count &&\n            (\n                client.isAnimating || (client.useInitialAnimation && client.eventStore.count) ||\n                features[`${scheduledEventName}Drag`]?.isActivelyDragging ||\n                features[`${scheduledEventName}Drag`]?.isAborting ||\n                features[`${scheduledEventName}Resize`]?.isResizing ||\n                features[`${scheduledEventName}SegmentDrag`]?.isActivelyDragging ||\n                features[`${scheduledEventName}SegmentResize`]?.isResizing\n            );\n        me.drawingLive && me.refresh(false, true);\n    }\n    rafRefresh() {\n        this.doRefresh.now();\n    }\n    /**\n     * Redraws dependencies on the next animation frame\n     */\n    refresh(immediateRefresh = this.immediateRefresh, rafRefresh = false) {\n        const\n            me         = this,\n            { client } = me;\n        // Queue up a draw unless refresh is suspended.\n        // immediateRefresh must be true to function because this method may be used as an event listener\n        // so therefore may receive an event object as a sole parameter.\n        if (!client.refreshSuspended && !me.disabled && client.isPainted && !client.timeAxisSubGrid.collapsed) {\n            if (immediateRefresh) {\n                me.doRefresh.now();\n            }\n            // When live updating, we want to refresh on frame to avoid lagging behind\n            else if (rafRefresh) {\n                me.rafRefresh();\n            }\n            else {\n                me.doRefresh();\n            }\n        }\n    }\n    // Resets grid cache and performs a draw on next frame. Conditions when it should be called:\n    // * Zooming\n    // * Shifting time axis\n    // * Resizing window\n    // * CRUD\n    // ...\n    reset({ source, type } = emptyObject) {\n        super.reset?.();\n        // Refresh immediately if the timeline viewport is changing size\n        this.refresh(source === this.client && type === 'timelineviewportresize');\n    }\n    /**\n     * Draws all dependencies for the specified task.\n     * @deprecated 5.1 The Dependencies feature was refactored and this fn is no longer needed\n     */\n    drawForEvent() {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Dependencies.drawForEvent() is no longer needed');\n        this.refresh();\n    }\n    //endregion\n    //region Scheduler hooks\n    render() {\n        // Pull in the svg canvas early, to have it available during drawing\n        this.client.getConfig('svgCanvas');\n    }\n    //endregion\n}\nDependencies._$name = 'Dependencies'; GridFeatureManager.registerFeature(Dependencies, false, ['Scheduler', 'ResourceHistogram']);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\n/**\n * @module Scheduler/feature/EventFilter\n */\n/**\n * Adds event filter menu items to the timeline header context menu.\n *\n * {@inlineexample Scheduler/feature/EventFilter.js}\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *   features : {\n *     eventFilter : true // `true` by default, set to `false` to disable the feature and remove the menu item from the timeline header\n *   }\n * });\n * ```\n *\n * This feature is **enabled** by default\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype eventFilter\n * @feature\n */\nexport default class EventFilter extends InstancePlugin {\n    static get $name() {\n        return 'EventFilter';\n    }\n    static get pluginConfig() {\n        return {\n            chain : ['populateTimeAxisHeaderMenu']\n        };\n    }\n    /**\n     * Populates the header context menu items.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateTimeAxisHeaderMenu({ items }) {\n        const me = this;\n        items.eventsFilter = {\n            text        : 'L{filterEvents}',\n            icon        : 'b-fw-icon b-icon-filter',\n            disabled    : me.disabled,\n            localeClass : me,\n            weight      : 100,\n            menu        : {\n                type        : 'popup',\n                localeClass : me,\n                items       : {\n                    nameFilter : {\n                        weight               : 110,\n                        type                 : 'textfield',\n                        cls                  : 'b-eventfilter b-last-row',\n                        clearable            : true,\n                        keyStrokeChangeDelay : 300,\n                        label                : 'L{byName}',\n                        localeClass          : me,\n                        width                : 200,\n                        internalListeners    : {\n                            change  : me.onEventFilterChange,\n                            thisObj : me\n                        }\n                    }\n                },\n                onBeforeShow({ source : menu }) {\n                    const\n                        [filterByName] = menu.items,\n                        filter         = me.store.filters.getBy('property', 'name');\n                    filterByName.value = filter?.value || '';\n                }\n            }\n        };\n    }\n    onEventFilterChange({ value }) {\n        if (value !== '') {\n            this.store.filter('name', value);\n        }\n        else {\n            this.store.removeFilter('name');\n        }\n    }\n    get store() {\n        const { client } = this;\n        return client.isGanttBase ? client.store : client.eventStore;\n    }\n}\nEventFilter.featureClass = 'b-event-filter';\nEventFilter._$name = 'EventFilter'; GridFeatureManager.registerFeature(EventFilter, true, ['Scheduler', 'Gantt']);\nGridFeatureManager.registerFeature(EventFilter, false, 'ResourceHistogram');\n", "import DateHelper from '../../../Core/helper/DateHelper.js';\nimport TimeSpan from '../../model/TimeSpan.js';\n/**\n * @module Scheduler/feature/mixin/NonWorkingTimeMixin\n */\n/**\n * Mixin with functionality shared between {@link Scheduler/feature/NonWorkingTime} and\n * {@link Scheduler/feature/EventNonWorkingTime}.\n * @mixin\n */\nexport default Target => class NonWorkingTimeMixin extends Target {\n    static $name = 'NonWorkingTimeMixin';\n    static configurable = {\n        /**\n         * The maximum time axis unit to display non-working ranges for ('hour' or 'day' etc).\n         * When zooming to a view with a larger unit, no non-working time elements will be rendered.\n         *\n         * **Note:** Be careful with setting this config to big units like 'year'. When doing this,\n         * make sure the timeline {@link Scheduler/view/TimelineBase#config-startDate start} and\n         * {@link Scheduler/view/TimelineBase#config-endDate end} dates are set tightly.\n         * When using a long range (for example many years) with non-working time elements rendered per hour,\n         * you will end up with millions of elements, impacting performance.\n         * When zooming, use the {@link Scheduler/view/mixin/TimelineZoomable#config-zoomKeepsOriginalTimespan} config.\n         * @config {'millisecond'|'second'|'minute'|'hour'|'day'|'week'|'month'|'quarter'|'year'}\n         * @default\n         */\n        maxTimeAxisUnit : 'week'\n    };\n    getNonWorkingTimeRanges(calendar, startDate, endDate) {\n        // make sure we will iterate the whole interval even if it is bigger than default (5 years)\n        const maxRange = endDate.getTime() - startDate.getTime() + 24 * 60 * 60 * 1000;\n        if (!calendar.getNonWorkingTimeRanges) {\n            const result = [];\n            calendar.forEachAvailabilityInterval(\n                { startDate, endDate, isForward : true, maxRange },\n                (intervalStartDate, intervalEndDate, calendarCacheInterval) => {\n                    for (const [entry, cache] of calendarCacheInterval.intervalGroups) {\n                        if (!cache.getIsWorking()) {\n                            result.push({\n                                name      : entry.name,\n                                iconCls   : entry.iconCls,\n                                cls       : entry.cls,\n                                startDate : intervalStartDate,\n                                endDate   : intervalEndDate\n                            });\n                        }\n                    }\n                }\n            );\n            return result;\n        }\n        return calendar.getNonWorkingTimeRanges(startDate, endDate, maxRange);\n    }\n    getCalendarTimeRanges(calendar, ignoreName = false) {\n        const\n            me                      = this,\n            { timeAxis, fillTicks } = me.client,\n            { unit, increment }     = timeAxis,\n            shouldPaint             = !me.maxTimeAxisUnit || DateHelper.compareUnits(unit, me.maxTimeAxisUnit) <= 0;\n        if (calendar && shouldPaint && timeAxis.count) {\n            const\n                allRanges     = me.getNonWorkingTimeRanges(calendar, timeAxis.startDate, timeAxis.endDate),\n                timeSpans     = allRanges.map(interval => new TimeSpan({\n                    name      : interval.name,\n                    cls       : `b-nonworkingtime ${interval.cls || ''}`,\n                    startDate : interval.startDate,\n                    endDate   : interval.endDate\n                }));\n            let mergedSpans = [];\n            let prevRange = null;\n            // intervals returned by the calendar are not merged, let's combine them to yield fewer elements\n            for (const range of timeSpans) {\n                if (prevRange && range.startDate <= prevRange.endDate && (ignoreName || range.name === prevRange.name) && range.duration > 0) {\n                    prevRange.endDate = range.endDate;\n                }\n                else {\n                    mergedSpans.push(range);\n                    range.setData('id', `nonworking-${mergedSpans.length}`);\n                    prevRange = range;\n                }\n            }\n            // When filling ticks, non-working-time ranges are snapped to full ticks too\n            if (fillTicks) {\n                mergedSpans = mergedSpans.filter(span => {\n                    return !DateHelper.isSameDate(span.startDate, span.endDate) &&\n                        DateHelper.ceil(span.startDate, { magnitude : increment, unit }) <\n                        DateHelper.floor(span.endDate, { magnitude : increment, unit });\n                });\n                mergedSpans.forEach(span => span.setStartEndDate(\n                    DateHelper.ceil(span.startDate, { magnitude : increment, unit }),\n                    DateHelper.floor(span.endDate, { magnitude : increment, unit }))\n                );\n            }\n            return mergedSpans;\n        }\n        else {\n            return [];\n        }\n    }\n    //region Basic scheduler calendar\n    setupDefaultCalendar() {\n        const { client, project } = this;\n        if (\n            // Might have been set up by NonWorkingTime / EventNonWorkingTime already\n            !this.autoGeneratedWeekends &&\n            // For basic scheduler...\n            !client.isSchedulerPro &&\n            !client.isGantt &&\n            // ...that uses the default calendar...\n            project.effectiveCalendar === project.defaultCalendar &&\n            // ...and has no defined intervals\n            !project.defaultCalendar.intervalStore.count\n        ) {\n            this.autoGeneratedWeekends = true;\n            this.updateDefaultCalendar();\n        }\n    }\n    updateDefaultCalendar() {\n        if (this.autoGeneratedWeekends) {\n            const\n                calendar     = this.client.project.effectiveCalendar,\n                intervals    = this.defaultNonWorkingIntervals,\n                hasIntervals = Boolean(intervals.length);\n            // The default \"weekends\" calendar should not be time zone converted\n            calendar.ignoreTimeZone = true;\n            calendar.clearIntervals(hasIntervals);\n            // Update weekends as non-working time\n            if (hasIntervals) {\n                calendar.addIntervals(intervals);\n            }\n        }\n    }\n    updateLocalization() {\n        super.updateLocalization?.();\n        this.autoGeneratedWeekends && this.updateDefaultCalendar();\n    }\n    get defaultNonWorkingIntervals() {\n        const dayNames  = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];\n        return DateHelper.nonWorkingDaysAsArray.map(dayIndex => ({\n            recurrentStartDate : `on ${dayNames[dayIndex]} at 0:00`,\n            recurrentEndDate   : `on ${dayNames[(dayIndex + 1) % 7]} at 0:00`,\n            isWorking          : false\n        }));\n    }\n    //endregion\n};\n", "import AbstractTimeRanges from './AbstractTimeRanges.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport VersionHelper from '../../Core/helper/VersionHelper.js';\nimport AttachToProjectMixin from '../data/mixin/AttachToProjectMixin.js';\nimport NonWorkingTimeMixin from './mixin/NonWorkingTimeMixin.js';\n/**\n * @module Scheduler/feature/NonWorkingTime\n */\n/**\n * Feature that allows styling of weekends (and other non-working time) by adding timeRanges for those days.\n *\n * {@inlineexample Scheduler/feature/NonWorkingTime.js}\n *\n * By default, the basic Scheduler's calendar is empty. When enabling this feature in the basic Scheduler, it injects\n * Saturday and Sunday weekend intervals if no intervals are encountered. For Scheduler Pro, it visualizes the project\n * calendar and does not automatically inject anything. You have to define a Calendar in the application and assign it\n * to the project, for more information on how to do that, please see Scheduler Pro's Scheduling/Calendars guide.\n *\n * Please note that to not clutter the view (and have a large negative effect on performance) the feature does not\n * render ranges shorter than the base unit used by the time axis. The behavior can be disabled with\n * {@link #config-hideRangesOnZooming} config.\n *\n * The feature also bails out of rendering ranges for very zoomed out views completely for the same reasons (see\n * {@link #config-maxTimeAxisUnit} for details).\n *\n * Also note that the feature uses virtualized rendering, only the currently visible non-working-time ranges are\n * available in the DOM.\n *\n * This feature is **disabled** by default for Scheduler, but **enabled** by default for Scheduler Pro.\n * For info on enabling it, see {@link Grid/view/mixin/GridFeatures}.\n *\n * @extends Scheduler/feature/AbstractTimeRanges\n * @demo Scheduler/nonworkingdays\n * @classtype nonWorkingTime\n * @mixes Scheduler/feature/mixin/NonWorkingTimeMixin\n * @feature\n */\nexport default class NonWorkingTime extends AbstractTimeRanges.mixin(AttachToProjectMixin, NonWorkingTimeMixin) {\n    //region Default config\n    static $name = 'NonWorkingTime';\n    /** @hideconfigs enableResizing, store*/\n    static get defaultConfig() {\n        return {\n            /**\n             * Set to `true` to highlight non-working periods of time\n             * @config {Boolean}\n             * @deprecated Since 5.2.0, will be removed since the feature is pointless if set to false\n             */\n            highlightWeekends : null,\n            /**\n             * The feature by default does not render ranges smaller than the base unit used by the time axis.\n             * Set this config to `false` to disable this behavior.\n             *\n             * <div class=\"note\">The {@link #config-maxTimeAxisUnit} config defines a zoom level at which to bail out of\n             * rendering ranges completely.</div>\n             * @config {Boolean}\n             * @default\n             */\n            hideRangesOnZooming : true,\n            showHeaderElements : true,\n            showLabelInBody    : true,\n            autoGeneratedWeekends : false\n        };\n    }\n    static pluginConfig = {\n        chain : [\n            'onInternalPaint',\n            'attachToProject',\n            'updateLocalization',\n            'onConfigChange',\n            'onSchedulerHorizontalScroll'\n        ]\n    };\n    //endregion\n    //region Init & destroy\n    doDestroy() {\n        this.attachToCalendar(null);\n        super.doDestroy();\n    }\n    set highlightWeekends(highlight) {\n        VersionHelper.deprecate('Scheduler', '6.0.0', 'Deprecated in favour of disabling the feature');\n        this.disabled = !highlight;\n    }\n    get highlightWeekends() {\n        return !this.disabled;\n    }\n    onConfigChange({ name }) {\n        if (!this.isConfiguring && name === 'fillTicks') {\n            this.refresh();\n        }\n    }\n    //endregion\n    //region Project\n    attachToProject(project) {\n        super.attachToProject(project);\n        this.attachToCalendar(project.effectiveCalendar);\n        // if there's no graph yet - need to delay this call until it appears, but not for scheduler\n        if (!project.graph && !this.client.isScheduler) {\n            project.ion({\n                name      : 'project',\n                dataReady : { fn : () => this.attachToCalendar(project.effectiveCalendar), once : true },\n                thisObj   : this\n            });\n        }\n        project.ion({\n            name           : 'project',\n            calendarChange : () => this.attachToCalendar(project.effectiveCalendar),\n            thisObj        : this\n        });\n    }\n    //endregion\n    //region TimeAxisViewModel\n    onTimeAxisViewModelUpdate(...args) {\n        this._timeAxisUnitDurationMs = null;\n        return super.onTimeAxisViewModelUpdate(...args);\n    }\n    //endregion\n    //region Calendar\n    attachToCalendar(calendar) {\n        const\n            me                  = this,\n            { project, client } = me;\n        me.detachListeners('calendar');\n        me.autoGeneratedWeekends = false;\n        if (calendar) {\n            // Sets up a default weekend calendar for basic Scheduler, when no calendar is set\n            me.setupDefaultCalendar();\n            calendar.intervalStore.ion({\n                name   : 'calendar',\n                change : () => me.setTimeout(() => me.refresh(), 1)\n            });\n        }\n        // On changing calendar we react to a data level event which is triggered after project refresh.\n        // Redraw right away\n        if (client.isEngineReady && !client.project.isDelayingCalculation && !client.isDestroying) {\n            me.refresh();\n        }\n        // Initially there is no guarantee we are ready to draw, wait for refresh\n        else if (!project.isDestroyed) {\n            me.detachListeners('initialProjectListener');\n            project.ion({\n                name : 'initialProjectListener',\n                refresh({ isCalculated }) {\n                    // Cant render early, have to wait for calculations\n                    if (isCalculated !== false) {\n                        me.refresh();\n                        me.detachListeners('initialProjectListener');\n                    }\n                },\n                thisObj : me\n            });\n        }\n    }\n    get calendar() {\n        return this.project?.effectiveCalendar;\n    }\n    //endregion\n    //region Draw\n    get timeAxisUnitDurationMs() {\n        // calculate and cache duration of the timeAxis unit in milliseconds\n        if (!this._timeAxisUnitDurationMs) {\n            this._timeAxisUnitDurationMs = DateHelper.as('ms', 1, this.client.timeAxis.unit);\n        }\n        return this._timeAxisUnitDurationMs;\n    }\n    /**\n     * Based on this method result the feature decides whether the provided non-working period should\n     * be rendered or not.\n     * The method checks that the range has non-zero {@link Scheduler.model.TimeSpan#field-duration},\n     * lays in the visible timespan and its duration is longer or equal the base timeaxis unit\n     * (if {@link #config-hideRangesOnZooming} is `true`).\n     *\n     * Override the method to implement your custom range rendering vetoing logic.\n     * @param {Scheduler.model.TimeSpan} range Range to render.\n     * @returns {Boolean} `true` if the range should be rendered and `false` otherwise.\n     */\n    shouldRenderRange(range) {\n        // if the range is longer or equal than one timeAxis unit then render it\n        return super.shouldRenderRange(range) && (!this.hideRangesOnZooming || range.durationMS >= this.timeAxisUnitDurationMs);\n    }\n    // Calendar intervals as TimeSpans, with adjacent intervals merged to create fewer\n    get timeRanges() {\n        const me = this;\n        if (!me._timeRanges) {\n            me._timeRanges = me.getCalendarTimeRanges(me.calendar);\n        }\n        return me._timeRanges;\n    }\n    //endregion\n}\nNonWorkingTime._$name = 'NonWorkingTime'; GridFeatureManager.registerFeature(NonWorkingTime, false, 'Scheduler');\nGridFeatureManager.registerFeature(NonWorkingTime, true, ['SchedulerPro', 'Gantt', 'ResourceHistogram']);\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport ClockTemplate from '../tooltip/ClockTemplate.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n/**\n * @module Scheduler/feature/ScheduleTooltip\n */\n/**\n * Feature that displays a tooltip containing the time at the mouse position when hovering empty parts of the schedule.\n * To hide the schedule tooltip, just disable this feature:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleTooltip : false\n *     }\n * });\n * ```\n *\n * You can also output a message along with the default time indicator (to indicate resource availability etc)\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *    features : {\n *       scheduleTooltip : {\n *           getText(date, event, resource) {\n *               return 'Hovering ' + resource.name;\n *           }\n *       }\n *   }\n * });\n * ```\n *\n * To take full control over the markup shown in the tooltip you can override the {@link #function-generateTipContent} method:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleTooltip : {\n *             generateTipContent({ date, event, resourceRecord }) {\n *                 return `\n *                     <dl>\n *                         <dt>Date</dt><dd>${date}</dd>\n *                         <dt>Resource</dt><dd>${resourceRecord.name}</dd>\n *                     </dl>\n *                 `;\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * Configuration properties from the feature are passed down into the resulting {@link Core.widget.Tooltip} instance.\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         scheduleTooltip : {\n *             // Don't show the tip until the mouse has been over the schedule for three seconds\n *             hoverDelay : 3000\n *         }\n *     }\n * });\n * ```\n *\n * {@inlineexample Scheduler/feature/ScheduleTooltip.js}\n *\n * This feature is **enabled** by default in `Scheduler` and **disabled** in `ResourceUtilization`.\n * For info on enabling it, see {@link Grid/view/mixin/GridFeatures}.\n *\n * @demo Scheduler/basic\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype scheduleTooltip\n * @feature\n */\nexport default class ScheduleTooltip extends InstancePlugin {\n    //region Config\n    static get $name() {\n        return 'ScheduleTooltip';\n    }\n    static get configurable() {\n        return {\n            messageTemplate : data => `<div class=\"b-sch-hovertip-msg\">${data.message}</div>`,\n            /**\n             * Set to `true` to hide this tooltip when hovering non-working time. Defaults to `false` for Scheduler,\n             * `true` for SchedulerPro\n             * @config {Boolean}\n             */\n            hideForNonWorkingTime : null\n        };\n    }\n    // Plugin configuration. This plugin chains some of the functions in Grid.\n    static get pluginConfig() {\n        return {\n            chain : ['onInternalPaint']\n        };\n    }\n    //endregion\n    //region Init\n    /**\n     * Set up drag and drop and hover tooltip.\n     * @private\n     */\n    onInternalPaint({ firstPaint }) {\n        if (!firstPaint) {\n            return;\n        }\n        const\n            me         = this,\n            { client } = me;\n        if (client.isSchedulerPro && me.hideForNonWorkingTime === undefined) {\n            me.hideForNonWorkingTime = true;\n        }\n        let reshowListener;\n        const tip = me.hoverTip = new Tooltip({\n            id                       : `${client.id}-schedule-tip`,\n            cls                      : 'b-sch-scheduletip',\n            allowOver                : true,\n            hoverDelay               : 0,\n            hideDelay                : 100,\n            showOnHover              : true,\n            forElement               : client.timeAxisSubGridElement,\n            anchorToTarget           : false,\n            trackMouse               : true,\n            updateContentOnMouseMove : true,\n            // disable text content and monitor resize for tooltip, otherwise it doesn't\n            // get sized properly on first appearance\n            monitorResize            : false,\n            textContent              : false,\n            forSelector              : '.b-schedulerbase:not(.b-dragging-event,.b-dragcreating,.b-creating-dependency) .b-grid-body-container:not(.b-scrolling) .b-timeline-subgrid:not(.b-scrolling) > :not(.b-sch-foreground-canvas):not(.b-group-footer):not(.b-group-row) *',\n            // Do not constrain at all, want it to be able to go outside of the viewport to not get in the way\n            getHtml                  : me.getHoverTipHtml.bind(me),\n            onDocumentMouseDown(event) {\n                // Click on the scheduler hides until the very next\n                // non-button-pressed mouse move!\n                if (tip.forElement.contains(event.event.target)) {\n                    reshowListener = EventHelper.on({\n                        thisObj   : me,\n                        element   : client.timeAxisSubGridElement,\n                        mousemove : e => tip.internalOnPointerOver(e),\n                        capture   : true\n                    });\n                }\n                const hideAnimation = tip.hideAnimation;\n                tip.hideAnimation = false;\n                tip.constructor.prototype.onDocumentMouseDown.call(tip, event);\n                tip.hideAnimation = hideAnimation;\n            },\n            // on Core/mixin/Events constructor, me.config.listeners is deleted and attributed its value to me.configuredListeners\n            // to then on processConfiguredListeners it set me.listeners to our TooltipBase\n            // but since we need our initial config.listeners to set to our internal tooltip, we leave processConfiguredListeners empty\n            // to avoid lost our listeners to apply for our internal tooltip here and force our feature has all Tooltip events firing\n            ...me.config,\n            internalListeners : me.configuredListeners\n        });\n        // We have to add our own listener after instantiation because it may conflict with a configured listener\n        tip.ion({\n            pointerover({ event }) {\n                const buttonsPressed = 'buttons' in event ? event.buttons > 0\n                    : event.which > 0; // fallback for Safari which doesn't support 'buttons'\n                // This is the non-button-pressed mousemove\n                // after the document mousedown\n                if (!buttonsPressed && reshowListener) {\n                    reshowListener();\n                }\n                // Never any tooltip while interaction is ongoing and a mouse button is pressed\n                return !me.disabled && !buttonsPressed;\n            },\n            innerhtmlupdate({ source }) {\n                me.clockTemplate.updateDateIndicator(source.element, me.lastTime);\n            }\n        });\n        // Update tooltip after zooming\n        client.ion({\n            timeAxisViewModelUpdate : 'updateTip',\n            thisObj                 : me\n        });\n        me.clockTemplate = new ClockTemplate({\n            scheduler : client\n        });\n    }\n    // leave configuredListeners alone until render time at which they are used on the tooltip\n    processConfiguredListeners() {}\n    updateTip() {\n        if (this.hoverTip.isVisible) {\n            this.hoverTip.updateContent();\n        }\n    }\n    doDestroy() {\n        this.destroyProperties('clockTemplate', 'hoverTip');\n        super.doDestroy();\n    }\n    //endregion\n    //region Contents\n    /**\n     * @deprecated Use {@link #function-generateTipContent} instead.\n     * Gets html to display in hover tooltip (tooltip displayed on empty parts of scheduler)\n     * @private\n     */\n    getHoverTipHtml({ tip, event }) {\n        const\n            me        = this,\n            scheduler = me.client,\n            date      = event && scheduler.getDateFromDomEvent(event, 'floor', true);\n        let html      = me.lastHtml;\n        // event.target might be null in the case of being hosted in a web component https://github.com/bryntum/bryntum-suite/pull/4488\n        if (date && event.target) {\n            const resourceRecord = scheduler.resolveResourceRecord(event);\n            // resourceRecord might be null if user hover over the tooltip, but we shouldn't hide the tooltip in this case\n            if ((resourceRecord && (date - me.lastTime !== 0 || resourceRecord.id !== me.lastResourceId))) {\n                if (me.hideForNonWorkingTime) {\n                    const isWorkingTime = resourceRecord.isWorkingTime(date);\n                    tip.element.classList.toggle('b-nonworking-time', !isWorkingTime);\n                }\n                me.lastResourceId = resourceRecord.id;\n                html              = me.lastHtml = me.generateTipContent({ date, event, resourceRecord });\n            }\n        }\n        else {\n            tip.hide();\n            me.lastTime = null;\n            me.lastResourceId = null;\n        }\n        return html;\n    }\n    /**\n     * Called as mouse pointer is moved over a new resource or time block. You can override this to show\n     * custom HTML in the tooltip.\n     * @param {Object} context\n     * @param {Date} context.date The date of the hovered point\n     * @param {Event} context.event The DOM event that triggered this tooltip to show\n     * @param {Scheduler.model.ResourceModel} context.resourceRecord The resource record\n     * @returns {String} The HTML contents to show in the tooltip (an empty return value will hide the tooltip)\n     */\n    generateTipContent({ date, event, resourceRecord }) {\n        const\n            me          = this,\n            clockHtml   = me.clockTemplate.generateContent({\n                date,\n                text : me.client.getFormattedDate(date)\n            }),\n            messageHtml = me.messageTemplate({\n                message : me.getText(date, event, resourceRecord) || ''\n            });\n        me.lastTime = date;\n        return clockHtml + messageHtml;\n    }\n    /**\n     * Override this to render custom text to default hover tip\n     * @param {Date} date\n     * @param {Event} event Browser event\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @returns {String}\n     */\n    getText(date, event, resourceRecord) {}\n    //endregion\n}\nScheduleTooltip.featureClass = 'b-scheduletip';\nScheduleTooltip._$name = 'ScheduleTooltip'; GridFeatureManager.registerFeature(ScheduleTooltip, true, 'Scheduler');\nGridFeatureManager.registerFeature(ScheduleTooltip, false, 'ResourceUtilization');\n", "import HeaderMenu from '../../Grid/feature/HeaderMenu.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport '../../Core/widget/Slider.js';\n/**\n * @module Scheduler/feature/TimeAxisHeaderMenu\n */\nconst setTimeSpanOptions = {\n    maintainVisibleStart : true\n};\n/**\n * Adds scheduler specific menu items to the timeline header context menu.\n *\n * ## Default timeaxis header menu items\n *\n * Here is the list of menu items provided by this and other features:\n *\n * | Reference          | Text                  | Weight | Feature                                           | Description                  |\n * |--------------------|-----------------------|--------|---------------------------------------------------|------------------------------|\n * | `eventsFilter`     | Filter tasks          | 100    | {@link Scheduler.feature.EventFilter EventFilter} | Submenu for event filtering  |\n * | \\>`nameFilter`     | By name               | 110    | {@link Scheduler.feature.EventFilter EventFilter} | Filter by `name`             |\n * | `zoomLevel`        | Zoom                  | 200    | *This feature*                                    | Submenu for timeline zooming |\n * | \\>`zoomSlider`     | -                     | 210    | *This feature*                                    | Changes current zoom level   |\n * | `dateRange`        | Date range            | 300    | *This feature*                                    | Submenu for timeline range   |\n * | \\>`startDateField` | Start date            | 310    | *This feature*                                    | Start date for the timeline  |\n * | \\>`endDateField`   | End date              | 320    | *This feature*                                    | End date for the timeline    |\n * | \\>`leftShiftBtn`   | <                     | 330    | *This feature*                                    | Shift backward               |\n * | \\>`todayBtn`       | Today                 | 340    | *This feature*                                    | Go to today                  |\n * | \\>`rightShiftBtn`  | \\>                    | 350    | *This feature*                                    | Shift forward                |\n * | `currentTimeLine`  | Show current timeline | 400    | {@link Scheduler.feature.TimeRanges TimeRanges}   | Show current time line       |\n *\n * \\> - first level of submenu\n *\n * ## Customizing the menu items\n *\n * The menu items in the TimeAxis Header menu can be customized, existing items can be changed or removed,\n * and new items can be added. This is handled using the `items` config of the feature.\n *\n * ### Add extra items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             items : {\n *                 extraItem : {\n *                     text : 'Extra',\n *                     icon : 'b-fa b-fa-fw b-fa-flag',\n *                     onItem() {\n *                         ...\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ### Remove existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             items : {\n *                 zoomLevel : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ### Customize existing item:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             items : {\n *                 zoomLevel : {\n *                     text : 'Scale'\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ### Customizing submenu items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *      features : {\n *          timeAxisHeaderMenu : {\n *              items : {\n *                  dateRange : {\n *                      menu : {\n *                          items : {\n *                              todayBtn : {\n *                                  text : 'Now'\n *                              }\n *                          }\n *                      }\n *                  }\n *              }\n *          }\n *      }\n * });\n * ```\n *\n * ### Manipulate existing items:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         timeAxisHeaderMenu : {\n *             // Process items before menu is shown\n *             processItems({ items }) {\n *                  // Add an extra item dynamically\n *                 items.coolItem = {\n *                     text : 'Cool action',\n *                     onItem() {\n *                           // ...\n *                     }\n *                 }\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">The `processItems` implementation my be an `async` function which `awaits` a result to\n * mutate the `items` object.</div>\n *\n * Full information of the menu customization can be found in the [\"Customizing the Event menu, the Schedule menu, and the TimeAxisHeader menu\"](#Scheduler/guides/customization/contextmenu.md)\n * guide.\n *\n * ## Video guides\n * {@frameworktabs}\n * {@react}\n * [@youtube](https://www.youtube.com/embed/ghWLmifpO_4)\n * {@endreact}\n * {@vue}\n * [@youtube](https://www.youtube.com/embed/HAq12QUBMx8)\n * {@endvue}\n * {@angular}\n * **Coming soon!**\n * {@endangular}\n * {@endframeworktabs}\n *\n * This feature is **enabled** by default\n *\n * {@inlineexample Scheduler/feature/TimeAxisHeaderMenu.js}\n *\n * @demo Scheduler/basic\n *\n * @extends Grid/feature/HeaderMenu\n * @classtype timeAxisHeaderMenu\n * @feature\n */\nexport default class TimeAxisHeaderMenu extends HeaderMenu {\n    //region Config\n    static get $name() {\n        return 'TimeAxisHeaderMenu';\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * A function called before displaying the menu that allows manipulations of its items.\n             * Returning `false` from this function prevents the menu being shown.\n             *\n             * ```javascript\n             *   features         : {\n             *       timeAxisHeaderMenu : {\n             *           processItems({ items }) {\n             *               // Add or hide existing items here as needed\n             *               items.myAction = {\n             *                   text   : 'Cool action',\n             *                   icon   : 'b-fa b-fa-fw b-fa-ban',\n             *                   onItem : () => console.log('Some coolness'),\n             *                   weight : 300 // Move to end\n             *               };\n             *\n             *               // Hide zoom slider\n             *               items.zoomLevel.hidden = true;\n             *           }\n             *       }\n             *   },\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} context An object with information about the menu being shown\n             * @param {Object<String,MenuItemConfig|Boolean>} context.items An object containing the\n             *   {@link Core.widget.MenuItem menu item} configs keyed by their id\n             * @param {Event} context.event The DOM event object that triggered the show\n             * @returns {Boolean|null} Returning `false` from this function prevents the menu being shown\n             * @preventable\n             */\n            processItems : null,\n            /**\n             * This is a preconfigured set of items used to create the default context menu.\n             *\n             * The `items` provided by this feature are listed in the intro section of this class. You can\n             * configure existing items by passing a configuration object to the keyed items.\n             *\n             * To remove existing items, set corresponding keys `null`:\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         timeAxisHeaderMenu : {\n             *             items : {\n             *                 eventsFilter : null\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * See the feature config in the above example for details.\n             *\n             * @config {Object<String,MenuItemConfig|Boolean|null>} items\n             */\n            items : null,\n            type : 'timeAxisHeader'\n        };\n    }\n    static get pluginConfig() {\n        const config = super.pluginConfig;\n        config.chain.push('populateTimeAxisHeaderMenu');\n        return config;\n    }\n    //endregion\n    //region Events\n    /**\n     * This event fires on the owning Scheduler or Gantt widget before the context menu is shown for the time axis header.\n     * Allows manipulation of the items to show in the same way as in the {@link #config-processItems}.\n     *\n     * Returning `false` from a listener prevents the menu from being shown.\n     *\n     * @event timeAxisHeaderMenuBeforeShow\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source The scheduler\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Time axis column\n     */\n    /**\n     * This event fires on the owning Scheduler or Gantt widget after the context menu is shown for a header\n     * @event timeAxisHeaderMenuShow\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source The scheduler\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Object<String,MenuItemConfig>} items Menu item configs\n     * @param {Grid.column.Column} column Time axis column\n     */\n    /**\n     * This event fires on the owning Scheduler or Gantt widget when an item is selected in the header context menu.\n     * @event timeAxisHeaderMenuItem\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source The scheduler\n     * @param {Core.widget.Menu} menu The menu\n     * @param {Core.widget.MenuItem} item Selected menu item\n     * @param {Grid.column.Column} column Time axis column\n     */\n    //endregion\n    construct() {\n        super.construct(...arguments);\n        if (this.triggerEvent.includes('click') && this.client.zoomOnTimeAxisDoubleClick) {\n            this.client.zoomOnTimeAxisDoubleClick = false;\n        }\n    }\n    shouldShowMenu(eventParams) {\n        const\n            { column, targetElement } = eventParams,\n            { client } = this;\n        if (client.isHorizontal) {\n            return column?.enableHeaderContextMenu !== false && column?.isTimeAxisColumn;\n        }\n        return targetElement.matches('.b-sch-header-timeaxis-cell');\n    }\n    showContextMenu(eventParams) {\n        super.showContextMenu(...arguments);\n        if (this.menu) {\n            // the TimeAxis's context menu probably will cause scrolls because it manipulates the dates.\n            // The menu should not hide on scroll when for a TimeAxisColumn\n            this.menu.scrollAction = 'realign';\n        }\n    }\n    populateTimeAxisHeaderMenu({ items }) {\n        const\n            me         = this,\n            { client } = me,\n            dateStep   = {\n                magnitude : client.timeAxis.shiftIncrement,\n                unit      : client.timeAxis.shiftUnit\n            };\n        Object.assign(items, {\n            zoomLevel : {\n                text        : 'L{pickZoomLevel}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-search-plus',\n                disabled    : !client.presets.count || me.disabled,\n                weight      : 200,\n                menu        : {\n                    type  : 'popup',\n                    items : {\n                        zoomSlider : {\n                            weight               : 210,\n                            type                 : 'slider',\n                            minWidth             : 130,\n                            showValue            : false,\n                            // so that we can use the change event which is easier to inject in tests\n                            triggerChangeOnInput : true\n                        }\n                    },\n                    onBeforeShow({ source : menu }) {\n                        const [zoom] = menu.items;\n                        zoom.min = client.minZoomLevel;\n                        zoom.max = client.maxZoomLevel;\n                        zoom.value = client.zoomLevel;\n                        // Default slider value is 50 which causes the above to trigger onZoomSliderChange (when\n                        // maxZoomLevel < 50) if we add our listener prior to this point.\n                        me.zoomDetatcher = zoom.ion({ change : 'onZoomSliderChange', thisObj : me });\n                    },\n                    onHide() {\n                        if (me.zoomDetatcher) {\n                            me.zoomDetatcher();\n                            me.zoomDetatcher = null;\n                        }\n                    }\n                }\n            },\n            dateRange : {\n                text        : 'L{activeDateRange}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-calendar',\n                weight      : 300,\n                menu        : {\n                    type     : 'popup',\n                    cls      : 'b-sch-timeaxis-menu-daterange-popup',\n                    defaults : {\n                        localeClass : me\n                    },\n                    items : {\n                        startDateField : {\n                            type              : 'datefield',\n                            label             : 'L{startText}',\n                            weight            : 310,\n                            labelWidth        : '6em',\n                            required          : true,\n                            step              : dateStep,\n                            internalListeners : {\n                                change  : me.onRangeDateFieldChange,\n                                thisObj : me\n                            }\n                        },\n                        endDateField : {\n                            type              : 'datefield',\n                            label             : 'L{endText}',\n                            weight            : 320,\n                            labelWidth        : '6em',\n                            required          : true,\n                            step              : dateStep,\n                            internalListeners : {\n                                change  : me.onRangeDateFieldChange,\n                                thisObj : me\n                            }\n                        },\n                        leftShiftBtn : {\n                            type              : 'button',\n                            weight            : 330,\n                            cls               : 'b-left-nav-btn',\n                            icon              : 'b-icon b-icon-previous',\n                            color             : 'b-blue b-raised',\n                            flex              : 1,\n                            margin            : 0,\n                            internalListeners : {\n                                click   : me.onLeftShiftBtnClick,\n                                thisObj : me\n                            }\n                        },\n                        todayBtn : {\n                            type              : 'button',\n                            weight            : 340,\n                            cls               : 'b-today-nav-btn',\n                            color             : 'b-blue b-raised',\n                            text              : 'L{todayText}',\n                            flex              : 4,\n                            margin            : '0 8',\n                            internalListeners : {\n                                click   : me.onTodayBtnClick,\n                                thisObj : me\n                            }\n                        },\n                        rightShiftBtn : {\n                            type              : 'button',\n                            weight            : 350,\n                            cls               : 'b-right-nav-btn',\n                            icon              : 'b-icon b-icon-next',\n                            color             : 'b-blue b-raised',\n                            flex              : 1,\n                            internalListeners : {\n                                click   : me.onRightShiftBtnClick,\n                                thisObj : me\n                            }\n                        }\n                    },\n                    internalListeners : {\n                        paint   : me.initDateRangeFields,\n                        thisObj : me\n                    }\n                }\n            }\n        });\n    }\n    onZoomSliderChange({ value }) {\n        const me = this;\n        // Zooming maintains timeline center point by scrolling the newly rerendered timeline to the\n        // correct point to maintain the visual center. Temporarily inhibit context menu hide on scroll\n        // of its context element.\n        me.menu.scrollAction = 'realign';\n        me.client.zoomLevel = value;\n        me.menu.setTimeout({\n            fn                : () => me.menu.scrollAction = 'hide',\n            delay             : 100,\n            cancelOutstanding : true\n        });\n    }\n    initDateRangeFields({ source : dateRange, firstPaint }) {\n        if (firstPaint) {\n            const { widgetMap } = dateRange;\n            this.startDateField = widgetMap.startDateField;\n            this.endDateField = widgetMap.endDateField;\n        }\n        this.initDates();\n    }\n    initDates() {\n        const me = this;\n        me.startDateField.suspendEvents();\n        me.endDateField.suspendEvents();\n        // The actual scheduler start dates may include time, but our Date field cannot currently handle\n        // a time portion and throws it away, so when we need the value from an unchanged field, we need\n        // to use the initialValue set from the timeAxis values.\n        // Until our DateField can optionally include a time value, this is the solution.\n        me.startDateField.value = me.startDateFieldInitialValue = me.client.startDate;\n        me.endDateField.value = me.endDateFieldInitialValue = me.client.endDate;\n        me.startDateField.resumeEvents();\n        me.endDateField.resumeEvents();\n    }\n    onRangeDateFieldChange({ source }) {\n        const\n            me               = this,\n            startDateChanged = (source === me.startDateField),\n            { client }       = me,\n            { timeAxis }     = client,\n            startDate        = me.startDateFieldInitialValue && !startDateChanged ? me.startDateFieldInitialValue : me.startDateField.value;\n        let endDate = me.endDateFieldInitialValue && startDateChanged ? me.endDateFieldInitialValue : me.endDateField.value;\n        // When either of the fields is changed, we no longer use its initialValue from the timeAxis start or end\n        // so that gets nulled to indicate that it's unavailable and the real field value is to be used.\n        if (startDateChanged) {\n            me.startDateFieldInitialValue = null;\n        }\n        else {\n            me.endDateFieldInitialValue = null;\n        }\n        // Because the start and end dates are exclusive, avoid a zero\n        // length time axis by incrementing the end by one tick unit\n        // if they are the same.\n        if (!(endDate - startDate)) {\n            endDate = DateHelper.add(endDate, timeAxis.shiftIncrement, timeAxis.shiftUnit);\n        }\n        // if start date got bigger than end date set end date to start date plus one tick\n        else if (endDate < startDate) {\n            endDate = DateHelper.add(startDate, timeAxis.shiftIncrement, timeAxis.shiftUnit);\n        }\n        // setTimeSpan will try to keep the scroll position the same.\n        client.setTimeSpan(startDate, endDate, setTimeSpanOptions);\n        me.initDates();\n    }\n    onLeftShiftBtnClick() {\n        this.client.timeAxis.shiftPrevious();\n        this.initDates();\n    }\n    onTodayBtnClick() {\n        const today = DateHelper.clearTime(new Date());\n        this.client.setTimeSpan(today, DateHelper.add(today, 1, 'day'));\n        this.initDates();\n    }\n    onRightShiftBtnClick() {\n        this.client.timeAxis.shiftNext();\n        this.initDates();\n    }\n}\nTimeAxisHeaderMenu._$name = 'TimeAxisHeaderMenu'; GridFeatureManager.registerFeature(TimeAxisHeaderMenu, true, ['Scheduler', 'TimelineHistogram', 'Gantt']);\n"],
  "mappings": "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",
  "names": ["DurationColumn", "NumberColumn", "__publicField", "durationEntity1", "durationEntity2", "ms1", "ms2", "sortFn", "args", "max", "min", "step", "largeStep", "ObjectHelper", "duration", "nbrDecimals", "multiplier", "durationUnit", "Duration", "DateHelper", "value", "record", "isExport", "type", "durationValue", "string", "ColumnStore", "DragBase", "InstancePlugin", "data", "snapTo", "_a", "dragData", "me", "client", "constrainDragToTimeline", "constrainDragToResource", "constrainDragToTimeSlot", "dragHelperConfig", "timeAxisViewModel", "isHorizontal", "lockY", "lockX", "Objects", "el", "element", "newX", "newY", "timeline", "draggedEventRecord", "coordinate", "snappedDate", "calendar", "snappedPosition", "event", "firstPaint", "DragHelper", "ClockTemplate", "_b", "_c", "tip", "oldTip", "result", "Tooltip", "proxy", "context", "eventRecord", "resourceRecord", "tipTarget", "eventMenu", "taskMenu", "menuFeature", "startDate", "endDate", "clockTemplate", "endDateElement", "target", "center", "Rectangle", "DomHelper", "Widget", "dd", "start", "valid", "newTimeline", "initial", "scrollables", "eventType", "eventData", "currentOverClient", "modified", "beforeDropTriggered", "dragHelper", "currentTimeline", "eventBarEls", "draggedEntities", "i", "abort", "updateRecords", "clientEventTipFeature", "externalDropTarget", "timeDiff", "info", "drag", "lastDragStartDate", "constrainToTimeSlot", "timeAxisPosition", "pointerDate", "range", "positionDirty", "suspend", "productDragData", "startEvent", "timespan", "origStart", "origEnd", "timeAxis", "startsOutsideView", "endsOutsideView", "multiSelect", "clientCoordinate", "constrainRegion", "elRegion", "tickSize", "constrained", "xTickSize", "yTickSize", "iLeft", "iRight", "iTickSize", "iUp", "iDown", "rounded", "draggedElement", "proxyRect", "fillSnap", "totalDurationMS", "offsetMS", "proxyMS", "offsetPx", "proxyStart", "tick", "tooltipTemplate", "startText", "endText", "message", "dragProxy", "dragged", "timeSpanRecord", "axis", "dateConstraints", "scheduleableRecord", "coord", "tipAlign", "EventResize", "Draggable_default", "Droppable_default", "VersionHelper", "eventElement", "eventResizable", "wrapperCls", "cls", "dragging", "visibleDateRange", "rtl", "dimension", "pageScroll", "clientRect", "startCoord", "endCoord", "date", "itemElement", "name", "isBatchUpdating", "wrapStartDate", "wrapEndDate", "useEventBuffer", "eventStartDate", "eventEndDate", "horizontal", "draggingEnd", "toSet", "wrapToSet", "otherEnd", "setMethod", "setOtherMethod", "elRect", "StringHelper", "diff", "minDate", "maxDate", "enableEventAnimations", "weekStartDay", "resolutionUnit", "resolutionIncrement", "oldValue", "offset", "isOccurrence", "eventStart", "eventEnd", "crossedOver", "avoidedZeroSize", "sign", "partialResizeEvent", "EventHelper", "updateRecord", "snapRelativeToEventStartDate", "wasChanged", "resource", "changed", "timespanRecord", "generation", "TimeSpan", "batchChanges", "setOtherEnd", "promisesToWait", "overItem", "oldOverItem", "item", "inner", "side", "eventEl", "dim", "handleSpec", "offsetWidth", "resizable", "eventRect", "handleStyle", "touchHandleSize", "BrowserHelper", "handleSize", "handleVisThresh", "centerGap", "deflateArgs", "handleHoldingElement", "handleEl", "startsOutside", "endsOutside", "tipData", "assignmentRecord", "GridFeatureManager", "TaskEditTransactional_default", "Target", "Base", "force", "commitOrReject", "startRecordingEarly", "TransactionalFeature_default", "AttachToProjectMixin_default", "project", "stmCapture", "stm", "chainResolved", "resolve", "afterApplyStashCallback", "transactionId", "_stmInitiallyDisabled", "_stmInitiallyAutoRecord", "id", "IdHelper", "getDragCreateDragDistance", "DragCreateBase", "TaskEditStm_default", "scheduler", "config", "validatorFn", "initialDate", "pan", "eventDragSelect", "dragTolerance", "doCreate", "completeFinalization", "createContext", "finalize", "async", "renderData", "dateTime", "rowRecord", "TooltipBase", "disable", "ignoreSelector", "v", "defaultDetacher", "tooltipDetacher", "forElement", "activeTarget", "recordProp", "endDateValue", "newTarget", "tooltip", "AbstractTimeRanges", "Delayable_default", "_d", "ResizeHelper", "timeRange", "bodyConfigs", "headerConfigs", "headerContainerElement", "updatedBodyElements", "DomSync", "targetElement", "action", "bodyElement", "rangeStart", "rangeEnd", "relativeTo", "startPos", "endPos", "size", "isRange", "translateX", "icon", "labelTpl", "bodyConfig", "headerConfig", "label", "rotate", "idOrRecord", "isVertical", "timeView", "timeAxisColumn", "show", "column", "items", "newWidth", "newHeight", "oldWidth", "oldHeight", "timeRangeRecord", "box", "emptyObject", "ColumnLines", "resourceStore", "groupers", "m", "variableColumnWidths", "columnConfig", "linesForLevel", "majorLinesForLevel", "end", "domConfigs", "dates", "addLineConfig", "isMajor", "tickStart", "columnWidth", "firstResource", "lastResource", "nbrGroupHeaders", "instanceMeta", "left", "groupParent", "DependencyCreation_default", "source", "creationData", "eventBarElement", "parent", "parentElement", "domEvent", "toEvent", "toEventRecord", "fromEvent", "timeAxisSubGridElement", "terminalNode", "timeSpanElement", "viewBounds", "key", "deltaX", "deltaY", "length", "angle", "connector", "allowDropOnEventBar", "overEventRecord", "toSide", "DependencyBaseModel", "dependencyType", "fromSide", "updateValidity", "validityCls", "dependency", "sourceResource", "targetResource", "x", "y", "syncId", "terminalsVisibleCls", "terminal", "eventParams", "newDependency", "classList", "tipTitleIconClsSuffix", "tipTitleText", "THRESHOLD", "BOX_PROPERTIES", "equalEnough", "a", "b", "sideToSide", "RectangularPathFinder", "_RectangularPathFinder", "lineDef", "noPathFallbackFn", "originalLineDef", "lineDefFull", "startBox", "endBox", "startShift", "endShift", "startSide", "endSide", "startArrowMargin", "endArrowMargin", "horizontalMargin", "verticalMargin", "startHorizontalMargin", "startVerticalMargin", "endHorizontalMargin", "endVerticalMargin", "otherHorizontalMargin", "otherVerticalMargin", "otherBoxes", "connStartPoint", "connEndPoint", "pathStartPoint", "pathEndPoint", "gridStartPoint", "gridEndPoint", "startGridBox", "endGridBox", "grid", "path", "tryNum", "ArrayHelper", "property", "box1", "box2", "vertical", "startProp", "endProp", "gridStartBox", "gridEndBox", "calculateOverlap", "originalOverlap", "finalOverlap", "shift", "coords", "arrowMargin", "gridBox", "otherGridBoxes", "xs", "ys", "ix", "iy", "xslen", "yslen", "ib", "blen", "permitted", "point", "points", "linearPoints", "gridPoint", "predicateFn", "neighbor", "distance", "WalkHelper", "neighborPoint", "pathFound", "neighbors", "lowestDistanceNeighbor", "xDiff", "yDiff", "resultA", "resultB", "firstSegment", "prependSegment", "lastSegment", "appendSegment", "optPath", "prevSegment", "curSegment", "fromBoxSide", "toBoxSide", "DependencyTooltip_default", "old", "ROWS_PER_CELL", "DependencyGridCache_default", "startMS", "endMS", "startIndex", "endIndex", "gridCache", "dependencies", "fromMSCell", "toMSCell", "fromRowCell", "toRowCell", "msCell", "j", "intersectingDependencies", "fromIndex", "toIndex", "fromDateMS", "toDateMS", "MS_PER_CELL", "timeAxisStartMS", "timeAxisEndMS", "timeAxisCells", "firstMSCell", "lastMSCell", "firstRowCell", "lastRowCell", "startMSCell", "endMSCell", "drawingDirection", "pointSet", "segmentLength", "arc", "nextPointSet", "radius", "corner", "rx", "ry", "line", "location", "prevRadius", "useRadius", "nextLength", "subtract", "useLength", "pathMapper", "currentRadius", "lineSpec", "DependencyLineGenerator_default", "width", "markerDef", "svg", "markerId", "assignment", "fromAssignment", "toAssignment", "forceBoxes", "cached", "clickWidth", "highlighted", "domConfig", "configs", "rectangle", "row", "overRow", "DependencyModel", "shrinkArrowMargins", "barMargin", "resetArrowMargins", "shrinkHorizontalMargin", "adjusters", "startRectangle", "endRectangle", "fromResource", "toResource", "minIndex", "maxIndex", "currentIndex", "assignmentBox", "eventNameMap", "collectLinkedAssignments", "l", "Dependencies", "scheduledEventName", "store", "eventStore", "assignmentStore", "dependencyStore", "drawOnScroll", "subGrid", "scrollX", "selector", "eventName", "rowStore", "enable", "params", "classes", "dep", "d", "batch", "topIndex", "bottomIndex", "useInitialAnimation", "idMap", "fromAssigned", "toAssigned", "from", "to", "lineDomConfigs", "r", "_e", "features", "immediateRefresh", "rafRefresh", "EventFilter", "menu", "filterByName", "filter", "NonWorkingTimeMixin_default", "maxRange", "intervalStartDate", "intervalEndDate", "calendarCacheInterval", "entry", "cache", "ignoreName", "fillTicks", "unit", "increment", "shouldPaint", "allRanges", "timeSpans", "interval", "mergedSpans", "prevRange", "span", "intervals", "hasIntervals", "dayNames", "dayIndex", "NonWorkingTime", "highlight", "isCalculated", "ScheduleTooltip", "reshowListener", "e", "hideAnimation", "buttonsPressed", "html", "isWorkingTime", "clockHtml", "messageHtml", "setTimeSpanOptions", "TimeAxisHeaderMenu", "HeaderMenu", "dateStep", "zoom", "dateRange", "widgetMap", "startDateChanged", "today"]
}
