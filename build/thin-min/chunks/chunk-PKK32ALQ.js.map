{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/widget/Splitter.js"],
  "sourcesContent": ["import Widget from './Widget.js';\nimport DomHelper from '../helper/DomHelper.js';\nimport EventHelper from '../helper/EventHelper.js';\nimport BrowserHelper from '../helper/BrowserHelper.js';\n/**\n * @module Core/widget/Splitter\n */\nconst\n    classesHV = ['b-horizontal', 'b-vertical'],\n    hasFlex = el => DomHelper.getStyleValue(el.parentElement, 'display') === 'flex' &&\n        (parseInt(DomHelper.getStyleValue(el, 'flex-basis'), 10) || parseInt(DomHelper.getStyleValue(el, 'flex-grow'), 10)),\n    verticality = {\n        horizontal : false,\n        vertical   : true\n    };\n/**\n * A simple splitter widget that resizes the elements next to it or above/below it depending on orientation.\n *\n * {@inlineexample Core/widget/Splitter.js}\n *\n * @extends Core/widget/Widget\n * @classtype splitter\n * @widget\n */\nexport default class Splitter extends Widget {\n    //region Config\n    static $name = 'Splitter';\n    static type = 'splitter';\n    static get configurable() {\n        return {\n            /**\n             * Fired when a drag starts\n             * @event dragStart\n             * @param {Core.widget.Splitter} source The Splitter\n             * @param {MouseEvent|TouchEvent} event The DOM event\n             */\n            /**\n             * Fired while dragging\n             * @event drag\n             * @param {Core.widget.Splitter} source The Splitter\n             * @param {MouseEvent|TouchEvent} event The DOM event\n             */\n            /**\n             * Fired after a drop\n             * @event drop\n             * @param {Core.widget.Splitter} source The Splitter\n             * @param {MouseEvent|TouchEvent} event The DOM event\n             */\n            /**\n             * Splitter orientation, see {@link #config-orientation}. When set to 'auto' then actually used orientation\n             * can be retrieved using {@link #property-currentOrientation}.\n             * @member {'auto'|'horizontal'|'vertical'} orientation\n             * @readonly\n             */\n            /**\n             * The splitter's orientation, configurable with 'auto', 'horizontal' or 'vertical'.\n             *\n             * 'auto' tries to determine the orientation by either checking the `flex-direction` of the parent element\n             * or by comparing the positions of the closest sibling elements to the splitter. If they are above and\n             * below 'horizontal' is used, if not it uses 'vertical'.\n             *\n             * ```\n             * new Splitter({\n             *    orientation : 'horizontal'\n             * });\n             * ```\n             *\n             * To receive the actually used orientation when configured with 'auto', see\n             * {@link #property-currentOrientation}.\n             *\n             * @config {'auto'|'horizontal'|'vertical'}\n             * @default\n             */\n            orientation : 'auto',\n            vertical : null,\n            containerElement : {\n                $config : 'nullify',\n                value   : null\n            },\n            nextNeighbor : {\n                $config : 'nullify',\n                value   : null\n            },\n            previousNeighbor : {\n                $config : 'nullify',\n                value   : null\n            }\n        };\n    }\n    static get delayable() {\n        return {\n            syncState : 'raf'\n        };\n    }\n    //endregion\n    //region Init & destroy\n    doDestroy() {\n        this.mouseDetacher?.();\n        super.doDestroy();\n    }\n    //endregion\n    //region Template & element\n    compose() {\n        return {\n            class : {\n                'b-splitter' : 1\n            },\n            // eslint-disable-next-line bryntum/no-listeners-in-lib\n            listeners : {\n                pointerdown : 'onMouseDown',\n                mouseenter  : 'syncState',\n                ...(!BrowserHelper.supportsPointerEvents && {\n                    mousedown  : 'onMouseDown',\n                    touchstart : 'onMouseDown'\n                })\n            }\n        };\n    }\n    //endregion\n    //region Orientation\n    /**\n     * Get actually used orientation, which is either the configured value for `orientation` or if configured with\n     * 'auto' the currently used orientation.\n     * @property {String}\n     * @readonly\n     */\n    get currentOrientation() {\n        return this.vertical ? 'vertical' : 'horizontal';\n    }\n    getSibling(next = true) {\n        let { element } = this,\n            result;\n        while (!result && (element = element[`${next ? 'next' : 'previous'}ElementSibling`])) {\n            if (!element.isConnected || DomHelper.isVisible(element)) {\n                result = element;\n            }\n        }\n        return result;\n    }\n    get nextWidget() {\n        let { element } = this,\n            result;\n        while (!result && (element = element.nextElementSibling)) {\n            // Second arg used to be 1, but when used inside elements inside another widget (FiddlePanel), nextWidget &\n            // previousWidget would both return the outer widget\n            result = Widget.fromElement(element, this.element.parentElement);\n        }\n        return result;\n    }\n    get previousWidget() {\n        let { element } = this,\n            result;\n        while (!result && (element = element.previousElementSibling)) {\n            result = Widget.fromElement(element, this.element.parentElement);\n        }\n        return result;\n    }\n    updateContainerElement(containerElement) {\n        const me = this;\n        me.stateDetector = me.stateDetector?.disconnect();\n        if (containerElement) {\n            me.stateDetector = new MutationObserver(() => me.syncState());  // syncState runs on next raf\n            me.stateDetector.observe(containerElement, {\n                attributes : true,  // in case style changes flip our orientation (when == 'auto')\n                childList  : true   // watch for our neighbors to render (so we can disable on hidden/collapsed state)\n            });\n        }\n    }\n    updateNextNeighbor(next) {\n        this.watchNeighbor(next, 'next');\n    }\n    updatePreviousNeighbor(previous) {\n        this.watchNeighbor(previous, 'previous');\n    }\n    watchNeighbor(neighbor, name) {\n        this.detachListeners(name);\n        neighbor?.ion({\n            name,\n            thisObj  : this,\n            collapse : 'syncState',\n            expand   : 'syncState',\n            hide     : 'syncState',\n            show     : 'syncState'\n        });\n    }\n    updateOrientation() {\n        this.syncState.now();\n    }\n    updateVertical(vertical) {\n        const classList = this.element?.classList;\n        classList?.add(classesHV[vertical ? 1 : 0]);\n        classList?.remove(classesHV[vertical ? 0 : 1]);\n    }\n    /**\n     * Determine orientation when set to `'auto'` and detects neighboring widgets to monitor their hidden/collapsed\n     * states.\n     * @private\n     */\n    syncState() {\n        const\n            me                                      = this,\n            { element, nextWidget, previousWidget } = me;\n        let vertical = verticality[me.orientation] ?? null;\n        me.nextNeighbor     = nextWidget;\n        me.previousNeighbor = previousWidget;\n        me.disabled = (\n            nextWidget && ((nextWidget.collapsible && nextWidget.collapsed) || nextWidget.hidden)\n        ) || (\n            previousWidget && ((previousWidget.collapsible && previousWidget.collapsed) || previousWidget.hidden)\n        );\n        if (vertical !== null && nextWidget && previousWidget) {\n            me.containerElement = null;\n        }\n        else {\n            // we'll need to monitor parent element child list changes until our neighbors are added to the DOM\n            me.containerElement = element.parentElement;\n            // Orientation auto and already rendered, determine orientation to use\n            if (me.rendered && element.offsetParent) {\n                const flexDirection = DomHelper.getStyleValue(element.parentElement, 'flex-direction');\n                // If used in a flex layout, determine orientation from flex-direction\n                if (flexDirection) {\n                    vertical = !flexDirection.startsWith('column');\n                }\n                // If used in some other layout, try to determine from sibling elements position\n                else {\n                    const\n                        previous = element.previousElementSibling,\n                        next = element.nextElementSibling;\n                    if (!previous || !next) {\n                        // To early in rendering, next sibling not rendered yet\n                        return;\n                    }\n                    const\n                        prevRect = previous.getBoundingClientRect(),\n                        nextRect = next.getBoundingClientRect(),\n                        topMost = prevRect.top < nextRect.top ? prevRect : nextRect,\n                        bottomMost = topMost === nextRect ? prevRect : nextRect;\n                    // orientation = topMost.top !== bottomMost.top ? 'horizontal' : 'vertical';\n                    vertical = topMost.top === bottomMost.top;\n                }\n            }\n        }\n        me.vertical = vertical;\n    }\n    //endregion\n    //region Events\n    onMouseDown(event) {\n        event.preventDefault();\n        if (event.touches) {\n            event = event.touches[0];\n        }\n        const\n            me          = this,\n            {\n                element,\n                nextNeighbor,\n                previousNeighbor\n            } = me,\n            prev        = previousNeighbor ? previousNeighbor.element : me.getSibling(false),\n            next        = nextNeighbor ? nextNeighbor.element : me.getSibling(),\n            prevHasFlex = hasFlex(prev),\n            nextHasFlex = hasFlex(next),\n            flexed      = [];\n        // First stop any ongoing drag operation, since we cannot trust that we always get the mouseup event\n        me.mouseDetacher?.();\n        // Remember flexed children, to enable maintaining their proportions on resize\n        for (const child of element.parentElement.children) {\n            if (hasFlex(child) && child !== element) {\n                flexed.push({\n                    element : child,\n                    width   : child.offsetWidth,\n                    height  : child.offsetHeight\n                });\n            }\n        }\n        me.context = {\n            startX     : event.pageX,\n            startY     : event.pageY,\n            prevWidth  : prev.offsetWidth,\n            prevHeight : prev.offsetHeight,\n            nextWidth  : next.offsetWidth,\n            nextHeight : next.offsetHeight,\n            prevHasFlex,\n            nextHasFlex,\n            flexed,\n            prev,\n            next\n        };\n        const events = {\n            element     : document,\n            pointermove : 'onMouseMove',\n            pointerup   : 'onMouseUp',\n            thisObj     : me\n        };\n        if (!BrowserHelper.supportsPointerEvents) {\n            events.mousemove = events.touchmove = 'onMouseMove';\n            events.mouseup   = events.touchend  = 'onMouseUp';\n        }\n        element.classList.add('b-moving');\n        me.mouseDetacher = EventHelper.on(events);\n        me.trigger('splitterMouseDown', { event });\n    }\n    onMouseMove(event) {\n        const\n            me        = this,\n            {\n                context,\n                nextWidget,\n                previousWidget\n            }         = me,\n            prevStyle = context.prev.style,\n            nextStyle = context.next.style,\n            deltaX    = (event.pageX - context.startX) * (me.rtl ? -1 : 1),\n            deltaY    = event.pageY - context.startY;\n        event.preventDefault();\n        Object.assign(context, {\n            deltaX,\n            deltaY\n        });\n        if (!context.started) {\n            context.started = true;\n            me.trigger('dragStart', { context, event });\n            // Convert heights/widths to flex for flexed elements to maintain proportions\n            // 100px high -> flex-grow 100\n            context.flexed.forEach(flexed => {\n                flexed.element.style.flexGrow = me.vertical ? flexed.width : flexed.height;\n                //Remove flex-basis, since it interferes with resizing\n                flexed.element.style.flexBasis = '0';\n            });\n        }\n        // Adjust flex-grow or width/height for splitter's closest siblings\n        if (me.vertical) {\n            const\n                newPrevWidth = context.prevWidth + deltaX,\n                newNextWidth = context.nextWidth - deltaX;\n            if (context.prevHasFlex) {\n                prevStyle.flexGrow = newPrevWidth;\n            }\n            else if (previousWidget) {\n                previousWidget.width = newPrevWidth;\n            }\n            else {\n                prevStyle.width = `${newPrevWidth}px`;\n            }\n            if (context.nextHasFlex) {\n                nextStyle.flexGrow = newNextWidth;\n            }\n            else if (nextWidget) {\n                nextWidget.width = newNextWidth;\n            }\n            else {\n                nextStyle.width = `${newNextWidth}px`;\n            }\n        }\n        else {\n            const\n                newPrevHeight = context.prevHeight + deltaY,\n                newNextHeight = context.nextHeight - deltaY;\n            if (context.prevHasFlex) {\n                prevStyle.flexGrow = newPrevHeight;\n            }\n            else if (previousWidget) {\n                previousWidget.height = newPrevHeight;\n            }\n            else {\n                prevStyle.height = `${newPrevHeight}px`;\n            }\n            if (context.nextHasFlex) {\n                nextStyle.flexGrow = newNextHeight;\n            }\n            else if (nextWidget) {\n                nextWidget.height = newNextHeight;\n            }\n            else {\n                nextStyle.height = `${newNextHeight}px`;\n            }\n        }\n        me.trigger('drag', { context, event });\n    }\n    onMouseUp(event) {\n        const me = this;\n        me.mouseDetacher?.();\n        me.mouseDetacher = null;\n        me.element.classList.remove('b-moving');\n        if (me.context.started) {\n            me.trigger('drop', { context : me.context, event });\n        }\n        me.context = null;\n    }\n    //endregion\n    render() {\n        super.render(...arguments);\n        this.syncState.now();\n        if (this.vertical === null) {\n            this.syncState();  // try again on next raf\n        }\n    }\n}\n// Register this widget type with its Factory\nSplitter.initClass();\nSplitter._$name = 'Splitter';"],
  "mappings": "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",
  "names": ["classesHV", "hasFlex", "el", "DomHelper", "verticality", "Splitter", "Widget", "_a", "BrowserHelper", "next", "element", "result", "containerElement", "me", "previous", "neighbor", "name", "vertical", "classList", "nextWidget", "previousWidget", "flexDirection", "prevRect", "nextRect", "topMost", "bottomMost", "event", "nextNeighbor", "previousNeighbor", "prev", "prevHasFlex", "nextHasFlex", "flexed", "child", "events", "EventHelper", "context", "prevStyle", "nextStyle", "deltaX", "deltaY", "newPrevWidth", "newNextWidth", "newPrevHeight", "newNextHeight", "__publicField"]
}
