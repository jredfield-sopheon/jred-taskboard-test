{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/widget/graph/Histogram.js", "../../../../Core/lib/Core/widget/graph/Scale.js"],
  "sourcesContent": ["import Widget from '../Widget.js';\nimport StringHelper from '../../helper/StringHelper.js';\nimport DomSync from '../../helper/DomSync.js';\nimport Tooltip from '../Tooltip.js';\nimport Objects from '../../helper/util/Objects.js';\n/**\n * @module Core/widget/graph/Histogram\n */\nconst\n    ns = 'http://www.w3.org/2000/svg',\n    // Outline series must overlay bars\n    typePrio = {\n        bar     : 1,\n        outline : 2,\n        text    : 3\n    },\n    byOrder = (l, r) => parseInt(l.order, 10) - parseInt(r.order, 10),\n    byDatasetOrder = (l, r) => parseInt(l.dataset.order, 10) - parseInt(r.dataset.order, 10),\n    getField = s => s.field,\n    returnFalse = () => false,\n    classesDelimiter = /\\s+/;\n/**\n * An object representing a series settings.\n *\n * @typedef {Object} HistogramSeries\n * @property {'bar'|'outline'} type The series type specifying how it is rendered, as solid bars or outlines.\n * @property {String} [field] The name of the property to to read value from. By default matches the series\n * identifier.\n * @property {Boolean} [stretch=false] Provide `true` to stretch the series bars to take the whole vertical space\n * Applicable to `bar` type series only.\n * @property {String} [id] The series identifier. When configuring the series this value is automatically taken from\n * the key name the series is provided. For example in the bellow code the series `id` will be set to `salary`:\n * ```javascript\n * series : {\n *     salary : {\n *         type : 'bar'\n *     },\n *     ...\n * }\n * ```\n */\n/**\n * Displays a simple bar histogram based upon an array of data objects passed in the {@link #config-data} config.\n *\n * @extends Core/widget/Widget\n * @classtype histogram\n */\nexport default class Histogram extends Widget {\n    //region Config\n    static type = 'histogram';\n    static $name = 'Histogram';\n    static get configurable() {\n        return {\n            /**\n             * An array of data objects used to drive the histogram. The property/properties used\n             * are defined in the {@link #config-series} option.\n             * @config {Object[]}\n             * @default\n             */\n            data : null,\n            /**\n             * The values to represent in bar form.\n             * @config {Number[]}\n             */\n            values : null,\n            /**\n             * Object enumerating data series for the histogram.\n             * The object keys are treated as series identifiers and values are objects that\n             * can contain the following properties:\n             *  - `type` A String, either `'bar'` or `'outline'`\n             *  - `field` A String, the name of the property to use from the data objects in the {@link #config-data} option.\n             * If the value is omitted the series identifier is used as the property name.\n             * @config {Object<String, HistogramSeries>}\n             */\n            series : null,\n            /**\n             * By default, the bars are scaled based upon the detected max value across all the series.\n             * A specific top value to represent the 100% height may be configured.\n             * @config {Number}\n             */\n            topValue : null,\n            element : {\n                children : [{\n                    ns,\n                    tag                 : 'svg',\n                    reference           : 'svgElement',\n                    width               : '100%',\n                    height              : '100%',\n                    preserveAspectRatio : 'none',\n                    children            : [{\n                        ns,\n                        tag       : 'g',\n                        reference : 'scaledSvgGroup'\n                    }, {\n                        ns,\n                        tag       : 'g',\n                        reference : 'unscaledSvgGroup'\n                    }]\n                }]\n            },\n            /**\n             * By default, all bars are rendered, even those with zero height. Configure this as `true`\n             * to omit zero height bars.\n             * @config {Boolean}\n             * @default\n             */\n            omitZeroHeightBars : false,\n            /**\n             * By default, the histogram calls {@link #config-getBarText} once per each datum.\n             * So the function is supposed to output all the series values the way it needs.\n             * Configure this as `false` to call the function for each series value\n             * if you need to display the values separately or having different styling.\n             * @config {Boolean}\n             * @default\n             */\n            singleTextForAllBars : true,\n            monitorResize : true,\n            /**\n             * A Function which returns a CSS class name to add to a rectangle element.\n             * The following parameters are passed:\n             * @config {Function}\n             * @param {HistogramSeries} series The series being rendered\n             * @param {Object} rectConfig The rectangle configuration object\n             * @param {Object} datum The datum being rendered\n             * @param {Number} index The index of the datum being rendered\n             * @returns {String} CSS class name of the rectangle element\n             * @returns {String} CSS class name\n             */\n            getRectClass(series, rectConfig, datum, index) {\n                return '';\n            },\n            /**\n             * A Function which returns a CSS class name to add to a path element\n             * built for an `outline` type series.\n             * The following parameters are passed:\n             * @param {HistogramSeries} series The series being rendered\n             * @param {Object[]} data The series data\n             * @returns {String} CSS class name of the path element\n             * @config {Function}\n             */\n            getOutlineClass(series, data) {\n                return '';\n            },\n            /**\n             * A Function which returns the tooltip text to display when hovering a bar.\n             * The following parameters are passed:\n             *\n             * @config {Function}\n             * @param {HistogramSeries} series The series being rendered\n             * @param {Object} rectConfig The rectangle configuration object\n             * @param {Object} datum The datum being rendered\n             * @param {Number} index The index of the datum being rendered\n             * @returns {String} Tip for the the bar.\n             */\n            getBarTip(series, rectConfig, datum, index) {},\n            /**\n             * A Function which returns the text to render inside a bar.\n             * The following parameters are passed:\n             * @param {Object} datum The datum being rendered\n             * @param {Number} index The index of the datum being rendered\n             * @param {HistogramSeries} [series] The series (provided if {@link #config-singleTextForAllBars}\n             * is `false`)\n             * @returns {String} Text to render in the bar.\n             * @config {Function}\n             */\n            getBarText(datum, index, series) {\n                return '';\n            },\n            getRectConfig : null,\n            getBarTextRenderData(renderData, datum, index, series) {\n                return renderData;\n            },\n            getBarTextTip(renderData, datum, index, series) {}\n        };\n    }\n    static properties = {\n        refreshSuspended : 0\n    };\n    //endregion\n    //region Init\n    construct(config) {\n        const me = this;\n        super.construct(config);\n        me.scheduleRefresh = me.createOnFrame(me.refresh, [], me, true);\n        me.refresh();\n    }\n    set tip(tip) {\n        const me = this;\n        me.tip?.destroy();\n        if (tip) {\n            me._tip = Tooltip.new({\n                owner             : me,\n                forElement        : me.svgElement,\n                forSelector       : 'rect',\n                internalListeners : {\n                    beforeShow : 'up.onBeforeTipShow'\n                }\n            }, tip);\n        }\n        else {\n            me._tip = null;\n        }\n    }\n    onElementResize() {\n        super.onElementResize(...arguments);\n        const svgRect = this.svgElement.getBoundingClientRect();\n        this.scaledSvgGroup.setAttribute('transform', `scale(${svgRect.width} ${svgRect.height})`);\n    }\n    onBeforeTipShow({ source : tip }) {\n        const index = parseInt(tip.activeTarget.dataset.index);\n        tip.html = tip.contentTemplate({\n            histogram : this,\n            index\n        });\n    }\n    updateSeries(value) {\n        const\n            me     = this,\n            series = me._series = {};\n        let\n            index = 0,\n            barSeriesCount = 0;\n        for (const id in value) {\n            // Providing\n            //\n            // \"series\" : {\n            //     \"foo\" : false\n            //     ...\n            //\n            // disables the \"foo\" series (that could be defined on a prototype level for example)\n            if (value[id] !== false) {\n                const data = series[id] = Objects.merge({}, value[id]);\n                // default field name is series identifier\n                if (!data.field) {\n                    data.field = id;\n                }\n                // default type is \"bar\"\n                if (!data.type) {\n                    data.type = 'bar';\n                }\n                if (!('order' in data)) {\n                    data.order = typePrio[data.type] * 10 + index;\n                }\n                if (!('index' in data)) {\n                    data.index = index;\n                }\n                if (data.type === 'bar') {\n                    data.index = barSeriesCount++;\n                }\n                data.id = id;\n                index++;\n            }\n        }\n        // Calculate the top value from all the series\n        if (!me.topValue && me._data) {\n            me.topValue = me.getDataTopValue(me._data);\n        }\n        if (!me.refreshSuspended) {\n            me.scheduleRefresh();\n        }\n    }\n    getDataTopValue(data, series) {\n        const fields   = Object.values(series || this.series).map(getField);\n        let result = 0, datum;\n        for (let i = 0, { length } = data; i < length; i++) {\n            datum = data[i];\n            for (let j = 0, { length } = fields; j < length; j++) {\n                result = Math.max(result, datum[fields[j]]);\n            }\n        }\n        return result;\n    }\n    updateData(data) {\n        const me = this;\n        me._data = data;\n        // Calculate the top value from all the series\n        if (!me.topValue && me._data && me._series) {\n            me.topValue = me.getDataTopValue(data);\n        }\n        if (!me.refreshSuspended) {\n            me.scheduleRefresh();\n        }\n    }\n    updateTopValue(value) {\n        const me = this;\n        me._topValue = value;\n        // Calculate the top value from all the series\n        if (!value && me._data) {\n            me._topValue = me.getDataTopValue(me._data);\n        }\n        if (!me.refreshSuspended) {\n            me.scheduleRefresh();\n        }\n    }\n    // Must exist from the start because configuration setters call it.\n    // Once configured, will be replaced with a function which schedules a refresh for the next animation frame.\n    scheduleRefresh() {\n    }\n    suspendRefresh() {\n        this.refreshSuspended++;\n    }\n    resumeRefresh() {\n        if (this.refreshSuspended) {\n            this.refreshSuspended--;\n        }\n    }\n    refresh(params) {\n        const\n            me             = this,\n            {\n                series,\n                _tip,\n                topValue,\n                singleTextForAllBars\n            }              = me,\n            // extra arguments to pass through\n            extraArgs = params?.args || [],\n            histogramElements = [],\n            textElements = [];\n        // bail out if there is no series provided\n        if (!series) {\n            return;\n        }\n        for (const data of Object.values(series).sort(byOrder)) {\n            const elConfig = me[`draw${StringHelper.capitalize(data.type)}`](data, ...extraArgs);\n            if (Array.isArray(elConfig)) {\n                histogramElements.push.apply(histogramElements, elConfig);\n            }\n            else {\n                histogramElements.push(elConfig);\n            }\n            // if it's told we should have separate texts for bars\n            if (!singleTextForAllBars && data.type === 'bar') {\n                textElements.push(...me.drawText(data, ...extraArgs));\n            }\n        }\n        // sort again since user could change order in a hook\n        histogramElements.sort(byDatasetOrder);\n        if (singleTextForAllBars) {\n            textElements.push(...me.drawText(null, ...extraArgs));\n        }\n        else {\n            textElements.sort(byDatasetOrder);\n        }\n        DomSync.sync({\n            domConfig : {\n                width               : '100%',\n                height              : '100%',\n                preserveAspectRatio : 'none',\n                dataset             : {\n                    topValue\n                },\n                children : [\n                    {\n                        ns,\n                        tag       : 'g',\n                        reference : 'scaledSvgGroup',\n                        children  : histogramElements\n                    },\n                    {\n                        ns,\n                        tag       : 'g',\n                        reference : 'unscaledSvgGroup',\n                        children  : textElements\n                    }\n                ]\n            },\n            configEquality : returnFalse,\n            targetElement  : me.svgElement\n        });\n        if (_tip && _tip.isVisible) {\n            me.onBeforeTipShow({ source : _tip });\n        }\n    }\n    drawBar(series, ...args) {\n        const\n            me           = this,\n            {\n                topValue,\n                data,\n                omitZeroHeightBars,\n                barStyle\n            }            = me,\n            {\n                field,\n                order,\n                stretch\n            }            = series,\n            { length }   = data,\n            defaultWidth = 1 / length,\n            children     = [],\n            seriesId     = StringHelper.createId(series.id),\n            seriesIndex  = series.index,\n            forceHeight  = stretch ? 1 : undefined;\n        let width;\n        for (let index = 0, x = 0, { length } = data; index < length; index++, x += width) {\n            const datum = data[index];\n            let rectConfig = (datum.rectConfig = {\n                ns,\n                tag     : 'rect',\n                dataset : {}\n            });\n            const\n                value = datum[field],\n                // limit height with topValue otherwise the histogram looks fine\n                // yet the bar tooltip picks wrong Y-coordinate and there is an empty space between it and the bar\n                height = value ? forceHeight || datum.height || (value > topValue ? topValue : value) / topValue : 0,\n                y = 1 - height,\n                barTip = me.callback('getBarTip', me, [series, rectConfig, datum, index, ...args]);\n            // use either provided width or the calculated value\n            width = datum.width || defaultWidth;\n            if (barStyle) {\n                rectConfig.style = barStyle;\n            }\n            else {\n                delete rectConfig.style;\n            }\n            Object.assign(rectConfig.dataset, {\n                index,\n                order,\n                series : seriesId\n            });\n            const\n                rectClass = {\n                    [`b-series-${seriesId}`]          : 1,\n                    [`b-series-index-${seriesIndex}`] : 1\n                },\n                classes = me.callback('getRectClass', me, [series, rectConfig, datum, index, ...args]);\n            if (classes) {\n                classes.split(classesDelimiter).forEach(cls => rectClass[cls] = 1);\n            }\n            Object.assign(rectConfig, {\n                x,\n                y,\n                width,\n                height,\n                class : rectClass\n            });\n            if (barTip) {\n                rectConfig.dataset.btip = barTip;\n            }\n            else {\n                delete rectConfig.dataset.btip;\n            }\n            if (me.getRectConfig) {\n                rectConfig = me.getRectConfig(rectConfig, datum, index, series, ...args);\n            }\n            if (rectConfig && (rectConfig.height || !omitZeroHeightBars)) {\n                children.push(rectConfig);\n            }\n        }\n        return children;\n    }\n    changeGetRectConfig(fn) {\n        return fn ? this.bindCallback(fn) : null;\n    }\n    drawOutline(series, ...args) {\n        const\n            me           = this,\n            {\n                topValue,\n                data\n            }            = me,\n            {\n                field,\n                order,\n                id\n            }            = series,\n            defaultWidth = 1 / data.length,\n            coords       = ['M 0,1'],\n            result       = {\n                ns,\n                tag     : 'path',\n                dataset : {\n                    order,\n                    id\n                }\n            };\n        let\n            barWidth,\n            command1 = 'M',\n            command2 = 'L';\n        for (let i = 0, x = 0, { length } = data; i < length; i++) {\n            const barHeight = 1 - data[i][field] / topValue;\n            // use either provided with or the calculated value\n            barWidth = data[i].width || defaultWidth;\n            coords.push(`${command1} ${x},${barHeight} ${command2} ${x += barWidth},${barHeight}`);\n            command1 = command2 = '';\n        }\n        // coords.push('1,1');\n        result.class = `b-series-${series.id} b-series-index-${series.index} ` +\n            me.callback('getOutlineClass', me, [series, data, ...args]);\n        result.d = coords.join(' ');\n        return result;\n    }\n    drawText(series, ...args) {\n        const\n            me                = this,\n            { data }          = me,\n            defaultWidth      = 1 / data.length,\n            defaultY          = '100%',\n            unscaledSvgGroups = [];\n        for (let index = 0, width, x = 0, { length } = data; index < length; index++, x += width) {\n            width = data[index].width || defaultWidth;\n            const barText = me.callback('getBarText', me, [data[index], index, series, ...args]);\n            if (barText) {\n                const renderData = me.callback('getBarTextRenderData', me, [{\n                    ns,\n                    tag       : 'text',\n                    className : 'b-bar-legend',\n                    html      : barText,\n                    left      : x,\n                    width,\n                    x         : `${(x + width / 2) * 100}%`,\n                    y         : data[index].y !== undefined ? data[index].y : defaultY,\n                    dataset   : {\n                        index,\n                        series\n                    }\n                }, data[index], index, series, ...args]);\n                const barTip = me.callback('getBarTextTip', me, [renderData, data[index], index, series, ...args]);\n                if (barTip) {\n                    renderData.dataset.btip = barTip;\n                }\n                else {\n                    delete renderData.dataset.btip;\n                }\n                unscaledSvgGroups.push(renderData);\n            }\n        }\n        return unscaledSvgGroups;\n    }\n    //endregion\n}\nHistogram.initClass();\nHistogram._$name = 'Histogram';", "import Widget from '../Widget.js';\nimport DomSync from '../../helper/DomSync.js';\n/**\n * @module Core/widget/graph/Scale\n */\nconst\n    ns = 'http://www.w3.org/2000/svg';\n/**\n * Displays a scale with ticks and labels.\n *\n * @extends Core/widget/Widget\n * @classtype scale\n */\nexport default class Scale extends Widget {\n    //region Config\n    static $name = 'Scale';\n    static type = 'scale';\n    static get configurable() {\n        return {\n            scalePoints : null,\n            // Padding after the max scale point.\n            // Expressed as the share of the height.\n            scaleMaxPadding : 0.1,\n            /**\n             * Configure as `true` to create a horizontal scale. Scales are vertical by default.\n             * @config {Boolean}\n             */\n            horizontal : false,\n            /**\n             * Side to align the scale to. Defaults to `bottom` for {@link #config-horizontal} Scales\n             * and `right` for vertical Scales.\n             * @config {String}\n             */\n            align : {\n                value   : false,\n                $config : {\n                    merge : 'replace'\n                }\n            },\n            element : {\n                children : [{\n                    ns,\n                    tag                 : 'svg',\n                    reference           : 'svgElement',\n                    width               : '100%',\n                    height              : '100%',\n                    preserveAspectRatio : 'none',\n                    children            : [{\n                        ns,\n                        tag       : 'g',\n                        reference : 'scaledSvgGroup',\n                        children  : [{\n                            ns,\n                            tag       : 'path',\n                            reference : 'pathElement'\n                        }]\n                    }, {\n                        ns,\n                        tag       : 'g',\n                        reference : 'unscaledSvgGroup'\n                    }]\n                }]\n            },\n            monitorResize : true\n        };\n    }\n    //endregion\n    //region Init\n    construct(config) {\n        super.construct(config);\n        this.scheduleRefresh = this.createOnFrame(this.refresh, [], this, true);\n        this.refresh();\n    }\n    changeAlign(align) {\n        if (!align) {\n            align = this.horizontal ? 'bottom' : 'right';\n        }\n        return align;\n    }\n    updateAlign(align, oldAlign) {\n        this.element.classList.remove(`b-align-${oldAlign}`);\n        this.element.classList.add(`b-align-${align}`);\n    }\n    updateHorizontal(horizontal, oldHorizontal) {\n        this.element.classList.remove(`b-scale-${oldHorizontal ? 'horizontal' : 'vertical'}`);\n        this.element.classList.add(`b-scale-${horizontal ? 'horizontal' : 'vertical'}`);\n    }\n    onElementResize() {\n        super.onElementResize(...arguments);\n        this.scheduleRefresh();\n    }\n    // Must exist from the start because configuration setters call it.\n    // Once configured, will be replaced with a function which schedules a refresh for the next animation frame.\n    scheduleRefresh() {\n    }\n    refresh() {\n        if (!this.scalePoints) {\n            return;\n        }\n        const\n            me             = this,\n            {\n                horizontal,\n                width,\n                height,\n                align,\n                scalePoints,\n                scaleMaxPadding\n            }                  = me,\n            scaleMax           = scalePoints[scalePoints.length - 1]?.value,\n            path               = [],\n            labels             = [];\n        const posFactor = 1 / (scaleMax + scaleMaxPadding * scaleMax);\n        me.scaledSvgGroup.setAttribute('transform', `scale(${horizontal ? width : 1} ${horizontal ? 1 : height})`);\n        for (const point of scalePoints) {\n            const isLabelStep = Boolean(point.text),\n                pos = posFactor * point.value;\n            if (isLabelStep) {\n                const label = {\n                    ns,\n                    tag       : 'text',\n                    className : 'b-scale-tick-label',\n                    html      : point.text,\n                    dataset   : {\n                        tick : point.value\n                    }\n                };\n                if (horizontal) {\n                    label.x = `${pos * 100}%`;\n                    label.y = align === 'top' ? '1.6em' : height - 12;\n                }\n                else {\n                    label.x = align === 'left' ? '12' : `${width - 12}`;\n                    label.y = `${(1 - pos) * 100}%`;\n                }\n                labels.push(label);\n            }\n            if (horizontal) {\n                if (align === 'top') {\n                    path.push(`M${pos},0 L${pos},${isLabelStep ? 10 : 5}`);\n                }\n                else {\n                    path.push(`M${pos},${height} L${pos},${height - (isLabelStep ? 10 : 5)}`);\n                }\n            }\n            else {\n                if (align === 'left') {\n                    path.push(`M0,${1 - pos} L${isLabelStep ? 10 : 5},${1 - pos}`);\n                }\n                else {\n                    path.push(`M${width},${1 - pos} L${width - (isLabelStep ? 10 : 5)},${1 - pos}`);\n                }\n            }\n        }\n        me.pathElement.setAttribute('d', path.join(''));\n        DomSync.syncChildren({\n            domConfig : { children : labels }\n        }, me.unscaledSvgGroup);\n    }\n    //endregion\n}\nScale.initClass();\nScale._$name = 'Scale';"],
  "mappings": "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",
  "names": ["ns", "typePrio", "byOrder", "l", "r", "byDatasetOrder", "getField", "s", "returnFalse", "classesDelimiter", "Histogram", "Widget", "series", "rectConfig", "datum", "index", "data", "renderData", "config", "me", "tip", "_a", "Tooltip", "svgRect", "value", "barSeriesCount", "id", "Objects", "fields", "result", "i", "length", "j", "params", "_tip", "topValue", "singleTextForAllBars", "extraArgs", "histogramElements", "textElements", "elConfig", "StringHelper", "DomSync", "args", "omitZeroHeightBars", "barStyle", "field", "order", "stretch", "defaultWidth", "children", "seriesId", "seriesIndex", "forceHeight", "width", "x", "height", "y", "barTip", "rectClass", "classes", "cls", "fn", "coords", "barWidth", "command1", "command2", "barHeight", "defaultY", "unscaledSvgGroups", "barText", "__publicField", "Scale", "align", "oldAlign", "horizontal", "oldHorizontal", "scalePoints", "scaleMaxPadding", "scaleMax", "path", "labels", "posFactor", "point", "isLabelStep", "pos", "label"]
}
