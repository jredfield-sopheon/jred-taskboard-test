{
  "version": 3,
  "sources": ["../../../../Grid/lib/Grid/feature/TreeGroup.js"],
  "sourcesContent": ["import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from './GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport FunctionHelper from '../../Core/helper/FunctionHelper.js';\n/**\n * @module Grid/feature/TreeGroup\n */\n/**\n * A feature that allows transforming a flat dataset (or the leaves of a hierarchical) into a tree by specifying a\n * record field per parent level. Parents are generated based on each leaf's value for those fields.\n *\n * {@inlineexample Grid/feature/TreeGroup.js}\n *\n * This feature can be used to mimic multi grouping or to generate another view for hierarchical data. The actual\n * transformation happens in a new store, that contains links to the original records. The original store's structure is\n * kept intact and will be plugged back in when calling {@link #function-clearGroups}.\n *\n * Any modification of the links is relayed to the original store. So cell editing and other features will work as\n * expected and the original data will be updated.\n *\n * Combine this feature with {@link Grid/widget/GroupBar} to allow users to drag drop column header to group the tree\n * store.\n *\n * <div class=\"note\">\n * Please note that this feature requires using a {@link Grid/view/TreeGrid} or having the {@link Grid/feature/Tree}\n * feature enabled.\n * </div>\n *\n * This snippet shows how the sample dataset used in the demo above is transformed:\n *\n * ```javascript\n * const grid = new TreeGrid({\n *     // Original data\n *     data : [\n *         { id : 1, name : 'Project 1', children : [\n *             { id : 11, name : 'Task 11', status : 'wip', prio : 'high' },\n *             { id : 12, name : 'Task 12', status : 'done', prio : 'low' },\n *             { id : 13, name : 'Task 13', status : 'done', prio : 'high' }\n *         ]},\n *         { id : 2, name : 'Project 2', children : [\n *             { id : 21, name : 'Task 21', status : 'wip', prio : 'high' },\n *         ]}\n *     ],\n *\n *     features : {\n *         treeGroup : {\n *             // Fields to build a new tree from\n *             levels : [ 'prio', 'status' ]\n *         }\n *     }\n * });\n *\n * // Resulting data\n * [\n *     { name : 'low', children : [\n *         { name : 'done', children : [\n *             { id : 12, name : 'Task 12', status : 'done', prio : 'low' }\n *         ]}\n *     ]},\n *     { name : 'high', children : [\n *         { name : 'done', children : [\n *             { id : 13, name : 'Task 13', status : 'done', prio : 'high' }\n *         ]},\n *         { name : 'wip', children : [\n *             { id : 11, name : 'Task 11', status : 'wip', prio : 'high' },\n *             { id : 21, name : 'Task 21', status : 'wip', prio : 'low' }\n *         ]}\n *     ]}\n * ]\n * ```\n *\n * Generated parent records are indicated with `generatedParent` and `key` properties. The first one is set to\n * `true` and the latter one has a value for the group the parent represents.\n *\n * ## Important information\n *\n * Using the TreeGroup feature comes with some caveats:\n *\n * * Generated parents are read-only, they cannot be edited using the default UI.\n * * Moving nodes manually in the tree is not supported while it is grouped. The linked records have their own\n *   `parentId` fields, not linked to the original records value.\n * * The generated structure is not meant to be persisted.\n *\n * <div class=\"note\">\n * Please note that this feature is not supported in vertical mode in Scheduler.\n * </div>\n *\n * This feature is <strong>disabled</strong> by default.\n *\n * @extends Core/mixin/InstancePlugin\n *\n * @classtype treeGroup\n * @feature\n */\nexport default class TreeGroup extends InstancePlugin {\n    static $name = 'TreeGroup';\n    static configurable = {\n        /**\n         * An array of model field names or functions used to determine the levels in the resulting tree.\n         *\n         * When supplying a function, it will be called for each leaf in the original data, and it is expected to return\n         * an atomic value used to determine which parent the leaf will be added to at that level.\n         *\n         * ```javascript\n         * const grid = new TreeGrid({\n         *     features : {\n         *         treeGroup : {\n         *             levels : [\n         *                 // First level is determined by the value of the status field\n         *                 'status',\n         *                 // Second level by the result of this function\n         *                 // (which puts percentdone 0-9 in one group, 10-19 into another and so on)\n         *                 record => (record.percentDone % 10) * 10\n         *             ]\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * The function form can also be used as a formatter/renderer of sorts, simply by returning a string:\n         *\n         * ```javascript\n         * const grid = new TreeGrid({\n         *     features : {\n         *         treeGroup : {\n         *             levels : [\n         *                 record => `Status: ${record.status}`\n         *             ]\n         *         }\n         *     }\n         * });\n         * ```\n         *\n         * Assigning `null` restores the tree structure to its original state.\n         *\n         * @prp {Array<String|Function(Core.data.Model) : any>} levels\n         */\n        levels : [],\n        /**\n         * CSS class to apply to the generated parents.\n         *\n         * @config {String}\n         * @default\n         */\n        parentCls : 'b-generated-parent',\n        /**\n         * A function letting you format the text shown in the generated parent group levels. This method will be provided\n         * with the value produced by the column representing the grouped level. Each column's renderer method will be\n         * provided an extra `isTreeGroup` param to indicate that the value will be used for a generated parent. `cellElement`\n         * and other DOM specific args will be in the context of the tree column.\n         *\n         * ```javascript\n         * const grid = new Grid({\n         *     features : {\n         *         treeGroup : {\n         *             hideGroupedColumns : true,\n         *             levels             : [\n         *                 'priority'\n         *             ],\n         *             parentRenderer({ field, value, column, record }) {\n         *                 // For generated group parent, prefix with the grouped column text\n         *                 return column.text + ': ' + value;\n         *             }\n         *         }\n         *     }\n         * })\n         * ```\n         *\n         * @config {Function}\n         * @param {Object} data The rendering data representing the generated tree parent record\n         * @param {String} data.field The field representing this group level (e.g. 'priority')\n         * @param {*} data.value The value representing this group level (e.g. 'high')\n         * @param {Grid.column.Column} data.column The value representing this group level (e.g. 'high')\n         * @param {Core.data.Model} data.record The first record for this parent\n         * @returns {String}\n         */\n        parentRenderer : null,\n        /**\n         * True to hide grouped columns. Only supported when using String to define levels.\n         *\n         * @config {Boolean}\n         */\n        hideGroupedColumns : null,\n        /**\n         * The number of milliseconds to wait after {@link #function-scheduleRefreshGroups} call\n         * before actually refreshing groups.\n         * Each further {@link #function-scheduleRefreshGroups} call during that timeout will restart the timer.\n         * @config {Number}\n         * @default\n         * @private\n         */\n        refreshGroupsTimeout : 100\n    };\n    static pluginConfig = {\n        chain  : ['populateHeaderMenu'],\n        assign : ['group', 'clearGroups', 'refreshGroups']\n    };\n    static properties = {\n        isApplying    : 0,\n        /**\n         * The original store used by the component before applying grouping. Use this to modify / load data\n         * while tree grouping is active.\n         * @property {Core.data.Store}\n         * @readonly\n         */\n        originalStore : null\n    };\n    construct(grid, config) {\n        this.treeColumn = grid.columns.find(col => col.isTreeColumn);\n        super.construct(grid, config);\n        this._levels = this._levels || [];\n        if (!grid.hasFeature('tree')) {\n            throw new Error('The TreeGroup feature requires the Tree feature to be enabled');\n        }\n    }\n    applyPluginConfig() {\n        /**\n         * A \"debounced\" version of {@link #function-refreshGroups} method.\n         * When first invoked will wait for {@link #config-refreshGroupsTimeout} before\n         * before actually refreshing groups.\n         * Each further {@link #function-scheduleRefreshGroups} call during that timeout will restart the timer.\n         *\n         * The function is useful to avoid excessive refreshes when reacting on some events tha could be triggered\n         * multiple times.\n         * @function scheduleRefreshGroups\n         * @private\n         */\n        this.scheduleRefreshGroups = FunctionHelper.createBuffered(this.refreshGroups, this.refreshGroupsTimeout, this);\n        return super.applyPluginConfig(...arguments);\n    }\n    processParentData(parentData) {\n        const me = this;\n        // Apply cls to allow custom styling of generated parents\n        if (me.parentCls) {\n            parentData.cls = me.parentCls;\n        }\n    }\n    processTransformedData(transformedData) {}\n    async waitForReadiness() {\n        const me = this;\n        // Wait for store to finish loading before transforming the data\n        if (me.originalStore.isLoading) {\n            await me.originalStore.await('load', false);\n            if (me.isDestroyed) {\n                return;\n            }\n        }\n        // For Scheduler, Pro & Gantt, to not have to implement a TreeGroup in Scheduler just to add this\n        const { crudManager } = this.client;\n        if (crudManager) {\n            if (crudManager.isLoadingOrSyncing || crudManager._autoLoadPromise) {\n                await crudManager.await('requestDone');\n            }\n            if (me.isDestroyed) {\n                return;\n            }\n            await me.client.project?.commitAsync();\n        }\n    }\n    async applyLevels(levels) {\n        const\n            me                     = this,\n            { client, treeColumn } = me;\n        let\n            { store } = client,\n            result    = null,\n            treeColumnField;\n        const { modelClass } = store;\n        // Get TreeColumn field name (if column.field is provided)\n        if (treeColumn?.field && modelClass.getFieldDefinition(treeColumn.field)) {\n            treeColumnField = modelClass.getFieldDataSource(treeColumn.field);\n        }\n        levels = levels || [];\n        if (levels.length === 0 && me.isConfiguring) {\n            return;\n        }\n        me._levels = levels;\n        me.isApplying++;\n        client.suspendRefresh();\n        if (!me.originalStore) {\n            me.originalStore = store;\n            store            = new store.constructor({\n                reapplyFilterOnAdd    : true,\n                reapplyFilterOnUpdate : true,\n                tree                  : true,\n                modelClass            : store.modelClass,\n                load                  : store.load?.bind(store),\n                commit                : store.commit.bind(store)\n            });\n            client.store     = store;\n            me.originalStore.ion({\n                name      : 'originalStore',\n                refresh   : me.onOriginalStoreRefresh,\n                add       : me.onOriginalStoreChanged,\n                remove    : me.onOriginalStoreChanged,\n                removeAll : me.onOriginalStoreChanged,\n                thisObj   : me\n            });\n        }\n        await me.waitForReadiness();\n        if (me.isDestroyed) {\n            return;\n        }\n        // Applying custom levels\n        if (levels.length > 0) {\n            const leafLinks = me.originalStore.getAllDataRecords(false).flatMap(record => record.isLeaf ? record.link() : []);\n            // reset leaf records meta (collapsed, hidden etc)\n            leafLinks.forEach(record => record.setInstanceMeta(store.id, { collapsed : false }));\n            // Plug links in to allow transforming them below\n            store.data = leafLinks;\n            // Transform it according to levels\n            result = store.treeify(levels, parentData => {\n                // Use group key as tree columns content (if the column field is provided)\n                if (treeColumnField) {\n                    ObjectHelper.setPath(parentData, treeColumnField, parentData.key);\n                }\n                // Let the outside world manipulate generated parents data before turning it into a record\n                me.processParentData(parentData);\n            });\n            me.processTransformedData(result);\n            await me.trigger('beforeDataLoad', { store, data : result.children });\n            // Load the transformed result into the \"display store\"\n            store.data = result.children;\n        }\n        // Clearing custom levels\n        else {\n            client.store = me.originalStore;\n            me.detachListeners('originalStore');\n            me.originalStore = null;\n        }\n        me.isApplying--;\n        client.resumeRefresh(false);\n        if (client.isPainted) {\n            client.renderRows(false);\n        }\n        client.trigger('treeGroupChange', { levels });\n    }\n    doDisable(disable) {\n        if (disable) {\n            this.clearGroups();\n        }\n        super.doDisable(disable);\n    }\n    onOriginalStoreChanged() {\n        this.scheduleRefreshGroups();\n    }\n    onOriginalStoreRefresh({ action }) {\n        if (action === 'dataset' || action === 'filter') {\n            this.scheduleRefreshGroups();\n        }\n    }\n    updateLevels(levels, old) {\n        const me         = this,\n            { client } = me;\n        if (me.hideGroupedColumns) {\n            old?.forEach(field => {\n                field = field.fieldName || field;\n                if (!levels.some(level => (level.fieldName || level) === field)) {\n                    client.columns.get(field).show();\n                }\n            });\n            levels?.forEach(field => {\n                field = field.fieldName || field;\n                if (!old || !old.some(fn => fn.fieldName === field)) {\n                    client._suspendRenderContentsOnColumnsChanged = true;\n                    client.columns.get(field).hide();\n                    client._suspendRenderContentsOnColumnsChanged = false;\n                }\n            });\n        }\n        if (levels || !me.isConfiguring) {\n            me.updatePromise = me.applyLevels(levels);\n            client.renderContents();\n        }\n    }\n    /**\n     *\n     * Transforms the data according to the supplied levels.\n     *\n     * Yields the same result as assigning to {@link #property-levels}.\n     *\n     * ```javascript\n     * // Transform into a tree with two parent levels\n     * grid.group('status', record => (record.percentDone % 10) * 10);\n     * ```\n     *\n     * @param {Array<String|Grid.column.Column|Function(Core.data.Model) : any>} levels Field names or functions use to generate parents in resulting tree.\n     * @on-owner\n     * @category Common\n     */\n    async group(levels) {\n        ObjectHelper.assertArray(levels, 'group()');\n        await this.applyLevels(levels);\n    }\n    /**\n     * Clears the previously applied transformation, restoring data to its initial state.\n     *\n     * Yields the same result as assigning `null` to {@link #property-levels}.\n     *\n     * ```javascript\n     * // Restore original data\n     * grid.clearGroups();\n     * ```\n     * @on-owner\n     * @category Common\n     */\n    async clearGroups() {\n        if (this.isGrouped) {\n            this.levels = [];\n            await this.updatePromise;\n        }\n    }\n    /**\n     * Refreshes the store tree grouping by re-applying the current transformation.\n     *\n     * ```javascript\n     * // Refresh groups\n     * grid.refreshGroups();\n     * ```\n     * @on-owner\n     * @category Common\n     * @private\n     */\n    refreshGroups() {\n        // since we have a buffered wrapper of this function\n        // we have to check if applyLevels exists in case the feature is destroyed\n        return this.applyLevels?.(this._levels);\n    }\n    /**\n     * Indicates if the feature has applied grouping and the component uses\n     * a transformed version of the store.\n     * @property {Boolean}\n     */\n    get isGrouped() {\n        return this._levels.length > 0;\n    }\n    /**\n     * Supply items for headers context menu.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateHeaderMenu({ column, items }) {\n        const\n            me        = this,\n            groupable = column.groupable !== false && !column.isTreeColumn;\n        let separator = false;\n        if (groupable && !me.isGroupedByField(column.field)) {\n            items.groupAsc = {\n                text        : 'L{group}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-group-asc',\n                separator   : true,\n                weight      : 400,\n                disabled    : me.disabled,\n                onItem      : () => me.addGrouper(column)\n            };\n            separator      = true;\n        }\n        if (me.isGrouped) {\n            if (me.isGroupedByField(column.field)) {\n                items.groupRemove = {\n                    text        : 'L{stopGroupingThisColumn}',\n                    localeClass : me,\n                    icon        : 'b-fw-icon b-icon-clear',\n                    separator   : !separator,\n                    weight      : 420,\n                    disabled    : me.disabled,\n                    onItem      : () => me.removeGrouper(column)\n                };\n                separator         = true;\n            }\n            items.groupRemoveAll = {\n                text        : 'L{stopGrouping}',\n                localeClass : me,\n                icon        : 'b-fw-icon b-icon-clear',\n                separator   : !separator,\n                weight      : 420,\n                disabled    : me.disabled,\n                onItem      : () => me.clearGroups()\n            };\n        }\n    }\n    addGrouper(column) {\n        this.levels = this.levels.concat(column.field);\n    }\n    isGroupedByField(field) {\n        return this.levels.find(groupFn => groupFn.fieldName === field);\n    }\n    removeGrouper(column) {\n        this.levels.splice(this.levels.findIndex(groupFn => groupFn.fieldName === column.field), 1);\n        this.levels = this.levels.slice();\n    }\n}\nTreeGroup._$name = 'TreeGroup'; GridFeatureManager.registerFeature(TreeGroup);\n"],
  "mappings": "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",
  "names": ["TreeGroup", "InstancePlugin", "grid", "config", "col", "FunctionHelper", "parentData", "me", "transformedData", "_a", "crudManager", "levels", "client", "treeColumn", "store", "result", "treeColumnField", "modelClass", "leafLinks", "record", "ObjectHelper", "disable", "action", "old", "field", "level", "fn", "column", "items", "groupable", "separator", "groupFn", "__publicField", "GridFeatureManager"]
}
