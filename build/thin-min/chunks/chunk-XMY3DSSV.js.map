{
  "version": 3,
  "sources": ["../../../../Core/lib/Core/mixin/Featureable.js", "../../../../Core/lib/Core/mixin/Fencible.js", "../../../../Core/lib/Core/widget/FilterField.js", "../../../../Core/lib/Core/widget/mixin/Responsive.js"],
  "sourcesContent": ["import Base from '../Base.js';\nimport DynamicObject from '../util/DynamicObject.js';\n/**\n * @module Core/mixin/Featureable\n */\n/**\n * This mixin provides management of a set of features that can be manipulated via the `features` config.\n *\n * The first step in using `Featureable` is to define the family of features using `Factoryable` to declare a base\n * class for features to extend:\n *\n * ```javascript\n *  class SuperWidgetFeature extends InstancePlugin.mixin(Factoryable) {\n *      static get factoryable() {\n *          //\n *      }\n *  }\n * ```\n *\n * The various feature classes extend the `SuperWidgetFeature` base class and call `initClass()` to register themselves:\n *\n * ```javascript\n *  export default class AmazingSuperWidgetFeature extends SuperWidgetFeature {\n *      static get type() {\n *          return 'amazing';\n *      }\n *  }\n *\n *  AmazingSuperWidgetFeature.initClass();\n * ```\n *\n * A class that supports these features via `Featureable` is declared like so:\n *\n * ```javascript\n *  class SuperWidget extends Widget.mixin(Featureable) {\n *      static get featureable() {\n *          return {\n *              factory : SuperWidgetFeature\n *          };\n *      }\n *\n *      static get configurable() {\n *          return {\n *              // Declare the default features. These can be disabled by setting them to a falsy value. Using\n *              // configurable(), the value defined by this class is merged with values defined by derived classes\n *              // and ultimately the instance.\n *              features : {\n *                  amazing : {\n *                      ...\n *                  }\n *              }\n *          };\n *      }\n *  }\n *```\n * @mixin\n * @internal\n */\nexport default Target => class Featureable extends (Target || Base) {\n    static get $name() {\n        return 'Featureable';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Specifies the features to create and associate with the instance. The keys of this object are the names\n             * of features. The values are config objects for those feature instances.\n             *\n             * After construction, this property can be used to access the feature instances and even reconfigure them.\n             *\n             * For example:\n             * ```\n             *  instance.features.amazing = {\n             *      // reconfigure this feature\n             *  }\n             * ```\n             * This can also be done in bulk:\n             * ```\n             *  instance.features = {\n             *      amazing : {\n             *          // reconfigure this feature\n             *      },\n             *      // reconfigure other features\n             *  }\n             * ```\n             * @config {Object}\n             */\n            features : null\n        };\n    }\n    static get declarable() {\n        return [\n            /**\n             * This property getter returns options that control feature management for the derived class. This\n             * property getter must be defined by the class that mixes in `Featureable` in order to initialize the\n             * class properly.\n             * ```\n             *  class SuperWidget extends Widget.mixin(Featureable) {\n             *      static get featureable() {\n             *          return {\n             *              factory : SuperWidgetFeature\n             *          };\n             *      }\n             *      ...\n             *  }\n             * ```\n             * @static\n             * @member {Object} featureable\n             * @property {Core.mixin.Factoryable} featureable.factory The factoryable class (not one of its instances)\n             * that will be used to create feature instances.\n             * @property {String} [featureable.ownerName='client'] The config or property to assign on each feature as\n             * a reference to its creator, the `Featureable` instance.\n             * @internal\n             */\n            'featureable'\n        ];\n    }\n    static setupFeatureable(cls) {\n        const featureable = {\n            ownerName : 'client',\n            ...cls.featureable\n        };\n        featureable.factory.initClass();\n        // Replace the class/static getter with a new one that returns the complete featureable object:\n        Reflect.defineProperty(cls, 'featureable', {\n            get() {\n                return featureable;\n            }\n        });\n    }\n    doDestroy() {\n        const features = this.features;\n        super.doDestroy();\n        for (const name in features) {\n            const feature = features[name];\n            // Feature might be false or destroyed already by Grid (EventList mixes in CalendarMixin which has this mixin)\n            feature.destroy?.();\n        }\n    }\n    /**\n     * Returns `true` if the specified feature is active for this instance and `false` otherwise.\n     * @param {String} name The feature name\n     * @returns {Boolean}\n     */\n    hasFeature(name) {\n        return Boolean(this.features?.[name]);\n    }\n    changeFeatures(features, was) {\n        if (this.isDestroying) {\n            return;\n        }\n        const\n            me = this,\n            { featureable } = me.constructor,\n            manager = me.$features || (me.$features = new DynamicObject({\n                configName : 'features',\n                factory    : featureable.factory,\n                owner      : me,\n                ownerName  : featureable.ownerName\n            }));\n        manager.update(features);\n        if (!was) {\n            // Only return the target once. Further calls are processed above so we need to return undefined to ensure\n            // onConfigChange is called. By returning the same target on 2nd+ call, it passes the === test and won't\n            // trigger onConfigChange.\n            return manager.target;\n        }\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n    getCurrentConfig(options) {\n        const\n            result       = super.getCurrentConfig(options),\n            { features } = result;\n        if (features) {\n            // Replace empty configs with `true`\n            for (const featureName in features) {\n                if (Object.keys(features[featureName]).length === 0) {\n                    features[featureName] = true;\n                }\n            }\n        }\n        return result;\n    }\n};\n", "import ObjectHelper from '../helper/ObjectHelper.js';\nimport StringHelper from '../helper/StringHelper.js';\nimport Base from '../Base.js';\n/**\n * @module Core/mixin/Fencible\n */\nconst\n    { defineProperty } = Object,\n    { hasOwn }         = ObjectHelper,\n    fencibleSymbol     = Symbol('fencible'),\n    NONE               = [],\n    distinct           = array => Array.from(new Set(array)),\n    parseNames         = names => names ? distinct(StringHelper.split(names)) : NONE,\n    fenceMethod = (target, name, options) => {\n        if (options === true) {\n            options = name;\n        }\n        if (!ObjectHelper.isObject(options)) {\n            options = {\n                all : options\n            };\n        }\n        let any = parseNames(options.any);\n        const\n            all      = parseNames(options.all),\n            lock     = options.lock ? parseNames(options.lock) : distinct(all.concat(any)),\n            implName = name + 'Impl',\n            fence    = function(...params) {  // cannot use => since we need to receive \"this\" from the caller\n                const\n                    me = this,\n                    // For static methods we have to be careful to use hasOwn to check the \"point of entry\" (i.e., the\n                    // class reference used to call the method) since \".\" will climb the constructor's __proto__ chain\n                    // to find properties from a super class. This does not happen to instances since we never put our\n                    // fences object on the prototype chain.\n                    fences = hasOwn(me, fencibleSymbol) ? me[fencibleSymbol] : (me[fencibleSymbol] = {}),\n                    isFree = key => !fences[key];\n                if (all.every(isFree) && (!any || any.some(isFree))) {\n                    try {\n                        lock.forEach(key => (fences[key] = (fences[key] || 0) + 1));\n                        return me[implName](...params);\n                    }\n                    finally {\n                        lock.forEach(key => --fences[key]);\n                    }\n                }\n            };\n        any = any.length ? any : null;  // [].some(f) is always false, but [].every(f) is always true\n        !target[implName] && defineProperty(target, implName, {\n            configurable : true,\n            value        : target[name]\n        });\n        defineProperty(target, name, {\n            configurable : true,\n            value        : fence\n        });\n    };\n/**\n * A description of how to protect a method from reentry.\n *\n * A value of `true` is transformed using the key as the `all` value. For example, this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : true\n *      };\n * ```\n *\n * Is equivalent to this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : {\n *              all : ['foo']\n *          }\n *      };\n * ```\n *\n * Strings are split on spaces to produce the `all` array. For example, this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : 'foo bar'\n *      };\n * ```\n *\n * Is equivalent to this:\n *\n * ```javascript\n *  class Foo extends Base.mixin(Fencible) {\n *      static fenced = {\n *          foo : {\n *              all : ['foo', 'bar']\n *          }\n *      };\n * ```\n *\n * This indicates that `foo()` cannot be reentered if `foo()` or `bar()` are already executing. On entry to `foo()`,\n * both `foo()` and `bar()` will be fenced (prevented from entering).\n *\n * @typedef {Object} MethodFence\n * @property {String|String[]} [all] One or more keys that must all be currently unlocked to allow entry to the fenced\n * method. String values are converted to an array by splitting on spaces.\n * @property {String|String[]} [any] One or more keys of which at least one must be currently unlocked to allow entry\n * to the fenced method. String values are converted to an array by splitting on spaces.\n * @property {String|String[]} [lock] One or more keys that will be locked on entry to the fenced method and released\n * on exit. String values are converted to an array by splitting on spaces. By default, this array includes all keys\n * in `all` and `any`.\n */\n/**\n * This mixin is used to apply reentrancy barriers to methods. For details, see\n * {@link Core.mixin.Fencible#property-fenced-static}.\n * @mixin\n * @internal\n */\nexport default Target => class Fencible extends (Target || Base) {\n    static $name = 'Fencible';\n    static declarable = [\n        /**\n         * This class property returns an object that specifies methods to be wrapped to prevent reentrancy.\n         *\n         * It is used like so:\n         * ```javascript\n         *  class Foo extends Base.mixin(Fencible) {\n         *      static fenced = {\n         *          reentrantMethod : true\n         *      };\n         *\n         *      reentrantMethod() {\n         *          // things() may cause reentrantMethod() to be called...\n         *          // but we won't be allowed to reenter this method since we are already inside it\n         *          this.things();\n         *      }\n         *  }\n         * ```\n         *\n         * This can also be used to protect mutually reentrant method groups:\n         *\n         * ```javascript\n         *  class Foo extends Base.mixin(Fencible) {\n         *      static fenced = {\n         *          foo : 'foobar'\n         *          bar : 'foobar'\n         *      };\n         *\n         *      foo() {\n         *          console.log('foo');\n         *          this.bar();\n         *      }\n         *\n         *      bar() {\n         *          console.log('bar');\n         *          this.foo();\n         *      }\n         *  }\n         *\n         *  instance = new Foo();\n         *  instance.foo();\n         *  >> foo\n         *  instance.bar();\n         *  >> bar\n         * ```\n         *\n         * The value for a fenced method value can be `true`, a string, an array of strings, or a\n         * {@link #typedef-MethodFence} options object.\n         *\n         * Internally these methods are protected by assigning a wrapper function in their place. The original function\n         * is moved to a new named property by appending 'Impl' to the original name. For example, in the above code,\n         * `foo` and `bar` are wrapper functions that apply reentrancy protection and call `fooImpl` and `barImpl`,\n         * respectively. This is important for inheritance and `super` calling because the new name must be used in\n         * order to retain the guard function implementations.\n         *\n         * @static\n         * @member {Object} fenced\n         * @internal\n         */\n        'fenced'\n    ];\n    static setupFenced(cls) {\n        let { fenced } = cls;\n        const\n            statics = fenced.static,\n            pairs = [];\n        if (statics) {\n            fenced = { ...fenced };\n            delete fenced.static;\n            pairs.push([statics, cls]);\n        }\n        pairs.push([fenced, cls.prototype]);\n        for (const [methods, target] of pairs) {\n            for (const methodName in methods) {\n                fenceMethod(target, methodName, methods[methodName]);\n            }\n        }\n    }\n    // This does not need a className on Widgets.\n    // Each *Class* which doesn't need 'b-' + constructor.name.toLowerCase() automatically adding\n    // to the Widget it's mixed in to should implement thus.\n    get widgetClass() {}\n};\n", "import TextField from '../../Core/widget/TextField.js';\n/**\n * @module Core/widget/FilterField\n */\n/**\n * A simple text field for filtering a store.\n *\n * Allows filtering by {@link #config-field field}:\n *\n * ```javascript\n * const filterField = new FilterField({\n *    store : eventStore,\n *    field : 'name'\n * });\n * ```\n *\n * Or by using a {@link #config-filterFunction filter function} for greater control/custom logic:\n *\n * ```javascript\n * const filterField = new FilterField({\n *    store          : eventStore,\n *    filterFunction : (record, value) => record.name.includes(value)\n * });\n * ```\n *\n * @extends Core/widget/TextField\n * @classtype filterfield\n * @widget\n */\nexport default class FilterField extends TextField {\n    static $name = 'FilterField';\n    static type = 'filterfield';\n    static get configurable() {\n        return {\n            /**\n             * The model field name to filter by. Can optionally be replaced by {@link #config-filterFunction}\n             * @config {String}\n             * @category Filtering\n             */\n            field : null,\n            /**\n             * The store to filter.\n             * @config {Core.data.Store}\n             * @category Filtering\n             */\n            store : null,\n            /**\n             * Optional filter function to be called with record and value as parameters for store filtering.\n             * ```javascript\n             * {\n             *     type           : 'filterfield',\n             *     store          : myStore,\n             *     filterFunction : (record, value)  => {\n             *        return record.text.includes(value);\n             *     }\n             * }\n             * ```\n             *\n             * @config {Function}\n             * @param {Core.data.Model} record Record for comparison\n             * @param {String} value Value to compare with\n             * @returns {Boolean} Returns `true` if record matches comparison requirements\n             *\n             * @category Filtering\n             */\n            filterFunction : null,\n            clearable            : true,\n            revertOnEscape       : true,\n            ignoreParentReadOnly : true,\n            keyStrokeChangeDelay : 100,\n            onChange({ value }) {\n                const { store, field, filterFunction } = this;\n                if (store) {\n                    const filterId = `${field || this.id}-Filter`;\n                    if (value.length === 0) {\n                        store.removeFilter(filterId);\n                    }\n                    else {\n                        let filterBy;\n                        if (filterFunction) {\n                            filterBy = record => filterFunction(record, value);\n                        }\n                        else {\n                            // We filter using a RegExp, so quote significant characters\n                            value = value.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n                            filterBy = record => record.getValue(field)?.match(new RegExp(value, 'i'));\n                        }\n                        // A filter with an id replaces any previous filter with that id.\n                        // Leave any other filters which may be in use in place.\n                        store.filter({\n                            id : filterId,\n                            filterBy\n                        });\n                    }\n                }\n            }\n        };\n    }\n    updateValue(value, old) {\n        super.updateValue(value, old);\n        // Initial value, apply it\n        if (value && this.isConfiguring) {\n            this.onChange({ value });\n        }\n    }\n};\nFilterField.initClass();\nFilterField._$name = 'FilterField';", "import Base from '../../Base.js';\nimport BrowserHelper from '../../helper/BrowserHelper.js';\nimport FunctionHelper from '../../helper/FunctionHelper.js';\nimport ObjectHelper from '../../helper/ObjectHelper.js';\nimport Delayable from '../../mixin/Delayable.js';\nimport Fencible from '../../mixin/Fencible.js';\n/**\n * @module Core/widget/mixin/Responsive\n */\nconst\n    EMPTY = [],\n    isStateName = name => name[0] !== '*',\n    pop = (object, key) => {\n        const ret = object[key] || null;\n        delete object[key];\n        return ret;\n    },\n    responsiveRootFn = widget => widget.responsiveRoot,\n    scoring = {\n        number : threshold => ({ width }) => width <= threshold && threshold\n    },\n    splitConfigs = configs => {\n        delete configs.once;\n        return {\n            callback : pop(configs, 'callback'),\n            configs,\n            when     : pop(configs, 'when')\n        };\n    },\n    // We cheat a bit and leave \"once\", \"when\" and \"callback\" in the config object for the merge.\n    splitMergedConfigs = (cls, ...parts) => {\n        const\n            once = parts.flatMap(p => p?.once || EMPTY), // onces are not arrays, so are unchanged; ==> filter().map()\n            configs = cls.mergeConfigs(...parts),\n            ret = splitConfigs(configs);\n        ret.once = once.length ? splitConfigs(cls.mergeConfigs(...once)) : null;\n        return ret;\n    },\n    // Allow responsiveTarget to be a DOM element? (see git history for wrapElement impl)\n    wrapWidget = (widget, handler) => {\n        let triggers,\n            desc = Proxy.revocable(widget, {\n                get(o, name) {\n                    if (triggers) {\n                        triggers[name] = true;\n                    }\n                    return widget[name];\n                }\n            }),\n            detacher = FunctionHelper.after(widget, 'onConfigChange', (ignore, { name }) => {\n                if (triggers?.[name]) {\n                    handler();\n                }\n            }),\n            resizer = widget.ion({\n                resize : () => {\n                    handler();\n                }\n            });\n        widget.monitorResize = true;\n        return {\n            widget,\n            get object() {\n                return desc?.proxy;\n            },\n            destroy() {\n                if (desc) {\n                    desc.revoke();\n                    detacher();\n                    resizer();\n                    desc = detacher = resizer = null;\n                }\n            },\n            reset() {\n                triggers = Object.create(null);\n            }\n        };\n    };\n/**\n * A state definition object used by the {@link Core.widget.mixin.Responsive#config-responsive} config property.\n *\n * ```javascript\n *  {\n *      responsive : {\n *          small : {\n *              // a ResponsiveState object\n *              when : 400,\n *\n *              callback() {\n *                  console.log('Applied small not first time');\n *              },\n *\n *              once : {\n *                  mode : 'full',\n *\n *                  callback() {\n *                      console.log('Applied small first time');\n *                  }\n *              }\n *\n *              // All other properties are configs to apply when\n *              // the state is active\n *              text  : null,\n *              color : 'b-blue'\n *          }\n *      }\n *  }\n * ```\n *\n * See {@link Core.widget.mixin.Responsive} for more details.\n *\n * @typedef ResponsiveState\n * @property {ResponsiveState} once A `ResponsiveState` object applied only one time when a state is first activated. It\n * is not valid to specify a `when` or `once` property on these `ResponsiveState` objects. It is valid to supply a\n * `callback`, and if done, this callback will be called instead of the `callback` on the parent `ResponsiveState`\n * object on first activation.\n * @property {Function|Number} when A two argument function to return the score for the state, or a number for both the\n * width threshold and score. The arguments passed are as follows:\n *  - `widget` The {@link Core.widget.mixin.Responsive#config-responsiveTarget widget} whose properties should determine\n *  the state's score\n *  - `browserHelper` The {@link Core.helper.BrowserHelper} singleton object\n * @property {Function} [callback] An optional callback, called when the state is activated. This function receives an\n * object with the following properties:\n *  - `source` The instance whose state is being activated (typically a {@link Core.widget.Widget})\n *  - `target` The {@link Core.widget.Widget} identified as the {@link Core.widget.mixin.Responsive#config-responsiveTarget}\n *  - `state` The name of the newly active responsive state\n *  - `oldState` The name of the previously active responsive state\n */\n/**\n * A breakpoint definition. Used when defining breakpoints, see {@link #config-breakpoints}.\n *\n * ```javascript\n * {\n *     name    : 'Small',\n *     configs : {\n *         text  : null,\n *         color : 'b-blue'\n *     },\n *     callback() {\n *         console.log('Applied small');\n *     }\n * }\n * ```\n *\n * @typedef Breakpoint\n * @property {String} name Name of the breakpoint\n * @property {Object} [configs] An optional configuration object to apply to the widget when the breakpoint is activated\n * @property {Function} [callback] An optional callback, called when the breakpoint is activated\n * @deprecated 5.0 Breakpoints have been replaced by {@link Core.widget.mixin.Responsive#config-responsive}.\n */\n/**\n * This mixin provides management of a named set of {@link #typedef-ResponsiveState} objects that are conditionally\n * applied in response to the widget's size or other platform details. The names of the {@link #typedef-ResponsiveState}\n * objects are the keys of the {@link #config-responsive} config object. For example:\n *\n * ```javascript\n *  class ResponsiveButton extends Button.mixin(Responsive) {\n *      static configurable = {\n *          responsive : {\n *              small : {\n *                  // this is a ResponsiveState object named \"small\"\n *                  text : 'S'\n *              },\n *              medium : {\n *                  text : 'M'\n *              }\n *              large : {\n *                  text : 'L'\n *              }\n *          }\n *      };\n *  }\n * ```\n *\n * When the conditions are right for the button to be in the `'small'` responsive state, the `text` config will be set\n * to `'S'`.\n *\n * Any desired configs can be present in a {@link #typedef-ResponsiveState} object, however, the `when` and `callback`\n * properties have special meaning to this mixin and are reserved.\n *\n * ## Selecting the Responsive State\n *\n * To determine the current responsive state, the `when` property is consulted for each candidate state.\n *\n * If `when` is a number, it is understood to be a width threshold and, if the widget's `width` is equal or less than\n * that value, the score is that value. For example, a value of 400 would produce a score of 400 if the widget's width\n * were less than or equal to 400. If the widget's width is greater than 400, the state would be skipped.\n *\n * If `when` is a function, it is called with two parameters: a readonly reference to the widget and the\n * {@link Core.helper.BrowserHelper} singleton object. The function should return the numeric score if the state is\n * applicable, or `null` or `false` if the state should be skipped.\n *\n * The state that has the minimum score is selected as the responsive state for the widget.\n *\n * Consider the default responsive states and their `when` values:\n *\n * ```javascript\n *  responsive : {\n *      small : {\n *          when : 400\n *      },\n *\n *      medium : {\n *          when : 800\n *      },\n *\n *      large : {\n *          when : () => Infinity\n *      },\n *\n *      '*' : {}\n *  },\n * ```\n *\n * For example, if the width of the widget is 300: the score for the `small` responsive state is 400, the score for\n * the `medium` responsive state is 800, and the score for `large` is infinity. In effect, the `large` state is always\n * a candidate, but will also always lose to other candidate states. In this case, the `small` state has the minimum\n * score and is selected as the responsive state.\n *\n * If the width of the widget is 600: the `small` state would be skipped, while the `medium` and `large` states would\n * produce the same scores resulting in `medium` being the responsive state.\n *\n * The `when` functions have access to any properties of the widget instance in the first argument, but are also passed\n * the {@link Core.helper.BrowserHelper} singleton as a second argument. This can be used as shown in the following,\n * over-simplified example:\n *\n * ```javascript\n *  class ResponsiveWidget extends Widget.mixin(Responsive) {\n *      static configurable = {\n *          responsive : {\n *              small : {\n *                  when : ({ width }, { isMobileSafari }) => isMobileSafari && width <= 600 && 10\n *                  text : 'iPhone'\n *              },\n *              medium : {\n *                  when : ({ width }, { isMobileSafari }) => isMobileSafari && width <= 1024 && 20\n *                  text : 'iPad'\n *              }\n *              large : {\n *                  text : 'Desktop'\n *              }\n *          }\n *      };\n *  }\n * ```\n *\n * It is best to avoid mixing `when` threshold values and `when` functions as the resulting scores can be confusing.\n * @mixin\n */\nexport default Target => class Responsive extends (Target || Base).mixin(Delayable, Fencible) {\n    static $name = 'Responsive';\n    static configurable = {\n        /**\n         * Specifies the various responsive state objects keyed by their name. Each key (except `'*'`, see below) in\n         * this object is a state name (see {@link #config-responsiveState}) and its corresponding value is the\n         * associated {@link #typedef-ResponsiveState} object.\n         *\n         * Some properties of a `ResponsiveState` object are special, for example `when` and `callback`. All other\n         * properties of the state object are config properties to apply when that state is active.\n         *\n         * The `when` property can be a function that computes the score for the state. The state whose `when` function\n         * returns the lowest score is selected and its non-special properties will be assigned to the instance. If\n         * `when` is a number, it will be converted into a scoring function (see below).\n         *\n         * A `when` function accepts two readonly parameters and returns either a numeric score if the state should be\n         * considered, or `false` or `null` if the state should be ignored (i.e., it does match with the current state).\n         *\n         * The first parameter is a readonly proxy for the {@link #config-responsiveTarget widget} whose size and other\n         * properties determine the state's score. The proxy tracks property access to that widget in order to update\n         * the responsive state should any of those properties change.\n         *\n         * The second argument to a `when` function is the {@link Core.helper.BrowserHelper} singleton. This allows\n         * a `when` function to conveniently test platform and browser information.\n         *\n         * The state whose `when` function returns the lowest score is selected as the new\n         * {@link #config-responsiveState} and its config object (minus the `when` function and other special\n         * properties) is applied to the instance.\n         *\n         * If `when` is a number, it is converted to function. The following two snippets produce the same `when`\n         * scoring:\n         *\n         * ```javascript\n         *      small : {\n         *          when : 400,\n         *          ...\n         *      }\n         * ```\n         *\n         * The above converted to:\n         *\n         * ```javascript\n         *      small : {\n         *          when : ({ width }) => width <= 400 && 400,\n         *          ...\n         *      }\n         * ```\n         * Selecting the lowest score as the winner allows for the simple conversion of width threshold to score value,\n         * such that the state with the smallest matching width is selected.\n         *\n         * If the `responsive` config object has an asterisk key (`'*'`), its value is used as the default set of config\n         * properties to apply all other states. This will be the only config properties to apply if no `when` function\n         * returns a score. In this way, this special state object acts as a default state as well as a set of\n         * default values for other states to share. This state object has no `when` function.\n         *\n         * The default for this config is:\n         * ```javascript\n         *  {\n         *      small : {\n         *          when : 400\n         *      },\n         *\n         *      medium : {\n         *          when : 800\n         *      },\n         *\n         *      large : {\n         *          when : () => Infinity\n         *      },\n         *\n         *      '*' : {}\n         *  }\n         * ```\n         *\n         * A derived class (or instance) can use these states by populating other config properties, define\n         * additional states, and/or adjust the `when` properties to use different size thresholds.\n         *\n         * @config {Object}\n         */\n        responsive : {\n            $config : {\n                lazy : 'paint'\n            },\n            value : null\n        },\n        /**\n         * The defaults for the {@link #config-responsive} config. These are separated so that the act of setting the\n         * {@link #config-responsive} config is what triggers additional processing.\n         * @config {Object}\n         * @internal\n         * @default\n         */\n        responsiveDefaults : {\n            small : {\n                when : 400\n            },\n            medium : {\n                when : 800\n            },\n            large : {\n                when : () => Infinity\n            },\n            '*' : {}\n        },\n        /**\n         * Set to `true` to mark this instance as the default {@link #config-responsiveTarget} for descendants that do\n         * not specify an explicit {@link #config-responsiveTarget} of their own.\n         * @config {Boolean}\n         * @default false\n         */\n        responsiveRoot : null,\n        /**\n         * The name of the active state of the {@link #config-responsive} config. This is assigned internally\n         * and should not be assigned directly.\n         *\n         * @config {String}\n         * @readonly\n         */\n        responsiveState : null,\n        /**\n         * The widget whose size and other properties drive this object's responsive behavior. If this config is not\n         * specified, the closest ancestor that specified {@link #config-responsiveRoot responsiveRoot=true} will be\n         * used. If there is no such ancestor, then the instance using this mixin is used.\n         *\n         * If this value is set to `'@'`, then this instance is used even if there is a {@link #config-responsiveRoot}\n         * ancestor.\n         *\n         * If this config is a string that starts with `'@'`, the text following the first character is the name of the\n         * property on this instance that holds the target to use. For example, `'@owner'` to use the value of the\n         * `owner` property as the responsive target.\n         *\n         * If this config is a string that does not start with `'@'`, that string is passed to\n         * {@link Core.widget.Widget#function-up} to find the closest matching ancestor.\n         *\n         * If another widget is used as the `responsiveTarget` and if this instance does not specify any explicit `when`\n         * properties in its {@link #config-responsive} config, then the `when` definitions of the `responsiveTarget`\n         * will be used for this instance.\n         * @config {String|Core.widget.Widget}\n         */\n        responsiveTarget : {\n            value   : null,\n            $config : {\n                lazy : 'paint'\n            }\n        },\n        responsiveWidget : {\n            value   : null,\n            $config : {\n                nullify : true\n            }\n        },\n        /**\n         * Defines responsive breakpoints, based on max-width or max-height.\n         *\n         * When the widget is resized, the defined breakpoints are queried to find the closest larger or equal\n         * breakpoint for both width and height. If the found breakpoint differs from the currently applied, it is\n         * applied.\n         *\n         * Applying a breakpoint triggers an event that applications can catch to react to the change. It also\n         * optionally applies a set of configs and calls a configured callback.\n         *\n         * ```javascript\n         * breakpoints : {\n         *     width : {\n         *         50 : { name : 'small', configs : { text : 'Small', ... } }\n         *         100 : { name : 'medium', configs : { text : 'Medium', ... } },\n         *         '*' : { name : 'large', configs : { text : 'Large', ... } }\n         *     }\n         * }\n         * ```\n         *\n         * @config {Object}\n         * @param {Object} width Max-width breakpoints, with keys as numerical widths (or '*' for larger widths than the\n         * largest defined one) and the value as a {@link #typedef-Breakpoint breakpoint definition}\n         * @param {Object} height Max-height breakpoints, with keys as numerical heights (or '*' for larger widths than\n         * the largest defined one) and the value as a {@link #typedef-Breakpoint breakpoint definition}\n         * @deprecated 5.0 Use {@link #config-responsive} instead.\n         */\n        breakpoints : null\n    };\n    static delayable = {\n        responsiveUpdate : 'raf'\n    };\n    static fenced = {\n        syncResponsiveWidget : true\n    };\n    static prototypeProperties = {\n        responsiveStateChanges : 0,\n        responsiveUpdateCount  : 0\n    };\n    get isResponsivePending() {\n        return this.responsiveUpdateCount === 0 && this.hasConfig('responsive');\n    }\n    get isResponsiveUpdating() {\n        return this._responsiveUpdating || this.responsiveWidget?._responsiveUpdating;\n    }\n    // responsive\n    updateResponsive(responsive) {\n        const\n            me  = this,\n            cls = me.constructor,\n            { responsiveDefaults } = me,\n            stateNames = Array.from(\n                new Set(ObjectHelper.keys(responsive).concat(ObjectHelper.keys(responsiveDefaults)))).filter(isStateName);\n        let states = null,\n            hasWhen, name, state, when;\n        if (responsive) {\n            states = {\n                '*' : splitMergedConfigs(cls, responsiveDefaults['*'], responsive['*'])\n            };\n            for (name of stateNames) {\n                state = responsive[name];\n                if (state !== null && state !== false) {\n                    // Track whether any state has an explicit \"when\" property\n                    hasWhen = hasWhen || (state && 'when' in state);\n                    states[name] = splitMergedConfigs(cls,\n                        responsiveDefaults['*'], responsiveDefaults[name], responsive['*'], state);\n                    when = states[name].when;\n                    states[name].when = scoring[typeof when]?.(when) || when;  // convert numbers to fns based on width\n                }\n            }\n        }\n        me.$responsiveStates = states;\n        me.$responsiveWhen = hasWhen;\n        me.syncResponsiveWidget();\n    }\n    // responsiveState\n    updateResponsiveState(state, oldState) {\n        const\n            me = this,\n            { $responsiveStates : states } = me,\n            initial = ++me.responsiveStateChanges === 1,\n            classList = me.element?.classList,\n            defaults = states['*'],\n            def = states[state] || defaults,\n            once = initial && (def.once || defaults.once),\n            isStateful = initial && me.isStateful,\n            target = me.responsiveWidget;\n        let config = def.configs,\n            otherConfigs = once?.configs;\n        if (otherConfigs) {\n            // overlay \":once\" configs on normal configs (the mergeConfigs method clones the first parameter before\n            // merging it with other values)\n            config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;\n        }\n        oldState && classList?.remove(`b-responsive-${oldState.toLowerCase()}`);\n        state && classList?.add(`b-responsive-${state.toLowerCase()}`);\n        if (isStateful) {\n            // our responsiveState is munged with the stateId to retrieve state info for this responsiveState (to track\n            // state by small/medium/large/etc). If we don't load the state on each call here we would end up smashing\n            // the values saved in state with those defined by the developer in the responsive config.\n            otherConfigs = me.loadStatefulData();\n            if (otherConfigs) {\n                // if there is stateful data for this responsiveState, it takes priority over our config object\n                config = config ? me.constructor.mergeConfigs(config, otherConfigs) : otherConfigs;\n            }\n            // We don't want responsive changes to configs to trigger state save:\n            me.suspendStateful();\n        }\n        me._responsiveUpdating = true;\n        try {\n            /**\n             * Triggered before a new {@link #config-responsiveState} is applied.\n             * @event beforeResponsiveStateChange\n             * @param {Core.widget.Widget} source The widget whose `responsiveState` is to be changed\n             * @param {String} state The new value for the widget's `responsiveState`\n             * @param {String} oldState The previous value for the widget's `responsiveState`\n             */\n            me.trigger?.('beforeResponsiveStateChange', { state, oldState, target });\n            config && me.setConfig(config);\n            def.callback?.({ source : me, state, oldState, target, initial });\n            once?.callback?.({ source : me, state, oldState, target, initial });\n            /**\n             * Triggered when a new {@link #config-responsiveState} is applied.\n             * @event responsiveStateChange\n             * @param {Core.widget.Widget} source The widget whose `responsiveState` has changed\n             * @param {String} state The new value for the widget's `responsiveState`\n             * @param {String} oldState The previous value for the widget's `responsiveState`\n             */\n            me.trigger?.('responsiveStateChange', { state, oldState, target });\n            // we normally would check for !me.isConstructing or !me.isConfiguring but this event needs to be fired\n            // during that time to allow the app to receive the initial responsive state since it is dynamic (i.e.,\n            // not something the app has configured into the widget)\n        }\n        finally {\n            // Be sure to reset these even if an exception occurs\n            me._responsiveUpdating = false;\n            isStateful && me.resumeStateful();\n        }\n    }\n    // responsiveTarget\n    get responsiveTarget() {\n        return this.responsiveWidget || this._responsiveTarget;\n    }\n    updateResponsiveTarget() {\n        this.syncResponsiveWidget();\n    }\n    // responsiveWidget\n    updateResponsiveWidget(target) {\n        const\n            me = this,\n            // being a delayable raf method effectively auto-bind's our this pointer\n            responsiveUpdate = target && me.responsiveUpdate;\n        me.$responsiveWrapper?.destroy();\n        me.$responsiveWrapper = target && wrapWidget(target, responsiveUpdate);\n        responsiveUpdate?.now();\n    }\n    // Support methods\n    responsiveUpdate() {\n        const\n            me = this,\n            { $responsiveStates : states, $responsiveWrapper : wrapper } = me,\n            responsiveTarget = wrapper?.widget;\n        if (states && wrapper) {\n            let best = null,\n                bestScore = 0,  // 0 doesn't get used (since !best) but data flow warnings arise w/o assignment\n                fromWhen = states,\n                score, state;\n            // If this instance has a responsiveWidget (via responsiveTarget being set to a widget), and that widget\n            // is not this instance, and if this instance did not specify any explicit \"when\" properties in its own\n            // \"responsive\" config, use those of the target\n            if (responsiveTarget && responsiveTarget !== me && !me.$responsiveWhen) {\n                responsiveTarget.getConfig('responsive');  // make sure the config has been evaluated\n                fromWhen = responsiveTarget.$responsiveStates || fromWhen;\n            }\n            wrapper.reset();\n            for (state in states) {\n                if (state !== '*') {\n                    score = fromWhen[state].when(wrapper.object, BrowserHelper);\n                    if (score != null && score !== false && (!best || score < bestScore)) {\n                        best = state;\n                        bestScore = score;\n                    }\n                }\n            }\n            ++me.responsiveUpdateCount; // this unlocks statefulId() getter in State mixin\n            me.responsiveState = best;\n        }\n    }\n    syncResponsiveWidget() {\n        const me = this;\n        let widget = null,\n            responsiveTarget;\n        if (!me.isDestroying && me.responsive) {\n            responsiveTarget = me.responsiveTarget;\n            if (!(widget = responsiveTarget)) {\n                widget = (!me.responsiveRoot && me.up?.(responsiveRootFn)) || me;\n            }\n            else if (typeof responsiveTarget === 'string') {\n                widget = responsiveTarget === '@' ? me : (\n                    responsiveTarget[0] === '@' ? me[responsiveTarget.substring(1)] : me.up(responsiveTarget)\n                );\n                if (!widget) {\n                    throw new Error(`No match for responsiveTarget=\"${responsiveTarget}\"`);\n                }\n            }\n            if (!widget.isWidget) {\n                throw new Error(`${widget.constructor.$$name} is not a widget and cannot be a responsiveTarget`);\n            }\n        }\n        me.responsiveWidget = widget;\n        return widget;\n    }\n    changeBreakpoints(breakpoints) {\n        ObjectHelper.assertObject(breakpoints, 'breakpoints');\n        // Normalize breakpoints\n        if (breakpoints?.width) {\n            Object.keys(breakpoints.width).forEach(key => {\n                breakpoints.width[key].maxWidth = key;\n            });\n        }\n        if (breakpoints?.height) {\n            Object.keys(breakpoints.height).forEach(key => {\n                breakpoints.height[key].maxHeight = key;\n            });\n        }\n        return breakpoints;\n    }\n    updateBreakpoints(breakpoints) {\n        if (breakpoints) {\n            this.monitorResize = true;\n        }\n    }\n    // Get a width/height breakpoint for the supplied dimension\n    getBreakpoint(levels, dimension) {\n        const\n            // Breakpoints as reverse sorted array of numerical widths [NaN for *, 50, 100]\n            ascendingLevels = Object.keys(levels).map(l => parseInt(l)).sort(),\n            // Find first one larger than current width\n            breakpoint     = ascendingLevels.find(bp => dimension <= bp);\n        // Return matched breakpoint or * if available and none matched\n        return levels[breakpoint ?? (levels['*'] && '*')];\n    }\n    // Apply a breakpoints configs, trigger event and call any callback\n    activateBreakpoint(orientation, breakpoint) {\n        const\n            me             = this,\n            prevBreakpoint = me[`current${orientation}Breakpoint`];\n        if (breakpoint !== prevBreakpoint) {\n            me[`current${orientation}Breakpoint`] = breakpoint;\n            me.setConfig(breakpoint.configs);\n            prevBreakpoint && me.element.classList.remove(`b-breakpoint-${prevBreakpoint.name.toLowerCase()}`);\n            me.element.classList.add(`b-breakpoint-${breakpoint.name.toLowerCase()}`);\n            /**\n             * Triggered when a new max-width based breakpoint is applied.\n             * @event responsiveWidthChange\n             * @param {Core.widget.Widget} source The widget\n             * @param {Breakpoint} breakpoint The applied breakpoint\n             * @param {Breakpoint} prevBreakpoint The previously applied breakpoint\n             * @deprecated 5.0 This event is associated with {@link #config-breakpoints} which is deprecated in favor of\n             * {@link #config-responsive}.\n             */\n            /**\n             * Triggered when a new max-height based breakpoint is applied.\n             * @event responsiveHeightChange\n             * @param {Core.widget.Widget} source The widget\n             * @param {Breakpoint} breakpoint The applied breakpoint\n             * @param {Breakpoint} prevBreakpoint The previously applied breakpoint\n             * @deprecated 5.0 This event is associated with {@link #config-breakpoints} which is deprecated in favor of\n             * {@link #config-responsive}.\n             */\n            me.trigger(`responsive${orientation}Change`, { breakpoint, prevBreakpoint });\n            breakpoint.callback?.({ source : me, breakpoint, prevBreakpoint });\n            me.recompose?.();\n        }\n    }\n    // Called on resize to pick and apply a breakpoint, if size changed enough\n    applyResponsiveBreakpoints(width, height) {\n        const\n            me = this,\n            {\n                width  : widths,\n                height : heights\n            }  = me.breakpoints ?? {};\n        if (widths) {\n            const breakpoint = me.getBreakpoint(widths, width);\n            me.activateBreakpoint('Width', breakpoint);\n        }\n        if (heights) {\n            const breakpoint = me.getBreakpoint(heights, height);\n            me.activateBreakpoint('Height', breakpoint);\n        }\n    }\n    onInternalResize(element, width, height, oldWidth, oldHeight) {\n        super.onInternalResize(element, width, height, oldWidth, oldHeight);\n        this.applyResponsiveBreakpoints(width, height);\n    }\n};\n"],
  "mappings": "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",
  "names": ["Featureable_default", "Target", "Base", "cls", "featureable", "_a", "features", "name", "feature", "was", "me", "manager", "DynamicObject", "options", "result", "featureName", "defineProperty", "hasOwn", "ObjectHelper", "fencibleSymbol", "NONE", "distinct", "array", "parseNames", "names", "StringHelper", "fenceMethod", "target", "any", "all", "lock", "implName", "fence", "params", "fences", "isFree", "key", "Fencible_default", "fenced", "statics", "pairs", "methods", "methodName", "__publicField", "FilterField", "TextField", "value", "store", "field", "filterFunction", "filterId", "filterBy", "record", "old", "EMPTY", "isStateName", "pop", "object", "ret", "responsiveRootFn", "widget", "scoring", "threshold", "width", "splitConfigs", "configs", "splitMergedConfigs", "parts", "once", "p", "wrapWidget", "handler", "triggers", "desc", "o", "detacher", "FunctionHelper", "ignore", "resizer", "Responsive_default", "Delayable_default", "responsive", "responsiveDefaults", "stateNames", "states", "hasWhen", "state", "when", "oldState", "_b", "_c", "_d", "_e", "initial", "classList", "defaults", "def", "isStateful", "config", "otherConfigs", "responsiveUpdate", "wrapper", "responsiveTarget", "best", "bestScore", "fromWhen", "score", "BrowserHelper", "breakpoints", "levels", "dimension", "ascendingLevels", "l", "breakpoint", "bp", "orientation", "prevBreakpoint", "height", "widths", "heights", "element", "oldWidth", "oldHeight"]
}
