{
  "version": 3,
  "sources": ["../../../../Scheduler/lib/Scheduler/column/ScaleColumn.js", "../../../../Scheduler/lib/Scheduler/feature/base/ResourceTimeRangesBase.js", "../../../../Scheduler/lib/Scheduler/view/DependencyEditor.js", "../../../../Scheduler/lib/Scheduler/feature/DependencyEdit.js", "../../../../Scheduler/lib/Scheduler/feature/ScheduleContext.js", "../../../../Scheduler/lib/Scheduler/feature/EventCopyPaste.js", "../../../../Scheduler/lib/Scheduler/feature/EventDrag.js", "../../../../Scheduler/lib/Scheduler/feature/EventDragCreate.js", "../../../../Scheduler/lib/Scheduler/feature/EventTooltip.js", "../../../../Scheduler/lib/Scheduler/feature/StickyEvents.js", "../../../../Scheduler/lib/Scheduler/feature/TimeRanges.js", "../../../../Scheduler/lib/Scheduler/view/mixin/DelayedRecordsRendering.js", "../../../../Scheduler/lib/Scheduler/view/TimelineHistogramRendering.js", "../../../../Scheduler/lib/Scheduler/view/TimelineHistogramBase.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineHistogramGrouping.js", "../../../../Scheduler/lib/Scheduler/view/mixin/TimelineHistogramScaleColumn.js", "../../../../Scheduler/lib/Scheduler/view/TimelineHistogram.js"],
  "sourcesContent": ["import Column from '../../Grid/column/Column.js';\nimport ColumnStore from '../../Grid/data/ColumnStore.js';\nimport Scale from '../../Core/widget/graph/Scale.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/column/ScaleColumn\n */\n/**\n * An object representing a point on the scale displayed by {@link Scheduler.column.ScaleColumn}.\n *\n * @typedef {Object} ScalePoint\n * @property {Number} value Point value\n * @property {String} unit Point value unit\n * @property {String} text Point text label\n */\n/**\n * A specialized column showing a graduated scale from a defined array of values\n * and labels. This column is used in the {@link Scheduler.view.TimelineHistogram} and is not editable. Normally\n * you should not need to interact with this class directly.\n *\n * @extends Grid/column/Column\n * @classtype scale\n * @column\n */\nexport default class ScaleColumn extends Column {\n    //region Config\n    static $name = 'ScaleColumn';\n    static type = 'scale';\n    static isScaleColumn = true;\n    static get fields() {\n        return [\n            'scalePoints'\n        ];\n    }\n    static get defaults() {\n        return {\n            text            : '\\xa0',\n            width           : 40,\n            minWidth        : 40,\n            field           : 'scalePoints',\n            cellCls         : 'b-scale-cell',\n            editor          : false,\n            sortable        : false,\n            groupable       : false,\n            filterable      : false,\n            alwaysClearCell : false,\n            scalePoints     : null\n        };\n    }\n    //endregion\n    //region Constructor/Destructor\n    onDestroy() {\n        this.scaleWidget.destroy();\n    }\n    //endregion\n    //region Internal\n    set width(width) {\n        super.width = width;\n        this.scaleWidget.width = width;\n    }\n    get width() {\n        return super.width;\n    }\n    applyValue(useProp, key, value) {\n        // pass value to scaleWidget\n        if (key === 'scalePoints') {\n            this.scaleWidget[key] = value;\n        }\n        return super.applyValue(...arguments);\n    }\n    buildScaleWidget() {\n        const me = this;\n        const scaleWidget = new Scale({\n            owner         : me.grid,\n            appendTo      : me.grid.floatRoot,\n            cls           : 'b-hide-offscreen',\n            align         : 'right',\n            scalePoints   : me.scalePoints,\n            monitorResize : false\n        });\n        Object.defineProperties(scaleWidget, {\n            width : {\n                get() {\n                    return me.width;\n                },\n                set(width) {\n                    this.element.style.width = `${width}px`;\n                    this._width = me.width;\n                }\n            },\n            height : {\n                get() {\n                    return this._height;\n                },\n                set(height) {\n                    this.element.style.height = `${height}px`;\n                    this._height = height;\n                }\n            }\n        });\n        scaleWidget.width = me.width;\n        return scaleWidget;\n    }\n    get scaleWidget() {\n        const me = this;\n        if (!me._scaleWidget) {\n            me._scaleWidget = me.buildScaleWidget();\n        }\n        return me._scaleWidget;\n    }\n    //endregion\n    //region Render\n    renderer({ cellElement, value, scaleWidgetConfig, scaleWidget = this.scaleWidget }) {\n        ObjectHelper.assign(scaleWidget, {\n            scalePoints : value || this.scalePoints,\n            height      : this.grid.rowHeight\n        }, scaleWidgetConfig);\n        scaleWidget.refresh();\n        // Clone the scale widget element since every row is supposed to have\n        // the same scale settings\n        const scaleCloneElement = scaleWidget.element.cloneNode(true);\n        scaleCloneElement.removeAttribute('id');\n        scaleCloneElement.classList.remove('b-hide-offscreen');\n        cellElement.innerHTML = '';\n        cellElement.appendChild(scaleCloneElement);\n    }\n    //endregion\n}\nColumnStore.registerColumnType(ScaleColumn);\nScaleColumn._$name = 'ScaleColumn';", "import InstancePlugin from '../../../Core/mixin/InstancePlugin.js';\nimport AttachToProjectMixin from '../../data/mixin/AttachToProjectMixin.js';\nimport StringHelper from '../../../Core/helper/StringHelper.js';\nimport EventHelper from '../../../Core/helper/EventHelper.js';\n/**\n * @module Scheduler/feature/base/ResourceTimeRangesBase\n */\n/**\n * Abstract base class for ResourceTimeRanges and ResourceNonWorkingTime features.\n * You should not use this class directly.\n *\n * @extends Core/mixin/InstancePlugin\n * @abstract\n */\nexport default class ResourceTimeRangesBase extends InstancePlugin.mixin(AttachToProjectMixin) {\n    //region Config\n    static configurable = {\n        /**\n         * Specify value to use for the tabIndex attribute of range elements\n         * @config {Number}\n         * @category Misc\n         */\n        tabIndex : null,\n        entityName : 'resourceTimeRange'\n    };\n    static get pluginConfig()  {\n        return {\n            chain    : ['getEventsToRender', 'onEventDataGenerated', 'noFeatureElementsInAxis'],\n            override : ['matchScheduleCell', 'resolveResourceRecord']\n        };\n    }\n    // Let Scheduler know if we have ResourceTimeRanges in view or not\n    noFeatureElementsInAxis() {\n        const { timeAxis } = this.client;\n        return !this.needsRefresh && this.store && !this.store.storage.values.some(t => timeAxis.isTimeSpanInAxis(t));\n    }\n    //endregion\n    //region Init\n    doDisable(disable) {\n        if (this.client.isPainted) {\n            this.client.refresh();\n        }\n        super.doDisable(disable);\n    }\n    updateTabIndex() {\n        if (!this.isConfiguring) {\n            this.client.refresh();\n        }\n    }\n    //endregion\n    getEventsToRender(resource, events) {\n        throw new Error('Implement in subclass');\n    }\n    // Called for each event during render, allows manipulation of render data. Adjust any resource time ranges\n    // (chained function from Scheduler)\n    onEventDataGenerated(renderData) {\n        const\n            me                       = this,\n            { client }               = me,\n            { eventRecord, iconCls } = renderData;\n        if (me.shouldInclude(eventRecord)) {\n            if (client.isVertical) {\n                renderData.width = renderData.resourceRecord.columnWidth || client.resourceColumnWidth;\n            }\n            else {\n                renderData.top = 0;\n            }\n            // Flag that we should fill entire row/col\n            renderData.fillSize = true;\n            // Add our own cls\n            renderData.wrapperCls['b-sch-resourcetimerange'] = 1;\n            if (me.rangeCls) {\n                renderData.wrapperCls[me.rangeCls] = 1;\n            }\n            renderData.wrapperCls[`b-sch-color-${eventRecord.timeRangeColor}`] = eventRecord.timeRangeColor;\n            me.renderContent(eventRecord, renderData);\n            renderData.children.push(renderData.eventContent);\n            // Allow configuring tabIndex\n            renderData.tabIndex = me.tabIndex != null ? String(me.tabIndex) : null;\n            // Add icon\n            if (iconCls?.length > 0) {\n                renderData.children.unshift({\n                    tag       : 'i',\n                    className : iconCls.toString()\n                });\n            }\n            // Event data for DOMSync comparison\n            renderData.eventId = me.generateElementId(eventRecord);\n        }\n    }\n    renderContent(eventRecord, renderData) {\n        renderData.eventContent.text = eventRecord.name;\n    }\n    /**\n     * Generates ID from the passed time range record\n     * @param {Scheduler.model.TimeSpan} record\n     * @returns {String} Generated ID for the DOM element\n     * @internal\n     */\n    generateElementId(record) {\n        return record.domId;\n    }\n    resolveResourceTimeRangeRecord(rangeElement) {\n        return rangeElement?.closest(`.${this.rangeCls}`)?.elementData.eventRecord;\n    }\n    getElementFromResourceTimeRangeRecord(record) {\n        // return this.client.foregroundCanvas.querySelector(`[data-event-id=\"${record.domId}\"]`);\n        return this.client.foregroundCanvas.syncIdMap[record.domId];\n    }\n    resolveResourceRecord(event) {\n        const record = this.overridden.resolveResourceRecord(...arguments);\n        return record || this.resolveResourceTimeRangeRecord(event.target || event)?.resource;\n    }\n    shouldInclude(eventRecord) {\n        throw new Error('Implement in subclass');\n    }\n    // Called when a ResourceTimeRangeModel is manipulated, relays to Scheduler#onInternalEventStoreChange which updates to UI\n    onStoreChange(event) {\n        // Edge case for scheduler not using any events, it has to refresh anyway to get rid of ResourceTimeRanges\n        if (event.action === 'removeall' || event.action === 'dataset') {\n            this.needsRefresh = true;\n        }\n        this.client.onInternalEventStoreChange(event);\n        this.needsRefresh = false;\n    }\n    // Override to let scheduler find the time cell from a resource time range element\n    matchScheduleCell(target) {\n        let cell = this.overridden.matchScheduleCell(target);\n        if (!cell && this.enableMouseEvents) {\n            const\n                { client }   = this,\n                rangeElement = target.closest(`.${this.rangeCls}`);\n            cell = rangeElement && client.getCell({\n                record : client.isHorizontal ? rangeElement.elementData.resource : client.store.first,\n                column : client.timeAxisColumn\n            });\n        }\n        return cell;\n    }\n    handleRangeMouseEvent(domEvent) {\n        const\n            me           = this,\n            rangeElement = domEvent.target.closest(`.${me.rangeCls}`);\n        if (rangeElement) {\n            const\n                eventName               = EventHelper.eventNameMap[domEvent.type] ?? StringHelper.capitalize(domEvent.type),\n                resourceTimeRangeRecord = me.resolveResourceTimeRangeRecord(rangeElement);\n            me.client.trigger(me.entityName + eventName, {\n                feature                    : me,\n                [`${me.entityName}Record`] : resourceTimeRangeRecord,\n                resourceRecord             : me.client.resourceStore.getById(resourceTimeRangeRecord.resourceId),\n                domEvent\n            });\n        }\n    }\n    updateEnableMouseEvents(enable) {\n        const\n            me         = this,\n            { client } = me;\n        me.mouseEventsDetacher?.();\n        me.mouseEventsDetacher = null;\n        if (enable) {\n            function attachMouseEvents() {\n                me.mouseEventsDetacher = EventHelper.on({\n                    element     : client.foregroundCanvas,\n                    delegate    : `.${me.rangeCls}`,\n                    mousedown   : 'handleRangeMouseEvent',\n                    mouseup     : 'handleRangeMouseEvent',\n                    click       : 'handleRangeMouseEvent',\n                    dblclick    : 'handleRangeMouseEvent',\n                    contextmenu : 'handleRangeMouseEvent',\n                    mouseover   : 'handleRangeMouseEvent',\n                    mouseout    : 'handleRangeMouseEvent',\n                    thisObj     : me\n                });\n            }\n            client.whenVisible(attachMouseEvents);\n        }\n        client.element.classList.toggle('b-interactive-resourcetimeranges', Boolean(enable));\n    }\n}\n// No feature based styling needed, do not add a cls to Scheduler\nResourceTimeRangesBase.featureClass = '';\nResourceTimeRangesBase._$name = 'ResourceTimeRangesBase';", "import Popup from '../../Core/widget/Popup.js';\n/**\n * @module Scheduler/view/DependencyEditor\n */\n/**\n * A dependency editor popup.\n *\n * @extends Core/widget/Popup\n * @private\n */\nexport default class DependencyEditor extends Popup {\n    static get $name() {\n        return 'DependencyEditor';\n    }\n    static get defaultConfig() {\n        return {\n            items     : [],\n            draggable : {\n                handleSelector : ':not(button,.b-field-inner)' // blacklist buttons and field inners\n            },\n            axisLock : 'flexible'\n        };\n    }\n    processWidgetConfig(widget) {\n        const { dependencyEditFeature } = this;\n        if (widget.ref === 'lagField' && !dependencyEditFeature.showLagField) {\n            return false;\n        }\n        if (widget.ref === 'deleteButton' && !dependencyEditFeature.showDeleteButton) {\n            return false;\n        }\n        return super.processWidgetConfig(widget);\n    }\n    afterShow(...args) {\n        const { deleteButton } = this.widgetMap;\n        // Only show delete button if the dependency record belongs to a store\n        if (deleteButton) {\n            deleteButton.hidden = !this.record.isPartOfStore();\n        }\n        super.afterShow(...args);\n    }\n    onInternalKeyDown(event) {\n        this.trigger('keyDown', { event });\n        super.onInternalKeyDown(event);\n    }\n}\nDependencyEditor._$name = 'DependencyEditor';", "import GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport '../../Core/widget/DisplayField.js';\nimport '../../Core/widget/DurationField.js';\nimport DependencyEditor from '../view/DependencyEditor.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport DependencyModel from '../model/DependencyModel.js';\nimport Duration from '../../Core/data/Duration.js';\n/**\n * @module Scheduler/feature/DependencyEdit\n */\n/**\n * Feature that displays a popup containing fields for editing a dependency. Requires the\n * {@link Scheduler.feature.Dependencies} feature to be enabled. Double click a line in the demo below to show the\n * editor.\n *\n * {@inlineexample Scheduler/feature/Dependencies.js}\n *\n * ## Customizing the built-in widgets\n *\n * ```javascript\n *  const scheduler = new Scheduler({\n *      columns : [\n *          { field : 'name', text : 'Name', width : 100 }\n *      ],\n *      features : {\n *          dependencies   : true,\n *          dependencyEdit : {\n *              editorConfig : {\n *                  items : {\n *                      // Custom label for the type field\n *                      typeField : {\n *                          label : 'Kind'\n *                      }\n *                  },\n *\n *                  bbar : {\n *                      items : {\n *                          // Hiding save button\n *                          saveButton : {\n *                              hidden : true\n *                          }\n *                      }\n *                  }\n *              }\n *          }\n *      }\n *  });\n * ```\n *\n * ## Built-in widgets\n *\n * | Widget ref             | Type                              | Weight | Description               |\n * |------------------------|-----------------------------------|--------|---------------------------|\n * | `fromNameField`        | {@link Core.widget.DisplayField}  | 100    | From task name (readonly) |\n * | `toNameField`          | {@link Core.widget.DisplayField}  | 200    | To task name (readonly)   |\n * | `typeField`            | {@link Core.widget.Combo}         | 300    | Edit type                 |\n * | `lagField`             | {@link Core.widget.DurationField} | 400    | Edit lag                  |\n *\n * The built-in buttons are:\n *\n * | Widget ref             | Type                       | Weight | Description                       |\n * |------------------------|----------------------------|--------|-----------------------------------|\n * | `saveButton`           | {@link Core.widget.Button} | 100    | Save button on the bbar           |\n * | `deleteButton`         | {@link Core.widget.Button} | 200    | Delete button on the bbar         |\n * | `cancelButton`         | {@link Core.widget.Button} | 300    | Cancel editing button on the bbar |\n *\n * This feature is **disabled** by default.\n * For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * @extends Core/mixin/InstancePlugin\n * @demo Scheduler/dependencies\n * @classtype dependencyEdit\n * @feature\n */\nexport default class DependencyEdit extends InstancePlugin {\n    //region Config\n    static get $name() {\n        return 'DependencyEdit';\n    }\n    static get configurable() {\n        return {\n            /**\n             * True to hide this editor if a click is detected outside it (defaults to true)\n             * @config {Boolean}\n             * @default\n             * @category Editor\n             */\n            autoClose : true,\n            /**\n             * True to save and close this panel if ENTER is pressed in one of the input fields inside the panel.\n             * @config {Boolean}\n             * @default\n             * @category Editor\n             */\n            saveAndCloseOnEnter : true,\n            /**\n             * True to show a delete button in the form.\n             * @config {Boolean}\n             * @default\n             * @category Editor widgets\n             */\n            showDeleteButton : true,\n            /**\n             * The event that shall trigger showing the editor. Defaults to `dependencydblclick`, set to empty string or\n             * `null` to disable editing of dependencies.\n             * @config {String}\n             * @default\n             * @category Editor\n             */\n            triggerEvent : 'dependencydblclick',\n            /**\n             * True to show the lag field for the dependency\n             * @config {Boolean}\n             * @default\n             * @category Editor widgets\n             */\n            showLagField : false,\n            dependencyRecord : null,\n            /**\n             * Default editor configuration, used to configure the Popup.\n             * @config {PopupConfig}\n             * @category Editor\n             */\n            editorConfig : {\n                title       : 'L{Edit dependency}',\n                localeClass : this,\n                closable    : true,\n                defaults : {\n                    localeClass : this\n                },\n                items : {\n                    /**\n                     * Reference to the from name\n                     * @member {Core.widget.DisplayField} fromNameField\n                     * @readonly\n                     */\n                    fromNameField : {\n                        type   : 'display',\n                        weight : 100,\n                        label  : 'L{From}'\n                    },\n                    /**\n                     * Reference to the to name field\n                     * @member {Core.widget.DisplayField} toNameField\n                     * @readonly\n                     */\n                    toNameField : {\n                        type   : 'display',\n                        weight : 200,\n                        label  : 'L{To}'\n                    },\n                    /**\n                     * Reference to the type field\n                     * @member {Core.widget.Combo} typeField\n                     * @readonly\n                     */\n                    typeField : {\n                        type                  : 'combo',\n                        weight                : 300,\n                        label                 : 'L{Type}',\n                        name                  : 'type',\n                        editable              : false,\n                        valueField            : 'id',\n                        displayField          : 'name',\n                        localizeDisplayFields : true,\n                        buildItems            : function() {\n                            const dialog = this.parent;\n                            return Object.keys(DependencyModel.Type).map(type => ({\n                                id        : DependencyModel.Type[type],\n                                name      : dialog.L(type),\n                                localeKey : type\n                            }));\n                        }\n                    },\n                    /**\n                     * Reference to the lag field\n                     * @member {Core.widget.DurationField} lagField\n                     * @readonly\n                     */\n                    lagField : {\n                        type                    : 'duration',\n                        weight                  : 400,\n                        label                   : 'L{Lag}',\n                        name                    : 'lag',\n                        allowNegative           : true,\n                        highlightExternalChange : false\n                    }\n                },\n                bbar : {\n                    defaults : {\n                        localeClass : this\n                    },\n                    items : {\n                        foo : {\n                            type : 'widget',\n                            cls  : 'b-label-filler'\n                        },\n                        /**\n                         * Reference to the save button, if used\n                         * @member {Core.widget.Button} saveButton\n                         * @readonly\n                         */\n                        saveButton : {\n                            color : 'b-green',\n                            text  : 'L{Save}'\n                        },\n                        /**\n                         * Reference to the delete button, if used\n                         * @member {Core.widget.Button} deleteButton\n                         * @readonly\n                         */\n                        deleteButton : {\n                            color : 'b-gray',\n                            text  : 'L{Delete}'\n                        },\n                        /**\n                         * Reference to the cancel button, if used\n                         * @member {Core.widget.Button} cancelButton\n                         * @readonly\n                         */\n                        cancelButton : {\n                            color : 'b-gray',\n                            text  : 'L{Object.Cancel}'\n                        }\n                    }\n                }\n            }\n        };\n    }\n    //endregion\n    //region Init & destroy\n    construct(client, config) {\n        const me = this;\n        client.dependencyEdit = me;\n        super.construct(client, config);\n        if (!client.features.dependencies) {\n            throw new Error('Dependencies feature required when using DependencyEdit');\n        }\n        me.clientListenersDetacher = client.ion({\n            [me.triggerEvent] : me.onActivateEditor,\n            thisObj           : me\n        });\n    }\n    doDestroy() {\n        this.clientListenersDetacher();\n        this.editor?.destroy();\n        super.doDestroy();\n    }\n    //endregion\n    //region Editing\n    changeEditorConfig(config) {\n        const\n            me                         = this,\n            { autoClose, cls, client } = me;\n        return ObjectHelper.assign({\n            owner        : client,\n            align        : 'b-t',\n            id           : `${client.id}-dependency-editor`, \n            autoShow     : false,\n            anchor       : true,\n            scrollAction : 'realign',\n            constrainTo  : globalThis,\n            autoClose,\n            cls\n        }, config);\n    }\n    //endregion\n    //region Save\n    get isValid() {\n        return Object.values(this.editor.widgetMap).every(field => {\n            if (!field.name || field.hidden) {\n                return true;\n            }\n            return field.isValid !== false;\n        });\n    }\n    get values() {\n        const values = {};\n        this.editor.eachWidget(widget => {\n            if (!widget.name || widget.hidden) return;\n            values[widget.name] = widget.value;\n        }, true);\n        return values;\n    }\n    /**\n     * Template method, intended to be overridden. Called before the dependency record has been updated.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record\n     *\n     **/\n    onBeforeSave(dependencyRecord) {}\n    /**\n     * Template method, intended to be overridden. Called after the dependency record has been updated.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record\n     *\n     **/\n    onAfterSave(dependencyRecord) {}\n    /**\n     * Updates record being edited with values from the editor\n     * @private\n     */\n    updateRecord(dependencyRecord) {\n        const { values } = this;\n        // Engine does not understand { magnitude, unit } syntax\n        if (values.lag) {\n            values.lagUnit = values.lag.unit;\n            values.lag = values.lag.magnitude;\n        }\n        // Type replaces fromSide/toSide, if they are used\n        if ('type' in values) {\n            dependencyRecord.fromSide != null && (values.fromSide = null);\n            dependencyRecord.toSide != null && (values.toSide = null);\n        }\n        // Chronograph doesn't filter out undefined fields, it nullifies them instead\n        // https://github.com/bryntum/chronograph/issues/11\n        ObjectHelper.cleanupProperties(values, true);\n        dependencyRecord.set(values);\n    }\n    //endregion\n    //region Events\n    onPopupKeyDown({ event }) {\n        if (event.key === 'Enter' && this.saveAndCloseOnEnter && event.target.tagName.toLowerCase() === 'input') {\n            // Need to prevent this key events from being fired on whatever receives focus after the editor is hidden\n            event.preventDefault();\n            this.onSaveClick();\n        }\n    }\n    onSaveClick() {\n        if (this.save()) {\n            this.afterSave();\n            this.editor.hide();\n        }\n    }\n    async onDeleteClick() {\n        if (await this.deleteDependency()) {\n            this.afterDelete();\n        }\n        this.editor.hide();\n    }\n    onCancelClick() {\n        this.afterCancel();\n        this.editor.hide();\n    }\n    afterSave() {}\n    afterDelete() {}\n    afterCancel() {}\n    //region Editing\n    // Called from editDependency() to actually show the editor\n    internalShowEditor(dependencyRecord) {\n        const\n            me         = this,\n            { client } = me,\n            editor     = me.getEditor(dependencyRecord);\n        me.loadRecord(dependencyRecord);\n        /**\n         * Fires on the owning Scheduler or Gantt widget when the editor for a dependency is available but before it is shown. Allows\n         * manipulating fields before the widget is shown.\n         * @event beforeDependencyEditShow\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler\n         * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.\n         * @param {Core.widget.Popup} editor The editor popup\n         */\n        client.trigger('beforeDependencyEditShow', {\n            dependencyEdit : me,\n            dependencyRecord,\n            editor\n        });\n        let showPoint = me.lastPointerDownCoordinate;\n        if (!showPoint) {\n            const center = Rectangle.from(client.element).center;\n            showPoint = [center.x - editor.width / 2, center.y - editor.height / 2];\n        }\n        const\n            result   = editor.showBy(showPoint),\n            labelled = [];\n        // All of this measuring code can be removed when we transition to grid layout\n        let labelWidth = 0;\n        // Measure labels\n        editor.eachWidget(widget => {\n            const { labelElement, element } = widget;\n            if (labelElement) {\n                // Has top labels? Don't measure them (material)\n                if (labelElement.getBoundingClientRect().top < element.getBoundingClientRect().top) {\n                    return false;\n                }\n                widget.labelWidth = null;\n                labelWidth = Math.max(labelWidth, labelElement.offsetWidth);\n                labelled.push(widget);\n            }\n        });\n        // Match longest\n        labelled.forEach(widget => widget.labelWidth = labelWidth);\n        return result;\n    }\n    /**\n     * Opens a popup to edit the passed dependency.\n     * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency to edit\n     * @return {Promise} A Promise that yields `true` after the editor is shown\n     * or `false` if some application logic vetoed the editing (see `beforeDependencyEdit` in the docs).\n     */\n    async editDependency(dependencyRecord) {\n        const\n            me         = this,\n            { client } = me;\n        if (client.readOnly || dependencyRecord.readOnly ||\n            /**\n             * Fires on the owning Scheduler or Gantt widget before an dependency is displayed in the editor.\n             * This may be listened for to allow an application to take over dependency editing duties. Return `false` to\n             * stop the default editing UI from being shown or a `Promise` yielding `true` or `false` for async vetoing.\n             * @event beforeDependencyEdit\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler\n             * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependencyEdit feature\n             * @param {Scheduler.model.DependencyModel} dependencyRecord The record about to be shown in the editor.\n             * @preventable\n             * @async\n             */\n            await client.trigger('beforeDependencyEdit', { dependencyEdit : me, dependencyRecord }) === false\n        ) {\n            return false;\n        }\n        // wait till the editor is shown\n        await this.internalShowEditor(dependencyRecord);\n        return true;\n    }\n    //endregion\n    //region Save\n    /**\n     * Gets an editor instance. Creates on first call, reuses on consecutive\n     * @internal\n     * @returns {Scheduler.view.DependencyEditor} Editor popup\n     */\n    getEditor() {\n        const me = this;\n        let { editor } = me;\n        if (editor) {\n            return editor;\n        }\n        editor = me.editor = DependencyEditor.new({\n            dependencyEditFeature : me,\n            autoShow              : false,\n            anchor                : true,\n            scrollAction          : 'realign',\n            constrainTo           : globalThis,\n            autoClose             : me.autoClose,\n            cls                   : me.cls,\n            rootElement           : me.client.rootElement,\n            internalListeners     : {\n                keydown : me.onPopupKeyDown,\n                thisObj : me\n            }\n        }, me.editorConfig);\n        if (editor.items.length === 0) {\n            console.warn('Editor configured without any `items`');\n        }\n        // assign widget refs\n        editor.eachWidget(widget => {\n            const ref = widget.ref || widget.id;\n            // don't overwrite if already defined\n            if (ref && !me[ref]) {\n                me[ref] = widget;\n            }\n        });\n        me.saveButton?.ion({ click : 'onSaveClick', thisObj : me });\n        me.deleteButton?.ion({ click : 'onDeleteClick', thisObj : me });\n        me.cancelButton?.ion({ click : 'onCancelClick', thisObj : me });\n        return me.editor;\n    }\n    //endregion\n    //region Delete\n    /**\n     * Sets fields values from record being edited\n     * @private\n     */\n    loadRecord(dependency) {\n        const me = this;\n        me.fromNameField.value = dependency.fromEvent.name;\n        me.toNameField.value = dependency.toEvent.name;\n        if (me.lagField) {\n            me.lagField.value = new Duration(dependency.lag, dependency.lagUnit);\n        }\n        me.editor.record = me.dependencyRecord = dependency;\n    }\n    //endregion\n    //region Stores\n    /**\n     * Saves the changes (applies them to record if valid, if invalid editor stays open)\n     * @private\n     * @fires beforeDependencySave\n     * @fires beforeDependencyAdd\n     * @fires afterDependencySave\n     * @returns {*}\n     */\n    async save() {\n        const\n            me                           = this,\n            { client, dependencyRecord } = me;\n        if (!dependencyRecord || !me.isValid) {\n            return;\n        }\n        const { dependencyStore, values } = me;\n        /**\n         * Fires on the owning Scheduler or Gantt widget before a dependency is saved\n         * @event beforeDependencySave\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler instance\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved\n         * @param {Object} values The new values\n         * @preventable\n         */\n        if (client.trigger('beforeDependencySave', {\n            dependencyRecord,\n            values\n        }) !== false) {\n            me.onBeforeSave(dependencyRecord);\n            me.updateRecord(dependencyRecord);\n            // Check if this is a new record\n            if (dependencyStore && !dependencyRecord.stores.length) {\n                /**\n                 * Fires on the owning Scheduler or Gantt widget before a dependency is added\n                 * @event beforeDependencyAdd\n                 * @on-owner\n                 * @param {Scheduler.view.Scheduler} source The scheduler\n                 * @param {Scheduler.feature.DependencyEdit} dependencyEdit The dependency edit feature\n                 * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be added\n                 * @preventable\n                 */\n                if (client.trigger('beforeDependencyAdd', { dependencyRecord, dependencyEdit : me }) === false) {\n                    return;\n                }\n                dependencyStore.add(dependencyRecord);\n            }\n            await client.project?.commitAsync();\n            /**\n             * Fires on the owning Scheduler or Gantt widget after a dependency is successfully saved\n             * @event afterDependencySave\n             * @on-owner\n             * @param {Scheduler.view.Scheduler} source The scheduler instance\n             * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency about to be saved\n             */\n            client.trigger('afterDependencySave', { dependencyRecord });\n            me.onAfterSave(dependencyRecord);\n        }\n        return dependencyRecord;\n    }\n    /**\n     * Delete dependency being edited\n     * @private\n     * @fires beforeDependencyDelete\n     */\n    async deleteDependency() {\n        const { client, editor, dependencyRecord } = this;\n        /**\n         * Fires on the owning Scheduler or Gantt widget before a dependency is deleted\n         * @event beforeDependencyDelete\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source The scheduler instance\n         * @param {Scheduler.model.DependencyModel} dependencyRecord The dependency record about to be deleted\n         * @preventable\n         */\n        if (client.trigger('beforeDependencyDelete', { dependencyRecord }) !== false) {\n            if (editor.containsFocus) {\n                editor.revertFocus();\n            }\n            client.dependencyStore.remove(dependencyRecord);\n            await client.project?.commitAsync();\n            return true;\n        }\n        return false;\n    }\n    get dependencyStore() {\n        return this.client.dependencyStore;\n    }\n    //endregion\n    //region Events\n    onActivateEditor({ dependency, event }) {\n        if (!this.disabled) {\n            this.lastPointerDownCoordinate = [event.clientX, event.clientY];\n            this.editDependency(dependency);\n        }\n    }\n    //endregion\n}\nDependencyEdit._$name = 'DependencyEdit'; GridFeatureManager.registerFeature(DependencyEdit, false);\n", "import DomHelper from '../../Core/helper/DomHelper.js';\nimport InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport Delayable from '../../Core/mixin/Delayable.js';\n/**\n * @module Scheduler/feature/ScheduleContext\n */\n/**\n * Allow visually selecting a schedule \"cell\" by clicking, or {@link #config-triggerEvent any other pointer gesture}.\n *\n * This feature is **disabled** by default\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         // Configure as a truthy value to enable the feature\n *         scheduleContext : {\n *             triggerEvent : 'hover',\n *             renderer     : (context, element) => {\n *                 element.innerText = '\uD83D\uDE0E';\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * The contextual details are available in the {@link #property-context} property.\n *\n * **Note that the context is cleared upon change of {@link Scheduler.view.Scheduler#property-viewPreset}\n * such as when zooming in or out.**\n *\n * {@inlineexample Scheduler/feature/ScheduleContext.js}\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype scheduleContext\n * @feature\n */\nexport default class ScheduleContext extends InstancePlugin.mixin(Delayable) {\n    static get $name() {\n        return 'ScheduleContext';\n    }\n    static delayable = {\n        syncContextElement : 'raf'\n    };\n    static configurable = {\n        /**\n         * The pointer event type to use to update the context. May be `'hover'` to highlight the\n         * tick context when moving the mouse across the timeline.\n         * @config {'click'|'hover'|'contextmenu'|'mousedown'}\n         * @default\n         */\n        triggerEvent : 'click',\n        /**\n         * A function (or the name of a function) which may mutate the contents of the context overlay\n         * element which tracks the active resource/tick context.\n         *\n         * @config {String|Function}\n         * @param {TimelineContext} context The context being highlighted.\n         * @param {HTMLElement} element The context highlight element. This will be empty each time.\n         * @returns {void}\n         */\n        renderer : null,\n        /**\n         * The active context.\n         * @member {TimelineContext} timelineContext\n         * @readonly\n         */\n        context : {\n            $config : {\n                // Reject non-changes so that when using mousemove, we only update the context\n                // when it changes.\n                equal(c1, c2) {\n                    return c1?.index === c2?.index &&\n                        c1?.tickParentIndex === c2?.tickParentIndex &&\n                        !((c1?.tickStartDate || 0) - (c2?.tickStartDate || 0));\n                }\n            }\n        }\n    };\n    /**\n     * The contextual information about which cell was clicked on and highlighted.\n     *\n     * When the {@link Scheduler.view.Scheduler#property-viewPreset} is changed (such as when zooming)\n     * the context is cleared and the highlight is removed.\n     *\n     * @member {Object} context\n     * @property {Scheduler.view.TimelineBase} context.source The owning Scheduler\n     * @property {Date} context.date Date at mouse position\n     * @property {Scheduler.model.TimeSpan} context.tick A record which encapsulates the time axis tick clicked on.\n     * @property {Number} context.tickIndex The index of the time axis tick clicked on.\n     * @property {Date} context.tickStartDate The start date of the current time axis tick\n     * @property {Date} context.tickEndDate The end date of the current time axis tick\n     * @property {Grid.row.Row} context.row Clicked row (in horizontal mode only)\n     * @property {Number} context.index Index of clicked resource\n     * @property {Scheduler.model.ResourceModel} context.resourceRecord Resource record\n     * @property {MouseEvent} context.event Browser event\n     */\n    construct(client, config) {\n        super.construct(client, config);\n        const\n            { triggerEvent } = this,\n            listeners        = {\n                datachange              : 'syncContextElement',\n                timeaxisviewmodelupdate : 'onTimeAxisViewModelUpdate',\n                presetchange            : 'clearContext',\n                thisObj                 : this\n            };\n        // If mousemove is our trigger, we cab use the client's timelineContextChange event\n        if (triggerEvent === 'mouseover') {\n            listeners.timelineContextChange = 'onTimelineContextChange';\n        }\n        // Otherwise, we have to listen for the required events on Schedule and events\n        else {\n            // Context menu will be expected to update the context if click or mousedown\n            // is the triggerEvent. Context menu is a mousedown gesture.\n            if (triggerEvent === 'click' || triggerEvent === 'mousedown') {\n                listeners.schedulecontextmenu = 'onScheduleContextGesture';\n            }\n            Object.assign(listeners, {\n                [`schedule${triggerEvent}`] : 'onScheduleContextGesture',\n                [`event${triggerEvent}`]    : 'onScheduleContextGesture',\n                ...listeners\n            });\n        }\n        client.ion(listeners);\n        client.rowManager.ion({\n            rowheight : 'syncContextElement',\n            thisObj   : this\n        });\n    }\n    changeTriggerEvent(triggerEvent) {\n        // Both these things should route through to using the client's timelineContextChange event\n        if (triggerEvent === 'hover' || triggerEvent === 'mousemove') {\n            triggerEvent = 'mouseover';\n        }\n        return triggerEvent;\n    }\n    get element() {\n        return this._element || (this._element = DomHelper.createElement({\n            parent    : this.client.timeAxisSubGridElement,\n            className : 'b-schedule-selected-tick'\n        }));\n    }\n    // Handle the Client's own timelineContextChange event which it maintains on mousemove\n    onTimelineContextChange({ context }) {\n        this.context = context;\n    }\n    // Handle the scheduleclick or eventclick Scheduler events if we re not using mouseover\n    onScheduleContextGesture(context) {\n        this.context = context;\n    }\n    onTimeAxisViewModelUpdate({ source : timeAxisViewModel }) {\n        // Just a mutation of existing tick details, sync the element\n        if (timeAxisViewModel.timeAxis.includes(this.context?.tick)) {\n            this.syncContextElement();\n        }\n        // The tick has gone, we have moved to a new ViewPreset, so clear the context.\n        else {\n            this.clearContext();\n        }\n    }\n    clearContext() {\n        this.context = null;\n    }\n    updateContext(context, oldContext) {\n        this.syncContextElement();\n    }\n    syncContextElement() {\n        if (this.context && this.enabled) {\n            const\n                me  = this,\n                {\n                    client,\n                    element,\n                    context,\n                    renderer\n                }   = me,\n                {\n                    isVertical\n                }   = client,\n                {\n                    style\n                }   = element,\n                row = isVertical ? client.rowManager.rows[0] : client.getRowFor(context.resourceRecord);\n            if (row) {\n                const\n                    {\n                        tickStartDate,\n                        tickEndDate,\n                        resourceRecord\n                    } = context,\n                    // get the position clicked based on dates\n                    renderData = client.currentOrientation.getTimeSpanRenderData({\n                        startDate   : tickStartDate,\n                        endDate     : tickEndDate,\n                        startDateMS : tickStartDate.getTime(),\n                        endDateMS   : tickEndDate.getTime()\n                    }, resourceRecord);\n                let top, width, height;\n                if (isVertical) {\n                    top = renderData.top;\n                    width = renderData.resourceWidth;\n                    height = renderData.height;\n                }\n                else {\n                    top = row.top;\n                    width = renderData.width;\n                    height = row.height;\n                }\n                // Move to current cell\n                style.display = '';\n                style.width = `${width}px`;\n                style.height = `${height}px`;\n                DomHelper.setTranslateXY(element, renderData.left, top);\n                // In case we updated on a datachange action : 'remove' or 'add' event.\n                context.index = row.index;\n                // Undo any contents added by the renderer last time round.\n                element.innerHTML = '';\n                // Show the context and the element to the renderer\n                renderer && me.callback(renderer, me, [context, element]);\n            }\n            // No row for resource might mean it's scrolled out of view or filtered out\n            // so just hide so that the next valid sync can restore it to visibility\n            else {\n                style.display = 'none';\n            }\n        }\n        else {\n            this.element.style.display = 'none';\n        }\n    }\n}\nScheduleContext.featureClass = 'b-scheduler-context';\nScheduleContext._$name = 'ScheduleContext'; GridFeatureManager.registerFeature(ScheduleContext, false, ['Scheduler']);\n", "import AttachToProjectMixin from '../../Scheduler/data/mixin/AttachToProjectMixin.js';\nimport CopyPasteBase from '../../Grid/feature/base/CopyPasteBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport './ScheduleContext.js';\nconst actions = {\n    cut   : 1,\n    copy  : 1,\n    paste : 1\n};\n/**\n * @module Scheduler/feature/EventCopyPaste\n */\n/**\n * Allow using [Ctrl/CMD + C/X] and [Ctrl/CMD + V] to copy/cut and paste events.\n *\n * This feature also adds entries to the {@link Scheduler/feature/EventMenu} for copying & cutting (see example below\n * for how to configure) and to the {@link Scheduler/feature/ScheduleMenu} for pasting.\n *\n * You can configure how a newly pasted record is named using {@link #function-generateNewName}.\n *\n * {@inlineexample Scheduler/feature/EventCopyPaste.js}\n *\n * If you want to highlight the paste location when clicking in the schedule, consider enabling the\n * {@link Scheduler/feature/ScheduleContext} feature.\n *\n * <div class=\"note\">When used with Scheduler Pro, pasting will bypass any constraint set on the event to allow the\n * copy to be assigned the targeted date.</div>\n *\n * This feature is **enabled** by default.\n *\n * ## Customize menu items\n *\n * See {@link Scheduler/feature/EventMenu} and {@link Scheduler/feature/ScheduleMenu} for more info on customizing the\n * menu items supplied by the feature. This snippet illustrates the concept:\n *\n * ```javascript\n * // Custom copy text + remove cut option from event menu:\n * const scheduler = new Scheduler({\n *     features : {\n *         eventMenu : {\n *             items : {\n *                 copyEvent : {\n *                     text : 'Copy booking'\n *                 },\n *                 cutEvent  : false\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * ## Keyboard shortcuts\n *\n * The feature has the following default keyboard shortcuts:\n *\n * | Keys       | Action   | Action description                                |\n * |------------|----------|---------------------------------------------------|\n * | `Ctrl`+`C` | *copy*   | Copies selected event(s) into the clipboard.      |\n * | `Ctrl`+`X` | *cut*    | Cuts out selected event(s) into the clipboard.    |\n * | `Ctrl`+`V` | *paste*  | Insert copied or cut event(s) from the clipboard. |\n *\n * <div class=\"note\">Please note that <code>Ctrl</code> is the equivalent to <code>Command</code> and <code>Alt</code>\n * is the equivalent to <code>Option</code> for Mac users</div>\n *\n * For more information on how to customize keyboard shortcuts, please see\n * [our guide](#Scheduler/guides/customization/keymap.md).\n *\n * ## Multi assigned events\n *\n * In a Scheduler that uses single assignment, copying and then pasting creates a clone of the event and assigns it\n * to the target resource. Cutting and pasting moves the original event to the target resource.\n *\n * In a Scheduler using multi assignment, the behaviour is slightly more complex. Cutting and pasting reassigns the\n * event to the target, keeping other assignments of the same event intact. The behaviour for copying and pasting is\n * configurable using the {@link #config-copyPasteAction} config. It accepts two values:\n *\n * * `'clone'` - The default, the event is cloned and the clone is assigned to the target resource. Very similar to the\n *   behaviour with single assignment (event count goes up by 1).\n * * `'assign'` - The original event is assigned to the target resource (event count is unaffected).\n *\n * This snippet shows how to reconfigure it:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     features : {\n *         eventCopyPaste : {\n *             copyPasteAction : 'assign'\n *         }\n *     }\n * });\n * ```\n *\n * <div class=\"note\">Copying multiple assignments of the same event will always result in all but the first assignment\n * being removed on paste, since paste targets a single resource and an event can only be assigned to a resource once.\n * </div>\n *\n * ## Native/shared clipboard\n *\n * If you have multiple Schedulers (or other Bryntum products) on the same page, they will share clipboard. This makes\n * it possible to copy and paste between different Scheduler instances. It is also possible to use the native Clipboard\n * API if it is available and if you set {@link #config-useNativeClipboard} to `true`.\n *\n * Regardless of native clipboard availability, copy-pasting \"outside\" of the current Scheduler instance will convert\n * the copied events to a string. When pasting, the string will then be parsed back into events. In case of usage of the\n * native Clipboard API, this means it is possible to copy and paste events between completely different applications.\n *\n * To configure the fields that is converted and parsed from the copied string value, please see the\n * {@link #config-eventToStringFields} config.\n *\n * @extends Grid/feature/base/CopyPasteBase\n * @classtype eventCopyPaste\n * @feature\n */\nexport default class EventCopyPaste extends CopyPasteBase.mixin(AttachToProjectMixin) {\n    static $name = 'EventCopyPaste';\n    static pluginConfig = {\n        assign : [\n            'copyEvents',\n            'pasteEvents'\n        ],\n        chain : [\n            'populateEventMenu',\n            'populateScheduleMenu',\n            'onEventDataGenerated'\n        ]\n    };\n    static configurable = {\n        /**\n         * The field to use as the name field when updating the name of copied records\n         * @config {String}\n         * @default\n         */\n        nameField : 'name',\n        /**\n         * How to handle a copy paste operation when the host uses multi assignment. Either:\n         *\n         * - `'clone'`  - The default, clone the copied event, assigning the clone to the target resource.\n         * - `'assign'` - Add an assignment for the existing event to the target resource.\n         *\n         * For single assignment mode, it always uses the `'clone'` behaviour.\n         *\n         * @config {'clone'|'assign'}\n         * @default\n         */\n        copyPasteAction : 'clone',\n        /**\n         * When copying events (or assignments), data will be sent to the clipboard as a tab (`\\t`) and new-line (`\\n`)\n         * separated string with field values for fields present in this config (in specified order). The default\n         * included fields are (in this order):\n         * * name\n         * * startDate\n         * * endDate\n         * * duration\n         * * durationUnit\n         * * allDay\n         * To override, provide your own array of fields:\n         * ```javascript\n         * new Scheduler({\n         *     features : {\n         *         eventCopyPaste : {\n         *             eventToStringFields : [\n         *                'name',\n         *                'startDate',\n         *                'endDate',\n         *                'percentDone'\n         *             ]\n         *         }\n         *     }\n         * });\n         * ```\n         * <div class=\"note\">Please note that this config is both used for **converting** events to a string value and\n         * is also used to **parse** a string value to events.</div>\n         * @config {Array<String>}\n         */\n        eventToStringFields : ['name', 'startDate', 'endDate', 'duration', 'durationUnit', 'allDay']\n    };\n    construct(scheduler, config) {\n        super.construct(scheduler, config);\n        scheduler.ion({\n            eventClick    : 'onEventClick',\n            scheduleClick : 'onScheduleClick',\n            projectChange : () => {\n                this.clearClipboard();\n                this._cellClickedContext = null;\n            },\n            thisObj : this\n        });\n    }\n    // Used in events to separate events from different features from each other\n    entityName = 'event';\n    get scheduler() {\n        return this.client;\n    }\n    attachToEventStore(eventStore) {\n        super.attachToEventStore(eventStore);\n        delete this._eventClickedContext;\n    }\n    onEventDataGenerated(eventData) {\n        const { assignmentRecord } = eventData;\n        // No assignmentRecord for resource time ranges, which we want to ignore anyway\n        if (assignmentRecord) {\n            eventData.cls['b-cut-item'] = assignmentRecord.meta.isCut;\n        }\n    }\n    onEventClick(context) {\n        this._cellClickedContext = null;\n        this._eventClickedContext = context;\n    }\n    onScheduleClick(context) {\n        this._cellClickedContext = context;\n        this._eventClickedContext = null;\n    }\n    isActionAvailable({ event, actionName }) {\n        if (actions[actionName]) {\n            // No action if\n            // 1. there is selected text on the page\n            // 2. cell editing is active\n            // 3. cursor is not in the grid (filter bar etc)\n            // 4. focus is on specialrow\n            return !this.disabled &&\n                globalThis.getSelection().toString().length === 0 &&\n                !this.client.features.cellEdit?.isEditing &&\n                Boolean(event.target.closest('.b-timeaxissubgrid')) &&\n                !this.client.focusedCell?.isSpecialRow;\n        }\n    }\n    async copy() {\n        await this.copyEvents();\n    }\n    async cut() {\n        await this.copyEvents(undefined, true);\n    }\n    async paste() {\n        await this.pasteEvents();\n    }\n    /**\n     * Copy events (when using single assignment mode) or assignments (when using multi assignment mode) to clipboard to\n     * paste later\n     * @fires beforeCopy\n     * @fires copy\n     * @param {Scheduler.model.EventModel[]|Scheduler.model.AssignmentModel[]} [records] Pass records to copy them,\n     * leave out to copying current selection\n     * @param {Boolean} [isCut] Copies by default, pass `true` to cut instead\n     * @category Edit\n     * @on-owner\n     */\n    async copyEvents(records = this.scheduler.selectedAssignments, isCut = false) {\n        const\n            me            = this,\n            { scheduler } = me;\n        // Relay to original if split\n        if (scheduler.splitFrom) {\n            return scheduler.splitFrom.features.eventCopyPaste.copyEvents(records, isCut);\n        }\n        if (!records?.length) {\n            return;\n        }\n        let assignmentRecords = records.slice(); // Slice to not lose records if selection changes\n        if (records[0].isEventModel) {\n            assignmentRecords = records.map(r => r.assignments).flat();\n        }\n        // Prevent cutting readOnly events\n        if (isCut) {\n            assignmentRecords = assignmentRecords.filter(a => !a.event.readOnly);\n        }\n        const eventRecords = assignmentRecords.map(a => a.event);\n        if (!assignmentRecords.length || scheduler.readOnly) {\n            return;\n        }\n        await me.writeToClipboard({ assignmentRecords, eventRecords }, isCut);\n        /**\n         * Fires on the owning Scheduler after a copy action is performed.\n         * @event copy\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords The event records that were copied\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records that were copied\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other copy events\n         */\n        scheduler.trigger('copy', { assignmentRecords, eventRecords, isCut, entityName : me.entityName });\n        // refresh to call onEventDataGenerated and reapply the cls for records where the cut was canceled\n        scheduler.refreshWithTransition();\n        me._focusedEventOnCopy = me._eventClickedContext;\n    }\n    async beforeCopy({ data : { assignmentRecords, eventRecords }, isCut }) {\n        /**\n         * Fires on the owning Scheduler before a copy action is performed, return `false` to prevent the action\n         * @event beforeCopy\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords The event records about to be copied\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignment records about to be copied\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other beforeCopy events\n         */\n        return await this.scheduler.trigger('beforeCopy',\n            { assignmentRecords,  eventRecords, isCut, entityName : this.entityName });\n    }\n    // Called from Clipboardable when cutData changes\n    handleCutData({ source }) {\n        const me = this;\n        if (source !== me && me.cutData?.length) {\n            const { assignmentRecords, eventRecords } = me.cutData[0];\n            if (assignmentRecords?.length) {\n                me.scheduler.assignmentStore.remove(assignmentRecords);\n            }\n            if (eventRecords?.length) {\n                me.scheduler.eventStore.remove(eventRecords);\n            }\n        }\n    }\n    /**\n     * Called from Clipboardable after writing a non-string value to the clipboard\n     * @param eventRecords\n     * @returns {string}\n     * @private\n     */\n    stringConverter({ eventRecords }) {\n        const rows = [];\n        for (const event of eventRecords) {\n            rows.push(this.eventToStringFields.map(field => {\n                const value = event[field];\n                if (value instanceof Date) {\n                    return DateHelper.format(value, this.dateFormat);\n                }\n                return value;\n            }).join('\\t'));\n        }\n        return rows.join('\\n');\n    }\n    // Called from Clipboardable for each cut out record\n    setIsCut({ assignmentRecords }, isCut) {\n        assignmentRecords.forEach(assignment => {\n            assignment.meta.isCut = isCut;\n        });\n        // refresh to call onEventDataGenerated and reapply the cls for records where the cut was canceled\n        this.scheduler.refreshWithTransition();\n    }\n    /**\n     * Paste events or assignments to specified date and resource\n     * @fires beforePaste\n     * @fires paste\n     * @param {Date} [date] Date where the events or assignments will be pasted\n     * @param {Scheduler.model.ResourceModel} [resourceRecord] Resource to assign the pasted events or assignments to\n     * @category Edit\n     * @on-owner\n     */\n    async pasteEvents(date, resourceRecord) {\n        const\n            me            = this,\n            { scheduler } = me;\n        // Relay to original if split\n        if (scheduler.splitFrom) {\n            return scheduler.splitFrom.features.eventCopyPaste.pasteEvents(date, resourceRecord);\n        }\n        const\n            {\n                entityName,\n                isCut,\n                _cellClickedContext,\n                _eventClickedContext\n            }  = me,\n            {\n                eventStore,\n                assignmentStore\n            }  = scheduler;\n        if (arguments.length === 0) {\n            if (_cellClickedContext) {\n                date           = _cellClickedContext.date;\n                resourceRecord = _cellClickedContext.resourceRecord;\n            }\n            else if (me._focusedEventOnCopy !== _eventClickedContext) {\n                date           = _eventClickedContext.eventRecord.startDate;\n                resourceRecord = _eventClickedContext.resourceRecord;\n            }\n        }\n        if (resourceRecord) {\n            resourceRecord = resourceRecord.$original;\n        }\n        const clipboardData = await me.readFromClipboard({ resourceRecord, date });\n        if (!clipboardData?.assignmentRecords?.length) {\n            return;\n        }\n        const\n            {\n                assignmentRecords,\n                eventRecords\n            }            = clipboardData;\n        let toFocus      = null;\n        const\n            pastedEvents = new Set(),\n            pastedEventRecords = [];\n        for (const assignmentRecord of assignmentRecords) {\n            let { event }            = assignmentRecord;\n            const\n                targetResourceRecord = resourceRecord || assignmentRecord.resource,\n                targetDate           = date || assignmentRecord.event.startDate;\n            // Pasting targets a specific resource, we cannot have multiple assignments to the same so remove all but\n            // the first (happens when pasting multiple assignments of the same event)\n            if (pastedEvents.has(event)) {\n                if (isCut) {\n                    assignmentRecord.remove();\n                }\n                continue;\n            }\n            pastedEvents.add(event);\n            // Cut always means reassign\n            if (isCut) {\n                assignmentRecord.meta.isCut = false;\n                assignmentRecord.resource   = targetResourceRecord;\n                toFocus                     = assignmentRecord;\n            }\n            // Copy creates a new event in single assignment, or when configured to copy\n            else if (!eventStore.usesResourceIds && (eventStore.usesSingleAssignment || me.copyPasteAction === 'clone')) {\n                event      = event.copy();\n                event.name = me.generateNewName(event);\n                eventStore.add(event);\n                event.assign(targetResourceRecord);\n                toFocus = assignmentStore.last;\n            }\n            // Safeguard against pasting on a resource where the event is already assigned,\n            // a new assignment in multiassign mode will only change the date in such case\n            else if (!event.resources.includes(targetResourceRecord)) {\n                const newAssignmentRecord    = assignmentRecord.copy();\n                newAssignmentRecord.resource = targetResourceRecord;\n                [toFocus]                    = assignmentStore.add(newAssignmentRecord);\n            }\n            event.startDate = targetDate;\n            // Pro specific, to allow event to appear where pasted\n            if (event.constraintDate) {\n                event.constraintDate = null;\n            }\n            pastedEventRecords.push(event);\n        }\n        /**\n         * Fires on the owning Scheduler after a paste action is performed.\n         * @event paste\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords Original events\n         * @param {Scheduler.model.EventModel[]} pastedEventRecords Pasted events\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Pasted assignments\n         * @param {Date} date date Pasted to this date\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other paste events\n         */\n        scheduler.trigger('paste', { assignmentRecords, pastedEventRecords, eventRecords, resourceRecord, date, isCut, entityName });\n        // Focus the last pasted assignment\n        const detacher = scheduler.ion({\n            renderEvent({ assignmentRecord }) {\n                if (assignmentRecord === toFocus) {\n                    scheduler.navigateTo(assignmentRecord, { scrollIntoView : false });\n                    detacher();\n                }\n            }\n        });\n        if (isCut) {\n            await me.clearClipboard();\n        }\n    }\n    // Called from Clipboardable before finishing the internal clipboard read\n    async beforePaste({ data : { assignmentRecords, eventRecords }, resourceRecord, isCut, date }) {\n        const\n            { scheduler } = this,\n            eventData     = {\n                assignmentRecords,\n                eventRecords,\n                resourceRecord : resourceRecord || assignmentRecords[0].resource,\n                date,\n                isCut,\n                entityName     : this.entityName\n            };\n        let reason;\n        // No pasting to readOnly resources\n        if (resourceRecord?.readOnly) {\n            reason = 'resourceReadOnly';\n        }\n        if (!scheduler.allowOverlap) {\n            const pasteWouldResultInOverlap = assignmentRecords.some(assignmentRecord => !scheduler.isDateRangeAvailable(\n                assignmentRecord.event.startDate,\n                assignmentRecord.event.endDate,\n                isCut ? assignmentRecord.event : null,\n                assignmentRecord.resource)\n            );\n            if (pasteWouldResultInOverlap) {\n                reason = 'overlappingEvents';\n            }\n        }\n        /**\n         * Fires on the owning Scheduler if a paste action is not allowed\n         * @event pasteNotAllowed\n         * @on-owner\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n         * @param {Date} date The paste date\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other `pasteNotAllowed` events\n         * @param {'overlappingEvents'|'resourceReadOnly'} reason A string id to use for displaying an error message to the user.\n         */\n        if (reason) {\n            scheduler.trigger('pasteNotAllowed', {\n                ...eventData,\n                reason\n            });\n            return false;\n        }\n        /**\n         * Fires on the owning Scheduler before a paste action is performed, return `false` to prevent the action\n         * @event beforePaste\n         * @preventable\n         * @on-owner\n         * @async\n         * @param {Scheduler.view.Scheduler} source Owner scheduler\n         * @param {Scheduler.model.EventModel[]} eventRecords The events about to be pasted\n         * @param {Scheduler.model.AssignmentModel[]} assignmentRecords The assignments about to be pasted\n         * @param {Date} date The date when the pasted events will be scheduled\n         * @param {Scheduler.model.ResourceModel} resourceRecord The target resource record, the clipboard\n         * event records will be assigned to this resource.\n         * @param {Boolean} isCut `true` if this is a cut action\n         * @param {String} entityName 'event' to distinguish this event from other beforePaste events\n         */\n        return await this.scheduler.trigger('beforePaste', eventData);\n    }\n    /**\n     * Called from Clipboardable after reading from clipboard, and it is determined that the clipboard data is\n     * \"external\"\n     * @param json\n     * @returns {Object}\n     * @private\n     */\n    stringParser(clipboardData) {\n        const\n            { eventStore, assignmentStore }    = this.scheduler,\n            { modifiedRecords : eventRecords } = this.setFromStringData(clipboardData, true, eventStore, this.eventToStringFields),\n            assignmentRecords                  = [];\n        for (const event of eventRecords) {\n            const assignment = new assignmentStore.modelClass({ eventId : event.id });\n            assignment.event = event;\n            assignmentRecords.push(assignment);\n        }\n        return { eventRecords, assignmentRecords };\n    }\n    populateEventMenu({ assignmentRecord, items }) {\n        const\n            me            = this,\n            { scheduler } = me;\n        if (!scheduler.readOnly) {\n            items.copyEvent = {\n                text        : 'L{copyEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-copy',\n                weight      : 110,\n                onItem      : () => {\n                    const assignments = scheduler.isAssignmentSelected(assignmentRecord) ? scheduler.selectedAssignments : [assignmentRecord];\n                    me.copyEvents(assignments);\n                }\n            };\n            items.cutEvent = {\n                text        : 'L{cutEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-cut',\n                weight      : 120,\n                disabled    : assignmentRecord.event.readOnly,\n                onItem      : () => {\n                    const assignments = scheduler.isAssignmentSelected(assignmentRecord) ? scheduler.selectedAssignments : [assignmentRecord];\n                    me.copyEvents(assignments, true);\n                }\n            };\n        }\n    }\n    populateScheduleMenu({ items, resourceRecord }) {\n        const\n            me            = this,\n            { scheduler } = me;\n        if (!scheduler.readOnly && me.hasClipboardData() !== false) {\n            items.pasteEvent = {\n                text        : 'L{pasteEvent}',\n                localeClass : me,\n                icon        : 'b-icon b-icon-paste',\n                disabled    : scheduler.resourceStore.count === 0 || resourceRecord.readOnly,\n                weight      : 110,\n                onItem      : ({\n                    date, resourceRecord\n                }) => {\n                    me.pasteEvents(date, resourceRecord, scheduler.getRowFor(resourceRecord));\n                }\n            };\n        }\n    }\n    /**\n     * A method used to generate the name for a copy pasted record. By defaults appends \"- 2\", \"- 3\" as a suffix.\n     *\n     * @param {Scheduler.model.EventModel} eventRecord The new eventRecord being pasted\n     * @returns {String}\n     */\n    generateNewName(eventRecord) {\n        const originalName = eventRecord.getValue(this.nameField);\n        let counter = 2;\n        while (this.client.eventStore.findRecord(this.nameField, `${originalName} - ${counter}`)) {\n            counter++;\n        }\n        return `${originalName} - ${counter}`;\n    }\n}\nEventCopyPaste.featureClass = 'b-event-copypaste';\nEventCopyPaste._$name = 'EventCopyPaste'; GridFeatureManager.registerFeature(EventCopyPaste, true, 'Scheduler');\n", "import DragBase from './base/DragBase.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport EventHelper from '../../Core/helper/EventHelper.js';\n/**\n * @module Scheduler/feature/EventDrag\n */\n/**\n * Object with information about the drop point for a single dragged event.\n *\n * @typedef {Object} EventDropData\n * @property {Scheduler.model.EventModel} eventRecord The event about to be dropped. Note, that when\n * \"copying\" mode is enabled, this will still be the originally dragged event, not the copy\n * (which will be created only during drag'n'drop finalization).\n * @property {Date} startDate The estimated start date of the event after drop. Note, that actual start date\n * might be different because of the other features, affecting the scheduling, like dependencies and constraints.\n * @property {Date} endDate The estimated end date of the event after drop. Note, that actual end date\n * might be different because of the other features, affecting the scheduling, like dependencies and constraints.\n */\n/**\n * Object with information about the drop point for a dragged assignment.\n *\n * @typedef {Object} AssignmentDropData\n * @property {Scheduler.model.AssignmentModel} assignmentRecord The assignment about to be dropped. Note, that in case\n * if \"copying\" mode is enabled, this will still be the originally dragged assignment, not the copy\n * (which will be created only during drag'n'drop finalization).\n * @property {Scheduler.model.ResourceModel} resourceRecord The new resource for the assignment. Note, that resource\n * might belong to another project (in case of drag and drop between different scheduler instances).\n */\n/**\n * Object with information about the drop points for the dragged events.\n * It is used in the Scheduler's {@link Scheduler.view.Scheduler#event-beforeEventDropFinalize} event.\n *\n * @typedef {Object} DropData\n * @property {Array<EventDropData>} events The array of drop points for every dragged event.\n * @property {Array<AssignmentDropData>} assignments The array of drop points for every dragged assignment.\n */\n/**\n * Allows user to drag and drop events within the scheduler, to change startDate or resource assignment.\n *\n * This feature is **enabled** by default\n *\n * ## Customizing the drag drop tooltip\n *\n * To show custom HTML in the tooltip, please see the {@link #config-tooltipTemplate} config. Example:\n *\n * ```javascript\n * features: {\n *     eventDrag : {\n *         // A minimal start date tooltip\n *         tooltipTemplate : ({ eventRecord, startDate }) => {\n *             return DateHelper.format(startDate, 'HH:mm');\n *         }\n *     }\n * }\n * ```\n *\n * ## Constraining the drag drop area\n *\n * You can constrain how the dragged event is allowed to move by using the following configs\n * * {@link #config-constrainDragToResource} Resource fixed, only allowed to change start date\n * * {@link #config-constrainDragToTimeSlot} Start date is fixed, only move between resources\n * * {@link Scheduler.view.Scheduler#config-getDateConstraints} A method on the Scheduler instance\n *    which lets you define the date range for the dragged event programmatically\n *\n * ```js\n * // Enable dragging + constrain drag to current resource\n * const scheduler = new Scheduler({\n *     features : {\n *         eventDrag : {\n *             constrainDragToResource : true\n *         }\n *     }\n * });\n * ```\n *\n * ## Drag drop events from outside\n *\n * Dragging unplanned events from an external grid is a very popular use case. There are\n * several demos showing you how to do this. Please see the [Drag from grid demo](../examples/dragfromgrid)\n * and study the **Drag from grid guide** to learn more.\n *\n * ## Drag drop events to outside target\n *\n * You can also drag events outside the schedule area by setting {@link #config-constrainDragToTimeline} to `false`. You\n * should also either:\n * * provide a {@link #config-validatorFn} to programmatically define if a drop location is valid or not\n * * configure a {@link #config-externalDropTargetSelector} CSS selector to define where drops are allowed\n *\n * See [this demo](../examples/drag-outside) to see this in action.\n *\n * ## Validating drag drop\n *\n * It is easy to programmatically decide what is a valid drag drop operation. Use the {@link #config-validatorFn}\n * and return either `true` / `false` (optionally a message to show to the user).\n *\n * ```javascript\n * features : {\n *     eventDrag : {\n *        validatorFn({ eventRecords, newResource }) {\n *            const task  = eventRecords[0],\n *                  valid = newResource.role === task.resource.role;\n *\n *            return {\n *                valid   : newResource.role === task.resource.role,\n *                message : valid ? '' : 'Resource role does not match required role for this task'\n *            };\n *        }\n *     }\n * }\n * ```\n *\n * See [this demo](../examples/validation) to see validation in action.\n *\n * If you instead want to do a single validation upon drop, you can listen to {@link #event-beforeEventDropFinalize}\n * and set the `valid` flag on the context object provided.\n *\n * ```javascript\n *   const scheduler = new Scheduler({\n *      listeners : {\n *          beforeEventDropFinalize({ context }) {\n *              const { eventRecords } = context;\n *              // Don't allow dropping events in the past\n *              context.valid = Date.now() <= eventRecords[0].startDate;\n *          }\n *      }\n *  });\n * ```\n *\n * ## Preventing drag of certain events\n *\n * To prevent certain events from being dragged, you have two options. You can set {@link Scheduler.model.EventModel#field-draggable}\n * to `false` in your data, or you can listen for the {@link Scheduler.view.Scheduler#event-beforeEventDrag} event and\n * return `false` to block the drag.\n *\n * ```javascript\n * new Scheduler({\n *    listeners : {\n *        beforeEventDrag({ eventRecord }) {\n *            // Don't allow dragging events that have already started\n *            return Date.now() <= eventRecord.startDate;\n *        }\n *    }\n * })\n * ```\n *\n * {@inlineexample Scheduler/feature/EventDrag.js}\n *\n * @demo Scheduler/basic\n *\n * @extends Scheduler/feature/base/DragBase\n * @classtype eventDrag\n * @feature\n */\nexport default class EventDrag extends DragBase {\n    //region Config\n    static get $name() {\n        return 'EventDrag';\n    }\n    static get configurable() {\n        return {\n            /**\n             * Template used to generate drag tooltip contents.\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventDrag : {\n             *             dragTipTemplate({eventRecord, startText}) {\n             *                 return `${eventRecord.name}: ${startText}`\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             * @config {Function} tooltipTemplate\n             * @param {Object} data Tooltip data\n             * @param {Scheduler.model.EventModel} data.eventRecord\n             * @param {Boolean} data.valid Currently over a valid drop target or not\n             * @param {Date} data.startDate New start date\n             * @param {Date} data.endDate New end date\n             * @returns {String}\n             */\n            /**\n             * Set to true to only allow dragging events within the same resource.\n             * @member {Boolean} constrainDragToResource\n             */\n            /**\n             * Set to true to only allow dragging events within the same resource.\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToResource : false,\n            /**\n             * Set to true to only allow dragging events to different resources, and disallow rescheduling by dragging.\n             * @member {Boolean} constrainDragToTimeSlot\n             */\n            /**\n             * Set to true to only allow dragging events to different resources, and disallow rescheduling by dragging.\n             * @config {Boolean}\n             * @default\n             */\n            constrainDragToTimeSlot : false,\n            /**\n             * A CSS selector specifying elements outside the scheduler element which are valid drop targets.\n             * @config {String}\n             */\n            externalDropTargetSelector : null,\n            /**\n             * An empty function by default, but provided so that you can perform custom validation on the item being\n             * dragged. This function is called during the drag and drop process and also after the drop is made.\n             * Return `true` if the new position is valid, `false` to prevent the drag.\n             *\n             * ```javascript\n             * features : {\n             *     eventDrag : {\n             *         validatorFn({ eventRecords, newResource }) {\n             *             const\n             *                 task  = eventRecords[0],\n             *                 valid = newResource.role === task.resource.role;\n             *\n             *             return {\n             *                 valid   : newResource.role === task.resource.role,\n             *                 message : valid ? '' : 'Resource role does not match required role for this task'\n             *             };\n             *         }\n             *     }\n             * }\n             * ```\n             * @param {Object} context A drag drop context object\n             * @param {Date} context.startDate New start date\n             * @param {Date} context.endDate New end date\n             * @param {Scheduler.model.AssignmentModel[]} context.assignmentRecords Assignment records which were dragged\n             * @param {Scheduler.model.EventModel[]} context.eventRecords Event records which were dragged\n             * @param {Scheduler.model.ResourceModel} context.newResource New resource record\n             * @param {Scheduler.model.EventModel} context.targetEventRecord Currently hovering this event record\n             * @param {Event} event The event object\n             * @returns {Boolean|Object} `true` if this validation passes, `false` if it does not.\n             *\n             * Or an object with 2 properties: `valid` -  Boolean `true`/`false` depending on validity,\n             * and `message` - String with a custom error message to display when invalid.\n             * @config {Function}\n             */\n            validatorFn : (context, event) => {},\n            /**\n             * The `this` reference for the validatorFn\n             * @config {Object}\n             */\n            validatorFnThisObj : null,\n            /**\n             * When the host Scheduler is `{@link Scheduler.view.mixin.EventSelection#config-multiEventSelect}: true`\n             * then, there are two modes of dragging *within the same Scheduler*.\n             *\n             * Non unified means that all selected events are dragged by the same number of resource rows.\n             *\n             * Unified means that all selected events are collected together and dragged as one, and are all dropped\n             * on the same targeted resource row at the same targeted time.\n             * @member {Boolean} unifiedDrag\n             */\n            /**\n             * When the host Scheduler is `{@link Scheduler.view.mixin.EventSelection#config-multiEventSelect}: true`\n             * then, there are two modes of dragging *within the same Scheduler*.\n             *\n             * Non unified means that all selected events are dragged by the same number of resource rows.\n             *\n             * Unified means that all selected events are collected together and dragged as one, and are all dropped\n             * on the same targeted resource row at the same targeted time.\n             * @config {Boolean}\n             * @default false\n             */\n            unifiedDrag : null,\n            /**\n             * A hook that allows manipulating the position the drag proxy snaps to. Manipulate the `snapTo` property\n             * to alter snap position.\n             *\n             * ```javascript\n             * const scheduler = new Scheduler({\n             *     features : {\n             *         eventDrag : {\n             *             snapToPosition({ eventRecord, snapTo }) {\n             *                 if (eventRecord.late) {\n             *                     snapTo.x = 400;\n             *                 }\n             *             }\n             *         }\n             *     }\n             * });\n             * ```\n             *\n             * @config {Function}\n             * @param {Object} context\n             * @param {Scheduler.model.AssignmentModel} context.assignmentRecord Dragged assignment\n             * @param {Scheduler.model.EventModel} context.eventRecord Dragged event\n             * @param {Scheduler.model.ResourceModel} context.resourceRecord Currently over this resource\n             * @param {Date} context.startDate Start date for current position\n             * @param {Date} context.endDate End date for current position\n             * @param {Object} context.snapTo\n             * @param {Number} context.snapTo.x X to snap to\n             * @param {Number} context.snapTo.y Y to snap to\n             * @returns {void}\n             */\n            snapToPosition : null,\n            /**\n             * A modifier key (CTRL, SHIFT, ALT, META) that when pressed will copy an event instead of moving it. Set to\n             * empty string to disable copying\n             * @prp {'CTRL'|'ALT'|'SHIFT'|'META'|''}\n             * @default\n             */\n            copyKey : 'SHIFT',\n            /**\n             * Event can be copied two ways: either by adding new assignment to an existing event ('assignment'), or\n             * by copying the event itself ('event'). 'auto' mode will pick 'event' for a single-assignment mode (when\n             * event has `resourceId` field) and 'assignment' mode otherwise.\n             * @prp {'auto'|'assignment'|'event'}\n             * @default\n             */\n            copyMode : 'auto',\n            /**\n             * Mode of the current drag drop operation.\n             * @member {'move'|'copy'}\n             * @readonly\n             */\n            mode : 'move',\n            capitalizedEventName : null\n        };\n    }\n    afterConstruct() {\n        this.capitalizedEventName = this.capitalizedEventName || this.client.capitalizedEventName;\n        super.afterConstruct(...arguments);\n    }\n    //endregion\n    changeMode(value) {\n        const { dragData, copyMode } = this;\n        // Do not create assignments in case scheduler doesn't use multiple assignments\n        // Do not allow to copy recurring events\n        if (\n            (copyMode === 'event' || copyMode === 'auto' ||\n                copyMode === 'assignment' && !this.scheduler.eventStore.usesSingleAssignment) &&\n            (!dragData || dragData.eventRecords.every(r => !r.isRecurring))\n        ) {\n            return value;\n        }\n    }\n    updateMode(mode) {\n        if (this.dragData) {\n            if (mode === 'copy') {\n                this.setCopying();\n            }\n            else {\n                this.setMoving();\n            }\n            /**\n             * Triggered when drag mode is changed, for example when copy key is\n             * pressed or released while dragging.\n             * @event eventDragModeChange\n             * @param {String} mode Drag mode, could be either 'move', 'copy', or 'auto'\n             * @on-owner\n             */\n            this.client.trigger('eventDragModeChange', { mode });\n        }\n    }\n    setCopying() {\n        const { dragData } = this;\n        if (!dragData) {\n            return;\n        }\n        // Check if proxies are added to the DOM by checking if any of them is\n        if (!dragData.eventBarCopies.some(el => el.isConnected)) {\n            dragData.eventBarCopies.forEach(el => {\n                el.classList.add('b-drag-proxy-copy');\n                // hidden class can be added by the drag feature if we're dragging event outside\n                el.classList.remove('b-hidden');\n                dragData.context.grabbedParent.appendChild(el);\n                // Mark this node as ignored for the DomSync\n                el.retainElement = true;\n            });\n        }\n        else {\n            dragData.eventBarCopies.forEach(el => {\n                el.classList.remove('b-hidden');\n            });\n        }\n    }\n    setMoving() {\n        const { dragData } = this;\n        if (!dragData) {\n            return;\n        }\n        dragData.eventBarCopies.forEach(el => {\n            el.classList.add('b-hidden');\n        });\n    }\n    //region Events\n    /**\n     * This event is fired on the owning Scheduler after the event drag operation completes, but before changing any data.\n     * It allows implementer to use asynchronous validation/finalization by setting `context.async = true`\n     * in the listener, for example, to show a confirmation popup, make async data request etc.\n     * In such case, implementer need to call the `context.finalize()` method manually:\n     *\n     * ```javascript\n     *  scheduler.on('beforeeventdropfinalize', ({ context }) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // `true` to perform the drop, `false` to ignore it\n     *          context.finalize(true);\n     *      }, 1000);\n     *  })\n     * ```\n     *\n     * For synchronous one-time validation, simply set `context.valid` to true or false.\n     * ```javascript\n     *  scheduler.on('beforeeventdropfinalize', ({ context }) => {\n     *      context.valid = false;\n     *  })\n     * ```\n     * @event beforeEventDropFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Object} context\n     * @param {DropData} context.dropData Information about the drop points for dragged events/assignments.\n     * @param {Boolean} context.async Set to `true` to not finalize the drag-drop operation immediately (e.g. to wait for user confirmation)\n     * @param {Scheduler.model.EventModel[]} context.eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} context.assignmentRecords Assignment records being dragged\n     * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target\n     * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target\n     * @param {Boolean} context.valid Set this to `false` to abort the drop immediately.\n     * @param {Function} context.finalize Call this method after an **async** finalization flow, to finalize the drag-drop operation. This method accepts one\n     * argument: pass `true` to update records, or `false` to ignore changes\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler after event drop\n     * @event afterEventDrop\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n     * @param {Scheduler.model.EventModel[]} eventRecords\n     * @param {Boolean} valid\n     * @param {Object} context\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler when an event is dropped\n     * @event eventDrop\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel[]} eventRecords\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords\n     * @param {HTMLElement} externalDropTarget The HTML element dropped upon, if drop happened on a valid external drop target\n     * @param {Boolean} isCopy\n     * @param {Object} context\n     * @param {Scheduler.model.EventModel} context.targetEventRecord Event record for drop target\n     * @param {Scheduler.model.ResourceModel} context.newResource Resource record for drop target\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler before event dragging starts. Return `false` to prevent the action.\n     * @event beforeEventDrag\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord Event record the drag starts from\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag starts from\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} event Browser event DEPRECATED (replaced by domEvent)\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler when event dragging starts\n     * @event eventDragStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag starts from\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} event Browser event DEPRECATED (replaced by domEvent)\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler when event is dragged\n     * @event eventDrag\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {Date} startDate Start date for the current location\n     * @param {Date} endDate End date for the current location\n     * @param {Scheduler.model.ResourceModel} resourceRecord Resource record the drag started from\n     * @param {Scheduler.model.ResourceModel} newResource Resource at the current location\n     * @param {Object} context\n     * @param {Boolean} context.valid Set this to `false` to signal that the current drop position is invalid.\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler after an event drag operation has been aborted\n     * @event eventDragAbort\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel[]} eventRecords Event records being dragged\n     * @param {Scheduler.model.AssignmentModel[]} assignmentRecords Assignment records being dragged\n     * @param {MouseEvent} domEvent Browser event\n     */\n    /**\n     * Fired on the owning Scheduler after an event drag operation regardless of the operation being cancelled or not\n     * @event eventDragReset\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     */\n    //endregion\n    //region Data layer\n    // Deprecated. Use this.client instead\n    get scheduler() {\n        return this.client;\n    }\n    //endregion\n    //#region Drag lifecycle\n    onAfterDragStart(event) {\n        const\n            me                        = this,\n            { context : { element } } = event;\n        super.onAfterDragStart(event);\n        me.handleKeyDownOrMove(event.event);\n        me.keyEventDetacher = EventHelper.on({\n            // In case we drag event between scheduler focused event gets moved and focus\n            // moves to the body. We only need to read the key from this event\n            element : DomHelper.getRootElement(element),\n            keydown : me.handleKeyDownOrMove,\n            keyup   : me.handleKeyUp,\n            thisObj : me\n        });\n    }\n    onDragReset(event) {\n        super.onDragReset(event);\n        this.keyEventDetacher?.();\n        this.mode = 'move';\n    }\n    onDrop(event) {\n        // Always remove proxy on drop\n        this.dragData.eventBarCopies?.forEach(el => el.remove());\n        return super.onDrop(event);\n    }\n    //#endregion\n    //region Drag events\n    getDraggableElement(el) {\n        return el?.closest(this.drag.targetSelector);\n    }\n    resolveEventRecord(eventElement, client = this.client) {\n        return client.resolveEventRecord(eventElement);\n    }\n    isElementDraggable(el, event) {\n        const\n            me           = this,\n            { client }   = me,\n            eventElement = me.getDraggableElement(el);\n        if (!eventElement || me.disabled || client.readOnly) {\n            return false;\n        }\n        // displaying something resizable within the event?\n        if (el.matches('[class$=\"-handle\"]')) {\n            return false;\n        }\n        const eventRecord = me.resolveEventRecord(eventElement, client);\n        if (!eventRecord || !eventRecord.isDraggable || eventRecord.readOnly) {\n            return false;\n        }\n        // Hook for features that need to prevent drag\n        const prevented = client[`is${me.capitalizedEventName}ElementDraggable`]?.(\n            eventElement, eventRecord, el, event\n        ) === false;\n        return !prevented;\n    }\n    getTriggerParams(dragData) {\n        const { assignmentRecords, eventRecords, resourceRecord, browserEvent : domEvent } = dragData;\n        return {\n            // `context` is now private, but used in WebSocketHelper\n            context : dragData,\n            eventRecords,\n            resourceRecord,\n            assignmentRecords,\n            event   : domEvent, // Deprecated, remove on  6.0?\n            domEvent\n        };\n    }\n    getGroupedToStoreResources(dragData) {\n        if (dragData.resourcesInStore) {\n            return dragData.resourcesInStore;\n        }\n        const\n            fromScheduler = this.client,\n            fromResourceStore = fromScheduler.isVertical ? fromScheduler.resourceStore : fromScheduler.store;\n        return dragData.resourcesInStore = [...new Set(fromResourceStore.getAllDataRecords().map(r => r.$original))].filter(r => r.isLeaf);\n    }\n    getIndexDiff(dragData) {\n        const\n            me = this,\n            fromScheduler = me.client,\n            toScheduler = me.currentOverClient,\n            isCrossScheduler = fromScheduler !== toScheduler,\n            { isVertical } = toScheduler,\n            // When using TreeGroup in horizontal mode, store != resourceStore. Does not apply for vertical mode.\n            fromResourceStore = fromScheduler.isVertical ? fromScheduler.resourceStore : fromScheduler.store,\n            toResourceStore = isVertical ? toScheduler.resourceStore : toScheduler.store,\n            {\n                resourceRecord : fromResource,\n                newResource : toResource\n            } = dragData;\n        let indexDiff;\n        if (isCrossScheduler) {\n            // The difference in indices via first dragged event will help us find resources for all the rest of the\n            // events accordingly\n            indexDiff = toResourceStore.indexOf(toResource) - fromResourceStore.indexOf(fromResource.$original);\n        }\n        else if (me.constainDragToResource) {\n            indexDiff = 0;\n        }\n        else if (isVertical && toResourceStore.isGrouped) {\n            const resourcesInStore    = me.getGroupedToStoreResources(dragData);\n            indexDiff = resourcesInStore.indexOf(fromResource.$original) - resourcesInStore.indexOf(toResource);\n        }\n        else {\n            indexDiff = fromResourceStore.indexOf(fromResource.$original) - fromResourceStore.indexOf(toResource);\n        }\n        return indexDiff;\n    }\n    getNewResource(dragData, originalResourceRecord, indexDiff) {\n        const\n            me = this,\n            fromScheduler = me.client,\n            toScheduler = me.currentOverClient,\n            isCrossScheduler = fromScheduler !== toScheduler,\n            { isVertical } = toScheduler,\n            // When using TreeGroup in horizontal mode, store != resourceStore. Does not apply for vertical mode.\n            fromResourceStore = fromScheduler.isVertical ? fromScheduler.resourceStore : fromScheduler.store,\n            toResourceStore = isVertical ? toScheduler.resourceStore : toScheduler.store;\n        let { newResource }    = dragData;\n        if (!isCrossScheduler) {\n            // If not dragging events as a unified block, distribute each to a new resource\n            // using the same offset as the dragged event.\n            if (indexDiff !== 0) {\n                let newIndex;\n                if (isVertical && toResourceStore.isGrouped) {\n                    const resourcesInStore    = me.getGroupedToStoreResources(dragData);\n                    newIndex    = Math.max(\n                        Math.min(\n                            resourcesInStore.indexOf(originalResourceRecord) - indexDiff,\n                            resourcesInStore.length - 1\n                        ),\n                        0\n                    );\n                    newResource = resourcesInStore[newIndex];\n                }\n                else {\n                    newIndex = Math.max(\n                        Math.min(\n                            fromResourceStore.indexOf(originalResourceRecord) - indexDiff,\n                            fromResourceStore.count - 1\n                        ),\n                        0\n                    );\n                    newResource = fromResourceStore.getAt(newIndex);\n                    // Exclude group headers, footers, summary row etc\n                    if (newResource.isSpecialRow) {\n                        newResource = fromResourceStore.getNext(newResource, false, true) || fromResourceStore.getPrevious(newResource, false, true);\n                    }\n                }\n                newResource = newResource?.$original;\n            }\n            else {\n                newResource = originalResourceRecord;\n            }\n        }\n        // we have a resource for first dragged event in toResource\n        else {\n            const draggedEventResourceIndex = fromResourceStore.indexOf(originalResourceRecord);\n            newResource                     = toResourceStore.getAt(draggedEventResourceIndex + indexDiff) || newResource;\n        }\n        return newResource;\n    }\n    getDropData(dragData) {\n        const indexDiff = this.getIndexDiff(dragData);\n        return {\n            events : dragData.eventRecords.map(eventRecord => {\n                return {\n                    eventRecord,\n                    ...this.getEventNewStartEndDates(eventRecord, dragData.timeDiff)\n                };\n            }),\n            assignments : dragData.assignmentRecords.map(assignmentRecord => {\n                return {\n                    assignmentRecord,\n                    resourceRecord : this.getNewResource(dragData, assignmentRecord.resource, indexDiff)\n                };\n            })\n        };\n    }\n    triggerBeforeEventDropFinalize(eventType, eventData, client) {\n        eventData.context.dropData = this.getDropData(eventData.context);\n        super.triggerBeforeEventDropFinalize(eventType, eventData, client);\n    }\n    triggerBeforeEventDrag(eventType, event) {\n        return this.client.trigger(eventType, event);\n    }\n    triggerEventDrag(dragData, start) {\n        this.client.trigger('eventDrag', Object.assign(this.getTriggerParams(dragData), {\n            startDate   : dragData.startDate,\n            endDate     : dragData.endDate,\n            newResource : dragData.newResource\n        }));\n    }\n    triggerDragStart(dragData) {\n        this.client.navigator.skipNextClick = true;\n        this.client.trigger('eventDragStart', this.getTriggerParams(dragData));\n    }\n    triggerDragAbort(dragData) {\n        this.client.trigger('eventDragAbort', this.getTriggerParams(dragData));\n    }\n    triggerDragAbortFinalized(dragData) {\n        this.client.trigger('eventDragAbortFinalized', this.getTriggerParams(dragData));\n    }\n    triggerAfterDrop(dragData, valid) {\n        const me = this;\n        me.currentOverClient.trigger('afterEventDrop', Object.assign(me.getTriggerParams(dragData), {\n            valid\n        }));\n        if (!valid) {\n            // Edge cases:\n            // 1. If this drag was a no-op, and underlying data was changed while drag was ongoing (e.g. web socket\n            // push), we need to manually force a view refresh to ensure a correct render state\n            //\n            // or\n            // 2. Events were removed before we dropped at an invalid point\n            const\n                { assignmentStore, eventStore } = me.client,\n                needRefresh                     = me.dragData.initialAssignmentsState.find(({\n                    resource, assignment\n                }, i) => {\n                    return !assignmentStore.includes(assignment) ||\n                        !eventStore.includes(assignment.event) ||\n                        resource.id !== me.dragData.assignmentRecords[i]?.resourceId;\n                });\n            if (needRefresh) {\n                me.client.refresh();\n            }\n        }\n        // Reset the skipNextClick after a potential click event fires. https://github.com/bryntum/support/issues/5135\n        me.client.setTimeout(() => me.client.navigator.skipNextClick = false, 10);\n    }\n    handleKeyDownOrMove(event) {\n        if (this.mode !== 'copy') {\n            if (event.key && EventHelper.specialKeyFromEventKey(event.key) === this.copyKey?.toLowerCase() || event[`${this.copyKey?.toLowerCase()}Key`]) {\n                this.mode = 'copy';\n            }\n        }\n    }\n    handleKeyUp(event) {\n        if (EventHelper.specialKeyFromEventKey(event.key) === this.copyKey.toLowerCase()) {\n            this.mode = 'move';\n        }\n    }\n    //endregion\n    //region Finalization & validation\n    /**\n     * Checks if an event can be dropped on the specified position.\n     * @private\n     * @returns {Boolean} Valid (true) or invalid (false)\n     */\n    isValidDrop(dragData) {\n        const\n            {\n                newResource,\n                resourceRecord,\n                browserEvent\n            }            = dragData,\n            sourceRecord = dragData.draggedEntities[0],\n            { target }   = browserEvent;\n        // Only allowed to drop outside scheduler element if we hit an element matching the externalDropTargetSelector\n        if (!newResource) {\n            return (!this.constrainDragToTimeline && this.externalDropTargetSelector) ? Boolean(target.closest(this.externalDropTargetSelector)) : false;\n        }\n        // Not allowed to drop an event on a group header or a readOnly resource\n        if (newResource.isSpecialRow || newResource.readOnly) {\n            return false;\n        }\n        // Not allowed to assign an event twice to the same resource\n        if (resourceRecord.$original !== newResource) {\n            return !sourceRecord.event.resources.includes(newResource);\n        }\n        return true;\n    }\n    checkDragValidity(dragData, event) {\n        const\n            me        = this,\n            scheduler = me.currentOverClient;\n        let result;\n        // Cannot assign anything to readOnly resources\n        if (dragData.newResource?.readOnly) {\n            return false;\n        }\n        // First make sure there's no overlap, if not run the external validatorFn\n        if (!scheduler.allowOverlap && !scheduler.isDateRangeAvailable(\n            dragData.startDate,\n            dragData.endDate,\n            dragData.draggedEntities[0],\n            dragData.newResource\n        )) {\n            result = {\n                valid   : false,\n                message : me.L('L{eventOverlapsExisting}')\n            };\n        }\n        else {\n            result = me.validatorFn.call(\n                me.validatorFnThisObj || me,\n                dragData,\n                event\n            );\n        }\n        if (!result || result.valid) {\n            // Hook for features to have a say on validity\n            result = scheduler['checkEventDragValidity']?.(dragData, event) ?? result;\n        }\n        return result;\n    }\n    //endregion\n    //region Update records\n    /**\n     * Update events being dragged.\n     * @private\n     * @param context Drag data.\n     */\n    async updateRecords(context) {\n        const\n            me                            = this,\n            fromScheduler                                          = me.client,\n            toScheduler                                            = me.currentOverClient,\n            copyKeyPressed                                         = me.mode === 'copy',\n            { draggedEntities, timeDiff, initialAssignmentsState } = context,\n            originalStartDate                                      = initialAssignmentsState[0].startDate,\n            droppedStartDate                                       = me.adjustStartDate(originalStartDate, timeDiff);\n        let result;\n        if (!context.externalDropTarget) {\n            // Dropping dragged event completely outside the time axis is not allowed\n            if (!toScheduler.timeAxis.timeSpanInAxis(droppedStartDate, DateHelper.add(droppedStartDate, draggedEntities[0].event.durationMS, 'ms'))) {\n                context.valid = false;\n            }\n            if (context.valid) {\n                fromScheduler.eventStore.suspendAutoCommit();\n                toScheduler.eventStore.suspendAutoCommit();\n                result = await me.updateAssignments(fromScheduler, toScheduler, context, copyKeyPressed);\n                fromScheduler.eventStore.resumeAutoCommit();\n                toScheduler.eventStore.resumeAutoCommit();\n            }\n        }\n        // Might be flagged invalid in updateAssignments() above, if drop did not lead to any change\n        // (for example if dropped on non-working-time in Pro)\n        if (context.valid) {\n            // Tell the world there was a successful drop\n            toScheduler.trigger('eventDrop', Object.assign(me.getTriggerParams(context), {\n                isCopy               : copyKeyPressed,\n                copyMode             : me.copyMode,\n                domEvent             : context.browserEvent,\n                targetEventRecord    : context.targetEventRecord,\n                targetResourceRecord : context.newResource,\n                externalDropTarget   : context.externalDropTarget\n            }));\n        }\n        return result;\n    }\n    /**\n     * Update assignments being dragged\n     * @private\n     */\n    async updateAssignments(fromScheduler, toScheduler, context, copy) {\n        // The code is written to emit as few store events as possible\n        const\n            me                  = this,\n            { copyMode }        = me,\n            isCrossScheduler    = (fromScheduler !== toScheduler),\n            { isVertical }      = toScheduler,\n            {\n                assignmentStore : fromAssignmentStore,\n                eventStore      : fromEventStore\n            }                   = fromScheduler,\n            {\n                assignmentStore : toAssignmentStore,\n                eventStore      : toEventStore\n            }                   = toScheduler,\n            // When using TreeGroup in horizontal mode, store != resourceStore. Does not apply for vertical mode.\n            fromResourceStore   = fromScheduler.isVertical ? fromScheduler.resourceStore : fromScheduler.store,\n            {\n                eventRecords,\n                assignmentRecords,\n                timeDiff,\n                initialAssignmentsState,\n                newResource    : toResource\n            }                   = context,\n            { unifiedDrag }     = me,\n            // For an empty target event store, check if it has usesSingleAssignment explicitly set, otherwise use\n            // the value from the source event store\n            useSingleAssignment = (toEventStore.usesSingleAssignment ||\n                (toEventStore.usesSingleAssignment !== false && fromEventStore.usesSingleAssignment)),\n            // this value has clear semantic only for same scheduler case\n            effectiveCopyMode   = copyMode === 'event'\n                ? 'event'\n                : copyMode === 'assignment'\n                    ? 'assignment'\n                    : useSingleAssignment ? 'event' : 'assignment',\n            event1Date          = me.adjustStartDate(assignmentRecords[0].event.startDate, timeDiff),\n            eventsToAdd         = [],\n            eventsToRemove      = [],\n            assignmentsToAdd    = [],\n            assignmentsToRemove = [],\n            eventsToCheck       = [],\n            eventsToBatch       = new Set();\n        fromScheduler.suspendRefresh();\n        toScheduler.suspendRefresh();\n        let updated      = false,\n            updatedEvent = false,\n            indexDiff = me.getIndexDiff(context); // By how many resource rows has the drag moved.\n        if (isVertical) {\n            eventRecords.forEach((draggedEvent, i) => {\n                const eventBar = context.eventBarEls[i];\n                delete draggedEvent.instanceMeta(fromScheduler).hasTemporaryDragElement;\n                // If it was created by a call to scheduler.currentOrientation.addTemporaryDragElement\n                // then release it back to be available to DomSync next time the rendered event block\n                // is synced.\n                if (eventBar.dataset.transient) {\n                    eventBar.remove();\n                }\n            });\n        }\n        const\n            eventBarEls          = context.eventBarEls.slice(),\n            addedEvents          = [],\n            // this map holds references between original assignment and its copy\n            copiedAssignmentsMap = {};\n        // Using for to support await inside\n        for (let i = 0; i < assignmentRecords.length; i++) {\n            const originalAssignment = assignmentRecords[i];\n            // Reassigned when dropped on other scheduler, thus not const\n            let draggedEvent = originalAssignment.event,\n                draggedAssignment;\n            if (copy) {\n                draggedAssignment                           = originalAssignment.copy();\n                copiedAssignmentsMap[originalAssignment.id] = draggedAssignment;\n            }\n            else {\n                draggedAssignment = originalAssignment;\n            }\n            if (!draggedAssignment.isOccurrenceAssignment && (!fromAssignmentStore.includes(originalAssignment) || !fromEventStore.includes(draggedEvent))) {\n                // Event was removed externally during the drag, just remove element from DOM (DomSync already has\n                // tried to clean it up at this point, but could not due to retainElement being set)\n                eventBarEls[i].remove();\n                eventBarEls.splice(i, 1);\n                assignmentRecords.splice(i, 1);\n                i--;\n                continue;\n            }\n            const\n                initialState           = initialAssignmentsState[i],\n                originalEventRecord    = draggedEvent,\n                originalStartDate      = initialState.startDate,\n                // grabbing resource early, since after \".copy()\" the record won't belong to any store\n                // and \".getResources()\" won't work. If it's a move to another scheduler, ensure the\n                // array still has a length. The process function will do an assign as opposed\n                // to a reassignment\n                originalResourceRecord = initialState.resource,\n                // Calculate new startDate (and round it) based on timeDiff up here, might be added to another\n                // event store below in which case it is invalidated. But this is anyway the target date\n                newStartDate           = this.constrainDragToTimeSlot\n                    ? originalStartDate\n                    : (unifiedDrag\n                        ? event1Date\n                        : me.adjustStartDate(originalStartDate, timeDiff));\n            if (fromAssignmentStore !== toAssignmentStore) {\n                // Single assignment from a multi assigned event dragged over, event needs to be copied over\n                // Same if we hold the copy key\n                const keepEvent = originalEventRecord.assignments.length > 1 || copy;\n                let newAssignment;\n                if (copy) {\n                    // In a copy mode dragged assignment is already a copy\n                    newAssignment = draggedAssignment;\n                }\n                else {\n                    newAssignment                              = draggedAssignment.copy();\n                    copiedAssignmentsMap[draggedAssignment.id] = newAssignment;\n                }\n                // Pro Engine does not seem to handle having the event already in place on the copied assignment,\n                // replacing it with id to have events bucket properly set up on commit\n                if (newAssignment.event && !useSingleAssignment) {\n                    newAssignment.event    = newAssignment.event.id;\n                    newAssignment.resource = newAssignment.resource.id;\n                }\n                if (!copy) {\n                    // If we're not copying, remove assignment from source scheduler\n                    assignmentsToRemove.push(draggedAssignment);\n                }\n                // If it was the last assignment, the event should also be removed\n                if (!keepEvent) {\n                    eventsToRemove.push(originalEventRecord);\n                }\n                // If event does not already exist in target scheduler a copy is added\n                // if we're copying the event, we always need to create new record\n                if (\n                    copy && (copyMode === 'event' || (copyMode === 'auto' && toEventStore.usesSingleAssignment)) ||\n                    !toEventStore.getById(originalEventRecord.id)\n                ) {\n                    draggedEvent = toEventStore.createRecord({\n                        ...originalEventRecord.data,\n                        children : originalEventRecord.children?.map(child => child.copy()),\n                        // If we're copying the event (not making new assignment to existing), we need to generate\n                        // phantom id to link event to the assignment record\n                        id       : copy && (copyMode === 'event' || copyMode === 'auto') ? undefined : originalEventRecord.id,\n                        // Engine gets mad if not nulled\n                        calendar : null\n                    });\n                    newAssignment.set({\n                        eventId : draggedEvent.id,\n                        event   : draggedEvent\n                    });\n                    eventsToAdd.push(draggedEvent);\n                }\n                // And add it to the target scheduler\n                if (!useSingleAssignment) {\n                    assignmentsToAdd.push(newAssignment);\n                }\n                draggedAssignment = newAssignment;\n            }\n            let newResource    = toResource,\n                reassignedFrom = null;\n            if (!unifiedDrag) {\n                newResource = me.getNewResource(context, originalResourceRecord, indexDiff) || toResource;\n            }\n            const isCrossResource = draggedAssignment.resourceId !== newResource.$original.id;\n            // Cannot rely on assignment generation to detect update, since it might be a new assignment\n            if (isCrossResource) {\n                reassignedFrom = fromResourceStore.getById(draggedAssignment.resourceId);\n                if (copy && fromAssignmentStore === toAssignmentStore) {\n                    // Scheduler Core patch\n                    // need to completely clear the resource/resourceId on the copied assignment, before setting the new\n                    // otherwise, what happens is that in the `$beforeChange.resource/Id` are still\n                    // stored the resource/Id of the original assignment\n                    // then, when finalizing commit, Core engine performs this:\n                    //     // First silently revert any data change (used by buckets), otherwise it won't be detected by `set()`\n                    //     me.setData(me.$beforeChange)\n                    // and then updates the data to new, which is recorded as UpdateAction in the STM with old/new data\n                    // then, when that update action in STM is undo-ed, the old data is written back to the record\n                    // and newly added assignment is pointing to the old resource\n                    // then, when STM action is redo-ed, a \"duplicate assignment\" exception is thrown\n                    // this is covered with the test:\n                    // Scheduler/tests/features/EventDragCopy.t.js -> Should not remove the original when undo-ing the copy-drag action (\"multi-assignment\")\n                    draggedAssignment.setData({\n                        resource   : null,\n                        resourceId : null\n                    });\n                    // eof Scheduler Core patch\n                    draggedAssignment.resource = newResource;\n                    draggedAssignment.event    = toEventStore.getById(draggedAssignment.eventId);\n                    const shouldCopyEvent = copyMode === 'event' || (fromEventStore.usesSingleAssignment && copyMode === 'auto');\n                    if (shouldCopyEvent) {\n                        draggedEvent = draggedEvent.copy();\n                        // need to clear the `endDate` of the copy\n                        // this is because when we drag the copy to a different position on the timeline\n                        // it will set the new start date and re-calculate end date\n                        // as a result, in STM transaction for this drag-copy there will be \"add\" action\n                        // and \"update\" action and NO COMMIT in the middle\n                        // so when re-doing this transaction the duration change is lost\n                        // this is covered with the test:\n                        // \"Scheduler/tests/features/EventDragCopy.t.js -> Should not remove the original when undo-ing the copy-drag action (usesSingleAssignment)\",\n                        // Before doing it, save a copy of endDate in meta object, considering timeDiff: that's because below it will check if event is in timeAxis.\n                        draggedEvent.meta.endDateCached = me.adjustStartDate(draggedEvent.endDate, timeDiff);\n                        draggedEvent.endDate = null;\n                        draggedAssignment.event = draggedEvent;\n                        if (toEventStore.usesSingleAssignment) {\n                            draggedEvent.resource   = newResource;\n                            draggedEvent.resourceId = newResource.id;\n                        }\n                    }\n                    if (\n                        !toAssignmentStore.find(a => a.eventId === draggedAssignment.eventId && a.resourceId === draggedAssignment.resourceId) &&\n                        !assignmentsToAdd.find(r => r.eventId === draggedAssignment.eventId && r.resourceId === draggedAssignment.resourceId)\n                    ) {\n                        shouldCopyEvent && eventsToAdd.push(draggedEvent);\n                        assignmentsToAdd.push(draggedAssignment);\n                    }\n                }\n                else {\n                    draggedAssignment.resource = newResource;\n                }\n                // Actual events should be batched, not data for new events when dragging between\n                draggedEvent.isEvent && eventsToBatch.add(draggedEvent);\n                updated = true;\n                // When dragging an occurrence, the assignment is only temporary. We have to tag the newResource along\n                // to be picked up by the occurrence -> event conversion\n                if (draggedEvent.isOccurrence) {\n                    draggedEvent.set('newResource', newResource);\n                }\n                if (isCrossScheduler && useSingleAssignment) {\n                    // In single assignment mode, when dragged to another scheduler it will not copy the assignment\n                    // over but instead set the resourceId of the event. To better match expected behaviour\n                    draggedEvent.resourceId = newResource.id;\n                }\n            }\n            else {\n                if (\n                    copy &&\n                    (copyMode === 'event' || (copyMode === 'auto' && fromEventStore.usesSingleAssignment)) &&\n                    !eventsToAdd.includes(draggedEvent)\n                ) {\n                    draggedEvent = draggedEvent.copy();\n                    // see the comment above\n                    draggedEvent.meta.endDateCached = me.adjustStartDate(draggedEvent.endDate, timeDiff);\n                    draggedEvent.endDate = null;\n                    eventsToAdd.push(draggedEvent);\n                    draggedAssignment.event = draggedEvent;\n                    if (toEventStore.usesSingleAssignment) {\n                        draggedEvent.set({\n                            resource   : newResource,\n                            resourceId : newResource.id\n                        });\n                    }\n                    // Always add assignment to the store to allow proper element reuse\n                    assignmentsToAdd.push(draggedAssignment);\n                }\n            }\n            // Same for event\n            if (!eventsToCheck.find(ev => ev.draggedEvent === draggedEvent) && !DateHelper.isEqual(draggedEvent.startDate, newStartDate)) {\n                // only do for non occurence records\n                while (!draggedEvent.isOccurrence && draggedEvent.isBatchUpdating) {\n                    draggedEvent.endBatch(true);\n                }\n                // for same scheduler with multi-assignments, and copyMode === assignment, need to keep the start date\n                // because user intention is to create a new assignment, not re-schedule the event\n                // but only for cross-resource dragging, same resource dragging has semantic of regular drag\n                const shouldKeepStartDate = copy && !isCrossScheduler && !useSingleAssignment && effectiveCopyMode === 'assignment' && isCrossResource;\n                if (!shouldKeepStartDate) {\n                    draggedEvent.startDate = newStartDate;\n                    eventsToCheck.push({ draggedEvent, originalStartDate });\n                }\n                draggedEvent.isEvent && eventsToBatch.add(draggedEvent);\n                updatedEvent = true;\n            }\n            // Hook for features that need to do additional processing on drop (used by NestedEvents)\n            toScheduler.processEventDrop({\n                eventRecord    : draggedEvent,\n                resourceRecord : newResource,\n                element        : i === 0 ? context.context.element : context.context.relatedElements[i - 1],\n                context,\n                toScheduler,\n                reassignedFrom,\n                eventsToAdd,\n                addedEvents,\n                draggedAssignment\n            });\n            // There are two cases to consider when triggering this event - `copy` and `move` mode. In case we are\n            // copying the assignment (we can also copy the event) draggedAssignment will point to the copy of the\n            // original assignment record. Same for draggedEvent. These records are new records which are not yet added\n            // to the store and they contain correct state of the drop - which event is going to be assigned to which\n            // resource on what time.\n            // These records possess no knowledge about original records which they were cloned from. And that might be\n            // useful. Let's say you want to copy assignment (or event) to every row in the way. You need to know start\n            // row and the end row. That information is kept in the `originalAssignment` record. Which might be identical\n            // to the `draggedAssignment` record in `move` mode.\n            toScheduler.trigger('processEventDrop', {\n                originalAssignment,\n                draggedAssignment,\n                context,\n                copyMode,\n                isCopy : copy\n            });\n        }\n        fromAssignmentStore.remove(assignmentsToRemove);\n        fromEventStore.remove(eventsToRemove);\n        toAssignmentStore.add(assignmentsToAdd);\n        // Modify syncIdMap on the FGCanvas to make sure elements get animated nicely to new position\n        if (copy && fromAssignmentStore === toAssignmentStore) {\n            const { syncIdMap } = fromScheduler.foregroundCanvas;\n            Object.entries(copiedAssignmentsMap).forEach(([originalId, cloneRecord]) => {\n                const element = syncIdMap[originalId];\n                delete syncIdMap[originalId];\n                syncIdMap[cloneRecord.id] = element;\n            });\n        }\n        eventsToAdd.length && addedEvents.push(...toEventStore.add(eventsToAdd));\n        addedEvents?.forEach(added => eventsToBatch.add(added));\n        // addedEvents order is the same with [context.element, ..context.relatedElements]\n        // Any added or removed events or assignments => something changed\n        if (assignmentsToRemove.length || eventsToRemove.length || assignmentsToAdd.length || eventsToAdd.length) {\n            updated = true;\n        }\n        // Commit changes to affected projects\n        if (updated || updatedEvent) {\n            // By batching event changes when using single assignment we avoid two updates, without it there will be one\n            // for date change and one when changed assignment updates resourceId on the event\n            useSingleAssignment && eventsToBatch.forEach(eventRecord => eventRecord.beginBatch());\n            await Promise.all([\n                toScheduler.project !== fromScheduler.project ? toScheduler.project.commitAsync() : null,\n                fromScheduler.project.commitAsync()\n            ]);\n            // End batch in engine friendly way, avoiding to have `set()` trigger another round of calculations\n            useSingleAssignment && eventsToBatch.forEach(eventRecord => eventRecord.endBatch(false, true));\n        }\n        if (!updated) {\n            // Engine might have reverted the date change, in which case this should be considered an invalid op\n            updated = eventsToCheck.some(({ draggedEvent, originalStartDate }) =>\n                !DateHelper.isEqual(draggedEvent.startDate, originalStartDate)\n            );\n        }\n        // When not constrained to timeline we are dragging a clone and need to manually do some cleanup if\n        // dropped in view, but only for valid drops\n        if (!me.constrainDragToTimeline && updated) {\n            // go through assignmentRecords again after events has been added to toEventStore (if any)\n            // now we have updated assignment ids and can properly reuse event HTML elements\n            for (let i = 0; i < assignmentRecords.length; i++) {\n                const\n                    assignmentRecord     = copiedAssignmentsMap[assignmentRecords[i].id] || assignmentRecords[i],\n                    originalDraggedEvent = assignmentRecord.event,\n                    // try to get dragged event from addedEvents array, it will be there with updated ids\n                    // if toScheduler is different\n                    draggedEvent         = addedEvents?.find(r => r.id === originalDraggedEvent.id) || originalDraggedEvent,\n                    eventBar             = context.eventBarEls[i],\n                    element              = i === 0 ? context.context.element : context.context.relatedElements[i - 1],\n                    // Determine if in time axis here also, since the records date might be invalidated further below\n                    inTimeAxis           = toScheduler.isInTimeAxis(draggedEvent);\n                // after checking if is in time axis, imeta.endDateCached can be deleted\n                delete draggedEvent.meta.endDateCached;\n                if (!copy) {\n                    // Remove original element properly\n                    DomSync.removeChild(eventBar.parentElement, eventBar);\n                }\n                if (draggedEvent.resource && (isVertical || toScheduler.rowManager.getRowFor(draggedEvent.resource)) && inTimeAxis) {\n                    // Nested events are added to correct parent by the feature\n                    if (!draggedEvent.parent || draggedEvent.parent.isRoot) {\n                        const elRect = Rectangle.from(element, toScheduler.foregroundCanvas, true);\n                        // Ensure that after inserting the dragged element clone into the toScheduler's foregroundCanvas\n                        // it's at the same visual position that it was dragged to.\n                        DomHelper.setTopLeft(element, elRect.y, elRect.x);\n                        // Add element properly, so that DomSync will reuse it on next update\n                        DomSync.addChild(toScheduler.foregroundCanvas, element, draggedEvent.assignments[0].id);\n                        isCrossScheduler && toScheduler.processCrossSchedulerEventDrop({\n                            eventRecord : draggedEvent,\n                            toScheduler\n                        });\n                    }\n                    element.classList.remove('b-sch-event-hover', 'b-active', 'b-drag-proxy', 'b-dragging');\n                    element.retainElement = false;\n                }\n            }\n        }\n        // Resumes self twice if not cross scheduler, but was suspended twice above also so all good\n        toScheduler.resumeRefresh(false);\n        fromScheduler.resumeRefresh(false);\n        if (assignmentRecords.length > 0) {\n            if (!updated) {\n                context.valid = false;\n            }\n            else {\n                // Always force re-render of the bars, to return them to their original position when:\n                // * Fill ticks leading to small date adjustment not actually changing the DOM\n                //   (https://github.com/bryntum/support/issues/630)\n                // * Dragging straight down with multiselection, events in the last resource will still be assigned to\n                //   that resource = no change in the DOM (https://github.com/bryntum/support/issues/6293)\n                eventBarEls.forEach(el => delete el.lastDomConfig);\n                // Not doing full refresh above, to allow for animations\n                toScheduler.refreshWithTransition();\n                if (isCrossScheduler) {\n                    fromScheduler.refreshWithTransition();\n                    toScheduler.selectedEvents = addedEvents;\n                }\n            }\n        }\n    }\n    //endregion\n    //region Drag data\n    getProductDragContext(dragData) {\n        const\n            me                                = this,\n            { currentOverClient : scheduler } = me,\n            target                            = dragData.browserEvent.target,\n            previousResolvedResource          = dragData.newResource || dragData.resourceRecord,\n            previousTargetEventRecord         = dragData.targetEventRecord;\n        let\n            targetEventRecord = scheduler ? me.resolveEventRecord(target, scheduler) : null,\n            newResource, externalDropTarget;\n        // Ignore if over dragged event\n        if (dragData.eventRecords.includes(targetEventRecord)) {\n            targetEventRecord = null;\n        }\n        if (me.constrainDragToResource) {\n            newResource = dragData.resourceRecord;\n        }\n        else if (!me.constrainDragToTimeline) {\n            newResource = me.resolveResource();\n        }\n        else if (scheduler) {\n            newResource = me.resolveResource() || dragData.newResource || dragData.resourceRecord;\n        }\n        const\n            { assignmentRecords, eventRecords } = dragData,\n            isOverNewResource                   = previousResolvedResource !== newResource;\n        let valid = Boolean(newResource && !newResource.isSpecialRow);\n        if (!newResource && me.externalDropTargetSelector) {\n            externalDropTarget = target.closest(me.externalDropTargetSelector);\n            valid              = Boolean(externalDropTarget);\n        }\n        return {\n            valid,\n            externalDropTarget,\n            eventRecords,\n            assignmentRecords,\n            newResource,\n            targetEventRecord,\n            dirty         : isOverNewResource || targetEventRecord !== previousTargetEventRecord,\n            proxyElements : [dragData.context.element, ...dragData.context.relatedElements || []]\n        };\n    }\n    getMinimalDragData(info) {\n        const\n            me                = this,\n            { scheduler }     = me,\n            element           = me.getElementFromContext(info),\n            eventRecord       = me.resolveEventRecord(element, scheduler),\n            resourceRecord    = scheduler.resolveResourceRecord(element),\n            assignmentRecord  = scheduler.resolveAssignmentRecord(element),\n            assignmentRecords = assignmentRecord ? [assignmentRecord] : [];\n        // We multi drag other selected events if the dragged event is already selected, or the ctrl key is pressed\n        if (assignmentRecord && (scheduler.isAssignmentSelected(assignmentRecords[0]) || (me.drag.startEvent.ctrlKey && scheduler.multiEventSelect))) {\n            assignmentRecords.push.apply(assignmentRecords, me.getRelatedRecords(assignmentRecord));\n        }\n        const eventRecords = [...new Set(assignmentRecords.map(assignment => assignment.event))];\n        return {\n            eventRecord,\n            resourceRecord,\n            assignmentRecord,\n            eventRecords,\n            assignmentRecords\n        };\n    }\n    setupProductDragData(info) {\n        const\n            me            = this,\n            { scheduler } = me,\n            element       = me.getElementFromContext(info),\n            {\n                eventRecord,\n                resourceRecord,\n                assignmentRecord,\n                assignmentRecords\n            }             = me.getMinimalDragData(info),\n            eventBarEls   = [];\n        if (me.constrainDragToResource && !resourceRecord) {\n            throw new Error('Resource could not be resolved for event: ' + eventRecord.id);\n        }\n        let dateConstraints;\n        if (me.constrainDragToTimeline) {\n            dateConstraints = me.getDateConstraints?.(resourceRecord, eventRecord);\n            const\n                constrainRectangle = me.constrainRectangle = me.getConstrainingRectangle(dateConstraints, resourceRecord, eventRecord),\n                eventRegion        = Rectangle.from(element, scheduler.timeAxisSubGridElement);\n            super.setupConstraints(\n                constrainRectangle,\n                eventRegion,\n                scheduler.timeAxisViewModel.snapPixelAmount,\n                Boolean(dateConstraints.start)\n            );\n        }\n        // Collecting all elements to drag\n        assignmentRecords.forEach(assignment => {\n            let eventBarEl = scheduler.getElementFromAssignmentRecord(assignment, true);\n            if (!eventBarEl) {\n                eventBarEl = scheduler.currentOrientation.addTemporaryDragElement(assignment.event, assignment.resource);\n            }\n            eventBarEls.push(eventBarEl);\n        });\n        return {\n            record          : assignmentRecord,\n            draggedEntities : assignmentRecords,\n            dateConstraints : dateConstraints?.start ? dateConstraints : null,\n            // Create copies of the elements\n            eventBarCopies  : eventBarEls.map(el => me.createProxy(el)),\n            eventBarEls\n        };\n    }\n    getDateConstraints(resourceRecord, eventRecord) {\n        const\n            { scheduler }           = this,\n            externalDateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord);\n        let minDate, maxDate;\n        if (this.constrainDragToTimeSlot) {\n            minDate = eventRecord.startDate;\n            maxDate = eventRecord.endDate;\n        }\n        else if (externalDateConstraints) {\n            minDate = externalDateConstraints.start;\n            maxDate = externalDateConstraints.end;\n        }\n        return {\n            start : minDate,\n            end   : maxDate\n        };\n    }\n    getConstrainingRectangle(dateRange, resourceRecord, eventRecord) {\n        return this.scheduler.getScheduleRegion(this.constrainDragToResource && resourceRecord, eventRecord, true, dateRange && {\n            start : dateRange.start, end : dateRange.end\n        });\n    }\n    /**\n     * Initializes drag data (dates, constraints, dragged events etc). Called when drag starts.\n     * @private\n     * @param info\n     * @returns {*}\n     */\n    getDragData(info) {\n        const dragData = this.getMinimalDragData(info) || {};\n        return {\n            ...super.getDragData(info),\n            ...dragData,\n            initialAssignmentsState : dragData.assignmentRecords.map(assignment => ({\n                startDate : assignment.event.startDate,\n                resource  : assignment.resource,\n                assignment\n            }))\n        };\n    }\n    /**\n     * Provide your custom implementation of this to allow additional selected records to be dragged together with the original one.\n     * @param {Scheduler.model.AssignmentModel} assignmentRecord The assignment about to be dragged\n     * @returns {Scheduler.model.AssignmentModel[]} An array of assignment records to drag together with the original\n     */\n    getRelatedRecords(assignmentRecord) {\n        return this.scheduler.selectedAssignments.filter(selectedRecord => selectedRecord !== assignmentRecord && !selectedRecord.resource.readOnly && selectedRecord.event.isDraggable);\n    }\n    /**\n     * Get correct axis coordinate depending on schedulers mode (horizontal -> x, vertical -> y). Also takes milestone\n     * layout into account.\n     * @private\n     * @param {Scheduler.model.EventModel} eventRecord Record being dragged\n     * @param {HTMLElement} element Element being dragged\n     * @param {Number[]} coord XY coordinates\n     * @returns {Number|Number[]} X,Y or XY\n     */\n    getCoordinate(eventRecord, element, coord) {\n        const scheduler = this.currentOverClient;\n        if (scheduler.isHorizontal) {\n            let x = coord[0];\n            // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events\n            if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {\n                switch (scheduler.milestoneAlign) {\n                    case 'center':\n                        x += element.offsetWidth / 2;\n                        break;\n                    case 'end':\n                        x += element.offsetWidth;\n                        break;\n                }\n            }\n            return x;\n        }\n        else {\n            let y = coord[1];\n            // Adjust coordinate for milestones if using a layout mode, since they are aligned differently than events\n            if (scheduler.milestoneLayoutMode !== 'default' && eventRecord.isMilestone) {\n                switch (scheduler.milestoneAlign) {\n                    case 'center':\n                        y += element.offsetHeight / 2;\n                        break;\n                    case 'end':\n                        y += element.offsetHeight;\n                        break;\n                }\n            }\n            return y;\n        }\n    }\n    /**\n     * Get resource record occluded by the drag proxy.\n     * @private\n     * @returns {Scheduler.model.ResourceModel}\n     */\n    resolveResource() {\n        const\n            me                 = this,\n            client             = me.currentOverClient,\n            { isHorizontal }   = client,\n            {\n                context,\n                browserEvent,\n                dragProxy\n            }                  = me.dragData,\n            element            = dragProxy || context.element,\n            // Page coords for elementFromPoint\n            pageRect           = Rectangle.from(element, null, true),\n            y                  = (client.isVertical || me.unifiedDrag) ? context.clientY : pageRect.center.y,\n            // Local coords to resolve resource in vertical\n            localRect          = Rectangle.from(element, client.timeAxisSubGridElement, true),\n            { x : lx, y : ly } = localRect.center,\n            eventTarget        = me.getMouseMoveEventTarget(browserEvent);\n        let resource = null;\n        if (client.element.contains(eventTarget)) {\n            // This is benchmarked as the fastest way to find a Grid Row from a viewport Y coordinate\n            // so use it in preference to elementFromPoint (which causes a forced synchronous layout) in horizontal mode.\n            if (isHorizontal) {\n                const row = client.rowManager.getRowAt(y);\n                resource = row && client.store.getAt(row.dataIndex);\n            }\n            else {\n                // In vertical mode, just use the X coordinate to find out which resource we are under.\n                // The method requires that a .b-sch-timeaxis-cell element be passed.\n                // There is only one in vertical mode, so use that.\n                resource = client.resolveResourceRecord(client.timeAxisSubGridElement.querySelector('.b-sch-timeaxis-cell'), [lx, ly]);\n            }\n        }\n        return resource?.$original;\n    }\n    //endregion\n    //region Other stuff\n    adjustStartDate(startDate, timeDiff) {\n        const\n            scheduler = this.currentOverClient;\n        startDate = scheduler.timeAxis.roundDate(new Date(startDate - 0 + timeDiff), scheduler.snapRelativeToEventStartDate ? startDate : false);\n        return this.constrainStartDate(startDate);\n    }\n    getRecordElement(assignmentRecord) {\n        return this.client.getElementFromAssignmentRecord(assignmentRecord, true);\n    }\n    // Used by the Dependencies feature to draw lines to the drag proxy instead of the original event element\n    getProxyElement(assignmentRecord) {\n        const { dragData } = this;\n        if (this.isDragging && dragData.proxyElements?.length) {\n            const index = dragData.assignmentRecords.indexOf(assignmentRecord);\n            if (index >= 0) {\n                return dragData.proxyElements[index];\n            }\n        }\n        return null;\n    }\n    //endregion\n    //#region Salesforce hooks\n    getMouseMoveEventTarget(event) {\n        return event.target;\n    }\n    //#endregion\n}\nEventDrag._$name = 'EventDrag'; GridFeatureManager.registerFeature(EventDrag, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventDrag, false, 'ResourceHistogram');\n", "import DragCreateBase from './base/DragCreateBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport ObjectHelper from '../../Core/helper/ObjectHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\n/**\n * @module Scheduler/feature/EventDragCreate\n */\n/**\n * Feature that allows the user to create new events by dragging in empty parts of the scheduler rows.\n *\n * {@inlineexample Scheduler/feature/EventDragCreate.js}\n *\n * This feature is **enabled** by default.\n *\n * <div class=\"note\">Incompatible with the {@link Scheduler.feature.EventDragSelect EventDragSelect} and\n * {@link Scheduler.feature.Pan Pan} features. If either of those features are enabled, this feature has no effect.\n * </div>\n *\n * ## Conditionally preventing drag creation\n *\n * To conditionally prevent drag creation for a certain resource or a certain timespan, you listen for the\n * {@link #event-beforeDragCreate} event, add your custom logic to it and return `false` to prevent the operation\n * from starting. For example to not allow drag creation on the topmost resource:\n *\n * ```javascript\n * const scheduler = new Scheduler({\n *     listeners : {\n *         beforeDragCreate({ resource }) {\n *             // Prevent drag creating on the topmost resource\n *             if (resource === scheduler.resourceStore.first) {\n *                 return false;\n *             }\n *         }\n *     }\n * });\n * ```\n *\n * @extends Scheduler/feature/base/DragCreateBase\n * @demo Scheduler/basic\n * @classtype eventDragCreate\n * @feature\n */\nexport default class EventDragCreate extends DragCreateBase {\n    //region Config\n    static $name = 'EventDragCreate';\n    static configurable = {\n        /**\n         * Locks the layout during drag create, overriding the default behaviour that uses the same rendering\n         * pathway for drag creation as for already existing events.\n         *\n         * This more closely resembles the behaviour of versions prior to 4.2.0.\n         *\n         * @config {Boolean} lockLayout\n         * @default false\n         */\n        /**\n         * An empty function by default, but provided so that you can perform custom validation on the event being\n         * created. Return `true` if the new event is valid, `false` to prevent an event being created.\n         * @param {Object} context A drag create context\n         * @param {Date} context.startDate Event start date\n         * @param {Date} context.endDate Event end date\n         * @param {Scheduler.model.EventModel} context.record Event record\n         * @param {Scheduler.model.ResourceModel} context.resourceRecord Resource record\n         * @param {Event} event The event object\n         * @returns {Boolean} `true` if this validation passes\n         * @config {Function}\n         */\n        validatorFn : () => true\n    };\n    //endregion\n    //region Events\n    /**\n     * Fires on the owning Scheduler after the new event has been created.\n     * @event dragCreateEnd\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The new `EventModel` record.\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource for the row in which the event is being\n     * created.\n     * @param {MouseEvent} event The ending mouseup event.\n     * @param {HTMLElement} eventElement The DOM element representing the newly created event un the UI.\n     */\n    /**\n     * Fires on the owning Scheduler at the beginning of the drag gesture. Returning `false` from a listener prevents\n     * the drag create operation from starting.\n     *\n     * ```javascript\n     * const scheduler = new Scheduler({\n     *     listeners : {\n     *         beforeDragCreate({ date }) {\n     *             // Prevent drag creating events in the past\n     *             return date >= Date.now();\n     *         }\n     *     }\n     * });\n     * ```\n     *\n     * @event beforeDragCreate\n     * @on-owner\n     * @preventable\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.ResourceModel} resourceRecord\n     * @param {Date} date The datetime associated with the drag start point.\n     */\n    /**\n     * Fires on the owning Scheduler after the drag start has created a new Event record.\n     * @event dragCreateStart\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the new event.\n     */\n    /**\n     * Fires on the owning Scheduler to allow implementer to prevent immediate finalization by setting\n     * `data.context.async = true` in the listener, to show a confirmation popup etc\n     * ```javascript\n     *  scheduler.on('beforedragcreatefinalize', ({context}) => {\n     *      context.async = true;\n     *      setTimeout(() => {\n     *          // async code don't forget to call finalize\n     *          context.finalize();\n     *      }, 1000);\n     *  })\n     * ```\n     * @event beforeDragCreateFinalize\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source Scheduler instance\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the new Event record\n     * @param {Object} context\n     * @param {Boolean} context.async Set true to handle drag create asynchronously (e.g. to wait for user\n     * confirmation)\n     * @param {Function} context.finalize Call this method to finalize drag create. This method accepts one\n     * argument: pass true to update records, or false, to ignore changes\n     */\n    /**\n     * Fires on the owning Scheduler at the end of the drag create gesture whether or not\n     * a new event was created by the gesture.\n     * @event afterDragCreate\n     * @on-owner\n     * @param {Scheduler.view.Scheduler} source\n     * @param {Scheduler.model.EventModel} eventRecord The event record being created\n     * @param {Scheduler.model.ResourceModel} resourceRecord The resource record\n     * @param {HTMLElement} eventElement The element representing the created event record\n     */\n    //endregion\n    //region Init\n    get scheduler() {\n        return this.client;\n    }\n    get store() {\n        return this.client.eventStore;\n    }\n    get project() {\n        return this.client.project;\n    }\n    updateLockLayout(lock) {\n        this.dragActiveCls = `b-dragcreating${lock ? ' b-dragcreate-lock' : ''}`;\n    }\n    //endregion\n    //region Scheduler specific implementation\n    handleBeforeDragCreate(drag, eventRecord, event) {\n        const { resourceRecord } = drag;\n        if (this.disabled || resourceRecord.readOnly || !this.scheduler.resourceStore.isAvailable(resourceRecord)) {\n            return false;\n        }\n        const\n            { scheduler }      = this,\n            // For resources with a calendar, ensure the date is inside a working time range\n            isWorkingTime      = !scheduler.isSchedulerPro || eventRecord.ignoreResourceCalendar || resourceRecord.isWorkingTime(drag.mousedownDate),\n            result             = isWorkingTime && scheduler.trigger('beforeDragCreate', {\n                resourceRecord,\n                date : drag.mousedownDate,\n                event\n            });\n        // Save date constraints\n        this.dateConstraints = scheduler.getDateConstraints?.(resourceRecord, eventRecord);\n        return result;\n    }\n    dragStart(drag) {\n        const\n            me               = this,\n            { client }       = me,\n            {\n                eventStore,\n                assignmentStore,\n                enableEventAnimations,\n                enableTransactionalFeatures\n            }                  = client,\n            { resourceRecord } = drag,\n            eventRecord        = me.createEventRecord(drag),\n            resourceRecords    = [resourceRecord];\n        eventRecord.set('duration', DateHelper.diff(eventRecord.startDate, eventRecord.endDate, eventRecord.durationUnit, true));\n        // It's only a provisional event until gesture is completed (possibly longer if an editor dialog is shown after)\n        eventRecord.isCreating = true;\n        // Flag used by rendering to not draw a zero length event being drag created as a milestone\n        eventRecord.meta.isDragCreating = true;\n        // force the transaction canceling in the taskeditor early\n        // this is because we are going to add a new event record to the store, and it has to be out of the\n        // task editor's stm transaction\n        // now there's a re-entrant protection in that method, so hopefully when it will be called by the\n        // editor itself that's ok\n        // `taskEdit === false` in some cases, so can't just use `?.` here\n        client.features.taskEdit && client.features.taskEdit.doCancel();\n        // This presents the event to be scheduled for validation at the proposed mouse/date point\n        // If rejected, we cancel operation\n        if (me.handleBeforeDragCreate(drag, eventRecord, drag.event) === false) {\n            return false;\n        }\n        // This is an async function which will start transaction asynchronously. This workflow expect transaction to\n        // be started ASAP\n        me.captureStm(true);\n        let assignmentRecords = [];\n        if (resourceRecord) {\n            if (eventStore.usesSingleAssignment || !enableTransactionalFeatures) {\n                assignmentRecords = assignmentStore.assignEventToResource(eventRecord, resourceRecord);\n            }\n            else {\n                // Do not add record to the store just yet, otherwise records would get to the STM queue assignment first,\n                // then event, which will break `store.added` bag after undo/redo.\n                assignmentRecords = [assignmentStore.createRecord({\n                    event    : eventRecord,\n                    resource : resourceRecord\n                })];\n            }\n        }\n        // Vetoable beforeEventAdd allows cancel of this operation\n        if (client.trigger('beforeEventAdd', { eventRecord, resourceRecords, assignmentRecords }) === false) {\n            if (eventStore.usesSingleAssignment || !enableTransactionalFeatures) {\n                assignmentStore.remove(assignmentRecords);\n            }\n            return false;\n        }\n        // When configured to lock layout during drag create, set a flag that HorizontalRendering will pick up to\n        // exclude the new event from the layout calculations. It will then be at the topmost position in the \"cell\"\n        if (me.lockLayout) {\n            eventRecord.meta.excludeFromLayout = true;\n        }\n        client.onEventCreated?.(eventRecord);\n        client.enableEventAnimations = false;\n        eventStore.addAsync(eventRecord).then(() => client.enableEventAnimations = enableEventAnimations);\n        if (!eventStore.usesSingleAssignment && enableTransactionalFeatures) {\n            // Add assignment after event only to keep STM transaction sane\n            assignmentStore.add(assignmentRecords[0]);\n        }\n        // Element must be created synchronously, not after the project's normalizing delays.\n        // Overrides the check for isEngineReady in VerticalRendering so that the newly added record\n        // will be rendered when we call refreshRows.\n        client.isCreating = true;\n        client.refreshRows();\n        client.isCreating = false;\n        // Set the element we are dragging\n        drag.itemElement = drag.element = client.getElementFromEventRecord(eventRecord);\n        // If the resource row is very tall, the event may have been rendered outside of the\n        // visible viewport. If so, scroll it into view.\n        if (!DomHelper.isInView(drag.itemElement)) {\n            client.scrollable.scrollIntoView(drag.itemElement, {\n                animate    : true,\n                edgeOffset : client.barMargin\n            });\n        }\n        return super.dragStart(drag);\n    }\n    checkValidity(context, event) {\n        const\n            me         = this,\n            { client } = me;\n        // Nicer for users of validatorFn\n        context.resourceRecord = me.dragging.resourceRecord;\n        return (\n            client.allowOverlap ||\n            client.isDateRangeAvailable(context.startDate, context.endDate, context.eventRecord, context.resourceRecord)\n        ) && me.createValidatorFn.call(me.validatorFnThisObj || me, context, event);\n    }\n    // Determine if resource already has events or not\n    isRowEmpty(resourceRecord) {\n        const events = this.store.getEventsForResource(resourceRecord);\n        return !events || !events.length;\n    }\n    //endregion\n    triggerBeforeFinalize(event) {\n        this.client.trigger(`beforeDragCreateFinalize`, event);\n    }\n    /**\n     * Creates an event by the event object coordinates\n     * @param {Object} drag The Bryntum event object\n     * @private\n     */\n    createEventRecord(drag) {\n        const\n            me          = this,\n            { client }  = me,\n            dimension   = client.isHorizontal ? 'X' : 'Y',\n            {\n                timeAxis,\n                eventStore,\n                weekStartDay\n            }           = client,\n            {\n                event,\n                mousedownDate\n            }           = drag,\n            draggingEnd = me.draggingEnd = event[`page${dimension}`] > drag.startEvent[`page${dimension}`],\n            eventConfig = {\n                name      : eventStore.modelClass.fieldMap.name.defaultValue || me.L('L{Object.newEvent}'),\n                startDate : draggingEnd ? DateHelper.floor(mousedownDate, timeAxis.resolution, null, weekStartDay) : mousedownDate,\n                endDate   : draggingEnd ? mousedownDate : DateHelper.ceil(mousedownDate, timeAxis.resolution, null, weekStartDay)\n            };\n        // if project model has been imported from Gantt, we have to define constraint data directly to correct\n        // auto-scheduling while dragCreate\n        if (client.project.isGanttProjectMixin) {\n            ObjectHelper.assign(eventConfig, {\n                constraintDate : eventConfig.startDate,\n                constraintType : 'startnoearlierthan'\n            });\n        }\n        return eventStore.createRecord(eventConfig);\n    }\n    async internalUpdateRecord(context, eventRecord) {\n        await super.internalUpdateRecord(context, eventRecord);\n        // Toggle isCreating after ending batch, to make sure assignments can become persistable\n        if (!this.client.hasEventEditor) {\n            context.eventRecord.isCreating = false;\n        }\n    }\n    async finalizeDragCreate(context) {\n        const { meta } = context.eventRecord;\n        // Remove the layout lock flag, event will jump into place as part of the finalization\n        meta.excludeFromLayout = false;\n        // Also allow new event to become a milestone now\n        meta.isDragCreating    = false;\n        const transferred = await super.finalizeDragCreate(context);\n        // if STM capture has NOT been transferred to the\n        // event editor, we need to finalize the STM transaction / release the capture\n        if (!transferred) {\n            await this.freeStm(true);\n        }\n        else {\n            // otherwise just freeing our capture\n            this.hasStmCapture = false;\n        }\n        return transferred;\n    }\n    async cancelDragCreate(context) {\n        await super.cancelDragCreate(context);\n        await this.freeStm(false);\n    }\n    getTipHtml(...args) {\n        const\n            html        = super.getTipHtml(...args),\n            { element } = this.tip;\n        element.classList.add('b-sch-dragcreate-tooltip');\n        element.classList.toggle('b-too-narrow', this.dragging.context.tooNarrow);\n        return html;\n    }\n    onAborted(context) {\n        const { eventRecord, resourceRecord } = context;\n        // The product this is being used in may not have resources.\n        this.store.unassignEventFromResource?.(eventRecord, resourceRecord);\n        this.store.remove(eventRecord);\n    }\n}\nEventDragCreate._$name = 'EventDragCreate'; GridFeatureManager.registerFeature(EventDragCreate, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventDragCreate, false, 'ResourceHistogram');\n", "import TooltipBase from './base/TooltipBase.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport StringHelper from '../../Core/helper/StringHelper.js';\nimport { parseAlign } from '../../Core/helper/util/Rectangle.js';\n/**\n * @module Scheduler/feature/EventTooltip\n */\n// Alignment offsets to clear any dependency terminals depending on whether\n// the tooltip is aligned top/bottom (1) or left/right (2) as parsed from the\n// align string by Rectangle's parseAlign\nconst\n    zeroOffset = [0, 0],\n    depOffset  = [\n        null, [0, 10], [10, 0]\n    ];\n/**\n * Displays a tooltip when hovering events. The template used to render the tooltip can be customized, see {@link #config-template}.\n * Config options are also applied to the tooltip shown, see {@link Core.widget.Tooltip} for available options.\n *\n * ## Showing local data\n * To show a basic \"local\" tooltip (with data available in the Event record) upon hover:\n * ```javascript\n * new Scheduler({\n *   features : {\n *     eventTooltip : {\n *         // Tooltip configs can be used here\n *         align : 'l-r' // Align left to right,\n *         // A custom HTML template\n *         template : data => `<dl>\n *           <dt>Assigned to:</dt>\n *              <dt>Time:</dt>\n *              <dd>\n *                  ${DateHelper.format(data.eventRecord.startDate, 'LT')} - ${DateHelper.format(data.eventRecord.endDate, 'LT')}\n *              </dd>\n *              ${data.eventRecord.get('note') ? `<dt>Note:</dt><dd>${data.eventRecord.note}</dd>` : ''}\n *\n *              ${data.eventRecord.get('image') ? `<dt>Image:</dt><dd><img class=\"image\" src=\"${data.eventRecord.get('image')}\"/></dd>` : ''}\n *          </dl>`\n *     }\n *   }\n * });\n * ```\n *\n * ## Showing remotely loaded data\n * Loading remote data into the event tooltip is easy. Simply use the {@link #config-template} and return a Promise which yields the content to show.\n * ```javascript\n * new Scheduler({\n *   features : {\n *     eventTooltip : {\n *        template : ({ eventRecord }) => AjaxHelper.get(`./fakeServer?name=${eventRecord.name}`).then(response => response.text())\n *     }\n *   }\n * });\n * ```\n *\n * This feature is **enabled** by default\n *\n * By default, the tooltip {@link Core.widget.Widget#config-scrollAction realigns on scroll}\n * meaning that it will stay aligned with its target should a scroll interaction make the target move.\n *\n * If this is causing performance issues in a Scheduler, such as if there are many dozens of events\n * visible, you can configure this feature with `scrollAction: 'hide'`. This feature's configuration is\n * applied to the tooltip, so that will mean that the tooltip will hide if its target is moved by a\n * scroll interaction.\n *\n * ## Keeping tooltip visible after mouse exits target element\n *\n * By default, a Tooltip is transient, and will {@link #function-hide} when the mouse leaves the target element.\n * Configure this feature with {@link #config-autoHide} set to `false` to make the Tooltip stay visible.\n *\n * {@inlineexample Scheduler/feature/EventTooltip.js}\n *\n * @demo Scheduler/basic\n *\n * @extends Scheduler/feature/base/TooltipBase\n * @classtype eventTooltip\n * @feature\n */\nexport default class EventTooltip extends TooltipBase {\n    //region Config\n    static get $name() {\n        return 'EventTooltip';\n    }\n    static get defaultConfig() {\n        return {\n            /**\n             * Set this value to `false` to keep Tooltip visible after mouse leaves the target element.\n             * @config {Boolean} autoHide\n             * @default true\n             */\n            /**\n             * A function which receives data about the event and returns a string,\n             * or a Promise yielding a string (for async tooltips), to be displayed in the tooltip.\n             * This method will be called with an object containing the fields below\n             *\n             * @config {Function} template\n             * @param {Scheduler.model.EventModel} data.eventRecord Hovered event record\n             * @param {Date} data.startDate Hovered event start date\n             * @param {Date} data.endDate Hovered event end date\n             * @param {String} data.startText Start text\n             * @param {String} data.endText End text\n             * @param {Core.widget.Tooltip} data.tip Current tooltip instance\n             * @param {String} data.startClockHtml Predefined HTML to show the start time\n             * @param {String} data.endClockHtml Predefined HTML to show the end time\n             * @returns {DomConfig|String|null}\n             *\n             * @category Rendering\n             */\n            template : data => `\n                ${data.eventRecord.name ? StringHelper.xss`<div class=\"b-sch-event-title\">${data.eventRecord.name}</div>` : ''}\n                ${data.startClockHtml}\n                ${data.endClockHtml}`,\n            cls : 'b-sch-event-tooltip',\n            monitorRecordUpdate : true,\n            /**\n             * Defines what to do if document is scrolled while the tooltip is visible.\n             *\n             * Valid values: \u00B4null\u00B4: do nothing, \u00B4hide\u00B4: hide the tooltip or \u00B4realign\u00B4: realign to the target if possible.\n             *\n             * @config {'hide'|'realign'|null}\n             * @default\n             */\n            scrollAction : 'hide'\n        };\n    }\n    /**\n     * The event which the tooltip feature has been activated for.\n     * @member {Scheduler.model.EventModel} eventRecord\n     * @readonly\n     */\n    //endregion\n    construct(client, config) {\n        super.construct(client, config);\n        if (typeof this.align === 'string') {\n            this.align = { align : this.align };\n        }\n    }\n    onInternalPaint({ firstPaint }) {\n        super.onInternalPaint(...arguments);\n        if (firstPaint) {\n            const\n                { dependencies } = this.client.features;\n            if (dependencies) {\n                this.tooltip.ion({\n                    beforeAlign({ source : tooltip, offset = zeroOffset }) {\n                        const\n                            { edgeAligned }   = parseAlign(tooltip.align.align),\n                            depTerminalOffset = (dependencies.disabled  || !dependencies.allowCreate) ? zeroOffset : depOffset[edgeAligned];\n                        // Add the spec's offset to the offset necessitated by dependency terminals\n                        arguments[0].offset = [\n                            offset[0] + depTerminalOffset[0],\n                            offset[1] + depTerminalOffset[1]\n                        ];\n                    }\n                });\n            }\n        }\n    }\n}\nEventTooltip._$name = 'EventTooltip'; GridFeatureManager.registerFeature(EventTooltip, true, 'Scheduler');\nGridFeatureManager.registerFeature(EventTooltip, false, 'ResourceHistogram');\n", "import InstancePlugin from '../../Core/mixin/InstancePlugin.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport DomSync from '../../Core/helper/DomSync.js';\n/**\n * @module Scheduler/feature/StickyEvents\n */\nconst zeroMargins = { width : 0, height : 0 };\n/**\n * This feature applies native `position: sticky` to event contents in horizontal mode, keeping the contents in view as\n * long as possible on scroll. For vertical mode it uses a programmatic solution to achieve the same result.\n *\n * Assign `eventRecord.stickyContents = false` to disable stickiness on a per event level (docs for\n * {@link Scheduler/model/EventModel#field-stickyContents}).\n *\n * This feature is **enabled** by default.\n *\n * ### Note\n * If a complex {@link Scheduler.view.Scheduler#config-eventRenderer} is used to create a DOM structure within the\n * `.b-sch-event-content` element, then application CSS will need to be written to cancel the stickiness on the\n * `.b-sch-event-content` element, and make some inner content element(s) sticky.\n *\n * @extends Core/mixin/InstancePlugin\n * @classtype stickyEvents\n * @feature\n */\nexport default class StickyEvents extends InstancePlugin {\n    static $name = 'StickyEvents';\n    static type = 'stickyEvents';\n    static pluginConfig = {\n        chain : ['onEventDataGenerated']\n    };\n    construct(scheduler, config) {\n        super.construct(scheduler, config);\n        if (scheduler.isVertical) {\n            this.toUpdate = new Set();\n            scheduler.ion({\n                scroll           : 'onSchedulerScroll',\n                horizontalScroll : 'onHorizontalScroll',\n                thisObj          : this,\n                prio             : 10000\n            });\n        }\n    }\n    onEventDataGenerated(renderData) {\n        if (this.client.isHorizontal) {\n            renderData.wrapperCls['b-disable-sticky'] = renderData.eventRecord.stickyContents === false;\n        }\n        else {\n            this.syncEventContentPosition(renderData, undefined, true);\n            this.updateStyles();\n        }\n    }\n    //region Vertical mode\n    onSchedulerScroll() {\n        if (!this.disabled) {\n            this.verticalSyncAllEventsContentPosition(this.client);\n        }\n    }\n    // Have to sync also on horizontal scroll, since we reuse elements and dom configs\n    onHorizontalScroll({ subGrid }) {\n        if (subGrid === this.client.timeAxisSubGrid) {\n            this.verticalSyncAllEventsContentPosition(this.client);\n        }\n    }\n    updateStyles() {\n        for (const { contentEl, style } of this.toUpdate) {\n            DomHelper.applyStyle(contentEl, style);\n        }\n        this.toUpdate.clear();\n    }\n    verticalSyncAllEventsContentPosition(scheduler) {\n        const { resourceMap } = scheduler.currentOrientation;\n        for (const eventsData of resourceMap.values()) {\n            for (const { renderData, elementConfig } of Object.values(eventsData)) {\n                const args = [renderData];\n                if (elementConfig && renderData.eventRecord.isResourceTimeRange) {\n                    args.push(elementConfig.children[0]);\n                }\n                this.syncEventContentPosition.apply(this, args);\n            }\n        }\n        this.toUpdate.size && this.updateStyles();\n    }\n    syncEventContentPosition(renderData, eventContent = renderData.eventContent, duringGeneration = false) {\n        if (\n            this.disabled ||\n            // Allow client disable stickiness for certain events\n            renderData.eventRecord.stickyContents === false\n        ) {\n            return;\n        }\n        const\n            { client }        = this,\n            {\n                eventRecord,\n                resourceRecord,\n                useEventBuffer,\n                bufferAfterWidth,\n                bufferBeforeWidth,\n                top,\n                height\n            }                 = renderData,\n            scrollPosition    = client.scrollable.y,\n            wrapperEl         = duringGeneration ? null : client.getElementFromEventRecord(eventRecord, resourceRecord, true),\n            contentEl         = wrapperEl && DomSync.getChild(wrapperEl, 'event.content'),\n            meta              = eventRecord.instanceMeta(client),\n            style             = typeof eventContent.style === 'string'\n                ? (eventContent.style = DomHelper.parseStyle(eventContent.style))\n                : eventContent.style || (eventContent.style = {});\n        // Do not process events being dragged\n        if (wrapperEl?.classList.contains('b-dragging')) {\n            return;\n        }\n        let start       = top,\n            contentSize = height,\n            end         = start + contentSize;\n        if (useEventBuffer) {\n            start += bufferBeforeWidth;\n            contentSize = contentSize - bufferBeforeWidth - bufferAfterWidth;\n            end = start + contentSize;\n        }\n        // Only process non-milestones that are partially out of view\n        if (start < scrollPosition && end >= scrollPosition && !eventRecord.isMilestone) {\n            const\n                contentWidth = contentEl?.offsetWidth,\n                justify      = contentEl?.parentNode && DomHelper.getStyleValue(contentEl.parentNode, 'justifyContent'),\n                c            = justify === 'center' ? (renderData.width - contentWidth) / 2 : 0,\n                eventStart   = start,\n                eventEnd     = eventStart + contentSize - 1;\n            // Only process non-milestone events. Milestones have no width.\n            // If there's no offsetWidth, it's still b-released, so we cannot measure it.\n            // If the event starts off the left edge, but its right edge is still visible,\n            // translate the contentEl to compensate. If not, undo any translation.\n            if ((!contentEl || contentWidth) && eventStart < scrollPosition && eventEnd >= scrollPosition) {\n                const\n                    edgeSizes = this.getEventContentMargins(contentEl),\n                    maxOffset = contentEl\n                        ? (contentSize - contentEl.offsetHeight - edgeSizes.height) - c\n                        : Number.MAX_SAFE_INTEGER,\n                    offset = Math.min(scrollPosition - eventStart, maxOffset - 2);\n                style.transform = offset > 0 ? `translateY(${offset}px)` : '';\n                meta.stuck = true;\n            }\n            else {\n                style.transform = '';\n                meta.stuck = false;\n            }\n            if (contentEl) {\n                this.toUpdate.add({\n                    contentEl,\n                    style\n                });\n            }\n        }\n        else if (contentEl && meta.stuck) {\n            style.transform = '';\n            meta.stuck = false;\n            this.toUpdate.add({\n                contentEl,\n                style\n            });\n        }\n    }\n    // Only measure the margins of an event's contentEl once\n    getEventContentMargins(contentEl) {\n        if (contentEl?.classList.contains('b-sch-event-content')) {\n            return DomHelper.getEdgeSize(contentEl, 'margin');\n        }\n        return zeroMargins;\n    }\n    //endregion\n    doDisable() {\n        super.doDisable(...arguments);\n        if (!this.isConfiguring) {\n            this.client.refreshWithTransition();\n        }\n    }\n}\nStickyEvents._$name = 'StickyEvents'; GridFeatureManager.registerFeature(StickyEvents, true, 'Scheduler');\nGridFeatureManager.registerFeature(StickyEvents, false, 'ResourceHistogram');\n", "import AbstractTimeRanges from './AbstractTimeRanges.js';\nimport GridFeatureManager from '../../Grid/feature/GridFeatureManager.js';\nimport DateHelper from '../../Core/helper/DateHelper.js';\nimport DomHelper from '../../Core/helper/DomHelper.js';\nimport Rectangle from '../../Core/helper/util/Rectangle.js';\nimport AttachToProjectMixin from '../data/mixin/AttachToProjectMixin.js';\nimport TimeSpan from '../model/TimeSpan.js';\n/**\n * @module Scheduler/feature/TimeRanges\n */\n/**\n * Feature that renders global ranges of time in the timeline. Use this feature to visualize a `range` like a 1 hr lunch\n * or some important point in time (a `line`, i.e. a range with 0 duration). This feature can also show a current time\n * indicator if you set {@link #config-showCurrentTimeLine} to true. To style the rendered elements, use the\n * {@link Scheduler.model.TimeSpan#field-cls cls} field of the `TimeSpan` class.\n *\n * {@inlineexample Scheduler/feature/TimeRanges.js}\n *\n * Each time range is represented by an instances of {@link Scheduler.model.TimeSpan}, held in a simple\n * {@link Core.data.Store}. The feature uses {@link Scheduler/model/ProjectModel#property-timeRangeStore} defined on the\n * project by default. The store's persisting/loading is handled by Crud Manager (if it's used by the component).\n *\n * Note that the feature uses virtualized rendering, only the currently visible ranges are available in the DOM.\n *\n * This feature is **disabled** by default.\n * For info on enabling it, see {@link Grid.view.mixin.GridFeatures}.\n *\n * ## Showing an icon in the time range header\n *\n * You can use Font Awesome icons easily (or set any other icon using CSS) by using the {@link Scheduler.model.TimeSpan#field-iconCls}\n * field. The JSON data below will show a flag icon:\n *\n * ```json\n * {\n *     \"id\"        : 5,\n *     \"iconCls\"   : \"b-fa b-fa-flag\",\n *     \"name\"      : \"v5.0\",\n *     \"startDate\" : \"2019-02-07 15:45\"\n * },\n * ```\n *\n * ## Recurring time ranges\n *\n * The feature supports recurring ranges in case the provided store and models\n * have {@link Scheduler/data/mixin/RecurringTimeSpansMixin} and {@link Scheduler/model/mixin/RecurringTimeSpan}\n * mixins applied:\n *\n * ```javascript\n * // We want to use recurring time ranges so we make a special model extending standard TimeSpan model with\n * // RecurringTimeSpan which adds recurrence support\n * class MyTimeRange extends RecurringTimeSpan(TimeSpan) {}\n *\n * // Define a new store extending standard Store with RecurringTimeSpansMixin mixin to add recurrence support to the\n * // store. This store will contain time ranges.\n * class MyTimeRangeStore extends RecurringTimeSpansMixin(Store) {\n *     static get defaultConfig() {\n *         return {\n *             // use our new MyResourceTimeRange model\n *             modelClass : MyTimeRange\n *         };\n *     }\n * };\n *\n * // Instantiate store for timeRanges using our new classes\n * const timeRangeStore = new MyTimeRangeStore({\n *     data : [{\n *         id             : 1,\n *         resourceId     : 'r1',\n *         startDate      : '2019-01-01T11:00',\n *         endDate        : '2019-01-01T13:00',\n *         name           : 'Lunch',\n *         // this time range should repeat every day\n *         recurrenceRule : 'FREQ=DAILY'\n *     }]\n * });\n *\n * const scheduler = new Scheduler({\n *     ...\n *     features : {\n *         timeRanges : true\n *     },\n *\n *     crudManager : {\n *         // store for \"timeRanges\" feature\n *         timeRangeStore\n *     }\n * });\n * ```\n *\n * @extends Scheduler/feature/AbstractTimeRanges\n * @classtype timeRanges\n * @feature\n * @demo Scheduler/timeranges\n */\nexport default class TimeRanges extends AbstractTimeRanges.mixin(AttachToProjectMixin) {\n    //region Config\n    static get $name() {\n        return 'TimeRanges';\n    }\n    static get defaultConfig() {\n        return {\n            store : true\n        };\n    }\n    static configurable = {\n        /**\n         * Store that holds the time ranges (using the {@link Scheduler.model.TimeSpan} model or subclass thereof).\n         * A store will be automatically created if none is specified.\n         * @config {Core.data.Store|StoreConfig}\n         * @category Misc\n         */\n        store : {\n            modelClass : TimeSpan\n        },\n        /**\n         * The interval (as amount of ms) defining how frequently the current timeline will be updated\n         * @config {Number}\n         * @default\n         * @category Misc\n         */\n        currentTimeLineUpdateInterval : 10000,\n        /**\n         * The date format to show in the header for the current time line (when {@link #config-showCurrentTimeLine} is configured).\n         * See {@link Core.helper.DateHelper} for the possible formats to use.\n         * @config {String}\n         * @default\n         * @category Common\n         */\n        currentDateFormat : 'HH:mm',\n        /**\n         * Show a line indicating current time. Either `true` or `false` or a {@link Scheduler.model.TimeSpan}\n         * configuration object to apply to this special time range (allowing you to provide a custom text):\n         *\n         * ```javascript\n         * showCurrentTimeLine : {\n         *     name : 'Now'\n         * }\n         * ```\n         *\n         * The line carries the CSS class name `b-sch-current-time`, and this may be used to add custom styling to it.\n         *\n         * @prp {Boolean|TimeSpanConfig}\n         * @default\n         * @category Common\n         */\n        showCurrentTimeLine : false\n    };\n    //endregion\n    //region Init & destroy\n    doDestroy() {\n        this.storeDetacher?.();\n        super.doDestroy();\n    }\n    /**\n     * Returns the TimeRanges which occur within the client Scheduler's time axis.\n     * @property {Scheduler.model.TimeSpan[]}\n     */\n    get timeRanges() {\n        const me        = this;\n        if (!me._timeRanges) {\n            const { store } = me;\n            let { records } = store;\n            if (store.recurringEvents) {\n                const {\n                    startDate,\n                    endDate\n                } = me.client.timeAxis;\n                records = records.flatMap(timeSpan => {\n                    // Collect occurrences for the recurring events in the record set\n                    if (timeSpan.isRecurring) {\n                        return timeSpan.getOccurrencesForDateRange(startDate, endDate);\n                    }\n                    return timeSpan;\n                });\n            }\n            if (me.currentTimeLine) {\n                // Avoid polluting store records\n                if (!store.recurringEvents) {\n                    records = records.slice();\n                }\n                records.push(me.currentTimeLine);\n            }\n            me._timeRanges = records;\n        }\n        return me._timeRanges;\n    }\n    //endregion\n    //region Current time line\n    attachToProject(project) {\n        super.attachToProject(project);\n        const me = this;\n        me.projectTimeZoneChangeDetacher?.();\n        if (me.showCurrentTimeLine) {\n            // Update currentTimeLine immediately after a time zone change\n            me.projectTimeZoneChangeDetacher = me.client.project?.ion({ timeZoneChange : () => me.updateCurrentTimeLine() });\n            // Update currentTimeLine if its already created\n            if (me.currentTimeLine) {\n                me.updateCurrentTimeLine();\n            }\n        }\n    }\n    initCurrentTimeLine() {\n        const me = this;\n        if (me.currentTimeLine || !me.showCurrentTimeLine) {\n            return;\n        }\n        const data = typeof me.showCurrentTimeLine === 'object' ? me.showCurrentTimeLine : {};\n        me.currentTimeLine = me.store.modelClass.new({\n            id  : 'currentTime', \n            cls : 'b-sch-current-time'\n        }, data);\n        me.currentTimeInterval = me.setInterval(() => me.updateCurrentTimeLine(), me.currentTimeLineUpdateInterval);\n        me._timeRanges = null;\n        me.updateCurrentTimeLine();\n    }\n    updateCurrentTimeLine() {\n        const\n            me                  = this,\n            { currentTimeLine } = me;\n        currentTimeLine.timeZone = me.project?.timeZone;\n        currentTimeLine.setLocalDate('startDate', new Date());\n        currentTimeLine.endDate = currentTimeLine.startDate;\n        if (!currentTimeLine.originalData.name) {\n            currentTimeLine.name = DateHelper.format(currentTimeLine.startDate, me.currentDateFormat);\n        }\n        me.renderRanges();\n    }\n    hideCurrentTimeLine() {\n        const me = this;\n        if (!me.currentTimeLine) {\n            return;\n        }\n        me.clearInterval(me.currentTimeInterval);\n        me.currentTimeLine = null;\n        me.refresh();\n    }\n    updateShowCurrentTimeLine(show) {\n        if (show) {\n            this.initCurrentTimeLine();\n        }\n        else {\n            this.hideCurrentTimeLine();\n        }\n    }\n    //endregion\n    //region Menu items\n    /**\n     * Adds a menu item to show/hide current time line.\n     * @param {Object} options Contains menu items and extra data retrieved from the menu target.\n     * @param {Grid.column.Column} options.column Column for which the menu will be shown\n     * @param {Object<String,MenuItemConfig|Boolean|null>} options.items A named object to describe menu items\n     * @internal\n     */\n    populateTimeAxisHeaderMenu({ items }) {\n        items.currentTimeLine = {\n            weight   : 400,\n            text     : this.L('L{showCurrentTimeLine}'),\n            checked  : this.currentTimeLine,\n            onToggle : ({ checked }) => {\n                if (!this.showCurrentTimeLine) {\n                    this.showCurrentTimeLine = checked;\n                }\n                else {\n                    this.updateShowCurrentTimeLine(checked);\n                }\n            }\n        };\n    }\n    //endregion\n    //region Store\n    attachToStore(store) {\n        const me = this;\n        let renderRanges = false;\n        // if we had some store assigned before we need to detach it\n        if (me.storeDetacher) {\n            me.storeDetacher();\n            // then we'll need to render ranges provided by the new store\n            renderRanges = true;\n        }\n        me.storeDetacher = store.ion({\n            change  : 'onStoreChange',\n            refresh : 'onStoreChange',\n            thisObj : me\n        });\n        me._timeRanges = null;\n        // render ranges if needed\n        renderRanges && me.renderRanges();\n    }\n    /**\n     * Returns the {@link Core.data.Store store} used by this feature\n     * @property {Core.data.Store}\n     * @category Misc\n     */\n    get store() {\n        return this.client.project.timeRangeStore;\n    }\n    updateStore(store) {\n        const\n            me          = this,\n            { client }  = me,\n            { project } = client;\n        store = project.timeRangeStore;\n        me.attachToStore(store);\n        // timeRanges can be set on scheduler/gantt, for convenience. Should only be processed by the TimeRanges and not\n        // any subclasses\n        if (client.timeRanges && !client._timeRangesExposed) {\n            store.add(client.timeRanges);\n            delete client.timeRanges;\n        }\n    }\n    // Called by ProjectConsumer after a new store is assigned at runtime\n    attachToTimeRangeStore(store) {\n        this.store = store;\n    }\n    resolveTimeRangeRecord(el) {\n        const id = el.closest(this.baseSelector).dataset.id;\n        if (id === 'currentTime') {\n            return this.currentTimeLine;\n        }\n        return this.store.getById(id);\n    }\n    onStoreChange({ type, action }) {\n        const me = this;\n        // Force re-evaluating of which ranges to consider for render\n        me._timeRanges = null;\n        // https://github.com/bryntum/support/issues/1398 - checking also if scheduler is visible to change elements\n        if (me.disabled || !me.client.isVisible || me.isConfiguring || (type === 'refresh' && action !== 'batch')) {\n            return;\n        }\n        me.client.runWithTransition(() => me.renderRanges(), !me.client.refreshSuspended);\n    }\n    //endregion\n    //region Drag\n    onDragStart(event) {\n        const\n            me                = this,\n            { context }       = event,\n            record            = me.resolveTimeRangeRecord(context.element.closest(me.baseSelector)),\n            rangeBodyEl       = me.getBodyElementByRecord(record);\n        context.relatedElements = [rangeBodyEl];\n        Object.assign(context, {\n            record,\n            rangeBodyEl,\n            originRangeX : DomHelper.getTranslateX(rangeBodyEl),\n            originRangeY : DomHelper.getTranslateY(rangeBodyEl)\n        });\n        super.onDragStart(event);\n        me.showTip(context);\n    }\n    onDrop(event) {\n        const { context } = event;\n        if (!context.valid) {\n            return this.onInvalidDrop({ context });\n        }\n        const\n            me          = this,\n            { client }  = me,\n            { record }  = context,\n            box         = Rectangle.from(context.rangeBodyEl),\n            newStart    = client.getDateFromCoordinate(box.getStart(client.rtl, client.isHorizontal), 'round', false),\n            wasModified = (record.startDate - newStart !== 0);\n        if (wasModified) {\n            record.setStartDate(newStart);\n        }\n        else {\n            me.drag.abort();\n        }\n        me.destroyTip();\n        super.onDrop(event);\n    }\n    //endregion\n    //region Resize\n    onResizeStart({ context }) {\n        const\n            me          = this,\n            record      = me.resolveTimeRangeRecord(context.element.closest(me.baseSelector)),\n            rangeBodyEl = me.getBodyElementByRecord(record);\n        Object.assign(context, {\n            record,\n            rangeBodyEl\n        });\n        me.showTip(context);\n        super.onResizeStart(...arguments);\n    }\n    onResizeDrag({ context }) {\n        const\n            me              = this,\n            { rangeBodyEl } = context,\n            { client }      = me,\n            box             = Rectangle.from(context.element),\n            startPos        = box.getStart(client.rtl, client.isHorizontal),\n            endPos          = box.getEnd(client.rtl, client.isHorizontal),\n            startDate       = client.getDateFromCoordinate(startPos, 'round', false),\n            endDate         = client.getDateFromCoordinate(endPos, 'round', false);\n        if (me.client.isVertical) {\n            if (context.edge === 'top') {\n                DomHelper.setTranslateY(rangeBodyEl, context.newY);\n            }\n            rangeBodyEl.style.height = context.newHeight + 'px';\n        }\n        else {\n            if (context.edge === 'left') {\n                DomHelper.setTranslateX(rangeBodyEl, context.newX);\n            }\n            rangeBodyEl.style.width = context.newWidth + 'px';\n        }\n        me.updateDateIndicator({ startDate, endDate });\n    }\n    onResize({ context }) {\n        if (!context.valid) {\n            return this.onInvalidDrop({ context });\n        }\n        const\n            me          = this,\n            { client }  = me,\n            { rtl }     = client,\n            record      = context.record,\n            box         = Rectangle.from(context.element),\n            startPos    = box.getStart(rtl, client.isHorizontal),\n            endPos      = box.getEnd(rtl, client.isHorizontal),\n            newStart    = client.getDateFromCoordinate(startPos, 'round', false),\n            isStart     = (rtl && context.edge === 'right') || (!rtl && context.edge === 'left') || context.edge === 'top',\n            newEnd      = client.getDateFromCoordinate(endPos, 'round', false),\n            wasModified = (isStart && record.startDate - newStart !== 0) ||\n                (newEnd && record.endDate - newEnd !== 0);\n        if (wasModified && newEnd > newStart) {\n            if (isStart) {\n                // could be that the drag operation placed the range with start/end outside the axis\n                record.setStartDate(newStart, false);\n            }\n            else {\n                record.setEndDate(newEnd, false);\n            }\n        }\n        else {\n            me.onInvalidResize({ context });\n        }\n        me.destroyTip();\n    }\n    onInvalidResize({ context }) {\n        const me = this;\n        me.resize.reset();\n        // Allow DomSync to reapply original state\n        context.rangeBodyEl.parentElement.lastDomConfig = context.rangeBodyEl.lastDomConfig = context.element.lastDomConfig = null;\n        me.renderRanges();\n        me.destroyTip();\n    }\n    //endregion\n}\nTimeRanges._$name = 'TimeRanges'; GridFeatureManager.registerFeature(TimeRanges, false, ['TimelineBase']);\n", "import Base from '../../../Core/Base.js';\nimport ArrayHelper from '../../../Core/helper/ArrayHelper.js';\n/**\n * @module Scheduler/view/mixin/DelayedRecordsRendering\n */\n/**\n * Mixin that implements scheduling/unscheduling a delayed row refresh.\n * @mixin\n * @internal\n */\nexport default Target => class DelayedRecordsRendering extends (Target || Base) {\n    static $name = 'DelayedRecordsRendering';\n    static configurable = {\n        scheduledRecordsRefreshTimeout : 10\n    };\n    static get properties() {\n        return {\n            recordsToRefresh : new Set()\n        };\n    }\n    beforeRenderRow({ record }) {\n        // unscheduler records refresh when corresponding rows are rendered\n        if (this.recordIsReadyForRendering?.(record)) {\n            this.unscheduleRecordRefresh(record);\n        }\n        return super.beforeRenderRow(...arguments);\n    }\n    cleanupScheduledRecord() {\n        const { rowManager, store } = this;\n        for (const record of [...this.recordsToRefresh]) {\n            // Remove the record from to-refresh list if:\n            // - it's not in the view store\n            // - or it's not visible\n            if (!record.stores.includes(store) || !rowManager.getRowById(record)) {\n                this.recordsToRefresh.delete(record);\n            }\n        }\n    }\n    renderScheduledRecords() {\n        const me = this;\n        if (!me.refreshSuspended) {\n            // remove invisible records from the set of scheduled\n            me.cleanupScheduledRecord();\n            const\n                { rowManager } = me,\n                records        = [...me.recordsToRefresh],\n                rows           = records.map(record => rowManager.getRowById(record));\n            if (rows.length) {\n                rowManager.renderRows(rows);\n                /**\n                 * This event fires when records which rendering\n                 * was previously scheduled is finally done.\n                 * @event scheduledRecordsRender\n                 * @param {Grid.view.Grid} source The component.\n                 * @param {Core.data.Model[]} records Rendered records.\n                 * @param {Grid.row.Row[]} rows Rendered rows.\n                 */\n                me.trigger('scheduledRecordsRender', { records, rows });\n            }\n            if (me.recordsToRefresh.size) {\n                me.scheduleRecordRefresh();\n            }\n        }\n        // reschedule this call if view refresh is suspended\n        else {\n            me.scheduleRecordRefresh();\n        }\n    }\n    /**\n     * Cancels scheduled rows refresh.\n     * @param {Core.data.Model|Core.data.Model[]|Boolean} [clearRecords=true] `true` to also clear the list of records\n     * scheduled for refreshing. `false` will result only canceling the scheduled call and keeping intact\n     * the list of records planned for refreshing.\n     */\n    unscheduleRecordRefresh(clearRecords = true) {\n        const me = this;\n        if (clearRecords === true) {\n            me.recordsToRefresh.clear();\n        }\n        else if (clearRecords) {\n            ArrayHelper.asArray(clearRecords).forEach(record => me.recordsToRefresh.delete(record));\n        }\n        if (me.scheduledRecordsRefreshTimer && !me.recordsToRefresh.size) {\n            me.clearTimeout(me.scheduledRecordsRefreshTimer);\n        }\n    }\n    /**\n     * Schedules the provided record row refresh.\n     * @param {Core.data.Model} records Record to refresh the row of.\n     */\n    scheduleRecordRefresh(records) {\n        const me = this;\n        if (records) {\n            ArrayHelper.asArray(records).forEach(record => me.recordsToRefresh.add(record));\n        }\n        me.scheduledRecordsRefreshTimer = me.setTimeout({\n            fn                : 'renderScheduledRecords',\n            delay             : me.scheduledRecordsRefreshTimeout,\n            cancelOutstanding : true\n        });\n    }\n    get widgetClass() {}\n};\n", "import Base from '../../Core/Base.js';\nexport default class TimelineHistogramRendering extends Base {\n    static configurable = {\n        scrollBuffer : 0\n    };\n    construct(client) {\n        super.construct();\n        this.client = client;\n    }\n    init() {}\n    onTimeAxisViewModelUpdate() {\n        const { scrollable } = this.client.timeAxisSubGrid;\n        // scrollLeft is the DOM's concept which is -ve in RTL mode.\n        // scrollX i always the +ve scroll offset from the origin.\n        // Both may be needed for different calculations.\n        this.updateFromHorizontalScroll(scrollable.x);\n    }\n    // Update header range on horizontal scroll\n    updateFromHorizontalScroll(scrollX) {\n        const\n            me            = this,\n            {\n                client,\n                // scrollBuffer is an export only thing\n                scrollBuffer\n            } = me,\n            {\n                timeAxisSubGrid,\n                timeAxis,\n                rtl\n            }             = client,\n            { width }     = timeAxisSubGrid,\n            { totalSize } = client.timeAxisViewModel,\n            start         = scrollX,\n            // If there are few pixels left from the right most position then just render all remaining ticks,\n            // there wouldn't be many. It makes end date reachable with more page zoom levels while not having any poor\n            // implications.\n            // 5px to make TimeViewRangePageZoom test stable in puppeteer.\n            returnEnd     = timeAxisSubGrid.scrollable.maxX !== 0 && Math.abs(timeAxisSubGrid.scrollable.maxX) <= Math.round(start) + 5,\n            startDate     = client.getDateFromCoord({ coord : Math.max(0, start - scrollBuffer), ignoreRTL : true }),\n            endDate       = returnEnd ? timeAxis.endDate : (client.getDateFromCoord({ coord : start + width + scrollBuffer, ignoreRTL : true }) || timeAxis.endDate);\n        if (startDate && !client._viewPresetChanging) {\n            me._visibleDateRange = { startDate, endDate, startMS : startDate.getTime(), endMS : endDate.getTime() };\n            me.viewportCoords  = rtl\n                // RTL starts all the way to the right (and goes in opposite direction)\n                ? { left : totalSize - scrollX - width + scrollBuffer, right : totalSize - scrollX - scrollBuffer }\n                // LTR all the way to the left\n                : { left : scrollX - scrollBuffer, right : scrollX + width + scrollBuffer };\n            // Update timeaxis header making it display the new dates\n            const range = client.timeView.range = { startDate, endDate };\n            client.internalOnVisibleDateRangeChange(range);\n            // If refresh is suspended, someone else is responsible for updating the UI later\n            if (!client.refreshSuspended && client.rowManager.rows.length) {\n                // Gets here too early in Safari for ResourceHistogram. ResizeObserver triggers a scroll before rows are\n                // rendered first time. Could not track down why, bailing out\n                if (client.rowManager.rows[0].id === null) {\n                    return;\n                }\n                // re-render all rows is timeAxis range has been updated\n                if (me._timeAxisStartDate - timeAxis.startDate || me._timeAxisEndDate - timeAxis.endDate) {\n                    me._timeAxisStartDate = timeAxis.startDate;\n                    me._timeAxisEndDate = timeAxis.endDate;\n                    client.rowManager.renderRows(client.rowManager.rows);\n                }\n            }\n        }\n    }\n    onViewportResize() {}\n    refreshRows() {}\n    get visibleDateRange() {\n        return this._visibleDateRange;\n    }\n    translateToPageCoordinate(x) {\n        const\n            { client } = this,\n            { scrollable } = client.timeAxisSubGrid;\n        let result = x + client.timeAxisSubGridElement.getBoundingClientRect().left;\n        if (client.rtl) {\n            result -= scrollable.maxX - Math.abs(client.scrollLeft);\n        }\n        else {\n            result -= client.scrollLeft;\n        }\n        return result;\n    }\n    translateToScheduleCoordinate(x) {\n        const\n            { client } = this,\n            { scrollable } = client.timeAxisSubGrid;\n        let result = x - client.timeAxisSubGridElement.getBoundingClientRect().left - globalThis.scrollX;\n        // Because we use getBoundingClientRect's left, we have to adjust for page scroll.\n        if (client.rtl) {\n            result += scrollable.maxX - Math.abs(client.scrollLeft);\n        }\n        else {\n            result += client.scrollLeft;\n        }\n        return result;\n    }\n    getDateFromXY(xy, roundingMethod, local, allowOutOfRange = false) {\n        const { client } = this;\n        let coord = xy[0];\n        if (!local) {\n            coord = this.translateToScheduleCoordinate(coord);\n        }\n        coord = client.getRtlX(coord);\n        return client.timeAxisViewModel.getDateFromPosition(coord, roundingMethod, allowOutOfRange);\n    }\n}\nTimelineHistogramRendering._$name = 'TimelineHistogramRendering';", "import Objects from '../../Core/helper/util/Objects.js';\nimport Histogram from '../../Core/widget/graph/Histogram.js';\nimport Tooltip from '../../Core/widget/Tooltip.js';\nimport '../../Grid/column/TreeColumn.js';\nimport '../../Grid/feature/Tree.js';\nimport '../column/TimeAxisColumn.js';\nimport '../feature/ColumnLines.js';\nimport DelayedRecordsRendering from './mixin/DelayedRecordsRendering.js';\nimport TimelineBase from './TimelineBase.js';\nimport TimelineHistogramRendering from './TimelineHistogramRendering.js';\n/**\n * @module Scheduler/view/TimelineHistogramBase\n */\nconst\n    histogramWidgetCleanState = {\n        series   : null,\n        topValue : null\n    },\n    emptyFn = () => {};\n/**\n * Histogram renderer parameters.\n *\n * @typedef {Object} HistogramRenderData\n * @property {Object} histogramData Histogram data\n * @property {HistogramConfig} histogramConfig Configuration object for the histogram widget\n * @property {HTMLElement|null} cellElement Cell element, for adding CSS classes, styling etc.\n *        Can be `null` in case of export\n * @property {Core.data.Model} record Record for the row\n * @property {Grid.column.Column} column This column\n * @property {Grid.view.Grid} grid This grid\n * @property {Grid.row.Row} row Row object. Can be null in case of export. Use the\n * {@link Grid.row.Row#function-assignCls row's API} to manipulate CSS class names.\n */\n/**\n * Base class for {@link Scheduler/view/TimelineHistogram} class.\n *\n * @extends Scheduler/view/TimelineBase\n * @abstract\n */\nexport default class TimelineHistogramBase extends TimelineBase.mixin(DelayedRecordsRendering) {\n    //region Config\n    static $name = 'TimelineHistogramBase';\n    static type = 'timelinehistogrambase';\n    static configurable = {\n        timeAxisColumnCellCls : 'b-sch-timeaxis-cell b-timelinehistogram-cell',\n        mode : 'horizontal',\n        rowHeight : 50,\n        /**\n         * Set to `true` if you want to display a tooltip when hovering an allocation bar. You can also pass a\n         * {@link Core/widget/Tooltip#configs} config object.\n         * Please use {@link #config-barTooltipTemplate} function to customize the tooltip contents.\n         * @prp {Boolean|TooltipConfig}\n         */\n        showBarTip : false,\n        barTooltip : null,\n        barTooltipClass : Tooltip,\n        /**\n         * Object enumerating data series for the histogram.\n         * The object keys are treated as the series identifiers and values are objects that\n         * must contain two properties:\n         *  - `type` A String, either `'bar'` or `'outline'`\n         *  - `field` A String, the name of the property to use from the data objects in the {@link #config-data} option.\n         *\n         * ```javascript\n         * histogram = new TimelineHistogram({\n         *     ...\n         *     series : {\n         *         s1 : {\n         *             type  : 'bar',\n         *             field : 's1'\n         *         },\n         *         s2 : {\n         *             type  : 'outline',\n         *             field : 's2'\n         *         }\n         *     },\n         *     store : new Store({\n         *         data : [\n         *             {\n         *                 id            : 'r1',\n         *                 name          : 'Record 1',\n         *                 histogramData : [\n         *                     { s1 : 200, s2 : 100 },\n         *                     { s1 : 150, s2 : 50 },\n         *                     { s1 : 175, s2 : 50 },\n         *                     { s1 : 175, s2 : 75 }\n         *                 ]\n         *             },\n         *             {\n         *                 id            : 'r2',\n         *                 name          : 'Record 2',\n         *                 histogramData : [\n         *                     { s1 : 100, s2 : 100 },\n         *                     { s1 : 150, s2 : 125 },\n         *                     { s1 : 175, s2 : 150 },\n         *                     { s1 : 175, s2 : 75 }\n         *                 ]\n         *             }\n         *         ]\n         *     })\n         * });\n         * ```\n         *\n         * @config {Object<String, HistogramSeries>}\n         */\n        series : null,\n        /**\n         * Record field from which the histogram data will be collected.\n         *\n         * ```javascript\n         * histogram = new TimelineHistogram({\n         *     ...\n         *     series : {\n         *         s1 : {\n         *             type : 'bar'\n         *         }\n         *     },\n         *     dataModelField : 'foo',\n         *     store : new Store({\n         *         data : [\n         *             {\n         *                 id   : 'r1',\n         *                 name : 'Record 1',\n         *                 foo  : [\n         *                     { s1 : 200 },\n         *                     { s1 : 150 },\n         *                     { s1 : 175 },\n         *                     { s1 : 175 }\n         *                 ]\n         *             },\n         *             {\n         *                 id   : 'r2',\n         *                 name : 'Record 2',\n         *                 foo  : [\n         *                     { s1 : 100 },\n         *                     { s1 : 150 },\n         *                     { s1 : 175 },\n         *                     { s1 : 175 }\n         *                 ]\n         *             }\n         *         ]\n         *     })\n         * });\n         * ```\n         *\n         * Alternatively {@link #config-getRecordData} function can be used to build a\n         * record's histogram data dynamically.\n         * @config {String}\n         * @default\n         */\n        dataModelField : 'histogramData',\n        /**\n         * A function, or name of a function which builds histogram data for the provided record.\n         *\n         * See also {@link #config-dataModelField} allowing to load histogram data from a record field.\n         *\n         * @config {Function|String} getRecordData\n         * @param {Core.data.Model} getRecordData.record Record to get histogram data for.\n         * @param {Object} [aggregationContext] Context object passed in case the data is being retrieved\n         * as a part of some parent record data collecting.\n         * @returns {Object} Histogram data.\n         */\n        getRecordData : null,\n        /**\n         * When set to `true` (default) the component reacts on time axis changes\n         * (zooming or changing the displayed time span), clears the histogram data cache of the records\n         * and then refreshes the view.\n         * @config {Boolean}\n         * @default\n         */\n        hardRefreshOnTimeAxisReconfigure : true,\n        /**\n         * A Function which returns a CSS class name to add to a rectangle element.\n         * The following parameters are passed:\n         * @param {HistogramSeries} series The series being rendered\n         * @param {DomConfig} rectConfig The rectangle configuration object\n         * @param {Object} datum The datum being rendered\n         * @param {Number} index The index of the datum being rendered\n         * @param {HistogramRenderData} renderData Current render data giving access to the record, row and cell\n         * being rendered.\n         * @returns {String} CSS classes of the rectangle element\n         * @config {Function}\n         */\n        getRectClass : null,\n        /**\n         * A Function which returns a CSS class name to add to a path element\n         * built for an `outline` type series.\n         * The following parameters are passed:\n         * @param {HistogramSeries} series The series being rendered\n         * @param {Object[]} data The series data\n         * @param {HistogramRenderData} renderData Current render data giving access to the record, row and cell\n         * being rendered.\n         * @returns {String} CSS class name of the path element\n         * @config {Function}\n         */\n        getOutlineClass(series) {\n            return '';\n        },\n        readOnly : true,\n        /**\n         * A Function which returns the tooltip text to display when hovering a bar.\n         * The following parameters are passed:\n         * @param {HistogramSeries} series The series being rendered\n         * @param {DomConfig} rectConfig The rectangle configuration object\n         * @param {Object} datum The datum being rendered\n         * @param {Number} index The index of the datum being rendered\n         * @deprecated Since 5.0.0. Please use {@link #config-barTooltipTemplate}\n         * @config {Function}\n         */\n        getBarTip : null,\n        /**\n         * A Function which returns the tooltip text to display when hovering a bar.\n         * The following parameters are passed:\n         * @param {Object} context The tooltip context info\n         * @param {Object} context.datum The histogram bar being hovered info\n         * @param {Core.widget.Tooltip} context.tip The tooltip instance\n         * @param {HTMLElement} context.element The Element for which the Tooltip is monitoring mouse movement\n         * @param {HTMLElement} context.activeTarget The target element that triggered the show\n         * @param {Event} context.event The raw DOM event\n         * @param {Core.data.Model} data.record The record which value\n         * the hovered bar displays.\n         * @returns {String} Tooltip HTML content\n         * @config {Function}\n         */\n        barTooltipTemplate : null,\n        /**\n         * A Function which returns the text to render inside a bar.\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     series : {\n         *         foo : {\n         *             type  : 'bar',\n         *             field : 'foo'\n         *         }\n         *     },\n         *     getBarText(datum) {\n         *         // display the value in the bar\n         *         return datum.foo;\n         *     },\n         *     ...\n         * })\n         * ```\n         *\n         * **Please note** that the function will be injected into the underlying\n         * {@link Core/widget/graph/Histogram} component that is used under the hood\n         * to render actual charts.\n         * So `this` will refer to the {@link Core/widget/graph/Histogram} instance, not\n         * this class instance.\n         * To access the view please use `this.owner` in the function:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     getBarText(datum) {\n         *         // \"this\" in the method refers core Histogram instance\n         *         // get the view instance\n         *         const timelineHistogram = this.owner;\n         *\n         *         .....\n         *     },\n         *     ...\n         * })\n         * ```\n         * The following parameters are passed:\n         * @param {Object} datum The datum being rendered\n         * @param {Number} index The index of the datum being rendered\n         * @param {HistogramSeries} series The series (provided if histogram widget\n         * {@link Core/widget/graph/Histogram#config-singleTextForAllBars} is `false`)\n         * @param {HistogramRenderData} renderData Current render data giving access to the record, row and cell\n         * being rendered.\n         * @returns {String} Text to render inside the bar\n         * @config {Function}\n         */\n        getBarText : null,\n        getRectConfig : null,\n        getBarTextRenderData : undefined,\n        /**\n         * The class used for building the {@link #property-histogramWidget histogram widget}\n         * @config {Core.widget.graph.Histogram}\n         * @default\n         */\n        histogramWidgetClass : Histogram,\n        /**\n         * The underlying {@link Core/widget/graph/Histogram} component that is used under the hood\n         * to render actual charts.\n         * @member {Core.widget.graph.Histogram} histogramWidget\n         */\n        /**\n         * An instance or a configuration object of the underlying {@link Core/widget/graph/Histogram}\n         * component that is used under the hood to render actual charts.\n         * In case a configuration object is provided the built class is defined with\n         * {@link #config-histogramWidgetClass} config.\n         * @config {Core.widget.graph.Histogram|HistogramConfig}\n         */\n        histogramWidget : {\n            cls                : 'b-hide-offscreen b-timelinehistogram-histogram',\n            omitZeroHeightBars : true,\n            data               : []\n        },\n        fixedRowHeight : true\n    };\n    static get properties() {\n        return {\n            histogramDataByRecord : new Map(),\n            collectingDataFor     : new Map()\n        };\n    }\n    updateGetRecordData(fn) {\n        this._getRecordData = fn ? this.resolveCallback(fn) : null;\n    }\n    updateHardRefreshOnTimeAxisReconfigure(value) {\n        const name = 'hardRefreshOnTimeAxisReconfigure';\n        if (value) {\n            this.timeAxis.ion({\n                name,\n                endReconfigure : 'onTimeAxisEndReconfigure',\n                thisObj        : this\n            });\n        }\n        else {\n            this.detachListeners(name);\n        }\n    }\n    //endregion\n    //region Constructor/Destructor\n    construct(config) {\n        super.construct(config);\n        const me = this;\n        // debounce refreshRows calls\n        me.scheduleRefreshRows = me.createOnFrame(me.refreshRows, [], me, true);\n        me.rowManager.ion({\n            beforeRowHeight : 'onBeforeRowHeight',\n            thisObj         : me\n        });\n    }\n    onDestroy() {\n        this.clearHistogramDataCache();\n        this._histogramWidget?.destroy();\n        this.barTooltip = null;\n    }\n    //endregion\n    //region Internal\n    // Used by shared features to resolve an event or task\n    resolveTimeSpanRecord(element) {}\n    getScheduleMouseEventParams(cellData, event) {\n        const record = this.store.getById(cellData.id);\n        return { record };\n    }\n    get currentOrientation() {\n        if (!this._currentOrientation) {\n            this._currentOrientation = new TimelineHistogramRendering(this);\n        }\n        return this._currentOrientation;\n    }\n    updateSeries(value) {\n        const me = this;\n        me.histogramWidget.series = value;\n        me._series = me.histogramWidget.series;\n        if (me.isPainted && !me.isConfiguring) {\n            me.scheduleRefreshRows();\n        }\n    }\n    getAsyncEventSuffixForStore(store) {\n        // Use xxPreCommit version of events if the store is a part of a project\n        return store.isAbstractPartOfProjectStoreMixin ? 'PreCommit' : '';\n    }\n    /**\n     * Schedules the component rows refresh on the next animation frame. However many time it is\n     * called in one event run, it will only be scheduled to run once.\n     */\n    scheduleRefreshRows() {}\n    getRowHeight() {\n        return this.rowHeight;\n    }\n    onInternalPaint({ firstPaint }) {\n        super.onInternalPaint({ firstPaint });\n        if (firstPaint && this.showBarTip) {\n            this.barTooltip = {};\n        }\n    }\n    updateGetBarTip(value) {\n        // reset barTooltipTemplate if custom getBarTip function is provided\n        if (value) {\n            this.barTooltipTemplate = null;\n        }\n        return value;\n    }\n    changeBarTooltip(tooltip, oldTooltip) {\n        oldTooltip?.destroy();\n        if (tooltip) {\n            return tooltip.isTooltip ? tooltip : this.barTooltipClass.new({\n                forElement  : this.timeAxisSubGridElement,\n                forSelector : '.b-histogram rect',\n                hoverDelay  : 0,\n                trackMouse  : false,\n                cls         : 'b-celltooltip-tip',\n                getHtml     : this.getTipHtml.bind(this)\n            }, this.showBarTip, tooltip);\n        }\n        return null;\n    }\n    async getTipHtml(args) {\n        if (this.showBarTip && this.barTooltipTemplate) {\n            const\n                { activeTarget } = args,\n                index            = parseInt(activeTarget.dataset.index, 10),\n                record           = this.getRecordFromElement(activeTarget),\n                histogramData    = await this.getRecordHistogramData(record);\n            return this.barTooltipTemplate({\n                ...args,\n                datum : this.extractHistogramDataArray(histogramData, record)[index],\n                record,\n                index\n            });\n        }\n    }\n    collectTicksWidth() {\n        const\n            { ticks }     = this.timeAxis,\n            prevDuration  = ticks[0].endDate - ticks[0].startDate,\n            tickDurations = { 0 : prevDuration };\n        let\n            totalDuration = prevDuration,\n            isMonotonous  = true;\n        for (let i = 1, { length } = ticks; i < length; i++) {\n            const\n                tick   = ticks[i],\n                duration = tick.endDate - tick.startDate;\n            // the ticks width is different -> reset isMonotonous flag\n            if (prevDuration !== duration) {\n                isMonotonous = false;\n            }\n            totalDuration    += duration;\n            tickDurations[i] = duration;\n        }\n        // if the ticks widths are not monotonous we need to calculate\n        // each bar width to provide it to the histogram widget later\n        if (!isMonotonous) {\n            const ticksWidth = {};\n            for (let i = 0, { length } = ticks; i < length; i++) {\n                ticksWidth[i] = tickDurations[i] / totalDuration;\n            }\n            this.ticksWidth = ticksWidth;\n        }\n        else {\n            this.ticksWidth = null;\n        }\n    }\n    changeHistogramWidget(widget) {\n        const me = this;\n        if (widget && !widget.isHistogram) {\n            if (me.getBarTextRenderData && !widget.getBarTextRenderData) {\n                widget.getBarTextRenderData = me.getBarTextRenderData;\n            }\n            widget = me.histogramWidgetClass.new({\n                owner           : me,\n                appendTo        : me.element,\n                height          : me.rowHeight,\n                width           : me.timeAxisColumn?.width || 0,\n                getBarTip       : !me.barTooltipTemplate && me.getBarTip || emptyFn,\n                getRectClass    : me.getRectClass || me.getRectClassDefault,\n                getBarText      : me.getBarText || me.getBarTextDefault,\n                getOutlineClass : me.getOutlineClass,\n                getRectConfig   : me.getRectConfig\n            }, widget);\n            widget.suspendRefresh();\n            // bind default getBarText in case it will be called from a custom getBarText()\n            me.getBarTextDefault = me.getBarTextDefault.bind(widget);\n        }\n        return widget;\n    }\n    // Injectable method.\n    getRectClassDefault(series, rectConfig, datum) {}\n    getBarTextDefault(datum, index) {}\n    updateShowBarTip(value) {\n        this.barTooltip = value;\n    }\n    //endregion\n    //region Columns\n    get columns() {\n        return super.columns;\n    }\n    set columns(columns) {\n        const me = this;\n        super.columns = columns;\n        if (!me.isDestroying) {\n            me.timeAxisColumn.renderer = me.histogramRenderer.bind(me);\n            me.timeAxisColumn.cellCls = me.timeAxisColumnCellCls;\n        }\n    }\n    //endregion\n    //region Events\n    onHistogramDataCacheSet({ record, data }) {\n        // schedule record refresh for later\n        this.scheduleRecordRefresh(record);\n    }\n    onTimeAxisEndReconfigure() {\n        if (this.hardRefreshOnTimeAxisReconfigure) {\n            // reset histogram cache\n            this.clearHistogramDataCache();\n            // schedule records refresh (that will re-fetch the histogram data from the server since the cache is empty)\n            this.scheduleRefreshRows();\n        }\n    }\n    onStoreUpdateRecord({ record, changes }) {\n        const me = this;\n        // If we read histogram data from a field and that field got changed\n        // - clear the corresponding record cache\n        if (!me.getRecordData && me.dataModelField && changes[me.dataModelField]) {\n            me.clearHistogramDataCache(record);\n        }\n        return super.onStoreUpdateRecord(...arguments);\n    }\n    onStoreRemove({ records }) {\n        super.onStoreRemove(...arguments);\n        for (const record of records) {\n            this.clearHistogramDataCache(record);\n        }\n    }\n    onBeforeRowHeight({ height }) {\n        if (this._timeAxisColumn) {\n            const widget = this._histogramWidget;\n            if (widget) {\n                widget.height = height;\n                widget.onElementResize(widget.element);\n            }\n        }\n    }\n    onTimeAxisViewModelUpdate() {\n        super.onTimeAxisViewModelUpdate(...arguments);\n        const widget = this._histogramWidget;\n        if (widget) {\n            widget.width = this.timeAxisViewModel.totalSize;\n            widget.onElementResize(widget.element);\n        }\n        this.collectTicksWidth();\n    }\n    //endregion\n    //region Data processing\n    extractHistogramDataArray(histogramData, record) {\n        return histogramData;\n    }\n    processRecordRenderData(renderData) {\n        return renderData;\n    }\n    /**\n     * Clears the histogram data cache for the provided record (if provided).\n     * If the record is not provided clears the cache for all records.\n     * @param {Core.data.Model} [record] Record to clear the cache for.\n     */\n    clearHistogramDataCache(record) {\n        if (record) {\n            this.histogramDataByRecord.delete(record);\n        }\n        else {\n            this.histogramDataByRecord.clear();\n        }\n    }\n    /**\n     * Caches the provided histogram data for the given record.\n     * @param {Core.data.Model} record Record to cache data for.\n     * @param {Object} data Histogram data to cache.\n     */\n    setHistogramDataCache(record, data) {\n        const eventData = { record, data };\n        /**\n         * Fires before the component stores a record's histogram data into the cache.\n         *\n         * A listener can be used to transform the collected data dynamically before\n         * it's cached:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     series : {\n         *         foo : {\n         *             type  : 'bar',\n         *             field : 'f1'\n         *         }\n         *     },\n         *     ...\n         *     listeners : {\n         *         beforeHistogramDataCacheSet(eventData) {\n         *             // completely replace the data for a specific record\n         *             if (eventData.record.id === 123) {\n         *                 eventData.data = [\n         *                     { f1 : 10 },\n         *                     { f1 : 20 },\n         *                     { f1 : 30 },\n         *                     { f1 : 40 },\n         *                     { f1 : 50 },\n         *                     { f1 : 60 }\n         *                 ];\n         *             }\n         *         }\n         *     }\n         * })\n         * ```\n         *\n         * @param {Scheduler.view.TimelineHistogram} source The component instance\n         * @param {Core.data.Model} record Record the histogram data of which is ready.\n         * @param {Object} data The record histogram data.\n         * @event beforeHistogramDataCacheSet\n         */\n        this.trigger('beforeHistogramDataCacheSet', eventData);\n        this.histogramDataByRecord.set(eventData.record, eventData.data);\n        /**\n         * Fires after the component retrieves a record's histogram data and stores\n         * it into the cache.\n         *\n         * Unlike similar {@link #event-beforeHistogramDataCacheSet} event this event is triggered\n         * after the data is put into the cache.\n         *\n         * A listener can be used to transform the collected data dynamically:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     series : {\n         *         bar : {\n         *             type : 'bar',\n         *             field : 'bar'\n         *         },\n         *         halfOfBar : {\n         *             type  : 'outline',\n         *             field : 'half'\n         *         }\n         *     },\n         *     ...\n         *     listeners : {\n         *         histogramDataCacheSet({ data }) {\n         *             // add extra entries to collected data\n         *             data.forEach(entry => {\n         *                 entry.half = entry.bar / 2;\n         *             });\n         *         }\n         *     }\n         * })\n         * ```\n         *\n         * @param {Scheduler.view.TimelineHistogram} source The component instance\n         * @param {Core.data.Model} record Record the histogram data of which is ready.\n         * @param {Object} data The record histogram data.\n         * @event histogramDataCacheSet\n         */\n        this.trigger('histogramDataCacheSet', eventData);\n    }\n    /**\n     * Returns entire histogram data cache if no record provided,\n     * or cached data for the provided record.\n     * @param {Core.data.Model} [record] Record to get the cached data for.\n     * @returns {Object} The provided record cached data or all the records data cache\n     * as a `Map` keyed by records.\n     */\n    getHistogramDataCache(record) {\n        return record ? this.histogramDataByRecord.get(record) : this.histogramDataByRecord;\n    }\n    /**\n     * Returns `true` if there is cached histogram data for the provided record.\n     * @param {Core.data.Model} record Record to check the cache existence for.\n     * @returns {Boolean} `True` if there is a cache for provided record.\n     */\n    hasHistogramDataCache(record) {\n        return this.histogramDataByRecord.has(record);\n    }\n    finalizeDataRetrievingInternal(record, data) {\n        // cleanup collectingDataFor map on data collecting completion\n        this.collectingDataFor.delete(record);\n        // cache record data\n        this.setHistogramDataCache(record, data);\n        // pass data through\n        return data;\n    }\n    finalizeDataRetrieving(record, data) {\n        if (Objects.isPromise(data)) {\n            this.collectingDataFor.set(record, data);\n            return data.then(data => this.finalizeDataRetrievingInternal(record, data));\n        }\n        return this.finalizeDataRetrievingInternal(record, data);\n    }\n    /**\n     * Retrieves the histogram data for the provided record.\n     *\n     * The method first checks if there is cached data for the record and returns it if found.\n     * Otherwise it starts collecting data by calling {@link #config-getRecordData} (if provided)\n     * or by reading it from {@link #config-dataModelField} record field.\n     *\n     * The method can be asynchronous depending on the provided {@link #config-getRecordData} function.\n     * If the function returns a `Promise` then the method will return a wrapping `Promise` in turn that will\n     * resolve with the collected histogram data.\n     *\n     * The method triggers {@link #event-histogramDataCacheSet} event when a record data is ready.\n     *\n     * @param {Core.data.Model} record Record to retrieve the histogram data for.\n     * @returns {Object|Promise} The histogram data for the provided record or a `Promise` that will provide the data\n     * when resolved.\n     */\n    getRecordHistogramData(record) {\n        const\n            me     = this,\n            { getRecordData } = me;\n        let result = me.collectingDataFor.get(record) || me.getHistogramDataCache(record);\n        if (!result && !me.hasHistogramDataCache(record)) {\n            // use \"getRecordData\" function if provided\n            if (getRecordData) {\n                result = getRecordData.handler.call(getRecordData.thisObj, ...arguments);\n            }\n            // or read data from the configured model field\n            else {\n                result = record.get(me.dataModelField);\n            }\n            result = me.finalizeDataRetrieving(record, result);\n        }\n        return result;\n    }\n    recordIsReadyForRendering(record) {\n        return !this.collectingDataFor.has(record);\n    }\n    //endregion\n    //region Render\n    beforeRenderRow(eventData) {\n        const\n            me = this,\n            histogramData = me.getRecordHistogramData(eventData.record);\n        if (!Objects.isPromise(histogramData)) {\n            const data = histogramData ? me.extractHistogramDataArray(histogramData, eventData.record) : [];\n            // bail out if no data\n            if (!data) {\n                return;\n            }\n            // if ticks widths are not monotonous\n            // we provide widths for each bar since in that case the histogram widget\n            // won't be able to calculate them properly\n            if (me.ticksWidth) {\n                for (let i = 0, { length } = data; i < length; i++) {\n                    data[i].width = me.ticksWidth[i];\n                }\n            }\n            const histogramConfig = Objects.merge(\n                // reset topValue by default to enable its auto-detection\n                { topValue : null },\n                me.initialConfig.histogramWidget,\n                {\n                    data,\n                    series : { ...me.series }\n                });\n            eventData = {\n                ...eventData,\n                histogramConfig,\n                histogramData,\n                histogramWidget : me.histogramWidget\n            };\n            /**\n             * Fires before the component renders a row.\n             *\n             * This event is recommended to use instead of generic {@link #event-beforeRenderRow} event since\n             * the component bails out of rendering rows for which histogram data is not ready yet\n             * (happens in case of async data collecting). The generic {@link #event-beforeRenderRow}\n             * is triggered in such cases too while this event is triggered only when the data is ready and the\n             * row is actually about to be rendered.\n             *\n             * Use a listener to adjust histograms rendering dynamically for individual rows:\n             *\n             * ```javascript\n             * new TimelineHistogram({\n             *     ...\n             *     listeners : {\n             *         beforeRenderHistogramRow({ record, histogramConfig }) {\n             *             // display an extra line for some specific record\n             *             if (record.id == 111) {\n             *                 histogramConfig.series.extraLine = {\n             *                     type  : 'outline',\n             *                     field : 'foo'\n             *                 };\n             *             }\n             *         }\n             *     }\n             * })\n             * ```\n             *\n             * @param {Scheduler.view.TimelineHistogram} source The component instance\n             * @param {Core.data.Model} record Record the histogram data of which is ready.\n             * @param {HistogramConfig} histogramConfig Configuration object that will be applied to `histogramWidget`.\n             * @param {Core.widget.graph.Histogram} histogramWidget The underlying widget that is used to render a chart.\n             * @event beforeRenderHistogramRow\n             */\n            me.trigger('beforeRenderHistogramRow', eventData);\n            // We are going to use eventData as stored renderData\n            // so sanitize it from unwanted properties\n            delete eventData.eventName;\n            delete eventData.source;\n            delete eventData.type;\n            delete eventData.oldId;\n            delete eventData.row;\n            delete eventData.recordIndex;\n            me._recordRenderData = me.processRecordRenderData(eventData);\n        }\n        super.beforeRenderRow(...arguments);\n    }\n    applyHistogramWidgetConfig(histogramWidget = this.histogramWidget, histogramConfig) {\n        // reset some parameters (topValue and series) to force recalculations\n        // and apply new configuration after\n        Object.assign(histogramWidget, histogramWidgetCleanState, histogramConfig);\n    }\n    /**\n     * Renders a histogram for a row.\n     * The method applies passed data to the underlying {@link #property-histogramWidget} component.\n     * Then the component renders charts and the method injects them into the corresponding column cell.\n     * @param {HistogramRenderData} renderData Render data\n     * @internal\n     */\n    renderRecordHistogram(renderData) {\n        const\n            me = this,\n            { histogramData, cellElement } = renderData;\n        // reset the cell for rows not having histogram data\n        if (!histogramData) {\n            cellElement.innerHTML = '';\n            return;\n        }\n        /**\n         * Fires before the component renders a histogram in a cell.\n         *\n         * @param {Scheduler.view.TimelineHistogram} source The component instance\n         * @param {Core.data.Model} record Record the histogram data of which is ready.\n         * @param {HistogramConfig} histogramConfig Configuration object that will be applied to `histogramWidget`.\n         * @param {Core.widget.graph.Histogram} histogramWidget The underlying widget that is used to render a chart.\n         * @event beforeRenderRecordHistogram\n         */\n        me.trigger('beforeRenderRecordHistogram', renderData);\n        // sanitize renderData from unwanted properties\n        delete renderData.eventName;\n        delete renderData.type;\n        delete renderData.source;\n        const histogramWidget = renderData.histogramWidget || me.histogramWidget;\n        me.applyHistogramWidgetConfig(histogramWidget, renderData.histogramConfig);\n        histogramWidget.refresh({\n            // tell histogram we want it to pass renderData as an extra argument in nested calls of getBarText and\n            // other configured hooks\n            args : [renderData]\n        });\n        const histogramCloneElement = histogramWidget.element.cloneNode(true);\n        histogramCloneElement.removeAttribute('id');\n        histogramCloneElement.classList.remove('b-hide-offscreen');\n        cellElement.innerHTML = '';\n        cellElement.appendChild(histogramCloneElement);\n    }\n    /**\n     * TimeAxis column renderer used by this view to render row histograms.\n     * It first calls {@link #function-getRecordHistogramData} method to retrieve\n     * the histogram data for the renderer record.\n     * If the record data is ready the method renders the record histogram.\n     * And in case the method returns a `Promise` the renderer just\n     * schedules the record refresh for later and exits.\n     *\n     * @param {HistogramRenderData} renderData Object containing renderer parameters.\n     * @internal\n     */\n    histogramRenderer(renderData) {\n        const\n            me            = this,\n            histogramData = renderData.histogramData || me.getRecordHistogramData(renderData.record);\n        // If the data is ready we just render a histogram\n        // Otherwise we render nothing and the rendering will happen once the data is ready\n        // (which is signalized by histogramDataCacheSet event)\n        if (!Objects.isPromise(histogramData)) {\n            Object.assign(renderData, me._recordRenderData);\n            return me.renderRecordHistogram(...arguments);\n        }\n        return '';\n    }\n    /**\n     * Group feature hook triggered by the feature to render group headers\n     * @param {*} renderData\n     * @internal\n     */\n    buildGroupHeader(renderData) {\n        if (renderData.column === this.timeAxisColumn) {\n            return this.histogramRenderer(renderData);\n        }\n        return this.features.group.buildGroupHeader(renderData);\n    }\n    //endregion\n    get widgetClass() {}\n}\nTimelineHistogramBase.initClass();\nTimelineHistogramBase._$name = 'TimelineHistogramBase';", "import ArrayHelper from '../../../Core/helper/ArrayHelper.js';\nimport Objects from '../../../Core/helper/util/Objects.js';\nimport TimelineHistogramBase from '../TimelineHistogramBase.js';\n/**\n * @module Scheduler/view/mixin/TimelineHistogramGrouping\n */\n/**\n * Mixin for {@link Scheduler/view/TimelineHistogram} that provides record grouping support.\n * The class implements API to work with groups and their members and allows to rollup group members data\n * to their parents.\n *\n * The _groups_ here are either group headers built with the {@link Grid/feature/Group} feature or\n * parent nodes built with the {@link Grid/feature/TreeGroup} feature.\n *\n * ## Parent histogram data aggregating\n *\n * The mixin provides a {@link #config-aggregateHistogramDataForGroups} config which enables automatically rolling up\n * child records histogram data to their parents. By default all registered {@link #config-series}' values are\n * just summed up on parents level, but that can be changed by providing `aggregate`\n * config to {@link #config-series}:\n *\n * ```javascript\n * new TimelineHistogram({\n *     series : {\n *         salary : {\n *            type : 'bar',\n *            // show maximum value on the parent level\n *            aggregate : 'max'\n *         }\n *     },\n *     ...\n * })\n * ```\n *\n * Here is the list of supported `aggregate` values:\n *\n * - `sum` or `add` - sum of values in the group (default)\n * - `min` - minimum value in the group\n * - `max` - maximum value in the group\n * - `count` - number of child records in the group\n * - `avg` - average of the child values in the group\n *\n * There are a few hooks allowing customization of the rolling up process:\n * {@link #config-aggregateDataEntry}, {@link #config-getDataEntryForAggregating} and\n * {@link #config-initAggregatedDataEntry}.\n *\n * @extends Scheduler/view/TimelineHistogramBase\n * @mixin\n */\nexport default Target => class TimelineHistogramGrouping extends (Target || TimelineHistogramBase) {\n    static $name = 'TimelineHistogramGrouping';\n    //region Configs\n    static configurable = {\n        /**\n         * When `true` the component will automatically calculate data for group records\n         * based on the groups members data by calling {@link #function-getGroupRecordHistogramData} method.\n         * @config {Boolean}\n         * @category Parent histogram data collecting\n         * @default\n         */\n        aggregateHistogramDataForGroups : true,\n        /**\n         * A function used for aggregating child records histogram data entries to their parent entry.\n         *\n         * It's called for each child entry and is meant to apply the child entry values to the\n         * target parent entry (provided in `aggregated` parameter).\n         * The function must return the resulting aggregated entry that will be passed as `aggregated`\n         * parameter to the next __aggregating__ step.\n         *\n         * Should be provided as a function, or name of a function in the ownership hierarchy which may be called.\n         *\n         * @config {Function|String} aggregateDataEntry\n         * @param {Object} aggregateDataEntry.aggregated Target parent data entry to aggregate the entry into.\n         * @param {Object} aggregateDataEntry.entry Current entry to aggregate into `aggregated`.\n         * @param {Number} aggregateDataEntry.arrayIndex Index of current array (index of the record among other records being aggregated).\n         * @param {Object[]} aggregateDataEntry.entryIndex Index of `entry` in the current array.\n         * @returns {Object} Return value becomes the value of the `aggregated` parameter on the next invocation of this function.\n         * @category Parent histogram data collecting\n         * @default\n         */\n        aggregateDataEntry : null,\n        /**\n         * Function that extracts a record histogram data entry for aggregating.\n         * By default it returns the entry as is. Override the function if you need a more complex way\n         * to retrieve the value for aggregating.\n         *\n         * Should be provided as a function, or name of a function in the ownership hierarchy which may be called.\n         *\n         * @config {Function|String} getDataEntryForAggregating\n         * @param {Object} getDataEntryForAggregating.entry Current data entry.\n         * @returns {Object} Entry to aggregate\n         * @category Parent histogram data collecting\n         * @default\n         */\n        getDataEntryForAggregating : null,\n        /**\n         * A function that initializes a target group record entry.\n         *\n         * Should be provided as a function, or name of a function in the ownership hierarchy which may be called.\n         *\n         * @config {Function|String} initAggregatedDataEntry\n         * @returns {Object} Target aggregated entry\n         * @category Parent histogram data collecting\n         * @default\n         */\n        initAggregatedDataEntry : null,\n        aggregateFunctions : {\n            sum : {\n                aliases : ['add'],\n                entry(seriesId, acc, entry) {\n                    acc[seriesId] = (acc[seriesId] || 0) + entry[seriesId];\n                    return acc;\n                }\n            },\n            min : {\n                entry(seriesId, acc, entry) {\n                    const entryValue = entry[seriesId];\n                    if (entryValue < (acc[seriesId] || Number.MAX_VALUE)) acc[seriesId] = entryValue;\n                    return acc;\n                }\n            },\n            max : {\n                entry(seriesId, acc, entry) {\n                    const entryValue = entry[seriesId];\n                    if (entryValue > (acc[seriesId] || Number.MIN_VALUE)) acc[seriesId] = entryValue;\n                    return acc;\n                }\n            },\n            count : {\n                init(seriesId, entry, entryIndex, aggregationContext) {\n                    entry[seriesId] = aggregationContext.arrays.length;\n                }\n            },\n            avg : {\n                entry(seriesId, acc, entry) {\n                    acc[seriesId] = (acc[seriesId] || 0) + entry[seriesId];\n                    return acc;\n                },\n                finalize(seriesId, data, recordsData, records, aggregationContext) {\n                    const cnt = aggregationContext.arrays.length;\n                    data.forEach(entry => entry[seriesId] /= cnt);\n                }\n            }\n        }\n    };\n    afterConfigure() {\n        const me = this;\n        me.internalAggregateDataEntry = me.internalAggregateDataEntry.bind(this);\n        me.internalInitAggregatedDataEntry = me.internalInitAggregatedDataEntry.bind(this);\n        super.afterConfigure();\n        if (me.features.treeGroup) {\n            me.features.treeGroup.ion({\n                // reset groups cache on store grouping change\n                beforeDataLoad : me.onTreeGroupBeforeDataLoad,\n                thisObj        : me\n            });\n        }\n    }\n    updateAggregateFunctions(value) {\n        for (const [id, fn] of Object.entries(value)) {\n            fn.id = id;\n            if (fn.aliases) {\n                for (const alias of fn.aliases) {\n                    value[alias] = fn;\n                }\n            }\n        }\n    }\n    updateStore(store) {\n        super.updateStore(...arguments);\n        this.detachListeners('store');\n        if (store) {\n            store.ion({\n                name    : 'store',\n                // reset groups cache on store grouping change\n                // Recalculation of group membership is done through sort\n                group   : this.onStoreGroup,\n                sort    : this.onStoreSort,\n                thisObj : this\n            });\n        }\n    }\n    changeAggregateDataEntry(fn) {\n        return this.bindCallback(fn);\n    }\n    changeGetDataEntryForAggregating(fn) {\n        return this.bindCallback(fn);\n    }\n    changeInitAggregatedDataEntry(fn) {\n        return this.bindCallback(fn);\n    }\n    //endregion\n    //region Event listeners\n    onHistogramDataCacheSet({ record, data }) {\n        // schedule record refresh for later\n        super.onHistogramDataCacheSet(...arguments);\n        if (this.aggregateHistogramDataForGroups) {\n            this.scheduleRecordParentsRefresh(record);\n        }\n    }\n    onTreeGroupBeforeDataLoad() {\n        if (this.aggregateHistogramDataForGroups) {\n            // reset groups cache on store grouping change\n            this.resetGeneratedRecordsHistogramDataCache();\n        }\n    }\n    onStoreGroup() {\n        if (this.aggregateHistogramDataForGroups) {\n            // reset groups cache on store grouping change\n            this.resetGeneratedRecordsHistogramDataCache();\n        }\n    }\n    onStoreSort({ source }) {\n        if (this.aggregateHistogramDataForGroups && source.isGrouped) {\n            // reset groups cache on store grouping change\n            this.resetGeneratedRecordsHistogramDataCache();\n        }\n    }\n    //endregion\n    // Override getRecordHistogramData to support data aggregating for parents\n    getRecordHistogramData(record, aggregationContext) {\n        const me = this;\n        let result;\n        // If that's a group record and records aggregating is enabled\n        // collect the aggregated data based on children\n        if (me.aggregateHistogramDataForGroups && me.isGroupRecord(record)) {\n            result = me.collectingDataFor.get(record) || me.getHistogramDataCache(record);\n            if (!result && !me.hasHistogramDataCache(record)) {\n                result = me.getGroupRecordHistogramData(record, aggregationContext);\n                result = me.finalizeDataRetrieving(record, result);\n            }\n        }\n        else {\n            result = super.getRecordHistogramData(...arguments);\n        }\n        return result;\n    }\n    //region ArrayHelper.aggregate default callbacks\n    internalAggregateDataEntry(acc, ...args) {\n        const { aggregateFunctions } = this;\n        // call series aggregate functions\n        for (const { id, aggregate = 'sum' } of Object.values(this.series)) {\n            let fn;\n            if (aggregate !== false && ((fn = aggregateFunctions[aggregate].entry))) {\n                acc = fn(id, acc, ...args);\n            }\n        }\n        return this.aggregateDataEntry ? this.aggregateDataEntry(acc, ...args) : acc;\n    }\n    internalInitAggregatedDataEntry() {\n        const\n            entry = this.initAggregatedDataEntry ? this.initAggregatedDataEntry(...arguments) : {},\n            { aggregateFunctions } = this;\n        // call series aggregate functions\n        for (const { id, aggregate = 'sum' } of Object.values(this.series)) {\n            const fn = aggregateFunctions[aggregate].init;\n            if (fn && aggregate !== false) {\n                fn(id, entry, ...arguments);\n            }\n        }\n        return entry;\n    }\n    //endregion\n    //region Public methods\n    /**\n     * Resets generated records (parents and links) data cache\n     */\n    resetGeneratedRecordsHistogramDataCache() {\n        const { store } = this;\n        for (const record of this.getHistogramDataCache().keys()) {\n            // clear cache for generated parents and links no longer in the store\n            if (record.isGroupHeader || record.generatedParent || (record.isLinked && !store.includes(record))) {\n                this.clearHistogramDataCache(record);\n            }\n        }\n    }\n    setHistogramDataCache(record, data) {\n        super.setHistogramDataCache(record, data);\n        // If that's a link let's update the original record cache too\n        if (record.isLinked) {\n            super.setHistogramDataCache(record.$original, data);\n        }\n        // if that's a record having links - update their caches too\n        else if (record.$links) {\n            const { store } = this;\n            for (const link of record.$links) {\n                // make sure the link belongs to this view store\n                if (store.includes(link)) {\n                    super.setHistogramDataCache(link, data);\n                }\n            }\n        }\n    }\n    // Override method to support links built by TreeGroup feature\n    // so for the links the method will retrieve original records cache\n    getHistogramDataCache(record) {\n        let result = super.getHistogramDataCache(record);\n        // if that's a link - try getting the original record cache\n        if (!result && record.isLinked) {\n            result = super.getHistogramDataCache(record.$original);\n        }\n        return result;\n    }\n    /**\n     * Aggregates the provided group record children histogram data.\n     * If some of the provided records data is not ready yet the method returns a `Promise`\n     * that's resolved once the data is ready and aggregated.\n     *\n     * ```javascript\n     * // get parent record aggregated histogram data\n     * const aggregatedData = await histogram.getGroupRecordHistogramData(record);\n     * ```\n     *\n     * @param {Core.data.Model} record Group record.\n     * @param {Object} [aggregationContext] Optional aggregation context object.\n     * When provided will be used as a shared object passed through while collecting the data.\n     * So can be used for some custom application purposes.\n     * @returns {Object[]|Promise} Either the provided group record histogram data or a `Promise` that\n     * returns the data when resolved.\n     * @category Parent histogram data collecting\n     */\n    getGroupRecordHistogramData(record, aggregationContext = {}) {\n        aggregationContext.parentRecord = record;\n        const result = this.aggregateRecordsHistogramData(this.getGroupChildren(record), aggregationContext);\n        return Objects.isPromise(result) ? result.then(res => res) : result;\n    }\n    /**\n     * Aggregates multiple records histogram data.\n     * If some of the provided records data is not ready yet the method returns a `Promise`\n     * that's resolved once the data is ready and aggregated.\n     *\n     * @param {Core.data.Model[]} records Records to aggregate data of.\n     * @param {Object} [aggregationContext] Optional aggregation context object.\n     * Can be used by to share some data between the aggregation steps.\n     * @returns {Object[]|Promise} Either the provided group record histogram data or a `Promise` that\n     * returns the data when resolved.\n     * @category Parent histogram data collecting\n     */\n    aggregateRecordsHistogramData(records, aggregationContext = {}) {\n        const\n            me = this,\n            recordsData = [],\n            { parentRecord } = aggregationContext;\n        let hasPromise = false;\n        // collect children data\n        for (const child of records) {\n            const childData = me.getRecordHistogramData(child, aggregationContext);\n            hasPromise = hasPromise || Objects.isPromise(childData);\n            childData && recordsData.push(childData);\n        }\n        // If some of children daa is not ready yet\n        if (hasPromise) {\n            // wait till all children data is ready\n            return Promise.all(recordsData).then(values => {\n                // re-apply parentRecord since it could get overridden in above getRecordHistogramData() calls\n                aggregationContext.parentRecord = parentRecord;\n                // filter out empty values\n                values = values.filter(x => x);\n                return me.aggregateHistogramData(values, records, aggregationContext);\n            });\n        }\n        // aggregate collected data\n        return me.aggregateHistogramData(recordsData, records, aggregationContext);\n    }\n    /**\n     * Indicates if the passed record represents a group header built by {@link Grid/feature/Group} feature\n     * or a group built by {@link Grid/feature/TreeGroup} feature.\n     *\n     * @param {Core.data.Model} record The view record\n     * @returns {Boolean} `true` if the record represents a group.\n     * @internal\n     */\n    isGroupRecord(record) {\n        return record.isGroupHeader || (this.isTreeGrouped && record.generatedParent);\n    }\n    /**\n     * For a record representing a group built by {@link Grid/feature/Group} or {@link Grid/feature/TreeGroup}\n     * feature returns the group members.\n     *\n     * @param {Core.data.Model} record A group record\n     * @returns {Core.data.Model[]} Records belonging to the group\n     * @internal\n     */\n    getGroupChildren(record) {\n        return record.groupChildren || record.children;\n    }\n    /**\n     * For a record belonging to a group built by {@link Grid/feature/Group} or {@link Grid/feature/TreeGroup}\n     * feature returns the group header or parent respectively.\n     *\n     * @param {Core.data.Model} record A member record\n     * @returns {Core.data.Model} The record group header or parent record\n     * @internal\n     */\n    getRecordParent(record) {\n        const { groupParent } = record;\n        return groupParent?.get(this.store.id) || (this.isTreeGrouped && record.parent);\n    }\n    /**\n     * Schedules refresh of the provided record's parents.\n     * The method iterates up from the provided record parent to the root node\n     * and schedules the iterated node rows refresh.\n     * @param {Core.data.Model} record Record to refresh parent rows of.\n     * @param {Boolean} [clearCache=true] `true` to reset the scheduled records histogram data cache.\n     * @internal\n     */\n    scheduleRecordParentsRefresh(record, clearCache = true) {\n        const me = this;\n        let groupParent;\n        while ((groupParent = me.getRecordParent(record))) {\n            // reset group cache\n            clearCache && me.clearHistogramDataCache(groupParent);\n            // and scheduler its later refresh\n            me.scheduleRecordRefresh(groupParent);\n            // bubble up\n            record = groupParent;\n        }\n    }\n    //endregion\n    /**\n     * Aggregates collected child records data to its parent.\n     * The method is synchronous and is called when all the child records data is ready.\n     * Override the method if you need to preprocess or postprocess parent records aggregated data:\n     *\n     * ````javascript\n     * class MyHistogramView extends TimelineHistogram({\n     *\n     *     aggregateHistogramData(recordsData, records, aggregationContext) {\n     *         const result = super.aggregateHistogramData(recordsData, records, aggregationContext);\n     *\n     *         // postprocess averageSalary series values collected for a parent record\n     *         result.forEach(entry => {\n     *             entry.averageSalary = entry.averageSalary / records.length;\n     *         });\n     *\n     *         return result;\n     *     }\n     *\n     * });\n     * ```\n     *\n     * @param {Object[]} recordsData Child records histogram data.\n     * @param {Core.data.Model[]} records Child records.\n     * @param {Object} aggregationContext An object containing current shared info on the current aggregation process\n     */\n    aggregateHistogramData(recordsData, records, aggregationContext = {}) {\n        const\n            me = this,\n            { aggregateFunctions } = me;\n        aggregationContext.recordsData = recordsData;\n        aggregationContext.records     = records;\n        const arrays = recordsData.map((histogramData, index) => {\n            return me.extractHistogramDataArray(\n                histogramData,\n                records[index]\n            );\n        });\n        // summarize children histogram data\n        const result = ArrayHelper.aggregate(\n            arrays,\n            me.getDataEntryForAggregating || (entry => entry),\n            me.internalAggregateDataEntry,\n            me.internalInitAggregatedDataEntry,\n            aggregationContext\n        );\n        // call series aggregate functions\n        for (const { id, aggregate = 'sum' } of Object.values(me.series)) {\n            const fn = aggregateFunctions[aggregate].finalize;\n            if (fn && aggregate !== false) {\n                fn(id, result, ...arguments);\n            }\n        }\n        return result;\n    }\n    get widgetClass() {}\n};\n", "import '../../column/ScaleColumn.js';\nimport ObjectHelper from '../../../Core/helper/ObjectHelper.js';\n/**\n * @module Scheduler/view/mixin/TimelineHistogramScaleColumn\n */\n/**\n * Mixin of {@link Scheduler/view/TimelineHistogram} class that implements\n * {@link Scheduler/column/ScaleColumn} automatic injection and functioning.\n *\n * @mixin\n */\nexport default Target => class TimelineHistogramScaleColumn extends (Target) {\n    static $name = 'TimelineHistogramScaleColumn';\n    //region Config\n    static configurable = {\n        /**\n         * The locked grid scale column reference.\n         * @member {Scheduler.column.ScaleColumn} scaleColumn\n         * @readonly\n         * @category Scale column\n         */\n        /**\n         * An object with configuration for the {@link Scheduler/column/ScaleColumn}.\n         *\n         * Example:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     scaleColumn : {\n         *         width : 50\n         *     },\n         *     ...\n         * });\n         * ```\n         *\n         * Provide `null` to the config to get rid of the column completely:\n         *\n         * ```javascript\n         * new TimelineHistogram({\n         *     // do not add scale column\n         *     scaleColumn : null,\n         *     ...\n         * });\n         * ```\n         *\n         * @config {Object} scaleColumn\n         * @category Scale column\n         */\n        scaleColumn : {},\n        scalePoints : null,\n        scalePointsModelField : 'scalePoints',\n        calculateTopValueByScalePoints : true\n    };\n    updateScalePoints(scalePoints) {\n        const\n            me            = this,\n            topScalePoint = scalePoints[scalePoints.length - 1];\n        if (topScalePoint) {\n            me.scaleUnit = topScalePoint.unit;\n            // Applying new maximum value to the histogram.\n            me.histogramWidget.topValue = me.getTopValueByScalePoints(scalePoints);\n        }\n        // Applying new points to the scale column\n        if (me.scaleColumn) {\n            me.scaleColumn.scalePoints = scalePoints;\n        }\n    }\n    //endregion\n    //region Columns\n    changeColumns(columns, currentStore) {\n        const\n            me = this,\n            scaleColumn = me.getConfig('scaleColumn');\n        // No columns means destroy\n        if (columns && scaleColumn) {\n            const isArray = Array.isArray(columns);\n            let cols = columns;\n            if (!isArray) {\n                cols = columns.data;\n            }\n            let\n                scaleColumnIndex = cols?.length,\n                scaleColumnConfig = scaleColumn;\n            cols.some((col, index) => {\n                if (col.type === 'scale') {\n                    scaleColumnIndex  = index;\n                    scaleColumnConfig = ObjectHelper.assign(col, scaleColumnConfig);\n                    return true;\n                }\n            });\n            // We're going to mutate this array which we do not own, so copy it first.\n            cols = cols.slice();\n            // Fix up the scaleColumn config in place\n            cols[scaleColumnIndex] = {\n                type : 'scale',\n                ...scaleColumnConfig\n            };\n            if (isArray) {\n                columns = cols;\n            }\n            else {\n                columns.data = cols;\n            }\n        }\n        return super.changeColumns(columns, currentStore);\n    }\n    updateColumns(columns, was) {\n        super.updateColumns(columns, was);\n        // Extract the known columns by type. Sorting will have placed them into visual order.\n        if (columns) {\n            this._scaleColumn = this.columns.find(c => c.isScaleColumn);\n        }\n    }\n    onColumnsChanged({ action, changes, record : column, records }) {\n        const { scaleColumn, columns } = this;\n        // If someone replaces the column set (syncing leads to batch), ensure scale is always added\n        if (scaleColumn && (action === 'dataset' || action === 'batch') && !columns.includes(scaleColumn)) {\n            columns.add(scaleColumn, true);\n        }\n        super.onColumnsChanged(...arguments);\n    }\n    //endregion\n    //region Data processing\n    /**\n     * A hook to convert scale point values to histogram ones.\n     * In case they use different units.\n     *\n     * Override this method in a sub-class to implement your custom\n     * application specific conversion.\n     * @param {Number} value Scale point value\n     * @param {String} unit Scale point unit\n     * @internal\n     */\n    convertUnitsToHistogramValue(value, unit) {\n        return value;\n    }\n    /**\n     * A hook to convert histogram values to scale point ones.\n     * In case they use different units.\n     *\n     * Override this method in a sub-class to implement your custom\n     * application specific conversion.\n     * @param {Number} value Scale point value\n     * @param {String} unit Scale point unit\n     * @internal\n     */\n    convertHistogramValueToUnits(value, unit) {\n        return value;\n    }\n    extractHistogramDataArray(histogramData, record) {\n        return histogramData;\n    }\n    getTopValueByScalePoints(scalePoints) {\n        const\n            me              = this,\n            { scaleColumn } = me,\n            lastPoint       = scalePoints[scalePoints.length - 1],\n            { value, unit } = lastPoint;\n        let rawValue = value;\n        if (scaleColumn) {\n            // add padding to top value\n            rawValue *= 1 + (scaleColumn.scaleWidget.scaleMaxPadding || 0);\n        }\n        return me.convertUnitsToHistogramValue(rawValue, unit || me.scaleUnit);\n    }\n    processRecordRenderData(renderData) {\n        renderData = super.processRecordRenderData(...arguments);\n        if (this.scaleColumn) {\n            const\n                me = this,\n                { record, histogramData, histogramConfig = {} } = renderData;\n            let\n                topValue = me.initialConfig.histogramWidget?.topValue,\n                scalePoints = me.scalePoints || record.get(me.scalePointsModelField);\n            if (!topValue) {\n                // if no topValue provided but we have scalePoints\n                if (scalePoints && me.calculateTopValueByScalePoints) {\n                    // calculate topValue based on the max scale point\n                    topValue = me.getTopValueByScalePoints(scalePoints);\n                }\n                // if still no topValue\n                if (!topValue && histogramData) {\n                    const histogramWidget = renderData.histogramWidget || me.histogramWidget;\n                    ObjectHelper.assign(histogramWidget, histogramConfig);\n                    // get top value based on histogramData\n                    topValue = histogramWidget.getDataTopValue(histogramData);\n                    scalePoints = [{\n                        value : me.convertHistogramValueToUnits(topValue, me.scaleUnit),\n                        text  : me.convertHistogramValueToUnits(topValue, me.scaleUnit)\n                    }];\n                    topValue += me.scaleColumn.scaleWidget.scaleMaxPadding * topValue;\n                }\n                renderData.scaleWidgetConfig = { scalePoints };\n                renderData.histogramConfig = { ...histogramConfig, topValue };\n            }\n        }\n        return renderData;\n    }\n    //endregion\n    //region Render\n    /**\n     * Group feature hook triggered by the feature to render group headers\n     * @param {Object} renderData\n     * @internal\n     */\n    buildGroupHeader(renderData) {\n        if (renderData.column === this.scaleColumn) {\n            return this.scaleColumn.renderer(renderData);\n        }\n        return super.buildGroupHeader(...arguments);\n    }\n    beforeRenderCell(renderData) {\n        if (this.scaleColumn && renderData.column === this.scaleColumn) {\n            renderData.histogramData = this.getRecordHistogramData(renderData.record);\n            // If data is read apply prepared render data\n            if (!ObjectHelper.isPromise(renderData.histogramData)) {\n                Object.assign(renderData, this._recordRenderData);\n            }\n        }\n        return super.beforeRenderCell(...arguments);\n    }\n    /**\n     * Renders record scale column content.\n     * @param {Core.data.Model} record Record to render scale for\n     * @param {Object} [renderData]\n     * @category Scale column\n     */\n    renderRecordScale(record, renderData) {\n        if (this.scaleColumn) {\n            const\n                row         = this.getRowFor(record),\n                cellElement = row?.getCell(this.scaleColumn.id);\n            if (cellElement) {\n                row.renderCell(cellElement);\n            }\n        }\n    }\n    get widgetClass() {}\n    //endregion\n};\n", "import '../../Grid/column/TreeColumn.js';\nimport '../../Grid/feature/Tree.js';\nimport '../column/ScaleColumn.js';\nimport '../column/TimeAxisColumn.js';\nimport TimelineHistogramGrouping from './mixin/TimelineHistogramGrouping.js';\nimport '../feature/ColumnLines.js';\nimport '../feature/ScheduleTooltip.js';\nimport TimelineHistogramBase from './TimelineHistogramBase.js';\nimport TimelineHistogramScaleColumn from './mixin/TimelineHistogramScaleColumn.js';\n/**\n * @module Scheduler/view/TimelineHistogram\n */\n/**\n * This view displays histograms for the provided store records.\n *\n * A {@link Scheduler/column/ScaleColumn} is also added automatically.\n *\n * {@inlineexample Scheduler/view/TimelineHistogram.js}\n *\n * To create a standalone histogram, simply configure it with a {@link Core/data/Store} instance:\n *\n * ```javascript\n * const store = new Store({\n *     data : [\n *         {\n *             id            : 'r1',\n *             name          : 'Record 1',\n *             // data used to render a histogram for this record\n *             histogramData : [\n *                 { value1 : 200, value2 : 100 },\n *                 { value1 : 150, value2 : 50 },\n *                 { value1 : 175, value2 : 50 },\n *                 { value1 : 175, value2 : 75 }\n *             ]\n *         },\n *         {\n *             id            : 'r2',\n *             name          : 'Record 2',\n *             // data used to render a histogram for this record\n *             histogramData : [\n *                 { value1 : 100, value2 : 100 },\n *                 { value1 : 150, value2 : 125 },\n *                 { value1 : 175, value2 : 150 },\n *                 { value1 : 175, value2 : 75 }\n *             ]\n *         }\n *     ]\n * });\n *\n * const histogram = new TimelineHistogram({\n *     appendTo  : 'targetDiv',\n *     startDate : new Date(2022, 11, 26),\n *     endDate   : new Date(2022, 11, 30),\n *     store,\n *     // specify series displayed in the histogram\n *     series : {\n *         value1 : {\n *             type  : 'bar',\n *             field : 'value1'\n *         },\n *         value2 : {\n *             type  : 'bar',\n *             field : 'value2'\n *         }\n *     },\n *     columns : [\n *         {\n *             field : 'name',\n *             text  : 'Name'\n *         }\n *     ]\n * });\n * ```\n *\n * ## Providing histogram data\n *\n * There are two basic ways to provide histogram data:\n *\n * - the data can be provided statically in a record field configured as {@link #config-dataModelField}:\n *\n * ```javascript\n * const store = new Store({\n *     data : [\n *         {\n *             id   : 11,\n *             name : 'John Smith',\n *             // data used to render a histogram for this record\n *             hd   : [\n *                 { weight : 200, price : 100 },\n *                 { weight : 150, price : 105 },\n *                 { weight : 175, price : 90 },\n *                 { weight : 175, price : 95 }\n *             ]\n *         }\n *     ]\n * });\n *\n * const histogram = new TimelineHistogram({\n *     dataModelField : 'hd',\n *     series : {\n *         weight : {\n *             type : 'bar'\n *         },\n *         price : {\n *             type : 'outline'\n *         }\n *     },\n *     ...\n * });\n * ```\n * - the data can be collected dynamically with the provided {@link #config-getRecordData} function:\n *\n * ```javascript\n * const histogram = new TimelineHistogram({\n *     dataModelField : 'hd',\n *     series : {\n *         weight : {\n *             type : 'bar'\n *         },\n *         price : {\n *             type : 'outline'\n *         }\n *     },\n *     ...\n *     async getRecordData(record) {\n *         // we get record histogram data from the server\n *         const response = await fetch('https://some.url/to/get/data?' + new URLSearchParams({\n *             // pass the record identifier and the time span we need data for\n *             record    : record.id,\n *             startDate : DateHelper.format(this.startDate),\n *             endDate   : DateHelper.format(this.endDate),\n *         }));\n *         return response.json();\n *     }\n * });\n * ```\n *\n * Please check [\"Timeline histogram\" guide](#Scheduler/guides/timelinehistogram.md) for more details.\n *\n * @features Scheduler/feature/ColumnLines\n * @features Scheduler/feature/GroupSummary\n * @features Scheduler/feature/HeaderZoom\n * @features Scheduler/feature/NonWorkingTime\n * @features Scheduler/feature/Pan\n * @features Scheduler/feature/ResourceMenu\n * @features Scheduler/feature/ResourceTimeRanges\n * @features Scheduler/feature/RowReorder\n * @features Scheduler/feature/ScheduleTooltip\n * @features Scheduler/feature/Split\n * @features Scheduler/feature/Summary\n * @features Scheduler/feature/TimeAxisHeaderMenu\n * @features Scheduler/feature/TimeRanges\n *\n * @extends Scheduler/view/TimelineHistogramBase\n * @mixes Scheduler/view/mixin/TimelineHistogramGrouping\n * @mixes Scheduler/view/mixin/TimelineHistogramScaleColumn\n *\n * @classtype timelinehistogram\n * @widget\n */\nexport default class TimelineHistogram extends TimelineHistogramBase.mixin(\n    TimelineHistogramGrouping,\n    TimelineHistogramScaleColumn\n) {\n    //region Config\n    static $name = 'TimelineHistogram';\n    static type = 'timelinehistogram';\n    /**\n     * Retrieves the histogram data for the provided record.\n     *\n     * The method first checks if there is cached data for the record and returns it if found.\n     * Otherwise it starts collecting data by calling {@link #config-getRecordData} (if provided)\n     * or by reading it from the {@link #config-dataModelField} record field.\n     *\n     * If the provided record represents a group and {@link #config-aggregateHistogramDataForGroups} is enabled\n     * then the group members data is calculated with a {@link #function-getGroupRecordHistogramData} method call.\n     *\n     * The method can be asynchronous depending on the provided {@link #config-getRecordData} function.\n     * If the function returns a `Promise` then the method will return a wrapping `Promise` in turn that will\n     * resolve with the collected histogram data.\n     *\n     * The method triggers the {@link #event-histogramDataCacheSet} event when a record data is ready.\n     *\n     * @param {Core.data.Model} record Record to retrieve the histogram data for.\n     * @param {Object} [aggregationContext] An optional object passed when the method is called when aggregating\n     * a group members histogram data.\n     *\n     * See {@link #function-getGroupRecordHistogramData} and {@link Core/helper/ArrayHelper#function-aggregate-static}\n     * for more details.\n     * @returns {Object|Promise} The histogram data for the provided record or a `Promise` that will provide the data\n     * when resolved.\n     * @function getRecordHistogramData\n     */\n}\nTimelineHistogram.initClass();\nTimelineHistogram._$name = 'TimelineHistogram';"],
  "mappings": "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",
  "names": ["ScaleColumn", "Column", "width", "useProp", "key", "value", "me", "scaleWidget", "Scale", "height", "cellElement", "scaleWidgetConfig", "ObjectHelper", "scaleCloneElement", "__publicField", "ColumnStore", "ResourceTimeRangesBase", "InstancePlugin", "AttachToProjectMixin_default", "timeAxis", "t", "disable", "resource", "events", "renderData", "client", "eventRecord", "iconCls", "record", "rangeElement", "_a", "event", "target", "cell", "domEvent", "eventName", "EventHelper", "StringHelper", "resourceTimeRangeRecord", "enable", "attachMouseEvents", "DependencyEditor", "Popup", "widget", "dependencyEditFeature", "args", "deleteButton", "DependencyEdit", "dialog", "DependencyModel", "type", "config", "autoClose", "cls", "field", "values", "dependencyRecord", "editor", "showPoint", "center", "Rectangle", "result", "labelled", "labelWidth", "labelElement", "element", "_b", "_c", "ref", "dependency", "Duration", "dependencyStore", "GridFeatureManager", "ScheduleContext", "Delayable_default", "triggerEvent", "listeners", "DomHelper", "context", "timeAxisViewModel", "oldContext", "renderer", "isVertical", "style", "row", "tickStartDate", "tickEndDate", "resourceRecord", "top", "c1", "c2", "actions", "EventCopyPaste", "CopyPasteBase", "scheduler", "eventStore", "eventData", "assignmentRecord", "actionName", "records", "isCut", "assignmentRecords", "r", "eventRecords", "source", "rows", "DateHelper", "assignment", "date", "entityName", "_cellClickedContext", "_eventClickedContext", "assignmentStore", "clipboardData", "toFocus", "pastedEvents", "pastedEventRecords", "targetResourceRecord", "targetDate", "newAssignmentRecord", "detacher", "reason", "items", "assignments", "originalName", "counter", "EventDrag", "DragBase", "dragData", "copyMode", "mode", "el", "eventElement", "fromScheduler", "fromResourceStore", "toScheduler", "isCrossScheduler", "toResourceStore", "fromResource", "toResource", "indexDiff", "resourcesInStore", "originalResourceRecord", "newResource", "draggedEventResourceIndex", "newIndex", "eventType", "start", "valid", "i", "browserEvent", "sourceRecord", "copyKeyPressed", "draggedEntities", "timeDiff", "initialAssignmentsState", "originalStartDate", "droppedStartDate", "copy", "fromAssignmentStore", "fromEventStore", "toAssignmentStore", "toEventStore", "unifiedDrag", "useSingleAssignment", "effectiveCopyMode", "event1Date", "eventsToAdd", "eventsToRemove", "assignmentsToAdd", "assignmentsToRemove", "eventsToCheck", "eventsToBatch", "updated", "updatedEvent", "draggedEvent", "eventBar", "eventBarEls", "addedEvents", "copiedAssignmentsMap", "originalAssignment", "draggedAssignment", "initialState", "originalEventRecord", "newStartDate", "keepEvent", "newAssignment", "child", "reassignedFrom", "isCrossResource", "shouldCopyEvent", "a", "ev", "syncIdMap", "originalId", "cloneRecord", "added", "originalDraggedEvent", "inTimeAxis", "DomSync", "elRect", "previousResolvedResource", "previousTargetEventRecord", "targetEventRecord", "externalDropTarget", "isOverNewResource", "info", "dateConstraints", "constrainRectangle", "eventRegion", "eventBarEl", "externalDateConstraints", "minDate", "maxDate", "dateRange", "selectedRecord", "coord", "x", "y", "isHorizontal", "dragProxy", "pageRect", "localRect", "lx", "ly", "eventTarget", "startDate", "index", "EventDragCreate", "DragCreateBase", "lock", "drag", "isWorkingTime", "enableEventAnimations", "enableTransactionalFeatures", "resourceRecords", "dimension", "weekStartDay", "mousedownDate", "draggingEnd", "eventConfig", "meta", "transferred", "html", "zeroOffset", "depOffset", "EventTooltip", "TooltipBase", "data", "firstPaint", "dependencies", "tooltip", "offset", "edgeAligned", "parseAlign", "depTerminalOffset", "zeroMargins", "StickyEvents", "subGrid", "contentEl", "resourceMap", "eventsData", "elementConfig", "eventContent", "duringGeneration", "useEventBuffer", "bufferAfterWidth", "bufferBeforeWidth", "scrollPosition", "wrapperEl", "contentSize", "end", "contentWidth", "justify", "c", "eventStart", "eventEnd", "edgeSizes", "maxOffset", "TimeRanges", "AbstractTimeRanges", "store", "endDate", "timeSpan", "project", "currentTimeLine", "show", "checked", "renderRanges", "id", "action", "rangeBodyEl", "box", "newStart", "startPos", "endPos", "rtl", "isStart", "newEnd", "TimeSpan", "DelayedRecordsRendering_default", "Target", "Base", "rowManager", "clearRecords", "ArrayHelper", "TimelineHistogramRendering", "scrollable", "scrollX", "scrollBuffer", "timeAxisSubGrid", "totalSize", "returnEnd", "range", "xy", "roundingMethod", "local", "allowOutOfRange", "histogramWidgetCleanState", "emptyFn", "TimelineHistogramBase", "TimelineBase", "fn", "name", "cellData", "oldTooltip", "activeTarget", "histogramData", "ticks", "prevDuration", "tickDurations", "totalDuration", "isMonotonous", "length", "tick", "duration", "ticksWidth", "series", "rectConfig", "datum", "columns", "changes", "Objects", "getRecordData", "histogramConfig", "histogramWidget", "histogramCloneElement", "Tooltip", "Histogram", "TimelineHistogramGrouping_default", "alias", "aggregationContext", "acc", "aggregateFunctions", "aggregate", "entry", "link", "res", "recordsData", "parentRecord", "hasPromise", "childData", "groupParent", "clearCache", "arrays", "seriesId", "entryValue", "entryIndex", "cnt", "TimelineHistogramScaleColumn_default", "scalePoints", "topScalePoint", "currentStore", "scaleColumn", "isArray", "cols", "scaleColumnIndex", "scaleColumnConfig", "col", "was", "column", "unit", "lastPoint", "rawValue", "topValue", "TimelineHistogram"]
}
